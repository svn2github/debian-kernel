#!/usr/bin/make -f

# debian/rules for kernel-patch-powerpc

# written by Jens Schmalzing <jensen@debian.org>

# debhelper compatibility version
export DH_COMPAT=4

# Set to Yes if we are going to generate the metapackages.
OFFICIAL_VERSION = No

# set the build architecture if necessary
DEB_HOST_ARCH ?= $(shell dpkg --print-architecture)

# the flavours we're building for
flavours := $(shell grep -v ^\# debian/flavours)

# cut the upstream version and the Debian revision from the changelog
kernel	:= $(shell head -1 debian/changelog | sed 's/^.*(\(.*\)-.*).*$$/\1/')
debian	:= $(shell head -1 debian/changelog | sed 's/^.*(.*-\(.*\)).*$$/\1/')
version	:= $(shell head -1 debian/changelog | sed 's/^.*(\(.*\)).*$$/\1/')

# some files in debian/ get version numbers and stuff updated on the fly
M4 = m4 -DM4VERSION="$(version)" -DM4KERNEL="$(kernel)" -DM4FLAVOUR="$(flavour)"
debian/%: debian/%.m4
	$(M4) $< > $@

# installation of files and programs
INSTALL_DATA	= install -m 644 -o root -g root
INSTALL_EXEC	= install -m 755 -o root -g root

# build locations - point TMP to a tmpfs for best performance
TMP ?= $(CURDIR)/tmp
KSOURCE	 = $(TMP)/kernel-source-$(kernel)
KFLAVOUR = $(TMP)/kernel-source-$(kernel)-$(flavour)
KDUMMY   = $(TMP)/kernel-image-$(kernel)-$(flavour)_$(version)_powerpc.deb
KHEADERS = $(TMP)/kernel-headers-$(kernel)-powerpc_$(version)_powerpc.deb

# install locations
KBUILD    = $(CURDIR)/debian/kernel-build-$(kernel)-$(flavour)
KBUILDDOC = $(KBUILD)/usr/share/doc/kernel-build-$(kernel)-$(flavour)
KSRC      = $(KBUILD)/usr/src/kernel-build-$(kernel)-$(flavour)
KIMAGE    = $(CURDIR)/debian/kernel-image-$(kernel)-$(flavour)
KIMAGEDOC = $(KIMAGE)/usr/share/doc/kernel-image-$(kernel)-$(flavour)
KLIB      = $(KIMAGE)/usr/lib/kernel-image-$(kernel)-$(flavour)

# environment for make-kpkg
export APPEND_TO_VERSION=-$(flavour)
#export PARALLEL_BUILD=-j2
export CONCURRENCY_LEVEL=8
export INITRD=Yes
export INITRD_OK=WeKnowWhatWeAreDoing
export KPKG_SUBARCH=pmac

# the configure target is responsible for setting up the build arena,
# i.e. unpacking the Debian kernel source and preparing a separate
# build tree for each flavour.

configure: stamp-configure

# the following is the first of a number of loop implementations using
# recursive make.  This provides much easier access to the loop
# variable than extracting it from the target.  In order to safeguard
# against infinite loops, the recursion level is checked for the
# critical targets.  This particular example calls a common target,
# then runs the loop, and also includes some common commands to
# process after the loop.

stamp-configure: \
stamp-configure-prepare \
$(foreach flavour,$(flavours),stamp-configure-flavour-$(flavour))

	cd $(KSOURCE); APPEND_TO_VERSION='' make-kpkg configure

	touch $@

# unpack the Debian kernel source, add a default .config file and the
# necessary Debian files (changelog, control, copyright, post-install,
# and official)
stamp-configure-prepare:

	test -d $(dir $(KSOURCE)) || mkdir -p $(dir $(KSOURCE))
	tar jxCf $(dir $(KSOURCE)) /usr/src/kernel-source-$(kernel).tar.bz2
	#cd $(KSOURCE); /usr/src/kernel-patches/all/$(kernel)/apply/debian
	#for file in $(shell debian/list patches); do patch -d $(KSOURCE) -p1 < patches/$$file; done

	-$(MAKE) -s -C config default > $(KSOURCE)/.config

	test -d $(KSOURCE)/debian || mkdir $(KSOURCE)/debian
	cd debian; cp -p changelog control copyright post-install $(KSOURCE)/debian
	> $(KSOURCE)/debian/official

	touch $@

ifeq (0,$(MAKELEVEL))

stamp-configure-flavour-%:
	$(MAKE) -f debian/rules stamp-configure-flavour-$* flavour=$*

else
ifeq (1,$(MAKELEVEL))

# create a separate build tree for a given flavour, add the flavour's
# .config and control files
stamp-configure-flavour-$(flavour): \
stamp-configure-prepare

	test -d $(dir $(KFLAVOUR)) || mkdir -p $(dir $(KFLAVOUR))

	cp -al $(KSOURCE) $(KFLAVOUR)

	rm -f $(KFLAVOUR)/.config $(KFLAVOUR)/debian/control
	-$(MAKE) -s -C config $(flavour) > $(KFLAVOUR)/.config
	$(M4) debian/control-dummy.m4 > $(KFLAVOUR)/debian/control
	$(M4) debian/dirs-image.m4 >> debian/kernel-image-$(kernel)-$(flavour).dirs

	touch $@

endif
endif

# the build target is responsible for, well, building the kernels and
# modules for each flavour.  To that end, it uses the build target of
# make-kpkg.

ifeq ($(DEB_HOST_ARCH),powerpc)
build: stamp-build
else
build:
endif

stamp-build: \
stamp-configure stamp-build-prepare
	$(MAKE) -f debian/rules $(PARALLEL_BUILD) $(foreach flavour,$(flavours),stamp-build-flavour-$(flavour))
	touch $@

stamp-build-prepare:
	dh_testdir
	touch $@

ifeq (0,$(MAKELEVEL))

stamp-build-flavour-%:
	$(MAKE) -f debian/rules $@

else
ifeq (1,$(MAKELEVEL))

stamp-build-flavour-%:
	$(MAKE) -f debian/rules stamp-build-flavour-$* flavour=$*

else
ifeq (2,$(MAKELEVEL))

# build the pmac kernel and the modules for a given flavour
stamp-build-flavour-$(flavour): \
stamp-configure-flavour-$(flavour) stamp-build-prepare
	cd $(KFLAVOUR); \
	MFLAGS="$(filter-out -j --j%,$(MFLAGS))" \
	MAKEFLAGS="$(filter-out -j --j%,$(MAKEFLAGS))" make-kpkg build
	touch $@

endif
endif
endif

# the install target is responsible for assigning the built kernels
# and modules to the right kernel-image and kernel-modules packages.
# The main work is done through the kernel-image target of make-kpkg.
# The resulting intermediate package is immediately unpacked again and
# its contents re-arranged slightly. The whole process results in one
# kernel-image directory per flavour. Also, the install target puts
# together the build infrastructure for modules.

install: stamp-install

stamp-install: \
stamp-build
	$(MAKE) -f debian/rules $(PARALLEL_BUILD) $(foreach flavour,$(flavours),stamp-install-flavour-$(flavour))
	touch $@

# do the usual checks
stamp-install-prepare:
	dh_testdir
	dh_testroot
	dh_clean

	touch $@

ifeq (0,$(MAKELEVEL))

stamp-install-flavour-%:
	$(MAKE) -f debian/rules $@

else
ifeq (1,$(MAKELEVEL))

stamp-install-flavour-%:
	$(MAKE) -f debian/rules stamp-install-flavour-$* flavour=$*

else
ifeq (2,$(MAKELEVEL))

# create an intermediate kernel-image package from the build tree,
# immediately unpack it into the install directory, and re-arrange a
# few things.  Also, install the build infrastructure for modules from
# the kernel source.

stamp-install-flavour-$(flavour): \
stamp-build-flavour-$(flavour) stamp-install-prepare

# create and unpack the intermediate kernel image package
	cd $(KFLAVOUR); \
	MFLAGS="$(filter-out -j --j%,$(MFLAGS))" \
	MAKEFLAGS="$(filter-out -j --j%,$(MAKEFLAGS))" make-kpkg kernel-image
	dpkg -x $(KDUMMY) $(KIMAGE)

# remove the coff image
	rm -f $(KIMAGE)/boot/vmlinux.coff-$(kernel)-$(flavour)

# copy build infrastructure for kernel modules
	cd $(KFLAVOUR); find scripts -type f ! -name '*.o' | cpio -pd $(KSRC)
	cat debian/build-files | ( cd $(KFLAVOUR); cpio -pd $(KSRC) )
	for file in `cat debian/build-links`; do \
		tmp=$$file; \
		link=".." ; \
		while [ `dirname $$tmp` != "." ]; do \
			link="$$link/.."; \
			tmp=`dirname $$tmp`; \
		done; \
		ln -sf $$link/kernel-headers-$(kernel)-$(flavour)/$$file $(KSRC)/$$file; \
	done
	ln -sf asm-ppc $(KSRC)/include/asm
	mkdir -p $(KBUILD)/lib/modules/$(kernel)-$(flavour)
	ln -sf ../../../usr/src/kernel-build-$(kernel)-$(flavour) \
		$(KBUILD)/lib/modules/$(kernel)-$(flavour)/build
	ln -sf ../../../usr/src/kernel-build-$(kernel)-$(flavour) \
		$(KBUILD)/lib/modules/$(kernel)-$(flavour)/source

# add some README files and the kernel-source changelog
	$(INSTALL_DATA) debian/README.kernel-image $(KIMAGEDOC)/NEWS.Debian
	$(INSTALL_DATA) /usr/share/doc/kernel-source-$(kernel)/changelog.Debian.gz \
		$(KIMAGEDOC)/changelog-kernel-source.Debian.gz
	mkdir -p $(KBUILDDOC)
	$(INSTALL_DATA) debian/README.kernel-build $(KBUILDDOC)/README.Debian

	touch $@

endif
endif
endif

# the binary target is responsible for creating Debian packages from
# the various package directories created by the install target.
# Also, it creates additional packages such as kernel-headers directly
# from the build directories.

ifeq ($(DEB_HOST_ARCH),powerpc)
binary: \
binary-kernel-headers-$(kernel)-powerpc \
$(foreach flavour,$(flavours),binary-flavour-$(flavour))
else
binary: binary-arch binary-indep
binary-arch:
binary-indep:
endif

ifeq (0,$(MAKELEVEL))

binary-flavour-%:
	$(MAKE) -f debian/rules binary-flavour-$* flavour=$*

else
ifeq (1,$(MAKELEVEL))

ifeq (Yes,$(OFFICIAL_VERSION))
binary-flavour-$(flavour): \
binary-kernel-image-$(flavour) \
binary-kernel-image-$(kernel)-$(flavour) \
binary-kernel-build-$(kernel)-$(flavour)
else
binary-flavour-$(flavour): \
binary-kernel-image-$(kernel)-$(flavour) \
binary-kernel-build-$(kernel)-$(flavour)
endif

endif
endif

# the following targets do the actual work of creating the packages.

# The kernel-headers package is special since it can be created with a
# simple call to make-kpkg.

binary-kernel-headers-$(kernel)-powerpc: stamp-install-prepare
	cd $(KSOURCE); APPEND_TO_VERSION='-powerpc' make-kpkg kernel-headers
	mv $(KHEADERS) ..
	dpkg-distaddfile $(notdir $(KHEADERS)) devel optional

# For all packages that are actually built here, almost all tasks are
# identical and are therefore collected in a common target.  The
# recursion takes care of passing the package name to the debhelper
# scripts.

# The kernel-image packages branch from the common packaging procedure
# just before the creation of the control file, because they need
# install scripts.  Right now, they simply uses the ones from the
# intermediate package.  In the future, it may come handy to modify
# them slightly, so the following code snippet is kept for reference.
# It erases $loader and changes $kimage from vmlinux to vmlinuz.
#
#	for file in {pre,post}{inst,rm}; do \
#	< $(KIMAGE)/DEBIAN/$$file sed \
#	-e's/^\(my..loader.*"\)[a-z]*"/\1"/' \
#	-e's/^\(my..kimage.*"vmlinu\)x/\1z/' > $(KIMAGE)/DEBIAN/$$file; \
#	chmod 755 $(KIMAGE)/DEBIAN/$$file; done

binary-kernel-image-$(kernel)-%: stamp-install-flavour-$(flavour)
	$(MAKE) -f debian/rules binary-image-package DH_OPTIONS=-pkernel-image-$(kernel)-$*

binary-image-package: binary-common-package
	dpkg -e $(KDUMMY) $(KIMAGE)/DEBIAN
	dh_gencontrol
	dh_md5sums
	dh_builddeb

binary-kernel-%: stamp-install-flavour-$(flavour)
	$(MAKE) -f debian/rules binary-package DH_OPTIONS=-pkernel-$*
binary-package: binary-common-package
	dh_gencontrol
	dh_md5sums
	dh_builddeb

binary-common-package:
	dh_testdir
	dh_testroot
	dh_installdocs
	dh_installexamples -X.svn
	dh_installmodules
	dh_installchangelogs
	dh_compress -X.stub
	dh_link
	dh_strip
	dh_fixperms
	dh_installdeb

# the clean target flushes the whole shebang down the drain, generated
# files in debian/, build directories, stamp files, everything.  The
# install-clean target reverts only the install stage, which is nice
# for changing the packaging without having to rebuild in all the
# kernel source trees.

install-clean:
	for file in debian/*.m4; do rm -f $${file%.m4}; done
	for dir in debian/kernel-*; do if test -d $$dir; then rm -rf $$dir; fi; done
	rm -f stamp-install-*

clean:	install-clean
	dh_testdir

	rm -rf $(TMP)
	rm -f stamp-*

	dh_clean

.PHONY:	configure build install binary binary-arch clean

# this target is intended for easy upgrade of the control file, in
# case the kernel version, the Debian revision, or the flavours
# change.

# slightly different m4 call, using a shell variable for the flavour
M4CONTROL = m4 -DM4KERNEL=$(kernel) -DM4FLAVOUR=$$flavour

debian/control: \
debian/changelog debian/flavours \
$(foreach flavour,$(flavours), debian/flavour-$(flavour)) \
debian/control.stub debian/control-image.m4 debian/control-official.m4

	$(M4CONTROL) debian/control.stub > $@

	for flavour in $(flavours); do \
		$(M4CONTROL) debian/control-image.m4 >> $@; \
		if [ "$(OFFICIAL_VERSION)" = "Yes" ]; then \
			$(M4CONTROL) debian/control-official.m4 >> $@; \
		fi; \
		cat debian/flavour-$$flavour >> $@; \
	done
