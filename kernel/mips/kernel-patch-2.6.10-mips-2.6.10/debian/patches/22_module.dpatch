#! /bin/sh -e
## 22_module.dpatch by Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Module loader fix.

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p0 ${patch_opts} < $0;;
    -unpatch) patch -R -p0 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

Index: arch/mips/kernel/Makefile
===================================================================
RCS file: /home/cvs/linux/arch/mips/kernel/Makefile,v
retrieving revision 1.87
diff -u -p -r1.87 Makefile
--- arch/mips/kernel/Makefile	7 Jan 2005 04:26:49 -0000	1.87
+++ arch/mips/kernel/Makefile	31 Jan 2005 02:26:26 -0000
@@ -11,11 +11,7 @@ obj-y		+= cpu-probe.o branch.o entry.o g
 binfmt_irix-objs	:= irixelf.o irixinv.o irixioctl.o irixsig.o	\
 			   irix5sys.o sysirix.o
 
-ifdef CONFIG_MODULES
-obj-y				+= mips_ksyms.o module.o
-obj-$(CONFIG_MIPS32)		+= module-elf32.o
-obj-$(CONFIG_MIPS64)		+= module-elf64.o
-endif
+obj-$(CONFIG_MODULES)		+= mips_ksyms.o module.o
 
 obj-$(CONFIG_CPU_R3000)		+= r2300_fpu.o r2300_switch.o
 obj-$(CONFIG_CPU_TX39XX)	+= r2300_fpu.o r2300_switch.o
Index: arch/mips/kernel/module-elf32.c
===================================================================
RCS file: arch/mips/kernel/module-elf32.c
diff -N arch/mips/kernel/module-elf32.c
--- arch/mips/kernel/module-elf32.c	17 Jun 2004 01:43:44 -0000	1.4
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,250 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *  Copyright (C) 2001 Rusty Russell.
- *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
- */
-
-#undef DEBUG
-
-#include <linux/moduleloader.h>
-#include <linux/elf.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-
-struct mips_hi16 {
-	struct mips_hi16 *next;
-	Elf32_Addr *addr;
-	Elf32_Addr value;
-};
-
-static struct mips_hi16 *mips_hi16_list;
-
-void *module_alloc(unsigned long size)
-{
-	if (size == 0)
-		return NULL;
-	return vmalloc(size);
-}
-
-
-/* Free memory returned from module_alloc */
-void module_free(struct module *mod, void *module_region)
-{
-	vfree(module_region);
-	/* FIXME: If module_region == mod->init_region, trim exception
-           table entries. */
-}
-
-int module_frob_arch_sections(Elf_Ehdr *hdr,
-			      Elf_Shdr *sechdrs,
-			      char *secstrings,
-			      struct module *mod)
-{
-	return 0;
-}
-
-static int apply_r_mips_none(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	return 0;
-}
-
-static int apply_r_mips_32(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	*location += v;
-
-	return 0;
-}
-
-static int apply_r_mips_26(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	if (v % 4) {
-		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
-		return -ENOEXEC;
-	}
-
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
-
-	*location = (*location & ~0x03ffffff) |
-	            ((*location + (v >> 2)) & 0x03ffffff);
-
-	return 0;
-}
-
-static int apply_r_mips_hi16(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	struct mips_hi16 *n;
-
-	/*
-	 * We cannot relocate this one now because we don't know the value of
-	 * the carry we need to add.  Save the information, and let LO16 do the
-	 * actual relocation.
-	 */
-	n = kmalloc(sizeof *n, GFP_KERNEL);
-	if (!n)
-		return -ENOMEM;
-
-	n->addr = location;
-	n->value = v;
-	n->next = mips_hi16_list;
-	mips_hi16_list = n;
-
-	return 0;
-}
-
-static int apply_r_mips_lo16(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	unsigned long insnlo = *location;
-	Elf32_Addr val, vallo;
-
-	/* Sign extend the addend we extract from the lo insn.  */
-	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
-
-	if (mips_hi16_list != NULL) {
-		struct mips_hi16 *l;
-
-		l = mips_hi16_list;
-		while (l != NULL) {
-			struct mips_hi16 *next;
-			unsigned long insn;
-
-			/*
-			 * The value for the HI16 had best be the same.
-			 */
-			if (v != l->value)
-				goto out_danger;
-
-			/*
-			 * Do the HI16 relocation.  Note that we actually don't
-			 * need to know anything about the LO16 itself, except
-			 * where to find the low 16 bits of the addend needed
-			 * by the LO16.
-			 */
-			insn = *l->addr;
-			val = ((insn & 0xffff) << 16) + vallo;
-			val += v;
-
-			/*
-			 * Account for the sign extension that will happen in
-			 * the low bits.
-			 */
-			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
-
-			insn = (insn & ~0xffff) | val;
-			*l->addr = insn;
-
-			next = l->next;
-			kfree(l);
-			l = next;
-		}
-
-		mips_hi16_list = NULL;
-	}
-
-	/*
-	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
-	 */
-	val = v + vallo;
-	insnlo = (insnlo & ~0xffff) | (val & 0xffff);
-	*location = insnlo;
-
-	return 0;
-
-out_danger:
-	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
-
-	return -ENOEXEC;
-}
-
-static int (*reloc_handlers[]) (struct module *me, uint32_t *location,
-	Elf32_Addr v) = {
-	[R_MIPS_NONE]	= apply_r_mips_none,
-	[R_MIPS_32]	= apply_r_mips_32,
-	[R_MIPS_26]	= apply_r_mips_26,
-	[R_MIPS_HI16]	= apply_r_mips_hi16,
-	[R_MIPS_LO16]	= apply_r_mips_lo16
-};
-
-int apply_relocate(Elf32_Shdr *sechdrs,
-		   const char *strtab,
-		   unsigned int symindex,
-		   unsigned int relsec,
-		   struct module *me)
-{
-	Elf32_Rel *rel = (void *) sechdrs[relsec].sh_addr;
-	Elf32_Sym *sym;
-	uint32_t *location;
-	unsigned int i;
-	Elf32_Addr v;
-	int res;
-
-	pr_debug("Applying relocate section %u to %u\n", relsec,
-	       sechdrs[relsec].sh_info);
-
-	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
-		Elf32_Word r_info = rel[i].r_info;
-
-		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
-		/* This is the symbol it is referring to */
-		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
-			+ ELF32_R_SYM(r_info);
-		if (!sym->st_value) {
-			printk(KERN_WARNING "%s: Unknown symbol %s\n",
-			       me->name, strtab + sym->st_name);
-			return -ENOENT;
-		}
-
-		v = sym->st_value;
-
-		res = reloc_handlers[ELF32_R_TYPE(r_info)](me, location, v);
-		if (res)
-			return res;
-	}
-
-	return 0;
-}
-
-int apply_relocate_add(Elf32_Shdr *sechdrs,
-		       const char *strtab,
-		       unsigned int symindex,
-		       unsigned int relsec,
-		       struct module *me)
-{
-	/*
-	 * Current binutils always generate .rela relocations.  Keep smiling
-	 * if it's empty, abort otherwise.
-	 */
-	if (!sechdrs[relsec].sh_size)
-		return 0;
-
-	printk(KERN_ERR "module %s: ADD RELOCATION unsupported\n",
-	       me->name);
-	return -ENOEXEC;
-}
Index: arch/mips/kernel/module-elf64.c
===================================================================
RCS file: arch/mips/kernel/module-elf64.c
diff -N arch/mips/kernel/module-elf64.c
--- arch/mips/kernel/module-elf64.c	17 Jun 2004 01:43:44 -0000	1.4
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,274 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *  Copyright (C) 2001 Rusty Russell.
- *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
- */
-
-#undef DEBUG
-
-#include <linux/moduleloader.h>
-#include <linux/elf.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-
-struct mips_hi16 {
-	struct mips_hi16 *next;
-	Elf32_Addr *addr;
-	Elf64_Addr value;
-};
-
-static struct mips_hi16 *mips_hi16_list;
-
-void *module_alloc(unsigned long size)
-{
-	if (size == 0)
-		return NULL;
-	return vmalloc(size);
-}
-
-
-/* Free memory returned from module_alloc */
-void module_free(struct module *mod, void *module_region)
-{
-	vfree(module_region);
-	/* FIXME: If module_region == mod->init_region, trim exception
-           table entries. */
-}
-
-int module_frob_arch_sections(Elf_Ehdr *hdr,
-			      Elf_Shdr *sechdrs,
-			      char *secstrings,
-			      struct module *mod)
-{
-	return 0;
-}
-
-int apply_relocate(Elf64_Shdr *sechdrs,
-		   const char *strtab,
-		   unsigned int symindex,
-		   unsigned int relsec,
-		   struct module *me)
-{
-	/*
-	 * We don't want to deal with REL relocations - RELA is so much saner.
-	 */
-	if (!sechdrs[relsec].sh_size)
-		return 0;
-
-	printk(KERN_ERR "module %s: REL relocation unsupported\n",
-	       me->name);
-	return -ENOEXEC;
-}
-
-static int apply_r_mips_none(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	return 0;
-}
-
-static int apply_r_mips_32(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = v;
-
-	return 0;
-}
-
-static int apply_r_mips_26(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	if (v % 4) {
-		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
-		return -ENOEXEC;
-	}
-
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
-
-	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
-
-	return 0;
-}
-
-static int apply_r_mips_hi16(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	struct mips_hi16 *n;
-
-	/*
-	 * We cannot relocate this one now because we don't know the value of
-	 * the carry we need to add.  Save the information, and let LO16 do the
-	 * actual relocation.
-	 */
-	n = kmalloc(sizeof *n, GFP_KERNEL);
-	if (!n)
-		return -ENOMEM;
-
-	n->addr = location;
-	n->value = v;
-	n->next = mips_hi16_list;
-	mips_hi16_list = n;
-
-	return 0;
-}
-
-static int apply_r_mips_lo16(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	unsigned long insnlo = *location;
-	Elf32_Addr val, vallo;
-
-	/* Sign extend the addend we extract from the lo insn.  */
-	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
-
-	if (mips_hi16_list != NULL) {
-		struct mips_hi16 *l;
-
-		l = mips_hi16_list;
-		while (l != NULL) {
-			struct mips_hi16 *next;
-			unsigned long insn;
-
-			/*
-			 * The value for the HI16 had best be the same.
-			 */
-			if (v != l->value)
-				goto out_danger;
-
-			/*
-			 * Do the HI16 relocation.  Note that we actually don't
-			 * need to know anything about the LO16 itself, except
-			 * where to find the low 16 bits of the addend needed
-			 * by the LO16.
-			 */
-			insn = *l->addr;
-			val = ((insn & 0xffff) << 16) + vallo;
-			val += v;
-
-			/*
-			 * Account for the sign extension that will happen in
-			 * the low bits.
-			 */
-			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
-
-			insn = (insn & ~0xffff) | val;
-			*l->addr = insn;
-
-			next = l->next;
-			kfree(l);
-			l = next;
-		}
-
-		mips_hi16_list = NULL;
-	}
-
-	/*
-	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
-	 */
-	insnlo = (insnlo & ~0xffff) | (v & 0xffff);
-	*location = insnlo;
-
-	return 0;
-
-out_danger:
-	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
-
-	return -ENOEXEC;
-}
-
-static int apply_r_mips_64(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*(uint64_t *) location = v;
-
-	return 0;
-}
-
-
-static int apply_r_mips_higher(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = (*location & 0xffff0000) |
-	            ((((long long) v + 0x80008000LL) >> 32) & 0xffff);
-
-	return 0;
-}
-
-static int apply_r_mips_highest(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = (*location & 0xffff0000) |
-	            ((((long long) v + 0x800080008000LL) >> 48) & 0xffff);
-
-	return 0;
-}
-
-static int (*reloc_handlers[]) (struct module *me, uint32_t *location,
-	Elf64_Addr v) = {
-	[R_MIPS_NONE]		= apply_r_mips_none,
-	[R_MIPS_32]		= apply_r_mips_32,
-	[R_MIPS_26]		= apply_r_mips_26,
-	[R_MIPS_HI16]		= apply_r_mips_hi16,
-	[R_MIPS_LO16]		= apply_r_mips_lo16,
-	[R_MIPS_64]		= apply_r_mips_64,
-	[R_MIPS_HIGHER]		= apply_r_mips_higher,
-	[R_MIPS_HIGHEST]	= apply_r_mips_highest
-};
-
-int apply_relocate_add(Elf64_Shdr *sechdrs,
-		       const char *strtab,
-		       unsigned int symindex,
-		       unsigned int relsec,
-		       struct module *me)
-{
-	Elf64_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;
-	Elf64_Sym *sym;
-	uint32_t *location;
-	unsigned int i;
-	Elf64_Addr v;
-	int res;
-
-	pr_debug("Applying relocate section %u to %u\n", relsec,
-	       sechdrs[relsec].sh_info);
-
-	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
-		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
-		/* This is the symbol it is referring to */
-		sym = (Elf64_Sym *)sechdrs[symindex].sh_addr + rel[i].r_sym;
-		if (!sym->st_value) {
-			printk(KERN_WARNING "%s: Unknown symbol %s\n",
-			       me->name, strtab + sym->st_name);
-			return -ENOENT;
-		}
-
-		v = sym->st_value;
-
-		res = reloc_handlers[rel[i].r_type](me, location, v);
-		if (res)
-			return res;
-	}
-
-	return 0;
-}
Index: arch/mips/kernel/module.c
===================================================================
RCS file: /home/cvs/linux/arch/mips/kernel/module.c,v
retrieving revision 1.7
diff -u -p -r1.7 module.c
--- arch/mips/kernel/module.c	26 Jun 2004 15:15:10 -0000	1.7
+++ arch/mips/kernel/module.c	31 Jan 2005 02:26:26 -0000
@@ -1,9 +1,345 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Copyright (C) 2001 Rusty Russell.
+ *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
+ *  Copyright (C) 2005 Thiemo Seufer
+ */
+
+#undef DEBUG
+
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 
+struct mips_hi16 {
+	struct mips_hi16 *next;
+	Elf_Addr *addr;
+	Elf_Addr value;
+};
+
+static struct mips_hi16 *mips_hi16_list;
+
 static LIST_HEAD(dbe_list);
 static spinlock_t dbe_lock = SPIN_LOCK_UNLOCKED;
 
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+	/* FIXME: If module_region == mod->init_region, trim exception
+           table entries. */
+}
+
+int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
+			      char *secstrings, struct module *mod)
+{
+	return 0;
+}
+
+static int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
+{
+	return 0;
+}
+
+static int apply_r_mips_32_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location += v;
+
+	return 0;
+}
+
+static int apply_r_mips_32_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = v;
+
+	return 0;
+}
+
+static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	if (v % 4) {
+		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
+		return -ENOEXEC;
+	}
+
+	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+		printk(KERN_ERR
+		       "module %s: relocation overflow\n",
+		       me->name);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & ~0x03ffffff) |
+	            ((*location + (v >> 2)) & 0x03ffffff);
+
+	return 0;
+}
+
+static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	if (v % 4) {
+		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
+		return -ENOEXEC;
+	}
+
+	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+		printk(KERN_ERR
+		       "module %s: relocation overflow\n",
+		       me->name);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
+
+	return 0;
+}
+
+static int apply_r_mips_hi16_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	struct mips_hi16 *n;
+
+	/*
+	 * We cannot relocate this one now because we don't know the value of
+	 * the carry we need to add.  Save the information, and let LO16 do the
+	 * actual relocation.
+	 */
+	n = kmalloc(sizeof *n, GFP_KERNEL);
+	if (!n)
+		return -ENOMEM;
+
+	n->addr = (Elf_Addr *)location;
+	n->value = v;
+	n->next = mips_hi16_list;
+	mips_hi16_list = n;
+
+	return 0;
+}
+
+static int apply_r_mips_hi16_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x8000LL) >> 16) & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_lo16_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	unsigned long insnlo = *location;
+	Elf_Addr val, vallo;
+
+	/* Sign extend the addend we extract from the lo insn.  */
+	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
+
+	if (mips_hi16_list != NULL) {
+		struct mips_hi16 *l;
+
+		l = mips_hi16_list;
+		while (l != NULL) {
+			struct mips_hi16 *next;
+			unsigned long insn;
+
+			/*
+			 * The value for the HI16 had best be the same.
+			 */
+			if (v != l->value)
+				goto out_danger;
+
+			/*
+			 * Do the HI16 relocation.  Note that we actually don't
+			 * need to know anything about the LO16 itself, except
+			 * where to find the low 16 bits of the addend needed
+			 * by the LO16.
+			 */
+			insn = *l->addr;
+			val = ((insn & 0xffff) << 16) + vallo;
+			val += v;
+
+			/*
+			 * Account for the sign extension that will happen in
+			 * the low bits.
+			 */
+			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
+
+			insn = (insn & ~0xffff) | val;
+			*l->addr = insn;
+
+			next = l->next;
+			kfree(l);
+			l = next;
+		}
+
+		mips_hi16_list = NULL;
+	}
+
+	/*
+	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
+	 */
+	val = v + vallo;
+	insnlo = (insnlo & ~0xffff) | (val & 0xffff);
+	*location = insnlo;
+
+	return 0;
+
+out_danger:
+	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
+
+	return -ENOEXEC;
+}
+
+static int apply_r_mips_lo16_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) | (v & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_64_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*(Elf_Addr *)location = v;
+
+	return 0;
+}
+
+static int apply_r_mips_higher_rela(struct module *me, u32 *location,
+				    Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x80008000LL) >> 32) & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_highest_rela(struct module *me, u32 *location,
+				     Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x800080008000LL) >> 48) & 0xffff);
+
+	return 0;
+}
+
+static int (*reloc_handlers_rel[]) (struct module *me, u32 *location,
+				Elf_Addr v) = {
+	[R_MIPS_NONE]		= apply_r_mips_none,
+	[R_MIPS_32]		= apply_r_mips_32_rel,
+	[R_MIPS_26]		= apply_r_mips_26_rel,
+	[R_MIPS_HI16]		= apply_r_mips_hi16_rel,
+	[R_MIPS_LO16]		= apply_r_mips_lo16_rel
+};
+
+static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,
+				Elf_Addr v) = {
+	[R_MIPS_NONE]		= apply_r_mips_none,
+	[R_MIPS_32]		= apply_r_mips_32_rela,
+	[R_MIPS_26]		= apply_r_mips_26_rela,
+	[R_MIPS_HI16]		= apply_r_mips_hi16_rela,
+	[R_MIPS_LO16]		= apply_r_mips_lo16_rela,
+	[R_MIPS_64]		= apply_r_mips_64_rela,
+	[R_MIPS_HIGHER]		= apply_r_mips_higher_rela,
+	[R_MIPS_HIGHEST]	= apply_r_mips_highest_rela
+};
+
+int apply_relocate(Elf_Shdr *sechdrs, const char *strtab,
+		   unsigned int symindex, unsigned int relsec,
+		   struct module *me)
+{
+	Elf_Mips_Rel *rel = (void *) sechdrs[relsec].sh_addr;
+	Elf_Sym *sym;
+	u32 *location;
+	unsigned int i;
+	Elf_Addr v;
+	int res;
+
+	pr_debug("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to */
+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
+			+ ELF_MIPS_R_SYM(rel[i]);
+		if (!sym->st_value) {
+			printk(KERN_WARNING "%s: Unknown symbol %s\n",
+			       me->name, strtab + sym->st_name);
+			return -ENOENT;
+		}
+
+		v = sym->st_value;
+
+		res = reloc_handlers_rel[ELF_MIPS_R_TYPE(rel[i])](me, location, v);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
+int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
+		       unsigned int symindex, unsigned int relsec,
+		       struct module *me)
+{
+	Elf_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;
+	Elf_Sym *sym;
+	u32 *location;
+	unsigned int i;
+	Elf_Addr v;
+	int res;
+
+	pr_debug("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to */
+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
+			+ ELF_MIPS_R_SYM(rel[i]);
+		if (!sym->st_value) {
+			printk(KERN_WARNING "%s: Unknown symbol %s\n",
+			       me->name, strtab + sym->st_name);
+			return -ENOENT;
+		}
+
+		v = sym->st_value + rel[i].r_addend;
+
+		res = reloc_handlers_rela[ELF_MIPS_R_TYPE(rel[i])](me, location, v);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
 /* Given an address, look for it in the module exception tables. */
 const struct exception_table_entry *search_module_dbetables(unsigned long addr)
 {
Index: include/asm-mips/module.h
===================================================================
RCS file: /home/cvs/linux/include/asm-mips/module.h,v
retrieving revision 1.7
diff -u -p -r1.7 module.h
--- include/asm-mips/module.h	17 Jun 2004 01:43:44 -0000	1.7
+++ include/asm-mips/module.h	31 Jan 2005 02:26:46 -0000
@@ -14,15 +14,23 @@ struct mod_arch_specific {
 
 typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
 
-typedef struct
-{
-  Elf64_Addr r_offset;			/* Address of relocation.  */
-  Elf64_Word r_sym;			/* Symbol index.  */
-  Elf64_Byte r_ssym;			/* Special symbol.  */
-  Elf64_Byte r_type3;			/* Third relocation.  */
-  Elf64_Byte r_type2;			/* Second relocation.  */
-  Elf64_Byte r_type;			/* First relocation.  */
-  Elf64_Sxword r_addend;		/* Addend.  */
+typedef struct {
+	Elf64_Addr r_offset;			/* Address of relocation.  */
+	Elf64_Word r_sym;			/* Symbol index.  */
+	Elf64_Byte r_ssym;			/* Special symbol.  */
+	Elf64_Byte r_type3;			/* Third relocation.  */
+	Elf64_Byte r_type2;			/* Second relocation.  */
+	Elf64_Byte r_type;			/* First relocation.  */
+} Elf64_Mips_Rel;
+
+typedef struct {
+	Elf64_Addr r_offset;			/* Address of relocation.  */
+	Elf64_Word r_sym;			/* Symbol index.  */
+	Elf64_Byte r_ssym;			/* Special symbol.  */
+	Elf64_Byte r_type3;			/* Third relocation.  */
+	Elf64_Byte r_type2;			/* Second relocation.  */
+	Elf64_Byte r_type;			/* First relocation.  */
+	Elf64_Sxword r_addend;			/* Addend.  */
 } Elf64_Mips_Rela;
 
 #ifdef CONFIG_MIPS32
@@ -30,6 +38,13 @@ typedef struct
 #define Elf_Shdr	Elf32_Shdr
 #define Elf_Sym		Elf32_Sym
 #define Elf_Ehdr	Elf32_Ehdr
+#define Elf_Addr	Elf32_Addr
+
+#define Elf_Mips_Rel	Elf32_Rel
+#define Elf_Mips_Rela	Elf32_Rela
+
+#define ELF_MIPS_R_SYM(rel) ELF32_R_SYM(rel.r_info)
+#define ELF_MIPS_R_TYPE(rel) ELF32_R_TYPE(rel.r_info)
 
 #endif
 
@@ -38,6 +53,13 @@ typedef struct
 #define Elf_Shdr	Elf64_Shdr
 #define Elf_Sym		Elf64_Sym
 #define Elf_Ehdr	Elf64_Ehdr
+#define Elf_Addr	Elf64_Addr
+
+#define Elf_Mips_Rel	Elf64_Mips_Rel
+#define Elf_Mips_Rela	Elf64_Mips_Rela
+
+#define ELF_MIPS_R_SYM(rel) (rel.r_sym)
+#define ELF_MIPS_R_TYPE(rel) (rel.r_type)
 
 #endif
 
