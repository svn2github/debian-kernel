#! /bin/sh -e 
## <PATCHNAME>.dpatch by <PATCH_AUTHOR@EMAI>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Description: modularised VESA FB
## DP: Patch author: unknown
## DP: Upstream status: not submitted

. $(dirname $0)/DPATCH

@DPATCH@
--- kernel-source-2.6.6/drivers/video/Kconfig	2004-05-10 19:48:01.000000000 +1000
+++ kernel-source-2.6.6-1/drivers/video/Kconfig	2004-05-10 22:21:43.000000000 +1000
@@ -283,7 +283,7 @@
 	  cards. Say Y if you have one of those.
 
 config FB_VESA
-	bool "VESA VGA graphics support"
+	tristate "VESA VGA graphics support"
 	depends on FB && (X86 || X86_64)
 	help
 	  This is the frame buffer device driver for generic VESA 2.0

--- a/drivers/video/vesafb.c	2004-10-18 17:53:11.000000000 -0400
+++ b/drivers/video/vesafb.c	2004-10-23 01:58:33.000000000 -0400
@@ -19,6 +19,7 @@
 #include <linux/fb.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
+#include <linux/moduleparam.h>
 #ifdef __i386__
 #include <video/edid.h>
 #endif
@@ -49,6 +50,7 @@
 
 static int             inverse   = 0;
 static int             mtrr      = 1;
+static int             mtrr_hdl;
 static int	       vram_remap __initdata = 0; /* Set amount of memory to be used */
 static int        vram_total __initdata = 0; /* Set total amount of memory */
 static int             pmi_setpal = 0;	/* pmi for palette changes ??? */
@@ -56,6 +58,9 @@
 static void            (*pmi_start)(void);
 static void            (*pmi_pal)(void);
 
+static char	       *options;
+module_param(options, charp, 0);
+
 /* --------------------------------------------------------------------- */
 
 static int vesafb_pan_display(struct fb_var_screeninfo *var,
@@ -221,6 +226,8 @@
 	struct fb_info *info;
 	int i, err;
 
+	vesafb_setup(options);
+
 	if (screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB)
 		return -ENXIO;
 
@@ -368,7 +375,7 @@
                 	temp_size &= (temp_size - 1);
                         
                 /* Try and find a power of two to add */
-		while (temp_size && mtrr_add(vesafb_fix.smem_start, temp_size, MTRR_TYPE_WRCOMB, 1)==-EINVAL) {
+		while (temp_size && (mtrr_hdl = mtrr_add(vesafb_fix.smem_start, temp_size, MTRR_TYPE_WRCOMB, 1)) == -EINVAL) {
 			temp_size >>= 1;
 		}
 	}
@@ -390,6 +397,7 @@
 	}
 	printk(KERN_INFO "fb%d: %s frame buffer device\n",
 	       info->node, info->fix.id);
+	dev_set_drvdata(device, info);
 	return 0;
 err:
 	framebuffer_release(info);
@@ -397,6 +405,17 @@
 	return err;
 }
 
+static void __exit vesafb_remove(struct device *device)
+{
+	struct fb_info *info = dev_get_drvdata(device);
+
+	unregister_framebuffer(info);
+	if (mtrr && mtrr_hdl >= 0)
+		mtrr_del(mtrr_hdl, 0, 0);
+	iounmap(info->screen_base);
+	release_mem_region(vesafb_fix.smem_start, vesafb_fix.smem_len);
+}
+
 static struct device_driver vesafb_driver = {
 	.name	= "vesafb",
 	.bus	= &platform_bus_type,
@@ -424,7 +443,14 @@
 	}
 	return ret;
 }
+
+static void __exit vesafb_exit(void)
+{
+	platform_device_unregister(&vesafb_device);
+	driver_unregister(&vesafb_driver);
+}
 module_init(vesafb_init);
+module_exit(vesafb_exit);
 
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
