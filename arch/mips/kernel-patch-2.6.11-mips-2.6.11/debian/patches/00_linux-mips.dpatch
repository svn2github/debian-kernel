#! /bin/sh -e
## 00_linux-mips.dpatch by Thiemo Seufer <ths@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Diff between kernel.org 2.6.12-rc1 and linux-mips.org, CVS HEAD,
## DP: taken at 2005-04-02.

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p1 ${patch_opts} < $0;;
    -unpatch) patch -R -p1 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

diff -urpNX dontdiff linux-2.6.11.6/Makefile linux_HEAD/Makefile
--- linux-2.6.11.6/Makefile	2005-04-02 23:39:51.000000000 +0200
+++ linux_HEAD/Makefile	2005-03-21 20:03:31.000000000 +0100
@@ -167,9 +167,7 @@ KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$
 # then ARCH is assigned, getting whatever value it gets normally, and 
 # SUBARCH is subsequently ignored.
 
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
-				  -e s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ -e s/parisc64/parisc/ )
+SUBARCH := mips
 
 # Cross compiling and selecting different set of gcc/bin-utils
 # ---------------------------------------------------------------------------
@@ -532,7 +530,7 @@ endif
 include $(srctree)/arch/$(ARCH)/Makefile
 
 # warn about C99 declaration after statement
-CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
+#CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
 
 # disable pointer signedness warnings in gcc 4.0
 CFLAGS += $(call cc-option,-Wno-pointer-sign,)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/Kconfig linux_HEAD/arch/mips/Kconfig
--- linux-2.6.11.6/arch/mips/Kconfig	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/Kconfig	2005-03-21 20:03:43.000000000 +0100
@@ -4,180 +4,130 @@ config MIPS
 	# Horrible source of confusion.  Die, die, die ...
 	select EMBEDDED
 
-config MIPS64
-	bool "64-bit kernel"
-	help
-	  Select this option if you want to build a 64-bit kernel.  You should
-	  only select this option if you have hardware that actually has a
-	  64-bit processor and if your application will actually benefit from
-	  64-bit processing, otherwise say N.  You must say Y for kernels for
-	  SGI IP27 (Origin 200 and 2000) and SGI IP32 (O2).  If in doubt say N.
-
-config 64BIT
-	def_bool MIPS64
-
-config MIPS32
-	bool
-	depends on MIPS64 = 'n'
-	default y
-
 mainmenu "Linux/MIPS Kernel Configuration"
 
 source "init/Kconfig"
 
 menu "Machine selection"
 
-config MACH_JAZZ
-	bool "Support for the Jazz family of machines"
-	select ARC
-	select ARC32
-	select GENERIC_ISA_DMA
-	select I8259
-	select ISA
-	help
-	 This a family of machines based on the MIPS R4030 chipset which was
-	 used by several vendors to build RISC/os and Windows NT workstations.
-	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millenium and
-	 Olivetti M700-10 workstations.
+choice
+	prompt "System type"
+	default SGI_IP22
 
-config ACER_PICA_61
-	bool "Support for Acer PICA 1 chipset (EXPERIMENTAL)"
-	depends on MACH_JAZZ && EXPERIMENTAL
+config MIPS_MTX1
+	bool "Support for 4G Systems MTX-1 board"
 	select DMA_NONCOHERENT
-	help
-	  This is a machine with a R4400 133/150 MHz CPU. To compile a Linux
-	  kernel that runs on these, say Y here. For details about Linux on
-	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
-	  <http://www.linux-mips.org/>.
+	select HW_HAS_PCI
+	select SOC_AU1500
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config MIPS_MAGNUM_4000
-	bool "Support for MIPS Magnum 4000"
-	depends on MACH_JAZZ
+config MIPS_BOSPORUS
+	bool "AMD Alchemy Bosporus board"
+	select SOC_AU1500
 	select DMA_NONCOHERENT
-	help
-	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
-	  kernel that runs on these, say Y here. For details about Linux on
-	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
-	  <http://www.linux-mips.org/>.
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config OLIVETTI_M700
-	bool "Support for Olivetti M700-10"
-	depends on MACH_JAZZ
+config MIPS_PB1000
+	bool "AMD Alchemy PB1000 board"
+	select SOC_AU1000
 	select DMA_NONCOHERENT
-	help
-	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
-	  kernel that runs on these, say Y here. For details about Linux on
-	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
-	  <http://www.linux-mips.org/>.
-
-config MACH_VR41XX
-	bool "Support for NEC VR41XX-based machines"
+	select HW_HAS_PCI
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config NEC_CMBVR4133
-	bool "Support for NEC CMB-VR4133"
-	depends on MACH_VR41XX
-	select CPU_VR41XX
+config MIPS_PB1100
+	bool "AMD Alchemy PB1100 board"
+	select SOC_AU1100
 	select DMA_NONCOHERENT
-	select IRQ_CPU
 	select HW_HAS_PCI
-	select PCI_VR41XX
-
-config ROCKHOPPER
-	bool "Support for Rockhopper baseboard"
-	depends on NEC_CMBVR4133
-	select I8259
-	select HAVE_STD_PC_SERIAL_PORT
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config CASIO_E55
-	bool "Support for CASIO CASSIOPEIA E-10/15/55/65"
-	depends on MACH_VR41XX
+config MIPS_PB1500
+	bool "AMD Alchemy PB1500 board"
+	select SOC_AU1500
 	select DMA_NONCOHERENT
-	select IRQ_CPU
-	select ISA
+	select HW_HAS_PCI
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config IBM_WORKPAD
-	bool "Support for IBM WorkPad z50"
-	depends on MACH_VR41XX
+config MIPS_PB1550
+	bool "AMD Alchemy PB1550 board"
+	select SOC_AU1550
 	select DMA_NONCOHERENT
-	select IRQ_CPU
-	select ISA
+	select HW_HAS_PCI
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config TANBAC_TB0226
-	bool "Support for TANBAC TB0226 (Mbase)"
-	depends on MACH_VR41XX
+config MIPS_PB1200
+	bool "AMD Alchemy PB1200 board"
+	select SOC_AU1200
 	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	help
-	  The TANBAC TB0226 (Mbase) is a MIPS-based platform manufactured by TANBAC.
-	  Please refer to <http://www.tanbac.co.jp/> about Mbase.
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config TANBAC_TB0229
-	bool "Support for TANBAC TB0229 (VR4131DIMM)"
-	depends on MACH_VR41XX
+config MIPS_DB1000
+	bool "AMD Alchemy DB1000 board"
+	select SOC_AU1000
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select IRQ_CPU
-	help
-	  The TANBAC TB0229 (VR4131DIMM) is a MIPS-based platform manufactured by TANBAC.
-	  Please refer to <http://www.tanbac.co.jp/> about VR4131DIMM.
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config TANBAC_TB0219
-	bool "Added TANBAC TB0219 Base board support"
-	depends on TANBAC_TB0229
-
-config VICTOR_MPC30X
-	bool "Support for Victor MP-C303/304"
+config MIPS_DB1100
+	bool "AMD Alchemy DB1100 board"
+	select SOC_AU1100
 	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	depends on MACH_VR41XX
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config ZAO_CAPCELLA
-	bool "Support for ZAO Networks Capcella"
-	depends on MACH_VR41XX
+config MIPS_DB1500
+	bool "AMD Alchemy DB1500 board"
+	select SOC_AU1500
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
-	select IRQ_CPU
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config PCI_VR41XX
-	bool "Add PCI control unit support of NEC VR4100 series"
-	depends on MACH_VR41XX && PCI
-
-config VRC4171
-	tristate "Add NEC VRC4171 companion chip support"
-	depends on MACH_VR41XX && ISA
-	---help---
-	  The NEC VRC4171/4171A is a companion chip for NEC VR4111/VR4121.
+config MIPS_DB1550
+	bool "AMD Alchemy DB1550 board"
+	select SOC_AU1550
+	select HW_HAS_PCI
+	select DMA_NONCOHERENT
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config VRC4173
-	tristate "Add NEC VRC4173 companion chip support"
-	depends on MACH_VR41XX && PCI_VR41XX
-	---help---
-	  The NEC VRC4173 is a companion chip for NEC VR4122/VR4131.
+config MIPS_DB1200
+	bool "AMD Alchemy DB1200 board"
+	select SOC_AU1200
+	select DMA_NONCOHERENT
+	select MIPS_DISABLE_OBSOLETE_IDE
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
-config TOSHIBA_JMR3927
-	bool "Support for Toshiba JMR-TX3927 board"
-	depends on MIPS32
+config MIPS_MIRAGE
+	bool "AMD Alchemy Mirage board"
 	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select SWAP_IO_SPACE
+	select SOC_AU1500
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_COBALT
-	bool "Support for Cobalt Server (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
+	bool "Support for Cobalt Server"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select I8259
 	select IRQ_CPU
+	select MIPS_GT64111
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MACH_DECSTATION
 	bool "Support for DECstations"
 	select BOOT_ELF32
 	select DMA_NONCOHERENT
+	select EARLY_PRINTK
 	select IRQ_CPU
-	depends on MIPS32 || EXPERIMENTAL
-	---help---
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
 	  This enables support for DEC's MIPS based workstations.  For details
 	  see the Linux/MIPS FAQ on <http://www.linux-mips.org/> and the
 	  DECstation porting pages on <http://decstation.unix-ag.org/>.
@@ -194,6 +148,9 @@ config MIPS_EV64120
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select MIPS_GT64120
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This is an evaluation board based on the Galileo GT-64120
 	  single-chip system controller that contains a MIPS R5000 compatible
@@ -201,10 +158,6 @@ config MIPS_EV64120
 	  <http://www.marvell.com/>.  Say Y here if you wish to build a
 	  kernel for this platform.
 
-config EVB_PCI1
-	bool "Enable Second PCI (PCI1)"
-	depends on MIPS_EV64120
-
 config MIPS_EV96100
 	bool "Support for Galileo EV96100 Evaluation board (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
@@ -214,6 +167,9 @@ config MIPS_EV96100
 	select MIPS_GT96100
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This is an evaluation board based on the Galileo GT-96100 LAN/WAN
 	  communications controllers containing a MIPS R5000 compatible core
@@ -224,6 +180,10 @@ config MIPS_IVR
 	bool "Support for Globespan IVR board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select ITE_BOARD_GEN
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This is an evaluation board built by Globespan to showcase thir
 	  iVR (Internet Video Recorder) design. It utilizes a QED RM5231
@@ -231,33 +191,14 @@ config MIPS_IVR
 	  located at <http://www.globespan.net/>. Say Y here if you wish to
 	  build a kernel for this platform.
 
-config LASAT
-	bool "Support for LASAT Networks platforms"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select MIPS_GT64120
-	select R5000_CPU_SCACHE
-
-config PICVUE
-	tristate "PICVUE LCD display driver"
-	depends on LASAT
-
-config PICVUE_PROC
-	tristate "PICVUE LCD display driver /proc interface"
-	depends on PICVUE
-
-config DS1603
-	bool "DS1603 RTC driver"
-	depends on LASAT
-
-config LASAT_SYSCTL
-	bool "LASAT sysctl interface"
-	depends on LASAT
-
 config MIPS_ITE8172
 	bool "Support for ITE 8172G board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select ITE_BOARD_GEN
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  Ths is an evaluation board made by ITE <http://www.ite.com.tw/>
 	  with ATX form factor that utilizes a MIPS R5000 to work with its
@@ -265,24 +206,49 @@ config MIPS_ITE8172
 	  either a NEC Vr5432 or QED RM5231. Say Y here if you wish to build
 	  a kernel for this platform.
 
-config IT8172_REVC
-	bool "Support for older IT8172 (Rev C)"
-	depends on MIPS_ITE8172
+config MACH_JAZZ
+	bool "Support for the Jazz family of machines"
+	select ARC
+	select ARC32
+	select GENERIC_ISA_DMA
+	select I8259
+	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
 	help
-	  Say Y here to support the older, Revision C version of the Integrated
-	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
-	  <http://www.ite.com.tw/ia/brief_it8172bsp.htm>; picture of the
-	  board at <http://www.mvista.com/partners/semiconductor/ite.html>.
+	 This a family of machines based on the MIPS R4030 chipset which was
+	 used by several vendors to build RISC/os and Windows NT workstations.
+	 Members include the Acer PICA, MIPS Magnum 4000, MIPS Millenium and
+	 Olivetti M700-10 workstations.
+
+config LASAT
+	bool "Support for LASAT Networks platforms"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select MIPS_GT64120
+	select MIPS_NILE4
+	select R5000_CPU_SCACHE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config MIPS_ATLAS
 	bool "Support for MIPS Atlas board"
 	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select MIPS_BOARDS_GEN
+	select MIPS_BONITO64
 	select MIPS_GT64120
+	select MIPS_MSC
+	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
-	  This enables support for the QED R5231-based MIPS Atlas evaluation
+	  This enables support for the MIPS Technologies Atlas evaluation
 	  board.
 
 config MIPS_MALTA
@@ -293,10 +259,17 @@ config MIPS_MALTA
 	select GENERIC_ISA_DMA
 	select HW_HAS_PCI
 	select I8259
+	select MIPS_BOARDS_GEN
+	select MIPS_BONITO64
 	select MIPS_GT64120
+	select MIPS_MSC
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
-	  This enables support for the VR5000-based MIPS Malta evaluation
+	  This enables support for the MIPS Technologies Malta evaluation
 	  board.
 
 config MIPS_SEAD
@@ -304,42 +277,46 @@ config MIPS_SEAD
 	depends on EXPERIMENTAL
 	select IRQ_CPU
 	select DMA_NONCOHERENT
-
-config MOMENCO_OCELOT
-	bool "Support for Momentum Ocelot board"
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select IRQ_CPU
-	select IRQ_CPU_RM7K
-	select MIPS_GT64120
-	select RM7000_CPU_SCACHE
-	select SWAP_IO_SPACE
+	select MIPS_BOARDS_GEN
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
-	  Momentum Computer <http://www.momenco.com/>.
+	  This enables support for the MIPS Technologies SEAD evaluation
+	  board.
 
-config MOMENCO_OCELOT_G
-	bool "Support for Momentum Ocelot-G board"
+config MOMENCO_JAGUAR_ATX
+	bool "Support for Momentum Jaguar board"
+	select BOOT_ELF32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
+	select IRQ_MV64340
+	select LIMITED_DMA
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
-	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
+	  The Jaguar ATX is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
 
-config MOMENCO_OCELOT_C
-	bool "Support for Momentum Ocelot-C board"
+config MOMENCO_OCELOT
+	bool "Support for Momentum Ocelot board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
-	select IRQ_MV64340
-	select PCI_MARVELL
+	select IRQ_CPU_RM7K
+	select MIPS_GT64120
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
@@ -355,70 +332,80 @@ config MOMENCO_OCELOT_3
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  The Ocelot-3 is based off Discovery III System Controller and
 	  PMC-Sierra Rm79000 core.
 
-config MOMENCO_JAGUAR_ATX
-	bool "Support for Momentum Jaguar board"
-	select BOOT_ELF32
+config MOMENCO_OCELOT_C
+	bool "Support for Momentum Ocelot-C board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
-	select IRQ_CPU_RM7K
 	select IRQ_MV64340
-	select LIMITED_DMA
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
-	  The Jaguar ATX is a MIPS-based Single Board Computer (SBC) made by
+	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
 
-config JAGUAR_DMALOW
-	bool "Low DMA Mode"
-	depends on MOMENCO_JAGUAR_ATX
-	help
-	  Select to Y if jump JP5 is set on your board, N otherwise.  Normally
-	  the jumper is set, so if you feel unsafe, just say Y.
-
-config PMC_YOSEMITE
-	bool "Support for PMC-Sierra Yosemite eval board"
-	select DMA_COHERENT
+config MOMENCO_OCELOT_G
+	bool "Support for Momentum Ocelot-G board"
+	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
-	select IRQ_CPU_RM9K
+	select PCI_MARVELL
+	select RM7000_CPU_SCACHE
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
-	  Yosemite is an evaluation board for the RM9000x2 processor
-	  manufactured by PMC-Sierra
+	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
+	  Momentum Computer <http://www.momenco.com/>.
 
-config HYPERTRANSPORT
-	bool "Hypertransport Support for PMC-Sierra Yosemite"
-	depends on PMC_YOSEMITE
+config MIPS_XXS1500
+	bool "Support for MyCable XXS1500 board"
+	select DMA_NONCOHERENT
+	select SOC_AU1500
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config DDB5074
 	bool "Support for NEC DDB Vrc-5074 (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
+	select DDB5XXX_COMMON
 	select DMA_NONCOHERENT
 	select HAVE_STD_PC_SERIAL_PORT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select I8259
 	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This enables support for the VR5000-based NEC DDB Vrc-5074
 	  evaluation board.
 
 config DDB5476
 	bool "Support for NEC DDB Vrc-5476"
+	select DDB5XXX_COMMON
 	select DMA_NONCOHERENT
 	select HAVE_STD_PC_SERIAL_PORT
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select I8259
 	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This enables support for the R5432-based NEC DDB Vrc-5476
 	  evaluation board.
@@ -429,10 +416,14 @@ config DDB5476
 
 config DDB5477
 	bool "Support for NEC DDB Vrc-5477"
+	select DDB5XXX_COMMON
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select I8259
 	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  This enables support for the R5432-based NEC DDB Vrc-5477,
 	  or Rockhopper/SolutionGear boards with R5432/R5500 CPUs.
@@ -440,15 +431,32 @@ config DDB5477
 	  Features : kernel debugging, serial terminal, NFS root fs, on-board
 	  ether port USB, AC97, PCI, etc.
 
-config DDB5477_BUS_FREQUENCY
-	int "bus frequency (in kHZ, 0 for auto-detect)"
-	depends on DDB5477
-	default 0
-
 config NEC_OSPREY
 	bool "Support for NEC Osprey board"
 	select DMA_NONCOHERENT
 	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select VR4181
+
+config MACH_VR41XX
+	bool "Support for NEC VR41XX-based machines"
+
+config PMC_YOSEMITE
+	bool "Support for PMC-Sierra Yosemite eval board"
+	select DMA_COHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select IRQ_CPU_RM7K
+	select IRQ_CPU_RM9K
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	help
+	  Yosemite is an evaluation board for the RM9000x2 processor
+	  manufactured by PMC-Sierra.
 
 config SGI_IP22
 	bool "Support for SGI IP22 (Indy/Indigo2)"
@@ -456,9 +464,13 @@ config SGI_IP22
 	select ARC32
 	select BOOT_ELF32
 	select DMA_NONCOHERENT
+	select HW_HAS_EISA
 	select IP22_CPU_SCACHE
 	select IRQ_CPU
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
 	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
@@ -466,75 +478,23 @@ config SGI_IP22
 
 config SGI_IP27
 	bool "Support for SGI IP27 (Origin200/2000)"
-	depends on MIPS64
 	select ARC
 	select ARC64
+	select BOOT_ELF64
 	select DMA_IP27
 	select HW_HAS_PCI
 	select PCI_DOMAINS
+	select QL_ISP_A64
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
 	  workstations.  To compile a Linux kernel that runs on these, say Y
 	  here.
 
-#config SGI_SN0_XXL
-#	bool "IP27 XXL"
-#	depends on SGI_IP27
-#	  This options adds support for userspace processes upto 16TB size.
-#	  Normally the limit is just .5TB.
-
-config SGI_SN0_N_MODE
-	bool "IP27 N-Mode"
-	depends on SGI_IP27
-	help
-	  The nodes of Origin 200, Origin 2000 and Onyx 2 systems can be
-	  configured in either N-Modes which allows for more nodes or M-Mode
-	  which allows for more memory.  Your system is most probably
-	  running in M-Mode, so you should say N here.
-
-config DISCONTIGMEM
-	bool
-	default y if SGI_IP27
-	help
-	  Say Y to upport efficient handling of discontiguous physical memory,
-	  for architectures which are either NUMA (Non-Uniform Memory Access)
-	  or have huge holes in the physical address space for other reasons.
-	  See <file:Documentation/vm/numa> for more.
-
-config NUMA
-	bool "NUMA Support"
-	depends on SGI_IP27
-	help
-	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
-	  Access).  This option is for configuring high-end multiprocessor
-	  server machines.  If in doubt, say N.
-
-config MAPPED_KERNEL
-	bool "Mapped kernel support"
-	depends on SGI_IP27
-	help
-	  Change the way a Linux kernel is loaded into memory on a MIPS64
-	  machine.  This is required in order to support text replication and
-	  NUMA.  If you need to understand it, read the source code.
-
-config REPLICATE_KTEXT
-	bool "Kernel text replication support"
-	depends on SGI_IP27
-	help
-	  Say Y here to enable replicating the kernel text across multiple
-	  nodes in a NUMA cluster.  This trades memory for speed.
-
-config REPLICATE_EXHANDLERS
-	bool "Exception handler replication support"
-	depends on SGI_IP27
-	help
-	  Say Y here to enable replicating the kernel exception handlers
-	  across multiple nodes in a NUMA cluster. This trades memory for
-	  speed.
-
 config SGI_IP32
 	bool "Support for SGI IP32 (O2) (EXPERIMENTAL)"
-	depends on MIPS64 && EXPERIMENTAL
+	depends on EXPERIMENTAL
 	select ARC
 	select ARC32
 	select BOOT_ELF32
@@ -544,330 +504,89 @@ config SGI_IP32
 	select HW_HAS_PCI
 	select R5000_CPU_SCACHE
 	select RM7000_CPU_SCACHE
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
 	help
 	  If you want this kernel to run on SGI O2 workstation, say Y here.
 
-config SOC_AU1X00
-	depends on MIPS32
-	bool "Support for AMD/Alchemy Au1X00 SOCs"
-
-choice
-	prompt "Au1X00 SOC Type"
-	depends on SOC_AU1X00
-	help
-	  Say Y here to enable support for one of three AMD/Alchemy
-	  SOCs. For additional documentation see www.amd.com.
-
-config SOC_AU1000
-	bool "SOC_AU1000"
-config SOC_AU1100
-	bool "SOC_AU1100"
-config SOC_AU1500
-	bool "SOC_AU1500"
-config SOC_AU1550
-	bool "SOC_AU1550"
-
-endchoice
-
-choice
-	prompt "AMD/Alchemy Au1x00 board support"
-	depends on SOC_AU1X00
-	help
-	  These are evaluation boards built by AMD/Alchemy to
-	  showcase their Au1X00 Internet Edge Processors. The SOC design
-	  is based on the MIPS32 architecture running at 266/400/500MHz
-	  with many integrated peripherals. Further information can be
-	  found at their website, <http://www.amd.com/>. Say Y here if you
-	  wish to build a kernel for this platform.
-
-config MIPS_PB1000
-	bool "PB1000 board"
-	depends on SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select SWAP_IO_SPACE
-
-config MIPS_PB1100
-	bool "PB1100 board"
-	depends on SOC_AU1100
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-	select SWAP_IO_SPACE
-
-config MIPS_PB1500
-	bool "PB1500 board"
-	depends on SOC_AU1500
-	select DMA_COHERENT
-	select HW_HAS_PCI
-
-config MIPS_PB1550
-	bool "PB1550 board"
-	depends on SOC_AU1550
-	select DMA_COHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-
-config MIPS_DB1000
-	bool "DB1000 board"
-	depends on SOC_AU1000
-	select DMA_NONCOHERENT
-	select HW_HAS_PCI
-
-config MIPS_DB1100
-	bool "DB1100 board"
-	depends on SOC_AU1100
-	select DMA_NONCOHERENT
-
-config MIPS_DB1500
-	bool "DB1500 board"
-	depends on SOC_AU1500
-	select DMA_COHERENT
-	select HW_HAS_PCI
-	select MIPS_DISABLE_OBSOLETE_IDE
-
-config MIPS_DB1550
-	bool "DB1550 board"
-	depends on SOC_AU1550
-	select HW_HAS_PCI
-	select DMA_COHERENT
-	select MIPS_DISABLE_OBSOLETE_IDE
-
-config MIPS_BOSPORUS
-	bool "Bosporus board"
-	depends on SOC_AU1500
-	select DMA_NONCOHERENT
-
-config MIPS_MIRAGE
-	bool "Mirage board"
-	depends on SOC_AU1500
-	select DMA_NONCOHERENT
-
-config MIPS_XXS1500
-	bool "MyCable XXS1500 board"
-	depends on SOC_AU1500
-	select DMA_NONCOHERENT
-
-config MIPS_MTX1
-	bool "4G Systems MTX-1 board"
-	depends on SOC_AU1500
-	select HW_HAS_PCI
-	select DMA_NONCOHERENT
-
-endchoice
-
-config SIBYTE_SB1xxx_SOC
-	bool "Support for Broadcom BCM1xxx SOCs (EXPERIMENTAL)"
-	depends on EXPERIMENTAL
+config SIBYTE_SWARM
+	bool "Support for Sibyte BCM91250A-SWARM"
 	select BOOT_ELF32
 	select DMA_COHERENT
-	select SWAP_IO_SPACE
-
-choice
-	prompt "BCM1xxx SOC-based board"
-	depends on SIBYTE_SB1xxx_SOC
-	default SIBYTE_SWARM
-	help
-	  Enable support for boards based on the SiByte line of SOCs
-	  from Broadcom.  There are configurations for the known
-	  evaluation boards, or you can choose "Other" and add your
-	  own board support code.
-
-config SIBYTE_SWARM
-	bool "BCM91250A-SWARM"
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_SENTOSA
-	bool "BCM91250E-Sentosa"
+	bool "Support for Sibyte BCM91250E-Sentosa"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_RHONE
-	bool "BCM91125E-Rhone"
+	bool "Support for Sibyte BCM91125E-Rhone"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1125H
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_CARMEL
-	bool "BCM91120x-Carmel"
+	bool "Support for Sibyte BCM91120x-Carmel"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1120
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_PTSWARM
-	bool "BCM91250PT-PTSWARM"
+	bool "Support for Sibyte BCM91250PT-PTSWARM"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_LITTLESUR
-	bool "BCM91250C2-LittleSur"
+	bool "Support for Sibyte BCM91250C2-LittleSur"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_SB1250
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_CRHINE
-	bool "BCM91120C-CRhine"
+	bool "Support for Sibyte BCM91120C-CRhine"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1120
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SIBYTE_CRHONE
-	bool "BCM91125C-CRhone"
-	select SIBYTE_BCM1125
-
-config SIBYTE_UNKNOWN
-	bool "Other"
-
-endchoice
-
-config SIBYTE_BOARD
-	bool
-	depends on SIBYTE_SB1xxx_SOC && !SIBYTE_UNKNOWN
-	default y
-
-choice
-	prompt "BCM1xxx SOC Type"
-	depends on SIBYTE_UNKNOWN
-	default SIBYTE_UNK_BCM1250
-	help
-	  Since you haven't chosen a known evaluation board from
-	  Broadcom, you must explicitly pick the SOC this kernel is
-	  targetted for.
-
-config SIBYTE_UNK_BCM1250
-	bool "BCM1250"
-	select SIBYTE_SB1250
-
-config SIBYTE_UNK_BCM1120
-	bool "BCM1120"
-	select SIBYTE_BCM1120
-
-config SIBYTE_UNK_BCM1125
-	bool "BCM1125"
+	bool "Support for Sibyte BCM91125C-CRhone"
+	depends on EXPERIMENTAL
+	select BOOT_ELF32
+	select DMA_COHERENT
 	select SIBYTE_BCM1125
-
-config SIBYTE_UNK_BCM1125H
-	bool "BCM1125H"
-	select SIBYTE_BCM1125H
-
-endchoice
-
-config SIBYTE_SB1250
-	bool
-	select HW_HAS_PCI
-
-config SIBYTE_BCM1120
-	bool
-	select SIBYTE_BCM112X
-
-config SIBYTE_BCM1125
-	bool
-	select HW_HAS_PCI
-	select SIBYTE_BCM112X
-
-config SIBYTE_BCM1125H
-	bool
-	select HW_HAS_PCI
-	select SIBYTE_BCM112X
-
-config SIBYTE_BCM112X
-	bool
-
-choice
-	prompt "SiByte SOC Stepping"
-	depends on SIBYTE_SB1xxx_SOC
-
-config CPU_SB1_PASS_1
-	bool "1250 Pass1"
-	depends on SIBYTE_SB1250
-	select CPU_HAS_PREFETCH
-
-config CPU_SB1_PASS_2_1250
-	bool "1250 An"
-	depends on SIBYTE_SB1250
-	select CPU_SB1_PASS_2
-	help
-	  Also called BCM1250 Pass 2
-
-config CPU_SB1_PASS_2_2
-	bool "1250 Bn"
-	depends on SIBYTE_SB1250
-	select CPU_HAS_PREFETCH
-	help
-	  Also called BCM1250 Pass 2.2
-
-config CPU_SB1_PASS_4
-	bool "1250 Cn"
-	depends on SIBYTE_SB1250
-	select CPU_HAS_PREFETCH
-	help
-	  Also called BCM1250 Pass 3
-
-config CPU_SB1_PASS_2_112x
-	bool "112x Hybrid"
-	depends on SIBYTE_BCM112X
-	select CPU_SB1_PASS_2
-
-config CPU_SB1_PASS_3
-	bool "112x An"
-	depends on SIBYTE_BCM112X
-	select CPU_HAS_PREFETCH
-
-endchoice
-
-config CPU_SB1_PASS_2
-	bool
-
-config SIBYTE_HAS_LDT
-	bool
-	depends on PCI && (SIBYTE_SB1250 || SIBYTE_BCM1125H)
-	default y
-
-config SIMULATION
-	bool "Running under simulation"
-	depends on SIBYTE_SB1xxx_SOC
-	help
-	  Build a kernel suitable for running under the GDB simulator.
-	  Primarily adjusts the kernel's notion of time.
-
-config SIBYTE_CFE
-	bool "Booting from CFE"
-	depends on SIBYTE_SB1xxx_SOC
-	help
-	  Make use of the CFE API for enumerating available memory,
-	  controlling secondary CPUs, and possibly console output.
-
-config SIBYTE_CFE_CONSOLE
-	bool "Use firmware console"
-	depends on SIBYTE_CFE
-	help
-	  Use the CFE API's console write routines during boot.  Other console
-	  options (VT console, sb1250 duart console, etc.) should not be
-	  configured.
-
-config SIBYTE_STANDALONE
-	bool
-	depends on SIBYTE_SB1xxx_SOC && !SIBYTE_CFE
-	default y
-
-config SIBYTE_STANDALONE_RAM_SIZE
-	int "Memory size (in megabytes)"
-	depends on SIBYTE_STANDALONE
-	default "32"
-
-config SIBYTE_BUS_WATCHER
-	bool "Support for Bus Watcher statistics"
-	depends on SIBYTE_SB1xxx_SOC
-	help
-	  Handle and keep statistics on the bus error interrupts (COR_ECC,
-	  BAD_ECC, IO_BUS).
-
-config SIBYTE_BW_TRACE
-	bool "Capture bus trace before bus error"
-	depends on SIBYTE_BUS_WATCHER
-	help
-	  Run a continuous bus trace, dumping the raw data as soon as
-	  a ZBbus error is detected.  Cannot work if ZBbus profiling
-	  is turned on, and also will interfere with JTAG-based trace
-	  buffer activity.  Raw buffer data is dumped to console, and
-	  must be processed off-line.
-
-config SIBYTE_SB1250_PROF
-	bool "Support for SB1/SOC profiling - SB1/SCD perf counters"
-	depends on SIBYTE_SB1xxx_SOC
-
-config SIBYTE_TBPROF
-	bool "Support for ZBbus profiling"
-	depends on SIBYTE_SB1xxx_SOC
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 
 config SNI_RM200_PCI
 	bool "Support for SNI RM200 PCI"
@@ -877,31 +596,61 @@ config SNI_RM200_PCI
 	select DMA_NONCOHERENT
 	select GENERIC_ISA_DMA
 	select HAVE_STD_PC_SERIAL_PORT
+	select HW_HAS_EISA
 	select HW_HAS_PCI
 	select I8259
 	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_BIG_ENDIAN if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
 	help
 	  The SNI RM200 PCI was a MIPS-based platform manufactured by Siemens
 	  Nixdorf Informationssysteme (SNI), parent company of Pyramid
 	  Technology and now in turn merged with Fujitsu.  Say Y here to
 	  support this machine type.
 
+config TOSHIBA_JMR3927
+	bool "Support for Toshiba JMR-TX3927 board"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select MIPS_TX3927
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select TOSHIBA_BOARDS
+
 config TOSHIBA_RBTX4927
 	bool "Support for Toshiba TBTX49[23]7 board"
-	depends on MIPS32
 	select DMA_NONCOHERENT
 	select HAS_TXX9_SERIAL
 	select HW_HAS_PCI
 	select I8259
 	select ISA
 	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select TOSHIBA_BOARDS
 	help
 	  This Toshiba board is based on the TX4927 processor. Say Y here to
 	  support this machine type
 
-config TOSHIBA_FPCIB0
-	bool "FPCIB0 Backplane Support"
-	depends on TOSHIBA_RBTX4927
+endchoice
+
+source "arch/mips/ddb5xxx/Kconfig"
+source "arch/mips/gt64120/ev64120/Kconfig"
+source "arch/mips/jazz/Kconfig"
+source "arch/mips/ite-boards/Kconfig"
+source "arch/mips/lasat/Kconfig"
+source "arch/mips/momentum/Kconfig"
+source "arch/mips/pmc-sierra/Kconfig"
+source "arch/mips/sgi-ip27/Kconfig"
+source "arch/mips/sibyte/Kconfig"
+source "arch/mips/tx4927/Kconfig"
+source "arch/mips/vr41xx/Kconfig"
+
+endmenu
 
 config RWSEM_GENERIC_SPINLOCK
 	bool
@@ -923,32 +672,30 @@ config HAVE_DEC_LOCK
 #
 config ARC
 	bool
-	depends on SNI_RM200_PCI || SGI_IP32 || SGI_IP27 || SGI_IP22 || MIPS_MAGNUM_4000 || OLIVETTI_M700 || ACER_PICA_61
-	default y
 
-config	DMA_COHERENT
+config DMA_COHERENT
+	bool
+
+config DMA_IP27
 	bool
 
-config	DMA_IP27
+config DMA_IP32
 	bool
 
-config	DMA_NONCOHERENT
+config OWN_DMA
+	bool
+
+config DMA_NONCOHERENT
 	bool
 
 config EARLY_PRINTK
 	bool
-	depends on MACH_DECSTATION
-	default y
 
 config GENERIC_ISA_DMA
 	bool
-	depends on SNI_RM200_PCI || MIPS_MAGNUM_4000 || OLIVETTI_M700 || ACER_PICA_61 || MIPS_MALTA
-	default y
 
 config I8259
 	bool
-	depends on SNI_RM200_PCI || DDB5477 || DDB5476 || DDB5074 || MACH_JAZZ || MIPS_MALTA || MIPS_COBALT
-	default y
 
 config LIMITED_DMA
 	bool
@@ -956,30 +703,46 @@ config LIMITED_DMA
 
 config MIPS_BONITO64
 	bool
-	depends on MIPS_ATLAS || MIPS_MALTA
-	default y
 
 config MIPS_MSC
 	bool
-	depends on MIPS_ATLAS || MIPS_MALTA
-	default y
 
 config MIPS_NILE4
 	bool
-	depends on LASAT
-	default y
 
 config MIPS_DISABLE_OBSOLETE_IDE
 	bool
 
-config CPU_LITTLE_ENDIAN
-	bool "Generate little endian code"
-	default y if ACER_PICA_61 || CASIO_E55 || DDB5074 || DDB5476 || DDB5477 || MACH_DECSTATION || IBM_WORKPAD || LASAT || MIPS_COBALT || MIPS_ITE8172 || MIPS_IVR || SOC_AU1X00 || NEC_OSPREY || OLIVETTI_M700 || SNI_RM200_PCI || VICTOR_MPC30X || ZAO_CAPCELLA
-	default n if MIPS_EV64120 || MIPS_EV96100 || MOMENCO_OCELOT || MOMENCO_OCELOT_G || SGI_IP22 || SGI_IP27 || SGI_IP32 || TOSHIBA_JMR3927
+#
+# Endianess selection.  Suffiently obscure so many users don't know what to
+# answer,so we try hard to limit the available choices.  Also the use of a
+# choice statement should be more obvious to the user.
+#
+choice
+	prompt "Endianess selection"
 	help
 	  Some MIPS machines can be configured for either little or big endian
-	  byte order. These modes require different kernels. Say Y if your
-	  machine is little endian, N if it's a big endian machine.
+	  byte order. These modes require different kernels and a different
+	  Linux distribution.  In general there is one prefered byteorder for a
+	  particular system but some systems are just as commonly used in the
+	  one or the other endianess.
+
+config CPU_BIG_ENDIAN
+	bool "Big endian"
+	depends on SYS_SUPPORTS_BIG_ENDIAN
+
+config CPU_LITTLE_ENDIAN
+	bool "Little endian"
+	depends on SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+
+endchoice
+
+config SYS_SUPPORTS_BIG_ENDIAN
+	bool
+
+config SYS_SUPPORTS_LITTLE_ENDIAN
+	bool
 
 config IRQ_CPU
 	bool
@@ -987,42 +750,57 @@ config IRQ_CPU
 config IRQ_CPU_RM7K
 	bool
 
+config IRQ_CPU_RM9K
+	bool
+
 config IRQ_MV64340
 	bool
 
 config DDB5XXX_COMMON
 	bool
-	depends on DDB5074 || DDB5476 || DDB5477
-	default y
 
 config MIPS_BOARDS_GEN
 	bool
-	depends on MIPS_ATLAS || MIPS_MALTA || MIPS_SEAD
-	default y
 
 config MIPS_GT64111
 	bool
-	depends on MIPS_COBALT
-	default y
 
 config MIPS_GT64120
 	bool
-	depends on MIPS_EV64120 || MIPS_EV96100 || LASAT || MIPS_ATLAS || MIPS_MALTA || MOMENCO_OCELOT
-	default y
 
 config MIPS_TX3927
 	bool
-	depends on TOSHIBA_JMR3927
 	select HAS_TXX9_SERIAL
-	default y
 
 config PCI_MARVELL
 	bool
 
 config ITE_BOARD_GEN
 	bool
-	depends on MIPS_IVR || MIPS_ITE8172
-	default y
+
+config SOC_AU1000
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1100
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1500
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1550
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1200
+	bool
+	select SOC_AU1X00
+
+config SOC_AU1X00
+	bool
+	select SYS_SUPPORTS_32BIT_KERNEL
 
 config SWAP_IO_SPACE
 	bool
@@ -1049,6 +827,9 @@ config SYSCLK_100
 
 endchoice
 
+config ARC32
+	bool
+
 config AU1X00_USB_DEVICE
 	bool
 	depends on MIPS_PB1500 || MIPS_PB1100 || MIPS_PB1000
@@ -1056,11 +837,7 @@ config AU1X00_USB_DEVICE
 
 config MIPS_GT96100
 	bool
-	depends on MIPS_EV96100
-	default y
-	help
-	  Say Y here to support the Galileo Technology GT96100 communications
-	  controller card.  There is a web page at <http://www.galileot.com/>.
+	select MIPS_GT64120
 
 config IT8172_CIR
 	bool
@@ -1074,8 +851,6 @@ config IT8712
 
 config BOOT_ELF32
 	bool
-	depends on MACH_DECSTATION || MIPS_ATLAS || MIPS_MALTA || MOMENCO_JAGUAR_ATX || MOMENCO_OCELOT_3 || SIBYTE_SB1xxx_SOC || SGI_IP32 || SGI_IP22 || SNI_RM200_PCI
-	default y
 
 config MIPS_L1_CACHE_SHIFT
 	int
@@ -1083,53 +858,11 @@ config MIPS_L1_CACHE_SHIFT
 	default "7" if SGI_IP27
 	default "5"
 
-config ARC32
-	bool
-	depends on MACH_JAZZ || SNI_RM200_PCI || SGI_IP22 || SGI_IP32
-	default y
-
-config FB
-	bool
-	depends on MIPS_MAGNUM_4000 || OLIVETTI_M700
-	default y
-	---help---
-	  The frame buffer device provides an abstraction for the graphics
-	  hardware. It represents the frame buffer of some video hardware and
-	  allows application software to access the graphics hardware through
-	  a well-defined interface, so the software doesn't need to know
-	  anything about the low-level (hardware register) stuff.
-
-	  Frame buffer devices work identically across the different
-	  architectures supported by Linux and make the implementation of
-	  application programs easier and more portable; at this point, an X
-	  server exists which uses the frame buffer device exclusively.
-	  On several non-X86 architectures, the frame buffer device is the
-	  only way to use the graphics hardware.
-
-	  The device is accessed through special device nodes, usually located
-	  in the /dev directory, i.e. /dev/fb*.
-
-	  You need an utility program called fbset to make full use of frame
-	  buffer devices. Please read <file:Documentation/fb/framebuffer.txt>
-	  and the Framebuffer-HOWTO at <http://www.tldp.org/docs.html#howto>
-	  for more information.
-
-	  Say Y here and to the driver for your graphics board below if you
-	  are compiling a kernel for a non-x86 architecture.
-
-	  If you are compiling for the x86 architecture, you can say Y if you
-	  want to play with it, but it is not essential. Please note that
-	  running graphical applications that directly touch the hardware
-	  (e.g. an accelerated X server) and that are not frame buffer
-	  device-aware may cause unexpected results. If unsure, say N.
-
 config HAVE_STD_PC_SERIAL_PORT
 	bool
 
 config VR4181
 	bool
-	depends on NEC_OSPREY
-	default y
 
 config ARC_CONSOLE
 	bool "ARC console support"
@@ -1147,30 +880,15 @@ config ARC_PROMLIB
 
 config ARC64
 	bool
-	depends on SGI_IP27
-	default y
 
 config BOOT_ELF64
 	bool
-	depends on SGI_IP27
-	default y
-
-#config MAPPED_PCI_IO y
-#	bool
-#	depends on SGI_IP27
-#	default y
 
 config QL_ISP_A64
 	bool
-	depends on SGI_IP27
-	default y
 
 config TOSHIBA_BOARDS
 	bool
-	depends on TOSHIBA_JMR3927 || TOSHIBA_RBTX4927
-	default y
-
-endmenu
 
 menu "CPU selection"
 
@@ -1180,13 +898,18 @@ choice
 
 config CPU_MIPS32
 	bool "MIPS32"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_HAS_PREFETCH
 
 config CPU_MIPS64
 	bool "MIPS64"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+	select CPU_HAS_PREFETCH
 
 config CPU_R3000
 	bool "R3000"
-	depends on MIPS32
+	select CPU_SUPPORTS_32BIT_KERNEL
 	help
 	  Please make sure to pick the right CPU type. Linux/MIPS is not
 	  designed to be generic, i.e. Kernels compiled for R3000 CPUs will
@@ -1197,10 +920,12 @@ config CPU_R3000
 
 config CPU_TX39XX
 	bool "R39XX"
-	depends on MIPS32
+	select CPU_SUPPORTS_32BIT_KERNEL
 
 config CPU_VR41XX
 	bool "R41xx"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  The options selects support for the NEC VR41xx series of processors.
 	  Only choose this option if you have one of these processors as a
@@ -1209,61 +934,126 @@ config CPU_VR41XX
 
 config CPU_R4300
 	bool "R4300"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  MIPS Technologies R4300-series processors.
 
 config CPU_R4X00
 	bool "R4x00"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  MIPS Technologies R4000-series processors other than 4300, including
 	  the R4000, R4400, R4600, and 4700.
 
 config CPU_TX49XX
 	bool "R49XX"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 
 config CPU_R5000
 	bool "R5000"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  MIPS Technologies R5000-series processors other than the Nevada.
 
 config CPU_R5432
 	bool "R5432"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 
 config CPU_R6000
 	bool "R6000"
-	depends on MIPS32 && EXPERIMENTAL
+	depends on EXPERIMENTAL
+	select CPU_SUPPORTS_32BIT_KERNEL
 	help
 	  MIPS Technologies R6000 and R6000A series processors.  Note these
 	  processors are extremly rare and the support for them is incomplete.
 
 config CPU_NEVADA
 	bool "RM52xx"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  QED / PMC-Sierra RM52xx-series ("Nevada") processors.
 
 config CPU_R8000
 	bool "R8000"
-	depends on MIPS64 && EXPERIMENTAL
+	depends on EXPERIMENTAL
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  MIPS Technologies R8000 processors.  Note these processors are
 	  uncommon and the support for them is incomplete.
 
 config CPU_R10000
 	bool "R10000"
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 	help
 	  MIPS Technologies R10000-series processors.
 
 config CPU_RM7000
 	bool "RM7000"
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 
 config CPU_RM9000
 	bool "RM9000"
+	select CPU_HAS_PREFETCH
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
 
 config CPU_SB1
 	bool "SB1"
+	select CPU_SUPPORTS_32BIT_KERNEL
+	select CPU_SUPPORTS_64BIT_KERNEL
+
+endchoice
+
+endmenu
+
+config SYS_SUPPORTS_32BIT_KERNEL
+	bool
+config SYS_SUPPORTS_64BIT_KERNEL
+	bool
+config CPU_SUPPORTS_32BIT_KERNEL
+	bool
+config CPU_SUPPORTS_64BIT_KERNEL
+	bool
+
+menu "Kernel type"
+
+choice
+
+	prompt "Kernel code model"
+	help
+	  You should only select this option if you have a workload that
+	  actually benefits from 64-bit processing or if your machine has
+	  large memory.  You will only be presented a single option in this
+	  menu if your system does not support both 32-bit and 64-bit kernels.
+
+config MIPS32
+	bool "32-bit kernel"
+	depends on CPU_SUPPORTS_32BIT_KERNEL && SYS_SUPPORTS_32BIT_KERNEL
+	select TRAD_SIGNALS
+	help
+	  Select this option if you want to build a 32-bit kernel.
+config MIPS64
+	bool "64-bit kernel"
+	depends on CPU_SUPPORTS_64BIT_KERNEL && SYS_SUPPORTS_64BIT_KERNEL
+	help
+	  Select this option if you want to build a 64-bit kernel.
 
 endchoice
 
+config 64BIT
+	def_bool MIPS64
+
 choice
 	prompt "Kernel page size"
 	default PAGE_SIZE_4KB
@@ -1332,12 +1122,7 @@ config SIBYTE_DMA_PAGEOPS
 	  SiByte Linux port.  Seems to give a small performance benefit.
 
 config CPU_HAS_PREFETCH
-	bool "Enable prefetches" if CPU_SB1 && !CPU_SB1_PASS_2
-	default y if CPU_MIPS32 || CPU_MIPS64 || CPU_RM7000 || CPU_RM9000 || CPU_R10000
-
-config VTAG_ICACHE
-	bool "Support for Virtual Tagged I-cache" if CPU_MIPS64 || CPU_MIPS32
-	default y if CPU_SB1
+	bool
 
 config SB1_PASS_1_WORKAROUNDS
 	bool
@@ -1462,6 +1247,17 @@ config PREEMPT
 	  This allows applications to run more reliably even when the system is
 	  under load.
 
+config PREEMPT_BKL
+	bool "Preempt The Big Kernel Lock"
+	depends on PREEMPT
+	default y
+	help
+	  This option reduces the latency of the kernel by making the
+	  big kernel lock preemptible.
+
+	  Say Y here if you are building a kernel for a desktop system.
+	  Say N if you are unsure.
+
 config RTC_DS1742
 	bool "DS1742 BRAM/RTC support"
 	depends on TOSHIBA_JMR3927 || TOSHIBA_RBTX4927
@@ -1476,14 +1272,16 @@ config MIPS_INSANE_LARGE
 	  This will result in additional memory usage, so it is not
 	  recommended for normal users.
 
+endmenu
+
 config RWSEM_GENERIC_SPINLOCK
 	bool
 	default y
 
-endmenu
-
 menu "Bus options (PCI, PCMCIA, EISA, ISA, TC)"
 
+config HW_HAS_EISA
+	bool
 config HW_HAS_PCI
 	bool
 
@@ -1517,7 +1315,7 @@ config ISA
 
 config EISA
 	bool "EISA support"
-	depends on SGI_IP22 || SNI_RM200_PCI
+	depends on HW_HAS_EISA
 	select ISA
 	---help---
 	  The Extended Industry Standard Architecture (EISA) bus was
@@ -1551,12 +1349,6 @@ config MMU
 	bool
 	default y
 
-config MCA
-	bool
-
-config SBUS
-	bool
-
 source "drivers/pcmcia/Kconfig"
 
 source "drivers/pci/hotplug/Kconfig"
@@ -1569,7 +1361,6 @@ source "fs/Kconfig.binfmt"
 
 config TRAD_SIGNALS
 	bool
-	default y if MIPS32
 
 config BUILD_ELF64
 	bool "Use 64-bit ELF format for building"
@@ -1588,7 +1379,7 @@ config BUILD_ELF64
 
 config BINFMT_IRIX
 	bool "Include IRIX binary compatibility"
-	depends on !CPU_LITTLE_ENDIAN && MIPS32 && BROKEN
+	depends on CPU_BIG_ENDIAN && MIPS32 && BROKEN
 
 config MIPS32_COMPAT
 	bool "Kernel support for Linux/MIPS 32-bit binary compatibility"
@@ -1628,9 +1419,26 @@ config BINFMT_ELF32
 	bool
 	default y if MIPS32_O32 || MIPS32_N32
 
+config SECCOMP
+	bool "Enable seccomp to safely compute untrusted bytecode"
+	depends on PROC_FS && BROKEN
+	default y
+	help
+	  This kernel feature is useful for number crunching applications
+	  that may need to compute untrusted bytecode during their
+	  execution. By using pipes or other transports made available to
+	  the process as file descriptors supporting the read/write
+	  syscalls, it's possible to isolate those applications in
+	  their own address space using seccomp. Once seccomp is
+	  enabled via /proc/<pid>/seccomp, it cannot be disabled
+	  and the task is only allowed to execute a few safe syscalls
+	  defined by each seccomp mode.
+
+	  If unsure, say Y. Only embedded should say N here.
+
 config PM
 	bool "Power Management support (EXPERIMENTAL)"
-	depends on EXPERIMENTAL && MACH_AU1X00
+	depends on EXPERIMENTAL && SOC_AU1X00
 
 endmenu
 
@@ -1638,6 +1446,8 @@ source "drivers/Kconfig"
 
 source "fs/Kconfig"
 
+source "arch/mips/oprofile/Kconfig"
+
 source "arch/mips/Kconfig.debug"
 
 source "security/Kconfig"
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/Makefile linux_HEAD/arch/mips/Makefile
--- linux-2.6.11.6/arch/mips/Makefile	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/Makefile	2005-04-02 19:49:57.000000000 +0200
@@ -52,6 +52,16 @@ ifdef CONFIG_CROSSCOMPILE
 CROSS_COMPILE		:= $(tool-prefix)
 endif
 
+CHECKFLAGS-y				+= -D__linux__ -D__mips__
+CHECKFLAGS-$(CONFIG_MIPS32)		+= -D_MIPS_SZLONG=32 \
+					   -D__PTRDIFF_TYPE__=int
+CHECKFLAGS-$(CONFIG_MIPS64)		+= -D_MIPS_SZLONG=64 \
+					   -D__PTRDIFF_TYPE__="long int"
+CHECKFLAGS-$(CONFIG_CPU_BIG_ENDIAN)	+= -D__MIPSEB__
+CHECKFLAGS-$(CONFIG_CPU_LITTLE_ENDIAN)	+= -D__MIPSEL__
+
+CHECKFLAGS				= $(CHECKFLAGS-y)
+
 ifdef CONFIG_BUILD_ELF64
 gas-abi			= 64
 ld-emul			= $(64bit-emul)
@@ -79,10 +89,11 @@ endif
 cflags-y			+= -I $(TOPDIR)/include/asm/gcc
 cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
 cflags-y			+= $(call cc-option, -finline-limit=100000)
-LDFLAGS_vmlinux			+= -G 0 -static -n
+LDFLAGS_vmlinux			+= -G 0 -static -n -nostdlib
 MODFLAGS			+= -mlong-calls
 
-cflags-$(CONFIG_SB1XXX_CORELIS)	+= -mno-sched-prolog -fno-omit-frame-pointer
+cflags-$(CONFIG_SB1XXX_CORELIS)	+= $(call cc-option,-mno-sched-prolog) \
+				   -fno-omit-frame-pointer
 
 #
 # Use: $(call set_gccflags,<cpu0>,<isa0>,<cpu1>,<isa1>,<isa2>)
@@ -266,6 +277,13 @@ cflags-$(CONFIG_MIPS_PB1550)	+= -Iinclud
 load-$(CONFIG_MIPS_PB1550)	+= 0xffffffff80100000
 
 #
+# AMD Alchemy Pb1200 eval board
+#
+libs-$(CONFIG_MIPS_PB1200)	+= arch/mips/au1000/pb1200/
+cflags-$(CONFIG_MIPS_PB1200)	+= -Iinclude/asm-mips/mach-pb1x00
+load-$(CONFIG_MIPS_PB1200)	+= 0xffffffff80100000
+
+#
 # AMD Alchemy Db1000 eval board
 #
 libs-$(CONFIG_MIPS_DB1000)	+= arch/mips/au1000/db1x00/
@@ -294,6 +312,13 @@ cflags-$(CONFIG_MIPS_DB1550)	+= -Iinclud
 load-$(CONFIG_MIPS_DB1550)	+= 0xffffffff80100000
 
 #
+# AMD Alchemy Db1200 eval board
+#
+libs-$(CONFIG_MIPS_DB1200)	+= arch/mips/au1000/pb1200/
+cflags-$(CONFIG_MIPS_DB1200)	+= -Iinclude/asm-mips/mach-db1x00
+load-$(CONFIG_MIPS_DB1200)	+= 0xffffffff80100000
+
+#
 # AMD Alchemy Bosporus eval board
 #
 libs-$(CONFIG_MIPS_BOSPORUS)	+= arch/mips/au1000/db1x00/
@@ -323,6 +348,7 @@ load-$(CONFIG_MIPS_XXS1500)	+= 0xfffffff
 # Cobalt Server
 #
 core-$(CONFIG_MIPS_COBALT)	+= arch/mips/cobalt/
+cflags-$(CONFIG_MIPS_COBALT)	+= -Iinclude/asm-mips/cobalt
 load-$(CONFIG_MIPS_COBALT)	+= 0xffffffff80080000
 
 #
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/arc/Makefile linux_HEAD/arch/mips/arc/Makefile
--- linux-2.6.11.6/arch/mips/arc/Makefile	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/arc/Makefile	2005-03-09 22:46:10.000000000 +0100
@@ -3,7 +3,7 @@
 #
 
 lib-y				+= cmdline.o env.o file.o identify.o init.o \
-				   misc.o time.o tree.o
+				   misc.o salone.o time.o tree.o
 
 lib-$(CONFIG_ARC_MEMORY)	+= memory.o
 lib-$(CONFIG_ARC_CONSOLE)	+= arc_con.o
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/common/au1xxx_irqmap.c linux_HEAD/arch/mips/au1000/common/au1xxx_irqmap.c
--- linux-2.6.11.6/arch/mips/au1000/common/au1xxx_irqmap.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/common/au1xxx_irqmap.c	2005-03-01 15:00:11.000000000 +0100
@@ -173,14 +173,14 @@ au1xxx_irq_map_t au1xxx_ic0_map[] = {
 	{ AU1550_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1550_PSC2_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1550_PSC3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
-	{ AU1550_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1550_NAND_INT, INTC_INT_RISE_EDGE, 0},
 	{ AU1550_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1550_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
@@ -201,14 +201,14 @@ au1xxx_irq_map_t au1xxx_ic0_map[] = {
 	{ AU1200_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1200_AES_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1200_CAMERA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
-	{ AU1200_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1200_NAND_INT, INTC_INT_RISE_EDGE, 0},
 	{ AU1200_USB_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1200_LCD_INT, INTC_INT_HIGH_LEVEL, 0},
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/common/cputable.c linux_HEAD/arch/mips/au1000/common/cputable.c
--- linux-2.6.11.6/arch/mips/au1000/common/cputable.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/common/cputable.c	2005-03-01 15:00:11.000000000 +0100
@@ -37,7 +37,8 @@ struct cpu_spec	cpu_specs[] = {
     { 0xffffffff, 0x02030203, "Au1100 BD", 0, 1 },
     { 0xffffffff, 0x02030204, "Au1100 BE", 0, 1 },
     { 0xffffffff, 0x03030200, "Au1550 AA", 0, 1 },
-    { 0xffffffff, 0x04030200, "Au1200 AA", 0, 1 },
+    { 0xffffffff, 0x04030200, "Au1200 AB", 0, 0 },
+    { 0xffffffff, 0x04030201, "Au1200 AC", 0, 1 },
     { 0x00000000, 0x00000000, "Unknown Au1xxx", 1, 0 },
 };
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/common/dbdma.c linux_HEAD/arch/mips/au1000/common/dbdma.c
--- linux-2.6.11.6/arch/mips/au1000/common/dbdma.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/common/dbdma.c	2005-03-01 15:00:11.000000000 +0100
@@ -29,6 +29,7 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  *
  */
+
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -38,10 +39,12 @@
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/module.h>
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-au1x00/au1xxx_dbdma.h>
 #include <asm/system.h>
 
+
 #if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
 
 /*
@@ -55,43 +58,16 @@
  * functions.  The drivers allocate the data buffers and assign them
  * to the descriptors.
  */
-static DEFINE_SPINLOCK(au1xxx_dbdma_spin_lock);
+static spinlock_t au1xxx_dbdma_spin_lock = SPIN_LOCK_UNLOCKED;
 
 /* I couldn't find a macro that did this......
 */
 #define ALIGN_ADDR(x, a)	((((u32)(x)) + (a-1)) & ~(a-1))
 
-static volatile dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
-static int dbdma_initialized;
+static dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
+static int dbdma_initialized=0;
 static void au1xxx_dbdma_init(void);
 
-typedef struct dbdma_device_table {
-	u32		dev_id;
-	u32		dev_flags;
-	u32		dev_tsize;
-	u32		dev_devwidth;
-	u32		dev_physaddr;		/* If FIFO */
-	u32		dev_intlevel;
-	u32		dev_intpolarity;
-} dbdev_tab_t;
-
-typedef struct dbdma_chan_config {
-	u32			chan_flags;
-	u32			chan_index;
-	dbdev_tab_t		*chan_src;
-	dbdev_tab_t		*chan_dest;
-	au1x_dma_chan_t		*chan_ptr;
-	au1x_ddma_desc_t	*chan_desc_base;
-	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
-	void			*chan_callparam;
-	void (*chan_callback)(int, void *, struct pt_regs *);
-} chan_tab_t;
-
-#define	DEV_FLAGS_INUSE		(1 << 0)
-#define	DEV_FLAGS_ANYUSE	(1 << 1)
-#define DEV_FLAGS_OUT		(1 << 2)
-#define DEV_FLAGS_IN		(1 << 3)
-
 static dbdev_tab_t dbdev_tab[] = {
 #ifdef CONFIG_SOC_AU1550
 	/* UARTS */
@@ -157,13 +133,13 @@ static dbdev_tab_t dbdev_tab[] = {
 	{ DSCR_CMD0_MAE_BOTH, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 	{ DSCR_CMD0_LCD, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
-	{ DSCR_CMD0_SDMS_TX0, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_RX0, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_TX1, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_SDMS_RX1, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_SDMS_TX0, DEV_FLAGS_OUT, 4, 8, 0x10600000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX0, DEV_FLAGS_IN, 4, 8, 0x10600004, 0, 0 },
+	{ DSCR_CMD0_SDMS_TX1, DEV_FLAGS_OUT, 4, 8, 0x10680000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX1, DEV_FLAGS_IN, 4, 8, 0x10680004, 0, 0 },
 
-	{ DSCR_CMD0_AES_TX, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_AES_RX, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_AES_RX, DEV_FLAGS_IN , 4, 32, 0x10300008, 0, 0 },
+	{ DSCR_CMD0_AES_TX, DEV_FLAGS_OUT, 4, 32, 0x10300004, 0, 0 },
 
 	{ DSCR_CMD0_PSC0_TX, DEV_FLAGS_OUT, 0, 0, 0x11a0001c, 0, 0 },
 	{ DSCR_CMD0_PSC0_RX, DEV_FLAGS_IN, 0, 0, 0x11a0001c, 0, 0 },
@@ -173,9 +149,9 @@ static dbdev_tab_t dbdev_tab[] = {
 	{ DSCR_CMD0_PSC1_RX, DEV_FLAGS_IN, 0, 0, 0x11b0001c, 0, 0 },
 	{ DSCR_CMD0_PSC1_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
-	{ DSCR_CMD0_CIM_RXA, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_CIM_RXB, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
-	{ DSCR_CMD0_CIM_RXC, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_CIM_RXA, DEV_FLAGS_IN, 0, 32, 0x14004020, 0, 0 },
+	{ DSCR_CMD0_CIM_RXB, DEV_FLAGS_IN, 0, 32, 0x14004040, 0, 0 },
+	{ DSCR_CMD0_CIM_RXC, DEV_FLAGS_IN, 0, 32, 0x14004060, 0, 0 },
 	{ DSCR_CMD0_CIM_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 
 	{ DSCR_CMD0_NAND_FLASH, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
@@ -184,6 +160,24 @@ static dbdev_tab_t dbdev_tab[] = {
 
 	{ DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 	{ DSCR_CMD0_ALWAYS, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+
+	/* Provide 16 user definable device types */
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
+	{ 0, 0, 0, 0, 0, 0, 0 },
 };
 
 #define DBDEV_TAB_SIZE (sizeof(dbdev_tab) / sizeof(dbdev_tab_t))
@@ -203,6 +197,30 @@ find_dbdev_id (u32 id)
 	return NULL;
 }
 
+u32
+au1xxx_ddma_add_device(dbdev_tab_t *dev)
+{
+	u32 ret = 0;
+	dbdev_tab_t *p=NULL;
+	static u16 new_id=0x1000;
+
+	p = find_dbdev_id(0);
+	if ( NULL != p )
+	{
+		memcpy(p, dev, sizeof(dbdev_tab_t));
+ 		p->dev_id = DSCR_DEV2CUSTOM_ID(new_id,dev->dev_id);
+		ret = p->dev_id;
+		new_id++;
+#if 0
+		printk("add_device: id:%x flags:%x padd:%x\n", 
+				p->dev_id, p->dev_flags, p->dev_physaddr );
+#endif
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(au1xxx_ddma_add_device);
+
 /* Allocate a channel and return a non-zero descriptor if successful.
 */
 u32
@@ -215,7 +233,7 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 d
 	int		i;
 	dbdev_tab_t	*stp, *dtp;
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	/* We do the intialization on the first channel allocation.
 	 * We have to wait because of the interrupt handler initialization
@@ -225,9 +243,6 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 d
 		au1xxx_dbdma_init();
 	dbdma_initialized = 1;
 
-	if ((srcid > DSCR_NDEV_IDS) || (destid > DSCR_NDEV_IDS))
-		return 0;
-
 	if ((stp = find_dbdev_id(srcid)) == NULL) return 0;
 	if ((dtp = find_dbdev_id(destid)) == NULL) return 0;
 
@@ -269,9 +284,9 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 d
 				/* If kmalloc fails, it is caught below same
 				 * as a channel not available.
 				 */
-				ctp = kmalloc(sizeof(chan_tab_t), GFP_KERNEL);
+				ctp = (chan_tab_t *)
+					kmalloc(sizeof(chan_tab_t), GFP_KERNEL);
 				chan_tab_ptr[i] = ctp;
-				ctp->chan_index = chan = i;
 				break;
 			}
 		}
@@ -279,10 +294,11 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 d
 
 		if (ctp != NULL) {
 			memset(ctp, 0, sizeof(chan_tab_t));
+			ctp->chan_index = chan = i;
 			dcp = DDMA_CHANNEL_BASE;
 			dcp += (0x0100 * chan);
 			ctp->chan_ptr = (au1x_dma_chan_t *)dcp;
-			cp = (volatile au1x_dma_chan_t *)dcp;
+			cp = (au1x_dma_chan_t *)dcp;
 			ctp->chan_src = stp;
 			ctp->chan_dest = dtp;
 			ctp->chan_callback = callback;
@@ -299,6 +315,9 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 d
 				i |= DDMA_CFG_DED;
 			if (dtp->dev_intpolarity)
 				i |= DDMA_CFG_DP;
+			if ((stp->dev_flags & DEV_FLAGS_SYNC) ||
+				(dtp->dev_flags & DEV_FLAGS_SYNC))
+					i |= DDMA_CFG_SYNC;
 			cp->ddma_cfg = i;
 			au_sync();
 
@@ -309,14 +328,14 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 d
 			rv = (u32)(&chan_tab_ptr[chan]);
 		}
 		else {
-			/* Release devices.
-			*/
+			/* Release devices */
 			stp->dev_flags &= ~DEV_FLAGS_INUSE;
 			dtp->dev_flags &= ~DEV_FLAGS_INUSE;
 		}
 	}
 	return rv;
 }
+EXPORT_SYMBOL(au1xxx_dbdma_chan_alloc);
 
 /* Set the device width if source or destination is a FIFO.
  * Should be 8, 16, or 32 bits.
@@ -344,6 +363,7 @@ au1xxx_dbdma_set_devwidth(u32 chanid, in
 
 	return rv;
 }
+EXPORT_SYMBOL(au1xxx_dbdma_set_devwidth);
 
 /* Allocate a descriptor ring, initializing as much as possible.
 */
@@ -370,7 +390,8 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 	 * and if we try that first we are likely to not waste larger
 	 * slabs of memory.
 	 */
-	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t), GFP_KERNEL);
+	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t), 
+			GFP_KERNEL|GFP_DMA);
 	if (desc_base == 0)
 		return 0;
 
@@ -381,7 +402,7 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 		kfree((const void *)desc_base);
 		i = entries * sizeof(au1x_ddma_desc_t);
 		i += (sizeof(au1x_ddma_desc_t) - 1);
-		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL)) == 0)
+		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL|GFP_DMA)) == 0)
 			return 0;
 
 		desc_base = ALIGN_ADDR(desc_base, sizeof(au1x_ddma_desc_t));
@@ -461,9 +482,14 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 	/* If source input is fifo, set static address.
 	*/
 	if (stp->dev_flags & DEV_FLAGS_IN) {
-		src0 = stp->dev_physaddr;
+		if ( stp->dev_flags & DEV_FLAGS_BURSTABLE ) 
+			src1 |= DSCR_SRC1_SAM(DSCR_xAM_BURST);
+		else 
 		src1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);
+
 	}
+	if (stp->dev_physaddr) 
+		src0 = stp->dev_physaddr;
 
 	/* Set up dest1.  For now, assume no stride and increment.
 	 * A channel attribute update can change this later.
@@ -487,10 +513,18 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 	/* If destination output is fifo, set static address.
 	*/
 	if (dtp->dev_flags & DEV_FLAGS_OUT) {
-		dest0 = dtp->dev_physaddr;
+		if ( dtp->dev_flags & DEV_FLAGS_BURSTABLE )
+	                dest1 |= DSCR_DEST1_DAM(DSCR_xAM_BURST);
+				else
 		dest1 |= DSCR_DEST1_DAM(DSCR_xAM_STATIC);
 	}
+	if (dtp->dev_physaddr) 
+		dest0 = dtp->dev_physaddr;
 
+#if 0
+		printk("did:%x sid:%x cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",
+			dtp->dev_id, stp->dev_id, cmd0, cmd1, src0, src1, dest0, dest1 );
+#endif
 	for (i=0; i<entries; i++) {
 		dp->dscr_cmd0 = cmd0;
 		dp->dscr_cmd1 = cmd1;
@@ -499,6 +533,7 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 		dp->dscr_dest0 = dest0;
 		dp->dscr_dest1 = dest1;
 		dp->dscr_stat = 0;
+				dp->sw_context = dp->sw_status = 0;
 		dp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(dp + 1));
 		dp++;
 	}
@@ -511,13 +546,14 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int 
 
 	return (u32)(ctp->chan_desc_base);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_ring_alloc);
 
 /* Put a source buffer into the DMA ring.
  * This updates the source pointer and byte count.  Normally used
  * for memory to fifo transfers.
  */
 u32
-au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes)
+_au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
@@ -544,24 +580,40 @@ au1xxx_dbdma_put_source(u32 chanid, void
 	*/
 	dp->dscr_source0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
-	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
-	ctp->chan_ptr->ddma_dbell = 0xffffffff;	/* Make it go */
-
+	/* Check flags  */
+	if (flags & DDMA_FLAGS_IE) 
+		dp->dscr_cmd0 |= DSCR_CMD0_IE;
+	if (flags & DDMA_FLAGS_NOIE)
+		dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
 	/* Get next descriptor pointer.
 	*/
 	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 
+	/*
+	 * There is an errata on the Au1200/Au1550 parts that could result 
+	 * in "stale" data being DMA'd. It has to do with the snoop logic on 
+	 * the dache eviction buffer.  NONCOHERENT_IO is on by default for 
+	 * these parts. If it is fixedin the future, these dma_cache_inv will 
+	 * just be nothing more than empty macros. See io.h.
+	 * */
+	dma_cache_wback_inv((unsigned long)buf, nbytes);
+        dp->dscr_cmd0 |= DSCR_CMD0_V;        /* Let it rip */
+	au_sync();
+	dma_cache_wback_inv((unsigned long)dp, sizeof(dp));
+        ctp->chan_ptr->ddma_dbell = 0;
+
 	/* return something not zero.
 	*/
 	return nbytes;
 }
+EXPORT_SYMBOL(_au1xxx_dbdma_put_source);
 
 /* Put a destination buffer into the DMA ring.
  * This updates the destination pointer and byte count.  Normally used
  * to place an empty buffer into the ring for fifo to memory transfers.
  */
 u32
-au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes)
+_au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
@@ -583,11 +635,33 @@ au1xxx_dbdma_put_dest(u32 chanid, void *
 	if (dp->dscr_cmd0 & DSCR_CMD0_V)
 		return 0;
 
-	/* Load up buffer address and byte count.
-	*/
+	/* Load up buffer address and byte count */
+
+	/* Check flags  */
+	if (flags & DDMA_FLAGS_IE) 
+		dp->dscr_cmd0 |= DSCR_CMD0_IE;
+	if (flags & DDMA_FLAGS_NOIE)
+		dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
+
 	dp->dscr_dest0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
+#if 0
+	printk("cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n", 
+			dp->dscr_cmd0, dp->dscr_cmd1, dp->dscr_source0, 
+			dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1 );
+#endif
+	/*
+	 * There is an errata on the Au1200/Au1550 parts that could result in 
+	 * "stale" data being DMA'd. It has to do with the snoop logic on the 
+	 * dache eviction buffer. NONCOHERENT_IO is on by default for these 
+	 * parts. If it is fixedin the future, these dma_cache_inv will just 
+	 * be nothing more than empty macros. See io.h. 
+	 * */
+	dma_cache_inv((unsigned long)buf,nbytes);
 	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
+	au_sync();
+	dma_cache_wback_inv((unsigned long)dp, sizeof(dp));
+        ctp->chan_ptr->ddma_dbell = 0;
 
 	/* Get next descriptor pointer.
 	*/
@@ -597,6 +671,7 @@ au1xxx_dbdma_put_dest(u32 chanid, void *
 	*/
 	return nbytes;
 }
+EXPORT_SYMBOL(_au1xxx_dbdma_put_dest);
 
 /* Get a destination buffer into the DMA ring.
  * Normally used to get a full buffer from the ring during fifo
@@ -646,7 +721,7 @@ void
 au1xxx_dbdma_stop(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 	int halt_timeout = 0;
 
 	ctp = *((chan_tab_t **)chanid);
@@ -666,6 +741,7 @@ au1xxx_dbdma_stop(u32 chanid)
 	cp->ddma_stat |= (DDMA_STAT_DB | DDMA_STAT_V);
 	au_sync();
 }
+EXPORT_SYMBOL(au1xxx_dbdma_stop);
 
 /* Start using the current descriptor pointer.  If the dbdma encounters
  * a not valid descriptor, it will stop.  In this case, we can just
@@ -675,17 +751,17 @@ void
 au1xxx_dbdma_start(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	ctp = *((chan_tab_t **)chanid);
-
 	cp = ctp->chan_ptr;
 	cp->ddma_desptr = virt_to_phys(ctp->cur_ptr);
 	cp->ddma_cfg |= DDMA_CFG_EN;	/* Enable channel */
 	au_sync();
-	cp->ddma_dbell = 0xffffffff;	/* Make it go */
+	cp->ddma_dbell = 0;
 	au_sync();
 }
+EXPORT_SYMBOL(au1xxx_dbdma_start);
 
 void
 au1xxx_dbdma_reset(u32 chanid)
@@ -704,15 +780,21 @@ au1xxx_dbdma_reset(u32 chanid)
 
 	do {
 		dp->dscr_cmd0 &= ~DSCR_CMD0_V;
+		/* reset our SW status -- this is used to determine 
+		 * if a descriptor is in use by upper level SW. Since 
+		 * posting can reset 'V' bit. 
+		 */
+		dp->sw_status = 0;
 		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	} while (dp != ctp->chan_desc_base);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_reset);
 
 u32
 au1xxx_get_dma_residue(u32 chanid)
 {
 	chan_tab_t	*ctp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 	u32		rv;
 
 	ctp = *((chan_tab_t **)chanid);
@@ -739,7 +821,7 @@ au1xxx_dbdma_chan_free(u32 chanid)
 	au1xxx_dbdma_stop(chanid);
 
 	if (ctp->chan_desc_base != NULL)
-		kfree(ctp->chan_desc_base);
+		kfree((void *)ctp->chan_desc_base);
 
 	stp->dev_flags &= ~DEV_FLAGS_INUSE;
 	dtp->dev_flags &= ~DEV_FLAGS_INUSE;
@@ -747,15 +829,16 @@ au1xxx_dbdma_chan_free(u32 chanid)
 
 	kfree(ctp);
 }
+EXPORT_SYMBOL(au1xxx_dbdma_chan_free);
 
 static irqreturn_t
 dbdma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	u32	intstat;
-	u32	chan_index;
+	u32 intstat;
+	u32 chan_index;
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
 
 	intstat = dbdma_gptr->ddma_intstat;
 	au_sync();
@@ -774,19 +857,27 @@ dbdma_interrupt(int irq, void *dev_id, s
 		(ctp->chan_callback)(irq, ctp->chan_callparam, regs);
 
 	ctp->cur_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
-
-	return IRQ_HANDLED;
+	return IRQ_RETVAL(1);
 }
 
-static void
-au1xxx_dbdma_init(void)
+static void au1xxx_dbdma_init(void)
 {
+	int irq_nr;
+
 	dbdma_gptr->ddma_config = 0;
 	dbdma_gptr->ddma_throttle = 0;
 	dbdma_gptr->ddma_inten = 0xffff;
 	au_sync();
 
-	if (request_irq(AU1550_DDMA_INT, dbdma_interrupt, SA_INTERRUPT,
+#if defined(CONFIG_SOC_AU1550)
+	irq_nr = AU1550_DDMA_INT;
+#elif defined(CONFIG_SOC_AU1200)
+	irq_nr = AU1200_DDMA_INT;
+#else
+	#error Unknown Au1x00 SOC
+#endif
+
+	if (request_irq(irq_nr, dbdma_interrupt, SA_INTERRUPT,
 			"Au1xxx dbdma", (void *)dbdma_gptr))
 		printk("Can't get 1550 dbdma irq");
 }
@@ -797,7 +888,8 @@ au1xxx_dbdma_dump(u32 chanid)
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
 	dbdev_tab_t		*stp, *dtp;
-	volatile au1x_dma_chan_t *cp;
+	au1x_dma_chan_t *cp;
+		u32			i = 0;
 
 	ctp = *((chan_tab_t **)chanid);
 	stp = ctp->chan_src;
@@ -822,15 +914,64 @@ au1xxx_dbdma_dump(u32 chanid)
 	dp = ctp->chan_desc_base;
 
 	do {
-		printk("dp %08x, cmd0 %08x, cmd1 %08x\n",
-			(u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
-		printk("src0 %08x, src1 %08x, dest0 %08x\n",
-			dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0);
-		printk("dest1 %08x, stat %08x, nxtptr %08x\n",
-			dp->dscr_dest1, dp->dscr_stat, dp->dscr_nxtptr);
+                printk("Dp[%d]= %08x, cmd0 %08x, cmd1 %08x\n",
+                        i++, (u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
+                printk("src0 %08x, src1 %08x, dest0 %08x, dest1 %08x\n",
+                        dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1);
+                printk("stat %08x, nxtptr %08x\n",
+                        dp->dscr_stat, dp->dscr_nxtptr);
 		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	} while (dp != ctp->chan_desc_base);
 }
 
+/* Put a descriptor into the DMA ring.
+ * This updates the source/destination pointers and byte count.
+ */
+u32
+au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr )
+{
+	chan_tab_t *ctp;
+	au1x_ddma_desc_t *dp;
+	u32 nbytes=0;
+
+	/* I guess we could check this to be within the
+	* range of the table......
+	*/
+	ctp = *((chan_tab_t **)chanid);
+
+	/* We should have multiple callers for a particular channel,
+	* an interrupt doesn't affect this pointer nor the descriptor,
+	* so no locking should be needed.
+	*/
+	dp = ctp->put_ptr;
+
+	/* If the descriptor is valid, we are way ahead of the DMA
+	* engine, so just return an error condition.
+	*/
+	if (dp->dscr_cmd0 & DSCR_CMD0_V)
+		return 0;
+
+	/* Load up buffer addresses and byte count.
+	*/
+	dp->dscr_dest0 = dscr->dscr_dest0;
+	dp->dscr_source0 = dscr->dscr_source0;
+	dp->dscr_dest1 = dscr->dscr_dest1;
+	dp->dscr_source1 = dscr->dscr_source1;
+	dp->dscr_cmd1 = dscr->dscr_cmd1;
+	nbytes = dscr->dscr_cmd1;
+	/* Allow the caller to specifiy if an interrupt is generated */
+	dp->dscr_cmd0 &= ~DSCR_CMD0_IE;
+	dp->dscr_cmd0 |= dscr->dscr_cmd0 | DSCR_CMD0_V;
+	ctp->chan_ptr->ddma_dbell = 0;
+
+	/* Get next descriptor pointer.
+	*/
+	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+
+	/* return something not zero.
+	*/
+	return nbytes;
+}
+
 #endif /* defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200) */
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/common/irq.c linux_HEAD/arch/mips/au1000/common/irq.c
--- linux-2.6.11.6/arch/mips/au1000/common/irq.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/common/irq.c	2005-03-17 22:10:46.000000000 +0100
@@ -253,52 +253,70 @@ void restore_local_and_enable(int contro
 
 
 static struct hw_interrupt_type rise_edge_irq_type = {
-	"Au1000 Rise Edge",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_rise_edge_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Rise Edge",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_rise_edge_irq,
+	.end = end_irq,
 };
 
 static struct hw_interrupt_type fall_edge_irq_type = {
-	"Au1000 Fall Edge",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_fall_edge_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Fall Edge",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_fall_edge_irq,
+	.end = end_irq,
 };
 
 static struct hw_interrupt_type either_edge_irq_type = {
-	"Au1000 Rise or Fall Edge",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_either_edge_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Rise or Fall Edge",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_either_edge_irq,
+	.end = end_irq,
 };
 
 static struct hw_interrupt_type level_irq_type = {
-	"Au1000 Level",
-	startup_irq,
-	shutdown_irq,
-	local_enable_irq,
-	local_disable_irq,
-	mask_and_ack_level_irq,
-	end_irq,
-	NULL
+	.typename = "Au1000 Level",
+	.startup = startup_irq,
+	.shutdown = shutdown_irq,
+	.enable = local_enable_irq,
+	.disable = local_disable_irq,
+	.ack = mask_and_ack_level_irq,
+	.end = end_irq,
 };
 
 #ifdef CONFIG_PM
-void startup_match20_interrupt(void)
+void startup_match20_interrupt(void (*handler)(int, void *, struct pt_regs *))
 {
+	static struct irqaction action;
+	/* This is a big problem.... since we didn't use request_irq
+	   when kernel/irq.c calls probe_irq_xxx this interrupt will
+	   be probed for usage. This will end up disabling the device :(
+
+       Give it a bogus "action" pointer -- this will keep it from
+	   getting auto-probed!
+
+       By setting the status to match that of request_irq() we
+       can avoid it.  --cgray
+	*/
+	action.dev_id = handler;
+	action.flags = 0;
+	action.mask = 0;
+	action.name = "Au1xxx TOY";
+	action.handler = handler;
+	action.next = NULL;
+
+	irq_desc[AU1000_TOY_MATCH2_INT].action = &action; 
+	irq_desc[AU1000_TOY_MATCH2_INT].status 
+		 &= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING | IRQ_INPROGRESS);
+
 	local_enable_irq(AU1000_TOY_MATCH2_INT);
 }
 #endif
@@ -492,7 +510,7 @@ void intc0_req0_irqdispatch(struct pt_re
 	intc0_req0 |= au_readl(IC0_REQ0INT);
 
 	if (!intc0_req0) return;
-
+#ifdef AU1000_USB_DEV_REQ_INT
 	/*
 	 * Because of the tight timing of SETUP token to reply
 	 * transactions, the USB devices-side packet complete
@@ -503,7 +521,7 @@ void intc0_req0_irqdispatch(struct pt_re
 		do_IRQ(AU1000_USB_DEV_REQ_INT, regs);
 		return;
 	}
-
+#endif
 	irq = au_ffs(intc0_req0) - 1;
 	intc0_req0 &= ~(1<<irq);
 	do_IRQ(irq, regs);
@@ -521,17 +539,7 @@ void intc0_req1_irqdispatch(struct pt_re
 
 	irq = au_ffs(intc0_req1) - 1;
 	intc0_req1 &= ~(1<<irq);
-#ifdef CONFIG_PM
-	if (irq == AU1000_TOY_MATCH2_INT) {
-		mask_and_ack_rise_edge_irq(irq);
-		counter0_irq(irq, NULL, regs);
-		local_enable_irq(irq);
-	}
-	else
-#endif
-	{
-		do_IRQ(irq, regs);
-	}
+	do_IRQ(irq, regs);
 }
 
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/common/time.c linux_HEAD/arch/mips/au1000/common/time.c
--- linux-2.6.11.6/arch/mips/au1000/common/time.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/common/time.c	2005-03-17 22:10:46.000000000 +0100
@@ -50,7 +50,6 @@
 #include <linux/mc146818rtc.h>
 #include <linux/timex.h>
 
-extern void startup_match20_interrupt(void);
 extern void do_softirq(void);
 extern volatile unsigned long wall_jiffies;
 unsigned long missed_heart_beats = 0;
@@ -65,7 +64,7 @@ static unsigned int timerhi = 0, timerlo
 
 #ifdef CONFIG_PM
 #define MATCH20_INC 328
-extern void startup_match20_interrupt(void);
+extern void startup_match20_interrupt(void (*handler)(int, void *, struct pt_regs *));
 static unsigned long last_pc0, last_match20;
 #endif
 
@@ -446,7 +445,7 @@ void au1xxx_timer_setup(struct irqaction
 		au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
 		au_sync();
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
-		startup_match20_interrupt();
+		startup_match20_interrupt(counter0_irq);
 
 		do_gettimeoffset = do_fast_pm_gettimeoffset;
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/db1x00/irqmap.c linux_HEAD/arch/mips/au1000/db1x00/irqmap.c
--- linux-2.6.11.6/arch/mips/au1000/db1x00/irqmap.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/db1x00/irqmap.c	2005-03-01 15:00:11.000000000 +0100
@@ -48,6 +48,38 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+#ifdef CONFIG_MIPS_DB1500
+char irq_tab_alchemy[][5] __initdata = {
+ [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT371   */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+};
+#endif
+
+#ifdef CONFIG_MIPS_BOSPORUS
+char irq_tab_alchemy[][5] __initdata = {
+ [11] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 11 - miniPCI  */
+ [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - SN1741   */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+};
+#endif
+
+#ifdef CONFIG_MIPS_MIRAGE
+char irq_tab_alchemy[][5] __initdata = {
+ [11] =	{ -1, INTD, INTX, INTX, INTX},   /* IDSEL 11 - SMI VGX */
+ [12] =	{ -1, INTX, INTX, INTC, INTX},   /* IDSEL 12 - PNX1300 */
+ [13] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 13 - miniPCI */
+};
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+char irq_tab_alchemy[][5] __initdata = {
+ [11] =	{ -1, INTC, INTX, INTX, INTX},   /* IDSEL 11 - on-board HPT371    */
+ [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+};
+#endif
+
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 
 #ifndef CONFIG_MIPS_MIRAGE
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/db1x00/mirage_ts.c linux_HEAD/arch/mips/au1000/db1x00/mirage_ts.c
--- linux-2.6.11.6/arch/mips/au1000/db1x00/mirage_ts.c	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/db1x00/mirage_ts.c	2005-02-28 16:56:39.000000000 +0100
@@ -102,15 +102,15 @@ static struct {
 } mirage_ts_cal =
 {
 #if 0
-	xscale:   84,
-	xtrans: -157,
-	yscale:   66,
-	ytrans: -150,
+	.xscale   = 84,
+	.xtrans = -157,
+	.yscale   = 66,
+	.ytrans = -150,
 #else
-	xscale:   84,
-	xtrans: -150,
-	yscale:   66,
-	ytrans: -146,
+	.xscale   = 84,
+	.xtrans = -150,
+	.yscale   = 66,
+	.ytrans = -146,
 #endif
 };
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/mtx-1/init.c linux_HEAD/arch/mips/au1000/mtx-1/init.c
--- linux-2.6.11.6/arch/mips/au1000/mtx-1/init.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/mtx-1/init.c	2005-02-17 21:48:53.000000000 +0100
@@ -59,7 +59,7 @@ void __init prom_init(void)
 
 	mips_machgroup = MACH_GROUP_ALCHEMY;
 	mips_machtype = MACH_MTX1;	/* set the platform # */
-
+	
 	prom_init_cmdline();
 
 	memsize_str = prom_getenv("memsize");
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/mtx-1/irqmap.c linux_HEAD/arch/mips/au1000/mtx-1/irqmap.c
--- linux-2.6.11.6/arch/mips/au1000/mtx-1/irqmap.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/mtx-1/irqmap.c	2005-03-01 15:00:11.000000000 +0100
@@ -47,6 +47,17 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+char irq_tab_alchemy[][5] __initdata = {
+ [0] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 00 - AdapterA-Slot0 (top)    */
+ [1] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 01 - AdapterA-Slot1 (bottom) */
+ [2] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 02 - AdapterB-Slot0 (top)    */
+ [3] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 03 - AdapterB-Slot1 (bottom) */
+ [4] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 04 - AdapterC-Slot0 (top)    */
+ [5] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 05 - AdapterC-Slot1 (bottom) */
+ [6] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 06 - AdapterD-Slot0 (top)    */
+ [7] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 07 - AdapterD-Slot1 (bottom) */
+};
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
        { AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
        { AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/pb1200/Makefile linux_HEAD/arch/mips/au1000/pb1200/Makefile
--- linux-2.6.11.6/arch/mips/au1000/pb1200/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/pb1200/Makefile	2005-03-01 07:33:16.000000000 +0100
@@ -0,0 +1,5 @@
+#
+# Makefile for the Alchemy Semiconductor PB1200 board.
+#
+
+lib-y := init.o board_setup.o irqmap.o
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/pb1200/board_setup.c linux_HEAD/arch/mips/au1000/pb1200/board_setup.c
--- linux-2.6.11.6/arch/mips/au1000/pb1200/board_setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/pb1200/board_setup.c	2005-03-04 20:36:08.000000000 +0100
@@ -0,0 +1,183 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Alchemy Pb1200/Db1200 board setup.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/mc146818rtc.h>
+#include <linux/delay.h>
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+#include <linux/ide.h>
+#endif
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/pgtable.h>
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/mach-pb1x00/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/mach-db1x00/db1200.h>
+#define PB1200_ETH_INT DB1200_ETH_INT
+#define PB1200_IDE_INT DB1200_IDE_INT
+#endif
+
+extern void _board_init_irq(void);
+extern void	(*board_init_irq)(void);
+
+#ifdef CONFIG_BLK_DEV_IDE_AU1XXX
+extern u32 au1xxx_ide_virtbase;
+extern u64 au1xxx_ide_physbase;
+extern int au1xxx_ide_irq;
+
+u32 led_base_addr;
+/* Ddma */
+chan_tab_t *ide_read_ch, *ide_write_ch;
+u32 au1xxx_ide_ddma_enable = 0, switch4ddma = 1; // PIO+ddma
+
+dbdev_tab_t new_dbdev_tab_element = { DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 };
+#endif /* end CONFIG_BLK_DEV_IDE_AU1XXX */
+
+void board_reset (void)
+{
+	bcsr->resets = 0;
+}
+
+void __init board_setup(void)
+{
+	char *argptr = NULL;
+	u32 pin_func;
+
+#if 0
+	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+	 * but it is board specific code, so put it here.
+	 */
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
+	au_writel(pin_func, SYS_PINFUNC);
+
+	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
+	au_sync();
+#endif
+
+#if defined( CONFIG_I2C_ALGO_AU1550 )
+	{
+	u32 freq0, clksrc;
+
+	/* Select SMBUS in CPLD */
+	bcsr->resets &= ~(BCSR_RESETS_PCS0MUX);
+
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func &= ~(3<<17 | 1<<4);
+	/* Set GPIOs correctly */
+	pin_func |= 2<<17;
+	au_writel(pin_func, SYS_PINFUNC);
+	au_sync();
+
+	/* The i2c driver depends on 50Mhz clock */
+	freq0 = au_readl(SYS_FREQCTRL0);
+	au_sync();
+	freq0 &= ~(SYS_FC_FRDIV1_MASK | SYS_FC_FS1 | SYS_FC_FE1);
+	freq0 |= (3<<SYS_FC_FRDIV1_BIT);
+	/* 396Mhz / (3+1)*2 == 49.5Mhz */
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+	freq0 |= SYS_FC_FE1;
+	au_writel(freq0, SYS_FREQCTRL0);
+	au_sync();
+
+	clksrc = au_readl(SYS_CLKSRC);
+	au_sync();
+	clksrc &= ~0x01f00000;
+	/* bit 22 is EXTCLK0 for PSC0 */
+	clksrc |= (0x3 << 22);
+	au_writel(clksrc, SYS_CLKSRC);
+	au_sync();
+	}
+#endif
+
+#ifdef CONFIG_FB_AU1200
+	argptr = prom_getcmdline();
+#ifdef CONFIG_MIPS_PB1200
+	strcat(argptr, " video=au1200fb:panel:s11");
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	strcat(argptr, " video=au1200fb:panel:s7");
+#endif
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE_AU1XXX)
+	/*
+	 * Iniz IDE parameters
+	 */
+	au1xxx_ide_irq = PB1200_IDE_INT;
+	au1xxx_ide_physbase = AU1XXX_ATA_PHYS_ADDR;
+	au1xxx_ide_virtbase = KSEG1ADDR(AU1XXX_ATA_PHYS_ADDR);
+	/*
+	 * change PIO or PIO+Ddma
+	 * check the GPIO-5 pin condition. pb1200:s18_dot */
+	switch4ddma = (au_readl(SYS_PINSTATERD) & (1 << 5)) ? 1 : 0; 
+#endif
+
+	/* The Pb1200 development board uses external MUX for PSC0 to
+	support SMB/SPI. bcsr->resets bit 12: 0=SMB 1=SPI
+	*/
+#if defined(CONFIG_AU1550_PSC_SPI) && defined(CONFIG_I2C_ALGO_AU1550)
+	#error I2C and SPI are mutually exclusive. Both are physically connected to PSC0.\
+			Refer to Pb1200/Db1200 documentation.
+#elif defined( CONFIG_AU1550_PSC_SPI )
+	bcsr->resets |= BCSR_RESETS_PCS0MUX;
+#elif defined( CONFIG_I2C_ALGO_AU1550 )
+	bcsr->resets &= (~BCSR_RESETS_PCS0MUX);
+#endif
+	au_sync();
+
+#ifdef CONFIG_MIPS_PB1200
+	printk("AMD Alchemy Pb1200 Board\n");
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	printk("AMD Alchemy Db1200 Board\n");
+#endif
+
+	/* Setup Pb1200 External Interrupt Controller */
+	{
+		extern void (*board_init_irq)(void);
+		extern void _board_init_irq(void);
+		board_init_irq = _board_init_irq;
+	}
+}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/pb1200/init.c linux_HEAD/arch/mips/au1000/pb1200/init.c
--- linux-2.6.11.6/arch/mips/au1000/pb1200/init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/pb1200/init.c	2005-03-01 07:33:16.000000000 +0100
@@ -0,0 +1,69 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	PB1200 board setup
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+int prom_argc;
+char **prom_argv, **prom_envp;
+extern void  __init prom_init_cmdline(void);
+extern char *prom_getenv(char *envname);
+
+const char *get_system_type(void)
+{
+	return "Alchemy Pb1200";
+}
+
+void __init prom_init(void)
+{
+	unsigned char *memsize_str;
+	unsigned long memsize;
+
+	prom_argc = (int) fw_arg0;
+	prom_argv = (char **) fw_arg1;
+	prom_envp = (char **) fw_arg2;
+
+	mips_machgroup = MACH_GROUP_ALCHEMY;
+	mips_machtype = MACH_PB1200;
+
+	prom_init_cmdline();
+	memsize_str = prom_getenv("memsize");
+	if (!memsize_str) {
+		memsize = 0x08000000;
+	} else {
+		memsize = simple_strtol(memsize_str, NULL, 0);
+	}
+	add_memory_region(0, memsize, BOOT_MEM_RAM);
+}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/pb1200/irqmap.c linux_HEAD/arch/mips/au1000/pb1200/irqmap.c
--- linux-2.6.11.6/arch/mips/au1000/pb1200/irqmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/pb1200/irqmap.c	2005-03-01 07:33:16.000000000 +0100
@@ -0,0 +1,180 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1xxx irq map table
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/mach-au1x00/au1000.h>
+
+#ifdef CONFIG_MIPS_PB1200
+#include <asm/mach-pb1x00/pb1200.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#include <asm/mach-db1x00/db1200.h>
+#define PB1200_INT_BEGIN DB1200_INT_BEGIN
+#define PB1200_INT_END DB1200_INT_END
+#endif
+
+au1xxx_irq_map_t au1xxx_irq_map[] = {
+	{ AU1000_GPIO_7, INTC_INT_LOW_LEVEL, 0 }, // This is exteranl interrupt cascade
+};
+
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
+/*
+ *	Support for External interrupts on the PbAu1200 Development platform.
+ */
+static volatile int pb1200_cascade_en=0;
+
+void pb1200_cascade_handler( int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned short bisr = bcsr->int_status;
+	int extirq_nr = 0;
+
+	/* Clear all the edge interrupts. This has no effect on level */
+	bcsr->int_status = bisr;
+	for( ; bisr; bisr &= (bisr-1) )
+	{
+		extirq_nr = (PB1200_INT_BEGIN-1) + au_ffs(bisr);
+		/* Ack and dispatch IRQ */
+		do_IRQ(extirq_nr,regs);
+	}
+}
+
+inline void pb1200_enable_irq(unsigned int irq_nr)
+{
+	bcsr->intset_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intset = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+inline void pb1200_disable_irq(unsigned int irq_nr)
+{
+	bcsr->intclr_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intclr = 1<<(irq_nr - PB1200_INT_BEGIN);
+}
+
+static unsigned int pb1200_startup_irq( unsigned int irq_nr )
+{
+	if (++pb1200_cascade_en == 1)
+	{
+		request_irq(AU1000_GPIO_7, &pb1200_cascade_handler,
+			0, "Pb1200 Cascade", &pb1200_cascade_handler );
+#ifdef CONFIG_MIPS_PB1200
+    /* We have a problem with CPLD rev3. Enable a workaround */
+	if( ((bcsr->whoami & BCSR_WHOAMI_CPLD)>>4) <= 3)
+	{
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("Pb1200 must be at CPLD rev4. Please have Pb1200\n");
+		printk("updated to latest revision. This software will not\n");
+		printk("work on anything less than CPLD rev4\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		printk("\nWARNING!!!\n");
+		while(1);
+	}
+#endif
+	}
+	pb1200_enable_irq(irq_nr);
+	return 0;
+}
+
+static void pb1200_shutdown_irq( unsigned int irq_nr )
+{
+	pb1200_disable_irq(irq_nr);
+	if (--pb1200_cascade_en == 0)
+	{
+		free_irq(AU1000_GPIO_7,&pb1200_cascade_handler );
+	}
+	return;
+}
+
+static inline void pb1200_mask_and_ack_irq(unsigned int irq_nr)
+{
+	pb1200_disable_irq( irq_nr );
+}
+
+static void pb1200_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS))) {
+		pb1200_enable_irq(irq_nr);
+	}
+}
+
+static struct hw_interrupt_type external_irq_type =
+{
+#ifdef CONFIG_MIPS_PB1200
+	"Pb1200 Ext",
+#endif
+#ifdef CONFIG_MIPS_DB1200
+	"Db1200 Ext",
+#endif
+	pb1200_startup_irq,
+	pb1200_shutdown_irq,
+	pb1200_enable_irq,
+	pb1200_disable_irq,
+	pb1200_mask_and_ack_irq,
+	pb1200_end_irq,
+	NULL
+};
+
+void _board_init_irq(void)
+{
+	int irq_nr;
+
+	for (irq_nr = PB1200_INT_BEGIN; irq_nr <= PB1200_INT_END; irq_nr++)
+	{
+		irq_desc[irq_nr].handler = &external_irq_type;
+		pb1200_disable_irq(irq_nr);
+	}
+
+	/* GPIO_7 can not be hooked here, so it is hooked upon first
+	request of any source attached to the cascade */
+}
+
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/pb1500/irqmap.c linux_HEAD/arch/mips/au1000/pb1500/irqmap.c
--- linux-2.6.11.6/arch/mips/au1000/pb1500/irqmap.c	2005-03-26 04:28:39.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/pb1500/irqmap.c	2005-03-01 15:00:11.000000000 +0100
@@ -47,6 +47,11 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+char irq_tab_alchemy[][5] __initdata = {
+ [12] = { -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT370   */
+ [13] = { -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+};
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/au1000/pb1550/irqmap.c linux_HEAD/arch/mips/au1000/pb1550/irqmap.c
--- linux-2.6.11.6/arch/mips/au1000/pb1550/irqmap.c	2005-03-26 04:28:38.000000000 +0100
+++ linux_HEAD/arch/mips/au1000/pb1550/irqmap.c	2005-03-01 15:00:12.000000000 +0100
@@ -47,6 +47,11 @@
 #include <asm/system.h>
 #include <asm/mach-au1x00/au1000.h>
 
+char irq_tab_alchemy[][5] __initdata = {
+ [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
+ [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+};
+
 au1xxx_irq_map_t au1xxx_irq_map[] = {
 	{ AU1000_GPIO_0, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_GPIO_1, INTC_INT_LOW_LEVEL, 0 },
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/cobalt/int-handler.S linux_HEAD/arch/mips/cobalt/int-handler.S
--- linux-2.6.11.6/arch/mips/cobalt/int-handler.S	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/cobalt/int-handler.S	2005-02-21 22:17:43.000000000 +0100
@@ -18,8 +18,8 @@
 		SAVE_ALL
 		CLI
 
-		la	ra, ret_from_irq
-		move	a1, sp
+		PTR_LA	ra, ret_from_irq
+		move	a0, sp
 		j	cobalt_irq
 
 		END(cobalt_handle_int)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/cobalt/irq.c linux_HEAD/arch/mips/cobalt/irq.c
--- linux-2.6.11.6/arch/mips/cobalt/irq.c	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/cobalt/irq.c	2005-02-21 22:17:43.000000000 +0100
@@ -10,6 +10,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irq.h>
+#include <linux/interrupt.h>
 
 #include <asm/i8259.h>
 #include <asm/irq_cpu.h>
@@ -25,8 +26,8 @@ extern void cobalt_handle_int(void);
  * the CPU interrupt lines, and ones that come in on the via chip. The CPU
  * mappings are:
  *
- *    16,  - Software interrupt 0 (unused)	IE_SW0
- *    17   - Software interrupt 1 (unused)	IE_SW0
+ *    16   - Software interrupt 0 (unused)	IE_SW0
+ *    17   - Software interrupt 1 (unused)	IE_SW1
  *    18   - Galileo chip (timer)		IE_IRQ0
  *    19   - Tulip 0 + NCR SCSI			IE_IRQ1
  *    20   - Tulip 1				IE_IRQ2
@@ -82,11 +83,15 @@ asmlinkage void cobalt_irq(struct pt_reg
 	}
 
 	if (pending & CAUSEF_IP7) {			/* int 23 */
-		do_IRQ(COBALT_QUBE_SLOT_IRQ, regs);
+		do_IRQ(23, regs);
 		return;
 	}
 }
 
+static struct irqaction irq_via = {
+	no_action, 0, { { 0, } }, "cascade", NULL, NULL
+};
+ 
 void __init arch_init_irq(void)
 {
 	set_except_vector(0, cobalt_handle_int);
@@ -99,4 +104,6 @@ void __init arch_init_irq(void)
 	 *  (except IE4, we already masked those at VIA level)
 	 */
 	change_c0_status(ST0_IM, IE_IRQ4);
+
+	setup_irq(COBALT_VIA_IRQ, &irq_via);
 }
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/cobalt/reset.c linux_HEAD/arch/mips/cobalt/reset.c
--- linux-2.6.11.6/arch/mips/cobalt/reset.c	2005-03-26 04:28:13.000000000 +0100
+++ linux_HEAD/arch/mips/cobalt/reset.c	2005-02-21 22:17:43.000000000 +0100
@@ -16,48 +16,45 @@
 #include <asm/reboot.h>
 #include <asm/system.h>
 #include <asm/mipsregs.h>
+#include <asm/cobalt/cobalt.h>
 
-void cobalt_machine_restart(char *command)
+void cobalt_machine_halt(void)
 {
-	*(volatile char *)0xbc000000 = 0x0f;
+	int state, last, diff;
+	unsigned long mark;
 
 	/*
-	 * Ouch, we're still alive ... This time we take the silver bullet ...
-	 * ... and find that we leave the hardware in a state in which the
-	 * kernel in the flush locks up somewhen during of after the PCI
-	 * detection stuff.
+	 * turn off bar on Qube, flash power off LED on RaQ (0.5Hz)
+	 *
+	 * restart if ENTER and SELECT are pressed
 	 */
-	set_c0_status(ST0_BEV | ST0_ERL);
-	change_c0_config(CONF_CM_CMASK, CONF_CM_UNCACHED);
-	flush_cache_all();
-	write_c0_wired(0);
-	__asm__ __volatile__(
-		"jr\t%0"
-		:
-		: "r" (0xbfc00000));
-}
 
-extern int led_state;
-#define kLED            0xBC000000
-#define LEDSet(x)       (*(volatile unsigned char *) kLED) = (( unsigned char)x)
+	last = COBALT_KEY_PORT;
 
-void cobalt_machine_halt(void)
-{
-	int mark;
+	for (state = 0;;) {
+
+		state ^= COBALT_LED_POWER_OFF;
+		COBALT_LED_PORT = state;
+
+		diff = COBALT_KEY_PORT ^ last;
+		last ^= diff;
 
-	/* Blink our cute? little LED (number 3)... */
-	while (1) {
-		led_state = led_state | ( 1 << 3 );
-		LEDSet(led_state);
-		mark = jiffies;
-		while (jiffies<(mark+HZ));
-		led_state = led_state & ~( 1 << 3 );
-		LEDSet(led_state);
-		mark = jiffies;
-		while (jiffies<(mark+HZ));
+		if((diff & (COBALT_KEY_ENTER | COBALT_KEY_SELECT)) && !(~last & (COBALT_KEY_ENTER | COBALT_KEY_SELECT)))
+			COBALT_LED_PORT = COBALT_LED_RESET;
+
+		for (mark = jiffies; jiffies - mark < HZ;)
+			;
 	}
 }
 
+void cobalt_machine_restart(char *command)
+{
+	COBALT_LED_PORT = COBALT_LED_RESET;
+
+	/* we should never get here */
+	cobalt_machine_halt();
+}
+
 /*
  * This triggers the luser mode device driver for the power switch ;-)
  */
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/cobalt/setup.c linux_HEAD/arch/mips/cobalt/setup.c
--- linux-2.6.11.6/arch/mips/cobalt/setup.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/cobalt/setup.c	2005-03-04 20:36:08.000000000 +0100
@@ -13,6 +13,8 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
 
 #include <asm/bootinfo.h>
 #include <asm/time.h>
@@ -21,6 +23,7 @@
 #include <asm/processor.h>
 #include <asm/reboot.h>
 #include <asm/gt64120.h>
+#include <asm/serial.h>
 
 #include <asm/cobalt/cobalt.h>
 
@@ -30,27 +33,25 @@ extern void cobalt_machine_power_off(voi
 
 int cobalt_board_id;
 
-static char my_cmdline[CL_SIZE] = {
- "console=ttyS0,115200 "
-#ifdef CONFIG_IP_PNP
- "ip=on "
-#endif
-#ifdef CONFIG_ROOT_NFS
- "root=/dev/nfs "
-#else
- "root=/dev/hda1 "
-#endif
- };
-
 const char *get_system_type(void)
 {
+	switch (cobalt_board_id) {
+		case COBALT_BRD_ID_QUBE1:
+			return "Cobalt Qube";
+		case COBALT_BRD_ID_RAQ1:
+			return "Cobalt RaQ";
+		case COBALT_BRD_ID_QUBE2:
+			return "Cobalt Qube2";
+		case COBALT_BRD_ID_RAQ2:
+			return "Cobalt RaQ2";
+	}
 	return "MIPS Cobalt";
 }
 
 static void __init cobalt_timer_setup(struct irqaction *irq)
 {
-	/* Load timer value for 150 Hz */
-	GALILEO_OUTL(500000, GT_TC0_OFS);
+	/* Load timer value for 1KHz */
+	GALILEO_OUTL(50*1000*1000 / 1000, GT_TC0_OFS);
 
 	/* Register our timer interrupt */
 	setup_irq(COBALT_TIMER_IRQ, irq);
@@ -58,17 +59,17 @@ static void __init cobalt_timer_setup(st
 	/* Enable timer ints */
 	GALILEO_OUTL((GALILEO_ENTC0 | GALILEO_SELTC0), GT_TC_CONTROL_OFS);
 	/* Unmask timer int */
-	GALILEO_OUTL(0x100, GT_INTRMASK_OFS);
+	GALILEO_OUTL(GALILEO_T0EXP, GT_INTRMASK_OFS);
 }
 
 extern struct pci_ops gt64111_pci_ops;
 
 static struct resource cobalt_mem_resource = {
-	"GT64111 PCI MEM", GT64111_IO_BASE, 0xffffffffUL, IORESOURCE_MEM
+	"PCI memory", GT64111_MEM_BASE, GT64111_MEM_END, IORESOURCE_MEM
 };
 
 static struct resource cobalt_io_resource = {
-	"GT64111 IO MEM", 0x00001000UL, 0x0fffffffUL, IORESOURCE_IO
+	"PCI I/O", 0x1000, 0xffff, IORESOURCE_IO
 };
 
 static struct resource cobalt_io_resources[] = {
@@ -86,11 +87,12 @@ static struct pci_controller cobalt_pci_
 	.mem_resource	= &cobalt_mem_resource,
 	.mem_offset	= 0,
 	.io_resource	= &cobalt_io_resource,
-	.io_offset	= 0x00001000UL - GT64111_IO_BASE
+	.io_offset	= 0 - GT64111_IO_BASE
 };
 
-static void __init cobalt_setup(void)
+static int __init cobalt_setup(void)
 {
+	static struct uart_port uart;
 	unsigned int devfn = PCI_DEVFN(COBALT_PCICONF_VIA, 0);
 	int i;
 
@@ -100,7 +102,10 @@ static void __init cobalt_setup(void)
 
 	board_timer_setup = cobalt_timer_setup;
 
-        set_io_port_base(KSEG1ADDR(GT64111_IO_BASE));
+        set_io_port_base(CKSEG1ADDR(GT64111_IO_BASE));
+
+	/* I/O port resource must include UART and LCD/buttons */
+	ioport_resource.end = 0x0fffffff;
 
 	/*
 	 * This is a prom style console. We just poke at the
@@ -120,27 +125,65 @@ static void __init cobalt_setup(void)
         cobalt_board_id >>= ((VIA_COBALT_BRD_ID_REG & 3) * 8);
         cobalt_board_id = VIA_COBALT_BRD_REG_to_ID(cobalt_board_id);
 
+	printk("Cobalt board ID: %d\n", cobalt_board_id);
+
 #ifdef CONFIG_PCI
 	register_pci_controller(&cobalt_pci_controller);
 #endif
+
+#ifdef CONFIG_SERIAL_8250
+	if (cobalt_board_id > COBALT_BRD_ID_RAQ1) {
+
+		uart.line	= 0;
+		uart.type	= PORT_UNKNOWN;
+		uart.uartclk	= 18432000;
+		uart.irq	= COBALT_SERIAL_IRQ;
+		uart.flags	= STD_COM_FLAGS;
+		uart.iobase	= 0xc800000;
+		uart.iotype	= UPIO_PORT;
+
+		early_serial_setup(&uart);
+	}
+#endif
+
+	return 0;
 }
 
 early_initcall(cobalt_setup);
 
 /*
  * Prom init. We read our one and only communication with the firmware.
- * Grab the amount of installed memory
+ * Grab the amount of installed memory.
+ * Better boot loaders (CoLo) pass a command line too :-)
  */
 
 void __init prom_init(void)
 {
-	int argc = fw_arg0;
-
-	strcpy(arcs_cmdline, my_cmdline);
+	int narg, indx, posn, nchr;
+	unsigned long memsz;
+	char **argv;
 
 	mips_machgroup = MACH_GROUP_COBALT;
 
-	add_memory_region(0x0, argc & 0x7fffffff, BOOT_MEM_RAM);
+	memsz = fw_arg0 & 0x7fff0000;
+	narg = fw_arg0 & 0x0000ffff;
+
+	if (narg) {
+		arcs_cmdline[0] = '\0';
+		argv = (char **) fw_arg1;
+		posn = 0;
+		for (indx = 1; indx < narg; ++indx) {
+			nchr = strlen(argv[indx]);
+			if (posn + 1 + nchr + 1 > sizeof(arcs_cmdline))
+				break;
+			if (posn)
+				arcs_cmdline[posn++] = ' ';
+			strcpy(arcs_cmdline + posn, argv[indx]);
+			posn += nchr;
+		}
+	}
+
+	add_memory_region(0x0, memsz, BOOT_MEM_RAM);
 }
 
 unsigned long __init prom_free_prom_memory(void)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/atlas_defconfig linux_HEAD/arch/mips/configs/atlas_defconfig
--- linux-2.6.11.6/arch/mips/configs/atlas_defconfig	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/configs/atlas_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:00 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:24 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,33 +54,55 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 CONFIG_MIPS_ATLAS=y
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
@@ -90,7 +110,10 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_MSC=y
-# CONFIG_CPU_LITTLE_ENDIAN is not set
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_MIPS_BOARDS_GEN=y
 CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
@@ -117,10 +140,22 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_BOARD_SCACHE=y
+CONFIG_RM7000_CPU_SCACHE=y
 CONFIG_CPU_HAS_PREFETCH=y
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -143,10 +178,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -290,7 +321,6 @@ CONFIG_SCSI_ISCSI_ATTRS=m
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
@@ -302,7 +332,6 @@ CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
 CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
 # CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
 # CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=y
@@ -334,6 +363,8 @@ CONFIG_DM_CRYPT=m
 CONFIG_DM_SNAPSHOT=m
 CONFIG_DM_MIRROR=m
 CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
 
 #
 # Fusion MPT device support
@@ -502,7 +533,7 @@ CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -601,6 +632,7 @@ CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -611,6 +643,7 @@ CONFIG_NET_CLS_IND=y
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -740,19 +773,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -765,6 +785,18 @@ CONFIG_MOUSE_SERIAL=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -811,6 +843,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -844,7 +881,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -854,13 +890,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -901,7 +933,12 @@ CONFIG_JFS_SECURITY=y
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
 CONFIG_XFS_SECURITY=y
@@ -1050,7 +1087,9 @@ CONFIG_NLS_UTF8=m
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -1072,6 +1111,7 @@ CONFIG_CRYPTO_SHA1=m
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/capcella_defconfig linux_HEAD/arch/mips/configs/capcella_defconfig
--- linux-2.6.11.6/arch/mips/configs/capcella_defconfig	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/configs/capcella_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:00 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:25 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,48 +54,73 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-CONFIG_ZAO_CAPCELLA=y
-CONFIG_PCI_VR41XX=y
-CONFIG_VRC4173=y
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_VICTOR_MPC30X is not set
+CONFIG_ZAO_CAPCELLA=y
+CONFIG_PCI_VR41XX=y
+# CONFIG_GPIO_VR41XX is not set
+CONFIG_VRC4173=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -121,6 +144,17 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -144,10 +178,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -428,19 +458,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=m
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -450,6 +467,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=m
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -470,6 +499,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_VR41XX is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -508,6 +538,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -541,7 +576,6 @@ CONFIG_WATCHDOG=y
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -551,13 +585,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -583,6 +613,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -675,7 +709,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/cobalt_defconfig linux_HEAD/arch/mips/configs/cobalt_defconfig
--- linux-2.6.11.6/arch/mips/configs/cobalt_defconfig	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/configs/cobalt_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:00 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:26 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,40 +48,64 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 CONFIG_MIPS_COBALT=y
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_GT64111=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -108,6 +130,17 @@ CONFIG_CPU_NEVADA=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -133,10 +166,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -414,19 +443,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -436,6 +452,18 @@ CONFIG_SERIO_RAW=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -482,6 +510,11 @@ CONFIG_COBALT_LCD=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -515,7 +548,6 @@ CONFIG_COBALT_LCD=y
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -525,13 +557,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -561,6 +589,10 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -621,7 +653,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_NFSD is not set
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -650,7 +681,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/db1000_defconfig linux_HEAD/arch/mips/configs/db1000_defconfig
--- linux-2.6.11.6/arch/mips/configs/db1000_defconfig	2005-03-26 04:28:43.000000000 +0100
+++ linux_HEAD/arch/mips/configs/db1000_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:01 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:27 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,55 +54,65 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+CONFIG_MIPS_DB1000=y
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-CONFIG_SOC_AU1000=y
-# CONFIG_SOC_AU1100 is not set
-# CONFIG_SOC_AU1500 is not set
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-CONFIG_MIPS_DB1000=y
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1000=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
@@ -127,6 +135,15 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -168,6 +185,7 @@ CONFIG_PCMCIA=m
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
 
 #
 # Device Drivers
@@ -183,7 +201,75 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -417,18 +503,6 @@ CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -438,6 +512,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -472,7 +557,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
@@ -488,6 +574,11 @@ CONFIG_SYNCLINK_CS=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -521,7 +612,6 @@ CONFIG_SYNCLINK_CS=m
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -531,12 +621,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -575,6 +662,10 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -620,6 +711,8 @@ CONFIG_RAMFS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -708,7 +801,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -731,6 +826,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/db1100_defconfig linux_HEAD/arch/mips/configs/db1100_defconfig
--- linux-2.6.11.6/arch/mips/configs/db1100_defconfig	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/configs/db1100_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:01 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:27 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,55 +54,65 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+CONFIG_MIPS_DB1100=y
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-CONFIG_SOC_AU1100=y
-# CONFIG_SOC_AU1500 is not set
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-CONFIG_MIPS_DB1100=y
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1100=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
@@ -127,12 +135,21 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_64BIT_PHYS_ADDR is not set
+CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
@@ -166,6 +183,7 @@ CONFIG_PCMCIA=m
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
 
 #
 # Device Drivers
@@ -181,7 +199,75 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -415,18 +501,6 @@ CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=m
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -436,6 +510,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=m
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -467,7 +552,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
@@ -483,6 +569,11 @@ CONFIG_SYNCLINK_CS=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -516,7 +607,6 @@ CONFIG_SYNCLINK_CS=m
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -526,12 +616,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -570,6 +657,10 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -615,6 +706,8 @@ CONFIG_RAMFS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -703,7 +796,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -726,6 +821,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/db1500_defconfig linux_HEAD/arch/mips/configs/db1500_defconfig
--- linux-2.6.11.6/arch/mips/configs/db1500_defconfig	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/configs/db1500_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:01 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:28 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,56 +54,66 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+CONFIG_MIPS_DB1500=y
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-CONFIG_SOC_AU1500=y
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-CONFIG_MIPS_DB1500=y
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1500=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
@@ -128,6 +136,15 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -176,6 +193,7 @@ CONFIG_PCMCIA_AU1X00=m
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
 
 #
 # Device Drivers
@@ -193,8 +211,8 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -239,9 +257,7 @@ CONFIG_MTD_CFI_UTIL=y
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_DB1X00=y
-CONFIG_MTD_DB1X00_BOOT=y
-CONFIG_MTD_DB1X00_USER=y
+CONFIG_MTD_ALCHEMY=y
 
 #
 # Self-contained MTD device drivers
@@ -549,19 +565,6 @@ CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -571,6 +574,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -603,7 +618,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -620,6 +636,11 @@ CONFIG_SYNCLINK_CS=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -647,7 +668,6 @@ CONFIG_SYNCLINK_CS=m
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -689,6 +709,8 @@ CONFIG_SOUND_AU1000=y
 #
 # USB support
 #
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
 CONFIG_USB=y
 # CONFIG_USB_DEBUG is not set
 
@@ -699,14 +721,14 @@ CONFIG_USB=y
 # CONFIG_USB_BANDWIDTH is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
 # USB Host Controller Drivers
 #
 # CONFIG_USB_EHCI_HCD is not set
 CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 # CONFIG_USB_UHCI_HCD is not set
 # CONFIG_USB_SL811_HCD is not set
 
@@ -762,6 +784,7 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_PEGASUS is not set
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=m
 
 #
 # USB port drivers
@@ -828,6 +851,10 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -963,7 +990,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -986,6 +1015,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/db1550_defconfig linux_HEAD/arch/mips/configs/db1550_defconfig
--- linux-2.6.11.6/arch/mips/configs/db1550_defconfig	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/configs/db1550_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:02 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:29 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,56 +54,66 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+CONFIG_MIPS_DB1550=y
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-# CONFIG_SOC_AU1500 is not set
-CONFIG_SOC_AU1550=y
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-CONFIG_MIPS_DB1550=y
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1550=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
@@ -128,6 +136,15 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -176,6 +193,7 @@ CONFIG_PCMCIA_AU1X00=m
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
 
 #
 # Device Drivers
@@ -193,8 +211,8 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -238,9 +256,7 @@ CONFIG_MTD_CFI_UTIL=y
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_DB1550=y
-CONFIG_MTD_DB1550_BOOT=y
-CONFIG_MTD_DB1550_USER=y
+CONFIG_MTD_ALCHEMY=y
 
 #
 # Self-contained MTD device drivers
@@ -588,19 +604,6 @@ CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -610,6 +613,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -660,6 +675,11 @@ CONFIG_SYNCLINK_CS=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -687,7 +707,6 @@ CONFIG_SYNCLINK_CS=m
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -697,13 +716,9 @@ CONFIG_SYNCLINK_CS=m
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -742,6 +757,10 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -877,7 +896,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -900,6 +921,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ddb5476_defconfig linux_HEAD/arch/mips/configs/ddb5476_defconfig
--- linux-2.6.11.6/arch/mips/configs/ddb5476_defconfig	2005-03-26 04:28:40.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ddb5476_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:02 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:30 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,40 +48,64 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 CONFIG_DDB5476=y
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_DDB5XXX_COMMON=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -109,6 +131,17 @@ CONFIG_CPU_R5432=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -135,11 +168,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-CONFIG_PCMCIA_PROBE=y
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -434,19 +462,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -456,6 +471,18 @@ CONFIG_SERIO_RAW=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -502,6 +529,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -529,6 +561,10 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -536,6 +572,7 @@ CONFIG_FB=y
 # CONFIG_FB_CYBER2000 is not set
 # CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_RADEON_OLD is not set
@@ -574,13 +611,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -606,6 +639,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -667,7 +704,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -696,7 +732,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="ip=any"
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ddb5477_defconfig linux_HEAD/arch/mips/configs/ddb5477_defconfig
--- linux-2.6.11.6/arch/mips/configs/ddb5477_defconfig	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ddb5477_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:02 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:30 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,41 +48,65 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 CONFIG_DDB5477=y
-CONFIG_DDB5477_BUS_FREQUENCY=0
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+CONFIG_DDB5477_BUS_FREQUENCY=0
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_DDB5XXX_COMMON=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -109,6 +131,17 @@ CONFIG_CPU_R5432=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -134,10 +167,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -415,19 +444,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -437,6 +453,18 @@ CONFIG_SERIO_RAW=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -483,6 +511,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -516,7 +549,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -526,13 +558,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -558,6 +586,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -650,7 +682,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="ip=any"
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/decstation_defconfig linux_HEAD/arch/mips/configs/decstation_defconfig
--- linux-2.6.11.6/arch/mips/configs/decstation_defconfig	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/configs/decstation_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:31 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,40 +54,64 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 CONFIG_MACH_DECSTATION=y
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_EARLY_PRINTK=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=4
@@ -114,6 +136,16 @@ CONFIG_CPU_R3000=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -134,10 +166,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -391,18 +419,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -412,6 +428,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -456,6 +483,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -489,7 +521,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -503,10 +534,6 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -534,6 +561,10 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -590,7 +621,6 @@ CONFIG_RAMFS=y
 #
 # CONFIG_NFS_FS is not set
 # CONFIG_NFSD is not set
-# CONFIG_EXPORTFS is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -630,7 +660,9 @@ CONFIG_ULTRIX_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/e55_defconfig linux_HEAD/arch/mips/configs/e55_defconfig
--- linux-2.6.11.6/arch/mips/configs/e55_defconfig	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/configs/e55_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:32 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,47 +54,72 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-CONFIG_CASIO_E55=y
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-# CONFIG_VRC4171 is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+CONFIG_CASIO_E55=y
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_GPIO_VR41XX is not set
+# CONFIG_VRC4171 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -120,6 +143,17 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -140,11 +174,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-CONFIG_PCMCIA_PROBE=y
-
-#
 # PCI Hotplug Support
 #
 
@@ -408,18 +437,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -429,6 +446,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -449,6 +477,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_VR41XX is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -487,6 +516,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -521,7 +555,6 @@ CONFIG_WATCHDOG=y
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -535,10 +568,6 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -562,6 +591,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -653,7 +686,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ev64120_defconfig linux_HEAD/arch/mips/configs/ev64120_defconfig
--- linux-2.6.11.6/arch/mips/configs/ev64120_defconfig	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ev64120_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:33 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,40 +54,64 @@ CONFIG_MODULE_SRCVERSION_ALL=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 CONFIG_MIPS_EV64120=y
-# CONFIG_EVB_PCI1 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_EVB_PCI1 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_MIPS_GT64120=y
 # CONFIG_SYSCLK_75 is not set
 # CONFIG_SYSCLK_83 is not set
@@ -116,6 +138,17 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -142,10 +175,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -409,19 +438,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -431,6 +447,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -477,6 +505,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -510,7 +543,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -520,13 +552,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -552,6 +580,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -613,7 +645,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -642,7 +673,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="console=ttyS0,115200 root=/dev/nfs rw nfsroot=192.168.1.1:/mnt/disk2/fs.gal ip=192.168.1.211:192.168.1.1:::gt::"
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ev96100_defconfig linux_HEAD/arch/mips/configs/ev96100_defconfig
--- linux-2.6.11.6/arch/mips/configs/ev96100_defconfig	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ev96100_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:03 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:33 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,39 +54,63 @@ CONFIG_MODULE_SRCVERSION_ALL=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 CONFIG_MIPS_EV96100=y
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
@@ -115,6 +137,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -142,10 +175,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -366,18 +395,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -387,6 +404,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -432,6 +460,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -465,7 +498,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -479,10 +511,6 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -506,6 +534,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -567,7 +599,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -596,7 +627,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ip22_defconfig linux_HEAD/arch/mips/configs/ip22_defconfig
--- linux-2.6.11.6/arch/mips/configs/ip22_defconfig	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ip22_defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:04 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:34 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,7 +22,6 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
@@ -33,6 +29,7 @@ CONFIG_IKCONFIG_PROC=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +39,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,40 +55,64 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 CONFIG_SGI_IP22=y
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_ARC32=y
@@ -119,6 +141,17 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -135,6 +168,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_EISA=y
 # CONFIG_EISA is not set
 CONFIG_MMU=y
 
@@ -144,10 +178,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -409,7 +439,7 @@ CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -478,6 +508,7 @@ CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -488,6 +519,7 @@ CONFIG_NET_CLS_U32=m
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -568,18 +600,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -597,6 +617,17 @@ CONFIG_MOUSE_SERIAL=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -648,6 +679,11 @@ CONFIG_RAW_DRIVER=m
 CONFIG_MAX_RAW_DEVS=256
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -692,7 +728,6 @@ CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_VGA16 is not set
 # CONFIG_LOGO_LINUX_CLUT224 is not set
 CONFIG_LOGO_SGI_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -706,10 +741,6 @@ CONFIG_LOGO_SGI_CLUT224=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -739,7 +770,12 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
 CONFIG_XFS_SECURITY=y
@@ -907,7 +943,9 @@ CONFIG_NLS_UTF8=m
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -930,6 +968,7 @@ CONFIG_CRYPTO_SHA1=m
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
@@ -944,7 +983,7 @@ CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=m
 CONFIG_CRYPTO_CRC32C=m
-CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ip27_defconfig linux_HEAD/arch/mips/configs/ip27_defconfig
--- linux-2.6.11.6/arch/mips/configs/ip27_defconfig	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ip27_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:04 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:35 2005
 #
 CONFIG_MIPS=y
-CONFIG_MIPS64=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -24,14 +22,15 @@ CONFIG_POSIX_MQUEUE=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=15
-# CONFIG_HOTPLUG is not set
+CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_CPUSETS=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +40,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,45 +57,70 @@ CONFIG_STOP_MACHINE=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
 CONFIG_SGI_IP27=y
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
 # CONFIG_SGI_SN0_N_MODE is not set
 CONFIG_DISCONTIGMEM=y
 CONFIG_NUMA=y
 # CONFIG_MAPPED_KERNEL is not set
 # CONFIG_REPLICATE_KTEXT is not set
 # CONFIG_REPLICATE_EXHANDLERS is not set
-# CONFIG_SGI_IP32 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
-# CONFIG_SNI_RM200_PCI is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_IP27=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=7
 CONFIG_ARC64=y
 CONFIG_BOOT_ELF64=y
@@ -121,6 +146,16 @@ CONFIG_CPU_R10000=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_MIPS32 is not set
+CONFIG_MIPS64=y
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -150,10 +185,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -163,7 +194,7 @@ CONFIG_MMU=y
 #
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
-# CONFIG_BUILD_ELF64 is not set
+CONFIG_BUILD_ELF64=y
 CONFIG_MIPS32_COMPAT=y
 CONFIG_COMPAT=y
 CONFIG_MIPS32_O32=y
@@ -179,7 +210,7 @@ CONFIG_BINFMT_ELF32=y
 #
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=m
 
 #
 # Memory Technology Devices (MTD)
@@ -256,7 +287,7 @@ CONFIG_SCSI_LOGGING=y
 #
 CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
 
 #
 # SCSI low-level drivers
@@ -274,7 +305,6 @@ CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
@@ -282,7 +312,6 @@ CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=y
@@ -313,6 +342,8 @@ CONFIG_DM_CRYPT=m
 CONFIG_DM_SNAPSHOT=m
 CONFIG_DM_MIRROR=m
 CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
 
 #
 # Fusion MPT device support
@@ -404,6 +435,7 @@ CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -413,6 +445,7 @@ CONFIG_NET_CLS_U32=m
 # CONFIG_NET_CLS_IND is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -513,25 +546,16 @@ CONFIG_SGI_IOC3_ETH_HW_TX_CSUM=y
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
+# Hardware I/O ports
 #
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_LIBPS2=m
 CONFIG_SERIO_RAW=m
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
 
 #
 # Character devices
@@ -584,6 +608,11 @@ CONFIG_SGI_IP27_RTC=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -611,7 +640,6 @@ CONFIG_SGI_IP27_RTC=y
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -621,13 +649,9 @@ CONFIG_SGI_IP27_RTC=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -642,7 +666,11 @@ CONFIG_USB_ARCH_HAS_OHCI=y
 #
 # InfiniBand support
 #
-# CONFIG_INFINIBAND is not set
+CONFIG_INFINIBAND=m
+CONFIG_INFINIBAND_MTHCA=m
+# CONFIG_INFINIBAND_MTHCA_DEBUG is not set
+CONFIG_INFINIBAND_IPOIB=m
+# CONFIG_INFINIBAND_IPOIB_DEBUG is not set
 
 #
 # File systems
@@ -661,6 +689,10 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=m
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
@@ -728,7 +760,6 @@ CONFIG_NFS_V3=y
 # CONFIG_ROOT_NFS is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 CONFIG_SUNRPC_GSS=y
 CONFIG_RPCSEC_GSS_KRB5=y
@@ -772,7 +803,9 @@ CONFIG_SGI_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=15
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -795,6 +828,7 @@ CONFIG_CRYPTO_SHA1=y
 CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=y
 CONFIG_CRYPTO_BLOWFISH=y
 CONFIG_CRYPTO_TWOFISH=y
@@ -809,7 +843,7 @@ CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
 CONFIG_CRYPTO_CRC32C=m
-CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ip32_defconfig linux_HEAD/arch/mips/configs/ip32_defconfig
--- linux-2.6.11.6/arch/mips/configs/ip32_defconfig	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ip32_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:04 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:36 2005
 #
 CONFIG_MIPS=y
-CONFIG_MIPS64=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -25,13 +23,13 @@ CONFIG_BSD_PROCESS_ACCT=y
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +39,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,33 +49,56 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 CONFIG_SGI_IP32=y
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
@@ -84,7 +106,9 @@ CONFIG_ARC=y
 CONFIG_DMA_IP32=y
 CONFIG_OWN_DMA=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -111,6 +135,16 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_MIPS32 is not set
+CONFIG_MIPS64=y
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -138,10 +172,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -268,7 +298,6 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
@@ -276,7 +305,6 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=y
@@ -474,27 +502,26 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
 #
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 # CONFIG_SERIO_MACEPS2 is not set
 # CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
 
 #
 # Character devices
@@ -543,6 +570,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -576,7 +608,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -586,13 +617,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -618,6 +645,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -681,7 +712,6 @@ CONFIG_NFS_V3=y
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -720,7 +750,9 @@ CONFIG_SGI_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/it8172_defconfig linux_HEAD/arch/mips/configs/it8172_defconfig
--- linux-2.6.11.6/arch/mips/configs/it8172_defconfig	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/configs/it8172_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:05 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:36 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -26,13 +23,13 @@ CONFIG_BSD_PROCESS_ACCT=y
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +39,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,40 +55,64 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 CONFIG_MIPS_ITE8172=y
-# CONFIG_IT8172_REVC is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_IT8172_REVC is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_ITE_BOARD_GEN=y
 CONFIG_IT8172_CIR=y
 CONFIG_IT8712=y
@@ -116,6 +138,17 @@ CONFIG_CPU_NEVADA=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -139,10 +172,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -169,8 +198,8 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-# CONFIG_MTD_PARTITIONS is not set
 # CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_PARTITIONS is not set
 
 #
 # User Modules And Translation Layers
@@ -454,18 +483,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -475,6 +492,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -524,6 +552,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -557,7 +590,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -591,10 +623,6 @@ CONFIG_SOUND_IT8172=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -618,6 +646,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -681,7 +713,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -710,7 +741,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ivr_defconfig linux_HEAD/arch/mips/configs/ivr_defconfig
--- linux-2.6.11.6/arch/mips/configs/ivr_defconfig	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ivr_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:05 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:37 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -26,13 +23,13 @@ CONFIG_BSD_PROCESS_ACCT=y
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +39,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,39 +55,63 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 CONFIG_MIPS_IVR=y
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_ITE_BOARD_GEN=y
 CONFIG_IT8172_CIR=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -114,6 +136,17 @@ CONFIG_CPU_NEVADA=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -139,10 +172,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -422,19 +451,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -444,6 +460,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -491,6 +519,11 @@ CONFIG_RTC=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -524,7 +557,6 @@ CONFIG_RTC=y
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -534,13 +566,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -566,6 +594,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -627,7 +659,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -656,7 +687,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/jaguar-atx_defconfig linux_HEAD/arch/mips/configs/jaguar-atx_defconfig
--- linux-2.6.11.6/arch/mips/configs/jaguar-atx_defconfig	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/configs/jaguar-atx_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:05 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:38 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -24,7 +21,6 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
@@ -32,6 +28,7 @@ CONFIG_IKCONFIG_PROC=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -54,35 +52,65 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+CONFIG_MOMENCO_JAGUAR_ATX=y
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-CONFIG_MOMENCO_JAGUAR_ATX=y
-CONFIG_JAGUAR_DMALOW=y
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+CONFIG_JAGUAR_DMALOW=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_LIMITED_DMA=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_IRQ_MV64340=y
@@ -111,6 +139,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_CPU_RM7000 is not set
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -142,10 +181,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -265,7 +300,14 @@ CONFIG_IP_PNP_BOOTP=y
 # CONFIG_INET_IPCOMP is not set
 CONFIG_INET_TUNNEL=m
 CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
+CONFIG_IP_TCPDIAG_IPV6=y
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
 # CONFIG_NETFILTER is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
@@ -390,20 +432,11 @@ CONFIG_MV643XX_ETH_2=y
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
+# CONFIG_SERIO is not set
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
-# CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
 
 #
 # Character devices
@@ -450,6 +483,10 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -477,7 +514,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -487,13 +523,9 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -518,6 +550,10 @@ CONFIG_USB_ARCH_HAS_OHCI=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -569,7 +605,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
@@ -590,7 +625,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -604,7 +641,31 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+CONFIG_CRYPTO_TEST=m
 
 #
 # Hardware crypto devices
@@ -615,6 +676,8 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 #
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/jmr3927_defconfig linux_HEAD/arch/mips/configs/jmr3927_defconfig
--- linux-2.6.11.6/arch/mips/configs/jmr3927_defconfig	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/configs/jmr3927_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:06 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:39 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,39 +48,63 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-CONFIG_TOSHIBA_JMR3927=y
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+CONFIG_TOSHIBA_JMR3927=y
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_MIPS_TX3927=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -108,6 +130,15 @@ CONFIG_CPU_TX39XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -132,10 +163,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -393,19 +420,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -415,6 +429,18 @@ CONFIG_SERIO_RAW=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -425,7 +451,6 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_ROCKETPORT is not set
 # CONFIG_CYCLADES is not set
 # CONFIG_DIGIEPCA is not set
-# CONFIG_DIGI is not set
 # CONFIG_MOXA_INTELLIO is not set
 # CONFIG_MOXA_SMARTIO is not set
 # CONFIG_ISI is not set
@@ -437,10 +462,6 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_SX is not set
 # CONFIG_RIO is not set
 # CONFIG_STALDRV is not set
-# CONFIG_SERIAL_TX3912 is not set
-CONFIG_TXX927_SERIAL=y
-CONFIG_TXX927_SERIAL_CONSOLE=y
-# CONFIG_SERIAL_TXX9 is not set
 
 #
 # Serial drivers
@@ -450,6 +471,12 @@ CONFIG_TXX927_SERIAL_CONSOLE=y
 #
 # Non-8250 serial port support
 #
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_TXX9=y
+CONFIG_HAS_TXX9_SERIAL=y
+CONFIG_SERIAL_TXX9_CONSOLE=y
+CONFIG_SERIAL_TXX9_STDSERIAL=y
 # CONFIG_UNIX98_PTYS is not set
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -476,6 +503,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -503,6 +535,10 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -510,6 +546,7 @@ CONFIG_FB=y
 # CONFIG_FB_CYBER2000 is not set
 # CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_RADEON_OLD is not set
@@ -547,13 +584,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -578,6 +611,10 @@ CONFIG_USB_ARCH_HAS_OHCI=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -637,7 +674,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -666,7 +702,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/lasat200_defconfig linux_HEAD/arch/mips/configs/lasat200_defconfig
--- linux-2.6.11.6/arch/mips/configs/lasat200_defconfig	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/arch/mips/configs/lasat200_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:06 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:39 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,44 +54,68 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-CONFIG_LASAT=y
-CONFIG_PICVUE=y
-CONFIG_PICVUE_PROC=y
-CONFIG_DS1603=y
-CONFIG_LASAT_SYSCTL=y
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+CONFIG_LASAT=y
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+CONFIG_PICVUE=y
+CONFIG_PICVUE_PROC=y
+CONFIG_DS1603=y
+CONFIG_LASAT_SYSCTL=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_MIPS_NILE4=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -117,6 +139,17 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -145,10 +178,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -176,8 +205,8 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -521,19 +550,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -543,6 +559,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -589,6 +617,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -622,7 +655,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -632,13 +664,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -669,6 +697,10 @@ CONFIG_JBD=y
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -732,7 +764,6 @@ CONFIG_NFS_V3=y
 # CONFIG_NFSD is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -761,7 +792,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/malta_defconfig linux_HEAD/arch/mips/configs/malta_defconfig
--- linux-2.6.11.6/arch/mips/configs/malta_defconfig	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/arch/mips/configs/malta_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:53:14 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:40 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,33 +54,55 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 CONFIG_MIPS_MALTA=y
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
@@ -92,7 +112,10 @@ CONFIG_GENERIC_ISA_DMA=y
 CONFIG_I8259=y
 CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_MSC=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_MIPS_BOARDS_GEN=y
 CONFIG_MIPS_GT64120=y
 CONFIG_SWAP_IO_SPACE=y
@@ -120,10 +143,21 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
@@ -145,10 +179,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -326,7 +356,6 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
@@ -334,7 +363,6 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=m
@@ -366,6 +394,8 @@ CONFIG_DM_CRYPT=m
 CONFIG_DM_SNAPSHOT=m
 CONFIG_DM_MIRROR=m
 CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
 
 #
 # Fusion MPT device support
@@ -534,7 +564,7 @@ CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -633,6 +663,7 @@ CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -643,6 +674,7 @@ CONFIG_NET_CLS_IND=y
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -772,19 +804,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -794,6 +813,18 @@ CONFIG_SERIO_SERPORT=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -839,6 +870,11 @@ CONFIG_RTC=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -872,7 +908,6 @@ CONFIG_RTC=y
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -882,13 +917,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -929,7 +960,12 @@ CONFIG_JFS_SECURITY=y
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
 CONFIG_XFS_SECURITY=y
@@ -1078,7 +1114,9 @@ CONFIG_NLS_UTF8=m
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -1100,6 +1138,7 @@ CONFIG_CRYPTO_SHA1=m
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/mpc30x_defconfig linux_HEAD/arch/mips/configs/mpc30x_defconfig
--- linux-2.6.11.6/arch/mips/configs/mpc30x_defconfig	2005-03-26 04:28:32.000000000 +0100
+++ linux_HEAD/arch/mips/configs/mpc30x_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:07 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:41 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,48 +54,73 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-CONFIG_VICTOR_MPC30X=y
-# CONFIG_ZAO_CAPCELLA is not set
-CONFIG_PCI_VR41XX=y
-CONFIG_VRC4173=y
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+CONFIG_VICTOR_MPC30X=y
+# CONFIG_ZAO_CAPCELLA is not set
+CONFIG_PCI_VR41XX=y
+# CONFIG_GPIO_VR41XX is not set
+CONFIG_VRC4173=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -121,6 +144,17 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -144,10 +178,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -406,19 +436,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -428,6 +445,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -448,6 +477,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_VR41XX is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -474,6 +504,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -507,7 +542,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -517,13 +551,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -549,6 +579,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -610,7 +644,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -639,7 +672,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -662,6 +697,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ocelot_3_defconfig linux_HEAD/arch/mips/configs/ocelot_3_defconfig
--- linux-2.6.11.6/arch/mips/configs/ocelot_3_defconfig	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ocelot_3_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:07 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:42 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,7 +22,6 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
@@ -33,6 +29,7 @@ CONFIG_IKCONFIG_PROC=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +39,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,39 +55,63 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 CONFIG_MOMENCO_OCELOT_3=y
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_IRQ_MV64340=y
@@ -118,6 +140,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_CPU_RM7000 is not set
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -149,10 +182,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -268,7 +297,6 @@ CONFIG_SCSI_PROC_FS=y
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_IPS is not set
@@ -276,7 +304,6 @@ CONFIG_SCSI_PROC_FS=y
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
 # CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=m
@@ -365,7 +392,7 @@ CONFIG_NETFILTER=y
 # CONFIG_IP_NF_ARPTABLES is not set
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 # CONFIG_IP6_NF_QUEUE is not set
 # CONFIG_IP6_NF_IPTABLES is not set
@@ -439,7 +466,6 @@ CONFIG_NET_PCI=y
 # CONFIG_DGRS is not set
 # CONFIG_EEPRO100 is not set
 CONFIG_E100=y
-# CONFIG_E100_NAPI is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
@@ -530,19 +556,6 @@ CONFIG_INPUT=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-# CONFIG_SERIO_RAW is not set
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -552,6 +565,18 @@ CONFIG_SERIO=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -597,6 +622,11 @@ CONFIG_RTC=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -624,6 +654,10 @@ CONFIG_RTC=y
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
 CONFIG_FB_MODE_HELPERS=y
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_CIRRUS is not set
@@ -631,6 +665,7 @@ CONFIG_FB_MODE_HELPERS=y
 # CONFIG_FB_CYBER2000 is not set
 # CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
+# CONFIG_FB_NVIDIA is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
 # CONFIG_FB_RADEON_OLD is not set
@@ -674,13 +709,9 @@ CONFIG_LOGO_LINUX_CLUT224=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -714,7 +745,12 @@ CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_PROC_INFO is not set
 # CONFIG_REISERFS_FS_XATTR is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_RT is not set
 # CONFIG_XFS_QUOTA is not set
 # CONFIG_XFS_SECURITY is not set
@@ -855,7 +891,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="ip=any root=nfs"
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ocelot_c_defconfig linux_HEAD/arch/mips/configs/ocelot_c_defconfig
--- linux-2.6.11.6/arch/mips/configs/ocelot_c_defconfig	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ocelot_c_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:07 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:43 2005
 #
 CONFIG_MIPS=y
-CONFIG_MIPS64=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -24,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -40,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -49,38 +48,63 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-CONFIG_MOMENCO_OCELOT_C=y
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+CONFIG_MOMENCO_OCELOT_C=y
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 # CONFIG_SGI_IP32 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_MV64340=y
 CONFIG_PCI_MARVELL=y
@@ -107,6 +131,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_MIPS32 is not set
+CONFIG_MIPS64=y
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -134,10 +169,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -399,19 +430,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -421,6 +439,18 @@ CONFIG_SERIO_RAW=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -467,6 +497,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -500,7 +535,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -510,13 +544,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -542,6 +572,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -634,7 +668,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ocelot_defconfig linux_HEAD/arch/mips/configs/ocelot_defconfig
--- linux-2.6.11.6/arch/mips/configs/ocelot_defconfig	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ocelot_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:08 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:44 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -50,39 +48,63 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 CONFIG_MOMENCO_OCELOT=y
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_MIPS_GT64120=y
@@ -112,6 +134,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -139,10 +172,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -362,18 +391,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -383,6 +400,17 @@ CONFIG_SERIO_RAW=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -428,6 +456,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -461,7 +494,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -475,10 +507,6 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -502,6 +530,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -594,7 +626,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/ocelot_g_defconfig linux_HEAD/arch/mips/configs/ocelot_g_defconfig
--- linux-2.6.11.6/arch/mips/configs/ocelot_g_defconfig	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/configs/ocelot_g_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,11 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:08 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:45 2005
 #
 CONFIG_MIPS=y
-CONFIG_MIPS64=y
-CONFIG_64BIT=y
 
 #
 # Code maturity level options
@@ -24,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -40,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -49,38 +48,63 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-CONFIG_MOMENCO_OCELOT_G=y
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+CONFIG_MOMENCO_OCELOT_G=y
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
 # CONFIG_SGI_IP27 is not set
 # CONFIG_SGI_IP32 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_PCI_MARVELL=y
@@ -110,6 +134,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_MIPS32 is not set
+CONFIG_MIPS64=y
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -137,10 +172,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -402,19 +433,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -424,6 +442,18 @@ CONFIG_SERIO_RAW=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=y
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -470,6 +500,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -503,7 +538,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -513,13 +547,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -545,6 +575,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -637,7 +671,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/osprey_defconfig linux_HEAD/arch/mips/configs/osprey_defconfig
--- linux-2.6.11.6/arch/mips/configs/osprey_defconfig	2005-03-26 04:28:39.000000000 +0100
+++ linux_HEAD/arch/mips/configs/osprey_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:08 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:46 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,39 +54,63 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 CONFIG_NEC_OSPREY=y
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_VR4181=y
@@ -113,6 +135,17 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -132,10 +165,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -356,18 +385,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -377,6 +394,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -397,6 +425,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_VR41XX is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -422,6 +451,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -455,7 +489,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -469,10 +502,6 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -496,6 +525,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -588,7 +621,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="ip=bootp ether=46,0x03fe0300,eth0"
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/pb1100_defconfig linux_HEAD/arch/mips/configs/pb1100_defconfig
--- linux-2.6.11.6/arch/mips/configs/pb1100_defconfig	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/configs/pb1100_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:08 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:47 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,55 +54,65 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+CONFIG_MIPS_PB1100=y
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-CONFIG_SOC_AU1100=y
-# CONFIG_SOC_AU1500 is not set
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-CONFIG_MIPS_PB1100=y
-# CONFIG_MIPS_PB1500 is not set
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1100=y
+CONFIG_SOC_AU1X00=y
 CONFIG_SWAP_IO_SPACE=y
 # CONFIG_AU1X00_USB_DEVICE is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -129,12 +137,21 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
-# CONFIG_64BIT_PHYS_ADDR is not set
+CONFIG_64BIT_PHYS_ADDR=y
 # CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_SYNC=y
@@ -170,6 +187,7 @@ CONFIG_PCMCIA=m
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
 
 #
 # Device Drivers
@@ -187,8 +205,8 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
-CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_CMDLINE_PARTS is not set
 
@@ -232,9 +250,7 @@ CONFIG_MTD_CFI_UTIL=y
 #
 # CONFIG_MTD_COMPLEX_MAPPINGS is not set
 # CONFIG_MTD_PHYSMAP is not set
-CONFIG_MTD_PB1100=y
-CONFIG_MTD_PB1500_BOOT=y
-CONFIG_MTD_PB1500_USER=y
+CONFIG_MTD_ALCHEMY=y
 
 #
 # Self-contained MTD device drivers
@@ -481,18 +497,6 @@ CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -502,6 +506,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -533,7 +548,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Watchdog Cards
 #
 # CONFIG_WATCHDOG is not set
-CONFIG_RTC=y
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 
@@ -549,6 +565,11 @@ CONFIG_SYNCLINK_CS=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -582,7 +603,6 @@ CONFIG_SYNCLINK_CS=m
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -592,12 +612,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB_ARCH_HAS_HCD is not set
-# CONFIG_USB_ARCH_HAS_OHCI is not set
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -636,6 +653,10 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -771,7 +792,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -794,6 +817,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/pb1500_defconfig linux_HEAD/arch/mips/configs/pb1500_defconfig
--- linux-2.6.11.6/arch/mips/configs/pb1500_defconfig	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/configs/pb1500_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:09 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:48 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,55 +54,65 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+CONFIG_MIPS_PB1500=y
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-CONFIG_SOC_AU1500=y
-# CONFIG_SOC_AU1550 is not set
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-CONFIG_MIPS_PB1500=y
-# CONFIG_MIPS_PB1550 is not set
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1500=y
+CONFIG_SOC_AU1X00=y
 # CONFIG_AU1X00_USB_DEVICE is not set
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -128,6 +136,15 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -177,6 +194,7 @@ CONFIG_PCCARD_NONSTATIC=m
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
 
 #
 # Device Drivers
@@ -192,7 +210,76 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -513,19 +600,6 @@ CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -535,6 +609,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -585,6 +671,11 @@ CONFIG_SYNCLINK_CS=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -612,7 +703,6 @@ CONFIG_SYNCLINK_CS=m
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -622,13 +712,9 @@ CONFIG_SYNCLINK_CS=m
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -667,6 +753,10 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -712,6 +802,8 @@ CONFIG_RAMFS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -800,7 +892,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -823,6 +917,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/pb1550_defconfig linux_HEAD/arch/mips/configs/pb1550_defconfig
--- linux-2.6.11.6/arch/mips/configs/pb1550_defconfig	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/configs/pb1550_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:09 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:49 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 CONFIG_HOTPLUG=y
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,56 +54,66 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+CONFIG_MIPS_PB1550=y
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-CONFIG_SOC_AU1X00=y
-# CONFIG_SOC_AU1000 is not set
-# CONFIG_SOC_AU1100 is not set
-# CONFIG_SOC_AU1500 is not set
-CONFIG_SOC_AU1550=y
-# CONFIG_MIPS_PB1000 is not set
-# CONFIG_MIPS_PB1100 is not set
-# CONFIG_MIPS_PB1500 is not set
-CONFIG_MIPS_PB1550=y
-# CONFIG_MIPS_DB1000 is not set
-# CONFIG_MIPS_DB1100 is not set
-# CONFIG_MIPS_DB1500 is not set
-# CONFIG_MIPS_DB1550 is not set
-# CONFIG_MIPS_BOSPORUS is not set
-# CONFIG_MIPS_MIRAGE is not set
-# CONFIG_MIPS_XXS1500 is not set
-# CONFIG_MIPS_MTX1 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
-CONFIG_DMA_COHERENT=y
+CONFIG_DMA_NONCOHERENT=y
 CONFIG_MIPS_DISABLE_OBSOLETE_IDE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SOC_AU1550=y
+CONFIG_SOC_AU1X00=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
 #
@@ -128,6 +136,15 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -177,6 +194,7 @@ CONFIG_PCCARD_NONSTATIC=m
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 CONFIG_TRAD_SIGNALS=y
+# CONFIG_PM is not set
 
 #
 # Device Drivers
@@ -192,7 +210,76 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_AMDSTD_RETRY=0
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_ALCHEMY=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -505,19 +592,6 @@ CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -527,6 +601,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 # CONFIG_VT is not set
@@ -577,6 +663,11 @@ CONFIG_SYNCLINK_CS=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -604,7 +695,6 @@ CONFIG_SYNCLINK_CS=m
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -614,13 +704,9 @@ CONFIG_SYNCLINK_CS=m
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -659,6 +745,10 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -704,6 +794,8 @@ CONFIG_RAMFS=y
 # CONFIG_BEFS_FS is not set
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+# CONFIG_JFFS2_FS is not set
 CONFIG_CRAMFS=m
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -792,7 +884,9 @@ CONFIG_NLS_DEFAULT="iso8859-1"
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -815,6 +909,7 @@ CONFIG_CRYPTO_NULL=y
 # CONFIG_CRYPTO_SHA256 is not set
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 # CONFIG_CRYPTO_DES is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/rm200_defconfig linux_HEAD/arch/mips/configs/rm200_defconfig
--- linux-2.6.11.6/arch/mips/configs/rm200_defconfig	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/configs/rm200_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:09 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:50 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -26,7 +23,6 @@ CONFIG_BSD_PROCESS_ACCT=y
 # CONFIG_BSD_PROCESS_ACCT_V3 is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
@@ -34,6 +30,7 @@ CONFIG_IKCONFIG_PROC=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -43,6 +40,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -58,33 +56,55 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 CONFIG_SNI_RM200_PCI=y
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
@@ -93,7 +113,10 @@ CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_GENERIC_ISA_DMA=y
 CONFIG_I8259=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_ARC32=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -122,6 +145,17 @@ CONFIG_CPU_R4X00=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -136,6 +170,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_EISA=y
 CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
@@ -150,11 +185,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-CONFIG_PCMCIA_PROBE=y
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -187,11 +217,11 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 #
 CONFIG_PARPORT=m
 CONFIG_PARPORT_PC=m
-CONFIG_PARPORT_PC_CML1=m
 CONFIG_PARPORT_SERIAL=m
 # CONFIG_PARPORT_PC_FIFO is not set
 # CONFIG_PARPORT_PC_SUPERIO is not set
-# CONFIG_PARPORT_OTHER is not set
+CONFIG_PARPORT_NOT_PC=y
+# CONFIG_PARPORT_GSC is not set
 CONFIG_PARPORT_1284=y
 
 #
@@ -321,7 +351,6 @@ CONFIG_MEGARAID_MAILBOX=m
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
 # CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
 # CONFIG_SCSI_FUTURE_DOMAIN is not set
 # CONFIG_SCSI_GDTH is not set
 # CONFIG_SCSI_GENERIC_NCR5380 is not set
@@ -343,7 +372,6 @@ CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
 # CONFIG_SCSI_PAS16 is not set
 # CONFIG_SCSI_PSI240I is not set
 # CONFIG_SCSI_QLOGIC_FAS is not set
-# CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
 CONFIG_SCSI_QLA2XXX=y
@@ -383,6 +411,8 @@ CONFIG_BLK_DEV_DM=m
 CONFIG_DM_SNAPSHOT=m
 CONFIG_DM_MIRROR=m
 CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_EMC=m
 
 #
 # Fusion MPT device support
@@ -515,7 +545,7 @@ CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -610,6 +640,7 @@ CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -620,6 +651,7 @@ CONFIG_NET_CLS_U32=m
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -793,20 +825,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_PARKBD=m
-# CONFIG_SERIO_PCIPS2 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -827,6 +845,19 @@ CONFIG_MOUSE_PS2=y
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_PARKBD=m
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -880,6 +911,11 @@ CONFIG_RTC=m
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -919,7 +955,6 @@ CONFIG_W1_SMEM=m
 CONFIG_VGA_CONSOLE=y
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -929,6 +964,8 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
 CONFIG_USB=m
 # CONFIG_USB_DEBUG is not set
 
@@ -939,8 +976,6 @@ CONFIG_USB_DEVICEFS=y
 # CONFIG_USB_BANDWIDTH is not set
 # CONFIG_USB_DYNAMIC_MINORS is not set
 # CONFIG_USB_OTG is not set
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB_ARCH_HAS_OHCI=y
 
 #
 # USB Host Controller Drivers
@@ -949,6 +984,8 @@ CONFIG_USB_EHCI_HCD=m
 # CONFIG_USB_EHCI_SPLIT_ISO is not set
 # CONFIG_USB_EHCI_ROOT_HUB_TT is not set
 CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_BIG_ENDIAN is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 CONFIG_USB_UHCI_HCD=m
 # CONFIG_USB_SL811_HCD is not set
 
@@ -968,7 +1005,7 @@ CONFIG_USB_STORAGE=m
 CONFIG_USB_STORAGE_DATAFAB=y
 CONFIG_USB_STORAGE_FREECOM=y
 CONFIG_USB_STORAGE_DPCM=y
-CONFIG_USB_STORAGE_HP8200e=y
+# CONFIG_USB_STORAGE_USBAT is not set
 CONFIG_USB_STORAGE_SDDR09=y
 CONFIG_USB_STORAGE_SDDR55=y
 CONFIG_USB_STORAGE_JUMPSHOT=y
@@ -1045,6 +1082,7 @@ CONFIG_USB_CDCETHER=y
 # USB Network Adapters
 #
 CONFIG_USB_AX8817X=y
+CONFIG_USB_MON=m
 
 #
 # USB port drivers
@@ -1109,6 +1147,7 @@ CONFIG_USB_CYTHERM=m
 CONFIG_USB_PHIDGETKIT=m
 CONFIG_USB_PHIDGETSERVO=m
 # CONFIG_USB_IDMOUSE is not set
+CONFIG_USB_SISUSBVGA=m
 CONFIG_USB_TEST=m
 
 #
@@ -1150,7 +1189,12 @@ CONFIG_REISERFS_FS_POSIX_ACL=y
 CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
 CONFIG_XFS_SECURITY=y
@@ -1328,7 +1372,9 @@ CONFIG_NLS_UTF8=m
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -1351,6 +1397,7 @@ CONFIG_CRYPTO_SHA1=m
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
@@ -1365,7 +1412,7 @@ CONFIG_CRYPTO_ANUBIS=m
 CONFIG_CRYPTO_DEFLATE=m
 CONFIG_CRYPTO_MICHAEL_MIC=m
 # CONFIG_CRYPTO_CRC32C is not set
-CONFIG_CRYPTO_TEST=m
+# CONFIG_CRYPTO_TEST is not set
 
 #
 # Hardware crypto devices
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/sb1250-swarm_defconfig linux_HEAD/arch/mips/configs/sb1250-swarm_defconfig
--- linux-2.6.11.6/arch/mips/configs/sb1250-swarm_defconfig	2005-03-26 04:28:38.000000000 +0100
+++ linux_HEAD/arch/mips/configs/sb1250-swarm_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:10 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:51 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,14 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=15
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
+CONFIG_CPUSETS=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +39,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,32 +56,45 @@ CONFIG_STOP_MACHINE=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-CONFIG_SIBYTE_SB1xxx_SOC=y
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
 CONFIG_SIBYTE_SWARM=y
 # CONFIG_SIBYTE_SENTOSA is not set
 # CONFIG_SIBYTE_RHONE is not set
@@ -91,9 +103,11 @@ CONFIG_SIBYTE_SWARM=y
 # CONFIG_SIBYTE_LITTLESUR is not set
 # CONFIG_SIBYTE_CRHINE is not set
 # CONFIG_SIBYTE_CRHONE is not set
-# CONFIG_SIBYTE_UNKNOWN is not set
-CONFIG_SIBYTE_BOARD=y
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_SIBYTE_SB1250=y
+CONFIG_SIBYTE_SB1xxx_SOC=y
 CONFIG_CPU_SB1_PASS_1=y
 # CONFIG_CPU_SB1_PASS_2_1250 is not set
 # CONFIG_CPU_SB1_PASS_2_2 is not set
@@ -107,13 +121,14 @@ CONFIG_SIBYTE_CFE=y
 # CONFIG_SIBYTE_BUS_WATCHER is not set
 # CONFIG_SIBYTE_SB1250_PROF is not set
 # CONFIG_SIBYTE_TBPROF is not set
-# CONFIG_SNI_RM200_PCI is not set
-# CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -138,6 +153,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 CONFIG_CPU_SB1=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+# CONFIG_MIPS32 is not set
+CONFIG_MIPS64=y
+CONFIG_64BIT=y
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -145,12 +171,9 @@ CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_SIBYTE_DMA_PAGEOPS is not set
 CONFIG_CPU_HAS_PREFETCH=y
 CONFIG_SB1_PASS_1_WORKAROUNDS=y
-# CONFIG_64BIT_PHYS_ADDR is not set
-# CONFIG_CPU_ADVANCED is not set
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
-# CONFIG_HIGHMEM is not set
 CONFIG_SMP=y
 CONFIG_NR_CPUS=2
 # CONFIG_PREEMPT is not set
@@ -170,10 +193,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -183,7 +202,12 @@ CONFIG_MMU=y
 #
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
-CONFIG_TRAD_SIGNALS=y
+# CONFIG_BUILD_ELF64 is not set
+CONFIG_MIPS32_COMPAT=y
+CONFIG_COMPAT=y
+CONFIG_MIPS32_O32=y
+# CONFIG_MIPS32_N32 is not set
+CONFIG_BINFMT_ELF32=y
 
 #
 # Device Drivers
@@ -227,7 +251,6 @@ CONFIG_BLK_DEV_RAM_COUNT=16
 CONFIG_BLK_DEV_RAM_SIZE=9220
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
-# CONFIG_LBD is not set
 CONFIG_CDROM_PKTCDVD=m
 CONFIG_CDROM_PKTCDVD_BUFFERS=8
 # CONFIG_CDROM_PKTCDVD_WCACHE is not set
@@ -263,7 +286,7 @@ CONFIG_BLK_DEV_IDEFLOPPY=y
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
-CONFIG_BLK_DEV_IDE_SWARM=y
+# CONFIG_BLK_DEV_IDE_SWARM is not set
 # CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
@@ -445,25 +468,16 @@ CONFIG_NET_SB1250_MAC=y
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
+# Hardware I/O ports
 #
-
-#
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
 CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
 # CONFIG_SERIO_PCIPS2 is not set
 # CONFIG_SERIO_LIBPS2 is not set
 CONFIG_SERIO_RAW=m
-
-#
-# Input Device Drivers
-#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
 
 #
 # Character devices
@@ -515,6 +529,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -542,7 +561,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -552,13 +570,9 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -588,6 +602,10 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -649,7 +667,6 @@ CONFIG_NFS_V3=y
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_RPCSEC_GSS_SPKM3 is not set
@@ -678,7 +695,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=15
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 # CONFIG_SB1XXX_CORELIS is not set
@@ -702,6 +721,7 @@ CONFIG_CRYPTO_SHA1=y
 CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=y
 CONFIG_CRYPTO_BLOWFISH=y
 CONFIG_CRYPTO_TWOFISH=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/sead_defconfig linux_HEAD/arch/mips/configs/sead_defconfig
--- linux-2.6.11.6/arch/mips/configs/sead_defconfig	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/arch/mips/configs/sead_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:10 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:52 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -19,17 +16,17 @@ CONFIG_BROKEN_ON_SMP=y
 # General setup
 #
 CONFIG_LOCALVERSION=""
-CONFIG_SWAP=y
-# CONFIG_SYSVIPC is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -39,6 +36,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -48,39 +46,64 @@ CONFIG_CC_ALIGN_JUMPS=0
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 CONFIG_MIPS_SEAD=y
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_BOARDS_GEN=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -105,6 +128,16 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -127,10 +160,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -179,9 +208,7 @@ CONFIG_BLK_DEV_RAM_SIZE=18432
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 # CONFIG_LBD is not set
-CONFIG_CDROM_PKTCDVD=y
-CONFIG_CDROM_PKTCDVD_BUFFERS=8
-# CONFIG_CDROM_PKTCDVD_WCACHE is not set
+# CONFIG_CDROM_PKTCDVD is not set
 
 #
 # IO Schedulers
@@ -237,47 +264,19 @@ CONFIG_IOSCHED_CFQ=y
 #
 # Input device support
 #
-CONFIG_INPUT=y
-
-#
-# Userland interfaces
-#
-CONFIG_INPUT_MOUSEDEV=y
-CONFIG_INPUT_MOUSEDEV_PSAUX=y
-CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
-CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
-# CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_TSDEV is not set
-# CONFIG_INPUT_EVDEV is not set
-# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT is not set
 
 #
-# Input I/O drivers
+# Hardware I/O ports
 #
+# CONFIG_SERIO is not set
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-# CONFIG_SERIO_I8042 is not set
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=y
-
-#
-# Input Device Drivers
-#
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_INPUT_JOYSTICK is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
 
 #
 # Character devices
 #
-CONFIG_VT=y
-CONFIG_VT_CONSOLE=y
-CONFIG_HW_CONSOLE=y
+# CONFIG_VT is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
 
 #
@@ -293,7 +292,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
+CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
 
@@ -318,6 +317,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -346,13 +350,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_FB is not set
 
 #
-# Console display driver support
-#
-# CONFIG_VGA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-
-#
 # Sound
 #
 # CONFIG_SOUND is not set
@@ -364,10 +361,6 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -386,15 +379,15 @@ CONFIG_DUMMY_CONSOLE=y
 # File systems
 #
 CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XATTR is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_JBD is not set
-CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -423,6 +416,7 @@ CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
 # CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
 # CONFIG_TMPFS is not set
 # CONFIG_HUGETLB_PAGE is not set
 CONFIG_RAMFS=y
@@ -447,8 +441,18 @@ CONFIG_RAMFS=y
 #
 # Partition Types
 #
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
 
 #
 # Native Language Support
@@ -463,15 +467,16 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
 #
 # Security options
 #
-CONFIG_KEYS=y
-CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_KEYS is not set
 # CONFIG_SECURITY is not set
 
 #
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/tb0226_defconfig linux_HEAD/arch/mips/configs/tb0226_defconfig
--- linux-2.6.11.6/arch/mips/configs/tb0226_defconfig	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/arch/mips/configs/tb0226_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:12 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:53 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,46 +54,71 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-CONFIG_TANBAC_TB0226=y
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+CONFIG_TANBAC_TB0226=y
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_GPIO_VR41XX is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -119,6 +142,17 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -140,10 +174,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -430,18 +460,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -451,6 +469,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -471,6 +500,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_VR41XX is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -496,6 +526,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -523,6 +558,10 @@ CONFIG_LEGACY_PTY_COUNT=256
 # Graphics support
 #
 CONFIG_FB=y
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SOFT_CURSOR is not set
 # CONFIG_FB_MODE_HELPERS is not set
 # CONFIG_FB_TILEBLITTING is not set
 # CONFIG_FB_VIRTUAL is not set
@@ -562,10 +601,6 @@ CONFIG_SOUND=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -589,6 +624,10 @@ CONFIG_EXT2_FS=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 CONFIG_ROMFS_FS=m
@@ -731,7 +770,9 @@ CONFIG_NLS_ISO8859_1=m
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/tb0229_defconfig linux_HEAD/arch/mips/configs/tb0229_defconfig
--- linux-2.6.11.6/arch/mips/configs/tb0229_defconfig	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/arch/mips/configs/tb0229_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:12 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:54 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,49 +54,73 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-# CONFIG_IBM_WORKPAD is not set
-# CONFIG_TANBAC_TB0226 is not set
-CONFIG_TANBAC_TB0229=y
-CONFIG_TANBAC_TB0219=y
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-CONFIG_PCI_VR41XX=y
-# CONFIG_VRC4173 is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_TANBAC_TB0226 is not set
+CONFIG_TANBAC_TB0229=y
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+CONFIG_PCI_VR41XX=y
+# CONFIG_GPIO_VR41XX is not set
+# CONFIG_VRC4173 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -122,6 +144,17 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -145,10 +178,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 # CONFIG_HOTPLUG_PCI is not set
@@ -444,19 +473,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_PCIPS2 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -466,6 +482,18 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -486,6 +514,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_VR41XX is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -504,6 +533,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
+CONFIG_TANBAC_TB0219=y
 
 #
 # Ftape, the floppy tape device driver
@@ -512,6 +542,11 @@ CONFIG_LEGACY_PTY_COUNT=256
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -545,7 +580,6 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -555,13 +589,9 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -596,7 +626,12 @@ CONFIG_JFS_FS=m
 # CONFIG_JFS_SECURITY is not set
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=y
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
 # CONFIG_XFS_SECURITY is not set
@@ -743,7 +778,9 @@ CONFIG_NLS_ISO8859_1=m
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE="mem=64M console=ttyS0,38400 ip=bootp root=/dev/nfs"
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/workpad_defconfig linux_HEAD/arch/mips/configs/workpad_defconfig
--- linux-2.6.11.6/arch/mips/configs/workpad_defconfig	2005-03-26 04:28:25.000000000 +0100
+++ linux_HEAD/arch/mips/configs/workpad_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:12 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:54 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,13 +22,13 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 # CONFIG_IKCONFIG is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -41,6 +38,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,47 +54,72 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-CONFIG_MACH_VR41XX=y
-# CONFIG_NEC_CMBVR4133 is not set
-# CONFIG_CASIO_E55 is not set
-CONFIG_IBM_WORKPAD=y
-# CONFIG_TANBAC_TB0226 is not set
-# CONFIG_TANBAC_TB0229 is not set
-# CONFIG_VICTOR_MPC30X is not set
-# CONFIG_ZAO_CAPCELLA is not set
-CONFIG_VRC4171=y
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+CONFIG_MACH_VR41XX=y
+# CONFIG_PMC_YOSEMITE is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_NEC_CMBVR4133 is not set
+# CONFIG_CASIO_E55 is not set
+CONFIG_IBM_WORKPAD=y
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_GPIO_VR41XX is not set
+CONFIG_VRC4171=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_BIG_ENDIAN is not set
 CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 
@@ -120,6 +143,17 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -140,11 +174,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-CONFIG_PCMCIA_PROBE=y
-
-#
 # PCI Hotplug Support
 #
 
@@ -408,18 +437,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-# CONFIG_SERIO_LIBPS2 is not set
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 # CONFIG_INPUT_KEYBOARD is not set
@@ -429,6 +446,17 @@ CONFIG_SERIO_RAW=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_LIBPS2 is not set
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -449,6 +477,7 @@ CONFIG_SERIAL_8250_NR_UARTS=4
 #
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_VR41XX is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -487,6 +516,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -521,7 +555,6 @@ CONFIG_WATCHDOG=y
 # CONFIG_VGA_CONSOLE is not set
 # CONFIG_MDA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -535,10 +568,6 @@ CONFIG_DUMMY_CONSOLE=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -566,6 +595,10 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -657,7 +690,9 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/configs/yosemite_defconfig linux_HEAD/arch/mips/configs/yosemite_defconfig
--- linux-2.6.11.6/arch/mips/configs/yosemite_defconfig	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/configs/yosemite_defconfig	2005-03-21 20:03:44.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:49:13 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:55 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -24,15 +21,16 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+# CONFIG_CPUSETS is not set
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_ALL is not set
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +40,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -56,34 +55,64 @@ CONFIG_STOP_MACHINE=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-CONFIG_PMC_YOSEMITE=y
-# CONFIG_HYPERTRANSPORT is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+CONFIG_PMC_YOSEMITE=y
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SOC_AU1X00 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_HYPERTRANSPORT is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_IRQ_CPU_RM7K=y
 CONFIG_IRQ_CPU_RM9K=y
@@ -110,6 +139,17 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_CPU_RM7000 is not set
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -140,10 +180,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -265,7 +301,14 @@ CONFIG_IP_PNP_BOOTP=y
 # CONFIG_INET_IPCOMP is not set
 CONFIG_INET_TUNNEL=m
 CONFIG_IP_TCPDIAG=m
-# CONFIG_IP_TCPDIAG_IPV6 is not set
+CONFIG_IP_TCPDIAG_IPV6=y
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IPV6_TUNNEL=m
 # CONFIG_NETFILTER is not set
 CONFIG_XFRM=y
 CONFIG_XFRM_USER=m
@@ -371,20 +414,11 @@ CONFIG_TITAN_GE=y
 # CONFIG_INPUT is not set
 
 #
-# Userland interfaces
-#
-
-#
-# Input I/O drivers
+# Hardware I/O ports
 #
+# CONFIG_SERIO is not set
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
-# CONFIG_SERIO is not set
-# CONFIG_SERIO_I8042 is not set
-
-#
-# Input Device Drivers
-#
 
 #
 # Character devices
@@ -432,6 +466,10 @@ CONFIG_GEN_RTC_X=y
 # CONFIG_RAW_DRIVER is not set
 
 #
+# TPM devices
+#
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -459,7 +497,6 @@ CONFIG_GEN_RTC_X=y
 # Graphics support
 #
 # CONFIG_FB is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -469,13 +506,9 @@ CONFIG_GEN_RTC_X=y
 #
 # USB support
 #
-# CONFIG_USB is not set
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
-
-#
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -500,6 +533,10 @@ CONFIG_USB_ARCH_HAS_OHCI=y
 # CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
+
+#
+# XFS support
+#
 # CONFIG_XFS_FS is not set
 # CONFIG_MINIX_FS is not set
 # CONFIG_ROMFS_FS is not set
@@ -552,7 +589,6 @@ CONFIG_NFS_FS=y
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-# CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
@@ -573,8 +609,10 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_MAGIC_SYSRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_DEBUG_SLAB is not set
 # CONFIG_DEBUG_SPINLOCK is not set
@@ -599,7 +637,31 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 #
 # Cryptographic options
 #
-# CONFIG_CRYPTO is not set
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
+CONFIG_CRYPTO_TEST=m
 
 #
 # Hardware crypto devices
@@ -610,6 +672,8 @@ CONFIG_KEYS_DEBUG_PROC_KEYS=y
 #
 # CONFIG_CRC_CCITT is not set
 # CONFIG_CRC32 is not set
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=m
+CONFIG_ZLIB_INFLATE=m
+CONFIG_ZLIB_DEFLATE=m
 CONFIG_GENERIC_HARDIRQS=y
 CONFIG_GENERIC_IRQ_PROBE=y
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/ddb5xxx/Kconfig linux_HEAD/arch/mips/ddb5xxx/Kconfig
--- linux-2.6.11.6/arch/mips/ddb5xxx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/ddb5xxx/Kconfig	2005-01-30 21:45:36.000000000 +0100
@@ -0,0 +1,4 @@
+config DDB5477_BUS_FREQUENCY
+	int "bus frequency (in kHZ, 0 for auto-detect)"
+	depends on DDB5477
+	default 0
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/ddb5xxx/ddb5074/nile4_pic.c linux_HEAD/arch/mips/ddb5xxx/ddb5074/nile4_pic.c
--- linux-2.6.11.6/arch/mips/ddb5xxx/ddb5074/nile4_pic.c	2005-03-26 04:28:41.000000000 +0100
+++ linux_HEAD/arch/mips/ddb5xxx/ddb5074/nile4_pic.c	2005-02-28 16:56:41.000000000 +0100
@@ -209,14 +209,13 @@ static void nile4_irq_end(unsigned int i
 #define nile4_irq_shutdown nile4_disable_irq
 
 static hw_irq_controller nile4_irq_controller = {
-    "nile4",
-    nile4_irq_startup,
-    nile4_irq_shutdown,
-    nile4_enable_irq,
-    nile4_disable_irq,
-    nile4_ack_irq,
-    nile4_irq_end,
-    NULL
+	.typename = "nile4",
+	.startup = nile4_irq_startup,
+	.shutdown = nile4_irq_shutdown,
+	.enable = nile4_enable_irq,
+	.disable = nile4_disable_irq,
+	.ack = nile4_ack_irq,
+	.end = nile4_irq_end,
 };
 
 void nile4_irq_setup(u32 base) {
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c linux_HEAD/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c
--- linux-2.6.11.6/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c	2005-03-26 04:28:30.000000000 +0100
+++ linux_HEAD/arch/mips/ddb5xxx/ddb5476/vrc5476_irq.c	2005-02-28 16:56:41.000000000 +0100
@@ -53,14 +53,13 @@ static void vrc5476_irq_end(uint irq)
 }
 
 static hw_irq_controller vrc5476_irq_controller = {
-	"vrc5476",
-	vrc5476_irq_startup,
-	vrc5476_irq_shutdown,
-	vrc5476_irq_enable,
-	vrc5476_irq_disable,
-	vrc5476_irq_ack,
-	vrc5476_irq_end,
-	NULL				/* no affinity stuff for UP */
+	.typename = "vrc5476",
+	.startup = vrc5476_irq_startup,
+	.shutdown = vrc5476_irq_shutdown,
+	.enable = vrc5476_irq_enable,
+	.disable = vrc5476_irq_disable,
+	.ack = vrc5476_irq_ack,
+	.end = vrc5476_irq_end
 };
 
 void __init
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/ddb5xxx/ddb5477/irq_5477.c linux_HEAD/arch/mips/ddb5xxx/ddb5477/irq_5477.c
--- linux-2.6.11.6/arch/mips/ddb5xxx/ddb5477/irq_5477.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/ddb5xxx/ddb5477/irq_5477.c	2005-02-28 16:56:41.000000000 +0100
@@ -90,14 +90,13 @@ vrc5477_irq_end(unsigned int irq)
 }
 
 hw_irq_controller vrc5477_irq_controller = {
-	"vrc5477_irq",
-	vrc5477_irq_startup,
-	vrc5477_irq_shutdown,
-	vrc5477_irq_enable,
-	vrc5477_irq_disable,
-	vrc5477_irq_ack,
-	vrc5477_irq_end,
-	NULL			/* no affinity stuff for UP */
+	.typename = "vrc5477_irq",
+	.startup = vrc5477_irq_startup,
+	.shutdown = vrc5477_irq_shutdown,
+	.enable = vrc5477_irq_enable,
+	.disable = vrc5477_irq_disable,
+	.ack = vrc5477_irq_ack,
+	.end = vrc5477_irq_end
 };
 
 void __init vrc5477_irq_init(u32 irq_base)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/defconfig linux_HEAD/arch/mips/defconfig
--- linux-2.6.11.6/arch/mips/defconfig	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/defconfig	2005-03-21 20:03:43.000000000 +0100
@@ -1,12 +1,9 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.11-rc2
-# Wed Jan 26 02:48:59 2005
+# Linux kernel version: 2.6.12-rc1
+# Fri Mar 18 15:41:23 2005
 #
 CONFIG_MIPS=y
-# CONFIG_MIPS64 is not set
-# CONFIG_64BIT is not set
-CONFIG_MIPS32=y
 
 #
 # Code maturity level options
@@ -25,7 +22,6 @@ CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_KOBJECT_UEVENT=y
 CONFIG_IKCONFIG=y
@@ -33,6 +29,7 @@ CONFIG_IKCONFIG_PROC=y
 CONFIG_EMBEDDED=y
 CONFIG_KALLSYMS=y
 # CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_BASE_FULL=y
 CONFIG_FUTEX=y
 CONFIG_EPOLL=y
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
@@ -42,6 +39,7 @@ CONFIG_CC_ALIGN_LABELS=0
 CONFIG_CC_ALIGN_LOOPS=0
 CONFIG_CC_ALIGN_JUMPS=0
 # CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
 
 #
 # Loadable module support
@@ -57,40 +55,64 @@ CONFIG_KMOD=y
 #
 # Machine selection
 #
-# CONFIG_MACH_JAZZ is not set
-# CONFIG_MACH_VR41XX is not set
-# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_PB1200 is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
+# CONFIG_MIPS_DB1200 is not set
+# CONFIG_MIPS_MIRAGE is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MIPS_EV64120 is not set
 # CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
-# CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_LASAT is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
 # CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
 # CONFIG_MOMENCO_OCELOT is not set
-# CONFIG_MOMENCO_OCELOT_G is not set
-# CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_OCELOT_3 is not set
-# CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MIPS_XXS1500 is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_PMC_YOSEMITE is not set
 CONFIG_SGI_IP22=y
-# CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SWARM is not set
+# CONFIG_SIBYTE_SENTOSA is not set
+# CONFIG_SIBYTE_RHONE is not set
+# CONFIG_SIBYTE_CARMEL is not set
+# CONFIG_SIBYTE_PTSWARM is not set
+# CONFIG_SIBYTE_LITTLESUR is not set
+# CONFIG_SIBYTE_CRHINE is not set
+# CONFIG_SIBYTE_CRHONE is not set
 # CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_ARC=y
 CONFIG_DMA_NONCOHERENT=y
+CONFIG_CPU_BIG_ENDIAN=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
 CONFIG_IRQ_CPU=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_ARC32=y
@@ -119,6 +141,17 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM7000 is not set
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_64BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_64BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+# CONFIG_64BIT is not set
 CONFIG_PAGE_SIZE_4KB=y
 # CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
@@ -135,6 +168,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_EISA=y
 # CONFIG_EISA is not set
 CONFIG_MMU=y
 
@@ -144,10 +178,6 @@ CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 
 #
-# PC-card bridges
-#
-
-#
 # PCI Hotplug Support
 #
 
@@ -409,7 +439,7 @@ CONFIG_IP_NF_ARPFILTER=m
 CONFIG_IP_NF_ARP_MANGLE=m
 
 #
-# IPv6: Netfilter Configuration
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
 #
 CONFIG_IP6_NF_QUEUE=m
 CONFIG_IP6_NF_IPTABLES=m
@@ -478,6 +508,7 @@ CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_QOS=y
 CONFIG_NET_ESTIMATOR=y
 CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
 CONFIG_NET_CLS_TCINDEX=m
 CONFIG_NET_CLS_ROUTE4=m
 CONFIG_NET_CLS_ROUTE=y
@@ -488,6 +519,7 @@ CONFIG_NET_CLS_U32=m
 # CONFIG_CLS_U32_MARK is not set
 CONFIG_NET_CLS_RSVP=m
 CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_EMATCH is not set
 # CONFIG_NET_CLS_ACT is not set
 CONFIG_NET_CLS_POLICE=y
 
@@ -568,18 +600,6 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_EVBUG is not set
 
 #
-# Input I/O drivers
-#
-# CONFIG_GAMEPORT is not set
-CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIO_RAW=m
-
-#
 # Input Device Drivers
 #
 CONFIG_INPUT_KEYBOARD=y
@@ -597,6 +617,17 @@ CONFIG_MOUSE_SERIAL=m
 # CONFIG_INPUT_MISC is not set
 
 #
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=m
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+
+#
 # Character devices
 #
 CONFIG_VT=y
@@ -648,6 +679,11 @@ CONFIG_RAW_DRIVER=m
 CONFIG_MAX_RAW_DEVS=256
 
 #
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
 # I2C support
 #
 # CONFIG_I2C is not set
@@ -692,7 +728,6 @@ CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_VGA16 is not set
 # CONFIG_LOGO_LINUX_CLUT224 is not set
 CONFIG_LOGO_SGI_CLUT224=y
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
 
 #
 # Sound
@@ -706,10 +741,6 @@ CONFIG_LOGO_SGI_CLUT224=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 
 #
-# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
-#
-
-#
 # USB Gadget Support
 #
 # CONFIG_USB_GADGET is not set
@@ -739,7 +770,12 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
+
+#
+# XFS support
+#
 CONFIG_XFS_FS=m
+CONFIG_XFS_EXPORT=y
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
 CONFIG_XFS_SECURITY=y
@@ -907,7 +943,9 @@ CONFIG_NLS_UTF8=m
 #
 # Kernel hacking
 #
+# CONFIG_PRINTK_TIME is not set
 # CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
 CONFIG_CROSSCOMPILE=y
 CONFIG_CMDLINE=""
 
@@ -930,6 +968,7 @@ CONFIG_CRYPTO_SHA1=m
 CONFIG_CRYPTO_SHA256=m
 CONFIG_CRYPTO_SHA512=m
 CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_TGR192=m
 CONFIG_CRYPTO_DES=m
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_TWOFISH=m
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/gt64120/ev64120/Kconfig linux_HEAD/arch/mips/gt64120/ev64120/Kconfig
--- linux-2.6.11.6/arch/mips/gt64120/ev64120/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/gt64120/ev64120/Kconfig	2005-01-30 21:45:37.000000000 +0100
@@ -0,0 +1,3 @@
+config EVB_PCI1
+	bool "Enable Second PCI (PCI1)"
+	depends on MIPS_EV64120
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/ite-boards/Kconfig linux_HEAD/arch/mips/ite-boards/Kconfig
--- linux-2.6.11.6/arch/mips/ite-boards/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/ite-boards/Kconfig	2005-01-30 21:45:36.000000000 +0100
@@ -0,0 +1,8 @@
+config IT8172_REVC
+	bool "Support for older IT8172 (Rev C)"
+	depends on MIPS_ITE8172
+	help
+	  Say Y here to support the older, Revision C version of the Integrated
+	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
+	  <http://www.ite.com.tw/ia/brief_it8172bsp.htm>; picture of the
+	  board at <http://www.mvista.com/partners/semiconductor/ite.html>.
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/ite-boards/generic/irq.c linux_HEAD/arch/mips/ite-boards/generic/irq.c
--- linux-2.6.11.6/arch/mips/ite-boards/generic/irq.c	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/ite-boards/generic/irq.c	2005-02-28 16:56:41.000000000 +0100
@@ -138,14 +138,13 @@ static void end_ite_irq(unsigned int irq
 }
 
 static struct hw_interrupt_type it8172_irq_type = {
-	"ITE8172",
-	startup_ite_irq,
-	shutdown_ite_irq,
-	enable_it8172_irq,
-	disable_it8172_irq,
-	mask_and_ack_ite_irq,
-	end_ite_irq,
-	NULL
+	.typename = "ITE8172",
+	.startup = startup_ite_irq,
+	.shutdown = shutdown_ite_irq,
+	.enable = enable_it8172_irq,
+	.disable = disable_it8172_irq,
+	.ack = mask_and_ack_ite_irq,
+	.end = end_ite_irq,
 };
 
 
@@ -159,13 +158,13 @@ static void ack_none(unsigned int irq) {
 #define end_none	enable_none
 
 static struct hw_interrupt_type cp0_irq_type = {
-	"CP0 Count",
-	startup_none,
-	shutdown_none,
-	enable_none,
-	disable_none,
-	ack_none,
-	end_none
+	.typename = "CP0 Count",
+	.startup = startup_none,
+	.shutdown = shutdown_none,
+	.enable = enable_none,
+	.disable = disable_none,
+	.ack = ack_none,
+	.end = end_none
 };
 
 void enable_cpu_timer(void)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/jazz/Kconfig linux_HEAD/arch/mips/jazz/Kconfig
--- linux-2.6.11.6/arch/mips/jazz/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/jazz/Kconfig	2005-01-30 21:45:36.000000000 +0100
@@ -0,0 +1,33 @@
+config ACER_PICA_61
+	bool "Support for Acer PICA 1 chipset (EXPERIMENTAL)"
+	depends on MACH_JAZZ && EXPERIMENTAL
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This is a machine with a R4400 133/150 MHz CPU. To compile a Linux
+	  kernel that runs on these, say Y here. For details about Linux on
+	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+	  <http://www.linux-mips.org/>.
+
+config MIPS_MAGNUM_4000
+	bool "Support for MIPS Magnum 4000"
+	depends on MACH_JAZZ
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_BIG_ENDIAN if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+	  kernel that runs on these, say Y here. For details about Linux on
+	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+	  <http://www.linux-mips.org/>.
+
+config OLIVETTI_M700
+	bool "Support for Olivetti M700-10"
+	depends on MACH_JAZZ
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+	  kernel that runs on these, say Y here. For details about Linux on
+	  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+	  <http://www.linux-mips.org/>.
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/jazz/irq.c linux_HEAD/arch/mips/jazz/irq.c
--- linux-2.6.11.6/arch/mips/jazz/irq.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/jazz/irq.c	2005-02-28 16:56:41.000000000 +0100
@@ -58,14 +58,13 @@ static void end_r4030_irq(unsigned int i
 }
 
 static struct hw_interrupt_type r4030_irq_type = {
-	"R4030",
-	startup_r4030_irq,
-	shutdown_r4030_irq,
-	enable_r4030_irq,
-	disable_r4030_irq,
-	mask_and_ack_r4030_irq,
-	end_r4030_irq,
-	NULL
+	.typename = "R4030",
+	.startup = startup_r4030_irq,
+	.shutdown = shutdown_r4030_irq,
+	.enable = enable_r4030_irq,
+	.disable = disable_r4030_irq,
+	.ack = mask_and_ack_r4030_irq,
+	.end = end_r4030_irq,
 };
 
 void __init init_r4030_ints(void)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/jmr3927/rbhma3100/irq.c linux_HEAD/arch/mips/jmr3927/rbhma3100/irq.c
--- linux-2.6.11.6/arch/mips/jmr3927/rbhma3100/irq.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/jmr3927/rbhma3100/irq.c	2005-02-28 16:56:41.000000000 +0100
@@ -412,13 +412,13 @@ void __init arch_init_irq(void)
 }
 
 static hw_irq_controller jmr3927_irq_controller = {
-	"jmr3927_irq",
-	jmr3927_irq_startup,
-	jmr3927_irq_shutdown,
-	jmr3927_irq_enable,
-	jmr3927_irq_disable,
-	jmr3927_irq_ack,
-	jmr3927_irq_end,
+	.typename = "jmr3927_irq",
+	.startup = jmr3927_irq_startup,
+	.shutdown = jmr3927_irq_shutdown,
+	.enable = jmr3927_irq_enable,
+	.disable = jmr3927_irq_disable,
+	.ack = jmr3927_irq_ack,
+	.end = jmr3927_irq_end,
 };
 
 void jmr3927_irq_init(u32 irq_base)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/jmr3927/rbhma3100/setup.c linux_HEAD/arch/mips/jmr3927/rbhma3100/setup.c
--- linux-2.6.11.6/arch/mips/jmr3927/rbhma3100/setup.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/jmr3927/rbhma3100/setup.c	2005-03-04 20:36:08.000000000 +0100
@@ -44,6 +44,11 @@
 #include <linux/ioport.h>
 #include <linux/param.h>	/* for HZ */
 #include <linux/delay.h>
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#endif
 
 #include <asm/addrspace.h>
 #include <asm/time.h>
@@ -211,8 +216,8 @@ static void __init jmr3927_setup(void)
 	 */
 	ioport_resource.start = pci_io_resource.start;
 	ioport_resource.end = pci_io_resource.end;
-	iomem_resource.start = pci_mem_resource.start;
-	iomem_resource.end = pci_mem_resource.end;
+	iomem_resource.start = 0;
+	iomem_resource.end = 0xffffffff;
 
 	/* Reboot on panic */
 	panic_timeout = 180;
@@ -265,13 +270,33 @@ static void __init jmr3927_setup(void)
 		strcat(argptr, " ip=bootp");
 	}
 
-#ifdef CONFIG_TXX927_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		int i;
+		struct uart_port req;
+		for(i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)TX3927_SIO_REG(i);
+			req.mapbase = TX3927_SIO_REG(i);
+			req.irq = i == 0 ?
+				JMR3927_IRQ_IRC_SIO0 : JMR3927_IRQ_IRC_SIO1;
+			if (i == 0)
+				req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
+			req.uartclk = JMR3927_IMCLK;
+			early_serial_txx9_setup(&req);
+		}
+	}
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
 	argptr = prom_getcmdline();
 	if ((argptr = strstr(argptr, "console=")) == NULL) {
 		argptr = prom_getcmdline();
 		strcat(argptr, " console=ttyS1,115200");
 	}
 #endif
+#endif
 }
 
 early_initcall(jmr3927_setup);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/Makefile linux_HEAD/arch/mips/kernel/Makefile
--- linux-2.6.11.6/arch/mips/kernel/Makefile	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/Makefile	2005-01-31 03:10:53.000000000 +0100
@@ -11,11 +11,7 @@ obj-y		+= cpu-probe.o branch.o entry.o g
 binfmt_irix-objs	:= irixelf.o irixinv.o irixioctl.o irixsig.o	\
 			   irix5sys.o sysirix.o
 
-ifdef CONFIG_MODULES
-obj-y				+= mips_ksyms.o module.o
-obj-$(CONFIG_MIPS32)		+= module-elf32.o
-obj-$(CONFIG_MIPS64)		+= module-elf64.o
-endif
+obj-$(CONFIG_MODULES)		+= mips_ksyms.o module.o
 
 obj-$(CONFIG_CPU_R3000)		+= r2300_fpu.o r2300_switch.o
 obj-$(CONFIG_CPU_TX39XX)	+= r2300_fpu.o r2300_switch.o
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/binfmt_elfn32.c linux_HEAD/arch/mips/kernel/binfmt_elfn32.c
--- linux-2.6.11.6/arch/mips/kernel/binfmt_elfn32.c	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/binfmt_elfn32.c	2005-02-17 21:48:54.000000000 +0100
@@ -52,7 +52,6 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #include <asm/processor.h>
 #include <linux/module.h>
-#include <linux/config.h>
 #include <linux/elfcore.h>
 #include <linux/compat.h>
 
@@ -116,4 +115,7 @@ MODULE_AUTHOR("Ralf Baechle (ralf@linux-
 #undef MODULE_DESCRIPTION
 #undef MODULE_AUTHOR
 
+#undef TASK_SIZE
+#define TASK_SIZE TASK_SIZE32
+
 #include "../../../fs/binfmt_elf.c"
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/binfmt_elfo32.c linux_HEAD/arch/mips/kernel/binfmt_elfo32.c
--- linux-2.6.11.6/arch/mips/kernel/binfmt_elfo32.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/binfmt_elfo32.c	2005-02-17 21:48:54.000000000 +0100
@@ -54,7 +54,6 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_N
 
 #include <asm/processor.h>
 #include <linux/module.h>
-#include <linux/config.h>
 #include <linux/elfcore.h>
 #include <linux/compat.h>
 
@@ -98,7 +97,7 @@ struct elf_prpsinfo32
 #define init_elf_binfmt init_elf32_binfmt
 
 #define jiffies_to_timeval jiffies_to_compat_timeval
-static __inline__ void
+static inline void
 jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)
 {
 	/*
@@ -113,21 +112,26 @@ jiffies_to_compat_timeval(unsigned long 
 #undef ELF_CORE_COPY_REGS
 #define ELF_CORE_COPY_REGS(_dest,_regs) elf32_core_copy_regs(_dest,_regs);
 
-void elf32_core_copy_regs(elf_gregset_t _dest, struct pt_regs *_regs)
+void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs)
 {
 	int i;
 
-	memset(_dest, 0, sizeof(elf_gregset_t));
-
-	/* XXXKW the 6 is from EF_REG0 in gdb/gdb/mips-linux-tdep.c, include/asm-mips/reg.h */
-	for (i=6; i<38; i++)
-		_dest[i] = (elf_greg_t) _regs->regs[i-6];
-	_dest[i++] = (elf_greg_t) _regs->lo;
-	_dest[i++] = (elf_greg_t) _regs->hi;
-	_dest[i++] = (elf_greg_t) _regs->cp0_epc;
-	_dest[i++] = (elf_greg_t) _regs->cp0_badvaddr;
-	_dest[i++] = (elf_greg_t) _regs->cp0_status;
-	_dest[i++] = (elf_greg_t) _regs->cp0_cause;
+	for (i = 0; i < EF_R0; i++)
+		grp[i] = 0;
+	grp[EF_R0] = 0;
+	for (i = 1; i <= 31; i++)
+		grp[EF_R0 + i] = (elf_greg_t) regs->regs[i];
+	grp[EF_R26] = 0;
+	grp[EF_R27] = 0;
+	grp[EF_LO] = (elf_greg_t) regs->lo;
+	grp[EF_HI] = (elf_greg_t) regs->hi;
+	grp[EF_CP0_EPC] = (elf_greg_t) regs->cp0_epc;
+	grp[EF_CP0_BADVADDR] = (elf_greg_t) regs->cp0_badvaddr;
+	grp[EF_CP0_STATUS] = (elf_greg_t) regs->cp0_status;
+	grp[EF_CP0_CAUSE] = (elf_greg_t) regs->cp0_cause;
+#ifdef EF_UNUSED0
+	grp[EF_UNUSED0] = 0;
+#endif
 }
 
 MODULE_DESCRIPTION("Binary format loader for compatibility with o32 Linux/MIPS binaries");
@@ -136,4 +140,7 @@ MODULE_AUTHOR("Ralf Baechle (ralf@linux-
 #undef MODULE_DESCRIPTION
 #undef MODULE_AUTHOR
 
+#undef TASK_SIZE
+#define TASK_SIZE TASK_SIZE32
+
 #include "../../../fs/binfmt_elf.c"
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/cpu-probe.c linux_HEAD/arch/mips/kernel/cpu-probe.c
--- linux-2.6.11.6/arch/mips/kernel/cpu-probe.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/cpu-probe.c	2005-03-01 15:00:12.000000000 +0100
@@ -116,6 +116,8 @@ static inline void check_wait(void)
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
+	case CPU_AU1550:
+	case CPU_AU1200:
 		if (au1k_wait_ptr != NULL) {
 			cpu_wait = au1k_wait_ptr;
 			printk(" available.\n");
@@ -511,6 +513,9 @@ static inline void cpu_probe_alchemy(str
 		case 3:
 			c->cputype = CPU_AU1550;
 			break;
+		case 4:
+			c->cputype = CPU_AU1200;
+			break;
 		default:
 			panic("Unknown Au Core!");
 			break;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/dma-no-isa.c linux_HEAD/arch/mips/kernel/dma-no-isa.c
--- linux-2.6.11.6/arch/mips/kernel/dma-no-isa.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/dma-no-isa.c	2005-02-17 21:48:54.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 by Ralf Baechle
+ *
+ * Dummy ISA DMA functions for systems that don't have ISA but share drivers
+ * with ISA such as legacy free PCI.
+ */
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+DEFINE_SPINLOCK(dma_spin_lock);
+
+int request_dma(unsigned int dmanr, const char * device_id)
+{
+	return -EINVAL;
+}
+
+void free_dma(unsigned int dmanr)
+{
+}
+
+EXPORT_SYMBOL(dma_spin_lock);
+EXPORT_SYMBOL(request_dma);
+EXPORT_SYMBOL(free_dma);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/entry.S linux_HEAD/arch/mips/kernel/entry.S
--- linux-2.6.11.6/arch/mips/kernel/entry.S	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/entry.S	2005-03-04 20:36:08.000000000 +0100
@@ -19,11 +19,11 @@
 #include <asm/war.h>
 
 #ifdef CONFIG_PREEMPT
-	.macro	preempt_stop reg=t0
+	.macro	preempt_stop
 	.endm
 #else
-	.macro	preempt_stop reg=t0
-	local_irq_disable \reg
+	.macro	preempt_stop
+	local_irq_disable
 	.endm
 #define resume_kernel	restore_all
 #endif
@@ -37,17 +37,18 @@ FEXPORT(ret_from_irq)
 	andi	t0, t0, KU_USER
 	beqz	t0, resume_kernel
 
-FEXPORT(resume_userspace)
-	local_irq_disable	t0	# make sure we dont miss an
+resume_userspace:
+	local_irq_disable		# make sure we dont miss an
 					# interrupt setting need_resched
 					# between sampling and return
 	LONG_L	a2, TI_FLAGS($28)	# current->work
-	andi	a2, _TIF_WORK_MASK	# (ignoring syscall_trace)
-	bnez	a2, work_pending
+	andi	t0, a2, _TIF_WORK_MASK	# (ignoring syscall_trace)
+	bnez	t0, work_pending
 	j	restore_all
 
 #ifdef CONFIG_PREEMPT
-ENTRY(resume_kernel)
+resume_kernel:
+	local_irq_disable
 	lw	t0, TI_PRE_COUNT($28)
 	bnez	t0, restore_all
 need_resched:
@@ -57,12 +58,7 @@ need_resched:
 	LONG_L	t0, PT_STATUS(sp)		# Interrupts off?
 	andi	t0, 1
 	beqz	t0, restore_all
-	li	t0, PREEMPT_ACTIVE
-	sw	t0, TI_PRE_COUNT($28)
-	local_irq_enable t0
-	jal	schedule
-	sw	zero, TI_PRE_COUNT($28)
-	local_irq_disable t0
+	jal	preempt_schedule_irq
 	b	need_resched
 #endif
 
@@ -88,13 +84,13 @@ FEXPORT(restore_partial)		# restore part
 	RESTORE_SP_AND_RET
 	.set	at
 
-FEXPORT(work_pending)
-	andi	t0, a2, _TIF_NEED_RESCHED
+work_pending:
+	andi	t0, a2, _TIF_NEED_RESCHED # a2 is preloaded with TI_FLAGS
 	beqz	t0, work_notifysig
 work_resched:
 	jal	schedule
 
-	local_irq_disable t0		# make sure need_resched and
+	local_irq_disable		# make sure need_resched and
 					# signals dont change between
 					# sampling and return
 	LONG_L	a2, TI_FLAGS($28)
@@ -113,11 +109,10 @@ work_notifysig:				# deal with pending s
 
 FEXPORT(syscall_exit_work_partial)
 	SAVE_STATIC
-FEXPORT(syscall_exit_work)
-	LONG_L	t0, TI_FLAGS($28)
-	li	t1, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
-	and	t0, t1
-	beqz	t0, work_pending	# trace bit is set
+syscall_exit_work:
+	li	t0, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
+	and	t0, a2			# a2 is preloaded with TI_FLAGS
+	beqz	t0, work_pending	# trace bit set?
 	local_irq_enable		# could let do_syscall_trace()
 					# call schedule() instead
 	move	a0, sp
@@ -128,28 +123,25 @@ FEXPORT(syscall_exit_work)
 /*
  * Common spurious interrupt handler.
  */
-	.text
-	.align  5
 LEAF(spurious_interrupt)
 	/*
 	 * Someone tried to fool us by sending an interrupt but we
 	 * couldn't find a cause for it.
 	 */
+	PTR_LA	t1, irq_err_count
 #ifdef CONFIG_SMP
-	lui     t1, %hi(irq_err_count)
-1:	ll      t0, %lo(irq_err_count)(t1)
+1:	ll      t0, (t1)
 	addiu   t0, 1
-	sc      t0, %lo(irq_err_count)(t1)
+	sc      t0, (t1)
 #if R10000_LLSC_WAR
 	beqzl	t0, 1b
 #else
 	beqz	t0, 1b
 #endif
 #else
-	lui     t1, %hi(irq_err_count)
-	lw      t0, %lo(irq_err_count)(t1)
+	lw      t0, (t1)
 	addiu   t0, 1
-	sw      t0, %lo(irq_err_count)(t1)
+	sw      t0, (t1)
 #endif
 	j	ret_from_irq
 	END(spurious_interrupt)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/gdb-stub.c linux_HEAD/arch/mips/kernel/gdb-stub.c
--- linux-2.6.11.6/arch/mips/kernel/gdb-stub.c	2005-03-26 04:28:38.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/gdb-stub.c	2005-02-17 21:48:54.000000000 +0100
@@ -176,7 +176,7 @@ int kgdb_enabled;
 /*
  * spin locks for smp case
  */
-static spinlock_t kgdb_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(kgdb_lock);
 static spinlock_t kgdb_cpulock[NR_CPUS] = { [0 ... NR_CPUS-1] = SPIN_LOCK_UNLOCKED};
 
 /*
@@ -637,15 +637,18 @@ static struct gdb_bp_save async_bp;
  * and only one can be active at a time.
  */
 extern spinlock_t smp_call_lock;
+
 void set_async_breakpoint(unsigned long *epc)
 {
 	/* skip breaking into userland */
 	if ((*epc & 0x80000000) == 0)
 		return;
 
+#ifdef CONFIG_SMP
 	/* avoid deadlock if someone is make IPC */
 	if (spin_is_locked(&smp_call_lock))
 		return;
+#endif
 
 	async_bp.addr = *epc;
 	*epc = (unsigned long)async_breakpoint;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/genex.S linux_HEAD/arch/mips/kernel/genex.S
--- linux-2.6.11.6/arch/mips/kernel/genex.S	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/genex.S	2004-12-21 03:25:15.000000000 +0100
@@ -82,7 +82,7 @@ NESTED(except_vec3_r4000, 0, sp)
 	 li	k0, 14<<2
 	beq	k1, k0, handle_vcei
 #ifdef CONFIG_MIPS64
-	dsll	k1, k1, 1
+	 dsll	k1, k1, 1
 #endif
 	.set	pop
 	PTR_L	k0, exception_handlers(k1)
@@ -90,17 +90,17 @@ NESTED(except_vec3_r4000, 0, sp)
 
 	/*
 	 * Big shit, we now may have two dirty primary cache lines for the same
-	 * physical address.  We can savely invalidate the line pointed to by
+	 * physical address.  We can safely invalidate the line pointed to by
 	 * c0_badvaddr because after return from this exception handler the
 	 * load / store will be re-executed.
 	 */
 handle_vced:
-	DMFC0	k0, CP0_BADVADDR
+	MFC0	k0, CP0_BADVADDR
 	li	k1, -4					# Is this ...
 	and	k0, k1					# ... really needed?
 	mtc0	zero, CP0_TAGLO
-	cache	Index_Store_Tag_D,(k0)
-	cache	Hit_Writeback_Inv_SD,(k0)
+	cache	Index_Store_Tag_D, (k0)
+	cache	Hit_Writeback_Inv_SD, (k0)
 #ifdef CONFIG_PROC_FS
 	PTR_LA	k0, vced_count
 	lw	k1, (k0)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/genrtc.c linux_HEAD/arch/mips/kernel/genrtc.c
--- linux-2.6.11.6/arch/mips/kernel/genrtc.c	2005-03-26 04:28:27.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/genrtc.c	2005-02-17 21:48:54.000000000 +0100
@@ -14,7 +14,7 @@
 #include <asm/rtc.h>
 #include <asm/time.h>
 
-static spinlock_t mips_rtc_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(mips_rtc_lock);
 
 unsigned int get_rtc_time(struct rtc_time *time)
 {
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/head.S linux_HEAD/arch/mips/kernel/head.S
--- linux-2.6.11.6/arch/mips/kernel/head.S	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/head.S	2005-03-28 22:29:17.000000000 +0200
@@ -157,6 +157,7 @@ NESTED(kernel_entry, 16, sp)			# kernel 
 	LONG_S		a2, fw_arg2
 	LONG_S		a3, fw_arg3
 
+	MTC0		zero, CP0_CONTEXT	# clear context register
 	PTR_LA		$28, init_thread_union
 	PTR_ADDIU	sp, $28, _THREAD_SIZE - 32
 	set_saved_sp	sp, t0, t1
@@ -200,19 +201,13 @@ NESTED(smp_bootstrap, 16, sp)
 	.comm	fw_arg2, SZREG, SZREG
 	.comm	fw_arg3, SZREG, SZREG
 
-	.macro	page name, order=0
-	.globl	\name
-\name:	.size	\name, (_PAGE_SIZE << \order)
-	.org	. + (_PAGE_SIZE << \order)
-	.type	\name, @object
+	.macro page name, order
+	.comm	\name, (_PAGE_SIZE << \order), (_PAGE_SIZE << \order)
 	.endm
 
-	.data
-	.align	PAGE_SHIFT
-
 	/*
-	 * ... but on 64-bit we've got three-level pagetables with a
-	 * slightly different layout ...
+	 * On 64-bit we've got three-level pagetables with a slightly
+	 * different layout ...
 	 */
 	page	swapper_pg_dir, _PGD_ORDER
 #ifdef CONFIG_MIPS64
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/i8259.c linux_HEAD/arch/mips/kernel/i8259.c
--- linux-2.6.11.6/arch/mips/kernel/i8259.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/i8259.c	2005-03-01 22:49:39.000000000 +0100
@@ -31,7 +31,7 @@ void disable_8259A_irq(unsigned int irq)
  * moves to arch independent land
  */
 
-spinlock_t i8259A_lock = SPIN_LOCK_UNLOCKED;
+DEFINE_SPINLOCK(i8259A_lock);
 
 static void end_8259A_irq (unsigned int irq)
 {
@@ -52,14 +52,13 @@ static unsigned int startup_8259A_irq(un
 }
 
 static struct hw_interrupt_type i8259A_irq_type = {
-	"XT-PIC",
-	startup_8259A_irq,
-	shutdown_8259A_irq,
-	enable_8259A_irq,
-	disable_8259A_irq,
-	mask_and_ack_8259A,
-	end_8259A_irq,
-	NULL
+	.typename = "XT-PIC",
+	.startup = startup_8259A_irq,
+	.shutdown = shutdown_8259A_irq,
+	.enable = enable_8259A_irq,
+	.disable = disable_8259A_irq,
+	.ack = mask_and_ack_8259A,
+	.end = end_8259A_irq,
 };
 
 /*
@@ -322,7 +321,7 @@ void __init init_i8259_irqs (void)
 
 	for (i = 0; i < 16; i++) {
 		irq_desc[i].status = IRQ_DISABLED;
-		irq_desc[i].action = 0;
+		irq_desc[i].action = NULL;
 		irq_desc[i].depth = 1;
 		irq_desc[i].handler = &i8259A_irq_type;
 	}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/irixinv.c linux_HEAD/arch/mips/kernel/irixinv.c
--- linux-2.6.11.6/arch/mips/kernel/irixinv.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/kernel/irixinv.c	2005-03-17 22:20:26.000000000 +0100
@@ -30,10 +30,10 @@ void add_to_inventory (int class, int ty
 	inventory_items++;
 }
 
-int dump_inventory_to_user (void *userbuf, int size)
+int dump_inventory_to_user (void __user *userbuf, int size)
 {
 	inventory_t *inv  = &inventory [0];
-	inventory_t *user = userbuf;
+	inventory_t __user *user = userbuf;
 	int v;
 
 	if (!access_ok(VERIFY_WRITE, userbuf, size))
@@ -41,7 +41,8 @@ int dump_inventory_to_user (void *userbu
 
 	for (v = 0; v < inventory_items; v++){
 		inv = &inventory [v];
-		copy_to_user (user, inv, sizeof (inventory_t));
+		if (copy_to_user (user, inv, sizeof (inventory_t)))
+			return -EFAULT;
 		user++;
 	}
 	return inventory_items * sizeof (inventory_t);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/irixioctl.c linux_HEAD/arch/mips/kernel/irixioctl.c
--- linux-2.6.11.6/arch/mips/kernel/irixioctl.c	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/irixioctl.c	2005-03-17 22:20:26.000000000 +0100
@@ -58,7 +58,7 @@ asmlinkage int irix_ioctl(int fd, unsign
 {
 	struct tty_struct *tp, *rtp;
 	mm_segment_t old_fs;
-	int error = 0;
+	int i, error = 0;
 
 #ifdef DEBUG_IOCTLS
 	printk("[%s:%d] irix_ioctl(%d, ", current->comm, current->pid, fd);
@@ -73,12 +73,13 @@ asmlinkage int irix_ioctl(int fd, unsign
 
 	case 0x0000540d: {
 		struct termios kt;
-		struct irix_termios *it = (struct irix_termios *) arg;
+		struct irix_termios __user *it =
+			(struct irix_termios __user *) arg;
 
 #ifdef DEBUG_IOCTLS
 		printk("TCGETS, %08lx) ", arg);
 #endif
-		if(!access_ok(VERIFY_WRITE, it, sizeof(*it))) {
+		if (!access_ok(VERIFY_WRITE, it, sizeof(*it))) {
 			error = -EFAULT;
 			break;
 		}
@@ -87,13 +88,14 @@ asmlinkage int irix_ioctl(int fd, unsign
 		set_fs(old_fs);
 		if (error)
 			break;
-		__put_user(kt.c_iflag, &it->c_iflag);
-		__put_user(kt.c_oflag, &it->c_oflag);
-		__put_user(kt.c_cflag, &it->c_cflag);
-		__put_user(kt.c_lflag, &it->c_lflag);
-		for(error = 0; error < NCCS; error++)
-			__put_user(kt.c_cc[error], &it->c_cc[error]);
-		error = 0;
+
+		error = __put_user(kt.c_iflag, &it->c_iflag);
+		error |= __put_user(kt.c_oflag, &it->c_oflag);
+		error |= __put_user(kt.c_cflag, &it->c_cflag);
+		error |= __put_user(kt.c_lflag, &it->c_lflag);
+
+		for (i = 0; i < NCCS; i++)
+			error |= __put_user(kt.c_cc[i], &it->c_cc[i]);
 		break;
 	}
 
@@ -111,14 +113,19 @@ asmlinkage int irix_ioctl(int fd, unsign
 		old_fs = get_fs(); set_fs(get_ds());
 		error = sys_ioctl(fd, TCGETS, (unsigned long) &kt);
 		set_fs(old_fs);
-		if(error)
+		if (error)
+			break;
+
+		error = __get_user(kt.c_iflag, &it->c_iflag);
+		error |= __get_user(kt.c_oflag, &it->c_oflag);
+		error |= __get_user(kt.c_cflag, &it->c_cflag);
+		error |= __get_user(kt.c_lflag, &it->c_lflag);
+
+		for (i = 0; i < NCCS; i++)
+			error |= __get_user(kt.c_cc[i], &it->c_cc[i]);
+
+		if (error)
 			break;
-		__get_user(kt.c_iflag, &it->c_iflag);
-		__get_user(kt.c_oflag, &it->c_oflag);
-		__get_user(kt.c_cflag, &it->c_cflag);
-		__get_user(kt.c_lflag, &it->c_lflag);
-		for(error = 0; error < NCCS; error++)
-			__get_user(kt.c_cc[error], &it->c_cc[error]);
 		old_fs = get_fs(); set_fs(get_ds());
 		error = sys_ioctl(fd, TCSETS, (unsigned long) &kt);
 		set_fs(old_fs);
@@ -152,7 +159,7 @@ asmlinkage int irix_ioctl(int fd, unsign
 #ifdef DEBUG_IOCTLS
 		printk("rtp->session=%d ", rtp->session);
 #endif
-		error = put_user(rtp->session, (unsigned long *) arg);
+		error = put_user(rtp->session, (unsigned long __user *) arg);
 		break;
 
 	case 0x746e:
@@ -194,50 +201,32 @@ asmlinkage int irix_ioctl(int fd, unsign
 		break;
 
 	case 0x8004667e:
-#ifdef DEBUG_IOCTLS
-		printk("FIONBIO, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, FIONBIO, arg);
 		break;
 
 	case 0x80047476:
-#ifdef DEBUG_IOCTLS
-		printk("TIOCSPGRP, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, TIOCSPGRP, arg);
 		break;
 
 	case 0x8020690c:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCSIFADDR, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCSIFADDR, arg);
 		break;
 
 	case 0x80206910:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCSIFFLAGS, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCSIFFLAGS, arg);
 		break;
 
 	case 0xc0206911:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCGIFFLAGS, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCGIFFLAGS, arg);
 		break;
 
 	case 0xc020691b:
-#ifdef DEBUG_IOCTLS
-		printk("SIOCGIFMETRIC, %08lx) arg=%d ", arg, *(int *)arg);
-#endif
 		error = sys_ioctl(fd, SIOCGIFMETRIC, arg);
 		break;
 
 	default: {
 #ifdef DEBUG_MISSING_IOCTL
-		char *msg = "Unimplemented IOCTL cmd tell linux@engr.sgi.com\n";
+		char *msg = "Unimplemented IOCTL cmd tell linux-mips@linux-mips.org\n";
 
 #ifdef DEBUG_IOCTLS
 		printk("UNIMP_IOCTL, %08lx)\n", arg);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/irq-msc01.c linux_HEAD/arch/mips/kernel/irq-msc01.c
--- linux-2.6.11.6/arch/mips/kernel/irq-msc01.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/irq-msc01.c	2005-02-28 16:56:41.000000000 +0100
@@ -129,25 +129,23 @@ msc_bind_eic_interrupt (unsigned int irq
 #define shutdown_msc_irq	disable_msc_irq
 
 struct hw_interrupt_type msc_levelirq_type = {
-	"SOC-it-Level",
-	startup_msc_irq,
-	shutdown_msc_irq,
-	enable_msc_irq,
-	disable_msc_irq,
-	level_mask_and_ack_msc_irq,
-	end_msc_irq,
-	NULL
+	.typename = "SOC-it-Level",
+	.startup = startup_msc_irq,
+	.shutdown = shutdown_msc_irq,
+	.enable = enable_msc_irq,
+	.disable = disable_msc_irq,
+	.ack = level_mask_and_ack_msc_irq,
+	.end = end_msc_irq,
 };
 
 struct hw_interrupt_type msc_edgeirq_type = {
-	"SOC-it-Edge",
-	startup_msc_irq,
-	shutdown_msc_irq,
-	enable_msc_irq,
-	disable_msc_irq,
-	edge_mask_and_ack_msc_irq,
-	end_msc_irq,
-	NULL
+	.typename = "SOC-it-Edge",
+	.startup =startup_msc_irq,
+	.shutdown = shutdown_msc_irq,
+	.enable = enable_msc_irq,
+	.disable = disable_msc_irq,
+	.ack = edge_mask_and_ack_msc_irq,
+	.end = end_msc_irq,
 };
 
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/irq-mv6434x.c linux_HEAD/arch/mips/kernel/irq-mv6434x.c
--- linux-2.6.11.6/arch/mips/kernel/irq-mv6434x.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/irq-mv6434x.c	2005-02-28 16:56:41.000000000 +0100
@@ -135,14 +135,13 @@ void ll_mv64340_irq(struct pt_regs *regs
 #define shutdown_mv64340_irq	disable_mv64340_irq
 
 struct hw_interrupt_type mv64340_irq_type = {
-	"MV-64340",
-	startup_mv64340_irq,
-	shutdown_mv64340_irq,
-	enable_mv64340_irq,
-	disable_mv64340_irq,
-	mask_and_ack_mv64340_irq,
-	end_mv64340_irq,
-	NULL
+	.typename = "MV-64340",
+	.startup = startup_mv64340_irq,
+	.shutdown = shutdown_mv64340_irq,
+	.enable = enable_mv64340_irq,
+	.disable = disable_mv64340_irq,
+	.ack = mask_and_ack_mv64340_irq,
+	.end = end_mv64340_irq,
 };
 
 void __init mv64340_irq_init(unsigned int base)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/irq-rm7000.c linux_HEAD/arch/mips/kernel/irq-rm7000.c
--- linux-2.6.11.6/arch/mips/kernel/irq-rm7000.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/irq-rm7000.c	2005-02-28 16:56:41.000000000 +0100
@@ -72,13 +72,13 @@ static void rm7k_cpu_irq_end(unsigned in
 }
 
 static hw_irq_controller rm7k_irq_controller = {
-	"RM7000",
-	rm7k_cpu_irq_startup,
-	rm7k_cpu_irq_shutdown,
-	rm7k_cpu_irq_enable,
-	rm7k_cpu_irq_disable,
-	rm7k_cpu_irq_ack,
-	rm7k_cpu_irq_end,
+	.typename = "RM7000",
+	.startup = rm7k_cpu_irq_startup,
+	.shutdown = rm7k_cpu_irq_shutdown,
+	.enable = rm7k_cpu_irq_enable,
+	.disable = rm7k_cpu_irq_disable,
+	.ack = rm7k_cpu_irq_ack,
+	.end = rm7k_cpu_irq_end,
 };
 
 void __init rm7k_cpu_irq_init(int base)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/irq-rm9000.c linux_HEAD/arch/mips/kernel/irq-rm9000.c
--- linux-2.6.11.6/arch/mips/kernel/irq-rm9000.c	2005-03-26 04:28:40.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/irq-rm9000.c	2005-02-28 16:56:41.000000000 +0100
@@ -106,23 +106,23 @@ static void rm9k_cpu_irq_end(unsigned in
 }
 
 static hw_irq_controller rm9k_irq_controller = {
-	"RM9000",
-	rm9k_cpu_irq_startup,
-	rm9k_cpu_irq_shutdown,
-	rm9k_cpu_irq_enable,
-	rm9k_cpu_irq_disable,
-	rm9k_cpu_irq_ack,
-	rm9k_cpu_irq_end,
+	.typename = "RM9000",
+	.startup = rm9k_cpu_irq_startup,
+	.shutdown = rm9k_cpu_irq_shutdown,
+	.enable = rm9k_cpu_irq_enable,
+	.disable = rm9k_cpu_irq_disable,
+	.ack = rm9k_cpu_irq_ack,
+	.end = rm9k_cpu_irq_end,
 };
 
 static hw_irq_controller rm9k_perfcounter_irq = {
-	"RM9000",
-	rm9k_perfcounter_irq_startup,
-	rm9k_perfcounter_irq_shutdown,
-	rm9k_cpu_irq_enable,
-	rm9k_cpu_irq_disable,
-	rm9k_cpu_irq_ack,
-	rm9k_cpu_irq_end,
+	.typename = "RM9000",
+	.startup = rm9k_perfcounter_irq_startup,
+	.shutdown = rm9k_perfcounter_irq_shutdown,
+	.enable = rm9k_cpu_irq_enable,
+	.disable = rm9k_cpu_irq_disable,
+	.ack = rm9k_cpu_irq_ack,
+	.end = rm9k_cpu_irq_end,
 };
 
 unsigned int rm9000_perfcount_irq;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/irq_cpu.c linux_HEAD/arch/mips/kernel/irq_cpu.c
--- linux-2.6.11.6/arch/mips/kernel/irq_cpu.c	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/irq_cpu.c	2005-02-28 16:56:41.000000000 +0100
@@ -3,6 +3,8 @@
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
  *
  * Copyright (C) 2001 Ralf Baechle
+ * Copyright (C) 2005  MIPS Technologies, Inc.  All rights reserved.
+ *      Author: Maciej W. Rozycki <macro@mips.com>
  *
  * This file define the irq handler for MIPS CPU interrupts.
  *
@@ -37,7 +39,6 @@ static int mips_cpu_irq_base;
 
 static inline void unmask_mips_irq(unsigned int irq)
 {
-	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
 	set_c0_status(0x100 << (irq - mips_cpu_irq_base));
 }
 
@@ -92,14 +93,13 @@ static void mips_cpu_irq_end(unsigned in
 }
 
 static hw_irq_controller mips_cpu_irq_controller = {
-	"MIPS",
-	mips_cpu_irq_startup,
-	mips_cpu_irq_shutdown,
-	mips_cpu_irq_enable,
-	mips_cpu_irq_disable,
-	mips_cpu_irq_ack,
-	mips_cpu_irq_end,
-	NULL			/* no affinity stuff for UP */
+	.typename = "MIPS",
+	.startup = mips_cpu_irq_startup,
+	.shutdown = mips_cpu_irq_shutdown,
+	.enable = mips_cpu_irq_enable,
+	.disable = mips_cpu_irq_disable,
+	.ack = mips_cpu_irq_ack,
+	.end = mips_cpu_irq_end,
 };
 
 
@@ -107,6 +107,10 @@ void __init mips_cpu_irq_init(int irq_ba
 {
 	int i;
 
+	/* Mask interrupts. */
+	clear_c0_status(ST0_IM);
+	clear_c0_cause(CAUSEF_IP);
+
 	for (i = irq_base; i < irq_base + 8; i++) {
 		irq_desc[i].status = IRQ_DISABLED;
 		irq_desc[i].action = NULL;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/linux32.c linux_HEAD/arch/mips/kernel/linux32.c
--- linux-2.6.11.6/arch/mips/kernel/linux32.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/kernel/linux32.c	2005-02-17 21:48:55.000000000 +0100
@@ -215,81 +215,35 @@ sys32_readdir(unsigned int fd, void * di
 	return(n);
 }
 
-struct rusage32 {
-        struct compat_timeval ru_utime;
-        struct compat_timeval ru_stime;
-        int    ru_maxrss;
-        int    ru_ixrss;
-        int    ru_idrss;
-        int    ru_isrss;
-        int    ru_minflt;
-        int    ru_majflt;
-        int    ru_nswap;
-        int    ru_inblock;
-        int    ru_oublock;
-        int    ru_msgsnd;
-        int    ru_msgrcv;
-        int    ru_nsignals;
-        int    ru_nvcsw;
-        int    ru_nivcsw;
-};
+asmlinkage int compat_sys_wait4(compat_pid_t pid, unsigned int * stat_addr,
+				int options, struct compat_rusage * ru);
 
-static int
-put_rusage (struct rusage32 *ru, struct rusage *r)
+asmlinkage int
+sys32_waitpid(compat_pid_t pid, unsigned int *stat_addr, int options)
 {
-	int err;
-
-	if (verify_area(VERIFY_WRITE, ru, sizeof *ru))
-		return -EFAULT;
-
-	err = __put_user (r->ru_utime.tv_sec, &ru->ru_utime.tv_sec);
-	err |= __put_user (r->ru_utime.tv_usec, &ru->ru_utime.tv_usec);
-	err |= __put_user (r->ru_stime.tv_sec, &ru->ru_stime.tv_sec);
-	err |= __put_user (r->ru_stime.tv_usec, &ru->ru_stime.tv_usec);
-	err |= __put_user (r->ru_maxrss, &ru->ru_maxrss);
-	err |= __put_user (r->ru_ixrss, &ru->ru_ixrss);
-	err |= __put_user (r->ru_idrss, &ru->ru_idrss);
-	err |= __put_user (r->ru_isrss, &ru->ru_isrss);
-	err |= __put_user (r->ru_minflt, &ru->ru_minflt);
-	err |= __put_user (r->ru_majflt, &ru->ru_majflt);
-	err |= __put_user (r->ru_nswap, &ru->ru_nswap);
-	err |= __put_user (r->ru_inblock, &ru->ru_inblock);
-	err |= __put_user (r->ru_oublock, &ru->ru_oublock);
-	err |= __put_user (r->ru_msgsnd, &ru->ru_msgsnd);
-	err |= __put_user (r->ru_msgrcv, &ru->ru_msgrcv);
-	err |= __put_user (r->ru_nsignals, &ru->ru_nsignals);
-	err |= __put_user (r->ru_nvcsw, &ru->ru_nvcsw);
-	err |= __put_user (r->ru_nivcsw, &ru->ru_nivcsw);
-
-	return err;
+	return compat_sys_wait4(pid, stat_addr, options, NULL);
 }
 
-asmlinkage int
-sys32_wait4(compat_pid_t pid, unsigned int * stat_addr, int options,
-	    struct rusage32 * ru)
+asmlinkage long
+sysn32_waitid(int which, compat_pid_t pid,
+	      siginfo_t __user *uinfo, int options,
+	      struct compat_rusage __user *uru)
 {
-	if (!ru)
-		return sys_wait4(pid, stat_addr, options, NULL);
-	else {
-		struct rusage r;
-		int ret;
-		unsigned int status;
-		mm_segment_t old_fs = get_fs();
+	struct rusage ru;
+	long ret;
+	mm_segment_t old_fs = get_fs();
 
-		set_fs(KERNEL_DS);
-		ret = sys_wait4(pid, stat_addr ? &status : NULL, options, &r);
-		set_fs(old_fs);
-		if (put_rusage (ru, &r)) return -EFAULT;
-		if (stat_addr && put_user (status, stat_addr))
-			return -EFAULT;
+	set_fs (KERNEL_DS);
+	ret = sys_waitid(which, pid, uinfo, options,
+			 uru ? (struct rusage __user *) &ru : NULL);
+	set_fs (old_fs);
+
+	if (ret < 0 || uinfo->si_signo == 0)
 		return ret;
-	}
-}
 
-asmlinkage int
-sys32_waitpid(compat_pid_t pid, unsigned int *stat_addr, int options)
-{
-	return sys32_wait4(pid, stat_addr, options, NULL);
+	if (uru)
+		ret = put_compat_rusage(&ru, uru);
+	return ret;
 }
 
 struct sysinfo32 {
@@ -1467,3 +1421,53 @@ asmlinkage long sys32_socketcall(int cal
 	}
 	return err;
 }
+
+struct sigevent32 { 
+	u32 sigev_value;
+	u32 sigev_signo; 
+	u32 sigev_notify; 
+	u32 payload[(64 / 4) - 3]; 
+}; 
+
+extern asmlinkage long
+sys_timer_create(clockid_t which_clock,
+		 struct sigevent __user *timer_event_spec,
+		 timer_t __user * created_timer_id);
+
+long
+sys32_timer_create(u32 clock, struct sigevent32 __user *se32, timer_t __user *timer_id)
+{
+	struct sigevent __user *p = NULL;
+	if (se32) { 
+		struct sigevent se;
+		p = compat_alloc_user_space(sizeof(struct sigevent));
+		memset(&se, 0, sizeof(struct sigevent)); 
+		if (get_user(se.sigev_value.sival_int,  &se32->sigev_value) ||
+		    __get_user(se.sigev_signo, &se32->sigev_signo) ||
+		    __get_user(se.sigev_notify, &se32->sigev_notify) ||
+		    __copy_from_user(&se._sigev_un._pad, &se32->payload, 
+				     sizeof(se32->payload)) ||
+		    copy_to_user(p, &se, sizeof(se)))
+			return -EFAULT;
+	} 
+	return sys_timer_create(clock, p, timer_id);
+} 
+
+asmlinkage long
+sysn32_rt_sigtimedwait(const sigset_t __user *uthese,
+		       siginfo_t __user *uinfo,
+		       const struct compat_timespec __user *uts32,
+		       size_t sigsetsize)
+{
+	struct timespec __user *uts = NULL;
+
+	if (uts32) {
+		struct timespec ts;
+		uts = compat_alloc_user_space(sizeof(struct timespec));
+		if (get_user(ts.tv_sec, &uts32->tv_sec) ||
+		    get_user(ts.tv_nsec, &uts32->tv_nsec) ||
+		    copy_to_user (uts, &ts, sizeof (ts)))
+			return -EFAULT;
+	}
+	return sys_rt_sigtimedwait(uthese, uinfo, uts, sigsetsize);
+}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/module-elf32.c linux_HEAD/arch/mips/kernel/module-elf32.c
--- linux-2.6.11.6/arch/mips/kernel/module-elf32.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/module-elf32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,250 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *  Copyright (C) 2001 Rusty Russell.
- *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
- */
-
-#undef DEBUG
-
-#include <linux/moduleloader.h>
-#include <linux/elf.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-
-struct mips_hi16 {
-	struct mips_hi16 *next;
-	Elf32_Addr *addr;
-	Elf32_Addr value;
-};
-
-static struct mips_hi16 *mips_hi16_list;
-
-void *module_alloc(unsigned long size)
-{
-	if (size == 0)
-		return NULL;
-	return vmalloc(size);
-}
-
-
-/* Free memory returned from module_alloc */
-void module_free(struct module *mod, void *module_region)
-{
-	vfree(module_region);
-	/* FIXME: If module_region == mod->init_region, trim exception
-           table entries. */
-}
-
-int module_frob_arch_sections(Elf_Ehdr *hdr,
-			      Elf_Shdr *sechdrs,
-			      char *secstrings,
-			      struct module *mod)
-{
-	return 0;
-}
-
-static int apply_r_mips_none(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	return 0;
-}
-
-static int apply_r_mips_32(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	*location += v;
-
-	return 0;
-}
-
-static int apply_r_mips_26(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	if (v % 4) {
-		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
-		return -ENOEXEC;
-	}
-
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
-
-	*location = (*location & ~0x03ffffff) |
-	            ((*location + (v >> 2)) & 0x03ffffff);
-
-	return 0;
-}
-
-static int apply_r_mips_hi16(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	struct mips_hi16 *n;
-
-	/*
-	 * We cannot relocate this one now because we don't know the value of
-	 * the carry we need to add.  Save the information, and let LO16 do the
-	 * actual relocation.
-	 */
-	n = kmalloc(sizeof *n, GFP_KERNEL);
-	if (!n)
-		return -ENOMEM;
-
-	n->addr = location;
-	n->value = v;
-	n->next = mips_hi16_list;
-	mips_hi16_list = n;
-
-	return 0;
-}
-
-static int apply_r_mips_lo16(struct module *me, uint32_t *location,
-	Elf32_Addr v)
-{
-	unsigned long insnlo = *location;
-	Elf32_Addr val, vallo;
-
-	/* Sign extend the addend we extract from the lo insn.  */
-	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
-
-	if (mips_hi16_list != NULL) {
-		struct mips_hi16 *l;
-
-		l = mips_hi16_list;
-		while (l != NULL) {
-			struct mips_hi16 *next;
-			unsigned long insn;
-
-			/*
-			 * The value for the HI16 had best be the same.
-			 */
-			if (v != l->value)
-				goto out_danger;
-
-			/*
-			 * Do the HI16 relocation.  Note that we actually don't
-			 * need to know anything about the LO16 itself, except
-			 * where to find the low 16 bits of the addend needed
-			 * by the LO16.
-			 */
-			insn = *l->addr;
-			val = ((insn & 0xffff) << 16) + vallo;
-			val += v;
-
-			/*
-			 * Account for the sign extension that will happen in
-			 * the low bits.
-			 */
-			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
-
-			insn = (insn & ~0xffff) | val;
-			*l->addr = insn;
-
-			next = l->next;
-			kfree(l);
-			l = next;
-		}
-
-		mips_hi16_list = NULL;
-	}
-
-	/*
-	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
-	 */
-	val = v + vallo;
-	insnlo = (insnlo & ~0xffff) | (val & 0xffff);
-	*location = insnlo;
-
-	return 0;
-
-out_danger:
-	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
-
-	return -ENOEXEC;
-}
-
-static int (*reloc_handlers[]) (struct module *me, uint32_t *location,
-	Elf32_Addr v) = {
-	[R_MIPS_NONE]	= apply_r_mips_none,
-	[R_MIPS_32]	= apply_r_mips_32,
-	[R_MIPS_26]	= apply_r_mips_26,
-	[R_MIPS_HI16]	= apply_r_mips_hi16,
-	[R_MIPS_LO16]	= apply_r_mips_lo16
-};
-
-int apply_relocate(Elf32_Shdr *sechdrs,
-		   const char *strtab,
-		   unsigned int symindex,
-		   unsigned int relsec,
-		   struct module *me)
-{
-	Elf32_Rel *rel = (void *) sechdrs[relsec].sh_addr;
-	Elf32_Sym *sym;
-	uint32_t *location;
-	unsigned int i;
-	Elf32_Addr v;
-	int res;
-
-	pr_debug("Applying relocate section %u to %u\n", relsec,
-	       sechdrs[relsec].sh_info);
-
-	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
-		Elf32_Word r_info = rel[i].r_info;
-
-		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
-		/* This is the symbol it is referring to */
-		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
-			+ ELF32_R_SYM(r_info);
-		if (!sym->st_value) {
-			printk(KERN_WARNING "%s: Unknown symbol %s\n",
-			       me->name, strtab + sym->st_name);
-			return -ENOENT;
-		}
-
-		v = sym->st_value;
-
-		res = reloc_handlers[ELF32_R_TYPE(r_info)](me, location, v);
-		if (res)
-			return res;
-	}
-
-	return 0;
-}
-
-int apply_relocate_add(Elf32_Shdr *sechdrs,
-		       const char *strtab,
-		       unsigned int symindex,
-		       unsigned int relsec,
-		       struct module *me)
-{
-	/*
-	 * Current binutils always generate .rela relocations.  Keep smiling
-	 * if it's empty, abort otherwise.
-	 */
-	if (!sechdrs[relsec].sh_size)
-		return 0;
-
-	printk(KERN_ERR "module %s: ADD RELOCATION unsupported\n",
-	       me->name);
-	return -ENOEXEC;
-}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/module-elf64.c linux_HEAD/arch/mips/kernel/module-elf64.c
--- linux-2.6.11.6/arch/mips/kernel/module-elf64.c	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/module-elf64.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,274 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *  Copyright (C) 2001 Rusty Russell.
- *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
- */
-
-#undef DEBUG
-
-#include <linux/moduleloader.h>
-#include <linux/elf.h>
-#include <linux/vmalloc.h>
-#include <linux/slab.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-
-struct mips_hi16 {
-	struct mips_hi16 *next;
-	Elf32_Addr *addr;
-	Elf64_Addr value;
-};
-
-static struct mips_hi16 *mips_hi16_list;
-
-void *module_alloc(unsigned long size)
-{
-	if (size == 0)
-		return NULL;
-	return vmalloc(size);
-}
-
-
-/* Free memory returned from module_alloc */
-void module_free(struct module *mod, void *module_region)
-{
-	vfree(module_region);
-	/* FIXME: If module_region == mod->init_region, trim exception
-           table entries. */
-}
-
-int module_frob_arch_sections(Elf_Ehdr *hdr,
-			      Elf_Shdr *sechdrs,
-			      char *secstrings,
-			      struct module *mod)
-{
-	return 0;
-}
-
-int apply_relocate(Elf64_Shdr *sechdrs,
-		   const char *strtab,
-		   unsigned int symindex,
-		   unsigned int relsec,
-		   struct module *me)
-{
-	/*
-	 * We don't want to deal with REL relocations - RELA is so much saner.
-	 */
-	if (!sechdrs[relsec].sh_size)
-		return 0;
-
-	printk(KERN_ERR "module %s: REL relocation unsupported\n",
-	       me->name);
-	return -ENOEXEC;
-}
-
-static int apply_r_mips_none(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	return 0;
-}
-
-static int apply_r_mips_32(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = v;
-
-	return 0;
-}
-
-static int apply_r_mips_26(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	if (v % 4) {
-		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
-		return -ENOEXEC;
-	}
-
-	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
-		printk(KERN_ERR
-		       "module %s: relocation overflow\n",
-		       me->name);
-		return -ENOEXEC;
-	}
-
-	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
-
-	return 0;
-}
-
-static int apply_r_mips_hi16(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	struct mips_hi16 *n;
-
-	/*
-	 * We cannot relocate this one now because we don't know the value of
-	 * the carry we need to add.  Save the information, and let LO16 do the
-	 * actual relocation.
-	 */
-	n = kmalloc(sizeof *n, GFP_KERNEL);
-	if (!n)
-		return -ENOMEM;
-
-	n->addr = location;
-	n->value = v;
-	n->next = mips_hi16_list;
-	mips_hi16_list = n;
-
-	return 0;
-}
-
-static int apply_r_mips_lo16(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	unsigned long insnlo = *location;
-	Elf32_Addr val, vallo;
-
-	/* Sign extend the addend we extract from the lo insn.  */
-	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
-
-	if (mips_hi16_list != NULL) {
-		struct mips_hi16 *l;
-
-		l = mips_hi16_list;
-		while (l != NULL) {
-			struct mips_hi16 *next;
-			unsigned long insn;
-
-			/*
-			 * The value for the HI16 had best be the same.
-			 */
-			if (v != l->value)
-				goto out_danger;
-
-			/*
-			 * Do the HI16 relocation.  Note that we actually don't
-			 * need to know anything about the LO16 itself, except
-			 * where to find the low 16 bits of the addend needed
-			 * by the LO16.
-			 */
-			insn = *l->addr;
-			val = ((insn & 0xffff) << 16) + vallo;
-			val += v;
-
-			/*
-			 * Account for the sign extension that will happen in
-			 * the low bits.
-			 */
-			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
-
-			insn = (insn & ~0xffff) | val;
-			*l->addr = insn;
-
-			next = l->next;
-			kfree(l);
-			l = next;
-		}
-
-		mips_hi16_list = NULL;
-	}
-
-	/*
-	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
-	 */
-	insnlo = (insnlo & ~0xffff) | (v & 0xffff);
-	*location = insnlo;
-
-	return 0;
-
-out_danger:
-	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
-
-	return -ENOEXEC;
-}
-
-static int apply_r_mips_64(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*(uint64_t *) location = v;
-
-	return 0;
-}
-
-
-static int apply_r_mips_higher(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = (*location & 0xffff0000) |
-	            ((((long long) v + 0x80008000LL) >> 32) & 0xffff);
-
-	return 0;
-}
-
-static int apply_r_mips_highest(struct module *me, uint32_t *location,
-	Elf64_Addr v)
-{
-	*location = (*location & 0xffff0000) |
-	            ((((long long) v + 0x800080008000LL) >> 48) & 0xffff);
-
-	return 0;
-}
-
-static int (*reloc_handlers[]) (struct module *me, uint32_t *location,
-	Elf64_Addr v) = {
-	[R_MIPS_NONE]		= apply_r_mips_none,
-	[R_MIPS_32]		= apply_r_mips_32,
-	[R_MIPS_26]		= apply_r_mips_26,
-	[R_MIPS_HI16]		= apply_r_mips_hi16,
-	[R_MIPS_LO16]		= apply_r_mips_lo16,
-	[R_MIPS_64]		= apply_r_mips_64,
-	[R_MIPS_HIGHER]		= apply_r_mips_higher,
-	[R_MIPS_HIGHEST]	= apply_r_mips_highest
-};
-
-int apply_relocate_add(Elf64_Shdr *sechdrs,
-		       const char *strtab,
-		       unsigned int symindex,
-		       unsigned int relsec,
-		       struct module *me)
-{
-	Elf64_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;
-	Elf64_Sym *sym;
-	uint32_t *location;
-	unsigned int i;
-	Elf64_Addr v;
-	int res;
-
-	pr_debug("Applying relocate section %u to %u\n", relsec,
-	       sechdrs[relsec].sh_info);
-
-	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
-		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
-		/* This is the symbol it is referring to */
-		sym = (Elf64_Sym *)sechdrs[symindex].sh_addr + rel[i].r_sym;
-		if (!sym->st_value) {
-			printk(KERN_WARNING "%s: Unknown symbol %s\n",
-			       me->name, strtab + sym->st_name);
-			return -ENOENT;
-		}
-
-		v = sym->st_value;
-
-		res = reloc_handlers[rel[i].r_type](me, location, v);
-		if (res)
-			return res;
-	}
-
-	return 0;
-}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/module.c linux_HEAD/arch/mips/kernel/module.c
--- linux-2.6.11.6/arch/mips/kernel/module.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/module.c	2005-03-30 09:06:31.000000000 +0200
@@ -1,9 +1,345 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  Copyright (C) 2001 Rusty Russell.
+ *  Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
+ *  Copyright (C) 2005 Thiemo Seufer
+ */
+
+#undef DEBUG
+
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/spinlock.h>
 
+struct mips_hi16 {
+	struct mips_hi16 *next;
+	Elf_Addr *addr;
+	Elf_Addr value;
+};
+
+static struct mips_hi16 *mips_hi16_list;
+
 static LIST_HEAD(dbe_list);
 static DEFINE_SPINLOCK(dbe_lock);
 
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+	/* FIXME: If module_region == mod->init_region, trim exception
+           table entries. */
+}
+
+int module_frob_arch_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
+			      char *secstrings, struct module *mod)
+{
+	return 0;
+}
+
+static int apply_r_mips_none(struct module *me, u32 *location, Elf_Addr v)
+{
+	return 0;
+}
+
+static int apply_r_mips_32_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location += v;
+
+	return 0;
+}
+
+static int apply_r_mips_32_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = v;
+
+	return 0;
+}
+
+static int apply_r_mips_26_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	if (v % 4) {
+		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
+		return -ENOEXEC;
+	}
+
+	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+		printk(KERN_ERR
+		       "module %s: relocation overflow\n",
+		       me->name);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & ~0x03ffffff) |
+	            ((*location + (v >> 2)) & 0x03ffffff);
+
+	return 0;
+}
+
+static int apply_r_mips_26_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	if (v % 4) {
+		printk(KERN_ERR "module %s: dangerous relocation\n", me->name);
+		return -ENOEXEC;
+	}
+
+	if ((v & 0xf0000000) != (((unsigned long)location + 4) & 0xf0000000)) {
+		printk(KERN_ERR
+		       "module %s: relocation overflow\n",
+		       me->name);
+		return -ENOEXEC;
+	}
+
+	*location = (*location & ~0x03ffffff) | ((v >> 2) & 0x03ffffff);
+
+	return 0;
+}
+
+static int apply_r_mips_hi16_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	struct mips_hi16 *n;
+
+	/*
+	 * We cannot relocate this one now because we don't know the value of
+	 * the carry we need to add.  Save the information, and let LO16 do the
+	 * actual relocation.
+	 */
+	n = kmalloc(sizeof *n, GFP_KERNEL);
+	if (!n)
+		return -ENOMEM;
+
+	n->addr = (Elf_Addr *)location;
+	n->value = v;
+	n->next = mips_hi16_list;
+	mips_hi16_list = n;
+
+	return 0;
+}
+
+static int apply_r_mips_hi16_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x8000LL) >> 16) & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_lo16_rel(struct module *me, u32 *location, Elf_Addr v)
+{
+	unsigned long insnlo = *location;
+	Elf_Addr val, vallo;
+
+	/* Sign extend the addend we extract from the lo insn.  */
+	vallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;
+
+	if (mips_hi16_list != NULL) {
+		struct mips_hi16 *l;
+
+		l = mips_hi16_list;
+		while (l != NULL) {
+			struct mips_hi16 *next;
+			unsigned long insn;
+
+			/*
+			 * The value for the HI16 had best be the same.
+			 */
+			if (v != l->value)
+				goto out_danger;
+
+			/*
+			 * Do the HI16 relocation.  Note that we actually don't
+			 * need to know anything about the LO16 itself, except
+			 * where to find the low 16 bits of the addend needed
+			 * by the LO16.
+			 */
+			insn = *l->addr;
+			val = ((insn & 0xffff) << 16) + vallo;
+			val += v;
+
+			/*
+			 * Account for the sign extension that will happen in
+			 * the low bits.
+			 */
+			val = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;
+
+			insn = (insn & ~0xffff) | val;
+			*l->addr = insn;
+
+			next = l->next;
+			kfree(l);
+			l = next;
+		}
+
+		mips_hi16_list = NULL;
+	}
+
+	/*
+	 * Ok, we're done with the HI16 relocs.  Now deal with the LO16.
+	 */
+	val = v + vallo;
+	insnlo = (insnlo & ~0xffff) | (val & 0xffff);
+	*location = insnlo;
+
+	return 0;
+
+out_danger:
+	printk(KERN_ERR "module %s: dangerous " "relocation\n", me->name);
+
+	return -ENOEXEC;
+}
+
+static int apply_r_mips_lo16_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) | (v & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_64_rela(struct module *me, u32 *location, Elf_Addr v)
+{
+	*(Elf_Addr *)location = v;
+
+	return 0;
+}
+
+static int apply_r_mips_higher_rela(struct module *me, u32 *location,
+				    Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x80008000LL) >> 32) & 0xffff);
+
+	return 0;
+}
+
+static int apply_r_mips_highest_rela(struct module *me, u32 *location,
+				     Elf_Addr v)
+{
+	*location = (*location & 0xffff0000) |
+	            ((((long long) v + 0x800080008000LL) >> 48) & 0xffff);
+
+	return 0;
+}
+
+static int (*reloc_handlers_rel[]) (struct module *me, u32 *location,
+				Elf_Addr v) = {
+	[R_MIPS_NONE]		= apply_r_mips_none,
+	[R_MIPS_32]		= apply_r_mips_32_rel,
+	[R_MIPS_26]		= apply_r_mips_26_rel,
+	[R_MIPS_HI16]		= apply_r_mips_hi16_rel,
+	[R_MIPS_LO16]		= apply_r_mips_lo16_rel
+};
+
+static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,
+				Elf_Addr v) = {
+	[R_MIPS_NONE]		= apply_r_mips_none,
+	[R_MIPS_32]		= apply_r_mips_32_rela,
+	[R_MIPS_26]		= apply_r_mips_26_rela,
+	[R_MIPS_HI16]		= apply_r_mips_hi16_rela,
+	[R_MIPS_LO16]		= apply_r_mips_lo16_rela,
+	[R_MIPS_64]		= apply_r_mips_64_rela,
+	[R_MIPS_HIGHER]		= apply_r_mips_higher_rela,
+	[R_MIPS_HIGHEST]	= apply_r_mips_highest_rela
+};
+
+int apply_relocate(Elf_Shdr *sechdrs, const char *strtab,
+		   unsigned int symindex, unsigned int relsec,
+		   struct module *me)
+{
+	Elf_Mips_Rel *rel = (void *) sechdrs[relsec].sh_addr;
+	Elf_Sym *sym;
+	u32 *location;
+	unsigned int i;
+	Elf_Addr v;
+	int res;
+
+	pr_debug("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to */
+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
+			+ ELF_MIPS_R_SYM(rel[i]);
+		if (!sym->st_value) {
+			printk(KERN_WARNING "%s: Unknown symbol %s\n",
+			       me->name, strtab + sym->st_name);
+			return -ENOENT;
+		}
+
+		v = sym->st_value;
+
+		res = reloc_handlers_rel[ELF_MIPS_R_TYPE(rel[i])](me, location, v);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
+int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,
+		       unsigned int symindex, unsigned int relsec,
+		       struct module *me)
+{
+	Elf_Mips_Rela *rel = (void *) sechdrs[relsec].sh_addr;
+	Elf_Sym *sym;
+	u32 *location;
+	unsigned int i;
+	Elf_Addr v;
+	int res;
+
+	pr_debug("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to */
+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr
+			+ ELF_MIPS_R_SYM(rel[i]);
+		if (!sym->st_value) {
+			printk(KERN_WARNING "%s: Unknown symbol %s\n",
+			       me->name, strtab + sym->st_name);
+			return -ENOENT;
+		}
+
+		v = sym->st_value + rel[i].r_addend;
+
+		res = reloc_handlers_rela[ELF_MIPS_R_TYPE(rel[i])](me, location, v);
+		if (res)
+			return res;
+	}
+
+	return 0;
+}
+
 /* Given an address, look for it in the module exception tables. */
 const struct exception_table_entry *search_module_dbetables(unsigned long addr)
 {
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/proc.c linux_HEAD/arch/mips/kernel/proc.c
--- linux-2.6.11.6/arch/mips/kernel/proc.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/proc.c	2005-03-01 15:00:12.000000000 +0100
@@ -19,63 +19,66 @@
 unsigned int vced_count, vcei_count;
 
 static const char *cpu_name[] = {
-	[CPU_UNKNOWN]	"unknown",
-	[CPU_R2000]	"R2000",
-	[CPU_R3000]	"R3000",
-	[CPU_R3000A]	"R3000A",
-	[CPU_R3041]	"R3041",
-	[CPU_R3051]	"R3051",
-	[CPU_R3052]	"R3052",
-	[CPU_R3081]	"R3081",
-	[CPU_R3081E]	"R3081E",
-	[CPU_R4000PC]	"R4000PC",
-	[CPU_R4000SC]	"R4000SC",
-	[CPU_R4000MC]	"R4000MC",
-        [CPU_R4200]	"R4200",
-	[CPU_R4400PC]	"R4400PC",
-	[CPU_R4400SC]	"R4400SC",
-	[CPU_R4400MC]	"R4400MC",
-	[CPU_R4600]	"R4600",
-	[CPU_R6000]	"R6000",
-        [CPU_R6000A]	"R6000A",
-	[CPU_R8000]	"R8000",
-	[CPU_R10000]	"R10000",
-	[CPU_R12000]	"R12000",
-	[CPU_R4300]	"R4300",
-	[CPU_R4650]	"R4650",
-	[CPU_R4700]	"R4700",
-	[CPU_R5000]	"R5000",
-        [CPU_R5000A]	"R5000A",
-	[CPU_R4640]	"R4640",
-	[CPU_NEVADA]	"Nevada",
-	[CPU_RM7000]	"RM7000",
-	[CPU_RM9000]	"RM9000",
-	[CPU_R5432]	"R5432",
-	[CPU_4KC]	"MIPS 4Kc",
-        [CPU_5KC]	"MIPS 5Kc",
-	[CPU_R4310]	"R4310",
-	[CPU_SB1]	"SiByte SB1",
-	[CPU_TX3912]	"TX3912",
-	[CPU_TX3922]	"TX3922",
-	[CPU_TX3927]	"TX3927",
-	[CPU_AU1000]	"Au1000",
-	[CPU_AU1500]	"Au1500",
-	[CPU_4KEC]	"MIPS 4KEc",
-	[CPU_4KSC]	"MIPS 4KSc",
-	[CPU_VR41XX]	"NEC Vr41xx",
-	[CPU_R5500]	"R5500",
-	[CPU_TX49XX]	"TX49xx",
-	[CPU_20KC]	"MIPS 20Kc",
-	[CPU_24K]	"MIPS 24K",
-	[CPU_25KF]	"MIPS 25Kf",
-	[CPU_VR4111]	"NEC VR4111",
-	[CPU_VR4121]	"NEC VR4121",
-	[CPU_VR4122]	"NEC VR4122",
-	[CPU_VR4131]	"NEC VR4131",
-	[CPU_VR4133]	"NEC VR4133",
-	[CPU_VR4181]	"NEC VR4181",
-	[CPU_VR4181A]	"NEC VR4181A",
-	[CPU_SR71000]	"Sandcraft SR71000"
+	[CPU_UNKNOWN]	= "unknown",
+	[CPU_R2000]	= "R2000",
+	[CPU_R3000]	= "R3000",
+	[CPU_R3000A]	= "R3000A",
+	[CPU_R3041]	= "R3041",
+	[CPU_R3051]	= "R3051",
+	[CPU_R3052]	= "R3052",
+	[CPU_R3081]	= "R3081",
+	[CPU_R3081E]	= "R3081E",
+	[CPU_R4000PC]	= "R4000PC",
+	[CPU_R4000SC]	= "R4000SC",
+	[CPU_R4000MC]	= "R4000MC",
+        [CPU_R4200]	= "R4200",
+	[CPU_R4400PC]	= "R4400PC",
+	[CPU_R4400SC]	= "R4400SC",
+	[CPU_R4400MC]	= "R4400MC",
+	[CPU_R4600]	= "R4600",
+	[CPU_R6000]	= "R6000",
+        [CPU_R6000A]	= "R6000A",
+	[CPU_R8000]	= "R8000",
+	[CPU_R10000]	= "R10000",
+	[CPU_R12000]	= "R12000",
+	[CPU_R4300]	= "R4300",
+	[CPU_R4650]	= "R4650",
+	[CPU_R4700]	= "R4700",
+	[CPU_R5000]	= "R5000",
+        [CPU_R5000A]	= "R5000A",
+	[CPU_R4640]	= "R4640",
+	[CPU_NEVADA]	= "Nevada",
+	[CPU_RM7000]	= "RM7000",
+	[CPU_RM9000]	= "RM9000",
+	[CPU_R5432]	= "R5432",
+	[CPU_4KC]	= "MIPS 4Kc",
+        [CPU_5KC]	= "MIPS 5Kc",
+	[CPU_R4310]	= "R4310",
+	[CPU_SB1]	= "SiByte SB1",
+	[CPU_TX3912]	= "TX3912",
+	[CPU_TX3922]	= "TX3922",
+	[CPU_TX3927]	= "TX3927",
+	[CPU_AU1000]	= "Au1000",
+	[CPU_AU1500]	= "Au1500",
+	[CPU_AU1100]	= "Au1100",
+	[CPU_AU1550]	= "Au1550",
+	[CPU_AU1200]	= "Au1200",
+	[CPU_4KEC]	= "MIPS 4KEc",
+	[CPU_4KSC]	= "MIPS 4KSc",
+	[CPU_VR41XX]	= "NEC Vr41xx",
+	[CPU_R5500]	= "R5500",
+	[CPU_TX49XX]	= "TX49xx",
+	[CPU_20KC]	= "MIPS 20Kc",
+	[CPU_24K]	= "MIPS 24K",
+	[CPU_25KF]	= "MIPS 25Kf",
+	[CPU_VR4111]	= "NEC VR4111",
+	[CPU_VR4121]	= "NEC VR4121",
+	[CPU_VR4122]	= "NEC VR4122",
+	[CPU_VR4131]	= "NEC VR4131",
+	[CPU_VR4133]	= "NEC VR4133",
+	[CPU_VR4181]	= "NEC VR4181",
+	[CPU_VR4181A]	= "NEC VR4181A",
+	[CPU_SR71000]	= "Sandcraft SR71000"
 };
 
 
@@ -105,8 +108,8 @@ static int show_cpuinfo(struct seq_file 
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
-	              loops_per_jiffy / (500000/HZ),
-	              (loops_per_jiffy / (5000/HZ)) % 100);
+	              cpu_data[n].udelay_val / (500000/HZ),
+	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 	              cpu_has_counter ? "yes" : "no");
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/process.c linux_HEAD/arch/mips/kernel/process.c
--- linux-2.6.11.6/arch/mips/kernel/process.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/process.c	2005-03-17 22:10:47.000000000 +0100
@@ -39,14 +39,6 @@
 #include <asm/inst.h>
 
 /*
- * We use this if we don't have any better idle routine..
- * (This to kill: kernel/platform.c.
- */
-void default_idle (void)
-{
-}
-
-/*
  * The idle thread. There's no useful work to be done, so just try to conserve
  * power and have a low exit latency (ie sit in a loop waiting for somebody to
  * say that they'd like to reschedule)
@@ -175,6 +167,14 @@ void dump_regs(elf_greg_t *gp, struct pt
 #endif
 }
 
+int dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
+{
+	struct thread_info *ti = tsk->thread_info;
+	long ksp = (unsigned long)ti + THREAD_SIZE - 32;
+	dump_regs(&(*regs)[0], (struct pt_regs *) ksp - 1);
+	return 1;
+}
+
 int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
 {
 	memcpy(fpr, &t->thread.fpu, sizeof(current->thread.fpu));
@@ -211,22 +211,48 @@ long kernel_thread(int (*fn)(void *), vo
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
-struct mips_frame_info {
+static struct mips_frame_info {
+	void *func;
+	int omit_fp;	/* compiled without fno-omit-frame-pointer */
 	int frame_offset;
 	int pc_offset;
+} schedule_frame, mfinfo[] = {
+	{ schedule, 0 },	/* must be first */
+	/* arch/mips/kernel/semaphore.c */
+	{ __down, 1 },
+	{ __down_interruptible, 1 },
+	/* kernel/sched.c */
+#ifdef CONFIG_PREEMPT
+	{ preempt_schedule, 0 },
+#endif
+	{ wait_for_completion, 0 },
+	{ interruptible_sleep_on, 0 },
+	{ interruptible_sleep_on_timeout, 0 },
+	{ sleep_on, 0 },
+	{ sleep_on_timeout, 0 },
+	{ yield, 0 },
+	{ io_schedule, 0 },
+	{ io_schedule_timeout, 0 },
+#if defined(CONFIG_SMP) && defined(CONFIG_PREEMPT)
+	{ __preempt_spin_lock, 0 },
+	{ __preempt_write_lock, 0 },
+#endif
+	/* kernel/timer.c */
+	{ schedule_timeout, 1 },
+/*	{ nanosleep_restart, 1 }, */
+	/* lib/rwsem-spinlock.c */
+	{ __down_read, 1 },
+	{ __down_write, 1 },
 };
-static struct mips_frame_info schedule_frame;
-static struct mips_frame_info schedule_timeout_frame;
-static struct mips_frame_info sleep_on_frame;
-static struct mips_frame_info sleep_on_timeout_frame;
-static struct mips_frame_info wait_for_completion_frame;
+
 static int mips_frame_info_initialized;
-static int __init get_frame_info(struct mips_frame_info *info, void *func)
+static int __init get_frame_info(struct mips_frame_info *info)
 {
 	int i;
+	void *func = info->func;
 	union mips_instruction *ip = (union mips_instruction *)func;
 	info->pc_offset = -1;
-	info->frame_offset = -1;
+	info->frame_offset = info->omit_fp ? 0 : -1;
 	for (i = 0; i < 128; i++, ip++) {
 		/* if jal, jalr, jr, stop. */
 		if (ip->j_format.opcode == jal_op ||
@@ -247,14 +273,16 @@ static int __init get_frame_info(struct 
 			/* sw / sd $ra, offset($sp) */
 			if (ip->i_format.rt == 31) {
 				if (info->pc_offset != -1)
-					break;
+					continue;
 				info->pc_offset =
 					ip->i_format.simmediate / sizeof(long);
 			}
 			/* sw / sd $s8, offset($sp) */
 			if (ip->i_format.rt == 30) {
+//#if 0	/* gcc 3.4 does aggressive optimization... */
 				if (info->frame_offset != -1)
-					break;
+					continue;
+//#endif
 				info->frame_offset =
 					ip->i_format.simmediate / sizeof(long);
 			}
@@ -272,13 +300,25 @@ static int __init get_frame_info(struct 
 
 static int __init frame_info_init(void)
 {
-	mips_frame_info_initialized =
-		!get_frame_info(&schedule_frame, schedule) &&
-		!get_frame_info(&schedule_timeout_frame, schedule_timeout) &&
-		!get_frame_info(&sleep_on_frame, sleep_on) &&
-		!get_frame_info(&sleep_on_timeout_frame, sleep_on_timeout) &&
-		!get_frame_info(&wait_for_completion_frame, wait_for_completion);
-
+	int i, found;
+	for (i = 0; i < ARRAY_SIZE(mfinfo); i++)
+		if (get_frame_info(&mfinfo[i]))
+			return -1;
+	schedule_frame = mfinfo[0];
+	/* bubble sort */
+	do {
+		struct mips_frame_info tmp;
+		found = 0;
+		for (i = 1; i < ARRAY_SIZE(mfinfo); i++) {
+			if (mfinfo[i-1].func > mfinfo[i].func) {
+				tmp = mfinfo[i];
+				mfinfo[i] = mfinfo[i-1];
+				mfinfo[i-1] = tmp;
+				found = 1;
+			}
+		}
+	} while (found);
+	mips_frame_info_initialized = 1;
 	return 0;
 }
 
@@ -311,53 +351,27 @@ unsigned long get_wchan(struct task_stru
 	if (!mips_frame_info_initialized)
 		return 0;
 	pc = thread_saved_pc(p);
+
 	if (!in_sched_functions(pc))
 		goto out;
 
-	if (pc >= (unsigned long) sleep_on_timeout)
-		goto schedule_timeout_caller;
-	if (pc >= (unsigned long) sleep_on)
-		goto schedule_caller;
-	if (pc >= (unsigned long) interruptible_sleep_on_timeout)
-		goto schedule_timeout_caller;
-	if (pc >= (unsigned long)interruptible_sleep_on)
-		goto schedule_caller;
-	if (pc >= (unsigned long)wait_for_completion)
-		goto schedule_caller;
-	goto schedule_timeout_caller;
-
-schedule_caller:
-	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
-	if (pc >= (unsigned long) sleep_on)
-		pc = ((unsigned long *)frame)[sleep_on_frame.pc_offset];
-	else
-		pc = ((unsigned long *)frame)[wait_for_completion_frame.pc_offset];
-	goto out;
-
-schedule_timeout_caller:
-	/*
-	 * The schedule_timeout frame
-	 */
 	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
+	do {
+		int i;
+		for (i = ARRAY_SIZE(mfinfo) - 1; i >= 0; i--) {
+			if (pc >= (unsigned long) mfinfo[i].func)
+				break;
+		}
+		if (i < 0)
+			break;
 
-	/*
-	 * frame now points to sleep_on_timeout's frame
-	 */
-	pc    = ((unsigned long *)frame)[schedule_timeout_frame.pc_offset];
-
-	if (in_sched_functions(pc)) {
-		/* schedule_timeout called by [interruptible_]sleep_on_timeout */
-		frame = ((unsigned long *)frame)[schedule_timeout_frame.frame_offset];
-		pc    = ((unsigned long *)frame)[sleep_on_timeout_frame.pc_offset];
-	}
+		if (mfinfo[i].omit_fp)
+			break;
+		pc = ((unsigned long *)frame)[mfinfo[i].pc_offset];
+		frame = ((unsigned long *)frame)[mfinfo[i].frame_offset];
+	} while (in_sched_functions(pc));
 
 out:
-
-#ifdef CONFIG_MIPS64
-	if (current->thread.mflags & MF_32BIT_REGS) /* Kludge for 32-bit ps  */
-		pc &= 0xffffffffUL;
-#endif
-
 	return pc;
 }
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/ptrace.c linux_HEAD/arch/mips/kernel/ptrace.c
--- linux-2.6.11.6/arch/mips/kernel/ptrace.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/kernel/ptrace.c	2005-03-21 20:03:46.000000000 +0100
@@ -103,7 +103,7 @@ asmlinkage int sys_ptrace(long request, 
 		ret = -EIO;
 		if (copied != sizeof(tmp))
 			break;
-		ret = put_user(tmp,(unsigned long *) data);
+		ret = put_user(tmp,(unsigned long __user *) data);
 		break;
 	}
 
@@ -180,7 +180,7 @@ asmlinkage int sys_ptrace(long request, 
 			ret = -EIO;
 			goto out_tsk;
 		}
-		ret = put_user(tmp, (unsigned long *) data);
+		ret = put_user(tmp, (unsigned long __user *) data);
 		break;
 	}
 
@@ -307,14 +307,20 @@ out:
  */
 asmlinkage void do_syscall_trace(struct pt_regs *regs, int entryexit)
 {
-	if (unlikely(current->audit_context)) {
+	/* There is no ->orig_eax and that's quite intensional for now making
+	   this work will require some work in various other place before it's
+	   more than a placebo.  */
+	/* do the secure computing check first */
+	/* secure_computing(regs->orig_eax); */
+
+	/* if (unlikely(current->audit_context)) {
 		if (!entryexit)
 			audit_syscall_entry(current, regs->orig_eax,
 			                    regs->regs[4], regs->regs[5],
 			                    regs->regs[6], regs->regs[7]);
 		else
 			audit_syscall_exit(current, regs->regs[2]);
-	}
+	} */
 
 	if (!test_thread_flag(TIF_SYSCALL_TRACE))
 		return;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/ptrace32.c linux_HEAD/arch/mips/kernel/ptrace32.c
--- linux-2.6.11.6/arch/mips/kernel/ptrace32.c	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/ptrace32.c	2005-02-17 21:48:55.000000000 +0100
@@ -272,6 +272,11 @@ asmlinkage int sys32_ptrace(int request,
 		ret = ptrace_detach(child, data);
 		break;
 
+	case PTRACE_GETEVENTMSG:
+		ret = put_user(child->ptrace_message,
+			       (unsigned int __user *) (unsigned long) data);
+		break;
+
 	default:
 		ret = ptrace_request(child, request, addr, data);
 		break;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/scall32-o32.S linux_HEAD/arch/mips/kernel/scall32-o32.S
--- linux-2.6.11.6/arch/mips/kernel/scall32-o32.S	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/scall32-o32.S	2005-03-13 00:27:29.000000000 +0100
@@ -578,7 +578,7 @@ einval:	li	v0, -EINVAL
 	sys	sys_fremovexattr	2	/* 4235 */
 	sys	sys_tkill		2
 	sys	sys_sendfile64		5
-	sys	sys_futex		2
+	sys	sys_futex		6
 	sys	sys_sched_setaffinity	3
 	sys	sys_sched_getaffinity	3	/* 4240 */
 	sys	sys_io_setup		2
@@ -618,7 +618,7 @@ einval:	li	v0, -EINVAL
 	sys	sys_mq_notify		2	/* 4275 */
 	sys	sys_mq_getsetattr	3
 	sys	sys_ni_syscall		0	/* sys_vserver */
-	sys	sys_waitid		4
+	sys	sys_waitid		5
 	sys	sys_ni_syscall		0	/* available, was setaltroot */
 	sys	sys_add_key		5
 	sys	sys_request_key		4
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/scall64-n32.S linux_HEAD/arch/mips/kernel/scall64-n32.S
--- linux-2.6.11.6/arch/mips/kernel/scall64-n32.S	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/scall64-n32.S	2005-02-17 21:48:55.000000000 +0100
@@ -176,7 +176,7 @@ EXPORT(sysn32_call_table)
 	PTR	sys_fork
 	PTR	sys32_execve
 	PTR	sys_exit
-	PTR	sys32_wait4
+	PTR	compat_sys_wait4
 	PTR	sys_kill			/* 6060 */
 	PTR	sys32_newuname
 	PTR	sys_semget
@@ -243,8 +243,8 @@ EXPORT(sysn32_call_table)
 	PTR	sys_capget
 	PTR	sys_capset
 	PTR	sys32_rt_sigpending		/* 6125 */
-	PTR	compat_sys_rt_sigtimedwait
-	PTR	sys32_rt_sigqueueinfo
+	PTR	sysn32_rt_sigtimedwait
+	PTR	sys_rt_sigqueueinfo
 	PTR	sys32_rt_sigsuspend
 	PTR	sys32_sigaltstack
 	PTR	compat_sys_utime		/* 6130 */
@@ -337,15 +337,15 @@ EXPORT(sysn32_call_table)
 	PTR	compat_sys_statfs64
 	PTR	compat_sys_fstatfs64
 	PTR	sys_sendfile64
-	PTR	sys_timer_create		/* 6220 */
-	PTR	sys_timer_settime
-	PTR	sys_timer_gettime
+	PTR	sys32_timer_create		/* 6220 */
+	PTR	compat_sys_timer_settime
+	PTR	compat_sys_timer_gettime
 	PTR	sys_timer_getoverrun
 	PTR	sys_timer_delete
-	PTR	sys_clock_settime		/* 6225 */
-	PTR	sys_clock_gettime
-	PTR	sys_clock_getres
-	PTR	sys_clock_nanosleep
+	PTR	compat_sys_clock_settime		/* 6225 */
+	PTR	compat_sys_clock_gettime
+	PTR	compat_sys_clock_getres
+	PTR	compat_sys_clock_nanosleep
 	PTR	sys_tgkill
 	PTR	compat_sys_utimes		/* 6230 */
 	PTR	sys_ni_syscall			/* sys_mbind */
@@ -358,7 +358,7 @@ EXPORT(sysn32_call_table)
 	PTR	compat_sys_mq_notify
 	PTR	compat_sys_mq_getsetattr
 	PTR	sys_ni_syscall			/* 6240, sys_vserver */
-	PTR	sys_waitid
+	PTR	sysn32_waitid
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key
 	PTR	sys_request_key
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/scall64-o32.S linux_HEAD/arch/mips/kernel/scall64-o32.S
--- linux-2.6.11.6/arch/mips/kernel/scall64-o32.S	2005-03-26 04:28:13.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/scall64-o32.S	2005-02-17 21:48:55.000000000 +0100
@@ -316,7 +316,7 @@ sys_call_table:
 	PTR	sys_vhangup
 	PTR	sys_ni_syscall			/* was sys_idle	 */
 	PTR	sys_ni_syscall			/* sys_vm86 */
-	PTR	sys32_wait4
+	PTR	compat_sys_wait4
 	PTR	sys_swapoff			/* 4115 */
 	PTR	sys32_sysinfo
 	PTR	sys32_ipc
@@ -459,7 +459,7 @@ sys_call_table:
 	PTR	sys_fadvise64_64
 	PTR	compat_sys_statfs64		/* 4255 */
 	PTR	compat_sys_fstatfs64
-	PTR	sys_timer_create
+	PTR	sys32_timer_create
 	PTR	compat_sys_timer_settime
 	PTR	compat_sys_timer_gettime
 	PTR	sys_timer_getoverrun		/* 4260 */
@@ -480,7 +480,7 @@ sys_call_table:
 	PTR	compat_sys_mq_notify		/* 4275 */
 	PTR	compat_sys_mq_getsetattr
 	PTR	sys_ni_syscall			/* sys_vserver */
-	PTR	sys_waitid
+	PTR	sys32_waitid
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key			/* 4280 */
 	PTR	sys_request_key
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/signal-common.h linux_HEAD/arch/mips/kernel/signal-common.h
--- linux-2.6.11.6/arch/mips/kernel/signal-common.h	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/signal-common.h	2005-02-17 21:48:55.000000000 +0100
@@ -61,8 +61,8 @@ out:
 static inline int
 restore_sigcontext(struct pt_regs *regs, struct sigcontext *sc)
 {
-	int err = 0;
 	unsigned int used_math;
+	int err = 0;
 
 	/* Always make any pending restarted system calls return -EINTR */
 	current_thread_info()->restart_block.fn = do_no_restart_syscall;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/signal.c linux_HEAD/arch/mips/kernel/signal.c
--- linux-2.6.11.6/arch/mips/kernel/signal.c	2005-03-26 04:28:47.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/signal.c	2005-03-01 22:49:39.000000000 +0100
@@ -47,9 +47,10 @@ save_static_function(sys_sigsuspend);
 __attribute_used__ noinline static int
 _sys_sigsuspend(nabi_no_regargs struct pt_regs regs)
 {
-	sigset_t *uset, saveset, newset;
+	sigset_t saveset, newset;
+	sigset_t __user *uset;
 
-	uset = (sigset_t *) regs.regs[4];
+	uset = (sigset_t __user *) regs.regs[4];
 	if (copy_from_user(&newset, uset, sizeof(sigset_t)))
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
@@ -75,7 +76,8 @@ save_static_function(sys_rt_sigsuspend);
 __attribute_used__ noinline static int
 _sys_rt_sigsuspend(nabi_no_regargs struct pt_regs regs)
 {
-	sigset_t *unewset, saveset, newset;
+	sigset_t saveset, newset;
+	sigset_t __user *unewset;
 	size_t sigsetsize;
 
 	/* XXX Don't preclude handling different sized sigset_t's.  */
@@ -83,7 +85,7 @@ _sys_rt_sigsuspend(nabi_no_regargs struc
 	if (sigsetsize != sizeof(sigset_t))
 		return -EINVAL;
 
-	unewset = (sigset_t *) regs.regs[4];
+	unewset = (sigset_t __user *) regs.regs[4];
 	if (copy_from_user(&newset, unewset, sizeof(newset)))
 		return -EFAULT;
 	sigdelsetmask(&newset, ~_BLOCKABLE);
@@ -147,8 +149,8 @@ asmlinkage int sys_sigaction(int sig, co
 
 asmlinkage int sys_sigaltstack(nabi_no_regargs struct pt_regs regs)
 {
-	const stack_t *uss = (const stack_t *) regs.regs[4];
-	stack_t *uoss = (stack_t *) regs.regs[5];
+	const stack_t __user *uss = (const stack_t __user *) regs.regs[4];
+	stack_t __user *uoss = (stack_t __user *) regs.regs[5];
 	unsigned long usp = regs.regs[29];
 
 	return do_sigaltstack(uss, uoss, usp);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/signal32.c linux_HEAD/arch/mips/kernel/signal32.c
--- linux-2.6.11.6/arch/mips/kernel/signal32.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/kernel/signal32.c	2005-03-21 20:03:46.000000000 +0100
@@ -76,8 +76,10 @@ typedef struct compat_siginfo {
 
 		/* POSIX.1b timers */
 		struct {
-			unsigned int _timer1;
-			unsigned int _timer2;
+			timer_t _tid;		/* timer id */
+			int _overrun;		/* overrun count */
+			compat_sigval_t _sigval;/* same as below */
+			int _sys_private;       /* not to be passed to user */
 		} _timer;
 
 		/* POSIX.1b signals */
@@ -259,11 +261,12 @@ asmlinkage int sys32_sigaction(int sig, 
 
 	if (act) {
 		old_sigset_t mask;
+		s32 handler;
 
 		if (!access_ok(VERIFY_READ, act, sizeof(*act)))
 			return -EFAULT;
-		err |= __get_user((u32)(u64)new_ka.sa.sa_handler,
-		                  &act->sa_handler);
+		err |= __get_user(handler, &act->sa_handler);
+		new_ka.sa.sa_handler = (void*)(s64)handler;
 		err |= __get_user(new_ka.sa.sa_flags, &act->sa_flags);
 		err |= __get_user(mask, &act->sa_mask.sig[0]);
 		if (err)
@@ -411,6 +414,11 @@ int copy_siginfo_to_user32(compat_siginf
 		err |= __copy_to_user(&to->_sifields._pad, &from->_sifields._pad, SI_PAD_SIZE);
 	else {
 		switch (from->si_code >> 16) {
+		case __SI_TIMER >> 16:
+			err |= __put_user(from->si_tid, &to->si_tid);
+			err |= __put_user(from->si_overrun, &to->si_overrun);
+			err |= __put_user(from->si_int, &to->si_int);
+			break;
 		case __SI_CHLD >> 16:
 			err |= __put_user(from->si_utime, &to->si_utime);
 			err |= __put_user(from->si_stime, &to->si_stime);
@@ -820,12 +828,13 @@ asmlinkage int sys32_rt_sigaction(int si
 		goto out;
 
 	if (act) {
+		s32 handler;
 		int err = 0;
 
 		if (!access_ok(VERIFY_READ, act, sizeof(*act)))
 			return -EFAULT;
-		err |= __get_user((u32)(u64)new_sa.sa.sa_handler,
-		                  &act->sa_handler);
+		err |= __get_user(handler, &act->sa_handler);
+		new_sa.sa.sa_handler = (void*)(s64)handler;
 		err |= __get_user(new_sa.sa.sa_flags, &act->sa_flags);
 		err |= get_sigset(&new_sa.sa.sa_mask, &act->sa_mask);
 		if (err)
@@ -903,3 +912,30 @@ asmlinkage int sys32_rt_sigqueueinfo(int
 	set_fs (old_fs);
 	return ret;
 }
+
+asmlinkage long
+sys32_waitid(int which, compat_pid_t pid,
+	     compat_siginfo_t __user *uinfo, int options,
+	     struct compat_rusage __user *uru)
+{
+	siginfo_t info;
+	struct rusage ru;
+	long ret;
+	mm_segment_t old_fs = get_fs();
+
+	info.si_signo = 0;
+	set_fs (KERNEL_DS);
+	ret = sys_waitid(which, pid, (siginfo_t __user *) &info, options,
+			 uru ? (struct rusage __user *) &ru : NULL);
+	set_fs (old_fs);
+
+	if (ret < 0 || info.si_signo == 0)
+		return ret;
+
+	if (uru && (ret = put_compat_rusage(&ru, uru)))
+		return ret;
+
+	BUG_ON(info.si_code & __SI_MASK);
+	info.si_code |= __SI_CHLD;
+	return copy_siginfo_to_user32(uinfo, &info);
+}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/smp.c linux_HEAD/arch/mips/kernel/smp.c
--- linux-2.6.11.6/arch/mips/kernel/smp.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/kernel/smp.c	2005-03-21 20:03:46.000000000 +0100
@@ -121,7 +121,19 @@ struct call_data_struct *call_data;
  * or are or have executed.
  *
  * You must not call this function with disabled interrupts or from a
- * hardware interrupt handler or from a bottom half handler.
+ * hardware interrupt handler or from a bottom half handler:
+ *
+ * CPU A                               CPU B
+ * Disable interrupts
+ *                                     smp_call_function()
+ *                                     Take call_lock
+ *                                     Send IPIs
+ *                                     Wait for all cpus to acknowledge IPI
+ *                                     CPU A has not responded, spin waiting
+ *                                     for cpu A to respond, holding call_lock
+ * smp_call_function()
+ * Spin waiting for call_lock
+ * Deadlock                            Deadlock
  */
 int smp_call_function (void (*func) (void *info), void *info, int retry,
 								int wait)
@@ -236,23 +248,28 @@ void __devinit smp_prepare_boot_cpu(void
 }
 
 /*
- * Startup the CPU with this logical number
+ * Called once for each "cpu_possible(cpu)".  Needs to spin up the cpu
+ * and keep control until "cpu_online(cpu)" is set.  Note: cpu is
+ * physical, not logical.
  */
-static int __init do_boot_cpu(int cpu)
+int __devinit __cpu_up(unsigned int cpu)
 {
 	struct task_struct *idle;
 
 	/*
+	 * Processor goes to start_secondary(), sets online flag
 	 * The following code is purely to make sure
 	 * Linux can schedule processes on this slave.
 	 */
 	idle = fork_idle(cpu);
 	if (IS_ERR(idle))
-		panic("failed fork for CPU %d\n", cpu);
+		panic(KERN_ERR "Fork failed for CPU %d\n", cpu);
 
 	prom_boot_secondary(cpu, idle);
 
-	/* XXXKW timeout */
+	/*
+	 * Trust is futile.  We should really have timeouts ...
+	 */
 	while (!cpu_isset(cpu, cpu_callin_map))
 		udelay(100);
 
@@ -261,23 +278,6 @@ static int __init do_boot_cpu(int cpu)
 	return 0;
 }
 
-/*
- * Called once for each "cpu_possible(cpu)".  Needs to spin up the cpu
- * and keep control until "cpu_online(cpu)" is set.  Note: cpu is
- * physical, not logical.
- */
-int __devinit __cpu_up(unsigned int cpu)
-{
-	int ret;
-
-	/* Processor goes to start_secondary(), sets online flag */
-	ret = do_boot_cpu(cpu);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
 /* Not really SMP stuff ... */
 int setup_profiling_timer(unsigned int multiplier)
 {
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/syscall.c linux_HEAD/arch/mips/kernel/syscall.c
--- linux-2.6.11.6/arch/mips/kernel/syscall.c	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/syscall.c	2005-03-28 22:55:50.000000000 +0200
@@ -26,6 +26,7 @@
 #include <linux/msg.h>
 #include <linux/shm.h>
 #include <linux/compiler.h>
+#include <linux/module.h>
 
 #include <asm/branch.h>
 #include <asm/cachectl.h>
@@ -56,6 +57,8 @@ out:
 
 unsigned long shm_align_mask = PAGE_SIZE - 1;	/* Sane caches */
 
+EXPORT_SYMBOL(shm_align_mask);
+
 #define COLOUR_ALIGN(addr,pgoff)				\
 	((((addr) + shm_align_mask) & ~shm_align_mask) +	\
 	 (((pgoff) << PAGE_SHIFT) & shm_align_mask))
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/traps.c linux_HEAD/arch/mips/kernel/traps.c
--- linux-2.6.11.6/arch/mips/kernel/traps.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/traps.c	2005-03-01 22:49:39.000000000 +0100
@@ -339,9 +339,9 @@ asmlinkage void do_be(struct pt_regs *re
 
 static inline int get_insn_opcode(struct pt_regs *regs, unsigned int *opcode)
 {
-	unsigned int *epc;
+	unsigned int __user *epc;
 
-	epc = (unsigned int *) regs->cp0_epc +
+	epc = (unsigned int __user *) regs->cp0_epc +
 	      ((regs->cp0_cause & CAUSEF_BD) != 0);
 	if (!get_user(*opcode, epc))
 		return 0;
@@ -371,7 +371,7 @@ static struct task_struct *ll_task = NUL
 
 static inline void simulate_ll(struct pt_regs *regs, unsigned int opcode)
 {
-	unsigned long value, *vaddr;
+	unsigned long value, __user *vaddr;
 	long offset;
 	int signal = 0;
 
@@ -385,7 +385,8 @@ static inline void simulate_ll(struct pt
 	offset <<= 16;
 	offset >>= 16;
 
-	vaddr = (unsigned long *)((long)(regs->regs[(opcode & BASE) >> 21]) + offset);
+	vaddr = (unsigned long __user *)
+	        ((unsigned long)(regs->regs[(opcode & BASE) >> 21]) + offset);
 
 	if ((unsigned long)vaddr & 3) {
 		signal = SIGBUS;
@@ -418,7 +419,8 @@ sig:
 
 static inline void simulate_sc(struct pt_regs *regs, unsigned int opcode)
 {
-	unsigned long *vaddr, reg;
+	unsigned long __user *vaddr;
+	unsigned long reg;
 	long offset;
 	int signal = 0;
 
@@ -432,7 +434,8 @@ static inline void simulate_sc(struct pt
 	offset <<= 16;
 	offset >>= 16;
 
-	vaddr = (unsigned long *)((long)(regs->regs[(opcode & BASE) >> 21]) + offset);
+	vaddr = (unsigned long __user *)
+	        ((unsigned long)(regs->regs[(opcode & BASE) >> 21]) + offset);
 	reg = (opcode & RT) >> 16;
 
 	if ((unsigned long)vaddr & 3) {
@@ -498,7 +501,7 @@ asmlinkage void do_ov(struct pt_regs *re
 	info.si_code = FPE_INTOVF;
 	info.si_signo = SIGFPE;
 	info.si_errno = 0;
-	info.si_addr = (void *)regs->cp0_epc;
+	info.si_addr = (void __user *) regs->cp0_epc;
 	force_sig_info(SIGFPE, &info, current);
 }
 
@@ -584,7 +587,7 @@ asmlinkage void do_bp(struct pt_regs *re
 			info.si_code = FPE_INTOVF;
 		info.si_signo = SIGFPE;
 		info.si_errno = 0;
-		info.si_addr = (void *)regs->cp0_epc;
+		info.si_addr = (void __user *) regs->cp0_epc;
 		force_sig_info(SIGFPE, &info, current);
 		break;
 	default:
@@ -621,7 +624,7 @@ asmlinkage void do_tr(struct pt_regs *re
 			info.si_code = FPE_INTOVF;
 		info.si_signo = SIGFPE;
 		info.si_errno = 0;
-		info.si_addr = (void *)regs->cp0_epc;
+		info.si_addr = (void __user *) regs->cp0_epc;
 		force_sig_info(SIGFPE, &info, current);
 		break;
 	default:
@@ -736,16 +739,12 @@ static inline void parity_protection_ini
 {
 	switch (current_cpu_data.cputype) {
 	case CPU_24K:
-		/* 24K cache parity not currently implemented in FPGA */
-		printk(KERN_INFO "Disable cache parity protection for "
-		       "MIPS 24K CPU.\n");
-		write_c0_ecc(read_c0_ecc() & ~0x80000000);
-		break;
 	case CPU_5KC:
-		/* Set the PE bit (bit 31) in the c0_ecc register. */
-		printk(KERN_INFO "Enable cache parity protection for "
-		       "MIPS 5KC/24K CPUs.\n");
-		write_c0_ecc(read_c0_ecc() | 0x80000000);
+		write_c0_ecc(0x80000000);
+		back_to_back_c0_hazard();
+		/* Set the PE bit (bit 31) in the c0_errctl register. */
+		printk(KERN_INFO "Cache parity protection %sabled\n",
+		       (read_c0_ecc() & 0x80000000) ? "en" : "dis");
 		break;
 	case CPU_20KC:
 	case CPU_25KF:
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/unaligned.c linux_HEAD/arch/mips/kernel/unaligned.c
--- linux-2.6.11.6/arch/mips/kernel/unaligned.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/kernel/unaligned.c	2005-03-17 22:20:26.000000000 +0100
@@ -94,7 +94,7 @@ unsigned long unaligned_instructions;
 #endif
 
 static inline int emulate_load_store_insn(struct pt_regs *regs,
-	void *addr, unsigned long pc,
+	void __user *addr, unsigned int __user *pc,
 	unsigned long **regptr, unsigned long *newvalue)
 {
 	union mips_instruction insn;
@@ -107,7 +107,7 @@ static inline int emulate_load_store_ins
 	/*
 	 * This load never faults.
 	 */
-	__get_user(insn.word, (unsigned int *)pc);
+	__get_user(insn.word, pc);
 
 	switch (insn.i_format.opcode) {
 	/*
@@ -494,8 +494,8 @@ asmlinkage void do_ade(struct pt_regs *r
 {
 	unsigned long *regptr, newval;
 	extern int do_dsemulret(struct pt_regs *);
+	unsigned int __user *pc;
 	mm_segment_t seg;
-	unsigned long pc;
 
 	/*
 	 * Address errors may be deliberately induced by the FPU emulator to
@@ -515,7 +515,7 @@ asmlinkage void do_ade(struct pt_regs *r
 	if ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))
 		goto sigbus;
 
-	pc = exception_epc(regs);
+	pc = (unsigned int __user *) exception_epc(regs);
 	if ((current->thread.mflags & MF_FIXADE) == 0)
 		goto sigbus;
 
@@ -526,7 +526,7 @@ asmlinkage void do_ade(struct pt_regs *r
 	seg = get_fs();
 	if (!user_mode(regs))
 		set_fs(KERNEL_DS);
-	if (!emulate_load_store_insn(regs, (void *)regs->cp0_badvaddr, pc,
+	if (!emulate_load_store_insn(regs, (void __user *)regs->cp0_badvaddr, pc,
 	                             &regptr, &newval)) {
 		compute_return_epc(regs);
 		/*
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/kernel/vmlinux.lds.S linux_HEAD/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.11.6/arch/mips/kernel/vmlinux.lds.S	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/kernel/vmlinux.lds.S	2005-03-17 22:10:47.000000000 +0100
@@ -54,13 +54,6 @@ SECTIONS
 
     *(.data)
 
-   /* Align the initial ramdisk image (INITRD) on page boundaries. */
-   . = ALIGN(4096);
-   __rd_start = .;
-   *(.initrd)
-   . = ALIGN(4096);
-   __rd_end = .;
-
     CONSTRUCTORS
   }
   _gp = . + 0x8000;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lasat/Kconfig linux_HEAD/arch/mips/lasat/Kconfig
--- linux-2.6.11.6/arch/mips/lasat/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/lasat/Kconfig	2005-01-30 21:45:37.000000000 +0100
@@ -0,0 +1,15 @@
+config PICVUE
+	tristate "PICVUE LCD display driver"
+	depends on LASAT
+
+config PICVUE_PROC
+	tristate "PICVUE LCD display driver /proc interface"
+	depends on PICVUE
+
+config DS1603
+	bool "DS1603 RTC driver"
+	depends on LASAT
+
+config LASAT_SYSCTL
+	bool "LASAT sysctl interface"
+	depends on LASAT
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lasat/interrupt.c linux_HEAD/arch/mips/lasat/interrupt.c
--- linux-2.6.11.6/arch/mips/lasat/interrupt.c	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/lasat/interrupt.c	2005-02-28 16:56:42.000000000 +0100
@@ -71,14 +71,13 @@ static void end_lasat_irq(unsigned int i
 }
 
 static struct hw_interrupt_type lasat_irq_type = {
-	"Lasat",
-	startup_lasat_irq,
-	shutdown_lasat_irq,
-	enable_lasat_irq,
-	disable_lasat_irq,
-	mask_and_ack_lasat_irq,
-	end_lasat_irq,
-	NULL
+	.typename = "Lasat",
+	.startup = startup_lasat_irq,
+	.shutdown = shutdown_lasat_irq,
+	.enable = enable_lasat_irq,
+	.disable = disable_lasat_irq,
+	.ack = mask_and_ack_lasat_irq,
+	.end = end_lasat_irq,
 };
 
 static inline int ls1bit32(unsigned int x)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lib/Makefile linux_HEAD/arch/mips/lib/Makefile
--- linux-2.6.11.6/arch/mips/lib/Makefile	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/lib/Makefile	2004-01-03 22:33:17.000000000 +0100
@@ -2,7 +2,7 @@
 # Makefile for MIPS-specific library files..
 #
 
-lib-y	+= csum_partial_copy.o dec_and_lock.o iomap.o memcpy.o promlib.o \
-	   strlen_user.o strncpy_user.o strnlen_user.o
+lib-y	+= csum_partial_copy.o dec_and_lock.o memcpy.o promlib.o strlen_user.o \
+	   strncpy_user.o strnlen_user.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lib/csum_partial_copy.c linux_HEAD/arch/mips/lib/csum_partial_copy.c
--- linux-2.6.11.6/arch/mips/lib/csum_partial_copy.c	2005-03-26 04:28:39.000000000 +0100
+++ linux_HEAD/arch/mips/lib/csum_partial_copy.c	2005-02-17 21:48:56.000000000 +0100
@@ -16,8 +16,8 @@
 /*
  * copy while checksumming, otherwise like csum_partial
  */
-unsigned int csum_partial_copy_nocheck(const unsigned char *src, unsigned char *dst,
-	int len, unsigned int sum)
+unsigned int csum_partial_copy_nocheck(const unsigned char *src,
+	unsigned char *dst, int len, unsigned int sum)
 {
 	/*
 	 * It's 2:30 am and I don't feel like doing it real ...
@@ -33,8 +33,8 @@ unsigned int csum_partial_copy_nocheck(c
  * Copy from userspace and compute checksum.  If we catch an exception
  * then zero the rest of the buffer.
  */
-unsigned int csum_partial_copy_from_user (const unsigned char *src, unsigned char *dst,
-	int len, unsigned int sum, int *err_ptr)
+unsigned int csum_partial_copy_from_user (const unsigned char *src,
+	unsigned char *dst, int len, unsigned int sum, int *err_ptr)
 {
 	int missing;
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lib/iomap.c linux_HEAD/arch/mips/lib/iomap.c
--- linux-2.6.11.6/arch/mips/lib/iomap.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/lib/iomap.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-/*
- *  iomap.c, Memory Mapped I/O routines for MIPS architecture.
- *
- *  This code is based on lib/iomap.c, by Linus Torvalds.
- *
- *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-
-#include <asm/io.h>
-
-void __iomem *ioport_map(unsigned long port, unsigned int nr)
-{
-	unsigned long end;
-
-	end = port + nr - 1UL;
-	if (ioport_resource.start > port ||
-	    ioport_resource.end < end || port > end)
-		return NULL;
-
-	return (void __iomem *)(mips_io_port_base + port);
-}
-
-void ioport_unmap(void __iomem *addr)
-{
-}
-EXPORT_SYMBOL(ioport_map);
-EXPORT_SYMBOL(ioport_unmap);
-
-void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long maxlen)
-{
-	unsigned long start, len, flags;
-
-	if (dev == NULL)
-		return NULL;
-
-	start = pci_resource_start(dev, bar);
-	len = pci_resource_len(dev, bar);
-	if (!start || !len)
-		return NULL;
-
-	if (maxlen != 0 && len > maxlen)
-		len = maxlen;
-
-	flags = pci_resource_flags(dev, bar);
-	if (flags & IORESOURCE_IO)
-		return ioport_map(start, len);
-	if (flags & IORESOURCE_MEM) {
-		if (flags & IORESOURCE_CACHEABLE)
-			return ioremap_cacheable_cow(start, len);
-		return ioremap_nocache(start, len);
-	}
-
-	return NULL;
-}
-
-void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
-{
-	iounmap(addr);
-}
-EXPORT_SYMBOL(pci_iomap);
-EXPORT_SYMBOL(pci_iounmap);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lib-32/dump_tlb.c linux_HEAD/arch/mips/lib-32/dump_tlb.c
--- linux-2.6.11.6/arch/mips/lib-32/dump_tlb.c	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/lib-32/dump_tlb.c	2005-02-17 21:48:56.000000000 +0100
@@ -32,8 +32,6 @@ static inline const char *msk2str(unsign
 	case PM_256M:	return "256Mb";
 #endif
 	}
-
-	return "unknown";
 }
 
 #define BARRIER()					\
@@ -139,6 +137,7 @@ void dump_tlb_nonwired(void)
 void dump_list_process(struct task_struct *t, void *address)
 {
 	pgd_t	*page_dir, *pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte, page;
 	unsigned long addr, val;
@@ -162,7 +161,10 @@ void dump_list_process(struct task_struc
 		pgd = pgd_offset(t->mm, addr);
 	printk("pgd == %08x, ", (unsigned int) pgd);
 
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	printk("pud == %08x, ", (unsigned int) pud);
+
+	pmd = pmd_offset(pud, addr);
 	printk("pmd == %08x, ", (unsigned int) pmd);
 
 	pte = pte_offset(pmd, addr);
@@ -195,13 +197,15 @@ void dump_list_current(void *address)
 unsigned int vtop(void *address)
 {
 	pgd_t	*pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte;
 	unsigned int addr, paddr;
 
 	addr = (unsigned long) address;
 	pgd = pgd_offset(current->mm, addr);
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	pmd = pmd_offset(pud, addr);
 	pte = pte_offset(pmd, addr);
 	paddr = (KSEG1 | (unsigned int) pte_val(*pte)) & PAGE_MASK;
 	paddr |= (addr & ~PAGE_MASK);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lib-32/r3k_dump_tlb.c linux_HEAD/arch/mips/lib-32/r3k_dump_tlb.c
--- linux-2.6.11.6/arch/mips/lib-32/r3k_dump_tlb.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/lib-32/r3k_dump_tlb.c	2005-02-17 21:48:56.000000000 +0100
@@ -105,6 +105,7 @@ void dump_tlb_nonwired(void)
 void dump_list_process(struct task_struct *t, void *address)
 {
 	pgd_t	*page_dir, *pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte, page;
 	unsigned int addr;
@@ -121,7 +122,10 @@ void dump_list_process(struct task_struc
 	pgd = pgd_offset(t->mm, addr);
 	printk("pgd == %08x, ", (unsigned int) pgd);
 
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	printk("pud == %08x, ", (unsigned int) pud);
+
+	pmd = pmd_offset(pud, addr);
 	printk("pmd == %08x, ", (unsigned int) pmd);
 
 	pte = pte_offset(pmd, addr);
@@ -149,13 +153,15 @@ void dump_list_current(void *address)
 unsigned int vtop(void *address)
 {
 	pgd_t	*pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte;
 	unsigned int addr, paddr;
 
 	addr = (unsigned long) address;
 	pgd = pgd_offset(current->mm, addr);
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	pmd = pmd_offset(pud, addr);
 	pte = pte_offset(pmd, addr);
 	paddr = (KSEG1 | (unsigned int) pte_val(*pte)) & PAGE_MASK;
 	paddr |= (addr & ~PAGE_MASK);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/lib-64/dump_tlb.c linux_HEAD/arch/mips/lib-64/dump_tlb.c
--- linux-2.6.11.6/arch/mips/lib-64/dump_tlb.c	2005-03-26 04:28:47.000000000 +0100
+++ linux_HEAD/arch/mips/lib-64/dump_tlb.c	2005-02-17 21:48:56.000000000 +0100
@@ -32,8 +32,6 @@ static inline const char *msk2str(unsign
 	case PM_256M:	return "256Mb";
 #endif
 	}
-
-	return "unknown";
 }
 
 #define BARRIER()					\
@@ -140,6 +138,7 @@ void dump_tlb_nonwired(void)
 void dump_list_process(struct task_struct *t, void *address)
 {
 	pgd_t	*page_dir, *pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte, page;
 	unsigned long addr, val;
@@ -155,7 +154,10 @@ void dump_list_process(struct task_struc
 	pgd = pgd_offset(t->mm, addr);
 	printk("pgd == %016lx\n", (unsigned long) pgd);
 
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	printk("pud == %016lx\n", (unsigned long) pud);
+
+	pmd = pmd_offset(pud, addr);
 	printk("pmd == %016lx\n", (unsigned long) pmd);
 
 	pte = pte_offset(pmd, addr);
@@ -184,13 +186,15 @@ void dump_list_current(void *address)
 unsigned int vtop(void *address)
 {
 	pgd_t	*pgd;
+	pud_t	*pud;
 	pmd_t	*pmd;
 	pte_t	*pte;
 	unsigned int addr, paddr;
 
 	addr = (unsigned long) address;
 	pgd = pgd_offset(current->mm, addr);
-	pmd = pmd_offset(pgd, addr);
+	pud = pud_offset(pgd, addr);
+	pmd = pmd_offset(pud, addr);
 	pte = pte_offset(pmd, addr);
 	paddr = (CKSEG1 | (unsigned int) pte_val(*pte)) & PAGE_MASK;
 	paddr |= (addr & ~PAGE_MASK);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/math-emu/cp1emu.c linux_HEAD/arch/mips/math-emu/cp1emu.c
--- linux-2.6.11.6/arch/mips/math-emu/cp1emu.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/math-emu/cp1emu.c	2005-02-28 22:37:28.000000000 +0100
@@ -196,7 +196,7 @@ static int isBranchInstr(mips_instructio
 static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_soft_struct *ctx)
 {
 	mips_instruction ir;
-	vaddr_t emulpc, contpc;
+	void * emulpc, *contpc;
 	unsigned int cond;
 
 	if (get_user(ir, (mips_instruction *) xcp->cp0_epc)) {
@@ -221,12 +221,12 @@ static int cop1Emulate(struct pt_regs *x
 		 * Linux MIPS branch emulator operates on context, updating the
 		 * cp0_epc.
 		 */
-		emulpc = REG_TO_VA(xcp->cp0_epc + 4);	/* Snapshot emulation target */
+		emulpc = (void *) (xcp->cp0_epc + 4);	/* Snapshot emulation target */
 
 		if (__compute_return_epc(xcp)) {
 #ifdef CP1DBG
 			printk("failed to emulate branch at %p\n",
-				REG_TO_VA(xcp->cp0_epc));
+				(void *) (xcp->cp0_epc));
 #endif
 			return SIGILL;
 		}
@@ -235,13 +235,12 @@ static int cop1Emulate(struct pt_regs *x
 			return SIGBUS;
 		}
 		/* __compute_return_epc() will have updated cp0_epc */
-		contpc = REG_TO_VA xcp->cp0_epc;
+		contpc = (void *)  xcp->cp0_epc;
 		/* In order not to confuse ptrace() et al, tweak context */
-		xcp->cp0_epc = VA_TO_REG emulpc - 4;
-	}
-	else {
-		emulpc = REG_TO_VA xcp->cp0_epc;
-		contpc = REG_TO_VA(xcp->cp0_epc + 4);
+		xcp->cp0_epc = (unsigned long) emulpc - 4;
+	} else {
+		emulpc = (void *)  xcp->cp0_epc;
+		contpc = (void *) (xcp->cp0_epc + 4);
 	}
 
       emul:
@@ -249,7 +248,7 @@ static int cop1Emulate(struct pt_regs *x
 	switch (MIPSInst_OPCODE(ir)) {
 #ifndef SINGLE_ONLY_FPU
 	case ldc1_op:{
-		u64 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u64 *va = (void *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u64 val;
 
@@ -263,7 +262,7 @@ static int cop1Emulate(struct pt_regs *x
 	}
 
 	case sdc1_op:{
-		u64 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u64 *va = (void *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u64 val;
 
@@ -278,7 +277,7 @@ static int cop1Emulate(struct pt_regs *x
 #endif
 
 	case lwc1_op:{
-		u32 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u32 *va = (void *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u32 val;
 
@@ -298,7 +297,7 @@ static int cop1Emulate(struct pt_regs *x
 	}
 
 	case swc1_op:{
-		u32 *va = REG_TO_VA(xcp->regs[MIPSInst_RS(ir)] +
+		u32 *va = (void *) (xcp->regs[MIPSInst_RS(ir)] +
 			MIPSInst_SIMM(ir));
 		u32 val;
 
@@ -371,7 +370,7 @@ static int cop1Emulate(struct pt_regs *x
 				value = ctx->fcr31;
 #ifdef CSRTRACE
 				printk("%p gpr[%d]<-csr=%08x\n",
-					REG_TO_VA(xcp->cp0_epc),
+					(void *) (xcp->cp0_epc),
 					MIPSInst_RT(ir), value);
 #endif
 			}
@@ -398,7 +397,7 @@ static int cop1Emulate(struct pt_regs *x
 			if (MIPSInst_RD(ir) == FPCREG_CSR) {
 #ifdef CSRTRACE
 				printk("%p gpr[%d]->csr=%08x\n",
-					REG_TO_VA(xcp->cp0_epc),
+					(void *) (xcp->cp0_epc),
 					MIPSInst_RT(ir), value);
 #endif
 				ctx->fcr31 = value;
@@ -445,12 +444,12 @@ static int cop1Emulate(struct pt_regs *x
 				 * instruction
 				 */
 				xcp->cp0_epc += 4;
-				contpc = REG_TO_VA
+				contpc = (void *) 
 					(xcp->cp0_epc +
 					(MIPSInst_SIMM(ir) << 2));
 
 				if (get_user(ir, (mips_instruction *)
-						REG_TO_VA xcp->cp0_epc)) {
+						(void *)  xcp->cp0_epc)) {
 					fpuemuprivate.stats.errors++;
 					return SIGBUS;
 				}
@@ -480,7 +479,7 @@ static int cop1Emulate(struct pt_regs *x
 				 * Single step the non-cp1
 				 * instruction in the dslot
 				 */
-				return mips_dsemul(xcp, ir, VA_TO_REG contpc);
+				return mips_dsemul(xcp, ir, (unsigned long) contpc);
 			}
 			else {
 				/* branch not taken */
@@ -539,8 +538,9 @@ static int cop1Emulate(struct pt_regs *x
 	}
 
 	/* we did it !! */
-	xcp->cp0_epc = VA_TO_REG(contpc);
+	xcp->cp0_epc = (unsigned long) contpc;
 	xcp->cp0_cause &= ~CAUSEF_BD;
+
 	return 0;
 }
 
@@ -628,7 +628,7 @@ static int fpux_emu(struct pt_regs *xcp,
 
 		switch (MIPSInst_FUNC(ir)) {
 		case lwxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
 			fpuemuprivate.stats.loads++;
@@ -648,7 +648,7 @@ static int fpux_emu(struct pt_regs *xcp,
 			break;
 
 		case swxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
 			fpuemuprivate.stats.stores++;
@@ -724,7 +724,7 @@ static int fpux_emu(struct pt_regs *xcp,
 
 		switch (MIPSInst_FUNC(ir)) {
 		case ldxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
 			fpuemuprivate.stats.loads++;
@@ -736,7 +736,7 @@ static int fpux_emu(struct pt_regs *xcp,
 			break;
 
 		case sdxc1_op:
-			va = REG_TO_VA(xcp->regs[MIPSInst_FR(ir)] +
+			va = (void *) (xcp->regs[MIPSInst_FR(ir)] +
 				xcp->regs[MIPSInst_FT(ir)]);
 
 			fpuemuprivate.stats.stores++;
@@ -1282,7 +1282,7 @@ static int fpu_emu(struct pt_regs *xcp, 
 int fpu_emulator_cop1Handler(int xcptno, struct pt_regs *xcp,
 	struct mips_fpu_soft_struct *ctx)
 {
-	gpreg_t oldepc, prevepc;
+	unsigned long oldepc, prevepc;
 	mips_instruction insn;
 	int sig = 0;
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/math-emu/dsemul.c linux_HEAD/arch/mips/math-emu/dsemul.c
--- linux-2.6.11.6/arch/mips/math-emu/dsemul.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/math-emu/dsemul.c	2005-03-21 20:03:46.000000000 +0100
@@ -28,9 +28,6 @@
 #endif
 #define __mips 4
 
-extern struct mips_fpu_emulator_private fpuemuprivate;
-
-
 /*
  * Emulate the arbritrary instruction ir at xcp->cp0_epc.  Required when
  * we have to emulate the instruction in a COP1 branch delay slot.  Do
@@ -52,10 +49,10 @@ struct emuframe {
 	mips_instruction	emul;
 	mips_instruction	badinst;
 	mips_instruction	cookie;
-	gpreg_t			epc;
+	unsigned long		epc;
 };
 
-int mips_dsemul(struct pt_regs *regs, mips_instruction ir, gpreg_t cpc)
+int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc)
 {
 	extern asmlinkage void handle_dsemulret(void);
 	mips_instruction *dsemul_insns;
@@ -91,7 +88,7 @@ int mips_dsemul(struct pt_regs *regs, mi
 	 */
 
 	/* Ensure that the two instructions are in the same cache line */
-	dsemul_insns = (mips_instruction *) REG_TO_VA ((regs->regs[29] - sizeof(struct emuframe)) & ~0x7);
+	dsemul_insns = (mips_instruction *) ((regs->regs[29] - sizeof(struct emuframe)) & ~0x7);
 	fr = (struct emuframe *) dsemul_insns;
 
 	/* Verify that the stack pointer is not competely insane */
@@ -108,7 +105,7 @@ int mips_dsemul(struct pt_regs *regs, mi
 		return SIGBUS;
 	}
 
-	regs->cp0_epc = VA_TO_REG & fr->emul;
+	regs->cp0_epc = (unsigned long) &fr->emul;
 
 	flush_cache_sigtramp((unsigned long)&fr->badinst);
 
@@ -118,7 +115,7 @@ int mips_dsemul(struct pt_regs *regs, mi
 int do_dsemulret(struct pt_regs *xcp)
 {
 	struct emuframe *fr;
-	gpreg_t epc;
+	unsigned long epc;
 	u32 insn, cookie;
 	int err = 0;
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/math-emu/dsemul.h linux_HEAD/arch/mips/math-emu/dsemul.h
--- linux-2.6.11.6/arch/mips/math-emu/dsemul.h	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/math-emu/dsemul.h	2005-02-28 22:37:28.000000000 +0100
@@ -1,11 +1,5 @@
-typedef long gpreg_t;
-typedef void *vaddr_t;
-
-#define REG_TO_VA (vaddr_t)
-#define VA_TO_REG (gpreg_t)
-
-int mips_dsemul(struct pt_regs *regs, mips_instruction ir, gpreg_t cpc);
-int do_dsemulret(struct pt_regs *xcp);
+extern int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc);
+extern int do_dsemulret(struct pt_regs *xcp);
 
 /* Instruction which will always cause an address error */
 #define AdELOAD 0x8c000001	/* lw $0,1($0) */
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/math-emu/kernel_linkage.c linux_HEAD/arch/mips/math-emu/kernel_linkage.c
--- linux-2.6.11.6/arch/mips/math-emu/kernel_linkage.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/math-emu/kernel_linkage.c	2005-02-28 22:37:28.000000000 +0100
@@ -27,8 +27,6 @@
 
 #include <asm/fpu_emulator.h>
 
-extern struct mips_fpu_emulator_private fpuemuprivate;
-
 #define SIGNALLING_NAN 0x7ff800007ff80000LL
 
 void fpu_emulator_init_fpu(void)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mips-boards/atlas/atlas_int.c linux_HEAD/arch/mips/mips-boards/atlas/atlas_int.c
--- linux-2.6.11.6/arch/mips/mips-boards/atlas/atlas_int.c	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/arch/mips/mips-boards/atlas/atlas_int.c	2005-02-28 16:56:42.000000000 +0100
@@ -76,14 +76,13 @@ static void end_atlas_irq(unsigned int i
 }
 
 static struct hw_interrupt_type atlas_irq_type = {
-	"Atlas",
-	startup_atlas_irq,
-	shutdown_atlas_irq,
-	enable_atlas_irq,
-	disable_atlas_irq,
-	mask_and_ack_atlas_irq,
-	end_atlas_irq,
-	NULL
+	.typename = "Atlas",
+	.startup = startup_atlas_irq,
+	.shutdown = shutdown_atlas_irq,
+	.enable = enable_atlas_irq,
+	.disable = disable_atlas_irq,
+	.ack = mask_and_ack_atlas_irq,
+	.end = end_atlas_irq,
 };
 
 static inline int ls1bit32(unsigned int x)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mips-boards/generic/init.c linux_HEAD/arch/mips/mips-boards/generic/init.c
--- linux-2.6.11.6/arch/mips/mips-boards/generic/init.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/mips-boards/generic/init.c	2005-02-17 21:48:56.000000000 +0100
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999,2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004, 2005  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -22,18 +24,17 @@
 #include <linux/string.h>
 #include <linux/kernel.h>
 
-#include <asm/io.h>
 #include <asm/bootinfo.h>
+#include <asm/gt64120.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
 #include <asm/mips-boards/prom.h>
 #include <asm/mips-boards/generic.h>
-#ifdef CONFIG_MIPS_GT64120
-#include <asm/gt64120.h>
-#endif
-#include <asm/mips-boards/msc01_pci.h>
 #include <asm/mips-boards/bonito64.h>
-#ifdef CONFIG_MIPS_MALTA
+#include <asm/mips-boards/msc01_pci.h>
+
 #include <asm/mips-boards/malta.h>
-#endif
 
 #ifdef CONFIG_KGDB
 extern int rs_kgdb_hook(int, int);
@@ -225,6 +226,8 @@ void __init kgdb_config (void)
 
 void __init prom_init(void)
 {
+	u32 start, map, mask, data;
+
 	prom_argc = fw_arg0;
 	_prom_argv = (int *) fw_arg1;
 	_prom_envp = (int *) fw_arg2;
@@ -266,12 +269,15 @@ void __init prom_init(void)
 #else
 		GT_WRITE(GT_PCI0_CMD_OFS, 0);
 #endif
+		/* Fix up PCI I/O mapping if necessary (for Atlas).  */
+		start = GT_READ(GT_PCI0IOLD_OFS);
+		map = GT_READ(GT_PCI0IOREMAP_OFS);
+		if ((start & map) != 0) {
+			map &= ~start;
+			GT_WRITE(GT_PCI0IOREMAP_OFS, map);
+		}
 
-#ifdef CONFIG_MIPS_MALTA
 		set_io_port_base(MALTA_GT_PORT_BASE);
-#else
-		set_io_port_base((unsigned long)ioremap(0, 0x20000000));
-#endif
 		break;
 
 	case MIPS_REVISION_CORID_CORE_EMUL_BON:
@@ -300,11 +306,7 @@ void __init prom_init(void)
 			BONITO_BONGENCFG_BYTESWAP;
 #endif
 
-#ifdef CONFIG_MIPS_MALTA
 		set_io_port_base(MALTA_BONITO_PORT_BASE);
-#else
-		set_io_port_base((unsigned long)ioremap(0, 0x20000000));
-#endif
 		break;
 
 	case MIPS_REVISION_CORID_CORE_MSC:
@@ -312,6 +314,12 @@ void __init prom_init(void)
 	case MIPS_REVISION_CORID_CORE_EMUL_MSC:
 		_pcictrl_msc = (unsigned long)ioremap(MIPS_MSC01_PCI_REG_BASE, 0x2000); 
 
+		mb();
+		MSC_READ(MSC01_PCI_CFG, data);
+		MSC_WRITE(MSC01_PCI_CFG, data & ~MSC01_PCI_CFG_EN_BIT);
+		wmb();
+
+		/* Fix up lane swapping.  */
 #ifdef CONFIG_CPU_LITTLE_ENDIAN
 		MSC_WRITE(MSC01_PCI_SWAP, MSC01_PCI_SWAP_NOSWAP);
 #else
@@ -320,12 +328,23 @@ void __init prom_init(void)
 			  MSC01_PCI_SWAP_BYTESWAP << MSC01_PCI_SWAP_MEM_SHF |
 			  MSC01_PCI_SWAP_BYTESWAP << MSC01_PCI_SWAP_BAR0_SHF);
 #endif
+		/* Fix up target memory mapping.  */
+		MSC_READ(MSC01_PCI_BAR0, mask);
+		MSC_WRITE(MSC01_PCI_P2SCMSKL, mask & MSC01_PCI_BAR0_SIZE_MSK);
+
+		/* Don't handle target retries indefinitely.  */
+		if ((data & MSC01_PCI_CFG_MAXRTRY_MSK) ==
+		    MSC01_PCI_CFG_MAXRTRY_MSK)
+			data = (data & ~(MSC01_PCI_CFG_MAXRTRY_MSK <<
+					 MSC01_PCI_CFG_MAXRTRY_SHF)) |
+			       ((MSC01_PCI_CFG_MAXRTRY_MSK - 1) <<
+				MSC01_PCI_CFG_MAXRTRY_SHF);
+
+		wmb();
+		MSC_WRITE(MSC01_PCI_CFG, data);
+		mb();
 
-#ifdef CONFIG_MIPS_MALTA
 		set_io_port_base(MALTA_MSC_PORT_BASE);
-#else
-		set_io_port_base((unsigned long)ioremap(0, 0x20000000));
-#endif
 		break;
 
 	default:
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mips-boards/generic/pci.c linux_HEAD/arch/mips/mips-boards/generic/pci.c
--- linux-2.6.11.6/arch/mips/mips-boards/generic/pci.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/mips-boards/generic/pci.c	2005-02-17 21:48:56.000000000 +0100
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004, 2005  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
@@ -25,59 +27,41 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 
-#include <asm/mips-boards/generic.h>
 #include <asm/gt64120.h>
+
+#include <asm/mips-boards/generic.h>
 #include <asm/mips-boards/bonito64.h>
 #include <asm/mips-boards/msc01_pci.h>
-#ifdef CONFIG_MIPS_MALTA
-#include <asm/mips-boards/malta.h>
-#endif
 
 static struct resource bonito64_mem_resource = {
 	.name	= "Bonito PCI MEM",
-	.start	= 0x10000000UL,
-	.end	= 0x1bffffffUL,
 	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource bonito64_io_resource = {
-	.name	= "Bonito IO MEM",
-	.start	= 0x00002000UL,	/* avoid conflicts with YAMON allocated I/O addresses */
+	.name	= "Bonito PCI I/O",
+	.start	= 0x00000000UL,
 	.end	= 0x000fffffUL,
 	.flags	= IORESOURCE_IO,
 };
 
 static struct resource gt64120_mem_resource = {
-	.name	= "GT64120 PCI MEM",
-	.start	= 0x10000000UL,
-	.end	= 0x1bdfffffUL,
+	.name	= "GT-64120 PCI MEM",
 	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource gt64120_io_resource = {
-	.name	= "GT64120 IO MEM",
-#ifdef CONFIG_MIPS_ATLAS
-	.start	= 0x18000000UL,
-	.end	= 0x181fffffUL,
-#endif
-#ifdef CONFIG_MIPS_MALTA
-	.start	= 0x00002000UL,
-	.end	= 0x001fffffUL,
-#endif
+	.name	= "GT-64120 PCI I/O",
 	.flags	= IORESOURCE_IO,
 };
 
 static struct resource msc_mem_resource = {
 	.name	= "MSC PCI MEM",
-	.start	= 0x10000000UL,
-	.end	= 0x1fffffffUL,
 	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource msc_io_resource = {
-	.name	= "MSC IO MEM",
-	.start	= 0x00002000UL,
-	.end	= 0x007fffffUL,
+	.name	= "MSC PCI I/O",
 	.flags	= IORESOURCE_IO,
 };
 
@@ -89,7 +73,6 @@ static struct pci_controller bonito64_co
 	.pci_ops	= &bonito64_pci_ops,
 	.io_resource	= &bonito64_io_resource,
 	.mem_resource	= &bonito64_mem_resource,
-	.mem_offset	= 0x10000000UL,
 	.io_offset	= 0x00000000UL,
 };
 
@@ -97,21 +80,18 @@ static struct pci_controller gt64120_con
 	.pci_ops	= &gt64120_pci_ops,
 	.io_resource	= &gt64120_io_resource,
 	.mem_resource	= &gt64120_mem_resource,
-	.mem_offset	= 0x00000000UL,
-	.io_offset	= 0x00000000UL,
 };
 
-static struct pci_controller  msc_controller = {
+static struct pci_controller msc_controller = {
 	.pci_ops	= &msc_pci_ops,
 	.io_resource	= &msc_io_resource,
 	.mem_resource	= &msc_mem_resource,
-	.mem_offset	= 0x10000000UL,
-	.io_offset	= 0x00000000UL,
 };
 
 static int __init pcibios_init(void)
 {
 	struct pci_controller *controller;
+	unsigned long start, end, map, start1, end1, map1, map2, map3, mask;
 
 	switch (mips_revision_corid) {
 	case MIPS_REVISION_CORID_QED_RM5261:
@@ -130,29 +110,138 @@ static int __init pcibios_init(void)
 			 (0 << GT_PCI0_CFGADDR_DEVNUM_SHF) | /* GT64120 dev */
 			 (0 << GT_PCI0_CFGADDR_FUNCTNUM_SHF) | /* Function 0*/
 			 ((0x20/4) << GT_PCI0_CFGADDR_REGNUM_SHF) | /* BAR 4*/
-			 GT_PCI0_CFGADDR_CONFIGEN_BIT );
+			 GT_PCI0_CFGADDR_CONFIGEN_BIT);
 
 		/* Perform the write */
 		GT_WRITE(GT_PCI0_CFGDATA_OFS, CPHYSADDR(MIPS_GT_BASE));
 
+		/* Set up resource ranges from the controller's registers.  */
+		start = GT_READ(GT_PCI0M0LD_OFS);
+		end = GT_READ(GT_PCI0M0HD_OFS);
+		map = GT_READ(GT_PCI0M0REMAP_OFS);
+		end = (end & GT_PCI_HD_MSK) | (start & ~GT_PCI_HD_MSK);
+		start1 = GT_READ(GT_PCI0M1LD_OFS);
+		end1 = GT_READ(GT_PCI0M1HD_OFS);
+		map1 = GT_READ(GT_PCI0M1REMAP_OFS);
+		end1 = (end1 & GT_PCI_HD_MSK) | (start1 & ~GT_PCI_HD_MSK);
+		/* Cannot support multiple windows, use the wider.  */
+		if (end1 - start1 > end - start) {
+			start = start1;
+			end = end1;
+			map = map1;
+		}
+		mask = ~(start ^ end);
+                /* We don't support remapping with a discontiguous mask.  */
+		BUG_ON((start & GT_PCI_HD_MSK) != (map & GT_PCI_HD_MSK) &&
+		       mask != ~((mask & -mask) - 1));
+		gt64120_mem_resource.start = start;
+		gt64120_mem_resource.end = end;
+		gt64120_controller.mem_offset = (start & mask) - (map & mask);
+		/* Addresses are 36-bit, so do shifts in the destinations.  */
+		gt64120_mem_resource.start <<= GT_PCI_DCRM_SHF;
+		gt64120_mem_resource.end <<= GT_PCI_DCRM_SHF;
+		gt64120_mem_resource.end |= (1 << GT_PCI_DCRM_SHF) - 1;
+		gt64120_controller.mem_offset <<= GT_PCI_DCRM_SHF;
+
+		start = GT_READ(GT_PCI0IOLD_OFS);
+		end = GT_READ(GT_PCI0IOHD_OFS);
+		map = GT_READ(GT_PCI0IOREMAP_OFS);
+		end = (end & GT_PCI_HD_MSK) | (start & ~GT_PCI_HD_MSK);
+		mask = ~(start ^ end);
+                /* We don't support remapping with a discontiguous mask.  */
+		BUG_ON((start & GT_PCI_HD_MSK) != (map & GT_PCI_HD_MSK) &&
+		       mask != ~((mask & -mask) - 1));
+		gt64120_io_resource.start = map & mask;
+		gt64120_io_resource.end = (map & mask) | ~mask;
+		gt64120_controller.io_offset = 0;
+		/* Addresses are 36-bit, so do shifts in the destinations.  */
+		gt64120_io_resource.start <<= GT_PCI_DCRM_SHF;
+		gt64120_io_resource.end <<= GT_PCI_DCRM_SHF;
+		gt64120_io_resource.end |= (1 << GT_PCI_DCRM_SHF) - 1;
+
 		controller = &gt64120_controller;
 		break;
 
 	case MIPS_REVISION_CORID_BONITO64:
 	case MIPS_REVISION_CORID_CORE_20K:
 	case MIPS_REVISION_CORID_CORE_EMUL_BON:
+		/* Set up resource ranges from the controller's registers.  */
+		map = BONITO_PCIMAP;
+		map1 = (BONITO_PCIMAP & BONITO_PCIMAP_PCIMAP_LO0) >>
+		       BONITO_PCIMAP_PCIMAP_LO0_SHIFT;
+		map2 = (BONITO_PCIMAP & BONITO_PCIMAP_PCIMAP_LO1) >>
+		       BONITO_PCIMAP_PCIMAP_LO1_SHIFT;
+		map3 = (BONITO_PCIMAP & BONITO_PCIMAP_PCIMAP_LO2) >>
+		       BONITO_PCIMAP_PCIMAP_LO2_SHIFT;
+		/* Combine as many adjacent windows as possible.  */
+		map = map1;
+		start = BONITO_PCILO0_BASE;
+		end = 1;
+		if (map3 == map2 + 1) {
+			map = map2;
+			start = BONITO_PCILO1_BASE;
+			end++;
+		}
+		if (map2 == map1 + 1) {
+			map = map1;
+			start = BONITO_PCILO0_BASE;
+			end++;
+		}
+		bonito64_mem_resource.start = start;
+		bonito64_mem_resource.end = start +
+					    BONITO_PCIMAP_WINBASE(end) - 1;
+		bonito64_controller.mem_offset = start -
+						 BONITO_PCIMAP_WINBASE(map);
+
 		controller = &bonito64_controller;
 		break;
 
 	case MIPS_REVISION_CORID_CORE_MSC:
 	case MIPS_REVISION_CORID_CORE_FPGA2:
 	case MIPS_REVISION_CORID_CORE_EMUL_MSC:
+		/* Set up resource ranges from the controller's registers.  */
+		MSC_READ(MSC01_PCI_SC2PMBASL, start);
+		MSC_READ(MSC01_PCI_SC2PMMSKL, mask);
+		MSC_READ(MSC01_PCI_SC2PMMAPL, map);
+		msc_mem_resource.start = start & mask;
+		msc_mem_resource.end = (start & mask) | ~mask;
+		msc_controller.mem_offset = (start & mask) - (map & mask);
+
+		MSC_READ(MSC01_PCI_SC2PIOBASL, start);
+		MSC_READ(MSC01_PCI_SC2PIOMSKL, mask);
+		MSC_READ(MSC01_PCI_SC2PIOMAPL, map);
+		msc_io_resource.start = map & mask;
+		msc_io_resource.end = (map & mask) | ~mask;
+		msc_controller.io_offset = 0;
+		ioport_resource.end = ~mask;
+
+		/* If ranges overlap I/O takes precedence.  */
+		start = start & mask;
+		end = start | ~mask;
+		if ((start >= msc_mem_resource.start &&
+		     start <= msc_mem_resource.end) ||
+		    (end >= msc_mem_resource.start &&
+		     end <= msc_mem_resource.end)) {
+			/* Use the larger space.  */
+			start = max(start, msc_mem_resource.start);
+			end = min(end, msc_mem_resource.end);
+			if (start - msc_mem_resource.start >=
+			    msc_mem_resource.end - end)
+				msc_mem_resource.end = start - 1;
+			else
+				msc_mem_resource.start = end + 1;
+		}
+
 		controller = &msc_controller;
 		break;
 	default:
 		return 1;
 	}
 
+	if (controller->io_resource->start < 0x00001000UL)	/* FIXME */
+		controller->io_resource->start = 0x00001000UL;
+
+	iomem_resource.end &= 0xfffffffffULL;			/* 64 GB */
 	ioport_resource.end = controller->io_resource->end;
 
 	register_pci_controller (controller);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mips-boards/sead/sead_int.c linux_HEAD/arch/mips/mips-boards/sead/sead_int.c
--- linux-2.6.11.6/arch/mips/mips-boards/sead/sead_int.c	2005-03-26 04:28:29.000000000 +0100
+++ linux_HEAD/arch/mips/mips-boards/sead/sead_int.c	2005-02-17 21:48:56.000000000 +0100
@@ -2,6 +2,7 @@
  * Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
  * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2004  Maciej W. Rozycki
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -21,7 +22,9 @@
  */
 #include <linux/init.h>
 #include <linux/irq.h>
-#include <linux/interrupt.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/system.h>
 
 #include <asm/mips-boards/seadint.h>
 
@@ -39,13 +42,8 @@ asmlinkage void sead_hw1_irqdispatch(str
 
 void __init arch_init_irq(void)
 {
-        /*
-         * Mask out all interrupt
-	 */
-	clear_c0_status(0x0000ff00);
+	mips_cpu_irq_init(0);
 
 	/* Now safe to set the exception vector. */
 	set_except_vector(0, mipsIRQ);
-
-	mips_cpu_irq_init(0);
 }
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/c-r4k.c linux_HEAD/arch/mips/mm/c-r4k.c
--- linux-2.6.11.6/arch/mips/mm/c-r4k.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/mm/c-r4k.c	2005-03-21 20:03:46.000000000 +0100
@@ -372,12 +372,21 @@ static inline void local_r4k_flush_cache
 	int exec = vma->vm_flags & VM_EXEC;
 	struct mm_struct *mm = vma->vm_mm;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 
+	/*
+	 * If ownes no valid ASID yet, cannot possibly have gotten
+	 * this page into the cache.
+	 */
+	if (cpu_context(smp_processor_id(), mm) == 0)
+		return;
+
 	page &= PAGE_MASK;
 	pgdp = pgd_offset(mm, page);
-	pmdp = pmd_offset(pgdp, page);
+	pudp = pud_offset(pgdp, page);
+	pmdp = pmd_offset(pudp, page);
 	ptep = pte_offset(pmdp, page);
 
 	/*
@@ -419,8 +428,8 @@ static inline void local_r4k_flush_cache
 		if (cpu_has_vtag_icache) {
 			int cpu = smp_processor_id();
 
-			if (cpu_context(cpu, vma->vm_mm) != 0)
-				drop_mmu_context(vma->vm_mm, cpu);
+			if (cpu_context(cpu, mm) != 0)
+				drop_mmu_context(mm, cpu);
 		} else
 			r4k_blast_icache_page_indexed(page);
 	}
@@ -430,13 +439,6 @@ static void r4k_flush_cache_page(struct 
 {
 	struct flush_cache_page_args args;
 
-	/*
-	 * If ownes no valid ASID yet, cannot possibly have gotten
-	 * this page into the cache.
-	 */
-	if (cpu_context(smp_processor_id(), vma->vm_mm) == 0)
-		return;
-
 	args.vma = vma;
 	args.page = page;
 
@@ -454,8 +456,8 @@ static void r4k_flush_data_cache_page(un
 }
 
 struct flush_icache_range_args {
-	unsigned long start;
-	unsigned long end;
+	unsigned long __user start;
+	unsigned long __user end;
 };
 
 static inline void local_r4k_flush_icache_range(void *args)
@@ -517,7 +519,8 @@ static inline void local_r4k_flush_icach
 	}
 }
 
-static void r4k_flush_icache_range(unsigned long start, unsigned long end)
+static void r4k_flush_icache_range(unsigned long __user start,
+	unsigned long __user end)
 {
 	struct flush_icache_range_args args;
 
@@ -1011,9 +1014,19 @@ static void __init probe_pcache(void)
 	 * normally they'd suffer from aliases but magic in the hardware deals
 	 * with that for us so we don't need to take care ourselves.
 	 */
-	if (c->cputype != CPU_R10000 && c->cputype != CPU_R12000)
-		if (c->dcache.waysize > PAGE_SIZE)
-		        c->dcache.flags |= MIPS_CACHE_ALIASES;
+	switch (c->cputype) {
+	case CPU_20KC:
+	case CPU_25KF:
+	case CPU_R10000:
+	case CPU_R12000:
+	case CPU_SB1:
+		break;
+	case CPU_24K:
+		if (!(read_c0_config7() & (1 << 16)))
+	default:
+			if (c->dcache.waysize > PAGE_SIZE)
+				c->dcache.flags |= MIPS_CACHE_ALIASES;
+	}
 
 	switch (c->cputype) {
 	case CPU_20KC:
@@ -1024,7 +1037,11 @@ static void __init probe_pcache(void)
 		c->icache.flags |= MIPS_CACHE_VTAG;
 		break;
 
+	case CPU_AU1000:
 	case CPU_AU1500:
+	case CPU_AU1100:
+	case CPU_AU1550:
+	case CPU_AU1200:
 		c->icache.flags |= MIPS_CACHE_IC_F_DC;
 		break;
 	}
@@ -1212,9 +1229,6 @@ void __init ld_mmu_r4xx0(void)
 	probe_pcache();
 	setup_scache();
 
-	if (c->dcache.sets * c->dcache.ways > PAGE_SIZE)
-		c->dcache.flags |= MIPS_CACHE_ALIASES;
-
 	r4k_blast_dcache_page_setup();
 	r4k_blast_dcache_page_indexed_setup();
 	r4k_blast_dcache_setup();
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/c-sb1.c linux_HEAD/arch/mips/mm/c-sb1.c
--- linux-2.6.11.6/arch/mips/mm/c-sb1.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/mm/c-sb1.c	2005-03-21 20:03:46.000000000 +0100
@@ -235,7 +235,7 @@ static inline void __sb1_flush_icache_ra
 /*
  * Invalidate all caches on this CPU
  */
-static void local_sb1___flush_cache_all(void)
+static void __attribute_used__ local_sb1___flush_cache_all(void)
 {
 	__sb1_writeback_inv_dcache_all();
 	__sb1_flush_icache_all();
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/cache.c linux_HEAD/arch/mips/mm/cache.c
--- linux-2.6.11.6/arch/mips/mm/cache.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/mm/cache.c	2005-03-21 20:03:46.000000000 +0100
@@ -32,6 +34,8 @@ void (*flush_cache_sigtramp)(unsigned lo
 void (*flush_data_cache_page)(unsigned long addr);
 void (*flush_icache_all)(void);
 
+EXPORT_SYMBOL(flush_data_cache_page);
+
 #ifdef CONFIG_DMA_NONCOHERENT
 
 /* DMA cache operations. */
@@ -49,10 +53,10 @@ EXPORT_SYMBOL(_dma_cache_inv);
  * We could optimize the case where the cache argument is not BCACHE but
  * that seems very atypical use ...
  */
-asmlinkage int sys_cacheflush(unsigned long addr, unsigned long int bytes,
-	unsigned int cache)
+asmlinkage int sys_cacheflush(unsigned long __user addr,
+	unsigned long bytes, unsigned int cache)
 {
-	if (verify_area(VERIFY_WRITE, (void *) addr, bytes))
+	if (verify_area(VERIFY_WRITE, (void __user *) addr, bytes))
 		return -EFAULT;
 
 	flush_icache_range(addr, addr + bytes);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/dma-ip32.c linux_HEAD/arch/mips/mm/dma-ip32.c
--- linux-2.6.11.6/arch/mips/mm/dma-ip32.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/mm/dma-ip32.c	2005-02-17 21:48:56.000000000 +0100
@@ -175,7 +175,7 @@ int dma_map_sg(struct device *dev, struc
 
 	for (i = 0; i < nents; i++, sg++) {
 		unsigned long addr;
-
+ 
 		addr = (unsigned long) page_address(sg->page)+sg->offset;
 		if (addr)
 			__dma_sync(addr, sg->length, direction);
@@ -251,9 +251,9 @@ void dma_sync_single_for_cpu(struct devi
 	size_t size, enum dma_data_direction direction)
 {
 	unsigned long addr;
-
+ 
 	BUG_ON(direction == DMA_NONE);
-
+ 
 	dma_handle&=RAM_OFFSET_MASK;
 	addr = dma_handle + PAGE_OFFSET;
 	if(dma_handle>=256*1024*1024)
@@ -315,9 +315,9 @@ void dma_sync_sg_for_cpu(struct device *
 	enum dma_data_direction direction)
 {
 	int i;
-
+ 
 	BUG_ON(direction == DMA_NONE);
-
+ 
 	/* Make sure that gcc doesn't leave the empty loop body.  */
 	for (i = 0; i < nelems; i++, sg++)
 		__dma_sync((unsigned long)page_address(sg->page),
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/fault.c linux_HEAD/arch/mips/mm/fault.c
--- linux-2.6.11.6/arch/mips/mm/fault.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/mm/fault.c	2005-03-01 22:49:39.000000000 +0100
@@ -25,6 +25,7 @@
 #include <asm/system.h>
 #include <asm/uaccess.h>
 #include <asm/ptrace.h>
+#include <asm/highmem.h>		/* For VMALLOC_END */
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -57,7 +58,7 @@ asmlinkage void do_page_fault(struct pt_
 	 * only copy the information from the master page table,
 	 * nothing more.
 	 */
-	if (unlikely(address >= VMALLOC_START))
+	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))
 		goto vmalloc_fault;
 
 	/*
@@ -140,7 +141,7 @@ bad_area_nosemaphore:
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		/* info.si_code has been set above */
-		info.si_addr = (void *) address;
+		info.si_addr = (void __user *) address;
 		force_sig_info(SIGSEGV, &info, tsk);
 		return;
 	}
@@ -196,7 +197,7 @@ do_sigbus:
 	info.si_signo = SIGBUS;
 	info.si_errno = 0;
 	info.si_code = BUS_ADRERR;
-	info.si_addr = (void *) address;
+	info.si_addr = (void __user *) address;
 	force_sig_info(SIGBUS, &info, tsk);
 
 	return;
@@ -212,6 +213,7 @@ vmalloc_fault:
 		 */
 		int offset = __pgd_offset(address);
 		pgd_t *pgd, *pgd_k;
+		pud_t *pud, *pud_k;
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 
@@ -222,8 +224,13 @@ vmalloc_fault:
 			goto no_context;
 		set_pgd(pgd, *pgd_k);
 
-		pmd = pmd_offset(pgd, address);
-		pmd_k = pmd_offset(pgd_k, address);
+		pud = pud_offset(pgd, address);
+		pud_k = pud_offset(pgd_k, address);
+		if (!pud_present(*pud_k))
+			goto no_context;
+
+		pmd = pmd_offset(pud, address);
+		pmd_k = pmd_offset(pud_k, address);
 		if (!pmd_present(*pmd_k))
 			goto no_context;
 		set_pmd(pmd, *pmd_k);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/init.c linux_HEAD/arch/mips/mm/init.c
--- linux-2.6.11.6/arch/mips/mm/init.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/mm/init.c	2005-03-21 20:03:46.000000000 +0100
@@ -83,7 +83,7 @@ pte_t *kmap_pte;
 pgprot_t kmap_prot;
 
 #define kmap_get_fixmap_pte(vaddr)					\
-	pte_offset_kernel(pmd_offset(pgd_offset_k(vaddr), (vaddr)), (vaddr))
+	pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k(vaddr), (vaddr)), (vaddr)), (vaddr))
 
 static void __init kmap_init(void)
 {
@@ -96,36 +96,42 @@ static void __init kmap_init(void)
 	kmap_prot = PAGE_KERNEL;
 }
 
-#ifdef CONFIG_MIPS64
-static void __init fixrange_init(unsigned long start, unsigned long end,
+#ifdef CONFIG_MIPS32
+void __init fixrange_init(unsigned long start, unsigned long end,
 	pgd_t *pgd_base)
 {
 	pgd_t *pgd;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
-	int i, j;
+	int i, j, k;
 	unsigned long vaddr;
 
 	vaddr = start;
 	i = __pgd_offset(vaddr);
-	j = __pmd_offset(vaddr);
+	j = __pud_offset(vaddr);
+	k = __pmd_offset(vaddr);
 	pgd = pgd_base + i;
 
 	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
-		pmd = (pmd_t *)pgd;
-		for (; (j < PTRS_PER_PMD) && (vaddr != end); pmd++, j++) {
-			if (pmd_none(*pmd)) {
-				pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-				set_pmd(pmd, __pmd(pte));
-				if (pte != pte_offset_kernel(pmd, 0))
-					BUG();
+		pud = (pud_t *)pgd;
+		for ( ; (j < PTRS_PER_PUD) && (vaddr != end); pud++, j++) {
+			pmd = (pmd_t *)pud;
+			for (; (k < PTRS_PER_PMD) && (vaddr != end); pmd++, k++) {
+				if (pmd_none(*pmd)) {
+					pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
+					set_pmd(pmd, __pmd(pte));
+					if (pte != pte_offset_kernel(pmd, 0))
+						BUG();
+				}
+				vaddr += PMD_SIZE;
 			}
-			vaddr += PMD_SIZE;
+			k = 0;
 		}
 		j = 0;
 	}
 }
-#endif /* CONFIG_MIPS64 */
+#endif /* CONFIG_MIPS32 */
 #endif /* CONFIG_HIGHMEM */
 
 #ifndef CONFIG_DISCONTIGMEM
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/ioremap.c linux_HEAD/arch/mips/mm/ioremap.c
--- linux-2.6.11.6/arch/mips/mm/ioremap.c	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/arch/mips/mm/ioremap.c	2005-02-17 21:48:57.000000000 +0100
@@ -79,9 +79,14 @@ static int remap_area_pages(unsigned lon
 		BUG();
 	spin_lock(&init_mm.page_table_lock);
 	do {
+		pud_t *pud;
 		pmd_t *pmd;
-		pmd = pmd_alloc(&init_mm, dir, address);
+
 		error = -ENOMEM;
+		pud = pud_alloc(&init_mm, dir, address);
+		if (!pud)
+			break;
+		pmd = pmd_alloc(&init_mm, pud, address);
 		if (!pmd)
 			break;
 		if (remap_area_pmd(pmd, address, end - address,
@@ -141,7 +146,7 @@ void * __ioremap(phys_t phys_addr, phys_
 	 */
 	if (IS_LOW512(phys_addr) && IS_LOW512(last_addr) &&
 	    flags == _CACHE_UNCACHED)
-		return (void *) KSEG1ADDR(phys_addr);
+		return (void *) CKSEG1ADDR(phys_addr);
 
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using..
@@ -180,7 +185,7 @@ void * __ioremap(phys_t phys_addr, phys_
 	return (void *) (offset + (char *)addr);
 }
 
-#define IS_KSEG1(addr) (((unsigned long)(addr) & ~0x1fffffffUL) == KSEG1)
+#define IS_KSEG1(addr) (((unsigned long)(addr) & ~0x1fffffffUL) == CKSEG1)
 
 void __iounmap(volatile void __iomem *addr)
 {
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/pg-sb1.c linux_HEAD/arch/mips/mm/pg-sb1.c
--- linux-2.6.11.6/arch/mips/mm/pg-sb1.c	2005-03-26 04:28:39.000000000 +0100
+++ linux_HEAD/arch/mips/mm/pg-sb1.c	2005-04-02 11:54:44.000000000 +0200
@@ -60,7 +60,8 @@ static inline void clear_page_cpu(void *
 	"	.set	noreorder	\n"
 #ifdef CONFIG_CPU_HAS_PREFETCH
 	"	daddiu	%0, %0, 128	\n"
-	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%0)  \n"  /* Prefetch the first 4 lines */
+	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%0)  \n"
+					     /* Prefetch the first 4 lines */
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -96(%0)  \n"
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -64(%0)  \n"
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -32(%0)  \n"
@@ -106,7 +107,8 @@ static inline void copy_page_cpu(void *t
 #ifdef CONFIG_CPU_HAS_PREFETCH
 	"	daddiu	%0, %0, 128	\n"
 	"	daddiu	%1, %1, 128	\n"
-	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ", -128(%0)\n"  /* Prefetch the first 4 lines */
+	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ", -128(%0)\n"
+					     /* Prefetch the first 4 lines */
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ", -128(%1)\n"
 	"	pref	" SB1_PREF_LOAD_STREAMED_HINT  ",  -96(%0)\n"
 	"	pref	" SB1_PREF_STORE_STREAMED_HINT ",  -96(%1)\n"
@@ -207,66 +209,73 @@ typedef struct dmadscr_s {
 	u64 pad_b;
 } dmadscr_t;
 
-static dmadscr_t page_descr[NR_CPUS] __attribute__((aligned(SMP_CACHE_BYTES)));
+static dmadscr_t page_descr[DM_NUM_CHANNELS]
+	__attribute__((aligned(SMP_CACHE_BYTES)));
 
 void sb1_dma_init(void)
 {
-	int cpu = smp_processor_id();
-	u64 base_val = CPHYSADDR(&page_descr[cpu]) | V_DM_DSCR_BASE_RINGSZ(1);
+	int i;
 
-	bus_writeq(base_val,
-		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
-	bus_writeq(base_val | M_DM_DSCR_BASE_RESET,
-		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
-	bus_writeq(base_val | M_DM_DSCR_BASE_ENABL,
-		   (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	for (i = 0; i < DM_NUM_CHANNELS; i++) {
+		const u64 base_val = CPHYSADDR(&page_descr[i]) |
+				     V_DM_DSCR_BASE_RINGSZ(1);
+		const volatile void *base_reg =
+			IOADDR(A_DM_REGISTER(i, R_DM_DSCR_BASE));
+
+		__raw_writeq(base_val, base_reg);
+		__raw_writeq(base_val | M_DM_DSCR_BASE_RESET, base_reg);
+		__raw_writeq(base_val | M_DM_DSCR_BASE_ENABL, base_reg);
+	}
 }
 
 void clear_page(void *page)
 {
-	int cpu = smp_processor_id();
+	u64 to_phys = CPHYSADDR(page);
+	unsigned int cpu = smp_processor_id();
 
-	/* if the page is above Kseg0, use old way */
+	/* if the page is not in KSEG0, use old way */
 	if ((long)KSEGX(page) != (long)CKSEG0)
 		return clear_page_cpu(page);
 
-	page_descr[cpu].dscr_a = CPHYSADDR(page) | M_DM_DSCRA_ZERO_MEM | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
+	page_descr[cpu].dscr_a = to_phys | M_DM_DSCRA_ZERO_MEM |
+				 M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
 	page_descr[cpu].dscr_b = V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
-	bus_writeq(1, (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
+	__raw_writeq(1, IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
 
 	/*
 	 * Don't really want to do it this way, but there's no
 	 * reliable way to delay completion detection.
 	 */
-	while (!(bus_readq((void *)(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) &
-			   M_DM_DSCR_BASE_INTERRUPT))))
+	while (!(__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)))
+		 & M_DM_DSCR_BASE_INTERRUPT))
 		;
-	bus_readq((void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
 }
 
 void copy_page(void *to, void *from)
 {
-	unsigned long from_phys = CPHYSADDR(from);
-	unsigned long to_phys = CPHYSADDR(to);
-	int cpu = smp_processor_id();
+	u64 from_phys = CPHYSADDR(from);
+	u64 to_phys = CPHYSADDR(to);
+	unsigned int cpu = smp_processor_id();
 
-	/* if either page is above Kseg0, use old way */
+	/* if any page is not in KSEG0, use old way */
 	if ((long)KSEGX(to) != (long)CKSEG0
 	    || (long)KSEGX(from) != (long)CKSEG0)
 		return copy_page_cpu(to, from);
 
-	page_descr[cpu].dscr_a = CPHYSADDR(to_phys) | M_DM_DSCRA_L2C_DEST | M_DM_DSCRA_INTERRUPT;
-	page_descr[cpu].dscr_b = CPHYSADDR(from_phys) | V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
-	bus_writeq(1, (void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
+	page_descr[cpu].dscr_a = to_phys | M_DM_DSCRA_L2C_DEST |
+				 M_DM_DSCRA_INTERRUPT;
+	page_descr[cpu].dscr_b = from_phys | V_DM_DSCRB_SRC_LENGTH(PAGE_SIZE);
+	__raw_writeq(1, IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_COUNT)));
 
 	/*
 	 * Don't really want to do it this way, but there's no
 	 * reliable way to delay completion detection.
 	 */
-	while (!(bus_readq((void *)(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)) &
-				    M_DM_DSCR_BASE_INTERRUPT))))
+	while (!(__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE_DEBUG)))
+		 & M_DM_DSCR_BASE_INTERRUPT))
 		;
-	bus_readq((void *)IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
+	__raw_readq(IOADDR(A_DM_REGISTER(cpu, R_DM_DSCR_BASE)));
 }
 
 #else /* !CONFIG_SIBYTE_DMA_PAGEOPS */
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/pgtable-32.c linux_HEAD/arch/mips/mm/pgtable-32.c
--- linux-2.6.11.6/arch/mips/mm/pgtable-32.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/mm/pgtable-32.c	2005-02-20 02:08:41.000000000 +0100
@@ -10,6 +10,7 @@
 #include <linux/mm.h>
 #include <linux/bootmem.h>
 #include <linux/highmem.h>
+#include <asm/fixmap.h>
 #include <asm/pgtable.h>
 
 void pgd_init(unsigned long page)
@@ -29,42 +30,12 @@ void pgd_init(unsigned long page)
 	}
 }
 
-#ifdef CONFIG_HIGHMEM
-static void __init fixrange_init (unsigned long start, unsigned long end,
-	pgd_t *pgd_base)
-{
-	pgd_t *pgd;
-	pmd_t *pmd;
-	pte_t *pte;
-	int i, j;
-	unsigned long vaddr;
-
-	vaddr = start;
-	i = __pgd_offset(vaddr);
-	j = __pmd_offset(vaddr);
-	pgd = pgd_base + i;
-
-	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
-		pmd = (pmd_t *)pgd;
-		for (; (j < PTRS_PER_PMD) && (vaddr != end); pmd++, j++) {
-			if (pmd_none(*pmd)) {
-				pte = (pte_t *) alloc_bootmem_low_pages(PAGE_SIZE);
-				set_pmd(pmd, __pmd((unsigned long)pte));
-				if (pte != pte_offset_kernel(pmd, 0))
-					BUG();
-			}
-			vaddr += PMD_SIZE;
-		}
-		j = 0;
-	}
-}
-#endif
-
 void __init pagetable_init(void)
 {
 #ifdef CONFIG_HIGHMEM
 	unsigned long vaddr;
 	pgd_t *pgd, *pgd_base;
+	pud_t *pud;
 	pmd_t *pmd;
 	pte_t *pte;
 #endif
@@ -90,7 +61,8 @@ void __init pagetable_init(void)
 	fixrange_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base);
 
 	pgd = swapper_pg_dir + __pgd_offset(vaddr);
-	pmd = pmd_offset(pgd, vaddr);
+	pud = pud_offset(pgd, vaddr);
+	pmd = pmd_offset(pud, vaddr);
 	pte = pte_offset_kernel(pmd, vaddr);
 	pkmap_page_table = pte;
 #endif
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/tlb-andes.c linux_HEAD/arch/mips/mm/tlb-andes.c
--- linux-2.6.11.6/arch/mips/mm/tlb-andes.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/mm/tlb-andes.c	2005-02-17 21:48:57.000000000 +0100
@@ -195,6 +195,7 @@ void __update_tlb(struct vm_area_struct 
 {
 	unsigned long flags;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 	int idx, pid;
@@ -220,7 +221,8 @@ void __update_tlb(struct vm_area_struct 
 	write_c0_entryhi(address | (pid));
 	pgdp = pgd_offset(vma->vm_mm, address);
 	tlb_probe();
-	pmdp = pmd_offset(pgdp, address);
+	pudp = pud_offset(pgdp, address);
+	pmdp = pmd_offset(pudp, address);
 	idx = read_c0_index();
 	ptep = pte_offset_map(pmdp, address);
 	write_c0_entrylo0(pte_val(*ptep++) >> 6);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/tlb-r4k.c linux_HEAD/arch/mips/mm/tlb-r4k.c
--- linux-2.6.11.6/arch/mips/mm/tlb-r4k.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/mm/tlb-r4k.c	2005-03-30 09:19:14.000000000 +0200
@@ -21,6 +21,12 @@
 
 extern void build_tlb_refill_handler(void);
 
+/*
+ * Make sure all entries differ.  If they're not different
+ * MIPS32 will take revenge ...
+ */
+#define UNIQUE_ENTRYHI(idx) (CKSEG0 + ((idx) << (PAGE_SHIFT + 1)))
+
 /* CP0 hazard avoidance. */
 #define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
 				     "nop; nop; nop; nop; nop; nop;\n\t" \
@@ -42,11 +48,8 @@ void local_flush_tlb_all(void)
 
 	/* Blast 'em all away. */
 	while (entry < current_cpu_data.tlbsize) {
-		/*
-		 * Make sure all entries differ.  If they're not different
-		 * MIPS32 will take revenge ...
-		 */
-		write_c0_entryhi(CKSEG0 + (entry << (PAGE_SHIFT + 1)));
+		/* Make sure all entries differ. */
+		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
 		write_c0_index(entry);
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
@@ -57,12 +60,21 @@ void local_flush_tlb_all(void)
 	local_irq_restore(flags);
 }
 
+/* All entries common to a mm share an asid.  To effectively flush
+   these entries, we just bump the asid. */
 void local_flush_tlb_mm(struct mm_struct *mm)
 {
-	int cpu = smp_processor_id();
+	int cpu;
+
+	preempt_disable();
 
-	if (cpu_context(cpu, mm) != 0)
-		drop_mmu_context(mm,cpu);
+	cpu = smp_processor_id();
+
+	if (cpu_context(cpu, mm) != 0) {
+		drop_mmu_context(mm, cpu);
+	}
+
+	preempt_enable();
 }
 
 void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
@@ -75,9 +87,9 @@ void local_flush_tlb_range(struct vm_are
 		unsigned long flags;
 		int size;
 
-		local_irq_save(flags);
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
+		local_irq_save(flags);
 		if (size <= current_cpu_data.tlbsize/2) {
 			int oldpid = read_c0_entryhi();
 			int newpid = cpu_asid(cpu, mm);
@@ -99,8 +111,7 @@ void local_flush_tlb_range(struct vm_are
 				if (idx < 0)
 					continue;
 				/* Make sure all entries differ. */
-				write_c0_entryhi(CKSEG0 +
-				                 (idx << (PAGE_SHIFT + 1)));
+				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 				mtc0_tlbw_hazard();
 				tlb_write_indexed();
 			}
@@ -118,9 +129,9 @@ void local_flush_tlb_kernel_range(unsign
 	unsigned long flags;
 	int size;
 
-	local_irq_save(flags);
 	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	size = (size + 1) >> 1;
+	local_irq_save(flags);
 	if (size <= current_cpu_data.tlbsize / 2) {
 		int pid = read_c0_entryhi();
 
@@ -142,7 +153,7 @@ void local_flush_tlb_kernel_range(unsign
 			if (idx < 0)
 				continue;
 			/* Make sure all entries differ. */
-			write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 			mtc0_tlbw_hazard();
 			tlb_write_indexed();
 		}
@@ -176,7 +187,7 @@ void local_flush_tlb_page(struct vm_area
 		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
-		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -197,8 +208,8 @@ void local_flush_tlb_one(unsigned long p
 	int oldpid, idx;
 
 	local_irq_save(flags);
-	page &= (PAGE_MASK << 1);
 	oldpid = read_c0_entryhi();
+	page &= (PAGE_MASK << 1);
 	write_c0_entryhi(page);
 	mtc0_tlbw_hazard();
 	tlb_probe();
@@ -208,7 +219,7 @@ void local_flush_tlb_one(unsigned long p
 	write_c0_entrylo1(0);
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
-		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -227,6 +238,7 @@ void __update_tlb(struct vm_area_struct 
 {
 	unsigned long flags;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 	int idx, pid;
@@ -237,35 +249,34 @@ void __update_tlb(struct vm_area_struct 
 	if (current->active_mm != vma->vm_mm)
 		return;
 
-	pid = read_c0_entryhi() & ASID_MASK;
-
 	local_irq_save(flags);
+
+	pid = read_c0_entryhi() & ASID_MASK;
 	address &= (PAGE_MASK << 1);
 	write_c0_entryhi(address | pid);
 	pgdp = pgd_offset(vma->vm_mm, address);
 	mtc0_tlbw_hazard();
 	tlb_probe();
 	BARRIER;
-	pmdp = pmd_offset(pgdp, address);
+	pudp = pud_offset(pgdp, address);
+	pmdp = pmd_offset(pudp, address);
 	idx = read_c0_index();
 	ptep = pte_offset_map(pmdp, address);
 
- #if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
- 	write_c0_entrylo0(ptep->pte_high);
- 	ptep++;
- 	write_c0_entrylo1(ptep->pte_high);
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+	write_c0_entrylo0(ptep->pte_high);
+	ptep++;
+	write_c0_entrylo1(ptep->pte_high);
 #else
-  	write_c0_entrylo0(pte_val(*ptep++) >> 6);
-  	write_c0_entrylo1(pte_val(*ptep) >> 6);
+	write_c0_entrylo0(pte_val(*ptep++) >> 6);
+	write_c0_entrylo1(pte_val(*ptep) >> 6);
 #endif
-	write_c0_entryhi(address | pid);
 	mtc0_tlbw_hazard();
 	if (idx < 0)
 		tlb_write_random();
 	else
 		tlb_write_indexed();
 	tlbw_use_hazard();
-	write_c0_entryhi(pid);
 	local_irq_restore(flags);
 }
 
@@ -357,7 +368,8 @@ __init int add_temporary_entry(unsigned 
 	old_pagemask = read_c0_pagemask();
 	wired = read_c0_wired();
 	if (--temp_tlb_entry < wired) {
-		printk(KERN_WARNING "No TLB space left for add_temporary_entry\n");
+		printk(KERN_WARNING
+		       "No TLB space left for add_temporary_entry\n");
 		ret = -ENOSPC;
 		goto out;
 	}
@@ -388,7 +400,7 @@ static void __init probe_tlb(unsigned lo
 	 * is not supported, we assume R4k style.  Cpu probing already figured
 	 * out the number of tlb entries.
 	 */
-	if ((c->processor_id  & 0xff0000) == PRID_COMP_LEGACY)
+	if ((c->processor_id & 0xff0000) == PRID_COMP_LEGACY)
 		return;
 
 	reg = read_c0_config1();
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/tlb-sb1.c linux_HEAD/arch/mips/mm/tlb-sb1.c
--- linux-2.6.11.6/arch/mips/mm/tlb-sb1.c	2005-03-26 04:28:38.000000000 +0100
+++ linux_HEAD/arch/mips/mm/tlb-sb1.c	2005-04-01 16:07:44.000000000 +0200
@@ -94,7 +94,7 @@ void local_flush_tlb_all(void)
 
 	local_irq_save(flags);
 	/* Save old context and create impossible VPN2 value */
-	old_ctx = read_c0_entryhi() & ASID_MASK;
+	old_ctx = read_c0_entryhi();
 	write_c0_entrylo0(0);
 	write_c0_entrylo1(0);
 
@@ -144,17 +144,17 @@ void local_flush_tlb_range(struct vm_are
 	unsigned long end)
 {
 	struct mm_struct *mm = vma->vm_mm;
-	unsigned long flags;
-	int cpu;
+	int cpu = smp_processor_id();
 
-	local_irq_save(flags);
-	cpu = smp_processor_id();
 	if (cpu_context(cpu, mm) != 0) {
+		unsigned long flags;
 		int size;
+
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
+		local_irq_save(flags);
 		if (size <= (current_cpu_data.tlbsize/2)) {
-			int oldpid = read_c0_entryhi() & ASID_MASK;
+			int oldpid = read_c0_entryhi();
 			int newpid = cpu_asid(cpu, mm);
 
 			start &= (PAGE_MASK << 1);
@@ -169,17 +169,17 @@ void local_flush_tlb_range(struct vm_are
 				idx = read_c0_index();
 				write_c0_entrylo0(0);
 				write_c0_entrylo1(0);
-				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 				if (idx < 0)
 					continue;
+				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 				tlb_write_indexed();
 			}
 			write_c0_entryhi(oldpid);
 		} else {
 			drop_mmu_context(mm, cpu);
 		}
+		local_irq_restore(flags);
 	}
-	local_irq_restore(flags);
 }
 
 void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
@@ -189,7 +189,6 @@ void local_flush_tlb_kernel_range(unsign
 
 	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	size = (size + 1) >> 1;
-
 	local_irq_save(flags);
 	if (size <= (current_cpu_data.tlbsize/2)) {
 		int pid = read_c0_entryhi();
@@ -207,9 +206,9 @@ void local_flush_tlb_kernel_range(unsign
 			idx = read_c0_index();
 			write_c0_entrylo0(0);
 			write_c0_entrylo1(0);
-			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 			if (idx < 0)
 				continue;
+			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 			tlb_write_indexed();
 		}
 		write_c0_entryhi(pid);
@@ -221,15 +220,16 @@ void local_flush_tlb_kernel_range(unsign
 
 void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 {
-	unsigned long flags;
 	int cpu = smp_processor_id();
 
-	local_irq_save(flags);
 	if (cpu_context(cpu, vma->vm_mm) != 0) {
+		unsigned long flags;
 		int oldpid, newpid, idx;
+
 		newpid = cpu_asid(cpu, vma->vm_mm);
 		page &= (PAGE_MASK << 1);
-		oldpid = read_c0_entryhi() & ASID_MASK;
+		local_irq_save(flags);
+		oldpid = read_c0_entryhi();
 		write_c0_entryhi(page | newpid);
 		tlb_probe();
 		idx = read_c0_index();
@@ -240,10 +240,11 @@ void local_flush_tlb_page(struct vm_area
 		/* Make sure all entries differ. */
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
 		tlb_write_indexed();
+
 	finish:
 		write_c0_entryhi(oldpid);
+		local_irq_restore(flags);
 	}
-	local_irq_restore(flags);
 }
 
 /*
@@ -255,18 +256,17 @@ void local_flush_tlb_one(unsigned long p
 	unsigned long flags;
 	int oldpid, idx;
 
-	page &= (PAGE_MASK << 1);
-	oldpid = read_c0_entryhi() & ASID_MASK;
-
 	local_irq_save(flags);
+	oldpid = read_c0_entryhi();
+	page &= (PAGE_MASK << 1);
 	write_c0_entryhi(page);
 	tlb_probe();
 	idx = read_c0_index();
+	write_c0_entrylo0(0);
+	write_c0_entrylo1(0);
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
-		write_c0_entrylo0(0);
-		write_c0_entrylo1(0);
 		tlb_write_indexed();
 	}
 
@@ -297,6 +297,7 @@ void __update_tlb(struct vm_area_struct 
 {
 	unsigned long flags;
 	pgd_t *pgdp;
+	pud_t *pudp;
 	pmd_t *pmdp;
 	pte_t *ptep;
 	int idx, pid;
@@ -311,19 +312,26 @@ void __update_tlb(struct vm_area_struct 
 
 	pid = read_c0_entryhi() & ASID_MASK;
 	address &= (PAGE_MASK << 1);
-	write_c0_entryhi(address | (pid));
+	write_c0_entryhi(address | pid);
 	pgdp = pgd_offset(vma->vm_mm, address);
 	tlb_probe();
-	pmdp = pmd_offset(pgdp, address);
+	pudp = pud_offset(pgdp, address);
+	pmdp = pmd_offset(pudp, address);
 	idx = read_c0_index();
 	ptep = pte_offset_map(pmdp, address);
+
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+	write_c0_entrylo0(ptep->pte_high);
+	ptep++;
+	write_c0_entrylo1(ptep->pte_high);
+#else
 	write_c0_entrylo0(pte_val(*ptep++) >> 6);
 	write_c0_entrylo1(pte_val(*ptep) >> 6);
-	if (idx < 0) {
+#endif
+	if (idx < 0)
 		tlb_write_random();
-	} else {
+	else
 		tlb_write_indexed();
-	}
 	local_irq_restore(flags);
 }
 
@@ -336,7 +344,8 @@ void __init add_wired_entry(unsigned lon
 	unsigned long old_ctx;
 
 	local_irq_save(flags);
-	old_ctx = read_c0_entryhi() & 0xff;
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = read_c0_entryhi();
 	old_pagemask = read_c0_pagemask();
 	wired = read_c0_wired();
 	write_c0_wired(wired + 1);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/mm/tlbex.c linux_HEAD/arch/mips/mm/tlbex.c
--- linux-2.6.11.6/arch/mips/mm/tlbex.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/mm/tlbex.c	2005-03-21 20:03:47.000000000 +0100
@@ -91,7 +91,7 @@ enum opcode {
 	insn_addu, insn_addiu, insn_and, insn_andi, insn_beq,
 	insn_beql, insn_bgez, insn_bgezl, insn_bltz, insn_bltzl,
 	insn_bne, insn_daddu, insn_daddiu, insn_dmfc0, insn_dmtc0,
-	insn_dsll, insn_dsll32, insn_dsra, insn_dsrl, insn_dsrl32,
+	insn_dsll, insn_dsll32, insn_dsra, insn_dsrl,
 	insn_dsubu, insn_eret, insn_j, insn_jal, insn_jr, insn_ld,
 	insn_ll, insn_lld, insn_lui, insn_lw, insn_mfc0, insn_mtc0,
 	insn_ori, insn_rfe, insn_sc, insn_scd, insn_sd, insn_sll,
@@ -134,7 +134,6 @@ static __initdata struct insn insn_table
 	{ insn_dsll32, M(spec_op,0,0,0,0,dsll32_op), RT | RD | RE },
 	{ insn_dsra, M(spec_op,0,0,0,0,dsra_op), RT | RD | RE },
 	{ insn_dsrl, M(spec_op,0,0,0,0,dsrl_op), RT | RD | RE },
-	{ insn_dsrl32, M(spec_op,0,0,0,0,dsrl32_op), RT | RD | RE },
 	{ insn_dsubu, M(spec_op,0,0,0,0,dsubu_op), RS | RT | RD },
 	{ insn_eret, M(cop0_op,cop_op,0,0,0,eret_op), 0 },
 	{ insn_j, M(j_op,0,0,0,0,0), JIMM },
@@ -366,7 +365,6 @@ I_u2u1u3(_dsll);
 I_u2u1u3(_dsll32);
 I_u2u1u3(_dsra);
 I_u2u1u3(_dsrl);
-I_u2u1u3(_dsrl32);
 I_u3u1u2(_dsubu);
 I_0(_eret);
 I_u1(_j);
@@ -830,6 +828,7 @@ static __init void build_tlb_write_entry
 		i_nop(p);
 		break;
 
+	case CPU_R4300:
 	case CPU_R4600:
 	case CPU_R4700:
 	case CPU_R5000:
@@ -840,6 +839,7 @@ static __init void build_tlb_write_entry
 	case CPU_AU1100:
 	case CPU_AU1500:
 	case CPU_AU1550:
+	case CPU_AU1200:
 		i_nop(p);
 		tlbw(p);
 		break;
@@ -942,34 +942,29 @@ build_get_pmde64(u32 **p, struct label *
 	/* No i_nop needed here, since the next insn doesn't touch TMP. */
 
 #ifdef CONFIG_SMP
+# ifdef CONFIG_BUILD_ELF64
 	/*
-	 * 64 bit SMP has the lower part of &pgd_current[smp_processor_id()]
+	 * 64 bit SMP running in XKPHYS has smp_processor_id() << 3
 	 * stored in CONTEXT.
 	 */
-	if (in_compat_space_p(pgdc)) {
-		i_dmfc0(p, ptr, C0_CONTEXT);
-		i_dsra(p, ptr, ptr, 23);
-		i_ld(p, ptr, 0, ptr);
-	} else {
-#ifdef CONFIG_BUILD_ELF64
-		i_dmfc0(p, ptr, C0_CONTEXT);
-		i_dsrl(p, ptr, ptr, 23);
-		i_dsll(p, ptr, ptr, 3);
-		i_LA_mostly(p, tmp, pgdc);
-		i_daddu(p, ptr, ptr, tmp);
-		i_dmfc0(p, tmp, C0_BADVADDR);
-		i_ld(p, ptr, rel_lo(pgdc), ptr);
-#else
-		i_dmfc0(p, ptr, C0_CONTEXT);
-		i_lui(p, tmp, rel_highest(pgdc));
-		i_dsll(p, ptr, ptr, 9);
-		i_daddiu(p, tmp, tmp, rel_higher(pgdc));
-		i_dsrl32(p, ptr, ptr, 0);
-		i_and(p, ptr, ptr, tmp);
-		i_dmfc0(p, tmp, C0_BADVADDR);
-		i_ld(p, ptr, 0, ptr);
-#endif
-	}
+	i_dmfc0(p, ptr, C0_CONTEXT);
+	i_dsrl(p, ptr, ptr, 23);
+	i_LA_mostly(p, tmp, pgdc);
+	i_daddu(p, ptr, ptr, tmp);
+	i_dmfc0(p, tmp, C0_BADVADDR);
+	i_ld(p, ptr, rel_lo(pgdc), ptr);
+# else
+	/*
+	 * 64 bit SMP running in compat space has the lower part of
+	 * &pgd_current[smp_processor_id()] stored in CONTEXT.
+	 */
+	if (!in_compat_space_p(pgdc))
+		panic("Invalid page directory address!");
+
+	i_dmfc0(p, ptr, C0_CONTEXT);
+	i_dsra(p, ptr, ptr, 23);
+	i_ld(p, ptr, 0, ptr);
+# endif
 #else
 	i_LA_mostly(p, ptr, pgdc);
 	i_ld(p, ptr, rel_lo(pgdc), ptr);
@@ -1026,7 +1021,6 @@ build_get_pgde32(u32 **p, unsigned int t
 	i_mfc0(p, ptr, C0_CONTEXT);
 	i_LA_mostly(p, tmp, pgdc);
 	i_srl(p, ptr, ptr, 23);
-	i_sll(p, ptr, ptr, 2);
 	i_addu(p, ptr, tmp, ptr);
 #else
 	i_LA_mostly(p, ptr, pgdc);
@@ -1256,7 +1250,7 @@ static void __init build_r4000_tlb_refil
 
 /*
  * TLB load/store/modify handlers.
- *
+ * 
  * Only the fastpath gets synthesized at runtime, the slowpath for
  * do_page_fault remains normal asm.
  */
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/momentum/Kconfig linux_HEAD/arch/mips/momentum/Kconfig
--- linux-2.6.11.6/arch/mips/momentum/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/momentum/Kconfig	2005-01-30 21:45:37.000000000 +0100
@@ -0,0 +1,6 @@
+config JAGUAR_DMALOW
+	bool "Low DMA Mode"
+	depends on MOMENCO_JAGUAR_ATX
+	help
+	  Select to Y if jump JP5 is set on your board, N otherwise.  Normally
+	  the jumper is set, so if you feel unsafe, just say Y.
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/momentum/ocelot_c/cpci-irq.c linux_HEAD/arch/mips/momentum/ocelot_c/cpci-irq.c
--- linux-2.6.11.6/arch/mips/momentum/ocelot_c/cpci-irq.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/momentum/ocelot_c/cpci-irq.c	2005-02-28 16:56:42.000000000 +0100
@@ -129,14 +129,13 @@ void ll_cpci_irq(struct pt_regs *regs)
 #define shutdown_cpci_irq	disable_cpci_irq
 
 struct hw_interrupt_type cpci_irq_type = {
-	"CPCI/FPGA",
-	startup_cpci_irq,
-	shutdown_cpci_irq,
-	enable_cpci_irq,
-	disable_cpci_irq,
-	mask_and_ack_cpci_irq,
-	end_cpci_irq,
-	NULL
+	.typename = "CPCI/FPGA",
+	.startup = startup_cpci_irq,
+	.shutdown = shutdown_cpci_irq,
+	.enable = enable_cpci_irq,
+	.disable = disable_cpci_irq,
+	.ack = mask_and_ack_cpci_irq,
+	.end = end_cpci_irq,
 };
 
 void cpci_irq_init(void)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/momentum/ocelot_c/uart-irq.c linux_HEAD/arch/mips/momentum/ocelot_c/uart-irq.c
--- linux-2.6.11.6/arch/mips/momentum/ocelot_c/uart-irq.c	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/arch/mips/momentum/ocelot_c/uart-irq.c	2005-02-28 16:56:42.000000000 +0100
@@ -122,14 +122,13 @@ void ll_uart_irq(struct pt_regs *regs)
 #define shutdown_uart_irq	disable_uart_irq
 
 struct hw_interrupt_type uart_irq_type = {
-	"UART/FPGA",
-	startup_uart_irq,
-	shutdown_uart_irq,
-	enable_uart_irq,
-	disable_uart_irq,
-	mask_and_ack_uart_irq,
-	end_uart_irq,
-	NULL
+	.typename = "UART/FPGA",
+	.startup = startup_uart_irq,
+	.shutdown = shutdown_uart_irq,
+	.enable = enable_uart_irq,
+	.disable = disable_uart_irq,
+	.ack = mask_and_ack_uart_irq,
+	.end = end_uart_irq,
 };
 
 void uart_irq_init(void)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/oprofile/Kconfig linux_HEAD/arch/mips/oprofile/Kconfig
--- linux-2.6.11.6/arch/mips/oprofile/Kconfig	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/arch/mips/oprofile/Kconfig	2004-12-12 03:22:46.000000000 +0100
@@ -7,7 +7,7 @@ config PROFILING
 	help
 	  Say Y here to enable the extended profiling support mechanisms used
 	  by profilers such as OProfile.
-
+	  
 
 config OPROFILE
 	tristate "OProfile system profiling (EXPERIMENTAL)"
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/oprofile/common.c linux_HEAD/arch/mips/oprofile/common.c
--- linux-2.6.11.6/arch/mips/oprofile/common.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/oprofile/common.c	2005-02-17 21:48:57.000000000 +0100
@@ -68,9 +68,18 @@ static void op_mips_stop(void)
 	on_each_cpu(model->cpu_stop, NULL, 0, 1);
 }
 
-void __init oprofile_arch_init(struct oprofile_operations *ops)
+static struct oprofile_operations oprof_mips_ops = {
+	.create_files	= op_mips_create_files,
+	.setup		= op_mips_setup,
+	.start		= op_mips_start,
+	.stop		= op_mips_stop,
+	.cpu_type	= NULL
+};
+
+int __init oprofile_arch_init(struct oprofile_operations **ops)
 {
 	struct op_mips_model *lmodel = NULL;
+	int res;
 
 	switch (current_cpu_data.cputype) {
 	case CPU_24K:
@@ -83,21 +92,21 @@ void __init oprofile_arch_init(struct op
 	};
 
 	if (!lmodel)
-		return;
+		return -ENODEV;
 
-	if (lmodel->init())
-		return;
+	res = lmodel->init();
+	if (res)
+		return res;
 
 	model = lmodel;
 
-	ops->create_files = op_mips_create_files;
-	ops->setup = op_mips_setup;
-	ops->start = op_mips_start;
-	ops->stop = op_mips_stop;
-	ops->cpu_type = lmodel->cpu_type;
+	oprof_mips_ops.cpu_type = lmodel->cpu_type;
+	*ops = &oprof_mips_ops;
 
 	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
 	       lmodel->cpu_type);
+
+	return 0;
 }
 
 void oprofile_arch_exit(void)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/oprofile/op_model_rm9000.c linux_HEAD/arch/mips/oprofile/op_model_rm9000.c
--- linux-2.6.11.6/arch/mips/oprofile/op_model_rm9000.c	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/arch/mips/oprofile/op_model_rm9000.c	2005-02-17 21:48:57.000000000 +0100
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 2004 by Ralf Baechle
  */
+#include <linux/init.h>
 #include <linux/oprofile.h>
 #include <linux/interrupt.h>
 #include <linux/smp.h>
@@ -114,7 +115,7 @@ static irqreturn_t rm9000_perfcount_hand
 	return IRQ_HANDLED;
 }
 
-static int rm9000_init(void)
+static int __init rm9000_init(void)
 {
 	return request_irq(rm9000_perfcount_irq, rm9000_perfcount_handler,
 	                   0, "Perfcounter", NULL);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/fixup-atlas.c linux_HEAD/arch/mips/pci/fixup-atlas.c
--- linux-2.6.11.6/arch/mips/pci/fixup-atlas.c	2005-03-26 04:28:39.000000000 +0100
+++ linux_HEAD/arch/mips/pci/fixup-atlas.c	2005-02-17 21:48:57.000000000 +0100
@@ -1,14 +1,37 @@
+/*
+ * Copyright (C) 2003, 2004  Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Author:	 Maciej W. Rozycki <macro@mips.com>
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
 #include <linux/config.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+
 #include <asm/mips-boards/atlasint.h>
 
-#define INTD		ATLASINT_INTD
-#define INTC		ATLASINT_INTC
-#define INTB		ATLASINT_INTB
+#define PCIA		ATLASINT_PCIA
+#define PCIB		ATLASINT_PCIB
+#define PCIC		ATLASINT_PCIC
+#define PCID		ATLASINT_PCID
 #define INTA		ATLASINT_INTA
-#define SCSI		ATLASINT_SCSI
+#define INTB		ATLASINT_INTB
 #define ETH		ATLASINT_ETH
+#define INTC		ATLASINT_INTC
+#define SCSI		ATLASINT_SCSI
+#define INTD		ATLASINT_INTD
 
 static char irq_tab[][5] __initdata = {
 	/*      INTA    INTB    INTC    INTD */
@@ -27,13 +50,13 @@ static char irq_tab[][5] __initdata = {
 	{0,	0,	0,	0,	0 },	/* 12: Unused */
 	{0,	0,	0,	0,	0 },	/* 13: Unused */
 	{0,	0,	0,	0,	0 },	/* 14: Unused */
-	{0,	0,	0,	0,	0 },	/* 15: Unused */
+	{0,	PCIA,	PCIB,	PCIC,	PCID },	/* 15: cPCI (behind 21150) */
 	{0,	SCSI,	0,	0,	0 },	/* 16: SYM53C810A SCSI */
 	{0,	0,	0,	0,	0 },	/* 17: Core */
-	{0,	INTA,	INTB,	INTC,	INTD },	/* 18: PCI Slot 1 */
-	{0,	ETH,	0,	0,	0 },	/* 19: SAA9730 Ethernet */
-	{0,	0,	0,	0,	0 },	/* 20: PCI Slot 3 */
-	{0,	0,	0,	0,	0 }	/* 21: PCI Slot 4 */
+	{0,	INTA,	INTB,	INTC,	INTD },	/* 18: PCI Slot */
+	{0,	ETH,	0,	0,	0 },	/* 19: SAA9730 Eth. et al. */
+	{0,	0,	0,	0,	0 },	/* 20: Unused */
+	{0,	0,	0,	0,	0 }	/* 21: Unused */
 };
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/fixup-au1000.c linux_HEAD/arch/mips/pci/fixup-au1000.c
--- linux-2.6.11.6/arch/mips/pci/fixup-au1000.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/pci/fixup-au1000.c	2005-03-01 15:00:12.000000000 +0100
@@ -34,82 +34,7 @@
 
 #include <asm/mach-au1x00/au1000.h>
 
-/*
- * Shortcut
- */
-#ifdef CONFIG_SOC_AU1500
-#define INTA AU1000_PCI_INTA
-#define INTB AU1000_PCI_INTB
-#define INTC AU1000_PCI_INTC
-#define INTD AU1000_PCI_INTD
-#endif
-
-#ifdef CONFIG_SOC_AU1550
-#define INTA AU1550_PCI_INTA
-#define INTB AU1550_PCI_INTB
-#define INTC AU1550_PCI_INTC
-#define INTD AU1550_PCI_INTD
-#endif
-
-#define INTX    0xFF /* not valid */
-
-#ifdef CONFIG_MIPS_DB1500
-static char irq_tab_alchemy[][5] __initdata = {
- [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT371   */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
-};
-#endif
-
-#ifdef CONFIG_MIPS_BOSPORUS
-static char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 11 - miniPCI  */
- [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - SN1741   */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
-};
-#endif
-
-#ifdef CONFIG_MIPS_MIRAGE
-static char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTD, INTX, INTX, INTX},   /* IDSEL 11 - SMI VGX */
- [12] =	{ -1, INTX, INTX, INTC, INTX},   /* IDSEL 12 - PNX1300 */
- [13] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 13 - miniPCI */
-};
-#endif
-
-#ifdef CONFIG_MIPS_DB1550
-static char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTC, INTX, INTX, INTX},   /* IDSEL 11 - on-board HPT371    */
- [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
-};
-#endif
-
-#ifdef CONFIG_MIPS_PB1500
-static char irq_tab_alchemy[][5] __initdata = {
- [12] = { -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT370   */
- [13] = { -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
-};
-#endif
-
-#ifdef CONFIG_MIPS_PB1550
-static char irq_tab_alchemy[][5] __initdata = {
- [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
-};
-#endif
-
-#ifdef CONFIG_MIPS_MTX1
-static char irq_tab_alchemy[][5] __initdata = {
- [0] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 00 - AdapterA-Slot0 (top)    */
- [1] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 01 - AdapterA-Slot1 (bottom) */
- [2] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 02 - AdapterB-Slot0 (top)    */
- [3] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 03 - AdapterB-Slot1 (bottom) */
- [4] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 04 - AdapterC-Slot0 (top)    */
- [5] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 05 - AdapterC-Slot1 (bottom) */
- [6] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 06 - AdapterD-Slot0 (top)    */
- [7] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 07 - AdapterD-Slot1 (bottom) */
-};
-#endif
+extern char irq_tab_alchemy[][5];
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/fixup-cobalt.c linux_HEAD/arch/mips/pci/fixup-cobalt.c
--- linux-2.6.11.6/arch/mips/pci/fixup-cobalt.c	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/arch/mips/pci/fixup-cobalt.c	2005-03-04 20:36:08.000000000 +0100
@@ -21,6 +21,20 @@
 
 extern int cobalt_board_id;
 
+static void qube_raq_galileo_early_fixup(struct pci_dev *dev)
+{
+	if (dev->devfn == PCI_DEVFN(0, 0) &&
+		(dev->class >> 8) == PCI_CLASS_MEMORY_OTHER) {
+
+		dev->class = (PCI_CLASS_BRIDGE_HOST << 8) | (dev->class & 0xff);
+
+		printk(KERN_INFO "Galileo: fixed bridge class\n");
+	}
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_MARVELL, PCI_DEVICE_ID_MARVELL_GT64111,
+	 qube_raq_galileo_early_fixup);
+
 static void qube_raq_via_bmIDE_fixup(struct pci_dev *dev)
 {
 	unsigned short cfgword;
@@ -48,6 +62,9 @@ static void qube_raq_galileo_fixup(struc
 {
 	unsigned short galileo_id;
 
+	if (dev->devfn != PCI_DEVFN(0, 0))
+		return;
+		
 	/* Fix PCI latency-timer and cache-line-size values in Galileo
 	 * host bridge.
 	 */
@@ -55,6 +72,13 @@ static void qube_raq_galileo_fixup(struc
 	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 7);
 
 	/*
+	 * The code described by the comment below has been removed
+	 * as it causes bus mastering by the Ethernet controllers
+	 * to break under any kind of network load. We always set
+	 * the retry timeouts to their maximum.
+	 *
+	 * --x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--x--
+	 *
 	 * On all machines prior to Q2, we had the STOP line disconnected
 	 * from Galileo to VIA on PCI.  The new Galileo does not function
 	 * correctly unless we have it connected.
@@ -64,10 +88,16 @@ static void qube_raq_galileo_fixup(struc
 	 */
 	pci_read_config_word(dev, PCI_REVISION_ID, &galileo_id);
 	galileo_id &= 0xff;	/* mask off class info */
+
+ 	printk(KERN_INFO "Galileo: revision %u\n", galileo_id);
+
+#if 0
 	if (galileo_id >= 0x10) {
 		/* New Galileo, assumes PCI stop line to VIA is connected. */
 		GALILEO_OUTL(0x4020, GT_PCI0_TOR_OFS);
-	} else if (galileo_id == 0x1 || galileo_id == 0x2) {
+	} else if (galileo_id == 0x1 || galileo_id == 0x2)
+#endif
+	{
 		signed int timeo;
 		/* XXX WE MUST DO THIS ELSE GALILEO LOCKS UP! -DaveM */
 		timeo = GALILEO_INL(GT_PCI0_TOR_OFS);
@@ -76,9 +106,18 @@ static void qube_raq_galileo_fixup(struc
 	}
 }
 
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_GALILEO, PCI_ANY_ID,
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_MARVELL, PCI_DEVICE_ID_MARVELL_GT64111,
 	 qube_raq_galileo_fixup);
 
+static char irq_tab_qube1[] __initdata = {
+  [COBALT_PCICONF_CPU]     = 0,
+  [COBALT_PCICONF_ETH0]    = COBALT_QUBE1_ETH0_IRQ,
+  [COBALT_PCICONF_RAQSCSI] = COBALT_SCSI_IRQ,
+  [COBALT_PCICONF_VIA]     = 0,
+  [COBALT_PCICONF_PCISLOT] = COBALT_QUBE_SLOT_IRQ,
+  [COBALT_PCICONF_ETH1]    = 0
+};
+
 static char irq_tab_cobalt[] __initdata = {
   [COBALT_PCICONF_CPU]     = 0,
   [COBALT_PCICONF_ETH0]    = COBALT_ETH0_IRQ,
@@ -99,6 +138,9 @@ static char irq_tab_raq2[] __initdata = 
 
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
+	if (cobalt_board_id < COBALT_BRD_ID_QUBE2)
+		return irq_tab_qube1[slot];
+
 	if (cobalt_board_id == COBALT_BRD_ID_RAQ2)
 		return irq_tab_raq2[slot];
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/fixup-vr4133.c linux_HEAD/arch/mips/pci/fixup-vr4133.c
--- linux-2.6.11.6/arch/mips/pci/fixup-vr4133.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/pci/fixup-vr4133.c	2004-12-15 15:08:18.000000000 +0100
@@ -11,9 +11,9 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
- * Modified for support in 2.6
+ * Modified for support in 2.6 
  * Author: Manish Lachwani (mlachwani@mvista.com)
- *
+ * 
  */
 #include <linux/config.h>
 #include <linux/init.h>
@@ -29,21 +29,21 @@ extern void ali_m5229_init(struct pci_de
 /* Do platform specific device initialization at pci_enable_device() time */
 int pcibios_plat_dev_init(struct pci_dev *dev)
 {
-	/*
+	/* 
 	 * We have to reset AMD PCnet adapter on Rockhopper since
 	 * PMON leaves it enabled and generating interrupts. This leads
 	 * to a lock if some PCI device driver later enables the IRQ line
 	 * shared with PCnet and there is no AMD PCnet driver to catch its
-	 * interrupts.
+	 * interrupts. 
 	 */
 #ifdef CONFIG_ROCKHOPPER
-	if (dev->vendor == PCI_VENDOR_ID_AMD &&
+	if (dev->vendor == PCI_VENDOR_ID_AMD && 
 		dev->device == PCI_DEVICE_ID_AMD_LANCE) {
 		inl(pci_resource_start(dev, 0) + 0x18);
 	}
 #endif
 
-	/*
+	/* 
 	 * we have to open the bridges' windows down to 0 because otherwise
  	 * we cannot access ISA south bridge I/O registers that get mapped from
 	 * 0. for example, 8259 PIC would be unaccessible without that
@@ -60,8 +60,8 @@ int pcibios_plat_dev_init(struct pci_dev
 	return 0;
 }
 
-/*
- * M1535 IRQ mapping
+/* 
+ * M1535 IRQ mapping 
  * Feel free to change this, although it shouldn't be needed
  */
 #define M1535_IRQ_INTA  7
@@ -124,7 +124,7 @@ static struct irq_map_entry int_map[] = 
 	{1, ROCKHOPPER_PCI2_SLOT, M1535_IRQ_INTC},	/* PCI slot #2 */
 	{1, ROCKHOPPER_M5237_SLOT, M1535_IRQ_USB},	/* USB host controller */
 	{1, ROCKHOPPER_M5229_SLOT, IDE_PRIMARY_IRQ},	/* IDE controller */
-	{2, ROCKHOPPER_PCNET_SLOT, M1535_IRQ_INTD},	/* AMD Am79c973 on-board
+	{2, ROCKHOPPER_PCNET_SLOT, M1535_IRQ_INTD},	/* AMD Am79c973 on-board 
 							   ethernet */
 	{2, ROCKHOPPER_PCI3_SLOT, M1535_IRQ_INTB},	/* PCI slot #3 */
 	{2, ROCKHOPPER_PCI4_SLOT, M1535_IRQ_INTC}	/* PCI slot #4 */
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/ops-au1000.c linux_HEAD/arch/mips/pci/ops-au1000.c
--- linux-2.6.11.6/arch/mips/pci/ops-au1000.c	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/arch/mips/pci/ops-au1000.c	2005-02-28 16:56:42.000000000 +0100
@@ -50,11 +50,6 @@
 
 int (*board_pci_idsel)(unsigned int devsel, int assert);
 
-/* CP0 hazard avoidance. */
-#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
-				     "nop; nop; nop; nop;\t" \
-				     ".set reorder\n\t")
-
 void mod_wired_entry(int entry, unsigned long entrylo0,
 		unsigned long entrylo1, unsigned long entryhi,
 		unsigned long pagemask)
@@ -66,16 +61,12 @@ void mod_wired_entry(int entry, unsigned
 	old_ctx = read_c0_entryhi() & 0xff;
 	old_pagemask = read_c0_pagemask();
 	write_c0_index(entry);
-	BARRIER;
 	write_c0_pagemask(pagemask);
 	write_c0_entryhi(entryhi);
 	write_c0_entrylo0(entrylo0);
 	write_c0_entrylo1(entrylo1);
-	BARRIER;
 	tlb_write_indexed();
-	BARRIER;
 	write_c0_entryhi(old_ctx);
-	BARRIER;
 	write_c0_pagemask(old_pagemask);
 }
 
@@ -128,9 +119,8 @@ static int config_access(unsigned char a
 		last_entryLo0  = last_entryLo1 = 0xffffffff;
 	}
 
-	/* Since the Au1xxx doesn't do the idsel timing exactly to spec,
-	 * many board vendors implement their own off-chip idsel, so call
-	 * it now.  If it doesn't succeed, may as well bail out at this point.
+	/* Allow board vendors to implement their own off-chip idsel.  
+	 * If it doesn't succeed, may as well bail out at this point.
 	 */
 	if (board_pci_idsel) {
 		if (board_pci_idsel(device, 1) == 0) {
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/ops-bonito64.c linux_HEAD/arch/mips/pci/ops-bonito64.c
--- linux-2.6.11.6/arch/mips/pci/ops-bonito64.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/pci/ops-bonito64.c	2005-02-17 21:48:57.000000000 +0100
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -57,13 +59,6 @@ static int bonito64_pcibios_config_acces
 		return -1;
 	}
 
-#ifdef CONFIG_MIPS_BOARDS_GEN
-	if ((busnum == 0) && (PCI_SLOT(devfn) == 17)) {
-		/* MIPS Core boards have Bonito connected as device 17 */
-		return -1;
-	}
-#endif
-
 	/* Clear cause register bits */
 	BONITO_PCICMD |= (BONITO_PCICMD_MABORT_CLR |
 			  BONITO_PCICMD_MTABORT_CLR);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/ops-gt64111.c linux_HEAD/arch/mips/pci/ops-gt64111.c
--- linux-2.6.11.6/arch/mips/pci/ops-gt64111.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/pci/ops-gt64111.c	2005-03-04 20:36:08.000000000 +0100
@@ -20,13 +20,21 @@
 /*
  * Accessing device 31 hangs the GT64120.  Not sure if this will also hang
  * the GT64111, let's be paranoid for now.
+ *
+ * Accessing device COBALT_PCICONF_CPU hangs early units.
  */
 static inline int pci_range_ck(struct pci_bus *bus, unsigned int devfn)
 {
-	if (bus->number == 0 && devfn == PCI_DEVFN(31, 0))
-		return -1;
+	unsigned slot;
 
-	return 0;
+	if (bus->number == 0) {
+
+		slot = PCI_SLOT(devfn);
+		if (slot != COBALT_PCICONF_CPU && slot < 31)
+			return 0;
+	}
+
+	return -1;
 }
 
 static int gt64111_pci_read_config(struct pci_bus *bus, unsigned int devfn,
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/ops-gt64120.c linux_HEAD/arch/mips/pci/ops-gt64120.c
--- linux-2.6.11.6/arch/mips/pci/ops-gt64120.c	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/arch/mips/pci/ops-gt64120.c	2005-02-17 21:48:57.000000000 +0100
@@ -1,6 +1,8 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 1999, 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 1999, 2000, 2004  MIPS Technologies, Inc.
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -43,10 +45,6 @@ static int gt64120_pcibios_config_access
 	unsigned char busnum = bus->number;
 	u32 intr;
 
-	if ((busnum == 0) && (PCI_SLOT(devfn) == 0))
-		/* Galileo itself is devfn 0, don't move it around */
-		return -1;
-
 	if ((busnum == 0) && (devfn >= PCI_DEVFN(31, 0)))
 		return -1;	/* Because of a bug in the galileo (for slot 31). */
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/ops-msc.c linux_HEAD/arch/mips/pci/ops-msc.c
--- linux-2.6.11.6/arch/mips/pci/ops-msc.c	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/arch/mips/pci/ops-msc.c	2005-02-17 21:48:57.000000000 +0100
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 1999, 2000, 2004, 2005  MIPS Technologies, Inc.
- *    All rights reserved.
- *    Authors: Carsten Langgaard <carstenl@mips.com>
- *             Maciej W. Rozycki <macro@mips.com>
+ *	All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can distribute it and/or modify it
@@ -49,34 +49,17 @@ static int msc_pcibios_config_access(uns
 	struct pci_bus *bus, unsigned int devfn, int where, u32 * data)
 {
 	unsigned char busnum = bus->number;
-	unsigned char type;
 	u32 intr;
 
-#ifdef CONFIG_MIPS_BOARDS_GEN
-	if ((busnum == 0) && (PCI_SLOT(devfn) == 17)) {
-		/* MIPS Core boards have SOCit connected as device 17 */
-		return -1;
-	}
-#endif
-
 	/* Clear status register bits. */
 	MSC_WRITE(MSC01_PCI_INTSTAT,
 		  (MSC01_PCI_INTCFG_MA_BIT | MSC01_PCI_INTCFG_TA_BIT));
 
-	/* Setup address */
-	if (busnum == 0)
-		type = 0;	/* Type 0 */
-	else
-		type = 1;	/* Type 1 */
-
 	MSC_WRITE(MSC01_PCI_CFGADDR,
 		  ((busnum << MSC01_PCI_CFGADDR_BNUM_SHF) |
-		   (PCI_SLOT(devfn) << MSC01_PCI_CFGADDR_DNUM_SHF)
-		   | (PCI_FUNC(devfn) <<
-		      MSC01_PCI_CFGADDR_FNUM_SHF) | ((where /
-						      4) <<
-						     MSC01_PCI_CFGADDR_RNUM_SHF)
-		   | (type)));
+		   (PCI_SLOT(devfn) << MSC01_PCI_CFGADDR_DNUM_SHF) |
+		   (PCI_FUNC(devfn) << MSC01_PCI_CFGADDR_FNUM_SHF) |
+		   ((where / 4) << MSC01_PCI_CFGADDR_RNUM_SHF)));
 
 	/* Perform access */
 	if (access_type == PCI_ACCESS_WRITE)
@@ -86,15 +69,12 @@ static int msc_pcibios_config_access(uns
 
 	/* Detect Master/Target abort */
 	MSC_READ(MSC01_PCI_INTSTAT, intr);
-	if (intr & (MSC01_PCI_INTCFG_MA_BIT |
-		    MSC01_PCI_INTCFG_TA_BIT)) {
+	if (intr & (MSC01_PCI_INTCFG_MA_BIT | MSC01_PCI_INTCFG_TA_BIT)) {
 		/* Error occurred */
 
 		/* Clear bits */
-		MSC_READ(MSC01_PCI_INTSTAT, intr);
 		MSC_WRITE(MSC01_PCI_INTSTAT,
-			  (MSC01_PCI_INTCFG_MA_BIT |
-			   MSC01_PCI_INTCFG_TA_BIT));
+			  (MSC01_PCI_INTCFG_MA_BIT | MSC01_PCI_INTCFG_TA_BIT));
 
 		return -1;
 	}
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/ops-tx4927.c linux_HEAD/arch/mips/pci/ops-tx4927.c
--- linux-2.6.11.6/arch/mips/pci/ops-tx4927.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/pci/ops-tx4927.c	2005-02-17 21:48:57.000000000 +0100
@@ -120,7 +120,7 @@ static int tx4927_pcibios_read_config(st
 	switch (size) {
 	case 1:
 		*val = *(volatile u8 *) ((ulong) & tx4927_pcicptr->
-                              g2pcfgdata |
+                              g2pcfgdata | 
 #ifdef __LITTLE_ENDIAN
 						(where & 3));
 #else
@@ -129,7 +129,7 @@ static int tx4927_pcibios_read_config(st
 		break;
 	case 2:
 		*val = *(volatile u16 *) ((ulong) & tx4927_pcicptr->
-                               g2pcfgdata |
+                               g2pcfgdata | 
 #ifdef __LITTLE_ENDIAN
 						(where & 3));
 #else
@@ -169,7 +169,7 @@ static int tx4927_pcibios_write_config(s
 	switch (size) {
 	case 1:
 		 *(volatile u8 *) ((ulong) & tx4927_pcicptr->
-                          g2pcfgdata |
+                          g2pcfgdata | 
 #ifdef __LITTLE_ENDIAN
 					(where & 3)) = val;
 #else
@@ -179,7 +179,7 @@ static int tx4927_pcibios_write_config(s
 
 	case 2:
 		*(volatile u16 *) ((ulong) & tx4927_pcicptr->
-                           g2pcfgdata |
+                           g2pcfgdata | 
 #ifdef __LITTLE_ENDIAN
 					(where & 3)) = val;
 #else
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/ops-vr41xx.c linux_HEAD/arch/mips/pci/ops-vr41xx.c
--- linux-2.6.11.6/arch/mips/pci/ops-vr41xx.c	2005-03-26 04:28:25.000000000 +0100
+++ linux_HEAD/arch/mips/pci/ops-vr41xx.c	2005-03-09 22:46:10.000000000 +0100
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2001-2003 MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -29,8 +29,8 @@
 
 #include <asm/io.h>
 
-#define PCICONFDREG	KSEG1ADDR(0x0f000c14)
-#define PCICONFAREG	KSEG1ADDR(0x0f000c18)
+#define PCICONFDREG	(void __iomem *)KSEG1ADDR(0x0f000c14)
+#define PCICONFAREG	(void __iomem *)KSEG1ADDR(0x0f000c18)
 
 static inline int set_pci_configuration_address(unsigned char number,
                                                 unsigned int devfn, int where)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/pci-ip32.c linux_HEAD/arch/mips/pci/pci-ip32.c
--- linux-2.6.11.6/arch/mips/pci/pci-ip32.c	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/arch/mips/pci/pci-ip32.c	2005-02-01 13:09:52.000000000 +0100
@@ -136,7 +136,9 @@ static int __init mace_init(void)
 	BUG_ON(request_irq(MACE_PCI_BRIDGE_IRQ, macepci_error, 0,
 			   "MACE PCI error", NULL));
 
-	ioport_resource.end = mace_pci_io_resource.end;
+	iomem_resource = mace_pci_mem_resource;
+	ioport_resource = mace_pci_io_resource;
+
 	register_pci_controller(&mace_pci_controller);
 
 	return 0;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/pci-vr41xx.c linux_HEAD/arch/mips/pci/pci-vr41xx.c
--- linux-2.6.11.6/arch/mips/pci/pci-vr41xx.c	2005-04-02 23:39:54.000000000 +0200
+++ linux_HEAD/arch/mips/pci/pci-vr41xx.c	2005-03-09 22:46:11.000000000 +0100
@@ -3,8 +3,8 @@
  *
  *  Copyright (C) 2001-2003 MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -31,12 +31,18 @@
 
 #include <asm/cpu.h>
 #include <asm/io.h>
+#include <asm/vr41xx/pci.h>
 #include <asm/vr41xx/vr41xx.h>
 
 #include "pci-vr41xx.h"
 
 extern struct pci_ops vr41xx_pci_ops;
 
+static void __iomem *pciu_base;
+
+#define pciu_read(offset)		readl(pciu_base + (offset))
+#define pciu_write(offset, value)	writel((value), pciu_base + (offset))
+
 static struct pci_master_address_conversion pci_master_memory1 = {
 	.bus_base_address	= PCI_MASTER_MEM1_BUS_BASE_ADDRESS,
 	.address_mask		= PCI_MASTER_MEM1_ADDRESS_MASK,
@@ -113,6 +119,13 @@ static int __init vr41xx_pciu_init(void)
 
 	setup = &vr41xx_pci_controller_unit_setup;
 
+	if (request_mem_region(PCIU_BASE, PCIU_SIZE, "PCIU") == NULL)
+		return -EBUSY;
+
+	pciu_base = ioremap(PCIU_BASE, PCIU_SIZE);
+	if (pciu_base == NULL)
+		return -EBUSY;
+
 	/* Disable PCI interrupt */
 	vr41xx_disable_pciint();
 
@@ -129,14 +142,14 @@ static int __init vr41xx_pciu_init(void)
 		pci_clock_max = PCI_CLOCK_MAX;
 	vtclock = vr41xx_get_vtclock_frequency();
 	if (vtclock < pci_clock_max)
-		writel(EQUAL_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, EQUAL_VTCLOCK);
 	else if ((vtclock / 2) < pci_clock_max)
-		writel(HALF_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, HALF_VTCLOCK);
 	else if (current_cpu_data.processor_id >= PRID_VR4131_REV2_1 &&
 	         (vtclock / 3) < pci_clock_max)
-		writel(ONE_THIRD_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, ONE_THIRD_VTCLOCK);
 	else if ((vtclock / 4) < pci_clock_max)
-		writel(QUARTER_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, QUARTER_VTCLOCK);
 	else {
 		printk(KERN_ERR "PCI Clock is over 33MHz.\n");
 		return -EINVAL;
@@ -151,11 +164,11 @@ static int __init vr41xx_pciu_init(void)
 		      MASTER_MSK(master->address_mask) |
 		      WINEN |
 		      PCIA(master->pci_base_address);
-		writel(val, PCIMMAW1REG);
+		pciu_write(PCIMMAW1REG, val);
 	} else {
-		val = readl(PCIMMAW1REG);
+		val = pciu_read(PCIMMAW1REG);
 		val &= ~WINEN;
-		writel(val, PCIMMAW1REG);
+		pciu_write(PCIMMAW1REG, val);
 	}
 
 	if (setup->master_memory2 != NULL) {
@@ -164,11 +177,11 @@ static int __init vr41xx_pciu_init(void)
 		      MASTER_MSK(master->address_mask) |
 		      WINEN |
 		      PCIA(master->pci_base_address);
-		writel(val, PCIMMAW2REG);
+		pciu_write(PCIMMAW2REG, val);
 	} else {
-		val = readl(PCIMMAW2REG);
+		val = pciu_read(PCIMMAW2REG);
 		val &= ~WINEN;
-		writel(val, PCIMMAW2REG);
+		pciu_write(PCIMMAW2REG, val);
 	}
 
 	if (setup->target_memory1 != NULL) {
@@ -176,11 +189,11 @@ static int __init vr41xx_pciu_init(void)
 		val = TARGET_MSK(target->address_mask) |
 		      WINEN |
 		      ITA(target->bus_base_address);
-		writel(val, PCITAW1REG);
+		pciu_write(PCITAW1REG, val);
 	} else {
-		val = readl(PCITAW1REG);
+		val = pciu_read(PCITAW1REG);
 		val &= ~WINEN;
-		writel(val, PCITAW1REG);
+		pciu_write(PCITAW1REG, val);
 	}
 
 	if (setup->target_memory2 != NULL) {
@@ -188,11 +201,11 @@ static int __init vr41xx_pciu_init(void)
 		val = TARGET_MSK(target->address_mask) |
 		      WINEN |
 		      ITA(target->bus_base_address);
-		writel(val, PCITAW2REG);
+		pciu_write(PCITAW2REG, val);
 	} else {
-		val = readl(PCITAW2REG);
+		val = pciu_read(PCITAW2REG);
 		val &= ~WINEN;
-		writel(val, PCITAW2REG);
+		pciu_write(PCITAW2REG, val);
 	}
 
 	if (setup->master_io != NULL) {
@@ -201,50 +214,50 @@ static int __init vr41xx_pciu_init(void)
 		      MASTER_MSK(master->address_mask) |
 		      WINEN |
 		      PCIIA(master->pci_base_address);
-		writel(val, PCIMIOAWREG);
+		pciu_write(PCIMIOAWREG, val);
 	} else {
-		val = readl(PCIMIOAWREG);
+		val = pciu_read(PCIMIOAWREG);
 		val &= ~WINEN;
-		writel(val, PCIMIOAWREG);
+		pciu_write(PCIMIOAWREG, val);
 	}
 
 	if (setup->exclusive_access == CANNOT_LOCK_FROM_DEVICE)
-		writel(UNLOCK, PCIEXACCREG);
+		pciu_write(PCIEXACCREG, UNLOCK);
 	else
-		writel(0, PCIEXACCREG);
+		pciu_write(PCIEXACCREG, 0);
 
 	if (current_cpu_data.cputype == CPU_VR4122)
-		writel(TRDYV(setup->wait_time_limit_from_irdy_to_trdy), PCITRDYVREG);
+		pciu_write(PCITRDYVREG, TRDYV(setup->wait_time_limit_from_irdy_to_trdy));
 
-	writel(MLTIM(setup->master_latency_timer), LATTIMEREG);
+	pciu_write(LATTIMEREG, MLTIM(setup->master_latency_timer));
 
 	if (setup->mailbox != NULL) {
 		mailbox = setup->mailbox;
 		val = MBADD(mailbox->base_address) | TYPE_32BITSPACE |
 		      MSI_MEMORY | PREF_APPROVAL;
-		writel(val, MAILBAREG);
+		pciu_write(MAILBAREG, val);
 	}
 
 	if (setup->target_window1) {
 		window = setup->target_window1;
 		val = PMBA(window->base_address) | TYPE_32BITSPACE |
 		      MSI_MEMORY | PREF_APPROVAL;
-		writel(val, PCIMBA1REG);
+		pciu_write(PCIMBA1REG, val);
 	}
 
 	if (setup->target_window2) {
 		window = setup->target_window2;
 		val = PMBA(window->base_address) | TYPE_32BITSPACE |
 		      MSI_MEMORY | PREF_APPROVAL;
-		writel(val, PCIMBA2REG);
+		pciu_write(PCIMBA2REG, val);
 	}
 
-	val = readl(RETVALREG);
+	val = pciu_read(RETVALREG);
 	val &= ~RTYVAL_MASK;
 	val |= RTYVAL(setup->retry_limit);
-	writel(val, RETVALREG);
+	pciu_write(RETVALREG, val);
 
-	val = readl(PCIAPCNTREG);
+	val = pciu_read(PCIAPCNTREG);
 	val &= ~(TKYGNT | PAPC);
 
 	switch (setup->arbiter_priority_control) {
@@ -262,15 +275,16 @@ static int __init vr41xx_pciu_init(void)
 	if (setup->take_away_gnt_mode == PCI_TAKE_AWAY_GNT_ENABLE)
 		val |= TKYGNT_ENABLE;
 
-	writel(val, PCIAPCNTREG);
+	pciu_write(PCIAPCNTREG, val);
 
-	writel(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
-	       PCI_COMMAND_PARITY | PCI_COMMAND_SERR, COMMANDREG);
+	pciu_write(COMMANDREG, PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
+	                       PCI_COMMAND_MASTER | PCI_COMMAND_PARITY |
+			       PCI_COMMAND_SERR);
 
 	/* Clear bus error */
-	readl(BUSERRADREG);
+	pciu_read(BUSERRADREG);
 
-	writel(BLOODY_CONFIG_DONE, PCIENREG);
+	pciu_write(PCIENREG, PCIU_CONFIG_DONE);
 
 	if (setup->mem_resource != NULL)
 		vr41xx_pci_controller.mem_resource = setup->mem_resource;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pci/pci-vr41xx.h linux_HEAD/arch/mips/pci/pci-vr41xx.h
--- linux-2.6.11.6/arch/mips/pci/pci-vr41xx.h	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/pci/pci-vr41xx.h	2005-03-09 22:46:11.000000000 +0100
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2002  MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -22,11 +22,14 @@
 #ifndef __PCI_VR41XX_H
 #define __PCI_VR41XX_H
 
-#define PCIMMAW1REG		KSEG1ADDR(0x0f000c00)
-#define PCIMMAW2REG		KSEG1ADDR(0x0f000c04)
-#define PCITAW1REG		KSEG1ADDR(0x0f000c08)
-#define PCITAW2REG		KSEG1ADDR(0x0f000c0c)
-#define PCIMIOAWREG		KSEG1ADDR(0x0f000c10)
+#define PCIU_BASE		0x0f000c00UL
+#define PCIU_SIZE		0x200UL
+
+#define PCIMMAW1REG		0x00
+#define PCIMMAW2REG		0x04
+#define PCITAW1REG		0x08
+#define PCITAW2REG		0x0c
+#define PCIMIOAWREG		0x10
  #define IBA(addr)		((addr) & 0xff000000U)
  #define MASTER_MSK(mask)	(((mask) >> 11) & 0x000fe000U)
  #define PCIA(addr)		(((addr) >> 24) & 0x000000ffU)
@@ -34,13 +37,13 @@
  #define ITA(addr)		(((addr) >> 24) & 0x000000ffU)
  #define PCIIA(addr)		(((addr) >> 24) & 0x000000ffU)
  #define WINEN			0x1000U
-#define PCICONFDREG		KSEG1ADDR(0x0f000c14)
-#define PCICONFAREG		KSEG1ADDR(0x0f000c18)
-#define PCIMAILREG		KSEG1ADDR(0x0f000c1c)
-#define BUSERRADREG		KSEG1ADDR(0x0f000c24)
+#define PCICONFDREG		0x14
+#define PCICONFAREG		0x18
+#define PCIMAILREG		0x1c
+#define BUSERRADREG		0x24
  #define EA(reg)		((reg) &0xfffffffc)
 
-#define INTCNTSTAREG		KSEG1ADDR(0x0f000c28)
+#define INTCNTSTAREG		0x28
  #define MABTCLR		0x80000000U
  #define TRDYCLR		0x40000000U
  #define PARCLR			0x20000000U
@@ -67,34 +70,34 @@
  #define MABORT			0x00000002U
  #define TABORT			0x00000001U
 
-#define PCIEXACCREG		KSEG1ADDR(0x0f000c2c)
+#define PCIEXACCREG		0x2c
  #define UNLOCK			0x2U
  #define EAREQ			0x1U
-#define PCIRECONTREG		KSEG1ADDR(0x0f000c30)
+#define PCIRECONTREG		0x30
  #define RTRYCNT(reg)		((reg) & 0x000000ffU)
-#define PCIENREG		KSEG1ADDR(0x0f000c34)
- #define BLOODY_CONFIG_DONE	0x4U
-#define PCICLKSELREG		KSEG1ADDR(0x0f000c38)
+#define PCIENREG		0x34
+ #define PCIU_CONFIG_DONE	0x4U
+#define PCICLKSELREG		0x38
  #define EQUAL_VTCLOCK		0x2U
  #define HALF_VTCLOCK		0x0U
  #define ONE_THIRD_VTCLOCK	0x3U
  #define QUARTER_VTCLOCK	0x1U
-#define PCITRDYVREG		KSEG1ADDR(0x0f000c3c)
+#define PCITRDYVREG		0x3c
  #define TRDYV(val)		((uint32_t)(val) & 0xffU)
-#define PCICLKRUNREG		KSEG1ADDR(0x0f000c60)
+#define PCICLKRUNREG		0x60
 
-#define VENDORIDREG		KSEG1ADDR(0x0f000d00)
-#define DEVICEIDREG		KSEG1ADDR(0x0f000d00)
-#define COMMANDREG		KSEG1ADDR(0x0f000d04)
-#define STATUSREG		KSEG1ADDR(0x0f000d04)
-#define REVIDREG		KSEG1ADDR(0x0f000d08)
-#define CLASSREG		KSEG1ADDR(0x0f000d08)
-#define CACHELSREG		KSEG1ADDR(0x0f000d0c)
-#define LATTIMEREG		KSEG1ADDR(0x0f000d0c)
+#define VENDORIDREG		0x100
+#define DEVICEIDREG		0x100
+#define COMMANDREG		0x104
+#define STATUSREG		0x104
+#define REVIDREG		0x108
+#define CLASSREG		0x108
+#define CACHELSREG		0x10c
+#define LATTIMEREG		0x10c
  #define MLTIM(val)		(((uint32_t)(val) << 7) & 0xff00U)
-#define MAILBAREG		KSEG1ADDR(0x0f000d10)
-#define PCIMBA1REG		KSEG1ADDR(0x0f000d14)
-#define PCIMBA2REG		KSEG1ADDR(0x0f000d18)
+#define MAILBAREG		0x110
+#define PCIMBA1REG		0x114
+#define PCIMBA2REG		0x118
  #define MBADD(base)		((base) & 0xfffff800U)
  #define PMBA(base)		((base) & 0xffe00000U)
  #define PREF			0x8U
@@ -104,10 +107,10 @@
  #define TYPE_32BITSPACE	0x0U
  #define MSI			0x1U
  #define MSI_MEMORY		0x0U
-#define INTLINEREG		KSEG1ADDR(0x0f000d3c)
-#define INTPINREG		KSEG1ADDR(0x0f000d3c)
-#define RETVALREG		KSEG1ADDR(0x0f000d40)
-#define PCIAPCNTREG		KSEG1ADDR(0x0f000d40)
+#define INTLINEREG		0x13c
+#define INTPINREG		0x13c
+#define RETVALREG		0x140
+#define PCIAPCNTREG		0x140
  #define TKYGNT			0x04000000U
  #define TKYGNT_ENABLE		0x04000000U
  #define TKYGNT_DISABLE		0x00000000U
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/pmc-sierra/Kconfig linux_HEAD/arch/mips/pmc-sierra/Kconfig
--- linux-2.6.11.6/arch/mips/pmc-sierra/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/pmc-sierra/Kconfig	2005-01-30 21:45:37.000000000 +0100
@@ -0,0 +1,3 @@
+config HYPERTRANSPORT
+	bool "Hypertransport Support for PMC-Sierra Yosemite"
+	depends on PMC_YOSEMITE
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sgi-ip27/Kconfig linux_HEAD/arch/mips/sgi-ip27/Kconfig
--- linux-2.6.11.6/arch/mips/sgi-ip27/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/sgi-ip27/Kconfig	2005-01-30 21:45:36.000000000 +0100
@@ -0,0 +1,54 @@
+#config SGI_SN0_XXL
+#	bool "IP27 XXL"
+#	depends on SGI_IP27
+#	  This options adds support for userspace processes upto 16TB size.
+#	  Normally the limit is just .5TB.
+
+config SGI_SN0_N_MODE
+	bool "IP27 N-Mode"
+	depends on SGI_IP27
+	help
+	  The nodes of Origin 200, Origin 2000 and Onyx 2 systems can be
+	  configured in either N-Modes which allows for more nodes or M-Mode
+	  which allows for more memory.  Your system is most probably
+	  running in M-Mode, so you should say N here.
+
+config DISCONTIGMEM
+	bool
+	default y if SGI_IP27
+	help
+	  Say Y to upport efficient handling of discontiguous physical memory,
+	  for architectures which are either NUMA (Non-Uniform Memory Access)
+	  or have huge holes in the physical address space for other reasons.
+	  See <file:Documentation/vm/numa> for more.
+
+config NUMA
+	bool "NUMA Support"
+	depends on SGI_IP27
+	help
+	  Say Y to compile the kernel to support NUMA (Non-Uniform Memory
+	  Access).  This option is for configuring high-end multiprocessor
+	  server machines.  If in doubt, say N.
+
+config MAPPED_KERNEL
+	bool "Mapped kernel support"
+	depends on SGI_IP27
+	help
+	  Change the way a Linux kernel is loaded into memory on a MIPS64
+	  machine.  This is required in order to support text replication and
+	  NUMA.  If you need to understand it, read the source code.
+
+config REPLICATE_KTEXT
+	bool "Kernel text replication support"
+	depends on SGI_IP27
+	help
+	  Say Y here to enable replicating the kernel text across multiple
+	  nodes in a NUMA cluster.  This trades memory for speed.
+
+config REPLICATE_EXHANDLERS
+	bool "Exception handler replication support"
+	depends on SGI_IP27
+	help
+	  Say Y here to enable replicating the kernel exception handlers
+	  across multiple nodes in a NUMA cluster. This trades memory for
+	  speed.
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sgi-ip27/ip27-init.c linux_HEAD/arch/mips/sgi-ip27/ip27-init.c
--- linux-2.6.11.6/arch/mips/sgi-ip27/ip27-init.c	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/arch/mips/sgi-ip27/ip27-init.c	2005-03-21 20:03:47.000000000 +0100
@@ -56,12 +56,12 @@ static void __init per_hub_init(cnodeid_
 {
 	struct hub_data *hub = hub_data(cnode);
 	nasid_t nasid = COMPACT_TO_NASID_NODEID(cnode);
+	int i;
 
 	cpu_set(smp_processor_id(), hub->h_cpus);
 
 	if (test_and_set_bit(cnode, hub_init_mask))
 		return;
-
 	/*
 	 * Set CRB timeout at 5ms, (< PI timeout of 10ms)
 	 */
@@ -88,6 +88,24 @@ static void __init per_hub_init(cnodeid_
 		__flush_cache_all();
 	}
 #endif
+
+	/*
+	 * Some interrupts are reserved by hardware or by software convention.
+	 * Mark these as reserved right away so they won't be used accidently
+	 * later.
+	 */
+	for (i = 0; i <= BASE_PCI_IRQ; i++) {
+		__set_bit(i, hub->irq_alloc_mask);
+		LOCAL_HUB_CLR_INTR(INT_PEND0_BASELVL + i);
+	}
+
+	__set_bit(IP_PEND0_6_63, hub->irq_alloc_mask);
+	LOCAL_HUB_S(PI_INT_PEND_MOD, IP_PEND0_6_63);
+
+	for (i = NI_BRDCAST_ERR_A; i <= MSC_PANIC_INTR; i++) {
+		__set_bit(i, hub->irq_alloc_mask);
+		LOCAL_HUB_CLR_INTR(INT_PEND1_BASELVL + i);
+	}
 }
 
 void __init per_cpu_init(void)
@@ -104,30 +122,12 @@ void __init per_cpu_init(void)
 
 	clear_c0_status(ST0_IM);
 
+	per_hub_init(cnode);
+
 	for (i = 0; i < LEVELS_PER_SLICE; i++)
 		si->level_to_irq[i] = -1;
 
 	/*
-	 * Some interrupts are reserved by hardware or by software convention.
-	 * Mark these as reserved right away so they won't be used accidently
-	 * later.
-	 */
-	for (i = 0; i <= BASE_PCI_IRQ; i++) {
-		__set_bit(i, si->irq_alloc_mask);
-		LOCAL_HUB_S(PI_INT_PEND_MOD, i);
-	}
-
-	__set_bit(IP_PEND0_6_63, si->irq_alloc_mask);
-	LOCAL_HUB_S(PI_INT_PEND_MOD, IP_PEND0_6_63);
-
-	for (i = NI_BRDCAST_ERR_A; i <= MSC_PANIC_INTR; i++) {
-		__set_bit(i, si->irq_alloc_mask + 1);
-		LOCAL_HUB_S(PI_INT_PEND_MOD, i);
-	}
-
-	LOCAL_HUB_L(PI_INT_PEND0);
-
-	/*
 	 * We use this so we can find the local hub's data as fast as only
 	 * possible.
 	 */
@@ -140,8 +140,6 @@ void __init per_cpu_init(void)
 	install_cpu_nmi_handler(cputoslice(cpu));
 
 	set_c0_status(SRB_DEV0 | SRB_DEV1);
-
-	per_hub_init(cnode);
 }
 
 /*
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sgi-ip27/ip27-irq.c linux_HEAD/arch/mips/sgi-ip27/ip27-irq.c
--- linux-2.6.11.6/arch/mips/sgi-ip27/ip27-irq.c	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/sgi-ip27/ip27-irq.c	2005-03-21 20:03:47.000000000 +0100
@@ -74,14 +74,15 @@ extern int irq_to_slot[];
 
 static inline int alloc_level(int cpu, int irq)
 {
+	struct hub_data *hub = hub_data(cpu_to_node(cpu));
 	struct slice_data *si = cpu_data[cpu].data;
-	int level;				/* pre-allocated entries */
+	int level;
 
-	level = find_first_zero_bit(si->irq_alloc_mask, LEVELS_PER_SLICE);
+	level = find_first_zero_bit(hub->irq_alloc_mask, LEVELS_PER_SLICE);
 	if (level >= LEVELS_PER_SLICE)
 		panic("Cpu %d flooded with devices\n", cpu);
 
-	__set_bit(level, si->irq_alloc_mask);
+	__set_bit(level, hub->irq_alloc_mask);
 	si->level_to_irq[level] = irq;
 
 	return level;
@@ -216,9 +217,11 @@ static int intr_connect_level(int cpu, i
 {
 	nasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));
 	struct slice_data *si = cpu_data[cpu].data;
+	unsigned long flags;
 
-	__set_bit(bit, si->irq_enable_mask);
+	set_bit(bit, si->irq_enable_mask);
 
+	local_irq_save(flags);
 	if (!cputoslice(cpu)) {
 		REMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);
 		REMOTE_HUB_S(nasid, PI_INT_MASK1_A, si->irq_enable_mask[1]);
@@ -226,6 +229,7 @@ static int intr_connect_level(int cpu, i
 		REMOTE_HUB_S(nasid, PI_INT_MASK0_B, si->irq_enable_mask[0]);
 		REMOTE_HUB_S(nasid, PI_INT_MASK1_B, si->irq_enable_mask[1]);
 	}
+	local_irq_restore(flags);
 
 	return 0;
 }
@@ -235,7 +239,7 @@ static int intr_disconnect_level(int cpu
 	nasid_t nasid = COMPACT_TO_NASID_NODEID(cpu_to_node(cpu));
 	struct slice_data *si = cpu_data[cpu].data;
 
-	__clear_bit(bit, si->irq_enable_mask);
+	clear_bit(bit, si->irq_enable_mask);
 
 	if (!cputoslice(cpu)) {
 		REMOTE_HUB_S(nasid, PI_INT_MASK0_A, si->irq_enable_mask[0]);
@@ -298,6 +302,7 @@ static unsigned int startup_bridge_irq(u
 static void shutdown_bridge_irq(unsigned int irq)
 {
 	struct bridge_controller *bc = IRQ_TO_BRIDGE(irq);
+	struct hub_data *hub = hub_data(cpu_to_node(bc->irq_cpu));
 	bridge_t *bridge = bc->base;
 	struct slice_data *si = cpu_data[bc->irq_cpu].data;
 	int pin, swlevel;
@@ -313,7 +318,7 @@ static void shutdown_bridge_irq(unsigned
 	swlevel = find_level(&cpu, irq);
 	intr_disconnect_level(cpu, swlevel);
 
-	__clear_bit(swlevel, si->irq_alloc_mask);
+	__clear_bit(swlevel, hub->irq_alloc_mask);
 	si->level_to_irq[swlevel] = -1;
 
 	bridge->b_int_enable &= ~(1 << pin);
@@ -433,25 +438,24 @@ void install_ipi(void)
 	int slice = LOCAL_HUB_L(PI_CPU_NUM);
 	int cpu = smp_processor_id();
 	struct slice_data *si = cpu_data[cpu].data;
-	hubreg_t mask, set;
+	struct hub_data *hub = hub_data(cpu_to_node(cpu));
+	int resched, call;
+
+	resched = CPU_RESCHED_A_IRQ + slice;
+	__set_bit(resched, hub->irq_alloc_mask);
+	__set_bit(resched, si->irq_enable_mask);
+	LOCAL_HUB_CLR_INTR(resched);
+
+	call = CPU_CALL_A_IRQ + slice;
+	__set_bit(call, hub->irq_alloc_mask);
+	__set_bit(call, si->irq_enable_mask);
+	LOCAL_HUB_CLR_INTR(call);
 
 	if (slice == 0) {
-		LOCAL_HUB_CLR_INTR(CPU_RESCHED_A_IRQ);
-		LOCAL_HUB_CLR_INTR(CPU_CALL_A_IRQ);
-		mask = LOCAL_HUB_L(PI_INT_MASK0_A);	/* Slice A */
-		set = (1UL << CPU_RESCHED_A_IRQ) | (1UL << CPU_CALL_A_IRQ);
-		mask |= set;
-		si->irq_enable_mask[0] |= set;
-		si->irq_alloc_mask[0] |= set;
-		LOCAL_HUB_S(PI_INT_MASK0_A, mask);
+		LOCAL_HUB_S(PI_INT_MASK0_A, si->irq_enable_mask[0]);
+		LOCAL_HUB_S(PI_INT_MASK1_A, si->irq_enable_mask[1]);
 	} else {
-		LOCAL_HUB_CLR_INTR(CPU_RESCHED_B_IRQ);
-		LOCAL_HUB_CLR_INTR(CPU_CALL_B_IRQ);
-		mask = LOCAL_HUB_L(PI_INT_MASK0_B);	/* Slice B */
-		set = (1UL << CPU_RESCHED_B_IRQ) | (1UL << CPU_CALL_B_IRQ);
-		mask |= set;
-		si->irq_enable_mask[1] |= set;
-		si->irq_alloc_mask[1] |= set;
-		LOCAL_HUB_S(PI_INT_MASK0_B, mask);
+		LOCAL_HUB_S(PI_INT_MASK0_B, si->irq_enable_mask[0]);
+		LOCAL_HUB_S(PI_INT_MASK1_B, si->irq_enable_mask[1]);
 	}
 }
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sgi-ip27/ip27-smp.c linux_HEAD/arch/mips/sgi-ip27/ip27-smp.c
--- linux-2.6.11.6/arch/mips/sgi-ip27/ip27-smp.c	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/sgi-ip27/ip27-smp.c	2005-02-17 21:48:58.000000000 +0100
@@ -127,37 +127,28 @@ void cpu_node_probe(void)
 	printk("Discovered %d cpus on %d nodes\n", highest + 1, num_online_nodes());
 }
 
-static void intr_clear_bits(nasid_t nasid, volatile hubreg_t *pend,
-	int base_level)
+static __init void intr_clear_all(nasid_t nasid)
 {
-	volatile hubreg_t bits;
 	int i;
 
-	/* Check pending interrupts */
-	if ((bits = HUB_L(pend)) != 0)
-		for (i = 0; i < N_INTPEND_BITS; i++)
-			if (bits & (1 << i))
-				LOCAL_HUB_CLR_INTR(base_level + i);
-}
-
-static void intr_clear_all(nasid_t nasid)
-{
 	REMOTE_HUB_S(nasid, PI_INT_MASK0_A, 0);
 	REMOTE_HUB_S(nasid, PI_INT_MASK0_B, 0);
 	REMOTE_HUB_S(nasid, PI_INT_MASK1_A, 0);
 	REMOTE_HUB_S(nasid, PI_INT_MASK1_B, 0);
-	intr_clear_bits(nasid, REMOTE_HUB_ADDR(nasid, PI_INT_PEND0),
-	                INT_PEND0_BASELVL);
-	intr_clear_bits(nasid, REMOTE_HUB_ADDR(nasid, PI_INT_PEND1),
-	                INT_PEND1_BASELVL);
+
+	for (i = 0; i < 128; i++) 
+		REMOTE_HUB_CLR_INTR(nasid, i);
 }
 
 void __init prom_prepare_cpus(unsigned int max_cpus)
 {
 	cnodeid_t	cnode;
 
-	for_each_online_node(cnode)
+	for_each_online_node(cnode) {
+		if (cnode == 0)
+			continue;
 		intr_clear_all(COMPACT_TO_NASID_NODEID(cnode));
+	}
 
 	replicate_kernel_text();
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sgi-ip32/crime.c linux_HEAD/arch/mips/sgi-ip32/crime.c
--- linux-2.6.11.6/arch/mips/sgi-ip32/crime.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/sgi-ip32/crime.c	2005-01-11 20:07:11.000000000 +0100
@@ -26,7 +26,7 @@ void __init crime_init(void)
 	unsigned int id, rev;
 	const int field = 2 * sizeof(unsigned long);
 
-	set_io_port_base((unsigned long) ioremap(MACEPCI_LOW_IO, 0x2000000));
+	set_io_port_base((unsigned long) ioremap(MACEPCI_LOW_IO, 0x2000000));	
 	crime = ioremap(CRIME_BASE, sizeof(struct sgi_crime));
 	mace = ioremap(MACE_BASE, sizeof(struct sgi_mace));
 
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sgi-ip32/ip32-irq.c linux_HEAD/arch/mips/sgi-ip32/ip32-irq.c
--- linux-2.6.11.6/arch/mips/sgi-ip32/ip32-irq.c	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/arch/mips/sgi-ip32/ip32-irq.c	2005-02-28 16:56:42.000000000 +0100
@@ -163,14 +163,13 @@ static void end_cpu_irq(unsigned int irq
 #define mask_and_ack_cpu_irq disable_cpu_irq
 
 static struct hw_interrupt_type ip32_cpu_interrupt = {
-	"IP32 CPU",
-	startup_cpu_irq,
-	shutdown_cpu_irq,
-	enable_cpu_irq,
-	disable_cpu_irq,
-	mask_and_ack_cpu_irq,
-	end_cpu_irq,
-	NULL
+	.typename = "IP32 CPU",
+	.startup = startup_cpu_irq,
+	.shutdown = shutdown_cpu_irq,
+	.enable = enable_cpu_irq,
+	.disable = disable_cpu_irq,
+	.ack = mask_and_ack_cpu_irq,
+	.end = end_cpu_irq,
 };
 
 /*
@@ -234,14 +233,13 @@ static void end_crime_irq(unsigned int i
 #define shutdown_crime_irq disable_crime_irq
 
 static struct hw_interrupt_type ip32_crime_interrupt = {
-	"IP32 CRIME",
-	startup_crime_irq,
-	shutdown_crime_irq,
-	enable_crime_irq,
-	disable_crime_irq,
-	mask_and_ack_crime_irq,
-	end_crime_irq,
-	NULL
+	.typename = "IP32 CRIME",
+	.startup = startup_crime_irq,
+	.shutdown = shutdown_crime_irq,
+	.enable = enable_crime_irq,
+	.disable = disable_crime_irq,
+	.ack = mask_and_ack_crime_irq,
+	.end = end_crime_irq,
 };
 
 /*
@@ -294,14 +292,13 @@ static void end_macepci_irq(unsigned int
 #define mask_and_ack_macepci_irq disable_macepci_irq
 
 static struct hw_interrupt_type ip32_macepci_interrupt = {
-	"IP32 MACE PCI",
-	startup_macepci_irq,
-	shutdown_macepci_irq,
-	enable_macepci_irq,
-	disable_macepci_irq,
-	mask_and_ack_macepci_irq,
-	end_macepci_irq,
-	NULL
+	.typename = "IP32 MACE PCI",
+	.startup = startup_macepci_irq,
+	.shutdown = shutdown_macepci_irq,
+	.enable = enable_macepci_irq,
+	.disable = disable_macepci_irq,
+	.ack = mask_and_ack_macepci_irq,
+	.end = end_macepci_irq,
 };
 
 /* This is used for MACE ISA interrupts.  That means bits 4-6 in the
@@ -425,14 +422,13 @@ static void end_maceisa_irq(unsigned irq
 #define shutdown_maceisa_irq disable_maceisa_irq
 
 static struct hw_interrupt_type ip32_maceisa_interrupt = {
-	"IP32 MACE ISA",
-	startup_maceisa_irq,
-	shutdown_maceisa_irq,
-	enable_maceisa_irq,
-	disable_maceisa_irq,
-	mask_and_ack_maceisa_irq,
-	end_maceisa_irq,
-	NULL
+	.typename = "IP32 MACE ISA",
+	.startup = startup_maceisa_irq,
+	.shutdown = shutdown_maceisa_irq,
+	.enable = enable_maceisa_irq,
+	.disable = disable_maceisa_irq,
+	.ack = mask_and_ack_maceisa_irq,
+	.end = end_maceisa_irq,
 };
 
 /* This is used for regular non-ISA, non-PCI MACE interrupts.  That means
@@ -476,14 +472,13 @@ static void end_mace_irq(unsigned int ir
 #define mask_and_ack_mace_irq disable_mace_irq
 
 static struct hw_interrupt_type ip32_mace_interrupt = {
-	"IP32 MACE",
-	startup_mace_irq,
-	shutdown_mace_irq,
-	enable_mace_irq,
-	disable_mace_irq,
-	mask_and_ack_mace_irq,
-	end_mace_irq,
-	NULL
+	.typename = "IP32 MACE",
+	.startup = startup_mace_irq,
+	.shutdown = shutdown_mace_irq,
+	.enable = enable_mace_irq,
+	.disable = disable_mace_irq,
+	.ack = mask_and_ack_mace_irq,
+	.end = end_mace_irq,
 };
 
 static void ip32_unknown_interrupt(struct pt_regs *regs)
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sgi-ip32/ip32-memory.c linux_HEAD/arch/mips/sgi-ip32/ip32-memory.c
--- linux-2.6.11.6/arch/mips/sgi-ip32/ip32-memory.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/sgi-ip32/ip32-memory.c	2005-01-31 21:33:22.000000000 +0100
@@ -36,8 +36,8 @@ void __init prom_meminit (void)
 		if (base + size > (256 << 20))
 			base += CRIME_HI_MEM_BASE;
 
-		printk("CRIME MC: bank %u base 0x%016lx size %luMB\n",
-			bank, base, size);
+		printk("CRIME MC: bank %u base 0x%016lx size %luMiB\n",
+			bank, base, size >> 20);
 		add_memory_region (base, size, BOOT_MEM_RAM);
 	}
 }
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/Kconfig linux_HEAD/arch/mips/sibyte/Kconfig
--- linux-2.6.11.6/arch/mips/sibyte/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/Kconfig	2005-02-03 15:28:23.000000000 +0100
@@ -0,0 +1,143 @@
+config SIBYTE_SB1250
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_HAS_LDT
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1120
+	bool
+	select SIBYTE_BCM112X
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1125
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_BCM112X
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM1125H
+	bool
+	select HW_HAS_PCI
+	select SIBYTE_BCM112X
+	select SIBYTE_HAS_LDT
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_BCM112X
+	bool
+	select SIBYTE_SB1xxx_SOC
+
+config SIBYTE_SB1xxx_SOC
+	bool
+	depends on EXPERIMENTAL
+	select DMA_COHERENT
+	select SIBYTE_CFE
+	select SWAP_IO_SPACE
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL
+
+choice
+	prompt "SiByte SOC Stepping"
+	depends on SIBYTE_SB1xxx_SOC
+
+config CPU_SB1_PASS_1
+	bool "1250 Pass1"
+	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
+
+config CPU_SB1_PASS_2_1250
+	bool "1250 An"
+	depends on SIBYTE_SB1250
+	select CPU_SB1_PASS_2
+	help
+	  Also called BCM1250 Pass 2
+
+config CPU_SB1_PASS_2_2
+	bool "1250 Bn"
+	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
+	help
+	  Also called BCM1250 Pass 2.2
+
+config CPU_SB1_PASS_4
+	bool "1250 Cn"
+	depends on SIBYTE_SB1250
+	select CPU_HAS_PREFETCH
+	help
+	  Also called BCM1250 Pass 3
+
+config CPU_SB1_PASS_2_112x
+	bool "112x Hybrid"
+	depends on SIBYTE_BCM112X
+	select CPU_SB1_PASS_2
+
+config CPU_SB1_PASS_3
+	bool "112x An"
+	depends on SIBYTE_BCM112X
+	select CPU_HAS_PREFETCH
+
+endchoice
+
+config CPU_SB1_PASS_2
+	bool
+
+config SIBYTE_HAS_LDT
+	bool
+	depends on PCI && (SIBYTE_SB1250 || SIBYTE_BCM1125H)
+	default y
+
+config SIMULATION
+	bool "Running under simulation"
+	depends on SIBYTE_SB1xxx_SOC
+	help
+	  Build a kernel suitable for running under the GDB simulator.
+	  Primarily adjusts the kernel's notion of time.
+
+config SIBYTE_CFE
+	bool "Booting from CFE"
+	depends on SIBYTE_SB1xxx_SOC
+	help
+	  Make use of the CFE API for enumerating available memory,
+	  controlling secondary CPUs, and possibly console output.
+
+config SIBYTE_CFE_CONSOLE
+	bool "Use firmware console"
+	depends on SIBYTE_CFE
+	help
+	  Use the CFE API's console write routines during boot.  Other console
+	  options (VT console, sb1250 duart console, etc.) should not be
+	  configured.
+
+config SIBYTE_STANDALONE
+	bool
+	depends on SIBYTE_SB1xxx_SOC && !SIBYTE_CFE
+	default y
+
+config SIBYTE_STANDALONE_RAM_SIZE
+	int "Memory size (in megabytes)"
+	depends on SIBYTE_STANDALONE
+	default "32"
+
+config SIBYTE_BUS_WATCHER
+	bool "Support for Bus Watcher statistics"
+	depends on SIBYTE_SB1xxx_SOC
+	help
+	  Handle and keep statistics on the bus error interrupts (COR_ECC,
+	  BAD_ECC, IO_BUS).
+
+config SIBYTE_BW_TRACE
+	bool "Capture bus trace before bus error"
+	depends on SIBYTE_BUS_WATCHER
+	help
+	  Run a continuous bus trace, dumping the raw data as soon as
+	  a ZBbus error is detected.  Cannot work if ZBbus profiling
+	  is turned on, and also will interfere with JTAG-based trace
+	  buffer activity.  Raw buffer data is dumped to console, and
+	  must be processed off-line.
+
+config SIBYTE_SB1250_PROF
+	bool "Support for SB1/SOC profiling - SB1/SCD perf counters"
+	depends on SIBYTE_SB1xxx_SOC
+
+config SIBYTE_TBPROF
+	bool "Support for ZBbus profiling"
+	depends on SIBYTE_SB1xxx_SOC
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/sb1250/bcm1250_tbprof.c linux_HEAD/arch/mips/sibyte/sb1250/bcm1250_tbprof.c
--- linux-2.6.11.6/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/sb1250/bcm1250_tbprof.c	2005-02-24 00:13:17.000000000 +0100
@@ -28,6 +28,7 @@
 #include <linux/fs.h>
 #include <linux/errno.h>
 #include <linux/reboot.h>
+#include <linux/wait.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/sibyte/sb1250.h>
@@ -64,24 +65,25 @@ static void arm_tb(void)
 	u_int64_t tb_options = M_SCD_TRACE_CFG_FREEZE_FULL;
 	/* Generate an SCD_PERFCNT interrupt in TB_PERIOD Zclks to
 	   trigger start of trace.  XXX vary sampling period */
-	bus_writeq(0, IOADDR(A_SCD_PERF_CNT_1));
-	scdperfcnt = bus_readq(IOADDR(A_SCD_PERF_CNT_CFG));
+	__raw_writeq(0, IOADDR(A_SCD_PERF_CNT_1));
+	scdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));
 	/* Unfortunately, in Pass 2 we must clear all counters to knock down
 	   a previous interrupt request.  This means that bus profiling
 	   requires ALL of the SCD perf counters. */
-	bus_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) | // keep counters 0,2,3 as is
-		   M_SPC_CFG_ENABLE |		 // enable counting
-		   M_SPC_CFG_CLEAR |		 // clear all counters
-		   V_SPC_CFG_SRC1(1),		 // counter 1 counts cycles
-		   IOADDR(A_SCD_PERF_CNT_CFG));
-	bus_writeq(next, IOADDR(A_SCD_PERF_CNT_1));
+	__raw_writeq((scdperfcnt & ~M_SPC_CFG_SRC1) |
+						// keep counters 0,2,3 as is
+		     M_SPC_CFG_ENABLE |		// enable counting
+		     M_SPC_CFG_CLEAR |		// clear all counters
+		     V_SPC_CFG_SRC1(1),		// counter 1 counts cycles
+		     IOADDR(A_SCD_PERF_CNT_CFG));
+	__raw_writeq(next, IOADDR(A_SCD_PERF_CNT_1));
 	/* Reset the trace buffer */
-	bus_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
+	__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 #if 0 && defined(M_SCD_TRACE_CFG_FORCECNT)
 	/* XXXKW may want to expose control to the data-collector */
 	tb_options |= M_SCD_TRACE_CFG_FORCECNT;
 #endif
-	bus_writeq(tb_options, IOADDR(A_SCD_TRACE_CFG));
+	__raw_writeq(tb_options, IOADDR(A_SCD_TRACE_CFG));
 	sbp.tb_armed = 1;
 }
 
@@ -93,23 +95,30 @@ static irqreturn_t sbprof_tb_intr(int ir
 		/* XXX should use XKPHYS to make writes bypass L2 */
 		u_int64_t *p = sbp.sbprof_tbbuf[sbp.next_tb_sample++];
 		/* Read out trace */
-		bus_writeq(M_SCD_TRACE_CFG_START_READ, IOADDR(A_SCD_TRACE_CFG));
+		__raw_writeq(M_SCD_TRACE_CFG_START_READ,
+			     IOADDR(A_SCD_TRACE_CFG));
 		__asm__ __volatile__ ("sync" : : : "memory");
 		/* Loop runs backwards because bundles are read out in reverse order */
 		for (i = 256 * 6; i > 0; i -= 6) {
 			// Subscripts decrease to put bundle in the order
 			//   t0 lo, t0 hi, t1 lo, t1 hi, t2 lo, t2 hi
-			p[i-1] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 hi
-			p[i-2] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t2 lo
-			p[i-3] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 hi
-			p[i-4] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t1 lo
-			p[i-5] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 hi
-			p[i-6] = bus_readq(IOADDR(A_SCD_TRACE_READ)); // read t0 lo
+			p[i - 1] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t2 hi
+			p[i - 2] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t2 lo
+			p[i - 3] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t1 hi
+			p[i - 4] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t1 lo
+			p[i - 5] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t0 hi
+			p[i - 6] = __raw_readq(IOADDR(A_SCD_TRACE_READ));
+								// read t0 lo
 		}
 		if (!sbp.tb_enable) {
 			DBG(printk(DEVNAME ": tb_intr shutdown\n"));
-			bus_writeq(M_SCD_TRACE_CFG_RESET,
-				   IOADDR(A_SCD_TRACE_CFG));
+			__raw_writeq(M_SCD_TRACE_CFG_RESET,
+				     IOADDR(A_SCD_TRACE_CFG));
 			sbp.tb_armed = 0;
 			wake_up(&sbp.tb_sync);
 		} else {
@@ -118,7 +127,7 @@ static irqreturn_t sbprof_tb_intr(int ir
 	} else {
 		/* No more trace buffer samples */
 		DBG(printk(DEVNAME ": tb_intr full\n"));
-		bus_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
+		__raw_writeq(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 		sbp.tb_armed = 0;
 		if (!sbp.tb_enable) {
 			wake_up(&sbp.tb_sync);
@@ -152,13 +161,11 @@ int sbprof_zbprof_start(struct file *fil
 		return -EBUSY;
 	}
 	/* Make sure there isn't a perf-cnt interrupt waiting */
-	scdperfcnt = bus_readq(IOADDR(A_SCD_PERF_CNT_CFG));
+	scdperfcnt = __raw_readq(IOADDR(A_SCD_PERF_CNT_CFG));
 	/* Disable and clear counters, override SRC_1 */
-	bus_writeq((scdperfcnt & ~(M_SPC_CFG_SRC1 | M_SPC_CFG_ENABLE)) |
-		   M_SPC_CFG_ENABLE |
-		   M_SPC_CFG_CLEAR |
-		   V_SPC_CFG_SRC1(1),
-		   IOADDR(A_SCD_PERF_CNT_CFG));
+	__raw_writeq((scdperfcnt & ~(M_SPC_CFG_SRC1 | M_SPC_CFG_ENABLE)) |
+		     M_SPC_CFG_ENABLE | M_SPC_CFG_CLEAR | V_SPC_CFG_SRC1(1),
+		     IOADDR(A_SCD_PERF_CNT_CFG));
 
 	/* We grab this interrupt to prevent others from trying to use
            it, even though we don't want to service the interrupts
@@ -172,55 +179,55 @@ int sbprof_zbprof_start(struct file *fil
 	/* I need the core to mask these, but the interrupt mapper to
 	   pass them through.  I am exploiting my knowledge that
 	   cp0_status masks out IP[5]. krw */
-	bus_writeq(K_INT_MAP_I3,
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-			  (K_INT_PERF_CNT << 3)));
+	__raw_writeq(K_INT_MAP_I3,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+			    (K_INT_PERF_CNT << 3)));
 
 	/* Initialize address traps */
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_0));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_1));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_2));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_UP_3));
-
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_0));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_1));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_2));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_3));
-
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_0));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_1));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_2));
-	bus_writeq(0, IOADDR(A_ADDR_TRAP_CFG_3));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_0));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_1));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_2));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_UP_3));
+
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_0));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_1));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_2));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_DOWN_3));
+
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_0));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_1));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_2));
+	__raw_writeq(0, IOADDR(A_ADDR_TRAP_CFG_3));
 
 	/* Initialize Trace Event 0-7 */
 	//				when interrupt
-	bus_writeq(M_SCD_TREVT_INTERRUPT, IOADDR(A_SCD_TRACE_EVENT_0));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_1));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_2));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_3));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_4));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_5));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_6));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_EVENT_7));
+	__raw_writeq(M_SCD_TREVT_INTERRUPT, IOADDR(A_SCD_TRACE_EVENT_0));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_1));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_2));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_3));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_4));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_5));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_6));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_EVENT_7));
 
 	/* Initialize Trace Sequence 0-7 */
 	//				     Start on event 0 (interrupt)
-	bus_writeq(V_SCD_TRSEQ_FUNC_START | 0x0fff,
-		   IOADDR(A_SCD_TRACE_SEQUENCE_0));
+	__raw_writeq(V_SCD_TRSEQ_FUNC_START | 0x0fff,
+		     IOADDR(A_SCD_TRACE_SEQUENCE_0));
 	//			  dsamp when d used | asamp when a used
-	bus_writeq(M_SCD_TRSEQ_ASAMPLE | M_SCD_TRSEQ_DSAMPLE |
-		   K_SCD_TRSEQ_TRIGGER_ALL,
-		   IOADDR(A_SCD_TRACE_SEQUENCE_1));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_2));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_3));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_4));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_5));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_6));
-	bus_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_7));
+	__raw_writeq(M_SCD_TRSEQ_ASAMPLE | M_SCD_TRSEQ_DSAMPLE |
+		     K_SCD_TRSEQ_TRIGGER_ALL,
+		     IOADDR(A_SCD_TRACE_SEQUENCE_1));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_2));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_3));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_4));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_5));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_6));
+	__raw_writeq(0, IOADDR(A_SCD_TRACE_SEQUENCE_7));
 
 	/* Now indicate the PERF_CNT interrupt as a trace-relevant interrupt */
-	bus_writeq((1ULL << K_INT_PERF_CNT),
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_TRACE)));
+	__raw_writeq(1ULL << K_INT_PERF_CNT,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_TRACE)));
 
 	arm_tb();
 
@@ -231,6 +238,7 @@ int sbprof_zbprof_start(struct file *fil
 
 int sbprof_zbprof_stop(void)
 {
+	DEFINE_WAIT(wait);
 	DBG(printk(DEVNAME ": stopping\n"));
 
 	if (sbp.tb_enable) {
@@ -240,7 +248,9 @@ int sbprof_zbprof_stop(void)
 		   this sleep happens. */
 		if (sbp.tb_armed) {
 			DBG(printk(DEVNAME ": wait for disarm\n"));
-			interruptible_sleep_on(&sbp.tb_sync);
+			prepare_to_wait(&sbp.tb_sync, &wait, TASK_INTERRUPTIBLE);
+			schedule();
+			finish_wait(&sbp.tb_sync, &wait);
 			DBG(printk(DEVNAME ": disarm complete\n"));
 		}
 		free_irq(K_INT_TRACE_FREEZE, &sbp);
@@ -348,7 +358,10 @@ static int sbprof_tb_ioctl(struct inode 
 		error = sbprof_zbprof_stop();
 		break;
 	case SBPROF_ZBWAITFULL:
-		interruptible_sleep_on(&sbp.tb_read);
+		DEFINE_WAIT(wait);
+		prepare_to_wait(&sbp.tb_read, &wait, TASK_INTERRUPTIBLE);
+		schedule();
+		finish_wait(&sbp.tb_read, &wait);
 		/* XXXKW check if interrupted? */
 		return put_user(TB_FULL, (int *) arg);
 	default:
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/sb1250/bus_watcher.c linux_HEAD/arch/mips/sibyte/sb1250/bus_watcher.c
--- linux-2.6.11.6/arch/mips/sibyte/sb1250/bus_watcher.c	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/sb1250/bus_watcher.c	2005-02-24 00:13:17.000000000 +0100
@@ -189,7 +189,7 @@ static irqreturn_t sibyte_bw_int(int irq
 
 	for (i=0; i<256*6; i++)
 		printk("%016llx\n",
-		       (unsigned long long)bus_readq(IOADDR(A_SCD_TRACE_READ)));
+		       (long long)__raw_readq(IOADDR(A_SCD_TRACE_READ)));
 
 	csr_out32(M_SCD_TRACE_CFG_RESET, IOADDR(A_SCD_TRACE_CFG));
 	csr_out32(M_SCD_TRACE_CFG_START, IOADDR(A_SCD_TRACE_CFG));
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/sb1250/irq.c linux_HEAD/arch/mips/sibyte/sb1250/irq.c
--- linux-2.6.11.6/arch/mips/sibyte/sb1250/irq.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/sb1250/irq.c	2005-02-28 16:56:42.000000000 +0100
@@ -71,17 +71,15 @@ extern char sb1250_duart_present[];
 #endif
 
 static struct hw_interrupt_type sb1250_irq_type = {
-	"SB1250-IMR",
-	startup_sb1250_irq,
-	shutdown_sb1250_irq,
-	enable_sb1250_irq,
-	disable_sb1250_irq,
-	ack_sb1250_irq,
-	end_sb1250_irq,
+	.typename = "SB1250-IMR",
+	.startup = startup_sb1250_irq,
+	.shutdown = shutdown_sb1250_irq,
+	.enable = enable_sb1250_irq,
+	.disable = disable_sb1250_irq,
+	.ack = ack_sb1250_irq,
+	.end = end_sb1250_irq,
 #ifdef CONFIG_SMP
-	sb1250_set_affinity
-#else
-	NULL
+	.set_affinity = sb1250_set_affinity
 #endif
 };
 
@@ -96,11 +94,11 @@ void sb1250_mask_irq(int cpu, int irq)
 	u64 cur_ints;
 
 	spin_lock_irqsave(&sb1250_imr_lock, flags);
-	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	cur_ints |= (((u64) 1) << irq);
-	__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	spin_unlock_irqrestore(&sb1250_imr_lock, flags);
 }
 
@@ -110,11 +108,11 @@ void sb1250_unmask_irq(int cpu, int irq)
 	u64 cur_ints;
 
 	spin_lock_irqsave(&sb1250_imr_lock, flags);
-	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	cur_ints &= ~(((u64) 1) << irq);
-	__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
-				      R_IMR_INTERRUPT_MASK));
+	____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	spin_unlock_irqrestore(&sb1250_imr_lock, flags);
 }
 
@@ -149,23 +147,23 @@ static void sb1250_set_affinity(unsigned
 
 	/* Swizzle each CPU's IMR (but leave the IP selection alone) */
 	old_cpu = sb1250_irq_owner[irq];
-	cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(old_cpu) +
-			       R_IMR_INTERRUPT_MASK));
+	cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(old_cpu) +
+					R_IMR_INTERRUPT_MASK));
 	int_on = !(cur_ints & (((u64) 1) << irq));
 	if (int_on) {
 		/* If it was on, mask it */
 		cur_ints |= (((u64) 1) << irq);
-		__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(old_cpu) +
-					      R_IMR_INTERRUPT_MASK));
+		____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(old_cpu) +
+					R_IMR_INTERRUPT_MASK));
 	}
 	sb1250_irq_owner[irq] = cpu;
 	if (int_on) {
 		/* unmask for the new CPU */
-		cur_ints = __bus_readq(IOADDR(A_IMR_MAPPER(cpu) +
-				       R_IMR_INTERRUPT_MASK));
+		cur_ints = ____raw_readq(IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 		cur_ints &= ~(((u64) 1) << irq);
-		__bus_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
-					      R_IMR_INTERRUPT_MASK));
+		____raw_writeq(cur_ints, IOADDR(A_IMR_MAPPER(cpu) +
+					R_IMR_INTERRUPT_MASK));
 	}
 	spin_unlock(&sb1250_imr_lock);
 	spin_unlock_irqrestore(&desc->lock, flags);
@@ -208,8 +206,8 @@ static void ack_sb1250_irq(unsigned int 
 	 * deliver the interrupts to all CPUs (which makes affinity
 	 * changing easier for us)
 	 */
-	pending = bus_readq(IOADDR(A_IMR_REGISTER(sb1250_irq_owner[irq],
-						  R_IMR_LDT_INTERRUPT)));
+	pending = __raw_readq(IOADDR(A_IMR_REGISTER(sb1250_irq_owner[irq],
+						    R_IMR_LDT_INTERRUPT)));
 	pending &= ((u64)1 << (irq));
 	if (pending) {
 		int i;
@@ -224,8 +222,8 @@ static void ack_sb1250_irq(unsigned int 
 			 * Clear for all CPUs so an affinity switch
 			 * doesn't find an old status
 			 */
-			bus_writeq(pending,
-				   IOADDR(A_IMR_REGISTER(cpu,
+			__raw_writeq(pending, 
+				     IOADDR(A_IMR_REGISTER(cpu,
 						R_IMR_LDT_INTERRUPT_CLR)));
 		}
 
@@ -340,12 +338,14 @@ void __init arch_init_irq(void)
 
 	/* Default everything to IP2 */
 	for (i = 0; i < SB1250_NR_IRQS; i++) {	/* was I0 */
-		bus_writeq(IMR_IP2_VAL,
-			   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-				  (i << 3)));
-		bus_writeq(IMR_IP2_VAL,
-			   IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
-				  (i << 3)));
+		__raw_writeq(IMR_IP2_VAL,
+			     IOADDR(A_IMR_REGISTER(0,
+						   R_IMR_INTERRUPT_MAP_BASE) +
+				    (i << 3)));
+		__raw_writeq(IMR_IP2_VAL,
+			     IOADDR(A_IMR_REGISTER(1,
+						   R_IMR_INTERRUPT_MAP_BASE) +
+				    (i << 3)));
 	}
 
 	init_sb1250_irqs();
@@ -355,23 +355,23 @@ void __init arch_init_irq(void)
 	 * inter-cpu messages
 	 */
 	/* Was I1 */
-	bus_writeq(IMR_IP3_VAL,
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-			  (K_INT_MBOX_0 << 3)));
-	bus_writeq(IMR_IP3_VAL,
-		   IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
-			  (K_INT_MBOX_0 << 3)));
+	__raw_writeq(IMR_IP3_VAL,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
+			    (K_INT_MBOX_0 << 3)));
+	__raw_writeq(IMR_IP3_VAL,
+		     IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MAP_BASE) +
+			    (K_INT_MBOX_0 << 3)));
 
 	/* Clear the mailboxes.  The firmware may leave them dirty */
-	bus_writeq(0xffffffffffffffffULL,
-		   IOADDR(A_IMR_REGISTER(0, R_IMR_MAILBOX_CLR_CPU)));
-	bus_writeq(0xffffffffffffffffULL,
-		   IOADDR(A_IMR_REGISTER(1, R_IMR_MAILBOX_CLR_CPU)));
+	__raw_writeq(0xffffffffffffffffULL,
+		     IOADDR(A_IMR_REGISTER(0, R_IMR_MAILBOX_CLR_CPU)));
+	__raw_writeq(0xffffffffffffffffULL,
+		     IOADDR(A_IMR_REGISTER(1, R_IMR_MAILBOX_CLR_CPU)));
 
 	/* Mask everything except the mailbox registers for both cpus */
 	tmp = ~((u64) 0) ^ (((u64) 1) << K_INT_MBOX_0);
-	bus_writeq(tmp, IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MASK)));
-	bus_writeq(tmp, IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MASK)));
+	__raw_writeq(tmp, IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MASK)));
+	__raw_writeq(tmp, IOADDR(A_IMR_REGISTER(1, R_IMR_INTERRUPT_MASK)));
 
 	sb1250_steal_irq(K_INT_MBOX_0);
 
@@ -396,12 +396,14 @@ void __init arch_init_irq(void)
 		sb1250_duart_present[kgdb_port] = 0;
 #endif
 		/* Setup uart 1 settings, mapper */
-		bus_writeq(M_DUART_IMR_BRK, IOADDR(A_DUART_IMRREG(kgdb_port)));
+		__raw_writeq(M_DUART_IMR_BRK,
+			     IOADDR(A_DUART_IMRREG(kgdb_port)));
 
 		sb1250_steal_irq(kgdb_irq);
-		bus_writeq(IMR_IP6_VAL,
-			   IOADDR(A_IMR_REGISTER(0, R_IMR_INTERRUPT_MAP_BASE) +
-				  (kgdb_irq<<3)));
+		__raw_writeq(IMR_IP6_VAL,
+			     IOADDR(A_IMR_REGISTER(0,
+						   R_IMR_INTERRUPT_MAP_BASE) +
+				    (kgdb_irq << 3)));
 		sb1250_unmask_irq(0, kgdb_irq);
 	}
 #endif
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/sb1250/setup.c linux_HEAD/arch/mips/sibyte/sb1250/setup.c
--- linux-2.6.11.6/arch/mips/sibyte/sb1250/setup.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/sb1250/setup.c	2005-02-24 00:13:17.000000000 +0100
@@ -153,7 +153,7 @@ void sb1250_setup(void)
 	int bad_config = 0;
 
 	sb1_pass = read_c0_prid() & 0xff;
-	sys_rev = bus_readq(IOADDR(A_SCD_SYSTEM_REVISION));
+	sys_rev = __raw_readq(IOADDR(A_SCD_SYSTEM_REVISION));
 	soc_type = SYS_SOC_TYPE(sys_rev);
 	soc_pass = G_SYS_REVISION(sys_rev);
 
@@ -162,7 +162,7 @@ void sb1250_setup(void)
 		machine_restart(NULL);
 	}
 
-	plldiv = G_SYS_PLL_DIV(bus_readq(IOADDR(A_SCD_SYSTEM_CFG)));
+	plldiv = G_SYS_PLL_DIV(__raw_readq(IOADDR(A_SCD_SYSTEM_CFG)));
 	zbbus_mhz = ((plldiv >> 1) * 50) + ((plldiv & 1) * 25);
 
 	prom_printf("Broadcom SiByte %s %s @ %d MHz (SB1 rev %d)\n",
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/sb1250/smp.c linux_HEAD/arch/mips/sibyte/sb1250/smp.c
--- linux-2.6.11.6/arch/mips/sibyte/sb1250/smp.c	2005-03-26 04:28:43.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/sb1250/smp.c	2005-02-24 00:13:17.000000000 +0100
@@ -29,18 +29,18 @@
 #include <asm/sibyte/sb1250_int.h>
 
 static void *mailbox_set_regs[] = {
-	(void *)IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_SET_CPU),
-	(void *)IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_SET_CPU)
+	IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_SET_CPU),
+	IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_SET_CPU)
 };
 
 static void *mailbox_clear_regs[] = {
-	(void *)IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CLR_CPU),
-	(void *)IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CLR_CPU)
+	IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CLR_CPU),
+	IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CLR_CPU)
 };
 
 static void *mailbox_regs[] = {
-	(void *)IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CPU),
-	(void *)IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CPU)
+	IOADDR(A_IMR_CPU0_BASE + R_IMR_MAILBOX_CPU),
+	IOADDR(A_IMR_CPU1_BASE + R_IMR_MAILBOX_CPU)
 };
 
 /*
@@ -73,7 +73,7 @@ void sb1250_smp_finish(void)
  */
 void core_send_ipi(int cpu, unsigned int action)
 {
-	bus_writeq((((u64)action) << 48), mailbox_set_regs[cpu]);
+	__raw_writeq((((u64)action) << 48), mailbox_set_regs[cpu]);
 }
 
 void sb1250_mailbox_interrupt(struct pt_regs *regs)
@@ -83,10 +83,10 @@ void sb1250_mailbox_interrupt(struct pt_
 
 	kstat_this_cpu.irqs[K_INT_MBOX_0]++;
 	/* Load the mailbox register to figure out what we're supposed to do */
-	action = (__bus_readq(mailbox_regs[cpu]) >> 48) & 0xffff;
+	action = (____raw_readq(mailbox_regs[cpu]) >> 48) & 0xffff;
 
 	/* Clear the mailbox to clear the interrupt */
-	__bus_writeq(((u64)action) << 48, mailbox_clear_regs[cpu]);
+	____raw_writeq(((u64)action) << 48, mailbox_clear_regs[cpu]);
 
 	/*
 	 * Nothing to do for SMP_RESCHEDULE_YOURSELF; returning from the
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/sb1250/time.c linux_HEAD/arch/mips/sibyte/sb1250/time.c
--- linux-2.6.11.6/arch/mips/sibyte/sb1250/time.c	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/sb1250/time.c	2005-02-24 00:13:17.000000000 +0100
@@ -67,24 +67,24 @@ void sb1250_time_init(void)
 	sb1250_mask_irq(cpu, irq);
 
 	/* Map the timer interrupt to ip[4] of this cpu */
-	bus_writeq(IMR_IP4_VAL,
-		   IOADDR(A_IMR_REGISTER(cpu, R_IMR_INTERRUPT_MAP_BASE) +
-			  (irq << 3)));
+	__raw_writeq(IMR_IP4_VAL,
+		     IOADDR(A_IMR_REGISTER(cpu, R_IMR_INTERRUPT_MAP_BASE) +
+			    (irq << 3)));
 
 	/* the general purpose timer ticks at 1 Mhz independent if the rest of the system */
 	/* Disable the timer and set up the count */
-	bus_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	__raw_writeq(0, IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 #ifdef CONFIG_SIMULATION
-	bus_writeq(50000 / HZ,
-		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+	__raw_writeq(50000 / HZ,
+		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
 #else
-	bus_writeq(1000000/HZ,
-		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
+	__raw_writeq(1000000 / HZ,
+		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_INIT)));
 #endif
 
 	/* Set the timer running */
-	bus_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-		   IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	__raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
+		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
 	sb1250_unmask_irq(cpu, irq);
 	sb1250_steal_irq(irq);
@@ -105,8 +105,8 @@ void sb1250_timer_interrupt(struct pt_re
 	int irq = K_INT_TIMER_0 + cpu;
 
 	/* Reset the timer */
-	__bus_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
-		     IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
+	____raw_writeq(M_SCD_TIMER_ENABLE | M_SCD_TIMER_MODE_CONTINUOUS,
+		       IOADDR(A_SCD_TIMER_REGISTER(cpu, R_SCD_TIMER_CFG)));
 
 	/*
 	 * CPU 0 handles the global timer interrupt job
@@ -130,7 +130,7 @@ void sb1250_timer_interrupt(struct pt_re
 unsigned long sb1250_gettimeoffset(void)
 {
 	unsigned long count =
-		bus_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
+		__raw_readq(IOADDR(A_SCD_TIMER_REGISTER(0, R_SCD_TIMER_CNT)));
 
 	return 1000000/HZ - count;
  }
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/swarm/rtc_m41t81.c linux_HEAD/arch/mips/sibyte/swarm/rtc_m41t81.c
--- linux-2.6.11.6/arch/mips/sibyte/swarm/rtc_m41t81.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/swarm/rtc_m41t81.c	2005-02-24 00:13:17.000000000 +0100
@@ -82,59 +82,60 @@
 #define M41T81REG_SQW	0x13		/* square wave register */
 
 #define M41T81_CCR_ADDRESS	0x68
-#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+
+#define SMB_CSR(reg)	IOADDR(A_SMB_REGISTER(1, reg))
 
 static int m41t81_read(uint8_t addr)
 {
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
-	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq((V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	}
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int m41t81_write(uint8_t addr, int b)
 {
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	bus_writeq((addr & 0xFF), SMB_CSR(R_SMB_CMD));
-	bus_writeq((b & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(b & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 
-	if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+	if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
 		/* Clear error bit by writing a 1 */
-		bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+		__raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
 		return -1;
 	} 
 
 	/* read the same byte again to make sure it is written */
-	bus_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(M41T81_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-	while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+	while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
 		;
 	
 	return 0;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/swarm/rtc_xicor1241.c linux_HEAD/arch/mips/sibyte/swarm/rtc_xicor1241.c
--- linux-2.6.11.6/arch/mips/sibyte/swarm/rtc_xicor1241.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/swarm/rtc_xicor1241.c	2005-02-24 00:13:17.000000000 +0100
@@ -57,52 +57,52 @@
 
 #define X1241_CCR_ADDRESS	0x6F
 
-#define SMB_CSR(reg) ((u8 *) (IOADDR(A_SMB_REGISTER(1, reg))))
+#define SMB_CSR(reg)	IOADDR(A_SMB_REGISTER(1, reg))
 
 static int xicor_read(uint8_t addr)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         }
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
+	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         } else {
 		return 0;
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sibyte/swarm/time.c linux_HEAD/arch/mips/sibyte/swarm/time.c
--- linux-2.6.11.6/arch/mips/sibyte/swarm/time.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/arch/mips/sibyte/swarm/time.c	2005-02-24 00:13:17.000000000 +0100
@@ -79,48 +79,48 @@ static unsigned int usec_bias = 0;
 
 static int xicor_read(uint8_t addr)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff), SMB_CSR(R_SMB_DATA));
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq((addr >> 8) & 0x7, SMB_CSR(R_SMB_CMD));
+	__raw_writeq(addr & 0xff, SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR2BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq((V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE),
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_RD1BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         }
 
-	return (bus_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
+	return (__raw_readq(SMB_CSR(R_SMB_DATA)) & 0xff);
 }
 
 static int xicor_write(uint8_t addr, int b)
 {
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-	bus_writeq(addr, SMB_CSR(R_SMB_CMD));
-	bus_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
-	bus_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
-		   SMB_CSR(R_SMB_START));
+	__raw_writeq(addr, SMB_CSR(R_SMB_CMD));
+	__raw_writeq((addr & 0xff) | ((b & 0xff) << 8), SMB_CSR(R_SMB_DATA));
+	__raw_writeq(V_SMB_ADDR(X1241_CCR_ADDRESS) | V_SMB_TT_WR3BYTE,
+		     SMB_CSR(R_SMB_START));
 
-        while (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
+        while (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_BUSY)
                 ;
 
-        if (bus_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
+        if (__raw_readq(SMB_CSR(R_SMB_STATUS)) & M_SMB_ERROR) {
                 /* Clear error bit by writing a 1 */
-                bus_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
+                __raw_writeq(M_SMB_ERROR, SMB_CSR(R_SMB_STATUS));
                 return -1;
         } else {
 		return 0;
@@ -228,8 +228,8 @@ void __init swarm_time_init(void)
 	/* Establish communication with the Xicor 1241 RTC */
 	/* XXXKW how do I share the SMBus with the I2C subsystem? */
 
-	bus_writeq(K_SMB_FREQ_400KHZ, SMB_CSR(R_SMB_FREQ));
-	bus_writeq(0, SMB_CSR(R_SMB_CONTROL));
+	__raw_writeq(K_SMB_FREQ_400KHZ, SMB_CSR(R_SMB_FREQ));
+	__raw_writeq(0, SMB_CSR(R_SMB_CONTROL));
 
 	if ((status = xicor_read(X1241REG_SR_RTCF)) < 0) {
 		printk("x1241: couldn't detect on SWARM SMBus 1\n");
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/sni/irq.c linux_HEAD/arch/mips/sni/irq.c
--- linux-2.6.11.6/arch/mips/sni/irq.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/arch/mips/sni/irq.c	2005-02-28 16:56:42.000000000 +0100
@@ -58,14 +58,13 @@ static void end_pciasic_irq(unsigned int
 }
 
 static struct hw_interrupt_type pciasic_irq_type = {
-	"ASIC-PCI",
-	startup_pciasic_irq,
-	shutdown_pciasic_irq,
-	enable_pciasic_irq,
-	disable_pciasic_irq,
-	mask_and_ack_pciasic_irq,
-	end_pciasic_irq,
-	NULL
+	.typename = "ASIC-PCI",
+	.startup = startup_pciasic_irq,
+	.shutdown = shutdown_pciasic_irq,
+	.enable = enable_pciasic_irq,
+	.disable = disable_pciasic_irq,
+	.ack = mask_and_ack_pciasic_irq,
+	.end = end_pciasic_irq,
 };
 
 /*
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/tx4927/Kconfig linux_HEAD/arch/mips/tx4927/Kconfig
--- linux-2.6.11.6/arch/mips/tx4927/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/tx4927/Kconfig	2005-01-30 21:45:36.000000000 +0100
@@ -0,0 +1,3 @@
+config TOSHIBA_FPCIB0
+	bool "FPCIB0 Backplane Support"
+	depends on TOSHIBA_RBTX4927
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c linux_HEAD/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c
--- linux-2.6.11.6/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/arch/mips/tx4927/toshiba_rbtx4927/toshiba_rbtx4927_setup.c	2005-03-04 20:36:08.000000000 +0100
@@ -77,6 +77,11 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #endif
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#endif
 
 #undef TOSHIBA_RBTX4927_SETUP_DEBUG
 
@@ -920,12 +925,30 @@ void __init toshiba_rbtx4927_setup(void)
 
 #endif /* CONFIG_PCI */
 
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		int i;
+		struct uart_port req;
+		for(i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)(0xff1ff300 + i * 0x100);
+			req.mapbase = 0xff1ff300 + i * 0x100;
+			req.irq = 32 + i;
+			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
+			req.uartclk = 50000000;
+			early_serial_txx9_setup(&req);
+		}
+	}
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
         argptr = prom_getcmdline();
         if (strstr(argptr, "console=") == NULL) {
                 strcat(argptr, " console=ttyS0,38400");
         }
 #endif
+#endif
 
 #ifdef CONFIG_ROOT_NFS
         argptr = prom_getcmdline();
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr4181/Kconfig linux_HEAD/arch/mips/vr4181/Kconfig
--- linux-2.6.11.6/arch/mips/vr4181/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/vr4181/Kconfig	2005-03-21 20:03:47.000000000 +0100
@@ -0,0 +1,61 @@
+config NEC_CMBVR4133
+	bool "Support for NEC CMB-VR4133"
+	depends on MACH_VR41XX
+	select CPU_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select PCI_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+
+config ROCKHOPPER
+	bool "Support for Rockhopper baseboard"
+	depends on NEC_CMBVR4133
+	select I8259
+	select HAVE_STD_PC_SERIAL_PORT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+
+config CASIO_E55
+	bool "Support for CASIO CASSIOPEIA E-10/15/55/65"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+
+config IBM_WORKPAD
+	bool "Support for IBM WorkPad z50"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+
+config TANBAC_TB0226
+	bool "Support for TANBAC TB0226 (Mbase)"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	help
+	  The TANBAC TB0226 (Mbase) is a MIPS-based platform manufactured by
+	  TANBAC.  Please refer to <http://www.tanbac.co.jp/> about Mbase.
+
+config TANBAC_TB0229
+	bool "Support for TANBAC TB0229 (VR4131DIMM)"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	help
+	  The TANBAC TB0229 (VR4131DIMM) is a MIPS-based platform manufactured
+	  by TANBAC.  Please refer to <http://www.tanbac.co.jp/> about
+	  VR4131DIMM.
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr4181/common/irq.c linux_HEAD/arch/mips/vr4181/common/irq.c
--- linux-2.6.11.6/arch/mips/vr4181/common/irq.c	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/arch/mips/vr4181/common/irq.c	2005-02-28 16:56:42.000000000 +0100
@@ -86,14 +86,13 @@ sys_irq_end(unsigned int irq)
 }
 
 static hw_irq_controller sys_irq_controller = {
-	"vr4181_sys_irq",
-	sys_irq_startup,
-	sys_irq_shutdown,
-	sys_irq_enable,
-	sys_irq_disable,
-	sys_irq_ack,
-	sys_irq_end,
-	NULL			/* no affinity stuff for UP */
+	.typename = "vr4181_sys_irq",
+	.startup = sys_irq_startup,
+	.shutdown = sys_irq_shutdown,
+	.enable = sys_irq_enable,
+	.disable = sys_irq_disable,
+	.ack = sys_irq_ack,
+	.end = sys_irq_end,
 };
 
 /* ---------------------- gpio irq ------------------------ */
@@ -162,14 +161,13 @@ gpio_irq_end(unsigned int irq)
 }
 
 static hw_irq_controller gpio_irq_controller = {
-	"vr4181_gpio_irq",
-	gpio_irq_startup,
-	gpio_irq_shutdown,
-	gpio_irq_enable,
-	gpio_irq_disable,
-	gpio_irq_ack,
-	gpio_irq_end,
-	NULL			/* no affinity stuff for UP */
+	.typename = "vr4181_gpio_irq",
+	.startup = gpio_irq_startup,
+	.shutdown = gpio_irq_shutdown,
+	.enable = gpio_irq_enable,
+	.disable = gpio_irq_disable,
+	.ack = gpio_irq_ack,
+	.end = gpio_irq_end,
 };
 
 /* ---------------------  IRQ init stuff ---------------------- */
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr41xx/Kconfig linux_HEAD/arch/mips/vr41xx/Kconfig
--- linux-2.6.11.6/arch/mips/vr41xx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/arch/mips/vr41xx/Kconfig	2005-03-21 20:03:47.000000000 +0100
@@ -0,0 +1,107 @@
+config NEC_CMBVR4133
+	bool "Support for NEC CMB-VR4133"
+	depends on MACH_VR41XX
+	select CPU_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select PCI_VR41XX
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config ROCKHOPPER
+	bool "Support for Rockhopper baseboard"
+	depends on NEC_CMBVR4133
+	select I8259
+	select HAVE_STD_PC_SERIAL_PORT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+
+config CASIO_E55
+	bool "Support for CASIO CASSIOPEIA E-10/15/55/65"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config IBM_WORKPAD
+	bool "Support for IBM WorkPad z50"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select IRQ_CPU
+	select ISA
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config TANBAC_TB0226
+	bool "Support for TANBAC TB0226 (Mbase)"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  The TANBAC TB0226 (Mbase) is a MIPS-based platform manufactured by
+	  TANBAC.  Please refer to <http://www.tanbac.co.jp/> about Mbase.
+
+config TANBAC_TB0229
+	bool "Support for TANBAC TB0229 (VR4131DIMM)"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	help
+	  The TANBAC TB0229 (VR4131DIMM) is a MIPS-based platform manufactured
+	  by TANBAC.  Please refer to <http://www.tanbac.co.jp/> about
+	  VR4131DIMM.
+
+config VICTOR_MPC30X
+	bool "Support for Victor MP-C303/304"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	depends on MACH_VR41XX
+
+config ZAO_CAPCELLA
+	bool "Support for ZAO Networks Capcella"
+	depends on MACH_VR41XX
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
+config PCI_VR41XX
+	bool "Add PCI control unit support of NEC VR4100 series"
+	depends on MACH_VR41XX && PCI
+
+config GPIO_VR41XX
+	tristate "Add General-purpose I/O unit support of NEC VR4100 series"
+	depends on MACH_VR41XX
+
+config VRC4171
+	tristate "Add NEC VRC4171 companion chip support"
+	depends on MACH_VR41XX && ISA
+	help
+	  The NEC VRC4171/4171A is a companion chip for NEC VR4111/VR4121.
+
+config VRC4173
+	tristate "Add NEC VRC4173 companion chip support"
+	depends on MACH_VR41XX && PCI_VR41XX
+	help
+	  The NEC VRC4173 is a companion chip for NEC VR4122/VR4131.
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr41xx/common/giu.c linux_HEAD/arch/mips/vr41xx/common/giu.c
--- linux-2.6.11.6/arch/mips/vr41xx/common/giu.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/arch/mips/vr41xx/common/giu.c	2005-03-21 20:03:47.000000000 +0100
@@ -3,8 +3,7 @@
  *
  *  Copyright (C) 2002 MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ *  Copyright (C) 2003-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -29,6 +28,7 @@
  *  - Added support for NEC VR4133.
  *  - Removed board_irq_init.
  */
+#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/irq.h>
@@ -63,12 +63,6 @@
 
 static uint32_t giu_base;
 
-static struct irqaction giu_cascade = {
-	.handler	= no_action,
-	.mask		= CPU_MASK_NONE,
-	.name		= "cascade",
-};
-
 #define read_giuint(offset)		readw(giu_base + (offset))
 #define write_giuint(val, offset)	writew((val), giu_base + (offset))
 
@@ -192,18 +186,20 @@ static struct hw_interrupt_type giuint_h
 	.end		= end_giuint_high_irq,
 };
 
-void __init init_vr41xx_giuint_irq(void)
+void vr41xx_enable_giuint(unsigned int pin)
 {
-	int i;
-
-	for (i = GIU_IRQ_BASE; i <= GIU_IRQ_LAST; i++) {
-		if (i < (GIU_IRQ_BASE + GIUINT_HIGH_OFFSET))
-			irq_desc[i].handler = &giuint_low_irq_type;
-		else
-			irq_desc[i].handler = &giuint_high_irq_type;
-	}
+	if (pin < GIUINT_HIGH_OFFSET)
+		enable_giuint_low_irq(GIU_IRQ(pin));
+	else
+		enable_giuint_high_irq(GIU_IRQ(pin));
+}
 
-	setup_irq(GIUINT_CASCADE_IRQ, &giu_cascade);
+void vr41xx_disable_giuint(unsigned int pin)
+{
+	if (pin < GIUINT_HIGH_OFFSET)
+		disable_giuint_low_irq(GIU_IRQ(pin));
+	else
+		disable_giuint_high_irq(GIU_IRQ(pin));
 }
 
 void vr41xx_set_irq_trigger(int pin, int trigger, int hold)
@@ -296,6 +292,8 @@ void vr41xx_set_irq_level(int pin, int l
 
 EXPORT_SYMBOL(vr41xx_set_irq_level);
 
+#ifndef MODULE
+
 #define GIUINT_NR_IRQS		32
 
 enum {
@@ -310,6 +308,12 @@ struct vr41xx_giuint_cascade {
 
 static struct vr41xx_giuint_cascade giuint_cascade[GIUINT_NR_IRQS];
 
+static struct irqaction giu_cascade = {
+	.handler	= no_action,
+	.mask		= CPU_MASK_NONE,
+	.name		= "cascade",
+};
+
 static int no_irq_number(int irq)
 {
 	return -EINVAL;
@@ -421,7 +425,7 @@ void giuint_irq_dispatch(struct pt_regs 
 	enable_irq(GIUINT_CASCADE_IRQ);
 }
 
-static int __init vr41xx_giu_init(void)
+void __init init_vr41xx_giuint_irq(void)
 {
 	int i;
 
@@ -437,7 +441,7 @@ static int __init vr41xx_giu_init(void)
 		break;
 	default:
 		printk(KERN_ERR "GIU: Unexpected CPU of NEC VR4100 series\n");
-		return -EINVAL;
+		return;
 	}
 
 	for (i = 0; i < GIUINT_NR_IRQS; i++) {
@@ -449,7 +453,14 @@ static int __init vr41xx_giu_init(void)
 		giuint_cascade[i].get_irq_number = no_irq_number;
 	}
 
-	return 0;
+	for (i = GIU_IRQ_BASE; i <= GIU_IRQ_LAST; i++) {
+		if (i < (GIU_IRQ_BASE + GIUINT_HIGH_OFFSET))
+			irq_desc[i].handler = &giuint_low_irq_type;
+		else
+			irq_desc[i].handler = &giuint_high_irq_type;
+	}
+
+	setup_irq(GIUINT_CASCADE_IRQ, &giu_cascade);
 }
 
-early_initcall(vr41xx_giu_init);
+#endif
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr41xx/common/icu.c linux_HEAD/arch/mips/vr41xx/common/icu.c
--- linux-2.6.11.6/arch/mips/vr41xx/common/icu.c	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/arch/mips/vr41xx/common/icu.c	2005-03-09 22:46:11.000000000 +0100
@@ -3,8 +3,7 @@
  *
  *  Copyright (C) 2001-2002  MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ *  Copyright (C) 2003-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -29,6 +28,7 @@
  *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *  - Coped with INTASSIGN of NEC VR4133.
  */
+#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
@@ -45,8 +45,10 @@
 
 extern asmlinkage void vr41xx_handle_interrupt(void);
 
+#ifdef CONFIG_GPIO_VR41XX
 extern void init_vr41xx_giuint_irq(void);
 extern void giuint_irq_dispatch(struct pt_regs *regs);
+#endif
 
 static uint32_t icu1_base;
 static uint32_t icu2_base;
@@ -672,9 +674,11 @@ asmlinkage void irq_dispatch(unsigned ch
 		for (i = 0; i < 16; i++) {
 			if (intnum == sysint1_assign[i] &&
 			    (mask1 & ((uint16_t)1 << i))) {
+#ifdef CONFIG_GPIO_VR41XX
 				if (i == 8)
 					giuint_irq_dispatch(regs);
 				else
+#endif
 					do_IRQ(SYSINT1_IRQ(i), regs);
 				return;
 			}
@@ -698,8 +702,10 @@ asmlinkage void irq_dispatch(unsigned ch
 
 /*=======================================================================*/
 
-static int __init vr41xx_icu_init(void)
+static inline void init_vr41xx_icu_irq(void)
 {
+	int i;
+
 	switch (current_cpu_data.cputype) {
 	case CPU_VR4111:
 	case CPU_VR4121:
@@ -723,17 +729,6 @@ static int __init vr41xx_icu_init(void)
 	write_icu2(0, MSYSINT2REG);
 	write_icu2(0xffff, MGIUINTHREG);
 
-	return 0;
-}
-
-early_initcall(vr41xx_icu_init);
-
-/*=======================================================================*/
-
-static inline void init_vr41xx_icu_irq(void)
-{
-	int i;
-
 	for (i = SYSINT1_IRQ_BASE; i <= SYSINT1_IRQ_LAST; i++)
 		irq_desc[i].handler = &sysint1_irq_type;
 
@@ -751,7 +746,9 @@ void __init arch_init_irq(void)
 {
 	mips_cpu_irq_init(MIPS_CPU_IRQ_BASE);
 	init_vr41xx_icu_irq();
+#ifdef CONFIG_GPIO_VR41XX
 	init_vr41xx_giuint_irq();
+#endif
 
 	set_except_vector(0, vr41xx_handle_interrupt);
 }
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr41xx/nec-cmbvr4133/init.c linux_HEAD/arch/mips/vr41xx/nec-cmbvr4133/init.c
--- linux-2.6.11.6/arch/mips/vr41xx/nec-cmbvr4133/init.c	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/arch/mips/vr41xx/nec-cmbvr4133/init.c	2004-12-15 15:08:18.000000000 +0100
@@ -12,7 +12,7 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
- * Support for NEC-CMBVR4133 in 2.6
+ * Support for NEC-CMBVR4133 in 2.6 
  * Manish Lachwani (mlachwani@mvista.com)
  */
 #include <linux/config.h>
@@ -40,7 +40,7 @@ void disable_pcnet(void)
 {
 	u32 data;
 
-	/*
+	/* 
 	 * Workaround for the bug in PMON on VR4133. PMON leaves
 	 * AMD PCNet controller (on Rockhopper) initialized and running in
 	 * bus master mode. We have do disable it before doing any
@@ -69,7 +69,7 @@ void disable_pcnet(void)
 	       (4 & 0xfc)		|
                1UL,
 	       PCICONFAREG);
-
+	
 	data &= ~4;
 
 	writel(data, PCICONFDREG);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr41xx/nec-cmbvr4133/irq.c linux_HEAD/arch/mips/vr41xx/nec-cmbvr4133/irq.c
--- linux-2.6.11.6/arch/mips/vr41xx/nec-cmbvr4133/irq.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/arch/mips/vr41xx/nec-cmbvr4133/irq.c	2004-12-15 15:08:18.000000000 +0100
@@ -27,9 +27,9 @@ extern void enable_8259A_irq(unsigned in
 extern void disable_8259A_irq(unsigned int irq);
 extern void mask_and_ack_8259A(unsigned int irq);
 extern void init_8259A(int hoge);
-
+                                                                                                    
 extern int vr4133_rockhopper;
-
+                                                                                                    
 static unsigned int startup_i8259_irq(unsigned int irq)
 {
 	enable_8259A_irq(irq - I8259_IRQ_BASE);
diff -urpNX dontdiff linux-2.6.11.6/arch/mips/vr41xx/nec-cmbvr4133/setup.c linux_HEAD/arch/mips/vr41xx/nec-cmbvr4133/setup.c
--- linux-2.6.11.6/arch/mips/vr41xx/nec-cmbvr4133/setup.c	2005-04-02 23:39:55.000000000 +0200
+++ linux_HEAD/arch/mips/vr41xx/nec-cmbvr4133/setup.c	2004-12-15 15:08:18.000000000 +0100
@@ -36,13 +37,13 @@ static struct mtd_partition cmbvr4133_mt
 		.size =		0x1be0000,
 		.offset =	0,
 		.mask_flags = 	0,
-	},
+	}, 
 	{
 		.name =		"PMON",
 		.size =		0x140000,
 		.offset =	MTDPART_OFS_APPEND,
 		.mask_flags =	MTD_WRITEABLE,  /* force read-only */
-	},
+	}, 
 	{
 		.name =		"User FS2",
 		.size =		MTDPART_SIZ_FULL,
@@ -54,6 +55,15 @@ static struct mtd_partition cmbvr4133_mt
 #define number_partitions (sizeof(cmbvr4133_mtd_parts)/sizeof(struct mtd_partition))
 #endif
 
+extern void (*late_time_init)(void);
+
+static void __init vr4133_serial_init(void)
+{
+	vr41xx_select_siu_interface(SIU_RS232C, IRDA_NONE);
+	vr41xx_siu_init();
+	vr41xx_dsiu_init();
+}
+
 extern void i8259_init(void);
 
 static int __init nec_cmbvr4133_setup(void)
@@ -68,6 +78,8 @@ static int __init nec_cmbvr4133_setup(vo
 	mips_machgroup = MACH_GROUP_NEC_VR41XX;
 	mips_machtype = MACH_NEC_CMBVR4133;
 
+	late_time_init = vr4133_serial_init;
+
 #ifdef CONFIG_PCI
 #ifdef CONFIG_ROCKHOPPER
 	ali_m5229_preinit();
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/Kconfig linux_HEAD/drivers/char/Kconfig
--- linux-2.6.11.6/drivers/char/Kconfig	2005-04-03 00:10:55.000000000 +0200
+++ linux_HEAD/drivers/char/Kconfig	2005-03-21 20:04:03.000000000 +0100
@@ -331,23 +331,33 @@ config ISTALLION
 	  To compile this driver as a module, choose M here: the
 	  module will be called istallion.
 
-config AU1000_UART
-	bool "Enable Au1000 UART Support"
-	depends on SERIAL_NONSTANDARD && MIPS
-	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use serial ports, say Y.  Otherwise, say N.
-
-config AU1000_SERIAL_CONSOLE
-	bool "Enable Au1000 serial console"
-	depends on AU1000_UART
-	help
-	  If you have an Alchemy AU1000 processor (MIPS based) and you want
-	  to use a console on a serial port, say Y.  Otherwise, say N.
+config AU1X00_GPIO
+	tristate "Alchemy Au1000 GPIO device support"
+	depends on MIPS && SOC_AU1X00
+
+config TS_AU1X00_ADS7846
+	tristate "Au1000/ADS7846 touchscreen support"
+	depends on MIPS && SOC_AU1X00
+
+config AU1X00_USB_TTY
+	tristate "Au1000 USB TTY Device support"
+	depends on MIPS && MIPS_AU1000 && AU1000_USB_DEVICE=y && AU1000_USB_DEVICE
+
+config AU1X00_USB_RAW
+	tristate "Au1000 USB Raw Device support"
+	depends on MIPS && MIPS_AU1000 && AU1000_USB_DEVICE=y && AU1000_USB_TTY!=y && AU1X00_USB_DEVICE
+
+config SIBYTE_SB1250_DUART
+	bool "Support for BCM1xxx onchip DUART"
+	depends on MIPS && SIBYTE_SB1xxx_SOC=y
+
+config SIBYTE_SB1250_DUART_CONSOLE
+	bool "Console on BCM1xxx DUART"
+	depends on SIBYTE_SB1250_DUART
 
 config QTRONIX_KEYBOARD
 	bool "Enable Qtronix 990P Keyboard Support"
-	depends on IT8712
+	depends on MIPS && (MIPS_ITE8172 || MIPS_IVR)
 	help
 	  Images of Qtronix keyboards are at
 	  <http://www.qtronix.com/keyboard.html>.
@@ -359,7 +369,7 @@ config IT8172_CIR
 
 config IT8172_SCR0
 	bool "Enable Smart Card Reader 0 Support "
-	depends on IT8712
+	depends on MIPS && (MIPS_ITE8172 || MIPS_IVR)
 	help
 	  Say Y here to support smart-card reader 0 (SCR0) on the Integrated
 	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
@@ -368,13 +378,17 @@ config IT8172_SCR0
 
 config IT8172_SCR1
 	bool "Enable Smart Card Reader 1 Support "
-	depends on IT8712
+	depends on MIPS && (MIPS_ITE8172 || MIPS_IVR) && MIPS_ITE8172
 	help
 	  Say Y here to support smart-card reader 1 (SCR1) on the Integrated
 	  Technology Express, Inc. ITE8172 SBC.  Vendor page at
 	  <http://www.ite.com.tw/ia/brief_it8172bsp.htm>; picture of the
 	  board at <http://www.mvista.com/partners/semiconductor/ite.html>.
 
+config ITE_GPIO
+	tristate "ITE GPIO"
+	depends on MIPS && MIPS_ITE8172
+
 config A2232
 	tristate "Commodore A2232 serial support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && ZORRO && BROKEN_ON_SMP
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/Makefile linux_HEAD/drivers/char/Makefile
--- linux-2.6.11.6/drivers/char/Makefile	2005-04-03 00:10:55.000000000 +0200
+++ linux_HEAD/drivers/char/Makefile	2005-03-21 20:04:03.000000000 +0100
@@ -31,6 +31,7 @@ obj-$(CONFIG_MOXA_INTELLIO)	+= moxa.o
 obj-$(CONFIG_A2232)		+= ser_a2232.o generic_serial.o
 obj-$(CONFIG_ATARI_DSP56K)	+= dsp56k.o
 obj-$(CONFIG_MOXA_SMARTIO)	+= mxser.o
+obj-$(CONFIG_SIBYTE_SB1250_DUART) += sb1250_duart.o
 obj-$(CONFIG_COMPUTONE)		+= ip2.o ip2main.o
 obj-$(CONFIG_RISCOM8)		+= riscom8.o
 obj-$(CONFIG_ISI)		+= isicom.o
@@ -74,6 +75,10 @@ obj-$(CONFIG_DS1620) += ds1620.o
 obj-$(CONFIG_QIC02_TAPE) += tpqic02.o
 obj-$(CONFIG_FTAPE) += ftape/
 obj-$(CONFIG_COBALT_LCD) += lcd.o
+obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
+obj-$(CONFIG_AU1000_GPIO) += au1000_gpio.o
+obj-$(CONFIG_AU1000_USB_TTY) += au1000_usbtty.o
+obj-$(CONFIG_AU1000_USB_RAW) += au1000_usbraw.o
 obj-$(CONFIG_PPDEV) += ppdev.o
 obj-$(CONFIG_NWBUTTON) += nwbutton.o
 obj-$(CONFIG_NWFLASH) += nwflash.o
@@ -90,7 +94,7 @@ obj-$(CONFIG_IPMI_HANDLER) += ipmi/
 obj-$(CONFIG_HANGCHECK_TIMER) += hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM) += tpm/
 # Files generated that shall be removed upon make clean
-clean-files := consolemap_deftbl.c defkeymap.c qtronixmap.c
+clean-files := consolemap_deftbl.c defkeymap.c qtronixmap.c ibm_workpad_keymap.c
 
 quiet_cmd_conmk = CONMK   $@
       cmd_conmk = scripts/conmakehash $< > $@
@@ -102,6 +106,8 @@ $(obj)/defkeymap.o:  $(obj)/defkeymap.c
 
 $(obj)/qtronixmap.o: $(obj)/qtronixmap.c
 
+$(obj)/ibm_workpad_keymap.o: $(obj)/ibm_workpad_keymap.c
+
 # Uncomment if you're changing the keymap and have an appropriate
 # loadkeys version for the map. By default, we'll use the shipped
 # versions.
@@ -109,7 +115,8 @@ $(obj)/qtronixmap.o: $(obj)/qtronixmap.c
 
 ifdef GENERATE_KEYMAP
 
-$(obj)/defkeymap.c $(obj)/qtronixmap.c: $(obj)/%.c: $(src)/%.map
+$(obj)/defkeymap.c $(obj)/qtronixmap.c $(obj)/ibm_workpad_keymap.c: \
+		$(obj)/%.c: $(src)/%.map
 	loadkeys --mktable $< > $@.tmp
 	sed -e 's/^static *//' $@.tmp > $@
 	rm $@.tmp
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/au1000_gpio.c linux_HEAD/drivers/char/au1000_gpio.c
--- linux-2.6.11.6/drivers/char/au1000_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/char/au1000_gpio.c	2005-02-28 16:56:48.000000000 +0100
@@ -0,0 +1,266 @@
+/*
+ * FILE NAME au1000_gpio.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *  Driver for Alchemy Au1000 GPIO.
+ *
+ *  Author: MontaVista Software, Inc.  <source@mvista.com>
+ *          Steve Longerbeam <stevel@mvista.com>
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/au1000_gpio.h>
+
+#define VERSION "0.01"
+
+static const struct {
+	u32 active_hi;
+	u32 avail_mask;
+} pinfunc_to_avail[15] = {
+	{1,  0x7<<16},   // 0  = SSI0     / GPIO[18:16]
+	{-1, 0},         // 1  = AC97     / SSI1
+	{1,  1<<19},     // 2  = IRDA     / GPIO19
+	{1,  1<<20},     // 3  = UART0    / GPIO20
+	{1,  0x1f<<24},  // 4  = NIC2     / GPIO[28:24]
+	{1,  0x7<<29},   // 5  = I2S      / GPIO[31:29]
+	{0,  1<<8},      // 6  = I2SDI    / GPIO8
+	{0,  0x3f<<9},   // 7  = UART3    / GPIO[14:9]
+	{0,  1<<15},     // 8  = IRFIRSEL / GPIO15
+	{0,  1<<2},      // 9  = EXTCLK0 or OSC / GPIO2
+	{0,  1<<3},      // 10 = EXTCLK1  / GPIO3
+	{0,  1<<6},      // 11 = SMROMCKE / GPIO6
+	{1,  1<<21},     // 12 = UART1    / GPIO21
+	{1,  1<<22},     // 13 = UART2    / GPIO22
+	{1,  1<<23}      // 14 = UART3    / GPIO23
+};
+
+	
+u32 get_au1000_avail_gpio_mask(void)
+{
+	int i;
+	u32 pinfunc = inl(SYS_PINFUNC);
+	u32 avail_mask = 0; // start with no gpio available
+
+	// first, check for GPIO's reprogrammed as peripheral pins
+	for (i=0; i<15; i++) {
+		if (pinfunc_to_avail[i].active_hi < 0)
+			continue;
+		if (!(pinfunc_to_avail[i].active_hi ^
+		      ((pinfunc & (1<<i)) ? 1:0)))
+			avail_mask |= pinfunc_to_avail[i].avail_mask;
+	}
+
+	// check for GPIO's used as interrupt sources
+	avail_mask &= ~(inl(IC1_MASKRD) &
+			(inl(IC1_CFG0RD) | inl(IC1_CFG1RD)));
+
+#ifdef CONFIG_USB_OHCI
+	avail_mask &= ~((1<<4) | (1<<11));
+#ifndef CONFIG_AU1X00_USB_DEVICE
+	avail_mask &= ~((1<<5) | (1<<13));
+#endif
+#endif
+	
+	return avail_mask;
+}
+
+
+/*
+ * Tristate the requested GPIO pins specified in data.
+ * Only available GPIOs will be tristated.
+ */
+int au1000gpio_tristate(u32 data)
+{
+	data &= get_au1000_avail_gpio_mask();
+
+	if (data)
+		outl(data, SYS_TRIOUTCLR);
+
+	return 0;
+}
+
+
+/*
+ * Return the pin state. Pins configured as outputs will return
+ * the output state, and pins configured as inputs (tri-stated)
+ * will return input pin state.
+ */
+int au1000gpio_in(u32 *data)
+{
+	*data = inl(SYS_PINSTATERD);
+	return 0;
+}
+
+
+/*
+ * Set/clear GPIO pins. Only available GPIOs will be affected.
+ */
+int au1000gpio_set(u32 data)
+{
+	data &= get_au1000_avail_gpio_mask();
+
+	if (data)
+		outl(data, SYS_OUTPUTSET);
+	return 0;
+}
+
+int au1000gpio_clear(u32 data)
+{
+	data &= get_au1000_avail_gpio_mask();
+
+	if (data)
+		outl(data, SYS_OUTPUTCLR);
+	return 0;
+}
+
+/*
+ * Output data to GPIO pins. Only available GPIOs will be affected.
+ */
+int au1000gpio_out(u32 data)
+{
+	au1000gpio_set(data);
+	au1000gpio_clear(~data);
+	return 0;
+}
+
+
+EXPORT_SYMBOL(get_au1000_avail_gpio_mask);
+EXPORT_SYMBOL(au1000gpio_tristate);
+EXPORT_SYMBOL(au1000gpio_in);
+EXPORT_SYMBOL(au1000gpio_set);
+EXPORT_SYMBOL(au1000gpio_clear);
+EXPORT_SYMBOL(au1000gpio_out);
+
+
+static int au1000gpio_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+static int au1000gpio_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+static int au1000gpio_ioctl(struct inode *inode, struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	int status;
+	u32 val;
+	
+	switch(cmd) {
+	case AU1000GPIO_IN:
+		
+		status = au1000gpio_in(&val);
+		if (status != 0)
+			return status;
+
+		return put_user(val, (u32 *)arg);
+
+	case AU1000GPIO_OUT:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_out(val);
+
+	case AU1000GPIO_SET:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_set(val);
+		
+	case AU1000GPIO_CLEAR:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_clear(val);
+
+	case AU1000GPIO_TRISTATE:
+
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		return au1000gpio_tristate(val);
+
+	case AU1000GPIO_AVAIL_MASK:
+		
+		return put_user(get_au1000_avail_gpio_mask(),
+				(u32 *)arg);
+		
+	default:
+		return -ENOIOCTLCMD;
+
+	}
+
+	return 0;
+}
+
+
+static struct file_operations au1000gpio_fops =
+{
+	.owner		= THIS_MODULE,
+	.ioctl		= au1000gpio_ioctl,
+	.open		= au1000gpio_open,
+	.release	= au1000gpio_release,
+};
+
+
+static struct miscdevice au1000gpio_miscdev =
+{
+	MISC_DYNAMIC_MINOR,
+	"au1000_gpio",
+	&au1000gpio_fops
+};
+
+
+int __init au1000gpio_init(void)
+{
+	misc_register(&au1000gpio_miscdev);
+	printk("Au1000 gpio driver, version %s\n", VERSION);
+	return 0;
+}	
+
+
+void __exit au1000gpio_exit(void)
+{
+	misc_deregister(&au1000gpio_miscdev);
+}
+
+
+module_init(au1000gpio_init);
+module_exit(au1000gpio_exit);
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/au1000_ts.c linux_HEAD/drivers/char/au1000_ts.c
--- linux-2.6.11.6/drivers/char/au1000_ts.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/char/au1000_ts.c	2005-02-28 16:56:48.000000000 +0100
@@ -0,0 +1,677 @@
+/*
+ *      au1000_ts.c  --  Touch screen driver for the Alchemy Au1000's
+ *                       SSI Port 0 talking to the ADS7846 touch screen
+ *                       controller.
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Notes:
+ *
+ *  Revision history
+ *    06.27.2001  Initial version
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/string.h>
+#include <linux/ioport.h>       /* request_region */
+#include <linux/interrupt.h>    /* mark_bh */
+#include <asm/uaccess.h>        /* get_user,copy_to_user */
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#define TS_NAME "au1000-ts"
+#define TS_MAJOR 11
+
+#define PFX TS_NAME
+#define AU1000_TS_DEBUG 1
+
+#ifdef AU1000_TS_DEBUG
+#define dbg(format, arg...) printk(KERN_DEBUG PFX ": " format "\n" , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING PFX ": " format "\n" , ## arg)
+
+
+// SSI Status register bit defines
+#define SSISTAT_BF    (1<<4)
+#define SSISTAT_OF    (1<<3)
+#define SSISTAT_UF    (1<<2)
+#define SSISTAT_DONE  (1<<1)
+#define SSISTAT_BUSY  (1<<0)
+
+// SSI Interrupt Pending and Enable register bit defines
+#define SSIINT_OI     (1<<3)
+#define SSIINT_UI     (1<<2)
+#define SSIINT_DI     (1<<1)
+
+// SSI Address/Data register bit defines
+#define SSIADAT_D         (1<<24)
+#define SSIADAT_ADDR_BIT  16
+#define SSIADAT_ADDR_MASK (0xff<<SSIADAT_ADDR_BIT)
+#define SSIADAT_DATA_BIT  0
+#define SSIADAT_DATA_MASK (0xfff<<SSIADAT_DATA_BIT)
+
+// SSI Enable register bit defines
+#define SSIEN_CD (1<<1)
+#define SSIEN_E  (1<<0)
+
+// SSI Config register bit defines
+#define SSICFG_AO (1<<24)
+#define SSICFG_DO (1<<23)
+#define SSICFG_ALEN_BIT 20
+#define SSICFG_ALEN_MASK (0x7<<SSICFG_ALEN_BIT)
+#define SSICFG_DLEN_BIT 16
+#define SSICFG_DLEN_MASK (0xf<<SSICFG_DLEN_BIT)
+#define SSICFG_DD (1<<11)
+#define SSICFG_AD (1<<10)
+#define SSICFG_BM_BIT 8
+#define SSICFG_BM_MASK (0x3<<SSICFG_BM_BIT)
+#define SSICFG_CE (1<<7)
+#define SSICFG_DP (1<<6)
+#define SSICFG_DL (1<<5)
+#define SSICFG_EP (1<<4)
+
+// Bus Turnaround Selection
+#define SCLK_HOLD_HIGH 0
+#define SCLK_HOLD_LOW  1
+#define SCLK_CYCLE     2
+
+/*
+ * Default config for SSI0:
+ *
+ *   - transmit MSBit first
+ *   - expect MSBit first on data receive
+ *   - address length 7 bits
+ *   - expect data length 12 bits
+ *   - do not disable Direction bit
+ *   - do not disable Address bits
+ *   - SCLK held low during bus turnaround
+ *   - Address and Data bits clocked out on falling edge of SCLK
+ *   - Direction bit high is a read, low is a write
+ *   - Direction bit precedes Address bits
+ *   - Active low enable signal
+ */
+
+#define DEFAULT_SSI_CONFIG \
+    (SSICFG_AO | SSICFG_DO | (6<<SSICFG_ALEN_BIT) | (11<<SSICFG_DLEN_BIT) |\
+    (SCLK_HOLD_LOW<<SSICFG_BM_BIT) | SSICFG_DP | SSICFG_EP)
+
+
+// ADS7846 Control Byte bit defines
+#define ADS7846_ADDR_BIT  4
+#define ADS7846_ADDR_MASK (0x7<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_X  (0x5<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_Y  (0x1<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_Z1 (0x3<<ADS7846_ADDR_BIT)
+#define   ADS7846_MEASURE_Z2 (0x4<<ADS7846_ADDR_BIT)
+#define ADS7846_8BITS     (1<<3)
+#define ADS7846_12BITS    0
+#define ADS7846_SER       (1<<2)
+#define ADS7846_DFR       0
+#define ADS7846_PWR_BIT   0
+#define   ADS7846_PD      0
+#define   ADS7846_ADC_ON  (0x1<<ADS7846_PWR_BIT)
+#define   ADS7846_REF_ON  (0x2<<ADS7846_PWR_BIT)
+#define   ADS7846_REF_ADC_ON (0x3<<ADS7846_PWR_BIT)
+
+#define MEASURE_12BIT_X \
+    (ADS7846_MEASURE_X | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+#define MEASURE_12BIT_Y \
+    (ADS7846_MEASURE_Y | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+#define MEASURE_12BIT_Z1 \
+    (ADS7846_MEASURE_Z1 | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+#define MEASURE_12BIT_Z2 \
+    (ADS7846_MEASURE_Z2 | ADS7846_12BITS | ADS7846_DFR | ADS7846_PD)
+
+typedef enum {
+	IDLE = 0,
+	ACQ_X,
+	ACQ_Y,
+	ACQ_Z1,
+	ACQ_Z2
+} acq_state_t;
+
+/* +++++++++++++ Lifted from include/linux/h3600_ts.h ++++++++++++++*/
+typedef struct {
+	unsigned short pressure;  // touch pressure
+	unsigned short x;         // calibrated X
+	unsigned short y;         // calibrated Y
+	unsigned short millisecs; // timestamp of this event
+} TS_EVENT;
+
+typedef struct {
+	int xscale;
+	int xtrans;
+	int yscale;
+	int ytrans;
+	int xyswap;
+} TS_CAL;
+
+/* Use 'f' as magic number */
+#define IOC_MAGIC  'f'
+
+#define TS_GET_RATE             _IO(IOC_MAGIC, 8)
+#define TS_SET_RATE             _IO(IOC_MAGIC, 9)
+#define TS_GET_CAL              _IOR(IOC_MAGIC, 10, TS_CAL)
+#define TS_SET_CAL              _IOW(IOC_MAGIC, 11, TS_CAL)
+
+/* +++++++++++++ Done lifted from include/linux/h3600_ts.h +++++++++*/
+
+
+#define EVENT_BUFSIZE 128
+
+/*
+ * Which pressure equation to use from ADS7846 datasheet.
+ * The first equation requires knowing only the X plate
+ * resistance, but needs 4 measurements (X, Y, Z1, Z2).
+ * The second equation requires knowing both X and Y plate
+ * resistance, but only needs 3 measurements (X, Y, Z1).
+ * The second equation is preferred because of the shorter
+ * acquisition time required.
+ */
+enum {
+	PRESSURE_EQN_1 = 0,
+	PRESSURE_EQN_2
+};
+
+
+/*
+ * The touch screen's X and Y plate resistances, used by
+ * pressure equations.
+ */
+#define DEFAULT_X_PLATE_OHMS 580
+#define DEFAULT_Y_PLATE_OHMS 580
+
+/*
+ * Pen up/down pressure resistance thresholds.
+ *
+ * FIXME: these are bogus and will have to be found empirically.
+ *
+ * These are hysteresis points. If pen state is up and pressure
+ * is greater than pen-down threshold, pen transitions to down.
+ * If pen state is down and pressure is less than pen-up threshold,
+ * pen transitions to up. If pressure is in-between, pen status
+ * doesn't change.
+ *
+ * This wouldn't be needed if PENIRQ* from the ADS7846 were
+ * routed to an interrupt line on the Au1000. This would issue
+ * an interrupt when the panel is touched.
+ */
+#define DEFAULT_PENDOWN_THRESH_OHMS 100
+#define DEFAULT_PENUP_THRESH_OHMS    80
+
+typedef struct {
+	int baudrate;
+	u32 clkdiv;
+	acq_state_t acq_state;            // State of acquisition state machine
+	int x_raw, y_raw, z1_raw, z2_raw; // The current raw acquisition values
+	TS_CAL cal;                       // Calibration values
+	// The X and Y plate resistance, needed to calculate pressure
+	int x_plate_ohms, y_plate_ohms;
+	// pressure resistance at which pen is considered down/up
+	int pendown_thresh_ohms;
+	int penup_thresh_ohms;
+	int pressure_eqn;                 // eqn to use for pressure calc
+	int pendown;                      // 1 = pen is down, 0 = pen is up
+	TS_EVENT event_buf[EVENT_BUFSIZE];// The event queue
+	int nextIn, nextOut;
+	int event_count;
+	struct fasync_struct *fasync;     // asynch notification
+	struct timer_list acq_timer;      // Timer for triggering acquisitions
+	wait_queue_head_t wait;           // read wait queue
+	spinlock_t lock;
+	struct tq_struct chug_tq;
+} au1000_ts_t;
+
+static au1000_ts_t au1000_ts;
+
+
+static inline u32
+calc_clkdiv(int baud)
+{
+	u32 sys_busclk =
+		(get_au1000_speed() / (int)(inl(PM_POWERUP_CONTROL)&0x03) + 2);
+	return (sys_busclk / (2 * baud)) - 1;
+}
+
+static inline int
+calc_baudrate(u32 clkdiv)
+{
+	u32 sys_busclk =
+		(get_au1000_speed() / (int)(inl(PM_POWERUP_CONTROL)&0x03) + 2);
+	return sys_busclk / (2 * (clkdiv + 1));
+}
+
+
+/*
+ * This is a bottom-half handler that is scheduled after
+ * raw X,Y,Z1,Z2 coordinates have been acquired, and does
+ * the following:
+ *
+ *   - computes touch screen pressure resistance
+ *   - if pressure is above a threshold considered to be pen-down:
+ *         - compute calibrated X and Y coordinates
+ *         - queue a new TS_EVENT
+ *         - signal asynchronously and wake up any read
+ */
+static void
+chug_raw_data(void* private)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)private;
+	TS_EVENT event;
+	int Rt, Xcal, Ycal;
+	unsigned long flags;
+
+	// timestamp this new event.
+	event.millisecs = jiffies;
+
+	// Calculate touch pressure resistance
+	if (ts->pressure_eqn == PRESSURE_EQN_2) {
+		Rt = (ts->x_plate_ohms * ts->x_raw *
+		      (4096 - ts->z1_raw)) / ts->z1_raw;
+		Rt -= (ts->y_plate_ohms * ts->y_raw);
+		Rt = (Rt + 2048) >> 12; // round up to nearest ohm
+	} else {
+		Rt = (ts->x_plate_ohms * ts->x_raw *
+		      (ts->z2_raw - ts->z1_raw)) / ts->z1_raw;
+		Rt = (Rt + 2048) >> 12; // round up to nearest ohm
+	}
+
+	// hysteresis
+	if (!ts->pendown && Rt > ts->pendown_thresh_ohms)
+		ts->pendown = 1;
+	else if (ts->pendown && Rt < ts->penup_thresh_ohms)
+		ts->pendown = 0;
+
+	if (ts->pendown) {
+		// Pen is down
+		// Calculate calibrated X,Y
+		Xcal = ((ts->cal.xscale * ts->x_raw) >> 8) + ts->cal.xtrans;
+		Ycal = ((ts->cal.yscale * ts->y_raw) >> 8) + ts->cal.ytrans;
+
+		event.x = (unsigned short)Xcal;
+		event.y = (unsigned short)Ycal;
+		event.pressure = (unsigned short)Rt;
+
+		// add this event to the event queue
+		spin_lock_irqsave(&ts->lock, flags);
+		ts->event_buf[ts->nextIn++] = event;
+		if (ts->nextIn == EVENT_BUFSIZE)
+			ts->nextIn = 0;
+		if (ts->event_count < EVENT_BUFSIZE) {
+			ts->event_count++;
+		} else {
+			// throw out the oldest event
+			if (++ts->nextOut == EVENT_BUFSIZE)
+				ts->nextOut = 0;
+		}
+		spin_unlock_irqrestore(&ts->lock, flags);
+
+		// async notify
+		if (ts->fasync)
+			kill_fasync(&ts->fasync, SIGIO, POLL_IN);
+		// wake up any read call
+		if (waitqueue_active(&ts->wait))
+			wake_up_interruptible(&ts->wait);
+	}
+}
+
+
+/*
+ * Raw X,Y,pressure acquisition timer function. This triggers
+ * the start of a new acquisition. Its duration between calls
+ * is the touch screen polling rate.
+ */
+static void
+au1000_acq_timer(unsigned long data)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	// start acquisition with X coordinate
+	ts->acq_state = ACQ_X;
+	// start me up
+	outl(SSIADAT_D | (MEASURE_12BIT_X << SSIADAT_ADDR_BIT), SSI0_ADATA);
+
+	// schedule next acquire
+	ts->acq_timer.expires = jiffies + HZ / 100;
+	add_timer(&ts->acq_timer);
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+}
+
+static void
+ssi0_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	au1000_ts_t *ts = (au1000_ts_t*)dev_id;
+	u32 stat, int_stat, data;
+
+	spin_lock(&ts->lock);
+
+	stat = inl(SSI0_STATUS);
+	// clear sticky status bits
+	outl(stat & (SSISTAT_OF|SSISTAT_UF|SSISTAT_DONE), SSI0_STATUS);
+
+	int_stat = inl(SSI0_INT);
+	// clear sticky intr status bits
+	outl(int_stat & (SSIINT_OI|SSIINT_UI|SSIINT_DI), SSI0_INT);
+
+	if ((int_stat & (SSIINT_OI|SSIINT_UI|SSIINT_DI)) != SSIINT_DI) {
+		if (int_stat & SSIINT_OI)
+			err("overflow");
+		if (int_stat & SSIINT_UI)
+			err("underflow");
+		spin_unlock(&ts->lock);
+		return;
+	}
+
+	data = inl(SSI0_ADATA) & SSIADAT_DATA_MASK;
+
+	switch (ts->acq_state) {
+	case IDLE:
+		break;
+	case ACQ_X:
+		ts->x_raw = data;
+		ts->acq_state = ACQ_Y;
+		// trigger Y acq
+		outl(SSIADAT_D | (MEASURE_12BIT_Y << SSIADAT_ADDR_BIT),
+		     SSI0_ADATA);
+		break;
+	case ACQ_Y:
+		ts->y_raw = data;
+		ts->acq_state = ACQ_Z1;
+		// trigger Z1 acq
+		outl(SSIADAT_D | (MEASURE_12BIT_Z1 << SSIADAT_ADDR_BIT),
+		     SSI0_ADATA);
+		break;
+	case ACQ_Z1:
+		ts->z1_raw = data;
+		if (ts->pressure_eqn == PRESSURE_EQN_2) {
+			// don't acq Z2, using 2nd eqn for touch pressure
+			ts->acq_state = IDLE;
+			// got the raw stuff, now mark BH
+			queue_task(&ts->chug_tq, &tq_immediate);
+			mark_bh(IMMEDIATE_BH);
+		} else {
+			ts->acq_state = ACQ_Z2;
+			// trigger Z2 acq
+			outl(SSIADAT_D | (MEASURE_12BIT_Z2<<SSIADAT_ADDR_BIT),
+			     SSI0_ADATA);
+		}
+		break;
+	case ACQ_Z2:
+		ts->z2_raw = data;
+		ts->acq_state = IDLE;
+		// got the raw stuff, now mark BH
+		queue_task(&ts->chug_tq, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
+		break;
+	}
+
+	spin_unlock(&ts->lock);
+}
+
+
+/* +++++++++++++ File operations ++++++++++++++*/
+
+static int
+au1000_fasync(int fd, struct file *filp, int mode)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	return fasync_helper(fd, filp, mode, &ts->fasync);
+}
+
+static int
+au1000_ioctl(struct inode * inode, struct file *filp,
+	     unsigned int cmd, unsigned long arg)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+
+	switch(cmd) {
+	case TS_GET_RATE:       /* TODO: what is this? */
+		break;
+	case TS_SET_RATE:       /* TODO: what is this? */
+		break;
+	case TS_GET_CAL:
+		copy_to_user((char *)arg, (char *)&ts->cal, sizeof(TS_CAL));
+		break;
+	case TS_SET_CAL:
+		copy_from_user((char *)&ts->cal, (char *)arg, sizeof(TS_CAL));
+		break;
+	default:
+		err("unknown cmd %04x", cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned int
+au1000_poll(struct file * filp, poll_table * wait)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	poll_wait(filp, &ts->wait, wait);
+	if (ts->event_count)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static ssize_t
+au1000_read(struct file * filp, char * buf, size_t count, loff_t * l)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	unsigned long flags;
+	TS_EVENT event;
+	int i;
+
+	if (ts->event_count == 0) {
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		interruptible_sleep_on(&ts->wait);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+	}
+
+	for (i = count;
+	     i >= sizeof(TS_EVENT);
+	     i -= sizeof(TS_EVENT), buf += sizeof(TS_EVENT)) {
+		if (ts->event_count == 0)
+			break;
+		spin_lock_irqsave(&ts->lock, flags);
+		event = ts->event_buf[ts->nextOut++];
+		if (ts->nextOut == EVENT_BUFSIZE)
+			ts->nextOut = 0;
+		if (ts->event_count)
+			ts->event_count--;
+		spin_unlock_irqrestore(&ts->lock, flags);
+		copy_to_user(buf, &event, sizeof(TS_EVENT));
+	}
+
+	return count - i;
+}
+
+
+static int
+au1000_open(struct inode * inode, struct file * filp)
+{
+	au1000_ts_t* ts;
+	unsigned long flags;
+
+	filp->private_data = ts = &au1000_ts;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	// setup SSI0 config
+	outl(DEFAULT_SSI_CONFIG, SSI0_CONFIG);
+
+	// clear out SSI0 status bits
+	outl(SSISTAT_OF|SSISTAT_UF|SSISTAT_DONE, SSI0_STATUS);
+	// clear out SSI0 interrupt pending bits
+	outl(SSIINT_OI|SSIINT_UI|SSIINT_DI, SSI0_INT);
+
+	// enable SSI0 interrupts
+	outl(SSIINT_OI|SSIINT_UI|SSIINT_DI, SSI0_INT_ENABLE);
+
+	/*
+	 * init bh handler that chugs the raw data (calibrates and
+	 * calculates touch pressure).
+	 */
+	ts->chug_tq.routine = chug_raw_data;
+	ts->chug_tq.data = ts;
+	ts->pendown = 0; // pen up
+	
+	// flush event queue
+	ts->nextIn = ts->nextOut = ts->event_count = 0;
+	
+	// Start acquisition timer function
+	init_timer(&ts->acq_timer);
+	ts->acq_timer.function = au1000_acq_timer;
+	ts->acq_timer.data = (unsigned long)ts;
+	ts->acq_timer.expires = jiffies + HZ / 100;
+	add_timer(&ts->acq_timer);
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	return 0;
+}
+
+static int
+au1000_release(struct inode * inode, struct file * filp)
+{
+	au1000_ts_t* ts = (au1000_ts_t*)filp->private_data;
+	unsigned long flags;
+	
+	au1000_fasync(-1, filp, 0);
+	del_timer_sync(&ts->acq_timer);
+
+	spin_lock_irqsave(&ts->lock, flags);
+	// disable SSI0 interrupts
+	outl(0, SSI0_INT_ENABLE);
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	return 0;
+}
+
+
+static struct file_operations ts_fops = {
+	.read           = au1000_read,
+	.poll           = au1000_poll,
+	.ioctl		= au1000_ioctl,
+	.fasync         = au1000_fasync,
+	.open		= au1000_open,
+	.release	= au1000_release,
+};
+
+/* +++++++++++++ End File operations ++++++++++++++*/
+
+
+int __init
+au1000ts_init_module(void)
+{
+	au1000_ts_t* ts = &au1000_ts;
+	int ret;
+
+	/* register our character device */
+	if ((ret = register_chrdev(TS_MAJOR, TS_NAME, &ts_fops)) < 0) {
+		err("can't get major number");
+		return ret;
+	}
+	info("registered");
+
+	memset(ts, 0, sizeof(au1000_ts_t));
+	init_waitqueue_head(&ts->wait);
+	spin_lock_init(&ts->lock);
+
+	if (!request_region(virt_to_phys((void*)SSI0_STATUS), 0x100, TS_NAME)) {
+		err("SSI0 ports in use");
+		return -ENXIO;
+	}
+
+	if ((ret = request_irq(AU1000_SSI0_INT, ssi0_interrupt,
+			       SA_SHIRQ | SA_INTERRUPT, TS_NAME, ts))) {
+		err("could not get IRQ");
+		return ret;
+	}
+
+	// initial calibration values
+	ts->cal.xscale = -93;
+	ts->cal.xtrans = 346;
+	ts->cal.yscale = -64;
+	ts->cal.ytrans = 251;
+
+	// init pen up/down hysteresis points
+	ts->pendown_thresh_ohms = DEFAULT_PENDOWN_THRESH_OHMS;
+	ts->penup_thresh_ohms = DEFAULT_PENUP_THRESH_OHMS;
+	ts->pressure_eqn = PRESSURE_EQN_2;
+	// init X and Y plate resistances
+	ts->x_plate_ohms = DEFAULT_X_PLATE_OHMS;
+	ts->y_plate_ohms = DEFAULT_Y_PLATE_OHMS;
+
+	// set GPIO to SSI0 function
+	outl(inl(PIN_FUNCTION) & ~1, PIN_FUNCTION);
+	
+	// enable SSI0 clock and bring SSI0 out of reset
+	outl(0, SSI0_CONTROL);
+	udelay(1000);
+	outl(SSIEN_E, SSI0_CONTROL);
+	udelay(100);
+	
+	// FIXME: is this a working baudrate?
+	ts->clkdiv = 0;
+	ts->baudrate = calc_baudrate(ts->clkdiv);
+	outl(ts->clkdiv, SSI0_CLKDIV);
+
+	info("baudrate = %d Hz", ts->baudrate);
+	
+	return 0;
+}
+
+void
+au1000ts_cleanup_module(void)
+{
+	// disable clocks and hold in reset
+	outl(SSIEN_CD, SSI0_CONTROL);
+	free_irq(AU1000_SSI0_INT, &au1000_ts);
+	release_region(virt_to_phys((void*)SSI0_STATUS), 0x100);
+	unregister_chrdev(TS_MAJOR, TS_NAME);
+}
+
+/* Module information */
+MODULE_AUTHOR("Steve Longerbeam, stevel@mvista.com, www.mvista.com");
+MODULE_DESCRIPTION("Au1000/ADS7846 Touch Screen Driver");
+
+module_init(au1000ts_init_module);
+module_exit(au1000ts_cleanup_module);
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/au1000_usbraw.c linux_HEAD/drivers/char/au1000_usbraw.c
--- linux-2.6.11.6/drivers/char/au1000_usbraw.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/char/au1000_usbraw.c	2005-02-28 16:56:48.000000000 +0100
@@ -0,0 +1,573 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1x00 USB Device-Side Raw Block Driver (function layer)
+ *
+ * Copyright 2001-2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *		stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#undef DEBUG
+#include <linux/usb.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1000_usbdev.h>
+
+#define USBRAW_MAJOR 190 // FIXME: need a legal major
+#define USBRAW_NAME "usbraw"
+
+#define MAX_NUM_PORTS 2
+
+#define IN_MAX_PACKET_SIZE  64
+#define OUT_MAX_PACKET_SIZE 64
+
+// FIXME: when Au1x00 endpoints 3 and 5 are fixed, make NUM_PORTS=2
+#define NUM_PORTS 1
+#define NUM_EP 2*NUM_PORTS
+
+#define CONFIG_DESC_LEN \
+ USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE + NUM_EP*USB_DT_ENDPOINT_SIZE
+
+/* must be power of two */
+#define READ_BUF_SIZE (1<<12)
+
+struct usb_raw_port {
+	unsigned char number;
+	spinlock_t port_lock;
+
+	struct usb_endpoint_descriptor* out_desc;
+	struct usb_endpoint_descriptor* in_desc;
+
+	int out_ep_addr; /* endpoint address of OUT endpoint */
+	int in_ep_addr;  /* endpoint address of IN endpoint */
+	
+	__u8 read_buf[READ_BUF_SIZE]; // FIXME: allocate with get_free_pages
+	int read_nextin, read_nextout;
+	int read_count;
+
+	wait_queue_head_t wait;
+	struct fasync_struct *fasync;     // asynch notification
+
+	int active;	/* someone has this device open */
+	int open_count;	/* number of times this port has been opened */
+};
+
+static struct usb_serial {
+	struct usb_device_descriptor* dev_desc;
+	struct usb_config_descriptor* config_desc;
+	struct usb_interface_descriptor* if_desc;
+	struct usb_string_descriptor * str_desc[6];
+	void* str_desc_buf;
+
+	usbdev_state_t dev_state;
+
+	struct usb_raw_port port[NUM_PORTS];
+} usbraw;
+
+static struct usb_device_descriptor dev_desc = {
+	bLength:USB_DT_DEVICE_SIZE,
+	bDescriptorType:USB_DT_DEVICE,
+	bcdUSB:USBDEV_REV,		//usb rev
+	bDeviceClass:USB_CLASS_PER_INTERFACE,	//class    (none)
+	bDeviceSubClass:0x00,	//subclass (none)
+	bDeviceProtocol:0x00,	//protocol (none)
+	bMaxPacketSize0:USBDEV_EP0_MAX_PACKET_SIZE, //max packet size for ep0
+	idVendor:0x6d04,	//vendor  id
+	idProduct:0x0bc0,	//product id
+	bcdDevice:0x0001,	//BCD rev 0.1
+	iManufacturer:0x01,	//manufactuer string index
+	iProduct:0x02,		//product string index
+	iSerialNumber:0x03,	//serial# string index
+	bNumConfigurations:0x01	//num configurations
+};
+
+static struct usb_endpoint_descriptor ep_desc[] = {
+	{
+		// Bulk IN for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk IN for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	}
+};
+
+static struct usb_interface_descriptor if_desc = {
+	bLength:USB_DT_INTERFACE_SIZE,
+	bDescriptorType:USB_DT_INTERFACE,
+	bInterfaceNumber:0x00,
+	bAlternateSetting:0x00,
+	bNumEndpoints:NUM_EP,
+	bInterfaceClass:0xff,
+	bInterfaceSubClass:0xab,
+	bInterfaceProtocol:0x00,
+	iInterface:0x05
+};
+
+static struct usb_config_descriptor config_desc = {
+	bLength:USB_DT_CONFIG_SIZE,
+	bDescriptorType:USB_DT_CONFIG,
+	wTotalLength:CONFIG_DESC_LEN,
+	bNumInterfaces:0x01,
+	bConfigurationValue:0x01,
+	iConfiguration:0x04,	// configuration string
+	bmAttributes:0xc0,	// self-powered
+	MaxPower:20		// 40 mA
+};
+
+// String[0] is a list of Language IDs supported by this device
+static struct usb_string_descriptor string_desc0 = {
+	bLength:4,
+	bDescriptorType:USB_DT_STRING,
+	wData:{0x0409} // English, US
+};
+
+// These strings will be converted to Unicode in string_desc[]
+static char *strings[5] = {
+	"Alchemy Semiconductor",  // iManufacturer
+	"USB Raw Block Device",   // iProduct
+	"0.1",                    // iSerialNumber
+	"USB Raw Config",         // iConfiguration
+	"USB Raw Interface"       // iInterface
+};
+
+
+static void
+receive_callback(struct usb_raw_port *port)
+{
+	int i, pkt_size;
+	usbdev_pkt_t* pkt;
+	
+	if ((pkt_size = usbdev_receive_packet(port->out_ep_addr,
+					      &pkt)) <= 0) {
+		dbg(__FUNCTION__ ": usbdev_receive_packet returns %d",
+		    pkt_size);
+		return;
+	}
+
+	dbg(__FUNCTION__ ": ep%d, size=%d", port->out_ep_addr, pkt_size);
+
+	spin_lock(&port->port_lock);
+	for (i=0; i < pkt_size; i++) {
+		port->read_buf[port->read_nextin++] = pkt->payload[i];
+		port->read_nextin &= (READ_BUF_SIZE - 1);
+		if (++port->read_count == READ_BUF_SIZE)
+			break;
+	}
+	spin_unlock(&port->port_lock);
+
+	/* free the packet */
+	kfree(pkt);
+	
+	// async notify
+	if (port->fasync)
+		kill_fasync(&port->fasync, SIGIO, POLL_IN);
+	// wake up any read call
+	if (waitqueue_active(&port->wait))
+		wake_up_interruptible(&port->wait);
+}
+
+static void
+transmit_callback(struct usb_raw_port *port, usbdev_pkt_t* pkt)
+{
+	dbg(__FUNCTION__ ": ep%d", port->in_ep_addr);
+	/* just free the returned packet */
+	kfree(pkt);
+}
+
+
+static void
+usbraw_callback(usbdev_cb_type_t cb_type, unsigned long arg, void* data)
+{
+	usbdev_pkt_t* pkt;
+	int i;
+	
+	switch (cb_type) {
+	case CB_NEW_STATE:
+		usbraw.dev_state = (usbdev_state_t)arg;
+		break;
+	case CB_PKT_COMPLETE:
+		pkt = (usbdev_pkt_t*)arg;
+		for (i=0; i<NUM_PORTS; i++) {
+			struct usb_raw_port *port = &usbraw.port[i];
+			if (pkt->ep_addr == port->in_ep_addr) {
+				transmit_callback(port, pkt);
+				break;
+			} else if (pkt->ep_addr == port->out_ep_addr) {
+				receive_callback(port);
+				break;
+			}
+		}
+		break;
+	}
+}
+
+/*****************************************************************************
+ * Here begins the driver interface functions
+ *****************************************************************************/
+
+static unsigned int usbraw_poll(struct file * filp, poll_table * wait)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	unsigned long flags;
+	int count;
+	
+	poll_wait(filp, &port->wait, wait);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	count = port->read_count;
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	if (count > 0) {
+		dbg(__FUNCTION__ ": count=%d", count);
+		return POLLIN | POLLRDNORM;
+	}
+	
+	return 0;
+}
+
+static int usbraw_fasync(int fd, struct file *filp, int mode)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	return fasync_helper(fd, filp, mode, &port->fasync);
+}
+
+static int usbraw_open(struct inode * inode, struct file *filp)
+{
+	int portNumber;
+	struct usb_raw_port *port;
+	unsigned long flags;
+
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbraw.dev_state != CONFIGURED)
+		return -ENODEV;
+	
+	/* set up our port structure making the tty driver remember
+	   our port object, and us it */
+	portNumber = MINOR(inode->i_rdev);
+	port = &usbraw.port[portNumber];
+	filp->private_data = port;
+
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	++port->open_count;
+
+	if (!port->active) {
+		port->active = 1;
+	}
+
+	/* flush read buffer */
+	port->read_nextin = port->read_nextout = port->read_count = 0;
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return 0;
+}
+
+static int usbraw_release(struct inode * inode, struct file * filp)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	unsigned long flags;
+
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not opened");
+		return -ENODEV;
+	}
+
+	usbraw_fasync(-1, filp, 0);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	--port->open_count;
+
+	if (port->open_count <= 0) {
+		port->active = 0;
+		port->open_count = 0;
+	}
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return 0;
+}
+
+
+static ssize_t usbraw_read(struct file * filp, char * buf,
+			   size_t count, loff_t * l)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	unsigned long flags;
+	int i, cnt;
+
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbraw.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	do { 
+		spin_lock_irqsave(&port->port_lock, flags);
+		cnt = port->read_count;
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		if (cnt == 0) {
+			if (filp->f_flags & O_NONBLOCK)
+				return -EAGAIN;
+			interruptible_sleep_on(&port->wait);
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+		}
+	} while (cnt == 0);
+
+	count = (count > cnt) ? cnt : count;
+
+	for (i=0; i<count; i++) {
+		put_user(port->read_buf[port->read_nextout++], &buf[i]);
+		port->read_nextout &= (READ_BUF_SIZE - 1);
+		spin_lock_irqsave(&port->port_lock, flags);
+		port->read_count--;
+		spin_unlock_irqrestore(&port->port_lock, flags);
+		if (port->read_count == 0)
+			break;
+	}
+
+	return i+1;
+}
+
+static ssize_t usbraw_write(struct file * filp, const char * buf,
+			    size_t count, loff_t *ppos)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+	usbdev_pkt_t* pkt;
+	int ret, max_pkt_sz;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbraw.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not opened");
+		return -EINVAL;
+	}
+
+	if (count == 0) {
+		dbg(__FUNCTION__ ": write request of 0 bytes");
+		return (0);
+	}
+
+	max_pkt_sz = port->in_desc->wMaxPacketSize;
+	count = (count > max_pkt_sz) ? max_pkt_sz : count;
+
+	if ((ret = usbdev_alloc_packet(port->in_ep_addr, count, &pkt)) < 0)
+		return ret;
+
+	copy_from_user(pkt->payload, buf, count);
+	
+	return usbdev_send_packet(port->in_ep_addr, pkt);
+}
+
+static int usbraw_ioctl(struct inode *inode, struct file *filp,
+			unsigned int cmd, unsigned long arg)
+{
+	struct usb_raw_port *port = (struct usb_raw_port *)filp->private_data;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -ENODEV;
+	}
+	// FIXME: need any IOCTLs?
+
+	return -ENOIOCTLCMD;
+}
+
+
+static struct file_operations usbraw_fops = {
+        .owner          = THIS_MODULE,
+        .write          = usbraw_write,
+	.read           = usbraw_read,
+	.poll           = usbraw_poll,
+	.ioctl		= usbraw_ioctl,
+	.fasync         = usbraw_fasync,
+	.open		= usbraw_open,
+	.release	= usbraw_release,
+};
+
+void usbfn_raw_exit(void)
+{
+	/* kill the device layer */
+	usbdev_exit();
+
+	unregister_chrdev(USBRAW_MAJOR, USBRAW_NAME);
+
+	if (usbraw.str_desc_buf)
+		kfree(usbraw.str_desc_buf);
+}
+
+
+int usbfn_raw_init(void)
+{
+	int ret = 0, i, str_desc_len;
+
+	/* register our character device */
+	if ((ret = register_chrdev(USBRAW_MAJOR, USBRAW_NAME,
+				   &usbraw_fops)) < 0) {
+		err("can't get major number");
+		return ret;
+	}
+	info("registered");
+
+	/*
+	 * initialize pointers to descriptors
+	 */
+	usbraw.dev_desc = &dev_desc;
+	usbraw.config_desc = &config_desc;
+	usbraw.if_desc = &if_desc;
+
+	/*
+	 * initialize the string descriptors
+	 */
+
+	/* alloc buffer big enough for all string descriptors */
+	str_desc_len = string_desc0.bLength;
+	for (i = 0; i < 5; i++)
+		str_desc_len += 2 + 2 * strlen(strings[i]);
+	usbraw.str_desc_buf = (void *) kmalloc(str_desc_len, GFP_KERNEL);
+	if (!usbraw.str_desc_buf) {
+		err(__FUNCTION__ ": failed to alloc string descriptors");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	usbraw.str_desc[0] =
+		(struct usb_string_descriptor *)usbraw.str_desc_buf;
+	memcpy(usbraw.str_desc[0], &string_desc0, string_desc0.bLength);
+	usbraw.str_desc[1] = (struct usb_string_descriptor *)
+		(usbraw.str_desc_buf + string_desc0.bLength);
+	for (i = 1; i < 6; i++) {
+		struct usb_string_descriptor *desc = usbraw.str_desc[i];
+		char *str = strings[i - 1];
+		int j, str_len = strlen(str);
+
+		desc->bLength = 2 + 2 * str_len;
+		desc->bDescriptorType = USB_DT_STRING;
+		for (j = 0; j < str_len; j++) {
+			desc->wData[j] = (u16) str[j];
+		}
+		if (i < 5)
+			usbraw.str_desc[i + 1] =
+				(struct usb_string_descriptor *)
+				((u8 *) desc + desc->bLength);
+	}
+
+	/*
+	 * start the device layer. The device layer assigns us
+	 * our endpoint addresses
+	 */
+	if ((ret = usbdev_init(&dev_desc, &config_desc, &if_desc, ep_desc,
+			       usbraw.str_desc, usbraw_callback, NULL))) {
+		err(__FUNCTION__ ": device-layer init failed");
+		goto out;
+	}
+	
+	/* initialize the devfs nodes for this device and let the user
+	   know what ports we are bound to */
+	for (i = 0; i < NUM_PORTS; ++i) {
+		struct usb_raw_port *port = &usbraw.port[i];
+
+		port->number = i;
+		port->in_desc = &ep_desc[NUM_PORTS*i];
+		port->out_desc = &ep_desc[NUM_PORTS*i + 1];
+		port->in_ep_addr = port->in_desc->bEndpointAddress & 0x0f;
+		port->out_ep_addr = port->out_desc->bEndpointAddress & 0x0f;
+		init_waitqueue_head(&port->wait);
+		spin_lock_init(&port->port_lock);
+	}
+
+ out:
+	if (ret)
+		usbfn_raw_exit();
+	return ret;
+}
+
+
+/* Module information */
+MODULE_AUTHOR("Steve Longerbeam, stevel@mvista.com, www.mvista.com");
+MODULE_DESCRIPTION("Au1x00 USB Device-Side Raw Block Driver");
+MODULE_LICENSE("GPL");
+
+module_init(usbfn_raw_init);
+module_exit(usbfn_raw_exit);
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/au1000_usbtty.c linux_HEAD/drivers/char/au1000_usbtty.c
--- linux-2.6.11.6/drivers/char/au1000_usbtty.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/char/au1000_usbtty.c	2005-02-28 16:56:48.000000000 +0100
@@ -0,0 +1,761 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1x00 USB Device-Side Serial TTY Driver (function layer)
+ *
+ * Copyright 2001-2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *		stevel@mvista.com or source@mvista.com
+ *
+ *  Derived from drivers/usb/serial/usbserial.c:
+ *
+ *  Copyright (C) 1999 - 2001 Greg Kroah-Hartman (greg@kroah.com)
+ *  Copyright (c) 2000 Peter Berger (pberger@brimson.com)
+ *  Copyright (c) 2000 Al Borchers (borchers@steinerpoint.com)
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/fcntl.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/smp_lock.h>
+#undef DEBUG
+#include <linux/usb.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/irq.h>
+#include <asm/au1000.h>
+#include <asm/au1000_usbdev.h>
+
+
+/* local function prototypes */
+static int serial_open(struct tty_struct *tty, struct file *filp);
+static void serial_close(struct tty_struct *tty, struct file *filp);
+static int serial_write(struct tty_struct *tty, int from_user,
+			const unsigned char *buf, int count);
+static int serial_write_room(struct tty_struct *tty);
+static int serial_chars_in_buffer(struct tty_struct *tty);
+static void serial_throttle(struct tty_struct *tty);
+static void serial_unthrottle(struct tty_struct *tty);
+static int serial_ioctl(struct tty_struct *tty, struct file *file,
+			unsigned int cmd, unsigned long arg);
+static void serial_set_termios (struct tty_struct *tty, struct termios * old);
+
+#define SERIAL_TTY_MAJOR 189 // FIXME: need a legal major
+
+#define MAX_NUM_PORTS 2
+
+#define IN_MAX_PACKET_SIZE  32
+#define OUT_MAX_PACKET_SIZE 32
+
+// FIXME: when Au1x00 endpoints 3 and 5 are fixed, make NUM_PORTS=2
+#define NUM_PORTS 2
+#define NUM_EP 2*NUM_PORTS
+
+#define CONFIG_DESC_LEN \
+ USB_DT_CONFIG_SIZE + USB_DT_INTERFACE_SIZE + NUM_EP*USB_DT_ENDPOINT_SIZE
+
+struct usb_serial_port {
+	struct tty_struct *tty;	   /* the coresponding tty for this port */
+	unsigned char number;
+	spinlock_t port_lock;
+
+	struct usb_endpoint_descriptor* out_desc;
+	struct usb_endpoint_descriptor* in_desc;
+
+	int out_ep_addr; /* endpoint address of OUT endpoint */
+	int in_ep_addr;  /* endpoint address of IN endpoint */
+	
+	/* task queue for line discipline waking up on send packet complete */
+	struct tq_struct send_complete_tq;
+	/* task queue for line discipline wakeup on receive packet complete */
+	struct tq_struct receive_complete_tq;
+
+	int active;	/* someone has this device open */
+	int writing;    /* a packet write is in progress */
+	int open_count;	/* number of times this port has been opened */
+
+};
+
+static struct usb_serial {
+	usbdev_state_t dev_state; // current state of device layer
+	struct usb_device_descriptor* dev_desc;
+	struct usb_config_descriptor* config_desc;
+	struct usb_interface_descriptor* if_desc;
+	struct usb_string_descriptor * str_desc[6];
+	void* str_desc_buf;
+
+	struct usb_serial_port port[NUM_PORTS];
+} usbtty;
+
+static int                 serial_refcount;
+static struct tty_driver   serial_tty_driver;
+static struct tty_struct * serial_tty[NUM_PORTS];
+static struct termios *    serial_termios[NUM_PORTS];
+static struct termios *    serial_termios_locked[NUM_PORTS];
+
+static struct usb_device_descriptor dev_desc = {
+	bLength:USB_DT_DEVICE_SIZE,
+	bDescriptorType:USB_DT_DEVICE,
+	bcdUSB:USBDEV_REV,		//usb rev
+	bDeviceClass:USB_CLASS_PER_INTERFACE,	//class    (none)
+	bDeviceSubClass:0x00,	//subclass (none)
+	bDeviceProtocol:0x00,	//protocol (none)
+	bMaxPacketSize0:USBDEV_EP0_MAX_PACKET_SIZE, //max packet size for ep0
+	idVendor:0x6d04,	//vendor  id
+	idProduct:0x0bc0,	//product id
+	bcdDevice:0x0001,	//BCD rev 0.1
+	iManufacturer:0x01,	//manufactuer string index
+	iProduct:0x02,		//product string index
+	iSerialNumber:0x03,	//serial# string index
+	bNumConfigurations:0x01	//num configurations
+};
+
+static struct usb_endpoint_descriptor ep_desc[] = {
+	{
+		// Bulk IN for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 0
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk IN for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_IN,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:IN_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	},
+	{
+		// Bulk OUT for Port 1
+		bLength:USB_DT_ENDPOINT_SIZE,
+		bDescriptorType:USB_DT_ENDPOINT,
+		bEndpointAddress:USB_DIR_OUT,
+		bmAttributes:USB_ENDPOINT_XFER_BULK,
+		wMaxPacketSize:OUT_MAX_PACKET_SIZE,
+		bInterval:0x00	// ignored for bulk
+	}
+};
+
+static struct usb_interface_descriptor if_desc = {
+	bLength:USB_DT_INTERFACE_SIZE,
+	bDescriptorType:USB_DT_INTERFACE,
+	bInterfaceNumber:0x00,
+	bAlternateSetting:0x00,
+	bNumEndpoints:NUM_EP,
+	bInterfaceClass:0xff,
+	bInterfaceSubClass:0xab,
+	bInterfaceProtocol:0x00,
+	iInterface:0x05
+};
+
+static struct usb_config_descriptor config_desc = {
+	bLength:USB_DT_CONFIG_SIZE,
+	bDescriptorType:USB_DT_CONFIG,
+	wTotalLength:CONFIG_DESC_LEN,
+	bNumInterfaces:0x01,
+	bConfigurationValue:0x01,
+	iConfiguration:0x04,	// configuration string
+	bmAttributes:0xc0,	// self-powered
+	MaxPower:20		// 40 mA
+};
+
+// String[0] is a list of Language IDs supported by this device
+static struct usb_string_descriptor string_desc0 = {
+	bLength:4,
+	bDescriptorType:USB_DT_STRING,
+	wData:{0x0409} // English, US
+};
+
+// These strings will be converted to Unicode in string_desc[]
+static char *strings[5] = {
+	"Alchemy Semiconductor",  // iManufacturer
+	"WutzAMattaU",            // iProduct
+	"1.0.doh!",               // iSerialNumber
+	"Au1000 TTY Config",      // iConfiguration
+	"Au1000 TTY Interface"    // iInterface
+};
+
+static inline int
+port_paranoia_check(struct usb_serial_port *port, const char *function)
+{
+	if (!port) {
+		err("%s: port is NULL", function);
+		return -1;
+	}
+	if (!port->tty) {
+		err("%s: port->tty is NULL", function);
+		return -1;
+	}
+
+	return 0;
+}
+
+
+static void
+port_rx_callback(struct usb_serial_port *port)
+{
+	dbg(__FUNCTION__ ": ep%d", port->out_ep_addr);
+	// mark a bh to push this data up to the tty
+	queue_task(&port->receive_complete_tq, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static void
+port_tx_callback(struct usb_serial_port *port, usbdev_pkt_t* pkt)
+{
+	dbg(__FUNCTION__ ": ep%d", port->in_ep_addr);
+	// mark a bh to wakeup any tty write system call on the port.
+	queue_task(&port->send_complete_tq, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+
+	/* free the returned packet */
+	kfree(pkt);
+}
+
+static void
+usbtty_callback(usbdev_cb_type_t cb_type, unsigned long arg, void* data)
+{
+	usbdev_pkt_t* pkt;
+	int i;
+	
+	switch (cb_type) {
+	case CB_NEW_STATE:
+		dbg(__FUNCTION__ ": new dev_state=%d", (int)arg);
+		usbtty.dev_state = (usbdev_state_t)arg;
+		break;
+	case CB_PKT_COMPLETE:
+		pkt = (usbdev_pkt_t*)arg;
+		for (i=0; i<NUM_PORTS; i++) {
+			struct usb_serial_port *port = &usbtty.port[i];
+			if (pkt->ep_addr == port->in_ep_addr) {
+				port_tx_callback(port, pkt);
+				break;
+			} else if (pkt->ep_addr == port->out_ep_addr) {
+				port_rx_callback(port);
+				break;
+			}
+		}
+		break;
+	}
+}
+
+
+/*****************************************************************************
+ * Here begins the tty driver interface functions
+ *****************************************************************************/
+
+static int serial_open(struct tty_struct *tty, struct file *filp)
+{
+	int portNumber;
+	struct usb_serial_port *port;
+	unsigned long flags;
+
+	/* initialize the pointer incase something fails */
+	tty->driver_data = NULL;
+
+	/* set up our port structure making the tty driver remember
+	   our port object, and us it */
+	portNumber = MINOR(tty->device);
+	port = &usbtty.port[portNumber];
+	tty->driver_data = port;
+	port->tty = tty;
+
+	if (usbtty.dev_state != CONFIGURED ||
+	    port_paranoia_check(port, __FUNCTION__)) {
+		/*
+		 * the device-layer must be in the configured state before
+		 * the function layer can operate.
+		 */
+		return -ENODEV;
+	}
+	
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	++port->open_count;
+
+	if (!port->active) {
+		port->active = 1;
+
+		/*
+		 * force low_latency on so that our tty_push actually forces
+		 * the data through, otherwise it is scheduled, and with high
+		 * data rates (like with OHCI) data can get lost.
+		 */
+		port->tty->low_latency = 1;
+
+	}
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return 0;
+}
+
+
+static void serial_close(struct tty_struct *tty, struct file *filp)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	unsigned long flags;
+
+	dbg(__FUNCTION__ ": port %d", port->number);
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not opened");
+		return;
+	}
+
+	spin_lock_irqsave(&port->port_lock, flags);
+
+	--port->open_count;
+
+	if (port->open_count <= 0) {
+		port->active = 0;
+		port->open_count = 0;
+	}
+
+	spin_unlock_irqrestore(&port->port_lock, flags);
+	MOD_DEC_USE_COUNT;
+}
+
+
+static int serial_write(struct tty_struct *tty, int from_user,
+			const unsigned char *buf, int count)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	usbdev_pkt_t* pkt;
+	int max_pkt_sz, ret;
+	unsigned long flags;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbtty.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -EINVAL;
+	}
+
+	if (count == 0) {
+		dbg(__FUNCTION__ ": request of 0 bytes");
+		return (0);
+	}
+
+#if 0
+	if (port->writing) {
+		dbg(__FUNCTION__ ": already writing");
+		return 0;
+	}
+#endif
+	
+	max_pkt_sz = port->in_desc->wMaxPacketSize;
+	count = (count > max_pkt_sz) ? max_pkt_sz : count;
+
+	if ((ret = usbdev_alloc_packet(port->in_ep_addr, count, &pkt)))
+		return ret;
+
+	if (from_user)
+		copy_from_user(pkt->payload, buf, count);
+	else
+		memcpy(pkt->payload, buf, count);
+	
+	ret = usbdev_send_packet(port->in_ep_addr, pkt);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	port->writing = 1;
+	spin_unlock_irqrestore(&port->port_lock, flags);
+
+	return ret;
+}
+
+
+static int serial_write_room(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	int room = 0;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbtty.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -EINVAL;
+	}
+
+	//room = port->writing ? 0 : port->in_desc->wMaxPacketSize;
+	room = port->in_desc->wMaxPacketSize;
+	
+	dbg(__FUNCTION__ ": %d", room);
+	return room;
+}
+
+
+static int serial_chars_in_buffer(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+	int chars = 0;
+	
+	/*
+	 * the device-layer must be in the configured state before the
+	 * function layer can operate.
+	 */
+	if (usbtty.dev_state != CONFIGURED)
+		return -ENODEV;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -EINVAL;
+	}
+
+	//chars = port->writing ? usbdev_get_byte_count(port->in_ep_addr) : 0;
+	chars = usbdev_get_byte_count(port->in_ep_addr);
+
+	dbg(__FUNCTION__ ": %d", chars);
+	return chars;
+}
+
+
+static void serial_throttle(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED) {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	// FIXME: anything to do?
+	dbg(__FUNCTION__);
+}
+
+
+static void serial_unthrottle(struct tty_struct *tty)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED) {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	// FIXME: anything to do?
+	dbg(__FUNCTION__);
+}
+
+
+static int serial_ioctl(struct tty_struct *tty, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active) {
+		err(__FUNCTION__ ": port not open");
+		return -ENODEV;
+	}
+	// FIXME: need any IOCTLs?
+	dbg(__FUNCTION__);
+
+	return -ENOIOCTLCMD;
+}
+
+
+static void serial_set_termios(struct tty_struct *tty, struct termios *old)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED)  {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	dbg(__FUNCTION__);
+	// FIXME: anything to do?
+}
+
+
+static void serial_break(struct tty_struct *tty, int break_state)
+{
+	struct usb_serial_port *port =
+		(struct usb_serial_port *) tty->driver_data;
+
+	if (!port->active || usbtty.dev_state != CONFIGURED)  {
+		err(__FUNCTION__ ": port not open");
+		return;
+	}
+
+	dbg(__FUNCTION__);
+	// FIXME: anything to do?
+}
+
+
+static void port_send_complete(void *private)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) private;
+	struct tty_struct *tty;
+	unsigned long flags;
+
+	dbg(__FUNCTION__ ": port %d, ep%d", port->number, port->in_ep_addr);
+
+	tty = port->tty;
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup) {
+		dbg(__FUNCTION__ ": write wakeup call.");
+		(tty->ldisc.write_wakeup) (tty);
+	}
+
+	wake_up_interruptible(&tty->write_wait);
+
+	spin_lock_irqsave(&port->port_lock, flags);
+	port->writing = usbdev_get_byte_count(port->in_ep_addr) <= 0 ? 0 : 1;
+	spin_unlock_irqrestore(&port->port_lock, flags);
+}
+
+
+static void port_receive_complete(void *private)
+{
+	struct usb_serial_port *port = (struct usb_serial_port *) private;
+	struct tty_struct *tty = port->tty;
+	usbdev_pkt_t* pkt = NULL;
+	int i, count;
+
+	/* while there is a packet available */
+	while ((count = usbdev_receive_packet(port->out_ep_addr,
+					      &pkt)) != -ENODATA) {
+		if (count < 0) {
+			if (pkt)
+				kfree(pkt);
+			break; /* exit if error other than ENODATA */
+		}
+		
+		dbg(__FUNCTION__ ": port %d, ep%d, size=%d",
+		    port->number, port->out_ep_addr, count);
+
+		for (i = 0; i < count; i++) {
+			/* if we insert more than TTY_FLIPBUF_SIZE characters,
+			   we drop them. */
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+				tty_flip_buffer_push(tty);
+			}
+			/* this doesn't actually push the data through
+			   unless tty->low_latency is set */
+			tty_insert_flip_char(tty, pkt->payload[i], 0);
+		}
+		tty_flip_buffer_push(tty);
+
+		kfree(pkt); /* make sure we free the packet */
+	}
+
+}
+
+
+static struct tty_driver serial_tty_driver = {
+	.magic= TTY_DRIVER_MAGIC,
+	.driver_name= "usbfn-tty",
+	.name= "usb/ttsdev/%d",
+	.major= SERIAL_TTY_MAJOR,
+	.minor_start= 0,
+	.num= NUM_PORTS,
+	.type= TTY_DRIVER_TYPE_SERIAL,
+	.subtype= SERIAL_TYPE_NORMAL,
+	.flags= TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
+	.refcount= &serial_refcount,
+	.table= serial_tty,
+	.termios= serial_termios,
+	.termios_locked= serial_termios_locked,
+
+	.open= serial_open,
+	.close= serial_close,
+	.write= serial_write,
+	.write_room= serial_write_room,
+	.ioctl= serial_ioctl,
+	.set_termios= serial_set_termios,
+	.throttle= serial_throttle,
+	.unthrottle= serial_unthrottle,
+	.break_ctl= serial_break,
+	.chars_in_buffer= serial_chars_in_buffer,
+};
+
+
+void usbfn_tty_exit(void)
+{
+	int i;
+	
+	/* kill the device layer */
+	usbdev_exit();
+
+	for (i=0; i < NUM_PORTS; i++) {
+		tty_unregister_devfs(&serial_tty_driver, i);
+		info("usb serial converter now disconnected from ttyUSBdev%d",
+		     i);
+	}
+
+	tty_unregister_driver(&serial_tty_driver);
+
+	if (usbtty.str_desc_buf)
+		kfree(usbtty.str_desc_buf);
+}
+
+
+int usbfn_tty_init(void)
+{
+	int ret = 0, i, str_desc_len;
+
+	/* register the tty driver */
+	serial_tty_driver.init_termios = tty_std_termios;
+	serial_tty_driver.init_termios.c_cflag =
+		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	
+	if (tty_register_driver(&serial_tty_driver)) {
+		err(__FUNCTION__ ": failed to register tty driver");
+		ret = -ENXIO;
+		goto out;
+	}
+
+	/*
+	 * initialize pointers to descriptors
+	 */
+	usbtty.dev_desc = &dev_desc;
+	usbtty.config_desc = &config_desc;
+	usbtty.if_desc = &if_desc;
+
+	/*
+	 * initialize the string descriptors
+	 */
+
+	/* alloc buffer big enough for all string descriptors */
+	str_desc_len = string_desc0.bLength;
+	for (i = 0; i < 5; i++)
+		str_desc_len += 2 + 2 * strlen(strings[i]);
+	usbtty.str_desc_buf = (void *) kmalloc(str_desc_len, GFP_KERNEL);
+	if (!usbtty.str_desc_buf) {
+		err(__FUNCTION__ ": failed to alloc string descriptors");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	usbtty.str_desc[0] =
+		(struct usb_string_descriptor *)usbtty.str_desc_buf;
+	memcpy(usbtty.str_desc[0], &string_desc0, string_desc0.bLength);
+	usbtty.str_desc[1] = (struct usb_string_descriptor *)
+		(usbtty.str_desc_buf + string_desc0.bLength);
+	for (i = 1; i < 6; i++) {
+		struct usb_string_descriptor *desc = usbtty.str_desc[i];
+		char *str = strings[i - 1];
+		int j, str_len = strlen(str);
+
+		desc->bLength = 2 + 2 * str_len;
+		desc->bDescriptorType = USB_DT_STRING;
+		for (j = 0; j < str_len; j++) {
+			desc->wData[j] = (u16) str[j];
+		}
+		if (i < 5)
+			usbtty.str_desc[i + 1] =
+				(struct usb_string_descriptor *)
+				((u8 *) desc + desc->bLength);
+	}
+
+	/*
+	 * start the device layer. The device layer assigns us
+	 * our endpoint addresses
+	 */
+	if ((ret = usbdev_init(&dev_desc, &config_desc, &if_desc, ep_desc,
+			       usbtty.str_desc, usbtty_callback, NULL))) {
+		err(__FUNCTION__ ": device-layer init failed");
+		goto out;
+	}
+	
+	/* initialize the devfs nodes for this device and let the user
+	   know what ports we are bound to */
+	for (i = 0; i < NUM_PORTS; ++i) {
+		struct usb_serial_port *port;
+		tty_register_devfs(&serial_tty_driver, 0, i);
+		info("usbdev serial attached to ttyUSBdev%d "
+		     "(or devfs usb/ttsdev/%d)", i, i);
+		port = &usbtty.port[i];
+		port->number = i;
+		port->in_desc = &ep_desc[NUM_PORTS*i];
+		port->out_desc = &ep_desc[NUM_PORTS*i + 1];
+		port->in_ep_addr = port->in_desc->bEndpointAddress & 0x0f;
+		port->out_ep_addr = port->out_desc->bEndpointAddress & 0x0f;
+		port->send_complete_tq.routine = port_send_complete;
+		port->send_complete_tq.data = port;
+		port->receive_complete_tq.routine = port_receive_complete;
+		port->receive_complete_tq.data = port;
+		spin_lock_init(&port->port_lock);
+	}
+
+ out:
+	if (ret)
+		usbfn_tty_exit();
+	return ret;
+}
+
+
+/* Module information */
+MODULE_AUTHOR("Steve Longerbeam, stevel@mvista.com, www.mvista.com");
+MODULE_DESCRIPTION("Au1x00 USB Device-Side Serial TTY Driver");
+MODULE_LICENSE("GPL");
+
+module_init(usbfn_tty_init);
+module_exit(usbfn_tty_exit);
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/decserial.c linux_HEAD/drivers/char/decserial.c
--- linux-2.6.11.6/drivers/char/decserial.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/drivers/char/decserial.c	2004-09-21 13:10:14.000000000 +0200
@@ -14,87 +14,85 @@
  *      device. Added support for PROM console in drivers/char/tty_io.c
  *      instead. Although it may work to enable more than one 
  *      console device I strongly recommend to use only one.
+ *
+ *	Copyright (C) 2004  Maciej W. Rozycki
  */
 
 #include <linux/config.h>
+#include <linux/errno.h>
 #include <linux/init.h>
-#include <asm/dec/machtype.h>
-
-#ifdef CONFIG_ZS
-extern int zs_init(void);
-#endif
 
-#ifdef CONFIG_DZ
-extern int dz_init(void);
-#endif
+#include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
 
-#ifdef CONFIG_SERIAL_CONSOLE
+extern int register_zs_hook(unsigned int channel,
+			    struct dec_serial_hook *hook);
+extern int unregister_zs_hook(unsigned int channel);
 
+int register_dec_serial_hook(unsigned int channel,
+			     struct dec_serial_hook *hook)
+{
 #ifdef CONFIG_ZS
-extern void zs_serial_console_init(void);
-#endif
-
-#ifdef CONFIG_DZ
-extern void dz_serial_console_init(void);
+	if (IOASIC)
+		return register_zs_hook(channel, hook);
 #endif
+	return 0;
+}
 
+int unregister_dec_serial_hook(unsigned int channel)
+{
+#ifdef CONFIG_ZS
+	if (IOASIC)
+		return unregister_zs_hook(channel);
 #endif
+	return 0;
+}
 
-/* rs_init - starts up the serial interface -
-   handle normal case of starting up the serial interface */
 
-#ifdef CONFIG_SERIAL
+extern int zs_init(void);
+extern int dz_init(void);
 
+/*
+ * rs_init - starts up the serial interface -
+ * handle normal case of starting up the serial interface
+ */
 int __init rs_init(void)
 {
-
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	return zs_init();
-    else
-	return dz_init();
-#else
-
 #ifdef CONFIG_ZS
-    return zs_init();
+	if (IOASIC)
+		return zs_init();
 #endif
-
 #ifdef CONFIG_DZ
-    return dz_init();
-#endif
-
+	if (!IOASIC)
+		return dz_init();
 #endif
+	return -ENXIO;
 }
 
 __initcall(rs_init);
 
-#endif
 
-#ifdef CONFIG_SERIAL_CONSOLE
+#ifdef CONFIG_SERIAL_DEC_CONSOLE
+
+extern void zs_serial_console_init(void);
+extern void dz_serial_console_init(void);
 
-/* serial_console_init handles the special case of starting
- *   up the console on the serial port
+/*
+ * dec_serial_console_init handles the special case of starting
+ * up the console on the serial port
  */
-static int __init decserial_console_init(void)
+static int __init dec_serial_console_init(void)
 {
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	zs_serial_console_init();
-    else
-	dz_serial_console_init();
-#else
-
 #ifdef CONFIG_ZS
-    zs_serial_console_init();
+	if (IOASIC)
+		zs_serial_console_init();
 #endif
-
 #ifdef CONFIG_DZ
-    dz_serial_console_init();
-#endif
-
+	if (!IOASIC)
+		dz_serial_console_init();
 #endif
     return 0;
 }
-console_initcall(decserial_console_init);
+console_initcall(dec_serial_console_init);
 
 #endif
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/generic_serial.c linux_HEAD/drivers/char/generic_serial.c
--- linux-2.6.11.6/drivers/char/generic_serial.c	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/drivers/char/generic_serial.c	2005-02-17 21:49:30.000000000 +0100
@@ -21,6 +21,7 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/interrupt.h>
 #include <linux/tty.h>
 #include <linux/serial.h>
 #include <linux/mm.h>
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/ibm_workpad_keymap.map linux_HEAD/drivers/char/ibm_workpad_keymap.map
--- linux-2.6.11.6/drivers/char/ibm_workpad_keymap.map	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/char/ibm_workpad_keymap.map	2003-12-20 15:18:07.000000000 +0100
@@ -0,0 +1,343 @@
+# Keymap for IBM Workpad z50
+# US Mapping
+#
+# by Michael Klar <wyldfier@iname.com>
+#
+# This is a great big mess on account of how the Caps Lock key is handled as
+# LeftShift-RightShift.  Right shift key had to be broken out, so don't use
+# use this map file as a basis for other keyboards that don't do the same
+# thing with Caps Lock.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+
+keymaps 0-2,4-5,8,12,32-33,36-37
+strings as usual
+
+keycode 0 = F1 F11 Console_13
+	shiftr keycode 0 = F11
+	shift shiftr keycode 0 = F11
+	control keycode 0 = F1
+	alt keycode 0 = Console_1
+	control alt keycode 0 = Console_1
+keycode 1 = F3 F13 Console_15
+	shiftr keycode 1 = F13
+	shift shiftr keycode 1 = F13
+	control keycode 1 = F3
+	alt keycode 1 = Console_3
+	control alt keycode 1 = Console_3
+keycode 2 = F5 F15 Console_17
+	shiftr keycode 2 = F15
+	shift shiftr keycode 2 = F15
+	control keycode 2 = F5
+	alt keycode 2 = Console_5
+	control alt keycode 2 = Console_5
+keycode 3 = F7 F17 Console_19
+	shiftr keycode 3 = F17
+	shift shiftr keycode 3 = F17
+	control keycode 3 = F7
+	alt keycode 3 = Console_7
+	control alt keycode 3 = Console_7
+keycode 4 = F9 F19 Console_21
+	shiftr keycode 4 = F19
+	shift shiftr keycode 4 = F19
+	control keycode 4 = F9
+	alt keycode 4 = Console_9
+	control alt keycode 4 = Console_9
+#keycode 5 is contrast down
+#keycode 6 is contrast up
+keycode 7 = F11 F11 Console_23
+	shiftr keycode 7 = F11
+	shift shiftr keycode 7 = F11
+	control keycode 7 = F11
+	alt keycode 7 = Console_11
+	control alt keycode 7 = Console_11
+keycode 8 = F2 F12 Console_14
+	shiftr keycode 8 = F12
+	shift shiftr keycode 8 = F12
+	control keycode 8 = F2
+	alt keycode 8 = Console_2
+	control alt keycode 8 = Console_2
+keycode 9 = F4 F14 Console_16
+	shiftr keycode 9 = F14
+	shift shiftr keycode 9 = F14
+	control keycode 9 = F4
+	alt keycode 9 = Console_4
+	control alt keycode 9 = Console_4
+keycode 10 = F6 F16 Console_18
+	shiftr keycode 10 = F16
+	shift shiftr keycode 10 = F16
+	control keycode 10 = F6
+	alt keycode 10 = Console_6
+	control alt keycode 10 = Console_6
+keycode 11 = F8 F18 Console_20
+	shiftr keycode 11 = F18
+	shift shiftr keycode 11 = F18
+	control keycode 11 = F8
+	alt keycode 11 = Console_8
+	control alt keycode 11 = Console_8
+keycode 12 = F10 F20 Console_22
+	shiftr keycode 12 = F20
+	shift shiftr keycode 12 = F20
+	control keycode 12 = F10
+	alt keycode 12 = Console_10
+	control alt keycode 12 = Console_10
+#keycode 13 is brightness down
+#keycode 14 is brightness up
+keycode 15 = F12 F12 Console_24
+	shiftr keycode 15 = F12
+	shift shiftr keycode 15 = F12
+	control keycode 15 = F12
+	alt keycode 15 = Console_12
+	control alt keycode 15 = Console_12
+keycode 16 = apostrophe quotedbl
+	shiftr keycode 16 = quotedbl
+	shift shiftr keycode 16 = quotedbl
+	control keycode 16 = Control_g
+	alt keycode 16 = Meta_apostrophe
+keycode 17 = bracketleft braceleft
+	shiftr keycode 17 = braceleft
+	shift shiftr keycode 17 = braceleft
+	control keycode 17 = Escape
+	alt keycode 17 = Meta_bracketleft
+keycode 18 = minus underscore backslash       
+	shiftr keycode 18 = underscore
+	shift shiftr keycode 18 = underscore
+	control keycode 18 = Control_underscore
+	shift control keycode 18 = Control_underscore
+	shiftr control keycode 18 = Control_underscore
+	shift shiftr control keycode 18 = Control_underscore
+	alt keycode 18 = Meta_minus
+keycode 19 = zero parenright braceright
+	shiftr keycode 19 = parenright
+	shift shiftr keycode 19 = parenright
+	alt keycode 19 = Meta_zero
+keycode 20 = p
+	shiftr keycode 20 = +P
+	shift shiftr keycode 20 = +p
+keycode 21 = semicolon colon
+	shiftr keycode 21 = colon
+	shift shiftr keycode 21 = colon
+	alt keycode 21 = Meta_semicolon
+keycode 22 = Up Scroll_Backward
+	shiftr keycode 22 = Scroll_Backward
+	shift shiftr keycode 22 = Scroll_Backward
+	alt keycode 22 = Prior
+keycode 23 = slash question
+	shiftr keycode 23 = question
+	shift shiftr keycode 23 = question
+	control keycode 23 = Delete
+	alt keycode 23 = Meta_slash
+
+keycode 27 = nine parenleft bracketright
+	shiftr keycode 27 = parenleft
+	shift shiftr keycode 27 = parenleft
+	alt keycode 27 = Meta_nine
+keycode 28 = o
+	shiftr keycode 28 = +O
+	shift shiftr keycode 28 = +o
+keycode 29 = l
+	shiftr keycode 29 = +L
+	shift shiftr keycode 29 = +l
+keycode 30 = period greater
+	shiftr keycode 30 = greater
+	shift shiftr keycode 30 = greater
+	control keycode 30 = Compose
+	alt keycode 30 = Meta_period
+
+keycode 32 = Left Decr_Console
+	shiftr keycode 32 = Decr_Console
+	shift shiftr keycode 32 = Decr_Console
+	alt keycode 32 = Home
+keycode 33 = bracketright braceright asciitilde      
+	shiftr keycode 33 = braceright
+	shift shiftr keycode 33 = braceright
+	control keycode 33 = Control_bracketright
+	alt keycode 33 = Meta_bracketright
+keycode 34 = equal plus
+	shiftr keycode 34 = plus
+	shift shiftr keycode 34 = plus
+	alt keycode 34 = Meta_equal
+keycode 35 = eight asterisk bracketleft
+	shiftr keycode 35 = asterisk
+	shift shiftr keycode 35 = asterisk
+	control keycode 35 = Delete
+	alt keycode 35 = Meta_eight
+keycode 36 = i
+	shiftr keycode 36 = +I
+	shift shiftr keycode 36 = +i
+keycode 37 = k
+	shiftr keycode 37 = +K
+	shift shiftr keycode 37 = +k
+keycode 38 = comma less
+	shiftr keycode 38 = less
+	shift shiftr keycode 38 = less
+	alt keycode 38 = Meta_comma
+
+keycode 40 = h
+	shiftr keycode 40 = +H
+	shift shiftr keycode 40 = +h
+keycode 41 = y
+	shiftr keycode 41 = +Y
+	shift shiftr keycode 41 = +y
+keycode 42 = six asciicircum
+	shiftr keycode 42 = asciicircum
+	shift shiftr keycode 42 = asciicircum
+	control keycode 42 = Control_asciicircum
+	alt keycode 42 = Meta_six
+keycode 43 = seven ampersand braceleft
+	shiftr keycode 43 = ampersand
+	shift shiftr keycode 43 = ampersand
+	control keycode 43 = Control_underscore
+	alt keycode 43 = Meta_seven
+keycode 44 = u
+	shiftr keycode 44 = +U
+	shift shiftr keycode 44 = +u
+keycode 45 = j
+	shiftr keycode 45 = +J
+	shift shiftr keycode 45 = +j
+keycode 46 = m
+	shiftr keycode 46 = +M
+	shift shiftr keycode 46 = +m
+keycode 47 = n
+	shiftr keycode 47 = +N
+	shift shiftr keycode 47 = +n
+
+# This is the "Backspace" key:
+keycode 49 = Delete Delete
+	shiftr keycode 49 = Delete
+	shift shiftr keycode 49 = Delete
+	control keycode 49 = BackSpace
+	alt keycode 49 = Meta_Delete
+keycode 50 = Num_Lock
+	shift keycode 50 = Bare_Num_Lock
+	shiftr keycode 50 = Bare_Num_Lock
+	shift shiftr keycode 50 = Bare_Num_Lock
+# This is the "Delete" key:
+keycode 51 = Remove
+	control alt keycode 51 = Boot
+
+keycode 53 = backslash bar
+	shiftr keycode 53 = bar
+	shift shiftr keycode 53 = bar
+	control keycode 53 = Control_backslash
+	alt keycode 53 = Meta_backslash
+keycode 54 = Return
+	alt keycode 54 = Meta_Control_m
+keycode 55 = space space           
+	shiftr keycode 55 = space
+	shift shiftr keycode 55 = space
+	control keycode 55 = nul
+	alt keycode 55 = Meta_space
+keycode 56 = g
+	shiftr keycode 56 = +G
+	shift shiftr keycode 56 = +g
+keycode 57 = t
+	shiftr keycode 57 = +T
+	shift shiftr keycode 57 = +t
+keycode 58 = five percent
+	shiftr keycode 58 = percent
+	shift shiftr keycode 58 = percent
+	control keycode 58 = Control_bracketright
+	alt keycode 58 = Meta_five
+keycode 59 = four dollar dollar
+	shiftr keycode 59 = dollar
+	shift shiftr keycode 59 = dollar
+	control keycode 59 = Control_backslash
+	alt keycode 59 = Meta_four
+keycode 60 = r
+	shiftr keycode 60 = +R
+	shift shiftr keycode 60 = +r
+keycode 61 = f
+	shiftr keycode 61 = +F
+	shift shiftr keycode 61 = +f
+	altgr keycode 61 = Hex_F
+keycode 62 = v
+	shiftr keycode 62 = +V
+	shift shiftr keycode 62 = +v
+keycode 63 = b
+	shiftr keycode 63 = +B
+	shift shiftr keycode 63 = +b
+	altgr keycode 63 = Hex_B
+
+keycode 67 = three numbersign
+	shiftr keycode 67 = numbersign
+	shift shiftr keycode 67 = numbersign
+	control keycode 67 = Escape
+	alt keycode 67 = Meta_three
+keycode 68 = e
+	shiftr keycode 68 = +E
+	shift shiftr keycode 68 = +e
+	altgr keycode 68 = Hex_E
+keycode 69 = d
+	shiftr keycode 69 = +D
+	shift shiftr keycode 69 = +d
+	altgr keycode 69 = Hex_D
+keycode 70 = c
+	shiftr keycode 70 = +C
+	shift shiftr keycode 70 = +c
+	altgr keycode 70 = Hex_C
+keycode 71 = Right Incr_Console
+	shiftr keycode 71 = Incr_Console
+	shift shiftr keycode 71 = Incr_Console
+	alt keycode 71 = End
+
+keycode 75 = two at at
+	shiftr keycode 75 = at
+	shift shiftr keycode 75 = at
+	control keycode 75 = nul
+	shift control keycode 75 = nul
+	shiftr control keycode 75 = nul
+	shift shiftr control keycode 75 = nul
+	alt keycode 75 = Meta_two
+keycode 76 = w
+	shiftr keycode 76 = +W
+	shift shiftr keycode 76 = +w
+keycode 77 = s
+	shiftr keycode 77 = +S
+	shift shiftr keycode 77 = +s
+keycode 78 = x
+	shiftr keycode 78 = +X
+	shift shiftr keycode 78 = +x
+keycode 79 = Down Scroll_Forward
+	shiftr keycode 79 = Scroll_Forward
+	shift shiftr keycode 79 = Scroll_Forward
+	alt keycode 79 = Next
+keycode 80 = Escape Escape
+	shiftr keycode 80 = Escape
+	shift shiftr keycode 80 = Escape
+	alt keycode 80 = Meta_Escape
+keycode 81 = Tab Tab             
+	shiftr keycode 81 = Tab
+	shift shiftr keycode 81 = Tab
+	alt keycode 81 = Meta_Tab
+keycode 82 = grave asciitilde
+	shiftr keycode 82 = asciitilde
+	shift shiftr keycode 82 = asciitilde
+	control keycode 82 = nul
+	alt keycode 82 = Meta_grave
+keycode 83 = one exclam
+	shiftr keycode 83 = exclam
+	shift shiftr keycode 83 = exclam
+	alt keycode 83 = Meta_one
+keycode 84 = q
+	shiftr keycode 84 = +Q
+	shift shiftr keycode 84 = +q
+keycode 85 = a
+	shiftr keycode 85 = +A
+	shift shiftr keycode 85 = +a
+	altgr keycode 85 = Hex_A
+keycode 86 = z
+	shiftr keycode 86 = +Z
+	shift shiftr keycode 86 = +z
+
+# This is the windows key:
+keycode 88 = Decr_Console
+keycode 89 = Shift
+keycode 90 = Control
+keycode 91 = Control
+keycode 92 = Alt
+keycode 93 = AltGr
+keycode 94 = ShiftR
+	shift keycode 94 = Caps_Lock
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/lcd.c linux_HEAD/drivers/char/lcd.c
--- linux-2.6.11.6/drivers/char/lcd.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/drivers/char/lcd.c	2005-02-21 22:17:44.000000000 +0100
@@ -575,8 +575,8 @@ static inline int button_pressed(void)
 
 static int lcd_waiters = 0;
 
-static long lcd_read(struct inode *inode, struct file *file, char *buf,
-		     unsigned long count)
+static ssize_t lcd_read(struct file *file, char *buf,
+		     size_t count, loff_t *ofs)
 {
 	long buttons_now;
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/lcd.h linux_HEAD/drivers/char/lcd.h
--- linux-2.6.11.6/drivers/char/lcd.h	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/drivers/char/lcd.h	2005-02-21 22:17:44.000000000 +0100
@@ -22,7 +22,7 @@ static int timeout(volatile unsigned lon
 #define MAX_IDLE_TIME 120
 
 struct lcd_display {
-        unsigned long buttons;
+        unsigned buttons;
         int size1;
         int size2;
         unsigned char line1[LCD_CHARS_PER_LINE];
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/qtronix.c linux_HEAD/drivers/char/qtronix.c
--- linux-2.6.11.6/drivers/char/qtronix.c	2005-03-26 04:28:40.000000000 +0100
+++ linux_HEAD/drivers/char/qtronix.c	2005-03-11 18:48:13.000000000 +0100
@@ -535,8 +535,7 @@ repeat:
 		i--;
 	}
 	if (count-i) {
-		struct inode *inode = file->f_dentry->d_inode;
-		inode->i_atime = current_fs_time(inode->i_sb);
+		file->f_dentry->d_inode->i_atime = get_seconds();
 		return count-i;
 	}
 	if (signal_pending(current))
@@ -591,6 +590,11 @@ static int __init psaux_init(void)
 		return retval;
 
 	queue = (struct aux_queue *) kmalloc(sizeof(*queue), GFP_KERNEL);
+	if (!queue) {
+		misc_deregister(&psaux_mouse);
+		return -ENOMEM;
+	}
+		
 	memset(queue, 0, sizeof(*queue));
 	queue->head = queue->tail = 0;
 	init_waitqueue_head(&queue->proc_list);
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/rtc.c linux_HEAD/drivers/char/rtc.c
--- linux-2.6.11.6/drivers/char/rtc.c	2005-04-03 00:10:56.000000000 +0200
+++ linux_HEAD/drivers/char/rtc.c	2005-03-21 20:04:04.000000000 +0100
@@ -35,23 +35,21 @@
  *	1.09a	Pete Zaitcev: Sun SPARC
  *	1.09b	Jeff Garzik: Modularize, init cleanup
  *	1.09c	Jeff Garzik: SMP cleanup
- *	1.10    Paul Barton-Davis: add support for async I/O
+ *	1.10	Paul Barton-Davis: add support for async I/O
  *	1.10a	Andrea Arcangeli: Alpha updates
  *	1.10b	Andrew Morton: SMP lock fix
  *	1.10c	Cesar Barros: SMP locking fixes and cleanup
  *	1.10d	Paul Gortmaker: delete paranoia check in rtc_exit
  *	1.10e	Maciej W. Rozycki: Handle DECstation's year weirdness.
- *      1.11    Takashi Iwai: Kernel access functions
+ *	1.11	Takashi Iwai: Kernel access functions
  *			      rtc_register/rtc_unregister/rtc_control
  *      1.11a   Daniele Bellucci: Audit create_proc_read_entry in rtc_init
- *	1.12	Venkatesh Pallipadi: Hooks for emulating rtc on HPET base-timer
+ *	1.12    Venkatesh Pallipadi: Hooks for emulating rtc on HPET base-timer
  *		CONFIG_HPET_EMULATE_RTC
- *
+ *	1.12a	Maciej W. Rozycki: Handle memory-mapped chips properly.
  */
 
-#define RTC_VERSION		"1.12"
-
-#define RTC_IO_EXTENT	0x8
+#define RTC_VERSION		"1.12a"
 
 /*
  *	Note that *all* calls to CMOS_READ and CMOS_WRITE are done with
@@ -323,7 +321,15 @@ static ssize_t rtc_read(struct file *fil
 	if (rtc_has_irq == 0)
 		return -EIO;
 
-	if (count < sizeof(unsigned))
+	/*
+	 * Historically this function used to assume that sizeof(unsigned long)
+	 * is the same in userspace and kernelspace.  This lead to problems
+	 * for configurations with multiple ABIs such a the MIPS o32 and 64
+	 * ABIs supported on the same kernel.  So now we support read of both
+	 * 4 and 8 bytes and assume that's the sizeof(unsigned long) in the
+	 * userspace ABI.
+	 */
+	if (count != sizeof(unsigned int) && count !=  sizeof(unsigned long))
 		return -EINVAL;
 
 	add_wait_queue(&rtc_wait, &wait);
@@ -354,10 +360,12 @@ static ssize_t rtc_read(struct file *fil
 		schedule();
 	} while (1);
 
-	if (count < sizeof(unsigned long))
-		retval = put_user(data, (unsigned int __user *)buf) ?: sizeof(int); 
+	if (count == sizeof(unsigned int))
+		retval = put_user(data, (unsigned int __user *)buf) ?: sizeof(int);
 	else
 		retval = put_user(data, (unsigned long __user *)buf) ?: sizeof(long);
+	if (!retval)
+		retval = count;
  out:
 	current->state = TASK_RUNNING;
 	remove_wait_queue(&rtc_wait, &wait);
@@ -905,6 +913,9 @@ static int __init rtc_init(void)
 	struct sparc_isa_device *isa_dev;
 #endif
 #endif
+#ifndef __sparc__
+	void *r;
+#endif
 
 #ifdef __sparc__
 	for_each_ebus(ebus) {
@@ -951,8 +962,13 @@ found:
 	}
 no_irq:
 #else
-	if (!request_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc")) {
-		printk(KERN_ERR "rtc: I/O port %d is not free.\n", RTC_PORT (0));
+	if (RTC_IOMAPPED)
+		r = request_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc");
+	else
+		r = request_mem_region(RTC_PORT(0), RTC_IO_EXTENT, "rtc");
+	if (!r) {
+		printk(KERN_ERR "rtc: I/O resource %lx is not free.\n",
+		       (long)(RTC_PORT(0)));
 		return -EIO;
 	}
 
@@ -966,7 +982,10 @@ no_irq:
 	if(request_irq(RTC_IRQ, rtc_int_handler_ptr, SA_INTERRUPT, "rtc", NULL)) {
 		/* Yeah right, seeing as irq 8 doesn't even hit the bus. */
 		printk(KERN_ERR "rtc: IRQ %d is not free.\n", RTC_IRQ);
-		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		if (RTC_IOMAPPED)
+			release_region(RTC_PORT(0), RTC_IO_EXTENT);
+		else
+			release_mem_region(RTC_PORT(0), RTC_IO_EXTENT);
 		return -EIO;
 	}
 	hpet_rtc_timer_init();
@@ -1070,7 +1089,10 @@ static void __exit rtc_exit (void)
 	if (rtc_has_irq)
 		free_irq (rtc_irq, &rtc_port);
 #else
-	release_region (RTC_PORT (0), RTC_IO_EXTENT);
+	if (RTC_IOMAPPED)
+		release_region(RTC_PORT(0), RTC_IO_EXTENT);
+	else
+		release_mem_region(RTC_PORT(0), RTC_IO_EXTENT);
 #ifdef RTC_IRQ
 	if (rtc_has_irq)
 		free_irq (RTC_IRQ, NULL);
diff -urpNX dontdiff linux-2.6.11.6/drivers/char/sb1250_duart.c linux_HEAD/drivers/char/sb1250_duart.c
--- linux-2.6.11.6/drivers/char/sb1250_duart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/char/sb1250_duart.c	2005-02-28 16:56:48.000000000 +0100
@@ -0,0 +1,899 @@
+/*
+ * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/* 
+ * Driver support for the on-chip sb1250 dual-channel serial port,
+ * running in asynchronous mode.  Also, support for doing a serial console
+ * on one of those ports 
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/serial.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/termios.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <linux/errno.h>
+#include <linux/tty.h>
+#include <linux/sched.h>
+#include <linux/tty_flip.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/sibyte/swarm.h>
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/sb1250_uart.h>
+#include <asm/sibyte/sb1250_int.h>
+#include <asm/sibyte/sb1250.h>
+#include <asm/war.h>
+
+/* Toggle spewing of debugging output */
+#undef DUART_SPEW
+
+#define DEFAULT_CFLAGS          (CS8 | B115200)
+
+#define TX_INTEN          1
+#define DUART_INITIALIZED 2
+
+#ifndef MIN
+#define MIN(a,b)	((a) < (b) ? (a) : (b))
+#endif
+
+#define DUART_MAX_LINE 2
+char sb1250_duart_present[DUART_MAX_LINE] = {1,1};
+EXPORT_SYMBOL(sb1250_duart_present);
+
+/*
+ * Still not sure what the termios structures set up here are for, 
+ *  but we have to supply pointers to them to register the tty driver
+ */
+static struct tty_driver *sb1250_duart_driver; //, sb1250_duart_callout_driver;
+
+/*
+ * This lock protects both the open flags for all the uart states as 
+ * well as the reference count for the module
+ */
+static DEFINE_SPINLOCK(open_lock);
+
+typedef struct { 
+	unsigned char       outp_buf[SERIAL_XMIT_SIZE];
+	unsigned int        outp_head;
+	unsigned int        outp_tail;
+	unsigned int        outp_count;
+	spinlock_t          outp_lock;
+	unsigned int        open;
+	unsigned int        line;
+	unsigned int        last_cflags;
+	unsigned long       flags;
+	struct tty_struct   *tty;
+	/* CSR addresses */
+	u32		    *status;
+	u32		    *imr;
+	u32		    *tx_hold;
+	u32		    *rx_hold;
+	u32		    *mode_1;
+	u32		    *mode_2;
+	u32		    *clk_sel;
+	u32		    *cmd;
+} uart_state_t;
+
+static uart_state_t uart_states[DUART_MAX_LINE];
+
+/*
+ * Inline functions local to this module 
+ */
+
+/*
+ * In bug 1956, we get glitches that can mess up uart registers.  This
+ * "write-mode-1 after any register access" is the accepted
+ * workaround.
+ */
+#if SIBYTE_1956_WAR
+static unsigned int last_mode1[DUART_MAX_LINE];
+#endif
+
+static inline u32 READ_SERCSR(u32 *addr, int line)
+{
+	u32 val = csr_in32(addr);
+#if SIBYTE_1956_WAR
+	csr_out32(last_mode1[line], uart_states[line].mode_1);
+#endif
+	return val;
+}
+
+static inline void WRITE_SERCSR(u32 val, u32 *addr, int line)
+{
+	csr_out32(val, addr);
+#if SIBYTE_1956_WAR
+	csr_out32(last_mode1[line], uart_states[line].mode_1);
+#endif
+}
+
+static void init_duart_port(uart_state_t *port, int line)
+{
+	if (!(port->flags & DUART_INITIALIZED)) {
+		port->line = line;
+		port->status = IOADDR(A_DUART_CHANREG(line, R_DUART_STATUS));
+		port->imr = IOADDR(A_DUART_IMRREG(line));
+		port->tx_hold = IOADDR(A_DUART_CHANREG(line, R_DUART_TX_HOLD));
+		port->rx_hold = IOADDR(A_DUART_CHANREG(line, R_DUART_RX_HOLD));
+		port->mode_1 = IOADDR(A_DUART_CHANREG(line,
+						      R_DUART_MODE_REG_1));
+		port->mode_2 = IOADDR(A_DUART_CHANREG(line,
+						      R_DUART_MODE_REG_2));
+		port->clk_sel = IOADDR(A_DUART_CHANREG(line, R_DUART_CLK_SEL));
+		port->cmd = IOADDR(A_DUART_CHANREG(line, R_DUART_CMD));
+		port->flags |= DUART_INITIALIZED;
+	}
+}
+
+/*
+ * Mask out the passed interrupt lines at the duart level.  This should be
+ * called while holding the associated outp_lock.
+ */
+static inline void duart_mask_ints(unsigned int line, unsigned int mask)
+{
+	uart_state_t *port = uart_states + line;
+	u64 tmp = READ_SERCSR(port->imr, line);
+	WRITE_SERCSR(tmp & ~mask, port->imr, line);
+}
+
+	
+/* Unmask the passed interrupt lines at the duart level */
+static inline void duart_unmask_ints(unsigned int line, unsigned int mask)
+{
+	uart_state_t *port = uart_states + line;
+	u64 tmp = READ_SERCSR(port->imr, line);
+	WRITE_SERCSR(tmp | mask, port->imr, line);
+}
+
+static inline void transmit_char_pio(uart_state_t *us)
+{
+	struct tty_struct *tty = us->tty;
+	int blocked = 0;
+
+	if (spin_trylock(&us->outp_lock)) {
+		for (;;) {
+			if (!(READ_SERCSR(us->status, us->line) & M_DUART_TX_RDY))
+				break;
+			if (us->outp_count <= 0 || tty->stopped || tty->hw_stopped) {
+				break;
+			} else {
+				WRITE_SERCSR(us->outp_buf[us->outp_head],
+					     us->tx_hold, us->line);
+				us->outp_head = (us->outp_head + 1) & (SERIAL_XMIT_SIZE-1);
+				if (--us->outp_count <= 0)
+					break;
+			}
+			udelay(10);
+		}
+		spin_unlock(&us->outp_lock);
+	} else {
+		blocked = 1;
+	}
+
+	if (!us->outp_count || tty->stopped ||
+	    tty->hw_stopped || blocked) {
+		us->flags &= ~TX_INTEN;
+		duart_mask_ints(us->line, M_DUART_IMR_TX);
+	}
+
+      	if (us->open &&
+	    (us->outp_count < (SERIAL_XMIT_SIZE/2))) {
+		/*
+		 * We told the discipline at one point that we had no
+		 * space, so it went to sleep.  Wake it up when we hit
+		 * half empty
+		 */
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+		    tty->ldisc.write_wakeup)
+			tty->ldisc.write_wakeup(tty);
+		wake_up_interruptible(&tty->write_wait);
+	}
+}
+
+/* 
+ * Generic interrupt handler for both channels.  dev_id is a pointer
+ * to the proper uart_states structure, so from that we can derive 
+ * which port interrupted 
+ */
+
+static irqreturn_t duart_int(int irq, void *dev_id, struct pt_regs *regs)
+{
+	uart_state_t *us = (uart_state_t *)dev_id;
+	struct tty_struct *tty = us->tty;
+	unsigned int status = READ_SERCSR(us->status, us->line);
+
+#ifdef DUART_SPEW
+	printk("DUART INT\n");
+#endif
+
+	if (status & M_DUART_RX_RDY) {
+		int counter = 2048;
+		unsigned int ch;
+
+		if (status & M_DUART_OVRUN_ERR)
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		if (status & M_DUART_PARITY_ERR) {
+			printk("Parity error!\n");
+		} else if (status & M_DUART_FRM_ERR) {
+			printk("Frame error!\n");
+		}
+
+		while (counter > 0) {
+			if (!(READ_SERCSR(us->status, us->line) & M_DUART_RX_RDY))
+				break;
+			ch = READ_SERCSR(us->rx_hold, us->line);
+			if (tty->flip.count < TTY_FLIPBUF_SIZE) {
+				*tty->flip.char_buf_ptr++ = ch;
+				*tty->flip.flag_buf_ptr++ = 0;
+				tty->flip.count++;
+			}
+			udelay(1);
+			counter--;
+		}
+		tty_flip_buffer_push(tty);
+	}
+
+	if (status & M_DUART_TX_RDY) {
+		transmit_char_pio(us);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *  Actual driver functions
+ */
+
+/* Return the number of characters we can accomodate in a write at this instant */
+static int duart_write_room(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	int retval;
+
+	retval = SERIAL_XMIT_SIZE - us->outp_count;
+
+#ifdef DUART_SPEW
+	printk("duart_write_room called, returning %i\n", retval);
+#endif
+
+	return retval;
+}
+
+/* memcpy the data from src to destination, but take extra care if the
+   data is coming from user space */
+static inline int copy_buf(char *dest, const char *src, int size, int from_user) 
+{
+	if (from_user) {
+		(void) copy_from_user(dest, src, size); 
+	} else {
+		memcpy(dest, src, size);
+	}
+	return size;
+}
+
+/*
+ * Buffer up to count characters from buf to be written.  If we don't have
+ * other characters buffered, enable the tx interrupt to start sending
+ */
+static int duart_write(struct tty_struct *tty, const unsigned char *buf,
+		       int count)
+{
+	uart_state_t *us;
+	int c, t, total = 0;
+	unsigned long flags;
+
+	if (!tty) return 0;
+
+	us = tty->driver_data;
+	if (!us) return 0;
+
+#ifdef DUART_SPEW
+	printk("duart_write called for %i chars by %i (%s)\n", count, current->pid, current->comm);
+#endif
+
+	spin_lock_irqsave(&us->outp_lock, flags);
+
+	for (;;) {
+		c = count;
+
+		t = SERIAL_XMIT_SIZE - us->outp_tail;
+		if (t < c) c = t;
+
+		t = SERIAL_XMIT_SIZE - 1 - us->outp_count;
+		if (t < c) c = t;
+
+		if (c <= 0) break;
+
+		memcpy(us->outp_buf + us->outp_tail, buf, c);
+
+		us->outp_count += c;
+		us->outp_tail = (us->outp_tail + c) & (SERIAL_XMIT_SIZE - 1);
+		buf += c;
+		count -= c;
+		total += c;
+	}
+
+	spin_unlock_irqrestore(&us->outp_lock, flags);
+
+	if (us->outp_count && !tty->stopped && 
+	    !tty->hw_stopped && !(us->flags & TX_INTEN)) {
+		us->flags |= TX_INTEN;
+		duart_unmask_ints(us->line, M_DUART_IMR_TX);
+	}
+
+	return total;
+}
+
+
+/* Buffer one character to be written.  If there's not room for it, just drop
+   it on the floor.  This is used for echo, among other things */
+static void duart_put_char(struct tty_struct *tty, u_char ch)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long flags;
+
+#ifdef DUART_SPEW
+	printk("duart_put_char called.  Char is %x (%c)\n", (int)ch, ch);
+#endif
+
+	spin_lock_irqsave(&us->outp_lock, flags);
+
+	if (us->outp_count == SERIAL_XMIT_SIZE) {
+		spin_unlock_irqrestore(&us->outp_lock, flags);
+		return;
+	}
+
+	us->outp_buf[us->outp_tail] = ch;
+	us->outp_tail = (us->outp_tail + 1) &(SERIAL_XMIT_SIZE-1);
+	us->outp_count++;
+
+	spin_unlock_irqrestore(&us->outp_lock, flags);
+}
+
+static void duart_flush_chars(struct tty_struct * tty)
+{
+	uart_state_t *port;
+
+	if (!tty) return;
+
+	port = tty->driver_data;
+
+	if (!port) return;
+
+	if (port->outp_count <= 0 || tty->stopped || tty->hw_stopped) {
+		return;
+	}
+
+	port->flags |= TX_INTEN;
+	duart_unmask_ints(port->line, M_DUART_IMR_TX);
+}
+
+/* Return the number of characters in the output buffer that have yet to be 
+   written */
+static int duart_chars_in_buffer(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	int retval;
+
+	retval = us->outp_count;
+
+#ifdef DUART_SPEW
+	printk("duart_chars_in_buffer returning %i\n", retval);
+#endif
+	return retval;
+}
+
+/* Kill everything we haven't yet shoved into the FIFO.  Turn off the
+   transmit interrupt since we've nothing more to transmit */
+static void duart_flush_buffer(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long flags;
+
+#ifdef DUART_SPEW
+	printk("duart_flush_buffer called\n");
+#endif
+	spin_lock_irqsave(&us->outp_lock, flags);
+	us->outp_head = us->outp_tail = us->outp_count = 0;
+	spin_unlock_irqrestore(&us->outp_lock, flags);
+
+	wake_up_interruptible(&us->tty->write_wait);
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+	    tty->ldisc.write_wakeup)
+		tty->ldisc.write_wakeup(tty);
+}
+
+
+/* See sb1250 user manual for details on these registers */
+static inline void duart_set_cflag(unsigned int line, unsigned int cflag)
+{
+	unsigned int mode_reg1 = 0, mode_reg2 = 0;
+	unsigned int clk_divisor;
+	uart_state_t *port = uart_states + line;
+
+	switch (cflag & CSIZE) {
+	case CS7:
+		mode_reg1 |= V_DUART_BITS_PER_CHAR_7;
+		
+	default:
+		/* We don't handle CS5 or CS6...is there a way we're supposed to flag this? 
+		   right now we just force them to CS8 */
+		mode_reg1 |= 0x0;
+		break;
+	}
+	if (cflag & CSTOPB) {
+	        mode_reg2 |= M_DUART_STOP_BIT_LEN_2;
+	}
+	if (!(cflag & PARENB)) {
+	        mode_reg1 |= V_DUART_PARITY_MODE_NONE;
+	}
+	if (cflag & PARODD) {
+		mode_reg1 |= M_DUART_PARITY_TYPE_ODD;
+	}
+	
+	/* Formula for this is (5000000/baud)-1, but we saturate
+	   at 12 bits, which means we can't actually do anything less
+	   that 1200 baud */
+	switch (cflag & CBAUD) {
+	case B200:	
+	case B300:	
+	case B1200:	clk_divisor = 4095;		break;
+	case B1800:	clk_divisor = 2776;		break;
+	case B2400:	clk_divisor = 2082;		break;
+	case B4800:	clk_divisor = 1040;		break;
+	default:
+	case B9600:	clk_divisor = 519;		break;
+	case B19200:	clk_divisor = 259;		break;
+	case B38400:	clk_divisor = 129;		break;
+	case B57600:	clk_divisor = 85;		break;
+	case B115200:	clk_divisor = 42;		break;
+	}
+	WRITE_SERCSR(mode_reg1, port->mode_1, port->line);
+	WRITE_SERCSR(mode_reg2, port->mode_2, port->line);
+	WRITE_SERCSR(clk_divisor, port->clk_sel, port->line);
+	port->last_cflags = cflag;
+}
+
+
+/* Handle notification of a termios change.  */
+static void duart_set_termios(struct tty_struct *tty, struct termios *old)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+#ifdef DUART_SPEW 
+	printk("duart_set_termios called by %i (%s)\n", current->pid, current->comm);
+#endif
+	if (old && tty->termios->c_cflag == old->c_cflag)
+		return;
+	duart_set_cflag(us->line, tty->termios->c_cflag);
+}
+
+static int get_serial_info(uart_state_t *us, struct serial_struct * retinfo) {
+
+	struct serial_struct tmp;
+
+	memset(&tmp, 0, sizeof(tmp));
+
+	tmp.type=PORT_SB1250;
+	tmp.line=us->line;
+	tmp.port=A_DUART_CHANREG(tmp.line,0);
+	tmp.irq=K_INT_UART_0 + tmp.line;
+	tmp.xmit_fifo_size=16; /* fixed by hw */
+	tmp.baud_base=5000000;
+	tmp.io_type=SERIAL_IO_MEM;
+
+	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static int duart_ioctl(struct tty_struct *tty, struct file * file,
+		       unsigned int cmd, unsigned long arg)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+/*	if (serial_paranoia_check(info, tty->device, "rs_ioctl"))
+	return -ENODEV;*/
+	switch (cmd) {
+	case TIOCMGET:
+		printk("Ignoring TIOCMGET\n");
+		break;
+	case TIOCMBIS:
+		printk("Ignoring TIOCMBIS\n");
+		break;
+	case TIOCMBIC:
+		printk("Ignoring TIOCMBIC\n");
+		break;
+	case TIOCMSET:
+		printk("Ignoring TIOCMSET\n");
+		break;
+	case TIOCGSERIAL:
+		return get_serial_info(us,(struct serial_struct *) arg);
+	case TIOCSSERIAL:
+		printk("Ignoring TIOCSSERIAL\n");
+		break;
+	case TIOCSERCONFIG:
+		printk("Ignoring TIOCSERCONFIG\n");
+		break;
+	case TIOCSERGETLSR: /* Get line status register */
+		printk("Ignoring TIOCSERGETLSR\n");
+		break;
+	case TIOCSERGSTRUCT:
+		printk("Ignoring TIOCSERGSTRUCT\n");
+		break;
+	case TIOCMIWAIT:
+		printk("Ignoring TIOCMIWAIT\n");
+		break;
+	case TIOCGICOUNT:
+		printk("Ignoring TIOCGICOUNT\n");
+		break;
+	case TIOCSERGWILD:
+		printk("Ignoring TIOCSERGWILD\n");
+		break;
+	case TIOCSERSWILD:
+		printk("Ignoring TIOCSERSWILD\n");
+		break;
+	default:
+		break;
+	}
+//	printk("Ignoring IOCTL %x from pid %i (%s)\n", cmd, current->pid, current->comm);
+	return -ENOIOCTLCMD;
+}
+
+/* XXXKW locking? */
+static void duart_start(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+#ifdef DUART_SPEW
+	printk("duart_start called\n");
+#endif
+
+	if (us->outp_count && !(us->flags & TX_INTEN)) {
+		us->flags |= TX_INTEN;
+		duart_unmask_ints(us->line, M_DUART_IMR_TX);
+	}
+}
+
+/* XXXKW locking? */
+static void duart_stop(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+#ifdef DUART_SPEW
+	printk("duart_stop called\n");
+#endif
+
+	if (us->outp_count && (us->flags & TX_INTEN)) {
+		us->flags &= ~TX_INTEN;
+		duart_mask_ints(us->line, M_DUART_IMR_TX);
+	}
+}
+
+/* Not sure on the semantics of this; are we supposed to wait until the stuff
+   already in the hardware FIFO drains, or are we supposed to wait until 
+   we've drained the output buffer, too?  I'm assuming the former, 'cause thats
+   what the other drivers seem to assume 
+*/
+
+static void duart_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long orig_jiffies;
+
+	orig_jiffies = jiffies;
+#ifdef DUART_SPEW
+	printk("duart_wait_until_sent(%d)+\n", timeout);
+#endif
+	while (!(READ_SERCSR(us->status, us->line) & M_DUART_TX_EMT)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+	 	schedule_timeout(1);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
+	}
+#ifdef DUART_SPEW
+	printk("duart_wait_until_sent()-\n");
+#endif
+}
+
+/*
+ * duart_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void duart_hangup(struct tty_struct *tty)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
+	duart_flush_buffer(tty);
+	us->open = 0;
+	us->tty = 0;
+}
+
+/*
+ * Open a tty line.  Note that this can be called multiple times, so ->open can
+ * be >1.  Only set up the tty struct if this is a "new" open, e.g. ->open was
+ * zero
+ */
+static int duart_open(struct tty_struct *tty, struct file *filp)
+{
+	uart_state_t *us;
+	unsigned int line = tty->index;
+	unsigned long flags;
+
+	if ((line >= tty->driver->num) || !sb1250_duart_present[line])
+		return -ENODEV;
+
+#ifdef DUART_SPEW
+	printk("duart_open called by %i (%s), tty is %p, rw is %p, ww is %p\n",
+	       current->pid, current->comm, tty, tty->read_wait,
+	       tty->write_wait);
+#endif
+
+	us = uart_states + line;
+	tty->driver_data = us;
+
+	spin_lock_irqsave(&open_lock, flags);
+	if (!us->open) {
+		us->tty = tty;
+		us->tty->termios->c_cflag = us->last_cflags;
+	}
+	us->open++;
+	us->flags &= ~TX_INTEN;
+	duart_unmask_ints(line, M_DUART_IMR_RX);
+	spin_unlock_irqrestore(&open_lock, flags);
+
+	return 0;
+}
+
+
+/*
+ * Close a reference count out.  If reference count hits zero, null the
+ * tty, kill the interrupts.  The tty_io driver is responsible for making
+ * sure we've cleared out our internal buffers before calling close()
+ */
+static void duart_close(struct tty_struct *tty, struct file *filp)
+{
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+	unsigned long flags;
+
+#ifdef DUART_SPEW
+	printk("duart_close called by %i (%s)\n", current->pid, current->comm);
+#endif
+
+	if (!us || !us->open)
+		return;
+
+	spin_lock_irqsave(&open_lock, flags);
+	if (tty_hung_up_p(filp)) {
+		spin_unlock_irqrestore(&open_lock, flags);
+		return;
+	}
+
+	if (--us->open < 0) {
+		us->open = 0;
+		printk(KERN_ERR "duart: bad open count: %d\n", us->open);
+	}
+	if (us->open) {
+		spin_unlock_irqrestore(&open_lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&open_lock, flags);
+
+	tty->closing = 1;
+
+	/* Stop accepting input */
+	duart_mask_ints(us->line, M_DUART_IMR_RX);
+	/* Wait for FIFO to drain */
+	while (!(READ_SERCSR(us->status, us->line) & M_DUART_TX_EMT))
+		;
+
+	if (tty->driver->flush_buffer)
+		tty->driver->flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+}
+
+
+static struct tty_operations duart_ops = {
+        .open   = duart_open,
+        .close = duart_close,
+        .write = duart_write,
+        .put_char = duart_put_char,
+        .flush_chars = duart_flush_chars,
+        .write_room = duart_write_room,
+        .chars_in_buffer = duart_chars_in_buffer,
+        .flush_buffer = duart_flush_buffer,
+        .ioctl = duart_ioctl,
+//        .throttle = duart_throttle,
+//        .unthrottle = duart_unthrottle,
+        .set_termios = duart_set_termios,
+        .stop = duart_stop,
+        .start = duart_start,
+        .hangup = duart_hangup,
+	.wait_until_sent = duart_wait_until_sent,
+};
+
+/* Set up the driver and register it, register the 2 1250 UART interrupts.  This
+   is called from tty_init, or as a part of the module init */
+static int __init sb1250_duart_init(void) 
+{
+	int i;
+
+	sb1250_duart_driver = alloc_tty_driver(DUART_MAX_LINE);
+	if (!sb1250_duart_driver)
+		return -ENOMEM;
+
+	sb1250_duart_driver->owner = THIS_MODULE;
+	sb1250_duart_driver->name = "duart";
+	sb1250_duart_driver->devfs_name = "duart/";
+	sb1250_duart_driver->major = TTY_MAJOR;
+	sb1250_duart_driver->minor_start = SB1250_DUART_MINOR_BASE;
+	sb1250_duart_driver->type            = TTY_DRIVER_TYPE_SERIAL;
+	sb1250_duart_driver->subtype         = SERIAL_TYPE_NORMAL;
+	sb1250_duart_driver->init_termios    = tty_std_termios;
+	sb1250_duart_driver->flags           = TTY_DRIVER_REAL_RAW;
+	tty_set_operations(sb1250_duart_driver, &duart_ops);
+
+	for (i=0; i<DUART_MAX_LINE; i++) {
+		uart_state_t *port = uart_states + i;
+
+		if (!sb1250_duart_present[i])
+			continue;
+
+		init_duart_port(port, i);
+		spin_lock_init(&port->outp_lock);
+		duart_mask_ints(i, M_DUART_IMR_ALL);
+		if (request_irq(K_INT_UART_0+i, duart_int, 0, "uart", port)) {
+			panic("Couldn't get uart0 interrupt line");
+		}
+		__raw_writeq(M_DUART_RX_EN|M_DUART_TX_EN,
+			     IOADDR(A_DUART_CHANREG(i, R_DUART_CMD)));
+		duart_set_cflag(i, DEFAULT_CFLAGS);
+	}
+
+	/* Interrupts are now active, our ISR can be called. */
+
+	if (tty_register_driver(sb1250_duart_driver)) {
+		printk(KERN_ERR "Couldn't register sb1250 duart serial driver\n");
+		put_tty_driver(sb1250_duart_driver);
+		return 1;
+	}
+	return 0;
+}
+
+/* Unload the driver.  Unregister stuff, get ready to go away */
+static void __exit sb1250_duart_fini(void)
+{
+	unsigned long flags;
+	int i;
+
+	local_irq_save(flags);
+	tty_unregister_driver(sb1250_duart_driver);
+	put_tty_driver(sb1250_duart_driver);
+
+	for (i=0; i<DUART_MAX_LINE; i++) {
+		if (!sb1250_duart_present[i])
+			continue;
+		free_irq(K_INT_UART_0+i, &uart_states[i]);
+		disable_irq(K_INT_UART_0+i);
+	}
+	local_irq_restore(flags);
+}
+
+module_init(sb1250_duart_init);
+module_exit(sb1250_duart_fini);
+MODULE_DESCRIPTION("SB1250 Duart serial driver");
+MODULE_AUTHOR("Justin Carlson, Broadcom Corp.");
+
+#ifdef CONFIG_SIBYTE_SB1250_DUART_CONSOLE
+
+/*
+ * Serial console stuff.  Very basic, polling driver for doing serial
+ * console output.  The console_sem is held by the caller, so we
+ * shouldn't be interrupted for more console activity.
+ * XXXKW What about getting interrupted by uart driver activity?
+ */
+
+void serial_outc(unsigned char c, int line)
+{
+	uart_state_t *port = uart_states + line;
+	while (!(READ_SERCSR(port->status, line) & M_DUART_TX_RDY)) ;
+	WRITE_SERCSR(c, port->tx_hold, line);
+	while (!(READ_SERCSR(port->status, port->line) & M_DUART_TX_EMT)) ;
+}
+
+static void ser_console_write(struct console *cons, const char *s,
+	unsigned int count)
+{
+	int line = cons->index;
+	uart_state_t *port = uart_states + line;
+	u32 imr;
+
+	imr = READ_SERCSR(port->imr, line);
+	WRITE_SERCSR(0, port->imr, line);
+	while (count--) {
+		if (*s == '\n')
+			serial_outc('\r', line);
+		serial_outc(*s++, line);
+    	}
+	WRITE_SERCSR(imr, port->imr, line);
+}
+
+static struct tty_driver *ser_console_device(struct console *c, int *index)
+{
+	*index = c->index;
+	return sb1250_duart_driver;
+}
+
+static int ser_console_setup(struct console *cons, char *str)
+{
+	int i;
+
+	for (i=0; i<DUART_MAX_LINE; i++) {
+		uart_state_t *port = uart_states + i;
+
+		if (!sb1250_duart_present[i])
+			continue;
+
+		init_duart_port(port, i);
+#if SIBYTE_1956_WAR
+		last_mode1[i] = V_DUART_PARITY_MODE_NONE|V_DUART_BITS_PER_CHAR_8;
+#endif
+		WRITE_SERCSR(V_DUART_PARITY_MODE_NONE|V_DUART_BITS_PER_CHAR_8,
+			     port->mode_1, i);
+		WRITE_SERCSR(M_DUART_STOP_BIT_LEN_1,
+			     port->mode_2, i);
+		WRITE_SERCSR(V_DUART_BAUD_RATE(115200),
+			     port->clk_sel, i);
+		WRITE_SERCSR(M_DUART_RX_EN|M_DUART_TX_EN,
+			     port->cmd, i);
+	}
+	return 0;
+}
+
+static struct console sb1250_ser_cons = {
+	.name		= "duart",
+	.write		= ser_console_write,
+	.device		= ser_console_device,
+	.setup		= ser_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+};
+
+static int __init sb1250_serial_console_init(void)
+{
+	register_console(&sb1250_ser_cons);
+	return 0;
+}
+
+console_initcall(sb1250_serial_console_init);
+
+#endif /* CONFIG_SIBYTE_SB1250_DUART_CONSOLE */
diff -urpNX dontdiff linux-2.6.11.6/drivers/i2c/busses/i2c-au1550.c linux_HEAD/drivers/i2c/busses/i2c-au1550.c
--- linux-2.6.11.6/drivers/i2c/busses/i2c-au1550.c	2005-04-03 00:10:57.000000000 +0200
+++ linux_HEAD/drivers/i2c/busses/i2c-au1550.c	2005-03-21 20:04:08.000000000 +0100
@@ -21,7 +21,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
+ * 
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
@@ -290,8 +290,8 @@ static struct i2c_algorithm au1550_algo 
 	.functionality	= au1550_func,
 };
 
-/*
- * registering functions to load algorithms at runtime
+/* 
+ * registering functions to load algorithms at runtime 
  * Prior to calling us, the 50MHz clock frequency and routing
  * must have been set up for the PSC indicated by the adapter.
  */
diff -urpNX dontdiff linux-2.6.11.6/drivers/i2c/busses/i2c-sibyte.c linux_HEAD/drivers/i2c/busses/i2c-sibyte.c
--- linux-2.6.11.6/drivers/i2c/busses/i2c-sibyte.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/drivers/i2c/busses/i2c-sibyte.c	2005-01-11 18:55:08.000000000 +0100
@@ -24,8 +24,8 @@
 #include <asm/sibyte/sb1250_smbus.h>
 
 static struct i2c_algo_sibyte_data sibyte_board_data[2] = {
-	{ NULL, 0, (void *) (KSEG1+A_SMB_BASE(0)) },
-	{ NULL, 1, (void *) (KSEG1+A_SMB_BASE(1)) }
+	{ NULL, 0, (void *) (CKSEG1+A_SMB_BASE(0)) },
+	{ NULL, 1, (void *) (CKSEG1+A_SMB_BASE(1)) }
 };
 
 static struct i2c_adapter sibyte_board_adapter[2] = {
diff -urpNX dontdiff linux-2.6.11.6/drivers/ide/Kconfig linux_HEAD/drivers/ide/Kconfig
--- linux-2.6.11.6/drivers/ide/Kconfig	2005-04-03 00:10:57.000000000 +0200
+++ linux_HEAD/drivers/ide/Kconfig	2005-03-21 20:04:08.000000000 +0100
@@ -771,6 +771,10 @@ config BLK_DEV_IDE_PMAC_BLINK
 	  This option enables the use of the sleep LED as a hard drive
 	  activity LED.
 
+config BLK_DEV_IDE_SWARM
+	bool "IDE for Sibyte evaluation boards"
+	depends on SIBYTE_SB1xxx_SOC
+
 config IDE_ARM
 	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/ide/Makefile linux_HEAD/drivers/ide/Makefile
--- linux-2.6.11.6/drivers/ide/Makefile	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/drivers/ide/Makefile	2004-11-19 01:14:26.000000000 +0100
@@ -50,6 +50,6 @@ obj-$(CONFIG_BLK_DEV_IDECD)		+= ide-cd.o
 obj-$(CONFIG_BLK_DEV_IDETAPE)		+= ide-tape.o
 obj-$(CONFIG_BLK_DEV_IDEFLOPPY)		+= ide-floppy.o
 
-obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/
+obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/ mips/
 obj-$(CONFIG_BLK_DEV_HD)		+= legacy/
 obj-$(CONFIG_ETRAX_IDE)		+= cris/
diff -urpNX dontdiff linux-2.6.11.6/drivers/ide/ide.c linux_HEAD/drivers/ide/ide.c
--- linux-2.6.11.6/drivers/ide/ide.c	2005-04-03 00:10:58.000000000 +0200
+++ linux_HEAD/drivers/ide/ide.c	2005-03-21 20:04:09.000000000 +0100
@@ -2003,6 +2003,12 @@ static void __init probe_for_hwifs (void
 		q40ide_init();
 	}
 #endif /* CONFIG_BLK_DEV_Q40IDE */
+#ifdef CONFIG_BLK_DEV_IDE_SWARM
+	{
+		extern void swarm_ide_probe(void);
+		swarm_ide_probe();
+	}
+#endif /* CONFIG_BLK_DEV_IDE_SWARM */
 #ifdef CONFIG_BLK_DEV_BUDDHA
 	{
 		extern void buddha_init(void);
diff -urpNX dontdiff linux-2.6.11.6/drivers/ide/mips/Makefile linux_HEAD/drivers/ide/mips/Makefile
--- linux-2.6.11.6/drivers/ide/mips/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/ide/mips/Makefile	2004-09-21 13:10:22.000000000 +0200
@@ -0,0 +1,3 @@
+obj-$(CONFIG_BLK_DEV_IDE_SWARM)		+= swarm.o
+
+EXTRA_CFLAGS	:= -I../
diff -urpNX dontdiff linux-2.6.11.6/drivers/ide/mips/swarm.c linux_HEAD/drivers/ide/mips/swarm.c
--- linux-2.6.11.6/drivers/ide/mips/swarm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/ide/mips/swarm.c	2005-02-24 00:13:18.000000000 +0100
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2001, 2002, 2003 Broadcom Corporation
+ * Copyright (C) 2004 MontaVista Software Inc.
+ *	Author:	Manish Lachwani, mlachwani@mvista.com
+ * Copyright (C) 2004  MIPS Technologies, Inc.  All rights reserved.
+ *	Author: Maciej W. Rozycki <macro@mips.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ *  Derived loosely from ide-pmac.c, so:  
+ *  Copyright (C) 1998 Paul Mackerras.
+ *  Copyright (C) 1995-1998 Mark Lord
+ */
+
+/*
+ * Boards with SiByte processors so far have supported IDE devices via
+ * the Generic Bus, PCI bus, and built-in PCMCIA interface.  In all
+ * cases, byte-swapping must be avoided for these devices (whereas
+ * other PCI devices, for example, will require swapping).  Any
+ * SiByte-targetted kernel including IDE support will include this
+ * file.  Probing of a Generic Bus for an IDE device is controlled by
+ * the definition of "SIBYTE_HAVE_IDE", which is provided by
+ * <asm/sibyte/board.h> for Broadcom boards.
+ */
+
+#include <linux/ide.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+
+#include <asm/sibyte/board.h>
+#include <asm/sibyte/sb1250_genbus.h>
+#include <asm/sibyte/sb1250_regs.h>
+
+#define DRV_NAME "ide-swarm"
+
+static struct resource swarm_ide_resource = {
+	.name	= "SWARM GenBus IDE",
+	.flags	= IORESOURCE_MEM,
+};
+
+/*
+ * swarm_ide_probe - if the board header indicates the existence of
+ * Generic Bus IDE, allocate a HWIF for it.
+ */
+void __init swarm_ide_probe(void)
+{
+	ide_hwif_t *hwif;
+	u8 __iomem *base;
+	phys_t offset, size;
+	int i;
+
+	if (!SIBYTE_HAVE_IDE)
+		return;
+
+	/* Find an empty slot.  */
+	for (i = 0; i < MAX_HWIFS; i++) 
+		if (!ide_hwifs[i].io_ports[IDE_DATA_OFFSET])
+			break;
+	if (i >= MAX_HWIFS) {
+		printk(KERN_ERR DRV_NAME ": no free slot for interface\n");
+		return;
+	}
+	hwif = ide_hwifs + i;
+
+	base = ioremap(A_IO_EXT_BASE, 0x800);
+	offset = __raw_readq(base + R_IO_EXT_REG(R_IO_EXT_START_ADDR, IDE_CS));
+	size = __raw_readq(base + R_IO_EXT_REG(R_IO_EXT_MULT_SIZE, IDE_CS));
+	iounmap(base);
+	
+	offset = G_IO_START_ADDR(offset) << S_IO_ADDRBASE;
+	size = (G_IO_MULT_SIZE(size) + 1) << S_IO_REGSIZE;
+	if (offset < A_PHYS_GENBUS || offset >= A_PHYS_GENBUS_END) {
+		printk(KERN_INFO DRV_NAME
+		       ": IDE interface at GenBus disabled\n");
+		return;
+	}
+
+	printk(KERN_INFO DRV_NAME ": IDE interface at GenBus slot %i\n",
+	       IDE_CS);
+
+	swarm_ide_resource.start = offset;
+	swarm_ide_resource.end = offset + size - 1;
+	if (request_resource(&iomem_resource, &swarm_ide_resource)) {
+		printk(KERN_ERR DRV_NAME
+		       ": can't request I/O memory resource\n");
+		return;
+	}
+
+	base = ioremap(offset, size);
+
+	/* Setup MMIO ops.  */
+	default_hwif_mmiops(hwif);
+	/* Prevent resource map manipulation.  */
+	hwif->mmio = 2;
+	hwif->noprobe = 0;
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++)
+		hwif->hw.io_ports[i] =
+				(unsigned long)(base + ((0x1f0 + i) << 5));
+	hwif->hw.io_ports[IDE_CONTROL_OFFSET] =
+				(unsigned long)(base + (0x3f6 << 5));
+	hwif->hw.irq = K_INT_GB_IDE;
+
+	memcpy(hwif->io_ports, hwif->hw.io_ports, sizeof(hwif->io_ports));
+	hwif->irq = hwif->hw.irq;
+}
diff -urpNX dontdiff linux-2.6.11.6/drivers/input/serio/i8042-x86ia64io.h linux_HEAD/drivers/input/serio/i8042-x86ia64io.h
--- linux-2.6.11.6/drivers/input/serio/i8042-x86ia64io.h	2005-04-03 00:11:01.000000000 +0200
+++ linux_HEAD/drivers/input/serio/i8042-x86ia64io.h	2005-03-21 20:04:13.000000000 +0100
@@ -86,186 +86,208 @@ static struct dmi_system_id __initdata i
 	},
 	{ }
 };
+
+/*
+ * Some Fujitsu notebooks are ahving trouble with touhcpads if
+ * active multiplexing mode is activated. Luckily they don't have
+ * external PS/2 ports so we can safely disable it.
+ */
+static struct dmi_system_id __initdata i8042_dmi_nomux_table[] = {
+	{
+		.ident = "Fujitsu Lifebook P7010/P7010D",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "P7010"),
+		},
+	},
+	{
+		.ident = "Fujitsu Lifebook P5020D",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook P Series"),
+		},
+	},
+	{
+		.ident = "Fujitsu Lifebook S2000",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook S Series"),
+		},
+	},
+	{
+		.ident = "Fujitsu T70H",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "FMVLT70H"),
+		},
+	},
+	{ }
+};
+
+
+
 #endif
 
-#if defined(__ia64__) && defined(CONFIG_ACPI)
-#include <linux/acpi.h>
-#include <acpi/acpi_bus.h>
-
-struct i8042_acpi_resources {
-	unsigned int port1;
-	unsigned int port2;
-	unsigned int irq;
-};
-
-static int i8042_acpi_kbd_registered;
-static int i8042_acpi_aux_registered;
-
-static acpi_status i8042_acpi_parse_resource(struct acpi_resource *res, void *data)
-{
-	struct i8042_acpi_resources *i8042_res = data;
-	struct acpi_resource_io *io;
-	struct acpi_resource_fixed_io *fixed_io;
-	struct acpi_resource_irq *irq;
-	struct acpi_resource_ext_irq *ext_irq;
-
-	switch (res->id) {
-		case ACPI_RSTYPE_IO:
-			io = &res->data.io;
-			if (io->range_length) {
-				if (!i8042_res->port1)
-					i8042_res->port1 = io->min_base_address;
-				else
-					i8042_res->port2 = io->min_base_address;
-			}
-			break;
-
-		case ACPI_RSTYPE_FIXED_IO:
-			fixed_io = &res->data.fixed_io;
-			if (fixed_io->range_length) {
-				if (!i8042_res->port1)
-					i8042_res->port1 = fixed_io->base_address;
-				else
-					i8042_res->port2 = fixed_io->base_address;
-			}
-			break;
-
-		case ACPI_RSTYPE_IRQ:
-			irq = &res->data.irq;
-			if (irq->number_of_interrupts > 0)
-				i8042_res->irq =
-					acpi_register_gsi(irq->interrupts[0],
-							  irq->edge_level,
-							  irq->active_high_low);
-			break;
-
-		case ACPI_RSTYPE_EXT_IRQ:
-			ext_irq = &res->data.extended_irq;
-			if (ext_irq->number_of_interrupts > 0)
-				i8042_res->irq =
-					acpi_register_gsi(ext_irq->interrupts[0],
-							  ext_irq->edge_level,
-							  ext_irq->active_high_low);
-			break;
-	}
-	return AE_OK;
-}
-
-static int i8042_acpi_kbd_add(struct acpi_device *device)
-{
-	struct i8042_acpi_resources kbd_res;
-	acpi_status status;
-
-	memset(&kbd_res, 0, sizeof(kbd_res));
-	status = acpi_walk_resources(device->handle, METHOD_NAME__CRS,
-				     i8042_acpi_parse_resource, &kbd_res);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
 
-	if (kbd_res.port1)
-		i8042_data_reg = kbd_res.port1;
-	else
-		printk(KERN_WARNING "ACPI: [%s] has no data port; default is 0x%x\n",
-			acpi_device_bid(device), i8042_data_reg);
-
-	if (kbd_res.port2)
-		i8042_command_reg = kbd_res.port2;
-	else
-		printk(KERN_WARNING "ACPI: [%s] has no command port; default is 0x%x\n",
-			acpi_device_bid(device), i8042_command_reg);
-
-	if (kbd_res.irq)
-		i8042_kbd_irq = kbd_res.irq;
-	else
-		printk(KERN_WARNING "ACPI: [%s] has no IRQ; default is %d\n",
-			acpi_device_bid(device), i8042_kbd_irq);
-
-	strncpy(acpi_device_name(device), "PS/2 Keyboard Controller",
-		sizeof(acpi_device_name(device)));
-	printk("ACPI: %s [%s] at I/O 0x%x, 0x%x, irq %d\n",
-		acpi_device_name(device), acpi_device_bid(device),
-		i8042_data_reg, i8042_command_reg, i8042_kbd_irq);
+#ifdef CONFIG_PNP
+#include <linux/pnp.h>
+
+static int i8042_pnp_kbd_registered;
+static int i8042_pnp_aux_registered;
+
+static int i8042_pnp_command_reg;
+static int i8042_pnp_data_reg;
+static int i8042_pnp_kbd_irq;
+static int i8042_pnp_aux_irq;
+
+static char i8042_pnp_kbd_name[32];
+static char i8042_pnp_aux_name[32];
+
+static int i8042_pnp_kbd_probe(struct pnp_dev *dev, const struct pnp_device_id *did)
+{
+	if (pnp_port_valid(dev, 0) && pnp_port_len(dev, 0) == 1)
+		i8042_pnp_data_reg = pnp_port_start(dev,0);
+
+	if (pnp_port_valid(dev, 1) && pnp_port_len(dev, 1) == 1)
+		i8042_pnp_command_reg = pnp_port_start(dev, 1);
+
+	if (pnp_irq_valid(dev,0))
+		i8042_pnp_kbd_irq = pnp_irq(dev, 0);
+
+	strncpy(i8042_pnp_kbd_name, did->id, sizeof(i8042_pnp_kbd_name));
+	if (strlen(pnp_dev_name(dev))) {
+		strncat(i8042_pnp_kbd_name, ":", sizeof(i8042_pnp_kbd_name));
+		strncat(i8042_pnp_kbd_name, pnp_dev_name(dev), sizeof(i8042_pnp_kbd_name));
+	}
 
 	return 0;
 }
 
-static int i8042_acpi_aux_add(struct acpi_device *device)
+static int i8042_pnp_aux_probe(struct pnp_dev *dev, const struct pnp_device_id *did)
 {
-	struct i8042_acpi_resources aux_res;
-	acpi_status status;
+	if (pnp_port_valid(dev, 0) && pnp_port_len(dev, 0) == 1)
+		i8042_pnp_data_reg = pnp_port_start(dev,0);
 
-	memset(&aux_res, 0, sizeof(aux_res));
-	status = acpi_walk_resources(device->handle, METHOD_NAME__CRS,
-				     i8042_acpi_parse_resource, &aux_res);
-	if (ACPI_FAILURE(status))
-		return -ENODEV;
+	if (pnp_port_valid(dev, 1) && pnp_port_len(dev, 1) == 1)
+		i8042_pnp_command_reg = pnp_port_start(dev, 1);
 
-	if (aux_res.irq)
-		i8042_aux_irq = aux_res.irq;
-	else
-		printk(KERN_WARNING "ACPI: [%s] has no IRQ; default is %d\n",
-			acpi_device_bid(device), i8042_aux_irq);
-
-	strncpy(acpi_device_name(device), "PS/2 Mouse Controller",
-		sizeof(acpi_device_name(device)));
-	printk("ACPI: %s [%s] at irq %d\n",
-		acpi_device_name(device), acpi_device_bid(device), i8042_aux_irq);
+	if (pnp_irq_valid(dev, 0))
+		i8042_pnp_aux_irq = pnp_irq(dev, 0);
+
+	strncpy(i8042_pnp_aux_name, did->id, sizeof(i8042_pnp_aux_name));
+	if (strlen(pnp_dev_name(dev))) {
+		strncat(i8042_pnp_aux_name, ":", sizeof(i8042_pnp_aux_name));
+		strncat(i8042_pnp_aux_name, pnp_dev_name(dev), sizeof(i8042_pnp_aux_name));
+	}
 
 	return 0;
 }
 
-static struct acpi_driver i8042_acpi_kbd_driver = {
-	.name		= "i8042",
-	.ids		= "PNP0303,PNP030B",
-	.ops		= {
-		.add		= i8042_acpi_kbd_add,
-	},
+static struct pnp_device_id pnp_kbd_devids[] = {
+	{ .id = "PNP0303", .driver_data = 0 },
+	{ .id = "PNP030b", .driver_data = 0 },
+	{ .id = "", },
 };
 
-static struct acpi_driver i8042_acpi_aux_driver = {
-	.name		= "i8042",
-	.ids		= "PNP0F03,PNP0F0B,PNP0F0E,PNP0F12,PNP0F13,SYN0801",
-	.ops		= {
-		.add		= i8042_acpi_aux_add,
-	},
+static struct pnp_driver i8042_pnp_kbd_driver = {
+	.name           = "i8042 kbd",
+	.id_table       = pnp_kbd_devids,
+	.probe          = i8042_pnp_kbd_probe,
+};
+
+static struct pnp_device_id pnp_aux_devids[] = {
+	{ .id = "PNP0f03", .driver_data = 0 },
+	{ .id = "PNP0f0b", .driver_data = 0 },
+	{ .id = "PNP0f0e", .driver_data = 0 },
+	{ .id = "PNP0f12", .driver_data = 0 },
+	{ .id = "PNP0f13", .driver_data = 0 },
+	{ .id = "PNP0f19", .driver_data = 0 },
+	{ .id = "PNP0f1c", .driver_data = 0 },
+	{ .id = "SYN0801", .driver_data = 0 },
+	{ .id = "", },
 };
 
-static int i8042_acpi_init(void)
+static struct pnp_driver i8042_pnp_aux_driver = {
+	.name           = "i8042 aux",
+	.id_table       = pnp_aux_devids,
+	.probe          = i8042_pnp_aux_probe,
+};
+
+static void i8042_pnp_exit(void)
 {
-	int result;
+	if (i8042_pnp_kbd_registered)
+		pnp_unregister_driver(&i8042_pnp_kbd_driver);
+
+	if (i8042_pnp_aux_registered)
+		pnp_unregister_driver(&i8042_pnp_aux_driver);
+}
 
-	if (acpi_disabled || i8042_noacpi) {
-		printk("i8042: ACPI detection disabled\n");
+static int i8042_pnp_init(void)
+{
+	int result_kbd, result_aux;
+
+	if (i8042_nopnp) {
+		printk("i8042: PNP detection disabled\n");
 		return 0;
 	}
 
-	result = acpi_bus_register_driver(&i8042_acpi_kbd_driver);
-	if (result < 0)
-		return result;
+	if ((result_kbd = pnp_register_driver(&i8042_pnp_kbd_driver)) >= 0)
+		i8042_pnp_kbd_registered = 1;
+	if ((result_aux = pnp_register_driver(&i8042_pnp_aux_driver)) >= 0)
+		i8042_pnp_aux_registered = 1;
 
-	if (result == 0) {
-		acpi_bus_unregister_driver(&i8042_acpi_kbd_driver);
+	if (result_kbd <= 0 && result_aux <= 0) {
+		i8042_pnp_exit();
+#if defined(__ia64__)
 		return -ENODEV;
+#else
+		printk(KERN_WARNING "PNP: No PS/2 controller found. Probing ports directly.\n");
+		return 0;
+#endif
+	}
+
+	if (((i8042_pnp_data_reg & ~0xf) == (i8042_data_reg & ~0xf) &&
+	      i8042_pnp_data_reg != i8042_data_reg) || !i8042_pnp_data_reg) {
+		printk(KERN_WARNING "PNP: PS/2 controller has invalid data port %#x; using default %#x\n",
+			i8042_pnp_data_reg, i8042_data_reg);
+		i8042_pnp_data_reg = i8042_data_reg;
+	}
+
+	if (((i8042_pnp_command_reg & ~0xf) == (i8042_command_reg & ~0xf) &&
+	      i8042_pnp_command_reg != i8042_command_reg) || !i8042_pnp_command_reg) {
+		printk(KERN_WARNING "PNP: PS/2 controller has invalid command port %#x; using default %#x\n",
+			i8042_pnp_command_reg, i8042_command_reg);
+		i8042_pnp_command_reg = i8042_command_reg;
+	}
+
+	if (!i8042_pnp_kbd_irq) {
+		printk(KERN_WARNING "PNP: PS/2 controller doesn't have KBD irq; using default %#x\n", i8042_kbd_irq);
+		i8042_pnp_kbd_irq = i8042_kbd_irq;
+	}
+
+	if (result_aux > 0 && !i8042_pnp_aux_irq) {
+		printk(KERN_WARNING "PNP: PS/2 controller doesn't have AUX irq; using default %#x\n", i8042_aux_irq);
+		i8042_pnp_aux_irq = i8042_aux_irq;
 	}
-	i8042_acpi_kbd_registered = 1;
 
-	result = acpi_bus_register_driver(&i8042_acpi_aux_driver);
-	if (result >= 0)
-		i8042_acpi_aux_registered = 1;
-	if (result == 0)
+#if defined(__ia64__)
+	if (result_aux <= 0)
 		i8042_noaux = 1;
+#endif
+
+	i8042_data_reg = i8042_pnp_data_reg;
+	i8042_command_reg = i8042_pnp_command_reg;
+	i8042_kbd_irq = i8042_pnp_kbd_irq;
+	i8042_aux_irq = i8042_pnp_aux_irq;
+
+	printk(KERN_INFO "PNP: PS/2 Controller [%s%s%s] at %#x,%#x irq %d%s%d\n",
+		i8042_pnp_kbd_name, (result_kbd > 0 && result_aux > 0) ? "," : "", i8042_pnp_aux_name,
+		i8042_data_reg, i8042_command_reg, i8042_kbd_irq,
+		(result_aux > 0) ? "," : "", i8042_aux_irq);
 
 	return 0;
 }
 
-static void i8042_acpi_exit(void)
-{
-	if (i8042_acpi_kbd_registered)
-		acpi_bus_unregister_driver(&i8042_acpi_kbd_driver);
-
-	if (i8042_acpi_aux_registered)
-		acpi_bus_unregister_driver(&i8042_acpi_aux_driver);
-}
 #endif
 
 static inline int i8042_platform_init(void)
@@ -281,8 +303,8 @@ static inline int i8042_platform_init(vo
 	i8042_kbd_irq = I8042_MAP_IRQ(1);
 	i8042_aux_irq = I8042_MAP_IRQ(12);
 
-#if defined(__ia64__) && defined(CONFIG_ACPI)
-	if (i8042_acpi_init())
+#ifdef CONFIG_PNP
+	if (i8042_pnp_init())
 		return -1;
 #endif
 
@@ -303,8 +325,8 @@ static inline int i8042_platform_init(vo
 
 static inline void i8042_platform_exit(void)
 {
-#if defined(__ia64__) && defined(CONFIG_ACPI)
-	i8042_acpi_exit();
+#ifdef CONFIG_PNP
+	i8042_pnp_exit();
 #endif
 }
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/md/raid6altivec.uc linux_HEAD/drivers/md/raid6altivec.uc
--- linux-2.6.11.6/drivers/md/raid6altivec.uc	2005-04-03 00:11:02.000000000 +0200
+++ linux_HEAD/drivers/md/raid6altivec.uc	2005-03-21 20:04:17.000000000 +0100
@@ -108,11 +108,7 @@ int raid6_have_altivec(void);
 int raid6_have_altivec(void)
 {
 	/* This assumes either all CPUs have Altivec or none does */
-#ifdef CONFIG_PPC64
-	return cur_cpu_spec->cpu_features & CPU_FTR_ALTIVEC;
-#else
-	return cur_cpu_spec[0]->cpu_features & CPU_FTR_ALTIVEC;
-#endif
+	return cpu_has_feature(CPU_FTR_ALTIVEC);
 }
 #endif
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/Kconfig linux_HEAD/drivers/media/video/Kconfig
--- linux-2.6.11.6/drivers/media/video/Kconfig	2005-04-03 00:11:02.000000000 +0200
+++ linux_HEAD/drivers/media/video/Kconfig	2005-03-21 20:04:18.000000000 +0100
@@ -82,6 +82,14 @@ config VIDEO_W9966
 	  Check out <file:Documentation/video4linux/w9966.txt> for more
 	  information.
 
+config VIDEO_SWARM_7114H
+	tristate "Philips SAA7114H for SiByte BCM91250A"
+	depends on SIBYTE_SWARM && VIDEO_DEV && I2C_ALGO_SIBYTE
+	help
+	  Say Y or M to build the video4linux driver for the Philips
+	  SAA7114H video decoder on Broadcom SWARM board (BCM91250A).
+	  The decoder chip is on the BCM1250's "E2" 8-bit FIFO port.
+
 config VIDEO_CPIA
 	tristate "CPiA Video For Linux"
 	depends on VIDEO_DEV
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/Makefile linux_HEAD/drivers/media/video/Makefile
--- linux-2.6.11.6/drivers/media/video/Makefile	2005-04-03 00:11:02.000000000 +0200
+++ linux_HEAD/drivers/media/video/Makefile	2005-03-21 20:04:18.000000000 +0100
@@ -51,6 +51,9 @@ obj-$(CONFIG_VIDEO_BUF_DVB) += video-buf
 obj-$(CONFIG_VIDEO_BTCX)  += btcx-risc.o
 obj-$(CONFIG_VIDEO_TVEEPROM) += tveeprom.o
 
+obj-$(CONFIG_VIDEO_SWARM_7114H) += swarm_saa7114h.o
+obj-$(CONFIG_TUNER_3036) += tuner-3036.o
+
 obj-$(CONFIG_VIDEO_M32R_AR_M64278) += arv.o
 
 EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/adv7170.c linux_HEAD/drivers/media/video/adv7170.c
--- linux-2.6.11.6/drivers/media/video/adv7170.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/drivers/media/video/adv7170.c	2005-03-21 20:04:18.000000000 +0100
@@ -402,7 +402,6 @@ static struct i2c_client_address_data ad
 	.force			= force
 };
 
-static int adv7170_i2c_id = 0;
 static struct i2c_driver i2c_driver_adv7170;
 
 static int
@@ -432,7 +431,6 @@ adv7170_detect_client (struct i2c_adapte
 	client->adapter = adapter;
 	client->driver = &i2c_driver_adv7170;
 	client->flags = I2C_CLIENT_ALLOW_USE;
-	client->id = adv7170_i2c_id++;
 	if ((client->addr == I2C_ADV7170 >> 1) ||
 	    (client->addr == (I2C_ADV7170 >> 1) + 1)) {
 		dname = adv7170_name;
@@ -444,8 +442,7 @@ adv7170_detect_client (struct i2c_adapte
 		kfree(client);
 		return 0;
 	}
-	snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
-		"%s[%d]", dname, client->id);
+	strlcpy(I2C_NAME(client), dname, sizeof(I2C_NAME(client)));
 
 	encoder = kmalloc(sizeof(struct adv7170), GFP_KERNEL);
 	if (encoder == NULL) {
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/adv7175.c linux_HEAD/drivers/media/video/adv7175.c
--- linux-2.6.11.6/drivers/media/video/adv7175.c	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/drivers/media/video/adv7175.c	2005-03-21 20:04:18.000000000 +0100
@@ -452,7 +452,6 @@ static struct i2c_client_address_data ad
 	.force			= force
 };
 
-static int adv7175_i2c_id = 0;
 static struct i2c_driver i2c_driver_adv7175;
 
 static int
@@ -482,7 +481,6 @@ adv7175_detect_client (struct i2c_adapte
 	client->adapter = adapter;
 	client->driver = &i2c_driver_adv7175;
 	client->flags = I2C_CLIENT_ALLOW_USE;
-	client->id = adv7175_i2c_id++;
 	if ((client->addr == I2C_ADV7175 >> 1) ||
 	    (client->addr == (I2C_ADV7175 >> 1) + 1)) {
 		dname = adv7175_name;
@@ -494,8 +492,7 @@ adv7175_detect_client (struct i2c_adapte
 		kfree(client);
 		return 0;
 	}
-	snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
-		"%s[%d]", dname, client->id);
+	strlcpy(I2C_NAME(client), dname, sizeof(I2C_NAME(client)));
 
 	encoder = kmalloc(sizeof(struct adv7175), GFP_KERNEL);
 	if (encoder == NULL) {
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/bt819.c linux_HEAD/drivers/media/video/bt819.c
--- linux-2.6.11.6/drivers/media/video/bt819.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/drivers/media/video/bt819.c	2005-03-21 20:04:18.000000000 +0100
@@ -517,7 +517,6 @@ static struct i2c_client_address_data ad
 	.force			= force
 };
 
-static int bt819_i2c_id = 0;
 static struct i2c_driver i2c_driver_bt819;
 
 static int
@@ -546,7 +545,6 @@ bt819_detect_client (struct i2c_adapter 
 	client->adapter = adapter;
 	client->driver = &i2c_driver_bt819;
 	client->flags = I2C_CLIENT_ALLOW_USE;
-	client->id = bt819_i2c_id++;
 
 	decoder = kmalloc(sizeof(struct bt819), GFP_KERNEL);
 	if (decoder == NULL) {
@@ -568,16 +566,13 @@ bt819_detect_client (struct i2c_adapter 
 	id = bt819_read(client, 0x17);
 	switch (id & 0xf0) {
 	case 0x70:
-	        snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
-			 "bt819a[%d]", client->id);
+		strlcpy(I2C_NAME(client), "bt819a", sizeof(I2C_NAME(client)));
 		break;
 	case 0x60:
-		snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
-			 "bt817a[%d]", client->id);
+		strlcpy(I2C_NAME(client), "bt817a", sizeof(I2C_NAME(client)));
 		break;
 	case 0x20:
-		snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
-			 "bt815a[%d]", client->id);
+		strlcpy(I2C_NAME(client), "bt815a", sizeof(I2C_NAME(client)));
 		break;
 	default:
 		dprintk(1,
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/saa7114.c linux_HEAD/drivers/media/video/saa7114.c
--- linux-2.6.11.6/drivers/media/video/saa7114.c	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/drivers/media/video/saa7114.c	2005-03-21 20:04:19.000000000 +0100
@@ -838,7 +838,6 @@ static struct i2c_client_address_data ad
 	.force			= force
 };
 
-static int saa7114_i2c_id = 0;
 static struct i2c_driver i2c_driver_saa7114;
 
 static int
@@ -871,9 +870,7 @@ saa7114_detect_client (struct i2c_adapte
 	client->adapter = adapter;
 	client->driver = &i2c_driver_saa7114;
 	client->flags = I2C_CLIENT_ALLOW_USE;
-	client->id = saa7114_i2c_id++;
-	snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
-		"saa7114[%d]", client->id);
+	strlcpy(I2C_NAME(client), "saa7114", sizeof(I2C_NAME(client)));
 
 	decoder = kmalloc(sizeof(struct saa7114), GFP_KERNEL);
 	if (decoder == NULL) {
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/saa7185.c linux_HEAD/drivers/media/video/saa7185.c
--- linux-2.6.11.6/drivers/media/video/saa7185.c	2005-03-26 04:28:39.000000000 +0100
+++ linux_HEAD/drivers/media/video/saa7185.c	2005-03-21 20:04:19.000000000 +0100
@@ -398,7 +398,6 @@ static struct i2c_client_address_data ad
 	.force			= force
 };
 
-static int saa7185_i2c_id = 0;
 static struct i2c_driver i2c_driver_saa7185;
 
 static int
@@ -427,9 +426,7 @@ saa7185_detect_client (struct i2c_adapte
 	client->adapter = adapter;
 	client->driver = &i2c_driver_saa7185;
 	client->flags = I2C_CLIENT_ALLOW_USE;
-	client->id = saa7185_i2c_id++;
-	snprintf(I2C_NAME(client), sizeof(I2C_NAME(client)) - 1,
-		"saa7185[%d]", client->id);
+	strlcpy(I2C_NAME(client), "saa7185", sizeof(I2C_NAME(client)));
 
 	encoder = kmalloc(sizeof(struct saa7185), GFP_KERNEL);
 	if (encoder == NULL) {
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/swarm_saa7114h.c linux_HEAD/drivers/media/video/swarm_saa7114h.c
--- linux-2.6.11.6/drivers/media/video/swarm_saa7114h.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/media/video/swarm_saa7114h.c	2005-02-25 14:59:27.000000000 +0100
@@ -0,0 +1,1691 @@
+/* 
+   saa7114h - Philips SAA7114H video decoder driver
+
+   Copyright (C) 2001,2002,2003 Broadcom Corporation
+
+   From saa7111.c:
+     Copyright (C) 1998 Dave Perks <dperks@ibm.net>
+   From cpia.c:
+     (C) Copyright 1999-2000 Peter Pregler
+     (C) Copyright 1999-2000 Scott J. Bertin
+     (C) Copyright 1999-2000 Johannes Erdfelt <johannes@erdfelt.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Important note: this driver is reasonably functional, and has been
+ * tested with the "camserv" v4l application.  But it primarily a
+ * proof-of-concept, and example for setting up FIFO-mode.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/ctype.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/pci.h>
+#include <linux/signal.h>
+#include <linux/proc_fs.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/sched.h>
+#include <asm/segment.h>
+#include <linux/types.h>
+#include <linux/wrapper.h>
+#include <linux/smp_lock.h>
+#include <asm/hardirq.h>
+
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c-algo-sibyte.h>
+
+#include <asm/sibyte/sb1250_regs.h>
+#include <asm/sibyte/sb1250_int.h>
+#include <asm/sibyte/sb1250_mac.h>
+#include <asm/sibyte/sb1250_dma.h>
+
+#define SAA_BRIGHTNESS	 0x0a
+#define SAA_CONTRAST	 0x0b
+#define SAA_SATURATION	 0x0c
+#define SAA_HUE		 0x0d
+
+#define DECODER_STATUS	 0x1f
+#define SLICER_STATUS_0	 0x60
+#define SLICER_STATUS_1	 0x61
+#define SLICER_STATUS_2	 0x62
+#define SCALER_STATUS	 0x8f
+
+#define NUM_FRAME	 2
+#define MAX_HORIZ	 720
+#define MAX_VERT	 480
+#define MIN_HORIZ	 180
+#define MIN_VERT	 120
+#define MAX_PER_PIXEL	 3
+#define MAX_FRAME_SIZE	 (MAX_HORIZ*MAX_VERT*MAX_PER_PIXEL)
+#define MAX_MMAP_SIZE	 (PAGE_ALIGN(MAX_FRAME_SIZE*NUM_FRAME))
+#define RAW_PER_PIXEL	 2
+#define RAW_LINE_PAD	 8
+#define RAW_LINE_SIZE	 (((MAX_HORIZ*RAW_PER_PIXEL)+RAW_LINE_PAD+0x1f) & ~0x1f)
+#define RAW_FRAME_SIZE	 (RAW_LINE_SIZE*MAX_VERT)
+
+#define NUM_DESCR	 64
+#define INTR_PKT_CNT	 8
+
+/* Extensions to videodev.h IOCTL definitions */
+#define VIDIOREADREG	_IOR('v', 50, int)
+#define VIDIOWRITEREG	_IOW('v', 50, int)
+#define VIDIOGRABFRAME	_IOR('v', 51, int)
+#define VIDIOSHOWEAV	_IOR('v', 52, int)
+
+#define IF_NAME "saa7114h"
+
+#define MAC2_CSR(r)	   (KSEG1 + A_MAC_REGISTER(2, r))
+#define MAC2_DMARX0_CSR(r) (KSEG1 + A_MAC_DMA_REGISTER(2, DMA_RX, 0, r))
+
+/* Options */
+#define DMA_DEINTERLACE	 1
+#define LAZY_READ	 1
+#define NULL_DMA	 0
+
+/* Debug filters */
+#define DBG_NULL	 0x0000
+#define DBG_IO		 0x0001
+#define DBG_DESCR	 0x0002
+#define DBG_INTR	 0x0004
+#define DBG_CONVERT	 0x0008
+#define DBG_FRAMING	 0x0010
+#define DBG_REGISTER	 0x0020
+#define DBG_CALL	 0x0040
+#define DBG_FRAMING_LOUD 0x0080
+
+/* XXXKW make this settable through /proc... */
+#define DEBUG_LVL	 (DBG_NULL)
+
+#if DEBUG_LVL
+#define DBG(l, p) do { if (DEBUG_LVL & l) p; } while (0)
+#else
+#define DBG(l, p)
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+enum {
+	FRAME_READY,		/* Ready to grab into */
+	FRAME_GRABBING,		/* In the process of being grabbed into */
+	FRAME_DONE,		/* Finished grabbing, but not been synced yet */
+	FRAME_UNUSED,		/* Unused (belongs to driver, but can't be used) */
+};
+
+struct saa_frame {
+	uint8_t		 *data;
+	uint8_t		 *pos;
+	int		  width;
+	int		  height;
+	uint32_t	  size;
+	volatile int	  state;
+	wait_queue_head_t read_wait;
+};
+
+typedef struct fifo_descr_s {
+	uint64_t descr_a;
+	uint64_t descr_b;
+} fifo_descr_t;
+
+typedef unsigned long paddr_t;
+
+typedef struct fifo_s {
+	unsigned	 ringsz;
+	fifo_descr_t	*descrtab;
+	fifo_descr_t	*descrtab_end;
+	fifo_descr_t	*next_descr;
+	paddr_t		 descrtab_phys;
+	void		*dma_buf;	    /* DMA buffer */
+} fifo_t;
+
+struct saa7114h {
+	struct i2c_client    *client;
+	struct video_device  *vd;
+	struct video_window   vw;
+	struct video_picture  vp;
+	uint8_t		      reg[256];
+
+	fifo_t		 ff;
+	void		*frame_buf; /* hold frames for the client */
+	struct saa_frame frame[NUM_FRAME]; /* point into frame_buf */
+	int		 hwframe;
+	int		 swframe;
+
+	uint16_t depth;
+	uint16_t palette;
+	uint8_t	 bright;
+	uint8_t	 contrast;
+	uint8_t	 hue;
+	uint8_t	 sat;
+
+	struct proc_dir_entry *proc_entry;
+	struct semaphore       param_lock;
+	struct semaphore       busy_lock;
+
+	int	dma_enable;
+	int	opened;
+	int	irq;
+	int	interlaced;
+};
+
+static int saa7114h_probe(struct i2c_adapter *adap);
+static int saa7114h_detach(struct i2c_client *device);
+
+struct i2c_driver i2c_driver_saa7114h =
+{
+	name:		"saa7114h",		/* name */
+	id:		I2C_DRIVERID_SAA7114H,	/* ID */
+	flags:		I2C_DF_NOTIFY,		/* XXXKW do I care? */
+	attach_adapter: saa7114h_probe,
+	detach_client:	saa7114h_detach
+};
+
+/* -----------------------------------------------------------------------
+ * VM assist for MMAPed space
+ * ----------------------------------------------------------------------- */
+
+/* Given PGD from the address space's page table, return the kernel
+ * virtual mapping of the physical memory mapped at ADR.
+ */
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
+{
+	unsigned long ret = 0UL;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+	if (!pgd_none(*pgd)) {
+		pmd = pmd_offset(pgd, adr);
+		if (!pmd_none(*pmd)) {
+			ptep = pte_offset(pmd, adr);
+			pte = *ptep;
+			if (pte_present(pte)) {
+				ret = (unsigned long) page_address(pte_page(pte));
+				ret |= (adr & (PAGE_SIZE-1));
+			}
+		}
+	}
+	return ret;
+}
+
+/* Here we want the physical address of the memory.
+ * This is used when initializing the contents of the
+ * area and marking the pages as reserved.
+ */
+static inline unsigned long kvirt_to_pa(unsigned long adr)
+{
+	unsigned long va, kva, ret;
+
+	va = VMALLOC_VMADDR(adr);
+	kva = uvirt_to_kva(pgd_offset_k(va), va);
+	ret = __pa(kva);
+	return ret;
+}
+
+static void *rvmalloc(unsigned long size)
+{
+	void *mem;
+	unsigned long adr, page;
+
+	/* Round it off to PAGE_SIZE */
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+
+	mem = vmalloc_32(size);
+	if (!mem)
+		return NULL;
+
+	memset(mem, 0, size); /* Clear the ram out, no junk to the user */
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_reserve(virt_to_page(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return mem;
+}
+
+static void rvfree(void *mem, unsigned long size)
+{
+	unsigned long adr, page;
+
+	if (!mem)
+		return;
+
+	size += (PAGE_SIZE - 1);
+	size &= ~(PAGE_SIZE - 1);
+
+	adr = (unsigned long) mem;
+	while (size > 0) {
+		page = kvirt_to_pa(adr);
+		mem_map_unreserve(virt_to_page(__va(page)));
+		adr += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+	vfree(mem);
+}
+
+/* -----------------------------------------------------------------------
+ * Control interface (i2c)
+ * ----------------------------------------------------------------------- */
+
+static int saa7114h_reg_read(struct saa7114h *dev, unsigned char subaddr)
+{
+	return i2c_smbus_read_byte_data(dev->client, subaddr);
+}
+
+static int saa7114h_reg_write(struct saa7114h *dev, unsigned char subaddr, int data)
+{
+	return i2c_smbus_write_byte_data(dev->client, subaddr, data & 0xff);
+}
+
+static int saa7114h_reg_init(struct saa7114h *dev, unsigned const char *data, unsigned int len)
+{
+	int rc = 0;
+	int val;
+
+	while (len && !rc) {
+		dev->reg[data[0]] = data[1];
+		rc = saa7114h_reg_write(dev, data[0], data[1]);
+		if (!rc && (data[0] != 0)) {
+			val = saa7114h_reg_read(dev, data[0]);
+			if ((val < 0) || (val != data[1])) {
+				printk(KERN_ERR
+				       IF_NAME ": init readback mismatch reg %02x = %02x (should be %02x)\n",
+				       data[0], val, data[1]);
+			}
+		}
+		len -= 2;
+		data += 2;
+	}
+	return rc;
+}
+
+/* -----------------------------------------------------------------------
+ * /proc interface
+ * ----------------------------------------------------------------------- */
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *saa7114h_proc_root=NULL;
+
+static int decoder_read_proc(char *page, char **start, off_t off,
+			     int count, int *eof, void *data)
+{
+	char *out = page;
+	int len, status;
+	struct saa7114h *decoder = data;
+
+	out += sprintf(out, "  SWARM saa7114h\n------------------\n");
+	status = saa7114h_reg_read(decoder, DECODER_STATUS);
+	out += sprintf(out, "  Decoder status = %02x\n", status);
+	if (status & 0x80)
+		out += sprintf(out, "	 interlaced\n");
+	if (status & 0x40)
+		out += sprintf(out, "	 not locked\n");
+	if (status & 0x02)
+		out += sprintf(out, "	 Macrovision detected\n");
+	if (status & 0x01)
+		out += sprintf(out, "	 color\n");
+	out += sprintf(out, "  Brightness = %02x\n", decoder->bright);
+	out += sprintf(out, "  Contrast	  = %02x\n", decoder->contrast);
+	out += sprintf(out, "  Saturation = %02x\n", decoder->sat);
+	out += sprintf(out, "  Hue	  = %02x\n\n", decoder->hue);
+
+	out += sprintf(out, "  Scaler status  = %02x\n", 
+		       (int)saa7114h_reg_read(decoder, SCALER_STATUS));
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0) return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+	return len;
+}
+
+static int decoder_write_proc(struct file *file, const char *buffer,
+			       unsigned long count, void *data)
+{
+	struct saa7114h *d = data;
+	int retval;
+	unsigned int cmd, reg, reg_val;
+	
+	if (down_interruptible(&d->param_lock))
+		return -ERESTARTSYS;
+
+#define VALUE \
+	({ \
+		char *_p; \
+		unsigned long int _ret; \
+		while (count && isspace(*buffer)) { \
+			buffer++; \
+			count--; \
+		} \
+		_ret = simple_strtoul(buffer, &_p, 16); \
+		if (_p == buffer) \
+			retval = -EINVAL; \
+		else { \
+			count -= _p - buffer; \
+			buffer = _p; \
+		} \
+		_ret; \
+	})
+	
+	retval = 0;
+	while (count && !retval) {
+		cmd = VALUE;
+		if (retval)
+			break;
+		switch (cmd) {
+		case 1:
+			reg = VALUE;
+			if (retval)
+				break;
+			reg_val = VALUE;
+			if (retval)
+				break;
+			printk(IF_NAME ": write reg %x <- %x\n", reg, reg_val);
+			if (saa7114h_reg_write(d, reg, reg_val) == -1)
+				retval = -EINVAL;
+			break;
+		case 2:
+			reg = VALUE;
+			if (retval)
+				break;
+			reg_val = saa7114h_reg_read(d, reg);
+			if (reg_val == -1)
+				retval = -EINVAL;
+			else
+				printk(IF_NAME ": read reg %x -> %x\n", reg, reg_val);
+			break;
+		default:
+			break;
+		}
+	}
+	up(&d->param_lock);
+	
+	return retval;
+}
+
+static void create_proc_decoder(struct saa7114h *decoder)
+{
+	char name[8];
+	struct proc_dir_entry *ent;
+	
+	if (!saa7114h_proc_root || !decoder)
+		return;
+
+	sprintf(name, "video%d", decoder->vd->minor);
+	
+	ent = create_proc_entry(name, S_IFREG|S_IRUGO|S_IWUSR, saa7114h_proc_root);
+	if (!ent) {
+		printk(KERN_INFO IF_NAME ": Unable to initialize /proc/saa7114h/%s\n", name);
+		return;
+	}
+
+	ent->data = decoder;
+	ent->read_proc = decoder_read_proc;
+	ent->write_proc = decoder_write_proc;
+	ent->size = 3626;	/* XXXKW ??? */
+	decoder->proc_entry = ent;
+}
+
+static void destroy_proc_decoder(struct saa7114h *decoder)
+{
+	char name[7];
+	
+	if (!decoder || !decoder->proc_entry)
+		return;
+	
+	sprintf(name, "video%d", decoder->vd->minor);
+	remove_proc_entry(name, saa7114h_proc_root);
+	decoder->proc_entry = NULL;
+}
+
+static void proc_saa7114h_create(void)
+{
+	saa7114h_proc_root = create_proc_entry("saa7114h", S_IFDIR, 0);
+
+	if (saa7114h_proc_root)
+		saa7114h_proc_root->owner = THIS_MODULE;
+	else
+		printk(KERN_INFO IF_NAME ": Unable to initialize /proc/saa7114h\n");
+}
+
+static void proc_saa7114h_destroy(void)
+{
+	remove_proc_entry("saa7114h", 0);
+}
+#endif /* CONFIG_PROC_FS */
+
+
+/* -----------------------------------------------------------------------
+ * Initialization
+ * ----------------------------------------------------------------------- */
+
+static int dma_setup(struct saa7114h *d)
+{
+	int i;
+	void *curbuf;
+
+	/* Reset the port */
+	__raw_writeq(M_MAC_PORT_RESET, MAC2_CSR(R_MAC_ENABLE));
+	__raw_readq(MAC2_CSR(R_MAC_ENABLE));
+
+	/* Zero everything out, disable filters */
+	__raw_writeq(0, MAC2_CSR(R_MAC_TXD_CTL));
+	__raw_writeq(M_MAC_ALLPKT_EN, MAC2_CSR(R_MAC_ADFILTER_CFG));
+	__raw_writeq(V_MAC_RX_RD_THRSH(4) | V_MAC_RX_RL_THRSH(4),
+	      MAC2_CSR(R_MAC_THRSH_CFG));
+	for (i=0; i<MAC_CHMAP_COUNT; i++) {
+		__raw_writeq(0, MAC2_CSR(R_MAC_CHLO0_BASE+(i*8)));
+		__raw_writeq(0, MAC2_CSR(R_MAC_CHUP0_BASE+(i*8)));
+	}
+	for (i=0; i<MAC_HASH_COUNT; i++) {
+		__raw_writeq(0, MAC2_CSR(R_MAC_HASH_BASE+(i*8)));
+	}
+	for (i=0; i<MAC_ADDR_COUNT; i++) {
+		__raw_writeq(0, MAC2_CSR(R_MAC_ADDR_BASE+(i*8)));
+	}	 
+	
+	__raw_writeq(V_MAC_MAX_FRAMESZ(16*1024) | V_MAC_MIN_FRAMESZ(0),
+	      MAC2_CSR(R_MAC_FRAMECFG));
+
+	/* Select bypass mode */
+	__raw_writeq((M_MAC_BYPASS_SEL | V_MAC_BYPASS_CFG(K_MAC_BYPASS_EOP) | 
+	       M_MAC_FC_SEL | M_MAC_SS_EN | V_MAC_SPEED_SEL_1000MBPS),
+	      MAC2_CSR(R_MAC_CFG));
+
+	/* Set up the descriptor table */
+	d->ff.descrtab = kmalloc(NUM_DESCR * sizeof(fifo_descr_t), GFP_KERNEL);
+	d->ff.descrtab_phys = __pa(d->ff.descrtab);
+	d->ff.descrtab_end = d->ff.descrtab + NUM_DESCR;
+	d->ff.next_descr = d->ff.descrtab;
+	d->ff.ringsz = NUM_DESCR;
+#if 0
+	/* XXXKW this won't work because the physical may not be
+	   contiguous; how do I handle a bigger alloc then? */
+	d->ff.dma_buf = rvmalloc(RAW_LINE_SIZE*NUM_DESCR);
+	printk(KERN_DEBUG IF_NAME ": DMA buffer allocated (%p)\n",
+	       d->ff.dma_buf);
+#else
+	d->ff.dma_buf = kmalloc(RAW_LINE_SIZE*NUM_DESCR, GFP_KERNEL);
+#endif
+	if (!d->ff.dma_buf) {
+		printk(KERN_ERR IF_NAME ": couldn't allocate DMA buffer\n");
+		return -ENOMEM;
+	}
+	memset(d->ff.dma_buf, 0, RAW_LINE_SIZE*NUM_DESCR);
+
+	for (i=0, curbuf=d->ff.dma_buf; i<d->ff.ringsz; i++, curbuf+=RAW_LINE_SIZE) {
+		d->ff.descrtab[i].descr_a = (__pa(curbuf) |
+					     V_DMA_DSCRA_A_SIZE(RAW_LINE_SIZE >> 5));
+		d->ff.descrtab[i].descr_b = 0;
+	}
+
+	__raw_writeq(V_DMA_INT_PKTCNT(INTR_PKT_CNT) | M_DMA_EOP_INT_EN |
+	      V_DMA_RINGSZ(d->ff.ringsz) | M_DMA_TDX_EN,
+	      MAC2_DMARX0_CSR(R_MAC_DMA_CONFIG0));
+	__raw_writeq(M_DMA_L2CA, MAC2_DMARX0_CSR(R_MAC_DMA_CONFIG1));
+	__raw_writeq(d->ff.descrtab_phys, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_BASE));
+
+	/* Enable interrupts and DMA */
+	__raw_writeq(M_MAC_INT_EOP_COUNT<<S_MAC_RX_CH0, MAC2_CSR(R_MAC_INT_MASK));
+	__raw_writeq(M_MAC_RXDMA_EN0 | M_MAC_BYP_RX_ENABLE, MAC2_CSR(R_MAC_ENABLE));
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------
+ * v4linux helpers - color conversion, etc  (taken from cpia.c)
+ * ----------------------------------------------------------------------- */
+
+#define LIMIT(x) ((((x)>0xffffff)?0xff0000:(((x)<=0xffff)?0:(x)&0xff0000))>>16)
+
+static void yuvconvert_inplace(uint8_t *data, uint32_t in_uyvy, int out_fmt, int mmap)
+{
+	int y, u, v, r, g, b, y1;
+	uint8_t *src, *dst;
+
+	if (out_fmt == VIDEO_PALETTE_RGB24) {
+		src = (uint8_t *)((int)data + in_uyvy);
+		dst = (uint8_t *)((int)data + in_uyvy + (in_uyvy >> 1));
+		DBG(DBG_CONVERT, printk(KERN_DEBUG "inplace: %p %p %p\n", data, src, dst));
+		while (src > data) {
+			if ((int)(src-data) < 4)
+				break;
+				//printk("freaky %p %p\n", src, data);
+			y1 = (*(--src) - 16) * 76310;
+			v = *(--src) - 128;
+			y = (*(--src) - 16) * 76310;
+			u = *(--src) - 128;
+			r = 104635 * v;
+			g = -25690 * u + -53294 * v;
+			b = 132278 * u;
+			/* XXXKW what on earth is up with mmap? */
+			if (mmap) {
+				*(--dst) = LIMIT(r+y1);
+				*(--dst) = LIMIT(g+y1);
+				*(--dst) = LIMIT(b+y1);
+				*(--dst) = LIMIT(r+y);
+				*(--dst) = LIMIT(g+y);
+				*(--dst) = LIMIT(b+y);
+			} else {
+				*(--dst) = LIMIT(b+y1);
+				*(--dst) = LIMIT(g+y1);
+				*(--dst) = LIMIT(r+y1);
+				*(--dst) = LIMIT(b+y);
+				*(--dst) = LIMIT(g+y);
+				*(--dst) = LIMIT(r+y);
+			}
+		}
+	}
+}
+
+static int saa7114h_get_cparams(struct saa7114h *decoder)
+{
+	/* XXX check for error code */
+	decoder->bright	    = saa7114h_reg_read(decoder, SAA_BRIGHTNESS);
+	decoder->contrast   = saa7114h_reg_read(decoder, SAA_CONTRAST);
+	decoder->sat	    = saa7114h_reg_read(decoder, SAA_SATURATION);
+	decoder->hue	    = saa7114h_reg_read(decoder, SAA_HUE);
+
+	decoder->vp.brightness = (uint16_t)decoder->bright << 8;
+	decoder->vp.contrast   = (uint16_t)decoder->contrast << 9;
+	decoder->vp.colour     = decoder->sat << 9;
+	decoder->vp.hue	       = ((int16_t)decoder->hue + 128) << 8;
+	return 0;
+}
+
+static int saa7114h_set_cparams(struct saa7114h *decoder)
+{
+	decoder->bright	  = decoder->vp.brightness >> 8;
+	decoder->contrast = decoder->vp.contrast >> 9;
+	decoder->sat	  = decoder->vp.colour >> 9;
+	decoder->hue	  = (uint8_t)((int8_t)(decoder->vp.hue >> 8) - 128);
+
+	return (saa7114h_reg_write(decoder, SAA_BRIGHTNESS, decoder->bright) ||
+		saa7114h_reg_write(decoder, SAA_CONTRAST, decoder->contrast) ||
+		saa7114h_reg_write(decoder, SAA_SATURATION, decoder->sat) ||
+		saa7114h_reg_write(decoder, SAA_HUE, decoder->hue));
+}
+
+/* -----------------------------------------------------------------------
+ * Custom IOCTL support
+ * ----------------------------------------------------------------------- */
+
+unsigned char eav[625][2];
+static int grab_frame(struct saa7114h *d, void *user_buf, int print_eav)
+{
+	int cur_idx = 0;
+	int to_go = 625;
+	int delta;
+	int i, len, eav_val, sav_val;
+	int started = 0;
+	uint8_t *buf;
+	fifo_descr_t *cur_d;
+	int swptr = d->ff.next_descr - d->ff.descrtab;
+	int hwptr;
+
+	DBG(DBG_CALL, printk(IF_NAME ": grabbing frame\n"));
+
+	/* Check for Macrovision -- if it's on, DMA won't happen */
+	if (saa7114h_reg_read(d, DECODER_STATUS) & 0x2)
+		return -EACCES;
+
+	__raw_writeq(d->ff.ringsz, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	do {
+		hwptr = (unsigned) (((__raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_CUR_DSCRADDR)) &
+				      M_DMA_CURDSCR_ADDR) -
+				     d->ff.descrtab_phys) /
+				    sizeof(fifo_descr_t));
+		delta = (hwptr + d->ff.ringsz - swptr) % d->ff.ringsz;
+		
+		if (delta == 0) {
+#if 0
+			uint64_t val = __raw_readq(MAC2_DMARX0_CSR(R_MAC_STATUS));
+			printk("mac status: %08x%08x\n",
+			       (u32)(val >> 32), (u32)(val&0xffffffff));
+#endif
+		}
+
+		for (i=0; i<delta; i++) {
+			cur_d = d->ff.next_descr;
+			if (++d->ff.next_descr == d->ff.descrtab_end)
+				d->ff.next_descr = d->ff.descrtab;
+			
+			if (!(cur_d->descr_a & M_DMA_ETHRX_SOP)) {
+				printk("bogus RX\n");
+				continue;
+			}
+			cur_d->descr_a &= ~M_DMA_ETHRX_SOP;
+			len = G_DMA_DSCRB_PKT_SIZE(cur_d->descr_b);
+			buf = (uint8_t *)__va(cur_d->descr_a & M_DMA_DSCRA_A_ADDR);
+			if (len != (d->vw.width*RAW_PER_PIXEL)+RAW_LINE_PAD) {
+				printk("funny size %d\n", len);
+				continue;
+			}
+			eav_val = buf[1];
+			sav_val = buf[5];
+			if (eav_val == 0xf1) { /* end of field 2, V-blank */
+				if (started) {
+					started = 0;
+					delta = to_go = 0;
+					/* just let DMA finish in background */
+				} else {
+					started = 1;
+				}
+			}
+			if (started) {
+				eav[cur_idx][0] = eav_val;
+				eav[cur_idx++][1] = sav_val;
+				if (copy_to_user(user_buf, &buf[6], 1440))
+					return -EFAULT;
+				user_buf += 1440;
+			}
+		}
+		swptr = hwptr;
+		if (delta) {
+			if (started)
+				to_go -= delta;
+			if (delta > to_go)
+				delta = to_go;
+			__raw_writeq(delta, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		}
+	} while (to_go);
+
+	if (print_eav) {
+		for (i=0; i<cur_idx; i++) {
+			printk("%3d: %02x | %02x\n", i, eav[i][0], eav[i][1]);
+		}
+	}
+
+	return cur_idx;
+}
+
+/* -----------------------------------------------------------------------
+ * Interrupt handler
+ * ----------------------------------------------------------------------- */
+
+unsigned long int_count = 0;
+
+static void saa7114h_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct saa7114h *d = dev_id;
+	uint64_t status_val;
+	fifo_descr_t *cur_d;
+	int i, delta, len;
+	uint8_t *buf, eav_val;
+	int swptr = d->ff.next_descr - d->ff.descrtab;
+	int hwptr;
+
+	status_val = __raw_readq(MAC2_CSR(R_MAC_STATUS));
+
+	/* Process finished decsriptors */
+	hwptr = (unsigned) (((__raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_CUR_DSCRADDR)) &
+			      M_DMA_CURDSCR_ADDR) - d->ff.descrtab_phys) /
+			    sizeof(fifo_descr_t));
+	delta = (hwptr + d->ff.ringsz - swptr) % d->ff.ringsz;
+	if (!delta) {
+		if (status_val & M_MAC_INT_EOP_SEEN<<S_MAC_RX_CH0) {
+			/* Must have wrapped since the last interrupt */
+			delta = d->ff.ringsz;
+		} else {
+			/* XXXKW why would this happen? */
+			return;
+		}
+	}
+
+	for (i=0; i<delta; i++) {
+		cur_d = d->ff.next_descr;
+		if (++d->ff.next_descr == d->ff.descrtab_end)
+			d->ff.next_descr = d->ff.descrtab;
+		
+		if (!(cur_d->descr_a & M_DMA_ETHRX_SOP)) {
+			printk(KERN_DEBUG "bogus RX\n");
+			continue;
+		}
+		cur_d->descr_a &= ~M_DMA_ETHRX_SOP;
+		if (!d->dma_enable)
+			continue;
+		
+		len = G_DMA_DSCRB_PKT_SIZE(cur_d->descr_b);
+		buf = (uint8_t *)__va(cur_d->descr_a & M_DMA_DSCRA_A_ADDR);
+		if (len != (d->vw.width*RAW_PER_PIXEL)+RAW_LINE_PAD) {
+			printk(KERN_DEBUG "funny size %d\n", len);
+//				  continue;
+		}
+		len -= RAW_LINE_PAD;
+		eav_val = buf[1];
+		DBG(DBG_FRAMING_LOUD,
+		    printk(KERN_DEBUG "eav: %02x len: %d\n", eav_val, len));
+		if (eav_val == 0xf1) { /* end of field 2, V-blank: start-of-frame */
+			switch (d->frame[d->hwframe].state) {
+			case FRAME_UNUSED:
+				DBG(DBG_FRAMING,
+				    printk(KERN_ERR "capture to unused frame %d\n", 
+					   d->hwframe));
+				break;
+			case FRAME_READY:
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame started %d\n",
+					   d->hwframe));
+				/* start this frame (skip eav/sav) */
+				memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+#if DMA_DEINTERLACE
+				if (!d->interlaced)
+					memcpy(d->frame[d->hwframe].pos-len, &buf[6], len);
+				d->frame[d->hwframe].pos += len*2;
+#else
+				d->frame[d->hwframe].pos += len;
+#endif
+				d->frame[d->hwframe].state = FRAME_GRABBING;
+				/* XXXKW check pos overflow */
+				break;
+			case FRAME_GRABBING:
+				/* kick over to new frame */
+				d->frame[d->hwframe].size = d->frame[d->hwframe].pos -
+					d->frame[d->hwframe].data;
+				d->frame[d->hwframe].state = FRAME_DONE;
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame finished %d\n",
+					   d->frame[d->hwframe].size));
+				/* wake up a waiting reader */
+				DBG(DBG_IO, printk(KERN_DEBUG "wakeup\n"));
+				wake_up(&d->frame[d->hwframe].read_wait);
+				d->hwframe = (d->hwframe + 1) % NUM_FRAME;
+				if (d->frame[d->hwframe].state == FRAME_READY) {
+					/* start this frame */
+					DBG(DBG_FRAMING,
+					    printk(KERN_DEBUG "frame bumped %d\n",
+						   d->hwframe));
+					memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+#if DMA_DEINTERLACE
+					if (!d->interlaced)
+						memcpy(d->frame[d->hwframe].pos-len, &buf[6], len);
+					d->frame[d->hwframe].pos += len*2;
+#else
+					d->frame[d->hwframe].pos += len;
+#endif
+					d->frame[d->hwframe].state = FRAME_GRABBING;
+				} else {
+					/* drop on the floor,
+					   note that we've stopped DMA'ing */
+					DBG(DBG_FRAMING,
+					    printk(KERN_DEBUG "frame capture halted\n"));
+					d->dma_enable = 0;
+				}
+				break;
+			case FRAME_DONE:
+				/* drop on the floor (must be waiting for sw) */
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame capture halted\n"));
+				d->dma_enable = 0;
+				break;
+			}
+		} else {
+			switch (d->frame[d->hwframe].state) {
+			case FRAME_UNUSED:
+				DBG(DBG_FRAMING,
+				    printk(KERN_ERR "capture to unused frame %d\n",
+					   d->hwframe));
+				break;
+			case FRAME_READY:
+				/* drop on the floor (must have dropped something) */
+				DBG(DBG_FRAMING_LOUD,
+				    printk(KERN_DEBUG "missed SOF\n"));
+				break;
+			case FRAME_DONE:
+				/* drop on the floor (must be waiting for sw) */
+				DBG(DBG_FRAMING,
+				    printk(KERN_DEBUG "frame overflow\n"));
+				d->dma_enable = 0;
+				break;
+			case FRAME_GRABBING:
+#if DMA_DEINTERLACE
+				if (eav_val == 0xb6) {
+					d->frame[d->hwframe].pos = d->frame[d->hwframe].data;
+				}
+				memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+				if (!d->interlaced)
+					memcpy(d->frame[d->hwframe].pos-len, &buf[6], len);
+				d->frame[d->hwframe].pos += len*2;
+#else
+				memcpy(d->frame[d->hwframe].pos, &buf[6], len);
+				d->frame[d->hwframe].pos += len;
+#endif
+				/* XXXKW check pos overflow */
+				break;
+			}
+		}
+	}
+	
+	if (d->dma_enable) {
+		__raw_writeq(delta, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		DBG(DBG_DESCR,
+		    printk(KERN_DEBUG IF_NAME ": interrupt adds %d -> %d descrs\n",
+			   delta, (int)__raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT))));
+	}
+}
+
+/* -----------------------------------------------------------------------
+ * /dev/video interface
+ * ----------------------------------------------------------------------- */
+
+static int saa7114h_open(struct video_device *vd, int nb)
+{
+	struct saa7114h *d = vd->priv;
+	uint32_t status;
+
+	if (!d || d->opened)
+		return -EBUSY;
+
+	d->opened = 1;
+	DBG(DBG_CALL, printk(KERN_DEBUG IF_NAME ": open\n"));
+
+	/* XXKW Should check this periodically!? */
+	status = saa7114h_reg_read(d, DECODER_STATUS);
+	d->interlaced = ((status & 0x80) != 0);
+
+#if !NULL_DMA
+	if (d->dma_enable) {
+		printk(IF_NAME ": open found DMA on?!\n");
+#if LAZY_READ
+	}
+#else
+	} else {
+		int descr;
+		d->dma_enable = 1;
+		DBG(DBG_DESCR, printk(IF_NAME ": open enabling DMA\n"));
+		/* Force capture to start into frame buffer 0 */
+		descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		DBG(DBG_DESCR,
+		    printk(IF_NAME ": open adds %d -> %d descrs\n",
+			   d->ff.ringsz-desc, descr));
+		__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	}
+#endif
+#endif
+
+	return 0;
+}
+
+static void saa7114h_release(struct video_device *vd)
+{
+	struct saa7114h *d = vd->priv;
+
+	DBG(DBG_CALL, printk(KERN_DEBUG IF_NAME ": release\n"));
+	d->opened = 0;
+	d->dma_enable = 0;
+
+	/* XXXKW do a clean drain of outstanding DMAs? toss leftover
+	   buffer contents to avoid stale pictures? */
+
+	return;
+}
+
+static long saa7114h_read(struct video_device *vd, char *buf,
+			  unsigned long count, int noblock)
+{
+	struct saa7114h *d = vd->priv;
+	int descr, status;
+
+	if (!d)
+		return -ENODEV;
+
+	/* XXKW Should check this periodically!? */
+	status = saa7114h_reg_read(d, DECODER_STATUS);
+//	  d->interlaced = ((status & 0x80) != 0);
+	
+#if !NULL_DMA
+#if LAZY_READ
+	if (!d->dma_enable) {
+		DBG(DBG_DESCR, printk(KERN_DEBUG IF_NAME ": enabling DMA\n"));
+		/* Give the buffer to the DMA engine (force ptr reset) */
+		d->swframe = d->hwframe;
+		d->frame[d->swframe].state = FRAME_READY;
+#if DMA_DEINTERLACE
+		d->frame[d->swframe].pos = d->frame[d->swframe].data+d->vw.width*RAW_PER_PIXEL;
+#else
+		d->frame[d->swframe].pos = d->frame[d->swframe].data;
+#endif
+		/* Fire up the DMA engine again if it stopped */
+		d->dma_enable = 1;
+		descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	}
+#endif
+#endif
+
+	/* XXXKW mmap/read mixture could break the swframe sequence */
+
+	if (d->frame[d->swframe].state != FRAME_DONE) {
+		if (noblock)
+			return -EAGAIN;
+		else {
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": sleeping for frame\n"));
+			interruptible_sleep_on(&d->frame[d->swframe].read_wait);
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": awakened\n"));
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+		}
+	}
+
+	if (count < d->frame[d->swframe].size)
+		return -EFAULT;
+
+	count = d->frame[d->swframe].size;
+	yuvconvert_inplace(d->frame[d->swframe].data, d->frame[d->swframe].size, d->vp.palette, 0);
+	copy_to_user(buf, d->frame[d->swframe].data, d->frame[d->swframe].size);
+	d->swframe = (d->swframe + 1) % NUM_FRAME;
+	/* XXXKW doesn't do format conversion!!! */
+#if !NULL_DMA
+#if !LAZY_READ
+	/* XXXKW Fire up the DMA engine again if it stopped ??? */
+	if (!d->dma_enable) {
+		DBG(DBG_DESCR, printk(KERN_DEBUG IF_NAME ": enabling DMA\n"));
+		/* Fire up the DMA engine again if it stopped */
+		d->dma_enable = 1;
+		descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+	}
+#endif
+#endif
+
+	return count;
+}
+
+static int saa7114h_ioctl(struct video_device *vd, unsigned int cmd, void *arg)
+{
+	struct saa7114h *d = vd->priv;
+	int val, reg, retval = 0;
+
+	if (!d)
+		return -ENODEV;
+
+	switch (cmd) {
+	case VIDIOCGCHAN:
+	{
+		struct video_channel v;
+
+		if (copy_from_user(&v, arg, sizeof(v))) {
+			retval = -EFAULT;
+			break;
+		}
+		if (v.channel != 0) {
+			retval = -EINVAL;
+			break;
+		}
+
+		v.channel = 0;
+		strcpy(v.name, "Camera");
+		v.tuners = 0;
+		v.flags = 0;
+		v.type = VIDEO_TYPE_CAMERA;
+		v.norm = 0;
+
+		if (copy_to_user(arg, &v, sizeof(v)))
+			retval = -EFAULT;
+		break;
+	}
+	
+	case VIDIOCSCHAN:
+	{
+		int v;
+
+		if (copy_from_user(&v, arg, sizeof(v)))
+			retval = -EFAULT;
+
+		if (retval == 0 && v != 0)
+			retval = -EINVAL;
+
+		break;
+	}
+
+	case VIDIOCGCAP:
+	{
+		struct video_capability b;
+
+		strcpy(b.name, "Philips SAA7114H Decoder");
+		b.type = VID_TYPE_CAPTURE /* | VID_TYPE_TELETEXT */ | VID_TYPE_SCALES;
+		b.channels = 1;
+		b.audios = 0;
+		b.maxwidth = MAX_HORIZ;
+		b.maxheight = MAX_VERT;
+		/* XXXKW find real values */
+		b.minwidth = 48;
+		b.minheight = 48;
+
+		if (copy_to_user(arg, &b, sizeof(b)))
+			retval = -EFAULT;
+
+		break;
+	}
+
+	/* image properties */
+	case VIDIOCGPICT:
+		if (copy_to_user(arg, &d->vp, sizeof(struct video_picture)))
+			retval = -EFAULT;
+		break;
+		
+	case VIDIOCSPICT:
+	{
+		struct video_picture vp;
+
+		/* copy_from_user */
+		if (copy_from_user(&vp, arg, sizeof(vp))) {
+			retval = -EFAULT;
+			break;
+		}
+
+		down(&d->param_lock);
+		/* brightness, colour, contrast need not check 0-65535 */
+		memcpy( &d->vp, &vp, sizeof(vp) );
+		/* update cam->params.colourParams */
+		saa7114h_set_cparams(d);
+		up(&d->param_lock);
+		break;
+	}
+
+	/* get/set capture window */
+	case VIDIOCGWIN:
+		if (copy_to_user(arg, &d->vw, sizeof(struct video_window)))
+			retval = -EFAULT;
+		break;
+	
+	case VIDIOCSWIN:
+	{
+		/* copy_from_user, check validity, copy to internal structure */
+		struct video_window vw;
+		if (copy_from_user(&vw, arg, sizeof(vw))) {
+			retval = -EFAULT;
+			break;
+		}
+
+		if (vw.clipcount != 0) {    /* clipping not supported */
+			retval = -EINVAL;
+			break;
+		}
+		if (vw.clips != NULL) {	    /* clipping not supported */
+			retval = -EINVAL;
+			break;
+		}
+		if ((vw.width > MAX_HORIZ || vw.width < MIN_HORIZ) ||
+		    (vw.height > MAX_VERT || vw.height < MIN_VERT)) {
+			retval = -EINVAL;
+			break;
+		}
+
+		/* we set the video window to something smaller or equal to what
+		 * is requested by the user???
+		 */
+		down(&d->param_lock);
+		if (vw.width != d->vw.width || vw.height != d->vw.height) {
+			uint32_t scale_factor;
+			/* XXXKW base percentage on input stream, not MAX? */
+
+			/* Assert scaler reset */
+			saa7114h_reg_write(d, 0x88, 0x98);
+
+			/* Vertical scaling */
+			scale_factor = (MAX_VERT*1024) / vw.height;
+			saa7114h_reg_write(d, 0x9e, vw.height & 0xff);
+			saa7114h_reg_write(d, 0x9f, (vw.height >> 8) & 0xf);
+			saa7114h_reg_write(d, 0xb0, scale_factor & 0xff);
+			saa7114h_reg_write(d, 0xb1, (scale_factor >> 8) & 0xff);
+			saa7114h_reg_write(d, 0xb2, scale_factor & 0xff);
+			saa7114h_reg_write(d, 0xb3, (scale_factor >> 8) & 0xff);
+			/* Horizontal scaling */
+			scale_factor = (MAX_HORIZ*1024) / vw.width;
+			saa7114h_reg_write(d, 0x9c, vw.width & 0xff);
+			saa7114h_reg_write(d, 0x9d, (vw.width >> 8) & 0xf);
+			saa7114h_reg_write(d, 0xa8, scale_factor & 0xff);
+			saa7114h_reg_write(d, 0xa9, (scale_factor >> 8) & 0xff);
+			saa7114h_reg_write(d, 0xac, (scale_factor >> 1) & 0xff);
+			saa7114h_reg_write(d, 0xad, (scale_factor >> 9) & 0xff);
+#if 0
+			/* prescaler
+			saa7114h_reg_write(d, 0xa0, 2);
+			saa7114h_reg_write(d, 0xa1, 1);
+			saa7114h_reg_write(d, 0xa2, 1);
+			*/
+#endif
+
+			/* Release scaler reset */
+			saa7114h_reg_write(d, 0x88, 0xb8);
+			d->vw.width = vw.width;
+			d->vw.height = vw.height;
+		}
+		up(&d->param_lock);
+		break;
+	}
+
+	/* mmap interface */
+	case VIDIOCGMBUF:
+	{
+		struct video_mbuf vm;
+		int i;
+
+		memset(&vm, 0, sizeof(vm));
+		vm.size = MAX_FRAME_SIZE*NUM_FRAME;
+		vm.frames = NUM_FRAME;
+		for (i = 0; i < NUM_FRAME; i++)
+			vm.offsets[i] = MAX_FRAME_SIZE * i;
+
+		if (copy_to_user((void *)arg, (void *)&vm, sizeof(vm)))
+			retval = -EFAULT;
+
+		break;
+	}
+
+	case VIDIOCMCAPTURE:
+	{
+		struct video_mmap vm;
+		int descr, status;
+
+		if (copy_from_user((void *)&vm, (void *)arg, sizeof(vm))) {
+			retval = -EFAULT;
+			break;
+		}
+		if (vm.frame<0||vm.frame>NUM_FRAME) {
+			retval = -EINVAL;
+			break;
+		}
+
+		DBG(DBG_CALL,
+		    printk(KERN_DEBUG IF_NAME ":ioctl MCAPTURE %d\n", vm.frame));
+
+		d->vp.palette = vm.format;
+		/* XXXKW set depth? */
+		/* XXXKW match/update for vm.width, vm.height */
+
+		/* XXKW Should check this periodically!? */
+		status = saa7114h_reg_read(d, DECODER_STATUS);
+//		  d->interlaced = ((status & 0x80) != 0);
+
+		/* Give the buffer to the DMA engine */
+		/* XXXKW vm.frame vs d->swframe!!  mmap/read mismatch */
+#if DMA_DEINTERLACE
+		d->frame[vm.frame].pos = d->frame[vm.frame].data + d->vw.width*RAW_PER_PIXEL;
+#else
+		d->frame[vm.frame].pos = d->frame[vm.frame].data;
+#endif
+#if !NULL_DMA
+		d->frame[vm.frame].state = FRAME_READY;
+		/* Fire up the DMA engine again if it stopped */
+		if (!d->dma_enable) {
+			d->dma_enable = 1;
+			d->hwframe = d->swframe = vm.frame;
+			descr = __raw_readq(MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+			DBG(DBG_DESCR,
+			    printk(KERN_DEBUG IF_NAME ": capture adds %d -> %d descrs\n",
+				   d->ff.ringsz-descr, descr));
+			__raw_writeq(d->ff.ringsz-descr, MAC2_DMARX0_CSR(R_MAC_DMA_DSCR_CNT));
+		}
+#endif
+		break;
+	}
+
+	case VIDIOCSYNC:
+	{
+		int frame;
+
+		if (copy_from_user((void *)&frame, arg, sizeof(int))) {
+			retval = -EFAULT;
+			break;
+		}
+
+		if (frame<0 || frame >= NUM_FRAME) {
+			retval = -EINVAL;
+			break;
+		}
+
+		DBG(DBG_CALL, printk(KERN_DEBUG IF_NAME ":ioctl CSYNC %d\n", frame));
+
+		switch (d->frame[frame].state) {
+		case FRAME_UNUSED:
+			DBG(DBG_IO,
+			    printk(KERN_ERR IF_NAME ":sync to unused frame %d\n", frame));
+			retval = -EINVAL;
+			break;
+
+		case FRAME_READY:
+		case FRAME_GRABBING:
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": sleeping for frame %d\n", frame));
+			interruptible_sleep_on(&d->frame[frame].read_wait);
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": awakened\n"));
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+		case FRAME_DONE:
+#if !NULL_DMA
+			yuvconvert_inplace(d->frame[frame].data,
+					   d->frame[frame].size,
+					   d->vp.palette, 1);
+			d->frame[frame].state = FRAME_UNUSED;
+#endif
+			DBG(DBG_IO,
+			    printk(KERN_DEBUG IF_NAME ": sync finished %d\n",
+				   frame));
+			break;
+		}
+		break;
+	}
+
+	case VIDIOREADREG:
+		reg = *(int *)arg;
+		DBG(DBG_REGISTER, printk(KERN_DEBUG IF_NAME ": read of %02x\n", reg));
+		if ((reg > 0xEF) || (reg < 0))
+			return -EINVAL;
+		val = saa7114h_reg_read((struct saa7114h *)vd->priv, reg);
+		if (val == -1)
+			return -EIO;
+		*(int *)arg = val;
+		break;
+	case VIDIOWRITEREG:
+		if (copy_from_user(&reg, arg, sizeof(int)) ||
+		    copy_from_user(&val, arg+sizeof(int), sizeof(int)))
+			return -EFAULT;
+		DBG(DBG_REGISTER, printk(KERN_DEBUG IF_NAME ": write of %02x <- %02x\n", reg, val));
+		if ((reg > 0xEF) || (reg < 0))
+			return -EINVAL;
+		val = saa7114h_reg_write((struct saa7114h *)vd->priv, reg, val);
+		if (val == -1)
+			return -EIO;
+		break;
+	case VIDIOGRABFRAME:
+		return grab_frame((struct saa7114h *)vd->priv, arg, 0);
+	case VIDIOSHOWEAV:
+		return grab_frame((struct saa7114h *)vd->priv, arg, 1);
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+	return retval;
+}
+
+static int saa7114h_mmap(struct video_device *vd, const char *adr,
+			 unsigned long size)
+{
+	struct saa7114h *d = vd->priv;
+	unsigned long start = (unsigned long)adr;
+	unsigned long page, pos;
+
+	if (!d)
+		return -ENODEV;
+
+	if (size > MAX_MMAP_SIZE) {
+		printk("mmap: bad size %lu > %lu\n", size, MAX_MMAP_SIZE);
+		return -EINVAL;
+	}
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&d->busy_lock))
+		return -EINTR;
+
+	pos = (unsigned long)(d->frame_buf);
+	while (size > 0) {
+		page = kvirt_to_pa(pos);
+		if (remap_page_range(start, page, PAGE_SIZE, PAGE_SHARED)) {
+			up(&d->busy_lock);
+			return -EAGAIN;
+		}
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+	up(&d->busy_lock);
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------
+ * Device probing and initialization
+ * ----------------------------------------------------------------------- */
+
+/* Default values to program into SAA7114H */
+static const unsigned char reg_init[] =	{
+	0x00, 0x00,	/* 00 - ID byte */
+
+	/*front end */
+	0x01, 0x08,	/* 01 - Horizontal increment -> recommended delay */
+	0x02, 0xC4,	/* 02 - AI Control 1 (CVBS AI23) */
+	0x03, 0x10,	/* 03 - AI Control 2 */
+	0x04, 0x90,	/* 04 - AI Control 3 (Gain ch 1) */
+	0x05, 0x90,	/* 05 - AI Control 4 (Gain ch 2) */
+	
+	/* decoder */
+	0x06, 0xEB,	/* 06 - Horiz sync start */
+	0x07, 0xE0,	/* 07 - Horiz sync stop */
+	0x08, 0x98,	/* 08 - Sync control */
+	0x09, 0x40,	/* 09 - L Control */
+	0x0a, 0x80,	/* 0a - L Brightness */
+	0x0b, 0x44,	/* 0b - L Contrast */
+	0x0c, 0x40,	/* 0c - C Saturation */
+	0x0d, 0x00,	/* 0d - C Hue */
+	0x0e, 0x89,	/* 0e - C Control 1 */
+	0x0f, 0x0f,	/* 0f - C Gain (??? 0x2A recommended) */
+	0x10, 0x0E,	/* 10 - C Control 2 */
+	0x11, 0x00,	/* 11 - Mode/Delay */
+	0x12, 0x00,	/* 12 - RT signal control */
+	0x13, 0x00,	/* 13 - RT/X output */
+	0x14, 0x00,	/* 14 - Analog, Compat */
+	0x15, 0x11,	/* 15 - VGATE start */
+	0x16, 0xFE,	/* 16 - VGATE stop */
+	0x17, 0x40,	/* 17 - Misc VGATE (disable LLC2) */
+	0x18, 0x40,	/* 18 - Raw data gain - 128 */
+	0x19, 0x80,	/* 19 - Raw data offset - 0 */
+
+	/* Global settings */
+	0x88, 0x98,	/* 88 - AI1x on, AI2x off; decoder/slicer off; ACLK gen off */
+	0x83, 0x00,	/* 83 - X-port output disabled */
+	0x84, 0xF0,	/* 84 - I-port V/G output framing, IGP1=0=IGP0=0 */
+	0x85, 0x00,	/* 85 - I-port default polarities, X-port signals */
+	0x86, 0x40,	/* 86 - more IGP1/0, FIFO level, only video transmitted */
+	0x87, 0x01,	/* 87 - ICK default, IDQ default, I-port output enabled */
+
+	/* Task A: scaler input config and output format */
+	0x90, 0x00,	/* 90 - Task handling */
+	0x91, 0x08,	/* 91 - Scalar input and format */
+	0x92, 0x10,	/* 92 - Reference signal def */
+	0x93, 0x80,	/* 93 - I-port output */
+
+	/* Task B */
+	0xc0, 0x42,	/* 90 - Task handling */
+	0xc1, 0x08,	/* 91 - Scalar input and format */
+	0xc2, 0x10,	/* 92 - Reference signal def */
+	0xc3, 0x80,	/* 93 - I-port output */
+
+	/* Input and Output windows */
+	0x94, 0x10,	/*  - */
+	0x95, 0x00,	/*  - */
+	0x96, 0xD0,	/*  - */
+	0x97, 0x02,	/*  - */
+	0x98, 0x0A,	/*  - */
+	0x99, 0x00,	/*  - */
+	0x9a, 0xF2,	/*  - */
+	0x9b, 0x00,	/*  - */
+	0x9c, 0xD0,	/*  - */
+	0x9d, 0x02,	/*  - */
+	0xc4, 0x10,	/*  - */
+	0xc5, 0x00,	/*  - */
+	0xc6, 0xD0,	/*  - */
+	0xc7, 0x02,	/*  - */
+	0xc8, 0x0A,	/*  - */
+	0xc9, 0x00,	/*  - */
+	0xca, 0xF2,	/*  - */
+	0xcb, 0x00,	/*  - */
+	0xcc, 0xD0,	/*  - */
+	0xcd, 0x02,	/*  - */
+
+	0x9e, 0xf0,	/*  - */
+	0x9f, 0x00,	/*  - */
+	0xce, 0xf0,	/*  - */
+	0xcf, 0x00,	/*  - */
+
+	/* Prefiltering and prescaling */
+	0xa0, 0x01,	/*  - */
+	0xa1, 0x00,	/*  - */
+	0xa2, 0x00,	/*  - */
+	0xa4, 0x80,	/*  - */
+	0xa5, 0x40,	/*  - */
+	0xa6, 0x40,	/*  - */
+	0xd4, 0x80,	/*  - */
+	0xd5, 0x40,	/*  - */
+	0xd6, 0x40,	/*  - */
+
+	/* Horizontal phase scaling */
+	0xa8, 0x00,	/*  - */
+	0xa9, 0x04,	/*  - */
+	0xaa, 0x00,	/*  - */
+	0xd8, 0x00,	/*  - */
+	0xd9, 0x04,	/*  - */
+	0xda, 0x00,	/*  - */
+
+	0xac, 0x00,	/*  - */
+	0xad, 0x02,	/*  - */
+	0xae, 0x00,	/*  - */
+	0xdc, 0x00,	/*  - */
+	0xdd, 0x02,	/*  - */
+	0xde, 0x00,	/*  - */
+
+	/* Vertical phase scaling */
+	0xb0, 0x00,	/*  - */
+	0xb1, 0x04,	/*  - */
+	0xb2, 0x00,	/*  - */
+	0xb3, 0x04,	/*  - */
+	0xe0, 0x00,	/*  - */
+	0xe1, 0x04,	/*  - */
+	0xe2, 0x00,	/*  - */
+	0xe3, 0x04,	/*  - */
+	0xb4, 0x00,	/* b4 - vscale mode control */
+	0xe4, 0x00,	/* b4 - vscale mode control */
+
+	/* Task enables */
+	0x80, 0x10,	/* 80 - LLC->ICLK, dq->IDQ, scaler->F/V timing, task enables */
+
+	/* Reset the slicer */
+	0x88, 0xb8,	/* 88 - AI1x on, AI2x off; decoder/slicer on; ACLK gen off */
+};
+
+static int saa7114h_attach(struct i2c_adapter *adap, int addr, unsigned short flags, int kind)
+{
+	struct i2c_client *client;
+	struct video_device *vd;
+	struct saa7114h *decoder;
+	int err;
+	int val, i;
+
+	client = kmalloc(sizeof(*client), GFP_KERNEL);
+	if (client == NULL)
+		return -ENOMEM;
+	client->adapter = adap;
+	client->addr = addr;
+	client->driver = &i2c_driver_saa7114h;
+	strcpy(client->name, IF_NAME);
+
+	decoder = kmalloc(sizeof(*decoder), GFP_KERNEL);
+	if (decoder == NULL) {
+		kfree(client);
+		return -ENOMEM;
+	}
+	memset(decoder, 0, sizeof(struct saa7114h));
+	decoder->client = client;
+	decoder->dma_enable = 0;
+	decoder->palette = VIDEO_PALETTE_UYVY;
+	decoder->depth = 16;
+	decoder->vw.width = MAX_HORIZ;
+	decoder->vw.height = MAX_VERT;
+	decoder->frame_buf = rvmalloc(MAX_FRAME_SIZE*NUM_FRAME);
+	if (!decoder->frame_buf) {
+		kfree(decoder);
+		kfree(client);
+		return -ENOMEM;
+	}
+	/* XXXKW use clear_page? */
+	memset(decoder->frame_buf, 0, MAX_FRAME_SIZE*NUM_FRAME);
+	printk("saa7114h_attach: frame_buf = (fb=%8p / %08lx)\n",
+	       decoder->frame_buf, kvirt_to_pa((int)decoder->frame_buf));
+	for (i=0; i<NUM_FRAME; i++) {
+		decoder->frame[i].data = decoder->frame_buf+i*MAX_FRAME_SIZE;
+#if NULL_DMA
+		decoder->frame[i].state = FRAME_DONE;
+#else
+		decoder->frame[i].state = FRAME_UNUSED;
+#endif
+		init_waitqueue_head(&decoder->frame[i].read_wait);
+	}
+	decoder->irq = K_INT_MAC_2;
+	if (request_irq
+	    (decoder->irq, saa7114h_interrupt, 0, "Philips SAA7114h", decoder)) {
+		rvfree(decoder->frame_buf, MAX_FRAME_SIZE*NUM_FRAME);
+		kfree(decoder);
+		kfree(client);
+		return -ENOMEM;
+	}
+	init_MUTEX(&decoder->param_lock);
+	init_MUTEX(&decoder->busy_lock);
+
+	if ((err = i2c_attach_client(client)) < 0) {
+		kfree(client);
+		kfree(decoder);
+		return err;
+	}
+
+	if (saa7114h_reg_init(decoder, reg_init, sizeof(reg_init)) ||
+	    saa7114h_get_cparams(decoder)) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		return -ENODEV;
+	}
+
+	vd = kmalloc(sizeof(*vd), GFP_KERNEL);
+	memset(vd, 0, sizeof(*vd));
+	if (vd == NULL) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		return -ENOMEM;
+	}
+	vd->priv = decoder;
+	strcpy(vd->name, IF_NAME);
+	vd->type = VID_TYPE_CAPTURE;
+	vd->hardware = VID_HARDWARE_SAA7114H;
+	vd->open =  saa7114h_open;
+	vd->close = saa7114h_release;
+	vd->read =  saa7114h_read;
+	vd->ioctl = saa7114h_ioctl;
+	vd->mmap =  saa7114h_mmap;
+
+	if ((err = video_register_device(vd, VFL_TYPE_GRABBER, -1)) < 0) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		kfree(vd);
+		return err;
+	}
+
+	client->data = vd;
+	decoder->vd = vd;
+
+	/* Turn on the ITRDY - preserve the GENO pin for syncser */
+	val = __raw_readq(KSEG1 + A_MAC_REGISTER(2, R_MAC_MDIO));
+	__raw_writeq(M_MAC_MDIO_OUT | (val & M_MAC_GENC),
+	      KSEG1 + A_MAC_REGISTER(2, R_MAC_MDIO));
+
+	if ((err = dma_setup(decoder))) {
+		i2c_detach_client(client);
+		kfree(client);
+		kfree(decoder);
+		kfree(vd);
+		return err;
+	}
+
+	printk("saa7114h_attach successful\n");
+
+#ifdef CONFIG_PROC_FS
+	proc_saa7114h_create();
+	create_proc_decoder(vd->priv);
+#endif
+
+	return 0;
+}
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = {I2C_CLIENT_END};
+static unsigned short normal_i2c_range[] = {0x20, 0x21, I2C_CLIENT_END};
+static unsigned short probe[2]	      = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short probe_range[2]  = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore[2]	      = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short ignore_range[2] = { I2C_CLIENT_END, I2C_CLIENT_END };
+static unsigned short force[2]	      = { I2C_CLIENT_END, I2C_CLIENT_END };
+
+static struct i2c_client_address_data addr_data = {
+	normal_i2c, normal_i2c_range,
+	probe, probe_range,
+	ignore, ignore_range,
+	force
+};
+
+static int saa7114h_probe(struct i2c_adapter *adap)
+{
+	/* Look for this device on the given adapter (bus) */
+	if (adap->id == (I2C_ALGO_SIBYTE | I2C_HW_SIBYTE))
+		return i2c_probe(adap, &addr_data, &saa7114h_attach);
+	else
+		return 0;
+}
+
+static int saa7114h_detach(struct i2c_client *device)
+{
+#if 0
+	kfree(device->data);
+#endif
+#ifdef CONFIG_PROC_FS
+	destroy_proc_decoder(((struct video_device *)device->data)->priv);
+	proc_saa7114h_destroy();
+#endif
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static int __init swarm_7114h_init(void)
+{
+	return i2c_add_driver(&i2c_driver_saa7114h);
+}
+
+static void __exit swarm_7114h_cleanup(void)
+{
+}
+
+MODULE_AUTHOR("Kip Walker, Broadcom Corp.");
+MODULE_DESCRIPTION("Philips SAA7114H Driver for Broadcom SWARM board");
+
+module_init(swarm_7114h_init);
+module_exit(swarm_7114h_cleanup);
diff -urpNX dontdiff linux-2.6.11.6/drivers/media/video/vino.c linux_HEAD/drivers/media/video/vino.c
--- linux-2.6.11.6/drivers/media/video/vino.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/drivers/media/video/vino.c	2003-09-24 15:24:56.000000000 +0200
@@ -1,6 +1,6 @@
 /*
  * (incomplete) Driver for the VINO (Video In No Out) system found in SGI Indys.
- *
+ * 
  * This file is subject to the terms and conditions of the GNU General Public
  * License version 2 as published by the Free Software Foundation.
  *
@@ -139,7 +139,7 @@ static int i2c_vino_client_reg(struct i2
 static int i2c_vino_client_unreg(struct i2c_client *client)
 {
 	int res = 0;
-
+	
 	down(&Vino->input_lock);
 	if (client == Vino->decoder.driver) {
 		if (Vino->decoder.owner)
@@ -223,7 +223,7 @@ static int __init vino_init(void)
 {
 	unsigned long rev;
 	int i, ret = 0;
-
+	
 	/* VINO is Indy specific beast */
 	if (ip22_is_fullhouse())
 		return -ENODEV;
@@ -231,7 +231,7 @@ static int __init vino_init(void)
 	/*
 	 * VINO is in the EISA address space, so the sysid register will tell
 	 * us if the EISA_PRESENT pin on MC has been pulled low.
-	 *
+	 * 
 	 * If EISA_PRESENT is not set we definitely don't have a VINO equiped
 	 * system.
 	 */
diff -urpNX dontdiff linux-2.6.11.6/drivers/mtd/devices/Kconfig linux_HEAD/drivers/mtd/devices/Kconfig
--- linux-2.6.11.6/drivers/mtd/devices/Kconfig	2005-03-26 04:28:42.000000000 +0100
+++ linux_HEAD/drivers/mtd/devices/Kconfig	2005-02-17 21:49:45.000000000 +0100
@@ -47,6 +47,11 @@ config MTD_MS02NV
 	  accelerator.  Say Y here if you have a DECstation 5000/2x0 or a
 	  DECsystem 5900 equipped with such a module.
 
+	  If you want to compile this driver as a module ( = code which can be
+	  inserted in and removed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module will
+	  be called ms02-nv.o.
+
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	depends on MTD
diff -urpNX dontdiff linux-2.6.11.6/drivers/mtd/devices/docprobe.c linux_HEAD/drivers/mtd/devices/docprobe.c
--- linux-2.6.11.6/drivers/mtd/devices/docprobe.c	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/drivers/mtd/devices/docprobe.c	2005-02-17 21:49:45.000000000 +0100
@@ -84,10 +84,10 @@ static unsigned long __initdata doc_loca
 	0xe4000000,
 #elif defined(CONFIG_MOMENCO_OCELOT)
 	0x2f000000,
-        0xff000000,
+	0xff000000,
 #elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-        0xff000000,
-##else
+	0xff000000,
+#else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0xffffffff };
diff -urpNX dontdiff linux-2.6.11.6/drivers/mtd/maps/Kconfig linux_HEAD/drivers/mtd/maps/Kconfig
--- linux-2.6.11.6/drivers/mtd/maps/Kconfig	2005-04-03 00:12:09.000000000 +0200
+++ linux_HEAD/drivers/mtd/maps/Kconfig	2005-03-21 20:04:22.000000000 +0100
@@ -201,87 +201,12 @@ config MTD_TSUNAMI
 	help
 	  Support for the flash chip on Tsunami TIG bus.
 
-config MTD_LASAT
-	tristate "Flash chips on LASAT board"
-	depends on LASAT
-	help
-	  Support for the flash chips on the Lasat 100 and 200 boards.
-
 config MTD_NETtel
 	tristate "CFI flash device on SnapGear/SecureEdge"
 	depends on X86 && MTD_PARTITIONS && MTD_JEDECPROBE
 	help
 	  Support for flash chips on NETtel/SecureEdge/SnapGear boards.
 
-config MTD_PB1XXX
-	tristate "Flash devices on Alchemy PB1xxx boards"
-	depends on MIPS && ( MIPS_PB1000 || MIPS_PB1100 || MIPS_PB1500 )
-	help
-	  Flash memory access on Alchemy Pb1000/Pb1100/Pb1500 boards
-
-config MTD_PB1XXX_BOOT
-	bool "PB1x00 boot flash device"
-	depends on MTD_PB1XXX && ( MIPS_PB1100 || MIPS_PB1500 )
-	help
-	  Use the first of the two 32MiB flash banks on Pb1100/Pb1500 board.
-	  You can say 'Y' to both this and 'MTD_PB1XXX_USER' below, to use
-	  both banks.
-
-config MTD_PB1XXX_USER
-	bool "PB1x00 user flash device"
-	depends on MTD_PB1XXX && ( MIPS_PB1100 || MIPS_PB1500 )
-	default y if MTD_PB1XX_BOOT = n
-	help
-	  Use the second of the two 32MiB flash banks on Pb1100/Pb1500 board.
-	  You can say 'Y' to both this and 'MTD_PB1XXX_BOOT' above, to use
-	  both banks.
-
-config MTD_PB1550
-	tristate "Flash devices on Alchemy PB1550 board"
-	depends on MIPS && MIPS_PB1550
-	help
-	  Flash memory access on Alchemy Pb1550 board
-
-config MTD_PB1550_BOOT
-	bool "PB1550 boot flash device"
-	depends on MTD_PB1550
-	help
-	  Use the first of the two 64MiB flash banks on Pb1550 board.
-	  You can say 'Y' to both this and 'MTD_PB1550_USER' below, to use
-	  both banks.
-
-config MTD_PB1550_USER
-	bool "PB1550 user flash device"
-	depends on MTD_PB1550
-	default y if MTD_PB1550_BOOT = n
-	help
-	  Use the second of the two 64MiB flash banks on Pb1550 board.
-	  You can say 'Y' to both this and 'MTD_PB1550_BOOT' above, to use
-	  both banks.
-
-config MTD_DB1550
-	tristate "Flash devices on Alchemy DB1550 board"
-	depends on MIPS && MIPS_DB1550
-	help
-	  Flash memory access on Alchemy Db1550 board
-
-config MTD_DB1550_BOOT
-	bool "DB1550 boot flash device"
-	depends on MTD_DB1550
-	help
-	  Use the first of the two 64MiB flash banks on Db1550 board.
-	  You can say 'Y' to both this and 'MTD_DB1550_USER' below, to use
-	  both banks.
-
-config MTD_DB1550_USER
-	bool "DB1550 user flash device"
-	depends on MTD_DB1550
-	default y if MTD_DB1550_BOOT = n
-	help
-	  Use the second of the two 64MiB flash banks on Db1550 board.
-	  You can say 'Y' to both this and 'MTD_DB1550_BOOT' above, to use
-	  both banks.
-
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_CONCAT && MTD_PARTITIONS && MTD_CFI_INTELEXT
@@ -357,6 +282,24 @@ config MTD_CFI_FLAGADM
 	  Mapping for the Flaga digital module. If you don't have one, ignore
 	  this setting.
 
+config MTD_ALCHEMY
+	tristate '  AMD Alchemy Pb1xxx/Db1xxx/RDK MTD support' 
+	depends on MIPS && SOC_AU1X00
+	help
+	  Flash memory access on AMD Alchemy Pb/Db/RDK Reference Boards
+
+config MTD_XXS1500
+	tristate "MyCable XXS1500 Flash device"
+	depends on MIPS && MIPS_XXS1500
+	help
+	  Flash memory access on MyCable XXS1500 Board
+
+config MTD_MTX1
+	tristate "4-G Systems MTX-1 Flash device"
+	depends on MIPS && MIPS_MTX1
+	help
+	  Flash memory access on 4-G Systems MTX-1 Board
+
 config MTD_BEECH
 	tristate "CFI Flash device mapped on IBM 405LP Beech"
 	depends on MTD_CFI && PPC32 && 40x && BEECH
@@ -457,6 +400,12 @@ config MTD_OCELOT
 	  NVRAM on the Momenco Ocelot board. If you have one of these boards
 	  and would like access to either of these, say 'Y'.
 
+config MTD_LASAT
+	tristate "LASAT flash device"
+	depends on LASAT && MTD_CFI
+	help
+	  Support for the flash chips on the Lasat 100 and 200 boards.
+
 config MTD_SOLUTIONENGINE
 	tristate "CFI Flash device mapped on Hitachi SolutionEngine"
 	depends on SUPERH && MTD_CFI && MTD_REDBOOT_PARTS
diff -urpNX dontdiff linux-2.6.11.6/drivers/mtd/maps/Makefile linux_HEAD/drivers/mtd/maps/Makefile
--- linux-2.6.11.6/drivers/mtd/maps/Makefile	2005-04-03 00:12:09.000000000 +0200
+++ linux_HEAD/drivers/mtd/maps/Makefile	2005-03-21 20:04:22.000000000 +0100
@@ -44,11 +44,9 @@ obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.
 obj-$(CONFIG_MTD_OCELOT)	+= ocelot.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
-obj-$(CONFIG_MTD_PB1XXX)	+= pb1xxx-flash.o
-obj-$(CONFIG_MTD_DB1X00)        += db1x00-flash.o
-obj-$(CONFIG_MTD_PB1550)        += pb1550-flash.o
-obj-$(CONFIG_MTD_DB1550)        += db1550-flash.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
+obj-$(CONFIG_MTD_PB1550)	+= pb1550-flash.o
+obj-$(CONFIG_MTD_DB1550)	+= db1550-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
@@ -70,4 +68,4 @@ obj-$(CONFIG_MTD_IXP4XX)	+= ixp4xx.o
 obj-$(CONFIG_MTD_IXP2000)	+= ixp2000.o
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
-obj-$(CONFIG_MTD_SHARP_SL)	+= sharpsl-flash.o
+obj-$(CONFIG_MTD_ALCHEMY)       += alchemy-flash.o
diff -urpNX dontdiff linux-2.6.11.6/drivers/mtd/maps/alchemy-flash.c linux_HEAD/drivers/mtd/maps/alchemy-flash.c
--- linux-2.6.11.6/drivers/mtd/maps/alchemy-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/mtd/maps/alchemy-flash.c	2005-02-27 23:03:20.000000000 +0100
@@ -0,0 +1,192 @@
+/*
+ * Flash memory access on AMD Alchemy evaluation boards
+ * 
+ * $Id: alchemy-flash.c,v 1.1 2005/02/27 22:03:20 ppopov Exp $
+ *
+ * (C) 2003, 2004 Pete Popov <ppopov@embeddedalley.com>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_PB1000
+#define BOARD_MAP_NAME "Pb1000 Flash"
+#define BOARD_FLASH_SIZE 0x00800000 /* 8MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1500
+#define BOARD_MAP_NAME "Pb1500 Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1100
+#define BOARD_MAP_NAME "Pb1100 Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1550
+#define BOARD_MAP_NAME "Pb1550 Flash"
+#define BOARD_FLASH_SIZE 0x08000000 /* 128MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_PB1200
+#define BOARD_MAP_NAME "Pb1200 Flash"
+#define BOARD_FLASH_SIZE 0x08000000 /* 128MB */
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1000
+#define BOARD_MAP_NAME "Db1000 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1500
+#define BOARD_MAP_NAME "Db1500 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1100
+#define BOARD_MAP_NAME "Db1100 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+#define BOARD_MAP_NAME "Db1550 Flash"
+#define BOARD_FLASH_SIZE 0x08000000 /* 128MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#endif
+
+#ifdef CONFIG_MIPS_DB1200
+#define BOARD_MAP_NAME "Db1200 Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+#endif
+
+#ifdef CONFIG_MIPS_HYDROGEN3
+#define BOARD_MAP_NAME "Hydrogen3 Flash"
+#define BOARD_FLASH_SIZE 0x02000000 /* 32MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#define USE_LOCAL_ACCESSORS /* why? */
+#endif
+
+#ifdef CONFIG_MIPS_BOSPORUS
+#define BOARD_MAP_NAME "Bosporus Flash"
+#define BOARD_FLASH_SIZE 0x01000000 /* 16MB */
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+#endif
+
+#ifdef CONFIG_MIPS_MIRAGE
+#define BOARD_MAP_NAME "Mirage Flash"
+#define BOARD_FLASH_SIZE 0x04000000 /* 64MB */
+#define BOARD_FLASH_WIDTH 4 /* 32-bits */
+#define USE_LOCAL_ACCESSORS /* why? */
+#endif
+
+static struct map_info alchemy_map = {
+	.name =	BOARD_MAP_NAME,
+};
+
+static struct mtd_partition alchemy_partitions[] = {
+        {
+                .name = "User FS",
+                .size = BOARD_FLASH_SIZE - 0x00400000,
+                .offset = 0x0000000
+        },{
+                .name = "YAMON",
+                .size = 0x0100000,
+		.offset = MTDPART_OFS_APPEND,
+                .mask_flags = MTD_WRITEABLE
+        },{
+                .name = "raw kernel",
+		.size = (0x300000 - 0x40000), /* last 256KB is yamon env */
+		.offset = MTDPART_OFS_APPEND,
+        }
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_info *mymtd;
+
+int __init alchemy_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	unsigned long window_addr;
+	unsigned long window_size;
+	
+	/* Default flash buswidth */
+	alchemy_map.bankwidth = BOARD_FLASH_WIDTH;
+
+	window_addr = 0x20000000 - BOARD_FLASH_SIZE;
+	window_size = BOARD_FLASH_SIZE;
+#ifdef CONFIG_MIPS_MIRAGE_WHY
+	/* Boot ROM flash bank only; no user bank */
+	window_addr = 0x1C000000;
+	window_size = 0x04000000;
+	/* USERFS from 0x1C00 0000 to 0x1FC00000 */
+	alchemy_partitions[0].size = 0x03C00000;
+#endif
+
+	/*
+	 * Static partition definition selection
+	 */
+	parts = alchemy_partitions;
+	nb_parts = NB_OF(alchemy_partitions);
+	alchemy_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE BOARD_MAP_NAME ": probing %d-bit flash bus\n", 
+			alchemy_map.bankwidth*8);
+	alchemy_map.virt = ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &alchemy_map);
+	if (!mymtd) {
+		iounmap(alchemy_map.virt);
+		return -ENXIO;
+	}
+	mymtd->owner = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit alchemy_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		iounmap(alchemy_map.virt);
+	}
+}
+
+module_init(alchemy_mtd_init);
+module_exit(alchemy_mtd_cleanup);
+
+MODULE_AUTHOR("Embedded Alley Solutions, Inc");
+MODULE_DESCRIPTION(BOARD_MAP_NAME " MTD driver");
+MODULE_LICENSE("GPL");
diff -urpNX dontdiff linux-2.6.11.6/drivers/mtd/maps/lasat.c linux_HEAD/drivers/mtd/maps/lasat.c
--- linux-2.6.11.6/drivers/mtd/maps/lasat.c	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/drivers/mtd/maps/lasat.c	2004-12-04 20:57:27.000000000 +0100
@@ -7,7 +7,7 @@
  * modify it under the terms of the GNU General Public License version
  * 2 as published by the Free Software Foundation.
  *
- * $Id: lasat.c,v 1.9 2004/11/04 13:24:15 gleixner Exp $
+ * $Id: lasat.c,v 1.7 2004/07/12 21:59:44 dwmw2 Exp $
  *
  */
 
@@ -50,7 +50,7 @@ static int __init init_lasat(void)
 	ENABLE_VPP((&lasat_map));
 
 	lasat_map.phys = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
-	lasat_map.virt = ioremap_nocache(
+	lasat_map.virt = (unsigned long)ioremap_nocache(
 		        lasat_map.phys, lasat_board_info.li_flash_size);
 	lasat_map.size = lasat_board_info.li_flash_size;
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/Kconfig linux_HEAD/drivers/net/Kconfig
--- linux-2.6.11.6/drivers/net/Kconfig	2005-04-03 00:12:09.000000000 +0200
+++ linux_HEAD/drivers/net/Kconfig	2005-03-21 20:04:23.000000000 +0100
@@ -447,6 +447,14 @@ config MIPS_JAZZ_SONIC
 	  This is the driver for the onboard card of MIPS Magnum 4000,
 	  Acer PICA, Olivetti M700-10 and a few other identical OEM systems.
 
+config GALILEO_64240_ETH
+	tristate "Galileo GT64240 Ethernet support"
+	depends on NET_ETHERNET && MOMENCO_OCELOT_G
+	select MII
+	help
+	  This is the driver for the ethernet interfaces integrated into
+	  the Galileo (now Marvell) GT64240 chipset.
+
 config MIPS_GT96100ETH
 	bool "MIPS GT96100 Ethernet support"
 	depends on NET_ETHERNET && MIPS_GT96100
@@ -461,10 +469,6 @@ config MIPS_AU1X00_ENET
 	  If you have an Alchemy Semi AU1X00 based system
 	  say Y.  Otherwise, say N.
 
-config NET_SB1250_MAC
-	tristate "SB1250 Ethernet support"
-	depends on NET_ETHERNET && SIBYTE_SB1xxx_SOC
-
 config SGI_IOC3_ETH
 	bool "SGI IOC3 Ethernet"
 	depends on NET_ETHERNET && PCI && SGI_IP27
@@ -1944,6 +1948,10 @@ config R8169_NAPI
 
 	  If in doubt, say N.
 
+config NET_SB1250_MAC
+	tristate "SB1250 Ethernet support"
+	depends on SIBYTE_SB1xxx_SOC
+
 config R8169_VLAN
 	bool "VLAN support"
 	depends on R8169 && VLAN_8021Q
@@ -2069,8 +2077,8 @@ config MV643XX_ETH
 	depends on MOMENCO_OCELOT_C || MOMENCO_JAGUAR_ATX || MV64360 || MOMENCO_OCELOT_3
 	help
 	  This driver supports the gigabit Ethernet on the Marvell MV643XX
-	  chipset which is used in the Momenco Ocelot C and Jaguar ATX and
-	  Pegasos II, amongst other PPC and MIPS boards.
+	  chipset which is used in the Momenco Ocelot C Ocelot, Jaguar ATX
+	  and Pegasos II, amongst other PPC and MIPS boards.
 
 config MV643XX_ETH_0
 	bool "MV-643XX Port 0"
@@ -2093,6 +2101,20 @@ config MV643XX_ETH_2
 	  This enables support for Port 2 of the Marvell MV643XX Gigabit
 	  Ethernet.
 
+config BIG_SUR_FE
+	bool "PMC-Sierra TITAN Fast Ethernet Support"
+	depends on NET_ETHERNET && PMC_BIG_SUR
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Big Sur SoC.
+
+config TITAN_GE
+	bool "PMC-Sierra TITAN Gigabit Ethernet Support"
+	depends on PMC_YOSEMITE
+	help
+	  This enables support for the the integrated ethernet of
+	  PMC-Sierra's Titan SoC.
+
 endmenu
 
 #
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/Makefile linux_HEAD/drivers/net/Makefile
--- linux-2.6.11.6/drivers/net/Makefile	2005-04-03 00:12:09.000000000 +0200
+++ linux_HEAD/drivers/net/Makefile	2005-03-21 20:04:23.000000000 +0100
@@ -100,6 +100,11 @@ obj-$(CONFIG_NE_H8300) += ne-h8300.o 839
 
 obj-$(CONFIG_MV643XX_ETH) += mv643xx_eth.o
 
+obj-$(CONFIG_GALILEO_64240_ETH) += gt64240eth.o
+obj-$(CONFIG_MV64340_ETH) += mv64340_eth.o
+obj-$(CONFIG_BIG_SUR_FE) += big_sur_ge.o
+obj-$(CONFIG_TITAN_GE) += titan_mdio.o titan_ge.o
+
 obj-$(CONFIG_PPP) += ppp_generic.o slhc.o
 obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/big_sur_ge.c linux_HEAD/drivers/net/big_sur_ge.c
--- linux-2.6.11.6/drivers/net/big_sur_ge.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/net/big_sur_ge.c	2005-02-17 21:49:47.000000000 +0100
@@ -0,0 +1,2005 @@
+/*
+ * drivers/net/big_sur_ge.c - Driver for PMC-Sierra Big Sur ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+/*************************************************************************
+ * Description :
+ *
+ * The driver has three modes of operation: FIFO non-DMA, Simple DMA
+ * and SG DMA. There is also a Polled mode and an Interrupt mode of
+ * operation. SG DMA should do zerocopy and check offload. Probably,
+ * zerocopy on the Rx might also work. Simple DMA is the non-zerocpy
+ * case on the Tx and the Rx.
+ *
+ * We turn on Simple DMA and interrupt mode. Although, support has been
+ * added for the SG mode also but not for the polled mode. This is a
+ * Fast Ethernet driver although there will be support for Gigabit soon.
+ *
+ * The driver is divided into two parts: Hardware dependent and a
+ * Hardware independent. There is currently no support for checksum offload
+ * zerocopy and Rx NAPI. There is support for Interrupt Mitigation.
+ ****************************************************************************/
+
+/*************************************************************
+ * Hardware Indepenent Part of the driver
+ *************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "big_sur_ge.h"
+
+#define TX_TIMEOUT (60*HZ)	/* Transmission timeout is 60 seconds. */
+
+static struct net_device *dev_list = NULL;
+static DEFINE_SPINLOCK(dev_lock);
+
+typedef enum DUPLEX { UNKNOWN, HALF_DUPLEX, FULL_DUPLEX } DUPLEX;
+
+/* Big Sur Ethernet MAC structure */
+struct big_sur_ge_enet {
+	struct net_device_stats stats;	/* Statistics for this device */
+	struct net_device *next_dev;	/* The next device in dev_list */
+	struct timer_list phy_timer;	/* PHY monitoring timer */
+	u32 index;		/* Which interface is this */
+	u32 save_base_address;	/* Saved physical base address */
+	struct sk_buff *saved_skb;	/* skb being transmitted */
+	spinlock_t lock;	/* For atomic access to saved_skb */
+	u8 mii_addr;		/* The MII address of the PHY */
+	big_sur_ge emac;	/* GE driver structure */
+};
+
+/* Manish : For testing purposes only */
+static unsigned char big_sur_mac_addr_base[6] = "00:11:22:33:44:55";
+
+/*********************************************************************
+ * Function Prototypes (whole bunch of them)
+ *********************************************************************/
+unsigned long big_sur_ge_dma_control(xdma_channel *);
+void big_sur_ge_dma_reset(xdma_channel *);
+static void handle_fifo_intr(big_sur_ge *);
+void big_sur_ge_check_fifo_recv_error(big_sur_ge *);
+void big_sur_ge_check_fifo_send_error(big_sur_ge *);
+static int big_sur_ge_config_fifo(big_sur_ge *);
+big_sur_ge_config *big_sur_ge_lookup_config(unsigned int);
+static int big_sur_ge_config_dma(big_sur_ge *);
+void big_sur_ge_enet_reset(big_sur_ge *);
+void big_sur_ge_check_mac_error(big_sur_ge *, unsigned long);
+
+/*********************************************************************
+ * DMA Channel Initialization
+ **********************************************************************/
+static int big_sur_ge_dma_init(xdma_channel * dma, unsigned long base_address)
+{
+	dma->reg_base_address = base_address;
+	dma->get_ptr = NULL;
+	dma->put_ptr = NULL;
+	dma->commit_ptr = NULL;
+	dma->last_ptr = NULL;
+	dma->total_desc_count = (unsigned long) NULL;
+	dma->active_desc_count = (unsigned long) NULL;
+	dma->ready = 1;		/* DMA channel is ready */
+
+	big_sur_ge_dma_reset(dma);
+
+	return 0;
+}
+
+/*********************************************************************
+ * Is the DMA channel ready yet ?
+ **********************************************************************/
+static int big_sur_ge_dma_ready(xdma_channel * dma)
+{
+	return dma->ready == 1;
+}
+
+/*********************************************************************
+ * Perform the self test on the DMA channel
+ **********************************************************************/
+#define BIG_SUR_GE_CONTROL_REG_RESET_MASK	0x98000000
+
+static int big_sur_ge_dma_self_test(xdma_channel * dma)
+{
+	unsigned long reg_data;
+
+	big_sur_ge_dma_reset(dma);
+
+	reg_data = big_sur_ge_dma_control(dma);
+	if (reg_data != BIG_SUR_GE_CONTROL_REG_RESET_MASK) {
+		printk(KERN_ERR "DMA Channel Self Test Failed \n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*********************************************************************
+ * Reset the DMA channel
+ **********************************************************************/
+static void big_sur_ge_dma_reset(xdma_channel * dma)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_RST_REG_OFFSET,
+			 BIG_SUR_GE_RESET_MASK);
+}
+
+/*********************************************************************
+ * Get control of the DMA channel
+ **********************************************************************/
+static unsigned long big_sur_ge_dma_control(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_DMAC_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Set control of the DMA channel
+ **********************************************************************/
+static void big_sur_ge_set_dma_control(xdma_channel * dma, unsigned long control)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address +
+			 BIG_SUR_GE_DMAC_REG_OFFSET, control);
+}
+
+/*********************************************************************
+ * Get the status of the DMA channel
+ *********************************************************************/
+static unsigned long big_sur_ge_dma_status(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_DMAS_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Set the interrupt status of the DMA channel
+ *********************************************************************/
+static void big_sur_ge_set_intr_status(xdma_channel * dma, unsigned long status)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_IS_REG_OFFSET,
+			 status);
+}
+
+/*********************************************************************
+ * Get the interrupt status of the DMA channel
+ *********************************************************************/
+static unsigned long big_sur_ge_get_intr_status(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_IS_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Set the Interrupt Enable
+ *********************************************************************/
+static void big_sur_ge_set_intr_enable(xdma_channel * dma, unsigned long enable)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_IE_REG_OFFSET,
+			 enable);
+}
+
+/*********************************************************************
+ * Get the Interrupt Enable field to make a check
+ *********************************************************************/
+static unsigned long big_sur_ge_get_intr_enable(xdma_channel * dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address +
+			       BIG_SUR_GE_IE_REG_OFFSET);
+}
+
+/*********************************************************************
+ * Transfer the data over the DMA channel
+ *********************************************************************/
+static void big_sur_ge_dma_transfer(xdma_channel * dma, unsigned long *source,
+			     unsigned long *dest, unsigned long length)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_SA_REG_OFFSET,
+			 (unsigned long) source);
+
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_DA_REG_OFFSET,
+			 (unsigned long) dest);
+
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_LEN_REG_OFFSET,
+			 length);
+}
+
+/*********************************************************************
+ * Get the DMA descriptor
+ *********************************************************************/
+static int big_sur_ge_get_descriptor(xdma_channel * dma,
+			      xbuf_descriptor ** buffer_desc)
+{
+	unsigned long reg_data;
+
+	reg_data = xbuf_descriptor_GetControl(dma->get_ptr);
+	xbuf_descriptor_SetControl(dma->get_ptr, reg_data |
+				   BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+	*buffer_desc = dma->get_ptr;
+
+	dma->get_ptr = xbuf_descriptor_GetNextPtr(dma->get_ptr);
+	dma->active_desc_count--;
+
+	return 0;
+}
+
+/*********************************************************************
+ * Get the packet count
+ *********************************************************************/
+static int big_sur_ge_get_packet_count(xdma_channel * dma)
+{
+	return (BIG_SUR_GE_READ
+		(dma->reg_base_address + BIG_SUR_GE_UPC_REG_OFFSET));
+}
+
+/*********************************************************************
+ * Descrement the packet count
+ *********************************************************************/
+static void big_sur_ge_decr_packet_count(xdma_channel * dma)
+{
+	unsigned long reg_data;
+
+	reg_data =
+	    BIG_SUR_GE_READ(dma->base_address + BIG_SUR_GE_UPC_REG_OFFSET);
+	if (reg_data > 0)
+		BIG_SUR_GE_WRITE(dma->base_address +
+				 BIG_SUR_GE_UPC_REG_OFFSET, 1);
+}
+
+/****************************************************************************
+ * Start of the code that deals with the Packet Fifo
+ *****************************************************************************/
+
+/****************************************************************************
+ * Init the packet fifo
+ ****************************************************************************/
+static int packet_fifo_init(packet_fifo * fifo, u32 reg, u32 data)
+{
+	fifo->reg_base_addr = reg;
+	fifo->data_base_address = data;
+	fifo->ready_status = 1;
+
+	BIG_SUR_GE_FIFO_RESET(fifo);
+
+	return 0;
+}
+
+/****************************************************************************
+ * Packet fifo self test
+ ****************************************************************************/
+static int packet_fifo_self_test(packet_fifo * fifo, unsigned long type)
+{
+	unsigned long reg_data;
+
+	BIG_SUR_GE_FIFO_RESET(fifo);
+	reg_data =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_COUNT_STATUS_REG_OFFSET);
+
+	if (type == BIG_SUR_GE_READ_FIFO_TYPE) {
+		if (reg_data != BIG_SUR_GE_EMPTY_FULL_MASK) {
+			printk(KERN_ERR "Read FIFO not empty \n");
+			return -1;
+		}
+	} else if (!(reg_data & BIG_SUR_GE_EMPTY_FULL_MASK)) {
+		printk(KERN_ERR "Write FIFO is full \n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/****************************************************************************
+ * Packet FIFO read
+ ****************************************************************************/
+static int packet_fifo_read(packet_fifo * fifo, u8 * buffer, unsigned int len)
+{
+	unsigned long fifo_count, word_count, extra_byte;
+	unsigned long *buffer_data = (unsigned long *) buffer;
+
+	fifo_count =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT);
+	fifo_count &= BIG_SUR_GE_COUNT_MASK;
+
+	if ((fifo_count * BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT) < len)
+		return -1;
+
+	word_count = len / BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+	extra_byte = len % BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+
+	for (fifo_count = 0; fifo_count < word_count; fifo_count++)
+		buffer_data[fifo_count] =
+		    BIG_SUR_GE_READ(fifo->reg_base_addr);
+
+	if (extra_byte > 0) {
+		unsigned long last_word;
+		int *extra_buffer_data =
+		    (int *) (buffer_data + word_count);
+
+		last_word = BIG_SUR_GE_READ(fifo->data_base_address);
+		if (extra_byte == 1)
+			extra_buffer_data[0] = (int) (last_word << 24);
+		else if (extra_byte == 2) {
+			extra_buffer_data[0] = (int) (last_word << 24);
+			extra_buffer_data[1] = (int) (last_word << 16);
+		} else if (extra_byte == 3) {
+			extra_buffer_data[0] = (int) (last_word << 24);
+			extra_buffer_data[1] = (int) (last_word << 16);
+			extra_buffer_data[2] = (int) (last_word << 8);
+		}
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+ * Write the data into the packet fifo
+ *****************************************************************************/
+static int packet_fifo_write(packet_fifo * fifo, int *buffer, int len)
+{
+	unsigned long fifo_count, word_count, extra_byte;
+	unsigned long *buffer_data = (unsigned long *) buffer;
+
+	fifo_count =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT);
+	fifo_count &= BIG_SUR_GE_COUNT_MASK;
+
+	word_count = len / BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+	extra_byte = len % BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+
+	/* You should see what the ppc driver does here. It just slobbers */
+	if (extra_byte > 0)
+		if (fifo_count > (word_count + 1)) {
+			printk(KERN_ERR
+			       "No room in the packet send fifo \n");
+			return -1;
+		}
+
+	for (fifo_count = 0; fifo_count < word_count; fifo_count++)
+		BIG_SUR_GE_WRITE(fifo->data_base_address,
+				 buffer_data[fifo_count]);
+
+
+	if (extra_byte > 0) {
+		unsigned long last_word = 0;
+		int *extra_buffer_data =
+		    (int *) (buffer_data + word_count);
+
+		if (extra_byte == 1)
+			last_word = extra_buffer_data[0] << 24;
+		else if (extra_byte == 2)
+			last_word = (extra_buffer_data[0] << 24 |
+				     extra_buffer_data[1] << 16);
+
+		else if (extra_byte == 3)
+			last_word = (extra_buffer_data[0] << 24 |
+				     extra_buffer_data[1] << 16 |
+				     extra_buffer_data[2] << 8);
+
+
+		BIG_SUR_GE_WRITE(fifo->data_base_address, last_word);
+	}
+
+	return 0;
+}
+
+
+/*****************************************************************************
+ * Interrupt handlers: We handle any errors associated with the FIFO.
+ * FIFO is for simple dma case and we do want to handle the simple DMA
+ * case. We dont handle the Scatter Gather DMA for now since it is not working.
+ ******************************************************************************/
+
+/*********************************************************************************
+ * FIFO send for Simple DMA with Interrupts
+ **********************************************************************************/
+static int big_sur_ge_enet_fifo_send(big_sur_ge * emac, u8 * buffer,
+			      unsigned long byte_cnt)
+{
+	unsigned long int_status, reg_data;
+
+	/* Silly checks here that we really dont need */
+	if (!emac->started)
+		return -1;
+
+	if (emac->polled)
+		return -1;
+
+	if (emac->dma_sg)
+		return -1;
+
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+	if (int_status & BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK) {
+		printk(KERN_ERR "Tx FIFO error: Queue is Full \n");
+		return -1;
+	}
+
+	/*
+	 * Write the data to the FIFO in the hardware
+	 */
+	if ((BIG_SUR_GE_GET_COUNT(&emac->send_fifo) *
+	     sizeof(unsigned long)) < byte_cnt) {
+		printk(KERN_ERR "Send FIFO on chip is full \n");
+		return -1;
+	}
+
+	if (big_sur_ge_dma_status(&emac->send_channel) &
+	    BIG_SUR_GE_DMASR_BUSY_MASK) {
+		printk(KERN_ERR "Send channel FIFO engine busy \n");
+		return -1;
+	}
+
+	big_sur_ge_set_dma_control(&emac->send_channel,
+				   BIG_SUR_GE_DMACR_SOURCE_INCR_MASK |
+				   BIG_SUR_GE_DMACR_DEST_LOCAL_MASK |
+				   BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+	big_sur_ge_dma_transfer(&emac->send_channel,
+				(unsigned long *) buffer,
+				(unsigned long *) (emac->base_address +
+						   BIG_SUR_GE_PFIFO_TXDATA_OFFSET),
+				byte_cnt);
+
+	reg_data = big_sur_ge_dma_status(&emac->send_channel);
+	while (reg_data & BIG_SUR_GE_DMASR_BUSY_MASK) {
+		reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+		if (!(reg_data & BIG_SUR_GE_DMASR_BUSY_MASK))
+			break;
+	}
+
+	if ((reg_data & BIG_SUR_GE_DMASR_BUS_ERROR_MASK) ||
+	    (reg_data & BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK)) {
+		printk(KERN_ERR "Send side DMA error \n");
+		return -1;
+	}
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_TPLR_OFFSET,
+			 byte_cnt);
+
+	return 0;
+}
+
+/*************************************************************************
+ * FIFO receive for Simple DMA case
+ *************************************************************************/
+static int big_sur_ge_enet_fifo_recv(big_sur_ge * emac, u8 * buffer,
+			      unsigned long *byte_cnt)
+{
+	unsigned long int_status, reg_data;
+
+	/* Silly checks here that we really dont need */
+	if (!emac->started)
+		return -1;
+
+	if (emac->polled)
+		return -1;
+
+	if (emac->dma_sg)
+		return -1;
+
+	if (*byte_cnt < BIG_SUR_GE_MAX_FRAME_SIZE)
+		return -1;
+
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+	if (int_status & BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK) {
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IISR_OFFSET,
+				 BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK);
+		return -1;
+	}
+
+	if (big_sur_ge_dma_status(&emac->recv_channel) &
+	    BIG_SUR_GE_DMASR_BUSY_MASK) {
+		printk(KERN_ERR "Rx side DMA Engine busy \n");
+		return -1;
+	}
+
+	if (BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_RPLR_OFFSET) ==
+	    0) {
+		printk(KERN_ERR "MAC has the FIFO packet length 0 \n");
+		return -1;
+	}
+
+	/* For the simple DMA case only */
+	big_sur_ge_set_dma_control(&emac->recv_channel,
+				   BIG_SUR_GE_DMACR_DEST_INCR_MASK |
+				   BIG_SUR_GE_DMACR_SOURCE_LOCAL_MASK |
+				   BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+	if (packet_fifo_read(&emac->recv_fifo, buffer,
+			     BIG_SUR_GE_READ(emac->base_address +
+					     BIG_SUR_GE_RPLR_OFFSET)) ==
+	    -1) {
+		printk(KERN_ERR "Not enough space in the FIFO \n");
+		return -1;
+	}
+
+	big_sur_ge_dma_transfer(&emac->recv_channel,
+				(unsigned long *) (emac->base_address +
+						   BIG_SUR_GE_PFIFO_RXDATA_OFFSET),
+				(unsigned long *)
+				buffer,
+				BIG_SUR_GE_READ(emac->base_address +
+						BIG_SUR_GE_RPLR_OFFSET));
+
+	reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+	while (reg_data & BIG_SUR_GE_DMASR_BUSY_MASK) {
+		reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+		if (!(reg_data & BIG_SUR_GE_DMASR_BUSY_MASK))
+			break;
+	}
+
+	if ((reg_data & BIG_SUR_GE_DMASR_BUS_ERROR_MASK) ||
+	    (reg_data & BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK)) {
+		printk(KERN_ERR "DMA Bus Error \n");
+		return -1;
+	}
+
+	*byte_cnt =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_RPLR_OFFSET);
+
+	return 0;
+}
+
+static irqreturn_t big_sur_ge_int_handler(int irq, void *dev_id,
+				   struct pt_regs *regs)
+{
+	struct net_device *netdev = dev_id;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	big_sur_ge *emac = (big_sur_ge *)emac_ptr;
+	void *emac_ptr = &lp->emac;
+	unsigned long int_status;
+
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_DIPR_OFFSET);
+	if (int_status & BIG_SUR_GE_IPIF_EMAC_MASK)
+		handle_fifo_intr(emac);
+
+	if (int_status & BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+		big_sur_ge_check_fifo_recv_error(emac);
+
+	if (int_status & BIG_SUR_GE_IPIF_SEND_FIFO_MASK)
+		big_sur_ge_check_fifo_send_error(emac);
+
+	if (int_status & XIIF_V123B_ERROR_MASK)
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_DISR_OFFSET,
+				 XIIF_V123B_ERROR_MASK);
+
+	return IRQ_HANDLED;
+}
+
+/****************************************************************************
+ * Set the FIFO send handler
+ ***************************************************************************/
+static void big_sur_ge_set_fifo_send_handler(big_sur_ge * emac, void *call_back,
+				      big_sur_fifo_handler function)
+{
+	emac->big_sur_ge_fifo_send_handler = function;
+	emac->fifo_send_ref = call_back;
+}
+
+/****************************************************************************
+ * Set the FIFO recv handler
+ ***************************************************************************/
+static void big_sur_ge_set_fifo_recv_handler(big_sur_ge * emac, void *call_back,
+				      big_sur_fifo_handler function)
+{
+	emac->big_sur_ge_fifo_recv_handler = function;
+	emac->fifo_recv_ref = call_back;
+}
+
+/****************************************************************************
+ * Main Fifo intr handler
+ ***************************************************************************/
+static void handle_fifo_intr(big_sur_ge * emac)
+{
+	unsigned long int_status;
+
+	/* Ack the interrupts asap */
+	int_status =
+	    BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IISR_OFFSET,
+			 int_status);
+
+	/* Process the Rx side */
+	if (int_status & BIG_SUR_GE_EIR_RECV_DONE_MASK) {
+		emac->big_sur_ge_fifo_recv_handler(&emac->fifo_recv_ref);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IISR_OFFSET,
+				 BIG_SUR_GE_EIR_RECV_DONE_MASK);
+	}
+
+	if (int_status & BIG_SUR_GE_EIR_XMIT_DONE_MASK) {
+		/* We dont collect stats and hence we dont need to get status */
+
+		emac->big_sur_ge_fifo_send_handler(emac->fifo_recv_ref);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IISR_OFFSET,
+				 BIG_SUR_GE_EIR_XMIT_DONE_MASK);
+	}
+
+	big_sur_ge_check_mac_error(emac, int_status);
+}
+
+/******************************************************************
+ * Handle the Receive side DMA interrupts. The PPC driver has
+ * callbacks all over the place. This has been eliminated here by
+ * using the following approach:
+ *
+ * The ISR is set to the main interrrupt handler. This will handle
+ * all the interrupts including the ones for DMA. In this main isr,
+ * we determine if we need to call recv or send side intr functions.
+ * Pretty complex but thats the way it is now.
+ *******************************************************************/
+static void big_sur_ge_handle_recv_intr(big_sur_ge * emac)
+{
+	unsigned long int_status;
+
+	int_status = big_sur_ge_get_intr_status(&emac->recv_channel);
+	if (int_status & (BIG_SUR_GE_IXR_PKT_THRESHOLD_MASK |
+			  BIG_SUR_GE_IXR_PKT_WAIT_BOUND_MASK)) {
+		u32 num_packets;
+		u32 num_processed;
+		u32 num_buffers;
+		u32 num_bytes;
+		xbuf_descriptor *first_desc_ptr = NULL;
+		xbuf_descriptor *buffer_desc;
+		int is_last = 0;
+
+		/* The number of packets we need to process on the Rx */
+		num_packets =
+		    big_sur_ge_get_packet_count(&emac->recv_channel);
+
+		for (num_processed = 0; num_processed < num_packets;
+		     num_processed++) {
+			while (!is_last) {
+				if (big_sur_ge_get_descriptor
+				    (&emac->recv_channel,
+				     &buffer_desc) == -1)
+					break;
+
+				if (first_desc_ptr == NULL)
+					first_desc_ptr = buffer_desc;
+
+				num_bytes +=
+				    xbuf_descriptor_GetLength(buffer_desc);
+
+				if (xbuf_descriptor_IsLastStatus
+				    (buffer_desc)) {
+					is_last = 1;
+				}
+
+				num_buffers++;
+			}
+
+			/* Number of buffers is always 1 since we dont do SG */
+
+			/*
+			 * Only for SG DMA which is currently not supported. In the
+			 * future, as we have SG channel working, we will code this
+			 * receive side routine. For now, do nothing. This is never
+			 * called from FIFO mode - Manish
+			 */
+			big_sur_ge_decr_packet_count(&emac->recv_channel);
+		}
+	}
+
+	/* Ack the interrupts */
+	big_sur_ge_set_intr_status(&emac->recv_channel, int_status);
+
+	if (int_status & BIG_SUR_GE_IXR_DMA_ERROR_MASK) {
+		/* We need a reset here */
+	}
+
+	big_sur_ge_set_intr_status(&emac->recv_channel, int_status);
+}
+
+/****************************************************************
+ * Handle the send side DMA interrupt
+ ****************************************************************/
+static void big_sur_ge_handle_send_intr(big_sur_ge * emac)
+{
+	unsigned long int_status;
+
+	int_status = big_sur_ge_get_intr_status(&emac->send_channel);
+
+	if (int_status & (BIG_SUR_GE_IXR_PKT_THRESHOLD_MASK |
+			  BIG_SUR_GE_IXR_PKT_WAIT_BOUND_MASK)) {
+		unsigned long num_frames = 0;
+		unsigned long num_processed = 0;
+		unsigned long num_buffers = 0;
+		unsigned long num_bytes = 0;
+		unsigned long is_last = 0;
+		xbuf_descriptor *first_desc_ptr = NULL;
+		xbuf_descriptor *buffer_desc;
+
+		num_frames =
+		    big_sur_ge_get_packet_count(&emac->send_channel);
+
+		for (num_processed = 0; num_processed < num_frames;
+		     num_processed++) {
+			while (!is_last) {
+				if (big_sur_ge_get_descriptor
+				    (&emac->send_channel, &buffer_desc)
+				    == -1) {
+					break;
+				}
+
+				if (first_desc_ptr == NULL)
+					first_desc_ptr = buffer_desc;
+
+				num_bytes +=
+				    xbuf_descriptor_GetLength(buffer_desc);
+				if (xbuf_descriptor_IsLastControl
+				    (buffer_desc))
+					is_last = 1;
+
+				num_buffers++;
+			}
+
+			/*
+			 * Only for SG DMA which is currently not supported. In the
+			 * future, as we have SG channel working, we will code this
+			 * receive side routine. For now, do nothing. This is never
+			 * called from FIFO mode - Manish
+			 */
+			big_sur_ge_decr_packet_count(&emac->send_channel);
+		}
+	}
+
+	/* Ack the interrupts and reset DMA channel if necessary */
+	big_sur_ge_set_intr_status(&emac->send_channel, int_status);
+	if (int_status & BIG_SUR_GE_IXR_DMA_ERROR_MASK) {
+		/* Manish : need reset */
+	}
+
+	big_sur_ge_set_intr_status(&emac->send_channel, int_status);
+}
+
+/*****************************************************************
+ * For now, the MAC address errors dont trigger a update of the
+ * stats. There is no stats framework in place. Hence, we just
+ * check for the errors below and do a reset if needed.
+ *****************************************************************/
+static void big_sur_ge_check_mac_error(big_sur_ge * emac,
+				unsigned long int_status)
+{
+	if (int_status & (BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK |
+			  BIG_SUR_GE_EIR_RECV_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK |
+			  BIG_SUR_GE_EIR_RECV_COLLISION_MASK |
+			  BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK |
+			  BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK |
+			  BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK |
+			  BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK |
+			  BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK)) {
+
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_IIER_OFFSET, 0);
+		/*
+		 * Manish Reset the MAC here
+		 */
+	}
+}
+
+/*****************************************************************
+ * Check for FIFO Recv errors
+ *****************************************************************/
+static void big_sur_ge_check_fifo_recv_error(big_sur_ge * emac)
+{
+	if (BIG_SUR_GE_IS_DEADLOCKED(&emac->recv_fifo)) {
+		unsigned long intr_enable;
+
+		intr_enable =
+		    BIG_SUR_GE_READ(emac->base_address +
+				    XIIF_V123B_DIER_OFFSET);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_DIER_OFFSET,
+				 intr_enable &
+				 ~(BIG_SUR_GE_IPIF_RECV_FIFO_MASK));
+
+	}
+}
+
+/*****************************************************************
+ * Check for FIFO Send errors
+ *****************************************************************/
+static void big_sur_ge_check_fifo_send_error(big_sur_ge * emac)
+{
+	if (BIG_SUR_GE_IS_DEADLOCKED(&emac->send_fifo)) {
+		unsigned long intr_enable;
+
+		intr_enable =
+		    BIG_SUR_GE_READ(emac->base_address +
+				    XIIF_V123B_DIER_OFFSET);
+		BIG_SUR_GE_WRITE(emac->base_address +
+				 XIIF_V123B_DIER_OFFSET,
+				 intr_enable &
+				 ~(BIG_SUR_GE_IPIF_SEND_FIFO_MASK));
+	}
+}
+
+/*****************************************************************
+ * GE unit init
+ ****************************************************************/
+static int big_sur_ge_enet_init(big_sur_ge * emac, unsigned int device_id)
+{
+	unsigned long reg_data;
+	big_sur_ge_config *config;
+	int err;
+
+	/* Assume that the device has been stopped */
+
+	config = big_sur_ge_lookup_config(device_id);
+	if (config == NULL)
+		return -1;
+
+	emac->ready = 0;
+	emac->started = 0;
+	emac->dma_sg = 0;	/* This MAC has no support for Scatter Gather DMA */
+	emac->has_mii = config->has_mii;
+	emac->has_mcast_hash_table = 0;
+	emac->dma_config = config->dma_config;
+
+	/*
+	 * Initialize the FIFO send and recv handlers to the stub handlers.
+	 * We only deal with the FIFO mode of operation since SG is not supported.
+	 * Also, there is no error handler. We try to handle as much of error as
+	 * possible and then return. No error codes also.
+	 */
+
+	emac->base_address = config->base_address;
+
+	if (big_sur_ge_config_dma(emac) == -1)
+		return -1;
+
+	err = big_sur_ge_config_fifo(emac);
+	if (err == -1)
+		return err;
+
+	/* Now, we know that the FIFO initialized successfully. So, set the ready flag */
+	emac->ready = 1;
+
+	/* Do we need a PHY reset here also. It did cause problems on some boards */
+	big_sur_ge_enet_reset(emac);
+
+	/* PHY reset code. Remove if causes a problem on the board */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &= ~(BIG_SUR_GE_ECR_PHY_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+	reg_data |= BIG_SUR_GE_ECR_PHY_ENABLE_MASK;
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	return 0;
+}
+
+/*******************************************************************
+ * Start the GE unit for Tx, Rx and Interrupts
+ *******************************************************************/
+static int big_sur_ge_start(big_sur_ge * emac)
+{
+	unsigned long reg_data;
+
+	/*
+	 * Basic mode of operation is polled and interrupt mode. We disable the polled
+	 * mode for good. We may use the polled mode for Rx NAPI but that does not
+	 * require all the interrupts to be disabled
+	 */
+
+	emac->polled = 0;
+
+	/*
+	 * DMA: Three modes of operation - simple, FIFO, SG. SG is surely not working
+	 * and so is kept off using the dma_sg flag. Simple and FIFO work. But, we may
+	 * not use FIFO at all. So, we enable the interrupts below
+	 */
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DIER_OFFSET,
+			 BIG_SUR_GE_IPIF_FIFO_DFT_MASK |
+			 XIIF_V123B_ERROR_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IIER_OFFSET,
+			 BIG_SUR_GE_EIR_DFT_FIFO_MASK);
+
+	/* Toggle the started flag */
+	emac->started = 1;
+
+	/* Start the Tx and Rx units respectively */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &=
+	    ~(BIG_SUR_GE_ECR_XMIT_RESET_MASK |
+	      BIG_SUR_GE_ECR_RECV_RESET_MASK);
+	reg_data |=
+	    (BIG_SUR_GE_ECR_XMIT_ENABLE_MASK |
+	     BIG_SUR_GE_ECR_RECV_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	return 0;
+}
+
+/**************************************************************************
+ * Stop the GE unit
+ **************************************************************************/
+static int big_sur_ge_stop(big_sur_ge * emac)
+{
+	unsigned long reg_data;
+
+	/* We assume that the device is not already stopped */
+	if (!emac->started)
+		return 0;
+
+	/* Disable the Tx and Rx unit respectively */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &=
+	    ~(BIG_SUR_GE_ECR_XMIT_ENABLE_MASK |
+	      BIG_SUR_GE_ECR_RECV_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	/* Disable the interrupts */
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DGIER_OFFSET, 0);
+
+	/* Toggle the started flag */
+	emac->started = 0;
+
+	return 0;
+}
+
+/************************************************************************
+ * Reset the GE MAC unit
+ *************************************************************************/
+static void big_sur_ge_enet_reset(big_sur_ge * emac)
+{
+	unsigned long reg_data;
+
+	(void) big_sur_ge_stop(emac);
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_RESETR_OFFSET,
+			 XIIF_V123B_RESET_MASK);
+
+	/*
+	 * For now, configure the receiver to not strip off FCS and padding since
+	 * this is not currently supported. In the future, just take the default
+	 * and provide the option for the user to change this behavior.
+	 */
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &=
+	    ~(BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK |
+	      BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK);
+	reg_data &= ~(BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+}
+
+/*************************************************************************
+ * Set the MAC address of the GE mac unit
+ *************************************************************************/
+static int big_sur_ge_set_mac_address(big_sur_ge * emac, unsigned char *addr)
+{
+	unsigned long mac_addr = 0;
+
+	/* Device is started and so mac address must be set */
+	if (emac->started == 1)
+		return 0;
+
+	mac_addr = ((addr[0] << 8) | addr[1]);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_SAH_OFFSET,
+			 mac_addr);
+
+	mac_addr |= ((addr[2] << 24) | (addr[3] << 16) |
+		     (addr[4] << 8) | addr[5]);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_SAL_OFFSET,
+			 mac_addr);
+
+	return 0;
+}
+
+/****************************************************************************
+ * Get the MAC address of the GE MAC unit
+ ***************************************************************************/
+static void big_sur_ge_get_mac_unit(big_sur_ge * emac, unsigned int *addr)
+{
+	unsigned long mac_addr_hi, mac_addr_lo;
+
+	mac_addr_hi =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_SAH_OFFSET);
+	mac_addr_lo =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_SAL_OFFSET);
+
+	addr[0] = (mac_addr_hi >> 8);
+	addr[1] = mac_addr_hi;
+
+	addr[2] = (mac_addr_lo >> 24);
+	addr[3] = (mac_addr_lo >> 16);
+	addr[4] = (mac_addr_lo >> 8);
+	addr[5] = mac_addr_lo;
+}
+
+/*********************************************************************************
+ * Configure the GE MAC for DMA capabilities. Not for Scatter Gather, only Simple
+ *********************************************************************************/
+static int big_sur_ge_config_dma(big_sur_ge * emac)
+{
+	if (big_sur_ge_dma_init(&emac->recv_channel, emac->base_address +
+				BIG_SUR_GE_DMA_RECV_OFFSET) == -1) {
+		printk(KERN_ERR "Could not initialize the DMA unit  \n");
+		return -1;
+	}
+
+	if (big_sur_ge_dma_init(&emac->send_channel, emac->base_address +
+				BIG_SUR_GE_DMA_SEND_OFFSET) == -1) {
+		printk(KERN_ERR "Could not initialize the DMA unit  \n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ * Configure the FIFO for simple DMA
+ ******************************************************************************/
+static int big_sur_ge_config_fifo(big_sur_ge * emac)
+{
+	int err = 0;
+
+	err = packet_fifo_init(&emac->recv_fifo, emac->base_address +
+			       BIG_SUR_GE_PFIFO_RXREG_OFFSET,
+			       emac->base_address +
+			       BIG_SUR_GE_PFIFO_RXDATA_OFFSET);
+
+	if (err == -1) {
+		printk(KERN_ERR
+		       "Could not initialize Rx packet FIFO for Simple DMA \n");
+		return err;
+	}
+
+	err = packet_fifo_init(&emac->send_fifo, emac->base_address +
+			       BIG_SUR_GE_PFIFO_TXREG_OFFSET,
+			       emac->base_address +
+			       BIG_SUR_GE_PFIFO_TXDATA_OFFSET);
+
+	if (err == -1) {
+		printk(KERN_ERR
+		       "Could not initialize Tx packet FIFO for Simple DMA \n");
+	}
+
+	return err;
+}
+
+#define BIG_SUR_GE_NUM_INSTANCES	2
+
+
+/**********************************************************************************
+ * Look up the config of the MAC
+ **********************************************************************************/
+static big_sur_ge_config *big_sur_ge_lookup_config(unsigned int device_id)
+{
+	big_sur_ge_config *config = NULL;
+	int i = 0;
+
+	for (i = 0; i < BIG_SUR_GE_NUM_INSTANCES; i++) {
+		/* Manish : Init the config here */
+		break;
+	}
+
+	return config;
+}
+
+typedef struct {
+	unsigned long option;
+	unsigned long mask;
+} option_map;
+
+static option_map option_table[] = {
+	{BIG_SUR_GE_UNICAST_OPTION, BIG_SUR_GE_ECR_UNICAST_ENABLE_MASK},
+	{BIG_SUR_GE_BROADCAST_OPTION, BIG_SUR_GE_ECR_BROAD_ENABLE_MASK},
+	{BIG_SUR_GE_PROMISC_OPTION, BIG_SUR_GE_ECR_PROMISC_ENABLE_MASK},
+	{BIG_SUR_GE_FDUPLEX_OPTION, BIG_SUR_GE_ECR_FULL_DUPLEX_MASK},
+	{BIG_SUR_GE_LOOPBACK_OPTION, BIG_SUR_GE_ECR_LOOPBACK_MASK},
+	{BIG_SUR_GE_MULTICAST_OPTION, BIG_SUR_GE_ECR_MULTI_ENABLE_MASK},
+	{BIG_SUR_GE_FLOW_CONTROL_OPTION, BIG_SUR_GE_ECR_PAUSE_FRAME_MASK},
+	{BIG_SUR_GE_INSERT_PAD_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_PAD_ENABLE_MASK},
+	{BIG_SUR_GE_INSERT_FCS_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_FCS_ENABLE_MASK},
+	{BIG_SUR_GE_INSERT_ADDR_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_ADDR_INSERT_MASK},
+	{BIG_SUR_GE_OVWRT_ADDR_OPTION,
+	 BIG_SUR_GE_ECR_XMIT_ADDR_OVWRT_MASK},
+	{BIG_SUR_GE_STRIP_PAD_OPTION, BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK},
+	{BIG_SUR_GE_STRIP_FCS_OPTION, BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK},
+	{BIG_SUR_GE_STRIP_PAD_FCS_OPTION,
+	 BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK}
+};
+
+#define BIG_SUR_GE_NUM_OPTIONS		(sizeof(option_table) / sizeof(option_map))
+
+/**********************************************************************
+ * Set the options for the GE
+ **********************************************************************/
+static int big_sur_ge_set_options(big_sur_ge * emac, unsigned long option_flag)
+{
+	unsigned long reg_data;
+	unsigned int index;
+
+	/* Assume that the device is stopped before calling this function */
+
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	for (index = 0; index < BIG_SUR_GE_NUM_OPTIONS; index++) {
+		if (option_flag & option_table[index].option)
+			reg_data |= option_table[index].mask;
+		else
+			reg_data &= ~(option_table[index].mask);
+
+	}
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET,
+			 reg_data);
+
+	/* No polled option */
+	emac->polled = 0;
+
+	return 0;
+}
+
+/*******************************************************
+ * Get the options from the GE
+ *******************************************************/
+static unsigned long big_sur_ge_get_options(big_sur_ge * emac)
+{
+	unsigned long option_flag = 0, reg_data;
+	unsigned int index;
+
+	reg_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+
+	for (index = 0; index < BIG_SUR_GE_NUM_OPTIONS; index++) {
+		if (option_flag & option_table[index].option)
+			reg_data |= option_table[index].mask;
+	}
+
+	/* No polled mode */
+
+	return option_flag;
+}
+
+/********************************************************
+ * Set the Inter frame gap
+ ********************************************************/
+static int big_sur_ge_set_frame_gap(big_sur_ge * emac, int part1, int part2)
+{
+	unsigned long config;
+
+	/* Assume that the device is stopped before calling this */
+
+	config = ((part1 << BIG_SUR_GE_IFGP_PART1_SHIFT) |
+		  (part2 << BIG_SUR_GE_IFGP_PART2_SHIFT));
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_IFGP_OFFSET,
+			 config);
+
+	return 0;
+}
+
+/********************************************************
+ * Get the Inter frame gap
+ ********************************************************/
+static void big_sur_ge_get_frame_gap(big_sur_ge * emac, int *part1, int *part2)
+{
+	unsigned long config;
+
+	config =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_IFGP_OFFSET);
+	*part1 =
+	    ((config & BIG_SUR_GE_IFGP_PART1_SHIFT) >>
+	     BIG_SUR_GE_IFGP_PART1_SHIFT);
+	*part2 =
+	    ((config & BIG_SUR_GE_IFGP_PART2_SHIFT) >>
+	     BIG_SUR_GE_IFGP_PART2_SHIFT);
+}
+
+/*******************************************************************
+ * PHY specific functions for the MAC
+ *******************************************************************/
+#define BIG_SUR_GE_MAX_PHY_ADDR		32
+#define BIG_SUR_GE_MAX_PHY_REG		32
+
+/*******************************************************************
+ * Read the PHY reg
+ *******************************************************************/
+static int big_sur_ge_phy_read(big_sur_ge * emac, unsigned long addr,
+			unsigned long reg_num, unsigned int *data)
+{
+	unsigned long mii_control, mii_data;
+
+	if (!emac->has_mii)
+		return -1;
+
+	mii_control =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET);
+	if (mii_control & BIG_SUR_GE_MGTCR_START_MASK) {
+		printk(KERN_ERR "PHY busy \n");
+		return -1;
+	}
+
+	mii_control = (addr << BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT);
+	mii_control |= (reg_num << BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT);
+	mii_control |=
+	    (BIG_SUR_GE_MGTCR_RW_NOT_MASK | BIG_SUR_GE_MGTCR_START_MASK |
+	     BIG_SUR_GE_MGTCR_MII_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET,
+			 mii_control);
+
+	while (mii_control & BIG_SUR_GE_MGTCR_START_MASK)
+		if (!(mii_control & BIG_SUR_GE_MGTCR_START_MASK))
+			break;
+
+	mii_data =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTDR_OFFSET);
+	*data = (unsigned int) mii_data;
+
+	return 0;
+}
+
+/**********************************************************************
+ * Write to the PHY register
+ **********************************************************************/
+static int big_sur_ge_phy_write(big_sur_ge * emac, unsigned long addr,
+			 unsigned long reg_num, unsigned int data)
+{
+	unsigned long mii_control;
+
+	if (!emac->has_mii)
+		return -1;
+
+	mii_control =
+	    BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET);
+	if (mii_control & BIG_SUR_GE_MGTCR_START_MASK) {
+		printk(KERN_ERR "PHY busy \n");
+		return -1;
+	}
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTDR_OFFSET,
+			 (unsigned long) data);
+
+	mii_control = (addr << BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT);
+	mii_control |= (reg_num << BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT);
+	mii_control |=
+	    (BIG_SUR_GE_MGTCR_START_MASK |
+	     BIG_SUR_GE_MGTCR_MII_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET,
+			 mii_control);
+
+	while (mii_control & BIG_SUR_GE_MGTCR_START_MASK)
+		if (!(mii_control & BIG_SUR_GE_MGTCR_START_MASK))
+			break;
+
+	return 0;
+}
+
+
+
+
+
+
+/********************************************************************
+ * The hardware dependent part of the driver begins here
+ ********************************************************************/
+
+
+/*******************************************************************
+ * Reset the GE system
+ *******************************************************************/
+static void big_sur_ge_reset(struct net_device *netdev, DUPLEX duplex)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *skb;
+	unsigned long options;
+	int ifcfg1, ifcfg2;
+
+	/* Stop the queue */
+	netif_stop_queue(netdev);
+
+	big_sur_ge_get_frame_gap(&lp->emac, &ifcfg1, &ifcfg2);
+	options = big_sur_ge_get_options(&lp->emac);
+	switch (duplex) {
+	case HALF_DUPLEX:
+		options &= ~(BIG_SUR_GE_FDUPLEX_OPTION);
+		break;
+
+	case FULL_DUPLEX:
+		options |= BIG_SUR_GE_FDUPLEX_OPTION;
+		break;
+
+	case UNKNOWN:
+		break;
+	}
+
+	/* There is no support for SG DMA in a 100 Mpbs NIC */
+
+	big_sur_ge_enet_reset(&lp->emac);
+
+	/* Set the necessary options for the MAC unit */
+	big_sur_ge_set_mac_address(&lp->emac, netdev->dev_addr);
+	big_sur_ge_set_frame_gap(&lp->emac, ifcfg1, ifcfg2);
+	big_sur_ge_set_options(&lp->emac, options);
+
+	(void) big_sur_ge_start(&lp->emac);
+
+	spin_lock_irq(&lp->lock);
+	skb = lp->saved_skb;
+	lp->saved_skb = NULL;
+	spin_unlock_irq(&lp->lock);
+
+	if (skb)
+		dev_kfree_skb(skb);
+
+	/* Wake the queue */
+	netif_wake_queue(netdev);
+}
+
+/********************************************************************
+ * Get the PHY status
+ *******************************************************************/
+static int big_sur_ge_get_phy_status(struct net_device *netdev,
+				     DUPLEX * duplex, int *linkup)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned int reg_data;
+	int err = 0;
+
+	err =
+	    big_sur_ge_phy_read(&lp->emac, lp->mii_addr, MII_BMCR,
+				&reg_data);
+	if (err == -1) {
+		printk(KERN_ERR "%s: Could not read PHY control register",
+		       netdev->name);
+		return err;
+	}
+
+	if (!(reg_data & BMCR_ANENABLE)) {
+		if (reg_data & BMCR_FULLDPLX)
+			*duplex = FULL_DUPLEX;
+		else
+			*duplex = HALF_DUPLEX;
+	} else {
+		unsigned int advertise, partner, neg;
+
+		err =
+		    big_sur_ge_phy_read(&lp->emac, lp->mii_addr,
+					MII_ADVERTISE, &advertise);
+		if (err == -1) {
+			printk(KERN_ERR
+			       "%s: Could not read PHY control register",
+			       netdev->name);
+			return err;
+		}
+
+		err =
+		    big_sur_ge_phy_read(&lp->emac, lp->mii_addr, MII_LPA,
+					&partner);
+		if (err == -1) {
+			printk(KERN_ERR
+			       "%s: Could not read PHY control register",
+			       netdev->name);
+			return err;
+		}
+
+		neg = advertise & partner & ADVERTISE_ALL;
+		if (neg & ADVERTISE_100FULL)
+			*duplex = FULL_DUPLEX;
+		else if (neg & ADVERTISE_100HALF)
+			*duplex = HALF_DUPLEX;
+		else if (neg & ADVERTISE_10FULL)
+			*duplex = FULL_DUPLEX;
+		else
+			*duplex = HALF_DUPLEX;
+
+		err =
+		    big_sur_ge_phy_read(&lp->emac, lp->mii_addr, MII_BMSR,
+					&reg_data);
+		if (err == -1) {
+			printk(KERN_ERR
+			       "%s: Could not read PHY control register",
+			       netdev->name);
+			return err;
+		}
+
+		*linkup = (reg_data & BMSR_LSTATUS) != 0;
+
+	}
+	return 0;
+}
+
+/************************************************************
+ * Poll the MII for duplex and link status
+ ***********************************************************/
+static void big_sur_ge_poll_mii(unsigned long data)
+{
+	struct net_device *netdev = (struct net_device *) data;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned long options;
+	DUPLEX mac_duplex, phy_duplex;
+	int phy_carrier, netif_carrier;
+
+	if (big_sur_ge_get_phy_status(netdev, &phy_duplex, &phy_carrier) ==
+	    -1) {
+		printk(KERN_ERR "%s: Terminating link monitoring.\n",
+		       netdev->name);
+		return;
+	}
+
+	options = big_sur_ge_get_options(&lp->emac);
+	if (options & BIG_SUR_GE_FDUPLEX_OPTION)
+		mac_duplex = FULL_DUPLEX;
+	else
+		mac_duplex = HALF_DUPLEX;
+
+	if (mac_duplex != phy_duplex) {
+		disable_irq(netdev->irq);
+		big_sur_ge_reset(netdev, phy_duplex);
+		enable_irq(netdev->irq);
+	}
+
+	netif_carrier = netif_carrier_ok(netdev) != 0;
+
+	if (phy_carrier != netif_carrier) {
+		if (phy_carrier) {
+			printk(KERN_INFO "%s: Link carrier restored.\n",
+			       netdev->name);
+			netif_carrier_on(netdev);
+		} else {
+			printk(KERN_INFO "%s: Link carrier lost.\n",
+			       netdev->name);
+			netif_carrier_off(netdev);
+		}
+	}
+
+	/* Set up the timer so we'll get called again in 2 seconds. */
+	lp->phy_timer.expires = jiffies + 2 * HZ;
+	add_timer(&lp->phy_timer);
+}
+
+/**************************************************************
+ * Open the network interface
+ *************************************************************/
+static int big_sur_ge_open(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned long options;
+	DUPLEX phy_duplex, mac_duplex;
+	int phy_carrier, retval;
+
+	(void) big_sur_ge_stop(&lp->emac);
+
+	if (big_sur_ge_set_mac_address(&lp->emac, netdev->dev_addr) == -1) {
+		printk(KERN_ERR "%s: Could not set MAC address.\n",
+		       netdev->name);
+		return -EIO;
+	}
+
+	options = big_sur_ge_get_options(&lp->emac);
+
+	retval =
+	    request_irq(netdev->irq, &big_sur_ge_int_handler, 0,
+			netdev->name, netdev);
+	if (retval) {
+		printk(KERN_ERR
+		       "%s: Could not allocate interrupt %d.\n",
+		       netdev->name, netdev->irq);
+
+		return retval;
+	}
+
+	if (!
+	    (big_sur_ge_get_phy_status(netdev, &phy_duplex, &phy_carrier)))
+	{
+		if (options & BIG_SUR_GE_FDUPLEX_OPTION)
+			mac_duplex = FULL_DUPLEX;
+		else
+			mac_duplex = HALF_DUPLEX;
+
+		if (mac_duplex != phy_duplex) {
+			switch (phy_duplex) {
+			case HALF_DUPLEX:
+				options &= ~(BIG_SUR_GE_FDUPLEX_OPTION);
+				break;
+			case FULL_DUPLEX:
+				options |= BIG_SUR_GE_FDUPLEX_OPTION;
+				break;
+			case UNKNOWN:
+				break;
+			}
+
+			big_sur_ge_set_options(&lp->emac, options);
+		}
+	}
+
+	if (big_sur_ge_start(&lp->emac) == -1) {
+		printk(KERN_ERR "%s: Could not start device.\n",
+		       netdev->name);
+		free_irq(netdev->irq, netdev);
+		return -EBUSY;
+	}
+
+	netif_start_queue(netdev);
+
+	lp->phy_timer.expires = jiffies + 2 * HZ;
+	lp->phy_timer.data = (unsigned long) netdev;
+	lp->phy_timer.function = &big_sur_ge_poll_mii;
+	add_timer(&lp->phy_timer);
+
+	return 0;
+}
+
+/*********************************************************************
+ * Close the network device interface
+ *********************************************************************/
+static int big_sur_ge_close(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+
+	del_timer_sync(&lp->phy_timer);
+	netif_stop_queue(netdev);
+
+	free_irq(netdev->irq, netdev);
+
+	if (big_sur_ge_stop(&lp->emac) == -1) {
+		printk(KERN_ERR "%s: Could not stop device.\n",
+		       netdev->name);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*********************************************************************
+ * Get the network device stats. For now, do nothing
+ *********************************************************************/
+static struct net_device_stats *big_sur_ge_get_stats(struct net_device
+						     *netdev)
+{
+	/* Do nothing */
+	return (struct net_device_stats *) 0;
+}
+
+/********************************************************************
+ * FIFO send for a packet that needs to be transmitted
+ ********************************************************************/
+static int big_sur_ge_fifo_send(struct sk_buff *orig_skb,
+				struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *new_skb;
+	unsigned int len, align;
+
+	netif_stop_queue(netdev);
+	len = orig_skb->len;
+
+	if (!(new_skb = dev_alloc_skb(len + 4))) {
+		dev_kfree_skb(orig_skb);
+		printk(KERN_ERR
+		       "%s: Could not allocate transmit buffer.\n",
+		       netdev->name);
+		netif_wake_queue(netdev);
+		return -EBUSY;
+	}
+
+	align = 4 - ((unsigned long) new_skb->data & 3);
+	if (align != 4)
+		skb_reserve(new_skb, align);
+
+	skb_put(new_skb, len);
+	memcpy(new_skb->data, orig_skb->data, len);
+
+	dev_kfree_skb(orig_skb);
+
+	lp->saved_skb = new_skb;
+	if (big_sur_ge_enet_fifo_send(&lp->emac, (u8 *) new_skb->data, len)
+	    == -1) {
+		spin_lock_irq(&lp->lock);
+		new_skb = lp->saved_skb;
+		lp->saved_skb = NULL;
+		spin_unlock_irq(&lp->lock);
+
+		dev_kfree_skb(new_skb);
+		printk(KERN_ERR "%s: Could not transmit buffer.\n",
+		       netdev->name);
+		netif_wake_queue(netdev);
+		return -EIO;
+	}
+	return 0;
+}
+
+/**********************************************************************
+ * Call the fifo send handler
+ **********************************************************************/
+static void big_sur_ge_fifo_send_handler(void *callback)
+{
+	struct net_device *netdev = (struct net_device *) callback;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *skb;
+
+	spin_lock_irq(&lp->lock);
+	skb = lp->saved_skb;
+	lp->saved_skb = NULL;
+	spin_unlock_irq(&lp->lock);
+
+	if (skb)
+		dev_kfree_skb(skb);
+
+	netif_wake_queue(netdev);
+}
+
+/**********************************************************************
+ * Handle the timeout of the ethernet device
+ **********************************************************************/
+static void big_sur_ge_tx_timeout(struct net_device *netdev)
+{
+	printk
+	    ("%s: Exceeded transmit timeout of %lu ms.	Resetting mac.\n",
+	     netdev->name, TX_TIMEOUT * 1000UL / HZ);
+
+	disable_irq(netdev->irq);
+	big_sur_ge_reset(netdev, UNKNOWN);
+	enable_irq(netdev->irq);
+}
+
+/*********************************************************************
+ * When in FIFO mode, the callback function for packets received
+ *********************************************************************/
+static void big_sur_ge_fifo_recv_handler(void *callback)
+{
+	struct net_device *netdev = (struct net_device *) callback;
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *skb;
+	unsigned long len = BIG_SUR_GE_MAX_FRAME_SIZE;
+	unsigned int align;
+
+	if (!(skb = dev_alloc_skb(len + 4))) {
+		printk(KERN_ERR "%s: Could not allocate receive buffer.\n",
+		       netdev->name);
+		return;
+	}
+
+	align = 4 - ((unsigned long) skb->data & 3);
+	if (align != 4)
+		skb_reserve(skb, align);
+
+	if (big_sur_ge_enet_fifo_recv(&lp->emac, (u8 *) skb->data, &len) ==
+	    -1) {
+		dev_kfree_skb(skb);
+
+		printk(KERN_ERR "%s: Could not receive buffer \n",
+		       netdev->name);
+		netdev->tx_timeout = NULL;
+		big_sur_ge_reset(netdev, UNKNOWN);
+		netdev->tx_timeout = big_sur_ge_tx_timeout;
+	}
+
+	skb_put(skb, len);	/* Tell the skb how much data we got. */
+	skb->dev = netdev;	/* Fill out required meta-data. */
+	skb->protocol = eth_type_trans(skb, netdev);
+
+	netif_rx(skb);		/* Send the packet upstream. */
+}
+
+/*********************************************************************
+ * Set the Multicast Hash list
+ *********************************************************************/
+static void big_sur_ge_set_multicast_hash_list(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned long options;
+
+	disable_irq(netdev->irq);
+	local_bh_disable();
+
+	(void) big_sur_ge_stop(&lp->emac);
+	options = big_sur_ge_get_options(&lp->emac);
+	options &=
+	    ~(BIG_SUR_GE_PROMISC_OPTION | BIG_SUR_GE_MULTICAST_OPTION);
+
+	/* Do nothing for now */
+
+	(void) big_sur_ge_start(&lp->emac);
+	local_bh_enable();
+	enable_irq(netdev->irq);
+}
+
+/***********************************************************************
+ * IOCTL support
+ ***********************************************************************/
+static int big_sur_ge_ioctl(struct net_device *netdev, struct ifreq *rq,
+			    int cmd)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct mii_ioctl_data *data =
+	    (struct mii_ioctl_data *) &rq->ifr_data;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
+	case SIOCDEVPRIVATE:	/* for binary compat, remove in 2.5 */
+		data->phy_id = lp->mii_addr;
+
+	case SIOCGMIIREG:	/* Read MII PHY register. */
+	case SIOCDEVPRIVATE + 1:	/* for binary compat, remove in 2.5 */
+		if (data->phy_id > 31 || data->reg_num > 31)
+			return -ENXIO;
+
+		del_timer_sync(&lp->phy_timer);
+
+		if (big_sur_ge_phy_read(&lp->emac, data->phy_id,
+					data->reg_num,
+					&data->val_out) == -1) {
+			printk(KERN_ERR "%s: Could not read from PHY",
+			       netdev->name);
+			return -EBUSY;
+		}
+
+		lp->phy_timer.expires = jiffies + 2 * HZ;
+		add_timer(&lp->phy_timer);
+
+		return 0;
+
+	case SIOCSMIIREG:	/* Write MII PHY register. */
+	case SIOCDEVPRIVATE + 2:	/* for binary compat, remove in 2.5 */
+		if (data->phy_id > 31 || data->reg_num > 31)
+			return -ENXIO;
+
+		del_timer_sync(&lp->phy_timer);
+
+		if (big_sur_ge_phy_write
+		    (&lp->emac, data->phy_id, data->reg_num,
+		     data->val_in) == -1) {
+			printk(KERN_ERR "%s: Could not write to PHY",
+			       netdev->name);
+			return -EBUSY;
+		}
+
+		lp->phy_timer.expires = jiffies + 2 * HZ;
+		add_timer(&lp->phy_timer);
+
+		return 0;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/*****************************************************************
+ * Get the config from the config table
+ *****************************************************************/
+static big_sur_ge_config *big_sur_ge_get_config(int index)
+{
+	/* Manish */
+	return (big_sur_ge_config *) 0;
+}
+
+/*****************************************************************
+ * Release the network device structure
+ *****************************************************************/
+static void big_sur_ge_remove_head(void)
+{
+	struct net_device *netdev;
+	struct big_sur_ge_enet *lp;
+	big_sur_ge_config *config;
+
+	spin_lock(&dev_lock);
+	netdev = dev_list;
+	lp = netdev->priv;
+
+	spin_unlock(&dev_lock);
+
+	config = big_sur_ge_get_config(lp->index);
+	iounmap((void *) config->base_address);
+	config->base_address = lp->save_base_address;
+
+	if (lp->saved_skb)
+		dev_kfree_skb(lp->saved_skb);
+	kfree(lp);
+
+	unregister_netdev(netdev);
+	kfree(netdev);
+}
+
+/*****************************************************************
+ * Initial Function to probe the network interface
+ *****************************************************************/
+static int __init big_sur_ge_probe(int index)
+{
+	static const unsigned long remap_size =
+	    BIG_SUR_GE_EMAC_0_HIGHADDR - BIG_SUR_GE_EMAC_0_BASEADDR + 1;
+	struct net_device *netdev;
+	struct big_sur_ge_enet *lp;
+	big_sur_ge_config *config;
+	unsigned int irq;
+	unsigned long maddr;
+	goto err;
+
+	switch (index) {
+	case 0:
+		irq = (31 - BIG_SUR_GE_INTC_0_EMAC_0_VEC_ID);
+		break;
+	case 1:
+		irq = (31 - BIG_SUR_GE_INTC_1_EMAC_1_VEC_ID);
+		break;
+	case 2:
+		irq = (31 - BIG_SUR_GE_INTC_2_EMAC_2_VEC_ID);
+		break;
+	default:
+		err = -ENODEV;
+		goto out;
+	}
+
+	config = big_sur_ge_get_config(index);
+	if (!config) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	netdev = alloc_etherdev(sizeof(big_sur_ge_config));
+
+	if (!netdev) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	SET_MODULE_OWNER(netdev);
+
+	netdev->irq = irq;
+
+	lp = (struct big_sur_ge_enet *) netdev->priv;
+	memset(lp, 0, sizeof(struct big_sur_ge_enet));
+	spin_lock_init(&lp->lock);
+	spin_lock(&dev_lock);
+	lp->next_dev = dev_list;
+	dev_list = netdev;
+	spin_unlock(&dev_lock);
+
+	lp->save_base_address = config->base_address;
+	config->base_address =
+	    (unsigned long) ioremap(lp->save_base_address, remap_size);
+	if (!config->base_address) {
+		err = -ENOMEM;
+		goto out_unlock;
+	}
+
+	if (big_sur_ge_enet_init(&lp->emac, config->device_id) == -1) {
+		printk(KERN_ERR "%s: Could not initialize device.\n",
+		       netdev->name);
+		err = -ENODEV;
+		goto out_unmap;
+	}
+
+	/* Manish: dev_addr value */
+	memcpy(netdev->dev_addr, big_sur_mac_addr_base, 6);
+	if (big_sur_ge_set_mac_address(&lp->emac, netdev->dev_addr) == -1) {
+		printk(KERN_ERR "%s: Could not set MAC address.\n",
+		       netdev->name);
+		err = -EIO;
+		goto out_unmap;
+	}
+
+	/*
+	 * There is no Scatter Gather support but there is a Simple DMA support
+	 */
+	big_sur_ge_set_fifo_recv_handler(&lp->emac, netdev,
+					 big_sur_ge_fifo_recv_handler);
+	big_sur_ge_set_fifo_send_handler(&lp->emac, netdev,
+					 big_sur_ge_fifo_send_handler);
+	netdev->hard_start_xmit = big_sur_ge_fifo_send;
+
+	lp->mii_addr = 0xFF;
+
+	for (maddr = 0; maddr < 31; maddr++) {
+		unsigned int reg_data;
+
+		if (big_sur_ge_phy_read
+		    (&lp->emac, maddr, MII_BMCR, &reg_data) == 0) {
+			lp->mii_addr = maddr;
+			break;
+		}
+	}
+
+	if (lp->mii_addr == 0xFF) {
+		lp->mii_addr = 0;
+		printk(KERN_WARNING
+		       "%s: No PHY detected.  Assuming a PHY at address %d.\n",
+		       netdev->name, lp->mii_addr);
+	}
+
+	netdev->open = big_sur_ge_open;
+	netdev->stop = big_sur_ge_close;
+	netdev->get_stats = big_sur_ge_get_stats;	/* Does nothing */
+	netdev->do_ioctl = big_sur_ge_ioctl;
+	netdev->tx_timeout = big_sur_ge_tx_timeout;
+	netdev->watchdog_timeo = TX_TIMEOUT;
+
+	err = register_netdev(netdev))
+	if (!err)
+		goto out_unmap;
+
+	printk(KERN_INFO "%s: PMC-Sierra Big Sur Ethernet Device %d  at 0x%08X "
+	       "mapped to 0x%08X, irq=%d\n", netdev->name, index,
+	       lp->save_base_address, config->base_address, netdev->irq);
+
+	return ret;
+
+out_unmap:
+	iounmap(config->base_address);
+
+out_unlock:
+	big_sur_ge_remove_head();
+
+out:
+	return ret;
+}
+
+static int __init big_sur_ge_init(void)
+{
+	int index = 0;
+
+	while (big_sur_ge_probe(index++) == 0);
+
+	return (index > 1) ? 0 : -ENODEV;
+}
+
+static void __exit big_sur_ge_cleanup(void)
+{
+	while (dev_list)
+		big_sur_ge_remove_head();
+}
+
+module_init(big_sur_ge_init);
+module_exit(big_sur_ge_cleanup);
+
+MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
+MODULE_DESCRIPTION("PMC-Sierra Big Sur Ethernet MAC Driver");
+MODULE_LICENSE("GPL");
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/big_sur_ge.h linux_HEAD/drivers/net/big_sur_ge.h
--- linux-2.6.11.6/drivers/net/big_sur_ge.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/net/big_sur_ge.h	2005-02-17 21:49:47.000000000 +0100
@@ -0,0 +1,714 @@
+/*
+ * drivers/net/big_sur_ge.h - Driver for PMC-Sierra Big Sur
+ * ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef	__BIG_SUR_GE_H__
+#define	__BIG_SUR_GE_H__
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#define	BIG_SUR_DEVICE_NAME	"big sur"
+#define	BIG_SUR_DEVICE_DESC	"Big Sur Ethernet 10/100 MAC"
+
+#define BIG_SUR_GE_BASE			0xbb000000
+
+#define	BIG_SUR_GE_WRITE(ofs,data)	*(volatile u32 *)(BIG_SUR_GE_BASE+(ofs)) = data
+
+#define	BIG_SUR_GE_READ(ofs)		*(volatile u32 *)(BIG_SUR_GE_BASE+(ofs))
+
+/* Manish : Need to fix these defines later */
+#define	BIG_SUR_GE_EMAC_0_HIGHADDR
+#define	BIG_SUR_GE_EMAC_0_BASEADDR
+#define	BIG_SUR_GE_INTC_0_EMAC_0_VEC_ID		1
+#define	BIG_SUR_GE_INTC_1_EMAC_1_VEC_ID		2
+#define	BIG_SUR_GE_INTC_2_EMAC_2_VEC_ID		3
+#define	BIG_SUR_GE_EMAC_0_ERR_COUNT_EXIST
+#define	BIG_SUR_GE_EMAC_0_DMA_PRESENT
+#define	BIG_SUR_GE_EMAC_0_MII_EXIST
+#define	BIG_SUR_GE_OPB_ETHERNET_0_BASEADDR
+#define	BIG_SUR_GE_EMAC_0_DEVICE_ID
+#define	BIG_SUR_GE_OPB_ETHERNET_0_ERR_COUNT_EXIST
+#define	BIG_SUR_GE_OPB_ETHERNET_0_DMA_PRESENT
+#define	BIG_SUR_GE_OPB_ETHERNET_0_MII_EXIST
+#define	BIG_SUR_GE_OPB_ETHERNET_0_DEVICE_ID
+
+#define	BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT	4UL
+/* IPIF specific defines */
+#define XIIF_V123B_DISR_OFFSET     0UL  /* device interrupt status register */
+#define XIIF_V123B_DIPR_OFFSET     4UL  /* device interrupt pending register */
+#define XIIF_V123B_DIER_OFFSET     8UL  /* device interrupt enable register */
+#define XIIF_V123B_DIIR_OFFSET     24UL /* device interrupt ID register */
+#define XIIF_V123B_DGIER_OFFSET    28UL /* device global interrupt enable reg */
+#define XIIF_V123B_IISR_OFFSET     32UL /* IP interrupt status register */
+#define XIIF_V123B_IIER_OFFSET     40UL /* IP interrupt enable register */
+#define XIIF_V123B_RESETR_OFFSET   64UL /* reset register */
+#define XIIF_V123B_RESET_MASK             0xAUL
+#define	XIIF_V123B_ERROR_MASK		0x1UL
+
+/* defines */
+#define BIG_SUR_GE_UNICAST_OPTION        	0x00000001
+#define BIG_SUR_GE_BROADCAST_OPTION      	0x00000002
+#define BIG_SUR_GE_PROMISC_OPTION        	0x00000004
+#define BIG_SUR_GE_FDUPLEX_OPTION        	0x00000008
+#define BIG_SUR_GE_POLLED_OPTION         	0x00000010
+#define BIG_SUR_GE_LOOPBACK_OPTION       	0x00000020
+#define BIG_SUR_GE_FLOW_CONTROL_OPTION   	0x00000080
+#define BIG_SUR_GE_INSERT_PAD_OPTION     	0x00000100
+#define BIG_SUR_GE_INSERT_FCS_OPTION     	0x00000200
+#define BIG_SUR_GE_INSERT_ADDR_OPTION    	0x00000400
+#define BIG_SUR_GE_OVWRT_ADDR_OPTION     	0x00000800
+#define BIG_SUR_GE_STRIP_PAD_FCS_OPTION  	0x00002000
+
+/* Not Supported */
+#define BIG_SUR_GE_MULTICAST_OPTION      	0x00000040
+#define BIG_SUR_GE_FLOW_CONTROL_OPTION   	0x00000080
+#define BIG_SUR_GE_INSERT_PAD_OPTION     	0x00000100
+#define BIG_SUR_GE_INSERT_FCS_OPTION     	0x00000200
+#define BIG_SUR_GE_INSERT_ADDR_OPTION    	0x00000400
+#define BIG_SUR_GE_OVWRT_ADDR_OPTION     	0x00000800
+#define BIG_SUR_GE_STRIP_PAD_OPTION      	0x00001000
+#define BIG_SUR_GE_STRIP_FCS_OPTION     	0x00002000
+
+
+/* Defaults for Interrupt Coalescing in the SG DMA Engine */
+#define BIG_SUR_GE_SGDMA_DFT_THRESHOLD     1   /* Default pkt threshold */
+#define BIG_SUR_GE_SGDMA_MAX_THRESHOLD     255 /* Maximum pkt theshold */
+#define BIG_SUR_GE_SGDMA_DFT_WAITBOUND     5   /* Default pkt wait bound (msec) */
+#define BIG_SUR_GE_SGDMA_MAX_WAITBOUND     1023        /* Maximum pkt wait bound (msec) */
+
+/* Direction */
+#define BIG_SUR_GE_SEND    1
+#define BIG_SUR_GE_RECV    2
+
+/* SG DMA */
+#define BIG_SUR_GE_SGDMA_NODELAY     0 /* start SG DMA immediately */
+#define BIG_SUR_GE_SGDMA_DELAY       1 /* do not start SG DMA */
+
+#define BIG_SUR_GE_CFG_NO_IPIF             0   /* Not supported by the driver */
+#define BIG_SUR_GE_CFG_NO_DMA              1   /* No DMA */
+#define BIG_SUR_GE_CFG_SIMPLE_DMA          2   /* Simple DMA */
+#define BIG_SUR_GE_CFG_DMA_SG              3   /* DMA scatter gather */
+
+#define BIG_SUR_GE_MAC_ADDR_SIZE   6   /* six-byte MAC address */
+#define BIG_SUR_GE_MTU             1500        /* max size of Ethernet frame */
+#define BIG_SUR_GE_HDR_SIZE        14  /* size of Ethernet header */
+#define BIG_SUR_GE_HDR_VLAN_SIZE   18  /* size of Ethernet header with VLAN */
+#define BIG_SUR_GE_TRL_SIZE        4   /* size of Ethernet trailer (FCS) */
+#define BIG_SUR_GE_MAX_FRAME_SIZE  \
+		(BIG_SUR_GE_MTU + BIG_SUR_GE_HDR_SIZE + BIG_SUR_GE_TRL_SIZE)
+
+#define BIG_SUR_GE_MAX_VLAN_FRAME_SIZE  \
+		(BIG_SUR_GE_MTU + BIG_SUR_GE_HDR_VLAN_SIZE + BIG_SUR_GE_TRL_SIZE)
+
+/* Send and Receive buffers */
+#define BIG_SUR_GE_MIN_RECV_BUFS   32  /* minimum # of recv buffers */
+#define BIG_SUR_GE_DFT_RECV_BUFS   64  /* default # of recv buffers */
+
+#define BIG_SUR_GE_MIN_SEND_BUFS   16  /* minimum # of send buffers */
+#define BIG_SUR_GE_DFT_SEND_BUFS   32  /* default # of send buffers */
+
+#define BIG_SUR_GE_MIN_BUFFERS     (BIG_SUR_GE_MIN_RECV_BUFS + BIG_SUR_GE_MIN_SEND_BUFS)
+#define BIG_SUR_GE_DFT_BUFFERS     (BIG_SUR_GE_DFT_RECV_BUFS + BIG_SUR_GE_DFT_SEND_BUFS)
+
+/* Send and Receive Descriptors */
+#define BIG_SUR_GE_MIN_RECV_DESC   16  /* minimum # of recv descriptors */
+#define BIG_SUR_GE_DFT_RECV_DESC   32  /* default # of recv descriptors */
+
+#define BIG_SUR_GE_MIN_SEND_DESC   8   /* minimum # of send descriptors */
+#define BIG_SUR_GE_DFT_SEND_DESC   16  /* default # of send descriptors */
+
+/* FIFO Specific Defines */
+#define BIG_SUR_GE_READ_FIFO_TYPE      0       /* a read FIFO */
+#define BIG_SUR_GE_WRITE_FIFO_TYPE     1       /* a write FIFO */
+#define BIG_SUR_GE_RESET_REG_OFFSET            0UL
+#define BIG_SUR_GE_MODULE_INFO_REG_OFFSET      0UL
+#define BIG_SUR_GE_COUNT_STATUS_REG_OFFSET     4UL
+#define BIG_SUR_GE_RESET_FIFO_MASK             0x0000000A
+#define BIG_SUR_GE_COUNT_MASK                  0x0000FFFF
+#define BIG_SUR_GE_DEADLOCK_MASK               0x20000000
+#define BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK      0x40000000
+#define BIG_SUR_GE_EMPTY_FULL_MASK             0x80000000
+
+#define BIG_SUR_GE_FIFO_RESET(fifo)	\
+	BIG_SUR_GE_WRITE((fifo)->reg_base_addr + BIG_SUR_GE_RESET_REG_OFFSET, BIG_SUR_GE_RESET_FIFO_MASK)
+
+#define	BIG_SUR_GE_GET_COUNT(fifo)	\
+	(BIG_SUR_GE_READ((fifo)->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) & 	\
+							BIG_SUR_GE_COUNT_MASK)
+
+#define	BIG_SUR_GE_IS_ALMOST_EMPTY(fifo)	\
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &	\
+							BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK)
+
+#define	BIG_SUR_GE_IS_ALMOST_FULL(fifo)  \
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK)
+
+#define BIG_SUR_GE_IS_EMPTY(fifo)  \
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_EMPTY_FULL_MASK)
+
+#define BIG_SUR_GE_IS_FULL(fifo)  \
+	(BIG_SUR_GE_READ(fifo->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_EMPTY_FULL_MASK)
+
+#define	BIG_SUR_GE_IS_DEADLOCKED(fifo)	\
+	(BIG_SUR_GE_READ((fifo)->reg_base_addr + BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+							BIG_SUR_GE_DEADLOCK_MASK)
+
+/* Device Config */
+typedef struct _big_sur_ge_config {
+	u16		device_id;
+	u32		base_address;
+	u32		has_counters;
+	u32		has_sg_dma;
+	u8		dma_config;
+	u32		has_mii;
+} big_sur_ge_config;
+
+#define BIG_SUR_GE_SIZE_IN_WORDS           10
+typedef unsigned long xbuf_descriptor[BIG_SUR_GE_SIZE_IN_WORDS];
+
+/* Callback Functions */
+typedef void (*big_sur_sg_handler) (void *callback, xbuf_descriptor *desc, u32 num_desc);
+typedef	void (*big_sur_fifo_handler) (void *callback);
+typedef void (*big_sur_irq_handler) (void *instance);
+
+typedef struct _xdma_channel_tag {
+	u32			reg_base_address;
+        u32                     base_address;
+        u32                     ready;
+        xbuf_descriptor         *put_ptr;
+        xbuf_descriptor         *get_ptr;
+        xbuf_descriptor         *commit_ptr;
+        xbuf_descriptor         *last_ptr;
+
+        u32                     total_desc_count;
+        u32                     active_desc_count;
+} xdma_channel;
+
+typedef struct _packet_fifo {
+        u32             reg_base_addr;
+        u32             ready_status;
+        u32             data_base_address;
+} packet_fifo;
+
+
+/* Big Sur GE driver structure */
+typedef struct _big_sur_ge {
+	u32		base_address;
+	u32		started;
+	u32		ready;
+	u32		polled;
+	u32		dma_sg;
+
+	u8		dma_config;
+	u32		has_mii;
+	u32		has_mcast_hash_table;
+
+	/* For the FIFO and simple DMA case only */
+	packet_fifo	recv_fifo;
+	packet_fifo	send_fifo;
+
+	big_sur_fifo_handler	big_sur_ge_fifo_recv_handler;
+	big_sur_fifo_handler	big_sur_ge_fifo_send_handler;
+
+	void	*fifo_send_ref;
+	void	*fifo_recv_ref;	
+
+	/* For SG DMA only */
+	xdma_channel	recv_channel;
+	xdma_channel	send_channel;
+} big_sur_ge;
+
+/* Offset of the MAC registers from the IPIF base address */
+#define BIG_SUR_GE_REG_OFFSET     0x1100UL
+
+/*
+ * Register offsets for the Ethernet MAC. Each register is 32 bits.
+ */
+#define BIG_SUR_GE_EMIR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x0)        /* EMAC Module ID */
+#define BIG_SUR_GE_ECR_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x4)        /* MAC Control */
+#define BIG_SUR_GE_IFGP_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x8)        /* Interframe Gap */
+#define BIG_SUR_GE_SAH_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0xC)        /* Station addr, high */
+#define BIG_SUR_GE_SAL_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x10)       /* Station addr, low */
+#define BIG_SUR_GE_MGTCR_OFFSET  (BIG_SUR_GE_REG_OFFSET + 0x14)       /* MII mgmt control */
+#define BIG_SUR_GE_MGTDR_OFFSET  (BIG_SUR_GE_REG_OFFSET + 0x18)       /* MII mgmt data */
+#define BIG_SUR_GE_RPLR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x1C)       /* Rx packet length */
+#define BIG_SUR_GE_TPLR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x20)       /* Tx packet length */
+#define BIG_SUR_GE_TSR_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x24)       /* Tx status */
+#define BIG_SUR_GE_RMFC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x28)       /* Rx missed frames */
+#define BIG_SUR_GE_RCC_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x2C)       /* Rx collisions */
+#define BIG_SUR_GE_RFCSEC_OFFSET (BIG_SUR_GE_REG_OFFSET + 0x30)       /* Rx FCS errors */
+#define BIG_SUR_GE_RAEC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x34)       /* Rx alignment errors */
+#define BIG_SUR_GE_TEDC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x38)       /* Transmit excess
+                                                         * deferral cnt */
+/*
+ * Register offsets for the IPIF components
+ */
+#define BIG_SUR_GE_ISR_OFFSET           0x20UL /* Interrupt status */
+
+#define BIG_SUR_GE_DMA_OFFSET           0x2300UL
+#define BIG_SUR_GE_DMA_SEND_OFFSET      (BIG_SUR_GE_DMA_OFFSET + 0x0) /* DMA send channel */
+#define BIG_SUR_GE_DMA_RECV_OFFSET      (BIG_SUR_GE_DMA_OFFSET + 0x40)        /* DMA recv channel */
+
+#define BIG_SUR_GE_PFIFO_OFFSET         0x2000UL
+#define BIG_SUR_GE_PFIFO_TXREG_OFFSET   (BIG_SUR_GE_PFIFO_OFFSET + 0x0)       /* Tx registers */
+#define BIG_SUR_GE_PFIFO_RXREG_OFFSET   (BIG_SUR_GE_PFIFO_OFFSET + 0x10)      /* Rx registers */
+#define BIG_SUR_GE_PFIFO_TXDATA_OFFSET  (BIG_SUR_GE_PFIFO_OFFSET + 0x100)     /* Tx keyhole */
+#define BIG_SUR_GE_PFIFO_RXDATA_OFFSET  (BIG_SUR_GE_PFIFO_OFFSET + 0x200)     /* Rx keyhole */
+
+/*
+ * EMAC Module Identification Register (EMIR)
+ */
+#define BIG_SUR_GE_EMIR_VERSION_MASK    0xFFFF0000UL   /* Device version */
+#define BIG_SUR_GE_EMIR_TYPE_MASK       0x0000FF00UL   /* Device type */
+
+/*
+ * EMAC Control Register (ECR)
+ */
+#define BIG_SUR_GE_ECR_FULL_DUPLEX_MASK         0x80000000   /* Full duplex mode */
+#define BIG_SUR_GE_ECR_XMIT_RESET_MASK          0x40000000   /* Reset transmitter */
+#define BIG_SUR_GE_ECR_XMIT_ENABLE_MASK         0x20000000   /* Enable transmitter */
+#define BIG_SUR_GE_ECR_RECV_RESET_MASK          0x10000000   /* Reset receiver */
+#define BIG_SUR_GE_ECR_RECV_ENABLE_MASK         0x08000000   /* Enable receiver */
+#define BIG_SUR_GE_ECR_PHY_ENABLE_MASK          0x04000000   /* Enable PHY */
+#define BIG_SUR_GE_ECR_XMIT_PAD_ENABLE_MASK     0x02000000   /* Enable xmit pad insert */
+#define BIG_SUR_GE_ECR_XMIT_FCS_ENABLE_MASK     0x01000000   /* Enable xmit FCS insert */
+#define BIG_SUR_GE_ECR_XMIT_ADDR_INSERT_MASK    0x00800000   /* Enable xmit source addr insertion */
+#define BIG_SUR_GE_ECR_XMIT_ERROR_INSERT_MASK   0x00400000   /* Insert xmit error */
+#define BIG_SUR_GE_ECR_XMIT_ADDR_OVWRT_MASK     0x00200000   /* Enable xmit source addr overwrite */
+#define BIG_SUR_GE_ECR_LOOPBACK_MASK            0x00100000   /* Enable internal loopback */
+#define BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK     0x00080000   /* Enable recv pad strip */
+#define BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK     0x00040000   /* Enable recv FCS strip */
+#define BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK   0x00080000   /* Enable recv pad/fcs strip */
+#define BIG_SUR_GE_ECR_UNICAST_ENABLE_MASK      0x00020000   /* Enable unicast addr */
+#define BIG_SUR_GE_ECR_MULTI_ENABLE_MASK        0x00010000   /* Enable multicast addr */
+#define BIG_SUR_GE_ECR_BROAD_ENABLE_MASK        0x00008000   /* Enable broadcast addr */
+#define BIG_SUR_GE_ECR_PROMISC_ENABLE_MASK      0x00004000   /* Enable promiscuous mode */
+#define BIG_SUR_GE_ECR_RECV_ALL_MASK            0x00002000   /* Receive all frames */
+#define BIG_SUR_GE_ECR_RESERVED2_MASK           0x00001000   /* Reserved */
+#define BIG_SUR_GE_ECR_MULTI_HASH_ENABLE_MASK   0x00000800   /* Enable multicast hash */
+#define BIG_SUR_GE_ECR_PAUSE_FRAME_MASK         0x00000400   /* Interpret pause frames */
+#define BIG_SUR_GE_ECR_CLEAR_HASH_MASK          0x00000200   /* Clear hash table */
+#define BIG_SUR_GE_ECR_ADD_HASH_ADDR_MASK       0x00000100  /* Add hash table address */
+
+/*
+ * Interframe Gap Register (IFGR)
+ */
+#define BIG_SUR_GE_IFGP_PART1_MASK         0xF8000000        /* Interframe Gap Part1 */
+#define BIG_SUR_GE_IFGP_PART1_SHIFT        27
+#define BIG_SUR_GE_IFGP_PART2_MASK         0x07C00000        /* Interframe Gap Part2 */
+#define BIG_SUR_GE_IFGP_PART2_SHIFT        22
+
+/*
+ * Station Address High Register (SAH)
+ */
+#define BIG_SUR_GE_SAH_ADDR_MASK           0x0000FFFF        /* Station address high bytes */
+
+/*
+ * Station Address Low Register (SAL)
+ */
+#define BIG_SUR_GE_SAL_ADDR_MASK           0xFFFFFFFF        /* Station address low bytes */
+
+/*
+ * MII Management Control Register (MGTCR)
+ */
+#define BIG_SUR_GE_MGTCR_START_MASK        0x80000000        /* Start/Busy */
+#define BIG_SUR_GE_MGTCR_RW_NOT_MASK       0x40000000        /* Read/Write Not (direction) */
+#define BIG_SUR_GE_MGTCR_PHY_ADDR_MASK     0x3E000000        /* PHY address */
+#define BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT    25  /* PHY address shift */
+#define BIG_SUR_GE_MGTCR_REG_ADDR_MASK     0x01F00000        /* Register address */
+#define BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT    20  /* Register addr shift */
+#define BIG_SUR_GE_MGTCR_MII_ENABLE_MASK   0x00080000        /* Enable MII from EMAC */
+#define BIG_SUR_GE_MGTCR_RD_ERROR_MASK     0x00040000        /* MII mgmt read error */
+
+/*
+ * MII Management Data Register (MGTDR)
+ */
+#define BIG_SUR_GE_MGTDR_DATA_MASK         0x0000FFFF        /* MII data */
+
+/*
+ * Receive Packet Length Register (RPLR)
+ */
+#define BIG_SUR_GE_RPLR_LENGTH_MASK        0x0000FFFF        /* Receive packet length */
+
+/*
+ * Transmit Packet Length Register (TPLR)
+ */
+#define BIG_SUR_GE_TPLR_LENGTH_MASK        0x0000FFFF       /* Transmit packet length */
+
+/*
+ * Transmit Status Register (TSR)
+ */
+#define BIG_SUR_GE_TSR_EXCESS_DEFERRAL_MASK 0x80000000       /* Transmit excess deferral */
+#define BIG_SUR_GE_TSR_FIFO_UNDERRUN_MASK   0x40000000       /* Packet FIFO underrun */
+#define BIG_SUR_GE_TSR_ATTEMPTS_MASK        0x3E000000      /* Transmission attempts */
+#define BIG_SUR_GE_TSR_LATE_COLLISION_MASK  0x01000000      /* Transmit late collision */
+
+/*
+ * Receive Missed Frame Count (RMFC)
+ */
+#define BIG_SUR_GE_RMFC_DATA_MASK          0x0000FFFF
+
+/*
+ * Receive Collision Count (RCC)
+ */
+#define BIG_SUR_GE_RCC_DATA_MASK           0x0000FFFF
+/*
+ * Receive FCS Error Count (RFCSEC)
+ */
+#define BIG_SUR_GE_RFCSEC_DATA_MASK        0x0000FFFF
+
+/*
+ * Receive Alignment Error Count (RALN)
+ */
+#define BIG_SUR_GE_RAEC_DATA_MASK          0x0000FFFF
+
+/*
+ * Transmit Excess Deferral Count (TEDC)
+ */
+#define BIG_SUR_GE_TEDC_DATA_MASK          0x0000FFFF
+
+/*
+ * EMAC Interrupt Registers (Status and Enable) masks. These registers are
+ * part of the IPIF IP Interrupt registers
+ */
+#define BIG_SUR_GE_EIR_XMIT_DONE_MASK         0x00000001     /* Xmit complete */
+#define BIG_SUR_GE_EIR_RECV_DONE_MASK         0x00000002     /* Recv complete */
+#define BIG_SUR_GE_EIR_XMIT_ERROR_MASK        0x00000004     /* Xmit error */
+#define BIG_SUR_GE_EIR_RECV_ERROR_MASK        0x00000008     /* Recv error */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_EMPTY_MASK  0x00000010     /* Xmit status fifo empty */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK  0x00000020     /* Recv length fifo empty */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK   0x00000040     /* Xmit length fifo full */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK   0x00000080     /* Recv length fifo overrun */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK  0x00000100     /* Recv length fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK   0x00000200     /* Xmit status fifo overrun */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK  0x00000400     /* Transmit status fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK   0x00000800     /* Transmit length fifo overrun */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK  0x00001000     /* Transmit length fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_PAUSE_MASK        0x00002000     /* Transmit pause pkt received */
+#define BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK   0x00004000     /* Receive data fifo overrun */
+#define BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK 0x00008000     /* Receive missed frame error */
+#define BIG_SUR_GE_EIR_RECV_COLLISION_MASK    0x00010000     /* Receive collision error */
+#define BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK    0x00020000     /* Receive FCS error */
+#define BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK    0x00040000     /* Receive length field error */
+#define BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK  0x00080000     /* Receive short frame error */
+#define BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK   0x00100000     /* Receive long frame error */
+#define BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK  0x00200000     /* Receive alignment error */
+
+#define	BIG_SUR_GE_READ_REG(base_addr, reg_offset)	\
+		BIG_SUR_GE_READ(base_addr + reg_offset)
+
+#define	BIG_SUR_GE_WRITE_REG(base_addr, reg_offset, data)	\
+		 BIG_SUR_GE_WRITE(base_addr + reg_offset, data)
+
+#define BIG_SUR_GE_CONTROL_REG(base_addr, mask)		\
+		BIG_SUR_GE_WRITE(base_addr + BIG_SUR_GE_ECR_OFFSET, mask)
+
+/* Set the MAC Address */
+#define	big_sur_ge_set_mac(base_addr, address)					\
+{										\
+	u32	mac_addr;							\
+										\
+	mac_addr = ((address[0] << 8) | (address[1]);				\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_SAH_OFFSET, mac_address);		\
+										\
+	mac_addr = ((address[2] << 24) | (address[3] << 16) |			\
+			(address[4] << 8) | address[5]);			\
+										\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_SAL_OFFSET, mac_address);		\
+										\
+}										
+
+/* Enable the MAC unit */
+#define	big_sur_ge_mac_enable(base_address)					\
+{										\
+	u32	control;							\
+	control = BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ECR_OFFSET);		\
+	control &= ~(BIG_SUR_GE_ECR_XMIT_RESET_MASK | BIG_SUR_GE_ECR_RECV_RESET_MASK);	\
+	control |= (BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | BIG_SUR_GE_ECR_RECV_ENABLE_MASK);	\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);		\
+}
+
+/* Disable the MAC unit */
+#define	big_sur_ge_mac_disable(base_address)					\
+{										\
+	u32	control;							\
+	control = BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ECR_OFFSET);		\
+	control &= ~(BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | BIG_SUR_GE_ECR_RECV_ENABLE_MASK);	\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);		\
+}
+
+/* Check if the Tx is done */
+#define	big_sur_ge_tx_done(base_address)						\
+	(BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ISR_OFFSET) & BIG_SUR_GE_EIR_XMIT_DONE_MASK)
+
+
+/* Check if Rx FIFO is empty */
+#define	big_sur_ge_rx_empty(base_address)						\
+	(!(BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ISR_OFFSET) & BIG_SUR_GE_EIR_RECV_DONE_MASK))
+
+/* Reset the MAC PHY */
+#define	big_sur_ge_reset_phy(base_address)						\
+{											\
+	u32	control;								\
+	control = BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ECR_OFFSET);			\
+	control &= ~(BIG_SUR_GE_ECR_PHY_ENABLE_MASK);						\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);			\
+	control |= BIG_SUR_GE_ECR_PHY_ENABLE_MASK;						\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);			\
+}
+
+/* DMA SG defines */
+#define BIG_SUR_GE_CONTROL_LAST_BD_MASK        0x02000000
+#define BIG_SUR_GE_STATUS_LAST_BD_MASK         0x10000000
+#define BIG_SUR_GE_RST_REG_OFFSET      0       /* reset register */
+#define BIG_SUR_GE_MI_REG_OFFSET       0       /* module information register */
+#define BIG_SUR_GE_DMAC_REG_OFFSET     4       /* DMA control register */
+#define BIG_SUR_GE_SA_REG_OFFSET       8       /* source address register */
+#define BIG_SUR_GE_DA_REG_OFFSET       12      /* destination address register */
+#define BIG_SUR_GE_LEN_REG_OFFSET      16      /* length register */
+#define BIG_SUR_GE_DMAS_REG_OFFSET     20      /* DMA status register */
+#define BIG_SUR_GE_BDA_REG_OFFSET      24      /* buffer descriptor address register */
+#define BIG_SUR_GE_SWCR_REG_OFFSET 28  /* software control register */
+#define BIG_SUR_GE_UPC_REG_OFFSET      32      /* unserviced packet count register */
+#define BIG_SUR_GE_PCT_REG_OFFSET      36      /* packet count threshold register */
+#define BIG_SUR_GE_PWB_REG_OFFSET      40      /* packet wait bound register */
+#define BIG_SUR_GE_IS_REG_OFFSET       44      /* interrupt status register */
+#define BIG_SUR_GE_IE_REG_OFFSET       48      /* interrupt enable register */
+
+#define BIG_SUR_GE_RESET_MASK                          0x0000000A
+
+/* Buffer Descriptor Control */
+
+#define BIG_SUR_GE_DEVICE_STATUS_OFFSET    0
+#define BIG_SUR_GE_CONTROL_OFFSET          1
+#define BIG_SUR_GE_SOURCE_OFFSET           2
+#define BIG_SUR_GE_DESTINATION_OFFSET      3
+#define BIG_SUR_GE_LENGTH_OFFSET           4
+#define BIG_SUR_GE_STATUS_OFFSET           5
+#define BIG_SUR_GE_NEXT_PTR_OFFSET         6
+#define BIG_SUR_GE_ID_OFFSET               7
+#define BIG_SUR_GE_FLAGS_OFFSET            8
+#define BIG_SUR_GE_RQSTED_LENGTH_OFFSET    9
+
+#define BIG_SUR_GE_FLAGS_LOCKED_MASK       1
+
+#define	xbuf_descriptor_init(base)				\
+{								\
+	(*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) = 0);		\
+	(*((u32 *)base + BIG_SUR_GE_SOURCE_OFFSET) = 0);        \
+    	(*((u32 *)base + BIG_SUR_GE_DESTINATION_OFFSET) = 0);   \
+    	(*((u32 *)base + BIG_SUR_GE_LENGTH_OFFSET) = 0);        \
+    	(*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET) = 0);        \
+    	(*((u32 *)base + BIG_SUR_GE_DEVICE_STATUS_OFFSET) = 0); \
+    	(*((u32 *)base + BIG_SUR_GE_NEXT_PTR_OFFSET) = 0);      \
+    	(*((u32 *)base + BIG_SUR_GE_ID_OFFSET) = 0);            \
+    	(*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) = 0);         \
+    	(*((u32 *)base + BIG_SUR_GE_RQSTED_LENGTH_OFFSET) = 0); \
+}
+
+#define xbuf_descriptor_GetControl(base)   \
+    (u32)(*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET))
+
+#define xbuf_descriptor_SetControl(base, Control)  \
+    (*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) = (u32)Control)
+
+#define xbuf_descriptor_IsLastControl(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) & \
+               BIG_SUR_GE_CONTROL_LAST_BD_MASK)
+
+#define xbuf_descriptor_SetLast(base) \
+    (*((u32 *)base + BIG_SUR_GE_CONTROL_OFFSET) |= BIG_SUR_GECONTROL_LAST_BD_MASK)
+
+#define xbuf_descriptor_GetSrcAddress(base) \
+    ((u32 *)(*((u32 *)base + BIG_SUR_GE_SOURCE_OFFSET)))
+
+#define xbuf_descriptor_SetSrcAddress(base, Source) \
+    (*((u32 *)base + BIG_SUR_GE_SOURCE_OFFSET) = (u32)Source)
+
+#define xbuf_descriptor_GetDestAddress(base) \
+    ((u32 *)(*((u32 *)base + BIG_SUR_GE_DESTINATION_OFFSET)))
+
+#define xbuf_descriptor_SetDestAddress(base, Destination) \
+    (*((u32 *)base + BIG_SUR_GE_DESTINATION_OFFSET) = (u32)Destination)
+
+#define xbuf_descriptor_GetLength(base)                           \
+    (u32)(*((u32 *)base + BIG_SUR_GE_RQSTED_LENGTH_OFFSET) -    \
+              *((u32 *)base + BIG_SUR_GE_LENGTH_OFFSET))
+
+#define xbuf_descriptor_SetLength(base, Length)                       \
+{                                                                           \
+    (*((u32 *)base + BIG_SUR_GE_LENGTH_OFFSET) = (u32)(Length));    \
+    (*((u32 *)base + BIG_SUR_GE_RQSTED_LENGTH_OFFSET) = (u32)(Length));\
+}
+
+#define xbuf_descriptor_GetStatus(base)    \
+    (u32)(*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET))
+
+#define xbuf_descriptor_SetStatus(base, Status)    \
+    (*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET) = (u32)Status)
+
+#define xbuf_descriptor_IsLastStatus(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_STATUS_OFFSET) & \
+               BIG_SUR_GE_STATUS_LAST_BD_MASK)
+
+#define xbuf_descriptor_GetDeviceStatus(base) \
+    ((u32)(*((u32 *)base + BIG_SUR_GE_DEVICE_STATUS_OFFSET)))
+
+#define xbuf_descriptor_SetDeviceStatus(base, Status) \
+    (*((u32 *)base + BIG_SUR_GE_DEVICE_STATUS_OFFSET) = (u32)Status)
+
+#define xbuf_descriptor_GetNextPtr(base) \
+    (xbuf_descriptor *)(*((u32 *)base + BIG_SUR_GE_NEXT_PTR_OFFSET))
+
+#define xbuf_descriptor_SetNextPtr(base, NextPtr) \
+    (*((u32 *)base + BIG_SUR_GE_NEXT_PTR_OFFSET) = (u32)NextPtr)
+
+#define xbuf_descriptor_GetId(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_ID_OFFSET))
+
+#define xbuf_descriptor_SetId(base, Id) \
+    (*((u32 *)base + BIG_SUR_GE_ID_OFFSET) = (u32)Id)
+
+#define xbuf_descriptor_GetFlags(base) \
+    (u32)(*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET))
+
+#define xbuf_descriptor_SetFlags(base, Flags) \
+    (*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) = (u32)Flags)
+
+#define xbuf_descriptor_Lock(base) \
+    (*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) |= BIG_SUR_GE_FLAGS_LOCKED_MASK)
+
+#define xbuf_descriptor_Unlock(base) \
+    (*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) &= ~BIG_SUR_GE_FLAGS_LOCKED_MASK)
+
+#define xbuf_descriptor_IsLocked(base) \
+	(*((u32 *)base + BIG_SUR_GE_FLAGS_OFFSET) & BIG_SUR_GE_FLAGS_LOCKED_MASK)
+
+#define BIG_SUR_GE_DMACR_SOURCE_INCR_MASK      0x80000000UL    /* increment source address */
+#define BIG_SUR_GE_DMACR_DEST_INCR_MASK        0x40000000UL    /* increment dest address */
+#define BIG_SUR_GE_DMACR_SOURCE_LOCAL_MASK 0x20000000UL        /* local source address */
+#define BIG_SUR_GE_DMACR_DEST_LOCAL_MASK       0x10000000UL    /* local dest address */
+#define BIG_SUR_GE_DMACR_SG_DISABLE_MASK       0x08000000UL    /* scatter gather disable */
+#define BIG_SUR_GE_DMACR_GEN_BD_INTR_MASK      0x04000000UL    /* descriptor interrupt */
+#define BIG_SUR_GE_DMACR_LAST_BD_MASK          BIG_SUR_GE_CONTROL_LAST_BD_MASK        /* last buffer */
+#define BIG_SUR_GE_DMASR_BUSY_MASK                     0x80000000UL    /* channel is busy */
+#define BIG_SUR_GE_DMASR_BUS_ERROR_MASK        0x40000000UL    /* bus error occurred */
+#define BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK      0x20000000UL    /* bus timeout occurred */
+#define BIG_SUR_GE_DMASR_LAST_BD_MASK          BIG_SUR_GE_STATUS_LAST_BD_MASK /* last buffer */
+#define BIG_SUR_GE_DMASR_SG_BUSY_MASK          0x08000000UL    /* scatter gather is busy */
+#define BIG_SUR_GE_IXR_DMA_DONE_MASK           0x1UL   /* dma operation done */
+#define BIG_SUR_GE_IXR_DMA_ERROR_MASK      0x2UL       /* dma operation error */
+#define BIG_SUR_GE_IXR_PKT_DONE_MASK       0x4UL       /* packet done */
+#define BIG_SUR_GE_IXR_PKT_THRESHOLD_MASK      0x8UL   /* packet count threshold */
+#define BIG_SUR_GE_IXR_PKT_WAIT_BOUND_MASK 0x10UL      /* packet wait bound reached */
+#define BIG_SUR_GE_IXR_SG_DISABLE_ACK_MASK 0x20UL      /* scatter gather disable
+                                                   acknowledge occurred */
+#define BIG_SUR_GEIXR_SG_END_MASK                     0x40UL  /* last buffer descriptor
+                                                           disabled scatter gather */
+#define BIG_SUR_GEIXR_BD_MASK                         0x80UL  /* buffer descriptor done */
+
+/* BD control */
+#define BIG_SUR_GE_DFT_SEND_BD_MASK    (BIG_SUR_GEDMACR_SOURCE_INCR_MASK | \
+                                 BIG_SUR_GEDMACR_DEST_LOCAL_MASK)
+#define BIG_SUR_GE_DFT_RECV_BD_MASK    (BIG_SUR_GEDMACR_DEST_INCR_MASK |  \
+                                 BIG_SUR_GEDMACR_SOURCE_LOCAL_MASK)
+
+/* Interrupts */
+#define BIG_SUR_GE_IPIF_EMAC_MASK      0x00000004UL    /* MAC interrupt */
+#define BIG_SUR_GE_IPIF_SEND_DMA_MASK  0x00000008UL    /* Send DMA interrupt */
+#define BIG_SUR_GE_IPIF_RECV_DMA_MASK  0x00000010UL    /* Receive DMA interrupt */
+#define BIG_SUR_GE_IPIF_RECV_FIFO_MASK 0x00000020UL    /* Receive FIFO interrupt */
+#define BIG_SUR_GE_IPIF_SEND_FIFO_MASK 0x00000040UL    /* Send FIFO interrupt */
+
+#define BIG_SUR_GE_IPIF_DMA_DFT_MASK   (BIG_SUR_GE_IPIF_SEND_DMA_MASK |   \
+                                 BIG_SUR_GE_IPIF_RECV_DMA_MASK |   \
+                                 BIG_SUR_GE_IPIF_EMAC_MASK |       \
+                                 BIG_SUR_GE_IPIF_SEND_FIFO_MASK |  \
+                                 BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+
+#define BIG_SUR_GE_IPIF_FIFO_DFT_MASK  (BIG_SUR_GE_IPIF_EMAC_MASK |       \
+                                 BIG_SUR_GE_IPIF_SEND_FIFO_MASK |  \
+                                 BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+
+#define BIG_SUR_GE_IPIF_DMA_DEV_INTR_COUNT   7 /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_FIFO_DEV_INTR_COUNT  5 /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_DEVICE_INTR_COUNT  7   /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_IP_INTR_COUNT      22  /* Number of MAC interrupts */
+
+/* a mask for all transmit interrupts, used in polled mode */
+#define BIG_SUR_GE_EIR_XMIT_ALL_MASK   (BIG_SUR_GE_EIR_XMIT_DONE_MASK |           \
+                                 BIG_SUR_GE_EIR_XMIT_ERROR_MASK |          \
+                                 BIG_SUR_GE_EIR_XMIT_SFIFO_EMPTY_MASK |    \
+                                 BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK)
+
+/* a mask for all receive interrupts, used in polled mode */
+#define BIG_SUR_GE_EIR_RECV_ALL_MASK   (BIG_SUR_GE_EIR_RECV_DONE_MASK |           \
+                                 BIG_SUR_GE_EIR_RECV_ERROR_MASK |          \
+                                 BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK |    \
+                                 BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK |     \
+                                 BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK |    \
+                                 BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK |     \
+                                 BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK |   \
+                                 BIG_SUR_GE_EIR_RECV_COLLISION_MASK |      \
+                                 BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK |      \
+                                 BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK |      \
+                                 BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK |    \
+                                 BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK |     \
+                                 BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK)
+
+/* a default interrupt mask for scatter-gather DMA operation */
+#define BIG_SUR_GE_EIR_DFT_SG_MASK    (BIG_SUR_GE_EIR_RECV_ERROR_MASK |           \
+                                BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK |     \
+                                BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK |     \
+                                BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK |     \
+                                BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK |      \
+                                BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK |    \
+                                BIG_SUR_GE_EIR_RECV_COLLISION_MASK |       \
+                                BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK |       \
+                                BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK |       \
+                                BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK |     \
+                                BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK |      \
+                                BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK)
+
+/* a default interrupt mask for non-DMA operation (direct FIFOs) */
+#define BIG_SUR_GE_EIR_DFT_FIFO_MASK  (BIG_SUR_GE_EIR_XMIT_DONE_MASK |            \
+                                BIG_SUR_GE_EIR_RECV_DONE_MASK |            \
+                                BIG_SUR_GE_EIR_DFT_SG_MASK)
+
+#define BIG_SUR_GE_DMA_SG_INTR_MASK    (BIG_SUR_GEIXR_DMA_ERROR_MASK  |      \
+                                 BIG_SUR_GEIXR_PKT_THRESHOLD_MASK |   \
+                                 BIG_SUR_GEIXR_PKT_WAIT_BOUND_MASK |  \
+                                 BIG_SUR_GEIXR_SG_END_MASK)
+
+#endif
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/declance.c linux_HEAD/drivers/net/declance.c
--- linux-2.6.11.6/drivers/net/declance.c	2005-03-26 04:28:44.000000000 +0100
+++ linux_HEAD/drivers/net/declance.c	2004-10-27 02:14:31.000000000 +0200
@@ -705,8 +705,8 @@ static void lance_dma_merr_int(const int
 	printk("%s: DMA error\n", dev->name);
 }
 
-static irqreturn_t
-lance_interrupt(const int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t lance_interrupt(const int irq, void *dev_id,
+				   struct pt_regs *regs)
 {
 	struct net_device *dev = (struct net_device *) dev_id;
 	struct lance_private *lp = netdev_priv(dev);
@@ -1260,7 +1260,7 @@ static int __init dec_lance_init(const i
 	return 0;
 
 err_out_free_dev:
-	kfree(dev);
+	free_netdev(dev);
 
 err_out:
 	return ret;
@@ -1306,6 +1306,7 @@ static void __exit dec_lance_cleanup(voi
 	while (root_lance_dev) {
 		struct net_device *dev = root_lance_dev;
 		struct lance_private *lp = netdev_priv(dev);
+
 		unregister_netdev(dev);
 #ifdef CONFIG_TC
 		if (lp->slot >= 0)
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/gt64240eth.c linux_HEAD/drivers/net/gt64240eth.c
--- linux-2.6.11.6/drivers/net/gt64240eth.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/net/gt64240eth.c	2004-10-27 02:14:32.000000000 +0200
@@ -0,0 +1,1672 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 Patton Electronics Company
+ * Copyright (C) 2002 Momentum Computer
+ *
+ * Copyright 2000 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or support@mvista.com
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Ethernet driver for the MIPS GT96100 Advanced Communication Controller.
+ * 
+ * Modified for the Gallileo/Marvell GT-64240 Communication Controller.
+ *
+ * Support for Rx NAPI, Rx checksum offload, IOCTL and ETHTOOL added
+ * Manish Lachwani (lachwani@pmc-sierra.com) - 09/16/2003
+ *
+ * Modified for later version of Linux 2.4 kernel
+ * Manish Lachwani (lachwani@pmc-sierra.com) - 04/29/2004
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/mii.h>
+
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+
+#define DESC_DATA_BE 1
+
+#include "gt64240eth.h"
+
+// enable this port (set hash size to 1/2K)
+//- #define PORT_CONFIG pcrHS
+#define PORT_CONFIG (pcrHS | pcrHD)
+//- #define PORT_CONFIG pcrHS |pcrPM |pcrPBF|pcrHDM
+//- GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, pcrEN | pcrHS);
+//- GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, pcrEN | pcrHS | pcrPM);
+//- GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, pcrEN | pcrHS | pcrPM | 1<<pcrLPBKBit);
+
+// clear all the MIB ctr regs
+#define EXT_CONFIG_CLEAR (pcxrFCTL | pcxrFCTLen | pcxrFLP | pcxrDPLXen | pcxrPRIOrxOverride | pcxrRMIIen)
+
+/*
+ * _debug level:
+ * <= 2	none.
+ *  > 2	some warnings such as queue full, .....
+ *  > 3	lots of change-of-state messages.
+ *  > 4	EXTENSIVE data/descriptor dumps.
+ */
+
+#ifdef GT64240_DEBUG
+static int gt64240_debug = GT64240_DEBUG;
+#else
+static int gt64240_debug = 0;
+#endif
+
+static int debug = -1;
+
+#define GT64240_MSG_ENABLE	(NETIF_MSG_DRV          | \
+				NETIF_MSG_PROBE        | \
+				NETIF_MSG_LINK)
+
+
+/********************************************************/
+
+// prototypes
+static void gt64240_delay(int msec);
+static int gt64240_add_hash_entry(struct net_device *dev,
+				  unsigned char *addr);
+static void read_mib_counters(struct gt64240_private *gp);
+static void dump_MII(struct net_device *dev);
+static void dump_tx_desc(struct net_device *dev, int i);
+static void dump_rx_desc(struct net_device *dev, int i);
+static void dump_hw_addr(unsigned char *addr_str);
+static void update_stats(struct gt64240_private *gp);
+static void abort(struct net_device *dev, u32 abort_bits);
+static void hard_stop(struct net_device *dev);
+static void enable_ether_irq(struct net_device *dev);
+static void disable_ether_irq(struct net_device *dev);
+static int __init gt64240_probe1(unsigned long ioaddr, int irq, int port_num);
+static void reset_tx(struct net_device *dev);
+static void reset_rx(struct net_device *dev);
+static int gt64240_init(struct net_device *dev);
+static int gt64240_open(struct net_device *dev);
+static int gt64240_close(struct net_device *dev);
+static int gt64240_tx(struct sk_buff *skb, struct net_device *dev);
+#ifdef GT64240_NAPI
+static int gt64240_poll(struct net_device *dev, int *budget);
+static int gt64240_rx(struct net_device *dev, u32 status, int budget);
+#else
+static int gt64240_rx(struct net_device *dev, u32 status);
+#endif
+static void gt64240_tx_timeout(struct net_device *dev);
+static void gt64240_set_rx_mode(struct net_device *dev);
+static struct net_device_stats *gt64240_get_stats(struct net_device *dev);
+
+extern char *__init prom_getcmdline(void);
+extern int prom_get_mac_addrs(unsigned char
+			      station_addr[NUM_INTERFACES][6]);
+
+static char version[] __devinitdata =
+	"gt64240eth.o: version 0.1, <www.patton.com>\n";
+
+// PHY device addresses
+static u32 gt64240_phy_addr[NUM_INTERFACES] __devinitdata = { 0x8, 0x1, 0xa };
+
+// Need real Ethernet addresses -- in parse_mac_addr_options(),
+// these will be replaced by prom_get_mac_addrs() and/or prom_getcmdline().
+static unsigned char gt64240_station_addr[NUM_INTERFACES][6] = {
+	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05},
+	{0x01, 0x02, 0x03, 0x04, 0x05, 0x06},
+	{0x02, 0x03, 0x04, 0x05, 0x06, 0x07}
+};
+
+static int max_interrupt_work = 32;
+
+/*
+ * Base address and interupt of the GT64240 ethernet controllers
+ */
+static struct {
+	unsigned int port;
+	int irq;
+} gt64240_iflist[NUM_INTERFACES] = {
+	{
+	GT64240_ETH0_BASE, 8}, {
+	GT64240_ETH1_BASE, 8}, {
+	GT64240_ETH2_BASE, 8}
+};
+
+static void gt64240_delay(int ms)
+{
+	if (in_interrupt())
+		return;
+	else {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(ms * HZ / 1000);
+	}
+}
+
+unsigned char prom_mac_addr_base[6];
+
+int prom_get_mac_addrs(unsigned char station_addr[NUM_INTERFACES][6])
+{
+	memcpy(station_addr[0], prom_mac_addr_base, 6);
+	memcpy(station_addr[1], prom_mac_addr_base, 6);
+	memcpy(station_addr[2], prom_mac_addr_base, 6);
+
+	station_addr[1][5] += 1;
+	station_addr[2][5] += 2;
+
+	return 0;
+}
+
+void parse_mac_addr_options(void)
+{
+	prom_get_mac_addrs(gt64240_station_addr);
+}
+
+static int read_MII(struct net_device *dev, int phy, int reg)
+{
+	int timedout = 20;
+	u32 smir = smirOpCode | (phy << smirPhyAdBit) |
+	    (reg << smirRegAdBit);
+
+	// wait for last operation to complete
+	while ((GT64240_READ(GT64240_ETH_SMI_REG)) & smirBusy) {
+		// snooze for 1 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: read_MII busy timeout!!\n", dev->name);
+			return -1;
+		}
+	}
+
+	GT64240_WRITE(GT64240_ETH_SMI_REG, smir);
+
+	timedout = 20;
+	// wait for read to complete
+	while (!
+	       ((smir =
+		 GT64240_READ(GT64240_ETH_SMI_REG)) & smirReadValid)) {
+		// snooze for 1 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: read_MII timeout!!\n", dev->name);
+			return -1;
+		}
+	}
+
+	return (int) (smir & smirDataMask);
+}
+
+static void gp_get_drvinfo (struct net_device *dev, 
+				struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, "gt64260");
+	strcpy(info->version, version);
+}
+
+static int gp_get_settings(struct net_device *dev, 
+				struct ethtool_cmd *cmd)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int rc;
+
+	spin_lock_irq(&gp->lock);
+	rc = mii_ethtool_gset(&gp->mii_if, cmd);
+	spin_unlock_irq(&gp->lock);
+	return rc;
+}
+
+static int gp_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int rc;
+
+	spin_lock_irq(&gp->lock);
+	rc = mii_ethtool_sset(&gp->mii_if, cmd);
+	spin_unlock_irq(&gp->lock);
+	return rc;
+}
+
+static int gp_nway_reset(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	return mii_nway_restart(&gp->mii_if);
+}
+
+static u32 gp_get_link(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	return mii_link_ok(&gp->mii_if);
+}
+
+static u32 gp_get_msglevel(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	return gp->msg_enable;
+}
+
+static void gp_set_msglevel(struct net_device *dev, u32 value)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	gp->msg_enable = value;
+}
+
+static struct ethtool_ops gp_ethtool_ops = {
+	.get_drvinfo		= gp_get_drvinfo,
+	.get_settings		= gp_get_settings,
+	.set_settings		= gp_set_settings,
+	.nway_reset		= gp_nway_reset,
+	.get_link		= gp_get_link,
+	.get_msglevel		= gp_get_msglevel,
+	.set_msglevel		= gp_set_msglevel,
+};
+
+static int gt64240_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	struct mii_ioctl_data *data =
+	    (struct mii_ioctl_data *) &rq->ifr_data;
+	int retval;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	spin_lock_irq(&gp->lock);
+	retval = generic_mii_ioctl(&gp->mii_if, data, cmd, NULL);
+	spin_unlock_irq(&gp->lock);
+
+	return retval;
+}
+
+static void dump_tx_desc(struct net_device *dev, int i)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	gt64240_td_t *td = &gp->tx_ring[i];
+
+	printk("%s:tx[%d]: self=%p cmd=%08x, cnt=%4d. bufp=%08x, next=%08x\n",
+	       dev->name, i, td, td->cmdstat, td->byte_cnt, td->buff_ptr,
+	       td->next);
+}
+
+static void dump_rx_desc(struct net_device *dev, int i)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	gt64240_rd_t *rd = &gp->rx_ring[i];
+
+	printk("%s:rx_dsc[%d]: self=%p cst=%08x,size=%4d. cnt=%4d. "
+	       "bufp=%08x, next=%08x\n",
+	       dev->name, i, rd, rd->cmdstat, rd->buff_sz, rd->byte_cnt,
+	       rd->buff_ptr, rd->next);
+}
+
+// These routines work, just disabled to avoid compile warnings
+static void write_MII(struct net_device *dev, int phy, int reg, int data)
+{
+	u32 smir = (phy << smirPhyAdBit) | (reg << smirRegAdBit) | data;
+	int timedout = 20;
+
+	// wait for last operation to complete
+	while (GT64240_READ(GT64240_ETH_SMI_REG) & smirBusy) {
+		// snooze for 1 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: write_MII busy timeout!!\n",
+			       dev->name);
+			return;
+		}
+	}
+
+	GT64240_WRITE(GT64240_ETH_SMI_REG, smir);
+}
+
+static void dump_MII(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int i, val;
+
+	for (i = 0; i < 7; i++) {
+		if ((val = read_MII(dev, gp->phy_addr, i)) >= 0)
+			printk("%s: MII Reg %d=%x\n", dev->name, i, val);
+	}
+	for (i = 16; i < 21; i++) {
+		if ((val = read_MII(dev, gp->phy_addr, i)) >= 0)
+			printk("%s: MII Reg %d=%x\n", dev->name, i, val);
+	}
+}
+
+
+static void dump_hw_addr(unsigned char *addr_str)
+{
+	int i;
+	for (i = 0; i < 6; i++) {
+		printk("%2.2x", addr_str[i]);
+		printk(i < 5 ? ":" : "\n");
+	}
+}
+
+static int gt64240_add_hash_entry(struct net_device *dev,
+				  unsigned char *addr)
+{
+	static unsigned char swapped[256];
+	struct gt64240_private *gp;
+	u32 value1, value0, *entry;
+	unsigned char hash_ea[6];
+	static int flag = 0;
+	u16 hashResult;
+	int i;
+
+	if (flag == 0) {	/* Create table to swap bits in a byte  */
+		flag = 1;
+		for (i = 0; i < 256; i++) {
+			swapped[i] = (i & 0x01) << 7;
+			swapped[i] |= (i & 0x02) << 5;
+			swapped[i] |= (i & 0x04) << 3;
+			swapped[i] |= (i & 0x08) << 1;
+			swapped[i] |= (i & 0x10) >> 1;
+			swapped[i] |= (i & 0x20) >> 3;
+			swapped[i] |= (i & 0x40) >> 5;
+			swapped[i] |= (i & 0x80) >> 7;
+		}
+	}
+
+	for (i = 0; i < 6; i++) {	/* swap bits from mac to create hash mac */
+		hash_ea[i] = swapped[addr[i]];
+	}
+
+	gp = netdev_priv(dev);
+
+	/* create hash entry address    */
+	hashResult = (((hash_ea[5] >> 2) & 0x3F) << 9) & 0x7E00;
+	hashResult |= ((hash_ea[4] & 0x7F) << 2) | (hash_ea[5] & 0x03);
+	hashResult ^=
+	    ((hash_ea[3] & 0xFF) << 1) | ((hash_ea[4] >> 7) & 0x01);
+	hashResult ^= ((hash_ea[1] & 0x01) << 8) | (hash_ea[2] & 0xFF);
+
+	value0 = hteValid | hteRD;	/* Create hash table entry value */
+	value0 |= (u32) addr[0] << 3;
+	value0 |= (u32) addr[1] << 11;
+	value0 |= (u32) addr[2] << 19;
+	value0 |= ((u32) addr[3] & 0x1f) << 27;
+
+	value1 = ((u32) addr[3] >> 5) & 0x07;
+	value1 |= (u32) addr[4] << 3;
+	value1 |= (u32) addr[5] << 11;
+
+	/* Inset entry value into hash table */
+	for (i = 0; i < HASH_HOP_NUMBER; i++) {
+		entry = (u32 *) ((u32) gp->hash_table +
+				 (((u32) hashResult & 0x07ff) << 3));
+		if ((*entry & hteValid) && !(*entry & hteSkip)) {
+			hashResult += 2;	/* oops, occupied, go to next entry */
+		} else {
+#ifdef __LITTLE_ENDIAN
+			entry[1] = value1;
+			entry[0] = value0;
+#else
+			entry[0] = value1;
+			entry[1] = value0;
+#endif
+			break;
+		}
+	}
+	if (i >= HASH_HOP_NUMBER) {
+		printk("%s: gt64240_add_hash_entry expired!\n", dev->name);
+		return (-1);
+	}
+	return (0);
+}
+
+
+static void read_mib_counters(struct gt64240_private *gp)
+{
+	u32 *mib_regs = (u32 *) & gp->mib;
+	int i;
+
+	for (i = 0; i < sizeof(mib_counters_t) / sizeof(u32); i++)
+		mib_regs[i] =
+		    GT64240ETH_READ(gp,
+				    GT64240_ETH_MIB_COUNT_BASE +
+				    i * sizeof(u32));
+}
+
+
+static void update_stats(struct gt64240_private *gp)
+{
+	mib_counters_t *mib = &gp->mib;
+	struct net_device_stats *stats = &gp->stats;
+
+	read_mib_counters(gp);
+
+	stats->rx_packets = mib->totalFramesReceived;
+	stats->tx_packets = mib->framesSent;
+	stats->rx_bytes = mib->totalByteReceived;
+	stats->tx_bytes = mib->byteSent;
+	stats->rx_errors = mib->totalFramesReceived - mib->framesReceived;
+	//the tx error counters are incremented by the ISR
+	//rx_dropped incremented by gt64240_rx
+	//tx_dropped incremented by gt64240_tx
+	stats->multicast = mib->multicastFramesReceived;
+	// collisions incremented by gt64240_tx_complete
+	stats->rx_length_errors = mib->oversizeFrames + mib->fragments;
+	// The RxError condition means the Rx DMA encountered a
+	// CPU owned descriptor, which, if things are working as
+	// they should, means the Rx ring has overflowed.
+	stats->rx_over_errors = mib->macRxError;
+	stats->rx_crc_errors = mib->cRCError;
+}
+
+static void abort(struct net_device *dev, u32 abort_bits)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int timedout = 100;	// wait up to 100 msec for hard stop to complete
+
+	if (gt64240_debug > 3)
+		printk("%s: abort\n", dev->name);
+
+	// Return if neither Rx or Tx abort bits are set
+	if (!(abort_bits & (sdcmrAR | sdcmrAT)))
+		return;
+
+	// make sure only the Rx/Tx abort bits are set
+	abort_bits &= (sdcmrAR | sdcmrAT);
+
+	spin_lock(&gp->lock);
+
+	// abort any Rx/Tx DMA immediately
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, abort_bits);
+
+	if (gt64240_debug > 3)
+		printk("%s: abort: SDMA cmd  = %x/%x\n",
+		       dev->name, abort_bits, GT64240ETH_READ(gp,
+							      GT64240_ETH_SDMA_COMM));
+
+	// wait for abort to complete
+	while ((GT64240ETH_READ(gp, GT64240_ETH_SDMA_COMM)) & abort_bits) {
+		// snooze for 20 msec and check again
+		gt64240_delay(1);
+
+		if (--timedout == 0) {
+			printk("%s: abort timeout!!\n", dev->name);
+			break;
+		}
+	}
+
+	spin_unlock(&gp->lock);
+}
+
+
+static void hard_stop(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+
+	if (gt64240_debug > 3)
+		printk("%s: hard stop\n", dev->name);
+
+	disable_ether_irq(dev);
+
+	abort(dev, sdcmrAR | sdcmrAT);
+
+	// disable port
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, 0);
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_hard_stop: Port Config=%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_PORT_CONFIG));
+
+}
+
+static void gt64240_tx_complete(struct net_device *dev, u32 status)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int nextOut, cdp;
+	gt64240_td_t *td;
+	u32 cmdstat;
+
+	cdp = (GT64240ETH_READ(gp, GT64240_ETH_CURR_TX_DESC_PTR0)
+	       - gp->tx_ring_dma) / sizeof(gt64240_td_t);
+
+	if (gt64240_debug > 3) {	/*+prk17aug01 */
+		nextOut = gp->tx_next_out;
+		printk
+		    ("%s: tx_complete: TX_PTR0=0x%08x, cdp=%d. nextOut=%d.\n",
+		     dev->name, GT64240ETH_READ(gp,
+						GT64240_ETH_CURR_TX_DESC_PTR0),
+		     cdp, nextOut);
+		td = &gp->tx_ring[nextOut];
+	}
+
+/*** NEED to check and CLEAR these errors every time thru here: ***/
+	if (gt64240_debug > 2) {
+		if (GT64240_READ(COMM_UNIT_INTERRUPT_CAUSE))
+			printk
+			    ("%s: gt64240_tx_complete: CIU Cause=%08x, Mask=%08x, EAddr=%08x\n",
+			     dev->name,
+			     GT64240_READ(COMM_UNIT_INTERRUPT_CAUSE),
+			     GT64240_READ(COMM_UNIT_INTERRUPT_MASK),
+			     GT64240_READ(COMM_UNIT_ERROR_ADDRESS));
+		GT64240_WRITE(COMM_UNIT_INTERRUPT_CAUSE, 0);
+	}
+	// Continue until we reach the current descriptor pointer
+	for (nextOut = gp->tx_next_out; nextOut != cdp;
+	     nextOut = (nextOut + 1) % TX_RING_SIZE) {
+
+		if (--gp->intr_work_done == 0)
+			break;
+
+		td = &gp->tx_ring[nextOut];
+		cmdstat = td->cmdstat;
+
+		if (cmdstat & (u32) txOwn) {
+			// DMA is not finished writing descriptor???
+			// Leave and come back later to pick-up where we left off.
+			break;
+		}
+		// increment Tx error stats
+		if (cmdstat & (u32) txErrorSummary) {
+			if (gt64240_debug > 2)
+				printk
+				    ("%s: tx_complete: Tx error, cmdstat = %x\n",
+				     dev->name, cmdstat);
+			gp->stats.tx_errors++;
+			if (cmdstat & (u32) txReTxLimit)
+				gp->stats.tx_aborted_errors++;
+			if (cmdstat & (u32) txUnderrun)
+				gp->stats.tx_fifo_errors++;
+			if (cmdstat & (u32) txLateCollision)
+				gp->stats.tx_window_errors++;
+		}
+
+		if (cmdstat & (u32) txCollision)
+			gp->stats.collisions +=
+			    (unsigned long) ((cmdstat & txReTxCntMask) >>
+					     txReTxCntBit);
+
+		// Wake the queue if the ring was full
+		if (gp->tx_full) {
+			gp->tx_full = 0;
+			if (gp->last_psr & psrLink) {
+				netif_wake_queue(dev);
+			}
+		}
+		// decrement tx ring buffer count
+		if (gp->tx_count)
+			gp->tx_count--;
+
+		// free the skb
+		if (gp->tx_skbuff[nextOut]) {
+			if (gt64240_debug > 3)
+				printk
+				    ("%s: tx_complete: good Tx, skb=%p\n",
+				     dev->name, gp->tx_skbuff[nextOut]);
+			dev_kfree_skb_irq(gp->tx_skbuff[nextOut]);
+			gp->tx_skbuff[nextOut] = NULL;
+		} else {
+			printk("%s: tx_complete: no skb!\n", dev->name);
+		}
+	}
+
+	gp->tx_next_out = nextOut;
+
+	if ((status & icrTxEndLow) && gp->tx_count != 0) {
+		// we must restart the DMA
+		GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM,
+				 sdcmrERD | sdcmrTXDL);
+	}
+}
+
+static irqreturn_t gt64240_interrupt(int irq, void *dev_id,
+	struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct gt64240_private *gp = netdev_priv(dev);
+	u32 status;
+
+	if (dev == NULL) {
+		printk("%s: isr: null dev ptr\n", dev->name);
+		return IRQ_NONE;
+	}
+
+	spin_lock(&gp->lock);
+
+	if (gt64240_debug > 3)
+		printk("%s: isr: entry\n", dev->name);
+
+	gp->intr_work_done = max_interrupt_work;
+
+	while (gp->intr_work_done > 0) {
+
+		status = GT64240ETH_READ(gp, GT64240_ETH_INT_CAUSE);
+#ifdef GT64240_NAPI
+		/* dont ack Rx interrupts */
+		if (!(status & icrRxBuffer))
+			GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0);
+#else
+		// ACK interrupts
+		GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0);
+#endif
+
+		if (gt64240_debug > 3)
+			printk("%s: isr: work=%d., icr=%x\n", dev->name,
+			       gp->intr_work_done, status);
+
+		if ((status & icrEtherIntSum) == 0) {
+			if (!(status &
+			      (icrTxBufferLow | icrTxBufferHigh |
+			       icrRxBuffer))) {
+				/* exit from the while() loop */
+				break;
+			}
+		}
+
+		if (status & icrMIIPhySTC) {
+			u32 psr =
+			    GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS);
+			if (gp->last_psr != psr) {
+				printk("%s: port status: 0x%08x\n",
+				       dev->name, psr);
+				printk
+				    ("%s:    %s MBit/s, %s-duplex, flow-control %s, link is %s,\n",
+				     dev->name,
+				     psr & psrSpeed ? "100" : "10",
+				     psr & psrDuplex ? "full" : "half",
+				     psr & psrFctl ? "disabled" :
+				     "enabled",
+				     psr & psrLink ? "up" : "down");
+				printk
+				    ("%s:    TxLowQ is %s, TxHighQ is %s, Transmitter is %s\n",
+				     dev->name,
+				     psr & psrTxLow ? "running" :
+				     "stopped",
+				     psr & psrTxHigh ? "running" :
+				     "stopped",
+				     psr & psrTxInProg ? "on" : "off");
+
+				if ((psr & psrLink) && !gp->tx_full &&
+				    netif_queue_stopped(dev)) {
+					printk
+					    ("%s: isr: Link up, waking queue.\n",
+					     dev->name);
+					netif_wake_queue(dev);
+				} else if (!(psr & psrLink)
+					   && !netif_queue_stopped(dev)) {
+					printk
+					    ("%s: isr: Link down, stopping queue.\n",
+					     dev->name);
+					netif_stop_queue(dev);
+				}
+
+				gp->last_psr = psr;
+			}
+		}
+
+		if (status & (icrTxBufferLow | icrTxEndLow))
+			gt64240_tx_complete(dev, status);
+
+		if (status & icrRxBuffer) {
+#ifdef GT64240_NAPI
+			if (netif_rx_schedule_prep(dev)) {
+				disable_ether_irq(dev);
+				__netif_rx_schedule(dev);
+			}
+#else
+			gt64240_rx(dev, status);
+#endif
+		}
+		// Now check TX errors (RX errors were handled in gt64240_rx)
+		if (status & icrTxErrorLow) {
+			printk("%s: isr: Tx resource error\n", dev->name);
+		}
+
+		if (status & icrTxUdr) {
+			printk("%s: isr: Tx underrun error\n", dev->name);
+		}
+	}
+
+	if (gp->intr_work_done == 0) {
+		// ACK any remaining pending interrupts
+		GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0);
+		if (gt64240_debug > 3)
+			printk("%s: isr: hit max work\n", dev->name);
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: isr: exit, icr=%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_INT_CAUSE));
+
+	spin_unlock(&gp->lock);
+
+	return IRQ_HANDLED;
+}
+
+static void enable_ether_irq(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	u32 intMask;
+
+	intMask =
+	    icrTxBufferLow | icrTxEndLow | icrTxErrorLow |
+	    icrTxBufferHigh | icrTxEndHigh | icrTxErrorHigh | icrTxUdr |
+	    icrRxBuffer | icrRxOVR | icrRxError | icrMIIPhySTC |
+	    icrEtherIntSum;
+
+
+//- GT64240ETH_WRITE(gp, GT64240_ETH_INT_CAUSE, 0); /* CLEAR existing ints */
+	// unmask device interrupts:
+	GT64240ETH_WRITE(gp, GT64240_ETH_INT_MASK, intMask);
+
+	// now route ethernet interrupts to GT PCI1 (eth0 and eth1 will be
+	// sharing it).
+	intMask = MV_READ(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH);
+	intMask |= 1 << gp->port_num;
+	MV_WRITE(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH, intMask);
+}
+
+static void disable_ether_irq(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	u32 intMask;
+
+	intMask = MV_READ(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH);
+	intMask &= ~(1 << gp->port_num);
+	MV_WRITE(PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH, intMask);
+
+	// mask all device interrupts: 
+	GT64240ETH_WRITE(gp, GT64240_ETH_INT_MASK, 0);
+}
+
+/*
+ * Probe for a GT64240 ethernet controller.
+ */
+static int __init gt64240_probe(void)
+{
+	int found = 0;
+	int i;
+
+	parse_mac_addr_options();
+
+	for (i = 0; i < NUM_INTERFACES; i++) {
+		unsigned long base_addr = gt64240_iflist[i].port;
+
+		if (check_region(base_addr, GT64240_ETH_IO_SIZE)) {
+			printk("gt64240_probe: ioaddr 0x%lx taken?\n",
+			       base_addr);
+			continue;
+		}
+
+		if (gt64240_probe1(base_addr, gt64240_iflist[i].irq, i) == 0) {
+			/*
+			 * Does not seem to be the "traditional" way folks do
+			 * this, but I want to init both eth ports if at all
+			 * possible!
+			 *
+			 * So, until I find out the "correct" way to do this:
+			 */
+			if (++found == NUM_INTERFACES)	/* That's all of them */
+				return 0;
+		}
+	}
+
+	if (found)
+		return 0;	/* as long as we found at least one! */
+
+	return -ENODEV;
+}
+
+module_init(gt64240_probe);
+
+static int __init gt64240_probe1(unsigned long ioaddr, int irq, int port_num)
+{
+	struct net_device *dev = NULL;
+	static unsigned version_printed = 0;
+	struct gt64240_private *gp = NULL;
+	int retval;
+	u32 cpuConfig;
+
+	dev = alloc_etherdev(sizeof(struct gt64240_private));
+	if (!dev)
+		return -ENOMEM;
+
+	if (irq < 0) {
+		printk
+		    ("gt64240_probe1: irq unknown - probing not supported\n");
+		return -ENODEV;
+	}
+#if 1				/* KLUDGE Alert: no check on return value: */
+	if (!request_region(ioaddr, GT64240_ETH_IO_SIZE, "gt64240eth"))
+		printk("*** request_region() failed!\n");
+#endif
+
+	cpuConfig = GT64240_READ(CPU_CONFIGURATION);
+	printk("gt64240_probe1: cpu in %s-endian mode\n",
+	       (cpuConfig & (1 << 12)) ? "little" : "big");
+
+	printk("%s: GT64240 found at ioaddr 0x%lx, irq %d.\n",
+	       dev->name, ioaddr, irq);
+
+	if (gt64240_debug && version_printed++ == 0)
+		printk("%s: %s", dev->name, version);
+
+	/* private struct aligned and zeroed by init_etherdev */
+	/* Fill in the 'dev' fields. */
+	dev->base_addr = ioaddr;
+	dev->irq = irq;
+	memcpy(dev->dev_addr, gt64240_station_addr[port_num],
+	       sizeof(dev->dev_addr));
+
+	printk("%s: HW Address ", dev->name);
+	dump_hw_addr(dev->dev_addr);
+
+	gp = dev->priv;
+
+	gp->msg_enable = (debug < 0 ? GT64240_MSG_ENABLE : debug);
+	gp->port_num = port_num;
+	gp->io_size = GT64240_ETH_IO_SIZE;
+	gp->port_offset = port_num * GT64240_ETH_IO_SIZE;
+	gp->phy_addr = gt64240_phy_addr[port_num];
+
+	printk("%s: GT64240 ethernet port %d\n", dev->name, gp->port_num);
+
+#ifdef GT64240_NAPI
+	printk("Rx NAPI supported \n");
+#endif
+
+/* MII Initialization */
+	gp->mii_if.dev = dev;
+	gp->mii_if.phy_id = dev->base_addr;
+	gp->mii_if.mdio_read = read_MII;
+	gp->mii_if.mdio_write = write_MII;
+	gp->mii_if.advertising = read_MII(dev, gp->phy_addr, MII_ADVERTISE);
+
+	// Allocate Rx and Tx descriptor rings
+	if (gp->rx_ring == NULL) {
+		// All descriptors in ring must be 16-byte aligned
+		gp->rx_ring = dma_alloc_noncoherent(NULL,
+					sizeof(gt64240_rd_t) * RX_RING_SIZE +
+					sizeof(gt64240_td_t) * TX_RING_SIZE,
+					&gp->rx_ring_dma, GFP_KERNEL);
+		if (gp->rx_ring == NULL) {
+			retval = -ENOMEM;
+			goto free_region;
+		}
+
+		gp->tx_ring = (gt64240_td_t *) (gp->rx_ring + RX_RING_SIZE);
+		gp->tx_ring_dma =
+			gp->rx_ring_dma + sizeof(gt64240_rd_t) * RX_RING_SIZE;
+	}
+	// Allocate the Rx Data Buffers
+	if (gp->rx_buff == NULL) {
+		gp->rx_buff = dma_alloc_coherent(NULL,
+				PKT_BUF_SZ * RX_RING_SIZE, &gp->rx_buff_dma,
+				GFP_KERNEL);
+		if (gp->rx_buff == NULL) {
+			dma_free_noncoherent(NULL,
+				sizeof(gt64240_rd_t) * RX_RING_SIZE +
+				sizeof(gt64240_td_t) * TX_RING_SIZE,
+				gp->rx_ring, gp->rx_ring_dma);
+			retval = -ENOMEM;
+			goto free_region;
+		}
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_probe1, rx_ring=%p, tx_ring=%p\n",
+		       dev->name, gp->rx_ring, gp->tx_ring);
+
+	// Allocate Rx Hash Table
+	if (gp->hash_table == NULL) {
+		gp->hash_table = dma_alloc_coherent(NULL,
+				RX_HASH_TABLE_SIZE, &gp->hash_table_dma,
+				GFP_KERNEL);
+		if (gp->hash_table == NULL) {
+			dma_free_noncoherent(NULL,
+				sizeof(gt64240_rd_t) * RX_RING_SIZE +
+				sizeof(gt64240_td_t) * TX_RING_SIZE,
+				gp->rx_ring, gp->rx_ring_dma);
+			dma_free_noncoherent(NULL, PKT_BUF_SZ * RX_RING_SIZE,
+				gp->rx_buff, gp->rx_buff_dma);
+			retval = -ENOMEM;
+			goto free_region;
+		}
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_probe1, hash=%p\n",
+		       dev->name, gp->hash_table);
+
+	spin_lock_init(&gp->lock);
+
+	dev->open = gt64240_open;
+	dev->hard_start_xmit = gt64240_tx;
+	dev->stop = gt64240_close;
+	dev->get_stats = gt64240_get_stats;
+	dev->do_ioctl = gt64240_ioctl;
+	dev->set_multicast_list = gt64240_set_rx_mode;
+	dev->tx_timeout = gt64240_tx_timeout;
+	dev->watchdog_timeo = GT64240ETH_TX_TIMEOUT;
+
+#ifdef GT64240_NAPI
+	dev->poll = gt64240_poll;
+	dev->weight = 64;
+#endif
+	dev->ethtool_ops = &gp_ethtool_ops;
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	return 0;
+
+free_region:
+	release_region(ioaddr, gp->io_size);
+	unregister_netdev(dev);
+	free_netdev(dev);
+	printk("%s: gt64240_probe1 failed.  Returns %d\n",
+	       dev->name, retval);
+	return retval;
+}
+
+
+static void reset_tx(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int i;
+
+	abort(dev, sdcmrAT);
+
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		if (gp->tx_skbuff[i]) {
+			if (in_interrupt())
+				dev_kfree_skb_irq(gp->tx_skbuff[i]);
+			else
+				dev_kfree_skb(gp->tx_skbuff[i]);
+			gp->tx_skbuff[i] = NULL;
+		}
+//-     gp->tx_ring[i].cmdstat = 0; // CPU owns
+		gp->tx_ring[i].cmdstat =
+		    (u32) (txGenCRC | txEI | txPad | txFirst | txLast);
+		gp->tx_ring[i].byte_cnt = 0;
+		gp->tx_ring[i].buff_ptr = 0;
+		gp->tx_ring[i].next =
+		    gp->tx_ring_dma + sizeof(gt64240_td_t) * (i + 1);
+		if (gt64240_debug > 4)
+			dump_tx_desc(dev, i);
+	}
+	/* Wrap the ring. */
+	gp->tx_ring[i - 1].next = gp->tx_ring_dma;
+	if (gt64240_debug > 4)
+		dump_tx_desc(dev, i - 1);
+
+	// setup only the lowest priority TxCDP reg
+	GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0,
+			 gp->tx_ring_dma);
+//- GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0, 0);     /* ROLLINS */
+//- GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0,virt_to_phys(&gp->tx_ring[0]));  /* ROLLINS */
+
+	GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR1, 0);
+
+	// init Tx indeces and pkt counter
+	gp->tx_next_in = gp->tx_next_out = 0;
+	gp->tx_count = 0;
+}
+
+static void reset_rx(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int i;
+
+	abort(dev, sdcmrAR);
+
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		gp->rx_ring[i].next =
+		    gp->rx_ring_dma + sizeof(gt64240_rd_t) * (i + 1);
+		gp->rx_ring[i].buff_ptr = gp->rx_buff_dma + i * PKT_BUF_SZ;
+		gp->rx_ring[i].buff_sz = PKT_BUF_SZ;
+		gp->rx_ring[i].byte_cnt = 0;	/* just for debug printk's */
+		// Give ownership to device, set first and last, enable interrupt
+		gp->rx_ring[i].cmdstat =
+		    (uint32_t) (rxFirst | rxLast | rxOwn | rxEI);
+		if (gt64240_debug > 4)
+			dump_rx_desc(dev, i);
+	}
+	/* Wrap the ring. */
+	gp->rx_ring[i - 1].next = gp->rx_ring_dma;
+	if (gt64240_debug > 4)
+		dump_rx_desc(dev, i - 1);
+
+	// Setup only the lowest priority RxFDP and RxCDP regs
+	for (i = 0; i < 4; i++) {
+		if (i == 0) {
+			GT64240ETH_WRITE(gp, GT64240_ETH_1ST_RX_DESC_PTR0,
+					 gp->rx_ring_dma);
+			GT64240ETH_WRITE(gp, GT64240_ETH_CURR_RX_DESC_PTR0,
+					 gp->rx_ring_dma);
+		} else {
+			GT64240ETH_WRITE(gp,
+					 GT64240_ETH_1ST_RX_DESC_PTR0 +
+					 i * 4, 0);
+			GT64240ETH_WRITE(gp,
+					 GT64240_ETH_CURR_RX_DESC_PTR0 +
+					 i * 4, 0);
+		}
+	}
+
+	// init Rx NextOut index
+	gp->rx_next_out = 0;
+}
+
+
+static int gt64240_init(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+
+	if (gt64240_debug > 3) {
+		printk("%s: gt64240_init: dev=%p\n", dev->name, dev);
+		printk("%s: gt64240_init: scs0_lo=%04x, scs0_hi=%04x\n",
+		       dev->name, GT64240_READ(0x008),
+		       GT64240_READ(0x010));
+		printk("%s: gt64240_init: scs1_lo=%04x, scs1_hi=%04x\n",
+		       dev->name, GT64240_READ(0x208),
+		       GT64240_READ(0x210));
+		printk("%s: gt64240_init: scs2_lo=%04x, scs2_hi=%04x\n",
+		       dev->name, GT64240_READ(0x018),
+		       GT64240_READ(0x020));
+		printk("%s: gt64240_init: scs3_lo=%04x, scs3_hi=%04x\n",
+		       dev->name, GT64240_READ(0x218),
+		       GT64240_READ(0x220));
+	}
+	// Stop and disable Port
+	hard_stop(dev);
+
+	GT64240_WRITE(COMM_UNIT_INTERRUPT_MASK, 0x07070777);	/*+prk21aug01 */
+	if (gt64240_debug > 2)
+		printk
+		    ("%s: gt64240_init: CIU Cause=%08x, Mask=%08x, EAddr=%08x\n",
+		     dev->name, GT64240_READ(COMM_UNIT_INTERRUPT_CAUSE),
+		     GT64240_READ(COMM_UNIT_INTERRUPT_MASK),
+		     GT64240_READ(COMM_UNIT_ERROR_ADDRESS));
+
+	// Set-up hash table
+	memset(gp->hash_table, 0, RX_HASH_TABLE_SIZE);	// clear it
+	gp->hash_mode = 0;
+	// Add a single entry to hash table - our ethernet address
+	gt64240_add_hash_entry(dev, dev->dev_addr);
+	// Set-up DMA ptr to hash table
+	GT64240ETH_WRITE(gp, GT64240_ETH_HASH_TBL_PTR, gp->hash_table_dma);
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Hash Tbl Ptr=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_HASH_TBL_PTR));
+
+	// Setup Tx
+	reset_tx(dev);
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Curr Tx Desc Ptr0=%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_CURR_TX_DESC_PTR0));
+
+	// Setup Rx
+	reset_rx(dev);
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: 1st/Curr Rx Desc Ptr0=%x/%x\n",
+		       dev->name, GT64240ETH_READ(gp,
+						  GT64240_ETH_1ST_RX_DESC_PTR0),
+		       GT64240ETH_READ(gp, GT64240_ETH_CURR_RX_DESC_PTR0));
+
+	if (gt64240_debug > 3)
+		dump_MII(dev);
+
+	/* force a PHY reset -- self-clearing! */
+	write_MII(dev, gp->phy_addr, 0, 0x8000);
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: PhyAD=%x\n", dev->name,
+		       GT64240_READ(GT64240_ETH_PHY_ADDR_REG));
+
+	// setup DMA
+	// We want the Rx/Tx DMA to write/read data to/from memory in
+	// Big Endian mode. Also set DMA Burst Size to 8 64Bit words.
+#ifdef DESC_DATA_BE
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_CONFIG,
+			 (0xf << sdcrRCBit) | sdcrRIFB | (3 <<
+							  sdcrBSZBit));
+#else
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_CONFIG, sdcrBLMR | sdcrBLMT |
+//-                  (0xf<<sdcrRCBit) | sdcrRIFB | (3<<sdcrBSZBit));
+			 (0xf << sdcrRCBit) | sdcrRIFB | (2 <<
+							  sdcrBSZBit));
+#endif
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: SDMA Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_SDMA_CONFIG));
+
+#if 0
+	// start Rx DMA
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, sdcmrERD);
+#endif
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: SDMA Cmd =%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_SDMA_COMM));
+
+#if 1
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG, PORT_CONFIG);
+#endif
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG));
+
+	/*
+	 * Disable all Type-of-Service queueing. All Rx packets will be
+	 * treated normally and will be sent to the lowest priority
+	 * queue.
+	 *
+	 * Disable flow-control for now. FIX! support flow control?
+	 */
+
+#if 1
+	// clear all the MIB ctr regs
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG_EXT,
+			 EXT_CONFIG_CLEAR);
+	read_mib_counters(gp);
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG_EXT,
+			 EXT_CONFIG_CLEAR | pcxrMIBclrMode);
+
+#endif
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Config Ext=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG_EXT));
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Command=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_COMMAND));
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_COMMAND, 0x0);
+
+	netif_start_queue(dev);
+
+	/* enable the port */
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG,
+			 (PORT_CONFIG | pcrEN));
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_init: Port Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG));
+#if 1
+	// start Rx DMA
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, sdcmrERD);
+#endif
+
+
+	// enable interrupts
+	enable_ether_irq(dev);
+
+//---    gp->last_psr |= psrLink;   /* KLUDGE ALERT */
+
+	// we should now be receiving frames
+	return 0;
+}
+
+
+static int gt64240_open(struct net_device *dev)
+{
+	int retval;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_open: dev=%p\n", dev->name, dev);
+
+	if ((retval = request_irq(dev->irq, &gt64240_interrupt,
+				  SA_SHIRQ, dev->name, dev))) {
+		printk("%s: unable to get IRQ %d\n", dev->name, dev->irq);
+
+		return retval;
+	}
+	// Initialize and startup the GT-64240 ethernet port
+	if ((retval = gt64240_init(dev))) {
+		printk("%s: error in gt64240_open\n", dev->name);
+		free_irq(dev->irq, dev);
+
+		return retval;
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_open: Initialization done.\n",
+		       dev->name);
+
+	return 0;
+}
+
+static int gt64240_close(struct net_device *dev)
+{
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_close: dev=%p\n", dev->name, dev);
+
+	// stop the device
+	if (netif_device_present(dev)) {
+		netif_stop_queue(dev);
+		hard_stop(dev);
+	}
+
+	free_irq(dev->irq, dev);
+
+	return 0;
+}
+
+#ifdef GT64240_NAPI
+/*
+ * Function will release Tx skbs which are now complete
+ */
+static void gt64240_tx_fill(struct net_device *dev, u32 status)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	int nextOut, cdp;
+	gt64240_td_t *td;
+	u32 cmdstat;
+
+	cdp = (GT64240ETH_READ(gp, GT64240_ETH_CURR_TX_DESC_PTR0)
+	       - gp->tx_ring_dma) / sizeof(gt64240_td_t);
+
+	for (nextOut = gp->tx_next_out; nextOut != cdp;
+	     nextOut = (nextOut + 1) % TX_RING_SIZE) {
+		if (--gp->intr_work_done == 0)
+			break;
+
+		td = &gp->tx_ring[nextOut];
+		cmdstat = td->cmdstat;
+
+		if (cmdstat & (u32) txOwn)
+			break;
+
+		if (gp->tx_full) {
+			gp->tx_full = 0;
+			if (gp->last_psr & psrLink) {
+				netif_wake_queue(dev);
+			}
+		}
+		// decrement tx ring buffer count
+		if (gp->tx_count)
+			gp->tx_count--;
+
+		// free the skb
+		if (gp->tx_skbuff[nextOut]) {
+			dev_kfree_skb_irq(gp->tx_skbuff[nextOut]);
+			gp->tx_skbuff[nextOut] = NULL;
+		}
+	}
+
+	gp->tx_next_out = nextOut;
+
+	if ((status & icrTxEndLow) && gp->tx_count != 0)
+		// we must restart the DMA
+		GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM,
+				 sdcmrERD | sdcmrTXDL);
+}
+
+/*
+ * Main function for NAPI
+ */
+static int gt64240_poll(struct net_device *dev, int *budget)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+	int done = 1, orig_budget, work_done;
+	u32 status = GT64240ETH_READ(gp, GT64240_ETH_INT_CAUSE);
+
+	spin_lock_irqsave(&gp->lock, flags);
+	gt64240_tx_fill(dev, status);
+
+	if (GT64240ETH_READ(gp, GT64240_ETH_CURR_RX_DESC_PTR0) !=
+	    gp->rx_next_out) {
+		orig_budget = *budget;
+		if (orig_budget > dev->quota)
+			orig_budget = dev->quota;
+
+		work_done = gt64240_rx(dev, status, orig_budget);
+		*budget -= work_done;
+		dev->quota -= work_done;
+		if (work_done >= orig_budget)
+			done = 0;
+		if (done) {
+			__netif_rx_complete(dev);
+			enable_ether_irq(dev);
+		}
+	}
+
+	spin_unlock_irqrestore(&gp->lock, flags);
+
+	return (done ? 0 : 1);
+}
+#endif
+
+static int gt64240_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+	int nextIn;
+
+	spin_lock_irqsave(&gp->lock, flags);
+
+	nextIn = gp->tx_next_in;
+
+	if (gt64240_debug > 3) {
+		printk("%s: gt64240_tx: nextIn=%d.\n", dev->name, nextIn);
+	}
+
+	if (gp->tx_count >= TX_RING_SIZE) {
+		printk("%s: Tx Ring full, pkt dropped.\n", dev->name);
+		gp->stats.tx_dropped++;
+		spin_unlock_irqrestore(&gp->lock, flags);
+		return 1;
+	}
+
+	if (!(gp->last_psr & psrLink)) {
+		printk("%s: gt64240_tx: Link down, pkt dropped.\n",
+		       dev->name);
+		gp->stats.tx_dropped++;
+		spin_unlock_irqrestore(&gp->lock, flags);
+//---   dump_MII(dev);          /* KLUDGE ALERT !!! */
+		return 1;
+	}
+
+	if (gp->tx_ring[nextIn].cmdstat & txOwn) {
+		printk
+		    ("%s: gt64240_tx: device owns descriptor, pkt dropped.\n",
+		     dev->name);
+		gp->stats.tx_dropped++;
+		// stop the queue, so Tx timeout can fix it
+		netif_stop_queue(dev);
+		spin_unlock_irqrestore(&gp->lock, flags);
+		return 1;
+	}
+	// Prepare the Descriptor at tx_next_in
+	gp->tx_skbuff[nextIn] = skb;
+	gp->tx_ring[nextIn].byte_cnt = skb->len;
+	gp->tx_ring[nextIn].buff_ptr = virt_to_phys(skb->data);
+
+	// make sure packet gets written back to memory
+	dma_cache_wback_inv((unsigned long) (skb->data), skb->len);
+	mb();
+
+	// Give ownership to device, set first and last desc, enable interrupt
+	// Setting of ownership bit must be *last*!
+	gp->tx_ring[nextIn].cmdstat =
+	    txOwn | txGenCRC | txEI | txPad | txFirst | txLast;
+
+	if (gt64240_debug > 5) {
+		dump_tx_desc(dev, nextIn);
+	}
+	// increment tx_next_in with wrap
+	gp->tx_next_in = (nextIn + 1) % TX_RING_SIZE;
+
+//+prk20aug01:
+	if (0) {		/* ROLLINS */
+		GT64240ETH_WRITE(gp, GT64240_ETH_CURR_TX_DESC_PTR0,
+				 virt_to_phys(&gp->tx_ring[nextIn]));
+	}
+
+	if (gt64240_debug > 3) {	/*+prk17aug01 */
+		printk
+		    ("%s: gt64240_tx: TX_PTR0=0x%08x, EthPortStatus=0x%08x\n",
+		     dev->name, GT64240ETH_READ(gp,
+						GT64240_ETH_CURR_TX_DESC_PTR0),
+		     GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS));
+	}
+	// If DMA is stopped, restart
+	if (!((GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS)) & psrTxLow)) {
+		GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM,
+				 sdcmrERD | sdcmrTXDL);
+	}
+
+	if (gt64240_debug > 3) {	/*+prk17aug01 */
+		printk
+		    ("%s: gt64240_tx: TX_PTR0=0x%08x, EthPortStatus=0x%08x\n",
+		     dev->name, GT64240ETH_READ(gp,
+						GT64240_ETH_CURR_TX_DESC_PTR0),
+		     GT64240ETH_READ(gp, GT64240_ETH_PORT_STATUS));
+	}
+	// increment count and stop queue if full
+	if (++gp->tx_count >= TX_RING_SIZE) {
+		gp->tx_full = 1;
+		netif_stop_queue(dev);
+	}
+
+	dev->trans_start = jiffies;
+	spin_unlock_irqrestore(&gp->lock, flags);
+
+	return 0;
+}
+
+
+static int
+#ifdef GT64240_NAPI
+gt64240_rx(struct net_device *dev, u32 status, int budget)
+#else
+gt64240_rx(struct net_device *dev, u32 status)
+#endif
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	struct sk_buff *skb;
+	int pkt_len, nextOut, cdp;
+	gt64240_rd_t *rd;
+	u32 cmdstat;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_rx: dev=%p, status=%x\n",
+		       dev->name, dev, status);
+
+	cdp = (GT64240ETH_READ(gp, GT64240_ETH_CURR_RX_DESC_PTR0)
+	       - gp->rx_ring_dma) / sizeof(gt64240_rd_t);
+
+	// Continue until we reach the current descriptor pointer
+	for (nextOut = gp->rx_next_out; nextOut != cdp;
+	     nextOut = (nextOut + 1) % RX_RING_SIZE) {
+
+#ifdef GT64240_NAPI
+		if (budget <= 0)
+			break;
+
+		budget--;
+#endif
+
+		if (--gp->intr_work_done == 0)
+			break;
+
+		if (gt64240_debug > 4)
+			dump_rx_desc(dev, nextOut);
+
+		rd = &gp->rx_ring[nextOut];
+		cmdstat = rd->cmdstat;
+
+		if (gt64240_debug > 3)
+			printk("%s: isr: Rx desc cmdstat=%x, nextOut=%d\n",
+			       dev->name, cmdstat, nextOut);
+
+		if (cmdstat & (u32) rxOwn) {
+			if (gt64240_debug > 2)
+				printk
+				    ("%s: gt64240_rx: device owns descriptor!\n",
+				     dev->name);
+			// DMA is not finished updating descriptor???
+			// Leave and come back later to pick-up where we left off.
+			break;
+		}
+		// must be first and last (ie only) buffer of packet
+		if (!(cmdstat & (u32) rxFirst)
+		    || !(cmdstat & (u32) rxLast)) {
+			printk
+			    ("%s: gt64240_rx: desc not first and last!\n",
+			     dev->name);
+			cmdstat |= (u32) rxOwn;
+			rd->cmdstat = cmdstat;
+			continue;
+		}
+		// Drop this received pkt if there were any errors
+		if ((cmdstat & (u32) rxErrorSummary)
+		    || (status & icrRxError)) {
+			// update the detailed rx error counters that are not covered
+			// by the MIB counters.
+			if (cmdstat & (u32) rxOverrun)
+				gp->stats.rx_fifo_errors++;
+			cmdstat |= (u32) rxOwn;
+			rd->cmdstat = cmdstat;
+			continue;
+		}
+
+		pkt_len = rd->byte_cnt;
+
+		/* Create new skb. */
+//      skb = dev_alloc_skb(pkt_len+2);
+		skb = dev_alloc_skb(1538);
+		if (skb == NULL) {
+			printk("%s: Memory squeeze, dropping packet.\n",
+			       dev->name);
+			gp->stats.rx_dropped++;
+			cmdstat |= (u32) rxOwn;
+			rd->cmdstat = cmdstat;
+			continue;
+		}
+		skb->dev = dev;
+		skb_reserve(skb, 2);	/* 16 byte IP header align */
+		memcpy(skb_put(skb, pkt_len),
+		       &gp->rx_buff[nextOut * PKT_BUF_SZ], pkt_len);
+		skb->protocol = eth_type_trans(skb, dev);
+
+		/* NIC performed some checksum computation */
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+#ifdef GT64240_NAPI
+		netif_receive_skb(skb);
+#else
+		netif_rx(skb);	/* pass the packet to upper layers */
+#endif
+
+		// now we can release ownership of this desc back to device
+		cmdstat |= (u32) rxOwn;
+		rd->cmdstat = cmdstat;
+
+		dev->last_rx = jiffies;
+	}
+
+	if (gt64240_debug > 3 && nextOut == gp->rx_next_out)
+		printk("%s: gt64240_rx: RxCDP did not increment?\n",
+		       dev->name);
+
+	gp->rx_next_out = nextOut;
+	return 0;
+}
+
+
+static void gt64240_tx_timeout(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&gp->lock, flags);
+
+
+	if (!(gp->last_psr & psrLink)) {
+		spin_unlock_irqrestore(&gp->lock, flags);
+	} else {
+		printk("======------> gt64240_tx_timeout: %d jiffies \n",
+		       GT64240ETH_TX_TIMEOUT);
+
+		disable_ether_irq(dev);
+		spin_unlock_irqrestore(&gp->lock, flags);
+		reset_tx(dev);
+		enable_ether_irq(dev);
+
+		netif_wake_queue(dev);
+	}
+}
+
+
+static void gt64240_set_rx_mode(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+	struct dev_mc_list *mcptr;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_set_rx_mode: dev=%p, flags=%x\n",
+		       dev->name, dev, dev->flags);
+
+	// stop the Receiver DMA
+	abort(dev, sdcmrAR);
+
+	spin_lock_irqsave(&gp->lock, flags);
+
+	if (dev->flags & IFF_PROMISC)
+		GT64240ETH_SETBIT(gp, GT64240_ETH_PORT_CONFIG, pcrPM);
+	else
+		GT64240ETH_CLRBIT(gp, GT64240_ETH_PORT_CONFIG, pcrPM);
+/*
+	GT64240ETH_WRITE(gp, GT64240_ETH_PORT_CONFIG,
+		(PORT_CONFIG | pcrPM | pcrEN));
+*/
+
+	memset(gp->hash_table, 0, RX_HASH_TABLE_SIZE);	// clear hash table
+	// Add our ethernet address
+	gt64240_add_hash_entry(dev, dev->dev_addr);
+	if (dev->mc_count) {
+		for (mcptr = dev->mc_list; mcptr; mcptr = mcptr->next) {
+			if (gt64240_debug > 2) {
+				printk("%s: gt64240_set_rx_mode: addr=\n",
+				       dev->name);
+				dump_hw_addr(mcptr->dmi_addr);
+			}
+			gt64240_add_hash_entry(dev, mcptr->dmi_addr);
+		}
+	}
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_set_rx: Port Config=%x\n", dev->name,
+		       GT64240ETH_READ(gp, GT64240_ETH_PORT_CONFIG));
+
+	// restart Rx DMA
+	GT64240ETH_WRITE(gp, GT64240_ETH_SDMA_COMM, sdcmrERD);
+
+	spin_unlock_irqrestore(&gp->lock, flags);
+}
+
+static struct net_device_stats *gt64240_get_stats(struct net_device *dev)
+{
+	struct gt64240_private *gp = netdev_priv(dev);
+	unsigned long flags;
+
+	if (gt64240_debug > 3)
+		printk("%s: gt64240_get_stats: dev=%p\n", dev->name, dev);
+
+	if (netif_device_present(dev)) {
+		spin_lock_irqsave(&gp->lock, flags);
+		update_stats(gp);
+		spin_unlock_irqrestore(&gp->lock, flags);
+	}
+
+	return &gp->stats;
+}
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/gt64240eth.h linux_HEAD/drivers/net/gt64240eth.h
--- linux-2.6.11.6/drivers/net/gt64240eth.h	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/drivers/net/gt64240eth.h	2005-02-17 21:49:49.000000000 +0100
@@ -9,6 +9,7 @@
  * Copyright 2000 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
  *         	stevel@mvista.com or support@mvista.com
+ * Copyright 2004, 05 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -31,6 +32,7 @@
 #ifndef _GT64240ETH_H
 #define _GT64240ETH_H
 
+#include <linux/config.h>
 #include <asm/gt64240.h>
 
 #define ETHERNET_PORTS_DIFFERENCE_OFFSETS	0x400
@@ -108,10 +110,10 @@
 #define REV_GT64240A 0x10
 
 #define GT64240ETH_READ(gp, offset)					\
-	GT_READ((gp)->port_offset + (offset))
+	MV_READ((gp)->port_offset + (offset))
 
 #define GT64240ETH_WRITE(gp, offset, data)				\
-	GT_WRITE((gp)->port_offset + (offset), (data))
+	MV_WRITE((gp)->port_offset + (offset), (data))
 
 #define GT64240ETH_SETBIT(gp, offset, bits)				\
 	GT64240ETH_WRITE((gp), (offset),				\
@@ -121,8 +123,8 @@
 	GT64240ETH_WRITE((gp), (offset),				\
 	                 GT64240ETH_READ((gp), (offset)) & ~(bits))
 
-#define GT64240_READ(ofs)		GT_READ(ofs)
-#define GT64240_WRITE(ofs, data)	GT_WRITE((ofs), (data))
+#define GT64240_READ(ofs)		MV_READ(ofs)
+#define GT64240_WRITE(ofs, data)	MV_WRITE((ofs), (data))
 
 /* Bit definitions of the SMI Reg */
 enum {
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/saa9730.c linux_HEAD/drivers/net/saa9730.c
--- linux-2.6.11.6/drivers/net/saa9730.c	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/drivers/net/saa9730.c	2005-02-17 21:49:50.000000000 +0100
@@ -1,8 +1,7 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
- *
- * ########################################################################
+ * Copyright (C) 2000, 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -17,15 +16,13 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
  *
- * ########################################################################
- *
  * SAA9730 ethernet driver.
  *
  * Changes:
- * Angelo Dell'Aera <buffer@antifork.org> : Conversion to the new PCI API (pci_driver).
- *                                          Conversion to spinlocks.
- *                                          Error handling fixes.
- *                                           
+ * Angelo Dell'Aera <buffer@antifork.org> :	Conversion to the new PCI API
+ *						(pci_driver).
+ *						Conversion to spinlocks.
+ *						Error handling fixes.
  */
 
 #include <linux/init.h>
@@ -36,8 +33,11 @@
 #include <linux/skbuff.h>
 #include <linux/pci.h>
 #include <linux/spinlock.h>
+#include <linux/types.h>
 
 #include <asm/addrspace.h>
+#include <asm/io.h>
+
 #include <asm/mips-boards/prom.h>
 
 #include "saa9730.h"
@@ -51,8 +51,8 @@ int lan_saa9730_debug;
 #define DRV_MODULE_NAME "saa9730"
 
 static struct pci_device_id saa9730_pci_tbl[] = {
-	{ PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA9370,
-          PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA9730,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 	{ 0, }
 };
 
@@ -61,8 +61,8 @@ MODULE_DEVICE_TABLE(pci, saa9730_pci_tbl
 /* Non-zero only if the current card is a PCI with BIOS-set IRQ. */
 static unsigned int pci_irq_line;
 
-#define INL(a)     inl((unsigned long)a)
-#define OUTL(x,a)  outl(x,(unsigned long)a)
+#define INL(a)		readl(a)
+#define OUTL(x, a)	writel(x, a)
 
 static void evm_saa9730_enable_lan_int(struct lan_saa9730_private *lp)
 {
@@ -98,13 +98,13 @@ static void evm_saa9730_unblock_lan_int(
 	     &lp->evm_saa9730_regs->InterruptBlock1);
 }
 
-static void show_saa9730_regs(struct lan_saa9730_private *lp)
+static void __attribute_used__ show_saa9730_regs(struct lan_saa9730_private *lp)
 {
 	int i, j;
-	printk("TxmBufferA = %x\n", lp->TxmBuffer[0][0]);
-	printk("TxmBufferB = %x\n", lp->TxmBuffer[1][0]);
-	printk("RcvBufferA = %x\n", lp->RcvBuffer[0][0]);
-	printk("RcvBufferB = %x\n", lp->RcvBuffer[1][0]);
+	printk("TxmBufferA = %p\n", lp->TxmBuffer[0][0]);
+	printk("TxmBufferB = %p\n", lp->TxmBuffer[1][0]);
+	printk("RcvBufferA = %p\n", lp->RcvBuffer[0][0]);
+	printk("RcvBufferB = %p\n", lp->RcvBuffer[1][0]);
 	for (i = 0; i < LAN_SAA9730_BUFFERS; i++) {
 		for (j = 0; j < LAN_SAA9730_TXM_Q_SIZE; j++) {
 			printk("TxmBuffer[%d][%d] = %x\n", i, j,
@@ -214,88 +214,95 @@ static void lan_saa9730_buffer_init(stru
 	}
 }
 
-static int lan_saa9730_allocate_buffers(struct lan_saa9730_private *lp)
+static void lan_saa9730_free_buffers(struct pci_dev *pdev,
+				     struct lan_saa9730_private *lp)
 {
-	unsigned int mem_size;
-	void *Pa;
-	unsigned int i, j, RcvBufferSize, TxmBufferSize;
-	unsigned int buffer_start;
+	pci_free_consistent(pdev, lp->buffer_size, lp->buffer_start,
+			    lp->dma_addr);
+}
 
-	/* 
-	 * Allocate all RX and TX packets in one chunk. 
-	 * The Rx and Tx packets must be PACKET_SIZE aligned.
-	 */
-	mem_size = ((LAN_SAA9730_RCV_Q_SIZE + LAN_SAA9730_TXM_Q_SIZE) *
-		    LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_BUFFERS) +
-	    LAN_SAA9730_PACKET_SIZE;
-	buffer_start =
-	    (unsigned int) kmalloc(mem_size, GFP_DMA | GFP_KERNEL);
-
-	if (!buffer_start)
-		return -ENOMEM;
-
-	/* 
-	 * Set DMA buffer to kseg1 (uncached).
-	 * Make sure to flush before using it uncached.
-	 */
-	Pa = (void *) KSEG1ADDR((buffer_start + LAN_SAA9730_PACKET_SIZE) &
-				~(LAN_SAA9730_PACKET_SIZE - 1));
-	dma_cache_wback_inv((unsigned long) Pa, mem_size);
+static int lan_saa9730_allocate_buffers(struct pci_dev *pdev,
+					struct lan_saa9730_private *lp)
+{
+	void *Pa;
+	unsigned int i, j, rxoffset, txoffset;
+	int ret;
 
 	/* Initialize buffer space */
-	RcvBufferSize = LAN_SAA9730_PACKET_SIZE;
-	TxmBufferSize = LAN_SAA9730_PACKET_SIZE;
 	lp->DmaRcvPackets = LAN_SAA9730_RCV_Q_SIZE;
 	lp->DmaTxmPackets = LAN_SAA9730_TXM_Q_SIZE;
 
+	/* Initialize Rx Buffer Index */
+	lp->NextRcvPacketIndex = 0;
+	lp->NextRcvBufferIndex = 0;
+
+	/* Set current buffer index & next available packet index */
+	lp->NextTxmPacketIndex = 0;
+	lp->NextTxmBufferIndex = 0;
+	lp->PendingTxmPacketIndex = 0;
+	lp->PendingTxmBufferIndex = 0;
+
+	/*
+	 * Allocate all RX and TX packets in one chunk.
+	 * The Rx and Tx packets must be PACKET_SIZE aligned.
+	 */
+	lp->buffer_size = ((LAN_SAA9730_RCV_Q_SIZE + LAN_SAA9730_TXM_Q_SIZE) *
+			   LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_BUFFERS) +
+			  LAN_SAA9730_PACKET_SIZE;
+	lp->buffer_start = pci_alloc_consistent(pdev, lp->buffer_size,
+						&lp->dma_addr);
+	if (!lp->buffer_start) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	Pa = (void *)ALIGN((unsigned long)lp->buffer_start,
+			   LAN_SAA9730_PACKET_SIZE);
+
+	rxoffset = Pa - lp->buffer_start;
+
 	/* Init RX buffers */
 	for (i = 0; i < LAN_SAA9730_BUFFERS; i++) {
 		for (j = 0; j < LAN_SAA9730_RCV_Q_SIZE; j++) {
 			*(unsigned int *) Pa =
 			    cpu_to_le32(RXSF_READY <<
 					RX_STAT_CTL_OWNER_SHF);
-			lp->RcvBuffer[i][j] = (unsigned int) Pa;
-			Pa += RcvBufferSize;
+			lp->RcvBuffer[i][j] = Pa;
+			Pa += LAN_SAA9730_PACKET_SIZE;
 		}
 	}
 
+	txoffset = Pa - lp->buffer_start;
+
 	/* Init TX buffers */
 	for (i = 0; i < LAN_SAA9730_BUFFERS; i++) {
 		for (j = 0; j < LAN_SAA9730_TXM_Q_SIZE; j++) {
 			*(unsigned int *) Pa =
 			    cpu_to_le32(TXSF_EMPTY <<
 					TX_STAT_CTL_OWNER_SHF);
-			lp->TxmBuffer[i][j] = (unsigned int) Pa;
-			Pa += TxmBufferSize;
+			lp->TxmBuffer[i][j] = Pa;
+			Pa += LAN_SAA9730_PACKET_SIZE;
 		}
 	}
 
-	/* 
-	 * Set rx buffer A and rx buffer B to point to the first two buffer 
+	/*
+	 * Set rx buffer A and rx buffer B to point to the first two buffer
 	 * spaces.
 	 */
-	OUTL(PHYSADDR(lp->RcvBuffer[0][0]),
+	OUTL(lp->dma_addr + rxoffset,
 	     &lp->lan_saa9730_regs->RxBuffA);
-	OUTL(PHYSADDR(lp->RcvBuffer[1][0]),
+	OUTL(lp->dma_addr + rxoffset +
+	     LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_RCV_Q_SIZE,
 	     &lp->lan_saa9730_regs->RxBuffB);
 
-	/* Initialize Buffer Index */
-	lp->NextRcvPacketIndex = 0;
-	lp->NextRcvToUseIsA = 1;
-
-	/* Set current buffer index & next availble packet index */
-	lp->NextTxmPacketIndex = 0;
-	lp->NextTxmBufferIndex = 0;
-	lp->PendingTxmPacketIndex = 0;
-	lp->PendingTxmBufferIndex = 0;
-
-	/* 
+	/*
 	 * Set txm_buf_a and txm_buf_b to point to the first two buffer
-	 * space 
+	 * space
 	 */
-	OUTL(PHYSADDR(lp->TxmBuffer[0][0]),
+	OUTL(lp->dma_addr + txoffset,
 	     &lp->lan_saa9730_regs->TxBuffA);
-	OUTL(PHYSADDR(lp->TxmBuffer[1][0]),
+	OUTL(lp->dma_addr + txoffset +
+	     LAN_SAA9730_PACKET_SIZE * LAN_SAA9730_TXM_Q_SIZE,
 	     &lp->lan_saa9730_regs->TxBuffB);
 
 	/* Set packet number */
@@ -306,6 +313,9 @@ static int lan_saa9730_allocate_buffers(
 	     &lp->lan_saa9730_regs->PacketCount);
 
 	return 0;
+
+out:
+	return ret;
 }
 
 static int lan_saa9730_cam_load(struct lan_saa9730_private *lp)
@@ -328,8 +338,7 @@ static int lan_saa9730_cam_load(struct l
 
 static int lan_saa9730_cam_init(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned int i;
 
 	/* Copy MAC-address into all entries. */
@@ -469,9 +478,9 @@ static int lan_saa9730_control_init(stru
 	OUTL(CAM_CONTROL_COMP_EN | CAM_CONTROL_BROAD_ACC,
 	     &lp->lan_saa9730_regs->CamCtl);
 
-	/* 
+	/*
 	 * Initialize CAM enable register, only turn on first entry, should
-	 * contain own addr. 
+	 * contain own addr.
 	 */
 	OUTL(0x0001, &lp->lan_saa9730_regs->CamEnable);
 
@@ -501,7 +510,7 @@ static int lan_saa9730_stop(struct lan_s
 	OUTL(INL(&lp->lan_saa9730_regs->MacCtl) | MAC_CONTROL_RESET,
 	     &lp->lan_saa9730_regs->MacCtl);
 
-	/* 
+	/*
 	 * Wait for MAC reset to have finished. The reset bit is auto cleared
 	 * when the reset is done.
 	 */
@@ -536,9 +545,9 @@ static int lan_saa9730_start(struct lan_
 
 	/* Initialize Rx Buffer Index */
 	lp->NextRcvPacketIndex = 0;
-	lp->NextRcvToUseIsA = 1;
+	lp->NextRcvBufferIndex = 0;
 
-	/* Set current buffer index & next availble packet index */
+	/* Set current buffer index & next available packet index */
 	lp->NextTxmPacketIndex = 0;
 	lp->NextTxmBufferIndex = 0;
 	lp->PendingTxmPacketIndex = 0;
@@ -555,9 +564,8 @@ static int lan_saa9730_start(struct lan_
 	OUTL(INL(&lp->lan_saa9730_regs->RxCtl) | RX_CTL_RX_EN,
 	     &lp->lan_saa9730_regs->RxCtl);
 
-	/* Set Ok2Use to let hardware owns the buffers */
-	OUTL(OK2USE_RX_A | OK2USE_RX_B | OK2USE_TX_A | OK2USE_TX_B,
-	     &lp->lan_saa9730_regs->Ok2Use);
+	/* Set Ok2Use to let hardware own the buffers.  */
+	OUTL(OK2USE_RX_A | OK2USE_RX_B, &lp->lan_saa9730_regs->Ok2Use);
 
 	return 0;
 }
@@ -572,8 +580,7 @@ static int lan_saa9730_restart(struct la
 
 static int lan_saa9730_tx(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned int *pPacket;
 	unsigned int tx_status;
 
@@ -584,10 +591,8 @@ static int lan_saa9730_tx(struct net_dev
 	OUTL(DMA_STATUS_MAC_TX_INT, &lp->lan_saa9730_regs->DmaStatus);
 
 	while (1) {
-		pPacket =
-		    (unsigned int *) lp->TxmBuffer[lp->
-						   PendingTxmBufferIndex]
-		    [lp->PendingTxmPacketIndex];
+		pPacket = lp->TxmBuffer[lp->PendingTxmBufferIndex]
+				       [lp->PendingTxmPacketIndex];
 
 		/* Get status of first packet transmitted. */
 		tx_status = le32_to_cpu(*pPacket);
@@ -605,23 +610,22 @@ static int lan_saa9730_tx(struct net_dev
 			lp->stats.tx_errors++;
 			if (tx_status &
 			    (TX_STATUS_EX_COLL << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_aborted_errors++;
+				lp->stats.tx_aborted_errors++;
 			if (tx_status &
-			    (TX_STATUS_LATE_COLL <<
-			     TX_STAT_CTL_STATUS_SHF)) lp->stats.
-	     tx_window_errors++;
+			    (TX_STATUS_LATE_COLL << TX_STAT_CTL_STATUS_SHF))
+				lp->stats.tx_window_errors++;
 			if (tx_status &
 			    (TX_STATUS_L_CARR << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_carrier_errors++;
+				lp->stats.tx_carrier_errors++;
 			if (tx_status &
 			    (TX_STATUS_UNDER << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_fifo_errors++;
+				lp->stats.tx_fifo_errors++;
 			if (tx_status &
 			    (TX_STATUS_SQ_ERR << TX_STAT_CTL_STATUS_SHF))
-				    lp->stats.tx_heartbeat_errors++;
+				lp->stats.tx_heartbeat_errors++;
 
 			lp->stats.collisions +=
-			    tx_status & TX_STATUS_TX_COLL_MSK;
+				tx_status & TX_STATUS_TX_COLL_MSK;
 		}
 
 		/* Free buffer. */
@@ -636,21 +640,15 @@ static int lan_saa9730_tx(struct net_dev
 		}
 	}
 
-	/* Make sure A and B are available to hardware. */
-	OUTL(OK2USE_TX_A | OK2USE_TX_B, &lp->lan_saa9730_regs->Ok2Use);
-
-	if (netif_queue_stopped(dev)) {
-		/* The tx buffer is no longer full. */
-		netif_wake_queue(dev);
-	}
+	/* The tx buffer is no longer full. */
+	netif_wake_queue(dev);
 
 	return 0;
 }
 
 static int lan_saa9730_rx(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	int len = 0;
 	struct sk_buff *skb = 0;
 	unsigned int rx_status;
@@ -667,12 +665,9 @@ static int lan_saa9730_rx(struct net_dev
 	     DMA_STATUS_RX_TO_INT, &lp->lan_saa9730_regs->DmaStatus);
 
 	/* Address next packet */
-	if (lp->NextRcvToUseIsA)
-		BufferIndex = 0;
-	else
-		BufferIndex = 1;
+	BufferIndex = lp->NextRcvBufferIndex;
 	PacketIndex = lp->NextRcvPacketIndex;
-	pPacket = (unsigned int *) lp->RcvBuffer[BufferIndex][PacketIndex];
+	pPacket = lp->RcvBuffer[BufferIndex][PacketIndex];
 	rx_status = le32_to_cpu(*pPacket);
 
 	/* Process each packet. */
@@ -715,51 +710,39 @@ static int lan_saa9730_rx(struct net_dev
 			lp->stats.rx_errors++;
 			if (rx_status &
 			    (RX_STATUS_CRC_ERR << RX_STAT_CTL_STATUS_SHF))
-				    lp->stats.rx_crc_errors++;
+				lp->stats.rx_crc_errors++;
 			if (rx_status &
-			    (RX_STATUS_ALIGN_ERR <<
-			     RX_STAT_CTL_STATUS_SHF)) lp->stats.
-	     rx_frame_errors++;
+			    (RX_STATUS_ALIGN_ERR << RX_STAT_CTL_STATUS_SHF))
+				lp->stats.rx_frame_errors++;
 			if (rx_status &
 			    (RX_STATUS_OVERFLOW << RX_STAT_CTL_STATUS_SHF))
-				    lp->stats.rx_fifo_errors++;
+				lp->stats.rx_fifo_errors++;
 			if (rx_status &
 			    (RX_STATUS_LONG_ERR << RX_STAT_CTL_STATUS_SHF))
-				    lp->stats.rx_length_errors++;
+				lp->stats.rx_length_errors++;
 		}
 
 		/* Indicate we have processed the buffer. */
-		*pPacket =
-		    cpu_to_le32(RXSF_READY << RX_STAT_CTL_OWNER_SHF);
+		*pPacket = cpu_to_le32(RXSF_READY << RX_STAT_CTL_OWNER_SHF);
+
+		/* Make sure A or B is available to hardware as appropriate. */
+		OUTL(BufferIndex ? OK2USE_RX_B : OK2USE_RX_A,
+		     &lp->lan_saa9730_regs->Ok2Use);
 
 		/* Go to next packet in sequence. */
 		lp->NextRcvPacketIndex++;
 		if (lp->NextRcvPacketIndex >= LAN_SAA9730_RCV_Q_SIZE) {
 			lp->NextRcvPacketIndex = 0;
-			if (BufferIndex) {
-				lp->NextRcvToUseIsA = 1;
-			} else {
-				lp->NextRcvToUseIsA = 0;
-			}
+			lp->NextRcvBufferIndex ^= 1;
 		}
-		OUTL(OK2USE_RX_A | OK2USE_RX_B,
-		     &lp->lan_saa9730_regs->Ok2Use);
 
 		/* Address next packet */
-		if (lp->NextRcvToUseIsA)
-			BufferIndex = 0;
-		else
-			BufferIndex = 1;
+		BufferIndex = lp->NextRcvBufferIndex;
 		PacketIndex = lp->NextRcvPacketIndex;
-		pPacket =
-		    (unsigned int *) lp->
-		    RcvBuffer[BufferIndex][PacketIndex];
+		pPacket = lp->RcvBuffer[BufferIndex][PacketIndex];
 		rx_status = le32_to_cpu(*pPacket);
 	}
 
-	/* Make sure A and B are available to hardware. */
-	OUTL(OK2USE_RX_A | OK2USE_RX_B, &lp->lan_saa9730_regs->Ok2Use);
-
 	return 0;
 }
 
@@ -767,8 +750,7 @@ static irqreturn_t lan_saa9730_interrupt
 				  struct pt_regs *regs)
 {
 	struct net_device *dev = (struct net_device *) dev_id;
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	if (lan_saa9730_debug > 5)
 		printk("lan_saa9730_interrupt\n");
@@ -794,15 +776,9 @@ static irqreturn_t lan_saa9730_interrupt
 	return IRQ_HANDLED;
 }
 
-static int lan_saa9730_open_fail(struct net_device *dev)
-{
-	return -ENODEV;
-}
-
 static int lan_saa9730_open(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	/* Associate IRQ with lan_saa9730_interrupt */
 	if (request_irq(dev->irq, &lan_saa9730_interrupt, 0, "SAA9730 Eth",
@@ -834,15 +810,13 @@ static int lan_saa9730_write(struct lan_
 	int PacketIndex;
 
 	if (lan_saa9730_debug > 5)
-		printk("lan_saa9730_write: skb=%08x\n",
-		       (unsigned int) skb);
+		printk("lan_saa9730_write: skb=%p\n", skb);
 
 	BufferIndex = lp->NextTxmBufferIndex;
 	PacketIndex = lp->NextTxmPacketIndex;
 
-	tx_status =
-	    le32_to_cpu(*(unsigned int *) lp->
-			TxmBuffer[BufferIndex][PacketIndex]);
+	tx_status = le32_to_cpu(*(unsigned int *)lp->TxmBuffer[BufferIndex]
+							      [PacketIndex]);
 	if ((tx_status & TX_STAT_CTL_OWNER_MSK) !=
 	    (TXSF_EMPTY << TX_STAT_CTL_OWNER_SHF)) {
 		if (lan_saa9730_debug > 4)
@@ -858,29 +832,29 @@ static int lan_saa9730_write(struct lan_
 		lp->NextTxmBufferIndex ^= 1;
 	}
 
-	pbPacketData =
-	    (unsigned char *) lp->TxmBuffer[BufferIndex][PacketIndex];
+	pbPacketData = lp->TxmBuffer[BufferIndex][PacketIndex];
 	pbPacketData += 4;
 
 	/* copy the bits */
 	memcpy(pbPacketData, pbData, len);
 
 	/* Set transmit status for hardware */
-	*(unsigned int *) lp->TxmBuffer[BufferIndex][PacketIndex] =
-	    cpu_to_le32((TXSF_READY << TX_STAT_CTL_OWNER_SHF) |
-			(TX_STAT_CTL_INT_AFTER_TX << TX_STAT_CTL_FRAME_SHF)
-			| (len << TX_STAT_CTL_LENGTH_SHF));
+	*(unsigned int *)lp->TxmBuffer[BufferIndex][PacketIndex] =
+		cpu_to_le32((TXSF_READY << TX_STAT_CTL_OWNER_SHF) |
+			    (TX_STAT_CTL_INT_AFTER_TX <<
+			     TX_STAT_CTL_FRAME_SHF) |
+			    (len << TX_STAT_CTL_LENGTH_SHF));
 
-	/* Set hardware tx buffer. */
-	OUTL(OK2USE_TX_A | OK2USE_TX_B, &lp->lan_saa9730_regs->Ok2Use);
+	/* Make sure A or B is available to hardware as appropriate. */
+	OUTL(BufferIndex ? OK2USE_TX_B : OK2USE_TX_A,
+	     &lp->lan_saa9730_regs->Ok2Use);
 
 	return 0;
 }
 
 static void lan_saa9730_tx_timeout(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	/* Transmitter timeout, serious problems */
 	lp->stats.tx_errors++;
@@ -889,20 +863,19 @@ static void lan_saa9730_tx_timeout(struc
 	lan_saa9730_restart(lp);
 
 	dev->trans_start = jiffies;
-	netif_start_queue(dev);
+	netif_wake_queue(dev);
 }
 
 static int lan_saa9730_start_xmit(struct sk_buff *skb,
 				  struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned long flags;
 	int skblen;
 	int len;
 
 	if (lan_saa9730_debug > 4)
-		printk("Send packet: skb=%08x\n", (unsigned int) skb);
+		printk("Send packet: skb=%p\n", skb);
 
 	skblen = skb->len;
 
@@ -912,8 +885,7 @@ static int lan_saa9730_start_xmit(struct
 
 	if (lan_saa9730_write(lp, skb, skblen)) {
 		spin_unlock_irqrestore(&lp->lock, flags);
-		printk("Error when writing packet to controller: skb=%08x\n",
-		     (unsigned int) skb);
+		printk("Error when writing packet to controller: skb=%p\n", skb);
 		netif_stop_queue(dev);
 		return -1;
 	}
@@ -922,7 +894,7 @@ static int lan_saa9730_start_xmit(struct
 	lp->stats.tx_packets++;
 
 	dev->trans_start = jiffies;
-	netif_start_queue(dev);
+	netif_wake_queue(dev);
 	dev_kfree_skb(skb);
 
 	spin_unlock_irqrestore(&lp->lock, flags);
@@ -932,8 +904,7 @@ static int lan_saa9730_start_xmit(struct
 
 static int lan_saa9730_close(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	if (lan_saa9730_debug > 1)
 		printk("lan_saa9730_close:\n");
@@ -955,16 +926,14 @@ static int lan_saa9730_close(struct net_
 static struct net_device_stats *lan_saa9730_get_stats(struct net_device
 						      *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	return &lp->stats;
 }
 
 static void lan_saa9730_set_multicast(struct net_device *dev)
 {
-	struct lan_saa9730_private *lp =
-	    (struct lan_saa9730_private *) dev->priv;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
 	/* Stop the controller */
 	lan_saa9730_stop(lp);
@@ -981,7 +950,7 @@ static void lan_saa9730_set_multicast(st
 			     CAM_CONTROL_BROAD_ACC,
 			     &lp->lan_saa9730_regs->CamCtl);
 		} else {
-			/* 
+			/*
 			 * Will handle the multicast stuff later. -carstenl
 			 */
 		}
@@ -993,94 +962,86 @@ static void lan_saa9730_set_multicast(st
 
 static void __devexit saa9730_remove_one(struct pci_dev *pdev)
 {
-        struct net_device *dev = pci_get_drvdata(pdev);
-
-        if (dev) {
-                unregister_netdev(dev);
-
-		if (dev->priv)
-			kfree(dev->priv);
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 
-                free_netdev(dev);
-                pci_release_regions(pdev);
-                pci_disable_device(pdev);
-                pci_set_drvdata(pdev, NULL);
-        }
+	if (dev) {
+		unregister_netdev(dev);
+		lan_saa9730_free_buffers(pdev, lp);
+		iounmap(lp->lan_saa9730_regs);
+		iounmap(lp->evm_saa9730_regs);
+		free_netdev(dev);
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		pci_set_drvdata(pdev, NULL);
+	}
 }
 
 
-static int lan_saa9730_init(struct net_device *dev, int ioaddr, int irq)
+static int lan_saa9730_init(struct net_device *dev, struct pci_dev *pdev,
+	unsigned long ioaddr, int irq)
 {
-	struct lan_saa9730_private *lp;
+	struct lan_saa9730_private *lp = netdev_priv(dev);
 	unsigned char ethernet_addr[6];
-	int ret = 0;
+	int ret;
 
-	dev->open = lan_saa9730_open_fail;
+	if (get_ethernet_addr(ethernet_addr)) {
+		ret = -ENODEV;
+		goto out;
+	}
 
-	if (get_ethernet_addr(ethernet_addr))
-		return -ENODEV;
-	
 	memcpy(dev->dev_addr, ethernet_addr, 6);
 	dev->base_addr = ioaddr;
 	dev->irq = irq;
-	
-	/* 
-	 * Make certain the data structures used by the controller are aligned 
-	 * and DMAble. 
-	 */
-	/*
-	 *  XXX: that is obviously broken - kfree() won't be happy with us.
-	 */
-	lp = (struct lan_saa9730_private *) (((unsigned long)
-					      kmalloc(sizeof(*lp) + 7,
-						      GFP_DMA | GFP_KERNEL)
-					      + 7) & ~7);
 
-	if (!lp)
-		return -ENOMEM;
-
-	dev->priv = lp;
-	memset(lp, 0, sizeof(*lp));
+	lp->pci_dev = pdev;
 
 	/* Set SAA9730 LAN base address. */
-	lp->lan_saa9730_regs = (t_lan_saa9730_regmap *) (ioaddr +
-							 SAA9730_LAN_REGS_ADDR);
+	lp->lan_saa9730_regs = ioremap(ioaddr + SAA9730_LAN_REGS_ADDR,
+				       SAA9730_LAN_REGS_SIZE);
+	if (!lp->lan_saa9730_regs) {
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	/* Set SAA9730 EVM base address. */
-	lp->evm_saa9730_regs = (t_evm_saa9730_regmap *) (ioaddr +
-							 SAA9730_EVM_REGS_ADDR);
+	lp->evm_saa9730_regs = ioremap(ioaddr + SAA9730_EVM_REGS_ADDR,
+				       SAA9730_EVM_REGS_SIZE);
+	if (!lp->evm_saa9730_regs) {
+		ret = -ENOMEM;
+		goto out_iounmap_lan;
+	}
 
 	/* Allocate LAN RX/TX frame buffer space. */
-	/* FIXME: a leak */
-	if ((ret = lan_saa9730_allocate_buffers(lp)))
-		goto out;
+	if ((ret = lan_saa9730_allocate_buffers(pdev, lp)))
+		goto out_iounmap;
 
 	/* Stop LAN controller. */
-	if ((ret = lan_saa9730_stop(lp))) 
-		goto out;
-	
+	if ((ret = lan_saa9730_stop(lp)))
+		goto out_free_consistent;
+
 	/* Initialize CAM registers. */
 	if ((ret = lan_saa9730_cam_init(dev)))
-		goto out;
+		goto out_free_consistent;
 
 	/* Initialize MII registers. */
 	if ((ret = lan_saa9730_mii_init(lp)))
-		goto out;
+		goto out_free_consistent;
 
 	/* Initialize control registers. */
-	if ((ret = lan_saa9730_control_init(lp))) 
-		goto out;
-        
+	if ((ret = lan_saa9730_control_init(lp)))
+		goto out_free_consistent;
+
 	/* Load CAM registers. */
-	if ((ret = lan_saa9730_cam_load(lp))) 
-		goto out;
-	
+	if ((ret = lan_saa9730_cam_load(lp)))
+		goto out_free_consistent;
+
 	/* Initialize DMA context registers. */
 	if ((ret = lan_saa9730_dma_init(lp)))
-		goto out;
-	
+		goto out_free_consistent;
+
 	spin_lock_init(&lp->lock);
-		
+
 	dev->open = lan_saa9730_open;
 	dev->hard_start_xmit = lan_saa9730_start_xmit;
 	dev->stop = lan_saa9730_close;
@@ -1089,45 +1050,43 @@ static int lan_saa9730_init(struct net_d
 	dev->tx_timeout = lan_saa9730_tx_timeout;
 	dev->watchdog_timeo = (HZ >> 1);
 	dev->dma = 0;
-	
-	ret = register_netdev(dev);
+
+	ret = register_netdev (dev);
 	if (ret)
-		goto out;
+		goto out_free_consistent;
+
 	return 0;
 
- out:
-	if (dev->priv)
-		kfree(dev->priv);
+out_free_consistent:
+	lan_saa9730_free_buffers(pdev, lp);
+out_iounmap:
+	iounmap(lp->evm_saa9730_regs);
+out_iounmap_lan:
+	iounmap(lp->lan_saa9730_regs);
+out:
 	return ret;
 }
 
 
 static int __devinit saa9730_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	struct net_device *dev;
-	unsigned int pci_ioaddr;
+	struct net_device *dev = NULL;
+	unsigned long pci_ioaddr;
 	int err;
 
 	if (lan_saa9730_debug > 1)
 		printk("saa9730.c: PCI bios is present, checking for devices...\n");
 
-	err = -ENOMEM;
-	dev = alloc_etherdev(0);
-	if (!dev)
-		goto out;
-
-	SET_MODULE_OWNER(dev);
-
 	err = pci_enable_device(pdev);
-        if (err) {
-                printk(KERN_ERR "Cannot enable PCI device, aborting.\n");
-                goto out1;
-        }
+	if (err) {
+		printk(KERN_ERR "Cannot enable PCI device, aborting.\n");
+		goto out;
+	}
 
 	err = pci_request_regions(pdev, DRV_MODULE_NAME);
 	if (err) {
 		printk(KERN_ERR "Cannot obtain PCI resources, aborting.\n");
-		goto out2;
+		goto out_disable_pdev;
 	}
 
 	pci_irq_line = pdev->irq;
@@ -1136,49 +1095,52 @@ static int __devinit saa9730_init_one(st
 	pci_ioaddr = pci_resource_start(pdev, 1);
 	pci_set_master(pdev);
 
-	printk("Found SAA9730 (PCI) at %#x, irq %d.\n",
+	printk("Found SAA9730 (PCI) at %lx, irq %d.\n",
 	       pci_ioaddr, pci_irq_line);
 
-	err = lan_saa9730_init(dev, pci_ioaddr, pci_irq_line);
+	dev = alloc_etherdev(sizeof(struct lan_saa9730_private));
+	if (!dev)
+		goto out_disable_pdev;
+
+	err = lan_saa9730_init(dev, pdev, pci_ioaddr, pci_irq_line);
 	if (err) {
-		printk("Lan init failed");
-		goto out2;
+		printk("LAN init failed");
+		goto out_free_netdev;
 	}
 
 	pci_set_drvdata(pdev, dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
 	return 0;
-	
-out2:
-	pci_disable_device(pdev);
-out1:
+
+out_free_netdev:
 	free_netdev(dev);
+out_disable_pdev:
+	pci_disable_device(pdev);
 out:
+	pci_set_drvdata(pdev, NULL);
 	return err;
 }
 
 
 static struct pci_driver saa9730_driver = {
-	.name           = DRV_MODULE_NAME,
-	.id_table       = saa9730_pci_tbl,
-	.probe          = saa9730_init_one,
-	.remove         = __devexit_p(saa9730_remove_one),
+	.name		= DRV_MODULE_NAME,
+	.id_table	= saa9730_pci_tbl,
+	.probe		= saa9730_init_one,
+	.remove		= __devexit_p(saa9730_remove_one),
 };
 
 
 static int __init saa9730_init(void)
 {
-        return pci_module_init(&saa9730_driver);
+	return pci_module_init(&saa9730_driver);
 }
 
 static void __exit saa9730_cleanup(void)
 {
-        pci_unregister_driver(&saa9730_driver);
+	pci_unregister_driver(&saa9730_driver);
 }
 
 module_init(saa9730_init);
 module_exit(saa9730_cleanup);
 
-
-
 MODULE_LICENSE("GPL");
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/saa9730.h linux_HEAD/drivers/net/saa9730.h
--- linux-2.6.11.6/drivers/net/saa9730.h	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/drivers/net/saa9730.h	2005-02-17 21:49:50.000000000 +0100
@@ -1,6 +1,7 @@
 /*
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2000, 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  * ########################################################################
  *
@@ -265,6 +266,7 @@
 
 /* The SAA9730 (LAN) controller register map, as seen via the PCI-bus. */
 #define SAA9730_LAN_REGS_ADDR   0x20400
+#define SAA9730_LAN_REGS_SIZE   0x00400
 
 struct lan_saa9730_regmap {
 	volatile unsigned int TxBuffA;			/* 0x20400 */
@@ -309,6 +311,7 @@ typedef volatile struct lan_saa9730_regm
 
 /* The SAA9730 (EVM) controller register map, as seen via the PCI-bus. */
 #define SAA9730_EVM_REGS_ADDR   0x02000
+#define SAA9730_EVM_REGS_SIZE   0x00400
 
 struct evm_saa9730_regmap {
 	volatile unsigned int InterruptStatus1;		/* 0x2000 */
@@ -329,16 +332,32 @@ typedef volatile struct evm_saa9730_regm
 
 
 struct lan_saa9730_private {
+	/*
+	 * Rx/Tx packet buffers.
+	 * The Rx and Tx packets must be PACKET_SIZE aligned.
+	 */
+	void		*buffer_start;
+	unsigned int	buffer_size;
+
+	/*
+	 * DMA address of beginning of this object, returned
+	 * by pci_alloc_consistent().
+	 */
+	dma_addr_t	dma_addr;
+
+	/* Pointer to the associated pci device structure */
+	struct pci_dev	*pci_dev;
+
 	/* Pointer for the SAA9730 LAN controller register set. */
 	t_lan_saa9730_regmap *lan_saa9730_regs;
 
 	/* Pointer to the SAA9730 EVM register. */
 	t_evm_saa9730_regmap *evm_saa9730_regs;
 
-	/* TRUE if the next buffer to write is RxBuffA,  FALSE if RxBuffB. */
-	unsigned char NextRcvToUseIsA;
 	/* Rcv buffer Index. */
 	unsigned char NextRcvPacketIndex;
+	/* Next buffer index. */
+	unsigned char NextRcvBufferIndex;
 
 	/* Index of next packet to use in that buffer. */
 	unsigned char NextTxmPacketIndex;
@@ -353,13 +372,8 @@ struct lan_saa9730_private {
 	unsigned char DmaRcvPackets;
 	unsigned char DmaTxmPackets;
 
-	unsigned char RcvAIndex;	/* index into RcvBufferSpace[] for Blk A */
-	unsigned char RcvBIndex;	/* index into RcvBufferSpace[] for Blk B */
-
-	unsigned int
-	    TxmBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_TXM_Q_SIZE];
-	unsigned int
-	    RcvBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_RCV_Q_SIZE];
+	void	      *TxmBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_TXM_Q_SIZE];
+	void	      *RcvBuffer[LAN_SAA9730_BUFFERS][LAN_SAA9730_RCV_Q_SIZE];
 	unsigned int TxBufferFree[LAN_SAA9730_BUFFERS];
 
 	unsigned char PhysicalAddress[LAN_SAA9730_CAM_ENTRIES][6];
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/sis900.c linux_HEAD/drivers/net/sis900.c
--- linux-2.6.11.6/drivers/net/sis900.c	2005-04-03 00:12:15.000000000 +0200
+++ linux_HEAD/drivers/net/sis900.c	2005-03-21 20:04:26.000000000 +0100
@@ -245,7 +245,7 @@ static int __devinit sis900_get_mac_addr
 	/* check to see if we have sane EEPROM */
 	signature = (u16) read_eeprom(ioaddr, EEPROMSignature);    
 	if (signature == 0xffff || signature == 0x0000) {
-		printk (KERN_INFO "%s: Error EERPOM read %x\n", 
+		printk (KERN_WARNING "%s: Error EERPOM read %x\n", 
 			pci_name(pci_dev), signature);
 		return 0;
 	}
@@ -278,7 +278,8 @@ static int __devinit sis630e_get_mac_add
 	if (!isa_bridge)
 		isa_bridge = pci_get_device(PCI_VENDOR_ID_SI, 0x0018, isa_bridge);
 	if (!isa_bridge) {
-		printk("%s: Can not find ISA bridge\n", pci_name(pci_dev));
+		printk(KERN_WARNING "%s: Can not find ISA bridge\n",
+		       pci_name(pci_dev));
 		return 0;
 	}
 	pci_read_config_byte(isa_bridge, 0x48, &reg);
@@ -466,31 +467,47 @@ static int __devinit sis900_probe(struct
 	net_dev->tx_timeout = sis900_tx_timeout;
 	net_dev->watchdog_timeo = TX_TIMEOUT;
 	net_dev->ethtool_ops = &sis900_ethtool_ops;
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+        net_dev->poll_controller = &sis900_poll;
+#endif
+
+	if (sis900_debug > 0)
+		sis_priv->msg_enable = sis900_debug;
+	else
+		sis_priv->msg_enable = SIS900_DEF_MSG;
 		
 	/* Get Mac address according to the chip revision */
-	pci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &revision);
+	pci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &(sis_priv->chipset_rev));
+	if(netif_msg_probe(sis_priv))
+		printk(KERN_DEBUG "%s: detected revision %2.2x, "
+				"trying to get MAC address...\n",
+				dev_name, sis_priv->chipset_rev);
+	
 	ret = 0;
-
-	if (revision == SIS630E_900_REV)
+	if (sis_priv->chipset_rev == SIS630E_900_REV)
 		ret = sis630e_get_mac_addr(pci_dev, net_dev);
-	else if ((revision > 0x81) && (revision <= 0x90) )
+	else if ((sis_priv->chipset_rev > 0x81) && (sis_priv->chipset_rev <= 0x90) )
 		ret = sis635_get_mac_addr(pci_dev, net_dev);
-	else if (revision == SIS96x_900_REV)
+	else if (sis_priv->chipset_rev == SIS96x_900_REV)
 		ret = sis96x_get_mac_addr(pci_dev, net_dev);
 	else
 		ret = sis900_get_mac_addr(pci_dev, net_dev);
 
 	if (ret == 0) {
+		printk(KERN_WARNING "%s: Cannot read MAC address.\n", dev_name);
 		ret = -ENODEV;
 		goto err_unmap_rx;
 	}
 	
 	/* 630ET : set the mii access mode as software-mode */
-	if (revision == SIS630ET_900_REV)
+	if (sis_priv->chipset_rev == SIS630ET_900_REV)
 		outl(ACCESSMODE | inl(ioaddr + cr), ioaddr + cr);
 
 	/* probe for mii transceiver */
 	if (sis900_mii_probe(net_dev) == 0) {
+		printk(KERN_WARNING "%s: Error probing MII device.\n",
+		       dev_name);
 		ret = -ENODEV;
 		goto err_unmap_rx;
 	}
@@ -506,10 +523,6 @@ static int __devinit sis900_probe(struct
 	if (ret)
 		goto err_unmap_rx;
 
-	ret = register_netdev(net_dev);
-	if (ret)
-		goto err_unmap_rx;
-
 	/* print some information about our NIC */
 	printk(KERN_INFO "%s: %s at %#lx, IRQ %d, ", net_dev->name,
 	       card_name, ioaddr, net_dev->irq);
@@ -549,7 +562,6 @@ static int __init sis900_mii_probe(struc
 	u16 poll_bit = MII_STAT_LINK, status = 0;
 	unsigned long timeout = jiffies + 5 * HZ;
 	int phy_addr;
-	u8 revision;
 
 	sis_priv->mii = NULL;
 
@@ -598,9 +610,11 @@ static int __init sis900_mii_probe(struc
 				if (mii_chip_table[i].phy_types == MIX)
 					mii_phy->phy_types =
 					    (mii_status & (MII_STAT_CAN_TX_FDX | MII_STAT_CAN_TX)) ? LAN : HOME;
-				printk(KERN_INFO "%s: %s transceiver found at address %d.\n",
-				       dev_name, mii_chip_table[i].name,
-				       phy_addr);
+				printk(KERN_INFO "%s: %s transceiver found "
+							"at address %d.\n",
+							dev_name,
+							mii_chip_table[i].name,
+							phy_addr);
 				break;
 			}
 			
@@ -643,8 +657,7 @@ static int __init sis900_mii_probe(struc
 		}
 	}
 
-	pci_read_config_byte(sis_priv->pci_dev, PCI_CLASS_REVISION, &revision);
-	if (revision == SIS630E_900_REV) {
+	if (sis_priv->chipset_rev == SIS630E_900_REV) {
 		/* SiS 630E has some bugs on default value of PHY registers */
 		mdio_write(net_dev, sis_priv->cur_phy, MII_ANADV, 0x05e1);
 		mdio_write(net_dev, sis_priv->cur_phy, MII_CONFIG1, 0x22);
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/titan_ge.c linux_HEAD/drivers/net/titan_ge.c
--- linux-2.6.11.6/drivers/net/titan_ge.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/net/titan_ge.c	2005-01-09 13:24:00.000000000 +0100
@@ -0,0 +1,2067 @@
+/*
+ * drivers/net/titan_ge.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * The MAC unit of the Titan consists of the following:
+ *
+ * -> XDMA Engine to move data to from the memory to the MAC packet FIFO
+ * -> FIFO is where the incoming and outgoing data is placed
+ * -> TRTG is the unit that pulls the data from the FIFO for Tx and pushes
+ *    the data into the FIFO for Rx
+ * -> TMAC is the outgoing MAC interface and RMAC is the incoming.
+ * -> AFX is the address filtering block
+ * -> GMII block to communicate with the PHY
+ *
+ * Rx will look like the following:
+ * GMII --> RMAC --> AFX --> TRTG --> Rx FIFO --> XDMA --> CPU memory
+ *
+ * Tx will look like the following:
+ * CPU memory --> XDMA --> Tx FIFO --> TRTG --> TMAC --> GMII
+ *
+ * The Titan driver has support for the following performance features:
+ * -> Rx side checksumming
+ * -> Jumbo Frames
+ * -> Interrupt Coalscing
+ * -> Rx NAPI
+ * -> SKB Recycling
+ * -> Transmit/Receive descriptors in SRAM
+ * -> Fast routing for IP forwarding
+ */
+
+#include <linux/config.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/init.h>
+#include <linux/in.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/prefetch.h>
+
+/* For MII specifc registers, titan_mdio.h should be included */
+#include <net/ip.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/titan_dep.h>
+
+#include "titan_ge.h"
+#include "titan_mdio.h"
+
+/* Static Function Declarations	 */
+static int titan_ge_eth_open(struct net_device *);
+static void titan_ge_eth_stop(struct net_device *);
+static struct net_device_stats *titan_ge_get_stats(struct net_device *);
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info *, int, int,
+				      unsigned long, unsigned long,
+				      unsigned long);
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info *, int,
+				      unsigned long, unsigned long);
+
+static int titan_ge_open(struct net_device *);
+static int titan_ge_start_xmit(struct sk_buff *, struct net_device *);
+static int titan_ge_stop(struct net_device *);
+
+static unsigned long titan_ge_tx_coal(unsigned long, int);
+
+static void titan_ge_port_reset(unsigned int);
+static int titan_ge_free_tx_queue(titan_ge_port_info *);
+static int titan_ge_rx_task(struct net_device *, titan_ge_port_info *);
+static int titan_ge_port_start(struct net_device *, titan_ge_port_info *);
+
+static int titan_ge_return_tx_desc(titan_ge_port_info *, int);
+
+/*
+ * Some configuration for the FIFO and the XDMA channel needs
+ * to be done only once for all the ports. This flag controls
+ * that
+ */
+static unsigned long config_done;
+
+/*
+ * One time out of memory flag
+ */
+static unsigned int oom_flag;
+
+static int titan_ge_poll(struct net_device *netdev, int *budget);
+
+static int titan_ge_receive_queue(struct net_device *, unsigned int);
+
+static struct platform_device *titan_ge_device[3];
+
+/* MAC Address */
+extern unsigned char titan_ge_mac_addr_base[6];
+
+unsigned long titan_ge_base;
+static unsigned long titan_ge_sram;
+
+static char titan_string[] = "titan";
+
+/*
+ * The Titan GE has two alignment requirements:
+ * -> skb->data to be cacheline aligned (32 byte)
+ * -> IP header alignment to 16 bytes
+ *
+ * The latter is not implemented. So, that results in an extra copy on
+ * the Rx. This is a big performance hog. For the former case, the
+ * dev_alloc_skb() has been replaced with titan_ge_alloc_skb(). The size
+ * requested is calculated:
+ *
+ * Ethernet Frame Size : 1518
+ * Ethernet Header     : 14
+ * Future Titan change for IP header alignment : 2
+ *
+ * Hence, we allocate (1518 + 14 + 2+ 64) = 1580 bytes.  For IP header
+ * alignment, we use skb_reserve().
+ */
+
+#define ALIGNED_RX_SKB_ADDR(addr) \
+	((((unsigned long)(addr) + (64UL - 1UL)) \
+	& ~(64UL - 1UL)) - (unsigned long)(addr))
+
+#define titan_ge_alloc_skb(__length, __gfp_flags) \
+({      struct sk_buff *__skb; \
+	__skb = alloc_skb((__length) + 64, (__gfp_flags)); \
+	if(__skb) { \
+		int __offset = (int) ALIGNED_RX_SKB_ADDR(__skb->data); \
+		if(__offset) \
+			skb_reserve(__skb, __offset); \
+	} \
+	__skb; \
+})
+
+/*
+ * Configure the GMII block of the Titan based on what the PHY tells us
+ */
+static void titan_ge_gmii_config(int port_num)
+{
+	unsigned int reg_data = 0, phy_reg;
+	int err;
+
+	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+
+	if (err == TITAN_GE_MDIO_ERROR) {
+		printk(KERN_ERR
+		       "Could not read PHY control register 0x11 \n");
+		printk(KERN_ERR
+			"Setting speed to 1000 Mbps and Duplex to Full \n");
+
+		return;
+	}
+
+	err = titan_ge_mdio_write(port_num, TITAN_GE_MDIO_PHY_IE, 0);
+
+	if (phy_reg & 0x8000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x201);
+		}  else {
+			/* Half Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2201);
+			}
+	}
+	if (phy_reg & 0x4000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x100);
+		} else {
+			/* Half Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2100);
+		}
+	}
+	reg_data = TITAN_GE_READ(TITAN_GE_GMII_CONFIG_GENERAL +
+				(port_num << 12));
+	reg_data |= 0x3;
+	TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_GENERAL +
+			(port_num << 12)), reg_data);
+}
+
+/*
+ * Enable the TMAC if it is not
+ */
+static void titan_ge_enable_tx(unsigned int port_num)
+{
+	unsigned long reg_data;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
+	if (!(reg_data & 0x8000)) {
+		printk("TMAC disabled for port %d!! \n", port_num);
+
+		reg_data |= 0x0001;	/* Enable TMAC */
+		reg_data |= 0x4000;	/* CRC Check Enable */
+		reg_data |= 0x2000;	/* Padding enable */
+		reg_data |= 0x0800;	/* CRC Add enable */
+		reg_data |= 0x0080;	/* PAUSE frame */
+
+		TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12)), reg_data);
+	}
+}
+
+/*
+ * Tx Timeout function
+ */
+static void titan_ge_tx_timeout(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	printk(KERN_INFO "%s: TX timeout  ", netdev->name);
+	printk(KERN_INFO "Resetting card \n");
+
+	/* Do the reset outside of interrupt context */
+	schedule_work(&titan_ge_eth->tx_timeout_task);
+}
+
+/*
+ * Update the AFX tables for UC and MC for slice 0 only
+ */
+static void titan_ge_update_afx(titan_ge_port_info * titan_ge_eth)
+{
+	int port = titan_ge_eth->port_num;
+	unsigned int i;
+	volatile unsigned long reg_data = 0;
+	u8 p_addr[6];
+
+	memcpy(p_addr, titan_ge_eth->port_mac_addr, 6);
+
+	/* Set the MAC address here for TMAC and RMAC */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((0x112c | (port << 12)), 0x1);
+	/* Configure the eight address filters */
+	for (i = 0; i < 8; i++) {
+		/* Select each of the eight filters */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_2 +
+				(port << 12)), i);
+
+		/* Configure the match */
+		reg_data = 0x9;	/* Forward Enable Bit */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_0 +
+				(port << 12)), reg_data);
+
+		/* Finally, AFX Exact Match Address Registers */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_LOW + (port << 12)),
+			       ((p_addr[1] << 8) | p_addr[0]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_MID + (port << 12)),
+			       ((p_addr[3] << 8) | p_addr[2]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_HIGH + (port << 12)),
+			       ((p_addr[5] << 8) | p_addr[4]));
+
+		/* VLAN id set to 0 */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_VID +
+				(port << 12)), 0);
+	}
+}
+
+/*
+ * Actual Routine to reset the adapter when the timeout occurred
+ */
+static void titan_ge_tx_timeout_task(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	int port = titan_ge_eth->port_num;
+
+	printk("Titan GE: Transmit timed out. Resetting ... \n");
+
+	/* Dump debug info */
+	printk(KERN_ERR "TRTG cause : %x \n",
+			TITAN_GE_READ(0x100c + (port << 12)));
+
+	/* Fix this for the other ports */
+	printk(KERN_ERR "FIFO cause : %x \n", TITAN_GE_READ(0x482c));
+	printk(KERN_ERR "IE cause : %x \n", TITAN_GE_READ(0x0040));
+	printk(KERN_ERR "XDMA GDI ERROR : %x \n",
+			TITAN_GE_READ(0x5008 + (port << 8)));
+	printk(KERN_ERR "CHANNEL ERROR: %x \n",
+			TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT
+						+ (port << 8)));
+
+	netif_device_detach(netdev);
+	titan_ge_port_reset(titan_ge_eth->port_num);
+	titan_ge_port_start(netdev, titan_ge_eth);
+	netif_device_attach(netdev);
+}
+
+/*
+ * Change the MTU of the Ethernet Device
+ */
+static int titan_ge_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned long flags;
+
+	if ((new_mtu > 9500) || (new_mtu < 64))
+		return -EINVAL;
+
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	netdev->mtu = new_mtu;
+
+	/* Now we have to reopen the interface so that SKBs with the new
+	 * size will be allocated */
+
+	if (netif_running(netdev)) {
+		titan_ge_eth_stop(netdev);
+
+		if (titan_ge_eth_open(netdev) != TITAN_OK) {
+			printk(KERN_ERR
+			       "%s: Fatal error on opening device\n",
+			       netdev->name);
+			spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+			return -1;
+		}
+	}
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+	return 0;
+}
+
+/*
+ * Titan Gbe Interrupt Handler. All the three ports send interrupt to one line
+ * only. Once an interrupt is triggered, figure out the port and then check
+ * the channel.
+ */
+static irqreturn_t titan_ge_int_handler(int irq, void *dev_id,
+	struct pt_regs *regs)
+{
+	struct net_device *netdev = (struct net_device *) dev_id;
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int reg_data;
+	unsigned int eth_int_cause_error = 0, is;
+	unsigned long eth_int_cause1;
+	int err = 0;
+#ifdef CONFIG_SMP
+	unsigned long eth_int_cause2;
+#endif
+
+	/* Ack the CPU interrupt */
+	switch (port_num) {
+	case 0:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS1);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR1, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS1);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR1, is);
+#endif
+		break;
+
+	case 1:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS0);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR0, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS0);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR0, is);
+#endif
+		break;
+
+	case 2:
+		is = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
+		OCD_WRITE(RM9000x2_OCD_INTP0CLEAR4, is);
+
+#ifdef CONFIG_SMP
+		is = OCD_READ(RM9000x2_OCD_INTP1STATUS4);
+		OCD_WRITE(RM9000x2_OCD_INTP1CLEAR4, is);
+#endif
+	}
+
+	eth_int_cause1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+#ifdef CONFIG_SMP
+	eth_int_cause2 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_B);
+#endif
+
+	/* Spurious interrupt */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 == 0) && (eth_int_cause2 == 0)) {
+#else
+	if (eth_int_cause1 == 0) {
+#endif
+		eth_int_cause_error = TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT +
+					(port_num << 8));
+
+		if (eth_int_cause_error == 0)
+			return IRQ_NONE;
+	}
+
+	/* Handle Tx first. No need to ack interrupts */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x20202) ||
+		(eth_int_cause2 & 0x20202) )
+#else
+	if (eth_int_cause1 & 0x20202)
+#endif
+		titan_ge_free_tx_queue(titan_ge_eth);
+
+	/* Handle the Rx next */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x10101) ||
+		(eth_int_cause2 & 0x10101)) {
+#else
+	if (eth_int_cause1 & 0x10101) {
+#endif
+		if (netif_rx_schedule_prep(netdev)) {
+			unsigned int ack;
+
+			ack = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+			/* Disable Tx and Rx both */
+			if (port_num == 0)
+				ack &= ~(0x3);
+			if (port_num == 1)
+				ack &= ~(0x300);
+
+			if (port_num == 2)
+				ack &= ~(0x30000);
+
+			/* Interrupts have been disabled */
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, ack);
+
+			__netif_rx_schedule(netdev);
+		}
+	}
+
+	/* Handle error interrupts */
+	if (eth_int_cause_error && (eth_int_cause_error != 0x2)) {
+		printk(KERN_ERR
+			"XDMA Channel Error : %x  on port %d\n",
+			eth_int_cause_error, port_num);
+
+		printk(KERN_ERR
+			"XDMA GDI Hardware error : %x  on port %d\n",
+			TITAN_GE_READ(0x5008 + (port_num << 8)), port_num);
+
+		printk(KERN_ERR
+			"XDMA currently has %d Rx descriptors \n",
+			TITAN_GE_READ(0x5048 + (port_num << 8)));
+
+		printk(KERN_ERR
+			"XDMA currently has prefetcted %d Rx descriptors \n",
+			TITAN_GE_READ(0x505c + (port_num << 8)));
+
+		TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT +
+			       (port_num << 8)), eth_int_cause_error);
+	}
+
+	/*
+	 * PHY interrupt to inform abt the changes. Reading the
+	 * PHY Status register will clear the interrupt
+	 */
+	if ((!(eth_int_cause1 & 0x30303)) &&
+		(eth_int_cause_error == 0)) {
+		err =
+		    titan_ge_mdio_read(port_num,
+			       TITAN_GE_MDIO_PHY_IS, &reg_data);
+
+		if (reg_data & 0x0400) {
+			/* Link status change */
+			titan_ge_mdio_read(port_num,
+				   TITAN_GE_MDIO_PHY_STATUS, &reg_data);
+			if (!(reg_data & 0x0400)) {
+				/* Link is down */
+				netif_carrier_off(netdev);
+				netif_stop_queue(netdev);
+			} else {
+				/* Link is up */
+				netif_carrier_on(netdev);
+				netif_wake_queue(netdev);
+
+				/* Enable the queue */
+				titan_ge_enable_tx(port_num);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Multicast and Promiscuous mode set. The
+ * set_multi entry point is called whenever the
+ * multicast address list or the network interface
+ * flags are updated.
+ */
+static void titan_ge_set_multi(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned long reg_data;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
+				(port_num << 12));
+
+	if (netdev->flags & IFF_PROMISC) {
+		reg_data |= 0x2;
+	}
+	else if (netdev->flags & IFF_ALLMULTI) {
+		reg_data |= 0x01;
+		reg_data |= 0x400; /* Use the 64-bit Multicast Hash bin */
+	}
+	else {
+		reg_data = 0x2;
+	}
+
+	TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 +
+			(port_num << 12)), reg_data);
+	if (reg_data & 0x01) {
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_LOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDLOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDHI +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_HI +
+				(port_num << 12)), 0xffff);
+	}
+}
+
+/*
+ * Open the network device
+ */
+static int titan_ge_open(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int irq = TITAN_ETH_PORT_IRQ - port_num;
+	int retval;
+
+	retval = request_irq(irq, titan_ge_int_handler,
+		     SA_INTERRUPT | SA_SAMPLE_RANDOM , netdev->name, netdev);
+
+	if (retval != 0) {
+		printk(KERN_ERR "Cannot assign IRQ number to TITAN GE \n");
+		return -1;
+	}
+
+	netdev->irq = irq;
+	printk(KERN_INFO "Assigned IRQ %d to port %d\n", irq, port_num);
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+
+	if (titan_ge_eth_open(netdev) != TITAN_OK) {
+		spin_unlock_irq(&(titan_ge_eth->lock));
+		printk("%s: Error opening interface \n", netdev->name);
+		free_irq(netdev->irq, netdev);
+		return -EBUSY;
+	}
+
+	spin_unlock_irq(&(titan_ge_eth->lock));
+
+	return 0;
+}
+
+/*
+ * Allocate the SKBs for the Rx ring. Also used
+ * for refilling the queue
+ */
+static int titan_ge_rx_task(struct net_device *netdev,
+				titan_ge_port_info *titan_ge_port)
+{
+	struct device *device = &titan_ge_device[titan_ge_port->port_num]->dev;
+	volatile titan_ge_rx_desc *rx_desc;
+	struct sk_buff *skb;
+	int rx_used_desc;
+	int count = 0;
+
+	while (titan_ge_port->rx_ring_skbs < titan_ge_port->rx_ring_size) {
+
+	/* First try to get the skb from the recycler */
+#ifdef TITAN_GE_JUMBO_FRAMES
+		skb = titan_ge_alloc_skb(TITAN_GE_JUMBO_BUFSIZE, GFP_ATOMIC);
+#else
+		skb = titan_ge_alloc_skb(TITAN_GE_STD_BUFSIZE, GFP_ATOMIC);
+#endif
+		if (unlikely(!skb)) {
+			/* OOM, set the flag */
+			printk("OOM \n");
+			oom_flag = 1;
+			break;
+		}
+		count++;
+		skb->dev = netdev;
+
+		titan_ge_port->rx_ring_skbs++;
+
+		rx_used_desc = titan_ge_port->rx_used_desc_q;
+		rx_desc = &(titan_ge_port->rx_desc_area[rx_used_desc]);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+		rx_desc->buffer_addr = dma_map_single(device, skb->data,
+				TITAN_GE_JUMBO_BUFSIZE - 2, DMA_FROM_DEVICE);
+#else
+		rx_desc->buffer_addr = dma_map_single(device, skb->data,
+				TITAN_GE_STD_BUFSIZE - 2, DMA_FROM_DEVICE);
+#endif
+
+		titan_ge_port->rx_skb[rx_used_desc] = skb;
+		rx_desc->cmd_sts = TITAN_GE_RX_BUFFER_OWNED;
+
+		titan_ge_port->rx_used_desc_q =
+			(rx_used_desc + 1) % TITAN_GE_RX_QUEUE;
+	}
+
+	return count;
+}
+
+/*
+ * Actual init of the Tital GE port. There is one register for
+ * the channel configuration
+ */
+static void titan_port_init(struct net_device *netdev,
+			    titan_ge_port_info * titan_ge_eth)
+{
+	unsigned long reg_data;
+
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	/* First reset the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x80000000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0xc0000000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	/* Now reset the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x00080000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0x000c0000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+}
+
+/*
+ * Start the port. All the hardware specific configuration
+ * for the XDMA, Tx FIFO, Rx FIFO, TMAC, RMAC, TRTG and AFX
+ * go here
+ */
+static int titan_ge_port_start(struct net_device *netdev,
+				titan_ge_port_info * titan_port)
+{
+	volatile unsigned long reg_data, reg_data1;
+	int port_num = titan_port->port_num;
+	int count = 0;
+	unsigned long reg_data_1;
+
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(0x0004);
+		reg_data |= 0x100;
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		reg_data &= ~(0x100);
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		/* Turn on GMII/MII mode and turn off TBI mode */
+		reg_data = TITAN_GE_READ(TITAN_GE_TSB_CTRL_1);
+		reg_data |= 0x00000700;
+		reg_data &= ~(0x00800000); /* Fencing */
+
+		TITAN_GE_WRITE(0x000c, 0x00001100);
+
+		TITAN_GE_WRITE(TITAN_GE_TSB_CTRL_1, reg_data);
+
+		/* Set the CPU Resource Limit register */
+		TITAN_GE_WRITE(0x00f8, 0x8);
+
+		/* Be conservative when using the BIU buffers */
+		TITAN_GE_WRITE(0x0068, 0x4);
+	}
+
+	titan_port->tx_threshold = 0;
+	titan_port->rx_threshold = 0;
+
+	/* We need to write the descriptors for Tx and Rx */
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_TX_DESC + (port_num << 8)),
+		       (unsigned long) titan_port->tx_dma);
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_RX_DESC + (port_num << 8)),
+		       (unsigned long) titan_port->rx_dma);
+
+	if (config_done == 0) {
+		/* Step 1:  XDMA config	*/
+		reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
+		reg_data &= ~(0x80000000);      /* clear reset */
+		reg_data |= 0x1 << 29;	/* sparse tx descriptor spacing */
+		reg_data |= 0x1 << 28;	/* sparse rx descriptor spacing */
+		reg_data |= (0x1 << 23) | (0x1 << 24);  /* Descriptor Coherency */
+		reg_data |= (0x1 << 21) | (0x1 << 22);  /* Data Coherency */
+		TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
+	}
+
+	/* IR register for the XDMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8));
+	reg_data |= 0x80068000; /* No Rx_OOD */
+	TITAN_GE_WRITE((TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8)), reg_data);
+
+	/* Start the Tx and Rx XDMA controller */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG + (port_num << 8));
+	reg_data &= 0x4fffffff;     /* Clear tx reset */
+	reg_data &= 0xfff4ffff;     /* Clear rx reset */
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	reg_data |= 0xa0 | 0x30030000;
+#else
+	reg_data |= 0x40 | 0x20030000;
+#endif
+
+#ifndef CONFIG_SMP
+	reg_data &= ~(0x10);
+	reg_data |= 0x0f; /* All of the packet */
+#endif
+
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG + (port_num << 8)), reg_data);
+
+	/* Rx desc count */
+	count = titan_ge_rx_task(netdev, titan_port);
+	TITAN_GE_WRITE((0x5048 + (port_num << 8)), count);
+	count = TITAN_GE_READ(0x5048 + (port_num << 8));
+
+	udelay(30);
+
+	/*
+	 * Step 2:  Configure the SDQPF, i.e. FIFO
+	 */
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+	}
+	/*
+	 * Enable RX FIFO 0, 4 and 8
+	 */
+	if (port_num == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4844);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x4844, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_0);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4944);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x4944, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+	}
+
+	if (port_num == 1) {
+		reg_data = TITAN_GE_READ(0x4870);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (0xff + 1);
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4874);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x4874, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+
+		reg_data = TITAN_GE_READ(0x494c);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+		reg_data |= (0xff << 10) | (0xff + 1);
+		TITAN_GE_WRITE(0x494c, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4950);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x4950, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+	}
+
+	/*
+	 * Titan 1.2 revision does support port #2
+	 */
+	if (port_num == 2) {
+		/*
+		 * Put the descriptors in the SRAM
+		 */
+		reg_data = TITAN_GE_READ(0x48a0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x48a4);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x48a4, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		
+		reg_data = TITAN_GE_READ(0x4958);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+		TITAN_GE_WRITE(0x4958, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x495c);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x495c, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+	}
+
+	if (port_num == 2) {
+		reg_data = TITAN_GE_READ(0x48a0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x48a4);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x48a4, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+
+		reg_data = TITAN_GE_READ(0x4958);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+		TITAN_GE_WRITE(0x4958, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x495c);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x495c, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+	}
+
+	/*
+	 * Step 3:  TRTG block enable
+	 */
+	reg_data = TITAN_GE_READ(TITAN_GE_TRTG_CONFIG + (port_num << 12));
+
+	/*
+	 * This is the 1.2 revision of the chip. It has fix for the
+	 * IP header alignment. Now, the IP header begins at an
+	 * aligned address and this wont need an extra copy in the
+	 * driver. This performance drawback existed in the previous
+	 * versions of the silicon
+	 */
+	reg_data_1 = TITAN_GE_READ(0x103c + (port_num << 12));
+	reg_data_1 |= 0x40000000;
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	reg_data_1 |= 0x04000000;
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	mdelay(5);
+
+	reg_data_1 &= ~(0x04000000);
+	TITAN_GE_WRITE((0x103c + (port_num << 12)), reg_data_1);
+
+	mdelay(5);
+
+	reg_data |= 0x0001;
+	TITAN_GE_WRITE((TITAN_GE_TRTG_CONFIG + (port_num << 12)), reg_data);
+
+	/*
+	 * Step 4:  Start the Tx activity
+	 */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_2 + (port_num << 12)), 0xe197);
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1258 + (port_num << 12)), 0x4000);
+#endif
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* Enable TMAC */
+	reg_data |= 0x6c70;	/* PAUSE also set */
+
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/* Destination Address drop bit */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_2 + (port_num << 12));
+	reg_data |= 0x218;        /* DA_DROP bit and pause */
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_2 + (port_num << 12)), reg_data);
+
+	TITAN_GE_WRITE((0x1218 + (port_num << 12)), 0x3);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1208 + (port_num << 12)), 0x4000);
+#endif
+	/* Start the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* RMAC Enable */
+	reg_data |= 0x0010;	/* CRC Check enable */
+	reg_data |= 0x0040;	/* Min Frame check enable */
+	reg_data |= 0x4400;	/* Max Frame check enable */
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/*
+	 * Enable the Interrupts for Tx and Rx
+	 */
+	reg_data1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0) {
+		reg_data1 |= 0x3;
+#ifdef CONFIG_SMP
+		TITAN_GE_WRITE(0x0038, 0x003);
+#else
+		TITAN_GE_WRITE(0x0038, 0x303);
+#endif
+	}
+
+	if (port_num == 1) {
+		reg_data1 |= 0x300;
+	}
+
+	if (port_num == 2)
+		reg_data1 |= 0x30000;
+
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data1);
+	TITAN_GE_WRITE(0x003c, 0x300);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x0024, 0x04000024);	/* IRQ vector */
+		TITAN_GE_WRITE(0x0020, 0x000fb000);	/* INTMSG base */
+	}
+
+	/* Priority */
+	reg_data = TITAN_GE_READ(0x1038 + (port_num << 12));
+	reg_data &= ~(0x00f00000);
+	TITAN_GE_WRITE((0x1038 + (port_num << 12)), reg_data);
+
+	/* Step 5:  GMII config */
+	titan_ge_gmii_config(port_num);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x1a80, 0);
+		config_done = 1;
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Function to queue the packet for the Ethernet device
+ */
+static void titan_ge_tx_queue(titan_ge_port_info * titan_ge_eth,
+				struct sk_buff * skb)
+{
+	struct device *device = &titan_ge_device[titan_ge_eth->port_num]->dev;
+	unsigned int curr_desc = titan_ge_eth->tx_curr_desc_q;
+	volatile titan_ge_tx_desc *tx_curr;
+	int port_num = titan_ge_eth->port_num;
+
+	tx_curr = &(titan_ge_eth->tx_desc_area[curr_desc]);
+	tx_curr->buffer_addr =
+		dma_map_single(device, skb->data, skb_headlen(skb),
+			       DMA_TO_DEVICE);
+
+	titan_ge_eth->tx_skb[curr_desc] = (struct sk_buff *) skb;
+	tx_curr->buffer_len = skb_headlen(skb);
+
+	/* Last descriptor enables interrupt and changes ownership */
+	tx_curr->cmd_sts = 0x1 | (1 << 15) | (1 << 5);
+
+	/* Kick the XDMA to start the transfer from memory to the FIFO */
+	TITAN_GE_WRITE((0x5044 + (port_num << 8)), 0x1);
+
+	/* Current descriptor updated */
+	titan_ge_eth->tx_curr_desc_q = (curr_desc + 1) % TITAN_GE_TX_QUEUE;
+
+	/* Prefetch the next descriptor */
+	prefetch((const void *)
+		 &titan_ge_eth->tx_desc_area[titan_ge_eth->tx_curr_desc_q]);
+}
+
+/*
+ * Actually does the open of the Ethernet device
+ */
+static int titan_ge_eth_open(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	struct device *device = &titan_ge_device[port_num]->dev;
+	unsigned long reg_data;
+	unsigned int phy_reg;
+	int err = 0;
+
+	/* Stop the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	/* Clear the port interrupts */
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT + (port_num << 8)), 0x0);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0);
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_B, 0);
+	}
+
+	/* Set the MAC Address */
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+
+	if (config_done == 0)
+		titan_port_init(netdev, titan_ge_eth);
+
+	titan_ge_update_afx(titan_ge_eth);
+
+	/* Allocate the Tx ring now */
+	titan_ge_eth->tx_ring_skbs = 0;
+	titan_ge_eth->tx_ring_size = TITAN_GE_TX_QUEUE;
+
+	/* Allocate space in the SRAM for the descriptors */
+	titan_ge_eth->tx_desc_area = (titan_ge_tx_desc *)
+		(titan_ge_sram + TITAN_TX_RING_BYTES * port_num);
+	titan_ge_eth->tx_dma = TITAN_SRAM_BASE + TITAN_TX_RING_BYTES * port_num;
+
+	if (!titan_ge_eth->tx_desc_area) {
+		printk(KERN_ERR
+		       "%s: Cannot allocate Tx Ring (size %d bytes) for port %d\n",
+		       netdev->name, TITAN_TX_RING_BYTES, port_num);
+		return -ENOMEM;
+	}
+
+	memset(titan_ge_eth->tx_desc_area, 0, titan_ge_eth->tx_desc_area_size);
+
+	/* Now initialize the Tx descriptor ring */
+	titan_ge_init_tx_desc_ring(titan_ge_eth,
+				   titan_ge_eth->tx_ring_size,
+				   (unsigned long) titan_ge_eth->tx_desc_area,
+				   (unsigned long) titan_ge_eth->tx_dma);
+
+	/* Allocate the Rx ring now */
+	titan_ge_eth->rx_ring_size = TITAN_GE_RX_QUEUE;
+	titan_ge_eth->rx_ring_skbs = 0;
+
+	titan_ge_eth->rx_desc_area =
+		(titan_ge_rx_desc *)(titan_ge_sram + 0x1000 + TITAN_RX_RING_BYTES * port_num);
+
+	titan_ge_eth->rx_dma = TITAN_SRAM_BASE + 0x1000 + TITAN_RX_RING_BYTES * port_num;
+
+	if (!titan_ge_eth->rx_desc_area) {
+		printk(KERN_ERR "%s: Cannot allocate Rx Ring (size %d bytes)\n",
+		       netdev->name, TITAN_RX_RING_BYTES);
+
+		printk(KERN_ERR "%s: Freeing previously allocated TX queues...",
+		       netdev->name);
+
+		dma_free_coherent(device, titan_ge_eth->tx_desc_area_size,
+				    (void *) titan_ge_eth->tx_desc_area,
+				    titan_ge_eth->tx_dma);
+
+		return -ENOMEM;
+	}
+
+	memset(titan_ge_eth->rx_desc_area, 0, titan_ge_eth->rx_desc_area_size);
+
+	/* Now initialize the Rx ring */
+#ifdef TITAN_GE_JUMBO_FRAMES
+	if ((titan_ge_init_rx_desc_ring
+	    (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_JUMBO_BUFSIZE,
+	     (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#else
+	if ((titan_ge_init_rx_desc_ring
+	     (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_STD_BUFSIZE,
+	      (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#endif
+		panic("%s: Error initializing RX Ring\n", netdev->name);
+
+	/* Fill the Rx ring with the SKBs */
+	titan_ge_port_start(netdev, titan_ge_eth);
+
+	/*
+	 * Check if Interrupt Coalscing needs to be turned on. The
+	 * values specified in the register is multiplied by
+	 * (8 x 64 nanoseconds) to determine when an interrupt should
+	 * be sent to the CPU.
+	 */
+
+	if (TITAN_GE_TX_COAL) {
+		titan_ge_eth->tx_int_coal =
+		    titan_ge_tx_coal(TITAN_GE_TX_COAL, port_num);
+	}
+
+	err = titan_ge_mdio_read(port_num, TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+	if (err == TITAN_GE_MDIO_ERROR) {
+		printk(KERN_ERR
+		       "Could not read PHY control register 0x11 \n");
+		return TITAN_ERROR;
+	}
+	if (!(phy_reg & 0x0400)) {
+		netif_carrier_off(netdev);
+		netif_stop_queue(netdev);
+		return TITAN_ERROR;
+	} else {
+		netif_carrier_on(netdev);
+		netif_start_queue(netdev);
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Queue the packet for Tx. Currently no support for zero copy,
+ * checksum offload and Scatter Gather. The chip does support
+ * Scatter Gather only. But, that wont help here since zero copy
+ * requires support for Tx checksumming also.
+ */
+int titan_ge_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned long flags;
+	struct net_device_stats *stats;
+//printk("titan_ge_start_xmit\n");
+
+	stats = &titan_ge_eth->stats;
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	if ((TITAN_GE_TX_QUEUE - titan_ge_eth->tx_ring_skbs) <=
+	    (skb_shinfo(skb)->nr_frags + 1)) {
+		netif_stop_queue(netdev);
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+		printk(KERN_ERR "Tx OOD \n");
+		return 1;
+	}
+
+	titan_ge_tx_queue(titan_ge_eth, skb);
+	titan_ge_eth->tx_ring_skbs++;
+
+	if (TITAN_GE_TX_QUEUE <= (titan_ge_eth->tx_ring_skbs + 4)) {
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+		titan_ge_free_tx_queue(titan_ge_eth);
+		spin_lock_irqsave(&titan_ge_eth->lock, flags);
+	}
+
+	stats->tx_bytes += skb->len;
+	stats->tx_packets++;
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	netdev->trans_start = jiffies;
+
+	return 0;
+}
+
+/*
+ * Actually does the Rx. Rx side checksumming supported.
+ */
+static int titan_ge_rx(struct net_device *netdev, int port_num,
+			titan_ge_port_info * titan_ge_port,
+		       titan_ge_packet * packet)
+{
+	int rx_curr_desc, rx_used_desc;
+	volatile titan_ge_rx_desc *rx_desc;
+
+	rx_curr_desc = titan_ge_port->rx_curr_desc_q;
+	rx_used_desc = titan_ge_port->rx_used_desc_q;
+
+	if (((rx_curr_desc + 1) % TITAN_GE_RX_QUEUE) == rx_used_desc)
+		return TITAN_ERROR;
+
+	rx_desc = &(titan_ge_port->rx_desc_area[rx_curr_desc]);
+
+	if (rx_desc->cmd_sts & TITAN_GE_RX_BUFFER_OWNED)
+		return TITAN_ERROR;
+
+	packet->skb = titan_ge_port->rx_skb[rx_curr_desc];
+	packet->len = (rx_desc->cmd_sts & 0x7fff);
+
+	/*
+	 * At this point, we dont know if the checksumming
+	 * actually helps relieve CPU. So, keep it for
+	 * port 0 only
+	 */
+	packet->checksum = ntohs((rx_desc->buffer & 0xffff0000) >> 16);
+	packet->cmd_sts = rx_desc->cmd_sts;
+
+	titan_ge_port->rx_curr_desc_q = (rx_curr_desc + 1) % TITAN_GE_RX_QUEUE;
+
+	/* Prefetch the next descriptor */
+	prefetch((const void *)
+	       &titan_ge_port->rx_desc_area[titan_ge_port->rx_curr_desc_q + 1]);
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx queue of the used SKBs
+ */
+static int titan_ge_free_tx_queue(titan_ge_port_info *titan_ge_eth)
+{
+	unsigned long flags;
+
+	/* Take the lock */
+	spin_lock_irqsave(&(titan_ge_eth->lock), flags);
+
+	while (titan_ge_return_tx_desc(titan_ge_eth, titan_ge_eth->port_num) == 0)
+		if (titan_ge_eth->tx_ring_skbs != 1)
+			titan_ge_eth->tx_ring_skbs--;
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	return TITAN_OK;
+}
+
+/*
+ * Threshold beyond which we do the cleaning of
+ * Tx queue and new allocation for the Rx
+ * queue
+ */
+#define	TX_THRESHOLD	4
+#define	RX_THRESHOLD	10
+
+/*
+ * Receive the packets and send it to the kernel.
+ */
+static int titan_ge_receive_queue(struct net_device *netdev, unsigned int max)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	titan_ge_packet packet;
+	struct net_device_stats *stats;
+	struct sk_buff *skb;
+	unsigned long received_packets = 0;
+	unsigned int ack;
+
+	stats = &titan_ge_eth->stats;
+
+	while ((--max)
+	       && (titan_ge_rx(netdev, port_num, titan_ge_eth, &packet) == TITAN_OK)) {
+		skb = (struct sk_buff *) packet.skb;
+
+		titan_ge_eth->rx_ring_skbs--;
+
+		if (--titan_ge_eth->rx_work_limit < 0)
+			break;
+		received_packets++;
+
+		stats->rx_packets++;
+		stats->rx_bytes += packet.len;
+
+		if ((packet.cmd_sts & TITAN_GE_RX_PERR) ||
+			(packet.cmd_sts & TITAN_GE_RX_OVERFLOW_ERROR) ||
+			(packet.cmd_sts & TITAN_GE_RX_TRUNC) ||
+			(packet.cmd_sts & TITAN_GE_RX_CRC_ERROR)) {
+				stats->rx_dropped++;
+				dev_kfree_skb_any(skb);
+
+				continue;
+		}
+		/*
+		 * Either support fast path or slow path. Decision
+		 * making can really slow down the performance. The
+		 * idea is to cut down the number of checks and improve
+		 * the fastpath.
+		 */
+
+		skb_put(skb, packet.len - 2);
+
+		/*
+		 * Increment data pointer by two since thats where
+		 * the MAC starts
+		 */
+		skb_reserve(skb, 2);
+		skb->protocol = eth_type_trans(skb, netdev);
+		netif_receive_skb(skb);
+
+		if (titan_ge_eth->rx_threshold > RX_THRESHOLD) {
+			ack = titan_ge_rx_task(netdev, titan_ge_eth);
+			TITAN_GE_WRITE((0x5048 + (port_num << 8)), ack);
+			titan_ge_eth->rx_threshold = 0;
+		} else
+			titan_ge_eth->rx_threshold++;
+
+		if (titan_ge_eth->tx_threshold > TX_THRESHOLD) {
+			titan_ge_eth->tx_threshold = 0;
+			titan_ge_free_tx_queue(titan_ge_eth);
+		}
+		else
+			titan_ge_eth->tx_threshold++;
+
+	}
+	return received_packets;
+}
+
+
+/*
+ * Enable the Rx side interrupts
+ */
+static void titan_ge_enable_int(unsigned int port_num,
+			titan_ge_port_info *titan_ge_eth,
+			struct net_device *netdev)
+{
+	unsigned long reg_data = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0)
+		reg_data |= 0x3;
+	if (port_num == 1)
+		reg_data |= 0x300;
+	if (port_num == 2)
+		reg_data |= 0x30000;
+
+	/* Re-enable interrupts */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data);
+}
+
+/*
+ * Main function to handle the polling for Rx side NAPI.
+ * Receive interrupts have been disabled at this point.
+ * The poll schedules the transmit followed by receive.
+ */
+static int titan_ge_poll(struct net_device *netdev, int *budget)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	int port_num = titan_ge_eth->port_num;
+	int work_done = 0;
+	unsigned long flags, status;
+
+	titan_ge_eth->rx_work_limit = *budget;
+	if (titan_ge_eth->rx_work_limit > netdev->quota)
+		titan_ge_eth->rx_work_limit = netdev->quota;
+
+	do {
+		/* Do the transmit cleaning work here */
+		titan_ge_free_tx_queue(titan_ge_eth);
+
+		/* Ack the Rx interrupts */
+		if (port_num == 0)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x3);
+		if (port_num == 1)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x300);
+		if (port_num == 2)
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x30000);
+
+		work_done += titan_ge_receive_queue(netdev, 0);
+
+		/* Out of quota and there is work to be done */
+		if (titan_ge_eth->rx_work_limit < 0)
+			goto not_done;
+
+		/* Receive alloc_skb could lead to OOM */
+		if (oom_flag == 1) {
+			oom_flag = 0;
+			goto oom;
+		}
+
+		status = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+	} while (status & 0x30300);
+
+	/* If we are here, then no more interrupts to process */
+	goto done;
+
+not_done:
+	*budget -= work_done;
+	netdev->quota -= work_done;
+	return 1;
+
+oom:
+	printk(KERN_ERR "OOM \n");
+	netif_rx_complete(netdev);
+	return 0;
+
+done:
+	/*
+	 * No more packets on the poll list. Turn the interrupts
+	 * back on and we should be able to catch the new
+	 * packets in the interrupt handler
+	 */
+	if (!work_done)
+		work_done = 1;
+
+	*budget -= work_done;
+	netdev->quota -= work_done;
+
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	/* Remove us from the poll list */
+	netif_rx_complete(netdev);
+
+	/* Re-enable interrupts */
+	titan_ge_enable_int(port_num, titan_ge_eth, netdev);
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+
+	return 0;
+}
+
+/*
+ * Close the network device
+ */
+int titan_ge_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+	titan_ge_eth_stop(netdev);
+	free_irq(netdev->irq, netdev);
+	spin_unlock_irq(&titan_ge_eth->lock);
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx ring
+ */
+static void titan_ge_free_tx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int curr;
+	unsigned long reg_data;
+
+	/* Stop the Tx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
+				(port_num << 8));
+	reg_data |= 0xc0000000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     (titan_ge_eth->tx_ring_skbs) && (curr < TITAN_GE_TX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->tx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->tx_skb[curr]);
+			titan_ge_eth->tx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->tx_ring_skbs != 0)
+		printk
+		    ("%s: Error on Tx descriptor free - could not free %d"
+		     " descriptors\n", netdev->name,
+		     titan_ge_eth->tx_ring_skbs);
+
+#ifndef TITAN_RX_RING_IN_SRAM
+	dma_free_coherent(&titan_ge_device[port_num]->dev,
+			  titan_ge_eth->tx_desc_area_size,
+			  (void *) titan_ge_eth->tx_desc_area,
+			  titan_ge_eth->tx_dma);
+#endif
+}
+
+/*
+ * Free the Rx ring
+ */
+static void titan_ge_free_rx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	unsigned int curr;
+	unsigned long reg_data;
+
+	/* Stop the Rx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
+				(port_num << 8));
+	reg_data |= 0x000c0000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     titan_ge_eth->rx_ring_skbs && (curr < TITAN_GE_RX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->rx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->rx_skb[curr]);
+			titan_ge_eth->rx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->rx_ring_skbs != 0)
+		printk(KERN_ERR
+		       "%s: Error in freeing Rx Ring. %d skb's still"
+		       " stuck in RX Ring - ignoring them\n", netdev->name,
+		       titan_ge_eth->rx_ring_skbs);
+
+#ifndef TITAN_RX_RING_IN_SRAM
+	dma_free_coherent(&titan_ge_device[port_num]->dev,
+			  titan_ge_eth->rx_desc_area_size,
+			  (void *) titan_ge_eth->rx_desc_area,
+			  titan_ge_eth->rx_dma);
+#endif
+}
+
+/*
+ * Actually does the stop of the Ethernet device
+ */
+static void titan_ge_eth_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	netif_stop_queue(netdev);
+
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	titan_ge_free_tx_rings(netdev);
+	titan_ge_free_rx_rings(netdev);
+
+	/* Disable the Tx and Rx Interrupts for all channels */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, 0x0);
+}
+
+/*
+ * Update the MAC address. Note that we have to write the
+ * address in three station registers, 16 bits each. And this
+ * has to be done for TMAC and RMAC
+ */
+static void titan_ge_update_mac_address(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+	unsigned int port_num = titan_ge_eth->port_num;
+	u8 p_addr[6];
+
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+	memcpy(p_addr, netdev->dev_addr, 6);
+
+	/* Update the Address Filtering Match tables */
+	titan_ge_update_afx(titan_ge_eth);
+
+	printk("Station MAC : %d %d %d %d %d %d  \n",
+		p_addr[5], p_addr[4], p_addr[3],
+		p_addr[2], p_addr[1], p_addr[0]);
+
+	/* Set the MAC address here for TMAC and RMAC */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+}
+
+/*
+ * Set the MAC address of the Ethernet device
+ */
+static int titan_ge_set_mac_address(struct net_device *dev, void *addr)
+{
+	titan_ge_port_info *tp = netdev_priv(dev);
+	struct sockaddr *sa = addr;
+
+	memcpy(dev->dev_addr, sa->sa_data, dev->addr_len);
+
+	spin_lock_irq(&tp->lock);
+	titan_ge_update_mac_address(dev);
+	spin_unlock_irq(&tp->lock);
+
+	return 0;
+}
+
+/*
+ * Get the Ethernet device stats
+ */
+static struct net_device_stats *titan_ge_get_stats(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev_priv(netdev);
+
+	return &titan_ge_eth->stats;
+}
+
+/*
+ * Initialize the Rx descriptor ring for the Titan Ge
+ */
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info * titan_eth_port,
+				      int rx_desc_num,
+				      int rx_buff_size,
+				      unsigned long rx_desc_base_addr,
+				      unsigned long rx_buff_base_addr,
+				      unsigned long rx_dma)
+{
+	volatile titan_ge_rx_desc *rx_desc;
+	unsigned long buffer_addr;
+	int index;
+	unsigned long titan_ge_rx_desc_bus = rx_dma;
+
+	buffer_addr = rx_buff_base_addr;
+	rx_desc = (titan_ge_rx_desc *) rx_desc_base_addr;
+
+	/* Check alignment */
+	if (rx_buff_base_addr & 0xF)
+		return 0;
+
+	/* Check Rx buffer size */
+	if ((rx_buff_size < 8) || (rx_buff_size > TITAN_GE_MAX_RX_BUFFER))
+		return 0;
+
+	/* 64-bit alignment
+	if ((rx_buff_base_addr + rx_buff_size) & 0x7)
+		return 0; */
+
+	/* Initialize the Rx desc ring */
+	for (index = 0; index < rx_desc_num; index++) {
+		titan_ge_rx_desc_bus += sizeof(titan_ge_rx_desc);
+		rx_desc[index].cmd_sts = 0;
+		rx_desc[index].buffer_addr = buffer_addr;
+		titan_eth_port->rx_skb[index] = NULL;
+		buffer_addr += rx_buff_size;
+	}
+
+	titan_eth_port->rx_curr_desc_q = 0;
+	titan_eth_port->rx_used_desc_q = 0;
+
+	titan_eth_port->rx_desc_area = (titan_ge_rx_desc *) rx_desc_base_addr;
+	titan_eth_port->rx_desc_area_size =
+	    rx_desc_num * sizeof(titan_ge_rx_desc);
+
+	titan_eth_port->rx_dma = rx_dma;
+
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the Tx descriptor ring. Descriptors in the SRAM
+ */
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info * titan_ge_port,
+				      int tx_desc_num,
+				      unsigned long tx_desc_base_addr,
+				      unsigned long tx_dma)
+{
+	titan_ge_tx_desc *tx_desc;
+	int index;
+	unsigned long titan_ge_tx_desc_bus = tx_dma;
+
+	if (tx_desc_base_addr & 0xF)
+		return 0;
+
+	tx_desc = (titan_ge_tx_desc *) tx_desc_base_addr;
+
+	for (index = 0; index < tx_desc_num; index++) {
+		titan_ge_port->tx_dma_array[index] =
+		    (dma_addr_t) titan_ge_tx_desc_bus;
+		titan_ge_tx_desc_bus += sizeof(titan_ge_tx_desc);
+		tx_desc[index].cmd_sts = 0x0000;
+		tx_desc[index].buffer_len = 0;
+		tx_desc[index].buffer_addr = 0x00000000;
+		titan_ge_port->tx_skb[index] = NULL;
+	}
+
+	titan_ge_port->tx_curr_desc_q = 0;
+	titan_ge_port->tx_used_desc_q = 0;
+
+	titan_ge_port->tx_desc_area = (titan_ge_tx_desc *) tx_desc_base_addr;
+	titan_ge_port->tx_desc_area_size =
+	    tx_desc_num * sizeof(titan_ge_tx_desc);
+
+	titan_ge_port->tx_dma = tx_dma;
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the device as an Ethernet device
+ */
+static int __init titan_ge_probe(struct device *device)
+{
+	titan_ge_port_info *titan_ge_eth;
+	struct net_device *netdev;
+	int port = to_platform_device(device)->id;
+	int err;
+
+	netdev = alloc_etherdev(sizeof(titan_ge_port_info));
+	if (!netdev) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	netdev->open = titan_ge_open;
+	netdev->stop = titan_ge_stop;
+	netdev->hard_start_xmit = titan_ge_start_xmit;
+	netdev->get_stats = titan_ge_get_stats;
+	netdev->set_multicast_list = titan_ge_set_multi;
+	netdev->set_mac_address = titan_ge_set_mac_address;
+
+	/* Tx timeout */
+	netdev->tx_timeout = titan_ge_tx_timeout;
+	netdev->watchdog_timeo = 2 * HZ;
+
+	/* Set these to very high values */
+	netdev->poll = titan_ge_poll;
+	netdev->weight = 64;
+
+	netdev->tx_queue_len = TITAN_GE_TX_QUEUE;
+	netif_carrier_off(netdev);
+	netdev->base_addr = 0;
+
+	netdev->change_mtu = titan_ge_change_mtu;
+
+	titan_ge_eth = netdev_priv(netdev);
+	/* Allocation of memory for the driver structures */
+
+	titan_ge_eth->port_num = port;
+
+	/* Configure the Tx timeout handler */
+	INIT_WORK(&titan_ge_eth->tx_timeout_task,
+		  (void (*)(void *)) titan_ge_tx_timeout_task, netdev);
+
+	spin_lock_init(&titan_ge_eth->lock);
+
+	/* set MAC addresses */
+	memcpy(netdev->dev_addr, titan_ge_mac_addr_base, 6);
+	netdev->dev_addr[5] += port;
+
+	err = register_netdev(netdev);
+
+	if (err)
+		goto out_free_netdev;
+
+	printk(KERN_NOTICE
+	       "%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       netdev->name, port, netdev->dev_addr[0],
+	       netdev->dev_addr[1], netdev->dev_addr[2],
+	       netdev->dev_addr[3], netdev->dev_addr[4],
+	       netdev->dev_addr[5]);
+
+	printk(KERN_NOTICE "Rx NAPI supported, Tx Coalescing ON \n");
+
+	return 0;
+
+out_free_netdev:
+	kfree(netdev);
+
+out:
+	return err;
+}
+
+/*
+ * Reset the Ethernet port
+ */
+static void titan_ge_port_reset(unsigned int port_num)
+{
+	unsigned int reg_data;
+
+	/* Stop the Tx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	/* Stop the Rx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	return;
+}
+
+/*
+ * Return the Tx desc after use by the XDMA
+ */
+static int titan_ge_return_tx_desc(titan_ge_port_info * titan_ge_eth, int port)
+{
+	int tx_desc_used;
+	struct sk_buff *skb;
+
+	tx_desc_used = titan_ge_eth->tx_used_desc_q;
+
+	/* return right away */
+	if (tx_desc_used == titan_ge_eth->tx_curr_desc_q)
+		return TITAN_ERROR;
+
+	/* Now the critical stuff */
+	skb = titan_ge_eth->tx_skb[tx_desc_used];
+
+	dev_kfree_skb_any(skb);
+
+	titan_ge_eth->tx_skb[tx_desc_used] = NULL;
+	titan_ge_eth->tx_used_desc_q =
+	    (tx_desc_used + 1) % TITAN_GE_TX_QUEUE;
+
+	return 0;
+}
+
+/*
+ * Coalescing for the Tx path
+ */
+static unsigned long titan_ge_tx_coal(unsigned long delay, int port)
+{
+	unsigned long rx_delay;
+
+	rx_delay = TITAN_GE_READ(TITAN_GE_INT_COALESCING);
+	delay = (delay << 16) | rx_delay;
+
+	TITAN_GE_WRITE(TITAN_GE_INT_COALESCING, delay);
+	TITAN_GE_WRITE(0x5038, delay);
+
+	return delay;
+}
+
+static struct device_driver titan_soc_driver = {
+	.name   = titan_string,
+	.bus    = &platform_bus_type,
+	.probe  = titan_ge_probe,
+	.remove = __devexit_p(titan_device_remove),
+};
+
+static void titan_platform_release (struct device *device)
+{
+	struct platform_device *pldev;
+
+	/* free device */
+	pldev = to_platform_device (device);
+	kfree (pldev);
+}
+
+/*
+ * Register the Titan GE with the kernel
+ */
+static int __init titan_ge_init_module(void)
+{
+	struct platform_device *pldev;
+	unsigned int version, device;
+	int i;
+
+	printk(KERN_NOTICE
+	       "PMC-Sierra TITAN 10/100/1000 Ethernet Driver \n");
+
+	titan_ge_base = (unsigned long) ioremap(TITAN_GE_BASE, TITAN_GE_SIZE);
+	if (!titan_ge_base) {
+		printk("Mapping Titan GE failed\n");
+		goto out;
+	}
+
+	device = TITAN_GE_READ(TITAN_GE_DEVICE_ID);
+	version = (device & 0x000f0000) >> 16;
+	device &= 0x0000ffff;
+
+	printk(KERN_NOTICE "Device Id : %x,  Version : %x \n", device, version);
+
+#ifdef TITAN_RX_RING_IN_SRAM
+	titan_ge_sram = (unsigned long) ioremap(TITAN_SRAM_BASE,
+						TITAN_SRAM_SIZE);
+	if (!titan_ge_sram) {
+		printk("Mapping Titan SRAM failed\n");
+		goto out_unmap_ge;
+	}
+#endif
+
+	if (driver_register(&titan_soc_driver)) {
+		printk(KERN_ERR "Driver registration failed\n");
+		goto out_unmap_sram;
+	}
+
+	for (i = 0; i < 3; i++) {
+		titan_ge_device[i] = NULL;
+
+	        if (!(pldev = kmalloc (sizeof (*pldev), GFP_KERNEL)))
+	                continue;
+
+                memset (pldev, 0, sizeof (*pldev));
+                pldev->name		= titan_string;
+                pldev->id		= i;
+                pldev->dev.release	= titan_platform_release;
+                titan_ge_device[i]	= pldev;
+
+                if (platform_device_register (pldev)) {
+                        kfree (pldev);
+                        titan_ge_device[i] = NULL;
+                        continue;
+                }
+                                                                                
+                if (!pldev->dev.driver) {
+	                /*
+			 * The driver was not bound to this device, there was
+	                 * no hardware at this address. Unregister it, as the
+	                 * release fuction will take care of freeing the
+	                 * allocated structure
+			 */
+                        titan_ge_device[i] = NULL;
+                        platform_device_unregister (pldev);
+                }
+        }
+
+	return 0;
+
+out_unmap_sram:
+	iounmap((void *)titan_ge_sram);
+
+out_unmap_ge:
+	iounmap((void *)titan_ge_base);
+
+out:
+	return -ENOMEM;
+}
+
+/*
+ * Unregister the Titan GE from the kernel
+ */
+static void __exit titan_ge_cleanup_module(void)
+{
+	int i;
+
+	driver_unregister(&titan_soc_driver);
+
+	for (i = 0; i < 3; i++) {
+		if (titan_ge_device[i]) {
+			platform_device_unregister (titan_ge_device[i]);
+			titan_ge_device[i] = NULL;
+		}
+	}
+
+	iounmap((void *)titan_ge_sram);
+	iounmap((void *)titan_ge_base);
+}
+
+MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
+MODULE_DESCRIPTION("Titan GE Ethernet driver");
+MODULE_LICENSE("GPL");
+
+module_init(titan_ge_init_module);
+module_exit(titan_ge_cleanup_module);
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/titan_ge.h linux_HEAD/drivers/net/titan_ge.h
--- linux-2.6.11.6/drivers/net/titan_ge.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/net/titan_ge.h	2005-02-17 21:49:50.000000000 +0100
@@ -0,0 +1,420 @@
+#ifndef _TITAN_GE_H_
+#define _TITAN_GE_H_
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+
+/*
+ * These functions should be later moved to a more generic location since there
+ * will be others accessing it also
+ */
+
+/*
+ * This is the way it works: LKB5 Base is at 0x0128. TITAN_BASE is defined in
+ * include/asm/titan_dep.h. TITAN_GE_BASE is the value in the TITAN_GE_LKB5
+ * register.
+ */
+
+#define	TITAN_GE_BASE	0xfe000000UL
+#define	TITAN_GE_SIZE	0x10000UL
+
+extern unsigned long titan_ge_base;
+
+#define	TITAN_GE_WRITE(offset, data) \
+		*(volatile u32 *)(titan_ge_base + (offset)) = (data)
+
+#define TITAN_GE_READ(offset) *(volatile u32 *)(titan_ge_base + (offset))
+
+#ifndef msec_delay
+#define msec_delay(x)   do { if(in_interrupt()) { \
+				/* Don't mdelay in interrupt context! */ \
+				BUG(); \
+			} else { \
+				set_current_state(TASK_UNINTERRUPTIBLE); \
+				schedule_timeout((x * HZ)/1000); \
+			} } while(0)
+#endif
+
+#define TITAN_GE_PORT_0
+
+#define	TITAN_SRAM_BASE		((OCD_READ(RM9000x2_OCD_LKB13) & ~1) << 4)
+#define	TITAN_SRAM_SIZE		0x2000UL
+
+extern unsigned long titan_ge_sram;
+
+/*
+ * We may need these constants
+ */
+#define TITAN_BIT0    0x00000001
+#define TITAN_BIT1    0x00000002
+#define TITAN_BIT2    0x00000004
+#define TITAN_BIT3    0x00000008
+#define TITAN_BIT4    0x00000010
+#define TITAN_BIT5    0x00000020
+#define TITAN_BIT6    0x00000040
+#define TITAN_BIT7    0x00000080
+#define TITAN_BIT8    0x00000100
+#define TITAN_BIT9    0x00000200
+#define TITAN_BIT10   0x00000400
+#define TITAN_BIT11   0x00000800
+#define TITAN_BIT12   0x00001000
+#define TITAN_BIT13   0x00002000
+#define TITAN_BIT14   0x00004000
+#define TITAN_BIT15   0x00008000
+#define TITAN_BIT16   0x00010000
+#define TITAN_BIT17   0x00020000
+#define TITAN_BIT18   0x00040000
+#define TITAN_BIT19   0x00080000
+#define TITAN_BIT20   0x00100000
+#define TITAN_BIT21   0x00200000
+#define TITAN_BIT22   0x00400000
+#define TITAN_BIT23   0x00800000
+#define TITAN_BIT24   0x01000000
+#define TITAN_BIT25   0x02000000
+#define TITAN_BIT26   0x04000000
+#define TITAN_BIT27   0x08000000
+#define TITAN_BIT28   0x10000000
+#define TITAN_BIT29   0x20000000
+#define TITAN_BIT30   0x40000000
+#define TITAN_BIT31   0x80000000
+
+/* Flow Control */
+#define	TITAN_GE_FC_NONE	0x0
+#define	TITAN_GE_FC_FULL	0x1
+#define	TITAN_GE_FC_TX_PAUSE	0x2
+#define	TITAN_GE_FC_RX_PAUSE	0x3
+
+/* Duplex Settings */
+#define	TITAN_GE_FULL_DUPLEX	0x1
+#define	TITAN_GE_HALF_DUPLEX	0x2
+
+/* Speed settings */
+#define	TITAN_GE_SPEED_1000	0x1
+#define	TITAN_GE_SPEED_100	0x2
+#define	TITAN_GE_SPEED_10	0x3
+
+/* Debugging info only */
+#undef TITAN_DEBUG
+
+/* Keep the rings in the Titan's SSRAM */
+#define TITAN_RX_RING_IN_SRAM
+
+#ifdef CONFIG_MIPS64
+#define	TITAN_GE_IE_MASK	0xfffffffffb001b64
+#define	TITAN_GE_IE_STATUS	0xfffffffffb001b60
+#else
+#define	TITAN_GE_IE_MASK	0xfb001b64
+#define	TITAN_GE_IE_STATUS	0xfb001b60
+#endif
+
+/* Support for Jumbo Frames */
+#undef TITAN_GE_JUMBO_FRAMES
+
+/* Rx buffer size */
+#ifdef TITAN_GE_JUMBO_FRAMES
+#define	TITAN_GE_JUMBO_BUFSIZE	9080
+#else
+#define	TITAN_GE_STD_BUFSIZE	1580
+#endif
+
+/*
+ * Tx and Rx Interrupt Coalescing parameter. These values are
+ * for 1 Ghz processor. Rx coalescing can be taken care of
+ * by NAPI. NAPI is adaptive and hence useful. Tx coalescing
+ * is not adaptive. Hence, these values need to be adjusted
+ * based on load, CPU speed etc.
+ */
+#define	TITAN_GE_RX_COAL	150
+#define	TITAN_GE_TX_COAL	300
+
+#if defined(__BIG_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct eth_rx_desc {
+	u32     reserved;	/* Unused 		*/
+	u32     buffer_addr;	/* CPU buffer address 	*/
+	u32	cmd_sts;	/* Command and Status	*/
+	u32	buffer;		/* XDMA buffer address	*/
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct eth_tx_desc {
+	u16     cmd_sts;	/* Command, Status and Buffer count */
+	u16	buffer_len;	/* Length of the buffer	*/
+	u32     buffer_addr;	/* Physical address of the buffer */
+} titan_ge_tx_desc;
+
+#elif defined(__LITTLE_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct eth_rx_desc {
+	u32	buffer_addr;	/* CPU buffer address   */
+	u32	reserved;	/* Unused               */
+	u32	buffer;		/* XDMA buffer address  */
+	u32	cmd_sts;	/* Command and Status   */
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct eth_tx_desc {
+	u32     buffer_addr;	/* Physical address of the buffer */
+	u16     buffer_len;     /* Length of the buffer */
+	u16     cmd_sts;        /* Command, Status and Buffer count */
+} titan_ge_tx_desc;
+#endif
+
+/* Default Tx Queue Size */
+#define	TITAN_GE_TX_QUEUE	128
+#define TITAN_TX_RING_BYTES	(TITAN_GE_TX_QUEUE * sizeof(struct eth_tx_desc))
+
+/* Default Rx Queue Size */
+#define	TITAN_GE_RX_QUEUE	64
+#define TITAN_RX_RING_BYTES	(TITAN_GE_RX_QUEUE * sizeof(struct eth_rx_desc))
+
+/* Packet Structure */
+typedef struct _pkt_info {
+	unsigned int           len;
+	unsigned int            cmd_sts;
+	unsigned int            buffer;
+	struct sk_buff          *skb;
+	unsigned int		checksum;
+} titan_ge_packet;
+
+
+#define	PHYS_CNT	3
+
+/* Titan Port specific data structure */
+typedef struct _eth_port_ctrl {
+	unsigned int		port_num;
+	u8			port_mac_addr[6];
+
+	/* Rx descriptor pointers */
+	int 			rx_curr_desc_q, rx_used_desc_q;
+
+	/* Tx descriptor pointers */
+	int 			tx_curr_desc_q, tx_used_desc_q;
+
+	/* Rx descriptor area */
+	volatile titan_ge_rx_desc	*rx_desc_area;
+	unsigned int			rx_desc_area_size;
+	struct sk_buff*			rx_skb[TITAN_GE_RX_QUEUE];
+
+	/* Tx Descriptor area */
+	volatile titan_ge_tx_desc	*tx_desc_area;
+	unsigned int                    tx_desc_area_size;
+	struct sk_buff*                 tx_skb[TITAN_GE_TX_QUEUE];
+
+	/* Timeout task */
+	struct work_struct		tx_timeout_task;
+
+	/* DMA structures and handles */
+	dma_addr_t			tx_dma;
+	dma_addr_t			rx_dma;
+	dma_addr_t			tx_dma_array[TITAN_GE_TX_QUEUE];
+
+	/* Device lock */
+	spinlock_t			lock;
+
+	unsigned int			tx_ring_skbs;
+	unsigned int			rx_ring_size;
+	unsigned int			tx_ring_size;
+	unsigned int			rx_ring_skbs;
+
+	struct net_device_stats		stats;
+
+	/* Tx and Rx coalescing */
+	unsigned long			rx_int_coal;
+	unsigned long			tx_int_coal;
+
+	/* Threshold for replenishing the Rx and Tx rings */
+	unsigned int			tx_threshold;
+	unsigned int			rx_threshold;
+
+	/* NAPI work limit */
+	unsigned int			rx_work_limit;
+} titan_ge_port_info;
+
+/* Titan specific constants */
+#define	TITAN_ETH_PORT_IRQ		3
+
+/* Max Rx buffer */
+#define	TITAN_GE_MAX_RX_BUFFER		65536
+
+/* Tx and Rx Error */
+#define	TITAN_GE_ERROR
+
+/* Rx Descriptor Command and Status */
+
+#define	TITAN_GE_RX_CRC_ERROR		TITAN_BIT27	/* crc error */
+#define	TITAN_GE_RX_OVERFLOW_ERROR	TITAN_BIT15	/* overflow */
+#define TITAN_GE_RX_BUFFER_OWNED	TITAN_BIT21	/* buffer ownership */
+#define	TITAN_GE_RX_STP			TITAN_BIT31	/* start of packet */
+#define	TITAN_GE_RX_BAM			TITAN_BIT30	/* broadcast address match */
+#define TITAN_GE_RX_PAM			TITAN_BIT28	/* physical address match */
+#define TITAN_GE_RX_LAFM		TITAN_BIT29	/* logical address filter match */
+#define TITAN_GE_RX_VLAN		TITAN_BIT26	/* virtual lans */
+#define TITAN_GE_RX_PERR		TITAN_BIT19	/* packet error */
+#define TITAN_GE_RX_TRUNC		TITAN_BIT20	/* packet size greater than 32 buffers */
+
+/* Tx Descriptor Command */
+#define	TITAN_GE_TX_BUFFER_OWNED	TITAN_BIT5	/* buffer ownership */
+#define	TITAN_GE_TX_ENABLE_INTERRUPT	TITAN_BIT15	/* Interrupt Enable */
+
+/* Return Status */
+#define	TITAN_OK	0x1	/* Good Status */
+#define	TITAN_ERROR	0x2	/* Error Status */
+
+/* MIB specific register offset */
+#define TITAN_GE_MSTATX_STATS_BASE_LOW       0x0800  /* MSTATX COUNTL[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_MID       0x0804  /* MSTATX COUNTM[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_HI        0x0808  /* MSTATX COUNTH[7:0] */
+#define TITAN_GE_MSTATX_CONTROL              0x0828  /* MSTATX Control */
+#define TITAN_GE_MSTATX_VARIABLE_SELECT      0x082C  /* MSTATX Variable Select */
+
+/* MIB counter offsets, add to the TITAN_GE_MSTATX_STATS_BASE_XXX */
+#define TITAN_GE_MSTATX_RXFRAMESOK                   0x0040
+#define TITAN_GE_MSTATX_RXOCTETSOK                   0x0050
+#define TITAN_GE_MSTATX_RXFRAMES                     0x0060
+#define TITAN_GE_MSTATX_RXOCTETS                     0x0070
+#define TITAN_GE_MSTATX_RXUNICASTFRAMESOK            0x0080
+#define TITAN_GE_MSTATX_RXBROADCASTFRAMESOK          0x0090
+#define TITAN_GE_MSTATX_RXMULTICASTFRAMESOK          0x00A0
+#define TITAN_GE_MSTATX_RXTAGGEDFRAMESOK             0x00B0
+#define TITAN_GE_MSTATX_RXMACPAUSECONTROLFRAMESOK    0x00C0
+#define TITAN_GE_MSTATX_RXMACCONTROLFRAMESOK         0x00D0
+#define TITAN_GE_MSTATX_RXFCSERROR                   0x00E0
+#define TITAN_GE_MSTATX_RXALIGNMENTERROR             0x00F0
+#define TITAN_GE_MSTATX_RXSYMBOLERROR                0x0100
+#define TITAN_GE_MSTATX_RXLAYER1ERROR                0x0110
+#define TITAN_GE_MSTATX_RXINRANGELENGTHERROR         0x0120
+#define TITAN_GE_MSTATX_RXLONGLENGTHERROR            0x0130
+#define TITAN_GE_MSTATX_RXLONGLENGTHCRCERROR         0x0140
+#define TITAN_GE_MSTATX_RXSHORTLENGTHERROR           0x0150
+#define TITAN_GE_MSTATX_RXSHORTLLENGTHCRCERROR       0x0160
+#define TITAN_GE_MSTATX_RXFRAMES64OCTETS             0x0170
+#define TITAN_GE_MSTATX_RXFRAMES65TO127OCTETS        0x0180
+#define TITAN_GE_MSTATX_RXFRAMES128TO255OCTETS       0x0190
+#define TITAN_GE_MSTATX_RXFRAMES256TO511OCTETS       0x01A0
+#define TITAN_GE_MSTATX_RXFRAMES512TO1023OCTETS      0x01B0
+#define TITAN_GE_MSTATX_RXFRAMES1024TO1518OCTETS     0x01C0
+#define TITAN_GE_MSTATX_RXFRAMES1519TOMAXSIZE        0x01D0
+#define TITAN_GE_MSTATX_RXSTATIONADDRESSFILTERED     0x01E0
+#define TITAN_GE_MSTATX_RXVARIABLE                   0x01F0
+#define TITAN_GE_MSTATX_GENERICADDRESSFILTERED       0x0200
+#define TITAN_GE_MSTATX_UNICASTFILTERED              0x0210
+#define TITAN_GE_MSTATX_MULTICASTFILTERED            0x0220
+#define TITAN_GE_MSTATX_BROADCASTFILTERED            0x0230
+#define TITAN_GE_MSTATX_HASHFILTERED                 0x0240
+#define TITAN_GE_MSTATX_TXFRAMESOK                   0x0250
+#define TITAN_GE_MSTATX_TXOCTETSOK                   0x0260
+#define TITAN_GE_MSTATX_TXOCTETS                     0x0270
+#define TITAN_GE_MSTATX_TXTAGGEDFRAMESOK             0x0280
+#define TITAN_GE_MSTATX_TXMACPAUSECONTROLFRAMESOK    0x0290
+#define TITAN_GE_MSTATX_TXFCSERROR                   0x02A0
+#define TITAN_GE_MSTATX_TXSHORTLENGTHERROR           0x02B0
+#define TITAN_GE_MSTATX_TXLONGLENGTHERROR            0x02C0
+#define TITAN_GE_MSTATX_TXSYSTEMERROR                0x02D0
+#define TITAN_GE_MSTATX_TXMACERROR                   0x02E0
+#define TITAN_GE_MSTATX_TXCARRIERSENSEERROR          0x02F0
+#define TITAN_GE_MSTATX_TXSQETESTERROR               0x0300
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESOK            0x0310
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESOK          0x0320
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESOK          0x0330
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESATTEMPTED     0x0340
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESATTEMPTED   0x0350
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESATTEMPTED   0x0360
+#define TITAN_GE_MSTATX_TXFRAMES64OCTETS             0x0370
+#define TITAN_GE_MSTATX_TXFRAMES65TO127OCTETS        0x0380
+#define TITAN_GE_MSTATX_TXFRAMES128TO255OCTETS       0x0390
+#define TITAN_GE_MSTATX_TXFRAMES256TO511OCTETS       0x03A0
+#define TITAN_GE_MSTATX_TXFRAMES512TO1023OCTETS      0x03B0
+#define TITAN_GE_MSTATX_TXFRAMES1024TO1518OCTETS     0x03C0
+#define TITAN_GE_MSTATX_TXFRAMES1519TOMAXSIZE        0x03D0
+#define TITAN_GE_MSTATX_TXVARIABLE                   0x03E0
+#define TITAN_GE_MSTATX_RXSYSTEMERROR                0x03F0
+#define TITAN_GE_MSTATX_SINGLECOLLISION              0x0400
+#define TITAN_GE_MSTATX_MULTIPLECOLLISION            0x0410
+#define TITAN_GE_MSTATX_DEFERREDXMISSIONS            0x0420
+#define TITAN_GE_MSTATX_LATECOLLISIONS               0x0430
+#define TITAN_GE_MSTATX_ABORTEDDUETOXSCOLLS          0x0440
+
+/* Interrupt specific defines */
+#define TITAN_GE_DEVICE_ID         0x0000  /* Device ID */
+#define TITAN_GE_RESET             0x0004  /* Reset reg */
+#define TITAN_GE_TSB_CTRL_0        0x000C  /* TSB Control reg 0 */
+#define TITAN_GE_TSB_CTRL_1        0x0010  /* TSB Control reg 1 */
+#define TITAN_GE_INTR_GRP0_STATUS  0x0040  /* General Interrupt Group 0 Status */
+#define TITAN_GE_INTR_XDMA_CORE_A  0x0048  /* XDMA Channel Interrupt Status, Core A*/
+#define TITAN_GE_INTR_XDMA_CORE_B  0x004C  /* XDMA Channel Interrupt Status, Core B*/
+#define	TITAN_GE_INTR_XDMA_IE	   0x0058  /* XDMA Channel Interrupt Enable */
+#define TITAN_GE_SDQPF_ECC_INTR    0x480C  /* SDQPF ECC Interrupt Status */
+#define TITAN_GE_SDQPF_RXFIFO_CTL  0x4828  /* SDQPF RxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_RXFIFO_INTR 0x482C  /* SDQPF RxFifo Interrupt Status */
+#define TITAN_GE_SDQPF_TXFIFO_CTL  0x4928  /* SDQPF TxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_TXFIFO_INTR 0x492C  /* SDQPF TxFifo Interrupt Status */
+#define	TITAN_GE_SDQPF_RXFIFO_0	   0x4840  /* SDQPF RxFIFO Enable */
+#define	TITAN_GE_SDQPF_TXFIFO_0	   0x4940  /* SDQPF TxFIFO Enable */
+#define TITAN_GE_XDMA_CONFIG       0x5000  /* XDMA Global Configuration */
+#define TITAN_GE_XDMA_INTR_SUMMARY 0x5010  /* XDMA Interrupt Summary */
+#define TITAN_GE_XDMA_BUFADDRPRE   0x5018  /* XDMA Buffer Address Prefix */
+#define TITAN_GE_XDMA_DESCADDRPRE  0x501C  /* XDMA Descriptor Address Prefix */
+#define TITAN_GE_XDMA_PORTWEIGHT   0x502C  /* XDMA Port Weight Configuration */
+
+/* Rx MAC defines */
+#define TITAN_GE_RMAC_CONFIG_1               0x1200  /* RMAC Configuration 1 */
+#define TITAN_GE_RMAC_CONFIG_2               0x1204  /* RMAC Configuration 2 */
+#define TITAN_GE_RMAC_MAX_FRAME_LEN          0x1208  /* RMAC Max Frame Length */
+#define TITAN_GE_RMAC_STATION_HI             0x120C  /* Rx Station Address High */
+#define TITAN_GE_RMAC_STATION_MID            0x1210  /* Rx Station Address Middle */
+#define TITAN_GE_RMAC_STATION_LOW            0x1214  /* Rx Station Address Low */
+#define TITAN_GE_RMAC_LINK_CONFIG            0x1218  /* RMAC Link Configuration */
+
+/* Tx MAC defines */
+#define TITAN_GE_TMAC_CONFIG_1               0x1240  /* TMAC Configuration 1 */
+#define TITAN_GE_TMAC_CONFIG_2               0x1244  /* TMAC Configuration 2 */
+#define TITAN_GE_TMAC_IPG                    0x1248  /* TMAC Inter-Packet Gap */
+#define TITAN_GE_TMAC_STATION_HI             0x124C  /* Tx Station Address High */
+#define TITAN_GE_TMAC_STATION_MID            0x1250  /* Tx Station Address Middle */
+#define TITAN_GE_TMAC_STATION_LOW            0x1254  /* Tx Station Address Low */
+#define TITAN_GE_TMAC_MAX_FRAME_LEN          0x1258  /* TMAC Max Frame Length */
+#define TITAN_GE_TMAC_MIN_FRAME_LEN          0x125C  /* TMAC Min Frame Length */
+#define TITAN_GE_TMAC_PAUSE_FRAME_TIME       0x1260  /* TMAC Pause Frame Time */
+#define TITAN_GE_TMAC_PAUSE_FRAME_INTERVAL   0x1264  /* TMAC Pause Frame Interval */
+
+/* GMII register */
+#define TITAN_GE_GMII_INTERRUPT_STATUS       0x1348  /* GMII Interrupt Status */
+#define TITAN_GE_GMII_CONFIG_GENERAL         0x134C  /* GMII Configuration General */
+#define TITAN_GE_GMII_CONFIG_MODE            0x1350  /* GMII Configuration Mode */
+
+/* Tx and Rx XDMA defines */
+#define	TITAN_GE_INT_COALESCING		     0x5030 /* Interrupt Coalescing */
+#define	TITAN_GE_CHANNEL0_CONFIG	     0x5040 /* Channel 0 XDMA config */
+#define	TITAN_GE_CHANNEL0_INTERRUPT	     0x504c /* Channel 0 Interrupt Status */
+#define	TITAN_GE_GDI_INTERRUPT_ENABLE        0x5050 /* IE for the GDI Errors */
+#define	TITAN_GE_CHANNEL0_PACKET	     0x5060 /* Channel 0 Packet count */
+#define	TITAN_GE_CHANNEL0_BYTE		     0x5064 /* Channel 0 Byte count */
+#define	TITAN_GE_CHANNEL0_TX_DESC	     0x5054 /* Channel 0 Tx first desc */
+#define	TITAN_GE_CHANNEL0_RX_DESC	     0x5058 /* Channel 0 Rx first desc */
+
+/* AFX (Address Filter Exact) register offsets for Slice 0 */
+#define TITAN_GE_AFX_EXACT_MATCH_LOW         0x1100  /* AFX Exact Match Address Low*/
+#define TITAN_GE_AFX_EXACT_MATCH_MID         0x1104  /* AFX Exact Match Address Mid*/
+#define TITAN_GE_AFX_EXACT_MATCH_HIGH        0x1108  /* AFX Exact Match Address Hi */
+#define TITAN_GE_AFX_EXACT_MATCH_VID         0x110C  /* AFX Exact Match VID */
+#define TITAN_GE_AFX_MULTICAST_HASH_LOW      0x1110  /* AFX Multicast HASH Low */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDLOW   0x1114  /* AFX Multicast HASH MidLow */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDHI    0x1118  /* AFX Multicast HASH MidHi */
+#define TITAN_GE_AFX_MULTICAST_HASH_HI       0x111C  /* AFX Multicast HASH Hi */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_0     0x1120  /* AFX Address Filter Ctrl 0 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_1     0x1124  /* AFX Address Filter Ctrl 1 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_2     0x1128  /* AFX Address Filter Ctrl 2 */
+
+/* Traffic Groomer block */
+#define        TITAN_GE_TRTG_CONFIG	     0x1000  /* TRTG Config */
+
+#endif 				/* _TITAN_GE_H_ */
+
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/titan_mdio.c linux_HEAD/drivers/net/titan_mdio.c
--- linux-2.6.11.6/drivers/net/titan_mdio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/net/titan_mdio.c	2004-10-20 17:57:59.000000000 +0200
@@ -0,0 +1,217 @@
+/*
+ * drivers/net/titan_mdio.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * Management Data IO (MDIO) driver for the Titan GMII. Interacts with the Marvel PHY
+ * on the Titan. No support for the TBI as yet.
+ *
+ */
+
+#include	"titan_mdio.h"
+
+#define MDIO_DEBUG
+
+/*
+ * Local constants
+ */
+#define MAX_CLKA            1023
+#define MAX_PHY_DEV         31
+#define MAX_PHY_REG         31
+#define WRITEADDRS_OPCODE   0x0
+#define	READ_OPCODE	    0x2
+#define WRITE_OPCODE        0x1
+#define MAX_MDIO_POLL       100
+
+/*
+ * Titan MDIO and SCMB registers
+ */
+#define TITAN_GE_SCMB_CONTROL                0x01c0  /* SCMB Control */
+#define TITAN_GE_SCMB_CLKA	             0x01c4  /* SCMB Clock A */
+#define TITAN_GE_MDIO_COMMAND                0x01d0  /* MDIO Command */
+#define TITAN_GE_MDIO_DEVICE_PORT_ADDRESS    0x01d4  /* MDIO Device and Port addrs */
+#define TITAN_GE_MDIO_DATA                   0x01d8  /* MDIO Data */
+#define TITAN_GE_MDIO_INTERRUPTS             0x01dC  /* MDIO Interrupts */
+
+/*
+ * Function to poll the MDIO
+ */
+static int titan_ge_mdio_poll(void)
+{
+	int	i, val;
+
+	for (i = 0; i < MAX_MDIO_POLL; i++) {
+		val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+
+		if (!(val & 0x8000))
+			return TITAN_GE_MDIO_GOOD;
+	}
+
+	return TITAN_GE_MDIO_ERROR;
+}
+
+
+/*
+ * Initialize and configure the MDIO
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *titan_mdio)
+{
+	unsigned long	val;
+
+	/* Reset the SCMB and program into MDIO mode*/
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x9000);
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x1000);
+
+	/* CLK A */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_SCMB_CLKA);
+	val = ( (val & ~(0x03ff)) | (titan_mdio->clka & 0x03ff));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CLKA, val);
+
+	/* Preamble Suppresion */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0001)) | (titan_mdio->mdio_spre & 0x0001));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	/* MDIO mode */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x4000)) | (titan_mdio->mdio_mode & 0x4000));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Set the PHY address in indirect mode
+ */
+int titan_ge_mdio_inaddrs(int dev_addr, int reg_addr)
+{
+	volatile unsigned long	val;
+
+	/* Setup the PHY device */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	/* Write the new address */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITEADDRS_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Read the MDIO register. This is what the individual parametes mean:
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register offset
+ *
+ * See the spec for the Titan MAC. We operate in the Direct Mode.
+ */
+
+#define MAX_RETRIES	2
+
+int titan_ge_mdio_read(int dev_addr, int reg_addr, unsigned int *pdata)
+{
+	volatile unsigned long	val;
+	int retries = 0;
+
+	/* Setup the PHY device */
+
+again:
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	udelay(30);
+
+	/* Issue the read command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (READ_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	*pdata = (unsigned int)TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DATA);
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
+
+	udelay(30);
+
+	if (val & 0x2) {
+		if (retries == MAX_RETRIES)
+			return TITAN_GE_MDIO_ERROR;
+		else {
+			retries++;
+			goto again;
+		}
+	}
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Write to the MDIO register
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register that needs to be written to
+ *
+ */
+int titan_ge_mdio_write(int dev_addr, int reg_addr, unsigned int data)
+{
+	volatile unsigned long	val;
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	/* Setup the PHY device */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	udelay(30);
+
+	/* Setup the data to write */
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DATA, data);
+
+	udelay(30);
+
+	/* Issue the write command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITE_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
+	if (val & 0x2)
+		return TITAN_GE_MDIO_ERROR;
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/titan_mdio.h linux_HEAD/drivers/net/titan_mdio.h
--- linux-2.6.11.6/drivers/net/titan_mdio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/net/titan_mdio.h	2004-10-20 17:57:59.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * MDIO used to interact with the PHY when using GMII/MII
+ */
+#ifndef _TITAN_MDIO_H
+#define _TITAN_MDIO_H
+
+#include <linux/netdevice.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include "titan_ge.h"
+
+
+#define	TITAN_GE_MDIO_ERROR	(-9000)
+#define	TITAN_GE_MDIO_GOOD	0
+
+#define	TITAN_GE_MDIO_BASE		titan_ge_base
+
+#define	TITAN_GE_MDIO_READ(offset)	\
+	*(volatile u32 *)(titan_ge_base + (offset))
+
+#define	TITAN_GE_MDIO_WRITE(offset, data)	\
+	*(volatile u32 *)(titan_ge_base + (offset)) = (data)
+
+
+/* GMII specific registers */
+#define	TITAN_GE_MARVEL_PHY_ID		0x00
+#define	TITAN_PHY_AUTONEG_ADV		0x04
+#define	TITAN_PHY_LP_ABILITY		0x05
+#define	TITAN_GE_MDIO_MII_CTRL		0x09
+#define	TITAN_GE_MDIO_MII_EXTENDED	0x0f
+#define	TITAN_GE_MDIO_PHY_CTRL		0x10
+#define	TITAN_GE_MDIO_PHY_STATUS	0x11
+#define	TITAN_GE_MDIO_PHY_IE		0x12
+#define	TITAN_GE_MDIO_PHY_IS		0x13
+#define	TITAN_GE_MDIO_PHY_LED		0x18
+#define	TITAN_GE_MDIO_PHY_LED_OVER	0x19
+#define	PHY_ANEG_TIME_WAIT		45	/* 45 seconds wait time */
+
+/*
+ * MDIO Config Structure
+ */
+typedef struct {
+	unsigned int		clka;
+	int			mdio_spre;
+	int			mdio_mode;
+} titan_ge_mdio_config;
+
+/*
+ * Function Prototypes
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *);
+int titan_ge_mdio_inaddrs(int, int);
+int titan_ge_mdio_read(int, int, unsigned int *);
+int titan_ge_mdio_write(int, int, unsigned int);
+
+#endif /* _TITAN_MDIO_H */
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/tulip/de2104x.c linux_HEAD/drivers/net/tulip/de2104x.c
--- linux-2.6.11.6/drivers/net/tulip/de2104x.c	2005-04-03 00:12:15.000000000 +0200
+++ linux_HEAD/drivers/net/tulip/de2104x.c	2005-03-21 20:04:29.000000000 +0100
@@ -1787,10 +1787,15 @@ static void __init de21041_get_srom_info
 	/* DEC now has a specification but early board makers
 	   just put the address in the first EEPROM locations. */
 	/* This does  memcmp(eedata, eedata+16, 8) */
+
+#ifndef CONFIG_MIPS_COBALT
+
 	for (i = 0; i < 8; i ++)
 		if (ee_data[i] != ee_data[16+i])
 			sa_offset = 20;
 
+#endif
+
 	/* store MAC address */
 	for (i = 0; i < 6; i ++)
 		de->dev->dev_addr[i] = ee_data[i + sa_offset];
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/tulip/eeprom.c linux_HEAD/drivers/net/tulip/eeprom.c
--- linux-2.6.11.6/drivers/net/tulip/eeprom.c	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/drivers/net/tulip/eeprom.c	2005-02-21 22:17:44.000000000 +0100
@@ -63,6 +63,22 @@ static struct eeprom_fixup eeprom_fixups
 	 */
 	{ 0x1e00, 0x0000, 0x000b, 0x8f01, 0x0103, 0x0300, 0x0821, 0x000, 0x0001, 0x0000, 0x01e1 }
   },
+  {"Cobalt Microserver", 0, 0x10, 0xE0, {0x1e00, /* 0 == controller #, 1e == offset	*/
+					 0x0000, /* 0 == high offset, 0 == gap		*/
+					 0x0800, /* Default Autoselect			*/
+					 0x8001, /* 1 leaf, extended type, bogus len	*/
+					 0x0003, /* Type 3 (MII), PHY #0		*/
+					 0x0400, /* 0 init instr, 4 reset instr		*/
+					 0x0801, /* Set control mode, GP0 output	*/
+					 0x0000, /* Drive GP0 Low (RST is active low)	*/
+					 0x0800, /* control mode, GP0 input (undriven)	*/
+					 0x0000, /* clear control mode			*/
+					 0x7800, /* 100TX FDX + HDX, 10bT FDX + HDX	*/
+					 0x01e0, /* Advertise all above			*/
+					 0x5000, /* FDX all above			*/
+					 0x1800, /* Set fast TTM in 100bt modes		*/
+					 0x0000, /* PHY cannot be unplugged		*/
+  }},
   {NULL}};
 
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/tulip/media.c linux_HEAD/drivers/net/tulip/media.c
--- linux-2.6.11.6/drivers/net/tulip/media.c	2005-04-03 00:12:15.000000000 +0200
+++ linux_HEAD/drivers/net/tulip/media.c	2005-03-21 20:04:29.000000000 +0100
@@ -399,6 +399,9 @@ void tulip_select_media(struct net_devic
 	}
 
 	tp->csr6 = new_csr6 | (tp->csr6 & 0xfdff) | (tp->full_duplex ? 0x0200 : 0);
+
+	udelay(1000);
+
 	return;
 }
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/tulip/tulip_core.c linux_HEAD/drivers/net/tulip/tulip_core.c
--- linux-2.6.11.6/drivers/net/tulip/tulip_core.c	2005-04-03 00:12:15.000000000 +0200
+++ linux_HEAD/drivers/net/tulip/tulip_core.c	2005-03-21 20:04:29.000000000 +0100
@@ -1514,8 +1514,8 @@ static int __devinit tulip_init_one (str
                     (PCI_SLOT(pdev->devfn) == 12))) {
                        /* Cobalt MAC address in first EEPROM locations. */
                        sa_offset = 0;
-                       /* No media table either */
-                       tp->flags &= ~HAS_MEDIA_TABLE;
+		       /* Ensure our media table fixup get's applied */
+		       memcpy(ee_data + 16, ee_data, 8);
                }
 #endif
 #ifdef CONFIG_GSC
diff -urpNX dontdiff linux-2.6.11.6/drivers/net/tun.c linux_HEAD/drivers/net/tun.c
--- linux-2.6.11.6/drivers/net/tun.c	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/drivers/net/tun.c	2005-03-21 20:04:27.000000000 +0100
@@ -843,7 +843,7 @@ static struct ethtool_ops tun_ethtool_op
 	.set_rx_csum	= tun_set_rx_csum
 };
 
-int __init tun_init(void)
+static int __init tun_init(void)
 {
 	int ret = 0;
 
@@ -856,7 +856,7 @@ int __init tun_init(void)
 	return ret;
 }
 
-void tun_cleanup(void)
+static void tun_cleanup(void)
 {
 	struct tun_struct *tun, *nxt;
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/Kconfig linux_HEAD/drivers/pcmcia/Kconfig
--- linux-2.6.11.6/drivers/pcmcia/Kconfig	2005-04-03 00:12:23.000000000 +0200
+++ linux_HEAD/drivers/pcmcia/Kconfig	2005-03-21 20:04:33.000000000 +0100
@@ -201,3 +201,4 @@ config PCCARD_NONSTATIC
 endif	# PCCARD
 
 endmenu
+
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/Makefile linux_HEAD/drivers/pcmcia/Makefile
--- linux-2.6.11.6/drivers/pcmcia/Makefile	2005-03-26 04:28:25.000000000 +0100
+++ linux_HEAD/drivers/pcmcia/Makefile	2005-02-17 21:50:00.000000000 +0100
@@ -28,15 +28,21 @@ obj-$(CONFIG_HD64465_PCMCIA)			+= hd6446
 obj-$(CONFIG_PCMCIA_SA1100)			+= sa11xx_core.o sa1100_cs.o
 obj-$(CONFIG_PCMCIA_SA1111)			+= sa11xx_core.o sa1111_cs.o
 obj-$(CONFIG_PCMCIA_PXA2XX)                     += pxa2xx_core.o pxa2xx_cs.o
-obj-$(CONFIG_M32R_PCC)				+= m32r_pcc.o
-obj-$(CONFIG_M32R_CFC)				+= m32r_cfc.o
-obj-$(CONFIG_PCMCIA_AU1X00)			+= au1x00_ss.o
 obj-$(CONFIG_PCMCIA_VRC4171)			+= vrc4171_card.o
 obj-$(CONFIG_PCMCIA_VRC4173)			+= vrc4173_cardu.o
+obj-$(CONFIG_PCMCIA_AU1X00)			+= au1x00_ss.o
+
+pcmcia_core-y					+= cistpl.o rsrc_mgr.o cs.o socket_sysfs.o
+pcmcia_core-$(CONFIG_CARDBUS)			+= cardbus.o
 
 sa11xx_core-y					+= soc_common.o sa11xx_base.o
 pxa2xx_core-y					+= soc_common.o pxa2xx_base.o
 
+sa1111_cs-y					+= sa1111_generic.o
+sa1111_cs-$(CONFIG_ASSABET_NEPONSET)		+= sa1100_neponset.o
+sa1111_cs-$(CONFIG_SA1100_BADGE4)		+= sa1100_badge4.o
+sa1111_cs-$(CONFIG_SA1100_JORNADA720)		+= sa1100_jornada720.o
+
 au1x00_ss-y					+= au1000_generic.o
 au1x00_ss-$(CONFIG_MIPS_PB1000)			+= au1000_pb1x00.o
 au1x00_ss-$(CONFIG_MIPS_PB1100)			+= au1000_pb1x00.o
@@ -45,12 +51,7 @@ au1x00_ss-$(CONFIG_MIPS_DB1000)			+= au1
 au1x00_ss-$(CONFIG_MIPS_DB1100)			+= au1000_db1x00.o
 au1x00_ss-$(CONFIG_MIPS_DB1500)			+= au1000_db1x00.o
 au1x00_ss-$(CONFIG_MIPS_DB1550)			+= au1000_db1x00.o
-au1x00_ss-$(CONFIG_MIPS_XXS1500)               += au1000_xxs1500.o
-
-sa1111_cs-y					+= sa1111_generic.o
-sa1111_cs-$(CONFIG_ASSABET_NEPONSET)		+= sa1100_neponset.o
-sa1111_cs-$(CONFIG_SA1100_BADGE4)		+= sa1100_badge4.o
-sa1111_cs-$(CONFIG_SA1100_JORNADA720)		+= sa1100_jornada720.o
+au1x00_ss-$(CONFIG_MIPS_XXS1500)	 	+= au1000_xxs1500.o
 
 sa1100_cs-y					+= sa1100_generic.o
 sa1100_cs-$(CONFIG_SA1100_ASSABET)		+= sa1100_assabet.o
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/au1000_db1x00.c linux_HEAD/drivers/pcmcia/au1000_db1x00.c
--- linux-2.6.11.6/drivers/pcmcia/au1000_db1x00.c	2005-03-26 04:28:50.000000000 +0100
+++ linux_HEAD/drivers/pcmcia/au1000_db1x00.c	2004-10-27 02:14:43.000000000 +0200
@@ -8,7 +8,7 @@
  *
  * Copyright 2004 Pete Popov, updated the driver to 2.6.
  * Followed the sa11xx API and largely copied many of the hardware
- * independent functions.
+ * independent functions. 
  *
  * ########################################################################
  *
@@ -27,7 +27,7 @@
  *
  * ########################################################################
  *
- *
+ * 
  */
 
 #include <linux/module.h>
@@ -71,7 +71,7 @@ static void db1x00_pcmcia_shutdown(struc
 	au_sync_delay(2);
 }
 
-static void
+static void 
 db1x00_pcmcia_socket_state(struct au1000_pcmcia_socket *skt, struct pcmcia_state *state)
 {
 	u32 inserted;
@@ -95,8 +95,8 @@ db1x00_pcmcia_socket_state(struct au1000
 		return;
 	}
 
-	if (inserted)
-		debug("db1x00 socket %d: inserted %d, vs %d pcmcia %x\n",
+	if (inserted) 
+		debug("db1x00 socket %d: inserted %d, vs %d pcmcia %x\n", 
 				skt->nr, inserted, vs, bcsr->pcmcia);
 
 	if (inserted) {
@@ -120,14 +120,14 @@ db1x00_pcmcia_socket_state(struct au1000
 		 * we should turn off power to it
 		 */
 		if ((skt->nr == 0) && (bcsr->pcmcia & BCSR_PCMCIA_PC0RST)) {
-			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC0RST |
+			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC0RST | 
 					BCSR_PCMCIA_PC0DRVEN |
 					BCSR_PCMCIA_PC0VPP |
 					BCSR_PCMCIA_PC0VCC);
 			au_sync_delay(10);
 		}
 		else if ((skt->nr == 1) && bcsr->pcmcia & BCSR_PCMCIA_PC1RST) {
-			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC1RST |
+			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC1RST | 
 					BCSR_PCMCIA_PC1DRVEN |
 					BCSR_PCMCIA_PC1VPP |
 					BCSR_PCMCIA_PC1VCC);
@@ -137,21 +137,21 @@ db1x00_pcmcia_socket_state(struct au1000
 
 	state->bvd1=1;
 	state->bvd2=1;
-	state->wrprot=0;
+	state->wrprot=0; 
 }
 
-static int
+static int 
 db1x00_pcmcia_configure_socket(struct au1000_pcmcia_socket *skt, struct socket_state_t *state)
 {
 	u16 pwr;
 	int sock = skt->nr;
 
-	debug("config_skt %d Vcc %dV Vpp %dV, reset %d\n",
-			sock, state->Vcc, state->Vpp,
+	debug("config_skt %d Vcc %dV Vpp %dV, reset %d\n", 
+			sock, state->Vcc, state->Vpp, 
 			state->flags & SS_RESET);
 
 	/* pcmcia reg was set to zero at init time. Be careful when
-	 * initializing a socket not to wipe out the settings of the
+	 * initializing a socket not to wipe out the settings of the 
 	 * other socket.
 	 */
 	pwr = bcsr->pcmcia;
@@ -176,9 +176,9 @@ db1x00_pcmcia_configure_socket(struct au
 				case 33:
 				default:
 					pwr |= SET_VCC_VPP(0,0,sock);
-					printk("%s: bad Vcc/Vpp (%d:%d)\n",
-							__FUNCTION__,
-							state->Vcc,
+					printk("%s: bad Vcc/Vpp (%d:%d)\n", 
+							__FUNCTION__, 
+							state->Vcc, 
 							state->Vpp);
 					break;
 			}
@@ -197,16 +197,16 @@ db1x00_pcmcia_configure_socket(struct au
 				case 50:
 				default:
 					pwr |= SET_VCC_VPP(0,0,sock);
-					printk("%s: bad Vcc/Vpp (%d:%d)\n",
-							__FUNCTION__,
-							state->Vcc,
+					printk("%s: bad Vcc/Vpp (%d:%d)\n", 
+							__FUNCTION__, 
+							state->Vcc, 
 							state->Vpp);
 					break;
 			}
 			break;
 		default: /* what's this ? */
 			pwr |= SET_VCC_VPP(0,0,sock);
-			printk(KERN_ERR "%s: bad Vcc %d\n",
+			printk(KERN_ERR "%s: bad Vcc %d\n", 
 					__FUNCTION__, state->Vcc);
 			break;
 	}
@@ -265,7 +265,7 @@ void db1x00_socket_suspend(struct au1000
 	/* nothing to do for now */
 }
 
-struct pcmcia_low_level db1x00_pcmcia_ops = {
+struct pcmcia_low_level db1x00_pcmcia_ops = { 
 	.owner			= THIS_MODULE,
 
 	.hw_init 		= db1x00_pcmcia_hw_init,
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/au1000_generic.c linux_HEAD/drivers/pcmcia/au1000_generic.c
--- linux-2.6.11.6/drivers/pcmcia/au1000_generic.c	2005-03-26 04:28:22.000000000 +0100
+++ linux_HEAD/drivers/pcmcia/au1000_generic.c	2005-02-17 21:50:00.000000000 +0100
@@ -7,8 +7,8 @@
  *         	ppopov@embeddedalley.com or source@mvista.com
  *
  * Copyright 2004 Pete Popov, Embedded Alley Solutions, Inc.
- * Updated the driver to 2.6. Followed the sa11xx API and largely
- * copied many of the hardware independent functions.
+ * Updated the driver to 2.6. Followed the sa11xx API and largely 
+ * copied many of the hardware independent functions. 
  *
  * ########################################################################
  *
@@ -78,7 +78,7 @@ static int (*au1x00_pcmcia_hw_init[])(st
 	au1x_board_init,
 };
 
-static int
+static int 
 au1x00_pcmcia_skt_state(struct au1000_pcmcia_socket *skt)
 {
 	struct pcmcia_state state;
@@ -246,7 +246,7 @@ au1x00_pcmcia_get_status(struct pcmcia_s
 
 /* au1x00_pcmcia_get_socket()
  * Implements the get_socket() operation for the in-kernel PCMCIA
- * service (formerly SS_GetSocket in Card Services). Not a very
+ * service (formerly SS_GetSocket in Card Services). Not a very 
  * exciting routine.
  *
  * Returns: 0
@@ -345,7 +345,7 @@ au1x00_pcmcia_set_mem_map(struct pcmcia_
 		map->static_start = skt->phys_mem + map->card_start;
 	}
 
-	debug("set_mem_map %d start %08lx card_start %08x\n",
+	debug("set_mem_map %d start %08lx card_start %08x\n", 
 			map->map, map->static_start, map->card_start);
 	return 0;
 
@@ -412,11 +412,11 @@ int au1x00_pcmcia_socket_probe(struct de
 		skt->res_mem.flags	= IORESOURCE_MEM;
 		skt->res_attr.name	= "attribute";
 		skt->res_attr.flags	= IORESOURCE_MEM;
-
+		
 		/*
 		 * PCMCIA client drivers use the inb/outb macros to access the
-		 * IO registers. Since mips_io_port_base is added to the
-		 * access address of the mips implementation of inb/outb,
+		 * IO registers. Since mips_io_port_base is added to the 
+		 * access address of the mips implementation of inb/outb, 
 		 * we need to subtract it here because we want to access the
 		 * I/O or MEM address directly, without going through this
 		 * "mips_io_port_base" mechanism.
@@ -462,7 +462,7 @@ int au1x00_pcmcia_socket_probe(struct de
 
 	do {
 		struct au1000_pcmcia_socket *skt = PCMCIA_SOCKET(i);
-
+		
 		del_timer_sync(&skt->poll_timer);
 		pcmcia_unregister_socket(&skt->socket);
 out_err:
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/au1000_generic.h linux_HEAD/drivers/pcmcia/au1000_generic.h
--- linux-2.6.11.6/drivers/pcmcia/au1000_generic.h	2005-03-26 04:28:46.000000000 +0100
+++ linux_HEAD/drivers/pcmcia/au1000_generic.h	2005-03-17 22:10:53.000000000 +0100
@@ -61,21 +61,21 @@
 
 struct pcmcia_state {
   unsigned detect: 1,
-            ready: 1,
-           wrprot: 1,
+	    ready: 1,
+	   wrprot: 1,
 	     bvd1: 1,
 	     bvd2: 1,
-            vs_3v: 1,
-            vs_Xv: 1;
+	    vs_3v: 1,
+	    vs_Xv: 1;
 };
 
 struct pcmcia_configure {
   unsigned sock: 8,
-            vcc: 8,
-            vpp: 8,
-         output: 1,
-        speaker: 1,
-          reset: 1;
+	    vcc: 8,
+	    vpp: 8,
+	 output: 1,
+	speaker: 1,
+	  reset: 1;
 };
 
 struct pcmcia_irqs {
@@ -88,7 +88,7 @@ struct pcmcia_irqs {
 struct au1000_pcmcia_socket {
 	struct pcmcia_socket socket;
 
-	/*
+	/* 
 	 * Info from low level handler
 	 */
 	struct device		*dev;
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/au1000_xxs1500.c linux_HEAD/drivers/pcmcia/au1000_xxs1500.c
--- linux-2.6.11.6/drivers/pcmcia/au1000_xxs1500.c	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/drivers/pcmcia/au1000_xxs1500.c	2004-10-27 02:14:43.000000000 +0200
@@ -23,7 +23,7 @@
  *
  * ########################################################################
  *
- *
+ * 
  */
 #include <linux/module.h>
 #include <linux/init.h>
@@ -74,14 +74,14 @@ static int xxs1500_pcmcia_shutdown(void)
 	au_sync_delay(100);
 
 	/* assert reset */
-	au_writel(au_readl(GPIO2_PINSTATE) | (1<<4)|(1<<20),
+	au_writel(au_readl(GPIO2_PINSTATE) | (1<<4)|(1<<20), 
 			GPIO2_OUTPUT);
 	au_sync_delay(100);
 	return 0;
 }
 
 
-static int
+static int 
 xxs1500_pcmcia_socket_state(unsigned sock, struct pcmcia_state *state)
 {
 	u32 inserted; u32 vs;
@@ -123,7 +123,7 @@ xxs1500_pcmcia_socket_state(unsigned soc
 
 	state->bvd1= gpio2 & (1<<10);
 	state->bvd2 = gpio2 & (1<<11);
-	state->wrprot=0;
+	state->wrprot=0; 
 	return 1;
 }
 
@@ -137,13 +137,13 @@ static int xxs1500_pcmcia_get_irq_info(s
 }
 
 
-static int
+static int 
 xxs1500_pcmcia_configure_socket(const struct pcmcia_configure *configure)
 {
 
 	if(configure->sock > PCMCIA_MAX_SOCK) return -1;
 
-	DEBUG("Vcc %dV Vpp %dV, reset %d\n",
+	DEBUG("Vcc %dV Vpp %dV, reset %d\n", 
 			configure->vcc, configure->vpp, configure->reset);
 
 	switch(configure->vcc){
@@ -167,22 +167,22 @@ xxs1500_pcmcia_configure_socket(const st
 
 	if (!configure->reset) {
 		DEBUG("deassert reset\n");
-		au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<4))|(1<<20),
+		au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<4))|(1<<20), 
 				GPIO2_OUTPUT);
 		au_sync_delay(100);
-		au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<5))|(1<<21),
+		au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<5))|(1<<21), 
 				GPIO2_OUTPUT);
 	}
 	else {
 		DEBUG("assert reset\n");
-		au_writel(au_readl(GPIO2_PINSTATE) | (1<<4)|(1<<20),
+		au_writel(au_readl(GPIO2_PINSTATE) | (1<<4)|(1<<20), 
 				GPIO2_OUTPUT);
 	}
 	au_sync_delay(100);
 	return 0;
 }
 
-struct pcmcia_low_level xxs1500_pcmcia_ops = {
+struct pcmcia_low_level xxs1500_pcmcia_ops = { 
 	xxs1500_pcmcia_init,
 	xxs1500_pcmcia_shutdown,
 	xxs1500_pcmcia_socket_state,
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/vrc4173_cardu.c linux_HEAD/drivers/pcmcia/vrc4173_cardu.c
--- linux-2.6.11.6/drivers/pcmcia/vrc4173_cardu.c	2005-04-03 00:12:23.000000000 +0200
+++ linux_HEAD/drivers/pcmcia/vrc4173_cardu.c	2004-10-27 02:14:44.000000000 +0200
@@ -300,7 +300,7 @@ static int cardu_get_io_map(unsigned int
 
 	map = io->map;
 	if (map > 1)
-		return -EINVAL;
+		return -EINVAL; 
 
 	io->start = exca_readw(socket, IO_WIN_SA(map));
 	io->stop = exca_readw(socket, IO_WIN_EA(map));
@@ -467,7 +467,7 @@ static uint16_t get_events(vrc4173_socke
 
 	status = exca_readb(socket, IF_STATUS);
 	csc = exca_readb(socket, CARD_SC);
-	if ((csc & CARD_DT_CHG) &&
+	if ((csc & CARD_DT_CHG) && 
 	    ((status & (CARD_DETECT1|CARD_DETECT2)) == (CARD_DETECT1|CARD_DETECT2)))
 		events |= SS_DETECT;
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/pcmcia/vrc4173_cardu.h linux_HEAD/drivers/pcmcia/vrc4173_cardu.h
--- linux-2.6.11.6/drivers/pcmcia/vrc4173_cardu.h	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/drivers/pcmcia/vrc4173_cardu.h	2003-11-16 09:21:03.000000000 +0100
@@ -136,8 +136,8 @@
 
 #define IO_WIN_CNT		0x007
  #define IO_WIN_CNT_MASK(x)	(0x03 << ((x) << 2))
- #define IO_WIN_DATA_AUTOSZ(x)	(0x02 << ((x) << 2))
- #define IO_WIN_DATA_16BIT(x)	(0x01 << ((x) << 2))
+ #define IO_WIN_DATA_AUTOSZ(x)	(0x02 << ((x) << 2))	
+ #define IO_WIN_DATA_16BIT(x)	(0x01 << ((x) << 2))	
 
 #define IO_WIN_SA(x)		(0x008 + ((x) << 2))
 #define IO_WIN_EA(x)		(0x00a + ((x) << 2))
diff -urpNX dontdiff linux-2.6.11.6/drivers/scsi/NCR53C9x.h linux_HEAD/drivers/scsi/NCR53C9x.h
--- linux-2.6.11.6/drivers/scsi/NCR53C9x.h	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/drivers/scsi/NCR53C9x.h	2005-02-17 21:50:04.000000000 +0100
@@ -145,12 +145,7 @@
 
 #ifndef MULTIPLE_PAD_SIZES
 
-#ifdef CONFIG_CPU_HAS_WB
-#include <asm/wbflush.h>
-#define esp_write(__reg, __val) do{(__reg) = (__val); wbflush();} while(0)
-#else
-#define esp_write(__reg, __val) ((__reg) = (__val))
-#endif
+#define esp_write(__reg, __val) do{(__reg) = (__val); iob();} while(0)
 #define esp_read(__reg) (__reg)
 
 struct ESP_regs {
diff -urpNX dontdiff linux-2.6.11.6/drivers/scsi/dec_esp.c linux_HEAD/drivers/scsi/dec_esp.c
--- linux-2.6.11.6/drivers/scsi/dec_esp.c	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/drivers/scsi/dec_esp.c	2004-10-27 02:14:47.000000000 +0200
@@ -54,7 +54,7 @@
 
 static int  dma_bytes_sent(struct NCR_ESP *esp, int fifo_count);
 static void dma_drain(struct NCR_ESP *esp);
-static int  dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd *sp);
+static int  dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd * sp);
 static void dma_dump_state(struct NCR_ESP *esp);
 static void dma_init_read(struct NCR_ESP *esp, u32 vaddress, int length);
 static void dma_init_write(struct NCR_ESP *esp, u32 vaddress, int length);
@@ -63,9 +63,9 @@ static void dma_ints_on(struct NCR_ESP *
 static int  dma_irq_p(struct NCR_ESP *esp);
 static int  dma_ports_p(struct NCR_ESP *esp);
 static void dma_setup(struct NCR_ESP *esp, u32 addr, int count, int write);
-static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp);
-static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, struct scsi_cmnd * sp);
-static void dma_advance_sg(struct scsi_cmnd * sp);
+static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp);
+static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, Scsi_Cmnd * sp);
+static void dma_advance_sg(Scsi_Cmnd * sp);
 
 static void pmaz_dma_drain(struct NCR_ESP *esp);
 static void pmaz_dma_init_read(struct NCR_ESP *esp, u32 vaddress, int length);
@@ -73,7 +73,7 @@ static void pmaz_dma_init_write(struct N
 static void pmaz_dma_ints_off(struct NCR_ESP *esp);
 static void pmaz_dma_ints_on(struct NCR_ESP *esp);
 static void pmaz_dma_setup(struct NCR_ESP *esp, u32 addr, int count, int write);
-static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp);
+static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp);
 
 #define TC_ESP_RAM_SIZE 0x20000
 #define ESP_TGT_DMA_SIZE ((TC_ESP_RAM_SIZE/7) & ~(sizeof(int)-1))
@@ -97,7 +97,7 @@ static irqreturn_t scsi_dma_merr_int(int
 static irqreturn_t scsi_dma_err_int(int, void *, struct pt_regs *);
 static irqreturn_t scsi_dma_int(int, void *, struct pt_regs *);
 
-static int dec_esp_detect(struct scsi_host_template * tpnt);
+int dec_esp_detect(Scsi_Host_Template * tpnt);
 
 static int dec_esp_release(struct Scsi_Host *shost)
 {
@@ -109,9 +109,9 @@ static int dec_esp_release(struct Scsi_H
 	return 0;
 }
 
-static struct scsi_host_template driver_template = {
+static Scsi_Host_Template driver_template = {
 	.proc_name		= "dec_esp",
-	.proc_info		= esp_proc_info,
+	.proc_info		= &esp_proc_info,
 	.name			= "NCR53C94",
 	.detect			= dec_esp_detect,
 	.slave_alloc		= esp_slave_alloc,
@@ -132,7 +132,7 @@ static struct scsi_host_template driver_
 #include "scsi_module.c"
 
 /***************************************************************** Detection */
-static int dec_esp_detect(Scsi_Host_Template * tpnt)
+int dec_esp_detect(Scsi_Host_Template * tpnt)
 {
 	struct NCR_ESP *esp;
 	struct ConfigDev *esp_dev;
@@ -376,7 +376,7 @@ static void dma_drain(struct NCR_ESP *es
 	}
 }
 
-static int dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static int dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	return sp->SCp.this_residual;
 }
@@ -488,12 +488,12 @@ static void dma_setup(struct NCR_ESP *es
 		dma_init_write(esp, addr, count);
 }
 
-static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static void dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	sp->SCp.ptr = (char *)virt_to_phys(sp->request_buffer);
 }
 
-static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static void dma_mmu_get_scsi_sgl(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	int sz = sp->SCp.buffers_residual;
 	struct scatterlist *sg = sp->SCp.buffer;
@@ -505,7 +505,7 @@ static void dma_mmu_get_scsi_sgl(struct 
 	sp->SCp.ptr = (char *)(sp->SCp.buffer->dma_address);
 }
 
-static void dma_advance_sg(struct scsi_cmnd * sp)
+static void dma_advance_sg(Scsi_Cmnd * sp)
 {
 	sp->SCp.ptr = (char *)(sp->SCp.buffer->dma_address);
 }
@@ -567,7 +567,7 @@ static void pmaz_dma_setup(struct NCR_ES
 		pmaz_dma_init_write(esp, addr, count);
 }
 
-static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, struct scsi_cmnd * sp)
+static void pmaz_dma_mmu_get_scsi_one(struct NCR_ESP *esp, Scsi_Cmnd * sp)
 {
 	sp->SCp.ptr = (char *)virt_to_phys(sp->request_buffer);
 }
diff -urpNX dontdiff linux-2.6.11.6/drivers/scsi/jazz_esp.c linux_HEAD/drivers/scsi/jazz_esp.c
--- linux-2.6.11.6/drivers/scsi/jazz_esp.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/drivers/scsi/jazz_esp.c	2004-10-27 02:14:48.000000000 +0200
@@ -28,7 +28,7 @@
 #include <asm/pgtable.h>
 
 static int  dma_bytes_sent(struct NCR_ESP *esp, int fifo_count);
-static int  dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd *sp);
+static int  dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp);
 static void dma_dump_state(struct NCR_ESP *esp);
 static void dma_init_read(struct NCR_ESP *esp, __u32 vaddress, int length);
 static void dma_init_write(struct NCR_ESP *esp, __u32 vaddress, int length);
@@ -37,11 +37,11 @@ static void dma_ints_on(struct NCR_ESP *
 static int  dma_irq_p(struct NCR_ESP *esp);
 static int  dma_ports_p(struct NCR_ESP *esp);
 static void dma_setup(struct NCR_ESP *esp, __u32 addr, int count, int write);
-static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp);
-static void dma_advance_sg (struct scsi_cmnd *sp);
+static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_advance_sg (Scsi_Cmnd *sp);
 static void dma_led_off(struct NCR_ESP *);
 static void dma_led_on(struct NCR_ESP *);
 
@@ -87,7 +87,7 @@ static Scsi_Host_Template driver_templat
 #include "scsi_module.c"
 
 /***************************************************************** Detection */
-static int jazz_esp_detect(struct scsi_host_template *tpnt)
+int jazz_esp_detect(Scsi_Host_Template *tpnt)
 {
     struct NCR_ESP *esp;
     struct ConfigDev *esp_dev;
@@ -180,7 +180,7 @@ static int dma_bytes_sent(struct NCR_ESP
     return fifo_count;
 }
 
-static int dma_can_transfer(struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static int dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     /*
      * maximum DMA size is 1MB
@@ -253,13 +253,13 @@ static void dma_setup(struct NCR_ESP *es
     }
 }
 
-static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     sp->SCp.have_data_in = vdma_alloc(CPHYSADDR(sp->SCp.buffer), sp->SCp.this_residual);
     sp->SCp.ptr = (char *)((unsigned long)sp->SCp.have_data_in);
 }
 
-static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     int sz = sp->SCp.buffers_residual;
     struct scatterlist *sg = (struct scatterlist *) sp->SCp.buffer;
@@ -271,12 +271,12 @@ static void dma_mmu_get_scsi_sgl (struct
     sp->SCp.ptr=(char *)(sp->SCp.buffer->dma_address);
 }    
 
-static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     vdma_free(sp->SCp.have_data_in);
 }
 
-static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, struct scsi_cmnd *sp)
+static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     int sz = sp->use_sg - 1;
     struct scatterlist *sg = (struct scatterlist *)sp->buffer;
@@ -287,7 +287,7 @@ static void dma_mmu_release_scsi_sgl (st
     }
 }
 
-static void dma_advance_sg (struct scsi_cmnd *sp)
+static void dma_advance_sg (Scsi_Cmnd *sp)
 {
     sp->SCp.ptr = (char *)(sp->SCp.buffer->dma_address);
 }
@@ -308,22 +308,3 @@ static void dma_led_on(struct NCR_ESP *e
 #endif    
 }
 
-static struct scsi_host_template driver_template = {
-	.proc_name		= "jazz_esp",
-	.proc_info		= esp_proc_info,
-	.name			= "ESP 100/100a/200",
-	.detect			= jazz_esp_detect,
-	.slave_alloc		= esp_slave_alloc,
-	.slave_destroy		= esp_slave_destroy,
-	.release		= jazz_esp_release,
-	.info			= esp_info,
-	.queuecommand		= esp_queue,
-	.eh_abort_handler	= esp_abort,
-	.eh_bus_reset_handler	= esp_reset,
-	.can_queue		= 7,
-	.this_id		= 7,
-	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
-	.use_clustering		= DISABLE_CLUSTERING,
-};
-#include "scsi_module.c"
diff -urpNX dontdiff linux-2.6.11.6/drivers/scsi/sym53c8xx_defs.h linux_HEAD/drivers/scsi/sym53c8xx_defs.h
--- linux-2.6.11.6/drivers/scsi/sym53c8xx_defs.h	2005-03-26 04:28:47.000000000 +0100
+++ linux_HEAD/drivers/scsi/sym53c8xx_defs.h	2005-02-17 21:50:07.000000000 +0100
@@ -317,6 +317,16 @@
 #define	readl_raw(a)	__raw_readl((unsigned long)(a))
 #define	writew_raw	__raw_writew
 #define	writel_raw(v,a)	__raw_writel(v,(unsigned long)(a))
+#else /* Other big-endian */
+#elif defined(__mips__)
+#define readw_l2b	readw
+#define readl_l2b	readl
+#define writew_b2l	writew
+#define writel_b2l	writel
+#define inw_l2b 	inw
+#define inl_l2b 	inl
+#define outw_b2l	outw
+#define outl_b2l	outl
 #else	/* Other big-endian */
 #define	readw_l2b	readw
 #define	readl_l2b	readl
diff -urpNX dontdiff linux-2.6.11.6/drivers/serial/au1x00_uart.c linux_HEAD/drivers/serial/au1x00_uart.c
--- linux-2.6.11.6/drivers/serial/au1x00_uart.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/drivers/serial/au1x00_uart.c	2004-11-19 01:14:46.000000000 +0100
@@ -67,30 +67,7 @@
 #define is_real_interrupt(irq)	((irq) != 0)
 
 static struct old_serial_port old_serial_port[] = {
-	{	.baud_base = 0,
-		.iomem_base = (u8 *)UART0_ADDR,
-		.irq = AU1000_UART0_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2,
-	}, {
-		.baud_base = 0,
-		.iomem_base = (u8 *)UART1_ADDR,
-		.irq = AU1000_UART1_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2
-	}, {
-		.baud_base = 0,
-		.iomem_base = (u8 *)UART2_ADDR,
-		.irq = AU1000_UART2_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2
-	}, {
-		.baud_base = 0,
-		.iomem_base = (u8 *)UART3_ADDR,
-		.irq = AU1000_UART3_INT,
-		.flags = STD_COM_FLAGS,
-		.iomem_reg_shift = 2
-	}
+	SERIAL_PORT_DFNS
 };
 
 #define UART_NR	ARRAY_SIZE(old_serial_port)
@@ -801,7 +778,6 @@ serial8250_set_termios(struct uart_port 
 	 */
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16); 
 	quot = serial8250_get_divisor(port, baud);
-	quot = 0x35; /* FIXME */
 
 	/*
 	 * Work around a bug in the Oxford Semiconductor 952 rev B
@@ -1069,7 +1045,7 @@ static void __init serial8250_isa_init_p
 	     i++, up++) {
 		up->port.iobase   = old_serial_port[i].port;
 		up->port.irq      = old_serial_port[i].irq;
-		up->port.uartclk  = get_au1x00_uart_baud_base();
+		up->port.uartclk  = get_au1x00_uart_baud_base() * 16;
 		up->port.flags    = old_serial_port[i].flags;
 		up->port.hub6     = old_serial_port[i].hub6;
 		up->port.membase  = old_serial_port[i].iomem_base;
diff -urpNX dontdiff linux-2.6.11.6/drivers/serial/serial_txx9.c linux_HEAD/drivers/serial/serial_txx9.c
--- linux-2.6.11.6/drivers/serial/serial_txx9.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/drivers/serial/serial_txx9.c	2005-03-04 18:24:33.000000000 +0100
@@ -31,6 +31,7 @@
  *	1.01	Set fifosize to make tx_empry called properly.
  *		Use standard uart_get_divisor.
  *	1.02	Cleanup. (import 8250.c changes)
+ *	1.03	Fix low-latency mode. (import 8250.c changes)
  */
 #include <linux/config.h>
 
@@ -54,7 +55,7 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-static char *serial_version = "1.02";
+static char *serial_version = "1.03";
 static char *serial_name = "TX39/49 Serial driver";
 
 #define PASS_LIMIT	256
@@ -304,8 +305,11 @@ receive_chars(struct uart_txx9_port *up,
 		/* The following is not allowed by the tty layer and
 		   unsafe. It should be fixed ASAP */
 		if (unlikely(tty->flip.count >= TTY_FLIPBUF_SIZE)) {
-			if(tty->low_latency)
+			if (tty->low_latency) {
+				spin_unlock(&up->port.lock);
 				tty_flip_buffer_push(tty);
+				spin_lock(&up->port.lock);
+			}
 			/* If this failed then we will throw away the
 			   bytes but must do so to clear interrupts */
 		}
@@ -365,7 +369,9 @@ receive_chars(struct uart_txx9_port *up,
 	ignore_char:
 		disr = sio_in(up, TXX9_SIDISR);
 	} while (!(disr & TXX9_SIDISR_UVALID) && (max_count-- > 0));
+	spin_unlock(&up->port.lock);
 	tty_flip_buffer_push(tty);
+	spin_lock(&up->port.lock);
 	*status = disr;
 }
 
diff -urpNX dontdiff linux-2.6.11.6/drivers/usb/gadget/net2280.c linux_HEAD/drivers/usb/gadget/net2280.c
--- linux-2.6.11.6/drivers/usb/gadget/net2280.c	2005-04-03 00:12:27.000000000 +0200
+++ linux_HEAD/drivers/usb/gadget/net2280.c	2005-03-21 20:04:39.000000000 +0100
@@ -448,7 +448,8 @@ net2280_free_request (struct usb_ep *_ep
 #elif	defined(CONFIG_PPC) && !defined(CONFIG_NOT_COHERENT_CACHE)
 #define USE_KMALLOC
 
-#elif	defined(CONFIG_MIPS) && !defined(CONFIG_NONCOHERENT_IO)
+#elif	defined(CONFIG_MIPS) && \
+	(defined(CONFIG_DMA_COHERENT) || defined(CONFIG_DMA_IP27))
 #define USE_KMALLOC
 
 /* FIXME there are other cases, including an x86-64 one ...  */
diff -urpNX dontdiff linux-2.6.11.6/drivers/usb/host/ohci-hcd.c linux_HEAD/drivers/usb/host/ohci-hcd.c
--- linux-2.6.11.6/drivers/usb/host/ohci-hcd.c	2005-04-03 00:12:27.000000000 +0200
+++ linux_HEAD/drivers/usb/host/ohci-hcd.c	2005-03-21 20:04:42.000000000 +0100
@@ -901,10 +901,6 @@ MODULE_LICENSE ("GPL");
 #include "ohci-lh7a404.c"
 #endif
 
-#ifdef CONFIG_PXA27x
-#include "ohci-pxa27x.c"
-#endif
-
 #ifdef CONFIG_SOC_AU1X00
 #include "ohci-au1xxx.c"
 #endif
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/Kconfig linux_HEAD/drivers/video/Kconfig
--- linux-2.6.11.6/drivers/video/Kconfig	2005-04-03 00:12:31.000000000 +0200
+++ linux_HEAD/drivers/video/Kconfig	2005-03-21 20:04:44.000000000 +0100
@@ -1331,8 +1331,8 @@ config FB_PMAGB_B
 	select FB_SOFT_CURSOR
 	help
 	  Support for the PMAGB-B TURBOchannel framebuffer card used mainly
-	  in the MIPS-based DECstation series. The card is currently only
-	  supported in 1280x1024x8 mode.
+	  in the MIPS-based DECstation series. The card is currently only 
+	  supported in 1280x1024x8 mode.  
 
 config FB_MAXINE
 	bool "Maxine (Personal DECstation) onboard framebuffer support"
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/au1100fb.c linux_HEAD/drivers/video/au1100fb.c
--- linux-2.6.11.6/drivers/video/au1100fb.c	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/drivers/video/au1100fb.c	2005-02-28 16:56:53.000000000 +0100
@@ -57,7 +57,7 @@
 #include <video/fbcon-cfb8.h>
 #include <video/fbcon-cfb16.h>
 
-/*
+/* 
  * Sanity check. If this is a new Au1100 based board, search for
  * the PB1100 ifdefs to make sure you modify the code accordingly.
  */
@@ -90,7 +90,7 @@ struct au1100fb_info {
 
 struct au1100fb_par {
         struct fb_var_screeninfo var;
-
+	
 	int line_length;  // in bytes
 	int cmap_len;     // color-map length
 };
@@ -102,7 +102,7 @@ static struct display disp;
 
 int au1100fb_init(void);
 void au1100fb_setup(char *options, int *ints);
-static int au1100fb_mmap(struct fb_info *fb, struct file *file,
+static int au1100fb_mmap(struct fb_info *fb, struct file *file, 
 		struct vm_area_struct *vma);
 static int au1100_blank(int blank_mode, struct fb_info_gen *info);
 static int au1100fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
@@ -111,21 +111,21 @@ static int au1100fb_ioctl(struct inode *
 void au1100_nocursor(struct display *p, int mode, int xx, int yy){};
 
 static struct fb_ops au1100fb_ops = {
-	owner:		THIS_MODULE,
-	fb_get_fix:	fbgen_get_fix,
-	fb_get_var:	fbgen_get_var,
-	fb_set_var:	fbgen_set_var,
-	fb_get_cmap:	fbgen_get_cmap,
-	fb_set_cmap:	fbgen_set_cmap,
-	fb_pan_display: fbgen_pan_display,
-        fb_ioctl:       au1100fb_ioctl,
-	fb_mmap:        au1100fb_mmap,
+	.owner		= THIS_MODULE,
+	.fb_get_fix	= fbgen_get_fix,
+	.fb_get_var	= fbgen_get_var,
+	.fb_set_var	= fbgen_set_var,
+	.fb_get_cmap	= fbgen_get_cmap,
+	.fb_set_cmap	= fbgen_set_cmap,
+	.fb_pan_display = fbgen_pan_display,
+        .fb_ioctl       = au1100fb_ioctl,
+	.fb_mmap        = au1100fb_mmap,
 };
 
 static void au1100_detect(void)
 {
 	/*
-	 *  This function should detect the current video mode settings
+	 *  This function should detect the current video mode settings 
 	 *  and store it as the default video mode
 	 */
 
@@ -136,7 +136,7 @@ static void au1100_detect(void)
 
 }
 
-static int au1100_encode_fix(struct fb_fix_screeninfo *fix,
+static int au1100_encode_fix(struct fb_fix_screeninfo *fix, 
 		const void *_par, struct fb_info_gen *_info)
 {
         struct au1100fb_info *info = (struct au1100fb_info *) _info;
@@ -189,7 +189,7 @@ static void set_color_bitfields(struct f
 	var->transp.msb_right = 0;
 }
 
-static int au1100_decode_var(const struct fb_var_screeninfo *var,
+static int au1100_decode_var(const struct fb_var_screeninfo *var, 
 		void *_par, struct fb_info_gen *_info)
 {
 
@@ -211,7 +211,7 @@ static int au1100_decode_var(const struc
 
 	memset(par, 0, sizeof(struct au1100fb_par));
 	par->var = *var;
-
+	
 	/* FIXME */
 	switch (var->bits_per_pixel) {
 		case 8:
@@ -231,7 +231,7 @@ static int au1100_decode_var(const struc
 	return 0;
 }
 
-static int au1100_encode_var(struct fb_var_screeninfo *var,
+static int au1100_encode_var(struct fb_var_screeninfo *var, 
 		const void *par, struct fb_info_gen *_info)
 {
 
@@ -239,7 +239,7 @@ static int au1100_encode_var(struct fb_v
 	return 0;
 }
 
-static void
+static void 
 au1100_get_par(void *_par, struct fb_info_gen *_info)
 {
 	*(struct au1100fb_par *)_par = current_par;
@@ -259,10 +259,10 @@ static int au1100_getcolreg(unsigned reg
 
 	if (regno > 255)
 		return 1;
-
-	*red    = i->palette[regno].red;
-	*green  = i->palette[regno].green;
-	*blue   = i->palette[regno].blue;
+   
+	*red    = i->palette[regno].red; 
+	*green  = i->palette[regno].green; 
+	*blue   = i->palette[regno].blue; 
 	*transp = 0;
 
 	return 0;
@@ -281,14 +281,14 @@ static int au1100_setcolreg(unsigned reg
 	i->palette[regno].red    = red;
 	i->palette[regno].green  = green;
 	i->palette[regno].blue   = blue;
-
+   
 	switch(p_lcd->bpp) {
 #ifdef FBCON_HAS_CFB8
 	case 8:
 		red >>= 10;
 		green >>= 10;
 		blue >>= 10;
-		p_lcd_reg->lcd_pallettebase[regno] = (blue&0x1f) |
+		p_lcd_reg->lcd_pallettebase[regno] = (blue&0x1f) | 
 			((green&0x3f)<<5) | ((red&0x1f)<<11);
 		break;
 #endif
@@ -317,7 +317,7 @@ static int  au1100_blank(int blank_mode,
 		//printk("turn on panel\n");
 #ifdef CONFIG_MIPS_PB1100
 		p_lcd_reg->lcd_control |= LCD_CONTROL_GO;
-		au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight,
+		au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight, 
 			PB1100_G_CONTROL);
 #endif
 #ifdef CONFIG_MIPS_HYDROGEN3
@@ -335,13 +335,13 @@ static int  au1100_blank(int blank_mode,
 		/* turn off panel */
 		//printk("turn off panel\n");
 #ifdef CONFIG_MIPS_PB1100
-		au_writew(au_readw(PB1100_G_CONTROL) & ~p_lcd->mode_backlight,
+		au_writew(au_readw(PB1100_G_CONTROL) & ~p_lcd->mode_backlight, 
 			PB1100_G_CONTROL);
 		p_lcd_reg->lcd_control &= ~LCD_CONTROL_GO;
 #endif
 		au_sync();
 		break;
-	default:
+	default: 
 		break;
 
 	}
@@ -388,7 +388,7 @@ au1100fb_mmap(struct fb_info *_fb,
 	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
 		return -EINVAL;
 	}
-
+    
 	start = fb_info.fb_phys & PAGE_MASK;
 	len = PAGE_ALIGN((start & ~PAGE_MASK) + fb_info.fb_size);
 
@@ -407,7 +407,7 @@ au1100fb_mmap(struct fb_info *_fb,
 
 	/* This is an IO map - tell maydump to skip this VMA */
 	vma->vm_flags |= VM_IO;
-
+    
 	if (io_remap_page_range(vma, vma->vm_start, off,
 				vma->vm_end - vma->vm_start,
 				vma->vm_page_prot)) {
@@ -432,21 +432,21 @@ static int au1100fb_ioctl(struct inode *
 }
 
 static struct fbgen_hwswitch au1100_switch = {
-	au1100_detect,
-	au1100_encode_fix,
-	au1100_decode_var,
-	au1100_encode_var,
-	au1100_get_par,
-	au1100_set_par,
-	au1100_getcolreg,
-	au1100_setcolreg,
-	au1100_pan_display,
-	au1100_blank,
+	au1100_detect, 
+	au1100_encode_fix, 
+	au1100_decode_var, 
+	au1100_encode_var, 
+	au1100_get_par, 
+	au1100_set_par, 
+	au1100_getcolreg, 
+	au1100_setcolreg, 
+	au1100_pan_display, 
+	au1100_blank, 
 	au1100_set_disp
 };
 
 
-int au1100_setmode(void)
+int au1100_setmode(void) 
 {
 	int words;
 
@@ -482,7 +482,7 @@ int au1100_setmode(void)
 
 	/* turn on panel */
 #ifdef CONFIG_MIPS_PB1100
-	au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight,
+	au_writew(au_readw(PB1100_G_CONTROL) | p_lcd->mode_backlight, 
 			PB1100_G_CONTROL);
 #endif
 #ifdef CONFIG_MIPS_HYDROGEN3
@@ -512,16 +512,16 @@ int __init au1100fb_init(void)
 	{
 		case LCD_CONTROL_SM_0:
 		case LCD_CONTROL_SM_180:
-		p_lcd->xres =
+		p_lcd->xres = 
 			(p_lcd->mode_horztiming & LCD_HORZTIMING_PPL) + 1;
-		p_lcd->yres =
+		p_lcd->yres = 
 			(p_lcd->mode_verttiming & LCD_VERTTIMING_LPP) + 1;
 			break;
 		case LCD_CONTROL_SM_90:
 		case LCD_CONTROL_SM_270:
-		p_lcd->yres =
+		p_lcd->yres = 
 			(p_lcd->mode_horztiming & LCD_HORZTIMING_PPL) + 1;
-		p_lcd->xres =
+		p_lcd->xres = 
 			(p_lcd->mode_verttiming & LCD_VERTTIMING_LPP) + 1;
 			break;
 	}
@@ -529,16 +529,16 @@ int __init au1100fb_init(void)
 	/*
 	 * Panel dimensions x bpp must be divisible by 32
 	 */
-	if (((p_lcd->yres * p_lcd->bpp) % 32) != 0)
+	if (((p_lcd->yres * p_lcd->bpp) % 32) != 0) 
 		printk("VERT %% 32\n");
-	if (((p_lcd->xres * p_lcd->bpp) % 32) != 0)
+	if (((p_lcd->xres * p_lcd->bpp) % 32) != 0) 
 		printk("HORZ %% 32\n");
 
 	/*
 	 * Allocate LCD framebuffer from system memory
 	 */
 	fb_info.fb_size = (p_lcd->xres * p_lcd->yres * p_lcd->bpp) / 8;
-
+	
 	current_par.var.xres = p_lcd->xres;
 	current_par.var.xres_virtual = p_lcd->xres;
 	current_par.var.yres = p_lcd->yres;
@@ -548,7 +548,7 @@ int __init au1100fb_init(void)
 	/* FIX!!! only works for 8/16 bpp */
 	current_par.line_length = p_lcd->xres * p_lcd->bpp / 8; /* in bytes */
 	fb_info.fb_virt_start = (unsigned long )
-		__get_free_pages(GFP_ATOMIC | GFP_DMA,
+		__get_free_pages(GFP_ATOMIC | GFP_DMA, 
 				get_order(fb_info.fb_size + 0x1000));
 	if (!fb_info.fb_virt_start) {
 		printk("Unable to allocate fb memory\n");
@@ -561,7 +561,7 @@ int __init au1100fb_init(void)
 	 * since we'll be remapping normal memory.
 	 */
 	for (page = fb_info.fb_virt_start;
-	     page < PAGE_ALIGN(fb_info.fb_virt_start + fb_info.fb_size);
+	     page < PAGE_ALIGN(fb_info.fb_virt_start + fb_info.fb_size); 
 	     page += PAGE_SIZE) {
 		SetPageReserved(virt_to_page(page));
 	}
@@ -570,7 +570,7 @@ int __init au1100fb_init(void)
 
 	/* set freqctrl now to allow more time to stabilize */
 	/* zero-out out LCD bits */
-	sys_clksrc = au_readl(SYS_CLKSRC) & ~0x000003e0;
+	sys_clksrc = au_readl(SYS_CLKSRC) & ~0x000003e0; 
 	sys_clksrc |= p_lcd->mode_toyclksrc;
 	au_writel(sys_clksrc, SYS_CLKSRC);
 
@@ -598,8 +598,8 @@ int __init au1100fb_init(void)
 	fbgen_install_cmap(0, &fb_info.gen);
 	if (register_framebuffer(&fb_info.gen.info) < 0)
 		return -EINVAL;
-	printk(KERN_INFO "fb%d: %s frame buffer device\n",
-			GET_FB_IDX(fb_info.gen.info.node),
+	printk(KERN_INFO "fb%d: %s frame buffer device\n", 
+			GET_FB_IDX(fb_info.gen.info.node), 
 			fb_info.gen.info.modename);
 
 	return 0;
@@ -618,7 +618,7 @@ void au1100fb_setup(char *options, int *
 	int i;
 	int num_panels = sizeof(panels)/sizeof(struct known_lcd_panels);
 
-
+    
 	if (!options || !*options)
 		return;
 
@@ -640,7 +640,7 @@ void au1100fb_setup(char *options, int *
 #endif
 			/* Get the panel name, everything else if fixed */
 			for (i=0; i<num_panels; i++) {
-				if (!strncmp(this_opt+6, panels[i].panel_name,
+				if (!strncmp(this_opt+6, panels[i].panel_name, 
 							strlen(this_opt))) {
 					my_lcd_index = i;
 					break;
@@ -651,7 +651,7 @@ void au1100fb_setup(char *options, int *
 			printk("nohwcursor\n");
 			fb_info.nohwcursor = 1;
 		}
-	}
+	} 
 
 	printk("au1100fb: Panel %d %s\n", my_lcd_index,
 		panels[my_lcd_index].panel_name);
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/au1100fb.h linux_HEAD/drivers/video/au1100fb.h
--- linux-2.6.11.6/drivers/video/au1100fb.h	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/drivers/video/au1100fb.h	2002-07-14 23:33:34.000000000 +0200
@@ -195,7 +195,7 @@ struct known_lcd_panels panels[] =
 		320, /* xres */
 		240, /* yres */
 		16,  /* bpp  */
-
+		
 		"Sharp_320x240_16",
 		/* mode_control */
 		( LCD_CONTROL_SBPPF_565
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/bt431.h linux_HEAD/drivers/video/bt431.h
--- linux-2.6.11.6/drivers/video/bt431.h	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/drivers/video/bt431.h	2003-11-16 09:21:14.000000000 +0100
@@ -176,7 +176,7 @@ static inline void bt431_position_cursor
 {
 	/*
 	 * Magic from the MACH sources.
-	 *
+	 * 
 	 * Cx = x + D + H - P
 	 *  P = 37 if 1:1, 52 if 4:1, 57 if 5:1
 	 *  D = pixel skew between outdata and external data
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/epson1356fb.c linux_HEAD/drivers/video/epson1356fb.c
--- linux-2.6.11.6/drivers/video/epson1356fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/video/epson1356fb.c	2005-02-28 16:56:54.000000000 +0100
@@ -0,0 +1,3117 @@
+/*
+ *      epson1356fb.c  --  Epson SED1356 Framebuffer Driver
+ *
+ * Copyright 2001, 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * 
+ * TODO:
+ *
+ *  Revision history
+ *    03.12.2001  0.1   Initial release
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/selection.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/nvram.h>
+#include <linux/kd.h>
+#include <linux/vt_kern.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/timer.h>
+#include <linux/pagemap.h>
+
+#include <asm/pgalloc.h>
+#include <asm/uaccess.h>
+#include <asm/tlb.h>
+
+#ifdef CONFIG_MTRR
+#include <asm/mtrr.h>
+#endif
+
+#include <video/fbcon.h>
+#include <video/fbcon-cfb8.h>
+#include <video/fbcon-cfb16.h>
+#include <video/fbcon-cfb24.h>
+#include <video/fbcon-cfb32.h>
+
+#include <linux/spinlock.h>
+
+#include <linux/e1356fb.h>
+
+#ifdef CONFIG_MIPS_AU1000
+#include <asm/au1000.h>
+#endif
+
+#define E1356FB_DEBUG 1
+#undef E1356FB_VERBOSE_DEBUG
+#undef SHADOW_FRAME_BUFFER
+#include "epson1356fb.h"
+
+static char *options;
+MODULE_PARM(options, "s");
+
+/*
+ *  Frame buffer device API
+ */
+static int e1356fb_open(struct fb_info *fb, int user);
+static int e1356fb_release(struct fb_info *fb, int user);
+static int e1356fb_get_fix(struct fb_fix_screeninfo* fix, 
+			   int con,
+			   struct fb_info* fb);
+static int e1356fb_get_var(struct fb_var_screeninfo* var, 
+			   int con,
+			   struct fb_info* fb);
+static int e1356fb_set_var(struct fb_var_screeninfo* var,
+			   int con,
+			   struct fb_info* fb);
+static int e1356fb_pan_display(struct fb_var_screeninfo* var, 
+			       int con,
+			       struct fb_info* fb);
+static int e1356fb_get_cmap(struct fb_cmap *cmap, 
+			    int kspc, 
+			    int con,
+			    struct fb_info* info);
+static int e1356fb_set_cmap(struct fb_cmap* cmap, 
+			    int kspc, 
+			    int con,
+			    struct fb_info* info);
+static int e1356fb_ioctl(struct inode* inode, 
+			 struct file* file, 
+			 u_int cmd,
+			 u_long arg, 
+			 int con, 
+			 struct fb_info* info);
+static int e1356fb_mmap(struct fb_info *info,
+			struct file *file,
+			struct vm_area_struct *vma);
+
+/*
+ *  Interface to the low level console driver
+ */
+static int  e1356fb_switch_con(int con, 
+			       struct fb_info* fb);
+static int  e1356fb_updatevar(int con, 
+			      struct fb_info* fb);
+static void e1356fb_blank(int blank, 
+			  struct fb_info* fb);
+
+/*
+ *  Internal routines
+ */
+static void e1356fb_set_par(const struct e1356fb_par* par,
+			    struct fb_info_e1356* 
+			    info);
+static int  e1356fb_var_to_par(const struct fb_var_screeninfo *var,
+			       struct e1356fb_par* par,
+			       const struct fb_info_e1356* info);
+static int  e1356fb_par_to_var(struct fb_var_screeninfo* var,
+			       struct e1356fb_par* par,
+			       const struct fb_info_e1356* info);
+static int  e1356fb_encode_fix(struct fb_fix_screeninfo* fix,
+			       const struct e1356fb_par* par,
+			       const struct fb_info_e1356* info);
+static void e1356fb_set_dispsw(struct display* disp, 
+			       struct fb_info_e1356* info,
+			       int bpp, 
+			       int accel);
+static int  e1356fb_getcolreg(u_int regno,
+			      u_int* red, 
+			      u_int* green, 
+			      u_int* blue,
+			      u_int* transp, 
+			      struct fb_info* fb);
+static int  e1356fb_setcolreg(u_int regno, 
+			      u_int red, 
+			      u_int green, 
+			      u_int blue,
+			      u_int transp, 
+			      struct fb_info* fb);
+static void  e1356fb_install_cmap(struct display *d, 
+				  struct fb_info *info);
+
+static void e1356fb_hwcursor_init(struct fb_info_e1356* info);
+static void e1356fb_createcursorshape(struct display* p);
+static void e1356fb_createcursor(struct display * p);  
+
+/*
+ * do_xxx: Hardware-specific functions
+ */
+static void  do_pan_var(struct fb_var_screeninfo* var,
+			struct fb_info_e1356* i);
+static void  do_flashcursor(unsigned long ptr);
+static void  doBlt_Move(const struct e1356fb_par* par,
+			struct fb_info_e1356* i,
+			blt_info_t* blt);
+static void  doBlt_SolidFill(const struct e1356fb_par* par,
+			     struct fb_info_e1356* i,
+			     blt_info_t* blt);
+
+/*
+ *  Interface used by the world
+ */
+int e1356fb_init(void);
+void e1356fb_setup(char *options, int *ints);
+
+static int currcon = 0;
+
+static struct fb_ops e1356fb_ops = {
+	.owner	= THIS_MODULE,
+	.fb_open        = e1356fb_open,
+	.fb_release     = e1356fb_release,
+	.fb_get_fix	= e1356fb_get_fix,
+	.fb_get_var	= e1356fb_get_var,
+	.fb_set_var	= e1356fb_set_var,
+	.fb_get_cmap    = e1356fb_get_cmap,
+	.fb_set_cmap    = e1356fb_set_cmap,
+	.fb_pan_display = e1356fb_pan_display,
+	.fb_mmap        = e1356fb_mmap,
+};
+
+#define PCI_VENDOR_ID_EPSON         0x10f4
+#define PCI_DEVICE_ID_EPSON_SDU1356 0x1300
+
+
+static struct fb_info_e1356 fb_info;
+static struct e1356fb_fix boot_fix; // boot options
+static struct e1356fb_par boot_par; // boot options
+
+static int e1356_remap_page_range(unsigned long from, phys_t phys_addr, unsigned long size, pgprot_t prot);
+
+
+/* ------------------------------------------------------------------------- 
+ *                      Hardware-specific funcions
+ * ------------------------------------------------------------------------- */
+
+/*
+ * The SED1356 has only a 16-bit wide data bus, so some embedded
+ * implementations with 32-bit CPU's (Alchemy Pb1000) may not
+ * correctly emulate a 32-bit write to the framebuffer by splitting
+ * the write into two seperate 16-bit writes. So it is safest to
+ * only do byte or half-word writes to the fb. This routine assumes
+ * fbaddr is atleast aligned on a half-word boundary.
+ */
+static inline void
+fbfill(u16* fbaddr, u8 val, int size)
+{
+	u16 valw = (u16)val | ((u16)val << 8);
+	for ( ; size >= 2; size -= 2)
+		writew(valw, fbaddr++);
+	if (size)
+		writeb(val, (u8*)fbaddr);
+}
+
+static inline int
+e1356_wait_bitclr(u8* reg, u8 bit, int timeout)
+{
+	while (readb(reg) & bit) {
+		udelay(10);
+		if (!--timeout)
+			break;
+	}
+	return timeout;
+}
+
+static inline int
+e1356_wait_bitset(u8* reg, u8 bit, int timeout)
+{
+	while (!(readb(reg) & bit)) {
+		udelay(10);
+		if (!--timeout)
+			break;
+	}
+	return timeout;
+}
+
+
+static struct fb_videomode panel_modedb[] = {
+	{
+		/* 320x240 @ 109 Hz, 33.3 kHz hsync */
+		NULL, 109, 320, 240, KHZ2PICOS(MAX_PIXCLOCK/3),
+		16, 16, 32, 24, 48, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 640x480 @ 84 Hz, 48.1 kHz hsync */
+		NULL, 84, 640, 480, KHZ2PICOS(MAX_PIXCLOCK/1),
+		96, 32, 32, 48, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 800x600 @ 76 Hz, 46.3 kHz hsync */
+		NULL, 76, 800, 600, KHZ2PICOS(MAX_PIXCLOCK/1),
+		32, 10, 1, 1, 22, 1,
+		0, FB_VMODE_NONINTERLACED
+	}
+};
+static struct fb_videomode crt_modedb[] = {
+	{
+		/* 320x240 @ 84 Hz, 31.25 kHz hsync */
+		NULL, 84, 320, 240, KHZ2PICOS(MAX_PIXCLOCK/2),
+		128, 128, 60, 60, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 320x240 @ 109 Hz, 33.3 kHz hsync */
+		NULL, 109, 320, 240, KHZ2PICOS(MAX_PIXCLOCK/3),
+		16, 16, 32, 24, 48, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 512x384 @ 77 Hz, 31.25 kHz hsync */
+		NULL, 77, 512, 384, KHZ2PICOS(MAX_PIXCLOCK/2),
+		48, 16, 16, 1, 64, 3,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 640x400 @ 88 Hz, 43.1 kHz hsync */
+		NULL, 88, 640, 400, KHZ2PICOS(MAX_PIXCLOCK/1),
+		128, 96, 32, 48, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 640x480 @ 84 Hz, 48.1 kHz hsync */
+		NULL, 84, 640, 480, KHZ2PICOS(MAX_PIXCLOCK/1),
+		96, 32, 32, 48, 64, 8,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 768x576 @ 62 Hz, 38.5 kHz hsync */
+		NULL, 62, 768, 576, KHZ2PICOS(MAX_PIXCLOCK/1),
+		144, 16, 28, 6, 112, 4,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		/* 800x600 @ 60 Hz, 37.9 kHz hsync */
+		NULL, 60, 800, 600, KHZ2PICOS(MAX_PIXCLOCK/1),
+		88, 40, 23, 1, 128, 4,
+		FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED
+	}
+};
+
+static struct fb_videomode ntsc_modedb[] = {
+	{
+		/* 640x480 @ 62 Hz, requires flicker filter */
+		//NULL, 62, 640, 480, 34921, 213, 57, 20, 2, 0, 0,
+		NULL, 62, 640, 480, KHZ2PICOS(2*NTSC_PIXCLOCK),
+		200, 70, 15, 7, 0, 0,
+		FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED
+	}
+};
+static struct fb_videomode pal_modedb[] = {
+	{
+		/* 640x480 @ 56 Hz, requires flicker filter */
+		NULL, 56, 640, 480, KHZ2PICOS(2*PAL_PIXCLOCK),
+		350, 145, 49, 23, 0, 0,
+		FB_SYNC_BROADCAST, FB_VMODE_NONINTERLACED
+	}
+};
+
+
+static inline void
+fb_videomode_to_var(struct fb_videomode* mode,
+		    struct fb_var_screeninfo*var)
+{
+	var->xres = mode->xres;
+	var->yres = mode->yres;
+	var->pixclock = mode->pixclock;
+	var->left_margin = mode->left_margin;
+	var->right_margin = mode->right_margin;
+	var->upper_margin = mode->upper_margin;
+	var->lower_margin = mode->lower_margin;
+	var->hsync_len = mode->hsync_len;
+	var->vsync_len = mode->vsync_len;
+	var->sync = mode->sync;
+	var->vmode = mode->vmode;
+}
+
+
+static int
+e1356fb_get_mode(const struct fb_info_e1356 *info,
+		 int xres,
+		 int yres,
+		 struct fb_videomode ** modedb,
+		 struct fb_videomode ** mode)
+{
+	struct fb_videomode * ret;
+	int i, dbsize;
+
+	if (IS_PANEL(info->fix.disp_type)) {
+		ret = panel_modedb;
+		dbsize = sizeof(panel_modedb)/sizeof(struct fb_videomode);
+	} else if (info->fix.disp_type == DISP_TYPE_CRT) {
+		ret = crt_modedb;
+		dbsize = sizeof(crt_modedb)/sizeof(struct fb_videomode);
+	} else if (info->fix.disp_type == DISP_TYPE_NTSC) {
+		ret = ntsc_modedb;
+		dbsize = sizeof(ntsc_modedb)/sizeof(struct fb_videomode);
+	} else {
+		ret = pal_modedb;
+		dbsize = sizeof(pal_modedb)/sizeof(struct fb_videomode);
+	}
+	
+	if (modedb)
+		*modedb = ret;
+	for (i=0; i<dbsize; i++) {
+		if (xres == ret[i].xres && yres == ret[i].yres) {
+			*mode = &ret[i];
+			break;
+		}
+	}
+	if (i == dbsize)
+		return -EINVAL;
+	return dbsize;
+}
+
+
+
+#ifdef E1356FB_VERBOSE_DEBUG
+static void
+dump_par(const struct e1356fb_par* par)
+{
+	DPRINTK("width:       %d\n", par->width);
+	DPRINTK("height:      %d\n", par->height);
+	DPRINTK("width_virt:  %d\n", par->width_virt);
+	DPRINTK("height_virt: %d\n", par->height_virt);
+	DPRINTK("bpp:         %d\n", par->bpp);
+	DPRINTK("pixclock:    %d\n", par->ipclk.pixclk);
+	DPRINTK("horiz_ndp:   %d\n", par->horiz_ndp);
+	DPRINTK("vert_ndp:    %d\n", par->vert_ndp);
+	DPRINTK("hsync_pol:   %d\n", par->hsync_pol);
+	DPRINTK("hsync_start: %d\n", par->hsync_start);
+	DPRINTK("hsync_width: %d\n", par->hsync_width);
+	DPRINTK("vsync_pol:   %d\n", par->vsync_pol);
+	DPRINTK("vsync_start: %d\n", par->vsync_start);
+	DPRINTK("vsync_width: %d\n", par->vsync_width);
+	DPRINTK("cmap_len:    %d\n", par->cmap_len);
+}
+
+static void
+dump_display_regs(reg_dispcfg_t* dispcfg, reg_dispmode_t* dispmode)
+{
+	DPRINTK("hdw:            0x%02x\n", readb(&dispcfg->hdw));
+	DPRINTK("hndp:           0x%02x\n", readb(&dispcfg->hndp));
+	DPRINTK("hsync_start:    0x%02x\n", readb(&dispcfg->hsync_start));
+	DPRINTK("hsync_pulse:    0x%02x\n", readb(&dispcfg->hsync_pulse));
+	DPRINTK("vdh0:           0x%02x\n", readb(&dispcfg->vdh0));
+	DPRINTK("vdh1:           0x%02x\n", readb(&dispcfg->vdh1));
+	DPRINTK("vndp:           0x%02x\n", readb(&dispcfg->vndp));
+	DPRINTK("vsync_start:    0x%02x\n", readb(&dispcfg->vsync_start));
+	DPRINTK("vsync_pulse:    0x%02x\n", readb(&dispcfg->vsync_pulse));
+	DPRINTK("tv_output_ctrl: 0x%02x\n\n", readb(&dispcfg->tv_output_ctrl));
+
+	DPRINTK("disp_mode:        0x%02x\n", readb(&dispmode->disp_mode));
+	DPRINTK("lcd_misc:         0x%02x\n", readb(&dispmode->lcd_misc));
+	DPRINTK("start_addr0:      0x%02x\n", readb(&dispmode->start_addr0));
+	DPRINTK("start_addr1:      0x%02x\n", readb(&dispmode->start_addr1));
+	DPRINTK("start_addr2:      0x%02x\n", readb(&dispmode->start_addr2));
+	DPRINTK("mem_addr_offset0: 0x%02x\n", readb(&dispmode->mem_addr_offset0));
+	DPRINTK("mem_addr_offset1: 0x%02x\n", readb(&dispmode->mem_addr_offset1));
+	DPRINTK("pixel_panning:    0x%02x\n", readb(&dispmode->pixel_panning));
+	DPRINTK("fifo_high_thresh: 0x%02x\n", readb(&dispmode->fifo_high_thresh));
+	DPRINTK("fifo_low_thresh:  0x%02x\n", readb(&dispmode->fifo_low_thresh));
+}
+
+static void
+dump_fb(u8* base, int len)
+{
+	int i;
+	DPRINTK("FB memory dump, start 0x%p, len %d", base, len);
+	for (i=0; i<len; i++) {
+		if (!(i%16))
+			printk("\n%p: %02x ", &base[i], readb(&base[i]));
+		else
+			printk("%02x ", readb(&base[i]));
+	}
+	printk("\n");
+}
+
+#endif // E1356FB_VERBOSE_DEBUG
+
+
+
+// Input:  ipclk->clksrc, ipclk->pixclk_d
+// Output: ipclk->pixclk, ipclk->error, and ipclk->divisor
+static int
+get_nearest_pixclk_div(pixclock_info_t* ipclk, int x2)
+{
+	int pixclk_d = ipclk->pixclk_d;
+	int clksrc = ipclk->clksrc;
+
+	if (x2) clksrc *= 2;
+
+	if (clksrc < (3*pixclk_d+1)/2)
+		ipclk->divisor = 1;
+	else if (clksrc < (5*pixclk_d+1)/2)
+		ipclk->divisor = 2;
+	else if (clksrc < (7*pixclk_d+1)/2)
+		ipclk->divisor = 3;
+	else if (clksrc < (9*pixclk_d+1)/2)
+		ipclk->divisor = 4;
+	else
+		return -ENXIO;
+
+	ipclk->pixclk = clksrc / ipclk->divisor;
+	ipclk->error = (100*(pixclk_d - ipclk->pixclk)) / pixclk_d;
+	return 0;
+}
+
+static int
+e1356_calc_pixclock(const struct fb_info_e1356 *info,
+		    pixclock_info_t* ipclk)
+{
+	int src_sel=-1, flicker_mult=0;
+	pixclock_info_t test, ret;
+    
+	if (ipclk->pixclk > info->max_pixclock)
+		return -ENXIO;
+
+	test.pixclk_d = ipclk->pixclk_d;
+	ret.error = 100;
+	
+	if (IS_TV(info->fix.disp_type) &&
+	    (info->fix.tv_filt & TV_FILT_FLICKER))
+		flicker_mult = 0x80;
+	
+	test.clksrc = info->fix.busclk;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x01;
+	}
+
+	test.clksrc = info->fix.mclk;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x03;
+	}
+
+	test.clksrc = info->fix.clki;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x00;
+	}
+
+	test.clksrc = info->fix.clki2;
+	if (get_nearest_pixclk_div(&test, flicker_mult != 0) == 0 &&
+	    abs(test.error) < abs(ret.error)) {
+		ret = test;
+		src_sel = 0x02;
+	}
+
+	if (ret.error > MAX_PCLK_ERROR_LOWER ||
+	    ret.error < MAX_PCLK_ERROR_HIGHER)
+		return -ENXIO;
+    
+	ret.pixclk_bits = flicker_mult | ((ret.divisor-1)<<4) | src_sel;
+	*ipclk = ret;
+	return 0;
+}
+
+static inline int
+e1356_engine_wait_complete(reg_bitblt_t* bltreg)
+{
+	return e1356_wait_bitclr(&bltreg->ctrl0, 0x80, 5000);
+}
+static inline int
+e1356_engine_wait_busy(reg_bitblt_t* bltreg)
+{
+	return e1356_wait_bitset(&bltreg->ctrl0, 0x80, 5000);
+}
+
+static void
+e1356fb_engine_init(const struct e1356fb_par* par,
+		    struct fb_info_e1356* info)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+    
+	e1356_engine_wait_complete(bltreg);
+
+	writeb(0, &bltreg->ctrl0);
+	writeb(0, &bltreg->ctrl1);
+	writeb(0, &bltreg->rop_code);
+	writeb(0, &bltreg->operation);
+	writeb(0, &bltreg->src_start_addr0);
+	writeb(0, &bltreg->src_start_addr1);
+	writeb(0, &bltreg->src_start_addr2);
+	writeb(0, &bltreg->dest_start_addr0);
+	writeb(0, &bltreg->dest_start_addr1);
+	writeb(0, &bltreg->dest_start_addr2);
+	writew(0, &bltreg->mem_addr_offset0);
+	writew(0, &bltreg->width0);
+	writew(0, &bltreg->height0);
+	writew(0, &bltreg->bg_color0);
+	writew(0, &bltreg->fg_color0);
+}
+
+
+static void doBlt_Write(const struct e1356fb_par* par,
+			struct fb_info_e1356* info,
+			blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	int nWords, nTotalWords;
+	u32 srcphase, dstAddr;
+	u16* w16;
+	u32 stride = par->width_virt * par->Bpp;
+
+	dstAddr = blt->dst_x * par->Bpp + blt->dst_y * stride;
+	srcphase = (u32)blt->src & 1;
+    
+	if (blt->attribute & BLT_ATTR_TRANSPARENT)
+		writew(blt->bg_color, &bltreg->bg_color0);
+	else
+		writeb(blt->rop, &bltreg->rop_code);
+    
+	writeb(blt->operation, &bltreg->operation);
+	writeb((u8)srcphase, &bltreg->src_start_addr0);
+	writew(stride/2, &bltreg->mem_addr_offset0);
+
+	writeb(dstAddr, &bltreg->dest_start_addr0);
+	writeb(dstAddr>>8, &bltreg->dest_start_addr1);
+	writeb(dstAddr>>16, &bltreg->dest_start_addr2);
+
+	writew(blt->dst_width-1, &bltreg->width0);
+	writew(blt->dst_height-1, &bltreg->height0);
+
+	// program color format operation
+	writeb(par->bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+
+	// start it up
+	writeb(0x80, &bltreg->ctrl0);
+
+	// wait for it to actually start
+	e1356_engine_wait_busy(bltreg);
+
+	// calculate the number of 16 bit words per one blt line
+
+	nWords = srcphase + ((blt->dst_width - srcphase)*par->Bpp + 1) / 2;
+	nTotalWords = nWords*blt->dst_height;
+	w16 = (u16*)((u32)blt->src & 0xfffffffe);   // Word aligned
+
+	while (nTotalWords > 0) {
+		int j, nFIFO;
+		u8 ctrl0;
+
+		// read the FIFO status
+		ctrl0 = readb(&bltreg->ctrl0);
+
+		if ((ctrl0 & 0x30) == 0x20)
+			// FIFO is at least half full, but not full
+			nFIFO = 1;
+		else if ((ctrl0 & 0x40) == 0)
+			// FIFO is empty
+			nFIFO = 16;
+		else
+			// FIFO is full
+			continue;
+
+		for (j = 0; j < nFIFO && nTotalWords > 0; j++,nTotalWords--)
+			writew(*w16++, info->reg.bitblt_data);
+	}
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+static void
+doBlt_SolidFill(const struct e1356fb_par* par,
+		struct fb_info_e1356* info,
+		blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	u32 width = blt->dst_width, height = blt->dst_height;
+	u32 stride = par->width_virt * par->Bpp;
+	u32 dest_addr = (blt->dst_y * stride) + (blt->dst_x * par->Bpp);
+
+	if (width == 0 || height == 0)
+		return;
+
+	// program dest address
+	writeb(dest_addr & 0x00ff, &bltreg->dest_start_addr0);
+	writeb((dest_addr>>8) & 0x00ff, &bltreg->dest_start_addr1);
+	writeb((dest_addr>>16) & 0x00ff, &bltreg->dest_start_addr2);
+
+	// program width and height of solid-fill blit
+	writew(width-1, &bltreg->width0);
+	writew(height-1, &bltreg->height0);
+
+	// program color of fill
+	writew(blt->fg_color, &bltreg->fg_color0);
+	// select solid-fill BLIT
+	writeb(BLT_SOLID_FILL, &bltreg->operation);
+	// program color format operation
+	writeb(par->bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+	// program BLIT memory offset
+	writew(stride/2, &bltreg->mem_addr_offset0);
+
+	// start it up (self completes)
+	writeb(0x80, &bltreg->ctrl0);
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+static void
+doBlt_Move(const struct e1356fb_par* par,
+	   struct fb_info_e1356* info,
+	   blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	int neg_dir=0;
+	u32 dest_addr, src_addr;
+	u32 bpp = par->bpp;
+	u32 stride = par->width_virt * par->Bpp; // virt line length in bytes
+	u32 srcx = blt->src_x, srcy = blt->src_y;
+	u32 dstx = blt->dst_x, dsty = blt->dst_y;
+	u32 width = blt->dst_width, height = blt->dst_height;
+    
+	if (width == 0 || height == 0)
+		return;
+   
+	src_addr = srcx*par->Bpp + srcy*stride;
+	dest_addr = dstx*par->Bpp + dsty*stride;
+
+	/*
+	 * See if regions overlap and dest region is beyond source region.
+	 * If so, we need to do a move BLT in negative direction. Only applies
+	 * if the BLT is not transparent.
+	 */
+	if (!(blt->attribute & BLT_ATTR_TRANSPARENT)) {
+		if ((srcx + width  > dstx) && (srcx < dstx + width) &&
+		    (srcy + height > dsty) && (srcy < dsty + height) &&
+		    (dest_addr > src_addr)) {
+			neg_dir = 1;
+			// negative direction : get the coords of lower right corner
+			src_addr += stride * (height-1) + par->Bpp * (width-1);
+			dest_addr += stride * (height-1) + par->Bpp * (width-1);
+		}
+	}
+    
+	// program BLIT memory offset
+	writew(stride/2, &bltreg->mem_addr_offset0);
+
+	// program src and dest addresses
+	writeb(src_addr & 0x00ff, &bltreg->src_start_addr0);
+	writeb((src_addr>>8) & 0x00ff, &bltreg->src_start_addr1);
+	writeb((src_addr>>16) & 0x00ff, &bltreg->src_start_addr2);
+	writeb(dest_addr & 0x00ff, &bltreg->dest_start_addr0);
+	writeb((dest_addr>>8) & 0x00ff, &bltreg->dest_start_addr1);
+	writeb((dest_addr>>16) & 0x00ff, &bltreg->dest_start_addr2);
+
+	// program width and height of blit
+	writew(width-1, &bltreg->width0);
+	writew(height-1, &bltreg->height0);
+
+	// program color format operation
+	writeb(bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+
+	// set the blt type
+	if (blt->attribute & BLT_ATTR_TRANSPARENT) {
+		writew(blt->bg_color, &bltreg->bg_color0);
+		writeb(BLT_MOVE_POS_TRANSP, &bltreg->operation); 
+	} else {
+		writeb(blt->rop, &bltreg->rop_code);
+		// select pos/neg move BLIT
+		writeb(neg_dir ? BLT_MOVE_NEG_ROP : BLT_MOVE_POS_ROP,
+		       &bltreg->operation); 
+	}
+
+	// start it up (self completes)
+	writeb(0x80, &bltreg->ctrl0);
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+static void doBlt_ColorExpand(const struct e1356fb_par* par,
+			      struct fb_info_e1356* info,
+			      blt_info_t* blt)
+{
+	reg_bitblt_t* bltreg = info->reg.bitblt;
+	int i, j, nWords, Sx, Sy;
+	u32 dstAddr;
+	u16* wpt, *wpt1;
+	u32 stride = par->width_virt * par->Bpp;
+
+	if (blt->dst_width == 0 || blt->dst_height == 0)
+		return;
+
+	Sx = blt->src_x;
+	Sy = blt->src_y;
+
+	writeb((7 - Sx%8), &bltreg->rop_code);
+
+	writeb(blt->operation, &bltreg->operation);
+
+	writeb((u8)(Sx & 1), &bltreg->src_start_addr0);
+
+	dstAddr = blt->dst_x*par->Bpp + blt->dst_y * stride;
+	writeb(dstAddr, &bltreg->dest_start_addr0);
+	writeb(dstAddr>>8, &bltreg->dest_start_addr1);
+	writeb(dstAddr>>16, &bltreg->dest_start_addr2);
+
+	// program color format operation
+	writeb(par->bpp == 8 ? 0x00 : 0x01, &bltreg->ctrl1);
+	writew(stride/2, &bltreg->mem_addr_offset0);
+	writew(blt->dst_width-1, &bltreg->width0);
+	writew(blt->dst_height-1, &bltreg->height0);
+	writew(blt->bg_color, &bltreg->bg_color0);
+	writew(blt->fg_color, &bltreg->fg_color0);
+
+	// start it up
+	writeb(0x80, &bltreg->ctrl0);
+
+	// wait for it to actually start
+	e1356_engine_wait_busy(bltreg);
+
+	// calculate the number of 16 bit words per one blt line
+
+	nWords = (Sx%16 + blt->dst_width + 15)/16;
+
+	wpt = blt->src + (Sy*blt->srcstride + Sx/16)/2;
+
+	for (i = 0; i < blt->dst_height; i++) {
+		wpt1 = wpt;
+
+		for (j = 0; j < nWords; j++) {
+			// loop until FIFO becomes empty...
+			e1356_wait_bitclr(&bltreg->ctrl0, 0x40, 10000);
+			writew(*wpt1++, info->reg.bitblt_data);
+		}
+	
+		wpt += blt->srcstride/2;
+	}
+
+	e1356_engine_wait_complete(bltreg);
+}
+
+
+/*
+ * The BitBLT operation dispatcher
+ */
+static int
+doBlt(const struct e1356fb_par* par,
+      struct fb_info_e1356* info,
+      blt_info_t* blt)
+{
+	/*
+	 * Make sure we're not reentering in the middle of an
+	 * active BitBLT operation. ALWAYS call this dispatcher
+	 * and not one of the above BLT routines directly, or you
+	 * run the risk of overlapping BLT operations, which can
+	 * cause complete system hangs.
+     */
+	if (readb(&info->reg.bitblt->ctrl0) & 0x80)
+		return -ENXIO;
+    
+	switch (blt->operation) {
+	case BLT_MOVE_POS_ROP:
+	case BLT_MOVE_NEG_ROP:
+	case BLT_MOVE_POS_TRANSP:
+		doBlt_Move(par, info, blt);
+		break;
+	case BLT_COLOR_EXP:
+	case BLT_COLOR_EXP_TRANSP:
+		doBlt_ColorExpand(par, info, blt);
+		break;
+	case BLT_SOLID_FILL:
+		doBlt_SolidFill(par, info, blt);
+		break;
+	case BLT_WRITE_ROP:
+	case BLT_WRITE_TRANSP:
+		doBlt_Write(par, info, blt);
+		break;
+	case BLT_READ:
+	case BLT_PAT_FILL_ROP:
+	case BLT_PAT_FILL_TRANSP:
+	case BLT_MOVE_COLOR_EXP:
+	case BLT_MOVE_COLOR_EXP_TRANSP:
+		DPRINTK("BitBLT operation 0x%02x not implemented yet\n",
+			blt->operation);
+		return -ENXIO;
+	default:
+		DPRINTK("Unknown BitBLT operation 0x%02x\n", blt->operation);
+		return -ENXIO;
+	}
+    
+	return 0;
+}
+
+
+// Initializes blt->src and blt->srcstride
+static void fill_putcs_buffer(struct display *p,
+			      blt_info_t* blt,
+			      const unsigned short* str,
+			      int count)
+{   
+	int row, i, j;
+	u8* b1, *b2;
+	u32 fw = fontwidth(p);
+	u32 fwb = (fw + 7) >> 3;
+	u32 fh = fontheight(p);
+	int bytesPerChar = fwb * fh;
+
+	if (count*bytesPerChar > PAGE_SIZE) {
+		// Truncate the string if it overflows putcs_buffer, which is
+		// one page in size.
+		count = PAGE_SIZE/bytesPerChar - 1;
+	}
+
+	blt->srcstride = (fwb*count + 1) & ~1; //round up to be even
+	
+	b1 = (u8*)blt->src;
+
+	for (row = 0; row < fh; row++) {
+		b2 = b1;
+		for (i = 0; i < count; i++) {
+			for (j=0; j<fwb; j++)
+				*b2++ = p->fontdata[(str[i] & p->charmask) *
+						   bytesPerChar +
+						   row*fwb + j];
+		}
+		b1 += blt->srcstride;
+	}
+}
+
+
+/*
+ * Set the color of a palette entry in 8bpp mode 
+ */
+static inline void
+do_setpalentry(reg_lut_t* lut, unsigned regno,
+	       u8 r, u8 g, u8 b)
+{
+	writeb(0x00, &lut->mode);
+	writeb((u8)regno, &lut->addr);
+	writeb(r&0xf0, &lut->data);
+	writeb(g&0xf0, &lut->data);
+	writeb(b&0xf0, &lut->data);
+}
+
+   
+static void
+do_pan_var(struct fb_var_screeninfo* var, struct fb_info_e1356* info)
+{
+	u32 pixel_start, start_addr;
+	u8 pixel_pan;
+	struct e1356fb_par* par = &info->current_par;
+	reg_misc_t* misc = info->reg.misc;
+	reg_dispmode_t* dispmode = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_mode : info->reg.crttv_mode;
+	
+	pixel_start = var->yoffset * par->width_virt + var->xoffset;
+	start_addr = (pixel_start * par->Bpp) / 2;
+	pixel_pan = (par->bpp == 8) ? (u8)(pixel_start & 1) : 0;
+    
+	if (readb(&misc->disp_mode) != 0) {
+		reg_dispcfg_t* dispcfg = (IS_PANEL(info->fix.disp_type)) ?
+			info->reg.lcd_cfg : info->reg.crttv_cfg;
+
+		// wait for the end of the current VNDP
+		e1356_wait_bitclr(&dispcfg->vndp, 0x80, 5000);
+		// now wait for the start of a new VNDP
+		e1356_wait_bitset(&dispcfg->vndp, 0x80, 5000);
+	}
+    
+	writeb((u8)(start_addr & 0xff), &dispmode->start_addr0);
+	writeb((u8)((start_addr>>8) & 0xff), &dispmode->start_addr1);
+	writeb((u8)((start_addr>>16) & 0xff), &dispmode->start_addr2);
+	writeb(pixel_pan, &dispmode->pixel_panning);
+}
+
+
+/*
+ * Invert the hardware cursor image (timerfunc)  
+ */
+static void
+do_flashcursor(unsigned long ptr)
+{
+	u8 curs_ctrl;
+	struct fb_info_e1356* info = (struct fb_info_e1356 *)ptr;
+	reg_inkcurs_t* inkcurs = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_inkcurs : info->reg.crttv_inkcurs;
+
+	spin_lock(&info->cursor.lock);
+	// toggle cursor enable bit
+	curs_ctrl = readb(&inkcurs->ctrl);
+	writeb((curs_ctrl ^ 0x01) & 0x01, &inkcurs->ctrl);
+	info->cursor.timer.expires = jiffies+HZ/2;
+	add_timer(&info->cursor.timer);
+	spin_unlock(&info->cursor.lock);
+}
+
+#ifdef SHADOW_FRAME_BUFFER
+/*
+ * Write BLT the shadow frame buffer to the real fb (timerfunc)  
+ */
+static void
+do_write_shadow_fb(unsigned long ptr)
+{
+	blt_info_t blt;
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)ptr;
+	struct fb_info* fb = &info->fb_info;
+	struct e1356fb_par* par = &info->current_par;
+	u32 stride = par->width_virt * par->Bpp;
+
+	unsigned long j_start = jiffies;
+    
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = par->width;
+	blt.dst_height = par->height;
+	blt.dst_y = fb->var.yoffset;
+	blt.dst_x = fb->var.xoffset;
+	blt.operation = BLT_WRITE_ROP;
+	blt.rop = 0x0c; // ROP: destination = source
+	blt.src = (u16*)(info->shadow.fb + blt.dst_x * par->Bpp +
+			 blt.dst_y * stride);
+
+	doBlt(par, info, &blt);
+    
+	info->shadow.timer.expires = jiffies+HZ/2;
+	add_timer(&info->shadow.timer);
+
+	//DPRINTK("delta jiffies = %ld\n", jiffies - j_start);
+}
+#endif
+
+
+/* ------------------------------------------------------------------------- 
+ *              Hardware independent part, interface to the world
+ * ------------------------------------------------------------------------- */
+
+static void
+e1356_cfbX_clear_margins(struct vc_data* conp, struct display* p,
+			 int bottom_only)
+{
+	blt_info_t blt;
+	unsigned int cw=fontwidth(p);
+	unsigned int ch=fontheight(p);
+	unsigned int rw=p->var.xres % cw;
+	unsigned int bh=p->var.yres % ch;
+	unsigned int rs=p->var.xres - rw;
+	unsigned int bs=p->var.yres - bh;
+
+	//DPRINTK("\n");
+
+	if (!bottom_only && rw) { 
+		blt.dst_x = p->var.xoffset+rs;
+		blt.dst_y = p->var.yoffset;
+		blt.dst_height = p->var.yres;
+		blt.dst_width = rw;
+		blt.attribute = 0;
+		blt.fg_color = 0;
+		blt.operation = BLT_SOLID_FILL;
+		doBlt (&fb_info.current_par, &fb_info, &blt);
+	}
+    
+	if (bh) { 
+		blt.dst_x = p->var.xoffset;
+		blt.dst_y = p->var.yoffset+bs;
+		blt.dst_height = bh;
+		blt.dst_width = rs;
+		blt.attribute = 0;
+		blt.fg_color = 0;
+		blt.operation = BLT_SOLID_FILL;
+		doBlt (&fb_info.current_par, &fb_info, &blt);
+	}
+}
+
+static void
+e1356_cfbX_bmove(struct display* p, 
+		 int sy, 
+		 int sx, 
+		 int dy,
+		 int dx, 
+		 int height, 
+		 int width)
+{
+	blt_info_t blt;
+    
+	//DPRINTK("(%d,%d) to (%d,%d) size (%d,%d)\n", sx,sy,dx,dy,width,height);
+
+	blt.src_x = fontwidth_x8(p)*sx;
+	blt.src_y = fontheight(p)*sy;
+	blt.dst_x = fontwidth_x8(p)*dx;
+	blt.dst_y = fontheight(p)*dy;
+	blt.src_height = blt.dst_height = fontheight(p)*height;
+	blt.src_width = blt.dst_width = fontwidth_x8(p)*width;
+	blt.attribute = 0;
+	blt.rop = 0x0c;
+	/*
+	 * The move BLT routine will actually decide between a pos/neg
+	 * move BLT. This is just so that the BLT dispatcher knows to
+	 * call the move BLT routine.
+	 */
+	blt.operation = BLT_MOVE_POS_ROP;
+
+	doBlt (&fb_info.current_par, &fb_info, &blt);
+}
+
+static void
+e1356_cfb8_putc(struct vc_data* conp,
+		struct display* p,
+		int c, int yy,int xx)
+{   
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+	u16 cs = (u16)c;
+
+	fgx = attr_fgcol(p, c);
+	bgx = attr_bgcol(p, c);
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, &cs, 1);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+
+}
+
+static void
+e1356_cfb16_putc(struct vc_data* conp,
+		 struct display* p,
+		 int c, int yy,int xx)
+{   
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+	u16 cs = (u16)c;
+    
+	fgx = ((u16*)p->dispsw_data)[attr_fgcol(p,c)];
+	bgx = ((u16*)p->dispsw_data)[attr_bgcol(p,c)];
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, &cs, 1);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+}
+
+
+static void
+e1356_cfb8_putcs(struct vc_data* conp,
+		 struct display* p,
+		 const unsigned short *s,int count,int yy,int xx)
+{
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+
+	//DPRINTK("\n");
+
+	fgx=attr_fgcol(p, *s);
+	bgx=attr_bgcol(p, *s);
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = count * fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, s, count);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+}
+
+static void
+e1356_cfb16_putcs(struct vc_data* conp,
+		  struct display* p,
+		  const unsigned short *s,int count,int yy,int xx)
+{
+	blt_info_t blt;
+	u32 fgx,bgx;
+	u32 fw = fontwidth_x8(p);
+	u32 fh = fontheight(p);
+
+	//DPRINTK("\n");
+
+	fgx=((u16*)p->dispsw_data)[attr_fgcol(p,*s)];
+	bgx=((u16*)p->dispsw_data)[attr_bgcol(p,*s)];
+
+	blt.src_x = blt.src_y = 0;
+	blt.attribute = 0;
+	blt.dst_width = count * fw;
+	blt.dst_height = fh;
+	blt.dst_y = yy * fh;
+	blt.dst_x = xx * fw;
+	blt.bg_color = bgx;
+	blt.fg_color = fgx;
+	blt.operation = BLT_COLOR_EXP;
+	blt.src = fb_info.putcs_buffer;
+	fill_putcs_buffer(p, &blt, s, count);
+
+	doBlt(&fb_info.current_par, &fb_info, &blt);
+}
+
+
+static void
+e1356_cfb8_clear(struct vc_data* conp, 
+		 struct display* p, 
+		 int sy,
+		 int sx, 
+		 int height, 
+		 int width)
+{
+	blt_info_t blt;
+	u32 bg = attr_bgcol_ec(p,conp);
+
+	//DPRINTK("(%d,%d) size (%d,%d)\n", sx,sy,width,height);
+
+	blt.dst_x = fontwidth_x8(p)*sx;
+	blt.dst_y = fontheight(p)*sy;
+	blt.dst_height = fontheight(p)*height;
+	blt.dst_width = fontwidth_x8(p)*width;
+	blt.attribute = 0;
+	blt.fg_color = bg;
+	blt.operation = BLT_SOLID_FILL;
+
+	doBlt (&fb_info.current_par, &fb_info, &blt);
+}
+
+static void
+e1356_cfb16_clear(struct vc_data* conp, 
+		  struct display* p, 
+		  int sy,
+		  int sx, 
+		  int height, 
+		  int width)
+{
+	blt_info_t blt;
+	u32 bg = ((u16*)p->dispsw_data)[attr_bgcol_ec(p,conp)];
+
+	//DPRINTK("(%d,%d) size (%d,%d)\n", sx,sy,width,height);
+
+	blt.dst_x = fontwidth_x8(p)*sx;
+	blt.dst_y = fontheight(p)*sy;
+	blt.dst_height = fontheight(p)*height;
+	blt.dst_width = fontwidth_x8(p)*width;
+	blt.attribute = 0;
+	blt.fg_color = bg;
+	blt.operation = BLT_SOLID_FILL;
+
+	doBlt (&fb_info.current_par, &fb_info, &blt);
+}
+
+
+static void
+e1356_cfbX_revc(struct display *p, int xx, int yy)
+{
+	// not used if h/w cursor
+	//DPRINTK("\n");
+}
+
+static void
+e1356_cfbX_cursor(struct display *p, int mode, int x, int y) 
+{
+	unsigned long flags;
+	struct fb_info_e1356 *info=(struct fb_info_e1356 *)p->fb_info;
+	reg_inkcurs_t* inkcurs = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_inkcurs : info->reg.crttv_inkcurs;
+    
+	//DPRINTK("\n");
+
+	if (mode == CM_ERASE) {
+		if (info->cursor.state != CM_ERASE) {
+			spin_lock_irqsave(&info->cursor.lock,flags);
+			info->cursor.state = CM_ERASE;
+			del_timer(&(info->cursor.timer));
+			writeb(0x00, &inkcurs->ctrl);
+			spin_unlock_irqrestore(&info->cursor.lock,flags);
+		}
+		return;
+	}
+    
+	if ((p->conp->vc_cursor_type & CUR_HWMASK) != info->cursor.type)
+		e1356fb_createcursor(p);
+    
+	x *= fontwidth_x8(p);
+	y *= fontheight(p);
+	x -= p->var.xoffset;
+	y -= p->var.yoffset;
+    
+	spin_lock_irqsave(&info->cursor.lock,flags);
+	if ((x != info->cursor.x) || (y != info->cursor.y) ||
+	    (info->cursor.redraw)) {
+		info->cursor.x = x;
+		info->cursor.y = y;
+		info->cursor.redraw = 0;
+		writeb(0x01, &inkcurs->ctrl);
+		writew(x, &inkcurs->x_pos0);
+		writew(y, &inkcurs->y_pos0);
+		/* fix cursor color - XFree86 forgets to restore it properly */
+		writeb(0x00, &inkcurs->blue0);
+		writeb(0x00, &inkcurs->green0);
+		writeb(0x00, &inkcurs->red0);
+		writeb(0x1f, &inkcurs->blue1);
+		writeb(0x3f, &inkcurs->green1);
+		writeb(0x1f, &inkcurs->red1);
+	}
+
+	info->cursor.state = CM_DRAW;
+	mod_timer(&info->cursor.timer, jiffies+HZ/2);
+	spin_unlock_irqrestore(&info->cursor.lock,flags);
+}
+
+#ifdef FBCON_HAS_CFB8
+static struct display_switch fbcon_e1356_8 = {
+	.setup		= fbcon_cfb8_setup, 
+	.bmove		= e1356_cfbX_bmove, 
+	.clear		= e1356_cfb8_clear, 
+	.putc		= e1356_cfb8_putc,
+	.putcs		= e1356_cfb8_putcs, 
+	.revc		= e1356_cfbX_revc,   
+	.cursor		= e1356_cfbX_cursor, 
+	.clear_margins	= e1356_cfbX_clear_margins,
+	.fontwidthmask	= FONTWIDTHRANGE(6,16)
+};
+#endif
+
+#ifdef FBCON_HAS_CFB16
+static struct display_switch fbcon_e1356_16 = {
+	.setup		= fbcon_cfb16_setup, 
+	.bmove		= e1356_cfbX_bmove, 
+	.clear		= e1356_cfb16_clear, 
+	.putc		= e1356_cfb16_putc,
+	.putcs		= e1356_cfb16_putcs, 
+	.revc		= e1356_cfbX_revc, 
+	.cursor		= e1356_cfbX_cursor, 
+	.clear_margins	= e1356_cfbX_clear_margins,
+	.fontwidthmask	= FONTWIDTHRANGE(6,16)
+};
+#endif
+
+/* ------------------------------------------------------------------------- */
+
+static void
+e1356fb_set_par(const struct e1356fb_par* par,
+		struct fb_info_e1356* info)
+{
+	reg_dispcfg_t* dispcfg=NULL;
+	reg_dispmode_t* dispmode=NULL;
+	u8* pclk_cfg=NULL;
+	u8 width, hndp=0, hsync_start=0, hsync_width=0;
+	u8 vndp, vsync_start, vsync_width=0, display_mode;
+	u8 main_display_mode=0;
+	u16 height, addr_offset;
+	int disp_type = info->fix.disp_type;
+
+	DPRINTK("%dx%d-%dbpp @ %d Hz, %d kHz hsync\n",
+		par->width, par->height, par->bpp,
+		par->vsync_freq, (((2*par->hsync_freq)/1000)+1)/2);
+#ifdef E1356FB_VERBOSE_DEBUG
+	dump_par(par);
+#endif
+    
+	info->current_par = *par;
+
+	width = (par->width >> 3) - 1;
+	display_mode = (par->bpp == 8) ? 0x03 : 0x05;
+	addr_offset = (par->width_virt * par->Bpp) / 2;
+	vsync_start = (disp_type == DISP_TYPE_LCD) ? 0 : par->vsync_start - 1;
+	height = par->height - 1;
+	vndp = par->vert_ndp - 1;
+
+	switch (disp_type) {
+	case DISP_TYPE_LCD:
+		dispcfg = info->reg.lcd_cfg;
+		dispmode = info->reg.lcd_mode;
+		pclk_cfg = &info->reg.clk_cfg->lcd_pclk_cfg;
+		hndp = (par->horiz_ndp >> 3) - 1;
+		hsync_start = 0;
+		hsync_width = par->hsync_pol ? 0x00 : 0x80;
+		vsync_width = par->vsync_pol ? 0x00 : 0x80;
+		main_display_mode = 0x01;
+		break;
+	case DISP_TYPE_TFT:
+		dispcfg = info->reg.lcd_cfg;
+		dispmode = info->reg.lcd_mode;
+		pclk_cfg = &info->reg.clk_cfg->lcd_pclk_cfg;
+		hndp = (par->horiz_ndp >> 3) - 1;
+		hsync_start = (par->bpp == 8) ?
+			(par->hsync_start - 4) >> 3 :
+				(par->hsync_start - 6) >> 3;
+		hsync_width =
+			(par->hsync_pol ? 0x80 : 0x00) |
+			((par->hsync_width >> 3) - 1);
+		vsync_width =
+			(par->vsync_pol ? 0x80 : 0x00) |
+			(par->vsync_width - 1);
+		main_display_mode = 0x01;
+		break;
+	case DISP_TYPE_CRT:
+		dispcfg = info->reg.crttv_cfg;
+		dispmode = info->reg.crttv_mode;
+		pclk_cfg = &info->reg.clk_cfg->crttv_pclk_cfg;
+		hndp = (par->horiz_ndp >> 3) - 1;
+		hsync_start = (par->bpp == 8) ?
+			(par->hsync_start - 3) >> 3 :
+				(par->hsync_start - 5) >> 3;
+		hsync_width =
+			(par->hsync_pol ? 0x80 : 0x00) |
+			((par->hsync_width >> 3) - 1);
+		vsync_width =
+			(par->vsync_pol ? 0x80 : 0x00) |
+			(par->vsync_width - 1);
+		main_display_mode = 0x02;
+		break;
+	case DISP_TYPE_NTSC:
+	case DISP_TYPE_PAL:
+		dispcfg = info->reg.crttv_cfg;
+		dispmode = info->reg.crttv_mode;
+		pclk_cfg = &info->reg.clk_cfg->crttv_pclk_cfg;
+		hndp = (disp_type == DISP_TYPE_PAL) ?
+			(par->horiz_ndp - 7) >> 3 :
+				(par->horiz_ndp - 6) >> 3;
+		hsync_start = (par->bpp == 8) ?
+			(par->hsync_start + 7) >> 3 :
+				(par->hsync_start + 5) >> 3;
+		hsync_width = 0;
+		vsync_width = 0;
+		main_display_mode = (info->fix.tv_filt & TV_FILT_FLICKER) ?
+			0x06 : 0x04;
+		break;
+	}
+
+	// Blast the regs!
+	// note: reset panning/scrolling (set start-addr and
+	// pixel pan regs to 0). Panning is handled by pan_display.
+
+	e1356_engine_wait_complete(info->reg.bitblt);
+
+	// disable display while initializing
+	writeb(0, &info->reg.misc->disp_mode);
+
+	writeb(par->ipclk.pixclk_bits, pclk_cfg);
+
+	writeb(width, &dispcfg->hdw);
+	writeb(hndp, &dispcfg->hndp);
+	writeb(hsync_start, &dispcfg->hsync_start);
+	writeb(hsync_width, &dispcfg->hsync_pulse);
+	writew(height, &dispcfg->vdh0);
+	writeb(vndp, &dispcfg->vndp);
+	writeb(vsync_start, &dispcfg->vsync_start);
+	writeb(vsync_width, &dispcfg->vsync_pulse);
+
+	writeb(display_mode, &dispmode->disp_mode);
+	if (info->fix.mmunalign && info->mmaped)
+		writeb(1, &dispmode->start_addr0);
+	else
+		writeb(0, &dispmode->start_addr0);
+	writeb(0, &dispmode->start_addr1);
+	writeb(0, &dispmode->start_addr2);
+	writew(addr_offset, &dispmode->mem_addr_offset0);
+	writeb(0, &dispmode->pixel_panning);
+
+	// reset BitBlt engine
+	e1356fb_engine_init(par, info);
+
+#ifdef E1356FB_VERBOSE_DEBUG
+	dump_display_regs(dispcfg, dispmode);
+#endif
+
+	/* clear out framebuffer memory */
+	fbfill(fb_info.membase_virt, 0, fb_info.fb_size);
+	// finally, enable display!
+	writeb(main_display_mode, &info->reg.misc->disp_mode); 
+}
+
+
+static int
+e1356fb_verify_timing(struct e1356fb_par* par,
+		      const struct fb_info_e1356* info)
+{
+	int disp_type = info->fix.disp_type;
+
+	// timing boundary checks
+	if (par->horiz_ndp > max_hndp[disp_type]) {
+		DPRINTK("horiz_ndp too big: %d\n", par->horiz_ndp);
+		return -EINVAL;
+	}
+	if (par->vert_ndp > max_vndp[disp_type]) {
+		DPRINTK("vert_ndp too big: %d\n", par->vert_ndp);
+		return -EINVAL;
+	}
+
+	if (disp_type != DISP_TYPE_LCD) {
+		if (par->hsync_start >
+		    max_hsync_start[(par->bpp==16)][disp_type]) {
+			DPRINTK("hsync_start too big: %d\n",
+				par->hsync_start);
+			return -EINVAL;
+		}
+		if (par->vsync_start > max_vsync_start[disp_type]) {
+			DPRINTK("vsync_start too big: %d\n",
+				par->vsync_start);
+			return -EINVAL;
+		}
+		if (!IS_TV(disp_type)) {
+			if (par->hsync_width > max_hsync_width[disp_type]) {
+				DPRINTK("hsync_width too big: %d\n",
+					par->hsync_width);
+				return -EINVAL;
+			}
+			if (par->vsync_width > max_vsync_width[disp_type]) {
+				DPRINTK("vsync_width too big: %d\n",
+					par->vsync_width);
+				return -EINVAL;
+			}
+		}
+	}
+
+	if (IS_TV(disp_type)) {
+		int tv_pixclk = (disp_type == DISP_TYPE_NTSC) ?
+			NTSC_PIXCLOCK : PAL_PIXCLOCK;
+		if (info->fix.tv_filt & TV_FILT_FLICKER)
+			tv_pixclk *= 2;
+		
+		if (par->ipclk.pixclk_d != tv_pixclk) {
+			DPRINTK("invalid TV pixel clock %u kHz\n",
+				par->ipclk.pixclk_d);
+			return -EINVAL;
+		}
+	}
+	
+	if (e1356_calc_pixclock(info, &par->ipclk) < 0) {
+		DPRINTK("can't set pixel clock %u kHz\n",
+			par->ipclk.pixclk_d);
+		return -EINVAL;
+	}
+ 
+#ifdef E1356FB_VERBOSE_DEBUG
+	DPRINTK("desired pixclock = %d kHz, actual = %d kHz, error = %d%%\n",
+		par->ipclk.pixclk_d, par->ipclk.pixclk, par->ipclk.error);
+#endif
+    
+	if (disp_type != DISP_TYPE_LCD) {
+		if (par->horiz_ndp < par->hsync_start + par->hsync_width) {
+			DPRINTK("invalid horiz. timing\n");
+			return -EINVAL;
+		}
+		if (par->vert_ndp < par->vsync_start + par->vsync_width) {
+			DPRINTK("invalid vert. timing\n");
+			return -EINVAL;
+		}
+
+		// SED1356 Hardware Functional Spec, section 13.5
+		if (disp_type == DISP_TYPE_NTSC &&
+		    ((par->width + par->horiz_ndp != 910) ||
+		     (par->height + 2*par->vert_ndp+1 != 525))) {
+			DPRINTK("invalid NTSC timing\n");
+			return -EINVAL;
+		} else if (disp_type == DISP_TYPE_PAL &&
+			   ((par->width + par->horiz_ndp != 1135) ||
+			    (par->height + 2*par->vert_ndp+1 != 625))) {
+			DPRINTK("invalid PAL timing\n");
+			return -EINVAL;
+		}
+	}
+    
+	par->hsync_freq = (1000 * par->ipclk.pixclk) /
+		(par->width + par->horiz_ndp);
+	par->vsync_freq = par->hsync_freq / (par->height + par->vert_ndp);
+	
+	if (par->hsync_freq < 30000 || par->hsync_freq > 90000) {
+		DPRINTK("hsync freq too %s: %u Hz\n",
+			par->hsync_freq < 30000 ? "low" : "high",
+			par->hsync_freq);
+		return -EINVAL;
+	}
+	if (par->vsync_freq < 50 || par->vsync_freq > 110) {
+		DPRINTK("vsync freq too %s: %u Hz\n",
+			par->vsync_freq < 50 ? "low" : "high",
+			par->vsync_freq);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+e1356fb_verify_par(struct e1356fb_par* par,
+		   const struct fb_info_e1356* info)
+{
+	int disp_type = info->fix.disp_type;
+    
+	if (par->bpp != 8 && par->bpp != 16) {
+		DPRINTK("depth not supported: %u bpp\n", par->bpp);
+		return -EINVAL;
+	}
+
+	if (par->width > par->width_virt) {
+		DPRINTK("virtual x resolution < physical x resolution not possible\n");
+		return -EINVAL;
+	}
+
+	if (par->height > par->height_virt) {
+		DPRINTK("virtual y resolution < physical y resolution not possible\n");
+		return -EINVAL;
+	}
+
+	if (par->width < 320 || par->width > 1024) {
+		DPRINTK("width not supported: %u\n", par->width);
+		return -EINVAL;
+	}
+
+	if ((disp_type == DISP_TYPE_LCD && (par->width % 16)) ||
+	    (disp_type == DISP_TYPE_TFT && (par->width % 8))) {
+		DPRINTK("invalid width for panel type: %u\n", par->width);
+		return -EINVAL;
+	}
+
+	if (par->height < 200 || par->height > 1024) {
+		DPRINTK("height not supported: %u\n", par->height);
+		return -EINVAL;
+	}
+
+	if (par->width_virt * par->height_virt * par->Bpp >
+	    info->fb_size) {
+		DPRINTK("not enough memory for virtual screen (%ux%ux%u)\n",
+			par->width_virt, par->height_virt, par->bpp);
+		return -EINVAL;
+	}
+
+	return e1356fb_verify_timing(par, info);
+}
+
+
+static int
+e1356fb_var_to_par(const struct fb_var_screeninfo* var,
+		   struct e1356fb_par* par,
+		   const struct fb_info_e1356* info)
+{
+	if ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
+		DPRINTK("interlace not supported\n");
+		return -EINVAL;
+	}
+
+	memset(par, 0, sizeof(struct e1356fb_par));
+
+	par->width       = (var->xres + 15) & ~15; /* could sometimes be 8 */
+	par->width_virt  = var->xres_virtual;
+	par->height      = var->yres;
+	par->height_virt = var->yres_virtual;
+	par->bpp         = var->bits_per_pixel;
+	par->Bpp         = (par->bpp + 7) >> 3;
+
+	par->ipclk.pixclk_d = PICOS2KHZ(var->pixclock);
+
+	par->hsync_start = var->right_margin;
+	par->hsync_width = var->hsync_len;
+
+	par->vsync_start = var->lower_margin;
+	par->vsync_width = var->vsync_len;
+
+	par->horiz_ndp = var->left_margin + var->right_margin + var->hsync_len;
+	par->vert_ndp = var->upper_margin + var->lower_margin + var->vsync_len;
+
+	par->hsync_pol = (var->sync & FB_SYNC_HOR_HIGH_ACT) ? 1 : 0;
+	par->vsync_pol = (var->sync & FB_SYNC_VERT_HIGH_ACT) ? 1 : 0;
+
+	par->cmap_len  = (par->bpp == 8) ? 256 : 16;
+
+	return e1356fb_verify_par(par, info);
+}
+
+static int
+e1356fb_par_to_var(struct fb_var_screeninfo* var,
+		   struct e1356fb_par* par,
+		   const struct fb_info_e1356* info)
+{
+	struct fb_var_screeninfo v;
+	int ret;
+    
+	// First, make sure par is valid.
+	if ((ret = e1356fb_verify_par(par, info)))
+		return ret;
+
+	memset(&v, 0, sizeof(struct fb_var_screeninfo));
+	v.xres_virtual   = par->width_virt;
+	v.yres_virtual   = par->height_virt;
+	v.xres           = par->width;
+	v.yres           = par->height;
+	v.right_margin   = par->hsync_start;
+	v.hsync_len      = par->hsync_width;
+	v.left_margin    = par->horiz_ndp - par->hsync_start - par->hsync_width;
+	v.lower_margin   = par->vsync_start;
+	v.vsync_len      = par->vsync_width;
+	v.upper_margin   = par->vert_ndp - par->vsync_start - par->vsync_width;
+	v.bits_per_pixel = par->bpp;
+
+	switch(par->bpp) {
+	case 8:
+		v.red.offset = v.green.offset = v.blue.offset = 0;
+		v.red.length = v.green.length = v.blue.length = 4;
+		break;
+	case 16:
+		v.red.offset   = 11;
+		v.red.length   = 5;
+		v.green.offset = 5;
+		v.green.length = 6;
+		v.blue.offset  = 0;
+		v.blue.length  = 5;
+		break;
+	}
+
+	v.height = v.width = -1;
+	v.pixclock = KHZ2PICOS(par->ipclk.pixclk);
+
+	if (par->hsync_pol)
+		v.sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (par->vsync_pol)
+		v.sync |= FB_SYNC_VERT_HIGH_ACT;
+
+	*var = v;
+	return 0;
+}
+
+static int
+e1356fb_encode_fix(struct fb_fix_screeninfo*  fix,
+		   const struct e1356fb_par*   par,
+		   const struct fb_info_e1356* info)
+{
+	memset(fix, 0, sizeof(struct fb_fix_screeninfo));
+    
+	strcpy(fix->id, "Epson SED1356");
+	fix->smem_start  = info->fix.membase_phys;
+	fix->smem_len    = info->fb_size;
+	fix->mmio_start  = info->fix.regbase_phys;
+	fix->mmio_len    = info->regbase_size;
+	fix->accel       = FB_ACCEL_EPSON_SED1356;
+	fix->type        = FB_TYPE_PACKED_PIXELS;
+	fix->type_aux    = 0;
+	fix->line_length = par->width_virt * par->Bpp;
+	fix->visual      =
+		(par->bpp == 8) ? FB_VISUAL_PSEUDOCOLOR	: FB_VISUAL_TRUECOLOR;
+    
+	fix->xpanstep    = info->fix.nopan ? 0 : 1;
+	fix->ypanstep    = info->fix.nopan ? 0 : 1;
+	fix->ywrapstep   = 0;
+    
+	return 0;
+}
+
+static int e1356fb_open(struct fb_info *fb, int user)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+        if (user) {
+                info->open++;
+	}
+
+	return 0;
+}
+
+static int e1356fb_release(struct fb_info *fb, int user)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+        if (user && info->open) {
+                info->open--;
+		if (info->open == 0)
+                        info->mmaped = 0;
+	}
+
+	return 0;
+}
+
+static int
+e1356fb_get_fix(struct fb_fix_screeninfo *fix, 
+		int con,
+		struct fb_info *fb)
+{
+	const struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par par;
+
+	//DPRINTK("\n");
+
+	if (con == -1)
+		par = info->current_par;
+	else
+		e1356fb_var_to_par(&fb_display[con].var, &par, info);
+	e1356fb_encode_fix(fix, &par, info);
+	return 0;
+}
+
+static int
+e1356fb_get_var(struct fb_var_screeninfo *var, 
+		int con,
+		struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+
+	//DPRINTK("\n");
+
+	if (con == -1)
+		e1356fb_par_to_var(var, &info->current_par, info);
+	else
+		*var = fb_display[con].var;
+	return 0;
+}
+ 
+static void
+e1356fb_set_dispsw(struct display *disp, 
+		   struct fb_info_e1356 *info,
+		   int bpp, 
+		   int accel)
+{
+	struct e1356fb_fix* fix = &info->fix;
+	//DPRINTK("\n");
+
+	if (disp->dispsw && disp->conp) 
+		fb_con.con_cursor(disp->conp, CM_ERASE);
+	switch (bpp) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		disp->dispsw = fix->noaccel ? &fbcon_cfb8 : &fbcon_e1356_8;
+		if (fix->nohwcursor)
+			fbcon_e1356_8.cursor = NULL;
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+	case 16:
+		disp->dispsw = fix->noaccel ? &fbcon_cfb16 : &fbcon_e1356_16;
+		disp->dispsw_data = info->fbcon_cmap16;
+		if (fix->nohwcursor)
+			fbcon_e1356_16.cursor = NULL;
+		break;
+#endif
+	default:
+		disp->dispsw = &fbcon_dummy;
+	}
+   
+}
+
+static int
+e1356fb_set_var(struct fb_var_screeninfo *var, 
+		int con,
+		struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par par;
+	struct display *display;
+	int oldxres, oldyres, oldvxres, oldvyres, oldbpp, oldaccel, accel, err;
+	int activate = var->activate;
+	int j,k;
+    
+	DPRINTK("\n");
+	
+	if (con >= 0)
+		display = &fb_display[con];
+	else
+		display = fb->disp;	/* used during initialization */
+   
+	if ((err = e1356fb_var_to_par(var, &par, info))) {
+		struct fb_videomode *dm;
+		/*
+		 * this mode didn't pass the tests. Try the
+		 * corresponding mode from our own modedb.
+		 */
+		DPRINTK("req mode failed, trying SED1356 %dx%d mode\n",
+			var->xres, var->yres);
+		if (e1356fb_get_mode(info, var->xres,
+				     var->yres, NULL, &dm) < 0) {
+			DPRINTK("no SED1356 %dx%d mode found, failed\n",
+				var->xres, var->yres);
+			return err;
+		}
+		fb_videomode_to_var(dm, var);
+		if ((err = e1356fb_var_to_par(var, &par, info))) {
+			DPRINTK("SED1356 %dx%d mode failed\n",
+				var->xres, var->yres);
+			return err;
+		}
+	}
+	
+	if (info->fix.tv_filt & TV_FILT_FLICKER)
+		printk("e1356fb: TV flicker filter enabled\n");
+    
+	e1356fb_par_to_var(var, &par, info);
+   
+	if ((activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) {
+		oldxres  = display->var.xres;
+		oldyres  = display->var.yres;
+		oldvxres = display->var.xres_virtual;
+		oldvyres = display->var.yres_virtual;
+		oldbpp   = display->var.bits_per_pixel;
+		oldaccel = display->var.accel_flags;
+		display->var = *var;
+		if (con < 0                         ||
+		    oldxres  != var->xres           || 
+		    oldyres  != var->yres           ||
+		    oldvxres != var->xres_virtual   || 
+		    oldvyres != var->yres_virtual   ||
+		    oldbpp   != var->bits_per_pixel || 
+		    oldaccel != var->accel_flags) {
+			struct fb_fix_screeninfo fix;
+	    
+			e1356fb_encode_fix(&fix, &par, info);
+			display->screen_base    = info->membase_virt;
+			display->visual         = fix.visual;
+			display->type           = fix.type;
+			display->type_aux       = fix.type_aux;
+			display->ypanstep       = fix.ypanstep;
+			display->ywrapstep      = fix.ywrapstep;
+			display->line_length    = fix.line_length;
+			display->next_line      = fix.line_length;
+			display->can_soft_blank = 1;
+			display->inverse        = 0;
+			accel = var->accel_flags & FB_ACCELF_TEXT;
+			e1356fb_set_dispsw(display, info, par.bpp, accel);
+	 
+			if (info->fix.nopan)
+				display->scrollmode = SCROLL_YREDRAW;
+	
+			if (info->fb_info.changevar)
+				(*info->fb_info.changevar)(con);
+		}
+		if (var->bits_per_pixel==8)
+			for(j = 0; j < 16; j++) {
+				k = color_table[j];
+				fb_info.palette[j].red   = default_red[k];
+				fb_info.palette[j].green = default_grn[k];
+				fb_info.palette[j].blue  = default_blu[k];
+			}
+      
+		del_timer(&(info->cursor.timer)); 
+		fb_info.cursor.state=CM_ERASE;
+	
+		if (!info->fb_info.display_fg ||
+		    info->fb_info.display_fg->vc_num == con || con < 0)
+			e1356fb_set_par(&par, info);
+
+		if (!info->fix.nohwcursor) 
+			if (display && display->conp)
+				e1356fb_createcursor( display );
+		info->cursor.redraw = 1;
+
+		if (oldbpp != var->bits_per_pixel || con < 0) {
+			if ((err = fb_alloc_cmap(&display->cmap, 0, 0)))
+				return err;
+			e1356fb_install_cmap(display, &(info->fb_info));
+		}
+	}
+  
+	return 0;
+}
+
+static int
+e1356fb_pan_display(struct fb_var_screeninfo* var, 
+		    int con,
+		    struct fb_info* fb)
+{
+	struct fb_info_e1356* info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par* par = &info->current_par;
+    
+	//DPRINTK("\n");
+
+	if (info->fix.nopan)
+		return -EINVAL;
+
+	if ((int)var->xoffset < 0 ||
+	    var->xoffset + par->width > par->width_virt ||
+	    (int)var->yoffset < 0 ||
+	    var->yoffset + par->height > par->height_virt)
+		return -EINVAL;
+    
+	if (con == currcon)
+		do_pan_var(var, info);
+    
+	fb_display[con].var.xoffset = var->xoffset;
+	fb_display[con].var.yoffset = var->yoffset; 
+
+	return 0;
+}
+
+static int
+e1356fb_get_cmap(struct fb_cmap *cmap, 
+		 int kspc, 
+		 int con,
+		 struct fb_info *fb)
+{
+	struct fb_info_e1356* info = (struct fb_info_e1356*)fb;
+	struct display *d = (con<0) ? fb->disp : fb_display + con;
+   
+	//DPRINTK("\n");
+
+	if (con == currcon) {
+		/* current console? */
+		return fb_get_cmap(cmap, kspc, e1356fb_getcolreg, fb);
+	} else if (d->cmap.len) {
+		/* non default colormap? */
+		fb_copy_cmap(&d->cmap, cmap, kspc ? 0 : 2);
+	} else {
+		fb_copy_cmap(fb_default_cmap(info->current_par.cmap_len),
+			     cmap, kspc ? 0 : 2);
+	}
+	return 0;
+}
+
+static int
+e1356fb_set_cmap(struct fb_cmap *cmap, 
+		 int kspc, 
+		 int con,
+		 struct fb_info *fb)
+{
+	struct display *d = (con<0) ? fb->disp : fb_display + con;
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	int cmap_len = (info->current_par.bpp == 8) ? 256 : 16;
+
+	//DPRINTK("\n");
+
+	if (d->cmap.len!=cmap_len) {
+		int err;
+		if ((err = fb_alloc_cmap(&d->cmap, cmap_len, 0)))
+			return err;
+	}
+    
+	if (con == currcon) {
+		/* current console? */
+		return fb_set_cmap(cmap, kspc, e1356fb_setcolreg, fb);
+	} else {
+		fb_copy_cmap(cmap, &d->cmap, kspc ? 0 : 1);
+	}
+	return 0;
+}
+
+static int
+e1356fb_mmap(struct fb_info *fb,
+	     struct file *file,
+	     struct vm_area_struct *vma)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	unsigned int len;
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+	u64 start=0, off;
+#else
+	unsigned long start=0, off;
+#endif
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
+		DPRINTK("invalid vma->vm_pgoff\n");
+		return -EINVAL;
+	}
+    
+#ifdef SHADOW_FRAME_BUFFER
+	if (!info->shadow.fb) {
+		int order = 0;
+		while (info->fb_size > (PAGE_SIZE * (1 << order)))
+			order++;
+		info->shadow.fb = (void*)__get_free_pages(GFP_KERNEL, order);
+		if (!info->shadow.fb) {
+			DPRINTK("shadow fb alloc failed\n");
+			return -ENXIO;
+		}
+		memset(info->shadow.fb, 0, info->fb_size);
+		init_timer(&info->shadow.timer);
+		info->shadow.timer.function = do_write_shadow_fb;
+		info->shadow.timer.data = (unsigned long)info;
+	}
+	mod_timer(&info->shadow.timer, jiffies+HZ/2);
+	start = virt_to_phys(info->shadow.fb) & PAGE_MASK;
+#else
+	start = info->fix.membase_phys & PAGE_MASK;
+#endif
+
+	len = PAGE_ALIGN((start & ~PAGE_MASK) + info->fb_size);
+
+	off = vma->vm_pgoff << PAGE_SHIFT;
+    
+	if ((vma->vm_end - vma->vm_start + off) > len) {
+		DPRINTK("invalid vma\n");
+		return -EINVAL;
+	}
+
+	off += start;
+	vma->vm_pgoff = off >> PAGE_SHIFT;
+
+	pgprot_val(vma->vm_page_prot) &= ~_CACHE_MASK;
+#ifdef SHADOW_FRAME_BUFFER
+	vma->vm_flags |= VM_RESERVED;
+	pgprot_val(vma->vm_page_prot) &= ~_CACHE_UNCACHED;
+#else
+	pgprot_val(vma->vm_page_prot) |= _CACHE_UNCACHED;
+#endif
+
+	/* This is an IO map - tell maydump to skip this VMA */
+	vma->vm_flags |= VM_IO;
+	// FIXME: shouldn't have to do this. If the pages are marked writeable,
+	// the TLB fault handlers should set these.
+	pgprot_val(vma->vm_page_prot) |= (_PAGE_DIRTY | _PAGE_VALID);
+    
+	/*
+	 * The SED1356 has only a 16-bit wide data bus, and some
+	 * embedded platforms, such as the Pb1000, do not automatically
+	 * split 32-bit word accesses to the framebuffer into
+	 * seperate half-word accesses. Hence the upper half-word
+	 * never gets to the framebuffer. The following solution is
+	 * to intentionally return a non-32-bit-aligned VA. As long
+	 * as the user app assumes (and doesn't check) that the returned
+	 * VA is 32-bit aligned, all (assumed aligned) 32-bit accesses
+	 * will actually be unaligned and will get trapped by the MIPS
+	 * unaligned exception handler. This handler will emulate the
+	 * load/store instructions by splitting up the load/store
+	 * into two 16-bit load/stores. (This emulation is currently
+	 * enabled by default, but may be disabled in the future, when
+	 * alignment problems in user-level programs get fixed. When
+	 * that happens, this solution won't work anymore, unless the
+	 * process that mmap's the fb also calls sysmips(MIPS_FIXADE, 1),
+	 * which turns address-error emulation back on).
+	 *
+	 * Furthermore, this solution only seems to work for TinyX
+	 * (Xfbdev). Others, like Qt/E, do snoop the returned VA
+	 * and compensate, or do originally unaligned 32-bit accesses
+	 * which then become aligned, hence breaking this solution.
+	 */
+	if (info->fix.mmunalign)
+		vma->vm_start += 2;
+	
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+	if (e1356_remap_page_range(vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot))
+		return -EAGAIN;
+#else
+	if (io_remap_page_range(vma->vm_start, off,
+				vma->vm_end - vma->vm_start,
+				vma->vm_page_prot))
+		return -EAGAIN;
+#endif
+
+	info->mmaped = 1;
+	return 0;
+}
+
+
+int __init
+e1356fb_init(void)
+{
+	struct fb_var_screeninfo var;
+	struct e1356fb_fix * epfix = &fb_info.fix;
+	e1356_reg_t* reg;
+	void* regbase;
+	char* name = "SED1356";
+	int periodMCLK, periodBCLK;
+	int dram_timing, rr_div, mclk_src;
+	u8 rev_code, btmp, mclk_cfg;
+
+	if (options) {
+		e1356fb_setup(options, 0);
+	}
+
+	// clear out fb_info
+	memset(&fb_info, 0, sizeof(struct fb_info_e1356));
+
+	// copy boot options
+	fb_info.fix = boot_fix;
+	fb_info.default_par = boot_par;
+
+	fb_info.regbase_size = E1356_REG_SIZE;
+
+	if (!epfix->system) {
+		printk(KERN_ERR "e1356/86fb: no valid system found\n");
+		return -ENODEV;
+	}
+
+	if (epfix->system == SYS_SDU1356) {
+		// it's the SDU1356B0C PCI eval card.
+		struct pci_dev *pdev = NULL;
+		if (!pci_present())   /* No PCI bus in this machine! */
+			return -ENODEV;
+		if (!(pdev = pci_find_device(PCI_VENDOR_ID_EPSON,
+					     PCI_DEVICE_ID_EPSON_SDU1356, pdev)))
+			return -ENODEV;
+		if (pci_enable_device(pdev))
+			return -ENODEV;
+		epfix->regbase_phys = pci_resource_start(pdev, 0);
+		epfix->membase_phys = epfix->regbase_phys + E1356_REG_SIZE;
+	}
+	
+	fb_info.regbase_virt = ioremap_nocache(epfix->regbase_phys,
+					       E1356_REG_SIZE);
+
+	if (!fb_info.regbase_virt) {
+		printk("e1356fb: Can't remap %s register area.\n", name);
+		return -ENXIO;
+	}
+
+	regbase = fb_info.regbase_virt;
+	reg = &fb_info.reg;
+    
+	// Initialize the register pointers
+	reg->basic =         (reg_basic_t*)   (regbase + REG_BASE_BASIC);
+	reg->genio =         (reg_genio_t*)   (regbase + REG_BASE_GENIO);
+	reg->md_cfg =        (reg_mdcfg_t*)   (regbase + REG_BASE_MDCFG);
+	reg->clk_cfg =       (reg_clkcfg_t*)  (regbase + REG_BASE_CLKCFG);
+	reg->mem_cfg =       (reg_memcfg_t*)  (regbase + REG_BASE_MEMCFG);
+	reg->panel_cfg =     (reg_panelcfg_t*)(regbase + REG_BASE_PANELCFG);
+	reg->lcd_cfg =       (reg_dispcfg_t*) (regbase + REG_BASE_LCD_DISPCFG);
+	reg->crttv_cfg =     (reg_dispcfg_t*) (regbase + REG_BASE_CRTTV_DISPCFG);
+	reg->lcd_mode =      (reg_dispmode_t*)(regbase + REG_BASE_LCD_DISPMODE);
+	reg->crttv_mode =    (reg_dispmode_t*)(regbase + REG_BASE_CRTTV_DISPMODE);
+	reg->lcd_inkcurs =   (reg_inkcurs_t*) (regbase + REG_BASE_LCD_INKCURS);
+	reg->crttv_inkcurs = (reg_inkcurs_t*) (regbase + REG_BASE_CRTTV_INKCURS);
+	reg->bitblt =        (reg_bitblt_t*)  (regbase + REG_BASE_BITBLT);
+	reg->lut =           (reg_lut_t*)     (regbase + REG_BASE_LUT);
+	reg->pwr_save =      (reg_pwrsave_t*) (regbase + REG_BASE_PWRSAVE);
+	reg->misc =          (reg_misc_t*)    (regbase + REG_BASE_MISC);
+	reg->mediaplug =     (reg_mediaplug_t*)(regbase + REG_BASE_MEDIAPLUG);
+	reg->bitblt_data =   (u16*)           (regbase + REG_BASE_BITBLT_DATA);
+    
+	// Enable all register access
+	writeb(0, &reg->basic->misc);
+
+	rev_code = readb(&reg->basic->rev_code);
+	if ((rev_code >> 2) == 0x04) {
+		printk("Found EPSON1356 Display Controller\n");
+	}
+	else if ((rev_code >> 2) == 0x07) {
+		printk("Found EPSON13806 Display Controller\n");
+	}
+	else {
+		iounmap(fb_info.regbase_virt);
+		printk("e1356/806fb: %s not found, rev_code=0x%02x.\n",
+		       name, rev_code);
+		return -ENODEV;
+	}
+
+	fb_info.chip_rev = rev_code & 0x03;
+
+	// Determine frame-buffer size
+	switch (readb(&reg->md_cfg->md_cfg_stat0) >> 6) {
+	case 0:
+	case 2:
+		fb_info.fb_size = 0x80000;   /* 512K bytes */
+		break;
+	case 1:
+		if ((rev_code >> 2) == 7) /* 806 */
+			fb_info.fb_size = 0x140000;  /* 1.2M bytes */
+		else
+			fb_info.fb_size = 0x200000;  /* 2M bytes */
+		break;
+	default:
+		fb_info.fb_size = 0x200000;  /* 2M bytes */
+		break;
+	}
+
+	fb_info.membase_virt = ioremap_nocache(epfix->membase_phys,
+					       fb_info.fb_size);
+    
+	if (!fb_info.membase_virt) {
+		printk("e1356fb: Can't remap %s framebuffer.\n", name);
+		iounmap(fb_info.regbase_virt);
+		return -ENXIO;
+	}
+    
+	printk("e1356/806fb: Detected  %dKB framebuffer\n", 
+			(unsigned)fb_info.fb_size/1000);
+
+#ifdef CONFIG_MTRR
+	if (!epfix->nomtrr) {
+		fb_info.mtrr_idx = mtrr_add(epfix->membase_phys, fb_info.fb_size,
+					    MTRR_TYPE_WRCOMB, 1);
+		printk("e1356fb: MTRR's turned on\n");
+	}
+#endif
+    
+	if (!boot_fix.noaccel) {
+		/*
+		  Allocate a page for string BLTs. A 4K page is
+		  enough for a 256 character string at an 8x16 font.
+		*/
+		fb_info.putcs_buffer = (void*)__get_free_pages(GFP_KERNEL, 0);
+		if (fb_info.putcs_buffer == NULL) {
+			printk("e1356fb: Can't allocate putcs buffer\n");
+			goto unmap_ret_enxio;
+		}
+	}
+
+	// Begin SED1356 initialization
+
+	// disable display while initializing
+	writeb(0, &reg->misc->disp_mode);
+	// Set the GPIO1 and 2 to inputs
+	writeb(0, &reg->genio->gpio_cfg);
+	writeb(0, &reg->genio->gpio_ctrl);
+	if (fb_info.chip_rev == 7) /* 806 */
+		writeb(0, &reg->genio->gpio_ctrl2);
+
+	/*
+	 * Program the clocks
+	 */
+
+#ifdef CONFIG_MIPS_AU1000
+	if ((epfix->system == SYS_PB1000) || (epfix->system == SYS_PB1500))
+		epfix->busclk = get_au1000_lcd_clock();
+#endif
+	
+	if (epfix->busclk > 80000) {
+		printk("e1356fb: specified busclk too high\n");
+		goto ret_enxio;
+	}
+
+	epfix->mclk = mclk_cfg = 0;
+	if (epfix->system == SYS_PB1500) {
+		epfix->mclk = epfix->busclk;
+		mclk_cfg = 0x01;
+	}
+	else {
+		// Find the highest allowable MCLK
+		if (epfix->busclk <= MAX_PIXCLOCK && 
+				epfix->busclk > epfix->mclk) {
+			epfix->mclk = epfix->busclk;
+			mclk_cfg = 0x01;
+		}
+		if (epfix->clki <= MAX_PIXCLOCK && epfix->clki > epfix->mclk) {
+			epfix->mclk = epfix->clki;
+			mclk_cfg = 0x00;
+		}
+		if (epfix->busclk/2 <= MAX_PIXCLOCK && 
+				epfix->busclk/2 > epfix->mclk) {
+			epfix->mclk = epfix->busclk/2;
+			mclk_cfg = 0x11;
+		}
+		if (epfix->clki/2 <= MAX_PIXCLOCK && 
+				epfix->clki/2 > epfix->mclk) {
+			epfix->mclk = epfix->clki/2;
+			mclk_cfg = 0x10;
+		}
+	}
+	
+	if (!epfix->mclk) {
+		printk("e1356fb: couldn't find an allowable MCLK!\n");
+		goto ret_enxio;
+	}
+
+	// When changing mclk src, you must first set bit 4 to 1.
+	writeb(readb(&reg->clk_cfg->mem_clk_cfg) | 0x10,
+	       &reg->clk_cfg->mem_clk_cfg);
+	writeb(mclk_cfg, &reg->clk_cfg->mem_clk_cfg);
+
+	printk("e1356fb: clocks (kHz): busclk=%d mclk=%d clki=%d clki2=%d\n",
+	       epfix->busclk, epfix->mclk, epfix->clki, epfix->clki2);
+
+	// Set max pixel clock
+	switch (epfix->disp_type) {
+	case DISP_TYPE_LCD:
+	case DISP_TYPE_TFT:
+	case DISP_TYPE_CRT:
+		fb_info.max_pixclock = epfix->mclk;
+		break;
+	case DISP_TYPE_NTSC:
+	case DISP_TYPE_PAL:
+		fb_info.max_pixclock = (epfix->disp_type == DISP_TYPE_NTSC) ?
+			NTSC_PIXCLOCK : PAL_PIXCLOCK;
+		if (epfix->tv_filt & TV_FILT_FLICKER)
+			fb_info.max_pixclock *= 2;
+		break;
+	default:
+		printk("e1356fb: invalid specified display type\n");
+		goto ret_enxio;
+	}
+
+	periodMCLK = 1000000L / epfix->mclk;   // in nano-seconds
+	periodBCLK = 1000000L / epfix->busclk; // in nano-seconds
+	if (readb(&reg->md_cfg->md_cfg_stat1) & (1<<4))
+		periodBCLK *= 2;
+    
+	if ((epfix->system == SYS_PB1000) || (epfix->system == SYS_PB1500))
+		writeb(0x00, &reg->clk_cfg->cpu2mem_wait_sel);
+	else if (periodMCLK - 4 > periodBCLK)
+		writeb(0x02, &reg->clk_cfg->cpu2mem_wait_sel);
+	else if (2*periodMCLK - 4 > periodBCLK)
+		writeb(0x01, &reg->clk_cfg->cpu2mem_wait_sel);
+	else
+		writeb(0x00, &reg->clk_cfg->cpu2mem_wait_sel);
+
+	// Program memory config
+	if (epfix->mem_type < MEM_TYPE_EDO_2CAS ||
+	    epfix->mem_type > MEM_TYPE_EMBEDDED_SDRAM) {
+		printk("e1356fb: bad memory type specified\n");
+		goto ret_enxio;
+	}
+	writeb((u8)epfix->mem_type, &reg->mem_cfg->mem_cfg);
+
+	// calc closest refresh rate
+	rr_div = 7;
+	mclk_src = (mclk_cfg & 1) ? epfix->busclk : epfix->clki;
+	while ((mclk_src >> (6 + rr_div)) < epfix->mem_refresh)
+		if (--rr_div < 0) {
+			printk("e1356fb: can't set specified refresh rate\n");
+			goto ret_enxio;
+		}
+    
+	DPRINTK("refresh rate = %d kHz\n", (mclk_src >> (6 + rr_div)));
+
+	// add Suspend-Mode Refresh bits
+	if (epfix->mem_smr < MEM_SMR_CBR || epfix->mem_smr > MEM_SMR_NONE) {
+		printk("e1356fb: invalid specified suspend-mode refresh type\n");
+		goto ret_enxio;
+	}
+	writeb(rr_div | (epfix->mem_smr << 6), &reg->mem_cfg->dram_refresh);
+
+	// set DRAM speed
+	switch (epfix->mem_speed) {
+	case 50:
+		dram_timing = epfix->mclk >= 33000 ? 0x0101 : 0x0212;
+		break;
+	case 60:
+		if (epfix->mclk >= 30000)
+			dram_timing = 0x0101;
+		else if (epfix->mclk >= 25000)
+			dram_timing =
+				(epfix->mem_type == MEM_TYPE_EDO_2CAS ||
+				 epfix->mem_type == MEM_TYPE_EDO_2WE) ?
+				0x0212 : 0x0101;
+		else
+			dram_timing = 0x0212;
+		break;
+	case 70:
+		if (epfix->mclk >= 30000)
+			dram_timing = 0x0000;
+		else if (epfix->mclk >= 25000)
+			dram_timing = 0x0101;
+		else
+			dram_timing =
+				(epfix->mem_type == MEM_TYPE_EDO_2CAS ||
+				 epfix->mem_type == MEM_TYPE_EDO_2WE) ?
+				0x0212 : 0x0211;
+		break;
+	case 80:
+		if (epfix->mclk >= 25000)
+			dram_timing = 0x0100;
+		else
+			dram_timing = 0x0101;
+		break;
+	default:
+		printk("e1356fb: invalid specified memory speed\n");
+		goto ret_enxio;
+	}
+
+	writew(dram_timing, &reg->mem_cfg->dram_timings_ctrl0);
+    
+	currcon = -1;
+	if (!epfix->nohwcursor)
+		e1356fb_hwcursor_init(&fb_info);
+    
+	init_timer(&fb_info.cursor.timer);
+	fb_info.cursor.timer.function = do_flashcursor; 
+	fb_info.cursor.timer.data = (unsigned long)(&fb_info);
+	fb_info.cursor.state = CM_ERASE;
+	spin_lock_init(&fb_info.cursor.lock);
+    
+	strcpy(fb_info.fb_info.modename, "Epson "); 
+	strcat(fb_info.fb_info.modename, name);
+	fb_info.fb_info.changevar  = NULL;
+	fb_info.fb_info.node       = -1;
+
+	fb_info.fb_info.fbops      = &e1356fb_ops;
+	fb_info.fb_info.disp       = &fb_info.disp;
+	strcpy(fb_info.fb_info.fontname, epfix->fontname);
+	fb_info.fb_info.switch_con = &e1356fb_switch_con;
+	fb_info.fb_info.updatevar  = &e1356fb_updatevar;
+	fb_info.fb_info.blank      = &e1356fb_blank;
+	fb_info.fb_info.flags      = FBINFO_FLAG_DEFAULT;
+    
+	// Set-up display
+	// clear out unused stuff
+	writeb(0, &reg->panel_cfg->mod_rate);
+	writeb(0x01, &reg->lcd_mode->lcd_misc);
+	writeb(0, &reg->lcd_mode->fifo_high_thresh);
+	writeb(0, &reg->lcd_mode->fifo_low_thresh);
+	writeb(0, &reg->crttv_mode->fifo_high_thresh);
+	writeb(0, &reg->crttv_mode->fifo_low_thresh);
+    
+	switch (epfix->disp_type) {
+	case DISP_TYPE_LCD:
+		switch (epfix->panel_width) {
+		case 4: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x04); break;
+		case 8: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x14); break;
+		case 16: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x24); break;
+		default:
+			printk("e1356fb: invalid specified LCD panel data width\n");
+			goto ret_enxio;
+		}
+		writeb(btmp, &reg->panel_cfg->panel_type);
+		break;
+	case DISP_TYPE_TFT:
+		switch (epfix->panel_width) {
+		case 9: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x05); break;
+		case 12: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x15); break;
+		case 18: btmp = (u8)(((epfix->panel_el & 1)<<7) | 0x25); break;
+		default:
+			printk("e1356fb: invalid specified TFT panel data width\n");
+			goto ret_enxio;
+		}
+		writeb(btmp, &reg->panel_cfg->panel_type);
+		break;
+	case DISP_TYPE_CRT:
+		writeb(0x00, &reg->crttv_cfg->tv_output_ctrl);
+		break;
+	case DISP_TYPE_NTSC:
+	case DISP_TYPE_PAL:
+		if (epfix->tv_fmt < TV_FMT_COMPOSITE ||
+		    epfix->tv_fmt > TV_FMT_S_VIDEO) {
+			printk("e1356fb: invalid specified TV output format\n");
+			goto ret_enxio;
+		}
+		btmp = epfix->disp_type == DISP_TYPE_PAL ? 0x01 : 0x00;
+		btmp |= (epfix->tv_fmt == TV_FMT_S_VIDEO ? 0x02 : 0x00);
+		btmp |= ((epfix->tv_filt & TV_FILT_LUM) ? 0x10 : 0x00);
+		btmp |= ((epfix->tv_filt & TV_FILT_CHROM) ? 0x20 : 0x00);
+		writeb(btmp, &reg->crttv_cfg->tv_output_ctrl);
+		break;
+	}
+
+	memset(&var, 0, sizeof(var));
+	/*
+	 * If mode_option wasn't given at boot, assume all the boot
+	 * option timing parameters were specified individually, in
+	 * which case we convert par_to_var instead of calling
+	 * fb_find_mode.
+	 */
+	if (epfix->mode_option) {
+		struct fb_videomode* modedb, *dm;
+		int dbsize = e1356fb_get_mode(&fb_info, 640, 480, &modedb, &dm);
+
+		// first try the generic modedb
+		if (!fb_find_mode(&var, &fb_info.fb_info, epfix->mode_option,
+				  NULL, 0, NULL, boot_par.bpp)) {
+			printk("e1356fb: mode %s failed, trying e1356 modedb\n",
+			       epfix->mode_option);
+			// didn't work in generic modedb, try ours
+			if (!fb_find_mode(&var, &fb_info.fb_info,
+					  epfix->mode_option,
+					  modedb, dbsize, dm, boot_par.bpp)) {
+				printk("e1356fb: mode %s failed e1356 modedb too, sorry\n",
+				       epfix->mode_option);
+				
+				goto ret_enxio;
+			}
+		}
+
+		var.xres_virtual = boot_par.width_virt ?
+			boot_par.width_virt : boot_par.width;
+		var.yres_virtual = boot_par.height_virt ?
+			boot_par.height_virt : boot_par.height;
+	} else {
+		if (e1356fb_par_to_var(&var, &fb_info.default_par, &fb_info)) {
+			printk("e1356fb: boot option mode failed\n");
+			goto ret_enxio;
+		}
+	}
+    
+	if (boot_fix.noaccel)
+		var.accel_flags &= ~FB_ACCELF_TEXT;
+	else
+		var.accel_flags |= FB_ACCELF_TEXT;
+    
+	if (e1356fb_var_to_par(&var, &fb_info.default_par, &fb_info)) {
+		/*
+		 * Can't use the mode from the mode db or the default
+		 * mode or the boot options - give up
+		 */
+		printk("e1356fb: mode failed var_to_par\n");
+		goto ret_enxio;
+	}
+    
+	fb_info.disp.screen_base    = fb_info.membase_virt;
+	fb_info.disp.var            = var; // struct copy
+    
+	// here's where the screen is actually initialized and enabled
+	if (e1356fb_set_var(&var, -1, &fb_info.fb_info)) {
+		printk("e1356fb: can't set video mode\n");
+		goto ret_enxio;
+	}
+    
+	writeb(0, &reg->pwr_save->cfg);     // disable power-save mode
+	writeb(0, &reg->misc->cpu2mem_watchdog); // disable watchdog timer
+
+#ifdef E1356FB_VERBOSE_DEBUG
+	dump_fb(fb_info.membase_virt + 0x100000, 512);
+#endif
+
+	if (register_framebuffer(&fb_info.fb_info) < 0) {
+		writeb(0, &reg->misc->disp_mode); 
+		printk("e1356fb: can't register framebuffer\n");
+		goto ret_enxio;
+	}
+    
+	printk("fb%d: %s frame buffer device\n", 
+	       GET_FB_IDX(fb_info.fb_info.node),
+	       fb_info.fb_info.modename);
+    
+    
+	return 0;
+
+ ret_enxio:
+	free_pages((unsigned long)fb_info.putcs_buffer, 0);
+ unmap_ret_enxio:
+	iounmap(fb_info.regbase_virt);
+	iounmap(fb_info.membase_virt);
+	return -ENXIO;
+}
+
+/**
+ *	e1356fb_exit - Driver cleanup
+ *
+ *	Releases all resources allocated during the
+ *	course of the driver's lifetime.
+ *
+ *	FIXME - do results of fb_alloc_cmap need disposal?
+ */
+static void __exit
+e1356fb_exit (void)
+{
+	unregister_framebuffer(&fb_info.fb_info);
+	del_timer_sync(&fb_info.cursor.timer);
+
+#ifdef CONFIG_MTRR
+	if (!fb_info.fix.nomtrr) {
+		mtrr_del(fb_info.mtrr_idx, fb_info.fix.membase_phys,
+			 fb_info.fb_size);
+		printk("fb: MTRR's  turned off\n");
+	}
+#endif
+
+	free_pages((unsigned long)fb_info.putcs_buffer, 0);
+	iounmap(fb_info.regbase_virt);
+	iounmap(fb_info.membase_virt);
+}
+
+MODULE_AUTHOR("Steve Longerbeam <stevel@mvista.com>");
+MODULE_DESCRIPTION("SED1356 framebuffer device driver");
+
+#ifdef MODULE
+module_init(e1356fb_init);
+#endif
+module_exit(e1356fb_exit);
+
+
+void
+e1356fb_setup(char *options, int *ints)
+{
+	char* this_opt;
+    
+	memset(&boot_fix, 0, sizeof(struct e1356fb_fix));
+	memset(&boot_par, 0, sizeof(struct e1356fb_par));
+	boot_fix.system = -1;
+    
+	if (!options || !*options)
+		return;
+    
+	for(this_opt=strtok(options, ","); this_opt;
+	    this_opt=strtok(NULL, ",")) {
+		if (!strncmp(this_opt, "noaccel", 7)) {
+			boot_fix.noaccel = 1;
+		} else if (!strncmp(this_opt, "nopan", 5)) {
+			boot_fix.nopan = 1;
+		} else if (!strncmp(this_opt, "nohwcursor", 10)) {
+			boot_fix.nohwcursor = 1;
+		} else if (!strncmp(this_opt, "mmunalign:", 10)) {
+			boot_fix.mmunalign = simple_strtoul(this_opt+10,
+							    NULL, 0);
+#ifdef CONFIG_MTRR
+		} else if (!strncmp(this_opt, "nomtrr", 6)) {
+			boot_fix.nomtrr = 1;
+#endif
+		} else if (!strncmp(this_opt, "font:", 5)) {
+			strncpy(boot_fix.fontname, this_opt+5,
+				sizeof(boot_fix.fontname)-1);
+		} else if (!strncmp(this_opt, "regbase:", 8)) {
+			boot_fix.regbase_phys = simple_strtoul(this_opt+8,
+							       NULL, 0);
+		} else if (!strncmp(this_opt, "membase:", 8)) {
+			boot_fix.membase_phys = simple_strtoul(this_opt+8,
+							       NULL, 0);
+		} else if (!strncmp(this_opt, "memsp:", 6)) {
+			boot_fix.mem_speed = simple_strtoul(this_opt+6,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "memtyp:", 7)) {
+			boot_fix.mem_type = simple_strtoul(this_opt+7,
+							   NULL, 0);
+		} else if (!strncmp(this_opt, "memref:", 7)) {
+			boot_fix.mem_refresh = simple_strtoul(this_opt+7,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "memsmr:", 7)) {
+			boot_fix.mem_smr = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "busclk:", 7)) {
+			boot_fix.busclk = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "clki:", 5)) {
+			boot_fix.clki = simple_strtoul(this_opt+5, NULL, 0);
+		} else if (!strncmp(this_opt, "clki2:", 6)) {
+			boot_fix.clki2 = simple_strtoul(this_opt+6, NULL, 0);
+		} else if (!strncmp(this_opt, "display:", 8)) {
+			if (!strncmp(this_opt+8, "lcd", 3))
+				boot_fix.disp_type = DISP_TYPE_LCD;
+			else if (!strncmp(this_opt+8, "tft", 3))
+				boot_fix.disp_type = DISP_TYPE_TFT;
+			else if (!strncmp(this_opt+8, "crt", 3))
+				boot_fix.disp_type = DISP_TYPE_CRT;
+			else if (!strncmp(this_opt+8, "pal", 3))
+				boot_fix.disp_type = DISP_TYPE_PAL;
+			else if (!strncmp(this_opt+8, "ntsc", 4))
+				boot_fix.disp_type = DISP_TYPE_NTSC;
+		} else if (!strncmp(this_opt, "width:", 6)) {
+			boot_par.width = simple_strtoul(this_opt+6, NULL, 0);
+		} else if (!strncmp(this_opt, "height:", 7)) {
+			boot_par.height = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "bpp:", 4)) {
+			boot_par.bpp = simple_strtoul(this_opt+4, NULL, 0);
+			boot_par.cmap_len = (boot_par.bpp == 8) ? 256 : 16;
+		} else if (!strncmp(this_opt, "elpanel:", 8)) {
+			boot_fix.panel_el = simple_strtoul(this_opt+8,
+							   NULL, 0);
+		} else if (!strncmp(this_opt, "pdataw:", 7)) {
+			boot_fix.panel_width = simple_strtoul(this_opt+7,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "hndp:", 5)) {
+			boot_par.horiz_ndp = simple_strtoul(this_opt+5,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "vndp:", 5)) {
+			boot_par.vert_ndp = simple_strtoul(this_opt+5,
+							   NULL, 0);
+		} else if (!strncmp(this_opt, "hspol:", 6)) {
+			boot_par.hsync_pol = simple_strtoul(this_opt+6,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "vspol:", 6)) {
+			boot_par.vsync_pol = simple_strtoul(this_opt+6,
+							    NULL, 0);
+		} else if (!strncmp(this_opt, "hsstart:", 8)) {
+			boot_par.hsync_start = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "hswidth:", 8)) {
+			boot_par.hsync_width = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "vsstart:", 8)) {
+			boot_par.vsync_start = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "vswidth:", 8)) {
+			boot_par.vsync_width = simple_strtoul(this_opt+8,
+							      NULL, 0);
+		} else if (!strncmp(this_opt, "tvfilt:", 7)) {
+			boot_fix.tv_filt = simple_strtoul(this_opt+7, NULL, 0);
+		} else if (!strncmp(this_opt, "tvfmt:", 6)) {
+			boot_fix.tv_fmt = simple_strtoul(this_opt+6, NULL, 0);
+		} else if (!strncmp(this_opt, "system:", 7)) {
+			if (!strncmp(this_opt+7, "pb1000", 10)) {
+				boot_fix = systems[SYS_PB1000].fix;
+				boot_par = systems[SYS_PB1000].par;
+			} else if (!strncmp(this_opt+7, "pb1500", 7)) {
+				boot_fix = systems[SYS_PB1500].fix;
+				boot_par = systems[SYS_PB1500].par;
+			} else if (!strncmp(this_opt+7, "sdu1356", 7)) {
+				boot_fix = systems[SYS_SDU1356].fix;
+				boot_par = systems[SYS_SDU1356].par;
+			} else if (!strncmp(this_opt+7, "clio1050", 7)) {
+				boot_fix = systems[SYS_CLIO1050].fix;
+				boot_par = systems[SYS_CLIO1050].par;
+			}
+		} else {
+			boot_fix.mode_option = this_opt;
+		}
+	} 
+}
+
+
+/*
+ * FIXME: switching consoles could be dangerous. What if switching
+ * from a panel to a CRT/TV, or vice versa? More needs to be
+ * done here.
+ */
+static int
+e1356fb_switch_con(int con, struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	struct e1356fb_par par;
+	int old_con = currcon;
+	int set_par = 1;
+
+	//DPRINTK("\n");
+
+	/* Do we have to save the colormap? */
+	if (currcon>=0)
+		if (fb_display[currcon].cmap.len)
+			fb_get_cmap(&fb_display[currcon].cmap, 1,
+				    e1356fb_getcolreg, fb);
+   
+	currcon = con;
+	fb_display[currcon].var.activate = FB_ACTIVATE_NOW; 
+	e1356fb_var_to_par(&fb_display[con].var, &par, info);
+	if (old_con>=0 && vt_cons[old_con]->vc_mode!=KD_GRAPHICS) {
+		/* check if we have to change video registers */
+		struct e1356fb_par old_par;
+		e1356fb_var_to_par(&fb_display[old_con].var, &old_par, info);
+		if (!memcmp(&par,&old_par,sizeof(par)))
+			set_par = 0;	/* avoid flicker */
+	}
+	if (set_par)
+		e1356fb_set_par(&par, info);
+    
+	if (fb_display[con].dispsw && fb_display[con].conp)
+		fb_con.con_cursor(fb_display[con].conp, CM_ERASE);
+   
+	del_timer(&(info->cursor.timer));
+	fb_info.cursor.state=CM_ERASE; 
+   
+	if (!info->fix.nohwcursor) 
+		if (fb_display[con].conp)
+			e1356fb_createcursor( &fb_display[con] );
+   
+	info->cursor.redraw=1;
+   
+	e1356fb_set_dispsw(&fb_display[con], 
+			   info, 
+			   par.bpp,
+			   fb_display[con].var.accel_flags & FB_ACCELF_TEXT);
+   
+	e1356fb_install_cmap(&fb_display[con], fb);
+	e1356fb_updatevar(con, fb);
+   
+	return 1;
+}
+
+/* 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off */
+static void
+e1356fb_blank(int blank, struct fb_info *fb)
+{
+	struct fb_info_e1356 *info = (struct fb_info_e1356*)fb;
+	reg_dispmode_t* dispmode = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_mode : info->reg.crttv_mode;
+	reg_pwrsave_t* pwrsave = info->reg.pwr_save;
+
+	//DPRINTK("\n");
+
+	switch (blank) {
+	case 0:
+		// Get out of power save mode
+		writeb(0x00, &pwrsave->cfg);
+		writeb(readb(&dispmode->disp_mode) & ~0x80,
+		       &dispmode->disp_mode);
+		break;
+	case 1:
+		// Get out of power save mode
+		writeb(0x00, &pwrsave->cfg);
+		writeb(readb(&dispmode->disp_mode) | 0x80,
+		       &dispmode->disp_mode);
+		break;
+		// No support for turning off horiz or vert sync, so just treat
+		// it as a power off.
+	case 2:
+	case 3:
+	case 4:
+		writeb(0x01, &pwrsave->cfg);
+		break;
+	}
+}
+
+
+static int
+e1356fb_updatevar(int con, struct fb_info* fb)
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)fb;
+
+	//DPRINTK("\n");
+
+	if ((con==currcon) && (!i->fix.nopan)) 
+		do_pan_var(&fb_display[con].var,i);
+	return 0;
+}
+
+static int
+e1356fb_getcolreg(unsigned        regno, 
+		  unsigned*       red, 
+		  unsigned*       green,
+		  unsigned*       blue, 
+		  unsigned*       transp,
+		  struct fb_info* fb)
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)fb;
+
+	if (regno > i->current_par.cmap_len)
+		return 1;
+   
+	*red    = i->palette[regno].red; 
+	*green  = i->palette[regno].green; 
+	*blue   = i->palette[regno].blue; 
+	*transp = 0;
+   
+	return 0;
+}
+
+static int
+e1356fb_setcolreg(unsigned        regno, 
+		  unsigned        red, 
+		  unsigned        green,
+		  unsigned        blue, 
+		  unsigned        transp,
+		  struct fb_info* info)
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)info;
+
+	if (regno > 255)
+		return 1;
+
+	i->palette[regno].red    = red;
+	i->palette[regno].green  = green;
+	i->palette[regno].blue   = blue;
+   
+	switch(i->current_par.bpp) {
+#ifdef FBCON_HAS_CFB8
+	case 8:
+		do_setpalentry(i->reg.lut, regno,
+			       (u8)(red>>8), (u8)(green>>8), (u8)(blue>>8));
+		break;
+#endif
+#ifdef FBCON_HAS_CFB16
+	case 16:
+		i->fbcon_cmap16[regno] = (regno << 10) | (regno << 5) | regno;
+		break;
+#endif
+	default:
+		DPRINTK("bad depth %u\n", i->current_par.bpp);
+		break;
+	}
+	return 0;
+}
+
+static void
+e1356fb_install_cmap(struct display *d, struct fb_info *info) 
+{
+	struct fb_info_e1356* i = (struct fb_info_e1356*)info;
+
+	//DPRINTK("\n");
+
+	if (d->cmap.len) {
+		fb_set_cmap(&(d->cmap), 1, e1356fb_setcolreg, info);
+	} else {
+		fb_set_cmap(fb_default_cmap(i->current_par.cmap_len), 1,
+			    e1356fb_setcolreg, info);
+	}
+}
+
+static void
+e1356fb_createcursorshape(struct display* p) 
+{
+	int h,u;
+   
+	h = fontheight(p);
+
+	fb_info.cursor.type = p->conp->vc_cursor_type & CUR_HWMASK;
+
+	switch (fb_info.cursor.type) {
+	case CUR_NONE: 
+		u = h; 
+		break;
+	case CUR_UNDERLINE: 
+		u = h - 2; 
+		break;
+	case CUR_LOWER_THIRD: 
+		u = (h * 2) / 3; 
+		break;
+	case CUR_LOWER_HALF: 
+		u = h / 2; 
+		break;
+	case CUR_TWO_THIRDS: 
+		u = h / 3; 
+		break;
+	case CUR_BLOCK:
+	default:
+		u = 0;
+		break;
+	}
+    
+	fb_info.cursor.w = fontwidth_x8(p);
+	fb_info.cursor.u = u;
+	fb_info.cursor.h = h;
+}
+   
+static void
+e1356fb_createcursor(struct display *p)
+{
+	void* memcursor;
+	int y, w, h, u;
+    
+	e1356fb_createcursorshape(p);
+
+	h = fb_info.cursor.h;
+	w = fb_info.cursor.w;
+	u = fb_info.cursor.u;
+	memcursor = fb_info.membase_virt + fb_info.fb_size;
+
+	// write cursor to display memory
+	for (y=0; y<64; y++) {
+		if (y >= h || y < u) {
+			fbfill((u16*)memcursor, 0xaa, 16); // b/g
+		} else {
+			fbfill((u16*)memcursor, 0xff, w/4); // inverted b/g
+			fbfill((u16*)memcursor + w/4, 0xaa, (64 - w)/4); // b/g
+		}
+		memcursor += 16;
+	}
+}
+   
+static void
+e1356fb_hwcursor_init(struct fb_info_e1356* info)
+{
+	reg_inkcurs_t* inkcurs = (IS_PANEL(info->fix.disp_type)) ?
+		info->reg.lcd_inkcurs : info->reg.crttv_inkcurs;
+
+	fb_info.fb_size -= 1024;
+	// program cursor base address
+	writeb(0x00, &inkcurs->start_addr);
+	printk("e1356fb: reserving 1024 bytes for the hwcursor at %p\n",
+	       fb_info.membase_virt + fb_info.fb_size);
+}
+
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
+
+/*
+ * Return indicates whether a page was freed so caller can adjust rss
+ */
+static inline void forget_pte(pte_t page)
+{
+	if (!pte_none(page)) {
+		printk("forget_pte: old mapping existed!\n");
+		BUG();
+	}
+}
+
+/*
+ * maps a range of physical memory into the requested pages. the old
+ * mappings are removed. any references to nonexistent pages results
+ * in null mappings (currently treated as "copy-on-access")
+ */
+static inline void e1356_remap_pte_range(pte_t * pte, unsigned long address, unsigned long size,
+	phys_t phys_addr, pgprot_t prot)
+{
+	unsigned long end;
+
+	address &= ~PMD_MASK;
+	end = address + size;
+	if (end > PMD_SIZE)
+		end = PMD_SIZE;
+	do {
+		struct page *page;
+		pte_t oldpage;
+		oldpage = ptep_get_and_clear(pte);
+
+		page = virt_to_page(__va(phys_addr));
+		if ((!VALID_PAGE(page)) || PageReserved(page))
+ 			set_pte(pte, mk_pte_phys(phys_addr, prot));
+		forget_pte(oldpage);
+		address += PAGE_SIZE;
+		phys_addr += PAGE_SIZE;
+		pte++;
+	} while (address && (address < end));
+}
+
+static inline int e1356_remap_pmd_range(struct mm_struct *mm, pmd_t * pmd, unsigned long address, unsigned long size,
+	phys_t phys_addr, pgprot_t prot)
+{
+	unsigned long end;
+
+	address &= ~PGDIR_MASK;
+	end = address + size;
+	if (end > PGDIR_SIZE)
+		end = PGDIR_SIZE;
+	phys_addr -= address;
+	do {
+		pte_t * pte = pte_alloc(mm, pmd, address);
+		if (!pte)
+			return -ENOMEM;
+		e1356_remap_pte_range(pte, address, end - address, address + phys_addr, prot);
+		address = (address + PMD_SIZE) & PMD_MASK;
+		pmd++;
+	} while (address && (address < end));
+	return 0;
+}
+
+/*  Note: this is only safe if the mm semaphore is held when called. */
+static int e1356_remap_page_range(unsigned long from, phys_t phys_addr, unsigned long size, pgprot_t prot)
+{
+	int error = 0;
+	pgd_t * dir;
+	phys_t beg = from;
+	phys_t end = from + size;
+	struct mm_struct *mm = current->mm;
+
+	phys_addr -= from;
+	dir = pgd_offset(mm, from);
+	flush_cache_range(mm, beg, end);
+	if (from >= end)
+		BUG();
+
+	spin_lock(&mm->page_table_lock);
+	do {
+		pmd_t *pmd = pmd_alloc(mm, dir, from);
+		error = -ENOMEM;
+		if (!pmd)
+			break;
+		error = e1356_remap_pmd_range(mm, pmd, from, end - from, phys_addr + from, prot);
+		if (error)
+			break;
+		from = (from + PGDIR_SIZE) & PGDIR_MASK;
+		dir++;
+	} while (from && (from < end));
+	spin_unlock(&mm->page_table_lock);
+	flush_tlb_range(mm, beg, end);
+	return error;
+}
+#endif
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/epson1356fb.h linux_HEAD/drivers/video/epson1356fb.h
--- linux-2.6.11.6/drivers/video/epson1356fb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/drivers/video/epson1356fb.h	2002-08-15 11:27:24.000000000 +0200
@@ -0,0 +1,646 @@
+/*
+ *      epson1356fb.h  --  Epson SED1356 Framebuffer Driver
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	stevel@mvista.com or source@mvista.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifdef E1356FB_DEBUG
+#define DPRINTK(a,b...) printk(KERN_DEBUG "e1356fb: %s: " a, __FUNCTION__ , ## b)
+#else
+#define DPRINTK(a,b...)
+#endif 
+
+#define E1356_REG_SIZE  0x200000
+
+#define PICOS2KHZ(a) (1000000000UL/(a))
+#define KHZ2PICOS(a) (1000000000UL/(a))
+
+#define MAX_PIXCLOCK  40000 // KHz
+#define NTSC_PIXCLOCK 14318 // KHz
+#define PAL_PIXCLOCK  17734 // KHz
+
+/*
+ * Maximum percent errors between desired pixel clock and
+ * supported pixel clock. Lower-than and higher-than desired
+ * clock percent errors.
+ */
+#define MAX_PCLK_ERROR_LOWER  10
+#define MAX_PCLK_ERROR_HIGHER -1
+
+#define fontwidth_x8(p) (((fontwidth(p) + 7) >> 3) << 3)
+
+/*
+ * Register Structures
+ */
+
+// Basic
+#define REG_BASE_BASIC     0x00
+typedef struct {
+	u8 rev_code;           // 00
+	u8 misc;               // 01
+} reg_basic_t;
+
+// General IO Pins
+#define REG_BASE_GENIO     0x04
+typedef struct {
+	u8 gpio_cfg;           // 04
+	u8 gpio_cfg2;          // 05 SED13806
+	u8 spacer[2];          // 06
+	u8 gpio_ctrl;          // 08
+	u8 gpio_ctrl2;         // 09 SED13806
+} reg_genio_t;
+
+// MD Config Readback
+#define REG_BASE_MDCFG     0x0c
+typedef struct {
+	u8 md_cfg_stat0;       // 0C
+	u8 md_cfg_stat1;       // 0D
+} reg_mdcfg_t;
+
+// Clock Config
+#define REG_BASE_CLKCFG    0x10
+typedef struct {
+	u8 mem_clk_cfg;        // 10
+	u8 spacer1[3];         // 11
+	u8 lcd_pclk_cfg;       // 14
+	u8 spacer2[3];         // 15
+	u8 crttv_pclk_cfg;     // 18
+	u8 spacer3[3];         // 19
+	u8 mpclk_cfg;          // 1C
+	u8 spacer4;            // 1D
+	u8 cpu2mem_wait_sel;   // 1E
+} reg_clkcfg_t;
+
+// Memory Config
+#define REG_BASE_MEMCFG    0x20
+typedef struct {
+	u8 mem_cfg;            // 20
+	u8 dram_refresh;       // 21
+	u8 spacer[8];          // 22
+	u8 dram_timings_ctrl0; // 2A
+	u8 dram_timings_ctrl1; // 2B
+} reg_memcfg_t;
+
+// Panel Config
+#define REG_BASE_PANELCFG  0x30
+typedef struct {
+	u8 panel_type;         // 30
+	u8 mod_rate;           // 31
+} reg_panelcfg_t;
+
+// LCD and CRTTV Display Config
+#define REG_BASE_LCD_DISPCFG   0x32
+#define REG_BASE_CRTTV_DISPCFG 0x50
+typedef struct {
+	u8 hdw;                // 32 or 50
+	u8 spacer1;            // 33 or 51
+	u8 hndp;               // 34 or 52
+	u8 hsync_start;        // 35 or 53
+	u8 hsync_pulse;        // 36 or 54
+	u8 spacer2;            // 37 or 55
+	u8 vdh0;               // 38 or 56
+	u8 vdh1;               // 39 or 57
+	u8 vndp;               // 3A or 58
+	u8 vsync_start;        // 3B or 59
+	u8 vsync_pulse;        // 3C or 5A
+	u8 tv_output_ctrl;     // 5B (TV only)
+} reg_dispcfg_t;
+
+// LCD and CRTTV Display Mode
+#define REG_BASE_LCD_DISPMODE   0x40
+#define REG_BASE_CRTTV_DISPMODE 0x60
+typedef struct {
+	u8 disp_mode;          // 40 or 60
+	u8 lcd_misc;           // 41 (LCD only)
+	u8 start_addr0;        // 42 or 62
+	u8 start_addr1;        // 43 or 63
+	u8 start_addr2;        // 44 or 64
+	u8 spacer1;            // 45 or 65
+	u8 mem_addr_offset0;   // 46 or 66
+	u8 mem_addr_offset1;   // 47 or 67
+	u8 pixel_panning;      // 48 or 68
+	u8 spacer2;            // 49 or 69
+	u8 fifo_high_thresh;   // 4A or 6A
+	u8 fifo_low_thresh;    // 4B or 6B
+} reg_dispmode_t;
+
+// LCD and CRTTV Ink/Cursor
+#define REG_BASE_LCD_INKCURS   0x70
+#define REG_BASE_CRTTV_INKCURS 0x80
+typedef struct {
+	u8 ctrl;               // 70 or 80
+	u8 start_addr;         // 71 or 81
+	u8 x_pos0;             // 72 or 82
+	u8 x_pos1;             // 73 or 83
+	u8 y_pos0;             // 74 or 84
+	u8 y_pos1;             // 75 or 85
+	u8 blue0;              // 76 or 86
+	u8 green0;             // 77 or 87
+	u8 red0;               // 78 or 88
+	u8 spacer1;            // 79 or 89
+	u8 blue1;              // 7A or 8A
+	u8 green1;             // 7B or 8B
+	u8 red1;               // 7C or 8C
+	u8 spacer2;            // 7D or 8D
+	u8 fifo;               // 7E or 8E
+} reg_inkcurs_t;
+
+// BitBlt Config
+#define REG_BASE_BITBLT        0x100
+typedef struct {
+	u8 ctrl0;              // 100
+	u8 ctrl1;              // 101
+	u8 rop_code;           // 102
+	u8 operation;          // 103
+	u8 src_start_addr0;    // 104
+	u8 src_start_addr1;    // 105
+	u8 src_start_addr2;    // 106
+	u8 spacer1;            // 107
+	u8 dest_start_addr0;   // 108
+	u8 dest_start_addr1;   // 109
+	u8 dest_start_addr2;   // 10A
+	u8 spacer2;            // 10B
+	u8 mem_addr_offset0;   // 10C
+	u8 mem_addr_offset1;   // 10D
+	u8 spacer3[2];         // 10E
+	u8 width0;             // 110
+	u8 width1;             // 111
+	u8 height0;            // 112
+	u8 height1;            // 113
+	u8 bg_color0;          // 114
+	u8 bg_color1;          // 115
+	u8 spacer4[2];         // 116
+	u8 fg_color0;          // 118
+	u8 fg_color1;          // 119
+} reg_bitblt_t;
+
+// LUT
+#define REG_BASE_LUT           0x1e0
+typedef struct {
+	u8 mode;               // 1E0
+	u8 spacer1;            // 1E1
+	u8 addr;               // 1E2
+	u8 spacer2;            // 1E3
+	u8 data;               // 1E4
+} reg_lut_t;
+
+// Power Save Config
+#define REG_BASE_PWRSAVE       0x1f0
+typedef struct {
+	u8 cfg;                // 1F0
+	u8 status;             // 1F1
+} reg_pwrsave_t;
+
+// Misc
+#define REG_BASE_MISC          0x1f4
+typedef struct {
+	u8 cpu2mem_watchdog;   // 1F4
+	u8 spacer[7];          // 1F5
+	u8 disp_mode;          // 1FC
+} reg_misc_t;
+
+// MediaPlug
+#define REG_BASE_MEDIAPLUG     0x1000
+typedef struct {
+	u8 lcmd;               // 1000
+	u8 spacer1;            // 1001
+	u8 reserved_lcmd;      // 1002
+	u8 spacer2;            // 1003
+	u8 cmd;                // 1004
+	u8 spacer3;            // 1005
+	u8 reserved_cmd;       // 1006
+	u8 spacer4;            // 1007
+	u8 data;               // 1008
+} reg_mediaplug_t;
+
+// BitBlt data register. 16-bit access only
+#define REG_BASE_BITBLT_DATA   0x100000
+
+typedef struct {
+	reg_basic_t* basic;
+	reg_genio_t* genio;
+	reg_mdcfg_t* md_cfg;
+	reg_clkcfg_t* clk_cfg;
+	reg_memcfg_t* mem_cfg;
+	reg_panelcfg_t* panel_cfg;
+	reg_dispcfg_t* lcd_cfg;
+	reg_dispcfg_t* crttv_cfg;
+	reg_dispmode_t* lcd_mode;
+	reg_dispmode_t* crttv_mode;
+	reg_inkcurs_t* lcd_inkcurs;
+	reg_inkcurs_t* crttv_inkcurs;
+	reg_bitblt_t* bitblt;
+	reg_lut_t* lut;
+	reg_pwrsave_t* pwr_save;
+	reg_misc_t* misc;
+	reg_mediaplug_t* mediaplug;
+	u16* bitblt_data;
+} e1356_reg_t;
+
+
+/*--------------------------------------------------------*/
+
+enum mem_type_t {
+	MEM_TYPE_EDO_2CAS = 0,
+	MEM_TYPE_FPM_2CAS,
+	MEM_TYPE_EDO_2WE,
+	MEM_TYPE_FPM_2WE,
+	MEM_TYPE_EMBEDDED_SDRAM = 0x80
+};
+
+enum mem_smr_t {
+	MEM_SMR_CBR = 0,
+	MEM_SMR_SELF,
+	MEM_SMR_NONE
+};
+
+enum disp_type_t {
+	DISP_TYPE_LCD = 0,
+	DISP_TYPE_TFT,
+	DISP_TYPE_CRT,
+	DISP_TYPE_PAL,
+	DISP_TYPE_NTSC
+};
+
+/*
+ * Maximum timing values, as determined by the SED1356 register
+ * field sizes. All are indexed by display type, except
+ * max_hsync_start which is first indexed by color depth,
+ * then by display type.
+ */
+static const int max_hndp[5] = {256, 256, 512, 511, 510};
+static const int max_hsync_start[2][5] = {
+	{0, 252, 507, 505, 505}, // 8 bpp
+	{0, 254, 509, 507, 507}  // 16 bpp
+};
+static const int max_hsync_width[5] = {0, 128, 128, 0, 0};
+static const int max_vndp[5] = {64, 64, 128, 128, 128};
+static const int max_vsync_start[5] = {0, 64, 128, 128, 128};
+static const int max_vsync_width[5] = {0, 8, 8, 0, 0};
+
+#define IS_PANEL(disp_type) \
+    (disp_type == DISP_TYPE_LCD || disp_type == DISP_TYPE_TFT)
+#define IS_CRT(disp_type) (disp_type == DISP_TYPE_CRT)
+#define IS_TV(disp_type) \
+    (disp_type == DISP_TYPE_NTSC || disp_type == DISP_TYPE_PAL)
+
+
+enum tv_filters_t {
+	TV_FILT_LUM = 1,
+	TV_FILT_CHROM = 2,
+	TV_FILT_FLICKER = 4
+};
+
+enum tv_format_t {
+	TV_FMT_COMPOSITE = 0,
+	TV_FMT_S_VIDEO
+};
+
+
+struct e1356fb_fix {
+	int system;       // the number of a pre-packaged system
+	u64 regbase_phys; // phys start address of registers
+	u64 membase_phys; // phys start address of fb memory
+
+	// Memory parameters
+	int mem_speed;    // speed: 50, 60, 70, or 80 (nsec)
+	int mem_type;     // mem type: EDO-2CAS, FPM-2CAS, EDO-2WE, FPM-2WE
+	int mem_refresh;  // refresh rate in KHz
+	int mem_smr;      // suspend mode refresh: CAS_BEFORE_RAS, SELF, or NONE
+	// Clocks
+	int busclk;       // BUSCLK frequency, in KHz
+	int mclk;         // MCLK freq, in KHz, will either be BUSCLK or BUSCLK/2
+	int clki;         // CLKI frequency, in KHz
+	int clki2;        // CLKI2 frequency, in KHz
+
+	int disp_type;    // LCD, TFT, CRT, PAL, or NTSC
+
+	// TV Options
+	u8  tv_filt;      // TV Filter mask, LUM, CHROM, and FLICKER
+	int tv_fmt;       // TV output format, COMPOSITE or S_VIDEO
+    
+	// Panel (LCD,TFT) Options
+	int panel_el;     // enable support for EL-type panels
+	int panel_width;  // Panel data width: LCD: 4/8/16, TFT: 9/12/18
+    
+	// Misc
+	int noaccel;
+	int nopan;
+#ifdef CONFIG_MTRR
+	int nomtrr;
+#endif
+	int nohwcursor;
+	int mmunalign;    // force unaligned returned VA in mmap()
+	char fontname[40];
+
+	char *mode_option;
+};
+
+
+typedef struct {
+	int pixclk_d;     // Desired Pixel Clock, KHz
+	int pixclk;       // Closest supported clock to desired clock, KHz
+	int error;        // percent error between pixclock and pixclock_d
+	int clksrc;       // equal to busclk, mclk, clki, or clki2, KHz
+	int divisor;      // pixclk = clksrc/divisor, where divisor = 1,2,3, or 4
+	u8  pixclk_bits;  // pixclock register value for above settings
+} pixclock_info_t;
+
+
+struct e1356fb_par {
+	int width;
+	int height;
+	int width_virt;   // Width in pixels
+	int height_virt;  // Height in lines
+	int bpp;          // bits-per-pixel
+	int Bpp;          // Bytes-per-pixel
+
+	// Timing
+	pixclock_info_t ipclk;
+	int horiz_ndp;    // Horiz. Non-Display Period, pixels
+	int vert_ndp;     // Vert. Non-Display Period, lines
+	int hsync_pol;    // Polarity of horiz. sync signal (HRTC for CRT/TV,
+	// FPLINE for TFT). 0=active lo, 1=active hi
+	int hsync_start;  // Horiz. Sync Start position, pixels
+	int hsync_width;  // Horiz. Sync Pulse width, pixels
+	int hsync_freq;   // calculated horizontal sync frequency
+	int vsync_pol;    // Polarity of vert. sync signal (VRTC for CRT/TV,
+	// FPFRAME for TFT). 0=active lo, 1=active hi
+	int vsync_start;  // Vert. Sync Start position, lines
+	int vsync_width;  // Vert. Sync Pulse width, lines
+	int vsync_freq;   // calculated vertical sync frequency
+
+	int cmap_len;     // color-map length
+};
+
+
+
+struct fb_info_e1356 {
+	struct fb_info fb_info;
+
+	void *regbase_virt;
+	unsigned long regbase_size;
+	void *membase_virt;
+	unsigned long fb_size;
+
+	e1356_reg_t reg;
+
+	void* putcs_buffer;
+    
+	int max_pixclock;   // Max supported pixel clock, KHz
+	int open, mmaped;   // open count, is mmap'ed
+	
+	u8 chip_rev;
+    
+#ifdef CONFIG_MTRR
+	int mtrr_idx;
+#endif
+
+#ifdef SHADOW_FRAME_BUFFER
+	struct {
+		void* fb;
+		struct timer_list timer;
+	} shadow;
+#endif
+
+	struct { unsigned red, green, blue, pad; } palette[256];
+	struct display disp;
+
+#if defined(FBCON_HAS_CFB16)
+	u16 fbcon_cmap16[16];
+#endif
+    
+	struct {
+		int type;
+		int state;
+		int w,h,u;
+		int x,y,redraw;
+		unsigned long enable,disable;
+		struct timer_list timer;
+		spinlock_t lock; 
+	} cursor;
+ 
+	struct e1356fb_fix fix;
+	struct e1356fb_par default_par;
+	struct e1356fb_par current_par;
+};
+
+
+// The following are boot options for particular SED1356-based target systems
+
+enum {
+	SYS_NULL,
+	SYS_PB1000,
+	SYS_PB1500,
+	SYS_SDU1356,
+	SYS_CLIO1050,
+	NUM_SYSTEMS // must be last
+};
+
+static struct {
+	struct e1356fb_fix fix;
+	struct e1356fb_par par;
+} systems[NUM_SYSTEMS] = {
+
+	/*
+	 * NULL system to help us detect missing options
+ 	 * when the driver is compiled as a module.
+	 */
+	{
+		{   // fix
+			SYS_NULL,
+		},
+		{   // par
+		}
+	},
+
+	/*
+	 * Alchemy Pb1000 evaluation board, SED1356
+	 */
+	{
+		{   // fix
+			SYS_PB1000,
+			/*
+			 * Note!: these are "pseudo" physical addresses;
+			 * the SED1356 is not actually mapped here, but rather
+			 * at the 36-bit address of 0xE 0000 0000. There is an
+			 * ugly hack in the Au1000 TLB refill handler that will
+			 * translate pte_t's in the range 0xE000 0000 -->
+			 * 0xEFFF FFFF to the 36-bit range 0xE 0000 0000 -->
+			 * 0xE 0FFF FFFF. The long-term solution is to support
+			 * 36-bit physical addresses in linux-mips32 mm, since
+			 * the mips32 specification specifically supports this.
+			 */
+			0xE00000000, 0xE00200000,
+			60, MEM_TYPE_EDO_2CAS, 64, MEM_SMR_CBR,
+			0, 0,   // BUSCLK and MCLK are calculated at run-time
+			40000, 14318, // CLKI, CLKI2
+#ifdef CONFIG_PB1000_CRT
+			DISP_TYPE_CRT,
+			0, 0, // TV Options
+			0, 0, // Panel options
+#elif defined (CONFIG_PB1000_NTSC)
+			DISP_TYPE_NTSC,
+			TV_FILT_FLICKER|TV_FILT_LUM|TV_FILT_CHROM,
+			TV_FMT_COMPOSITE,
+			0, 0, // Panel options
+#elif defined (CONFIG_PB1000_TFT)
+			DISP_TYPE_TFT,
+			0, 0, // TV Options
+			0, 12, // Panel options, EL panel?, data width?
+#else
+			DISP_TYPE_PAL,
+			TV_FILT_FLICKER|TV_FILT_LUM|TV_FILT_CHROM,
+			TV_FMT_COMPOSITE,
+			0, 0, // Panel options
+#endif
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"800x600@60"
+		},
+		{   // par
+			0, 0, 800, 600, 8, 1,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			256
+		}
+	},
+
+	/*
+	 * Alchemy Pb1500 evaluation board, SED13806
+	 */
+	{
+		{   // fix
+			SYS_PB1500,
+			/*
+			 * Note!: these are "pseudo" physical addresses;
+			 * the SED1356 is not actually mapped here, but rather
+			 * at the 36-bit address of 0xE 0000 0000. There is an
+			 * ugly hack in the Au1000 TLB refill handler that will
+			 * translate pte_t's in the range 0xE000 0000 -->
+			 * 0xEFFF FFFF to the 36-bit range 0xE 0000 0000 -->
+			 * 0xE 0FFF FFFF. The long-term solution is to support
+			 * 36-bit physical addresses in linux-mips32 mm, since
+			 * the mips32 specification specifically supports this.
+			 */
+			0xE1B000000, 0xE1B200000,
+			50, MEM_TYPE_EMBEDDED_SDRAM, 64, MEM_SMR_CBR,
+			0, 0,   // BUSCLK and MCLK are calculated at run-time
+			40000, 14318, // CLKI, CLKI2
+#ifdef CONFIG_PB1500_CRT
+			DISP_TYPE_CRT,
+			0, 0, // TV Options
+			0, 0, // Panel options
+#else
+			DISP_TYPE_TFT,
+			0, 0, // TV Options
+			0, 12, // Panel options, EL panel?, data width?
+#endif
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"800x600@60"
+		},
+		{   // par
+			0, 0, 800, 600, 8, 1,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			256
+		}
+	},
+
+	/*
+	 * Epson SDU1356B0C PCI eval card. These settings assume the
+	 * card is configured for PCI, the MediaPlug is disabled,
+	 * and the onboard clock synthesizer is at the power-up
+	 * clock settings.
+	 */
+	{
+		{   // fix
+			SYS_SDU1356,
+			0x0, 0x0,  // addresses obtained from PCI config space
+			// FIXME: just guess for now
+			60, MEM_TYPE_EDO_2CAS, 64, MEM_SMR_CBR,
+			33000, 0, 40000, 25175, // BUSCLK, MCLK, CLKI, CLKI2
+			DISP_TYPE_CRT,
+			0, 0,
+			0, 0,
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"800x600@60"
+		},
+		{   // par
+			0, 0, 1024, 768, 8, 1,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			256
+		}
+	},
+
+	/*
+	 * Vadem Clio 1050 - this is for the benefit of the Linux-VR project.
+	 * FIXME: Most of these settings are just guesses, until I can get a
+	 * Clio 1050 and dump the registers that WinCE has setup.
+	 */
+	{
+		{   // fix
+			SYS_CLIO1050,
+			0x0a000000, 0x0a200000,
+			60, MEM_TYPE_EDO_2CAS, 64, MEM_SMR_CBR,
+			40000, 40000, 14318, 14318,
+			DISP_TYPE_TFT,
+			0, 0,
+			0, 16,
+			0, 0,
+#ifdef CONFIG_MTRR
+			0,
+#endif
+			0,
+			0,
+			{0},
+			"640x480@85"
+		},
+		{   // par
+			0, 0, 1024, 768, 16, 2,
+			// timings will be set by modedb
+			{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			16
+		}
+	}
+};
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/gbefb.c linux_HEAD/drivers/video/gbefb.c
--- linux-2.6.11.6/drivers/video/gbefb.c	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/drivers/video/gbefb.c	2005-03-04 20:39:34.000000000 +0100
@@ -1065,7 +1065,7 @@ static void __devexit gbefb_remove_sysfs
 	device_remove_file(dev, &dev_attr_revision);
 }
 
-static void gbefb_create_sysfs(struct device *dev)
+static void gbefb_create_sysfs(struct device *dev) 
 {
 	device_create_file(dev, &dev_attr_size);
 	device_create_file(dev, &dev_attr_revision);
@@ -1126,7 +1126,7 @@ static int __init gbefb_probe(struct dev
 	gbefb_setup(options);
 #endif
 
-	if (!request_mem_region(GBE_BASE, sizeof(struct sgi_gbe), "GBE")) {
+	if (!request_region(GBE_BASE, sizeof(struct sgi_gbe), "GBE")) {
 		printk(KERN_ERR "gbefb: couldn't reserve mmio region\n");
 		ret = -EBUSY;
 		goto out_release_framebuffer;
@@ -1152,12 +1152,24 @@ static int __init gbefb_probe(struct dev
 	if (gbe_mem_phys) {
 		/* memory was allocated at boot time */
 		gbe_mem = ioremap_nocache(gbe_mem_phys, gbe_mem_size);
+		if (!gbe_mem) {
+			printk(KERN_ERR "gbefb: couldn't map framebuffer\n");
+			ret = -ENOMEM;
+			goto out_tiles_free;
+		}
+
 		gbe_dma_addr = 0;
 	} else {
 		/* try to allocate memory with the classical allocator
 		 * this has high chance to fail on low memory machines */
 		gbe_mem = dma_alloc_coherent(NULL, gbe_mem_size, &gbe_dma_addr,
 					     GFP_KERNEL);
+		if (!gbe_mem) {
+			printk(KERN_ERR "gbefb: couldn't allocate framebuffer memory\n");
+			ret = -ENOMEM;
+			goto out_tiles_free;
+		}
+
 		gbe_mem_phys = (unsigned long) gbe_dma_addr;
 	}
 
@@ -1165,12 +1177,6 @@ static int __init gbefb_probe(struct dev
 	mtrr_add(gbe_mem_phys, gbe_mem_size, MTRR_TYPE_WRCOMB, 1);
 #endif
 
-	if (!gbe_mem) {
-		printk(KERN_ERR "gbefb: couldn't map framebuffer\n");
-		ret = -ENXIO;
-		goto out_tiles_free;
-	}
-
 	/* map framebuffer memory into tiles table */
 	for (i = 0; i < (gbe_mem_size >> TILE_SHIFT); i++)
 		gbe_tiles.cpu[i] = (gbe_mem_phys >> TILE_SHIFT) + i;
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/maxinefb.c linux_HEAD/drivers/video/maxinefb.c
--- linux-2.6.11.6/drivers/video/maxinefb.c	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/drivers/video/maxinefb.c	2004-10-12 19:31:18.000000000 +0200
@@ -109,7 +109,7 @@ static struct fb_ops maxinefb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_get_fix	= gen_get_fix,
 	.fb_get_var	= gen_get_var,
-	.fb_setcolreg	= maxinefb_setcolreg,
+	.fb_setcolreg	= maxinefb_setcolreg,     
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/pmag-aa-fb.c linux_HEAD/drivers/video/pmag-aa-fb.c
--- linux-2.6.11.6/drivers/video/pmag-aa-fb.c	2005-03-26 04:28:29.000000000 +0100
+++ linux_HEAD/drivers/video/pmag-aa-fb.c	2003-12-18 22:47:09.000000000 +0100
@@ -478,7 +478,7 @@ static int __exit exit_one(int slot)
 	return 0;
 }
 
-/*
+/* 
  * Initialise the framebuffer.
  */
 int __init pmagaafb_init(void)
diff -urpNX dontdiff linux-2.6.11.6/drivers/video/pmag-ba-fb.c linux_HEAD/drivers/video/pmag-ba-fb.c
--- linux-2.6.11.6/drivers/video/pmag-ba-fb.c	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/drivers/video/pmag-ba-fb.c	2004-10-12 19:31:18.000000000 +0200
@@ -66,7 +66,7 @@ static struct fb_var_screeninfo pmagbafb
 	.accel		= FB_ACCEL_NONE,
 	.vmode		= FB_VMODE_NONINTERLACED,
 };
-
+                                                                                
 static struct fb_fix_screeninfo pmagbafb_fix = {
 	.id		= "PMAG-BA",
 	.smem_len	= (1024 * 864),
diff -urpNX dontdiff linux-2.6.11.6/fs/eventpoll.c linux_HEAD/fs/eventpoll.c
--- linux-2.6.11.6/fs/eventpoll.c	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/fs/eventpoll.c	2005-03-21 20:04:48.000000000 +0100
@@ -640,8 +640,10 @@ asmlinkage long sys_epoll_wait(int epfd,
 		return -EINVAL;
 
 	/* Verify that the area passed by the user is writeable */
-	if ((error = verify_area(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))))
+	if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) {
+		error = -EFAULT;
 		goto eexit_1;
+	}
 
 	/* Get the "struct file *" for the eventpoll file */
 	error = -EBADF;
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/bootinfo.h linux_HEAD/include/asm-mips/bootinfo.h
--- linux-2.6.11.6/include/asm-mips/bootinfo.h	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/include/asm-mips/bootinfo.h	2005-03-01 15:00:56.000000000 +0100
@@ -177,6 +177,8 @@
 #define  MACH_MTX1		7       /* 4G MTX-1 Au1500-based board */
 #define  MACH_PB1550		8       /* Au1550-based eval board */
 #define  MACH_DB1550		9       /* Au1550-based eval board */
+#define  MACH_PB1200		10       /* Au1200-based eval board */
+#define  MACH_DB1200		11       /* Au1200-based eval board */
 
 /*
  * Valid machtype for group NEC_VR41XX
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/break.h linux_HEAD/include/asm-mips/break.h
--- linux-2.6.11.6/include/asm-mips/break.h	2005-03-26 04:28:25.000000000 +0100
+++ linux_HEAD/include/asm-mips/break.h	2005-02-17 21:50:43.000000000 +0100
@@ -28,6 +28,7 @@
 #define BRK_NORLD	10	/* No rld found - not used by Linux/MIPS */
 #define _BRK_THREADBP	11	/* For threads, user bp (used by debuggers) */
 #define BRK_BUG		512	/* Used by BUG() */
+#define BRK_KDB		513	/* Used in KDB_ENTER() */
 #define BRK_MULOVF	1023	/* Multiply overflow */
 
 #endif /* __ASM_BREAK_H */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/cacheflush.h linux_HEAD/include/asm-mips/cacheflush.h
--- linux-2.6.11.6/include/asm-mips/cacheflush.h	2005-04-03 00:13:08.000000000 +0200
+++ linux_HEAD/include/asm-mips/cacheflush.h	2005-03-21 20:04:58.000000000 +0100
@@ -49,17 +49,29 @@ static inline void flush_dcache_page(str
 
 extern void (*flush_icache_page)(struct vm_area_struct *vma,
 	struct page *page);
-extern void (*flush_icache_range)(unsigned long start, unsigned long end);
+extern void (*flush_icache_range)(unsigned long __user start,
+	unsigned long __user end);
 #define flush_cache_vmap(start, end)		flush_cache_all()
 #define flush_cache_vunmap(start, end)		flush_cache_all()
 
-#define copy_to_user_page(vma, page, vaddr, dst, src, len)		\
-do {									\
-	memcpy(dst, (void *) src, len);					\
-	flush_icache_page(vma, page);					\
-} while (0)
-#define copy_from_user_page(vma, page, vaddr, dst, src, len)		\
-	memcpy(dst, src, len)
+static inline void copy_to_user_page(struct vm_area_struct *vma,
+	struct page *page, unsigned long vaddr, void *dst, const void *src,
+	unsigned long len)
+{
+	if (cpu_has_dc_aliases)
+		flush_cache_page(vma, vaddr);
+	memcpy(dst, src, len);
+	flush_icache_page(vma, page);
+}
+
+static inline void copy_from_user_page(struct vm_area_struct *vma,
+	struct page *page, unsigned long vaddr, void *dst, const void *src,
+	unsigned long len)
+{
+	if (cpu_has_dc_aliases)
+		flush_cache_page(vma, vaddr);
+	memcpy(dst, src, len);
+}
 
 extern void (*flush_cache_sigtramp)(unsigned long addr);
 extern void (*flush_icache_all)(void);
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/cobalt/cobalt.h linux_HEAD/include/asm-mips/cobalt/cobalt.h
--- linux-2.6.11.6/include/asm-mips/cobalt/cobalt.h	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/include/asm-mips/cobalt/cobalt.h	2005-03-04 20:36:14.000000000 +0100
@@ -19,18 +19,21 @@
  *     9  - PCI
  *    14  - IDE0
  *    15  - IDE1
- *
+ */
+#define COBALT_QUBE_SLOT_IRQ	9
+
+/*
  * CPU IRQs  are 16 ... 23
  */
 #define COBALT_TIMER_IRQ	18
 #define COBALT_SCC_IRQ          19		/* pre-production has 85C30 */
 #define COBALT_RAQ_SCSI_IRQ	19
 #define COBALT_ETH0_IRQ		19
+#define COBALT_QUBE1_ETH0_IRQ	20
 #define COBALT_ETH1_IRQ		20
 #define COBALT_SERIAL_IRQ	21
 #define COBALT_SCSI_IRQ         21
 #define COBALT_VIA_IRQ		22		/* Chained to VIA ISA bridge */
-#define COBALT_QUBE_SLOT_IRQ	23
 
 /*
  * PCI configuration space manifest constants.  These are wired into
@@ -69,13 +72,16 @@
  * Most of this really should go into a separate GT64111 header file.
  */
 #define GT64111_IO_BASE		0x10000000UL
+#define GT64111_IO_END		0x11ffffffUL
+#define GT64111_MEM_BASE	0x12000000UL
+#define GT64111_MEM_END		0x13ffffffUL
 #define GT64111_BASE		0x14000000UL
-#define GALILEO_REG(ofs)	(KSEG0 + GT64111_BASE + (unsigned long)(ofs))
+#define GALILEO_REG(ofs)	CKSEG1ADDR(GT64111_BASE + (unsigned long)(ofs))
 
 #define GALILEO_INL(port)	(*(volatile unsigned int *) GALILEO_REG(port))
 #define GALILEO_OUTL(val, port)						\
 do {									\
-	*(volatile unsigned int *) GALILEO_REG(port) = (port);		\
+	*(volatile unsigned int *) GALILEO_REG(port) = (val);		\
 } while (0)
 
 #define GALILEO_T0EXP		0x0100
@@ -86,5 +92,21 @@ do {									\
 	GALILEO_OUTL((0x80000000 | (PCI_SLOT (devfn) << 11) |		\
 		(PCI_FUNC (devfn) << 8) | (where)), GT_PCI0_CFGADDR_OFS)
 
+#define COBALT_LED_PORT		(*(volatile unsigned char *) CKSEG1ADDR(0x1c000000))
+# define COBALT_LED_BAR_LEFT	(1 << 0)	/* Qube */
+# define COBALT_LED_BAR_RIGHT	(1 << 1)	/* Qube */
+# define COBALT_LED_WEB		(1 << 2)	/* RaQ */
+# define COBALT_LED_POWER_OFF	(1 << 3)	/* RaQ */
+# define COBALT_LED_RESET	0x0f
+
+#define COBALT_KEY_PORT		((~*(volatile unsigned int *) CKSEG1ADDR(0x1d000000) >> 24) & COBALT_KEY_MASK)
+# define COBALT_KEY_CLEAR	(1 << 1)
+# define COBALT_KEY_LEFT	(1 << 2)
+# define COBALT_KEY_UP		(1 << 3)
+# define COBALT_KEY_DOWN	(1 << 4)
+# define COBALT_KEY_RIGHT	(1 << 5)
+# define COBALT_KEY_ENTER	(1 << 6)
+# define COBALT_KEY_SELECT	(1 << 7)
+# define COBALT_KEY_MASK	0xfe
 
 #endif /* __ASM_COBALT_H */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/cobalt/mach-gt64120.h linux_HEAD/include/asm-mips/cobalt/mach-gt64120.h
--- linux-2.6.11.6/include/asm-mips/cobalt/mach-gt64120.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/include/asm-mips/cobalt/mach-gt64120.h	2005-02-21 17:24:02.000000000 +0100
@@ -0,0 +1 @@
+/* there's something here ... in the dark */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/cpu.h linux_HEAD/include/asm-mips/cpu.h
--- linux-2.6.11.6/include/asm-mips/cpu.h	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/include/asm-mips/cpu.h	2005-03-01 15:00:56.000000000 +0100
@@ -22,12 +22,17 @@
    spec.
 */
 
-#define PRID_COMP_LEGACY       0x000000
-#define PRID_COMP_MIPS         0x010000
-#define PRID_COMP_BROADCOM     0x020000
-#define PRID_COMP_ALCHEMY      0x030000
-#define PRID_COMP_SIBYTE       0x040000
-#define PRID_COMP_SANDCRAFT    0x050000
+#define PRID_COMP_LEGACY	0x000000
+#define PRID_COMP_MIPS		0x010000
+#define PRID_COMP_BROADCOM	0x020000
+#define PRID_COMP_ALCHEMY	0x030000
+#define PRID_COMP_SIBYTE	0x040000
+#define PRID_COMP_SANDCRAFT	0x050000
+#define PRID_COMP_PHILIPS	0x060000
+#define PRID_COMP_TOSHIBA	0x070000
+#define PRID_COMP_LSI		0x080000
+#define PRID_COMP_LEXRA		0x0b0000
+
 
 /*
  * Assigned values for the product ID register.  In order to detect a
@@ -177,7 +182,8 @@
 #define CPU_VR4133		56
 #define CPU_AU1550		57
 #define CPU_24K			58
-#define CPU_LAST		58
+#define CPU_AU1200		59
+#define CPU_LAST		59
 
 /*
  * ISA Level encodings
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/elf.h linux_HEAD/include/asm-mips/elf.h
--- linux-2.6.11.6/include/asm-mips/elf.h	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/include/asm-mips/elf.h	2005-03-17 22:10:54.000000000 +0100
@@ -225,18 +225,17 @@ do {	current->thread.mflags &= ~MF_ABI_M
 #endif /* CONFIG_MIPS64 */
 
 extern void dump_regs(elf_greg_t *, struct pt_regs *regs);
+extern int dump_task_regs (struct task_struct *, elf_gregset_t *);
 extern int dump_task_fpu(struct task_struct *, elf_fpregset_t *);
 
 #define ELF_CORE_COPY_REGS(elf_regs, regs)			\
 	dump_regs((elf_greg_t *)&(elf_regs), regs);
+#define ELF_CORE_COPY_TASK_REGS(tsk, elf_regs) dump_task_regs(tsk, elf_regs)
 #define ELF_CORE_COPY_FPREGS(tsk, elf_fpregs)			\
 	dump_task_fpu(tsk, elf_fpregs)
 
 #endif /* __KERNEL__ */
 
-/* This one accepts IRIX binaries.  */
-#define irix_elf_check_arch(hdr)	((hdr)->e_flags & RHF_SGI_ONLY)
-
 #define USE_ELF_CORE_DUMP
 #define ELF_EXEC_PAGESIZE	PAGE_SIZE
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/fixmap.h linux_HEAD/include/asm-mips/fixmap.h
--- linux-2.6.11.6/include/asm-mips/fixmap.h	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/include/asm-mips/fixmap.h	2005-02-17 21:50:43.000000000 +0100
@@ -107,4 +107,11 @@ static inline unsigned long virt_to_fix(
 	return __virt_to_fix(vaddr);
 }
 
+/*
+ * Called from pgtable_init()
+ */
+extern void fixrange_init(unsigned long start, unsigned long end,
+        pgd_t *pgd_base);
+
+
 #endif
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/fpu_emulator.h linux_HEAD/include/asm-mips/fpu_emulator.h
--- linux-2.6.11.6/include/asm-mips/fpu_emulator.h	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/include/asm-mips/fpu_emulator.h	2005-02-28 22:37:48.000000000 +0100
@@ -35,4 +35,6 @@ struct mips_fpu_emulator_private {
 	} stats;
 };
 
+extern struct mips_fpu_emulator_private fpuemuprivate;
+
 #endif /* _ASM_FPU_EMULATOR_H */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/hazards.h linux_HEAD/include/asm-mips/hazards.h
--- linux-2.6.11.6/include/asm-mips/hazards.h	2005-03-26 04:28:25.000000000 +0100
+++ linux_HEAD/include/asm-mips/hazards.h	2005-03-03 21:03:38.000000000 +0100
@@ -107,6 +107,7 @@ __asm__(
 	"	.endm						\n\t");
 
 #ifdef CONFIG_CPU_RM9000
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
@@ -124,6 +125,9 @@ __asm__(
 		".set\tmips32\n\t"					\
 		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
+
+#define back_to_back_c0_hazard()	do { } while (0)
+
 #else
 
 /*
@@ -170,6 +174,10 @@ __asm__(
 	__asm__ __volatile__(						\
 	"_ehb\t\t\t\t# irq_disable_hazard")
 
+#define back_to_back_c0_hazard()					\
+	__asm__ __volatile__(						\
+	"_ehb\t\t\t\t# back_to_back_c0_hazard")
+
 #elif defined(CONFIG_CPU_R10000) || defined(CONFIG_CPU_RM9000)
 
 /*
@@ -186,6 +194,8 @@ __asm__(
 #define irq_enable_hazard()	do { } while (0)
 #define irq_disable_hazard()	do { } while (0)
 
+#define back_to_back_c0_hazard()	do { } while (0)
+
 #else
 
 /*
@@ -210,6 +220,12 @@ __asm__(
 	__asm__ __volatile__(						\
 	"_ssnop; _ssnop; _ssnop;\t\t# irq_disable_hazard")
 
+#define back_to_back_c0_hazard()					\
+	__asm__ __volatile__(						\
+	"	.set noreorder				\n"		\
+	"	nop; nop; nop				\n"		\
+	"	.set reorder				\n")
+
 #endif
 
 #endif /* __ASSEMBLY__ */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/inventory.h linux_HEAD/include/asm-mips/inventory.h
--- linux-2.6.11.6/include/asm-mips/inventory.h	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/include/asm-mips/inventory.h	2005-03-17 22:20:30.000000000 +0100
@@ -4,6 +4,8 @@
 #ifndef __ASM_INVENTORY_H
 #define __ASM_INVENTORY_H
 
+#include <linux/compiler.h>
+
 typedef struct inventory_s {
 	struct inventory_s *inv_next;
 	int    inv_class;
@@ -14,7 +16,9 @@ typedef struct inventory_s {
 } inventory_t;
 
 extern int inventory_items;
-void add_to_inventory (int class, int type, int controller, int unit, int state);
-int dump_inventory_to_user (void *userbuf, int size);
+
+extern void add_to_inventory (int class, int type, int controller, int unit, int state);
+extern int dump_inventory_to_user (void __user *userbuf, int size);
+extern int __init init_inventory(void);
 
 #endif /* __ASM_INVENTORY_H */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/io.h linux_HEAD/include/asm-mips/io.h
--- linux-2.6.11.6/include/asm-mips/io.h	2005-04-03 00:13:08.000000000 +0200
+++ linux_HEAD/include/asm-mips/io.h	2005-03-21 20:04:58.000000000 +0100
@@ -34,7 +34,7 @@
 #undef CONF_SLOWDOWN_IO
 
 /*
- * Raw operations are never swapped in software.  Otoh values that raw
+ * Raw operations are never swapped in software.  OTOH values that raw
  * operations are working on may or may not have been swapped by the bus
  * hardware.  An example use would be for flash memory that's used for
  * execute in place.
@@ -43,45 +43,53 @@
 # define __raw_ioswabw(x)	(x)
 # define __raw_ioswabl(x)	(x)
 # define __raw_ioswabq(x)	(x)
+# define ____raw_ioswabq(x)	(x)
 
 /*
  * Sane hardware offers swapping of PCI/ISA I/O space accesses in hardware;
  * less sane hardware forces software to fiddle with this...
+ *
+ * Regardless, if the host bus endianness mismatches that of PCI/ISA, then
+ * you can't have the numerical value of data and byte addresses within
+ * multibyte quantities both preserved at the same time.  Hence two
+ * variations of functions: non-prefixed ones that preserve the value
+ * and prefixed ones that preserve byte addresses.  The latters are
+ * typically used for moving raw data between a peripheral and memory (cf.
+ * string I/O functions), hence the "mem_" prefix.
  */
 #if defined(CONFIG_SWAP_IO_SPACE)
 
 # define ioswabb(x)		(x)
+# define mem_ioswabb(x)		(x)
 # ifdef CONFIG_SGI_IP22
 /*
  * IP22 seems braindead enough to swap 16bits values in hardware, but
  * not 32bits.  Go figure... Can't tell without documentation.
  */
 #  define ioswabw(x)		(x)
+#  define mem_ioswabw(x)	le16_to_cpu(x)
 # else
 #  define ioswabw(x)		le16_to_cpu(x)
+#  define mem_ioswabw(x)	(x)
 # endif
 # define ioswabl(x)		le32_to_cpu(x)
+# define mem_ioswabl(x)		(x)
 # define ioswabq(x)		le64_to_cpu(x)
+# define mem_ioswabq(x)		(x)
 
 #else
 
 # define ioswabb(x)		(x)
+# define mem_ioswabb(x)		(x)
 # define ioswabw(x)		(x)
+# define mem_ioswabw(x)		cpu_to_le16(x)
 # define ioswabl(x)		(x)
+# define mem_ioswabl(x)		cpu_to_le32(x)
 # define ioswabq(x)		(x)
+# define mem_ioswabq(x)		cpu_to_le32(x)
 
 #endif
 
-/*
- * Native bus accesses never swapped.
- */
-#define bus_ioswabb(x)		(x)
-#define bus_ioswabw(x)		(x)
-#define bus_ioswabl(x)		(x)
-#define bus_ioswabq(x)		(x)
-
-#define __bus_ioswabq		bus_ioswabq
-
 #define IO_SPACE_LIMIT 0xffff
 
 /*
@@ -319,7 +327,8 @@ static inline type pfx##read##bwlq(volat
 	else if (cpu_has_64bits) {					\
 		unsigned long __flags;					\
 									\
-		local_irq_save(__flags);				\
+		if (irq)						\
+			local_irq_save(__flags);			\
 		__asm__ __volatile__(					\
 			".set	mips3"		"\t\t# __readq"	"\n\t"	\
 			"ld	%L0, %1"			"\n\t"	\
@@ -328,7 +337,8 @@ static inline type pfx##read##bwlq(volat
 			".set	mips0"				"\n"	\
 			: "=r" (__val)					\
 			: "m" (*__mem));				\
-		local_irq_restore(__flags);				\
+		if (irq)						\
+			local_irq_restore(__flags);			\
 	} else {							\
 		__val = 0;						\
 		BUG();							\
@@ -386,15 +396,15 @@ __BUILD_IOPORT_SINGLE(bus, bwlq, type, _
 
 #define BUILDIO(bwlq, type)						\
 									\
-__BUILD_MEMORY_PFX(, bwlq, type)					\
 __BUILD_MEMORY_PFX(__raw_, bwlq, type)					\
-__BUILD_MEMORY_PFX(bus_, bwlq, type)					\
+__BUILD_MEMORY_PFX(, bwlq, type)					\
+__BUILD_MEMORY_PFX(mem_, bwlq, type)					\
 __BUILD_IOPORT_PFX(, bwlq, type)					\
-__BUILD_IOPORT_PFX(__raw_, bwlq, type)
+__BUILD_IOPORT_PFX(mem_, bwlq, type)
 
 #define __BUILDIO(bwlq, type)						\
 									\
-__BUILD_MEMORY_SINGLE(__bus_, bwlq, type, 0)
+__BUILD_MEMORY_SINGLE(____raw_, bwlq, type, 0)
 
 BUILDIO(b, u8)
 BUILDIO(w, u16)
@@ -422,7 +432,7 @@ static inline void writes##bwlq(volatile
 	volatile type *__addr = addr;					\
 									\
 	while (count--) {						\
-		__raw_write##bwlq(*__addr, mem);			\
+		mem_write##bwlq(*__addr, mem);				\
 		__addr++;						\
 	}								\
 }									\
@@ -433,7 +443,7 @@ static inline void reads##bwlq(volatile 
 	volatile type *__addr = addr;					\
 									\
 	while (count--) {						\
-		*__addr = __raw_read##bwlq(mem);			\
+		*__addr = mem_read##bwlq(mem);				\
 		__addr++;						\
 	}								\
 }
@@ -446,7 +456,7 @@ static inline void outs##bwlq(unsigned l
 	volatile type *__addr = addr;					\
 									\
 	while (count--) {						\
-		__raw_out##bwlq(*__addr, port);				\
+		mem_out##bwlq(*__addr, port);				\
 		__addr++;						\
 	}								\
 }									\
@@ -457,7 +467,7 @@ static inline void ins##bwlq(unsigned lo
 	volatile type *__addr = addr;					\
 									\
 	while (count--) {						\
-		*__addr = __raw_in##bwlq(port);				\
+		*__addr = mem_in##bwlq(port);				\
 		__addr++;						\
 	}								\
 }
@@ -481,34 +491,6 @@ BUILDSTRING(q, u64)
 #define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
 
 /*
- * Memory Mapped I/O
- */
-#define ioread8(addr)		readb(addr)
-#define ioread16(addr)		readw(addr)
-#define ioread32(addr)		readl(addr)
-
-#define iowrite8(b,addr)	writeb(b,addr)
-#define iowrite16(w,addr)	writew(w,addr)
-#define iowrite32(l,addr)	writel(l,addr)
-
-#define ioread8_rep(a,b,c)	readsb(a,b,c)
-#define ioread16_rep(a,b,c)	readsw(a,b,c)
-#define ioread32_rep(a,b,c)	readsl(a,b,c)
-
-#define iowrite8_rep(a,b,c)	writesb(a,b,c)
-#define iowrite16_rep(a,b,c)	writesw(a,b,c)
-#define iowrite32_rep(a,b,c)	writesl(a,b,c)
-
-/* Create a virtual mapping cookie for an IO port range */
-extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
-extern void ioport_unmap(void __iomem *);
-
-/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
-struct pci_dev;
-extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
-extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
-
-/*
  * ISA space is 'always mapped' on currently supported MIPS systems, no need
  * to explicitly ioremap() it. The fact that the ISA IO space is mapped
  * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/irq.h linux_HEAD/include/asm-mips/irq.h
--- linux-2.6.11.6/include/asm-mips/irq.h	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/include/asm-mips/irq.h	2005-03-01 22:49:44.000000000 +0100
@@ -24,11 +24,9 @@ static inline int irq_canonicalize(int i
 
 struct pt_regs;
 
-#ifdef CONFIG_PREEMPT
-
 extern asmlinkage unsigned int do_IRQ(unsigned int irq, struct pt_regs *regs);
 
-#else
+#ifdef CONFIG_PREEMPT
 
 /*
  * do_IRQ handles all normal device IRQ's (the special
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/jmr3927/jmr3927.h linux_HEAD/include/asm-mips/jmr3927/jmr3927.h
--- linux-2.6.11.6/include/asm-mips/jmr3927/jmr3927.h	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/include/asm-mips/jmr3927/jmr3927.h	2005-03-04 20:36:14.000000000 +0100
@@ -202,20 +202,6 @@ static inline int jmr3927_have_isac(void
 #endif /* !__ASSEMBLY__ */
 
 /*
- * UART defines for serial.h
- */
-
-/* use Pre-scaler T0 (1/2) */
-#define JMR3927_BASE_BAUD (JMR3927_IMCLK / 2 / 16)
-
-#define UART0_ADDR   0xfffef300
-#define UART1_ADDR   0xfffef400
-#define UART0_INT    JMR3927_IRQ_IRC_SIO0
-#define UART1_INT    JMR3927_IRQ_IRC_SIO1
-#define UART0_FLAGS  ASYNC_BOOT_AUTOCONF
-#define UART1_FLAGS  0
-
-/*
  * IRQ mappings
  */
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mach-au1x00/au1000.h linux_HEAD/include/asm-mips/mach-au1x00/au1000.h
--- linux-2.6.11.6/include/asm-mips/mach-au1x00/au1000.h	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/include/asm-mips/mach-au1x00/au1000.h	2005-03-01 15:00:58.000000000 +0100
@@ -162,28 +162,356 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define ALLINTS (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4 | IE_IRQ5)
 #endif
 
-/* SDRAM Controller */
+/*
+ * SDRAM Register Offsets
+ */
 #if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
-#define MEM_SDMODE0                0xB4000000
-#define MEM_SDMODE1                0xB4000004
-#define MEM_SDMODE2                0xB4000008
-
-#define MEM_SDADDR0                0xB400000C
-#define MEM_SDADDR1                0xB4000010
-#define MEM_SDADDR2                0xB4000014
-
-#define MEM_SDREFCFG               0xB4000018
-#define MEM_SDPRECMD               0xB400001C
-#define MEM_SDAUTOREF              0xB4000020
-
-#define MEM_SDWRMD0                0xB4000024
-#define MEM_SDWRMD1                0xB4000028
-#define MEM_SDWRMD2                0xB400002C
+#define MEM_SDMODE0		(0x0000)
+#define MEM_SDMODE1		(0x0004)
+#define MEM_SDMODE2		(0x0008)
+#define MEM_SDADDR0		(0x000C)
+#define MEM_SDADDR1		(0x0010)
+#define MEM_SDADDR2		(0x0014)
+#define MEM_SDREFCFG	(0x0018)
+#define MEM_SDPRECMD	(0x001C)
+#define MEM_SDAUTOREF	(0x0020)
+#define MEM_SDWRMD0		(0x0024)
+#define MEM_SDWRMD1		(0x0028)
+#define MEM_SDWRMD2		(0x002C)
+#define MEM_SDSLEEP		(0x0030)
+#define MEM_SDSMCKE		(0x0034)
+
+#ifndef ASSEMBLER
+/*typedef volatile struct
+{
+	uint32 sdmode0;
+	uint32 sdmode1;
+	uint32 sdmode2;
+	uint32 sdaddr0;
+	uint32 sdaddr1;
+	uint32 sdaddr2;
+	uint32 sdrefcfg;
+	uint32 sdautoref;
+	uint32 sdwrmd0;
+	uint32 sdwrmd1;
+	uint32 sdwrmd2;
+	uint32 sdsleep;
+	uint32 sdsmcke;
+
+} AU1X00_SDRAM;*/
+#endif
+
+/*
+ * MEM_SDMODE register content definitions
+ */
+#define MEM_SDMODE_F		(1<<22)
+#define MEM_SDMODE_SR		(1<<21)
+#define MEM_SDMODE_BS		(1<<20)
+#define MEM_SDMODE_RS		(3<<18)
+#define MEM_SDMODE_CS		(7<<15)
+#define MEM_SDMODE_TRAS		(15<<11)
+#define MEM_SDMODE_TMRD		(3<<9)
+#define MEM_SDMODE_TWR		(3<<7)
+#define MEM_SDMODE_TRP		(3<<5)
+#define MEM_SDMODE_TRCD		(3<<3)
+#define MEM_SDMODE_TCL		(7<<0)
+
+#define MEM_SDMODE_BS_2Bank	(0<<20)
+#define MEM_SDMODE_BS_4Bank	(1<<20)
+#define MEM_SDMODE_RS_11Row	(0<<18)
+#define MEM_SDMODE_RS_12Row	(1<<18)
+#define MEM_SDMODE_RS_13Row	(2<<18)
+#define MEM_SDMODE_RS_N(N)	((N)<<18)
+#define MEM_SDMODE_CS_7Col	(0<<15)
+#define MEM_SDMODE_CS_8Col	(1<<15)
+#define MEM_SDMODE_CS_9Col	(2<<15)
+#define MEM_SDMODE_CS_10Col	(3<<15)
+#define MEM_SDMODE_CS_11Col	(4<<15)
+#define MEM_SDMODE_CS_N(N)		((N)<<15)
+#define MEM_SDMODE_TRAS_N(N)	((N)<<11)
+#define MEM_SDMODE_TMRD_N(N)	((N)<<9)
+#define MEM_SDMODE_TWR_N(N)		((N)<<7)
+#define MEM_SDMODE_TRP_N(N)		((N)<<5)
+#define MEM_SDMODE_TRCD_N(N)	((N)<<3)
+#define MEM_SDMODE_TCL_N(N)		((N)<<0)
+
+/*
+ * MEM_SDADDR register contents definitions
+ */
+#define MEM_SDADDR_E			(1<<20)
+#define MEM_SDADDR_CSBA			(0x03FF<<10)
+#define MEM_SDADDR_CSMASK		(0x03FF<<0)
+#define MEM_SDADDR_CSBA_N(N)	((N)&(0x03FF<<22)>>12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF<<22)>>22)
+
+/*
+ * MEM_SDREFCFG register content definitions
+ */
+#define MEM_SDREFCFG_TRC		(15<<28)
+#define MEM_SDREFCFG_TRPM		(3<<26)
+#define MEM_SDREFCFG_E			(1<<25)
+#define MEM_SDREFCFG_RE			(0x1ffffff<<0)
+#define MEM_SDREFCFG_TRC_N(N)	((N)<<MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N)<<MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_REF_N(N)	(N)
+#endif
+
+/***********************************************************************/
+
+/*
+ * Au1550 SDRAM Register Offsets
+ */
+
+/***********************************************************************/
+
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+#define MEM_SDMODE0		(0x0800)
+#define MEM_SDMODE1		(0x0808)
+#define MEM_SDMODE2		(0x0810)
+#define MEM_SDADDR0		(0x0820)
+#define MEM_SDADDR1		(0x0828)
+#define MEM_SDADDR2		(0x0830)
+#define MEM_SDCONFIGA	(0x0840)
+#define MEM_SDCONFIGB	(0x0848)
+#define MEM_SDSTAT		(0x0850)
+#define MEM_SDERRADDR	(0x0858)
+#define MEM_SDSTRIDE0	(0x0860)
+#define MEM_SDSTRIDE1	(0x0868)
+#define MEM_SDSTRIDE2	(0x0870)
+#define MEM_SDWRMD0		(0x0880)
+#define MEM_SDWRMD1		(0x0888)
+#define MEM_SDWRMD2		(0x0890)
+#define MEM_SDPRECMD	(0x08C0)
+#define MEM_SDAUTOREF	(0x08C8)
+#define MEM_SDSREF		(0x08D0)
+#define MEM_SDSLEEP		MEM_SDSREF
+
+#ifndef ASSEMBLER
+/*typedef volatile struct
+{
+	uint32 sdmode0;
+	uint32 reserved0;
+	uint32 sdmode1;
+	uint32 reserved1;
+	uint32 sdmode2;
+	uint32 reserved2[3];
+	uint32 sdaddr0;
+	uint32 reserved3;
+	uint32 sdaddr1;
+	uint32 reserved4;
+	uint32 sdaddr2;
+	uint32 reserved5[3];
+	uint32 sdconfiga;
+	uint32 reserved6;
+	uint32 sdconfigb;
+	uint32 reserved7;
+	uint32 sdstat;
+	uint32 reserved8;
+	uint32 sderraddr;
+	uint32 reserved9;
+	uint32 sdstride0;
+	uint32 reserved10;
+	uint32 sdstride1;
+	uint32 reserved11;
+	uint32 sdstride2;
+	uint32 reserved12[3];
+	uint32 sdwrmd0;
+	uint32 reserved13;
+	uint32 sdwrmd1;
+	uint32 reserved14;
+	uint32 sdwrmd2;
+	uint32 reserved15[11];
+	uint32 sdprecmd;
+	uint32 reserved16;
+	uint32 sdautoref;
+	uint32 reserved17;
+	uint32 sdsref;
+
+} AU1550_SDRAM;*/
+#endif
+#endif
 
-#define MEM_SDSLEEP                0xB4000030
-#define MEM_SDSMCKE                0xB4000034
+/*
+ * Physical base addresses for integrated peripherals
+ */
+
+#ifdef CONFIG_SOC_AU1000
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART2_PHYS_ADDR		0x11300000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1500
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x11500000
+#define	MAC1_PHYS_ADDR		0x11510000
+#define	MACEN_PHYS_ADDR		0x11520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define PCI_MEM_PHYS_ADDR     0x400000000
+#define PCI_IO_PHYS_ADDR      0x500000000
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/********************************************************************/
+
+#ifdef CONFIG_SOC_AU1100
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	DMA0_PHYS_ADDR		0x14002000
+#define	DMA1_PHYS_ADDR		0x14002100
+#define	DMA2_PHYS_ADDR		0x14002200
+#define	DMA3_PHYS_ADDR		0x14002300
+#define	DMA4_PHYS_ADDR		0x14002400
+#define	DMA5_PHYS_ADDR		0x14002500
+#define	DMA6_PHYS_ADDR		0x14002600
+#define	DMA7_PHYS_ADDR		0x14002700
+#define	IC0_PHYS_ADDR		0x10400000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	AC97_PHYS_ADDR		0x10000000
+#define	USBH_PHYS_ADDR		0x10100000
+#define	USBD_PHYS_ADDR		0x10200000
+#define	IRDA_PHYS_ADDR		0x10300000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	I2S_PHYS_ADDR		0x11000000
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define	SSI0_PHYS_ADDR		0x11600000
+#define	SSI1_PHYS_ADDR		0x11680000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define LCD_PHYS_ADDR		0x15000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
 #endif
 
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1550
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define	USBH_PHYS_ADDR		0x14020000
+#define	USBD_PHYS_ADDR		0x10200000
+#define PCI_PHYS_ADDR		0x14005000
+#define	MAC0_PHYS_ADDR		0x10500000
+#define	MAC1_PHYS_ADDR		0x10510000
+#define	MACEN_PHYS_ADDR		0x10520000
+#define	MACDMA0_PHYS_ADDR	0x14004000
+#define	MACDMA1_PHYS_ADDR	0x14004200
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define	UART3_PHYS_ADDR		0x11400000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PE_PHYS_ADDR		0x14008000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define PSC2_PHYS_ADDR	 	0x10A00000
+#define PSC3_PHYS_ADDR	 	0x10B00000
+#define PCI_MEM_PHYS_ADDR     0x400000000
+#define PCI_IO_PHYS_ADDR      0x500000000
+#define PCI_CONFIG0_PHYS_ADDR 0x600000000
+#define PCI_CONFIG1_PHYS_ADDR 0x680000000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#endif
+
+/***********************************************************************/
+
+#ifdef CONFIG_SOC_AU1200
+#define	MEM_PHYS_ADDR		0x14000000
+#define	STATIC_MEM_PHYS_ADDR	0x14001000
+#define AES_PHYS_ADDR		0x10300000
+#define CIM_PHYS_ADDR		0x14004000
+#define	IC0_PHYS_ADDR		0x10400000
+#define	IC1_PHYS_ADDR		0x11800000
+#define USBM_PHYS_ADDR		0x14020000
+#define	USBH_PHYS_ADDR		0x14020100
+#define	UART0_PHYS_ADDR		0x11100000
+#define	UART1_PHYS_ADDR		0x11200000
+#define GPIO2_PHYS_ADDR		0x11700000
+#define	SYS_PHYS_ADDR		0x11900000
+#define	DDMA_PHYS_ADDR		0x14002000
+#define PSC0_PHYS_ADDR	 	0x11A00000
+#define PSC1_PHYS_ADDR	 	0x11B00000
+#define PCMCIA_IO_PHYS_ADDR   0xF00000000
+#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000
+#define PCMCIA_MEM_PHYS_ADDR  0xF80000000
+#define SD0_PHYS_ADDR		0x10600000
+#define SD1_PHYS_ADDR		0x10680000
+#define LCD_PHYS_ADDR		0x15000000
+#define SWCNT_PHYS_ADDR		0x1110010C
+#define MAEFE_PHYS_ADDR		0x14012000
+#define MAEBE_PHYS_ADDR		0x14010000
+#endif
+
+
 /* Static Bus Controller */
 #define MEM_STCFG0                 0xB4001000
 #define MEM_STTIME0                0xB4001004
@@ -369,7 +697,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1000_MAC0_ENABLE       0xB0520000
 #define AU1000_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1000
+#endif /* CONFIG_SOC_AU1000 */
 
 /* Au1500 */
 #ifdef CONFIG_SOC_AU1500
@@ -429,6 +757,12 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1500_GPIO_207           62
 #define AU1500_GPIO_208_215       63
 
+/* shortcuts */
+#define INTA AU1000_PCI_INTA
+#define INTB AU1000_PCI_INTB
+#define INTC AU1000_PCI_INTC
+#define INTD AU1000_PCI_INTD
+
 #define UART0_ADDR                0xB1100000
 #define UART3_ADDR                0xB1400000
 
@@ -440,7 +774,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1500_MAC0_ENABLE       0xB1520000
 #define AU1500_MAC1_ENABLE       0xB1520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1500
+#endif /* CONFIG_SOC_AU1500 */
 
 /* Au1100 */
 #ifdef CONFIG_SOC_AU1100
@@ -485,6 +819,22 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1000_GPIO_13            45
 #define AU1000_GPIO_14            46
 #define AU1000_GPIO_15            47
+#define AU1000_GPIO_16            48
+#define AU1000_GPIO_17            49
+#define AU1000_GPIO_18            50
+#define AU1000_GPIO_19            51
+#define AU1000_GPIO_20            52
+#define AU1000_GPIO_21            53
+#define AU1000_GPIO_22            54
+#define AU1000_GPIO_23            55
+#define AU1000_GPIO_24            56
+#define AU1000_GPIO_25            57
+#define AU1000_GPIO_26            58
+#define AU1000_GPIO_27            59
+#define AU1000_GPIO_28            60
+#define AU1000_GPIO_29            61
+#define AU1000_GPIO_30            62
+#define AU1000_GPIO_31            63
 
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
@@ -496,7 +846,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1100_ETH0_BASE	  0xB0500000
 #define AU1100_MAC0_ENABLE       0xB0520000
 #define NUM_ETH_INTERFACES 1
-#endif // CONFIG_SOC_AU1100
+#endif /* CONFIG_SOC_AU1100 */
 
 #ifdef CONFIG_SOC_AU1550
 #define AU1550_UART0_INT          0
@@ -513,14 +863,14 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1550_PSC1_INT           11
 #define AU1550_PSC2_INT           12
 #define AU1550_PSC3_INT           13
-#define AU1550_TOY_INT			  14
-#define AU1550_TOY_MATCH0_INT     15
-#define AU1550_TOY_MATCH1_INT     16
-#define AU1550_TOY_MATCH2_INT     17
-#define AU1550_RTC_INT            18
-#define AU1550_RTC_MATCH0_INT     19
-#define AU1550_RTC_MATCH1_INT     20
-#define AU1550_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1550_NAND_INT           23
 #define AU1550_USB_DEV_REQ_INT    24
 #define AU1550_USB_DEV_SUS_INT    25
@@ -563,6 +913,12 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1500_GPIO_207           62
 #define AU1500_GPIO_208_218       63	// Logical or of GPIO208:218
 
+/* shortcuts */
+#define INTA AU1550_PCI_INTA
+#define INTB AU1550_PCI_INTB
+#define INTC AU1550_PCI_INTC
+#define INTD AU1550_PCI_INTD
+
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
 #define UART3_ADDR                0xB1400000
@@ -575,7 +931,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1550_MAC0_ENABLE       0xB0520000
 #define AU1550_MAC1_ENABLE       0xB0520004
 #define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1550
+#endif /* CONFIG_SOC_AU1550 */
 
 #ifdef CONFIG_SOC_AU1200
 #define AU1200_UART0_INT          0
@@ -592,14 +948,14 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1200_PSC1_INT           11
 #define AU1200_AES_INT            12
 #define AU1200_CAMERA_INT         13
-#define AU1200_TOY_INT			  14
-#define AU1200_TOY_MATCH0_INT     15
-#define AU1200_TOY_MATCH1_INT     16
-#define AU1200_TOY_MATCH2_INT     17
-#define AU1200_RTC_INT            18
-#define AU1200_RTC_MATCH0_INT     19
-#define AU1200_RTC_MATCH1_INT     20
-#define AU1200_RTC_MATCH2_INT     21
+#define AU1000_TOY_INT			  14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
 #define AU1200_NAND_INT           23
 #define AU1200_GPIO_204           24
 #define AU1200_GPIO_205           25
@@ -607,6 +963,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1200_GPIO_207           27
 #define AU1200_GPIO_208_215       28 // Logical OR of 208:215
 #define AU1200_USB_INT            29
+#define AU1000_USB_HOST_INT		  AU1200_USB_INT
 #define AU1200_LCD_INT            30
 #define AU1200_MAE_BOTH_INT       31
 #define AU1000_GPIO_0             32
@@ -645,20 +1002,36 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define UART0_ADDR                0xB1100000
 #define UART1_ADDR                0xB1200000
 
-#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB4027ffc
+#define USB_UOC_BASE              0x14020020
+#define USB_UOC_LEN               0x20
+#define USB_OHCI_BASE             0x14020100
+#define USB_OHCI_LEN              0x100
+#define USB_EHCI_BASE             0x14020200
+#define USB_EHCI_LEN              0x100
+#define USB_UDC_BASE              0x14022000
+#define USB_UDC_LEN               0x2000
+#define USB_MSR_BASE			  0xB4020000
+#define USB_MSR_MCFG              4
+#define USBMSRMCFG_OMEMEN         0
+#define USBMSRMCFG_OBMEN          1
+#define USBMSRMCFG_EMEMEN         2
+#define USBMSRMCFG_EBMEN          3
+#define USBMSRMCFG_DMEMEN         4
+#define USBMSRMCFG_DBMEN          5
+#define USBMSRMCFG_GMEMEN         6
+#define USBMSRMCFG_OHCCLKEN       16
+#define USBMSRMCFG_EHCCLKEN       17
+#define USBMSRMCFG_UDCCLKEN       18
+#define USBMSRMCFG_PHYPLLEN       19
+#define USBMSRMCFG_RDCOMB         30
+#define USBMSRMCFG_PFEN           31
 
-// these are here for prototyping on au1550 (do not exist on au1200)
-#define AU1200_ETH0_BASE      0xB0500000
-#define AU1200_ETH1_BASE      0xB0510000
-#define AU1200_MAC0_ENABLE       0xB0520000
-#define AU1200_MAC1_ENABLE       0xB0520004
-#define NUM_ETH_INTERFACES 2
-#endif // CONFIG_SOC_AU1200
+#endif /* CONFIG_SOC_AU1200 */
 
 #define AU1000_LAST_INTC0_INT     31
+#define AU1000_LAST_INTC1_INT     63
 #define AU1000_MAX_INTR           63
-
+#define INTX    		0xFF /* not valid */
 
 /* Programmable Counters 0 and 1 */
 #define SYS_BASE                   0xB1900000
@@ -730,6 +1103,8 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define I2S_CONTROL_D         (1<<1)
   #define I2S_CONTROL_CE        (1<<0)
 
+#ifndef CONFIG_SOC_AU1200
+
 /* USB Host Controller */
 #define USB_OHCI_LEN              0x00100000
 
@@ -775,6 +1150,8 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define USBDEV_ENABLE (1<<1)
   #define USBDEV_CE     (1<<0)
 
+#endif /* !CONFIG_SOC_AU1200 */
+
 /* Ethernet Controllers  */
 
 /* 4 byte offsets from AU1000_ETH_BASE */
@@ -1173,6 +1550,37 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define SYS_PF_PSC1_S1		(1 << 1)
   #define SYS_PF_MUST_BE_SET		((1 << 5) | (1 << 2))
 
+/* Au1200 Only */
+#ifdef CONFIG_SOC_AU1200
+#define SYS_PINFUNC_DMA		(1<<31)
+#define SYS_PINFUNC_S0A		(1<<30)
+#define SYS_PINFUNC_S1A		(1<<29)
+#define SYS_PINFUNC_LP0		(1<<28)
+#define SYS_PINFUNC_LP1		(1<<27)
+#define SYS_PINFUNC_LD16	(1<<26)
+#define SYS_PINFUNC_LD8		(1<<25)
+#define SYS_PINFUNC_LD1		(1<<24)
+#define SYS_PINFUNC_LD0		(1<<23)
+#define SYS_PINFUNC_P1A		(3<<21)
+#define SYS_PINFUNC_P1B		(1<<20)
+#define SYS_PINFUNC_FS3		(1<<19)
+#define SYS_PINFUNC_P0A		(3<<17)
+#define SYS_PINFUNC_CS		(1<<16)
+#define SYS_PINFUNC_CIM		(1<<15)
+#define SYS_PINFUNC_P1C		(1<<14)
+#define SYS_PINFUNC_U1T		(1<<12)
+#define SYS_PINFUNC_U1R		(1<<11)
+#define SYS_PINFUNC_EX1		(1<<10)
+#define SYS_PINFUNC_EX0		(1<<9)
+#define SYS_PINFUNC_U0R		(1<<8)
+#define SYS_PINFUNC_MC		(1<<7)
+#define SYS_PINFUNC_S0B		(1<<6)
+#define SYS_PINFUNC_S0C		(1<<5)
+#define SYS_PINFUNC_P0B		(1<<4)
+#define SYS_PINFUNC_U0T		(1<<3)
+#define SYS_PINFUNC_S1B		(1<<2)
+#endif
+
 #define SYS_TRIOUTRD              0xB1900100
 #define SYS_TRIOUTCLR             0xB1900100
 #define SYS_OUTPUTRD              0xB1900108
@@ -1300,7 +1708,6 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define SD1_XMIT_FIFO	0xB0680000
 #define SD1_RECV_FIFO	0xB0680004
 
-
 #if defined (CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 /* Au1500 PCI Controller */
 #define Au1500_CFG_BASE           0xB4005000 // virtual, kseg0 addr
@@ -1363,36 +1770,77 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 		      _ctl_; })
 
 
-#else /* Au1000 and Au1100 */
+#else /* Au1000 and Au1100 and Au1200 */
 
 /* don't allow any legacy ports probing */
-#define IOPORT_RESOURCE_START 0x10000000;
+#define IOPORT_RESOURCE_START 0x10000000
 #define IOPORT_RESOURCE_END   0xffffffff
 #define IOMEM_RESOURCE_START  0x10000000
 #define IOMEM_RESOURCE_END    0xffffffff
 
-#ifdef CONFIG_MIPS_PB1000
-#define PCI_IO_START      0x10000000
-#define PCI_IO_END        0x1000ffff
-#define PCI_MEM_START     0x18000000
-#define PCI_MEM_END       0x18ffffff
-#define PCI_FIRST_DEVFN   0
-#define PCI_LAST_DEVFN    1
-#else
-/* no PCI bus controller */
 #define PCI_IO_START    0
 #define PCI_IO_END      0
 #define PCI_MEM_START   0
 #define PCI_MEM_END     0 
 #define PCI_FIRST_DEVFN 0
 #define PCI_LAST_DEVFN  0
-#endif
 
 #endif
 
+#ifndef _LANGUAGE_ASSEMBLY
+typedef volatile struct
+{
+	/* 0x0000 */ u32 toytrim;
+	/* 0x0004 */ u32 toywrite;
+	/* 0x0008 */ u32 toymatch0;
+	/* 0x000C */ u32 toymatch1;
+	/* 0x0010 */ u32 toymatch2;
+	/* 0x0014 */ u32 cntrctrl;
+	/* 0x0018 */ u32 scratch0;
+	/* 0x001C */ u32 scratch1;
+	/* 0x0020 */ u32 freqctrl0;
+	/* 0x0024 */ u32 freqctrl1;
+	/* 0x0028 */ u32 clksrc;
+	/* 0x002C */ u32 pinfunc;
+	/* 0x0030 */ u32 reserved0;
+	/* 0x0034 */ u32 wakemsk;
+	/* 0x0038 */ u32 endian;
+	/* 0x003C */ u32 powerctrl;
+	/* 0x0040 */ u32 toyread;
+	/* 0x0044 */ u32 rtctrim;
+	/* 0x0048 */ u32 rtcwrite;
+	/* 0x004C */ u32 rtcmatch0;
+	/* 0x0050 */ u32 rtcmatch1;
+	/* 0x0054 */ u32 rtcmatch2;
+	/* 0x0058 */ u32 rtcread;
+	/* 0x005C */ u32 wakesrc;
+	/* 0x0060 */ u32 cpupll;
+	/* 0x0064 */ u32 auxpll;
+	/* 0x0068 */ u32 reserved1;
+	/* 0x006C */ u32 reserved2;
+	/* 0x0070 */ u32 reserved3;
+	/* 0x0074 */ u32 reserved4;
+	/* 0x0078 */ u32 slppwr;
+	/* 0x007C */ u32 sleep;
+	/* 0x0080 */ u32 reserved5[32];
+	/* 0x0100 */ u32 trioutrd;
+#define trioutclr trioutrd
+	/* 0x0104 */ u32 reserved6;
+	/* 0x0108 */ u32 outputrd;
+#define outputset outputrd
+	/* 0x010C */ u32 outputclr;
+	/* 0x0110 */ u32 pinstaterd;
+#define pininputen pinstaterd
+
+} AU1X00_SYS;
+
+static AU1X00_SYS* const sys  = (AU1X00_SYS *)SYS_BASE;
+
+#endif
 /* Processor information base on prid.
  * Copied from PowerPC.
  */
+#ifndef _LANGUAGE_ASSEMBLY
 struct cpu_spec {
 	/* CPU is matched via (PRID & prid_mask) == prid_value */
 	unsigned int	prid_mask;
@@ -1406,3 +1854,6 @@ struct cpu_spec {
 extern struct cpu_spec		cpu_specs[];
 extern struct cpu_spec		*cur_cpu_spec[];
 #endif
+
+#endif
+
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mach-au1x00/au1xxx_dbdma.h linux_HEAD/include/asm-mips/mach-au1x00/au1xxx_dbdma.h
--- linux-2.6.11.6/include/asm-mips/mach-au1x00/au1xxx_dbdma.h	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/include/asm-mips/mach-au1x00/au1xxx_dbdma.h	2005-03-01 15:00:58.000000000 +0100
@@ -45,7 +45,7 @@
 #define DDMA_GLOBAL_BASE	0xb4003000
 #define DDMA_CHANNEL_BASE	0xb4002000
 
-typedef struct dbdma_global {
+typedef volatile struct dbdma_global {
 	u32	ddma_config;
 	u32	ddma_intstat;
 	u32	ddma_throttle;
@@ -62,7 +62,7 @@ typedef struct dbdma_global {
 
 /* The structure of a DMA Channel.
 */
-typedef struct au1xxx_dma_channel {
+typedef volatile struct au1xxx_dma_channel {
 	u32	ddma_cfg;	/* See below */
 	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
 	u32	ddma_statptr;	/* word aligned pointer to status word */
@@ -98,7 +98,7 @@ typedef struct au1xxx_dma_channel {
 /* "Standard" DDMA Descriptor.
  * Must be 32-byte aligned.
  */
-typedef struct au1xxx_ddma_desc {
+typedef volatile struct au1xxx_ddma_desc {
 	u32	dscr_cmd0;		/* See below */
 	u32	dscr_cmd1;		/* See below */
 	u32	dscr_source0;		/* source phys address */
@@ -107,6 +107,12 @@ typedef struct au1xxx_ddma_desc {
 	u32	dscr_dest1;		/* See below */
 	u32	dscr_stat;		/* completion status */
 	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
+	/* First 32bytes are HW specific!!!
+	   Lets have some SW data following.. make sure its 32bytes
+	 */
+	u32	sw_status;
+	u32 	sw_context;
+	u32	sw_reserved[6];
 } au1x_ddma_desc_t;
 
 #define DSCR_CMD0_V		(1 << 31)	/* Descriptor valid */
@@ -125,8 +131,11 @@ typedef struct au1xxx_ddma_desc {
 #define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
 #define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
 
+#define SW_STATUS_INUSE		(1<<0)
+
 /* Command 0 device IDs.
 */
+#ifdef CONFIG_SOC_AU1550
 #define DSCR_CMD0_UART0_TX	0
 #define DSCR_CMD0_UART0_RX	1
 #define DSCR_CMD0_UART3_TX	2
@@ -155,9 +164,45 @@ typedef struct au1xxx_ddma_desc {
 #define DSCR_CMD0_MAC0_TX	25
 #define DSCR_CMD0_MAC1_RX	26
 #define DSCR_CMD0_MAC1_TX	27
+#endif /* CONFIG_SOC_AU1550 */
+
+#ifdef CONFIG_SOC_AU1200
+#define DSCR_CMD0_UART0_TX	0
+#define DSCR_CMD0_UART0_RX	1
+#define DSCR_CMD0_UART1_TX	2
+#define DSCR_CMD0_UART1_RX	3
+#define DSCR_CMD0_DMA_REQ0	4
+#define DSCR_CMD0_DMA_REQ1	5
+#define DSCR_CMD0_MAE_BE	6
+#define DSCR_CMD0_MAE_FE	7
+#define DSCR_CMD0_SDMS_TX0	8
+#define DSCR_CMD0_SDMS_RX0	9
+#define DSCR_CMD0_SDMS_TX1	10
+#define DSCR_CMD0_SDMS_RX1	11
+#define DSCR_CMD0_AES_TX	13
+#define DSCR_CMD0_AES_RX	12
+#define DSCR_CMD0_PSC0_TX	14
+#define DSCR_CMD0_PSC0_RX	15
+#define DSCR_CMD0_PSC1_TX	16
+#define DSCR_CMD0_PSC1_RX	17
+#define DSCR_CMD0_CIM_RXA	18
+#define DSCR_CMD0_CIM_RXB	19
+#define DSCR_CMD0_CIM_RXC	20
+#define DSCR_CMD0_MAE_BOTH	21
+#define DSCR_CMD0_LCD		22
+#define DSCR_CMD0_NAND_FLASH	23
+#define DSCR_CMD0_PSC0_SYNC	24
+#define DSCR_CMD0_PSC1_SYNC	25
+#define DSCR_CMD0_CIM_SYNC	26
+#endif /* CONFIG_SOC_AU1200 */
+
 #define DSCR_CMD0_THROTTLE	30
 #define DSCR_CMD0_ALWAYS	31
 #define DSCR_NDEV_IDS		32
+/* THis macro is used to find/create custom device types */
+#define DSCR_DEV2CUSTOM_ID(x,d)	(((((x)&0xFFFF)<<8)|0x32000000)|((d)&0xFF))
+#define DSCR_CUSTOM2DEV_ID(x)	((x)&0xFF)
+
 
 #define DSCR_CMD0_SID(x)	(((x) & 0x1f) << 25)
 #define DSCR_CMD0_DID(x)	(((x) & 0x1f) << 20)
@@ -246,6 +291,43 @@ typedef struct au1xxx_ddma_desc {
 */
 #define NUM_DBDMA_CHANS	16
 
+/*
+ * Ddma API definitions
+ * FIXME: may not fit to this header file
+ */
+typedef struct dbdma_device_table {
+	u32		dev_id;
+	u32		dev_flags;
+	u32		dev_tsize;
+	u32		dev_devwidth;
+	u32		dev_physaddr;		/* If FIFO */
+	u32		dev_intlevel;
+	u32		dev_intpolarity;
+} dbdev_tab_t;
+
+
+typedef struct dbdma_chan_config {
+	spinlock_t      lock;
+
+	u32			chan_flags;
+	u32			chan_index;
+	dbdev_tab_t		*chan_src;
+	dbdev_tab_t		*chan_dest;
+	au1x_dma_chan_t		*chan_ptr;
+	au1x_ddma_desc_t	*chan_desc_base;
+	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
+	void			*chan_callparam;
+	void (*chan_callback)(int, void *, struct pt_regs *);
+} chan_tab_t;
+
+#define DEV_FLAGS_INUSE		(1 << 0)
+#define DEV_FLAGS_ANYUSE	(1 << 1)
+#define DEV_FLAGS_OUT		(1 << 2)
+#define DEV_FLAGS_IN		(1 << 3)
+#define DEV_FLAGS_BURSTABLE (1 << 4)
+#define DEV_FLAGS_SYNC		(1 << 5)
+/* end Ddma API definitions */
+
 /* External functions for drivers to use.
 */
 /* Use this to allocate a dbdma channel.  The device ids are one of the
@@ -258,18 +340,6 @@ u32 au1xxx_dbdma_chan_alloc(u32 srcid, u
 
 #define DBDMA_MEM_CHAN	DSCR_CMD0_ALWAYS
 
-/* ACK!  These should be in a board specific description file.
-*/
-#ifdef CONFIG_MIPS_PB1550
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#endif
-#ifdef CONFIG_MIPS_DB1550
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#endif
-
-
 /* Set the device width of a in/out fifo.
 */
 u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits);
@@ -280,8 +350,8 @@ u32 au1xxx_dbdma_ring_alloc(u32 chanid, 
 
 /* Put buffers on source/destination descriptors.
 */
-u32 au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes);
-u32 au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes);
+u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
+u32 _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
 
 /* Get a buffer from the destination descriptor.
 */
@@ -295,5 +365,25 @@ u32 au1xxx_get_dma_residue(u32 chanid);
 void au1xxx_dbdma_chan_free(u32 chanid);
 void au1xxx_dbdma_dump(u32 chanid);
 
+u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr );
+
+u32 au1xxx_ddma_add_device( dbdev_tab_t *dev );
+
+/*
+ 	Some compatibilty macros --
+		Needed to make changes to API without breaking existing drivers
+*/
+#define	au1xxx_dbdma_put_source(chanid,buf,nbytes)_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_source_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
+
+#define au1xxx_dbdma_put_dest(chanid,buf,nbytes) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define	au1xxx_dbdma_put_dest_flags(chanid,buf,nbytes,flags) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
+
+/*
+ *	Flags for the put_source/put_dest functions.
+ */
+#define DDMA_FLAGS_IE	(1<<0)
+#define DDMA_FLAGS_NOIE (1<<1)
+
 #endif /* _LANGUAGE_ASSEMBLY */
 #endif /* _AU1000_DBDMA_H_ */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mach-db1x00/db1200.h linux_HEAD/include/asm-mips/mach-db1x00/db1200.h
--- linux-2.6.11.6/include/asm-mips/mach-db1x00/db1200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/include/asm-mips/mach-db1x00/db1200.h	2005-03-01 07:33:19.000000000 +0100
@@ -0,0 +1,215 @@
+/*
+ * AMD Alchemy DB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_DB1200_H
+#define __ASM_DB1200_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xB9800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+#define BCSR_RESETS_TV		0x0010
+/* not resets but in the same register */
+#define BCSR_RESETS_PWMR1mUX 0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+
+#define BCSR_LEDS_DECIMALS	0x0003
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x19000300)
+#define AU1XXX_SMC91111_IRQ			DB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x18800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			DB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x20000000
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the DB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define DB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define DB1200_IDE_INT			(DB1200_INT_BEGIN + 0)
+#define DB1200_ETH_INT			(DB1200_INT_BEGIN + 1)
+#define DB1200_PC0_INT			(DB1200_INT_BEGIN + 2)
+#define DB1200_PC0_STSCHG_INT	(DB1200_INT_BEGIN + 3)
+#define DB1200_PC1_INT			(DB1200_INT_BEGIN + 4)
+#define DB1200_PC1_STSCHG_INT	(DB1200_INT_BEGIN + 5)
+#define DB1200_DC_INT			(DB1200_INT_BEGIN + 6)
+#define DB1200_FLASHBUSY_INT	(DB1200_INT_BEGIN + 7)
+#define DB1200_PC0_INSERT_INT	(DB1200_INT_BEGIN + 8)
+#define DB1200_PC0_EJECT_INT	(DB1200_INT_BEGIN + 9)
+#define DB1200_PC1_INSERT_INT	(DB1200_INT_BEGIN + 10)
+#define DB1200_PC1_EJECT_INT	(DB1200_INT_BEGIN + 11)
+#define DB1200_SD0_INSERT_INT	(DB1200_INT_BEGIN + 12)
+#define DB1200_SD0_EJECT_INT	(DB1200_INT_BEGIN + 13)
+
+#define DB1200_INT_END			(DB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT DB1200_PC0_INT
+#define BOARD_PC1_INT DB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+#endif /* __ASM_DB1200_H */
+
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mach-ip27/mmzone.h linux_HEAD/include/asm-mips/mach-ip27/mmzone.h
--- linux-2.6.11.6/include/asm-mips/mach-ip27/mmzone.h	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/include/asm-mips/mach-ip27/mmzone.h	2005-03-25 09:05:33.000000000 +0100
@@ -10,7 +10,6 @@
 #define LEVELS_PER_SLICE        128
 
 struct slice_data {
-	unsigned long irq_alloc_mask[2];
 	unsigned long irq_enable_mask[2];
 	int level_to_irq[LEVELS_PER_SLICE];
 };
@@ -20,6 +19,7 @@ struct hub_data {
 	DECLARE_BITMAP(h_bigwin_used, HUB_NUM_BIG_WINDOW);
 	cpumask_t	h_cpus;
 	unsigned long slice_map;
+	unsigned long irq_alloc_mask[2];
 	struct slice_data slice[2];
 };
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mach-ip27/spaces.h linux_HEAD/include/asm-mips/mach-ip27/spaces.h
--- linux-2.6.11.6/include/asm-mips/mach-ip27/spaces.h	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/include/asm-mips/mach-ip27/spaces.h	2005-02-21 22:17:46.000000000 +0100
@@ -20,6 +20,7 @@
 #define IO_BASE			0x9200000000000000
 #define MSPEC_BASE		0x9400000000000000
 #define UNCAC_BASE		0x9600000000000000
+#define MAP_BASE		0xc000000000000000
 
 #define TO_PHYS(x)		(             ((x) & TO_PHYS_MASK))
 #define TO_CAC(x)		(CAC_BASE   | ((x) & TO_PHYS_MASK))
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mach-pb1x00/pb1200.h linux_HEAD/include/asm-mips/mach-pb1x00/pb1200.h
--- linux-2.6.11.6/include/asm-mips/mach-pb1x00/pb1200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/include/asm-mips/mach-pb1x00/pb1200.h	2005-03-01 07:33:19.000000000 +0100
@@ -0,0 +1,245 @@
+/*
+ * AMD Alchemy PB1200 Referrence Board
+ * Board Registers defines.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_PB1200_H
+#define __ASM_PB1200_H
+
+#include <linux/config.h>
+#include <linux/types.h>
+
+// This is defined in au1000.h with bogus value
+#undef AU1X00_EXTERNAL_INT
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
+
+/* SPI and SMB are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
+/* AC97 and I2S are muxed on the Pb1200 board.
+   Refer to board documentation.
+ */
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define I2S_PSC_BASE		PSC1_BASE_ADDR
+
+#define BCSR_KSEG1_ADDR 0xAD800000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 board;
+		u16 reserved5;
+	/*18*/	u16 disk_leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+	/*20*/	u16 intclr;
+		u16 reserved8;
+	/*24*/	u16 intset;
+		u16 reserved9;
+	/*28*/	u16 intclr_mask;
+		u16 reserved10;
+	/*2C*/	u16 intset_mask;
+		u16 reserved11;
+
+	/*30*/	u16 sig_status;
+		u16 reserved12;
+	/*34*/	u16 int_status;
+		u16 reserved13;
+	/*38*/	u16 reserved14;
+		u16 reserved15;
+	/*3C*/	u16 reserved16;
+		u16 reserved17;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_IDECBLID	0x0200
+#define BCSR_STATUS_SD0WP		0x0400
+#define BCSR_STATUS_SD1WP		0x0800
+#define BCSR_STATUS_U0RXD		0x1000
+#define BCSR_STATUS_U1RXD		0x2000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_ETH		0x0001
+#define BCSR_RESETS_CAMERA	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_IDE		0x0008
+/* not resets but in the same register */
+#define BCSR_RESETS_WSCFSM  0x0800
+#define BCSR_RESETS_PCS0MUX	0x1000
+#define BCSR_RESETS_PCS1MUX	0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+#define BCSR_RESETS_SD1MUX  0x8000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_BOARD_LCDVEE	0x0001
+#define BCSR_BOARD_LCDVDD	0x0002
+#define BCSR_BOARD_LCDBL	0x0004
+#define BCSR_BOARD_CAMSNAP	0x0010
+#define BCSR_BOARD_CAMPWR	0x0020
+#define BCSR_BOARD_SD0PWR	0x0040
+#define BCSR_BOARD_SD1PWR	0x0080
+
+#define BCSR_LEDS_DECIMALS	0x00FF
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_VDDI	0x001F
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+/* Bit positions for the different interrupt sources */
+#define BCSR_INT_IDE		0x0001
+#define BCSR_INT_ETH		0x0002
+#define BCSR_INT_PC0		0x0004
+#define BCSR_INT_PC0STSCHG	0x0008
+#define BCSR_INT_PC1		0x0010
+#define BCSR_INT_PC1STSCHG	0x0020
+#define BCSR_INT_DC			0x0040
+#define BCSR_INT_FLASHBUSY	0x0080
+#define BCSR_INT_PC0INSERT	0x0100
+#define BCSR_INT_PC0EJECT	0x0200
+#define BCSR_INT_PC1INSERT	0x0400
+#define BCSR_INT_PC1EJECT	0x0800
+#define BCSR_INT_SD0INSERT	0x1000
+#define BCSR_INT_SD0EJECT	0x2000
+#define BCSR_INT_SD1INSERT	0x4000
+#define BCSR_INT_SD1EJECT	0x8000
+
+#define AU1XXX_SMC91111_PHYS_ADDR	(0x0D000300)
+#define AU1XXX_SMC91111_IRQ			PB1200_ETH_INT
+
+#define AU1XXX_ATA_PHYS_ADDR		(0x0C800000)
+#define AU1XXX_ATA_PHYS_LEN			(0x100)
+#define AU1XXX_ATA_REG_OFFSET	(5)
+#define AU1XXX_ATA_INT			PB1200_IDE_INT
+#define AU1XXX_ATA_DDMA_REQ		DSCR_CMD0_DMA_REQ1;
+#define AU1XXX_ATA_RQSIZE		128
+
+#define NAND_PHYS_ADDR   0x1C000000
+
+/* Timing values as described in databook, * ns value stripped of
+ * lower 2 bits.
+ * These defines are here rather than an SOC1200 generic file because
+ * the parts chosen on another board may be different and may require
+ * different timings.
+ */
+#define NAND_T_H			(18 >> 2)
+#define NAND_T_PUL			(30 >> 2)
+#define NAND_T_SU			(30 >> 2)
+#define NAND_T_WH			(30 >> 2)
+
+/* Bitfield shift amounts */
+#define NAND_T_H_SHIFT		0
+#define NAND_T_PUL_SHIFT	4
+#define NAND_T_SU_SHIFT		8
+#define NAND_T_WH_SHIFT		12
+
+#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+
+
+/*
+ *	External Interrupts for Pb1200 as of 8/6/2004.
+ *   Bit positions in the CPLD registers can be calculated by taking
+ *   the interrupt define and subtracting the PB1200_INT_BEGIN value.
+ *    *example: IDE bis pos is  = 64 - 64
+                ETH bit pos is  = 65 - 64
+ */
+#define PB1200_INT_BEGIN		(AU1000_LAST_INTC1_INT + 1)
+#define PB1200_IDE_INT			(PB1200_INT_BEGIN + 0)
+#define PB1200_ETH_INT			(PB1200_INT_BEGIN + 1)
+#define PB1200_PC0_INT			(PB1200_INT_BEGIN + 2)
+#define PB1200_PC0_STSCHG_INT	(PB1200_INT_BEGIN + 3)
+#define PB1200_PC1_INT			(PB1200_INT_BEGIN + 4)
+#define PB1200_PC1_STSCHG_INT	(PB1200_INT_BEGIN + 5)
+#define PB1200_DC_INT			(PB1200_INT_BEGIN + 6)
+#define PB1200_FLASHBUSY_INT	(PB1200_INT_BEGIN + 7)
+#define PB1200_PC0_INSERT_INT	(PB1200_INT_BEGIN + 8)
+#define PB1200_PC0_EJECT_INT	(PB1200_INT_BEGIN + 9)
+#define PB1200_PC1_INSERT_INT	(PB1200_INT_BEGIN + 10)
+#define PB1200_PC1_EJECT_INT	(PB1200_INT_BEGIN + 11)
+#define PB1200_SD0_INSERT_INT	(PB1200_INT_BEGIN + 12)
+#define PB1200_SD0_EJECT_INT	(PB1200_INT_BEGIN + 13)
+#define PB1200_SD1_INSERT_INT	(PB1200_INT_BEGIN + 14)
+#define PB1200_SD1_EJECT_INT	(PB1200_INT_BEGIN + 15)
+
+#define PB1200_INT_END			(PB1200_INT_BEGIN + 15)
+
+/* For drivers/pcmcia/au1000_db1x00.c */
+#define BOARD_PC0_INT PB1200_PC0_INT
+#define BOARD_PC1_INT PB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+
+#endif /* __ASM_PB1200_H */
+
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mips-boards/msc01_pci.h linux_HEAD/include/asm-mips/mips-boards/msc01_pci.h
--- linux-2.6.11.6/include/asm-mips/mips-boards/msc01_pci.h	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/include/asm-mips/mips-boards/msc01_pci.h	2005-02-17 21:50:45.000000000 +0100
@@ -1,8 +1,9 @@
 /*
  * PCI Register definitions for the MIPS System Controller.
  *
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2002, 2005  MIPS Technologies, Inc.  All rights reserved.
+ *	Authors: Carsten Langgaard <carstenl@mips.com>
+ *		 Maciej W. Rozycki <macro@mips.com>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -29,22 +30,22 @@
 #define MSC01_PCI_CFGADDR_OFS		0x0610
 #define MSC01_PCI_CFGDATA_OFS		0x0618
 #define MSC01_PCI_IACK_OFS		0x0620
-#define MSC01_PCI_HEAD0_OFS		0x2000  /* DevID, VendorID */
-#define MSC01_PCI_HEAD1_OFS		0x2008  /* Status, Command */
-#define MSC01_PCI_HEAD2_OFS		0x2010  /* Class code, RevID */
-#define MSC01_PCI_HEAD3_OFS		0x2018  /* bist, header, latency */
-#define MSC01_PCI_HEAD4_OFS		0x2020  /* BAR 0 */
-#define MSC01_PCI_HEAD5_OFS		0x2028  /* BAR 1 */
-#define MSC01_PCI_HEAD6_OFS		0x2030  /* BAR 2 */
-#define MSC01_PCI_HEAD7_OFS		0x2038  /* BAR 3 */
-#define MSC01_PCI_HEAD8_OFS		0x2040  /* BAR 4 */
-#define MSC01_PCI_HEAD9_OFS		0x2048  /* BAR 5 */
-#define MSC01_PCI_HEAD10_OFS		0x2050  /* CardBus CIS Ptr */
-#define MSC01_PCI_HEAD11_OFS		0x2058  /* SubSystem ID, -VendorID */
-#define MSC01_PCI_HEAD12_OFS		0x2060  /* ROM BAR */
-#define MSC01_PCI_HEAD13_OFS		0x2068  /* Capabilities ptr */
-#define MSC01_PCI_HEAD14_OFS		0x2070  /* reserved */
-#define MSC01_PCI_HEAD15_OFS		0x2078  /* Maxl, ming, intpin, int */
+#define MSC01_PCI_HEAD0_OFS		0x2000	/* DevID, VendorID */
+#define MSC01_PCI_HEAD1_OFS		0x2008	/* Status, Command */
+#define MSC01_PCI_HEAD2_OFS		0x2010	/* Class code, RevID */
+#define MSC01_PCI_HEAD3_OFS		0x2018	/* bist, header, latency */
+#define MSC01_PCI_HEAD4_OFS		0x2020	/* BAR 0 */
+#define MSC01_PCI_HEAD5_OFS		0x2028	/* BAR 1 */
+#define MSC01_PCI_HEAD6_OFS		0x2030	/* BAR 2 */
+#define MSC01_PCI_HEAD7_OFS		0x2038	/* BAR 3 */
+#define MSC01_PCI_HEAD8_OFS		0x2040	/* BAR 4 */
+#define MSC01_PCI_HEAD9_OFS		0x2048	/* BAR 5 */
+#define MSC01_PCI_HEAD10_OFS		0x2050	/* CardBus CIS Ptr */
+#define MSC01_PCI_HEAD11_OFS		0x2058	/* SubSystem ID, -VendorID */
+#define MSC01_PCI_HEAD12_OFS		0x2060	/* ROM BAR */
+#define MSC01_PCI_HEAD13_OFS		0x2068	/* Capabilities ptr */
+#define MSC01_PCI_HEAD14_OFS		0x2070	/* reserved */
+#define MSC01_PCI_HEAD15_OFS		0x2078	/* Maxl, ming, intpin, int */
 #define MSC01_PCI_BAR0_OFS		0x2220
 #define MSC01_PCI_CFG_OFS		0x2380
 #define MSC01_PCI_SWAP_OFS		0x2388
@@ -86,73 +87,73 @@
 #define MSC01_PCI_P2SCMAPL_MAP_SHF	24
 #define MSC01_PCI_P2SCMAPL_MAP_MSK	0xff000000
 
-#define MSC01_PCI_INTCFG_RST_SHF        10
-#define MSC01_PCI_INTCFG_RST_MSK        0x00000400
-#define MSC01_PCI_INTCFG_RST_BIT        0x00000400
-#define MSC01_PCI_INTCFG_MWE_SHF        9
-#define MSC01_PCI_INTCFG_MWE_MSK        0x00000200
-#define MSC01_PCI_INTCFG_MWE_BIT        0x00000200
-#define MSC01_PCI_INTCFG_DTO_SHF        8
-#define MSC01_PCI_INTCFG_DTO_MSK        0x00000100
-#define MSC01_PCI_INTCFG_DTO_BIT        0x00000100
-#define MSC01_PCI_INTCFG_MA_SHF         7
-#define MSC01_PCI_INTCFG_MA_MSK         0x00000080
-#define MSC01_PCI_INTCFG_MA_BIT         0x00000080
-#define MSC01_PCI_INTCFG_TA_SHF         6
-#define MSC01_PCI_INTCFG_TA_MSK         0x00000040
-#define MSC01_PCI_INTCFG_TA_BIT         0x00000040
-#define MSC01_PCI_INTCFG_RTY_SHF        5
-#define MSC01_PCI_INTCFG_RTY_MSK        0x00000020
-#define MSC01_PCI_INTCFG_RTY_BIT        0x00000020
-#define MSC01_PCI_INTCFG_MWP_SHF        4
-#define MSC01_PCI_INTCFG_MWP_MSK        0x00000010
-#define MSC01_PCI_INTCFG_MWP_BIT        0x00000010
-#define MSC01_PCI_INTCFG_MRP_SHF        3
-#define MSC01_PCI_INTCFG_MRP_MSK        0x00000008
-#define MSC01_PCI_INTCFG_MRP_BIT        0x00000008
-#define MSC01_PCI_INTCFG_SWP_SHF        2
-#define MSC01_PCI_INTCFG_SWP_MSK        0x00000004
-#define MSC01_PCI_INTCFG_SWP_BIT        0x00000004
-#define MSC01_PCI_INTCFG_SRP_SHF        1
-#define MSC01_PCI_INTCFG_SRP_MSK        0x00000002
-#define MSC01_PCI_INTCFG_SRP_BIT        0x00000002
-#define MSC01_PCI_INTCFG_SE_SHF         0
-#define MSC01_PCI_INTCFG_SE_MSK         0x00000001
-#define MSC01_PCI_INTCFG_SE_BIT         0x00000001
-
-#define MSC01_PCI_INTSTAT_RST_SHF       10
-#define MSC01_PCI_INTSTAT_RST_MSK       0x00000400
-#define MSC01_PCI_INTSTAT_RST_BIT       0x00000400
-#define MSC01_PCI_INTSTAT_MWE_SHF       9
-#define MSC01_PCI_INTSTAT_MWE_MSK       0x00000200
-#define MSC01_PCI_INTSTAT_MWE_BIT       0x00000200
-#define MSC01_PCI_INTSTAT_DTO_SHF       8
-#define MSC01_PCI_INTSTAT_DTO_MSK       0x00000100
-#define MSC01_PCI_INTSTAT_DTO_BIT       0x00000100
-#define MSC01_PCI_INTSTAT_MA_SHF        7
-#define MSC01_PCI_INTSTAT_MA_MSK        0x00000080
-#define MSC01_PCI_INTSTAT_MA_BIT        0x00000080
-#define MSC01_PCI_INTSTAT_TA_SHF        6
-#define MSC01_PCI_INTSTAT_TA_MSK        0x00000040
-#define MSC01_PCI_INTSTAT_TA_BIT        0x00000040
-#define MSC01_PCI_INTSTAT_RTY_SHF       5
-#define MSC01_PCI_INTSTAT_RTY_MSK       0x00000020
-#define MSC01_PCI_INTSTAT_RTY_BIT       0x00000020
-#define MSC01_PCI_INTSTAT_MWP_SHF       4
-#define MSC01_PCI_INTSTAT_MWP_MSK       0x00000010
-#define MSC01_PCI_INTSTAT_MWP_BIT       0x00000010
-#define MSC01_PCI_INTSTAT_MRP_SHF       3
-#define MSC01_PCI_INTSTAT_MRP_MSK       0x00000008
-#define MSC01_PCI_INTSTAT_MRP_BIT       0x00000008
-#define MSC01_PCI_INTSTAT_SWP_SHF       2
-#define MSC01_PCI_INTSTAT_SWP_MSK       0x00000004
-#define MSC01_PCI_INTSTAT_SWP_BIT       0x00000004
-#define MSC01_PCI_INTSTAT_SRP_SHF       1
-#define MSC01_PCI_INTSTAT_SRP_MSK       0x00000002
-#define MSC01_PCI_INTSTAT_SRP_BIT       0x00000002
-#define MSC01_PCI_INTSTAT_SE_SHF        0
-#define MSC01_PCI_INTSTAT_SE_MSK        0x00000001
-#define MSC01_PCI_INTSTAT_SE_BIT        0x00000001
+#define MSC01_PCI_INTCFG_RST_SHF	10
+#define MSC01_PCI_INTCFG_RST_MSK	0x00000400
+#define MSC01_PCI_INTCFG_RST_BIT	0x00000400
+#define MSC01_PCI_INTCFG_MWE_SHF	9
+#define MSC01_PCI_INTCFG_MWE_MSK	0x00000200
+#define MSC01_PCI_INTCFG_MWE_BIT	0x00000200
+#define MSC01_PCI_INTCFG_DTO_SHF	8
+#define MSC01_PCI_INTCFG_DTO_MSK	0x00000100
+#define MSC01_PCI_INTCFG_DTO_BIT	0x00000100
+#define MSC01_PCI_INTCFG_MA_SHF		7
+#define MSC01_PCI_INTCFG_MA_MSK		0x00000080
+#define MSC01_PCI_INTCFG_MA_BIT		0x00000080
+#define MSC01_PCI_INTCFG_TA_SHF		6
+#define MSC01_PCI_INTCFG_TA_MSK		0x00000040
+#define MSC01_PCI_INTCFG_TA_BIT		0x00000040
+#define MSC01_PCI_INTCFG_RTY_SHF	5
+#define MSC01_PCI_INTCFG_RTY_MSK	0x00000020
+#define MSC01_PCI_INTCFG_RTY_BIT	0x00000020
+#define MSC01_PCI_INTCFG_MWP_SHF	4
+#define MSC01_PCI_INTCFG_MWP_MSK	0x00000010
+#define MSC01_PCI_INTCFG_MWP_BIT	0x00000010
+#define MSC01_PCI_INTCFG_MRP_SHF	3
+#define MSC01_PCI_INTCFG_MRP_MSK	0x00000008
+#define MSC01_PCI_INTCFG_MRP_BIT	0x00000008
+#define MSC01_PCI_INTCFG_SWP_SHF	2
+#define MSC01_PCI_INTCFG_SWP_MSK	0x00000004
+#define MSC01_PCI_INTCFG_SWP_BIT	0x00000004
+#define MSC01_PCI_INTCFG_SRP_SHF	1
+#define MSC01_PCI_INTCFG_SRP_MSK	0x00000002
+#define MSC01_PCI_INTCFG_SRP_BIT	0x00000002
+#define MSC01_PCI_INTCFG_SE_SHF		0
+#define MSC01_PCI_INTCFG_SE_MSK		0x00000001
+#define MSC01_PCI_INTCFG_SE_BIT		0x00000001
+
+#define MSC01_PCI_INTSTAT_RST_SHF	10
+#define MSC01_PCI_INTSTAT_RST_MSK	0x00000400
+#define MSC01_PCI_INTSTAT_RST_BIT	0x00000400
+#define MSC01_PCI_INTSTAT_MWE_SHF	9
+#define MSC01_PCI_INTSTAT_MWE_MSK	0x00000200
+#define MSC01_PCI_INTSTAT_MWE_BIT	0x00000200
+#define MSC01_PCI_INTSTAT_DTO_SHF	8
+#define MSC01_PCI_INTSTAT_DTO_MSK	0x00000100
+#define MSC01_PCI_INTSTAT_DTO_BIT	0x00000100
+#define MSC01_PCI_INTSTAT_MA_SHF	7
+#define MSC01_PCI_INTSTAT_MA_MSK	0x00000080
+#define MSC01_PCI_INTSTAT_MA_BIT	0x00000080
+#define MSC01_PCI_INTSTAT_TA_SHF	6
+#define MSC01_PCI_INTSTAT_TA_MSK	0x00000040
+#define MSC01_PCI_INTSTAT_TA_BIT	0x00000040
+#define MSC01_PCI_INTSTAT_RTY_SHF	5
+#define MSC01_PCI_INTSTAT_RTY_MSK	0x00000020
+#define MSC01_PCI_INTSTAT_RTY_BIT	0x00000020
+#define MSC01_PCI_INTSTAT_MWP_SHF	4
+#define MSC01_PCI_INTSTAT_MWP_MSK	0x00000010
+#define MSC01_PCI_INTSTAT_MWP_BIT	0x00000010
+#define MSC01_PCI_INTSTAT_MRP_SHF	3
+#define MSC01_PCI_INTSTAT_MRP_MSK	0x00000008
+#define MSC01_PCI_INTSTAT_MRP_BIT	0x00000008
+#define MSC01_PCI_INTSTAT_SWP_SHF	2
+#define MSC01_PCI_INTSTAT_SWP_MSK	0x00000004
+#define MSC01_PCI_INTSTAT_SWP_BIT	0x00000004
+#define MSC01_PCI_INTSTAT_SRP_SHF	1
+#define MSC01_PCI_INTSTAT_SRP_MSK	0x00000002
+#define MSC01_PCI_INTSTAT_SRP_BIT	0x00000002
+#define MSC01_PCI_INTSTAT_SE_SHF	0
+#define MSC01_PCI_INTSTAT_SE_MSK	0x00000001
+#define MSC01_PCI_INTSTAT_SE_BIT	0x00000001
 
 #define MSC01_PCI_CFGADDR_BNUM_SHF	16
 #define MSC01_PCI_CFGADDR_BNUM_MSK	0x00ff0000
@@ -167,29 +168,29 @@
 #define MSC01_PCI_CFGDATA_DATA_MSK	0xffffffff
 
 /* The defines below are ONLY valid for a MEM bar! */
-#define MSC01_PCI_BAR0_SIZE_SHF	        4
-#define MSC01_PCI_BAR0_SIZE_MSK	        0xfffffff0
-#define MSC01_PCI_BAR0_P_SHF	        3
-#define MSC01_PCI_BAR0_P_MSK	        0x00000008
-#define MSC01_PCI_BAR0_P_BIT	        MSC01_PCI_BAR0_P_MSK
-#define MSC01_PCI_BAR0_D_SHF	        1
-#define MSC01_PCI_BAR0_D_MSK	        0x00000006
-#define MSC01_PCI_BAR0_T_SHF	        0
-#define MSC01_PCI_BAR0_T_MSK	        0x00000001
-#define MSC01_PCI_BAR0_T_BIT	        MSC01_PCI_BAR0_T_MSK
-
-
-#define MSC01_PCI_CFG_RA_SHF	        17
-#define MSC01_PCI_CFG_RA_MSK	        0x00020000
-#define MSC01_PCI_CFG_RA_BIT	        MSC01_PCI_CFG_RA_MSK
-#define MSC01_PCI_CFG_G_SHF	        16
-#define MSC01_PCI_CFG_G_MSK	        0x00010000
-#define MSC01_PCI_CFG_G_BIT	        MSC01_PCI_CFG_G_MSK
-#define MSC01_PCI_CFG_EN_SHF	        15
-#define MSC01_PCI_CFG_EN_MSK	        0x00008000
-#define MSC01_PCI_CFG_EN_BIT	        MSC01_PCI_CFG_EN_MSK
-#define MSC01_PCI_CFG_MAXRTRY_SHF       0
-#define MSC01_PCI_CFG_MAXRTRY_MSK       0x000000ff
+#define MSC01_PCI_BAR0_SIZE_SHF		4
+#define MSC01_PCI_BAR0_SIZE_MSK		0xfffffff0
+#define MSC01_PCI_BAR0_P_SHF		3
+#define MSC01_PCI_BAR0_P_MSK		0x00000008
+#define MSC01_PCI_BAR0_P_BIT		MSC01_PCI_BAR0_P_MSK
+#define MSC01_PCI_BAR0_D_SHF		1
+#define MSC01_PCI_BAR0_D_MSK		0x00000006
+#define MSC01_PCI_BAR0_T_SHF		0
+#define MSC01_PCI_BAR0_T_MSK		0x00000001
+#define MSC01_PCI_BAR0_T_BIT		MSC01_PCI_BAR0_T_MSK
+
+
+#define MSC01_PCI_CFG_RA_SHF		17
+#define MSC01_PCI_CFG_RA_MSK		0x00020000
+#define MSC01_PCI_CFG_RA_BIT		MSC01_PCI_CFG_RA_MSK
+#define MSC01_PCI_CFG_G_SHF		16
+#define MSC01_PCI_CFG_G_MSK		0x00010000
+#define MSC01_PCI_CFG_G_BIT		MSC01_PCI_CFG_G_MSK
+#define MSC01_PCI_CFG_EN_SHF		15
+#define MSC01_PCI_CFG_EN_MSK		0x00008000
+#define MSC01_PCI_CFG_EN_BIT		MSC01_PCI_CFG_EN_MSK
+#define MSC01_PCI_CFG_MAXRTRY_SHF	0
+#define MSC01_PCI_CFG_MAXRTRY_MSK	0x00000fff
 
 #define MSC01_PCI_SWAP_IO_SHF		18
 #define MSC01_PCI_SWAP_IO_MSK		0x000c0000
@@ -219,19 +220,19 @@ extern unsigned long _pcictrl_msc;
  * Registers absolute addresses
  */
 
-#define MSC01_PCI_ID            (MSC01_PCI_REG_BASE + MSC01_PCI_ID_OFS)
-#define MSC01_PCI_SC2PMBASL     (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMBASL_OFS)
-#define MSC01_PCI_SC2PMMSKL     (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMSKL_OFS)
-#define MSC01_PCI_SC2PMMAPL     (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMAPL_OFS)
-#define MSC01_PCI_SC2PIOBASL    (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOBASL_OFS)
-#define MSC01_PCI_SC2PIOMSKL    (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMSKL_OFS)
-#define MSC01_PCI_SC2PIOMAPL    (MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMAPL_OFS)
-#define MSC01_PCI_P2SCMSKL      (MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMSKL_OFS)
-#define MSC01_PCI_P2SCMAPL      (MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMAPL_OFS)
-#define MSC01_PCI_INTCFG        (MSC01_PCI_REG_BASE + MSC01_PCI_INTCFG_OFS)
-#define MSC01_PCI_INTSTAT       (MSC01_PCI_REG_BASE + MSC01_PCI_INTSTAT_OFS)
-#define MSC01_PCI_CFGADDR       (MSC01_PCI_REG_BASE + MSC01_PCI_CFGADDR_OFS)
-#define MSC01_PCI_CFGDATA       (MSC01_PCI_REG_BASE + MSC01_PCI_CFGDATA_OFS)
+#define MSC01_PCI_ID		(MSC01_PCI_REG_BASE + MSC01_PCI_ID_OFS)
+#define MSC01_PCI_SC2PMBASL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMBASL_OFS)
+#define MSC01_PCI_SC2PMMSKL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMSKL_OFS)
+#define MSC01_PCI_SC2PMMAPL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PMMAPL_OFS)
+#define MSC01_PCI_SC2PIOBASL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOBASL_OFS)
+#define MSC01_PCI_SC2PIOMSKL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMSKL_OFS)
+#define MSC01_PCI_SC2PIOMAPL	(MSC01_PCI_REG_BASE + MSC01_PCI_SC2PIOMAPL_OFS)
+#define MSC01_PCI_P2SCMSKL	(MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMSKL_OFS)
+#define MSC01_PCI_P2SCMAPL	(MSC01_PCI_REG_BASE + MSC01_PCI_P2SCMAPL_OFS)
+#define MSC01_PCI_INTCFG	(MSC01_PCI_REG_BASE + MSC01_PCI_INTCFG_OFS)
+#define MSC01_PCI_INTSTAT	(MSC01_PCI_REG_BASE + MSC01_PCI_INTSTAT_OFS)
+#define MSC01_PCI_CFGADDR	(MSC01_PCI_REG_BASE + MSC01_PCI_CFGADDR_OFS)
+#define MSC01_PCI_CFGDATA	(MSC01_PCI_REG_BASE + MSC01_PCI_CFGDATA_OFS)
 #define MSC01_PCI_IACK		(MSC01_PCI_REG_BASE + MSC01_PCI_IACK_OFS)
 #define MSC01_PCI_HEAD0		(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD0_OFS)
 #define MSC01_PCI_HEAD1		(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD1_OFS)
@@ -248,7 +249,7 @@ extern unsigned long _pcictrl_msc;
 #define MSC01_PCI_HEAD12	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
 #define MSC01_PCI_HEAD13	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
 #define MSC01_PCI_HEAD14	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
-#define MSC01_PCI_HEAD15        (MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
+#define MSC01_PCI_HEAD15	(MSC01_PCI_REG_BASE + MSC01_PCI_HEAD11_OFS)
 #define MSC01_PCI_BAR0		(MSC01_PCI_REG_BASE + MSC01_PCI_BAR0_OFS)
 #define MSC01_PCI_CFG		(MSC01_PCI_REG_BASE + MSC01_PCI_CFG_OFS)
 #define MSC01_PCI_SWAP		(MSC01_PCI_REG_BASE + MSC01_PCI_SWAP_OFS)
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mipsregs.h linux_HEAD/include/asm-mips/mipsregs.h
--- linux-2.6.11.6/include/asm-mips/mipsregs.h	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/include/asm-mips/mipsregs.h	2005-02-17 21:50:43.000000000 +0100
@@ -790,10 +790,18 @@ do {									\
 #define read_c0_config1()	__read_32bit_c0_register($16, 1)
 #define read_c0_config2()	__read_32bit_c0_register($16, 2)
 #define read_c0_config3()	__read_32bit_c0_register($16, 3)
+#define read_c0_config4()	__read_32bit_c0_register($16, 4)
+#define read_c0_config5()	__read_32bit_c0_register($16, 5)
+#define read_c0_config6()	__read_32bit_c0_register($16, 6)
+#define read_c0_config7()	__read_32bit_c0_register($16, 7)
 #define write_c0_config(val)	__write_32bit_c0_register($16, 0, val)
 #define write_c0_config1(val)	__write_32bit_c0_register($16, 1, val)
 #define write_c0_config2(val)	__write_32bit_c0_register($16, 2, val)
 #define write_c0_config3(val)	__write_32bit_c0_register($16, 3, val)
+#define write_c0_config4(val)	__write_32bit_c0_register($16, 4, val)
+#define write_c0_config5(val)	__write_32bit_c0_register($16, 5, val)
+#define write_c0_config6(val)	__write_32bit_c0_register($16, 6, val)
+#define write_c0_config7(val)	__write_32bit_c0_register($16, 7, val)
 
 /*
  * The WatchLo register.  There may be upto 8 of them.
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/mmu_context.h linux_HEAD/include/asm-mips/mmu_context.h
--- linux-2.6.11.6/include/asm-mips/mmu_context.h	2005-03-26 04:28:20.000000000 +0100
+++ linux_HEAD/include/asm-mips/mmu_context.h	2005-03-14 02:10:59.000000000 +0100
@@ -30,7 +30,7 @@ extern unsigned long pgd_current[];
 
 #ifdef CONFIG_MIPS32
 #define TLBMISS_HANDLER_SETUP()						\
-	write_c0_context((unsigned long) smp_processor_id() << 23);	\
+	write_c0_context((unsigned long) smp_processor_id() << 25);	\
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 #endif
 #if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
@@ -40,7 +40,7 @@ extern unsigned long pgd_current[];
 #endif
 #if defined(CONFIG_MIPS64) && defined(CONFIG_BUILD_ELF64)
 #define TLBMISS_HANDLER_SETUP()						\
-	write_c0_context((unsigned long) smp_processor_id() << 23);	\
+	write_c0_context((unsigned long) smp_processor_id() << 26);	\
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 #endif
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/module.h linux_HEAD/include/asm-mips/module.h
--- linux-2.6.11.6/include/asm-mips/module.h	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/include/asm-mips/module.h	2005-01-31 02:45:43.000000000 +0100
@@ -14,15 +14,23 @@ struct mod_arch_specific {
 
 typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
 
-typedef struct
-{
-  Elf64_Addr r_offset;			/* Address of relocation.  */
-  Elf64_Word r_sym;			/* Symbol index.  */
-  Elf64_Byte r_ssym;			/* Special symbol.  */
-  Elf64_Byte r_type3;			/* Third relocation.  */
-  Elf64_Byte r_type2;			/* Second relocation.  */
-  Elf64_Byte r_type;			/* First relocation.  */
-  Elf64_Sxword r_addend;		/* Addend.  */
+typedef struct {
+	Elf64_Addr r_offset;			/* Address of relocation.  */
+	Elf64_Word r_sym;			/* Symbol index.  */
+	Elf64_Byte r_ssym;			/* Special symbol.  */
+	Elf64_Byte r_type3;			/* Third relocation.  */
+	Elf64_Byte r_type2;			/* Second relocation.  */
+	Elf64_Byte r_type;			/* First relocation.  */
+} Elf64_Mips_Rel;
+
+typedef struct {
+	Elf64_Addr r_offset;			/* Address of relocation.  */
+	Elf64_Word r_sym;			/* Symbol index.  */
+	Elf64_Byte r_ssym;			/* Special symbol.  */
+	Elf64_Byte r_type3;			/* Third relocation.  */
+	Elf64_Byte r_type2;			/* Second relocation.  */
+	Elf64_Byte r_type;			/* First relocation.  */
+	Elf64_Sxword r_addend;			/* Addend.  */
 } Elf64_Mips_Rela;
 
 #ifdef CONFIG_MIPS32
@@ -30,6 +38,13 @@ typedef struct
 #define Elf_Shdr	Elf32_Shdr
 #define Elf_Sym		Elf32_Sym
 #define Elf_Ehdr	Elf32_Ehdr
+#define Elf_Addr	Elf32_Addr
+
+#define Elf_Mips_Rel	Elf32_Rel
+#define Elf_Mips_Rela	Elf32_Rela
+
+#define ELF_MIPS_R_SYM(rel) ELF32_R_SYM(rel.r_info)
+#define ELF_MIPS_R_TYPE(rel) ELF32_R_TYPE(rel.r_info)
 
 #endif
 
@@ -38,6 +53,13 @@ typedef struct
 #define Elf_Shdr	Elf64_Shdr
 #define Elf_Sym		Elf64_Sym
 #define Elf_Ehdr	Elf64_Ehdr
+#define Elf_Addr	Elf64_Addr
+
+#define Elf_Mips_Rel	Elf64_Mips_Rel
+#define Elf_Mips_Rela	Elf64_Mips_Rela
+
+#define ELF_MIPS_R_SYM(rel) (rel.r_sym)
+#define ELF_MIPS_R_TYPE(rel) (rel.r_type)
 
 #endif
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/paccess.h linux_HEAD/include/asm-mips/paccess.h
--- linux-2.6.11.6/include/asm-mips/paccess.h	2005-03-26 04:28:19.000000000 +0100
+++ linux_HEAD/include/asm-mips/paccess.h	2005-03-04 21:13:41.000000000 +0100
@@ -52,7 +52,7 @@ struct __large_pstruct { unsigned long b
 })
 
 #define __get_dbe_asm(insn)						\
-({									\
+{									\
 	__asm__ __volatile__(						\
 	"1:\t" insn "\t%1,%2\n\t"					\
 	"move\t%0,$0\n"							\
@@ -67,7 +67,7 @@ struct __large_pstruct { unsigned long b
 	".previous"							\
 	:"=r" (__gu_err), "=r" (__gu_val)				\
 	:"o" (__mp(__gu_addr)), "i" (-EFAULT));				\
-})
+}
 
 extern void __get_dbe_unknown(void);
 
@@ -90,7 +90,7 @@ extern void __get_dbe_unknown(void);
 })
 
 #define __put_dbe_asm(insn)						\
-({									\
+{									\
 	__asm__ __volatile__(						\
 	"1:\t" insn "\t%1,%2\n\t"					\
 	"move\t%0,$0\n"							\
@@ -104,7 +104,7 @@ extern void __get_dbe_unknown(void);
 	".previous"							\
 	: "=r" (__pu_err)						\
 	: "r" (__pu_val), "o" (__mp(__pu_addr)), "i" (-EFAULT));	\
-})
+}
 
 extern void __put_dbe_unknown(void);
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/page.h linux_HEAD/include/asm-mips/page.h
--- linux-2.6.11.6/include/asm-mips/page.h	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/include/asm-mips/page.h	2005-02-17 21:50:43.000000000 +0100
@@ -87,21 +87,48 @@ static inline void copy_user_page(void *
 typedef struct { unsigned long pte; } pte_t;
 #define pte_val(x)	((x).pte)
 #endif
+#define __pte(x)	((pte_t) { (x) } )
 
-typedef struct { unsigned long pmd; } pmd_t;
-typedef struct { unsigned long pgd; } pgd_t;
-typedef struct { unsigned long pgprot; } pgprot_t;
+/*
+ * For 3-level pagetables we defines these ourselves, for 2-level the
+ * definitions are supplied by <asm-generic/pgtable-nopmd.h>.
+ */
+#ifdef CONFIG_MIPS64
 
+typedef struct { unsigned long pmd; } pmd_t;
 #define pmd_val(x)	((x).pmd)
+#define __pmd(x)	((pmd_t) { (x) } )
+
+#endif
+
+/*
+ * Right now we don't support 4-level pagetables, so all pud-related
+ * definitions come from <asm-generic/pgtable-nopud.h>.
+ */
+
+/*
+ * Finall the top of the hierarchy, the pgd
+ */
+typedef struct { unsigned long pgd; } pgd_t;
 #define pgd_val(x)	((x).pgd)
+#define __pgd(x)	((pgd_t) { (x) } )
+
+/*
+ * Manipulate page protection bits
+ */
+typedef struct { unsigned long pgprot; } pgprot_t;
 #define pgprot_val(x)	((x).pgprot)
+#define __pgprot(x)	((pgprot_t) { (x) } )
 
+/*
+ * On R4000-style MMUs where a TLB entry is mapping a adjacent even / odd
+ * pair of pages we only have a single global bit per pair of pages.  When
+ * writing to the TLB make sure we always have the bit set for both pages
+ * or none.  This macro is used to access the `buddy' of the pte we're just
+ * working on.
+ */
 #define ptep_buddy(x)	((pte_t *)((unsigned long)(x) ^ sizeof(pte_t)))
 
-#define __pte(x)	((pte_t) { (x) } )
-#define __pmd(x)	((pmd_t) { (x) } )
-#define __pgd(x)	((pgd_t) { (x) } )
-#define __pgprot(x)	((pgprot_t) { (x) } )
 
 /* Pure 2^n version of get_order */
 static __inline__ int get_order(unsigned long size)
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/pgalloc.h linux_HEAD/include/asm-mips/pgalloc.h
--- linux-2.6.11.6/include/asm-mips/pgalloc.h	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/include/asm-mips/pgalloc.h	2005-02-17 21:50:43.000000000 +0100
@@ -26,10 +26,22 @@ static inline void pmd_populate(struct m
 }
 
 /*
+ * Initialize a new pmd table with invalid pointers.
+ */
+extern void pmd_init(unsigned long page, unsigned long pagetable);
+
+#ifdef CONFIG_MIPS64
+
+static inline void pud_populate(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
+{
+	set_pud(pud, __pud((unsigned long)pmd));
+}
+#endif
+
+/*
  * Initialize a new pgd / pmd table with invalid pointers.
  */
 extern void pgd_init(unsigned long page);
-extern void pmd_init(unsigned long page, unsigned long pagetable);
 
 static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
@@ -86,21 +98,18 @@ static inline void pte_free(struct page 
 #define __pte_free_tlb(tlb,pte)		tlb_remove_page((tlb),(pte))
 
 #ifdef CONFIG_MIPS32
-#define pgd_populate(mm, pmd, pte)	BUG()
 
 /*
  * allocating and freeing a pmd is trivial: the 1-entry pmd is
  * inside the pgd, so has no extra memory associated with it.
  */
-#define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
 #define pmd_free(x)			do { } while (0)
 #define __pmd_free_tlb(tlb,x)		do { } while (0)
+
 #endif
 
 #ifdef CONFIG_MIPS64
 
-#define pgd_populate(mm, pgd, pmd)	set_pgd(pgd, __pgd(pmd))
-
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
 {
 	pmd_t *pmd;
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/pgtable-32.h linux_HEAD/include/asm-mips/pgtable-32.h
--- linux-2.6.11.6/include/asm-mips/pgtable-32.h	2005-03-26 04:28:21.000000000 +0100
+++ linux_HEAD/include/asm-mips/pgtable-32.h	2005-02-19 14:05:07.000000000 +0100
@@ -17,6 +17,8 @@
 #include <asm/cachectl.h>
 #include <asm/fixmap.h>
 
+#include <asm-generic/pgtable-nopmd.h>
+
 /*
  * - add_wired_entry() add a fixed TLB entry, and move wired register
  */
@@ -41,42 +43,38 @@ extern int add_temporary_entry(unsigned 
  * works even with the cache aliasing problem the R4k and above have.
  */
 
-/* PMD_SHIFT determines the size of the area a second-level page table can map */
+/* PGDIR_SHIFT determines what a third-level page table entry can map */
 #ifdef CONFIG_64BIT_PHYS_ADDR
-#define PMD_SHIFT	21
+#define PGDIR_SHIFT	21
 #else
-#define PMD_SHIFT	22
+#define PGDIR_SHIFT	22
 #endif
-#define PMD_SIZE	(1UL << PMD_SHIFT)
-#define PMD_MASK	(~(PMD_SIZE-1))
-
-/* PGDIR_SHIFT determines what a third-level page table entry can map */
-#define PGDIR_SHIFT	PMD_SHIFT
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
 /*
  * Entries per page directory level: we use two-level, so
- * we don't really have any PMD directory physically.
+ * we don't really have any PUD/PMD directory physically.
  */
 #ifdef CONFIG_64BIT_PHYS_ADDR
 #define PGD_ORDER	1
-#define PMD_ORDER	0
+#define PUD_ORDER	aieeee_attempt_to_allocate_pud
+#define PMD_ORDER	1
 #define PTE_ORDER	0
 #else
 #define PGD_ORDER	0
-#define PMD_ORDER	0
+#define PUD_ORDER	aieeee_attempt_to_allocate_pud
+#define PMD_ORDER	1
 #define PTE_ORDER	0
 #endif
 
 #define PTRS_PER_PGD	((PAGE_SIZE << PGD_ORDER) / sizeof(pgd_t))
-#define PTRS_PER_PMD	1
 #define PTRS_PER_PTE	((PAGE_SIZE << PTE_ORDER) / sizeof(pte_t))
 
 #define USER_PTRS_PER_PGD	(0x80000000UL/PGDIR_SIZE)
 #define FIRST_USER_PGD_NR	0
 
-#define VMALLOC_START     KSEG2
+#define VMALLOC_START     MAP_BASE
 
 #ifdef CONFIG_HIGHMEM
 # define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
@@ -91,8 +89,6 @@ extern int add_temporary_entry(unsigned 
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
 #endif
-#define pmd_ERROR(e) \
-	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
 
@@ -120,16 +116,6 @@ static inline void pmd_clear(pmd_t *pmdp
 	pmd_val(*pmdp) = ((unsigned long) invalid_pte_table);
 }
 
-/*
- * The "pgd_xxx()" functions here are trivial for a folded two-level
- * setup: the pgd is never bad, and a pmd always exists (as it's folded
- * into the pgd entry)
- */
-static inline int pgd_none(pgd_t pgd)		{ return 0; }
-static inline int pgd_bad(pgd_t pgd)		{ return 0; }
-static inline int pgd_present(pgd_t pgd)	{ return 1; }
-static inline void pgd_clear(pgd_t *pgdp)	{ }
-
 #if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32)
 #define pte_page(x)		pfn_to_page(pte_pfn(x))
 #define pte_pfn(x)		((unsigned long)((x).pte_high >> 6))
@@ -156,22 +142,17 @@ pfn_pte(unsigned long pfn, pgprot_t prot
 #endif /* defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_CPU_MIPS32) */
 
 #define __pgd_offset(address)	pgd_index(address)
+#define __pud_offset(address)	(((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
 #define __pmd_offset(address)	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
 
 /* to find an entry in a kernel page-table-directory */
 #define pgd_offset_k(address) pgd_offset(&init_mm, address)
 
-#define pgd_index(address)	((address) >> PGDIR_SHIFT)
+#define pgd_index(address)	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
 
 /* to find an entry in a page-table-directory */
 #define pgd_offset(mm,addr)	((mm)->pgd + pgd_index(addr))
 
-/* Find an entry in the second-level page table.. */
-static inline pmd_t *pmd_offset(pgd_t *dir, unsigned long address)
-{
-	return (pmd_t *) dir;
-}
-
 /* Find an entry in the third-level page table.. */
 #define __pte_offset(address)						\
 	(((address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/pgtable-64.h linux_HEAD/include/asm-mips/pgtable-64.h
--- linux-2.6.11.6/include/asm-mips/pgtable-64.h	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/include/asm-mips/pgtable-64.h	2005-02-26 16:20:32.000000000 +0100
@@ -16,13 +16,15 @@
 #include <asm/page.h>
 #include <asm/cachectl.h>
 
+#include <asm-generic/pgtable-nopud.h>
+
 /*
  * Each address space has 2 4K pages as its page directory, giving 1024
  * (== PTRS_PER_PGD) 8 byte pointers to pmd tables. Each pmd table is a
- * pair of 4K pages, giving 1024 (== PTRS_PER_PMD) 8 byte pointers to
- * page tables. Each page table is a single 4K page, giving 512 (==
- * PTRS_PER_PTE) 8 byte ptes. Each pgde is initialized to point to
- * invalid_pmd_table, each pmde is initialized to point to
+ * single 4K page, giving 512 (== PTRS_PER_PMD) 8 byte pointers to page
+ * tables. Each page table is also a single 4K page, giving 512 (==
+ * PTRS_PER_PTE) 8 byte ptes. Each pud entry is initialized to point to
+ * invalid_pmd_table, each pmd entry is initialized to point to
  * invalid_pte_table, each pte is initialized to 0. When memory is low,
  * and a pmd table or a page table allocation fails, empty_bad_pmd_table
  * and empty_bad_page_table is returned back to higher layer code, so
@@ -36,17 +38,17 @@
  */
 
 /* PMD_SHIFT determines the size of the area a second-level page table can map */
-#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT - 3))
+#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT + PTE_ORDER - 3))
 #define PMD_SIZE	(1UL << PMD_SHIFT)
 #define PMD_MASK	(~(PMD_SIZE-1))
 
 /* PGDIR_SHIFT determines what a third-level page table entry can map */
-#define PGDIR_SHIFT	(PMD_SHIFT + (PAGE_SHIFT + 1 - 3))
+#define PGDIR_SHIFT	(PMD_SHIFT + (PAGE_SHIFT + PMD_ORDER - 3))
 #define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
 /*
- * For 4kB page size we use a 3 level page tree and a 8kB pmd and pgds which
+ * For 4kB page size we use a 3 level page tree and an 8kB pud, which
  * permits us mapping 40 bits of virtual address space.
  *
  * We used to implement 41 bits by having an order 1 pmd level but that seemed
@@ -57,7 +59,7 @@
  * two levels would be easy to implement.
  *
  * For 16kB page size we use a 2 level page tree which permits a total of
- * 36 bits of virtual address space.  We could add a third leve. but it seems
+ * 36 bits of virtual address space.  We could add a third level but it seems
  * like at the moment there's no need for this.
  *
  * For 64kB page size we use a 2 level page table tree for a total of 42 bits
@@ -65,21 +67,25 @@
  */
 #ifdef CONFIG_PAGE_SIZE_4KB
 #define PGD_ORDER		1
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
 #ifdef CONFIG_PAGE_SIZE_8KB
 #define PGD_ORDER		0
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
 #ifdef CONFIG_PAGE_SIZE_16KB
 #define PGD_ORDER		0
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
 #ifdef CONFIG_PAGE_SIZE_64KB
 #define PGD_ORDER		0
+#define PUD_ORDER		aieeee_attempt_to_allocate_pud
 #define PMD_ORDER		0
 #define PTE_ORDER		0
 #endif
@@ -91,7 +97,7 @@
 #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
 #define FIRST_USER_PGD_NR	0
 
-#define VMALLOC_START		XKSEG
+#define VMALLOC_START		MAP_BASE
 #define VMALLOC_END	\
 	(VMALLOC_START + PTRS_PER_PGD * PTRS_PER_PMD * PTRS_PER_PTE * PAGE_SIZE)
 
@@ -102,13 +108,13 @@
 #define pgd_ERROR(e) \
 	printk("%s:%d: bad pgd %016lx.\n", __FILE__, __LINE__, pgd_val(e))
 
-extern pte_t invalid_pte_table[PAGE_SIZE/sizeof(pte_t)];
-extern pte_t empty_bad_page_table[PAGE_SIZE/sizeof(pte_t)];
-extern pmd_t invalid_pmd_table[2*PAGE_SIZE/sizeof(pmd_t)];
-extern pmd_t empty_bad_pmd_table[2*PAGE_SIZE/sizeof(pmd_t)];
+extern pte_t invalid_pte_table[PTRS_PER_PTE];
+extern pte_t empty_bad_page_table[PTRS_PER_PTE];
+extern pmd_t invalid_pmd_table[PTRS_PER_PMD];
+extern pmd_t empty_bad_pmd_table[PTRS_PER_PMD];
 
 /*
- * Empty pmd entries point to the invalid_pte_table.
+ * Empty pgd/pmd entries point to the invalid_pte_table.
  */
 static inline int pmd_none(pmd_t pmd)
 {
@@ -128,26 +134,30 @@ static inline void pmd_clear(pmd_t *pmdp
 }
 
 /*
- * Empty pgd entries point to the invalid_pmd_table.
+ * Empty pud entries point to the invalid_pmd_table.
  */
-static inline int pgd_none(pgd_t pgd)
+static inline int pud_none(pud_t pud)
 {
-	return pgd_val(pgd) == (unsigned long) invalid_pmd_table;
+	return pud_val(pud) == (unsigned long) invalid_pmd_table;
 }
 
-#define pgd_bad(pgd)		(pgd_val(pgd) &~ PAGE_MASK)
+static inline int pud_bad(pud_t pud)
+{
+	return pud_val(pud) & ~PAGE_MASK;
+}
 
-static inline int pgd_present(pgd_t pgd)
+static inline int pud_present(pud_t pud)
 {
-	return pgd_val(pgd) != (unsigned long) invalid_pmd_table;
+	return pud_val(pud) != (unsigned long) invalid_pmd_table;
 }
 
-static inline void pgd_clear(pgd_t *pgdp)
+static inline void pud_clear(pud_t *pudp)
 {
-	pgd_val(*pgdp) = ((unsigned long) invalid_pmd_table);
+	pud_val(*pudp) = ((unsigned long) invalid_pmd_table);
 }
 
-#define pte_page(x)		pfn_to_page((unsigned long)((pte_val(x) >> PAGE_SHIFT)))
+#define pte_page(x)		pfn_to_page(pte_pfn(x))
+
 #ifdef CONFIG_CPU_VR41XX
 #define pte_pfn(x)		((unsigned long)((x).pte >> (PAGE_SHIFT + 2)))
 #define pfn_pte(pfn, prot)	__pte(((pfn) << (PAGE_SHIFT + 2)) | pgprot_val(prot))
@@ -157,26 +167,28 @@ static inline void pgd_clear(pgd_t *pgdp
 #endif
 
 #define __pgd_offset(address)	pgd_index(address)
+#define __pud_offset(address)	(((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
+#define __pmd_offset(address)	pmd_index(address)
 #define page_pte(page) page_pte_prot(page, __pgprot(0))
 
 /* to find an entry in a kernel page-table-directory */
 #define pgd_offset_k(address) pgd_offset(&init_mm, 0)
 
-#define pgd_index(address)		((address) >> PGDIR_SHIFT)
+#define pgd_index(address)	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pmd_index(address)	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
 
 /* to find an entry in a page-table-directory */
 #define pgd_offset(mm,addr)	((mm)->pgd + pgd_index(addr))
 
-static inline unsigned long pgd_page(pgd_t pgd)
+static inline unsigned long pud_page(pud_t pud)
 {
-	return pgd_val(pgd);
+	return pud_val(pud);
 }
 
 /* Find an entry in the second-level page table.. */
-static inline pmd_t *pmd_offset(pgd_t * dir, unsigned long address)
+static inline pmd_t *pmd_offset(pud_t * pud, unsigned long address)
 {
-	return (pmd_t *) pgd_page(*dir) +
-	       ((address >> PMD_SHIFT) & (PTRS_PER_PMD - 1));
+	return (pmd_t *) pud_page(*pud) + pmd_index(address);
 }
 
 /* Find an entry in the third-level page table.. */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/pgtable.h linux_HEAD/include/asm-mips/pgtable.h
--- linux-2.6.11.6/include/asm-mips/pgtable.h	2005-04-03 00:13:08.000000000 +0200
+++ linux_HEAD/include/asm-mips/pgtable.h	2005-03-21 20:04:58.000000000 +0100
@@ -8,8 +8,6 @@
 #ifndef _ASM_PGTABLE_H
 #define _ASM_PGTABLE_H
 
-#include <asm-generic/4level-fixup.h>
-
 #include <linux/config.h>
 #ifdef CONFIG_MIPS32
 #include <asm/pgtable-32.h>
@@ -146,11 +144,18 @@ static inline void pte_clear(struct mm_s
 #endif
 
 /*
- * (pmds are folded into pgds so this doesn't get actually called,
+ * (pmds are folded into puds so this doesn't get actually called,
  * but the define is needed for a generic inline function.)
  */
 #define set_pmd(pmdptr, pmdval) do { *(pmdptr) = (pmdval); } while(0)
-#define set_pgd(pgdptr, pgdval) do { *(pgdptr) = (pgdval); } while(0)
+
+#ifdef CONFIG_MIPS64
+/*
+ * (puds are folded into pgds so this doesn't get actually called,
+ * but the define is needed for a generic inline function.)
+ */
+#define set_pud(pudptr, pudval) do { *(pudptr) = (pudval); } while(0)
+#endif
 
 #define PGD_T_LOG2	ffz(~sizeof(pgd_t))
 #define PMD_T_LOG2	ffz(~sizeof(pmd_t))
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/serial.h linux_HEAD/include/asm-mips/serial.h
--- linux-2.6.11.6/include/asm-mips/serial.h	2005-03-26 04:28:39.000000000 +0100
+++ linux_HEAD/include/asm-mips/serial.h	2005-03-04 20:36:14.000000000 +0100
@@ -78,16 +78,6 @@
 #define JAZZ_SERIAL_PORT_DEFNS
 #endif
 
-#ifdef CONFIG_MIPS_COBALT
-#include <asm/cobalt/cobalt.h>
-#define COBALT_BASE_BAUD  (18432000 / 16)
-#define COBALT_SERIAL_PORT_DEFNS		\
-	/* UART CLK   PORT  IRQ  FLAGS    */ 		\
-	{ 0, COBALT_BASE_BAUD, 0xc800000, COBALT_SERIAL_IRQ, STD_COM_FLAGS },   /* ttyS0 */
-#else
-#define COBALT_SERIAL_PORT_DEFNS
-#endif
-
 /*
  * Both Galileo boards have the same UART mappings.
  */
@@ -139,17 +129,6 @@
 #define IVR_SERIAL_PORT_DEFNS
 #endif
 
-#ifdef CONFIG_TOSHIBA_JMR3927
-#include <asm/jmr3927/jmr3927.h>
-#define TXX927_SERIAL_PORT_DEFNS                              \
-    { .baud_base = JMR3927_BASE_BAUD, .port = UART0_ADDR, .irq = UART0_INT,  \
-      .flags = UART0_FLAGS, .type = 1 },                        \
-    { .baud_base = JMR3927_BASE_BAUD, .port = UART1_ADDR, .irq = UART1_INT,  \
-      .flags = UART1_FLAGS, .type = 1 },
-#else
-#define TXX927_SERIAL_PORT_DEFNS
-#endif
-
 #ifdef CONFIG_SERIAL_AU1X00
 #include <asm/mach-au1x00/au1000.h>
 #ifdef CONFIG_SOC_AU1000
@@ -309,9 +288,9 @@
 #define JAGUAR_ATX_SERIAL1_BASE	0xfd000023L
 
 #define _JAGUAR_ATX_SERIAL_INIT(int, base)				\
-	{ baud_base: JAGUAR_ATX_BASE_BAUD, irq: int,			\
-	  flags: (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),		\
-	  iomem_base: (u8 *) base, iomem_reg_shift: 2,			\
+	{ .baud_base = JAGUAR_ATX_BASE_BAUD, irq: int,			\
+	  .flags = (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST),		\
+	  .iomem_base = (u8 *) base, iomem_reg_shift: 2,			\
 	  io_type: SERIAL_IO_MEM }
 #define MOMENCO_JAGUAR_ATX_SERIAL_PORT_DEFNS				\
 	_JAGUAR_ATX_SERIAL_INIT(JAGUAR_ATX_SERIAL1_IRQ, JAGUAR_ATX_SERIAL1_BASE)
@@ -325,9 +304,9 @@
 #define OCELOT_3_SERIAL_BASE	(signed)0xfd000020
 
 #define _OCELOT_3_SERIAL_INIT(int, base)				\
-	{ baud_base: OCELOT_3_BASE_BAUD, irq: int, 			\
-	  flags: STD_COM_FLAGS,						\
-	  iomem_base: (u8 *) base, iomem_reg_shift: 2,			\
+	{ .baud_base = OCELOT_3_BASE_BAUD, irq: int, 			\
+	  .flags = STD_COM_FLAGS,						\
+	  .iomem_base = (u8 *) base, iomem_reg_shift: 2,			\
 	  io_type: SERIAL_IO_MEM }
 
 #define MOMENCO_OCELOT_3_SERIAL_PORT_DEFNS				\
@@ -424,7 +403,6 @@
 #endif /* CONFIG_SGI_IP32 */
 
 #define SERIAL_PORT_DFNS				\
-	COBALT_SERIAL_PORT_DEFNS			\
 	DDB5477_SERIAL_PORT_DEFNS			\
 	EV96100_SERIAL_PORT_DEFNS			\
 	EXTRA_SERIAL_PORT_DEFNS				\
@@ -438,7 +416,6 @@
 	MOMENCO_OCELOT_C_SERIAL_PORT_DEFNS		\
 	MOMENCO_OCELOT_SERIAL_PORT_DEFNS		\
 	MOMENCO_OCELOT_3_SERIAL_PORT_DEFNS		\
-	TXX927_SERIAL_PORT_DEFNS                        \
 	AU1000_SERIAL_PORT_DEFNS
 
 #endif /* _ASM_SERIAL_H */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/sibyte/board.h linux_HEAD/include/asm-mips/sibyte/board.h
--- linux-2.6.11.6/include/asm-mips/sibyte/board.h	2005-03-26 04:28:15.000000000 +0100
+++ linux_HEAD/include/asm-mips/sibyte/board.h	2005-02-17 21:50:45.000000000 +0100
@@ -21,8 +21,6 @@
 
 #include <linux/config.h>
 
-#ifdef CONFIG_SIBYTE_BOARD
-
 #if defined(CONFIG_SIBYTE_SWARM) || defined(CONFIG_SIBYTE_PTSWARM) || \
     defined(CONFIG_SIBYTE_CRHONE) || defined(CONFIG_SIBYTE_CRHINE) || \
     defined(CONFIG_SIBYTE_LITTLESUR)
@@ -54,16 +52,6 @@
 #define setleds(t0,t1,c0,c1,c2,c3)
 #endif /* LEDS_PHYS */
 
-#else
-
-#ifdef LEDS_PHYS
-extern void setleds(char *str);
-#else
-#define setleds(s) do { } while (0)
-#endif /* LEDS_PHYS */
-
 #endif /* __ASSEMBLY__ */
 
-#endif /* CONFIG_SIBYTE_BOARD */
-
 #endif /* _SIBYTE_BOARD_H */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/sibyte/sb1250.h linux_HEAD/include/asm-mips/sibyte/sb1250.h
--- linux-2.6.11.6/include/asm-mips/sibyte/sb1250.h	2005-03-26 04:28:25.000000000 +0100
+++ linux_HEAD/include/asm-mips/sibyte/sb1250.h	2005-02-24 00:13:20.000000000 +0100
@@ -58,6 +58,6 @@ extern void prom_printf(char *fmt, ...);
 
 #endif
 
-#define IOADDR(a) (IO_BASE + (a))
+#define IOADDR(a) ((void *)(IO_BASE + (a)))
 
 #endif
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/signal.h linux_HEAD/include/asm-mips/signal.h
--- linux-2.6.11.6/include/asm-mips/signal.h	2005-03-26 04:28:18.000000000 +0100
+++ linux_HEAD/include/asm-mips/signal.h	2005-03-01 22:49:44.000000000 +0100
@@ -120,7 +120,8 @@ typedef unsigned long old_sigset_t;		/* 
 				   set only the low 32 bit of the sigset.  */
 
 /* Type of a signal handler.  */
-typedef void (*__sighandler_t)(int);
+typedef void __signalfn_t(int);
+typedef __signalfn_t __user *__sighandler_t;
 
 /* Fake signal functions */
 #define SIG_DFL	((__sighandler_t)0)	/* default signal handling */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/spinlock.h linux_HEAD/include/asm-mips/spinlock.h
--- linux-2.6.11.6/include/asm-mips/spinlock.h	2005-03-26 04:28:37.000000000 +0100
+++ linux_HEAD/include/asm-mips/spinlock.h	2005-02-17 21:50:44.000000000 +0100
@@ -140,6 +140,18 @@ typedef struct {
 
 #define rwlock_init(x)  do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 
+/*
+ * read_can_lock - would read_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define read_can_lock(rw)	((rw)->lock >= 0)
+
+/*
+ * write_can_lock - would write_trylock() succeed?
+ * @lock: the rwlock in question.
+ */
+#define write_can_lock(rw)	(!(rw)->lock)
+
 static inline void _raw_read_lock(rwlock_t *rw)
 {
 	unsigned int tmp;
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/stackframe.h linux_HEAD/include/asm-mips/stackframe.h
--- linux-2.6.11.6/include/asm-mips/stackframe.h	2005-03-26 04:28:13.000000000 +0100
+++ linux_HEAD/include/asm-mips/stackframe.h	2005-03-14 02:30:45.000000000 +0100
@@ -60,7 +60,6 @@
 		mfc0	k0, CP0_CONTEXT
 		lui	k1, %hi(kernelsp)
 		srl	k0, k0, 23
-		sll	k0, k0, 2
 		addu	k1, k0
 		LONG_L	k1, %lo(kernelsp)(k1)
 #endif
@@ -76,9 +75,14 @@
 #endif
 #if defined(CONFIG_MIPS64) && defined(CONFIG_BUILD_ELF64)
 		MFC0	k1, CP0_CONTEXT
+		lui	k0, %highest(kernelsp)
 		dsrl	k1, 23
-		dsll	k1, k1, 3
-		LONG_L	k1, kernelsp(k1)
+		daddiu	k0, %higher(kernelsp)
+		dsll	k0, k0, 16
+		daddiu	k0, %hi(kernelsp)
+		dsll	k0, k0, 16
+		daddu	k1, k1, k0
+		LONG_L	k1, %lo(kernelsp)(k1)
 #endif
 		.endm
 
@@ -86,7 +90,6 @@
 #ifdef CONFIG_MIPS32
 		mfc0	\temp, CP0_CONTEXT
 		srl	\temp, 23
-		sll	\temp, 2
 		LONG_S	\stackp, kernelsp(\temp)
 #endif
 #if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
@@ -97,8 +100,8 @@
 		LONG_S	\stackp, %lo(kernelsp)(\temp)
 #endif
 #if defined(CONFIG_MIPS64) && defined(CONFIG_BUILD_ELF64)
-		lw	\temp, TI_CPU(gp)
-		dsll	\temp, 3
+		MFC0	\temp, CP0_CONTEXT
+		dsrl	\temp, 23
 		LONG_S	\stackp, kernelsp(\temp)
 #endif
 		.endm
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/thread_info.h linux_HEAD/include/asm-mips/thread_info.h
--- linux-2.6.11.6/include/asm-mips/thread_info.h	2005-03-26 04:28:13.000000000 +0100
+++ linux_HEAD/include/asm-mips/thread_info.h	2005-03-21 20:04:59.000000000 +0100
@@ -114,6 +114,7 @@ register struct thread_info *__current_t
 #define TIF_SIGPENDING		2	/* signal pending */
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
 #define TIF_SYSCALL_AUDIT	4	/* syscall auditing active */
+#define TIF_SECCOMP		5	/* secure computing */
 #define TIF_USEDFPU		16	/* FPU was used by this task this quantum (SMP) */
 #define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
 #define TIF_MEMDIE		18
@@ -124,13 +125,14 @@ register struct thread_info *__current_t
 #define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
 #define _TIF_SYSCALL_AUDIT	(1<<TIF_SYSCALL_AUDIT)
+#define _TIF_SECCOMP		(1<<TIF_SECCOMP)
 #define _TIF_USEDFPU		(1<<TIF_USEDFPU)
 #define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
 
-#define _TIF_WORK_MASK		0x0000ffef	/* work to do on
-                                                   interrupt/exception return */
-#define _TIF_ALLWORK_MASK	0x8000ffff	/* work to do on any return to
-                                                   u-space */
+/* work to do on interrupt/exception return */
+#define _TIF_WORK_MASK		(0x0000ffef & ~_TIF_SECCOMP)
+/* work to do on any return to u-space */
+#define _TIF_ALLWORK_MASK	(0x8000ffff & ~_TIF_SECCOMP)	
 
 #endif /* __KERNEL__ */
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/uaccess.h linux_HEAD/include/asm-mips/uaccess.h
--- linux-2.6.11.6/include/asm-mips/uaccess.h	2005-04-03 00:13:08.000000000 +0200
+++ linux_HEAD/include/asm-mips/uaccess.h	2005-03-21 20:04:59.000000000 +0100
@@ -219,62 +220,58 @@ static inline int __deprecated verify_ar
 	__get_user_nocheck((x),(ptr),sizeof(*(ptr)))
 
 struct __large_struct { unsigned long buf[100]; };
-#define __m(x) (*(struct __large_struct *)(x))
+#define __m(x) (*(struct __large_struct __user *)(x))
 
 /*
  * Yuck.  We need two variants, one for 64bit operation and one
  * for 32 bit mode and old iron.
  */
 #ifdef __mips64
-#define __GET_USER_DW(__gu_err) __get_user_asm("ld", __gu_err)
+#define __GET_USER_DW(ptr) __get_user_asm("ld", ptr)
 #else
-#define __GET_USER_DW(__gu_err) __get_user_asm_ll32(__gu_err)
+#define __GET_USER_DW(ptr) __get_user_asm_ll32(ptr)
 #endif
 
 #define __get_user_nocheck(x,ptr,size)					\
 ({									\
-	__typeof(*(ptr)) __gu_val = 0;					\
-	long __gu_addr;							\
+	__typeof(*(ptr)) __gu_val =  (__typeof(*(ptr))) 0;		\
 	long __gu_err = 0;						\
 									\
 	might_sleep();							\
-	__gu_addr = (long) (ptr);					\
 	switch (size) {							\
-	case 1: __get_user_asm("lb", __gu_err); break;			\
-	case 2: __get_user_asm("lh", __gu_err); break;			\
-	case 4: __get_user_asm("lw", __gu_err); break;			\
-	case 8: __GET_USER_DW(__gu_err); break;				\
+	case 1: __get_user_asm("lb", ptr); break;			\
+	case 2: __get_user_asm("lh", ptr); break;			\
+	case 4: __get_user_asm("lw", ptr); break;			\
+	case 8: __GET_USER_DW(ptr); break;				\
 	default: __get_user_unknown(); break;				\
 	}								\
-	x = (__typeof__(*(ptr))) __gu_val;				\
+	(x) = (__typeof__(*(ptr))) __gu_val;				\
 	__gu_err;							\
 })
 
 #define __get_user_check(x,ptr,size)					\
 ({									\
+	const __typeof__(*(ptr)) __user * __gu_addr = (ptr);		\
 	__typeof__(*(ptr)) __gu_val = 0;				\
-	long __gu_addr;							\
-	long __gu_err;							\
+	long __gu_err = -EFAULT;					\
 									\
 	might_sleep();							\
-	__gu_addr = (long) (ptr);					\
-	__gu_err = verify_area(VERIFY_READ, (void *) __gu_addr, size);	\
 									\
-	if (likely(!__gu_err)) {					\
+	if (likely(access_ok(VERIFY_READ,  __gu_addr, size))) {		\
 		switch (size) {						\
-		case 1: __get_user_asm("lb", __gu_err); break;		\
-		case 2: __get_user_asm("lh", __gu_err); break;		\
-		case 4: __get_user_asm("lw", __gu_err); break;		\
-		case 8: __GET_USER_DW(__gu_err); break;			\
+		case 1: __get_user_asm("lb", __gu_addr); break;		\
+		case 2: __get_user_asm("lh", __gu_addr); break;		\
+		case 4: __get_user_asm("lw", __gu_addr); break;		\
+		case 8: __GET_USER_DW(__gu_addr); break;		\
 		default: __get_user_unknown(); break;			\
 		}							\
 	}								\
-	x = (__typeof__(*(ptr))) __gu_val;				\
+	(x) = (__typeof__(*(ptr))) __gu_val;				\
 	__gu_err;							\
 })
 
-#define __get_user_asm(insn,__gu_err)					\
-({									\
+#define __get_user_asm(insn, addr)					\
+{									\
 	__asm__ __volatile__(						\
 	"1:	" insn "	%1, %3				\n"	\
 	"2:							\n"	\
@@ -286,20 +283,20 @@ struct __large_struct { unsigned long bu
 	"	"__UA_ADDR "\t1b, 3b				\n"	\
 	"	.previous					\n"	\
 	: "=r" (__gu_err), "=r" (__gu_val)				\
-	: "0" (__gu_err), "o" (__m(__gu_addr)), "i" (-EFAULT));		\
-})
+	: "0" (0), "o" (__m(addr)), "i" (-EFAULT));			\
+}
 
 /*
  * Get a long long 64 using 32 bit registers.
  */
-#define __get_user_asm_ll32(__gu_err)					\
-({									\
+#define __get_user_asm_ll32(addr)					\
+{									\
 	__asm__ __volatile__(						\
-	"1:	lw	%1, %3					\n"	\
-	"2:	lw	%D1, %4					\n"	\
+	"1:	lw	%1, (%3)				\n"	\
+	"2:	lw	%D1, 4(%3)				\n"	\
 	"	move	%0, $0					\n"	\
 	"3:	.section	.fixup,\"ax\"			\n"	\
-	"4:	li	%0, %5					\n"	\
+	"4:	li	%0, %4					\n"	\
 	"	move	%1, $0					\n"	\
 	"	move	%D1, $0					\n"	\
 	"	j	3b					\n"	\
@@ -309,9 +306,8 @@ struct __large_struct { unsigned long bu
 	"	" __UA_ADDR "	2b, 4b				\n"	\
 	"	.previous					\n"	\
 	: "=r" (__gu_err), "=&r" (__gu_val)				\
-	: "0" (__gu_err), "o" (__m(__gu_addr)),				\
-	  "o" (__m(__gu_addr + 4)), "i" (-EFAULT));			\
-})
+	: "0" (0), "r" (addr), "i" (-EFAULT));				\
+}
 
 extern void __get_user_unknown(void);
 
@@ -320,25 +316,23 @@ extern void __get_user_unknown(void);
  * for 32 bit mode and old iron.
  */
 #ifdef __mips64
-#define __PUT_USER_DW(__pu_val) __put_user_asm("sd", __pu_val)
+#define __PUT_USER_DW(ptr) __put_user_asm("sd", ptr)
 #else
-#define __PUT_USER_DW(__pu_val) __put_user_asm_ll32(__pu_val)
+#define __PUT_USER_DW(ptr) __put_user_asm_ll32(ptr)
 #endif
 
 #define __put_user_nocheck(x,ptr,size)					\
 ({									\
 	__typeof__(*(ptr)) __pu_val;					\
-	long __pu_addr;							\
 	long __pu_err = 0;						\
 									\
 	might_sleep();							\
 	__pu_val = (x);							\
-	__pu_addr = (long) (ptr);					\
 	switch (size) {							\
-	case 1: __put_user_asm("sb", __pu_val); break;			\
-	case 2: __put_user_asm("sh", __pu_val); break;			\
-	case 4: __put_user_asm("sw", __pu_val); break;			\
-	case 8: __PUT_USER_DW(__pu_val); break;				\
+	case 1: __put_user_asm("sb", ptr); break;			\
+	case 2: __put_user_asm("sh", ptr); break;			\
+	case 4: __put_user_asm("sw", ptr); break;			\
+	case 8: __PUT_USER_DW(ptr); break;				\
 	default: __put_user_unknown(); break;				\
 	}								\
 	__pu_err;							\
@@ -346,29 +340,26 @@ extern void __get_user_unknown(void);
 
 #define __put_user_check(x,ptr,size)					\
 ({									\
-	__typeof__(*(ptr)) __pu_val;					\
-	long __pu_addr;							\
-	long __pu_err;							\
+	__typeof__(*(ptr)) __user *__pu_addr = (ptr);			\
+	__typeof__(*(ptr)) __pu_val = (x);				\
+	long __pu_err = -EFAULT;					\
 									\
 	might_sleep();							\
-	__pu_val = (x);							\
-	__pu_addr = (long) (ptr);					\
-	__pu_err = verify_area(VERIFY_WRITE, (void *) __pu_addr, size);	\
 									\
-	if (likely(!__pu_err)) {					\
+	if (likely(access_ok(VERIFY_WRITE,  __pu_addr, size))) {	\
 		switch (size) {						\
-		case 1: __put_user_asm("sb", __pu_val); break;		\
-		case 2: __put_user_asm("sh", __pu_val); break;		\
-		case 4: __put_user_asm("sw", __pu_val); break;		\
-		case 8: __PUT_USER_DW(__pu_val); break;			\
+		case 1: __put_user_asm("sb", __pu_addr); break;		\
+		case 2: __put_user_asm("sh", __pu_addr); break;		\
+		case 4: __put_user_asm("sw", __pu_addr); break;		\
+		case 8: __PUT_USER_DW(__pu_addr); break;		\
 		default: __put_user_unknown(); break;			\
 		}							\
 	}								\
 	__pu_err;							\
 })
 
-#define __put_user_asm(insn, __pu_val)					\
-({									\
+#define __put_user_asm(insn, ptr)					\
+{									\
 	__asm__ __volatile__(						\
 	"1:	" insn "	%z2, %3		# __put_user_asm\n"	\
 	"2:							\n"	\
@@ -380,18 +371,18 @@ extern void __get_user_unknown(void);
 	"	" __UA_ADDR "	1b, 3b				\n"	\
 	"	.previous					\n"	\
 	: "=r" (__pu_err)						\
-	: "0" (__pu_err), "Jr" (__pu_val), "o" (__m(__pu_addr)),	\
+	: "0" (0), "Jr" (__pu_val), "o" (__m(ptr)),			\
 	  "i" (-EFAULT));						\
-})
+}
 
-#define __put_user_asm_ll32(__pu_val)					\
-({									\
+#define __put_user_asm_ll32(ptr)					\
+{									\
 	__asm__ __volatile__(						\
-	"1:	sw	%2, %3		# __put_user_asm_ll32	\n"	\
-	"2:	sw	%D2, %4					\n"	\
+	"1:	sw	%2, (%3)	# __put_user_asm_ll32	\n"	\
+	"2:	sw	%D2, 4(%3)				\n"	\
 	"3:							\n"	\
 	"	.section	.fixup,\"ax\"			\n"	\
-	"4:	li	%0, %5					\n"	\
+	"4:	li	%0, %4					\n"	\
 	"	j	3b					\n"	\
 	"	.previous					\n"	\
 	"	.section	__ex_table,\"a\"		\n"	\
@@ -399,9 +390,9 @@ extern void __get_user_unknown(void);
 	"	" __UA_ADDR "	2b, 4b				\n"	\
 	"	.previous"						\
 	: "=r" (__pu_err)						\
-	: "0" (__pu_err), "r" (__pu_val), "o" (__m(__pu_addr)),		\
-	  "o" (__m(__pu_addr + 4)), "i" (-EFAULT));			\
-})
+	: "0" (0), "r" (__pu_val), "r" (ptr),				\
+	  "i" (-EFAULT));						\
+}
 
 extern void __put_user_unknown(void);
 
@@ -424,7 +415,7 @@ extern size_t __copy_user(void *__to, co
 
 #define __invoke_copy_to_user(to,from,n)				\
 ({									\
-	register void *__cu_to_r __asm__ ("$4");			\
+	register void __user *__cu_to_r __asm__ ("$4");			\
 	register const void *__cu_from_r __asm__ ("$5");		\
 	register long __cu_len_r __asm__ ("$6");			\
 									\
@@ -456,7 +447,7 @@ extern size_t __copy_user(void *__to, co
  */
 #define __copy_to_user(to,from,n)					\
 ({									\
-	void *__cu_to;							\
+	void __user __user *__cu_to;					\
 	const void *__cu_from;						\
 	long __cu_len;							\
 									\
@@ -486,7 +477,7 @@ extern size_t __copy_user(void *__to, co
  */
 #define copy_to_user(to,from,n)						\
 ({									\
-	void *__cu_to;							\
+	void __user *__cu_to;						\
 	const void *__cu_from;						\
 	long __cu_len;							\
 									\
@@ -503,7 +494,7 @@ extern size_t __copy_user(void *__to, co
 #define __invoke_copy_from_user(to,from,n)				\
 ({									\
 	register void *__cu_to_r __asm__ ("$4");			\
-	register const void *__cu_from_r __asm__ ("$5");		\
+	register const void __user *__cu_from_r __asm__ ("$5");		\
 	register long __cu_len_r __asm__ ("$6");			\
 									\
 	__cu_to_r = (to);						\
@@ -542,7 +533,7 @@ extern size_t __copy_user(void *__to, co
 #define __copy_from_user(to,from,n)					\
 ({									\
 	void *__cu_to;							\
-	const void *__cu_from;						\
+	const void __user *__cu_from;					\
 	long __cu_len;							\
 									\
 	might_sleep();							\
@@ -573,7 +564,7 @@ extern size_t __copy_user(void *__to, co
 #define copy_from_user(to,from,n)					\
 ({									\
 	void *__cu_to;							\
-	const void *__cu_from;						\
+	const void __user *__cu_from;					\
 	long __cu_len;							\
 									\
 	might_sleep();							\
@@ -590,8 +581,8 @@ extern size_t __copy_user(void *__to, co
 
 #define copy_in_user(to,from,n)						\
 ({									\
-	void *__cu_to;							\
-	const void *__cu_from;						\
+	void __user *__cu_to;						\
+	const void __user *__cu_from;					\
 	long __cu_len;							\
 									\
 	might_sleep();							\
@@ -617,7 +608,7 @@ extern size_t __copy_user(void *__to, co
  * On success, this will be zero.
  */
 static inline __kernel_size_t
-__clear_user(void *addr, __kernel_size_t size)
+__clear_user(void __user *addr, __kernel_size_t size)
 {
 	__kernel_size_t res;
 
@@ -637,7 +628,7 @@ __clear_user(void *addr, __kernel_size_t
 
 #define clear_user(addr,n)						\
 ({									\
-	void * __cl_addr = (addr);					\
+	void __user * __cl_addr = (addr);				\
 	unsigned long __cl_size = (n);					\
 	if (__cl_size && access_ok(VERIFY_WRITE,			\
 		((unsigned long)(__cl_addr)), __cl_size))		\
@@ -666,7 +657,7 @@ __clear_user(void *addr, __kernel_size_t
  * and returns @count.
  */
 static inline long
-__strncpy_from_user(char *__to, const char *__from, long __len)
+__strncpy_from_user(char *__to, const char __user *__from, long __len)
 {
 	long res;
 
@@ -703,7 +694,7 @@ __strncpy_from_user(char *__to, const ch
  * and returns @count.
  */
 static inline long
-strncpy_from_user(char *__to, const char *__from, long __len)
+strncpy_from_user(char *__to, const char __user *__from, long __len)
 {
 	long res;
 
@@ -722,7 +713,7 @@ strncpy_from_user(char *__to, const char
 }
 
 /* Returns: 0 if bad, string length+1 (memory size) of string if ok */
-static inline long __strlen_user(const char *s)
+static inline long __strlen_user(const char __user *s)
 {
 	long res;
 
@@ -752,7 +743,7 @@ static inline long __strlen_user(const c
  * If there is a limit on the length of a valid string, you may wish to
  * consider using strnlen_user() instead.
  */
-static inline long strlen_user(const char *s)
+static inline long strlen_user(const char __user *s)
 {
 	long res;
 
@@ -769,7 +760,7 @@ static inline long strlen_user(const cha
 }
 
 /* Returns: 0 if bad, string length+1 (memory size) of string if ok */
-static inline long __strnlen_user(const char *s, long n)
+static inline long __strnlen_user(const char __user *s, long n)
 {
 	long res;
 
@@ -800,7 +791,7 @@ static inline long __strnlen_user(const 
  * If there is a limit on the length of a valid string, you may wish to
  * consider using strnlen_user() instead.
  */
-static inline long strnlen_user(const char *s, long n)
+static inline long strnlen_user(const char __user *s, long n)
 {
 	long res;
 
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/vr41xx/pci.h linux_HEAD/include/asm-mips/vr41xx/pci.h
--- linux-2.6.11.6/include/asm-mips/vr41xx/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/include/asm-mips/vr41xx/pci.h	2005-03-07 19:42:17.000000000 +0100
@@ -0,0 +1,90 @@
+/*
+ *  Include file for NEC VR4100 series PCI Control Unit.
+ *
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __NEC_VR41XX_PCI_H
+#define __NEC_VR41XX_PCI_H
+
+#define PCI_MASTER_ADDRESS_MASK	0x7fffffffU
+
+struct pci_master_address_conversion {
+	uint32_t bus_base_address;
+	uint32_t address_mask;
+	uint32_t pci_base_address;
+};
+
+struct pci_target_address_conversion {
+	uint32_t address_mask;
+	uint32_t bus_base_address;
+};
+
+typedef enum {
+	CANNOT_LOCK_FROM_DEVICE,
+	CAN_LOCK_FROM_DEVICE,
+} pci_exclusive_access_t;
+
+struct pci_mailbox_address {
+	uint32_t base_address;
+};
+
+struct pci_target_address_window {
+	uint32_t base_address;
+};
+
+typedef enum {
+	PCI_ARBITRATION_MODE_FAIR,
+	PCI_ARBITRATION_MODE_ALTERNATE_0,
+	PCI_ARBITRATION_MODE_ALTERNATE_B,
+} pci_arbiter_priority_control_t;
+
+typedef enum {
+	PCI_TAKE_AWAY_GNT_DISABLE,
+	PCI_TAKE_AWAY_GNT_ENABLE,
+} pci_take_away_gnt_mode_t;
+
+struct pci_controller_unit_setup {
+	struct pci_master_address_conversion *master_memory1;
+	struct pci_master_address_conversion *master_memory2;
+
+	struct pci_target_address_conversion *target_memory1;
+	struct pci_target_address_conversion *target_memory2;
+
+	struct pci_master_address_conversion *master_io;
+
+	pci_exclusive_access_t exclusive_access;
+
+	uint32_t pci_clock_max;
+	uint8_t wait_time_limit_from_irdy_to_trdy;	/* Only VR4122 is supported */
+
+	struct pci_mailbox_address *mailbox;
+	struct pci_target_address_window *target_window1;
+	struct pci_target_address_window *target_window2;
+
+	uint8_t master_latency_timer;
+	uint8_t retry_limit;
+
+	pci_arbiter_priority_control_t arbiter_priority_control;
+	pci_take_away_gnt_mode_t take_away_gnt_mode;
+
+	struct resource *mem_resource;
+	struct resource *io_resource;
+};
+
+extern void vr41xx_pciu_setup(struct pci_controller_unit_setup *setup);
+
+#endif /* __NEC_VR41XX_PCI_H */
diff -urpNX dontdiff linux-2.6.11.6/include/asm-mips/vr41xx/vr41xx.h linux_HEAD/include/asm-mips/vr41xx/vr41xx.h
--- linux-2.6.11.6/include/asm-mips/vr41xx/vr41xx.h	2005-04-03 00:13:08.000000000 +0200
+++ linux_HEAD/include/asm-mips/vr41xx/vr41xx.h	2005-03-09 22:46:16.000000000 +0100
@@ -248,73 +247,31 @@ enum {
 };
 
 /*
- * PCI Control Unit
+ * Serial Interface Unit
  */
-#define PCI_MASTER_ADDRESS_MASK	0x7fffffffU
-
-struct pci_master_address_conversion {
-	uint32_t bus_base_address;
-	uint32_t address_mask;
-	uint32_t pci_base_address;
-};
-
-struct pci_target_address_conversion {
-	uint32_t address_mask;
-	uint32_t bus_base_address;
-};
+extern void vr41xx_siu_init(void);
+extern int vr41xx_serial_ports;
 
+/* SIU interfaces */
 typedef enum {
-	CANNOT_LOCK_FROM_DEVICE,
-	CAN_LOCK_FROM_DEVICE,
-} pci_exclusive_access_t;
-
-struct pci_mailbox_address {
-	uint32_t base_address;
-};
-
-struct pci_target_address_window {
-	uint32_t base_address;
-};
+	SIU_RS232C,
+	SIU_IRDA
+} siu_interface_t;
 
+/* IrDA interfaces */
 typedef enum {
-	PCI_ARBITRATION_MODE_FAIR,
-	PCI_ARBITRATION_MODE_ALTERNATE_0,
-	PCI_ARBITRATION_MODE_ALTERNATE_B,
-} pci_arbiter_priority_control_t;
-
-typedef enum {
-	PCI_TAKE_AWAY_GNT_DISABLE,
-	PCI_TAKE_AWAY_GNT_ENABLE,
-} pci_take_away_gnt_mode_t;
-
-struct pci_controller_unit_setup {
-	struct pci_master_address_conversion *master_memory1;
-	struct pci_master_address_conversion *master_memory2;
+	IRDA_NONE,
+	IRDA_SHARP,
+	IRDA_TEMIC,
+	IRDA_HP
+} irda_module_t;
 
-	struct pci_target_address_conversion *target_memory1;
-	struct pci_target_address_conversion *target_memory2;
+extern void vr41xx_select_siu_interface(siu_interface_t interface,
+                                        irda_module_t module);
 
-	struct pci_master_address_conversion *master_io;
-
-	pci_exclusive_access_t exclusive_access;
-
-	uint32_t pci_clock_max;
-	uint8_t wait_time_limit_from_irdy_to_trdy;	/* Only VR4122 is supported */
-
-	struct pci_mailbox_address *mailbox;
-	struct pci_target_address_window *target_window1;
-	struct pci_target_address_window *target_window2;
-
-	uint8_t master_latency_timer;
-	uint8_t retry_limit;
-
-	pci_arbiter_priority_control_t arbiter_priority_control;
-	pci_take_away_gnt_mode_t take_away_gnt_mode;
-
-	struct resource *mem_resource;
-	struct resource *io_resource;
-};
-
-extern void vr41xx_pciu_setup(struct pci_controller_unit_setup *setup);
+/*
+ * Debug Serial Interface Unit
+ */
+extern void vr41xx_dsiu_init(void);
 
 #endif /* __NEC_VR41XX_H */
diff -urpNX dontdiff linux-2.6.11.6/include/linux/ds17287rtc.h linux_HEAD/include/linux/ds17287rtc.h
--- linux-2.6.11.6/include/linux/ds17287rtc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/include/linux/ds17287rtc.h	2003-04-07 04:28:45.000000000 +0200
@@ -0,0 +1,68 @@
+/* 
+ * ds17287rtc.h - register definitions for the ds1728[57] RTC / CMOS RAM
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ * 
+ * (C) 2003 Guido Guenther <agx@sigxcpu.org>
+ *
+ */
+
+#ifndef _DS17287RTC_H
+#define _DS17287RTC_H
+
+#include <asm/io.h>
+#include <linux/rtc.h>			/* get the user-level API */
+#include <linux/spinlock.h>		/* spinlock_t */
+#include <linux/mc146818rtc.h>
+
+/* Register A */
+#define DS_REGA_DV2 0x40		/* countdown chain */
+#define DS_REGA_DV1 0x20		/* oscillator enable */
+#define DS_REGA_DV0 0x10		/* bank select */
+
+/* bank 1 registers */
+#define DS_B1_MODEL	 0x40		/* model number byte */
+#define DS_B1_SN1 	 0x41		/* serial number byte 1 */
+#define DS_B1_SN2 	 0x42		/* serial number byte 2 */
+#define DS_B1_SN3 	 0x43		/* serial number byte 3 */
+#define DS_B1_SN4 	 0x44		/* serial number byte 4 */
+#define DS_B1_SN5 	 0x45		/* serial number byte 5 */
+#define DS_B1_SN6 	 0x46		/* serial number byte 6 */
+#define DS_B1_CRC 	 0x47		/* CRC byte */
+#define DS_B1_CENTURY 	 0x48		/* Century byte */
+#define DS_B1_DALARM 	 0x49		/* date alarm */
+#define DS_B1_XCTRL4A	 0x4a		/* extendec control register 4a */
+#define DS_B1_XCTRL4B	 0x4b		/* extendec control register 4b */
+#define DS_B1_RTCADDR2 	 0x4e		/* rtc address 2 */
+#define DS_B1_RTCADDR3 	 0x4f		/* rtc address 3 */
+#define DS_B1_RAMLSB	 0x50		/* extended ram LSB */
+#define DS_B1_RAMMSB	 0x51		/* extended ram MSB */
+#define DS_B1_RAMDPORT	 0x53		/* extended ram data port */
+
+/* register details */
+/* extended control register 4a */
+#define DS_XCTRL4A_VRT2  0x80 		/* valid ram and time */
+#define DS_XCTRL4A_INCR  0x40		/* increment progress status */
+#define DS_XCTRL4A_BME   0x20		/* burst mode enable */
+#define DS_XCTRL4A_PAB   0x08		/* power active bar ctrl */
+#define DS_XCTRL4A_RF    0x04		/* ram clear flag */
+#define DS_XCTRL4A_WF    0x02		/* wake up alarm flag */
+#define DS_XCTRL4A_KF    0x01		/* kickstart flag */
+/* interrupt causes */
+#define DS_XCTRL4A_IFS	(DS_XCTRL4A_RF|DS_XCTRL4A_WF|DS_XCTRL4A_KF)
+
+/* extended control register 4b */
+#define DS_XCTRL4B_ABE   0x80 		/* auxiliary battery enable */
+#define DS_XCTRL4B_E32K	 0x40		/* enable 32.768 kHz Output */
+#define DS_XCTRL4B_CS    0x20		/* crystal select */
+#define DS_XCTRL4B_RCE   0x10		/* ram clear enable */
+#define DS_XCTRL4B_PRS   0x08		/* PAB resec select */
+#define DS_XCTRL4B_RIE   0x04		/* ram clear interrupt enable */
+#define DS_XCTRL4B_WFE   0x02		/* wake up alarm interrupt enable */
+#define DS_XCTRL4B_KFE   0x01		/* kickstart interrupt enable */
+/* interrupt enable bits */
+#define DS_XCTRL4B_IFES	(DS_XCTRL4B_RIE|DS_XCTRL4B_WFE|DS_XCTRL4B_KFE)
+
+#endif /* _DS17287RTC_H */
diff -urpNX dontdiff linux-2.6.11.6/include/linux/ds1742rtc.h linux_HEAD/include/linux/ds1742rtc.h
--- linux-2.6.11.6/include/linux/ds1742rtc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/include/linux/ds1742rtc.h	2003-11-18 06:15:20.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ * ds1742rtc.h - register definitions for the Real-Time-Clock / CMOS RAM
+ *
+ * Copyright (C) 1999-2001 Toshiba Corporation
+ * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ *
+ * Permission is hereby granted to copy, modify and redistribute this code
+ * in terms of the GNU Library General Public License, Version 2 or later,
+ * at your option.
+ */
+#ifndef __LINUX_DS1742RTC_H
+#define __LINUX_DS1742RTC_H
+
+#include <asm/ds1742.h>
+
+#define RTC_BRAM_SIZE		0x800
+#define RTC_OFFSET		0x7f8
+
+/*
+ * Register summary
+ */
+#define RTC_CONTROL		(RTC_OFFSET + 0)
+#define RTC_CENTURY		(RTC_OFFSET + 0)
+#define RTC_SECONDS		(RTC_OFFSET + 1)
+#define RTC_MINUTES		(RTC_OFFSET + 2)
+#define RTC_HOURS		(RTC_OFFSET + 3)
+#define RTC_DAY			(RTC_OFFSET + 4)
+#define RTC_DATE		(RTC_OFFSET + 5)
+#define RTC_MONTH		(RTC_OFFSET + 6)
+#define RTC_YEAR		(RTC_OFFSET + 7)
+
+#define RTC_CENTURY_MASK	0x3f
+#define RTC_SECONDS_MASK	0x7f
+#define RTC_DAY_MASK		0x07
+
+/*
+ * Bits in the Control/Century register
+ */
+#define RTC_WRITE		0x80
+#define RTC_READ		0x40
+
+/*
+ * Bits in the Seconds register
+ */
+#define RTC_STOP		0x80
+
+/*
+ * Bits in the Day register
+ */
+#define RTC_BATT_FLAG		0x80
+#define RTC_FREQ_TEST		0x40
+
+#endif /* __LINUX_DS1742RTC_H */
diff -urpNX dontdiff linux-2.6.11.6/include/linux/elf.h linux_HEAD/include/linux/elf.h
--- linux-2.6.11.6/include/linux/elf.h	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/include/linux/elf.h	2005-02-17 21:50:55.000000000 +0100
@@ -66,7 +66,7 @@ typedef __s64	Elf64_Sxword;
 
 #define EM_MIPS		8	/* MIPS R3000 (officially, big-endian only) */
 
-#define EM_MIPS_RS4_BE 10	/* MIPS R4000 big-endian */
+#define EM_MIPS_RS3_LE 10	/* MIPS R3000 little-endian */
 
 #define EM_PARISC      15	/* HPPA */
 
diff -urpNX dontdiff linux-2.6.11.6/include/linux/init.h linux_HEAD/include/linux/init.h
--- linux-2.6.11.6/include/linux/init.h	2005-03-26 04:28:14.000000000 +0100
+++ linux_HEAD/include/linux/init.h	2005-02-17 21:50:57.000000000 +0100
@@ -86,6 +86,8 @@ extern char saved_command_line[];
 	static initcall_t __initcall_##fn __attribute_used__ \
 	__attribute__((__section__(".initcall" level ".init"))) = fn
 
+#define early_initcall(fn)		__define_initcall(".early1",fn)
+
 #define core_initcall(fn)		__define_initcall("1",fn)
 #define postcore_initcall(fn)		__define_initcall("2",fn)
 #define arch_initcall(fn)		__define_initcall("3",fn)
diff -urpNX dontdiff linux-2.6.11.6/include/linux/mc146818rtc.h linux_HEAD/include/linux/mc146818rtc.h
--- linux-2.6.11.6/include/linux/mc146818rtc.h	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/include/linux/mc146818rtc.h	2004-12-04 20:57:43.000000000 +0100
@@ -89,4 +89,12 @@ extern spinlock_t rtc_lock;		/* serializ
 # define RTC_VRT 0x80		/* valid RAM and time */
 /**********************************************************************/
 
+#ifndef RTC_IO_EXTENT
+#define RTC_IO_EXTENT	0x8
+#endif
+
+#ifndef RTC_IOMAPPED
+#define RTC_IOMAPPED	1	/* Default to I/O mapping. */
+#endif
+
 #endif /* _MC146818RTC_H */
diff -urpNX dontdiff linux-2.6.11.6/include/linux/pci.h linux_HEAD/include/linux/pci.h
--- linux-2.6.11.6/include/linux/pci.h	2005-04-03 00:13:12.000000000 +0200
+++ linux_HEAD/include/linux/pci.h	2005-03-21 20:05:08.000000000 +0100
@@ -1037,7 +1037,7 @@ enum pci_fixup_pass {
 
 /* Anonymous variables would be nice... */
 #define DECLARE_PCI_FIXUP_SECTION(section, name, vendor, device, hook)	\
-	static struct pci_fixup __pci_fixup_##name __attribute_used__	\
+	static const struct pci_fixup __pci_fixup_##name __attribute_used__ \
 	__attribute__((__section__(#section))) = { vendor, device, hook };
 #define DECLARE_PCI_FIXUP_EARLY(vendor, device, hook)			\
 	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_early,			\
diff -urpNX dontdiff linux-2.6.11.6/include/linux/serial.h linux_HEAD/include/linux/serial.h
--- linux-2.6.11.6/include/linux/serial.h	2005-03-26 04:28:16.000000000 +0100
+++ linux_HEAD/include/linux/serial.h	2004-12-23 22:54:30.000000000 +0100
@@ -75,7 +75,8 @@ struct serial_struct {
 #define PORT_16654	11
 #define PORT_16850	12
 #define PORT_RSA	13	/* RSA-DV II/S card */
-#define PORT_MAX	13
+#define PORT_SB1250	14
+#define PORT_MAX	14
 
 #define SERIAL_IO_PORT	0
 #define SERIAL_IO_HUB6	1
diff -urpNX dontdiff linux-2.6.11.6/scripts/genksyms/Makefile linux_HEAD/scripts/genksyms/Makefile
--- linux-2.6.11.6/scripts/genksyms/Makefile	2005-03-26 04:28:36.000000000 +0100
+++ linux_HEAD/scripts/genksyms/Makefile	2004-09-21 13:12:23.000000000 +0200
@@ -47,3 +47,5 @@ clean-files	+= parse.output
 endif
 
 targets += keywords.c lex.c parse.c parse.h
+
+clean-files := keywords.c lex.c parse.c parse.h
diff -urpNX dontdiff linux-2.6.11.6/scripts/kallsyms.c linux_HEAD/scripts/kallsyms.c
--- linux-2.6.11.6/scripts/kallsyms.c	2005-03-26 04:28:38.000000000 +0100
+++ linux_HEAD/scripts/kallsyms.c	2005-02-21 15:26:30.000000000 +0100
@@ -145,6 +145,9 @@ read_symbol(FILE *in, struct sym_entry *
 	else if (toupper(s->type) == 'U' ||
 		 is_arm_mapping_symbol(str))
 		return -1;
+	/* exclude also MIPS ELF local symbols ($L123 instead of .L123) */
+	else if (str[0] == '$')
+		return -1;
 
 	/* include the type field in the symbol name, so that it gets
 	 * compressed together */
diff -urpNX dontdiff linux-2.6.11.6/sound/oss/Kconfig linux_HEAD/sound/oss/Kconfig
--- linux-2.6.11.6/sound/oss/Kconfig	2005-03-26 04:28:26.000000000 +0100
+++ linux_HEAD/sound/oss/Kconfig	2005-02-17 21:51:22.000000000 +0100
@@ -202,7 +202,7 @@ config SOUND_HAL2
 	depends on SOUND_PRIME!=n && SOUND && SGI_IP22 && EXPERIMENTAL
 	help
 	  Say Y or M if you have an SGI Indy system and want to be able to
-	  use it's on-board A2 audio system.
+	  use it's on-board A2 audio system
 
 config SOUND_IT8172
 	tristate "IT8172G Sound"
@@ -224,6 +224,10 @@ config SOUND_AU1550_AC97
 	tristate "Au1550 AC97 Sound"
 	depends on SOUND_PRIME!=n && SOC_AU1550 && SOUND
 
+config SOUND_AU1550_I2S
+	tristate "Au1550 I2S Sound"
+	depends on SOUND_PRIME!=n && SOC_AU1550 && SOUND
+
 config SOUND_TRIDENT
 	tristate "Trident 4DWave DX/NX, SiS 7018 or ALi 5451 PCI Audio Core"
 	depends on SOUND_PRIME!=n && SOUND && SOUND_GAMEPORT
diff -urpNX dontdiff linux-2.6.11.6/sound/oss/Makefile linux_HEAD/sound/oss/Makefile
--- linux-2.6.11.6/sound/oss/Makefile	2005-03-26 04:28:17.000000000 +0100
+++ linux_HEAD/sound/oss/Makefile	2005-02-17 21:51:22.000000000 +0100
@@ -64,8 +64,9 @@ endif
 obj-$(CONFIG_SOUND_ES1370)	+= es1370.o
 obj-$(CONFIG_SOUND_ES1371)	+= es1371.o ac97_codec.o
 obj-$(CONFIG_SOUND_VRC5477)	+= nec_vrc5477.o ac97_codec.o
-obj-$(CONFIG_SOUND_AU1000)	+= au1000.o ac97_codec.o
-obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o
+obj-$(CONFIG_SOUND_AU1000)	+= au1000.o ac97_codec.o  
+obj-$(CONFIG_SOUND_AU1550_AC97)	+= au1550_ac97.o ac97_codec.o  
+obj-$(CONFIG_SOUND_AU1550_I2S)	+= au1550_i2s.o  
 obj-$(CONFIG_SOUND_ESSSOLO1)	+= esssolo1.o
 obj-$(CONFIG_SOUND_FUSION)	+= cs46xx.o ac97_codec.o
 obj-$(CONFIG_SOUND_MAESTRO)	+= maestro.o
diff -urpNX dontdiff linux-2.6.11.6/sound/oss/au1000.c linux_HEAD/sound/oss/au1000.c
--- linux-2.6.11.6/sound/oss/au1000.c	2005-03-26 04:28:23.000000000 +0100
+++ linux_HEAD/sound/oss/au1000.c	2004-10-27 02:15:28.000000000 +0200
@@ -2123,7 +2123,7 @@ static int __devinit au1000_probe(void)
 
 #ifdef CONFIG_MIPS_XXS1500
 	/* deassert eapd */
-	wrcodec(&s->codec, AC97_POWER_CONTROL,
+	wrcodec(&s->codec, AC97_POWER_CONTROL, 
 			rdcodec(&s->codec, AC97_POWER_CONTROL) & ~0x8000);
 	/* mute a number of signals which seem to be causing problems
 	 * if not muted.
diff -urpNX dontdiff linux-2.6.11.6/sound/oss/au1550_ac97.c linux_HEAD/sound/oss/au1550_ac97.c
--- linux-2.6.11.6/sound/oss/au1550_ac97.c	2005-03-26 04:28:24.000000000 +0100
+++ linux_HEAD/sound/oss/au1550_ac97.c	2005-02-17 21:51:24.000000000 +0100
@@ -59,6 +59,7 @@
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-au1x00/au1xxx_psc.h>
 #include <asm/mach-au1x00/au1xxx_dbdma.h>
+#include <asm/mach-pb1x00/pb1550.h>
 
 #undef OSS_DOCUMENTED_MIXER_SEMANTICS
 
@@ -333,7 +334,7 @@ waitcodec(struct ac97_codec *codec)
 		*/
 		temp = rdcodec(codec, AC97_POWER_CONTROL);
 	}
-
+    
 	/* Check if Codec REF,ANL,DAC,ADC ready
 	*/
 	if ((temp & 0x7f0f) != 0x000f)
@@ -1123,7 +1124,7 @@ au1550_write(struct file *file, const ch
 
 	count *= db->cnt_factor;
 
-	down(&s->sem);
+	down(&s->sem);	
 	add_wait_queue(&db->wait, &wait);
 
 	while (count > 0) {
@@ -1222,7 +1223,7 @@ au1550_poll(struct file *file, struct po
 	}
 
 	spin_lock_irqsave(&s->lock, flags);
-
+	
 	if (file->f_mode & FMODE_READ) {
 		if (s->dma_adc.count >= (signed)s->dma_adc.dma_fragsize)
 			mask |= POLLIN | POLLRDNORM;
@@ -1230,7 +1231,7 @@ au1550_poll(struct file *file, struct po
 	if (file->f_mode & FMODE_WRITE) {
 		if (s->dma_dac.mapped) {
 			if (s->dma_dac.count >=
-			    (signed)s->dma_dac.dma_fragsize)
+			    (signed)s->dma_dac.dma_fragsize) 
 				mask |= POLLOUT | POLLWRNORM;
 		} else {
 			if ((signed) s->dma_dac.dmasize >=
@@ -1781,7 +1782,7 @@ au1550_open(struct inode *inode, struct 
 	else
 		pr_debug("open: blocking\n");
 #endif
-
+	
 	file->private_data = s;
 	/* wait for device to become free */
 	down(&s->open_sem);
@@ -1845,7 +1846,7 @@ au1550_release(struct inode *inode, stru
 	struct au1550_state *s = (struct au1550_state *)file->private_data;
 
 	lock_kernel();
-
+	
 	if (file->f_mode & FMODE_WRITE) {
 		unlock_kernel();
 		drain_dac(s, file->f_flags & O_NONBLOCK);
diff -urpNX dontdiff linux-2.6.11.6/sound/oss/au1550_i2s.c linux_HEAD/sound/oss/au1550_i2s.c
--- linux-2.6.11.6/sound/oss/au1550_i2s.c	1970-01-01 01:00:00.000000000 +0100
+++ linux_HEAD/sound/oss/au1550_i2s.c	2005-01-31 06:45:30.000000000 +0100
@@ -0,0 +1,2030 @@
+/*
+ *      au1550_i2s.c  --  Sound driver for Alchemy Au1550 MIPS
+ *			Internet Edge Processor.
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ * Copyright 2005 Matt Porter <mporter@kernel.crashing.org>
+ *
+ * Mostly copied from the au1550_psc.c driver and some from the
+ * PowerMac dbdma driver.
+ * We assume the processor can do memory coherent DMA.
+ *
+ * WM8731 mixer support, codec framework, cleanup, and 2.6 port
+ * Matt Porter <mporter@kernel.crashing.org>
+ *
+ * The SMBus (I2C) is required for the control of the 
+ * appears at I2C address 0x36 (I2C binary 0011011).  The Pb1550
+ * uses the Wolfson WM8731 codec, which is controlled over the I2C.
+ * It's connected to a 12MHz clock, so we can only reliably support
+ * 96KHz, 48KHz, 32KHz, and 8KHz data rates.  Variable rate audio is
+ * unsupported, we currently force it to 48KHz.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/hardirq.h>
+#include <linux/sound.h>
+#include <linux/slab.h>
+#include <linux/soundcard.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/hardirq.h>
+
+#include <asm/mach-au1x00/au1000.h>
+#include <asm/mach-au1x00/au1xxx_psc.h>
+#include <asm/mach-au1x00/au1xxx_dbdma.h>
+#include <asm/mach-pb1x00/pb1550.h>
+
+#undef OSS_DOCUMENTED_MIXER_SEMANTICS
+
+#define AU1550_MODULE_NAME "Au1550 I2S Audio"
+#define PFX AU1550_MODULE_NAME
+
+/* Define this if you want to try running at the 44.1 KHz rate.
+ * It's just a little off, I think it's actually 44117 or something.
+ * I did this for debugging, since many programs, including this
+ * driver, will try to upsample from 44.1 to 48 KHz.
+ * Seems to work well, we'll just leave it this way.
+ */
+#define TRY_441KHz
+
+#ifdef TRY_441KHz
+#define SAMP_RATE	44100
+#else
+#define SAMP_RATE	48000
+#endif
+
+/* The number of DBDMA ring descriptors to allocate.  No sense making
+ * this too large....if you can't keep up with a few you aren't likely
+ * to be able to with lots of them, either.
+ */
+#define NUM_DBDMA_DESCRIPTORS 4
+
+#define pr_error(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
+
+static void
+au1550_delay(int msec)
+{
+	unsigned long   tmo;
+	signed long     tmo2;
+
+	if (in_interrupt())
+		return;
+
+	tmo = jiffies + (msec * HZ) / 1000;
+	for (;;) {
+		tmo2 = tmo - jiffies;
+		if (tmo2 <= 0)
+			break;
+		schedule_timeout(tmo2);
+	}
+}
+
+/*
+ * Codec framework. If somebody supports another codec, they
+ * should hopefully be able to define another struct i2s_codec
+ * definition, and #ifdef the support for it and the WM8731 so
+ * they can be selected via a CONFIG option. For now, we just
+ * hardcode WM8731_CODEC.
+ */
+#define i2s_supported_mixer(CODEC,FOO) ((FOO >= 0) && \
+                                    (FOO < SOUND_MIXER_NRDEVICES) && \
+                                    (CODEC)->supported_mixers & (1<<FOO) )
+
+struct i2s_codec {
+	int			modcnt;
+	int			supported_mixers;
+	int			stereo_mixers;
+	int			record_sources;
+	unsigned int		mixer_state[SOUND_MIXER_NRDEVICES];
+	void			*data;
+	int			(*set_mixer) (struct i2s_codec *codec, unsigned int oss_mixer, unsigned int val);
+	void			(*init_codec) (struct i2s_codec *codec);
+};
+
+#define WM8731_CODEC
+#ifdef WM8731_CODEC
+/*
+ * WM8731 codec support
+ */
+#define WM8731_SUPPORTED_MASK (WM8731_STEREO_MASK|WM8731_RECORD_MASK)
+#define WM8731_STEREO_MASK (SOUND_MASK_VOLUME|SOUND_MASK_LINE)
+#define WM8731_RECORD_MASK (SOUND_MASK_MIC|SOUND_MASK_LINE)
+
+static struct codec_data {
+	u16			audio_path;
+} wm8731_data;
+
+static void
+wm8731_wrcodec(u8 ctlreg, u8 val)
+{
+	int	rcnt;
+	extern int pb1550_wm_codec_write(u8 addr, u8 reg, u8 val);
+
+	/* The codec is a write only device, with a 16-bit control/data
+	 * word.  Although it is written as two bytes on the I2C, the
+	 * format is actually 7 bits of register and 9 bits of data.
+	 * The ls bit of the first byte is the ms bit of the data.
+	 */
+	rcnt = 0;
+	while ((pb1550_wm_codec_write((0x36 >> 1), ctlreg, val) != 1) 
+							&& (rcnt < 50)) {
+		rcnt++;
+	}
+}
+
+static int
+wm8731_set_mixer(struct i2s_codec *codec, unsigned int oss_mixer, unsigned int val)
+{
+	unsigned int lvol, rvol;
+	struct codec_data *cdata = (struct codec_data *)codec->data;
+
+	switch (oss_mixer) {
+		case SOUND_MIXER_VOLUME:
+			/* normalize OSS range to fit codec volume control */
+			lvol = ((((val & 0x7f00) >> 8) * 0x60) / 0x64) + 0x1f;
+			rvol = (((val & 0x7f) * 0x60) / 0x64) + 0x1f;
+			lvol |= 0x80;
+			rvol |= 0x80;
+			wm8731_wrcodec(0x04, lvol);
+			au1550_delay(10);
+			wm8731_wrcodec(0x06, rvol);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		case SOUND_MIXER_LINE:
+			/* normalize OSS range to fit codec line control */
+			lvol = ((((val & 0x7f00) >> 8) * 0x1f) / 0x64);
+			rvol = (((val & 0x7f) * 0x1f) / 0x64);
+			if (!(val & 0x1f00))
+				lvol |= 0x80;
+			else
+				lvol &= ~0x80;
+			if (!(val & 0x001f))
+				rvol |= 0x80;
+			else
+				rvol &= ~0x80;
+			wm8731_wrcodec(0x00, lvol);
+			au1550_delay(10);
+			wm8731_wrcodec(0x02, rvol);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		case SOUND_MIXER_MIC:
+			if (!val)
+				cdata->audio_path |= 0x02;
+			else {
+				if (val >= 0x32)
+					cdata->audio_path |= 0x01;
+				else
+					cdata->audio_path &= ~0x01;
+				cdata->audio_path &= ~0x02;
+			}
+			wm8731_wrcodec(0x08, cdata->audio_path);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		case SOUND_MIXER_RECSRC:
+			if (val & SOUND_MASK_LINE)
+				cdata->audio_path &= ~0x04;
+			else
+				cdata->audio_path |= 0x04;
+			wm8731_wrcodec(0x08, cdata->audio_path);
+			au1550_delay(10);
+			codec->mixer_state[oss_mixer] = val;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+void
+wm8731_init_codec(struct i2s_codec *codec)
+{
+	struct codec_data *cdata = (struct codec_data *)codec->data;
+
+	wm8731_wrcodec(0x1e, 0x00);	/* Reset */
+	au1550_delay(200);
+	wm8731_wrcodec(0x0c, 0x00);	/* Power up everything */
+	au1550_delay(10);
+	wm8731_wrcodec(0x12, 0x00);	/* Deactivate codec */
+	au1550_delay(10);
+	cdata->audio_path = 0x10;
+	/* Select DAC outputs to line out */
+	wm8731_wrcodec(0x08, cdata->audio_path);
+	au1550_delay(10);
+	wm8731_wrcodec(0x0a, 0x00);	/* Disable output mute */
+	au1550_delay(10);
+	wm8731_wrcodec(0x0e, 0x02);	/* Set slave, 16-bit, I2S modes */
+	au1550_delay(10);
+	wm8731_wrcodec(0x10, 0x01);	/* 12MHz (USB), 250fs */
+	au1550_delay(10);
+	wm8731_wrcodec(0x12, 0x01);	/* Activate codec */
+	au1550_delay(10);
+
+	codec->set_mixer(codec, SOUND_MIXER_VOLUME, 0x5050);
+	codec->set_mixer(codec, SOUND_MIXER_LINE, 0x0000);
+	codec->set_mixer(codec, SOUND_MIXER_MIC, 0x00);
+	codec->mixer_state[SOUND_MIXER_RECSRC] = SOUND_MIXER_LINE;
+}
+
+static struct i2s_codec au1550_i2s_codec = {
+	.supported_mixers	= WM8731_SUPPORTED_MASK,
+	.stereo_mixers		= WM8731_STEREO_MASK,
+	.record_sources		= WM8731_RECORD_MASK,
+	.init_codec		= &wm8731_init_codec,
+	.set_mixer		= &wm8731_set_mixer,
+	.data			= &wm8731_data,
+};
+#endif /* WM8731_CODEC */
+
+static struct au1550_state {
+	/* soundcore stuff */
+	int             dev_audio;
+	int		dev_mixer;
+
+	spinlock_t		lock;
+	struct semaphore	open_sem;
+	struct semaphore	sem;
+	mode_t			open_mode;
+	wait_queue_head_t	open_wait;
+	volatile psc_i2s_t	*psc_addr;
+	struct i2s_codec	*codec;
+
+	struct dmabuf {
+		u32		dmanr;
+		unsigned        sample_rate;
+		unsigned	src_factor;
+		unsigned        sample_size;
+		int             num_channels;
+		int		dma_bytes_per_sample;
+		int		user_bytes_per_sample;
+		int		cnt_factor;
+
+		void		*rawbuf;
+		unsigned        buforder;
+		unsigned	numfrag;
+		unsigned        fragshift;
+		void		*nextIn;
+		void		*nextOut;
+		int		count;
+		unsigned        total_bytes;
+		unsigned        error;
+		wait_queue_head_t wait;
+
+		/* redundant, but makes calculations easier */
+		unsigned	fragsize;
+		unsigned	dma_fragsize;
+		unsigned	dmasize;
+		unsigned	dma_qcount;
+
+		/* OSS stuff */
+		unsigned        mapped:1;
+		unsigned        ready:1;
+		unsigned        stopped:1;
+		unsigned        ossfragshift;
+		int             ossmaxfrags;
+		unsigned        subdivision;
+
+		/* Mixer stuff */
+		int		dev_mixer;
+	} dma_dac, dma_adc;
+} au1550_state;
+
+static unsigned
+ld2(unsigned int x)
+{
+	unsigned        r = 0;
+
+	if (x >= 0x10000) {
+		x >>= 16;
+		r += 16;
+	}
+	if (x >= 0x100) {
+		x >>= 8;
+		r += 8;
+	}
+	if (x >= 0x10) {
+		x >>= 4;
+		r += 4;
+	}
+	if (x >= 4) {
+		x >>= 2;
+		r += 2;
+	}
+	if (x >= 2)
+		r++;
+	return r;
+}
+
+/* stop the ADC before calling */
+static void
+set_adc_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *adc = &s->dma_adc;
+
+	/* calc SRC factor */
+	adc->src_factor = (((SAMP_RATE*2) / rate) + 1) >> 1;
+	adc->sample_rate = SAMP_RATE / adc->src_factor;
+	return;
+
+	adc->src_factor = 1;
+}
+
+/* stop the DAC before calling */
+static void
+set_dac_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *dac = &s->dma_dac;
+
+	/* calc SRC factor */
+	dac->src_factor = (((SAMP_RATE*2) / rate) + 1) >> 1;
+	dac->sample_rate = SAMP_RATE / dac->src_factor;
+	return;
+
+	dac->src_factor = 1;
+}
+
+static void
+stop_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	unsigned long   flags;
+	uint	stat;
+	volatile psc_i2s_t *ip;
+
+	if (db->stopped)
+		return;
+
+	ip = s->psc_addr;
+	spin_lock_irqsave(&s->lock, flags);
+
+	ip->psc_i2spcr = PSC_I2SPCR_TP;
+	au_sync();
+
+	/* Wait for Transmit Busy to show disabled.
+	*/
+	do {
+		stat = ip->psc_i2sstat;
+		au_sync();
+	} while ((stat & PSC_I2SSTAT_TB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+stop_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	unsigned long   flags;
+	uint	stat;
+	volatile psc_i2s_t *ip;
+
+	if (db->stopped)
+		return;
+
+	ip = s->psc_addr;
+	spin_lock_irqsave(&s->lock, flags);
+
+	ip->psc_i2spcr = PSC_I2SPCR_RP;
+	au_sync();
+
+	/* Wait for Receive Busy to show disabled.
+	*/
+	do {
+		stat = ip->psc_i2sstat;
+		au_sync();
+	} while ((stat & PSC_I2SSTAT_RB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+set_xmit_slots(int num_channels)
+{
+	/* This is here just as a place holder.  The WM8731 only
+	 * supports two fixed channels.
+	 */
+}
+
+static void
+set_recv_slots(int num_channels)
+{
+	/* This is here just as a place holder.  The WM8731 only
+	 * supports two fixed channels.
+	 */
+}
+
+static void
+start_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	unsigned long   flags;
+	volatile psc_i2s_t *ip;
+
+	if (!db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	ip = s->psc_addr;
+	set_xmit_slots(db->num_channels);
+	ip->psc_i2spcr = PSC_I2SPCR_TC;
+	au_sync();
+	ip->psc_i2spcr = PSC_I2SPCR_TS;
+	au_sync();
+
+	au1xxx_dbdma_start(db->dmanr);
+
+	db->stopped = 0;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+start_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	int	i;
+	volatile psc_i2s_t *ip;
+
+	if (!db->stopped)
+		return;
+
+	/* Put two buffers on the ring to get things started.
+	*/
+	for (i=0; i<2; i++) {
+		au1xxx_dbdma_put_dest(db->dmanr, db->nextIn, db->dma_fragsize);
+
+		db->nextIn += db->dma_fragsize;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+	}
+
+	ip = s->psc_addr;
+	set_recv_slots(db->num_channels);
+	au1xxx_dbdma_start(db->dmanr);
+	ip->psc_i2spcr = PSC_I2SPCR_RC;
+	au_sync();
+	ip->psc_i2spcr = PSC_I2SPCR_RS;
+	au_sync();
+
+	db->stopped = 0;
+}
+
+static int
+prog_dmabuf(struct au1550_state *s, struct dmabuf *db)
+{
+	unsigned user_bytes_per_sec;
+	unsigned        bufs;
+	unsigned        rate = db->sample_rate;
+
+	if (!db->rawbuf) {
+		db->ready = db->mapped = 0;
+		db->buforder = 5;	/* 32 * PAGE_SIZE */
+		db->rawbuf = kmalloc((PAGE_SIZE << db->buforder), GFP_KERNEL);
+		if (!db->rawbuf)
+			return -ENOMEM;
+	}
+
+	db->cnt_factor = 1;
+	if (db->sample_size == 8)
+		db->cnt_factor *= 2;
+	if (db->num_channels == 1)
+		db->cnt_factor *= 2;
+	db->cnt_factor *= db->src_factor;
+
+	db->count = 0;
+	db->dma_qcount = 0;
+	db->nextIn = db->nextOut = db->rawbuf;
+
+	db->user_bytes_per_sample = (db->sample_size>>3) * db->num_channels;
+	db->dma_bytes_per_sample = 2 * ((db->num_channels == 1) ?
+					2 : db->num_channels);
+
+	user_bytes_per_sec = rate * db->user_bytes_per_sample;
+	bufs = PAGE_SIZE << db->buforder;
+	if (db->ossfragshift) {
+		if ((1000 << db->ossfragshift) < user_bytes_per_sec)
+			db->fragshift = ld2(user_bytes_per_sec/1000);
+		else
+			db->fragshift = db->ossfragshift;
+	} else {
+		db->fragshift = ld2(user_bytes_per_sec / 100 /
+				    (db->subdivision ? db->subdivision : 1));
+		if (db->fragshift < 3)
+			db->fragshift = 3;
+	}
+
+	db->fragsize = 1 << db->fragshift;
+	db->dma_fragsize = db->fragsize * db->cnt_factor;
+	db->numfrag = bufs / db->dma_fragsize;
+
+	while (db->numfrag < 4 && db->fragshift > 3) {
+		db->fragshift--;
+		db->fragsize = 1 << db->fragshift;
+		db->dma_fragsize = db->fragsize * db->cnt_factor;
+		db->numfrag = bufs / db->dma_fragsize;
+	}
+
+	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
+		db->numfrag = db->ossmaxfrags;
+
+	db->dmasize = db->dma_fragsize * db->numfrag;
+	memset(db->rawbuf, 0, bufs);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg("rate=%d, samplesize=%d, channels=%d",
+	    rate, db->sample_size, db->num_channels);
+	dbg("fragsize=%d, cnt_factor=%d, dma_fragsize=%d",
+	    db->fragsize, db->cnt_factor, db->dma_fragsize);
+	dbg("numfrag=%d, dmasize=%d", db->numfrag, db->dmasize);
+#endif
+
+	db->ready = 1;
+	return 0;
+}
+
+static int
+prog_dmabuf_adc(struct au1550_state *s)
+{
+	stop_adc(s);
+	return prog_dmabuf(s, &s->dma_adc);
+
+}
+
+static int
+prog_dmabuf_dac(struct au1550_state *s)
+{
+	stop_dac(s);
+	return prog_dmabuf(s, &s->dma_dac);
+}
+
+
+/* hold spinlock for the following */
+static void
+dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct au1550_state *s = (struct au1550_state *) dev_id;
+	struct dmabuf  *db = &s->dma_dac;
+	u32	i2s_stat;
+	volatile psc_i2s_t *ip;
+
+	ip = s->psc_addr;
+	i2s_stat = ip->psc_i2sstat;
+#ifdef AU1000_VERBOSE_DEBUG
+	if (i2s_stat & (PSC_I2SSTAT_TF | PSC_I2SSTAT_TR | PSC_I2SSTAT_TF))
+		dbg("I2S status = 0x%08x", i2s_stat);
+#endif
+	db->dma_qcount--;
+
+	if (db->count >= db->fragsize) {
+		if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+			pr_error("qcount < 2 and no ring room!");
+		}
+		db->nextOut += db->fragsize;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		db->count -= db->fragsize;
+		db->total_bytes += db->dma_fragsize;
+		db->dma_qcount++;
+	}
+
+	/* wake up anybody listening */
+	if (waitqueue_active(&db->wait))
+		wake_up(&db->wait);
+}
+
+
+static void
+adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct	au1550_state *s = (struct au1550_state *)dev_id;
+	struct	dmabuf  *dp = &s->dma_adc;
+	u32	obytes;
+	char	*obuf;
+
+	/* Pull the buffer from the dma queue.
+	*/
+	au1xxx_dbdma_get_dest(dp->dmanr, (void *)(&obuf), &obytes);
+
+	if ((dp->count + obytes) > dp->dmasize) {
+		/* Overrun. Stop ADC and log the error
+		*/
+		stop_adc(s);
+		dp->error++;
+		pr_error("adc overrun");
+		return;
+	}
+
+	/* Put a new empty buffer on the destination DMA.
+	*/
+	au1xxx_dbdma_put_dest(dp->dmanr, dp->nextIn, dp->dma_fragsize);
+
+	dp->nextIn += dp->dma_fragsize;
+	if (dp->nextIn >= dp->rawbuf + dp->dmasize)
+		dp->nextIn -= dp->dmasize;
+
+	dp->count += obytes;
+	dp->total_bytes += obytes;
+
+	/* wake up anybody listening
+	*/
+	if (waitqueue_active(&dp->wait))
+		wake_up(&dp->wait);
+
+}
+
+static loff_t
+au1550_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+static int
+au1550_open_mixdev(struct inode *inode, struct file *file)
+{
+	file->private_data = &au1550_state;
+	return 0;
+}
+
+static int
+au1550_release_mixdev(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+#define I2S_CODEC	"Wolfson WM8731"
+
+static int
+au1550_ioctl_mixdev(struct inode *inode, struct file *file,
+			       unsigned int cmd, unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct i2s_codec *codec = s->codec;
+	int i, val = 0;
+
+	if (cmd == SOUND_MIXER_INFO) {
+		mixer_info info;
+		memset(&info, 0, sizeof(info));
+		strlcpy(info.id, I2S_CODEC, sizeof(info.id));
+		strlcpy(info.name, I2S_CODEC, sizeof(info.name));
+		info.modify_counter = codec->modcnt;
+		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+	if (cmd == SOUND_OLD_MIXER_INFO) {
+		_old_mixer_info info;
+		memset(&info, 0, sizeof(info));
+		strlcpy(info.id, I2S_CODEC, sizeof(info.id));
+		strlcpy(info.name, I2S_CODEC, sizeof(info.name));
+		if (copy_to_user((void __user *)arg, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
+
+	if (_IOC_TYPE(cmd) != 'M' || _SIOC_SIZE(cmd) != sizeof(int))
+		return -EINVAL;
+
+	if (cmd == OSS_GETVERSION)
+		return put_user(SOUND_VERSION, (int __user *)arg);
+
+	if (_SIOC_DIR(cmd) == _SIOC_READ) {
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: /* give them the current record source */
+			val = codec->mixer_state[SOUND_MIXER_RECSRC];
+			break;
+
+		case SOUND_MIXER_DEVMASK: /* give them the supported mixers */
+			val = codec->supported_mixers;
+			break;
+
+		case SOUND_MIXER_RECMASK: /* Arg contains a bit for each supported recording source */
+			val = codec->record_sources;
+			break;
+
+		case SOUND_MIXER_STEREODEVS: /* Mixer channels supporting stereo */
+			val = codec->stereo_mixers;
+			break;
+
+		case SOUND_MIXER_CAPS:
+			val = SOUND_CAP_EXCL_INPUT;
+			break;
+
+		default: /* read a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!i2s_supported_mixer(codec, i)) 
+				return -EINVAL;
+
+			val = codec->mixer_state[i];
+ 			break;
+		}
+		return put_user(val, (int __user *)arg);
+	}
+
+	if (_SIOC_DIR(cmd) == (_SIOC_WRITE|_SIOC_READ)) {
+		codec->modcnt++;
+		if (get_user(val, (int __user *)arg))
+			return -EFAULT;
+
+		switch (_IOC_NR(cmd)) {
+		case SOUND_MIXER_RECSRC: /* Arg contains a bit for each recording source */
+			if (!val) return 0;
+			if (!(val &= codec->record_sources)) return -EINVAL;
+
+			codec->set_mixer(codec, SOUND_MIXER_RECSRC, val);
+
+			return 0;
+		default: /* write a specific mixer */
+			i = _IOC_NR(cmd);
+
+			if (!i2s_supported_mixer(codec, i)) 
+				return -EINVAL;
+
+			codec->set_mixer(codec, i, val);
+
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static struct file_operations au1550_mixer_fops = {
+	owner:THIS_MODULE,
+	llseek:au1550_llseek,
+	ioctl:au1550_ioctl_mixdev,
+	open:au1550_open_mixdev,
+	release:au1550_release_mixdev,
+};
+
+static int
+drain_dac(struct au1550_state *s, int nonblock)
+{
+	unsigned long   flags;
+	int             count, tmo;
+
+	if (s->dma_dac.mapped || !s->dma_dac.ready || s->dma_dac.stopped)
+		return 0;
+
+	for (;;) {
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count <= 0)
+			break;
+		if (signal_pending(current))
+			break;
+		if (nonblock)
+			return -EBUSY;
+		tmo = 1000 * count / SAMP_RATE;
+		tmo /= s->dma_dac.dma_bytes_per_sample;
+		au1550_delay(tmo);
+	}
+	if (signal_pending(current))
+		return -ERESTARTSYS;
+	return 0;
+}
+
+static inline u8 S16_TO_U8(s16 ch)
+{
+	return (u8) (ch >> 8) + 0x80;
+}
+static inline s16 U8_TO_S16(u8 ch)
+{
+	return (s16) (ch - 0x80) << 8;
+}
+
+/*
+ * Translates user samples to dma buffer suitable for audio DAC data:
+ *     If mono, copy left channel to right channel in dma buffer.
+ *     If 8 bit samples, cvt to 16-bit before writing to dma buffer.
+ *     If interpolating (no VRA), duplicate every audio frame src_factor times.
+ */
+static int
+translate_from_user(struct dmabuf *db, char* dmabuf, char* userbuf,
+							       int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+	s16             ch, dmasample[6];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_from_user(dmabuf, userbuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		if (copy_from_user(usersample, userbuf,
+				   db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				ch = U8_TO_S16(usersample[i]);
+			else
+				ch = *((s16 *) (&usersample[i * 2]));
+			dmasample[i] = ch;
+			if (mono)
+				dmasample[i + 1] = ch;	/* right channel */
+		}
+
+		/* duplicate every audio frame src_factor times
+		*/
+		for (i = 0; i < db->src_factor; i++)
+			memcpy(dmabuf, dmasample, db->dma_bytes_per_sample);
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Translates audio ADC samples to user buffer:
+ *     If mono, send only left channel to user buffer.
+ *     If 8 bit samples, cvt from 16 to 8 bit before writing to user buffer.
+ *     If decimating (no VRA), skip over src_factor audio frames.
+ */
+static int
+translate_to_user(struct dmabuf *db, char* userbuf, char* dmabuf,
+							     int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_to_user(userbuf, dmabuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				usersample[i] =
+					S16_TO_U8(*((s16 *) (&dmabuf[i * 2])));
+			else
+				*((s16 *) (&usersample[i * 2])) =
+					*((s16 *) (&dmabuf[i * 2]));
+		}
+
+		if (copy_to_user(userbuf, usersample,
+				 db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Copy audio data to/from user buffer from/to dma buffer, taking care
+ * that we wrap when reading/writing the dma buffer. Returns actual byte
+ * count written to or read from the dma buffer.
+ */
+static int
+copy_dmabuf_user(struct dmabuf *db, char* userbuf, int count, int to_user)
+{
+	char           *bufptr = to_user ? db->nextOut : db->nextIn;
+	char           *bufend = db->rawbuf + db->dmasize;
+	int             cnt, ret;
+
+	if (bufptr + count > bufend) {
+		int             partial = (int) (bufend - bufptr);
+		if (to_user) {
+			if ((cnt = translate_to_user(db, userbuf,
+						     bufptr, partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_to_user(db, userbuf + partial,
+						     db->rawbuf,
+						     count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		} else {
+			if ((cnt = translate_from_user(db, bufptr, userbuf,
+						       partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_from_user(db, db->rawbuf,
+						       userbuf + partial,
+						       count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		}
+	} else {
+		if (to_user)
+			ret = translate_to_user(db, userbuf, bufptr, count);
+		else
+			ret = translate_from_user(db, bufptr, userbuf, count);
+	}
+
+	return ret;
+}
+
+static ssize_t
+au1550_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_adc;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+	ret = 0;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for samples in ADC dma buffer
+		*/
+		do {
+			if (db->stopped)
+				start_adc(s);
+			spin_lock_irqsave(&s->lock, flags);
+			avail = db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from nextOut to user
+		*/
+		if ((cnt = copy_dmabuf_user(db, buffer,
+					    count > avail ?
+					    avail : count, 1)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count -= cnt;
+		db->nextOut += cnt;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+static ssize_t
+au1550_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_dac;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret = 0;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg("write: count=%d", count);
+#endif
+
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_READ, buffer, count))
+		return -EFAULT;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);	
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for space in playback buffer
+		*/
+		do {
+			spin_lock_irqsave(&s->lock, flags);
+			avail = (int) db->dmasize - db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from user to nextIn
+		*/
+		if ((cnt = copy_dmabuf_user(db, (char *) buffer,
+					    count > avail ?
+					    avail : count, 0)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count += cnt;
+		db->nextIn += cnt;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+
+		/* If the data is available, we want to keep two buffers
+		 * on the dma queue.  If the queue count reaches zero,
+		 * we know the dma has stopped.
+		 */
+		while ((db->dma_qcount < 2) && (db->count >= db->fragsize)) {
+			if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+				pr_error("qcount < 2 and no ring room!");
+			}
+			db->nextOut += db->fragsize;
+			if (db->nextOut >= db->rawbuf + db->dmasize)
+				db->nextOut -= db->dmasize;
+			db->count -= db->fragsize;
+			db->total_bytes += db->dma_fragsize;
+			if (db->dma_qcount == 0)
+				start_dac(s);
+			db->dma_qcount++;
+		}
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+
+/* No kernel lock - we have our own spinlock */
+static unsigned int
+au1550_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	unsigned int    mask = 0;
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!s->dma_dac.ready)
+			return 0;
+		poll_wait(file, &s->dma_dac.wait, wait);
+	}
+	if (file->f_mode & FMODE_READ) {
+		if (!s->dma_adc.ready)
+			return 0;
+		poll_wait(file, &s->dma_adc.wait, wait);
+	}
+
+	spin_lock_irqsave(&s->lock, flags);
+	
+	if (file->f_mode & FMODE_READ) {
+		if (s->dma_adc.count >= (signed)s->dma_adc.dma_fragsize)
+			mask |= POLLIN | POLLRDNORM;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if (s->dma_dac.mapped) {
+			if (s->dma_dac.count >=
+			    (signed)s->dma_dac.dma_fragsize) 
+				mask |= POLLOUT | POLLWRNORM;
+		} else {
+			if ((signed) s->dma_dac.dmasize >=
+			    s->dma_dac.count + (signed)s->dma_dac.dma_fragsize)
+				mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+	spin_unlock_irqrestore(&s->lock, flags);
+	return mask;
+}
+
+static int
+au1550_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db;
+	unsigned long   size;
+	int ret = 0;
+
+	lock_kernel();
+	down(&s->sem);
+	if (vma->vm_flags & VM_WRITE)
+		db = &s->dma_dac;
+	else if (vma->vm_flags & VM_READ)
+		db = &s->dma_adc;
+	else {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (vma->vm_pgoff != 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+	size = vma->vm_end - vma->vm_start;
+	if (size > (PAGE_SIZE << db->buforder)) {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (remap_pfn_range(vma, vma->vm_start,
+			     page_to_pfn(virt_to_page(db->rawbuf)),
+			     size, vma->vm_page_prot)) {
+		ret = -EAGAIN;
+		goto out;
+	}
+	vma->vm_flags &= ~VM_IO;
+	db->mapped = 1;
+out:
+	up(&s->sem);
+	unlock_kernel();
+	return ret;
+}
+
+
+#ifdef AU1000_VERBOSE_DEBUG
+static struct ioctl_str_t {
+	unsigned int    cmd;
+	const char     *str;
+} ioctl_str[] = {
+	{SNDCTL_DSP_RESET, "SNDCTL_DSP_RESET"},
+	{SNDCTL_DSP_SYNC, "SNDCTL_DSP_SYNC"},
+	{SNDCTL_DSP_SPEED, "SNDCTL_DSP_SPEED"},
+	{SNDCTL_DSP_STEREO, "SNDCTL_DSP_STEREO"},
+	{SNDCTL_DSP_GETBLKSIZE, "SNDCTL_DSP_GETBLKSIZE"},
+	{SNDCTL_DSP_SAMPLESIZE, "SNDCTL_DSP_SAMPLESIZE"},
+	{SNDCTL_DSP_CHANNELS, "SNDCTL_DSP_CHANNELS"},
+	{SOUND_PCM_WRITE_CHANNELS, "SOUND_PCM_WRITE_CHANNELS"},
+	{SOUND_PCM_WRITE_FILTER, "SOUND_PCM_WRITE_FILTER"},
+	{SNDCTL_DSP_POST, "SNDCTL_DSP_POST"},
+	{SNDCTL_DSP_SUBDIVIDE, "SNDCTL_DSP_SUBDIVIDE"},
+	{SNDCTL_DSP_SETFRAGMENT, "SNDCTL_DSP_SETFRAGMENT"},
+	{SNDCTL_DSP_GETFMTS, "SNDCTL_DSP_GETFMTS"},
+	{SNDCTL_DSP_SETFMT, "SNDCTL_DSP_SETFMT"},
+	{SNDCTL_DSP_GETOSPACE, "SNDCTL_DSP_GETOSPACE"},
+	{SNDCTL_DSP_GETISPACE, "SNDCTL_DSP_GETISPACE"},
+	{SNDCTL_DSP_NONBLOCK, "SNDCTL_DSP_NONBLOCK"},
+	{SNDCTL_DSP_GETCAPS, "SNDCTL_DSP_GETCAPS"},
+	{SNDCTL_DSP_GETTRIGGER, "SNDCTL_DSP_GETTRIGGER"},
+	{SNDCTL_DSP_SETTRIGGER, "SNDCTL_DSP_SETTRIGGER"},
+	{SNDCTL_DSP_GETIPTR, "SNDCTL_DSP_GETIPTR"},
+	{SNDCTL_DSP_GETOPTR, "SNDCTL_DSP_GETOPTR"},
+	{SNDCTL_DSP_MAPINBUF, "SNDCTL_DSP_MAPINBUF"},
+	{SNDCTL_DSP_MAPOUTBUF, "SNDCTL_DSP_MAPOUTBUF"},
+	{SNDCTL_DSP_SETSYNCRO, "SNDCTL_DSP_SETSYNCRO"},
+	{SNDCTL_DSP_SETDUPLEX, "SNDCTL_DSP_SETDUPLEX"},
+	{SNDCTL_DSP_GETODELAY, "SNDCTL_DSP_GETODELAY"},
+	{SNDCTL_DSP_GETCHANNELMASK, "SNDCTL_DSP_GETCHANNELMASK"},
+	{SNDCTL_DSP_BIND_CHANNEL, "SNDCTL_DSP_BIND_CHANNEL"},
+	{OSS_GETVERSION, "OSS_GETVERSION"},
+	{SOUND_PCM_READ_RATE, "SOUND_PCM_READ_RATE"},
+	{SOUND_PCM_READ_CHANNELS, "SOUND_PCM_READ_CHANNELS"},
+	{SOUND_PCM_READ_BITS, "SOUND_PCM_READ_BITS"},
+	{SOUND_PCM_READ_FILTER, "SOUND_PCM_READ_FILTER"}
+};
+#endif
+
+static int
+dma_count_done(struct dmabuf *db)
+{
+	if (db->stopped)
+		return 0;
+
+	return db->dma_fragsize - au1xxx_get_dma_residue(db->dmanr);
+}
+
+
+static int
+au1550_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	audio_buf_info  abinfo;
+	count_info      cinfo;
+	int             count;
+	int             val, mapped, ret, diff;
+
+	mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
+		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
+		if (ioctl_str[count].cmd == cmd)
+			break;
+	}
+	if (count < sizeof(ioctl_str) / sizeof(ioctl_str[0]))
+		dbg("ioctl %s, arg=0x%lx", ioctl_str[count].str, arg);
+	else
+		dbg("ioctl 0x%x unknown, arg=0x%lx", cmd, arg);
+#endif
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *) arg);
+
+	case SNDCTL_DSP_SYNC:
+		if (file->f_mode & FMODE_WRITE)
+			return drain_dac(s, file->f_flags & O_NONBLOCK);
+		return 0;
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return 0;
+
+	case SNDCTL_DSP_GETCAPS:
+		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
+				DSP_CAP_TRIGGER | DSP_CAP_MMAP, (int *)arg);
+
+	case SNDCTL_DSP_RESET:
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			synchronize_irq();
+			s->dma_dac.count = s->dma_dac.total_bytes = 0;
+			s->dma_dac.nextIn = s->dma_dac.nextOut =
+				s->dma_dac.rawbuf;
+		}
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			synchronize_irq();
+			s->dma_adc.count = s->dma_adc.total_bytes = 0;
+			s->dma_adc.nextIn = s->dma_adc.nextOut =
+				s->dma_adc.rawbuf;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val >= 0) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				set_adc_rate(s, val);
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				set_dac_rate(s, val);
+			}
+			if (s->open_mode & FMODE_READ)
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			if (s->open_mode & FMODE_WRITE)
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+		}
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SNDCTL_DSP_STEREO:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.num_channels = val ? 2 : 1;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.num_channels = val ? 2 : 1;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_CHANNELS:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 0) {
+			if (file->f_mode & FMODE_READ) {
+				if (val < 0 || val > 2)
+					return -EINVAL;
+				stop_adc(s);
+				s->dma_adc.num_channels = val;
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				switch (val) {
+				case 1:
+				case 2:
+					break;
+				default:
+					return -EINVAL;
+				}
+
+				stop_dac(s);
+				s->dma_dac.num_channels = val;
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_GETFMTS:	/* Returns a mask */
+		return put_user(AFMT_S16_LE | AFMT_U8, (int *) arg);
+
+	case SNDCTL_DSP_SETFMT:	/* Selects ONE fmt */
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != AFMT_QUERY) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				if (val == AFMT_S16_LE)
+					s->dma_adc.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_adc.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				if (val == AFMT_S16_LE)
+					s->dma_dac.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_dac.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		} else {
+			if (file->f_mode & FMODE_READ)
+				val = (s->dma_adc.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+			else
+				val = (s->dma_dac.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_POST:
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = 0;
+		spin_lock_irqsave(&s->lock, flags);
+		if (file->f_mode & FMODE_READ && !s->dma_adc.stopped)
+			val |= PCM_ENABLE_INPUT;
+		if (file->f_mode & FMODE_WRITE && !s->dma_dac.stopped)
+			val |= PCM_ENABLE_OUTPUT;
+		spin_unlock_irqrestore(&s->lock, flags);
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			if (val & PCM_ENABLE_INPUT)
+				start_adc(s);
+			else
+				stop_adc(s);
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			if (val & PCM_ENABLE_OUTPUT)
+				start_dac(s);
+			else
+				stop_dac(s);
+		}
+		return 0;
+
+	case SNDCTL_DSP_GETOSPACE:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_dac.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = (s->dma_dac.dmasize - count) /
+			s->dma_dac.cnt_factor;
+		abinfo.fragstotal = s->dma_dac.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
+#ifdef AU1000_VERBOSE_DEBUG
+		dbg("bytes=%d, fragments=%d", abinfo.bytes, abinfo.fragments);
+#endif
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_GETISPACE:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_adc.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_adc.count;
+		count += dma_count_done(&s->dma_adc);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = count / s->dma_adc.cnt_factor;
+		abinfo.fragstotal = s->dma_adc.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		return 0;
+
+	case SNDCTL_DSP_GETODELAY:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		count /= s->dma_dac.cnt_factor;
+		return put_user(count, (int *) arg);
+
+	case SNDCTL_DSP_GETIPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_adc.total_bytes;
+		count = s->dma_adc.count;
+		if (!s->dma_adc.stopped) {
+			diff = dma_count_done(&s->dma_adc);
+			count += diff;
+			cinfo.bytes += diff;
+			cinfo.ptr =  virt_to_phys(s->dma_adc.nextIn) + diff -
+				virt_to_phys(s->dma_adc.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_adc.nextIn) -
+				virt_to_phys(s->dma_adc.rawbuf);
+		if (s->dma_adc.mapped)
+			s->dma_adc.count &= (s->dma_adc.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETOPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_dac.total_bytes;
+		count = s->dma_dac.count;
+		if (!s->dma_dac.stopped) {
+			diff = dma_count_done(&s->dma_dac);
+			count -= diff;
+			cinfo.bytes += diff;
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) + diff -
+				virt_to_phys(s->dma_dac.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) -
+				virt_to_phys(s->dma_dac.rawbuf);
+		if (s->dma_dac.mapped)
+			s->dma_dac.count &= (s->dma_dac.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_dac.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		if (file->f_mode & FMODE_WRITE)
+			return put_user(s->dma_dac.fragsize, (int *) arg);
+		else
+			return put_user(s->dma_adc.fragsize, (int *) arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.ossfragshift = val & 0xffff;
+			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_adc.ossfragshift < 4)
+				s->dma_adc.ossfragshift = 4;
+			if (s->dma_adc.ossfragshift > 15)
+				s->dma_adc.ossfragshift = 15;
+			if (s->dma_adc.ossmaxfrags < 4)
+				s->dma_adc.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.ossfragshift = val & 0xffff;
+			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_dac.ossfragshift < 4)
+				s->dma_dac.ossfragshift = 4;
+			if (s->dma_dac.ossfragshift > 15)
+				s->dma_dac.ossfragshift = 15;
+			if (s->dma_dac.ossmaxfrags < 4)
+				s->dma_dac.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SUBDIVIDE:
+		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
+		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
+			return -EINVAL;
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 1 && val != 2 && val != 4)
+			return -EINVAL;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.subdivision = val;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.subdivision = val;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SOUND_PCM_READ_RATE:
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SOUND_PCM_READ_CHANNELS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.num_channels, (int *)arg);
+		else
+			return put_user(s->dma_dac.num_channels, (int *)arg);
+
+	case SOUND_PCM_READ_BITS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.sample_size, (int *)arg);
+		else
+			return put_user(s->dma_dac.sample_size, (int *)arg);
+
+	case SOUND_PCM_WRITE_FILTER:
+	case SNDCTL_DSP_SETSYNCRO:
+	case SOUND_PCM_READ_FILTER:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int
+au1550_open(struct inode *inode, struct file *file)
+{
+	int             minor = MINOR(inode->i_rdev);
+	DECLARE_WAITQUEUE(wait, current);
+	struct au1550_state *s = &au1550_state;
+	int             ret;
+
+#ifdef AU1000_VERBOSE_DEBUG
+	if (file->f_flags & O_NONBLOCK)
+		dbg(__FUNCTION__ ": non-blocking");
+	else
+		dbg(__FUNCTION__ ": blocking");
+#endif
+	
+	file->private_data = s;
+	/* wait for device to become free */
+	down(&s->open_sem);
+	while (s->open_mode & file->f_mode) {
+		if (file->f_flags & O_NONBLOCK) {
+			up(&s->open_sem);
+			return -EBUSY;
+		}
+		add_wait_queue(&s->open_wait, &wait);
+		__set_current_state(TASK_INTERRUPTIBLE);
+		up(&s->open_sem);
+		schedule();
+		remove_wait_queue(&s->open_wait, &wait);
+		set_current_state(TASK_RUNNING);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+		down(&s->open_sem);
+	}
+
+	stop_dac(s);
+	stop_adc(s);
+
+	if (file->f_mode & FMODE_READ) {
+		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
+			s->dma_adc.subdivision = s->dma_adc.total_bytes = 0;
+		s->dma_adc.num_channels = 1;
+		s->dma_adc.sample_size = 8;
+		set_adc_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_adc.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
+			s->dma_dac.subdivision = s->dma_dac.total_bytes = 0;
+		s->dma_dac.num_channels = 1;
+		s->dma_dac.sample_size = 8;
+		set_dac_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_dac.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		if ((ret = prog_dmabuf_adc(s)))
+			return ret;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if ((ret = prog_dmabuf_dac(s)))
+			return ret;
+	}
+
+	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
+	up(&s->open_sem);
+	init_MUTEX(&s->sem);
+	return 0;
+}
+
+static int
+au1550_release(struct inode *inode, struct file *file)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+
+	lock_kernel();
+	
+	if (file->f_mode & FMODE_WRITE) {
+		unlock_kernel();
+		drain_dac(s, file->f_flags & O_NONBLOCK);
+		lock_kernel();
+	}
+
+	down(&s->open_sem);
+	if (file->f_mode & FMODE_WRITE) {
+		stop_dac(s);
+		kfree(s->dma_dac.rawbuf);
+		s->dma_dac.rawbuf = NULL;
+	}
+	if (file->f_mode & FMODE_READ) {
+		stop_adc(s);
+		kfree(s->dma_adc.rawbuf);
+		s->dma_adc.rawbuf = NULL;
+	}
+	s->open_mode &= ((~file->f_mode) & (FMODE_READ|FMODE_WRITE));
+	up(&s->open_sem);
+	wake_up(&s->open_wait);
+	unlock_kernel();
+	return 0;
+}
+
+static struct file_operations au1550_audio_fops = {
+	owner:		THIS_MODULE,
+	llseek:		au1550_llseek,
+	read:		au1550_read,
+	write:		au1550_write,
+	poll:		au1550_poll,
+	ioctl:		au1550_ioctl,
+	mmap:		au1550_mmap,
+	open:		au1550_open,
+	release:	au1550_release,
+};
+
+/* Set up an internal clock for the PSC3.  This will then get
+ * driven out of the Au1550 as the master.
+ */
+static void
+intclk_setup(void)
+{
+	uint clk, rate;
+
+	/* Wire up Freq4 as a clock for the PSC3.
+	 * We know SMBus uses Freq3.
+	 * By making changes to this rate, plus the word strobe
+	 * size, we can make fine adjustments to the actual data rate.
+	 */
+	rate = get_au1x00_speed();
+#ifdef TRY_441KHz
+	rate /= (11 * 1000000);
+#else
+	rate /= (12 * 1000000);
+#endif
+
+	/* The FRDIV in the frequency control is (FRDIV + 1) * 2
+	*/
+	rate /=2;
+	rate--;
+	clk = au_readl(SYS_FREQCTRL1);
+	au_sync();
+	clk &= ~(SYS_FC_FRDIV4_MASK | SYS_FC_FS4);;
+	clk |= (rate << SYS_FC_FRDIV4_BIT);
+	clk |= SYS_FC_FE4;
+	au_writel(clk, SYS_FREQCTRL1);
+	au_sync();
+
+	/* Set up the clock source routing to get Freq4 to PSC3_intclk.
+	*/
+	clk = au_readl(SYS_CLKSRC);
+	au_sync();
+	clk &= ~0x01f00000;
+	clk |= (6 << 22);
+	au_writel(clk, SYS_CLKSRC);
+	au_sync();
+}
+
+static int __devinit
+au1550_probe(void)
+{
+	struct au1550_state *s = &au1550_state;
+	int val;
+	volatile psc_i2s_t *ip;
+#ifdef AU1550_DEBUG
+	char proc_str[80];
+#endif
+
+	memset(s, 0, sizeof(struct au1550_state));
+
+	init_waitqueue_head(&s->dma_adc.wait);
+	init_waitqueue_head(&s->dma_dac.wait);
+	init_waitqueue_head(&s->open_wait);
+	init_MUTEX(&s->open_sem);
+	spin_lock_init(&s->lock);
+
+	s->codec = &au1550_i2s_codec;
+	s->psc_addr = (volatile psc_i2s_t *)I2S_PSC_BASE;
+	ip = s->psc_addr;
+
+	if (!request_region(CPHYSADDR(ip),
+			    0x30, AU1550_MODULE_NAME)) {
+		pr_error("I2S Audio ports in use");
+	}
+
+	/* Allocate the DMA Channels
+	*/
+	if ((s->dma_dac.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_MEM_CHAN,
+	    DBDMA_I2S_TX_CHAN, dac_dma_interrupt, (void *)s)) == 0) {
+		pr_error("Can't get DAC DMA");
+		goto err_dma1;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_dac.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_dac.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		pr_error("Can't get DAC DMA descriptors");
+		goto err_dma1;
+	}
+
+	if ((s->dma_adc.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_I2S_RX_CHAN,
+	    DBDMA_MEM_CHAN, adc_dma_interrupt, (void *)s)) == 0) {
+		pr_error("Can't get ADC DMA");
+		goto err_dma2;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_adc.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_adc.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		pr_error("Can't get ADC DMA descriptors");
+		goto err_dma2;
+	}
+
+	pr_info("DAC: DMA%d, ADC: DMA%d", DBDMA_I2S_TX_CHAN, DBDMA_I2S_RX_CHAN);
+
+	/* register devices */
+
+	if ((s->dev_audio = register_sound_dsp(&au1550_audio_fops, -1)) < 0)
+		goto err_dev1;
+
+	if ((s->dev_mixer = register_sound_mixer(&au1550_mixer_fops, -1)) < 0)
+		goto err_dev2;
+
+#ifdef AU1550_DEBUG
+	/* intialize the debug proc device */
+	s->ps = create_proc_read_entry(AU1000_MODULE_NAME, 0, NULL,
+				       proc_au1550_dump, NULL);
+#endif /* AU1550_DEBUG */
+
+	intclk_setup();
+
+	/* The GPIO for the appropriate PSC was configured by the
+	 * board specific start up.
+	 *
+	 * configure PSC for I2S Audio
+	 */
+	ip->psc_ctrl = PSC_CTRL_DISABLE;	/* Disable PSC */
+	au_sync();
+	ip->psc_sel = (PSC_SEL_CLK_INTCLK | PSC_SEL_PS_I2SMODE);
+	au_sync();
+
+	/* Enable PSC
+	*/
+	ip->psc_ctrl = PSC_CTRL_ENABLE;
+	au_sync();
+
+	/* Wait for PSC ready.
+	*/
+	do {
+		val = ip->psc_i2sstat;
+		au_sync();
+	} while ((val & PSC_I2SSTAT_SR) == 0);
+
+	/* Configure I2S controller.
+	 * Deep FIFO, 16-bit sample, DMA, make sure DMA matches fifo size.
+	 * Actual I2S mode (first bit delayed by one clock).
+	 * Master mode (We provide the clock from the PSC).
+	 */
+	val = PSC_I2SCFG_SET_LEN(16);
+#ifdef TRY_441KHz
+	/* This really should be 250, but it appears that all of the
+	 * PLLs, dividers and so on in the chain shift it.  That's the
+	 * problem with sourceing the clock instead of letting the very
+	 * stable codec provide it.  But, the PSC doesn't appear to want
+	 * to work in slave mode, so this is what we get.  It's  not
+	 * studio quality timing, but it's good enough for listening
+	 * to mp3s.
+	 */
+	val |= PSC_I2SCFG_SET_WS(252);
+#else
+	val |= PSC_I2SCFG_SET_WS(250);
+#endif
+	val |= PSC_I2SCFG_RT_FIFO8 | PSC_I2SCFG_TT_FIFO8 | \
+					PSC_I2SCFG_BI | PSC_I2SCFG_XM;
+
+	ip->psc_i2scfg = val;
+	au_sync();
+	val |= PSC_I2SCFG_DE_ENABLE;
+	ip->psc_i2scfg = val;
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		val = ip->psc_i2sstat;
+		au_sync();
+	} while ((val & PSC_I2SSTAT_DR) == 0);
+
+	val = ip->psc_i2scfg;
+	au_sync();
+
+	s->codec->init_codec(s->codec);
+
+	return 0;
+
+ err_dev2:
+	unregister_sound_dsp(s->dev_audio);
+ err_dev1:
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+ err_dma2:
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+ err_dma1:
+	release_region(CPHYSADDR(I2S_PSC_BASE), 0x30);
+
+	return -1;
+}
+
+static void __devinit
+au1550_remove(void)
+{
+	struct au1550_state *s = &au1550_state;
+
+	if (!s)
+		return;
+#ifdef AU1550_DEBUG
+	if (s->ps)
+		remove_proc_entry(AU1000_MODULE_NAME, NULL);
+#endif /* AU1000_DEBUG */
+	synchronize_irq();
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+	release_region(CPHYSADDR(I2S_PSC_BASE), 0x30);
+	unregister_sound_dsp(s->dev_audio);
+	unregister_sound_mixer(s->dev_mixer);
+}
+
+static int __init
+init_au1550(void)
+{
+	return au1550_probe();
+}
+
+static void __exit
+cleanup_au1550(void)
+{
+	au1550_remove();
+}
+
+module_init(init_au1550);
+module_exit(cleanup_au1550);
+
+MODULE_AUTHOR("Advanced Micro Devices (AMD), dan@embeddededge.com");
+MODULE_DESCRIPTION("Au1550 I2S Audio Driver");
diff -urpNX dontdiff linux-2.6.11.6/sound/oss/nec_vrc5477.c linux_HEAD/sound/oss/nec_vrc5477.c
--- linux-2.6.11.6/sound/oss/nec_vrc5477.c	2005-03-26 04:28:46.000000000 +0100
+++ linux_HEAD/sound/oss/nec_vrc5477.c	2004-09-21 13:12:32.000000000 +0200
@@ -397,10 +397,10 @@ static void set_dac_rate(struct vrc5477_
 
 static int ac97_codec_not_present(struct ac97_codec *codec)
 {
-	struct vrc5477_ac97_state *s =
+	struct vrc5477_ac97_state *s = 
 		(struct vrc5477_ac97_state *)codec->private_data;
 	unsigned long flags;
-	unsigned short count  = 0xffff;
+	unsigned short count  = 0xffff; 
 
 	spin_lock_irqsave(&s->lock, flags);
 
@@ -419,8 +419,8 @@ static int ac97_codec_not_present(struct
 	outl((AC97_RESET << 16) | 0, s->io + VRC5477_CODEC_WR);
 
 	/* test whether we get a response from ac97 chip */
-	count  = 0xffff;
-	do {
+	count  = 0xffff; 
+	do { 
 	       if (!(inl(s->io + VRC5477_CODEC_WR) & 0x80000000))
 		       break;
 	} while (--count);
@@ -435,7 +435,7 @@ static int ac97_codec_not_present(struct
 
 /* --------------------------------------------------------------------- */
 
-extern inline void
+extern inline void 
 stop_dac(struct vrc5477_ac97_state *s)
 {
 	struct dmabuf* db = &s->dma_dac;
@@ -652,7 +652,7 @@ static void start_adc(struct vrc5477_ac9
 #define DMABUF_DEFAULTORDER (16-PAGE_SHIFT)
 #define DMABUF_MINORDER 1
 
-extern inline void dealloc_dmabuf(struct vrc5477_ac97_state *s,
+extern inline void dealloc_dmabuf(struct vrc5477_ac97_state *s, 
 				  struct dmabuf *db)
 {
 	if (db->lbuf) {
diff -urpNX dontdiff linux-2.6.11.6/sound/pci/ac97/ac97_codec.c linux_HEAD/sound/pci/ac97/ac97_codec.c
--- linux-2.6.11.6/sound/pci/ac97/ac97_codec.c	2005-04-03 00:24:31.000000000 +0200
+++ linux_HEAD/sound/pci/ac97/ac97_codec.c	2005-03-21 20:05:27.000000000 +0100
@@ -1308,8 +1308,9 @@ static int snd_ac97_mixer_build(ac97_t *
 	}
 	
 	/* build PC Speaker controls */
-	if ((ac97->flags & AC97_HAS_PC_BEEP) ||
-	    snd_ac97_try_volume_mix(ac97, AC97_PC_BEEP)) {
+	if (!(ac97->flags & AC97_HAS_NO_PC_BEEP) && 
+		((ac97->flags & AC97_HAS_PC_BEEP) ||
+	    snd_ac97_try_volume_mix(ac97, AC97_PC_BEEP))) {
 		for (idx = 0; idx < 2; idx++)
 			if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_controls_pc_beep[idx], ac97))) < 0)
 				return err;
@@ -1318,9 +1319,11 @@ static int snd_ac97_mixer_build(ac97_t *
 	}
 	
 	/* build Phone controls */
-	if (snd_ac97_try_volume_mix(ac97, AC97_PHONE)) {
-		if ((err = snd_ac97_cmix_new(card, "Phone Playback", AC97_PHONE, ac97)) < 0)
-			return err;
+	if (!(ac97->flags & AC97_HAS_NO_PHONE)) {
+		if (snd_ac97_try_volume_mix(ac97, AC97_PHONE)) {
+			if ((err = snd_ac97_cmix_new(card, "Phone Playback", AC97_PHONE, ac97)) < 0)
+				return err;
+		}
 	}
 	
 	/* build MIC controls */
@@ -1338,15 +1341,19 @@ static int snd_ac97_mixer_build(ac97_t *
 	}
 	
 	/* build CD controls */
-	if (snd_ac97_try_volume_mix(ac97, AC97_CD)) {
-		if ((err = snd_ac97_cmix_new(card, "CD Playback", AC97_CD, ac97)) < 0)
-			return err;
+	if (!(ac97->flags & AC97_HAS_NO_CD)) {
+		if (snd_ac97_try_volume_mix(ac97, AC97_CD)) {
+			if ((err = snd_ac97_cmix_new(card, "CD Playback", AC97_CD, ac97)) < 0)
+				return err;
+		}
 	}
 	
 	/* build Video controls */
-	if (snd_ac97_try_volume_mix(ac97, AC97_VIDEO)) {
-		if ((err = snd_ac97_cmix_new(card, "Video Playback", AC97_VIDEO, ac97)) < 0)
-			return err;
+	if (!(ac97->flags & AC97_HAS_NO_VIDEO)) {
+		if (snd_ac97_try_volume_mix(ac97, AC97_VIDEO)) {
+			if ((err = snd_ac97_cmix_new(card, "Video Playback", AC97_VIDEO, ac97)) < 0)
+				return err;
+		}
 	}
 
 	/* build Aux controls */
@@ -1392,17 +1399,18 @@ static int snd_ac97_mixer_build(ac97_t *
 	}
 
 	/* build Capture controls */
-	if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_src, ac97))) < 0)
-		return err;
-	if (snd_ac97_try_bit(ac97, AC97_REC_GAIN, 15)) {
-		if ((err = snd_ac97_cmute_new(card, "Capture Switch", AC97_REC_GAIN, ac97)) < 0)
+	if (!(ac97->flags & AC97_HAS_NO_REC_GAIN)) {
+		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_src, ac97))) < 0)
+			return err;
+		if (snd_ac97_try_bit(ac97, AC97_REC_GAIN, 15)) {
+			if ((err = snd_ac97_cmute_new(card, "Capture Switch", AC97_REC_GAIN, ac97)) < 0)
+				return err;
+		}
+		if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_vol, ac97))) < 0)
 			return err;
+		snd_ac97_write_cache(ac97, AC97_REC_SEL, 0x0000);
+		snd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x0000);
 	}
-	if ((err = snd_ctl_add(card, snd_ac97_cnew(&snd_ac97_control_capture_vol, ac97))) < 0)
-		return err;
-	snd_ac97_write_cache(ac97, AC97_REC_SEL, 0x0000);
-	snd_ac97_write_cache(ac97, AC97_REC_GAIN, 0x0000);
-
 	/* build MIC Capture controls */
 	if (snd_ac97_try_volume_mix(ac97, AC97_REC_GAIN_MIC)) {
 		for (idx = 0; idx < 2; idx++)
@@ -1544,6 +1552,7 @@ static int snd_ac97_test_rate(ac97_t *ac
 static void snd_ac97_determine_rates(ac97_t *ac97, int reg, int shadow_reg, unsigned int *r_result)
 {
 	unsigned int result = 0;
+	unsigned short saved;
 
 	if (ac97->bus->no_vra) {
 		*r_result = SNDRV_PCM_RATE_48000;
@@ -1553,6 +1562,7 @@ static void snd_ac97_determine_rates(ac9
 		return;
 	}
 
+	saved = snd_ac97_read(ac97, reg);
 	if ((ac97->ext_id & AC97_EI_DRA) && reg == AC97_PCM_FRONT_DAC_RATE)
 		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
 				     AC97_EA_DRA, 0);
@@ -1591,6 +1601,10 @@ static void snd_ac97_determine_rates(ac9
 		snd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,
 				     AC97_EA_DRA, 0);
 	}
+	/* restore the default value */
+	snd_ac97_write_cache(ac97, reg, saved);
+	if (shadow_reg)
+		snd_ac97_write_cache(ac97, shadow_reg, saved);
 	*r_result = result;
 }
 
@@ -1614,6 +1628,18 @@ static unsigned int snd_ac97_determine_s
 	return result;
 }
 
+/* look for the codec id table matching with the given id */
+static const ac97_codec_id_t *look_for_codec_id(const ac97_codec_id_t *table,
+						unsigned int id)
+{
+	const ac97_codec_id_t *pid;
+
+	for (pid = table; pid->id; pid++)
+		if (pid->id == (id & pid->mask))
+			return pid;
+	return NULL;
+}
+
 void snd_ac97_get_name(ac97_t *ac97, unsigned int id, char *name, int modem)
 {
 	const ac97_codec_id_t *pid;
@@ -1622,35 +1648,30 @@ void snd_ac97_get_name(ac97_t *ac97, uns
 		printable(id >> 24),
 		printable(id >> 16),
 		printable(id >> 8));
-	for (pid = snd_ac97_codec_id_vendors; pid->id; pid++)
-		if (pid->id == (id & pid->mask)) {
-			strcpy(name, pid->name);
-			if (ac97) {
-				if (!modem && pid->patch)
-					pid->patch(ac97);
-				else if (modem && pid->mpatch)
-					pid->mpatch(ac97);
-			} 
-			goto __vendor_ok;
-		}
-	return;
+	pid = look_for_codec_id(snd_ac97_codec_id_vendors, id);
+	if (! pid)
+		return;
 
-      __vendor_ok:
-	for (pid = snd_ac97_codec_ids; pid->id; pid++)
-		if (pid->id == (id & pid->mask)) {
-			strcat(name, " ");
-			strcat(name, pid->name);
-			if (pid->mask != 0xffffffff)
-				sprintf(name + strlen(name), " rev %d", id & ~pid->mask);
-			if (ac97) {
-				if (!modem && pid->patch)
-					pid->patch(ac97);
-				else if (modem && pid->mpatch)
-					pid->mpatch(ac97);
-			}
-			return;
+	strcpy(name, pid->name);
+	if (ac97 && pid->patch) {
+		if ((modem && (pid->flags & AC97_MODEM_PATCH)) ||
+		    (! modem && ! (pid->flags & AC97_MODEM_PATCH)))
+			pid->patch(ac97);
+	} 
+
+	pid = look_for_codec_id(snd_ac97_codec_ids, id);
+	if (pid) {
+		strcat(name, " ");
+		strcat(name, pid->name);
+		if (pid->mask != 0xffffffff)
+			sprintf(name + strlen(name), " rev %d", id & ~pid->mask);
+		if (ac97 && pid->patch) {
+			if ((modem && (pid->flags & AC97_MODEM_PATCH)) ||
+			    (! modem && ! (pid->flags & AC97_MODEM_PATCH)))
+				pid->patch(ac97);
 		}
-	sprintf(name + strlen(name), " id %x", id & 0xff);
+	} else
+		sprintf(name + strlen(name), " id %x", id & 0xff);
 }
 
 /**
--- linux-2.6.11.6/drivers/net/meth.c	2005-04-05 14:03:47.000000000 +0200
+++ linux_HEAD/drivers/net/meth.c	2005-03-02 08:38:38.000000000 +0100
@@ -27,7 +27,7 @@
 #include <linux/ip.h>          /* struct iphdr */
 #include <linux/tcp.h>         /* struct tcphdr */
 #include <linux/skbuff.h>
-#include <linux/mii.h> /*MII definitions */
+#include <linux/mii.h>         /* MII definitions */
 
 #include <asm/ip32/mace.h>
 #include <asm/ip32/ip32_ints.h>
@@ -105,27 +105,27 @@ static inline void load_eaddr(struct net
 		(int)o2meth_eaddr[3]&0xFF,(int)o2meth_eaddr[4]&0xFF,(int)o2meth_eaddr[5]&0xFF);
 	for (i = 0; i < 6; i++)
 		dev->dev_addr[i] = o2meth_eaddr[i];
-	mace_eth_write((*(u64*)o2meth_eaddr)>>16, mac_addr);
+	mace->eth.mac_addr = (*(unsigned long*)o2meth_eaddr) >> 16;
 }
 
 /*
  * Waits for BUSY status of mdio bus to clear
  */
-#define WAIT_FOR_PHY(___rval)						\
-	while ((___rval = mace_eth_read(phy_data)) & MDIO_BUSY) {	\
-		udelay(25);						\
+#define WAIT_FOR_PHY(___rval)					\
+	while ((___rval = mace->eth.phy_data) & MDIO_BUSY) {	\
+		udelay(25);					\
 	}
 /*read phy register, return value read */
 static unsigned long mdio_read(struct meth_private *priv, unsigned long phyreg)
 {
 	unsigned long rval;
 	WAIT_FOR_PHY(rval);
-	mace_eth_write((priv->phy_addr << 5) | (phyreg & 0x1f), phy_regs);
+	mace->eth.phy_regs = (priv->phy_addr << 5) | (phyreg & 0x1f);
 	udelay(25);
-	mace_eth_write(1, phy_trans_go);
+	mace->eth.phy_trans_go = 1;
 	udelay(25);
 	WAIT_FOR_PHY(rval);
-	return rval&MDIO_DATA_MASK;
+	return rval & MDIO_DATA_MASK;
 }
 
 static int mdio_probe(struct meth_private *priv)
@@ -191,7 +191,7 @@ static void meth_check_link(struct net_d
 			priv->mac_ctrl |= METH_PHY_FDX;
 		else
 			priv->mac_ctrl &= ~METH_PHY_FDX;
-		mace_eth_write(priv->mac_ctrl, mac_ctrl);
+		mace->eth.mac_ctrl = priv->mac_ctrl;
 	}
 
 	if ((priv->mac_ctrl & METH_100MBIT) ^ speed) {
@@ -200,7 +200,7 @@ static void meth_check_link(struct net_d
 			priv->mac_ctrl |= METH_100MBIT;
 		else
 			priv->mac_ctrl &= ~METH_100MBIT;
-		mace_eth_write(priv->mac_ctrl, mac_ctrl);
+		mace->eth.mac_ctrl = priv->mac_ctrl;
 	}
 }
 
@@ -214,26 +214,28 @@ static int meth_init_tx_ring(struct meth
 		return -ENOMEM;
 	memset(priv->tx_ring, 0, TX_RING_BUFFER_SIZE);
 	priv->tx_count = priv->tx_read = priv->tx_write = 0;
-	mace_eth_write(priv->tx_ring_dma, tx_ring_base);
+	mace->eth.tx_ring_base = priv->tx_ring_dma;
 	/* Now init skb save area */
-	memset(priv->tx_skbs,0,sizeof(priv->tx_skbs));
-	memset(priv->tx_skb_dmas,0,sizeof(priv->tx_skb_dmas));
+	memset(priv->tx_skbs, 0, sizeof(priv->tx_skbs));
+	memset(priv->tx_skb_dmas, 0, sizeof(priv->tx_skb_dmas));
 	return 0;
 }
 
 static int meth_init_rx_ring(struct meth_private *priv)
 {
 	int i;
-	for(i=0;i<RX_RING_ENTRIES;i++){
-		priv->rx_skbs[i]=alloc_skb(METH_RX_BUFF_SIZE,0);
-		/* 8byte status vector+3quad padding + 2byte padding,
-		   to put data on 64bit aligned boundary */
+
+	for (i = 0; i < RX_RING_ENTRIES; i++) {
+		priv->rx_skbs[i] = alloc_skb(METH_RX_BUFF_SIZE, 0);
+		/* 8byte status vector + 3quad padding + 2byte padding,
+		 * to put data on 64bit aligned boundary */
 		skb_reserve(priv->rx_skbs[i],METH_RX_HEAD);
 		priv->rx_ring[i]=(rx_packet*)(priv->rx_skbs[i]->head);
 		/* I'll need to re-sync it after each RX */
-		priv->rx_ring_dmas[i]=dma_map_single(NULL,priv->rx_ring[i],
-						     METH_RX_BUFF_SIZE,DMA_FROM_DEVICE);
-		mace_eth_write(priv->rx_ring_dmas[i], rx_fifo);
+		priv->rx_ring_dmas[i] = 
+			dma_map_single(NULL, priv->rx_ring[i],
+				       METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
+		mace->eth.rx_fifo = priv->rx_ring_dmas[i];
 	}
         priv->rx_write = 0;
 	return 0;
@@ -257,10 +259,11 @@ static void meth_free_rx_ring(struct met
 {
 	int i;
 
-	for(i=0;i<RX_RING_ENTRIES;i++) {
-		dma_unmap_single(NULL,priv->rx_ring_dmas[i],METH_RX_BUFF_SIZE,DMA_FROM_DEVICE);
-		priv->rx_ring[i]=0;
-		priv->rx_ring_dmas[i]=0;
+	for (i = 0; i < RX_RING_ENTRIES; i++) {
+		dma_unmap_single(NULL, priv->rx_ring_dmas[i],
+				 METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
+		priv->rx_ring[i] = 0;
+		priv->rx_ring_dmas[i] = 0;
 		kfree_skb(priv->rx_skbs[i]);
 	}
 }
@@ -270,8 +273,9 @@ int meth_reset(struct net_device *dev)
 	struct meth_private *priv = (struct meth_private *) dev->priv;
 
 	/* Reset card */
-	mace_eth_write(SGI_MAC_RESET, mac_ctrl);
-	mace_eth_write(0, mac_ctrl);
+	mace->eth.mac_ctrl = SGI_MAC_RESET;
+	udelay(1);
+	mace->eth.mac_ctrl = 0;
 	udelay(25);
 
 	/* Load ethernet address */
@@ -279,24 +283,24 @@ int meth_reset(struct net_device *dev)
 	/* Should load some "errata", but later */
 	
 	/* Check for device */
-	if(mdio_probe(priv) < 0) {
+	if (mdio_probe(priv) < 0) {
 		DPRINTK("Unable to find PHY\n");
 		return -ENODEV;
 	}
 
 	/* Initial mode: 10 | Half-duplex | Accept normal packets */
 	priv->mac_ctrl = METH_ACCEPT_MCAST | METH_DEFAULT_IPG;
-	if(dev->flags | IFF_PROMISC)
+	if (dev->flags | IFF_PROMISC)
 		priv->mac_ctrl |= METH_PROMISC;
-	mace_eth_write(priv->mac_ctrl, mac_ctrl);
+	mace->eth.mac_ctrl = priv->mac_ctrl;
 
 	/* Autonegotiate speed and duplex mode */
 	meth_check_link(dev);
 
 	/* Now set dma control, but don't enable DMA, yet */
-	priv->dma_ctrl= (4 << METH_RX_OFFSET_SHIFT) |
-		(RX_RING_ENTRIES << METH_RX_DEPTH_SHIFT);
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	priv->dma_ctrl = (4 << METH_RX_OFFSET_SHIFT) |
+			 (RX_RING_ENTRIES << METH_RX_DEPTH_SHIFT);
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 
 	return 0;
 }
@@ -335,7 +339,7 @@ static int meth_open(struct net_device *
 	/* Start DMA */
 	priv->dma_ctrl |= METH_DMA_TX_EN | /*METH_DMA_TX_INT_EN |*/
 			  METH_DMA_RX_EN | METH_DMA_RX_INT_EN;
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 
 	DPRINTK("About to start queue\n");
 	netif_start_queue(dev);
@@ -359,7 +363,7 @@ static int meth_release(struct net_devic
 	/* shut down DMA */
 	priv->dma_ctrl &= ~(METH_DMA_TX_EN | METH_DMA_TX_INT_EN |
 			    METH_DMA_RX_EN | METH_DMA_RX_INT_EN);
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 	free_irq(dev->irq, dev);
 	meth_free_tx_ring(priv);
 	meth_free_rx_ring(priv);
@@ -373,56 +377,57 @@ static int meth_release(struct net_devic
 static void meth_rx(struct net_device* dev, unsigned long int_status)
 {
 	struct sk_buff *skb;
+	unsigned long status;
 	struct meth_private *priv = (struct meth_private *) dev->priv;
-	unsigned long fifo_rptr=(int_status&METH_INT_RX_RPTR_MASK)>>8;
+	unsigned long fifo_rptr = (int_status & METH_INT_RX_RPTR_MASK) >> 8;
+
 	spin_lock(&priv->meth_lock);
-	priv->dma_ctrl&=~METH_DMA_RX_INT_EN;
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	priv->dma_ctrl &= ~METH_DMA_RX_INT_EN;
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 	spin_unlock(&priv->meth_lock);
 
-	if (int_status & METH_INT_RX_UNDERFLOW){
-		fifo_rptr=(fifo_rptr-1)&(0xF);
+	if (int_status & METH_INT_RX_UNDERFLOW) {
+		fifo_rptr = (fifo_rptr - 1) & 0x0f;
 	}
-	while(priv->rx_write != fifo_rptr) {
-		u64 status;
-		dma_unmap_single(NULL,priv->rx_ring_dmas[priv->rx_write],
-				 METH_RX_BUFF_SIZE,DMA_FROM_DEVICE);
-		status=priv->rx_ring[priv->rx_write]->status.raw;
+	while (priv->rx_write != fifo_rptr) {
+		dma_unmap_single(NULL, priv->rx_ring_dmas[priv->rx_write],
+				 METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
+		status = priv->rx_ring[priv->rx_write]->status.raw;
 #if MFE_DEBUG
-		if(!(status&METH_RX_ST_VALID)) {
+		if (!(status & METH_RX_ST_VALID)) {
 			DPRINTK("Not received? status=%016lx\n",status);
 		}
 #endif
-		if((!(status&METH_RX_STATUS_ERRORS))&&(status&METH_RX_ST_VALID)){
-			int len=(status&0xFFFF) - 4; /* omit CRC */
+		if ((!(status & METH_RX_STATUS_ERRORS)) && (status & METH_RX_ST_VALID)) {
+			int len = (status & 0xffff) - 4; /* omit CRC */
 			/* length sanity check */
-			if(len < 60 || len > 1518) {
-				printk(KERN_DEBUG "%s: bogus packet size: %d, status=%#2lx.\n",
+			if (len < 60 || len > 1518) {
+				printk(KERN_DEBUG "%s: bogus packet size: %ld, status=%#2lx.\n",
 				       dev->name, priv->rx_write,
 				       priv->rx_ring[priv->rx_write]->status.raw);
 				priv->stats.rx_errors++;
 				priv->stats.rx_length_errors++;
-				skb=priv->rx_skbs[priv->rx_write];
+				skb = priv->rx_skbs[priv->rx_write];
 			} else {
-				skb=alloc_skb(METH_RX_BUFF_SIZE,GFP_ATOMIC|GFP_DMA);
-				if(!skb){
+				skb = alloc_skb(METH_RX_BUFF_SIZE, GFP_ATOMIC | GFP_DMA);
+				if (!skb) {
 					/* Ouch! No memory! Drop packet on the floor */
 					DPRINTK("No mem: dropping packet\n");
 					priv->stats.rx_dropped++;
-					skb=priv->rx_skbs[priv->rx_write];
+					skb = priv->rx_skbs[priv->rx_write];
 				} else {
-					struct sk_buff *skb_c=priv->rx_skbs[priv->rx_write];
-					/* 8byte status vector+3quad padding + 2byte padding,
-					   to put data on 64bit aligned boundary */
-					skb_reserve(skb,METH_RX_HEAD);
+					struct sk_buff *skb_c = priv->rx_skbs[priv->rx_write];
+					/* 8byte status vector + 3quad padding + 2byte padding,
+					 * to put data on 64bit aligned boundary */
+					skb_reserve(skb, METH_RX_HEAD);
 					/* Write metadata, and then pass to the receive level */
-					skb_put(skb_c,len);
-					priv->rx_skbs[priv->rx_write]=skb;
+					skb_put(skb_c, len);
+					priv->rx_skbs[priv->rx_write] = skb;
 					skb_c->dev = dev;
 					skb_c->protocol = eth_type_trans(skb_c, dev);
 					dev->last_rx = jiffies;
 					priv->stats.rx_packets++;
-					priv->stats.rx_bytes+=len;
+					priv->stats.rx_bytes += len;
 					netif_rx(skb_c);
 				}
 			}
@@ -445,18 +450,19 @@ static void meth_rx(struct net_device* d
 				printk(KERN_WARNING "Carrier Event Seen\n");
 #endif
 		}
-		priv->rx_ring[priv->rx_write]=(rx_packet*)skb->head;
-		priv->rx_ring[priv->rx_write]->status.raw=0;
-		priv->rx_ring_dmas[priv->rx_write]=dma_map_single(NULL,priv->rx_ring[priv->rx_write],
-								  METH_RX_BUFF_SIZE,DMA_FROM_DEVICE);
-		mace_eth_write(priv->rx_ring_dmas[priv->rx_write], rx_fifo);
+		priv->rx_ring[priv->rx_write] = (rx_packet*)skb->head;
+		priv->rx_ring[priv->rx_write]->status.raw = 0;
+		priv->rx_ring_dmas[priv->rx_write] = 
+			dma_map_single(NULL, priv->rx_ring[priv->rx_write],
+				       METH_RX_BUFF_SIZE, DMA_FROM_DEVICE);
+		mace->eth.rx_fifo = priv->rx_ring_dmas[priv->rx_write];
 		ADVANCE_RX_PTR(priv->rx_write);
 	}
 	spin_lock(&priv->meth_lock);
 	/* In case there was underflow, and Rx DMA was disabled */
-	priv->dma_ctrl|=METH_DMA_RX_INT_EN|METH_DMA_RX_EN;
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
-	mace_eth_write(METH_INT_RX_THRESHOLD, int_stat);
+	priv->dma_ctrl |= METH_DMA_RX_INT_EN | METH_DMA_RX_EN;
+	mace->eth.dma_ctrl = priv->dma_ctrl;
+	mace->eth.int_stat = METH_INT_RX_THRESHOLD;
 	spin_unlock(&priv->meth_lock);
 }
 
@@ -464,31 +470,31 @@ static int meth_tx_full(struct net_devic
 {
 	struct meth_private *priv = (struct meth_private *) dev->priv;
 
-	return(priv->tx_count >= TX_RING_ENTRIES-1);
+	return (priv->tx_count >= TX_RING_ENTRIES - 1);
 }
 
 static void meth_tx_cleanup(struct net_device* dev, unsigned long int_status)
 {
 	struct meth_private *priv = dev->priv;
-	u64 status;
+	unsigned long status;
 	struct sk_buff *skb;
-	unsigned long rptr=(int_status&TX_INFO_RPTR)>>16;
+	unsigned long rptr = (int_status&TX_INFO_RPTR) >> 16;
 
 	spin_lock(&priv->meth_lock);
 
 	/* Stop DMA notification */
 	priv->dma_ctrl &= ~(METH_DMA_TX_INT_EN);
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 
-	while(priv->tx_read != rptr){
+	while (priv->tx_read != rptr) {
 		skb = priv->tx_skbs[priv->tx_read];
 		status = priv->tx_ring[priv->tx_read].header.raw;
 #if MFE_DEBUG>=1
-		if(priv->tx_read==priv->tx_write)
-			DPRINTK("Auchi! tx_read=%d,tx_write=%d,rptr=%d?\n",priv->tx_read,priv->tx_write,rptr);
+		if (priv->tx_read == priv->tx_write)
+			DPRINTK("Auchi! tx_read=%d,tx_write=%d,rptr=%d?\n", priv->tx_read, priv->tx_write,rptr);
 #endif
-		if(status & METH_TX_ST_DONE) {
-			if(status & METH_TX_ST_SUCCESS){
+		if (status & METH_TX_ST_DONE) {
+			if (status & METH_TX_ST_SUCCESS){
 				priv->stats.tx_packets++;
 				priv->stats.tx_bytes += skb->len;
 			} else {
@@ -518,19 +524,19 @@ static void meth_tx_cleanup(struct net_d
 		priv->tx_skbs[priv->tx_read] = NULL;
 		priv->tx_ring[priv->tx_read].header.raw = 0;
 		priv->tx_read = (priv->tx_read+1)&(TX_RING_ENTRIES-1);
-		priv->tx_count --;
+		priv->tx_count--;
 	}
 
 	/* wake up queue if it was stopped */
-	if (netif_queue_stopped(dev) && ! meth_tx_full(dev)) {
+	if (netif_queue_stopped(dev) && !meth_tx_full(dev)) {
 		netif_wake_queue(dev);
 	}
 
-	mace_eth_write(METH_INT_TX_EMPTY | METH_INT_TX_PKT, int_stat);
+	mace->eth.int_stat = METH_INT_TX_EMPTY | METH_INT_TX_PKT;
 	spin_unlock(&priv->meth_lock);
 }
 
-static void meth_error(struct net_device* dev, u32 status)
+static void meth_error(struct net_device* dev, unsigned status)
 {
 	struct meth_private *priv = (struct meth_private *) dev->priv;
 
@@ -548,17 +554,16 @@ static void meth_error(struct net_device
 	if (status & (METH_INT_RX_UNDERFLOW)) {
 		printk(KERN_WARNING "meth: Rx underflow\n");
 		spin_lock(&priv->meth_lock);
-		mace_eth_write(METH_INT_RX_UNDERFLOW, int_stat);
+		mace->eth.int_stat = METH_INT_RX_UNDERFLOW;
 		/* more underflow interrupts will be delivered, 
-		   effectively throwing us into an infinite loop.
-		   Thus I stop processing Rx in this case.
-		*/
-		priv->dma_ctrl&=~METH_DMA_RX_EN;
-		mace_eth_write(priv->dma_ctrl, dma_ctrl);
+		 * effectively throwing us into an infinite loop.
+		 *  Thus I stop processing Rx in this case. */
+		priv->dma_ctrl &= ~METH_DMA_RX_EN;
+		mace->eth.dma_ctrl = priv->dma_ctrl;
 		DPRINTK("Disabled meth Rx DMA temporarily\n");
 		spin_unlock(&priv->meth_lock);
 	}
-	mace_eth_write(METH_INT_ERROR, int_stat);
+	mace->eth.int_stat = METH_INT_ERROR;
 }
 
 /*
@@ -570,12 +575,12 @@ static irqreturn_t meth_interrupt(int ir
 	struct meth_private *priv = (struct meth_private *) dev->priv;
 	unsigned long status;
 
-	status = mace_eth_read(int_stat);
-	while (status & 0xFF) {
+	status = mace->eth.int_stat;
+	while (status & 0xff) {
 		/* First handle errors - if we get Rx underflow,
-		   Rx DMA will be disabled, and Rx handler will reenable
-		   it. I don't think it's possible to get Rx underflow,
-		   without getting Rx interrupt */
+		 * Rx DMA will be disabled, and Rx handler will reenable
+		 * it. I don't think it's possible to get Rx underflow,
+		 * without getting Rx interrupt */
 		if (status & METH_INT_ERROR) {
 			meth_error(dev, status);
 		}
@@ -589,7 +594,7 @@ static irqreturn_t meth_interrupt(int ir
 			/* send it to meth_rx for handling */
 			meth_rx(dev, status);
 		}
-		status = mace_eth_read(int_stat);
+		status = mace->eth.int_stat;
 	}
 
 	return IRQ_HANDLED;
@@ -601,45 +606,45 @@ static irqreturn_t meth_interrupt(int ir
 static void meth_tx_short_prepare(struct meth_private *priv,
 				  struct sk_buff *skb)
 {
-	tx_packet *desc=&priv->tx_ring[priv->tx_write];
-	int len = (skb->len<ETH_ZLEN)?ETH_ZLEN:skb->len;
+	tx_packet *desc = &priv->tx_ring[priv->tx_write];
+	int len = (skb->len < ETH_ZLEN) ? ETH_ZLEN : skb->len;
 
-	desc->header.raw=METH_TX_CMD_INT_EN|(len-1)|((128-len)<<16);
+	desc->header.raw = METH_TX_CMD_INT_EN | (len-1) | ((128-len) << 16);
 	/* maybe I should set whole thing to 0 first... */
-	memcpy(desc->data.dt+(120-len),skb->data,skb->len);
-	if(skb->len < len)
-		memset(desc->data.dt+120-len+skb->len,0,len-skb->len);
+	memcpy(desc->data.dt + (120 - len), skb->data, skb->len);
+	if (skb->len < len)
+		memset(desc->data.dt + 120 - len + skb->len, 0, len-skb->len);
 }
 #define TX_CATBUF1 BIT(25)
 static void meth_tx_1page_prepare(struct meth_private *priv,
 				  struct sk_buff *skb)
 {
-	tx_packet *desc=&priv->tx_ring[priv->tx_write];
+	tx_packet *desc = &priv->tx_ring[priv->tx_write];
 	void *buffer_data = (void *)(((unsigned long)skb->data + 7) & ~7);
 	int unaligned_len = (int)((unsigned long)buffer_data - (unsigned long)skb->data);
 	int buffer_len = skb->len - unaligned_len;
 	dma_addr_t catbuf;
 
-	desc->header.raw=METH_TX_CMD_INT_EN|TX_CATBUF1|(skb->len-1);
+	desc->header.raw = METH_TX_CMD_INT_EN | TX_CATBUF1 | (skb->len - 1);
 
 	/* unaligned part */
-	if(unaligned_len){
-		memcpy(desc->data.dt+(120-unaligned_len),
+	if (unaligned_len) {
+		memcpy(desc->data.dt + (120 - unaligned_len),
 		       skb->data, unaligned_len);
-		desc->header.raw |= (128-unaligned_len) << 16;
+		desc->header.raw |= (128 - unaligned_len) << 16;
 	}
 
 	/* first page */
 	catbuf = dma_map_single(NULL, buffer_data, buffer_len,
 				DMA_TO_DEVICE);
 	desc->data.cat_buf[0].form.start_addr = catbuf >> 3;
-	desc->data.cat_buf[0].form.len = buffer_len-1;
+	desc->data.cat_buf[0].form.len = buffer_len - 1;
 }
 #define TX_CATBUF2 BIT(26)
 static void meth_tx_2page_prepare(struct meth_private *priv,
 				  struct sk_buff *skb)
 {
-	tx_packet *desc=&priv->tx_ring[priv->tx_write];
+	tx_packet *desc = &priv->tx_ring[priv->tx_write];
 	void *buffer1_data = (void *)(((unsigned long)skb->data + 7) & ~7);
 	void *buffer2_data = (void *)PAGE_ALIGN((unsigned long)skb->data);
 	int unaligned_len = (int)((unsigned long)buffer1_data - (unsigned long)skb->data);
@@ -647,44 +652,44 @@ static void meth_tx_2page_prepare(struct
 	int buffer2_len = skb->len - buffer1_len - unaligned_len;
 	dma_addr_t catbuf1, catbuf2;
 
-	desc->header.raw=METH_TX_CMD_INT_EN|TX_CATBUF1|TX_CATBUF2|(skb->len-1);
+	desc->header.raw = METH_TX_CMD_INT_EN | TX_CATBUF1 | TX_CATBUF2| (skb->len - 1);
 	/* unaligned part */
-	if(unaligned_len){
-		memcpy(desc->data.dt+(120-unaligned_len),
+	if (unaligned_len){
+		memcpy(desc->data.dt + (120 - unaligned_len),
 		       skb->data, unaligned_len);
-		desc->header.raw |= (128-unaligned_len) << 16;
+		desc->header.raw |= (128 - unaligned_len) << 16;
 	}
 
 	/* first page */
 	catbuf1 = dma_map_single(NULL, buffer1_data, buffer1_len,
 				 DMA_TO_DEVICE);
 	desc->data.cat_buf[0].form.start_addr = catbuf1 >> 3;
-	desc->data.cat_buf[0].form.len = buffer1_len-1;
+	desc->data.cat_buf[0].form.len = buffer1_len - 1;
 	/* second page */
 	catbuf2 = dma_map_single(NULL, buffer2_data, buffer2_len,
 				 DMA_TO_DEVICE);
 	desc->data.cat_buf[1].form.start_addr = catbuf2 >> 3;
-	desc->data.cat_buf[1].form.len = buffer2_len-1;
+	desc->data.cat_buf[1].form.len = buffer2_len - 1;
 }
 
 static void meth_add_to_tx_ring(struct meth_private *priv, struct sk_buff *skb)
 {
 	/* Remember the skb, so we can free it at interrupt time */
 	priv->tx_skbs[priv->tx_write] = skb;
-	if(skb->len <= 120) {
+	if (skb->len <= 120) {
 		/* Whole packet fits into descriptor */
-		meth_tx_short_prepare(priv,skb);
-	} else if(PAGE_ALIGN((unsigned long)skb->data) !=
-		  PAGE_ALIGN((unsigned long)skb->data+skb->len-1)) {
+		meth_tx_short_prepare(priv, skb);
+	} else if (PAGE_ALIGN((unsigned long)skb->data) !=
+		   PAGE_ALIGN((unsigned long)skb->data + skb->len - 1)) {
 		/* Packet crosses page boundary */
-		meth_tx_2page_prepare(priv,skb);
+		meth_tx_2page_prepare(priv, skb);
 	} else {
 		/* Packet is in one page */
-		meth_tx_1page_prepare(priv,skb);
+		meth_tx_1page_prepare(priv, skb);
 	}
-	priv->tx_write = (priv->tx_write+1) & (TX_RING_ENTRIES-1);
-	mace_eth_write(priv->tx_write, tx_info);
-	priv->tx_count ++;
+	priv->tx_write = (priv->tx_write + 1) & (TX_RING_ENTRIES - 1);
+	mace->eth.tx_info = priv->tx_write;
+	priv->tx_count++;
 }
 
 /*
@@ -695,10 +700,10 @@ static int meth_tx(struct sk_buff *skb, 
 	struct meth_private *priv = (struct meth_private *) dev->priv;
 	unsigned long flags;
 
-	spin_lock_irqsave(&priv->meth_lock,flags);
+	spin_lock_irqsave(&priv->meth_lock, flags);
 	/* Stop DMA notification */
 	priv->dma_ctrl &= ~(METH_DMA_TX_INT_EN);
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 
 	meth_add_to_tx_ring(priv, skb);
 	dev->trans_start = jiffies; /* save the timestamp */
@@ -711,9 +716,9 @@ static int meth_tx(struct sk_buff *skb, 
 
 	/* Restart DMA notification */
 	priv->dma_ctrl |= METH_DMA_TX_INT_EN;
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 
-	spin_unlock_irqrestore(&priv->meth_lock,flags);
+	spin_unlock_irqrestore(&priv->meth_lock, flags);
 
 	return 0;
 }
@@ -743,11 +748,11 @@ static void meth_tx_timeout(struct net_d
 	meth_init_rx_ring(priv);
 
 	/* Restart dma */
-	priv->dma_ctrl|=METH_DMA_TX_EN|METH_DMA_RX_EN|METH_DMA_RX_INT_EN;
-	mace_eth_write(priv->dma_ctrl, dma_ctrl);
+	priv->dma_ctrl |= METH_DMA_TX_EN | METH_DMA_RX_EN | METH_DMA_RX_INT_EN;
+	mace->eth.dma_ctrl = priv->dma_ctrl;
 
 	/* Enable interrupt */
-	spin_unlock_irqrestore(&priv->meth_lock,flags);
+	spin_unlock_irqrestore(&priv->meth_lock, flags);
 
 	dev->trans_start = jiffies;
 	netif_wake_queue(dev);
@@ -760,8 +765,14 @@ static void meth_tx_timeout(struct net_d
  */
 static int meth_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-	DPRINTK("ioctl\n");
-	return 0;
+	/* XXX Not yet implemented */
+	switch(cmd) { 
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+	default:
+		return -EOPNOTSUPP;
+	}
 }
 
 /*
@@ -808,7 +819,7 @@ static struct net_device *meth_init(void
 	}
 
 	printk(KERN_INFO "%s: SGI MACE Ethernet rev. %d\n",
-	       dev->name, (unsigned int)mace_eth_read(mac_ctrl) >> 29);
+	       dev->name, (unsigned int)(mace->eth.mac_ctrl >> 29));
 	return 0;
 }
 
