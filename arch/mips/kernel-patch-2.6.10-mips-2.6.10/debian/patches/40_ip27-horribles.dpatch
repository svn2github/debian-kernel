#! /bin/sh -e
## 40_ip27-horribles.dpatch by Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Some horrible hacks to make ip27 appear to work.

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p0 ${patch_opts} < $0;;
    -unpatch) patch -R -p0 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

Index: arch/mips/pci/pci.c
===================================================================
RCS file: /home/cvs/linux/arch/mips/pci/pci.c,v
retrieving revision 1.30
diff -u -p -r1.30 pci.c
--- arch/mips/pci/pci.c	16 Dec 2004 12:55:01 -0000	1.30
+++ arch/mips/pci/pci.c	10 Jan 2005 22:10:33 -0000
@@ -20,11 +20,11 @@
  * Make this long-lived  so that we know when shutting down
  * whether we probed only or not.
  */
-int pci_probe_only;
+int pci_probe_only = 1;
 
 #define PCI_ASSIGN_ALL_BUSSES	1
 
-unsigned int pci_probe = PCI_ASSIGN_ALL_BUSSES;
+unsigned int pci_probe = 0; // PCI_ASSIGN_ALL_BUSSES;
 
 /*
  * The PCI controller list.
Index: drivers/md/md.c
===================================================================
RCS file: /home/cvs/linux/drivers/md/md.c,v
retrieving revision 1.78
diff -u -p -r1.78 md.c
--- drivers/md/md.c	4 Dec 2004 18:16:04 -0000	1.78
+++ drivers/md/md.c	10 Jan 2005 22:10:33 -0000
@@ -429,6 +429,7 @@ abort:
 	return ret;
 }
 
+#if 0
 static unsigned int calc_sb_csum(mdp_super_t * sb)
 {
 	unsigned int disk_csum, csum;
@@ -439,6 +440,23 @@ static unsigned int calc_sb_csum(mdp_sup
 	sb->sb_csum = disk_csum;
 	return csum;
 }
+#else
+unsigned long calc_sb_csum(mdp_super_t *super)
+{
+        unsigned int  oldcsum = super->sb_csum;
+        unsigned long long newcsum = 0;
+        unsigned long csum;
+        int i;
+        unsigned int *superc = (int*) super;
+        super->sb_csum = 0;
+                                                                                
+        for(i=0; i<MD_SB_BYTES/4; i++)
+                newcsum+= superc[i];
+        csum = (newcsum& 0xffffffff) + (newcsum>>32);
+        super->sb_csum = oldcsum;
+        return csum;
+}
+#endif
 
 
 /*
Index: drivers/scsi/qlogicisp.c
===================================================================
RCS file: /home/cvs/linux/drivers/scsi/qlogicisp.c,v
retrieving revision 1.40
diff -u -p -r1.40 qlogicisp.c
--- drivers/scsi/qlogicisp.c	25 Oct 2004 20:44:35 -0000	1.40
+++ drivers/scsi/qlogicisp.c	10 Jan 2005 22:10:34 -0000
@@ -1044,28 +1044,31 @@ void isp1020_intr_handler(int irq, void 
 
 		DEBUG_INTR(isp1020_print_status_entry(sts));
 
-		if (sts->hdr.entry_type == ENTRY_STATUS)
-			Cmnd->result = isp1020_return_status(sts);
-		else
-			Cmnd->result = DID_ERROR << 16;
-
-		if (Cmnd->use_sg)
-			pci_unmap_sg(hostdata->pci_dev,
-				     (struct scatterlist *)Cmnd->buffer,
-				     Cmnd->use_sg,
-				     scsi_to_pci_dma_dir(Cmnd->sc_data_direction));
-		else if (Cmnd->request_bufflen)
-			pci_unmap_single(hostdata->pci_dev,
+		if (Cmnd) {
+			if (sts->hdr.entry_type == ENTRY_STATUS)
+				Cmnd->result = isp1020_return_status(sts);
+			else
+				Cmnd->result = DID_ERROR << 16;
+
+			if (Cmnd->use_sg)
+				pci_unmap_sg(hostdata->pci_dev,
+					     (struct scatterlist *)Cmnd->buffer,
+					     Cmnd->use_sg,
+					     scsi_to_pci_dma_dir(Cmnd->sc_data_direction));
+			else if (Cmnd->request_bufflen)
+				pci_unmap_single(hostdata->pci_dev,
 #ifdef CONFIG_QL_ISP_A64
-					 (dma_addr_t)((long)Cmnd->SCp.ptr),
+						 (dma_addr_t)((long)Cmnd->SCp.ptr),
 #else
-					 (u32)((long)Cmnd->SCp.ptr),
+						 (u32)((long)Cmnd->SCp.ptr),
 #endif
-					 Cmnd->request_bufflen,
-					 scsi_to_pci_dma_dir(Cmnd->sc_data_direction));
+						 Cmnd->request_bufflen,
+						 scsi_to_pci_dma_dir(Cmnd->sc_data_direction));
 
 		isp_outw(out_ptr, host, MBOX5);
 		(*Cmnd->scsi_done)(Cmnd);
+		} else
+			printk(KERN_CRIT "qlogic: Cmnd == NULL");
 	}
 	hostdata->res_out_ptr = out_ptr;
 
@@ -1233,6 +1236,13 @@ int isp1020_reset(Scsi_Cmnd *Cmnd, unsig
 	return return_status;
 }
 
+static int
+isp1020_eh_abort(struct scsi_cmnd * cmd)
+{
+	printk(KERN_WARNING "ISP1020 is toast\n");
+	return -ENODEV;
+}
+
 
 int isp1020_biosparam(struct scsi_device *sdev, struct block_device *n,
 		sector_t capacity, int ip[])
@@ -1984,6 +1994,7 @@ static Scsi_Host_Template driver_templat
 	.release		= isp1020_release,
 	.info			= isp1020_info,	
 	.queuecommand		= isp1020_queuecommand,
+	.eh_abort_handler	= isp1020_eh_abort,
 	.bios_param		= isp1020_biosparam,
 	.can_queue		= QLOGICISP_REQ_QUEUE_LEN,
 	.this_id		= -1,
