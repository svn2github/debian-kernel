diff -urN kernel-source-2.4.27/arch/ppc/boot/common/misc-simple.c kernel-source-2.4.27-benh/arch/ppc/boot/common/misc-simple.c
--- kernel-source-2.4.27/arch/ppc/boot/common/misc-simple.c	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/boot/common/misc-simple.c	2004-09-01 20:56:21.829800424 +0200
@@ -75,7 +75,7 @@
 extern void gunzip(void *, int, unsigned char *, int *);
 extern void serial_fixups(void);
 
-struct bi_record *
+static struct bi_record *
 decompress_kernel(unsigned long load_addr, int num_words, unsigned long cksum,
 		void *ignored)
 {
diff -urN kernel-source-2.4.27/arch/ppc/boot/pmac/chrpmain.c kernel-source-2.4.27-benh/arch/ppc/boot/pmac/chrpmain.c
--- kernel-source-2.4.27/arch/ppc/boot/pmac/chrpmain.c	2004-02-18 14:36:30.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/boot/pmac/chrpmain.c	2004-09-01 20:56:21.904789024 +0200
@@ -29,8 +29,10 @@
 
 #define RAM_END		(16 << 20)
 
-#define PROG_START	0x00010000
-#define PROG_SIZE	0x003f0000
+//#define PROG_START	0x00010000
+//#define PROG_SIZE	0x003f0000
+#define PROG_START	0x00800000
+#define PROG_SIZE	0x00800000
 
 #define SCRATCH_SIZE	(128 << 10)
 
diff -urN kernel-source-2.4.27/arch/ppc/boot/pmac/coffmain.c kernel-source-2.4.27-benh/arch/ppc/boot/pmac/coffmain.c
--- kernel-source-2.4.27/arch/ppc/boot/pmac/coffmain.c	2004-02-18 14:36:30.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/boot/pmac/coffmain.c	2004-09-01 20:56:21.906788720 +0200
@@ -18,29 +18,36 @@
 extern char __ramdisk_begin[], __ramdisk_end;
 extern char _start, _end;
 
+extern int map(unsigned, unsigned, unsigned);
 extern char image_data[], initrd_data[];
 extern int initrd_len, image_len;
+extern int getprop(void *, const char *, void *, int);
 extern unsigned int heap_max;
+extern void *finddevice(const char *);
 extern void flush_cache(void *start, unsigned int len);
 extern void gunzip(void *, int, unsigned char *, int *);
 extern void make_bi_recs(unsigned long addr, char *name, unsigned int mach,
 		unsigned int progend);
+extern void pause(void);
 extern void setup_bats(unsigned long start);
 
 char *avail_ram;
 char *begin_avail, *end_avail;
 char *avail_high;
 
-#define RAM_START	0
-#define RAM_END		(RAM_START + 0x800000)	/* only 8M mapped with BATs */
-
-#define PROG_START	RAM_START
-#define PROG_SIZE	0x00400000
-
 #define SCRATCH_SIZE	(128 << 10)
 
 static char heap[SCRATCH_SIZE];
 
+//static unsigned long ram_start = 0;
+//static unsigned long ram_end = 0x800000;
+//static unsigned long prog_start = 0;
+//static unsigned long prog_size = 0x380000;
+
+static unsigned long ram_start = 0;
+static unsigned long ram_end = 0x1000000;
+static unsigned long prog_start = 0x800000;
+static unsigned long prog_size = 0x800000;
 typedef void (*kernel_start_t)(int, int, void *);
 
 void boot(int a1, int a2, void *prom)
@@ -51,32 +58,36 @@
     unsigned initrd_start, initrd_size;
 
     printf("coffboot starting: loaded at 0x%p\n", &_start);
-    setup_bats(RAM_START);
+    setup_bats(ram_start);
 
     initrd_size = (char *)(&__ramdisk_end) - (char *)(&__ramdisk_begin);
     if (initrd_size) {
-	initrd_start = (RAM_END - initrd_size) & ~0xFFF;
+	initrd_start = (ram_end - initrd_size) & ~0xFFF;
 	a1 = initrd_start;
 	a2 = initrd_size;
-	claim(initrd_start, RAM_END - initrd_start, 0);
+	claim(initrd_start, ram_end - initrd_start, 0);
 	printf("initial ramdisk moving 0x%x <- 0x%p (%x bytes)\n\r",
 	       initrd_start, (char *)(&__ramdisk_begin), initrd_size);
 	memcpy((char *)initrd_start, (char *)(&__ramdisk_begin), initrd_size);
+	prog_size = initrd_start - prog_start;
     } else
 	a2 = 0xdeadbeef;
 
     im = (char *)(&__image_begin);
     len = (char *)(&__image_end) - (char *)(&__image_begin);
     /* claim 4MB starting at 0 */
-    claim(0, PROG_SIZE, 0);
-    dst = (void *) RAM_START;
+    claim(prog_start, prog_size, 0);
+#if 0 /* Broken */
+    map(prog_start, prog_start, prog_size);
+#endif
+    dst = (void *) prog_start;
     if (im[0] == 0x1f && im[1] == 0x8b) {
 	/* set up scratch space */
 	begin_avail = avail_high = avail_ram = heap;
 	end_avail = heap + sizeof(heap);
 	printf("heap at 0x%p\n", avail_ram);
 	printf("gunzipping (0x%p <- 0x%p:0x%p)...", dst, im, im+len);
-	gunzip(dst, PROG_SIZE, im, &len);
+	gunzip(dst, prog_size, im, &len);
 	printf("done %u bytes\n", len);
 	printf("%u bytes of heap consumed, max in use %u\n",
 	       avail_high - begin_avail, heap_max);
@@ -86,9 +97,9 @@
 
     flush_cache(dst, len);
     make_bi_recs(((unsigned long) dst + len), "coffboot", _MACH_Pmac,
-		    (PROG_START + PROG_SIZE));
+		    (prog_start + prog_size));
 
-    sa = (unsigned long)PROG_START;
+    sa = (unsigned long)prog_start;
     printf("start address = 0x%x\n", sa);
 
     (*(kernel_start_t)sa)(a1, a2, prom);
diff -urN kernel-source-2.4.27/arch/ppc/boot/pmac/misc.S kernel-source-2.4.27-benh/arch/ppc/boot/pmac/misc.S
--- kernel-source-2.4.27/arch/ppc/boot/pmac/misc.S	2003-06-13 16:51:31.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/boot/pmac/misc.S	2004-09-01 20:56:21.980777472 +0200
@@ -22,6 +22,10 @@
 	mtibatl	3,0			/* invalidate BAT first */
 	ori	3,3,4			/* set up BAT registers for 601 */
 	li	4,0x7f
+	mtibatu	2,3
+	mtibatl	2,4
+	oris	3,3,0x80
+	oris	4,4,0x80
 	mtibatu	3,3
 	mtibatl	3,4
 	b	5f
@@ -29,6 +33,12 @@
 	mtibatu	3,0
 	ori	3,3,0xff		/* set up BAT registers for 604 */
 	li	4,2
+	mtdbatl	2,4
+	mtdbatu	2,3
+	mtibatl	2,4
+	mtibatu	2,3
+	oris	3,3,0x80
+	oris	4,4,0x80
 	mtdbatl	3,4
 	mtdbatu	3,3
 	mtibatl	3,4
diff -urN kernel-source-2.4.27/arch/ppc/config.in kernel-source-2.4.27-benh/arch/ppc/config.in
--- kernel-source-2.4.27/arch/ppc/config.in	2004-08-08 01:26:04.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/config.in	2004-09-01 20:56:22.057765768 +0200
@@ -55,6 +55,17 @@
   define_bool CONFIG_PPC_STD_MMU y
 fi
 
+bool 'CPU Frequency scaling' CONFIG_CPU_FREQ
+if [ "$CONFIG_CPU_FREQ" = "y" ]; then
+   bool '  /proc/sys/cpu/ interface (2.4.)' CONFIG_CPU_FREQ_24_API
+   if [ "$CONFIG_CPU_FREQ_24_API" = "n" ]; then
+       define_bool CONFIG_CPU_FREQ_26_API y
+   fi
+   if [ "$CONFIG_ADB_PMU" = "y" ]; then
+       bool "  Support for Apple PowerBooks" CONFIG_CPU_FREQ_PMAC
+   fi
+fi
+
 if [ "$CONFIG_8260" = "y" ]; then
   define_bool CONFIG_SERIAL_CONSOLE y
   define_bool CONFIG_CPM2 y
@@ -581,6 +592,9 @@
   if [ "$CONFIG_ADB_CUDA" != "n" ]; then
     bool 'Support for ANS LCD display' CONFIG_ANSLCD
   fi
+  if [ "$CONFIG_POWER4" != "n" ]; then
+    dep_tristate 'Support for thermal management on PowerMac G5' CONFIG_THERM_PM72 $CONFIG_I2C
+  fi
 fi
 endmenu
 
@@ -620,6 +634,10 @@
 
 bool 'Kernel debugging' CONFIG_DEBUG_KERNEL
 if [ "$CONFIG_DEBUG_KERNEL" = "y" ]; then
+  bool '  Check PTEs in free_one_pmds' CONFIG_DEBUG_CHECK_PMD_FREE
+  bool '  Disable page tables caching' CONFIG_DEBUG_NOPGTABLECACHE
+  bool '  Flush TLBs with lock' CONFIG_DEBUG_FLUSHWITHLOCK
+  bool '  Keep 745x CPU firmware setup' CONFIG_DEBUG_FW_CPU_SETUP
   bool '  Magic SysRq key' CONFIG_MAGIC_SYSRQ
   bool '  Debug high memory support' CONFIG_DEBUG_HIGHMEM
   bool '  Debug memory allocations' CONFIG_DEBUG_SLAB
@@ -639,6 +657,9 @@
     dep_bool '    Enable serial console thru kgdb port' CONFIG_KGDB_CONSOLE $CONFIG_KGDB
   fi
   bool '  Include xmon kernel debugger' CONFIG_XMON
+  if [ "$CONFIG_XMON" = "y" ]; then
+	  bool '    xmon over firewire remote debugging' CONFIG_XMON_FW
+  fi
   bool '  Include BDI-2000 user context switcher' CONFIG_BDI_SWITCH
   # CONFIG_KGDB is much more useful with -g enbaled.  This makes the
   # following look a little odd.
diff -urN kernel-source-2.4.27/arch/ppc/kernel/btext.c kernel-source-2.4.27-benh/arch/ppc/kernel/btext.c
--- kernel-source-2.4.27/arch/ppc/kernel/btext.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/btext.c	2004-09-01 20:56:22.206743120 +0200
@@ -42,22 +42,14 @@
 static unsigned char vga_font[cmapsz];
 
 int boot_text_mapped;
+int force_printk_to_btext;
 
 boot_infos_t disp_bi;
 
 extern char *klimit;
 
-/*
- * Powermac can use btext_* after boot for xmon,
- * chrp only uses it during early boot.
- */
-#ifdef CONFIG_XMON
-#define BTEXT	__pmac
-#define BTDATA	__pmacdata
-#else
-#define BTEXT	__init
-#define BTDATA	__initdata
-#endif /* CONFIG_XMON */
+#define BTEXT
+#define BTDATA
 
 /*
  * This is called only when we are booted via BootX.
diff -urN kernel-source-2.4.27/arch/ppc/kernel/cpu_setup_6xx.S kernel-source-2.4.27-benh/arch/ppc/kernel/cpu_setup_6xx.S
--- kernel-source-2.4.27/arch/ppc/kernel/cpu_setup_6xx.S	2004-02-18 14:36:30.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/cpu_setup_6xx.S	2004-09-01 20:56:22.208742816 +0200
@@ -53,6 +53,9 @@
 	bl	setup_7400_workarounds
 	bl	setup_common_caches
 	bl	setup_750_7400_hid0
+	mfspr	r3,SPRN_MSSCR0
+	ori	r3,r3,0x0100
+	mtspr	SPRN_MSSCR0,r3
 	mtlr	r4
 	blr
 _GLOBAL(__setup_cpu_7410)
@@ -67,7 +70,9 @@
 _GLOBAL(__setup_cpu_745x)
 	mflr	r4
 	bl	setup_common_caches
+#ifndef CONFIG_DEBUG_FW_CPU_SETUP
 	bl	setup_745x_specifics
+#endif
 	mtlr	r4
 	blr
 
diff -urN kernel-source-2.4.27/arch/ppc/kernel/cpu_setup_power4.S kernel-source-2.4.27-benh/arch/ppc/kernel/cpu_setup_power4.S
--- kernel-source-2.4.27/arch/ppc/kernel/cpu_setup_power4.S	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/cpu_setup_power4.S	2004-09-01 20:56:22.284731264 +0200
@@ -0,0 +1,183 @@
+/*
+ * This file contains low level CPU setup functions.
+ *    Copyright (C) 2003 Benjamin Herrenschmidt (benh@kernel.crashing.org)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/ppc_asm.h>
+#include <asm/cache.h>
+
+#include "ppc_defs.h"
+
+_GLOBAL(__power4_cpu_preinit)
+	/*
+	 * On the PPC970, we have to turn off real-mode cache inhibit
+	 * early, before we first turn the MMU off.
+	 */
+	mfspr	r0,SPRN_PVR
+	srwi	r0,r0,16
+	cmpwi	r0,0x39
+	bnelr
+
+	li	r0,0
+	sync
+	mtspr	SPRN_HID4,r0
+	isync
+	sync
+	mtspr	SPRN_HID5,r0
+	isync
+
+	mfspr	r0,SPRN_HID1
+	li	r11,0x1200		/* enable i-fetch cacheability */
+	sldi	r11,r11,44		/* and prefetch */
+	or	r0,r0,r11
+	mtspr	SPRN_HID1,r0
+	mtspr	SPRN_HID1,r0
+	isync
+	li	r0,0
+	sync
+	mtspr	SPRN_HIOR,0		/* Clear interrupt prefix */
+	isync
+	blr
+
+_GLOBAL(__setup_cpu_power4)
+	blr
+_GLOBAL(__setup_cpu_ppc970)
+	mfspr	r0,SPRN_HID0
+	li	r11,5			/* clear DOZE and SLEEP */
+	rldimi	r0,r11,52,8		/* set NAP and DPM */
+	mtspr	SPRN_HID0,r0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	mfspr	r0,SPRN_HID0
+	sync
+	isync
+	blr
+
+/* Definitions for the table use to save CPU states */
+#define CS_HID0		0
+#define CS_HID1		8
+#define	CS_HID4		16
+#define CS_HID5		24
+#define CS_SIZE		32
+
+	.data
+	.balign	L1_CACHE_LINE_SIZE
+cpu_state_storage:	
+	.space	CS_SIZE
+	.balign	L1_CACHE_LINE_SIZE,0
+	.text
+	
+/* Called in normal context to backup CPU 0 state. This
+ * does not include cache settings. This function is also
+ * called for machine sleep. This does not include the MMU
+ * setup, BATs, etc... but rather the "special" registers
+ * like HID0, HID1, HID4, etc...
+ */
+_GLOBAL(__save_cpu_setup)
+	/* Some CR fields are volatile, we back it up all */
+	mfcr	r7
+
+	/* Get storage ptr */
+	lis	r5,cpu_state_storage@h
+	ori	r5,r5,cpu_state_storage@l
+
+	/* We only deal with 970 for now */
+	mfspr	r0,SPRN_PVR
+	srwi	r0,r0,16
+	cmpwi	r0,0x39
+	bne	1f
+
+	/* Save HID0,1,4 and 5 */
+	mfspr	r3,SPRN_HID0
+	std	r3,CS_HID0(r5)
+	mfspr	r3,SPRN_HID1
+	std	r3,CS_HID1(r5)
+	mfspr	r3,SPRN_HID4
+	std	r3,CS_HID4(r5)
+	mfspr	r3,SPRN_HID5
+	std	r3,CS_HID5(r5)
+	
+1:
+	mtcr	r7
+	blr
+
+/* Called with no MMU context (typically MSR:IR/DR off) to
+ * restore CPU state as backed up by the previous
+ * function. This does not include cache setting
+ */
+_GLOBAL(__restore_cpu_setup)
+	/* Some CR fields are volatile, we back it up all */
+	mfcr	r7
+
+	/* Get storage ptr */
+	lis	r5,(cpu_state_storage-KERNELBASE)@h
+	ori	r5,r5,cpu_state_storage@l
+
+	/* We only deal with 970 for now */
+	mfspr	r0,SPRN_PVR
+	srwi	r0,r0,16
+	cmpwi	r0,0x39
+	bne	1f
+
+	/* Clear interrupt prefix */
+	li	r0,0
+	sync
+	mtspr	SPRN_HIOR,0
+	isync
+
+	/* Restore HID0 */
+	ld	r3,CS_HID0(r5)
+	sync
+	isync
+	mtspr	SPRN_HID0,r3
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	mfspr	r3,SPRN_HID0
+	sync
+	isync
+
+	/* Restore HID1 */
+	ld	r3,CS_HID1(r5)
+	sync
+	isync
+	mtspr	SPRN_HID1,r3
+	mtspr	SPRN_HID1,r3
+	sync
+	isync
+	
+	/* Restore HID4 */
+	ld	r3,CS_HID4(r5)
+	sync
+	isync
+	mtspr	SPRN_HID4,r3
+	sync
+	isync
+
+	/* Restore HID5 */
+	ld	r3,CS_HID5(r5)
+	sync
+	isync
+	mtspr	SPRN_HID5,r3
+	sync
+	isync
+1:
+	mtcr	r7
+	blr
+
diff -urN kernel-source-2.4.27/arch/ppc/kernel/cputable.c kernel-source-2.4.27-benh/arch/ppc/kernel/cputable.c
--- kernel-source-2.4.27/arch/ppc/kernel/cputable.c	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/cputable.c	2004-09-01 20:56:22.361719560 +0200
@@ -47,8 +47,10 @@
  */
 #ifdef CONFIG_ALTIVEC
 #define CPU_FTR_ALTIVEC_COMP	CPU_FTR_ALTIVEC
+#define PPC_FEATURE_ALTIVEC_COMP    	PPC_FEATURE_HAS_ALTIVEC  
 #else
 #define CPU_FTR_ALTIVEC_COMP	0
+#define PPC_FEATURE_ALTIVEC_COMP       	0
 #endif
 
 struct cpu_spec	cpu_specs[] = {
@@ -180,7 +182,7 @@
     	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_CAN_DOZE | CPU_FTR_USE_TB |
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_HPTE_TABLE |
 	CPU_FTR_CAN_NAP,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_7400
     },
@@ -189,7 +191,7 @@
     	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_CAN_DOZE | CPU_FTR_USE_TB |
 	CPU_FTR_L2CR | CPU_FTR_TAU | CPU_FTR_ALTIVEC_COMP | CPU_FTR_HPTE_TABLE |
 	CPU_FTR_CAN_NAP,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_7400
     },
@@ -198,7 +200,7 @@
     	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_CAN_DOZE | CPU_FTR_USE_TB |
 	CPU_FTR_L2CR | CPU_FTR_TAU | CPU_FTR_ALTIVEC_COMP | CPU_FTR_HPTE_TABLE |
 	CPU_FTR_CAN_NAP,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_7410
     },
@@ -207,7 +209,7 @@
     	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB |
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -216,7 +218,7 @@
     	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB |
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -226,7 +228,7 @@
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450 | CPU_FTR_NAP_DISABLE_L2_PR |
 	CPU_FTR_L3_DISABLE_NAP,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -235,7 +237,7 @@
     	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB | CPU_FTR_CAN_NAP |
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450 | CPU_FTR_NAP_DISABLE_L2_PR,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -244,7 +246,7 @@
     	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB |
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450 | CPU_FTR_HAS_HIGH_BATS,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -254,7 +256,7 @@
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450 | CPU_FTR_NAP_DISABLE_L2_PR |
 	CPU_FTR_L3_DISABLE_NAP | CPU_FTR_HAS_HIGH_BATS,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -264,7 +266,7 @@
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450 | CPU_FTR_NAP_DISABLE_L2_PR |
 	CPU_FTR_HAS_HIGH_BATS,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -274,7 +276,7 @@
 	CPU_FTR_L2CR | CPU_FTR_ALTIVEC_COMP | CPU_FTR_L3CR |
 	CPU_FTR_HPTE_TABLE | CPU_FTR_SPEC7450 | CPU_FTR_NAP_DISABLE_L2_PR |
 	CPU_FTR_HAS_HIGH_BATS,
-	COMMON_PPC | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_ALTIVEC_COMP,
 	32, 32,
 	__setup_cpu_745x
     },
@@ -343,7 +345,7 @@
 	0xffff0000, 0x00390000, "PPC970",
 	CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB | CPU_FTR_HPTE_TABLE |
 	CPU_FTR_ALTIVEC_COMP | CPU_FTR_CAN_NAP,
-	COMMON_PPC | PPC_FEATURE_64 | PPC_FEATURE_HAS_ALTIVEC,
+	COMMON_PPC | PPC_FEATURE_64 | PPC_FEATURE_ALTIVEC_COMP,
 	128, 128,
 	__setup_cpu_ppc970
     },
diff -urN kernel-source-2.4.27/arch/ppc/kernel/head.S kernel-source-2.4.27-benh/arch/ppc/kernel/head.S
--- kernel-source-2.4.27/arch/ppc/kernel/head.S	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/head.S	2004-09-01 20:56:22.445706792 +0200
@@ -141,17 +141,6 @@
 	mr	r27,r7
 	li	r24,0			/* cpu # */
 
-#ifdef CONFIG_POWER4
-/*
- * On the PPC970, we have to turn off real-mode cache inhibit
- * early, before we first turn the MMU off.
- */
-	mfspr	r0,SPRN_PVR
-	srwi	r0,r0,16
-	cmpwi	r0,0x39
-	beql	ppc970_setup_hid
-#endif
-
 /*
  * early_init() does the early machine identification and does
  * the necessary low-level setup and clears the BSS
@@ -159,6 +148,10 @@
  */
 	bl	early_init
 
+#ifdef CONFIG_POWER4
+	bl	__power4_cpu_preinit
+#endif /* CONFIG_POWER4 */
+
 #ifdef CONFIG_APUS
 /* On APUS the __va/__pa constants need to be set to the correct
  * values before continuing.
@@ -181,26 +174,8 @@
 	bl	setup_disp_bat
 #endif
 #else /* CONFIG_POWER4 */
-/*
- * Load up the SDR1 and segment register values now
- * since we don't have the BATs.
- * Also make sure we are running in 32-bit mode.
- */
 	bl	reloc_offset
-	addis	r14,r3,_SDR1@ha		/* get the value from _SDR1 */
-	lwz	r14,_SDR1@l(r14)	/* assume hash table below 4GB */
-	mtspr	SDR1,r14
-	slbia
-	lis	r4,0x2000		/* set pseudo-segment reg 12 */
-	ori	r5,r4,0x0ccc
-	mtsr	12,r5
-	ori	r4,r4,0x0888		/* set pseudo-segment reg 8 */
-	mtsr	8,r4			/* (for access to serial port) */
-	mfmsr	r0
-	clrldi	r0,r0,1
-	sync
-	mtmsr	r0
-	isync
+	bl	initial_mm_power4
 #endif /* CONFIG_POWER4 */
 
 	/*
@@ -331,17 +306,14 @@
 	. = 0x100
 	b	__secondary_start_gemini
 #else /* CONFIG_GEMINI */
-	STD_EXCEPTION(0x100, Reset, __secondary_start_psurge)
+	//STD_EXCEPTION(0x100, Reset, __secondary_start_psurge)
+	STD_EXCEPTION(0x100, Reset, UnknownException)
 #endif /* CONFIG_GEMINI */
 #else
 	STD_EXCEPTION(0x100, Reset, UnknownException)
 #endif
 
 /* Machine check */
-BEGIN_FTR_SECTION
-	DSSALL
-	sync
-END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
 	STD_EXCEPTION(0x200, MachineCheck, MachineCheckException)
 
 /* Data access exception. */
@@ -1354,26 +1326,15 @@
  */
 _GLOBAL(__setup_cpu_power3)
 	blr
-_GLOBAL(__setup_cpu_power4)
-	blr
-_GLOBAL(__setup_cpu_ppc970)
-	blr
 _GLOBAL(__setup_cpu_generic)
 	blr
 
-#ifndef CONFIG_6xx
+#if !defined(CONFIG_6xx) && !defined(CONFIG_POWER4)
 _GLOBAL(__save_cpu_setup)
 	blr
 _GLOBAL(__restore_cpu_setup)
-#ifdef CONFIG_POWER4
-	/* turn off real-mode cache inhibit on the PPC970 */
-	mfspr	r0,SPRN_PVR
-	srwi	r0,r0,16
-	cmpwi	r0,0x39
-	beq	ppc970_setup_hid
 	blr
-#endif
-#endif /* CONFIG_6xx */
+#endif /* !defined(CONFIG_6xx) && !defined(CONFIG_POWER4) */
 
 /*
  * Load stuff into the MMU.  Intended to be called with
@@ -1694,6 +1655,34 @@
 #endif /* !defined(CONFIG_APUS) && defined(CONFIG_BOOTX_TEXT) */
 
 #else /* CONFIG_POWER4 */
+/*
+ * Load up the SDR1 and segment register values now
+ * since we don't have the BATs.
+ * Also make sure we are running in 32-bit mode.
+ */
+
+initial_mm_power4:
+	addis	r14,r3,_SDR1@ha		/* get the value from _SDR1 */
+	lwz	r14,_SDR1@l(r14)	/* assume hash table below 4GB */
+	mtspr	SDR1,r14
+	slbia
+	lis	r4,0x2000		/* set pseudo-segment reg 12 */
+	ori	r5,r4,0x0ccc
+	mtsr	12,r5
+	ori	r5,r4,0x0888		/* set pseudo-segment reg 8 */
+	mtsr	8,r5			/* (for access to serial port) */
+	ori	r5,r4,0x0999		/* set pseudo-segment reg 8 */
+	mtsr	9,r5			/* (for access to screen) */
+	mfmsr	r0
+	clrldi	r0,r0,1
+	sync
+	mtmsr	r0
+	isync
+	blr
+
+/*
+ * On 970 (G5), we pre-set a few bits in HID0 & HID1
+ */
 ppc970_setup_hid:
 	li	r0,0
 	sync
diff -urN kernel-source-2.4.27/arch/ppc/kernel/irq.c kernel-source-2.4.27-benh/arch/ppc/kernel/irq.c
--- kernel-source-2.4.27/arch/ppc/kernel/irq.c	2003-11-28 19:26:19.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/irq.c	2004-09-01 20:56:22.447706488 +0200
@@ -75,6 +75,10 @@
 unsigned long ppc_lost_interrupts[NR_MASK_WORDS];
 atomic_t ppc_n_lost_interrupts;
 
+#ifdef CONFIG_DEBUG_SPINLOCK
+int debug_long_irqlock;
+#endif /* CONFIG_DEBUG_SPINLOCK */
+
 /* nasty hack for shared irq's since we need to do kmalloc calls but
  * can't very early in the boot when we need to do a request irq.
  * this needs to be removed.
@@ -591,6 +595,24 @@
 	unsigned long *stack;
 	int cpu = smp_processor_id();
 
+#ifdef CONFIG_XMON
+	xmon_printf("\n%s, CPU %d:\n", str, cpu);
+	xmon_printf("irq:  %d [%d %d]\n",
+	       atomic_read(&global_irq_count),
+	       local_irq_count(0),
+	       local_irq_count(1));
+	xmon_printf("bh:   %d [%d %d]\n",
+	       atomic_read(&global_bh_count),
+	       local_bh_count(0),
+	       local_bh_count(1));
+	stack = (unsigned long *) &str;
+	for (i = 40; i ; i--) {
+		unsigned long x = *++stack;
+		if (x > (unsigned long) &init_task_union && x < (unsigned long) &vsprintf) {
+			xmon_printf("<[%08lx]> ", x);
+		}
+	}
+#endif /* CONFIG_XMON */
 	printk("\n%s, CPU %d:\n", str, cpu);
 	printk("irq:  %d [%d %d]\n",
 	       atomic_read(&global_irq_count),
@@ -675,6 +697,7 @@
  */
 void synchronize_bh(void)
 {
+	smp_mb();
 	if (atomic_read(&global_bh_count) && !in_interrupt())
 		wait_on_bh();
 }
@@ -688,6 +711,7 @@
  */
 void synchronize_irq(void)
 {
+	smp_mb();
 	if (atomic_read(&global_irq_count)) {
 		/* Stupid approach */
 		cli();
@@ -707,6 +731,9 @@
 		do {
 			do {
 				if (loops-- == 0) {
+#ifdef CONFIG_XMON
+					xmon_printf("get_irqlock(%d) waiting, global_irq_holder=%d\n", cpu, global_irq_holder);
+#endif
 					printk("get_irqlock(%d) waiting, global_irq_holder=%d\n", cpu, global_irq_holder);
 #ifdef CONFIG_XMON
 					xmon(0);
diff -urN kernel-source-2.4.27/arch/ppc/kernel/m8xx_setup.c kernel-source-2.4.27-benh/arch/ppc/kernel/m8xx_setup.c
--- kernel-source-2.4.27/arch/ppc/kernel/m8xx_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/m8xx_setup.c	2004-09-01 20:56:22.528694176 +0200
@@ -43,6 +43,7 @@
 #include <asm/machdep.h>
 #include <asm/bootinfo.h>
 #include <asm/time.h>
+#include <asm/i8259.h>
 
 #include "ppc8xx_pic.h"
 
diff -urN kernel-source-2.4.27/arch/ppc/kernel/Makefile kernel-source-2.4.27-benh/arch/ppc/kernel/Makefile
--- kernel-source-2.4.27/arch/ppc/kernel/Makefile	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/Makefile	2004-09-01 20:56:22.603682776 +0200
@@ -43,12 +43,13 @@
 obj-y				+= idle_gen.o
 endif
 obj-$(CONFIG_6xx)		+= l2cr.o cpu_setup_6xx.o
+obj-$(CONFIG_POWER4)		+= cpu_setup_power4.o
 obj-$(CONFIG_MODULES)		+= ppc_ksyms.o
 obj-$(CONFIG_PCI)		+= pci.o
 obj-$(CONFIG_PCI)		+= pci-dma.o
 obj-$(CONFIG_KGDB)		+= ppc-stub.o
 obj-$(CONFIG_PPCBUG_NVRAM)	+= prep_nvram.o
-obj-$(CONFIG_SMP)		+= smp.o
+obj-$(CONFIG_SMP)		+= smp.o smp-tbsync.o
 obj-$(CONFIG_TAU)		+= temp.o
 ifeq ($(CONFIG_SERIAL)$(CONFIG_GEN550),yy)
 obj-$(CONFIG_KGDB)		+= gen550_kgdb.o gen550_dbg.o
@@ -76,7 +77,7 @@
 endif
 endif
 obj-$(CONFIG_MBX)		+= i8259.o
-obj-$(CONFIG_ALL_PPC)		+= prom_init.o prom.o open_pic.o \
+obj-$(CONFIG_ALL_PPC)		+= prom_init.o prom.o open_pic.o open_pic2.o \
 					indirect_pci.o i8259.o
 obj-$(CONFIG_GEMINI)		+= open_pic.o
 obj-$(CONFIG_LOPEC)		+= mpc10x_common.o indirect_pci.o pci_auto.o \
diff -urN kernel-source-2.4.27/arch/ppc/kernel/misc.S kernel-source-2.4.27-benh/arch/ppc/kernel/misc.S
--- kernel-source-2.4.27/arch/ppc/kernel/misc.S	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/misc.S	2004-09-01 20:56:22.605682472 +0200
@@ -200,6 +200,59 @@
 	mr	r4,r24
 	bctr
 
+#ifdef CONFIG_CPU_FREQ_PMAC
+
+/* This gets called by via-pmu.c to switch the PLL selection
+ * on 750fx CPU.
+ */
+_GLOBAL(low_choose_750fx_pll)
+	/* Clear MSR:EE */
+	mfmsr	r7
+	rlwinm	r0,r7,0,17,15
+	mtmsr	r0
+
+	/* If switching to PLL1, disable HID0:BTIC */
+	cmpli	cr0,r3,0
+	beq	1f
+	mfspr	r5,HID0
+	rlwinm	r5,r5,0,27,25
+	sync
+	mtspr	HID0,r5
+	isync
+	sync
+	
+1:
+	/* Calc new HID1 value */
+	mfspr	r4,SPRN_HID1	/* Build a HID1:PS bit from parameter */
+	rlwinm	r5,r3,16,15,15	/* Clear out HID1:PS from value read */
+	rlwinm	r4,r4,0,16,14	/* Could have I used rlwimi here ? */
+	or	r4,r4,r5
+	mtspr	SPRN_HID1,r4
+
+	/* Store new HID1 image */
+	lwz	r6,PROCESSOR(r2)
+	slwi	r6,r6,2
+	addis	r6,r6,nap_save_hid1@ha
+	stw	r4,nap_save_hid1@l(r6)
+
+	/* If switching to PLL0, enable HID0:BTIC */
+	cmpli	cr0,r3,0
+	bne	1f
+	mfspr	r5,HID0
+	ori	r5,r5,HID0_BTIC
+	sync
+	mtspr	HID0,r5
+	isync
+	sync
+	
+1:	
+	/* Return */		
+	mtmsr	r7
+	blr
+
+#endif /* CONFIG_CPU_FREQ_PMAC */
+
+
 /* void __save_flags_ptr(unsigned long *flags) */
 _GLOBAL(__save_flags_ptr)
 	mfmsr	r4
diff -urN kernel-source-2.4.27/arch/ppc/kernel/open_pic2.c kernel-source-2.4.27-benh/arch/ppc/kernel/open_pic2.c
--- kernel-source-2.4.27/arch/ppc/kernel/open_pic2.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/open_pic2.c	2004-09-01 20:56:22.758659216 +0200
@@ -0,0 +1,580 @@
+/*
+ *  arch/ppc/kernel/open_pic.c -- OpenPIC Interrupt Handling
+ *
+ *  Copyright (C) 1997 Geert Uytterhoeven
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive
+ *  for more details.
+ *
+ *  This is a duplicate of open_pic.c that deals with U3s MPIC on
+ *  G5 PowerMacs. It's the same file except it's using big endian
+ *  register accesses
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/ptrace.h>
+#include <asm/signal.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/prom.h>
+#include <asm/sections.h>
+#include <asm/open_pic.h>
+#include <asm/i8259.h>
+
+#include "open_pic_defs.h"
+
+void *OpenPIC2_Addr;
+static volatile struct OpenPIC *OpenPIC2 = NULL;
+/*
+ * We define OpenPIC_InitSenses table thusly:
+ * bit 0x1: sense, 0 for edge and 1 for level.
+ * bit 0x2: polarity, 0 for negative, 1 for positive.
+ */
+extern  u_int OpenPIC_NumInitSenses;
+extern u_char *OpenPIC_InitSenses;
+extern int use_of_interrupt_tree;
+
+static u_int NumProcessors;
+static u_int NumSources;
+static int open_pic2_irq_offset;
+static volatile OpenPIC_Source *ISR[NR_IRQS];
+
+/* Global Operations */
+static void openpic2_disable_8259_pass_through(void);
+static void openpic2_set_priority(u_int pri);
+static void openpic2_set_spurious(u_int vector);
+
+/* Interrupt Sources */
+static void openpic2_enable_irq(u_int irq);
+static void openpic2_disable_irq(u_int irq);
+static void openpic2_initirq(u_int irq, u_int pri, u_int vector, int polarity,
+			    int is_level);
+static void openpic2_mapirq(u_int irq, u_int cpumask, u_int keepmask);
+
+/*
+ * These functions are not used but the code is kept here
+ * for completeness and future reference.
+ */
+static void openpic2_reset(void);
+#ifdef notused
+static void openpic2_enable_8259_pass_through(void);
+static u_int openpic2_get_priority(void);
+static u_int openpic2_get_spurious(void);
+static void openpic2_set_sense(u_int irq, int sense);
+#endif /* notused */
+
+/*
+ * Description of the openpic for the higher-level irq code
+ */
+static void openpic2_end_irq(unsigned int irq_nr);
+static void openpic2_ack_irq(unsigned int irq_nr);
+
+struct hw_interrupt_type open_pic2 = {
+	" OpenPIC2 ",
+	NULL,
+	NULL,
+	openpic2_enable_irq,
+	openpic2_disable_irq,
+	openpic2_ack_irq,
+	openpic2_end_irq,
+};
+
+
+/*  Accesses to the current processor's openpic registers
+ *  On cascaded controller, this is only CPU 0
+ */
+#define THIS_CPU		Processor[0]
+#define DECL_THIS_CPU
+#define CHECK_THIS_CPU
+
+#if 1
+#define check_arg_ipi(ipi) \
+    if (ipi < 0 || ipi >= OPENPIC_NUM_IPI) \
+	printk("open_pic.c:%d: illegal ipi %d\n", __LINE__, ipi);
+#define check_arg_timer(timer) \
+    if (timer < 0 || timer >= OPENPIC_NUM_TIMERS) \
+	printk("open_pic.c:%d: illegal timer %d\n", __LINE__, timer);
+#define check_arg_vec(vec) \
+    if (vec < 0 || vec >= OPENPIC_NUM_VECTORS) \
+	printk("open_pic.c:%d: illegal vector %d\n", __LINE__, vec);
+#define check_arg_pri(pri) \
+    if (pri < 0 || pri >= OPENPIC_NUM_PRI) \
+	printk("open_pic.c:%d: illegal priority %d\n", __LINE__, pri);
+/*
+ * Print out a backtrace if it's out of range, since if it's larger than NR_IRQ's
+ * data has probably been corrupted and we're going to panic or deadlock later
+ * anyway --Troy
+ */
+extern unsigned long* _get_SP(void);
+#define check_arg_irq(irq) \
+    if (irq < open_pic2_irq_offset || irq >= NumSources+open_pic2_irq_offset \
+	|| ISR[irq - open_pic2_irq_offset] == 0) { \
+      printk("open_pic.c:%d: illegal irq %d\n", __LINE__, irq); \
+      print_backtrace(_get_SP()); }
+#define check_arg_cpu(cpu) \
+    if (cpu < 0 || cpu >= NumProcessors){ \
+	printk("open_pic2.c:%d: illegal cpu %d\n", __LINE__, cpu); \
+	print_backtrace(_get_SP()); }
+#else
+#define check_arg_ipi(ipi)	do {} while (0)
+#define check_arg_timer(timer)	do {} while (0)
+#define check_arg_vec(vec)	do {} while (0)
+#define check_arg_pri(pri)	do {} while (0)
+#define check_arg_irq(irq)	do {} while (0)
+#define check_arg_cpu(cpu)	do {} while (0)
+#endif
+
+static u_int openpic2_read(volatile u_int *addr)
+{
+	u_int val;
+
+	val = in_be32(addr);
+	return val;
+}
+
+static inline void openpic2_write(volatile u_int *addr, u_int val)
+{
+	out_be32(addr, val);
+}
+
+static inline u_int openpic2_readfield(volatile u_int *addr, u_int mask)
+{
+	u_int val = openpic2_read(addr);
+	return val & mask;
+}
+
+inline void openpic2_writefield(volatile u_int *addr, u_int mask,
+			       u_int field)
+{
+	u_int val = openpic2_read(addr);
+	openpic2_write(addr, (val & ~mask) | (field & mask));
+}
+
+static inline void openpic2_clearfield(volatile u_int *addr, u_int mask)
+{
+	openpic2_writefield(addr, mask, 0);
+}
+
+static inline void openpic2_setfield(volatile u_int *addr, u_int mask)
+{
+	openpic2_writefield(addr, mask, mask);
+}
+
+static void openpic2_safe_writefield(volatile u_int *addr, u_int mask,
+				    u_int field)
+{
+	openpic2_setfield(addr, OPENPIC_MASK);
+	while (openpic2_read(addr) & OPENPIC_ACTIVITY);
+	openpic2_writefield(addr, mask | OPENPIC_MASK, field | OPENPIC_MASK);
+}
+
+#if defined(CONFIG_PMAC_PBOOK)
+static void openpic2_reset(void)
+{
+	openpic2_setfield(&OpenPIC2->Global.Global_Configuration0,
+			 OPENPIC_CONFIG_RESET);
+	while (openpic2_readfield(&OpenPIC2->Global.Global_Configuration0,
+				 OPENPIC_CONFIG_RESET))
+		mb();
+}
+#endif
+
+void __init openpic2_set_sources(int first_irq, int num_irqs, void *first_ISR)
+{
+	volatile OpenPIC_Source *src = first_ISR;
+	int i, last_irq;
+
+	last_irq = first_irq + num_irqs;
+	if (last_irq > NumSources)
+		NumSources = last_irq;
+	if (src == 0)
+		src = &((struct OpenPIC *)OpenPIC2_Addr)->Source[first_irq];
+	for (i = first_irq; i < last_irq; ++i, ++src)
+		ISR[i] = src;
+}
+
+/*
+ * The `offset' parameter defines where the interrupts handled by the
+ * OpenPIC start in the space of interrupt numbers that the kernel knows
+ * about.  In other words, the OpenPIC's IRQ0 is numbered `offset' in the
+ * kernel's interrupt numbering scheme.
+ * We assume there is only one OpenPIC.
+ */
+void __init openpic2_init(int offset)
+{
+	u_int t, i;
+	u_int timerfreq;
+	const char *version;
+
+	if (!OpenPIC2_Addr) {
+		printk("No OpenPIC2 found !\n");
+		return;
+	}
+	OpenPIC2 = (volatile struct OpenPIC *)OpenPIC2_Addr;
+
+	if (ppc_md.progress) ppc_md.progress("openpic: enter", 0x122);
+
+	t = openpic2_read(&OpenPIC2->Global.Feature_Reporting0);
+	switch (t & OPENPIC_FEATURE_VERSION_MASK) {
+	case 1:
+		version = "1.0";
+		break;
+	case 2:
+		version = "1.2";
+		break;
+	case 3:
+		version = "1.3";
+		break;
+	default:
+		version = "?";
+		break;
+	}
+	NumProcessors = ((t & OPENPIC_FEATURE_LAST_PROCESSOR_MASK) >>
+			 OPENPIC_FEATURE_LAST_PROCESSOR_SHIFT) + 1;
+	if (NumSources == 0)
+		openpic2_set_sources(0,
+				    ((t & OPENPIC_FEATURE_LAST_SOURCE_MASK) >>
+				     OPENPIC_FEATURE_LAST_SOURCE_SHIFT) + 1,
+				    NULL);
+	printk("OpenPIC (2) Version %s (%d CPUs and %d IRQ sources) at %p\n",
+	       version, NumProcessors, NumSources, OpenPIC2);
+	timerfreq = openpic2_read(&OpenPIC2->Global.Timer_Frequency);
+	if (timerfreq)
+		printk("OpenPIC timer frequency is %d.%06d MHz\n",
+		       timerfreq / 1000000, timerfreq % 1000000);
+
+	open_pic2_irq_offset = offset;
+
+	/* Initialize external interrupts */
+	if (ppc_md.progress) ppc_md.progress("openpic2: external",0x3bc);
+
+	openpic2_set_priority(0xf);
+
+	/* Init all external sources, including possibly the cascade. */
+	for (i = 0; i < NumSources; i++) {
+		int sense;
+
+		if (ISR[i] == 0)
+			continue;
+
+		/* the bootloader may have left it enabled (bad !) */
+		openpic2_disable_irq(i+offset);
+
+		sense = (i < OpenPIC_NumInitSenses)? OpenPIC_InitSenses[i]: \
+				(IRQ_SENSE_LEVEL | IRQ_POLARITY_NEGATIVE);
+
+		if (sense & IRQ_SENSE_MASK)
+			irq_desc[i+offset].status = IRQ_LEVEL;
+
+		/* Enabled, Priority 8 */
+		openpic2_initirq(i, 8, i+offset, (sense & IRQ_POLARITY_MASK),
+				(sense & IRQ_SENSE_MASK));
+		/* Processor 0 */
+		openpic2_mapirq(i, 1<<0, 0);
+	}
+
+	/* Init descriptors */
+	for (i = offset; i < NumSources + offset; i++)
+		irq_desc[i].handler = &open_pic2;
+
+	/* Initialize the spurious interrupt */
+	if (ppc_md.progress) ppc_md.progress("openpic2: spurious",0x3bd);
+	openpic2_set_spurious(OPENPIC2_VEC_SPURIOUS+offset);
+
+	openpic2_disable_8259_pass_through();
+	openpic2_set_priority(0);
+
+	if (ppc_md.progress) ppc_md.progress("openpic2: exit",0x222);
+}
+
+#ifdef notused
+static void openpic2_enable_8259_pass_through(void)
+{
+	openpic2_clearfield(&OpenPIC2->Global.Global_Configuration0,
+			   OPENPIC_CONFIG_8259_PASSTHROUGH_DISABLE);
+}
+#endif /* notused */
+
+/* This can't be __init, it is used in openpic_sleep_restore_intrs */
+static void openpic2_disable_8259_pass_through(void)
+{
+	openpic2_setfield(&OpenPIC2->Global.Global_Configuration0,
+			 OPENPIC_CONFIG_8259_PASSTHROUGH_DISABLE);
+}
+
+/*
+ *  Find out the current interrupt
+ */
+u_int openpic2_irq(void)
+{
+	u_int vec;
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	vec = openpic2_readfield(&OpenPIC2->THIS_CPU.Interrupt_Acknowledge,
+				OPENPIC_VECTOR_MASK);
+	return vec;
+}
+
+void openpic2_eoi(void)
+{
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	openpic2_write(&OpenPIC2->THIS_CPU.EOI, 0);
+	/* Handle PCI write posting */
+	(void)openpic2_read(&OpenPIC2->THIS_CPU.EOI);
+}
+
+#ifdef notused
+static u_int openpic2_get_priority(void)
+{
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	return openpic2_readfield(&OpenPIC2->THIS_CPU.Current_Task_Priority,
+				 OPENPIC_CURRENT_TASK_PRIORITY_MASK);
+}
+#endif /* notused */
+
+static void __init openpic2_set_priority(u_int pri)
+{
+	DECL_THIS_CPU;
+
+	CHECK_THIS_CPU;
+	check_arg_pri(pri);
+	openpic2_writefield(&OpenPIC2->THIS_CPU.Current_Task_Priority,
+			   OPENPIC_CURRENT_TASK_PRIORITY_MASK, pri);
+}
+
+/*
+ *  Get/set the spurious vector
+ */
+#ifdef notused
+static u_int openpic2_get_spurious(void)
+{
+	return openpic2_readfield(&OpenPIC2->Global.Spurious_Vector,
+				 OPENPIC_VECTOR_MASK);
+}
+#endif /* notused */
+
+/* This can't be __init, it is used in openpic_sleep_restore_intrs */
+static void openpic2_set_spurious(u_int vec)
+{
+	check_arg_vec(vec);
+	openpic2_writefield(&OpenPIC2->Global.Spurious_Vector, OPENPIC_VECTOR_MASK,
+			   vec);
+}
+
+/*
+ * Initalize the interrupt source which will generate an NMI.
+ * This raises the interrupt's priority from 8 to 9.
+ *
+ * irq: The logical IRQ which generates an NMI.
+ */
+void __init
+openpic2_init_nmi_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	openpic2_safe_writefield(&ISR[irq - open_pic2_irq_offset]->Vector_Priority,
+				OPENPIC_PRIORITY_MASK,
+				9 << OPENPIC_PRIORITY_SHIFT);
+}
+
+/*
+ *
+ * All functions below take an offset'ed irq argument
+ *
+ */
+
+/*
+ *  Enable/disable an external interrupt source
+ *
+ *  Externally called, irq is an offseted system-wide interrupt number
+ */
+static void openpic2_enable_irq(u_int irq)
+{
+	volatile u_int *vpp;
+
+	check_arg_irq(irq);
+	vpp = &ISR[irq - open_pic2_irq_offset]->Vector_Priority;
+       	openpic2_clearfield(vpp, OPENPIC_MASK);
+	/* make sure mask gets to controller before we return to user */
+       	do {
+       		mb(); /* sync is probably useless here */
+       	} while (openpic2_readfield(vpp, OPENPIC_MASK));
+}
+
+static void openpic2_disable_irq(u_int irq)
+{
+	volatile u_int *vpp;
+	u32 vp;
+
+	check_arg_irq(irq);
+	vpp = &ISR[irq - open_pic2_irq_offset]->Vector_Priority;
+	openpic2_setfield(vpp, OPENPIC_MASK);
+	/* make sure mask gets to controller before we return to user */
+	do {
+		mb();  /* sync is probably useless here */
+		vp = openpic2_readfield(vpp, OPENPIC_MASK | OPENPIC_ACTIVITY);
+	} while((vp & OPENPIC_ACTIVITY) && !(vp & OPENPIC_MASK));
+}
+
+/*
+ *  Initialize an interrupt source (and disable it!)
+ *
+ *  irq: OpenPIC interrupt number
+ *  pri: interrupt source priority
+ *  vec: the vector it will produce
+ *  pol: polarity (1 for positive, 0 for negative)
+ *  sense: 1 for level, 0 for edge
+ */
+static void __init
+openpic2_initirq(u_int irq, u_int pri, u_int vec, int pol, int sense)
+{
+	openpic2_safe_writefield(&ISR[irq]->Vector_Priority,
+				OPENPIC_PRIORITY_MASK | OPENPIC_VECTOR_MASK |
+				OPENPIC_SENSE_MASK | OPENPIC_POLARITY_MASK,
+				(pri << OPENPIC_PRIORITY_SHIFT) | vec |
+				(pol ? OPENPIC_POLARITY_POSITIVE :
+			    		OPENPIC_POLARITY_NEGATIVE) |
+				(sense ? OPENPIC_SENSE_LEVEL : OPENPIC_SENSE_EDGE));
+}
+
+/*
+ *  Map an interrupt source to one or more CPUs
+ */
+static void openpic2_mapirq(u_int irq, u_int physmask, u_int keepmask)
+{
+	if (ISR[irq] == 0)
+		return;
+	if (keepmask != 0)
+		physmask |= openpic2_read(&ISR[irq]->Destination) & keepmask;
+	openpic2_write(&ISR[irq]->Destination, physmask);
+}
+
+#ifdef notused
+/*
+ *  Set the sense for an interrupt source (and disable it!)
+ *
+ *  sense: 1 for level, 0 for edge
+ */
+static void openpic2_set_sense(u_int irq, int sense)
+{
+	if (ISR[irq] != 0)
+		openpic2_safe_writefield(&ISR[irq]->Vector_Priority,
+					OPENPIC_SENSE_LEVEL,
+					(sense ? OPENPIC_SENSE_LEVEL : 0));
+}
+#endif /* notused */
+
+/* No spinlocks, should not be necessary with the OpenPIC
+ * (1 register = 1 interrupt and we have the desc lock).
+ */
+static void openpic2_ack_irq(unsigned int irq_nr)
+{
+	openpic2_disable_irq(irq_nr);
+	openpic2_eoi();
+}
+
+static void openpic2_end_irq(unsigned int irq_nr)
+{
+	if (!(irq_desc[irq_nr].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		openpic2_enable_irq(irq_nr);
+}
+
+int
+openpic2_get_irq(struct pt_regs *regs)
+{
+	int irq = openpic2_irq();
+
+	if (irq == OPENPIC2_VEC_SPURIOUS + open_pic2_irq_offset)
+		irq = -1;
+	return irq;
+}
+
+#ifdef CONFIG_PMAC_PBOOK
+static u32 save_ipi_vp[OPENPIC_NUM_IPI];
+static u32 save_irq_src_vp[OPENPIC_MAX_SOURCES];
+static u32 save_irq_src_dest[OPENPIC_MAX_SOURCES];
+static u32 save_cpu_task_pri[OPENPIC_MAX_PROCESSORS];
+static spinlock_t openpic2_setup_lock = SPIN_LOCK_UNLOCKED;
+
+static void openpic2_cached_enable_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	save_irq_src_vp[irq - open_pic2_irq_offset] &= ~OPENPIC_MASK; 
+}
+
+static void openpic2_cached_disable_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	save_irq_src_vp[irq - open_pic2_irq_offset] |= OPENPIC_MASK; 
+}
+
+void __pmac
+openpic2_sleep_save_intrs(void)
+{
+	int	i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&openpic2_setup_lock, flags);
+
+	open_pic2.enable = openpic2_cached_enable_irq;
+	open_pic2.disable = openpic2_cached_disable_irq;
+
+	for (i=0; i<NumProcessors; i++) {
+		save_cpu_task_pri[i] = openpic2_read(&OpenPIC2->Processor[i].Current_Task_Priority);
+		openpic2_writefield(&OpenPIC2->Processor[i].Current_Task_Priority,
+				   OPENPIC_CURRENT_TASK_PRIORITY_MASK, 0xf);
+	}
+
+	for (i=0; i<OPENPIC_NUM_IPI; i++)
+		save_ipi_vp[i] = openpic2_read(&OpenPIC2->Global.IPI_Vector_Priority(i));
+	for (i=0; i<NumSources; i++) {
+		if (ISR[i] == 0)
+			continue;
+		save_irq_src_vp[i] = openpic2_read(&ISR[i]->Vector_Priority)
+			& ~OPENPIC_ACTIVITY;
+		save_irq_src_dest[i] = openpic2_read(&ISR[i]->Destination);
+	}
+	spin_unlock_irqrestore(&openpic2_setup_lock, flags);
+}
+
+void __pmac
+openpic2_sleep_restore_intrs(void)
+{
+	int		i;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&openpic2_setup_lock, flags);
+
+	openpic2_reset();
+
+	for (i=0; i<OPENPIC_NUM_IPI; i++)
+		openpic2_write(&OpenPIC2->Global.IPI_Vector_Priority(i),
+			      save_ipi_vp[i]);
+	for (i=0; i<NumSources; i++) {
+		if (ISR[i] == 0)
+			continue;
+		openpic2_write(&ISR[i]->Vector_Priority, save_irq_src_vp[i]);
+		openpic2_write(&ISR[i]->Destination, save_irq_src_dest[i]);
+	}
+	openpic2_set_spurious(OPENPIC2_VEC_SPURIOUS+open_pic2_irq_offset);
+	openpic2_disable_8259_pass_through();
+	for (i=0; i<NumProcessors; i++)
+		openpic2_write(&OpenPIC2->Processor[i].Current_Task_Priority,
+			      save_cpu_task_pri[i]);
+
+	open_pic2.enable = openpic2_enable_irq;
+	open_pic2.disable = openpic2_disable_irq;
+
+	spin_unlock_irqrestore(&openpic2_setup_lock, flags);
+}
+#endif /* CONFIG_PMAC_PBOOK */
diff -urN kernel-source-2.4.27/arch/ppc/kernel/open_pic.c kernel-source-2.4.27-benh/arch/ppc/kernel/open_pic.c
--- kernel-source-2.4.27/arch/ppc/kernel/open_pic.c	2004-02-18 14:36:30.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/open_pic.c	2004-09-01 20:56:22.760658912 +0200
@@ -877,6 +877,17 @@
 static u32 save_irq_src_dest[OPENPIC_MAX_SOURCES];
 static u32 save_cpu_task_pri[OPENPIC_MAX_PROCESSORS];
 
+static void openpic_cached_enable_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	save_irq_src_vp[irq - open_pic_irq_offset] &= ~OPENPIC_MASK; 
+}
+
+static void openpic_cached_disable_irq(u_int irq)
+{
+	check_arg_irq(irq);
+	save_irq_src_vp[irq - open_pic_irq_offset] |= OPENPIC_MASK; 
+}
 void __pmac
 openpic_sleep_save_intrs(void)
 {
@@ -885,6 +896,9 @@
 
 	spin_lock_irqsave(&openpic_setup_lock, flags);
 
+	open_pic.enable = openpic_cached_enable_irq;
+	open_pic.disable = openpic_cached_disable_irq;
+
 	for (i=0; i<NumProcessors; i++) {
 		save_cpu_task_pri[i] = openpic_read(&OpenPIC->Processor[i].Current_Task_Priority);
 		openpic_writefield(&OpenPIC->Processor[i].Current_Task_Priority,
@@ -928,6 +942,9 @@
 		openpic_write(&OpenPIC->Processor[i].Current_Task_Priority,
 			      save_cpu_task_pri[i]);
 
+	open_pic.enable = openpic_enable_irq;
+	open_pic.disable = openpic_disable_irq;
+
 	spin_unlock_irqrestore(&openpic_setup_lock, flags);
 }
 #endif /* CONFIG_PMAC_PBOOK */
diff -urN kernel-source-2.4.27/arch/ppc/kernel/pci.c kernel-source-2.4.27-benh/arch/ppc/kernel/pci.c
--- kernel-source-2.4.27/arch/ppc/kernel/pci.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/pci.c	2004-09-01 20:56:22.914635504 +0200
@@ -22,7 +22,7 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 
-#undef DEBUG
+#define DEBUG
 
 #ifdef DEBUG
 #define DBG(x...) printk(x)
@@ -47,6 +47,7 @@
 static void fixup_cpc710_pci64(struct pci_dev* dev);
 #ifdef CONFIG_ALL_PPC
 static void pcibios_fixup_cardbus(struct pci_dev* dev);
+static void pcibios_fixup_pciata(struct pci_dev* dev);
 static u8* pci_to_OF_bus_map;
 #endif
 
@@ -68,6 +69,7 @@
 #ifdef CONFIG_ALL_PPC
 	/* We should add per-machine fixup support in xxx_setup.c or xxx_pci.c */
 	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_TI,	PCI_ANY_ID,			pcibios_fixup_cardbus },
+	{ PCI_FIXUP_FINAL,	PCI_ANY_ID,		PCI_ANY_ID,			pcibios_fixup_pciata },
 #endif /* CONFIG_ALL_PPC */
  	{ 0 }
 };
@@ -116,6 +118,10 @@
 	struct pci_controller* hose = dev->sysdata;
 	unsigned long io_offset;
 
+	if (dev->vendor == PCI_VENDOR_ID_APPLE && dev->device == PCI_DEVICE_ID_APPLE_KEYLARGO) {
+		printk("trying to reloc keylargo !! skipping\n");
+		return;
+	}
 	new = res->start;
 	res->flags &= ~IORESOURCE_UNSET;
 	if (hose && res->flags & IORESOURCE_IO) {
@@ -217,7 +223,8 @@
 	}
 	if (dev->device == PCI_DEVICE_ID_TI_1210 ||
 	    dev->device == PCI_DEVICE_ID_TI_1211 ||
-	    dev->device == PCI_DEVICE_ID_TI_1410) {
+	    dev->device == PCI_DEVICE_ID_TI_1410 ||
+	    dev->device == PCI_DEVICE_ID_TI_1510) {
 		u8 val;
 		/* 0x8c == TI122X_IRQMUX, 2 says to route the INTA
 		   signal out the MFUNC0 pin */
@@ -228,6 +235,49 @@
 			pci_write_config_byte(dev, 0x92, val & ~0x06);
 	}
 }
+
+static void
+pcibios_fixup_pciata(struct pci_dev* dev)
+{
+       u8 progif = 0;
+
+       /*
+        * On PowerMacs, we try to switch any PCI ATA controller to
+	* fully native mode
+        */
+	if (_machine != _MACH_Pmac)
+		return;
+	/* Some controllers don't have the class IDE */
+	if (dev->vendor == PCI_VENDOR_ID_PROMISE)
+		switch(dev->device) {
+		case PCI_DEVICE_ID_PROMISE_20246:
+		case PCI_DEVICE_ID_PROMISE_20262:
+		case PCI_DEVICE_ID_PROMISE_20263:
+		case PCI_DEVICE_ID_PROMISE_20265:
+		case PCI_DEVICE_ID_PROMISE_20267:
+		case PCI_DEVICE_ID_PROMISE_20268:
+		case PCI_DEVICE_ID_PROMISE_20269:
+		case PCI_DEVICE_ID_PROMISE_20270:
+		case PCI_DEVICE_ID_PROMISE_20271:
+		case PCI_DEVICE_ID_PROMISE_20275:
+		case PCI_DEVICE_ID_PROMISE_20276:
+		case PCI_DEVICE_ID_PROMISE_20277:
+			goto good;
+		}
+	/* Others, check PCI class */
+	if ((dev->class >> 8) != PCI_CLASS_STORAGE_IDE)
+		return;
+ good:
+	pci_read_config_byte(dev, PCI_CLASS_PROG, &progif);
+	if ((progif & 5) != 5) {
+		printk(KERN_INFO "Forcing PCI IDE into native mode: %s\n", pci_name(dev));
+		(void) pci_write_config_byte(dev, PCI_CLASS_PROG, progif|5);
+		if (pci_read_config_byte(dev, PCI_CLASS_PROG, &progif) ||
+		    (progif & 5) != 5)
+			printk(KERN_ERR "Rewrite of PROGIF failed !\n");
+	}
+}
+
 #endif /* CONFIG_ALL_PPC */
 
 /*
@@ -563,8 +613,9 @@
 {
 	struct resource *pr, *r = &dev->resource[idx];
 
-	DBG("PCI:%s: Resource %d: %08lx-%08lx (f=%lx)\n",
-	    dev->slot_name, idx, r->start, r->end, r->flags);
+	DBG("PCI:%s: Resource %d: %08lx-%08lx (f=%lx), vd: %04x, dev: %04x\n",
+	    dev->slot_name, idx, r->start, r->end, r->flags,
+	    dev->vendor, dev->device);
 	pr = pci_find_parent_resource(dev, r);
 	if (!pr || request_resource(pr, r) < 0) {
 		printk(KERN_ERR "PCI: Cannot allocate resource region %d"
@@ -956,7 +1007,7 @@
 	 */
 	ranges = (unsigned int *) get_property(dev, "ranges", &rlen);
 	prev = NULL;
-	while ((rlen -= np * sizeof(unsigned int)) >= 0) {
+	while (ranges && (rlen -= np * sizeof(unsigned int)) >= 0) {
 		if (prev) {
 			if (prev[0] == ranges[0] && prev[1] == ranges[1] &&
 				(prev[2] + prev[na+4]) == ranges[2] &&
@@ -980,9 +1031,8 @@
 	 *   cells 4+5 or 5+6:	the size of the range
 	 */
 	rlen = 0;
-	hose->io_base_phys = 0;
 	ranges = (unsigned int *) get_property(dev, "ranges", &rlen);
-	while ((rlen -= np * sizeof(unsigned int)) >= 0) {
+	while (ranges && (rlen -= np * sizeof(unsigned int)) >= 0) {
 		res = NULL;
 		size = ranges[na+4];
 		switch (ranges[0] >> 24) {
@@ -1029,6 +1079,10 @@
 		}
 		ranges += np;
 	}
+	DBG("hose %s, pci_mem_offset: %08lx, start0: %08lx\n",
+		dev->name, hose->pci_mem_offset, hose->mem_resources[0].start);
+	DBG("  io_base_virt: %p, io_base_phys: %08lx, isa_mem_base: %08lx\n",
+		hose->io_base_virt, hose->io_base_phys, isa_mem_base);
 }
 
 /* We create the "pci-OF-bus-map" property now so it appears in the
@@ -1341,6 +1395,9 @@
 	return PCI_SLOT(dev->devfn);
 }
 
+/* Where does that come from ? Doesn't seem to be correct for us, but we
+ * don't use it anyway so ... -BenH.
+ */
 void __init
 pcibios_fixup_pbus_ranges(struct pci_bus * bus, struct pbus_set_ranges_data * ranges)
 {
@@ -1704,9 +1761,21 @@
 long
 sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)
 {
-	struct pci_controller* hose = pci_bus_to_hose(bus);
+	struct pci_controller* hose;
 	long result = -EOPNOTSUPP;
 
+	/* Argh ! Please forgive me for that hack, but that's the
+	 * simplest way to get existing XFree to not lockup on some
+	 * G5 machines... So when something asks for bus 0 io base
+	 * (bus 0 is HT root), we return the AGP one instead.
+	 */
+#ifdef CONFIG_PPC_PMAC
+	if (_machine == _MACH_Pmac && machine_is_compatible("MacRISC4"))
+		if (bus == 0)
+			bus = 0xf0;
+#endif /* CONFIG_PPC_PMAC */
+
+	hose = pci_bus_to_hose(bus);
 	if (!hose)
 		return -ENODEV;
 
diff -urN kernel-source-2.4.27/arch/ppc/kernel/ppc_ksyms.c kernel-source-2.4.27-benh/arch/ppc/kernel/ppc_ksyms.c
--- kernel-source-2.4.27/arch/ppc/kernel/ppc_ksyms.c	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/ppc_ksyms.c	2004-09-01 20:56:22.916635200 +0200
@@ -14,6 +14,7 @@
 #include <linux/irq.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
+#include <linux/vmalloc.h>
 #include <linux/ide.h>
 
 #include <asm/page.h>
@@ -67,9 +68,10 @@
 extern int pmac_newworld;
 extern int sys_sigreturn(struct pt_regs *regs);
 
-long long __ashrdi3(long long, int);
-long long __ashldi3(long long, int);
-long long __lshrdi3(long long, int);
+extern long long __ashrdi3(long long, int);
+extern long long __ashldi3(long long, int);
+extern long long __lshrdi3(long long, int);
+
 int abs(int);
 
 extern unsigned char __res[];
@@ -128,7 +130,6 @@
 EXPORT_SYMBOL(strcmp);
 EXPORT_SYMBOL(strncmp);
 EXPORT_SYMBOL(strcasecmp);
-EXPORT_SYMBOL(__div64_32);
 
 /* EXPORT_SYMBOL(csum_partial); already in net/netsyms.c */
 EXPORT_SYMBOL(csum_partial_copy_generic);
@@ -212,6 +213,7 @@
 EXPORT_SYMBOL(flush_icache_user_range);
 EXPORT_SYMBOL(flush_icache_page);
 EXPORT_SYMBOL(flush_dcache_page);
+EXPORT_SYMBOL(local_flush_tlb_page);
 EXPORT_SYMBOL(xchg_u32);
 #ifdef CONFIG_ALTIVEC
 EXPORT_SYMBOL(last_task_used_altivec);
@@ -225,7 +227,7 @@
 EXPORT_SYMBOL(__global_sti);
 EXPORT_SYMBOL(__global_save_flags);
 EXPORT_SYMBOL(__global_restore_flags);
-#if SPINLOCK_DEBUG
+#ifdef CONFIG_DEBUG_SPINLOCK
 EXPORT_SYMBOL(_spin_lock);
 EXPORT_SYMBOL(_spin_unlock);
 EXPORT_SYMBOL(spin_trylock);
@@ -276,10 +278,10 @@
 EXPORT_SYMBOL(pci_device_to_OF_node);
 EXPORT_SYMBOL(pci_device_from_OF_node);
 EXPORT_SYMBOL(pmac_newworld);
+#ifdef CONFIG_NVRAM
 EXPORT_SYMBOL(nvram_read_byte);
 EXPORT_SYMBOL(nvram_write_byte);
-EXPORT_SYMBOL(pmac_xpram_read);
-EXPORT_SYMBOL(pmac_xpram_write);
+#endif
 #endif /* defined(CONFIG_ALL_PPC) */
 #if defined(CONFIG_BOOTX_TEXT)
 EXPORT_SYMBOL(btext_update_display);
@@ -301,6 +303,7 @@
 EXPORT_SYMBOL_NOVERS(memscan);
 EXPORT_SYMBOL_NOVERS(memcmp);
 EXPORT_SYMBOL_NOVERS(memchr);
+EXPORT_SYMBOL_NOVERS(__div64_32);
 
 EXPORT_SYMBOL(abs);
 
@@ -327,7 +330,7 @@
 EXPORT_SYMBOL(get_wchan);
 EXPORT_SYMBOL(console_drivers);
 #ifdef CONFIG_XMON
-extern void xmon_printf(char *fmt, ...);
+extern void xmon_printf(const char *fmt, ...);
 EXPORT_SYMBOL(xmon);
 EXPORT_SYMBOL(xmon_printf);
 #endif
@@ -389,6 +392,11 @@
 EXPORT_SYMBOL(ret_from_intercept);
 EXPORT_SYMBOL(cur_cpu_spec);
 #if defined(CONFIG_ALL_PPC)
+extern int map_page(unsigned long va, unsigned long pa, int flags);
+
+EXPORT_SYMBOL(map_page);
+EXPORT_SYMBOL(get_vm_area);
 extern unsigned long agp_special_page;
 EXPORT_SYMBOL_NOVERS(agp_special_page);
+EXPORT_SYMBOL(local_flush_tlb_all);
 #endif /* defined(CONFIG_ALL_PPC) */
diff -urN kernel-source-2.4.27/arch/ppc/kernel/process.c kernel-source-2.4.27-benh/arch/ppc/kernel/process.c
--- kernel-source-2.4.27/arch/ppc/kernel/process.c	2003-11-28 19:26:19.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/process.c	2004-09-01 20:56:22.993623496 +0200
@@ -507,14 +507,19 @@
 	if (sp == NULL)
 		asm("mr %0,1" : "=r" (sp));
 	printk("Call backtrace: ");
+	if (sp == NULL)
+		sp = (unsigned long *)_get_SP();
 	while (sp) {
+		if (__get_user(sp, (unsigned long **)sp))
+			break;
+		if (sp == NULL)
+			break;
 		if (__get_user( i, &sp[1] ))
 			break;
 		if (cnt++ % 7 == 0)
 			printk("\n");
 		printk("%08lX ", i);
-		if (cnt > 32) break;
-		if (__get_user(sp, (unsigned long **)sp))
+		if (cnt > 32)
 			break;
 	}
 	printk("\n");
diff -urN kernel-source-2.4.27/arch/ppc/kernel/prom.c kernel-source-2.4.27-benh/arch/ppc/kernel/prom.c
--- kernel-source-2.4.27/arch/ppc/kernel/prom.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/prom.c	2004-09-01 20:56:23.070611792 +0200
@@ -206,7 +206,7 @@
 		ifunc = interpret_macio_props;
 	else if (!strcmp(np->type, "isa"))
 		ifunc = interpret_isa_props;
-	else if (!strcmp(np->name, "uni-n"))
+	else if (!strcmp(np->name, "uni-n") || !strcmp(np->name, "u3"))
 		ifunc = interpret_root_props;
 	else if (!((ifunc == interpret_dbdma_props
 		    || ifunc == interpret_macio_props)
@@ -420,10 +420,21 @@
 		 * This doesn't cope with the general case of multiple
 		 * cascaded interrupt controllers, but then neither will
 		 * irq.c at the moment either.  -- paulus
+		 * The G5 triggers that code, I add a machine test. On
+		 * those machines, we want to offset interrupts from the
+		 * second openpic by 128 -- BenH
 		 */
-		if (num_interrupt_controllers > 1 && ic != NULL
+		if (_machine != _MACH_Pmac && num_interrupt_controllers > 1
+		    && ic != NULL
 		    && get_property(ic, "interrupt-parent", NULL) == NULL)
 			offset = 16;
+		else if (_machine == _MACH_Pmac && num_interrupt_controllers > 1
+			 && ic != NULL && ic->parent != NULL) {
+			char *name = get_property(ic->parent, "name", NULL);
+			if (name && !strcmp(name, "u3"))
+				offset = 128;
+		}
+
 		np->intrs[i].line = irq[0] + offset;
 		if (n > 1)
 			np->intrs[i].sense = irq[1];
diff -urN kernel-source-2.4.27/arch/ppc/kernel/prom_init.c kernel-source-2.4.27-benh/arch/ppc/kernel/prom_init.c
--- kernel-source-2.4.27/arch/ppc/kernel/prom_init.c	2003-11-28 19:26:19.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/prom_init.c	2004-09-01 20:56:23.148599936 +0200
@@ -253,6 +253,74 @@
 	}
 }
 
+#ifdef CONFIG_POWER4
+/*
+ * Set up a hash table with a set of entries in it to map the
+ * first 64MB of RAM.  This is used on 64-bit machines since
+ * some of them don't have BATs.
+ * We assume the PTE will fit in the primary PTEG.
+ */
+
+static inline void make_pte(unsigned long htab, unsigned int hsize,
+			    unsigned int va, unsigned int pa, int mode)
+{
+	unsigned int *pteg;
+	unsigned int hash, i, vsid;
+
+	vsid = ((va >> 28) * 0x111) << 12;
+	hash = ((va ^ vsid) >> 5) & 0x7fff80;
+	pteg = (unsigned int *)(htab + (hash & (hsize - 1)));
+	for (i = 0; i < 8; ++i, pteg += 4) {
+		if ((pteg[1] & 1) == 0) {
+			pteg[1] = vsid | ((va >> 16) & 0xf80) | 1;
+			pteg[3] = pa | mode;
+			break;
+		}
+	}
+}
+
+
+extern unsigned long _SDR1;
+extern PTE *Hash;
+extern unsigned long Hash_size;
+
+static void __init
+prom_alloc_htab(void)
+{
+	unsigned int hsize;
+	unsigned long htab;
+	unsigned int addr;
+
+	/*
+	 * Because of OF bugs we can't use the "claim" client
+	 * interface to allocate memory for the hash table.
+	 * This code is only used on 64-bit PPCs, and the only
+	 * 64-bit PPCs at the moment are RS/6000s, and their
+	 * OF is based at 0xc00000 (the 12M point), so we just
+	 * arbitrarily use the 0x800000 - 0xc00000 region for the
+	 * hash table.
+	 *  -- paulus.
+	 */
+	hsize = 4 << 20;	/* POWER4 has no BATs */
+	htab = (8 << 20);
+	call_prom("claim", 3, 1, htab, hsize, 0);
+	Hash = (void *)(htab + KERNELBASE);
+	Hash_size = hsize;
+	_SDR1 = htab + __ilog2(hsize) - 18;
+
+	/*
+	 * Put in PTEs for the first 64MB of RAM
+	 */
+	memset_io((void *)htab, 0, hsize);
+	for (addr = 0; addr < 0x4000000; addr += 0x1000)
+		make_pte(htab, hsize, addr + KERNELBASE, addr,
+			 _PAGE_ACCESSED | _PAGE_COHERENT | PP_RWXX);
+	make_pte(htab, hsize, 0x80013000, 0x80013000,
+		 _PAGE_ACCESSED | _PAGE_NO_CACHE | _PAGE_GUARDED | PP_RWXX);
+}
+#endif /* CONFIG_POWER4 */
+
+	 
 /*
  * If we have a display that we don't know how to drive,
  * we will want to try to execute OF's open method for it
@@ -428,9 +496,31 @@
 	if (strcmp(name, "valkyrie") == 0)
 		address += 0x1000;
 
-	btext_setup_display(width, height, depth, pitch, address);
+	prom_print("address:");
+	prom_print_hex(address);
+	prom_print("\n");
 
+#ifdef CONFIG_POWER4
+	extern boot_infos_t disp_bi;
+	{
+		unsigned long va, pa, i, offset;
+       		va = 0x90000000;
+		pa = address & 0xfffff000ul;
+		offset = address & 0x00000fff;
+
+		for (i=0; i<0x4000; i++) {  
+			make_pte((unsigned long)Hash - KERNELBASE, Hash_size, va, pa, 
+				 _PAGE_ACCESSED | _PAGE_NO_CACHE | _PAGE_GUARDED | PP_RWXX);
+			va += 0x1000;
+			pa += 0x1000;
+		}
+		btext_setup_display(width, height, depth, pitch, 0x90000000 | offset);
+		disp_bi.dispDeviceBase = (u8 *)address;
+	}
+#else /* CONFIG_POWER4 */
+	btext_setup_display(width, height, depth, pitch, address);
 	btext_prepare_BAT();
+#endif /* CONFIG_POWER4 */
 #endif /* CONFIG_BOOTX_TEXT */
 }
 
@@ -638,72 +728,6 @@
 	}
 }
 
-#ifdef CONFIG_POWER4
-/*
- * Set up a hash table with a set of entries in it to map the
- * first 64MB of RAM.  This is used on 64-bit machines since
- * some of them don't have BATs.
- * We assume the PTE will fit in the primary PTEG.
- */
-
-static inline void make_pte(unsigned long htab, unsigned int hsize,
-			    unsigned int va, unsigned int pa, int mode)
-{
-	unsigned int *pteg;
-	unsigned int hash, i, vsid;
-
-	vsid = ((va >> 28) * 0x111) << 12;
-	hash = ((va ^ vsid) >> 5) & 0x7fff80;
-	pteg = (unsigned int *)(htab + (hash & (hsize - 1)));
-	for (i = 0; i < 8; ++i, pteg += 4) {
-		if ((pteg[1] & 1) == 0) {
-			pteg[1] = vsid | ((va >> 16) & 0xf80) | 1;
-			pteg[3] = pa | mode;
-			break;
-		}
-	}
-}
-
-extern unsigned long _SDR1;
-extern PTE *Hash;
-extern unsigned long Hash_size;
-
-static void __init
-prom_alloc_htab(void)
-{
-	unsigned int hsize;
-	unsigned long htab;
-	unsigned int addr;
-
-	/*
-	 * Because of OF bugs we can't use the "claim" client
-	 * interface to allocate memory for the hash table.
-	 * This code is only used on 64-bit PPCs, and the only
-	 * 64-bit PPCs at the moment are RS/6000s, and their
-	 * OF is based at 0xc00000 (the 12M point), so we just
-	 * arbitrarily use the 0x800000 - 0xc00000 region for the
-	 * hash table.
-	 *  -- paulus.
-	 */
-	hsize = 4 << 20;	/* POWER4 has no BATs */
-	htab = (8 << 20);
-	call_prom("claim", 3, 1, htab, hsize, 0);
-	Hash = (void *)(htab + KERNELBASE);
-	Hash_size = hsize;
-	_SDR1 = htab + __ilog2(hsize) - 18;
-
-	/*
-	 * Put in PTEs for the first 64MB of RAM
-	 */
-	cacheable_memzero((void *)htab, hsize);
-	for (addr = 0; addr < 0x4000000; addr += 0x1000)
-		make_pte(htab, hsize, addr + KERNELBASE, addr,
-			 _PAGE_ACCESSED | _PAGE_COHERENT | PP_RWXX);
-	make_pte(htab, hsize, 0x80013000, 0x80013000,
-		 _PAGE_ACCESSED | _PAGE_NO_CACHE | _PAGE_GUARDED | PP_RWXX);
-}
-#endif /* CONFIG_POWER4 */
-
 static void __init
 prom_instantiate_rtas(void)
 {
diff -urN kernel-source-2.4.27/arch/ppc/kernel/semaphore.c kernel-source-2.4.27-benh/arch/ppc/kernel/semaphore.c
--- kernel-source-2.4.27/arch/ppc/kernel/semaphore.c	2003-06-13 16:51:31.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/semaphore.c	2004-09-01 20:56:23.149599784 +0200
@@ -73,9 +73,8 @@
 	struct task_struct *tsk = current;
 	DECLARE_WAITQUEUE(wait, tsk);
 
-	tsk->state = TASK_UNINTERRUPTIBLE;
+	__set_task_state(tsk, TASK_UNINTERRUPTIBLE);
 	add_wait_queue_exclusive(&sem->wait, &wait);
-	smp_wmb();
 
 	/*
 	 * Try to get the semaphore.  If the count is > 0, then we've
@@ -85,10 +84,10 @@
 	 */
 	while (__sem_update_count(sem, -1) <= 0) {
 		schedule();
-		tsk->state = TASK_UNINTERRUPTIBLE;
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
 	}
 	remove_wait_queue(&sem->wait, &wait);
-	tsk->state = TASK_RUNNING;
+	__set_task_state(tsk, TASK_RUNNING);
 
 	/*
 	 * If there are any more sleepers, wake one of them up so
@@ -104,9 +103,8 @@
 	struct task_struct *tsk = current;
 	DECLARE_WAITQUEUE(wait, tsk);
 
-	tsk->state = TASK_INTERRUPTIBLE;
+	__set_task_state(tsk, TASK_INTERRUPTIBLE);
 	add_wait_queue_exclusive(&sem->wait, &wait);
-	smp_wmb();
 
 	while (__sem_update_count(sem, -1) <= 0) {
 		if (signal_pending(current)) {
@@ -120,10 +118,11 @@
 			break;
 		}
 		schedule();
-		tsk->state = TASK_INTERRUPTIBLE;
+		set_task_state(tsk, TASK_INTERRUPTIBLE);
 	}
-	tsk->state = TASK_RUNNING;
 	remove_wait_queue(&sem->wait, &wait);
+	__set_task_state(tsk, TASK_RUNNING);
+	
 	wake_up(&sem->wait);
 	return retval;
 }
diff -urN kernel-source-2.4.27/arch/ppc/kernel/setup.c kernel-source-2.4.27-benh/arch/ppc/kernel/setup.c
--- kernel-source-2.4.27/arch/ppc/kernel/setup.c	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/setup.c	2004-09-01 20:56:23.299576984 +0200
@@ -52,6 +52,7 @@
 struct ide_machdep_calls ppc_ide_md;
 char *sysmap;
 unsigned long sysmap_size;
+int no_nap;
 
 /* Used with the BI_MEMSIZE bootinfo parameter to store the memory
    size value reported by the boot loader. */
@@ -329,6 +330,7 @@
 	      unsigned long r6, unsigned long r7)
 {
 #ifdef CONFIG_BOOTX_TEXT
+	extern int force_printk_to_btext;
 	if (boot_text_mapped) {
 		btext_clearscreen();
 		btext_welcome();
@@ -415,6 +417,31 @@
 	}
 	cmd_line[sizeof(cmd_line) - 1] = 0;
 
+	/* Debug stuff, do not merge ! */
+#ifdef CONFIG_ADB_PMU
+	if (strstr(cmd_line, "fake_sleep")) {
+		extern int __fake_sleep;
+		__fake_sleep = 1;
+	}
+#endif /* CONFIG_ADB_PMU */	
+#ifdef CONFIG_ADB
+	if (strstr(cmd_line, "adb_sync")) {
+		extern int __adb_probe_sync;
+		__adb_probe_sync = 1;
+	}
+#endif /* CONFIG_ADB */
+	if (strstr(cmd_line, "slowboot")) {
+		extern int __slow_boot;
+		__slow_boot = 1;
+	}
+	if (strstr(cmd_line, "nol3") && cur_cpu_spec[0]->cpu_features & CPU_FTR_L3CR)
+		_set_L3CR(0);
+	if (strstr(cmd_line, "nonap"))
+		cur_cpu_spec[0]->cpu_features &= ~CPU_FTR_CAN_NAP;
+#ifdef CONFIG_BOOTX_TEXT
+	if (strstr(cmd_line, "printkbtext"))
+		force_printk_to_btext = 1;
+#endif
 	switch (_machine) {
 	case _MACH_Pmac:
 		pmac_init(r3, r4, r5, r6, r7);
@@ -508,6 +535,23 @@
 		ppc_md.progress("id mach(): done", 0x200);
 }
 
+#ifdef CONFIG_NVRAM
+
+/* Generic nvram hooks used by drivers/char/gen_nvram.c */
+unsigned char nvram_read_byte(int addr)
+{
+	if (ppc_md.nvram_read_val)
+		return ppc_md.nvram_read_val(addr);
+	return 0xff;
+}
+
+void nvram_write_byte(unsigned char val, int addr)
+{
+	if (ppc_md.nvram_write_val)
+		ppc_md.nvram_write_val(addr, val);
+}
+
+#endif /* CONFIG_NVRAM */
 /* Checks "l2cr=xxxx" command-line option */
 int __init ppc_setup_l2cr(char *str)
 {
diff -urN kernel-source-2.4.27/arch/ppc/kernel/smp.c kernel-source-2.4.27-benh/arch/ppc/kernel/smp.c
--- kernel-source-2.4.27/arch/ppc/kernel/smp.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/smp.c	2004-09-01 20:56:23.376565280 +0200
@@ -55,14 +55,13 @@
 /* all cpu mappings are 1-1 -- Cort */
 volatile unsigned long cpu_callin_map[NR_CPUS];
 
-#define TB_SYNC_PASSES 4
-volatile unsigned long __initdata tb_sync_flag = 0;
-volatile unsigned long __initdata tb_offset = 0;
-
 int start_secondary(void *);
 extern int cpu_idle(void *unused);
 void smp_call_function_interrupt(void);
 
+extern void smp_generic_take_timebase(void);
+extern void smp_generic_give_timebase(void);
+
 /* Low level assembly function used to backup CPU 0 state */
 extern void __save_cpu_setup(void);
 
@@ -230,6 +229,10 @@
 	timeout = 1000000;
 	while (atomic_read(&data.started) != cpus) {
 		if (--timeout == 0) {
+#ifdef CONFIG_XMON
+			xmon_printf("smp_call_function on cpu %d: other cpus not responding (%d)\n",
+			       smp_processor_id(), atomic_read(&data.started));
+#endif			       
 			printk("smp_call_function on cpu %d: other cpus not responding (%d)\n",
 			       smp_processor_id(), atomic_read(&data.started));
 			goto out;
@@ -242,6 +245,10 @@
 		timeout = 1000000;
 		while (atomic_read(&data.finished) != cpus) {
 			if (--timeout == 0) {
+#ifdef CONFIG_XMON
+				xmon_printf("smp_call_function on cpu %d: other cpus not finishing (%d/%d)\n",
+				       smp_processor_id(), atomic_read(&data.finished), atomic_read(&data.started));
+#endif
 				printk("smp_call_function on cpu %d: other cpus not finishing (%d/%d)\n",
 				       smp_processor_id(), atomic_read(&data.finished), atomic_read(&data.started));
 				goto out;
@@ -399,81 +406,6 @@
 		smp_tb_synchronized = 1;
 }
 
-void __init smp_software_tb_sync(int cpu)
-{
-#define PASSES 4	/* 4 passes.. */
-	int pass;
-	int i, j;
-
-	/* stop - start will be the number of timebase ticks it takes for cpu0
-	 * to send a message to all others and the first reponse to show up.
-	 *
-	 * ASSUMPTION: this time is similiar for all cpus
-	 * ASSUMPTION: the time to send a one-way message is ping/2
-	 */
-	register unsigned long start = 0;
-	register unsigned long stop = 0;
-	register unsigned long temp = 0;
-
-	set_tb(0, 0);
-
-	/* multiple passes to get in l1 cache.. */
-	for (pass = 2; pass < 2+PASSES; pass++){
-		if (cpu == 0){
-			mb();
-			for (i = j = 1; i < smp_num_cpus; i++, j++){
-				/* skip stuck cpus */
-				while (!cpu_callin_map[j])
-					++j;
-				while (cpu_callin_map[j] != pass)
-					barrier();
-			}
-			mb();
-			tb_sync_flag = pass;
-			start = get_tbl();	/* start timing */
-			while (tb_sync_flag)
-				mb();
-			stop = get_tbl();	/* end timing */
-			/* theoretically, the divisor should be 2, but
-			 * I get better results on my dual mtx. someone
-			 * please report results on other smp machines..
-			 */
-			tb_offset = (stop-start)/4;
-			mb();
-			tb_sync_flag = pass;
-			udelay(10);
-			mb();
-			tb_sync_flag = 0;
-			mb();
-			set_tb(0,0);
-			mb();
-		} else {
-			cpu_callin_map[cpu] = pass;
-			mb();
-			while (!tb_sync_flag)
-				mb();		/* wait for cpu0 */
-			mb();
-			tb_sync_flag = 0;	/* send response for timing */
-			mb();
-			while (!tb_sync_flag)
-				mb();
-			temp = tb_offset;	/* make sure offset is loaded */
-			while (tb_sync_flag)
-				mb();
-			set_tb(0,temp);		/* now, set the timebase */
-			mb();
-		}
-	}
-	if (cpu == 0) {
-		smp_tb_synchronized = 1;
-		printk("smp_software_tb_sync: %d passes, final offset: %ld\n",
-			PASSES, tb_offset);
-	}
-	/* so time.c doesn't get confused */
-	set_dec(tb_ticks_per_jiffy);
-	last_jiffy_stamp(cpu) = 0;
-}
-
 void __init smp_commence(void)
 {
 	/*
@@ -498,7 +430,7 @@
 	if (!smp_tb_synchronized && smp_num_cpus == 2) {
 		unsigned long flags;
 		__save_and_cli(flags);
-		smp_software_tb_sync(0);
+		smp_generic_give_timebase();
 		__restore_flags(flags);
 	}
 }
@@ -508,19 +440,19 @@
 	int cpu = current->processor;
 
         smp_store_cpu_info(cpu);
-	smp_ops->setup_cpu(cpu);
 	set_dec(tb_ticks_per_jiffy);
 	cpu_online_map |= 1UL << cpu;
 	mb();
 	cpu_callin_map[cpu] = 1;
 
+	smp_ops->setup_cpu(cpu);
+
 	while(!smp_commenced)
 		barrier();
 
 	/* see smp_commence for more info */
-	if (!smp_tb_synchronized && smp_num_cpus == 2) {
-		smp_software_tb_sync(cpu);
-	}
+	if (!smp_tb_synchronized && smp_num_cpus == 2)
+		smp_generic_take_timebase();
 	__sti();
 }
 
diff -urN kernel-source-2.4.27/arch/ppc/kernel/smp-tbsync.c kernel-source-2.4.27-benh/arch/ppc/kernel/smp-tbsync.c
--- kernel-source-2.4.27/arch/ppc/kernel/smp-tbsync.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/smp-tbsync.c	2004-09-01 20:56:23.378564976 +0200
@@ -0,0 +1,182 @@
+/*
+ * Smp timebase synchronization for ppc.
+ *
+ * Copyright (C) 2003 Samuel Rydh (samuel@ibrium.se)
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/smp.h>
+#include <linux/unistd.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/atomic.h>
+#include <asm/smp.h>
+#include <asm/time.h>
+
+#define NUM_ITER		300
+
+enum {
+	kExit=0, kSetAndTest, kTest
+};
+
+static struct {
+	volatile int		tbu;
+	volatile int		tbl;
+	volatile int		mark;
+	volatile int		cmd;
+	volatile int		handshake;
+	int			filler[3];
+
+	volatile int		ack;
+	int			filler2[7];
+
+	volatile int		race_result;
+} *tbsync;
+
+static volatile int		running;
+
+static void __devinit
+enter_contest( int mark, int add )
+{
+	while( (int)(get_tbl() - mark) < 0 )
+		tbsync->race_result = add;
+}
+
+void __devinit
+smp_generic_take_timebase( void )
+{
+	int cmd, tbl, tbu;
+
+	local_irq_disable();
+	while( !running )
+		;
+	rmb();
+
+	for( ;; ) {
+		tbsync->ack = 1;
+		while( !tbsync->handshake )
+			;
+		rmb();
+
+		cmd = tbsync->cmd;
+		tbl = tbsync->tbl;
+		tbu = tbsync->tbu;
+		tbsync->ack = 0;
+		if( cmd == kExit )
+			return;
+
+		if( cmd == kSetAndTest ) {
+			while( tbsync->handshake )
+				;
+			asm volatile ("mttbl %0" :: "r" (tbl) );
+			asm volatile ("mttbu %0" :: "r" (tbu) );
+		} else {
+			while( tbsync->handshake )
+				;
+		}
+		enter_contest( tbsync->mark, -1 );
+	}
+	local_irq_enable();
+}
+
+static int __devinit
+start_contest( int cmd, int offset, int num )
+{
+	int i, tbu, tbl, mark, score=0;
+
+	tbsync->cmd = cmd;
+
+	local_irq_disable();
+	for( i=-3; i<num; ) {
+		tbl = get_tbl() + 400;
+		tbsync->tbu = tbu = get_tbu();
+		tbsync->tbl = tbl + offset;
+		tbsync->mark = mark = tbl + 400;
+
+		wmb();
+
+		tbsync->handshake = 1;
+		while( tbsync->ack )
+			;
+
+		while( (int)(get_tbl() - tbl) <= 0 )
+			;
+		tbsync->handshake = 0;
+		enter_contest( mark, 1 );
+
+		while( !tbsync->ack )
+			;
+
+		if( tbsync->tbu != get_tbu() || ((tbsync->tbl ^ get_tbl()) & 0x80000000) )
+			continue;
+		if( i++ > 0 )
+			score += tbsync->race_result;
+	}
+	local_irq_enable();
+	return score;
+}
+
+void __devinit
+smp_generic_give_timebase( void )
+{
+	int i, score, score2, old, min=0, max=5000, offset=1000;
+
+	printk("Synchronizing timebase\n");
+
+	/* if this fails then this kernel won't work anyway... */
+	tbsync = kmalloc( sizeof(*tbsync), GFP_KERNEL );
+	memset( tbsync, 0, sizeof(*tbsync) );
+	mb();
+	running = 1;
+
+	while( !tbsync->ack )
+		;
+
+	/* binary search */
+	for( old=-1 ; old != offset ; offset=(min+max)/2 ) {
+		score = start_contest( kSetAndTest, offset, NUM_ITER );
+
+		printk("score %d, offset %d\n", score, offset );
+
+		if( score > 0 )
+			max = offset;
+		else
+			min = offset;
+		old = offset;
+	}
+	score = start_contest( kSetAndTest, min, NUM_ITER );
+	score2 = start_contest( kSetAndTest, max, NUM_ITER );
+
+	printk( "Min %d (score %d), Max %d (score %d)\n", min, score, max, score2 );
+	score = abs( score );
+	score2 = abs( score2 );
+	offset = (score < score2) ? min : max;
+
+	/* guard against inaccurate mttb */
+	for( i=0; i<10; i++ ) {
+		start_contest( kSetAndTest, offset, NUM_ITER/10 );
+
+		if( (score2=start_contest(kTest, offset, NUM_ITER)) < 0 )
+			score2 = -score2;
+		if( score2 <= score || score2 < 20 )
+			break;
+	}
+	printk("Final offset: %d (%d/%d)\n", offset, score2, NUM_ITER );
+
+	/* exiting */
+	tbsync->cmd = kExit;
+	wmb();
+	tbsync->handshake = 1;
+	while( tbsync->ack )
+		;
+	tbsync->handshake = 0;
+	kfree( tbsync );
+	tbsync = NULL;
+	running = 0;
+
+	/* all done */
+	smp_tb_synchronized = 1;
+}
diff -urN kernel-source-2.4.27/arch/ppc/kernel/time.c kernel-source-2.4.27-benh/arch/ppc/kernel/time.c
--- kernel-source-2.4.27/arch/ppc/kernel/time.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/time.c	2004-09-01 20:56:23.459552664 +0200
@@ -145,6 +145,12 @@
 	unsigned jiffy_stamp = last_jiffy_stamp(cpu);
 	extern void do_IRQ(struct pt_regs *);
 
+#ifdef CONFIG_XMON_FW
+	extern volatile unsigned int xmon_fw_kick;
+	if (xmon_fw_kick)
+		xmon(regs);
+#endif /* CONFIG_XMON_FW */
+
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
 
diff -urN kernel-source-2.4.27/arch/ppc/kernel/traps.c kernel-source-2.4.27-benh/arch/ppc/kernel/traps.c
--- kernel-source-2.4.27/arch/ppc/kernel/traps.c	2004-04-14 15:05:27.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/kernel/traps.c	2004-09-01 20:56:23.537540808 +0200
@@ -76,6 +76,9 @@
 #endif
 #endif
 
+#undef DUMP_USER_ERRORS
+#undef SIGSTOP_ON_SIGILL
+
 /*
  * Trap & Exception support
  */
@@ -85,14 +88,25 @@
 
 void die(const char * str, struct pt_regs * fp, long err)
 {
+#ifdef CONFIG_BOOTX_TEXT
+	extern int force_printk_to_btext;
+#endif
 	console_verbose();
 	spin_lock_irq(&die_lock);
+#ifdef CONFIG_BOOTX_TEXT
+	force_printk_to_btext = 1;
+#endif	
 #ifdef CONFIG_PMAC_BACKLIGHT
+	if (_machine == _MACH_Pmac) {
 	set_backlight_enable(1);
 	set_backlight_level(BACKLIGHT_MAX);
+	}
 #endif
 	printk("Oops: %s, sig: %ld\n", str, err);
 	show_regs(fp);
+#ifdef CONFIG_BOOTX_TEXT
+	force_printk_to_btext = 0;
+#endif	
 	spin_unlock_irq(&die_lock);
 	/* do_exit() should take care of panic'ing from an interrupt
 	 * context so we don't handle it here
@@ -116,6 +130,79 @@
 	force_sig_info(signr, &info, current);
 }
 
+#ifdef DUMP_USER_ERRORS
+extern int get_pteptr(struct mm_struct *mm, unsigned long addr, pte_t **ptep);
+void
+dump_user_error(const char *label, int sig, struct pt_regs *regs)
+{
+	struct vm_area_struct * vma;
+	struct mm_struct *mm = current->mm;
+	pte_t *pte;
+	u32 insword;
+
+	if (!user_mode(regs))
+		return;
+	printk("User fault %d: %s in %s:%u", sig, label, current->comm, current->pid);
+	if (current->p_pptr) {
+		printk("<-(%s:%u)",current->p_pptr->comm,current->p_pptr->pid);
+		if (current->p_pptr->p_pptr)
+			printk("<-(%s:%u)",current->p_pptr->p_pptr->comm,current->p_pptr->p_pptr->pid);
+	}
+	printk("\nPC: %08lx, LR: %08lx\n", regs->nip, regs->link);
+	down_read(&mm->mmap_sem);
+	vma = find_vma(mm, regs->nip);
+	if (vma == NULL)
+		printk("No VMA found\n");
+	else {
+		printk("VMA start:%08lx,end:%08lx,flags:%08lx,prot:%08lx\n",
+		       vma->vm_start, vma->vm_end, vma->vm_flags, vma->vm_page_prot.pgprot);
+	}
+	up_read(&mm->mmap_sem);
+	if (get_user(insword, (u32 *)(regs->nip - 4)))
+		printk("PC-4: <fault>\n");
+	else
+		printk("PC-4: %08x\n", insword);
+	if (get_user(insword, (u32 *)(regs->nip)))
+		printk("PC : <fault>\n");
+	else
+		printk("PC : %08x\n", insword);
+	if (get_user(insword, (u32 *)(regs->nip + 4)))
+		printk("PC+4: <fault>\n");
+	else
+		printk("PC+4: %08x\n", insword);
+	if (get_pteptr(mm, regs->nip, &pte)) {
+		struct page *page = pte_page(*pte);
+		printk("PC: Page: %p, flags: %lx, PG_arch_1: %d\n",
+		       page, page->flags, test_bit(PG_arch_1, &page->flags));
+		printk("PC: page->mapping: %p (swapper: %p)\n",
+		       page->mapping, &swapper_space);
+	} else
+		printk("PC: No page !\n");
+	if (get_user(insword, (u32 *)(regs->link - 4)))
+		printk("LR-4: <fault>\n");
+	else
+		printk("LR-4: %08x\n", insword);
+	if (get_user(insword, (u32 *)(regs->link)))
+		printk("LR : <fault>\n");
+	else
+		printk("LR : %08x\n", insword);
+	if (get_user(insword, (u32 *)(regs->link + 4)))
+		printk("LR+4: <fault>\n");
+	else
+		printk("LR+4: %08x\n", insword);
+	if (get_pteptr(mm, regs->link, &pte)) {
+		struct page *page = pte_page(*pte);
+		printk("LR: Page: %p, flags: %lx, PG_arch_1: %d\n",
+			page, page->flags, test_bit(PG_arch_1, &page->flags));
+		printk("PC: page->mapping: %p (swapper: %p)\n",
+		       page->mapping, &swapper_space);
+	} else
+		printk("LR: No page !\n");
+}
+#else
+void
+dump_user_error(const char *label, int sig, struct pt_regs *regs) { }
+#endif
 /*
  * I/O accesses can cause machine checks on powermacs.
  * Check if the NIP corresponds to the address of a sync
@@ -429,11 +516,21 @@
 			emulate_single_step(regs);
 			return;
 		}
+		dump_user_error("privileged insn", SIGILL, regs);
 		_exception(SIGILL, regs, ILL_PRVOPC, regs->nip);
 		return;
 	}
 
+	dump_user_error("illegal insn", SIGILL, regs);
+#ifdef SIGSTOP_ON_SIGILL
+	if (!user_mode(regs)) {
+		debugger(regs);
+		die("Exception in kernel mode", regs, SIGILL);
+	}
+	force_sig(SIGSTOP, current);
+#else
 	_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
+#endif
 }
 
 void
diff -urN kernel-source-2.4.27/arch/ppc/lib/locks.c kernel-source-2.4.27-benh/arch/ppc/lib/locks.c
--- kernel-source-2.4.27/arch/ppc/lib/locks.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/lib/locks.c	2004-09-01 20:56:23.538540656 +0200
@@ -15,9 +15,19 @@
 
 #if SPINLOCK_DEBUG
 
+/* Route debug output to xmon when possible, there are more chances
+ * for it to work than the console
+ */
+#ifdef CONFIG_XMON
+extern void xmon_printf(const char* fmt,...);
+#define printk xmon_printf
+#endif
+
 #undef INIT_STUCK
 #define INIT_STUCK 200000000 /*0xffffffff*/
 
+#define isync()  __asm__ __volatile__ ("isync" : : : "memory")
+
 /*
  * Try to acquire a spinlock.
  * Only does the stwcx. if the load returned 0 - the Programming
@@ -25,7 +35,7 @@
  * since they may inhibit forward progress by other CPUs in getting
  * a lock.
  */
-static unsigned long __spin_trylock(volatile unsigned long *lock)
+unsigned long __spin_trylock(volatile unsigned long *lock)
 {
 	unsigned long ret;
 
@@ -86,7 +96,7 @@
 		      lp, smp_processor_id(), (int)lp->owner_cpu,
 		      lp->owner_pc,lp->lock);
 	lp->owner_pc = lp->owner_cpu = 0;
-	wmb();
+	mb();
 	lp->lock = 0;
 }
 
@@ -120,7 +130,7 @@
 		/* try to get the read lock again */
 		goto again;
 	}
-	wmb();
+	isync();
 }
 
 void _read_unlock(rwlock_t *rw)
@@ -129,7 +139,7 @@
 		printk("_read_unlock(): %s/%d (nip %08lX) lock %lx\n",
 		       current->comm,current->pid,current->thread.regs->nip,
 		      rw->lock);
-	wmb();
+	mb();
 	atomic_dec((atomic_t *) &(rw)->lock);
 }
 
@@ -170,7 +180,7 @@
 		}
 		goto again;
 	}
-	wmb();
+	isync();
 }
 
 void _write_unlock(rwlock_t *rw)
@@ -179,7 +189,7 @@
 		printk("_write_lock(): %s/%d (nip %08lX) lock %lx\n",
 		      current->comm,current->pid,current->thread.regs->nip,
 		      rw->lock);
-	wmb();
+	mb();
 	clear_bit(31,&(rw)->lock);
 }
 
diff -urN kernel-source-2.4.27/arch/ppc/mm/fault.c kernel-source-2.4.27-benh/arch/ppc/mm/fault.c
--- kernel-source-2.4.27/arch/ppc/mm/fault.c	2003-11-28 19:26:19.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/mm/fault.c	2004-09-01 20:56:23.616528800 +0200
@@ -96,7 +96,7 @@
 void do_page_fault(struct pt_regs *regs, unsigned long address,
 		   unsigned long error_code)
 {
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	struct mm_struct *mm = current->mm;
 	siginfo_t info;
 	int code = SEGV_MAPERR;
@@ -177,7 +177,8 @@
 		    && (!user_mode(regs) || !store_updates_sp(regs)))
 			goto bad_area;
 	}
-	if (expand_stack(vma, address))
+	vma = find_vma_prev(mm, address, &prev_vma);
+	if (expand_stack(vma, address, prev_vma))
 		goto bad_area;
 
 good_area:
diff -urN kernel-source-2.4.27/arch/ppc/mm/init.c kernel-source-2.4.27-benh/arch/ppc/mm/init.c
--- kernel-source-2.4.27/arch/ppc/mm/init.c	2003-11-28 19:26:19.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/mm/init.c	2004-09-01 20:56:23.692517248 +0200
@@ -125,6 +125,9 @@
 
 int do_check_pgt_cache(int low, int high)
 {
+#ifdef CONFIG_DEBUG_NOPGTABLECACHE
+	return 0;
+#else
 	int freed = 0;
 	if (pgtable_cache_size > high) {
 		do {
@@ -139,6 +142,7 @@
 		} while (pgtable_cache_size > low);
 	}
 	return freed;
+#endif
 }
 
 void show_mem(void)
@@ -483,6 +487,17 @@
 	high_memory = (void *) __va(PPC_MEMSTART + total_lowmem);
 	num_physpages = max_mapnr;	/* RAM is assumed contiguous */
 
+	/* Sanity check: did ioremap_bot stomp over vmalloc space ? We keep
+	 * a minimal 16Mb guard though if you only have 16Mb left, you'll
+	 * probably run into trouble, so we also printk something if you
+	 * have less than 64Mb. This is meant to help diagnosing such problems
+	 * as debugging it can be really painful. --BenH.
+	 */
+	if (VMALLOC_END < (VMALLOC_START + 0x01000000UL))
+		panic("Argh ! Virtual space exhausted !");
+	if (VMALLOC_END < (VMALLOC_START + 0x04000000UL))
+		printk(KERN_WARNING "Warning ! Virtual space small !");
+
 	totalram_pages += free_all_bootmem();
 
 	/* adjust vmalloc_start */
diff -urN kernel-source-2.4.27/arch/ppc/platforms/Makefile kernel-source-2.4.27-benh/arch/ppc/platforms/Makefile
--- kernel-source-2.4.27/arch/ppc/platforms/Makefile	2004-08-08 01:26:04.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/Makefile	2004-09-01 20:56:23.693517096 +0200
@@ -26,7 +26,7 @@
 
 O_TARGET := platform.o
 
-export-objs			:= prep_setup.o ibm440gp.o ibm440gx.o
+export-objs			:= prep_setup.o ibm440gp.o ibm440gx.o pmac_nvram.o
 
 obj-$(CONFIG_405GP)		+= ibm405gp.o
 obj-$(CONFIG_440GP)		+= ibm440gp.o
@@ -51,6 +51,9 @@
 					prep_time.o prep_setup.o pmac_sleep.o \
 					pmac_nvram.o
 obj-$(CONFIG_PMAC_BACKLIGHT)	+= pmac_backlight.o
+ifeq ($(CONFIG_ALL_PPC),y)
+obj-$(CONFIG_CPU_FREQ_PMAC)	+= pmac_cpufreq.o
+endif
 obj-$(CONFIG_PREP_RESIDUAL)	+= residual.o
 obj-$(CONFIG_GEMINI)		+= gemini_pci.o gemini_setup.o gemini_prom.o
 obj-$(CONFIG_LOPEC)		+= lopec_setup.o lopec_pci.o
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_backlight.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_backlight.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_backlight.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_backlight.c	2004-09-01 20:56:23.693517096 +0200
@@ -37,6 +37,10 @@
 	char *prop;
 	int valid = 0;
 
+	/* There's already a matching controller, bail out */
+	if (backlighter != NULL)
+		return;
+
 	bk_node = find_devices("backlight");
 
 #ifdef CONFIG_ADB_PMU
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_cpufreq.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_cpufreq.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_cpufreq.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_cpufreq.c	2004-09-01 20:56:23.771505240 +0200
@@ -0,0 +1,352 @@
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/adb.h>
+#include <linux/pmu.h>
+#include <linux/slab.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/irq.h>
+#include <asm/hardirq.h>
+#include <asm/pmac_feature.h>
+#include <asm/mmu_context.h>
+#include <asm/sections.h>
+#include <asm/cputable.h>
+#include <asm/time.h>
+
+#undef DEBUG_FREQ
+
+extern void low_choose_750fx_pll(int pll);
+extern void low_sleep_handler(void);
+extern void openpic_sleep_save_intrs(void);
+extern void openpic_sleep_restore_intrs(void);
+extern void enable_kernel_altivec(void);
+extern void enable_kernel_fp(void);
+
+static unsigned int low_freq;
+static unsigned int hi_freq;
+static unsigned int cur_freq;
+static int cpufreq_uses_pmu;
+
+#define PMAC_CPU_LOW_SPEED	1
+#define PMAC_CPU_HIGH_SPEED	0
+
+static inline void
+wakeup_decrementer(void)
+{
+	set_dec(tb_ticks_per_jiffy);
+	/* No currently-supported powerbook has a 601,
+	 * so use get_tbl, not native
+	 */
+	last_jiffy_stamp(0) = tb_last_stamp = get_tbl();
+}
+
+#ifdef DEBUG_FREQ
+static inline void
+debug_calc_bogomips(void)
+{
+	/* This will cause a recalc of bogomips and display the
+	 * result. We backup/restore the value to avoid affecting the
+	 * core cpufreq framework's own calculation.
+	 */
+	extern void calibrate_delay(void);
+
+	unsigned long save_lpj = loops_per_jiffy;
+	calibrate_delay();
+	loops_per_jiffy = save_lpj;
+}
+#endif
+
+/* Switch CPU speed under 750FX CPU control
+ */
+static int __pmac
+cpu_750fx_cpu_speed(int low_speed)
+{
+#ifdef DEBUG_FREQ
+	printk(KERN_DEBUG "HID1, before: %x\n", mfspr(SPRN_HID1));	
+#endif
+	low_choose_750fx_pll(low_speed);
+#ifdef DEBUG_FREQ
+	printk(KERN_DEBUG "HID1, after: %x\n", mfspr(SPRN_HID1));	
+	debug_calc_bogomips();
+#endif
+
+	return 0;
+}
+
+/* Switch CPU speed under PMU control
+ */
+static int __pmac
+pmu_set_cpu_speed(unsigned int low_speed)
+{
+	struct adb_request req;
+	unsigned long save_l2cr;
+	unsigned long save_l3cr;
+	
+#ifdef DEBUG_FREQ
+	printk(KERN_DEBUG "HID1, before: %x\n", mfspr(SPRN_HID1));	
+#endif
+	/* Disable all interrupt sources on openpic */
+	openpic_sleep_save_intrs();
+
+	/* Make sure the PMU is idle */
+	pmu_suspend();
+
+	/* Make sure the decrementer won't interrupt us */
+	asm volatile("mtdec %0" : : "r" (0x7fffffff));
+	/* Make sure any pending DEC interrupt occuring while we did
+	 * the above didn't re-enable the DEC */
+	mb();
+	asm volatile("mtdec %0" : : "r" (0x7fffffff));
+
+	/* We can now disable MSR_EE */
+	local_irq_disable();
+
+	/* Giveup the FPU & vec */
+	enable_kernel_fp();
+
+#ifdef CONFIG_ALTIVEC
+	if (cur_cpu_spec[0]->cpu_features & CPU_FTR_ALTIVEC)
+		enable_kernel_altivec();
+#endif /* CONFIG_ALTIVEC */
+
+	/* Save & disable L2 and L3 caches */
+	save_l3cr = _get_L3CR();	/* (returns -1 if not available) */
+	save_l2cr = _get_L2CR();	/* (returns -1 if not available) */
+	if (save_l3cr != 0xffffffff && (save_l3cr & L3CR_L3E) != 0)
+		_set_L3CR(save_l3cr & 0x7fffffff);
+	if (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)
+		_set_L2CR(save_l2cr & 0x7fffffff);
+
+	/* Send the new speed command. My assumption is that this command
+	 * will cause PLL_CFG[0..3] to be changed next time CPU goes to sleep
+	 */
+	pmu_request(&req, NULL, 6, PMU_CPU_SPEED, 'W', 'O', 'O', 'F', low_speed);
+	while (!req.complete)
+		pmu_poll();
+	
+	pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,1,1);
+
+	low_sleep_handler();
+	
+	pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,1,0);
+
+	/* Restore L2 cache */
+	if (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)
+ 		_set_L2CR(save_l2cr);
+	/* Restore L3 cache */
+	if (save_l3cr != 0xffffffff && (save_l3cr & L3CR_L3E) != 0)
+ 		_set_L3CR(save_l3cr);
+
+	/* Restore userland MMU context */
+	set_context(current->active_mm->context, current->active_mm->pgd);
+
+	pmu_unlock();
+	
+#ifdef DEBUG_FREQ
+	printk(KERN_DEBUG "HID1, after: %x\n", mfspr(SPRN_HID1));	
+#endif
+
+	/* Restore decrementer */
+	wakeup_decrementer();
+
+	/* Restore interrupts */
+	openpic_sleep_restore_intrs();
+
+	pmu_resume();
+
+	/* Let interrupts flow again ... */
+	local_irq_enable();
+
+#ifdef DEBUG_FREQ
+	debug_calc_bogomips();
+#endif
+
+	return 0;
+}
+
+static int __pmac
+do_set_cpu_speed(int speed_mode)
+{
+	struct cpufreq_freqs    freqs;
+	int rc;
+	
+	freqs.old = cur_freq;
+	freqs.new = (speed_mode == PMAC_CPU_HIGH_SPEED) ? hi_freq : low_freq;
+	freqs.cpu = CPUFREQ_ALL_CPUS;
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	if (cpufreq_uses_pmu)
+		rc = pmu_set_cpu_speed(speed_mode);
+	else
+		rc = cpu_750fx_cpu_speed(speed_mode);
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	cur_freq = (speed_mode == PMAC_CPU_HIGH_SPEED) ? hi_freq : low_freq;
+
+	return rc;
+}
+
+static int __pmac
+pmac_cpufreq_verify(struct cpufreq_policy *policy)
+{
+	if (!policy)
+		return -EINVAL;
+		
+	policy->cpu = 0; /* UP only */
+
+	cpufreq_verify_within_limits(policy, low_freq, hi_freq);
+
+	if ((policy->min > low_freq) && 
+	    (policy->max < hi_freq))
+		policy->max = hi_freq;
+
+	return 0;
+}
+
+static int __pmac
+pmac_cpufreq_setpolicy(struct cpufreq_policy *policy)
+{
+	int rc;
+	
+	if (!policy)
+		return -EINVAL;
+	if (policy->min > low_freq)
+		rc = do_set_cpu_speed(PMAC_CPU_HIGH_SPEED);
+	else if (policy->max < hi_freq)
+		rc = do_set_cpu_speed(PMAC_CPU_LOW_SPEED);
+	else if (policy->policy == CPUFREQ_POLICY_POWERSAVE)
+		rc = do_set_cpu_speed(PMAC_CPU_LOW_SPEED);
+	else
+		rc = do_set_cpu_speed(PMAC_CPU_HIGH_SPEED);
+
+	return rc;
+}
+
+unsigned int __pmac
+pmac_get_cur_cpufreq(void)
+{
+	return cur_freq;
+}
+
+
+/* Currently, we support the following machines:
+ * 
+ *  - Titanium PowerBook 800 (PMU based, 667Mhz & 800Mhz)
+ *  - Titanium PowerBook 500 (PMU based, 300Mhz & 500Mhz)
+ *  - iBook2 500 (PMU based, 400Mhz & 500Mhz)
+ *  - iBook2 700 (CPU based, 400Mhz & 700Mhz, support low voltage)
+ */
+static int __init
+pmac_cpufreq_setup(void)
+{	
+	struct device_node	*cpunode;
+	struct cpufreq_driver   *driver;
+	u32			*value;
+	int			has_freq_ctl = 0;
+	int			rc;
+	
+	memset(&driver, 0, sizeof(driver));
+
+	/* Assume only one CPU */
+	cpunode = find_type_devices("cpu");
+	if (!cpunode)
+		goto out;
+
+	/* Get current cpu clock freq */
+	value = (u32 *)get_property(cpunode, "clock-frequency", NULL);
+	if (!value)
+		goto out;
+	cur_freq = (*value) / 1000;
+
+	/* Check for newer machines */
+	if (machine_is_compatible("PowerBook3,4") ||
+	    machine_is_compatible("PowerBook3,5") ||
+	    machine_is_compatible("MacRISC3")) {
+		value = (u32 *)get_property(cpunode, "min-clock-frequency", NULL);
+		if (!value)
+			goto out;
+		low_freq = (*value) / 1000;
+		/* The PowerBook G4 12" (PowerBook6,1) has an error in the device-tree
+		 * here */
+		if (low_freq < 100000)
+			low_freq *= 10;
+		
+		value = (u32 *)get_property(cpunode, "max-clock-frequency", NULL);
+		if (!value)
+			goto out;
+		hi_freq = (*value) / 1000;			
+		has_freq_ctl = 1;
+		cpufreq_uses_pmu = 1;
+	}
+	/* Else check for iBook2 500 */
+	else if (machine_is_compatible("PowerBook4,1")) {
+		/* We only know about 500Mhz model */
+		if (cur_freq < 450000 || cur_freq > 550000)
+			goto out;
+		hi_freq = cur_freq;
+		low_freq = 400000;
+		has_freq_ctl = 1;
+		cpufreq_uses_pmu = 1;
+	}
+	/* Else check for TiPb 500 */
+	else if (machine_is_compatible("PowerBook3,2")) {
+		/* We only know about 500Mhz model */
+		if (cur_freq < 450000 || cur_freq > 550000)
+			goto out;
+		hi_freq = cur_freq;
+		low_freq = 300000;
+		has_freq_ctl = 1;
+		cpufreq_uses_pmu = 1;
+	}
+	/* Else check for 750FX */
+	else if (PVR_VER(mfspr(PVR)) == 0x7000) {
+		if (get_property(cpunode, "dynamic-power-step", NULL) == NULL)
+			goto out;	
+		hi_freq = cur_freq;
+		value = (u32 *)get_property(cpunode, "reduced-clock-frequency", NULL);
+		if (!value)
+			goto out;
+		low_freq = (*value) / 1000;
+		cpufreq_uses_pmu = 0;
+		has_freq_ctl = 1;
+	}
+out:
+	if (!has_freq_ctl)
+		return -ENODEV;
+	
+	/* initialization of main "cpufreq" code*/
+	driver = kmalloc(sizeof(struct cpufreq_driver) + 
+			 NR_CPUS * sizeof(struct cpufreq_policy), GFP_KERNEL);
+	if (!driver)
+		return -ENOMEM;
+
+	driver->policy = (struct cpufreq_policy *) (driver + 1);
+
+#ifdef CONFIG_CPU_FREQ_24_API
+	driver->cpu_min_freq[0] = low_freq;
+	driver->cpu_cur_freq[0] = cur_freq;
+#endif
+
+	driver->verify      = &pmac_cpufreq_verify;
+	driver->setpolicy   = &pmac_cpufreq_setpolicy;
+
+	driver->policy[0].cpu    = 0;
+	driver->policy[0].min    = low_freq;
+	driver->policy[0].max    = cur_freq;
+	driver->policy[0].max_cpu_freq = hi_freq;
+	driver->policy[0].policy = (cur_freq == low_freq) ? 
+	    CPUFREQ_POLICY_POWERSAVE : CPUFREQ_POLICY_PERFORMANCE;
+
+	rc = cpufreq_register(driver);
+	if (rc)
+		kfree(driver);
+	return rc;
+}
+
+__initcall(pmac_cpufreq_setup);
+
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_feature.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_feature.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_feature.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_feature.c	2004-09-01 20:56:23.852492928 +0200
@@ -80,6 +80,7 @@
 	macio_keylargo,
 	macio_pangea,
 	macio_intrepid,
+	macio_keylargo2,
 };
 
 static const char* macio_names[] __pmacdata =
@@ -93,7 +94,8 @@
 	"Paddington",
 	"Keylargo",
 	"Pangea",
-	"Intrepid"
+	"Intrepid",
+	"K2"
 };
 
 static struct macio_chip
@@ -149,6 +151,7 @@
 static struct device_node* uninorth_node __pmacdata;
 static u32* uninorth_base __pmacdata;
 static u32 uninorth_rev __pmacdata;
+static int uninorth_u3 __pmacdata;
 
 
 /*
@@ -1112,7 +1115,7 @@
 						KL_GPIO_RESET_CPU3 };
 
 	macio = &macio_chips[0];
-	if (macio->type != macio_keylargo)
+	if (macio->type != macio_keylargo && macio->type != macio_keylargo2)
 		return -ENODEV;
 
 	np = find_path_device("/cpus");
@@ -1135,7 +1138,7 @@
 	MACIO_OUT8(reset_io, KEYLARGO_GPIO_OUTPUT_ENABLE);
 	(void)MACIO_IN8(reset_io);
 	udelay(1);
-	MACIO_OUT8(reset_io, KEYLARGO_GPIO_OUTOUT_DATA | KEYLARGO_GPIO_OUTPUT_ENABLE);
+	MACIO_OUT8(reset_io, 0);
 	(void)MACIO_IN8(reset_io);
 	UNLOCK(flags);
 
@@ -1339,6 +1342,48 @@
 	return 0;
 }
 
+static int __pmac
+g5_gmac_enable(struct device_node* node, int param, int value)
+{
+	extern struct pci_dev *k2_skiplist[2];
+
+	struct macio_chip* macio = &macio_chips[0];
+	unsigned long flags;
+	struct pci_dev *pdev = NULL;
+	u8 pbus, pid;
+
+	if (pci_device_from_OF_node(node, &pbus, &pid) == 0)
+		pdev = pci_find_slot(pbus, pid);
+
+	LOCK(flags);
+	if (value) {
+		MACIO_BIS(0x3c, 0x00400000);
+		mb();
+		k2_skiplist[0] = NULL;
+	} else {
+		k2_skiplist[0] = pdev;
+		mb();
+		MACIO_BIC(0x3c, 0x00400000);
+	}
+	UNLOCK(flags);
+	udelay(20);
+
+	return 0;
+}
+
+/*
+ * This can be called from pmac_smp so isn't static
+ *
+ * This takes the second CPU off the bus on dual CPU machines
+ * running UP
+ */
+void __pmac g5_phy_disable_cpu1(void)
+{
+	printk(KERN_INFO "Removing CPU1 from bus\n");
+        UN_OUT(U3_API_PHY_CONFIG_1, 0);
+}
+                                                                                            
+
 static void __pmac
 keylargo_shutdown(struct macio_chip* macio, int sleep_mode)
 {
@@ -1810,6 +1855,18 @@
 	{ 0, NULL }
 };
 
+/* G5 features
+ */
+static struct feature_table_entry g5_features[]  __pmacdata = {
+	{ PMAC_FTR_GMAC_ENABLE,		g5_gmac_enable },
+#ifdef CONFIG_SMP
+	{ PMAC_FTR_RESET_CPU,		core99_reset_cpu },
+#endif /* CONFIG_SMP */
+	{ PMAC_FTR_READ_GPIO,		core99_read_gpio },
+	{ PMAC_FTR_WRITE_GPIO,		core99_write_gpio },
+	{ 0, NULL }
+};
+
 static struct pmac_mb_def pmac_mb_defs[] __pmacdata = {
 	/* Warning: ordering is important as some models may claim
 	 * beeing compatible with several types
@@ -1974,10 +2031,26 @@
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
 		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
+	{	"PowerBook5,2",			"PowerBook G4 15\"",
+		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+	},
+	{	"PowerBook5,3",			"PowerBook G4 17\"",
+		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+	},
 	{	"PowerBook6,1",			"PowerBook G4 12\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
 		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
 	},
+	{	"PowerBook6,3",			"iBook G4",
+		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+	},
+	{	"PowerMac7,2",			"PowerMac G5",
+		PMAC_TYPE_POWERMAC_G5,		g5_features,
+		0,
+	},
 };
 
 /*
@@ -2144,8 +2217,13 @@
 
 	/* Locate core99 Uni-N */
 	uninorth_node = find_devices("uni-n");
+	/* Locate G5 u3 */
+	if (uninorth_node == NULL) {
+		uninorth_node = find_compatible_devices(NULL, "u3");
+		uninorth_u3 = 1;
+	}
 	if (uninorth_node && uninorth_node->n_addrs > 0) {
-		uninorth_base = ioremap(uninorth_node->addrs[0].address, 0x4000);
+		uninorth_base = ioremap(uninorth_node->addrs[0].address, 0x40000);
 		uninorth_rev = in_be32(UN_REG(UNI_N_VERSION));
 	} else
 		uninorth_node = NULL;
@@ -2153,8 +2231,8 @@
 	if (!uninorth_node)
 		return;
 
-	printk(KERN_INFO "Found Uninorth memory controller & host bridge, revision: %d\n",
-			uninorth_rev);
+	printk(KERN_INFO "Found %s memory controller & host bridge, revision: %d\n",
+	       uninorth_u3 ? "U3" : "UniNorth", uninorth_rev);
 	printk(KERN_INFO "Mapped at 0x%08lx\n", (unsigned long)uninorth_base);
 
 	/* Set the arbitrer QAck delay according to what Apple does
@@ -2238,6 +2316,7 @@
 	probe_one_macio("mac-io", "paddington", macio_paddington);
 	probe_one_macio("mac-io", "gatwick", macio_gatwick);
 	probe_one_macio("mac-io", "heathrow", macio_heathrow);
+	probe_one_macio("mac-io", "K2-Keylargo", macio_keylargo2);
 
 	/* Make sure the "main" macio chip appear first */
 	if (macio_chips[0].type == macio_gatwick
@@ -2308,6 +2387,27 @@
 		MACIO_BIS(OHARE_FCR, OH_IOBUS_ENABLE);
 	}
 
+	if (macio_chips[0].type == macio_keylargo2) {
+#ifndef CONFIG_SMP
+		/* On SMP machines running UP, we have the second CPU eating
+		* bus cycles. We need to take it off the bus. This is done
+		* from pmac_smp for SMP kernels running on one CPU
+		*/
+		np = find_type_devices("cpu");
+	        if (np != NULL && np->next != NULL)
+	                g5_phy_disable_cpu1();
+#endif
+		/* Enable GMAC for now for PCI probing. It will be disabled
+		 * later on after PCI probe
+		 */
+		np = find_devices("ethernet");
+		while(np) {
+			if (device_is_compatible(np, "K2-GMAC"))
+				g5_gmac_enable(np, 0, 1);
+			np = np->next;
+		}
+	}
+
 	if (macio_chips[0].type == macio_keylargo ||
 	    macio_chips[0].type == macio_pangea ||
 	    macio_chips[0].type == macio_intrepid) {
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_nvram.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_nvram.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_nvram.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_nvram.c	2004-09-01 20:56:23.932480768 +0200
@@ -5,33 +5,46 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/stddef.h>
+#include <linux/string.h>
 #include <linux/nvram.h>
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/adb.h>
+#include <linux/pmu.h>
+#include <linux/bootmem.h>
+#include <linux/completion.h>
+#include <linux/spinlock.h>
 #include <asm/sections.h>
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/prom.h>
 #include <asm/machdep.h>
 #include <asm/nvram.h>
-#include <linux/adb.h>
-#include <linux/pmu.h>
 
-#undef DEBUG
+#define DEBUG
+
+#ifdef DEBUG
+#define DBG(x...) printk(x)
+#else
+#define DBG(x...)
+#endif
 
 #define NVRAM_SIZE		0x2000	/* 8kB of non-volatile RAM */
 
 #define CORE99_SIGNATURE	0x5a
 #define CORE99_ADLER_START	0x14
 
-/* Core99 nvram is a flash */
-#define CORE99_FLASH_STATUS_DONE	0x80
-#define CORE99_FLASH_STATUS_ERR		0x38
-#define CORE99_FLASH_CMD_ERASE_CONFIRM	0xd0
-#define CORE99_FLASH_CMD_ERASE_SETUP	0x20
-#define CORE99_FLASH_CMD_RESET		0xff
-#define CORE99_FLASH_CMD_WRITE_SETUP	0x40
+/* On Core99, nvram is either a sharp, a micron or an AMD flash */
+#define SM_FLASH_STATUS_DONE	0x80
+#define SM_FLASH_STATUS_ERR		0x38
+#define SM_FLASH_CMD_ERASE_CONFIRM	0xd0
+#define SM_FLASH_CMD_ERASE_SETUP	0x20
+#define SM_FLASH_CMD_RESET		0xff
+#define SM_FLASH_CMD_WRITE_SETUP	0x40
+#define SM_FLASH_CMD_CLEAR_STATUS	0x50
+#define SM_FLASH_CMD_READ_STATUS	0x70
 
 /* CHRP NVRAM header */
 struct chrp_header {
@@ -58,21 +71,95 @@
 static int nvram_mult, is_core_99;
 static int core99_bank = 0;
 static int nvram_partitions[3];
-
-/* FIXME: kmalloc fails to allocate the image now that I had to move it
- *        before time_init(). For now, I allocate a static buffer here
- *        but it's a waste of space on all but core99 machines
- */
-#if 0
-static char* nvram_image;
-#else
-static char nvram_image[NVRAM_SIZE] __pmacdata;
-#endif
+static spinlock_t nv_lock = SPIN_LOCK_UNLOCKED;
 
 extern int pmac_newworld;
 
-static u8 __openfirmware
-chrp_checksum(struct chrp_header* hdr)
+static int (*core99_write_bank)(int bank, u8* datas);
+static int (*core99_erase_bank)(int bank);
+
+static char *nvram_image __pmacdata;
+
+
+static unsigned char __pmac core99_nvram_read_byte(int addr)
+{
+	if (nvram_image == NULL)
+		return 0xff;
+	return nvram_image[addr];
+}
+
+static void __pmac core99_nvram_write_byte(int addr, unsigned char val)
+{
+	if (nvram_image == NULL)
+		return;
+	nvram_image[addr] = val;
+}
+
+
+static unsigned char __openfirmware direct_nvram_read_byte(int addr)
+{
+	return in_8(&nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult]);
+}
+
+static void __openfirmware direct_nvram_write_byte(int addr, unsigned char val)
+{
+	out_8(&nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult], val);
+}
+
+
+static unsigned char __pmac indirect_nvram_read_byte(int addr)
+{
+	unsigned char val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&nv_lock, flags);
+	out_8(nvram_addr, addr >> 5);
+	val = in_8(&nvram_data[(addr & 0x1f) << 4]);
+	spin_unlock_irqrestore(&nv_lock, flags);
+
+	return val;
+}
+
+static void __pmac indirect_nvram_write_byte(int addr, unsigned char val)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&nv_lock, flags);
+	out_8(nvram_addr, addr >> 5);
+	out_8(&nvram_data[(addr & 0x1f) << 4], val);
+	spin_unlock_irqrestore(&nv_lock, flags);
+}
+
+
+#ifdef CONFIG_ADB_PMU
+
+static unsigned char __pmac pmu_nvram_read_byte(int addr)
+{
+	struct adb_request req;
+
+	if (pmu_request(&req, NULL, 3, PMU_READ_NVRAM,
+			(addr >> 8) & 0xff, addr & 0xff))
+		return 0xff;
+	while (!req.complete)
+		pmu_poll();
+	return req.reply[0];
+}
+
+static void __pmac pmu_nvram_write_byte(int addr, unsigned char val)
+{
+	struct adb_request req;
+
+	if (pmu_request(&req, NULL, 4, PMU_WRITE_NVRAM,
+			(addr >> 8) & 0xff, addr & 0xff, val))
+		return;
+	while (!req.complete)
+		pmu_poll();
+}
+
+#endif /* CONFIG_ADB_PMU */
+
+
+static u8 __pmac chrp_checksum(struct chrp_header* hdr)
 {
 	u8 *ptr;
 	u16 sum = hdr->signature;
@@ -83,8 +170,7 @@
 	return sum;
 }
 
-static u32 __pmac
-core99_calc_adler(u8 *buffer)
+static u32 __pmac core99_calc_adler(u8 *buffer)
 {
 	int cnt;
 	u32 low, high;
@@ -106,86 +192,186 @@
 	return (high << 16) | low;
 }
 
-static u32 __pmac
-core99_check(u8* datas)
+static u32 __pmac core99_check(u8* datas)
 {
 	struct core99_header* hdr99 = (struct core99_header*)datas;
 
 	if (hdr99->hdr.signature != CORE99_SIGNATURE) {
-#ifdef DEBUG
-		printk("Invalid signature\n");
-#endif
+		DBG("Invalid signature\n");
 		return 0;
 	}
 	if (hdr99->hdr.cksum != chrp_checksum(&hdr99->hdr)) {
-#ifdef DEBUG
-		printk("Invalid checksum\n");
-#endif
+		DBG("Invalid checksum\n");
 		return 0;
 	}
 	if (hdr99->adler != core99_calc_adler(datas)) {
-#ifdef DEBUG
-		printk("Invalid adler\n");
-#endif
+		DBG("Invalid adler\n");
 		return 0;
 	}
 	return hdr99->generation;
 }
 
-static int __pmac
-core99_erase_bank(int bank)
+static int __pmac sm_erase_bank(int bank)
 {
 	int stat, i;
+	unsigned long timeout;
 
 	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
 
-	out_8(base, CORE99_FLASH_CMD_ERASE_SETUP);
-	out_8(base, CORE99_FLASH_CMD_ERASE_CONFIRM);
-	do { stat = in_8(base); }
-	while(!(stat & CORE99_FLASH_STATUS_DONE));
-	out_8(base, CORE99_FLASH_CMD_RESET);
-	if (stat & CORE99_FLASH_STATUS_ERR) {
-		printk("nvram: flash error 0x%02x on erase !\n", stat);
-		return -ENXIO;
+       	DBG("nvram: Sharp/Micron Erasing bank %d...\n", bank);
+
+	out_8(base, SM_FLASH_CMD_ERASE_SETUP);
+	out_8(base, SM_FLASH_CMD_ERASE_CONFIRM);
+	timeout = 0;
+	do {
+		if (++timeout > 1000000) {
+			printk(KERN_ERR "nvram: Sharp/Miron flash erase timeout !\n");
+			break;
 	}
+		out_8(base, SM_FLASH_CMD_READ_STATUS);
+		stat = in_8(base);
+	} while (!(stat & SM_FLASH_STATUS_DONE));
+
+	out_8(base, SM_FLASH_CMD_CLEAR_STATUS);
+	out_8(base, SM_FLASH_CMD_RESET);
+
 	for (i=0; i<NVRAM_SIZE; i++)
 		if (base[i] != 0xff) {
-			printk("nvram: flash erase failed !\n");
+			printk(KERN_ERR "nvram: Sharp/Micron flash erase failed !\n");
 			return -ENXIO;
 		}
 	return 0;
 }
 
-static int __pmac
-core99_write_bank(int bank, u8* datas)
+static int __pmac sm_write_bank(int bank, u8* datas)
 {
 	int i, stat = 0;
+	unsigned long timeout;
 
 	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
 
+       	DBG("nvram: Sharp/Micron Writing bank %d...\n", bank);
+
 	for (i=0; i<NVRAM_SIZE; i++) {
-		out_8(base+i, CORE99_FLASH_CMD_WRITE_SETUP);
+		out_8(base+i, SM_FLASH_CMD_WRITE_SETUP);
+		udelay(1);
 		out_8(base+i, datas[i]);
-		do { stat = in_8(base); }
-		while(!(stat & CORE99_FLASH_STATUS_DONE));
-		if (stat & CORE99_FLASH_STATUS_ERR)
+		timeout = 0;
+		do {
+			if (++timeout > 1000000) {
+				printk(KERN_ERR "nvram: Sharp/Micron flash write timeout !\n");
+				break;
+			}
+			out_8(base, SM_FLASH_CMD_READ_STATUS);
+			stat = in_8(base);
+		} while (!(stat & SM_FLASH_STATUS_DONE));
+		if (!(stat & SM_FLASH_STATUS_DONE))
 			break;
 	}
-	out_8(base, CORE99_FLASH_CMD_RESET);
-	if (stat & CORE99_FLASH_STATUS_ERR) {
-		printk("nvram: flash error 0x%02x on write !\n", stat);
+	out_8(base, SM_FLASH_CMD_CLEAR_STATUS);
+	out_8(base, SM_FLASH_CMD_RESET);
+	for (i=0; i<NVRAM_SIZE; i++)
+		if (base[i] != datas[i]) {
+			printk(KERN_ERR "nvram: Sharp/Micron flash write failed !\n");
+			return -ENXIO;
+		}
+	return 0;
+}
+
+static int __pmac amd_erase_bank(int bank)
+{
+	int i, stat = 0;
+	unsigned long timeout;
+
+	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
+
+       	DBG("nvram: AMD Erasing bank %d...\n", bank);
+
+	/* Unlock 1 */
+	out_8(base+0x555, 0xaa);
+	udelay(1);
+	/* Unlock 2 */
+	out_8(base+0x2aa, 0x55);
+	udelay(1);
+
+	/* Sector-Erase */
+	out_8(base+0x555, 0x80);
+	udelay(1);
+	out_8(base+0x555, 0xaa);
+	udelay(1);
+	out_8(base+0x2aa, 0x55);
+	udelay(1);
+	out_8(base, 0x30);
+	udelay(1);
+
+	timeout = 0;
+	do {
+		if (++timeout > 1000000) {
+			printk(KERN_ERR "nvram: AMD flash erase timeout !\n");
+			break;
+	}
+		stat = in_8(base) ^ in_8(base);
+	} while (stat != 0);
+	
+	/* Reset */
+	out_8(base, 0xf0);
+	udelay(1);
+	
+	for (i=0; i<NVRAM_SIZE; i++)
+		if (base[i] != 0xff) {
+			printk(KERN_ERR "nvram: AMD flash erase failed !\n");
 		return -ENXIO;
 	}
+	return 0;
+}
+
+static int __pmac amd_write_bank(int bank, u8* datas)
+{
+	int i, stat = 0;
+	unsigned long timeout;
+
+	u8* base = (u8 *)nvram_data + core99_bank*NVRAM_SIZE;
+
+       	DBG("nvram: AMD Writing bank %d...\n", bank);
+
+	for (i=0; i<NVRAM_SIZE; i++) {
+		/* Unlock 1 */
+		out_8(base+0x555, 0xaa);
+		udelay(1);
+		/* Unlock 2 */
+		out_8(base+0x2aa, 0x55);
+		udelay(1);
+
+		/* Write single word */
+		out_8(base+0x555, 0xa0);
+		udelay(1);
+		out_8(base+i, datas[i]);
+		
+		timeout = 0;
+		do {
+			if (++timeout > 1000000) {
+				printk(KERN_ERR "nvram: AMD flash write timeout !\n");
+				break;
+			}
+			stat = in_8(base) ^ in_8(base);
+		} while (stat != 0);
+		if (stat != 0)
+			break;
+	}
+
+	/* Reset */
+	out_8(base, 0xf0);
+	udelay(1);
+
 	for (i=0; i<NVRAM_SIZE; i++)
 		if (base[i] != datas[i]) {
-			printk("nvram: flash write failed !\n");
+			printk(KERN_ERR "nvram: AMD flash write failed !\n");
 			return -ENXIO;
 		}
 	return 0;
 }
 
-static void __init
-lookup_partitions(void)
+static void __init lookup_partitions(void)
 {
 	u8 buffer[17];
 	int i, offset;
@@ -215,15 +401,49 @@
 		nvram_partitions[pmac_nvram_XPRAM] = 0x1300;
 		nvram_partitions[pmac_nvram_NR] = 0x1400;
 	}
+	DBG("nvram: OF partition at 0x%x\n", nvram_partitions[pmac_nvram_OF]);
+	DBG("nvram: XP partition at 0x%x\n", nvram_partitions[pmac_nvram_XPRAM]);
+	DBG("nvram: NR partition at 0x%x\n", nvram_partitions[pmac_nvram_NR]);
+}
+
+void __pmac pmac_nvram_sync(void)
+{
+	struct core99_header* hdr99;
+	unsigned long flags;
+
+	if (!is_core_99 || !nvram_data || !nvram_image)
+		return;
+
+	spin_lock_irqsave(&nv_lock, flags);
+	if (!memcmp(nvram_image, (u8*)nvram_data + core99_bank*NVRAM_SIZE,
+		NVRAM_SIZE))
+		goto bail;
+
+	DBG("Updating nvram...\n");
+
+	hdr99 = (struct core99_header*)nvram_image;
+	hdr99->generation++;
+	hdr99->hdr.signature = CORE99_SIGNATURE;
+	hdr99->hdr.cksum = chrp_checksum(&hdr99->hdr);
+	hdr99->adler = core99_calc_adler(nvram_image);
+	core99_bank = core99_bank ? 0 : 1;
+	if (core99_erase_bank)
+		if (core99_erase_bank(core99_bank)) {
+			printk("nvram: Error erasing bank %d\n", core99_bank);
+			goto bail;
+		}
+	if (core99_write_bank)
+		if (core99_write_bank(core99_bank, nvram_image))
+			printk("nvram: Error writing bank %d\n", core99_bank);
+ bail:
+	spin_unlock_irqrestore(&nv_lock, flags);
+
 #ifdef DEBUG
-	printk("nvram: OF partition at 0x%x\n", nvram_partitions[pmac_nvram_OF]);
-	printk("nvram: XP partition at 0x%x\n", nvram_partitions[pmac_nvram_XPRAM]);
-	printk("nvram: NR partition at 0x%x\n", nvram_partitions[pmac_nvram_NR]);
+       	mdelay(2000);
 #endif
 }
 
-void __init
-pmac_nvram_init(void)
+void __init pmac_nvram_init(void)
 {
 	struct device_node *dp;
 
@@ -244,38 +464,65 @@
 			printk(KERN_ERR "nvram: no address\n");
 			return;
 		}
-#if 0
-		nvram_image = kmalloc(NVRAM_SIZE, GFP_KERNEL);
-		if (!nvram_image) {
-			printk(KERN_ERR "nvram: can't allocate image\n");
+		nvram_image = alloc_bootmem(NVRAM_SIZE);
+		if (nvram_image == NULL) {
+			printk(KERN_ERR "nvram: can't allocate ram image\n");
 			return;
 		}
-#endif
 		nvram_data = ioremap(dp->addrs[0].address, NVRAM_SIZE*2);
-#ifdef DEBUG
-		printk("nvram: Checking bank 0...\n");
-#endif
+		nvram_naddrs = 1; /* Make sure we get the correct case */
+
+		DBG("nvram: Checking bank 0...\n");
+
 		gen_bank0 = core99_check((u8 *)nvram_data);
 		gen_bank1 = core99_check((u8 *)nvram_data + NVRAM_SIZE);
 		core99_bank = (gen_bank0 < gen_bank1) ? 1 : 0;
-#ifdef DEBUG
-		printk("nvram: gen0=%d, gen1=%d\n", gen_bank0, gen_bank1);
-		printk("nvram: Active bank is: %d\n", core99_bank);
-#endif
+
+		DBG("nvram: gen0=%d, gen1=%d\n", gen_bank0, gen_bank1);
+		DBG("nvram: Active bank is: %d\n", core99_bank);
+
 		for (i=0; i<NVRAM_SIZE; i++)
 			nvram_image[i] = nvram_data[i + core99_bank*NVRAM_SIZE];
+
+		ppc_md.nvram_read_val	= core99_nvram_read_byte;
+		ppc_md.nvram_write_val	= core99_nvram_write_byte;
+
+		/* 
+		 * Maybe we could be smarter here though making an exclusive list
+		 * of known flash chips is a bit nasty as older OF didn't provide us
+		 * with a useful "compatible" entry. A solution would be to really
+		 * identify the chip using flash id commands and base ourselves on
+		 * a list of known chips IDs
+		 */
+		if (device_is_compatible(dp, "amd-0137")) {
+			core99_erase_bank = amd_erase_bank;
+			core99_write_bank = amd_write_bank;
+		} else {
+			core99_erase_bank = sm_erase_bank;
+			core99_write_bank = sm_write_bank;
+		}
 	} else if (_machine == _MACH_chrp && nvram_naddrs == 1) {
 		nvram_data = ioremap(dp->addrs[0].address + isa_mem_base,
 				     dp->addrs[0].size);
 		nvram_mult = 1;
+		ppc_md.nvram_read_val	= direct_nvram_read_byte;
+		ppc_md.nvram_write_val	= direct_nvram_write_byte;
 	} else if (nvram_naddrs == 1) {
 		nvram_data = ioremap(dp->addrs[0].address, dp->addrs[0].size);
 		nvram_mult = (dp->addrs[0].size + NVRAM_SIZE - 1) / NVRAM_SIZE;
+		ppc_md.nvram_read_val	= direct_nvram_read_byte;
+		ppc_md.nvram_write_val	= direct_nvram_write_byte;
 	} else if (nvram_naddrs == 2) {
 		nvram_addr = ioremap(dp->addrs[0].address, dp->addrs[0].size);
 		nvram_data = ioremap(dp->addrs[1].address, dp->addrs[1].size);
+		ppc_md.nvram_read_val	= indirect_nvram_read_byte;
+		ppc_md.nvram_write_val	= indirect_nvram_write_byte;
 	} else if (nvram_naddrs == 0 && sys_ctrler == SYS_CTRLER_PMU) {
+#ifdef CONFIG_ADB_PMU
 		nvram_naddrs = -1;
+		ppc_md.nvram_read_val	= pmu_nvram_read_byte;
+		ppc_md.nvram_write_val	= pmu_nvram_write_byte;
+#endif /* CONFIG_ADB_PMU */
 	} else {
 		printk(KERN_ERR "Don't know how to access NVRAM with %d addresses\n",
 		       nvram_naddrs);
@@ -283,117 +530,32 @@
 	lookup_partitions();
 }
 
-void __pmac
-pmac_nvram_update(void)
-{
-	struct core99_header* hdr99;
-
-	if (!is_core_99 || !nvram_data || !nvram_image)
-		return;
-	if (!memcmp(nvram_image, (u8*)nvram_data + core99_bank*NVRAM_SIZE,
-		NVRAM_SIZE))
-		return;
-#ifdef DEBUG
-	printk("Updating nvram...\n");
-#endif
-	hdr99 = (struct core99_header*)nvram_image;
-	hdr99->generation++;
-	hdr99->hdr.signature = CORE99_SIGNATURE;
-	hdr99->hdr.cksum = chrp_checksum(&hdr99->hdr);
-	hdr99->adler = core99_calc_adler(nvram_image);
-	core99_bank = core99_bank ? 0 : 1;
-	if (core99_erase_bank(core99_bank)) {
-		printk("nvram: Error erasing bank %d\n", core99_bank);
-		return;
-	}
-	if (core99_write_bank(core99_bank, nvram_image))
-		printk("nvram: Error writing bank %d\n", core99_bank);
-}
-
-unsigned char __openfirmware
-nvram_read_byte(int addr)
-{
-	switch (nvram_naddrs) {
-#ifdef CONFIG_ADB_PMU
-	case -1: {
-		struct adb_request req;
-
-		if (pmu_request(&req, NULL, 3, PMU_READ_NVRAM,
-				(addr >> 8) & 0xff, addr & 0xff))
-			break;
-		while (!req.complete)
-			pmu_poll();
-		return req.reply[0];
-	}
-#endif
-	case 1:
-		if (is_core_99)
-			return nvram_image[addr];
-		return nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult];
-	case 2:
-		*nvram_addr = addr >> 5;
-		eieio();
-		return nvram_data[(addr & 0x1f) << 4];
-	}
-	return 0;
-}
-
-void __openfirmware
-nvram_write_byte(unsigned char val, int addr)
-{
-	switch (nvram_naddrs) {
-#ifdef CONFIG_ADB_PMU
-	case -1: {
-		struct adb_request req;
-
-		if (pmu_request(&req, NULL, 4, PMU_WRITE_NVRAM,
-				(addr >> 8) & 0xff, addr & 0xff, val))
-			break;
-		while (!req.complete)
-			pmu_poll();
-		break;
-	}
-#endif
-	case 1:
-		if (is_core_99) {
-			nvram_image[addr] = val;
-			break;
-		}
-		nvram_data[(addr & (NVRAM_SIZE - 1)) * nvram_mult] = val;
-		break;
-	case 2:
-		*nvram_addr = addr >> 5;
-		eieio();
-		nvram_data[(addr & 0x1f) << 4] = val;
-		break;
-	}
-	eieio();
-}
-
-int __pmac
-pmac_get_partition(int partition)
+int __pmac pmac_get_partition(int partition)
 {
 	return nvram_partitions[partition];
 }
 
-u8 __pmac
-pmac_xpram_read(int xpaddr)
+u8 __pmac pmac_xpram_read(int xpaddr)
 {
 	int offset = nvram_partitions[pmac_nvram_XPRAM];
 
 	if (offset < 0)
-		return 0;
+		return 0xff;
 
-	return nvram_read_byte(xpaddr + offset);
+	return ppc_md.nvram_read_val(xpaddr + offset);
 }
 
-void __pmac
-pmac_xpram_write(int xpaddr, u8 data)
+void __pmac pmac_xpram_write(int xpaddr, u8 data)
 {
 	int offset = nvram_partitions[pmac_nvram_XPRAM];
 
 	if (offset < 0)
 		return;
 
-	nvram_write_byte(xpaddr + offset, data);
+	ppc_md.nvram_write_val(xpaddr + offset, data);
 }
+
+EXPORT_SYMBOL(pmac_get_partition);
+EXPORT_SYMBOL(pmac_nvram_sync);
+EXPORT_SYMBOL(pmac_xpram_read);
+EXPORT_SYMBOL(pmac_xpram_write);
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_pci.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_pci.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_pci.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_pci.c	2004-09-01 20:56:24.011468760 +0200
@@ -28,11 +28,14 @@
 
 #undef DEBUG
 
-static void add_bridges(struct device_node *dev);
+static void add_bridge(struct device_node *dev);
 
 /* XXX Could be per-controller, but I don't think we risk anything by
  * assuming we won't have both UniNorth and Bandit */
 static int has_uninorth;
+static struct pci_controller *u3_agp;
+
+struct pci_dev *k2_skiplist[2];
 
 /*
  * Magic constants for enabling cache coherency in the bandit/PSX bridge.
@@ -104,8 +107,27 @@
  * The "UniNorth" version is present in all Core99 machines
  * (iBook, G4, new IMacs, and all the recent Apple machines).
  * It contains 3 controllers in one ASIC.
+ *
+ * The U3 is the bridge used on G5 machines. It contains on
+ * AGP bus which is dealt with the old UniNorth access routines
+ * and an HyperTransport bus which uses its own set of access
+ * functions.
  */
 
+#define cfg_read(val, addr, type, op, op2)	\
+	*val = op((type)(addr))
+#define cfg_write(val, addr, type, op, op2)	\
+	op((type *)(addr), (val)); (void) op2((type *)(addr))
+
+#define cfg_read_bad(val, size)		*val = bad_##size;
+#define cfg_write_bad(val, size)
+
+#define bad_byte	0xff
+#define bad_word	0xffff
+#define bad_dword	0xffffffffU
+
+
+
 #define MACRISC_CFA0(devfn, off)	\
 	((1 << (unsigned long)PCI_SLOT(dev_fn)) \
 	| (((unsigned long)PCI_FUNC(dev_fn)) << 8) \
@@ -138,18 +160,6 @@
 	return (unsigned int)(hose->cfg_data) + (unsigned int)offset;
 }
 
-#define cfg_read(val, addr, type, op, op2)	\
-	*val = op((type)(addr))
-#define cfg_write(val, addr, type, op, op2)	\
-	op((type *)(addr), (val)); (void) op2((type *)(addr))
-
-#define cfg_read_bad(val, size)		*val = bad_##size;
-#define cfg_write_bad(val, size)
-
-#define bad_byte	0xff
-#define bad_word	0xffff
-#define bad_dword	0xffffffffU
-
 #define MACRISC_PCI_OP(rw, size, type, op, op2)				    \
 static int __pmac							    \
 macrisc_##rw##_config_##size(struct pci_dev *dev, int off, type val)	    \
@@ -231,6 +241,69 @@
 
 
 /*
+ * These versions of U3 HyperTransport config space access ops do not
+ * implement self-view of the HT host yet
+ */
+
+#define U3_HT_CFA0(devfn, off)		\
+		((((unsigned long)devfn) << 8) | offset)
+#define U3_HT_CFA1(bus, devfn, off)	\
+		(U3_HT_CFA0(devfn, off) \
+		+ (((unsigned long)bus) << 16) \
+		+ 0x01000000UL)
+
+static unsigned long __pmac
+u3_ht_cfg_addr(struct pci_controller* hose, u8 bus, u8 devfn, u8 offset)
+{
+	if (bus == hose->first_busno) {
+		/* For now, we don't self probe U3 HT bridge */
+		if (PCI_FUNC(devfn) != 0 || PCI_SLOT(devfn) > 7 ||
+		    PCI_SLOT(devfn) < 1)
+			return 0;
+		return ((unsigned long)hose->cfg_data) + U3_HT_CFA0(devfn, offset);
+	} else
+		return ((unsigned long)hose->cfg_data) + U3_HT_CFA1(bus, devfn, offset);
+}
+
+#define U3_HT_PCI_OP(rw, size, type, op, op2)				    \
+static int __pmac							    \
+u3_ht_##rw##_config_##size(struct pci_dev *dev, int off, type val)	    \
+{									    \
+	struct pci_controller *hose = dev->sysdata;			    \
+	unsigned long addr;						    \
+									    \
+	if (k2_skiplist[0] == dev || k2_skiplist[1] == dev) {               \
+		cfg_##rw##_bad(val, size);				    \
+		return PCIBIOS_SUCCESSFUL;				    \
+	}								    \
+	addr = u3_ht_cfg_addr(hose, dev->bus->number, dev->devfn, off);     \
+	if (!addr) {							    \
+		cfg_##rw##_bad(val, size)				    \
+		return PCIBIOS_DEVICE_NOT_FOUND;			    \
+	}								    \
+	cfg_##rw(val, addr, type, op, op2);				    \
+	return PCIBIOS_SUCCESSFUL;					    \
+}
+
+U3_HT_PCI_OP(read, byte, u8 *, in_8, x)
+U3_HT_PCI_OP(read, word, u16 *, in_le16, x)
+U3_HT_PCI_OP(read, dword, u32 *, in_le32, x)
+U3_HT_PCI_OP(write, byte, u8, out_8, in_8)
+U3_HT_PCI_OP(write, word, u16, out_le16, in_le16)
+U3_HT_PCI_OP(write, dword, u32, out_le32, in_le32)
+
+static struct pci_ops u3_ht_pci_ops =
+{
+	u3_ht_read_config_byte,
+	u3_ht_read_config_word,
+	u3_ht_read_config_dword,
+	u3_ht_write_config_byte,
+	u3_ht_write_config_word,
+	u3_ht_write_config_dword
+};
+
+
+/*
  * For a bandit bridge, turn on cache coherency if necessary.
  * N.B. we could clean this up using the hose ops directly.
  */
@@ -350,21 +423,44 @@
 		hose = pci_find_hose_for_OF_device(nec);
 		if (!hose)
 			continue;
-		printk("Found NEC PD720100A USB2 chip, enabling EHCI...\n");
 		early_read_config_dword(hose, bus, devfn, 0xe4, &data);
+		if (data & 1UL) {
+			printk("Found NEC PD720100A USB2 chip with disabled EHCI, fixing up...\n");
 		data &= ~1UL;
 		early_write_config_dword(hose, bus, devfn, 0xe4, data);
 		early_write_config_byte(hose, bus, devfn | 2, PCI_INTERRUPT_LINE,
 			nec->intrs[0].line);
 	}
 }
+}
 
 void __init
 pmac_find_bridges(void)
 {
-	add_bridges(find_devices("bandit"));
-	add_bridges(find_devices("chaos"));
-	add_bridges(find_devices("pci"));
+	struct device_node *np, *root;
+	struct device_node *ht = NULL;
+
+	root = find_path_device("/");
+	if (root == NULL) {
+		printk(KERN_CRIT "pmac_find_bridges: can't find root of device tree\n");
+		return;
+	}
+	for (np = root->child; np != NULL; np = np->sibling) {
+		if (np->name == NULL)
+			continue;
+		if (strcmp(np->name, "bandit") == 0
+		    || strcmp(np->name, "chaos") == 0
+		    || strcmp(np->name, "pci") == 0)
+			add_bridge(np);
+		if (strcmp(np->name, "ht") == 0)
+			ht = np;
+	}
+	/* Probe HT last as it relies on the agp resources to be already
+	 * setup
+	 */
+	if (ht)
+		add_bridge(ht);
+
 	init_p2pbridge();
 	fixup_nec_usb2();
 }
@@ -437,6 +533,108 @@
 		ioremap(addr->address + 0xc00000, 0x1000);
 }
 
+static void __init
+setup_u3_agp(struct pci_controller* hose, struct reg_property* addr)
+{
+	/* On G5, we move AGP up to high bus number so we don't need
+	 * to reassign bus numbers for HT. If we ever have P2P bridges
+	 * on AGP, we'll have to move pci_assign_all_busses to the
+	 * pci_controller structure so we enable it for AGP and not for
+	 * HT childs.
+	 * We hard code the address because of the different size of
+	 * the reg address cell, we shall fix that by killing struct
+	 * reg_property and using some accessor functions instead
+	 */
+       	hose->first_busno = 0xf0;
+	hose->last_busno = 0xff;
+	has_uninorth = 1;
+	hose->ops = &macrisc_pci_ops;
+	hose->cfg_addr = ioremap(0xf0000000 + 0x800000, 0x1000);
+	hose->cfg_data = ioremap(0xf0000000 + 0xc00000, 0x1000);
+
+	u3_agp = hose;
+}
+
+static void __init
+setup_u3_ht(struct pci_controller* hose, struct reg_property *addr)
+{
+	struct device_node *np = (struct device_node *)hose->arch_data;
+	int i, cur;
+
+	hose->ops = &u3_ht_pci_ops;
+
+	/* We hard code the address because of the different size of
+	 * the reg address cell, we shall fix that by killing struct
+	 * reg_property and using some accessor functions instead
+	 */
+	hose->cfg_data = (volatile unsigned char *)ioremap(0xf2000000, 0x02000000);
+
+	/*
+	 * /ht node doesn't expose a "ranges" property, so we "remove" regions that
+	 * have been allocated to AGP. So far, this version of the code doesn't assign
+	 * any of the 0xfxxxxxxx "fine" memory regions to /ht.
+	 * We need to fix that sooner or later by either parsing all child "ranges"
+	 * properties or figuring out the U3 address space decoding logic and
+	 * then read it's configuration register (if any).
+	 */
+	hose->io_base_phys = 0xf4000000 + 0x00400000;
+	hose->io_base_virt = ioremap(hose->io_base_phys, 0x00400000);
+	isa_io_base = (unsigned long) hose->io_base_virt;
+	hose->io_resource.name = np->full_name;
+	hose->io_resource.start = 0;
+	hose->io_resource.end = 0x003fffff;
+	hose->io_resource.flags = IORESOURCE_IO;
+	hose->pci_mem_offset = 0;
+	hose->first_busno = 0;
+	hose->last_busno = 0xef;
+	hose->mem_resources[0].name = np->full_name;
+	hose->mem_resources[0].start = 0x80000000;
+	hose->mem_resources[0].end = 0xefffffff;
+	hose->mem_resources[0].flags = IORESOURCE_MEM;
+
+	if (u3_agp == NULL) {
+		printk(KERN_INFO "U3 has no AGP, using full resource range\n");
+		return;
+	}
+
+	/* We "remove" the AGP resources from the resources allocated to HT, that
+	 * is we create "holes". However, that code does assumptions that so far
+	 * happen to be true (cross fingers...), typically that resources in the
+	 * AGP node are properly ordered
+	 */
+	cur = 0;
+	for (i=0; i<3; i++) {
+		struct resource *res = &u3_agp->mem_resources[i];
+		if (res->flags != IORESOURCE_MEM)
+			continue;
+		/* We don't care about "fine" resources */
+		if (res->start >= 0xf0000000)
+			continue;
+		/* Check if it's just a matter of "shrinking" us in one direction */
+		if (hose->mem_resources[cur].start == res->start) {
+			hose->mem_resources[cur].start = res->end + 1;
+			continue;
+		}
+		if (hose->mem_resources[cur].end == res->end) {
+			hose->mem_resources[cur].end = res->start - 1;
+			continue;
+		}
+		/* No, it's not the case, we need a hole */
+		if (cur == 2) {
+			/* not enough resources to make a hole, we drop part of the range */
+			printk(KERN_WARNING "Running out of resources for /ht host !\n");
+			hose->mem_resources[cur].end = res->start - 1;
+			continue;
+		}		
+		cur++;
+		hose->mem_resources[cur].name = np->full_name;
+		hose->mem_resources[cur].flags = IORESOURCE_MEM;
+		hose->mem_resources[cur].start = res->end + 1;
+		hose->mem_resources[cur].end = hose->mem_resources[cur-1].end;
+		hose->mem_resources[cur-1].end = res->start - 1;
+	}
+}
+
 void __init
 setup_grackle(struct pci_controller *hose)
 {
@@ -454,21 +652,20 @@
  * if we have one or more bandit or chaos bridges, we don't have a MPC106.
  */
 static void __init
-add_bridges(struct device_node *dev)
+add_bridge(struct device_node *dev)
 {
 	int len;
 	struct pci_controller *hose;
 	struct reg_property *addr;
 	char* disp_name;
 	int *bus_range;
-	int first = 1, primary;
+	int primary = 1;
 
-	for (; dev != NULL; dev = dev->next) {
 		addr = (struct reg_property *) get_property(dev, "reg", &len);
 		if (addr == NULL || len < sizeof(*addr)) {
 			printk(KERN_WARNING "Can't use %s: no address\n",
 			       dev->full_name);
-			continue;
+       		return;
 		}
 		bus_range = (int *) get_property(dev, "bus-range", &len);
 		if (bus_range == NULL || len < 2 * sizeof(int)) {
@@ -478,14 +675,21 @@
 
 		hose = pcibios_alloc_controller();
 		if (!hose)
-			continue;
+       		return;
 		hose->arch_data = dev;
 		hose->first_busno = bus_range ? bus_range[0] : 0;
 		hose->last_busno = bus_range ? bus_range[1] : 0xff;
 
 		disp_name = NULL;
-		primary = first;
-		if (device_is_compatible(dev, "uni-north")) {
+       	if (device_is_compatible(dev, "u3-agp")) {
+       		setup_u3_agp(hose, addr);
+       		disp_name = "U3-AGP";
+       		primary = 0;
+       	} else if (device_is_compatible(dev, "u3-ht")) {
+       		setup_u3_ht(hose, addr);
+       		disp_name = "U3-HT";
+       		primary = 1;
+       	} else if (device_is_compatible(dev, "uni-north")) {
 			primary = setup_uninorth(hose, addr);
 			disp_name = "UniNorth";
 		} else if (strcmp(dev->name, "pci") == 0) {
@@ -513,9 +717,6 @@
 
 		/* Fixup "bus-range" OF property */
 		fixup_bus_range(dev);
-
-		first &= !primary;
-	}
 }
 
 static void __init
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_pic.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_pic.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_pic.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_pic.c	2004-09-01 20:56:24.013468456 +0200
@@ -342,28 +342,69 @@
 pmac_pic_init(void)
 {
         int i;
-        struct device_node *irqctrler;
+        struct device_node *irqctrler = NULL;
+        struct device_node *irqctrler2 = NULL;
+        struct device_node *np;
         unsigned long addr;
 	int irq_cascade = -1;
 
 	/* We first try to detect Apple's new Core99 chipset, since mac-io
 	 * is quite different on those machines and contains an IBM MPIC2.
 	 */
-	irqctrler = find_type_devices("open-pic");
+	np = find_type_devices("open-pic");
+	while(np) {
+		if (np->parent && !strcmp(np->parent->name, "u3"))
+			irqctrler2 = np;
+		else
+			irqctrler = np;
+		np = np->next;
+	}
 	if (irqctrler != NULL)
 	{
-		printk("PowerMac using OpenPIC irq controller\n");
 		if (irqctrler->n_addrs > 0)
 		{
-			unsigned char senses[NR_IRQS];
+			unsigned char senses[128];
+
+			printk(KERN_INFO "PowerMac using OpenPIC irq controller at 0x%08x\n",
+			       irqctrler->addrs[0].address);
 
-			prom_get_irq_senses(senses, 0, NR_IRQS);
+			prom_get_irq_senses(senses, 0, 128);
 			OpenPIC_InitSenses = senses;
-			OpenPIC_NumInitSenses = NR_IRQS;
+			OpenPIC_NumInitSenses = 128;
 			ppc_md.get_irq = openpic_get_irq;
 			OpenPIC_Addr = ioremap(irqctrler->addrs[0].address,
 					       irqctrler->addrs[0].size);
 			openpic_init(0);
+
+			if (irqctrler2 != NULL && irqctrler2->n_intrs > 0 &&
+			    irqctrler2->n_addrs > 0) {
+				unsigned long u3 = (unsigned long)ioremap(0xf8000000, 0x1000);
+
+				printk(KERN_INFO "Slave OpenPIC at 0x%08x hooked on IRQ %d\n",
+				       irqctrler2->addrs[0].address,
+				       irqctrler2->intrs[0].line);
+
+				/* RAHHHH ! By default, MPIC in U3 seem to be disabled (vector priority
+				 * register is stuck to 0x80000000 on all sources). After dumping U3
+				 * registers in OSX, it appears that the magic is in register
+				 * 0xf80000e8 bits 0x00000006. Setting them enables the cell and it
+				 * just works ;) */
+				/* XXX FIXME: Move that to pmac_feature */
+				out_be32((volatile unsigned *)(u3 + 0xe0),
+					 in_be32((volatile unsigned *)(u3 + 0xe0)) | 0x6ul);
+				iounmap((void *)u3);
+
+				OpenPIC2_Addr = ioremap(irqctrler2->addrs[0].address,
+							irqctrler2->addrs[0].size);
+				prom_get_irq_senses(senses, PMAC_OPENPIC2_OFFSET,
+						    PMAC_OPENPIC2_OFFSET+128);
+				OpenPIC_InitSenses = senses;
+				OpenPIC_NumInitSenses = 128;
+				openpic2_init(PMAC_OPENPIC2_OFFSET);
+				openpic_hookup_cascade(irqctrler2->intrs[0].line,
+						       "U3 OpenPIC cascade",
+						       openpic2_get_irq);
+			}
 #ifdef CONFIG_XMON
 			{
 				struct device_node* pswitch;
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_setup.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_setup.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_setup.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_setup.c	2004-09-01 20:56:24.092456448 +0200
@@ -50,6 +50,7 @@
 #include <linux/seq_file.h>
 #include <linux/blkdev.h>
 #include <linux/genhd.h>
+#include <linux/cpufreq.h>
 
 #include <asm/processor.h>
 #include <asm/sections.h>
@@ -107,7 +108,6 @@
 			   char raw_mode);
 extern char pckbd_unexpected_up(unsigned char keycode);
 extern int keyboard_sends_linux_keycodes;
-extern void pmac_nvram_update(void);
 
 extern int pmac_pci_enable_device_hook(struct pci_dev *dev, int initial);
 extern void pmac_pcibios_after_init(void);
@@ -151,6 +151,16 @@
 	struct device_node *cpu_node;
 	int *fp, s;
 
+#ifdef CONFIG_CPU_FREQ_PMAC
+	if (_machine == _MACH_Pmac) {
+		extern unsigned int pmac_get_cur_cpufreq(void);
+		unsigned int freq = pmac_get_cur_cpufreq();
+		if (freq != 0) {
+			seq_printf(m, "clock\t\t: %dMHz\n", freq/1000);
+			return 0;
+		}
+	}
+#endif /* CONFIG_CPU_FREQ_PMAC */
 	cpu_node = find_type_devices("cpu");
 	if (!cpu_node)
 		return 0;
@@ -197,12 +207,27 @@
 			}
 			seq_printf(m, "\n");
 		}
+		pp = (char *) get_property(np, "scb#", &plen);
+		if (pp != NULL)
+			seq_printf(m, "board revision\t: %08x\n", *((int *)pp));
 	} else
 		seq_printf(m, "PowerMac\n");
 
 	/* print parsed model */
 	seq_printf(m, "detected as\t: %d (%s)\n", mbmodel, mbname);
 	seq_printf(m, "pmac flags\t: %08x\n", mbflags);
+#if 0
+{
+	extern long nap_return_count;
+	extern long nap_enter_count;
+	extern long nap_save_msscr0;
+	extern long dbg_nap_ret;
+	seq_printf(m, "nap_return_count: %d\n", nap_return_count);
+	seq_printf(m, "nap_enter_count\t: %d\n", nap_enter_count);
+	seq_printf(m, "nap_save_msscr0\t: %x\n", nap_save_msscr0);
+	seq_printf(m, "dbg_nap_ret\t: %x\n", dbg_nap_ret);
+}
+#endif
 
 	/* find l2 cache info */
 	np = find_devices("l2-cache");
@@ -309,6 +334,14 @@
 	sysctrl_regs = (volatile u32 *) ioremap(0xf8000000, 0x1000);
 	ohare_init();
 
+	/* Check & display some CPU config registers for diagnostic */
+	if (pvr == 0x8000 || pvr == 0x8001) { /* 745x */
+		printk(KERN_INFO "CPU MSCCR0 : 0x%08x\n", mfspr(SPRN_MSSCR0));
+		printk(KERN_INFO "CPU HID1   : 0x%08x\n", mfspr(SPRN_HID1));
+	}
+	if (pvr == 0x0008 || pvr == 0x7000) /* 750's */
+		printk(KERN_INFO "CPU HID1 : 0x%08x\n", mfspr(SPRN_HID1));
+
 	/* Lookup PCI hosts */
 	pmac_find_bridges();
 
@@ -329,6 +362,9 @@
 		}
 	}
 
+#if 0
+	printk("MSSCR0: %x\n", mfspr(SPRN_MSSCR0));
+#endif
 	if (ppc_override_l2cr)
 		printk(KERN_INFO "L2CR overriden (0x%x), backside cache is %s\n",
 			ppc_override_l2cr_value, (ppc_override_l2cr_value & 0x80000000)
@@ -372,7 +408,7 @@
 
 #ifdef CONFIG_SMP
 	/* Check for Core99 */
-	if (find_devices("uni-n"))
+	if (find_devices("uni-n") || find_devices("u3"))
 		ppc_md.smp_ops = &core99_smp_ops;
 	else
 		ppc_md.smp_ops = &psurge_smp_ops;
@@ -648,7 +684,7 @@
 #endif /* CONFIG_ADB_CUDA */
 
 #ifdef CONFIG_NVRAM
-	pmac_nvram_update();
+	pmac_nvram_sync();
 #endif
 
 	switch (sys_ctrler) {
@@ -677,7 +713,7 @@
 #endif /* CONFIG_ADB_CUDA */
 
 #ifdef CONFIG_NVRAM
-	pmac_nvram_update();
+	pmac_nvram_sync();
 #endif
 
 	switch (sys_ctrler) {
@@ -823,6 +859,12 @@
 #endif /* CONFIG_VT */
 }
 
+static int __pmac
+pmac_ide_reserved_hwifs(void)
+{
+	return 0;
+}
+
 void __init
 pmac_init(unsigned long r3, unsigned long r4, unsigned long r5,
 	  unsigned long r6, unsigned long r7)
@@ -864,6 +906,7 @@
 	select_adb_keyboard();
 
 #if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+        ppc_ide_md.reserved_hwifs	= pmac_ide_reserved_hwifs;
 #ifdef CONFIG_BLK_DEV_IDE_PMAC
         ppc_ide_md.ide_init_hwif	= pmac_ide_init_hwif_ports;
         ppc_ide_md.default_io_base	= pmac_ide_get_base;
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_sleep.S kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_sleep.S
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_sleep.S	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_sleep.S	2004-09-01 20:56:24.171444440 +0200
@@ -44,7 +44,7 @@
 	.text
 	.align	5
 
-#if defined(CONFIG_PMAC_PBOOK)
+#if defined(CONFIG_PMAC_PBOOK) || defined(CONFIG_CPU_FREQ_PMAC)
 
 /* This gets called by via-pmu.c late during the sleep process.
  * The PMU was already send the sleep command and will shut us down
@@ -52,6 +52,9 @@
  * vector that will be called by the ROM on wakeup
  */
 _GLOBAL(low_sleep_handler)
+#ifndef CONFIG_6xx
+	blr
+#else
 	mflr	r0
 	stw	r0,4(r1)
 	stwu	r1,-SL_SIZE(r1)
@@ -372,7 +375,7 @@
 	isync
 	rfi
 
-#endif /* defined(CONFIG_PMAC_PBOOK) */
+#endif /* defined(CONFIG_PMAC_PBOOK) || defined(CONFIG_CPU_FREQ) */
 
 	.data
 	.balign	L1_CACHE_LINE_SIZE
@@ -380,3 +383,5 @@
 	.long 0
 	.balign	L1_CACHE_LINE_SIZE, 0
 	.text
+
+#endif /* CONFIG_6xx */
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_smp.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_smp.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_smp.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_smp.c	2004-09-01 20:56:24.252432128 +0200
@@ -52,6 +52,7 @@
 #include <asm/time.h>
 #include <asm/open_pic.h>
 #include <asm/processor.h>
+#include <asm/keylargo.h>
 
 /*
  * Powersurge (old powermac SMP) support.
@@ -109,11 +110,17 @@
 /* what sort of powersurge board we have */
 static int psurge_type = PSURGE_NONE;
 
+/* L2 and L3 cache settings to pass from CPU0 to CPU1 */
 volatile static long int core99_l2_cache;
 volatile static long int core99_l3_cache;
 
-static void __init
-core99_init_caches(void)
+/* Timebase freeze GPIO */
+static int core99_tb_gpio = -1;
+
+/* Sync flag for HW tb sync */
+static volatile int sec_tb_reset = 0;
+
+static void __init core99_init_caches(void)
 {
 	int cpu = smp_processor_id();
 
@@ -183,8 +190,7 @@
  */
 static unsigned long psurge_smp_message[NR_CPUS];
 
-void __pmac
-psurge_smp_message_recv(struct pt_regs *regs)
+void __pmac psurge_smp_message_recv(struct pt_regs *regs)
 {
 	int cpu = smp_processor_id();
 	int msg;
@@ -201,14 +207,12 @@
 			smp_message_recv(msg, regs);
 }
 
-void __pmac
-psurge_primary_intr(int irq, void *d, struct pt_regs *regs)
+void __pmac psurge_primary_intr(int irq, void *d, struct pt_regs *regs)
 {
 	psurge_smp_message_recv(regs);
 }
 
-static void __pmac
-smp_psurge_message_pass(int target, int msg, unsigned long data, int wait)
+static void __pmac smp_psurge_message_pass(int target, int msg, unsigned long data, int wait)
 {
 	int i;
 
@@ -380,7 +384,6 @@
  */
 static void __init psurge_dual_sync_tb(int cpu_nr)
 {
-	static volatile int sec_tb_reset = 0;
 	int t;
 
 	set_dec(tb_ticks_per_jiffy);
@@ -403,8 +406,7 @@
 	smp_tb_synchronized = 1;
 }
 
-static void __init
-smp_psurge_setup_cpu(int cpu_nr)
+static void __init smp_psurge_setup_cpu(int cpu_nr)
 {
 
 	if (cpu_nr == 0) {
@@ -412,32 +414,42 @@
 		 * send it an IPI to start the timebase & DEC or we might
 		 * have them stuck.
 		 */
-		if (smp_num_cpus < 2)
-			goto sync_tb;
+		if (smp_num_cpus < 2) {
+			if (psurge_type == PSURGE_DUAL)
+				psurge_set_ipi(1);
+			return;
+		}
 		/* reset the entry point so if we get another intr we won't
 		 * try to startup again */
 		out_be32(psurge_start, 0x100);
 		if (request_irq(30, psurge_primary_intr, SA_INTERRUPT, "primary IPI", 0))
 			printk(KERN_ERR "Couldn't get primary IPI interrupt");
 	}
-sync_tb:
+
 	if (psurge_type == PSURGE_DUAL)
 		psurge_dual_sync_tb(cpu_nr);
 }
 
-static int __init
-smp_core99_probe(void)
+static int __init smp_core99_probe(void)
 {
 	struct device_node *cpus;
 	int i, ncpus = 1;
 	extern int powersave_nap;
+	u32 *tbprop;
 
 	if (ppc_md.progress) ppc_md.progress("smp_core99_probe", 0x345);
 	cpus = find_type_devices("cpu");
+	if (!machine_is_compatible("MacRISC4")) {
+		tbprop = (u32 *)get_property(cpus, "timebase-enable", NULL);
+		if (tbprop)
+			core99_tb_gpio = *tbprop;
+		else	
+			core99_tb_gpio = KL_GPIO_TB_ENABLE;
+	}
 	if (cpus)
 		while ((cpus = cpus->next) != NULL)
 			++ncpus;
-	printk("smp_core99_probe: found %d cpus\n", ncpus);
+
 	if (ncpus > 1) {
 		openpic_request_IPIs();
 		for (i = 1; i < ncpus; ++i)
@@ -452,8 +464,7 @@
 	return ncpus;
 }
 
-static void __init
-smp_core99_kick_cpu(int nr)
+static void __init smp_core99_kick_cpu(int nr)
 {
 	unsigned long save_vector, new_vector;
 	unsigned long flags;
@@ -507,8 +518,58 @@
 	if (ppc_md.progress) ppc_md.progress("smp_core99_kick_cpu done", 0x347);
 }
 
-static void __init
-smp_core99_setup_cpu(int cpu_nr)
+static void __init core99_dual_sync_tb(int cpu_nr)
+{
+	static volatile int sec_tb_reset = 0;
+	unsigned int t;
+
+	/* Some machines use a different mecanism */
+	if (core99_tb_gpio < 0)
+		return;
+
+	/* CPU 1 is enterred first, we stop the timebase by asserting a 0 on the
+	 * timebase-enable GPIO
+	 */
+	if (cpu_nr == 1) {
+		pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, core99_tb_gpio, 4);
+		pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, core99_tb_gpio, 0);
+		mb();
+	
+		set_dec(tb_ticks_per_jiffy);
+		set_tb(0, 0);
+		last_jiffy_stamp(cpu_nr) = 0;
+
+		mb();
+		sec_tb_reset = 1;
+		return;
+	}
+
+	/* We don't mess with the GPIO on machines with less than 2 CPUs,
+	 * as it can be used for other things, like firewire power on
+	 * laptops
+	 */
+	if (smp_num_cpus < 2)
+		return;
+
+	/* wait for the secondary to have reset its TB before proceeding */
+	for (t = 1000; t > 0 && !sec_tb_reset; --t)
+		udelay(1000);
+	if (t == 0)
+		printk(KERN_WARNING "Timeout waiting sync on second CPU\n");
+
+       	set_dec(tb_ticks_per_jiffy);
+	set_tb(0, 0);
+	last_jiffy_stamp(cpu_nr) = 0;
+	mb();
+
+	/* Now, restart the timebase by leaving the GPIO to an open collector */
+       	pmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, core99_tb_gpio, 0);
+        pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, core99_tb_gpio, 0);
+
+	smp_tb_synchronized = 1;
+}
+
+static void __init smp_core99_setup_cpu(int cpu_nr)
 {
 
 	/* Setup some critical registers
@@ -517,13 +578,19 @@
 	if (cpu_nr != 0)
 		core99_init_caches();
 
+	/* Sync timbases */
+	core99_dual_sync_tb(cpu_nr);
+
 	/* Setup openpic */
 	do_openpic_setup_cpu();
 
-	/* Setup L2/L3 */
-	if (cpu_nr == 0)
+	if (cpu_nr == 0) {
+		extern void g5_phy_disable_cpu1();
+		if (machine_is_compatible("MacRISC4") && smp_num_cpus < 2)
+			g5_phy_disable_cpu1();
 		if (ppc_md.progress) ppc_md.progress("core99_setup_cpu 0 done", 0x349);
 }
+}
 
 /* PowerSurge-style Macs */
 struct smp_ops_t psurge_smp_ops __pmacdata = {
diff -urN kernel-source-2.4.27/arch/ppc/platforms/pmac_time.c kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_time.c
--- kernel-source-2.4.27/arch/ppc/platforms/pmac_time.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/platforms/pmac_time.c	2004-09-01 20:56:24.253431976 +0200
@@ -167,7 +167,7 @@
 {
 	struct device_node *vias;
 	volatile unsigned char *via;
-	int count = VIA_TIMER_FREQ_6 / HZ;
+	int count = VIA_TIMER_FREQ_6 / 100;
 	unsigned int dstart, dend;
 
 	vias = find_devices("via-cuda");
@@ -197,7 +197,7 @@
 		;
 	dend = get_dec();
 
-	tb_ticks_per_jiffy = (dstart - dend) / 6;
+	tb_ticks_per_jiffy = (dstart - dend) / (6 * (HZ/100));
 	tb_to_us = mulhwu_scale_factor(dstart - dend, 60000);
 
 	printk(KERN_INFO "via_calibrate_decr: ticks per jiffy = %u (%u ticks)\n",
@@ -259,10 +259,20 @@
 	 * calibration. That's better since the VIA itself seems
 	 * to be slightly off. --BenH
 	 */
-	if (!machine_is_compatible("MacRISC2"))
+	if (!machine_is_compatible("MacRISC2") &&
+	    !machine_is_compatible("MacRISC3") &&
+	    !machine_is_compatible("MacRISC4"))
 		if (via_calibrate_decr())
 			return;
 
+	/* Special case: QuickSilver G4s seem to have a badly calibrated
+	 * timebase-frequency in OF, VIA is much better on these. We should
+	 * probably implement calibration based on the KL timer on these
+	 * machines anyway... -BenH
+	 */
+	if (machine_is_compatible("PowerMac3,5"))
+		if (via_calibrate_decr())
+			return;
 	/*
 	 * The cpu node should have a timebase-frequency property
 	 * to tell us the rate at which the decrementer counts.
@@ -278,4 +288,5 @@
 	       freq/1000000, freq%1000000);
 	tb_ticks_per_jiffy = freq / HZ;
 	tb_to_us = mulhwu_scale_factor(freq, 1000000);
+	printk("tb_to_us: %d\n", tb_to_us);
 }
diff -urN kernel-source-2.4.27/arch/ppc/xmon/start.c kernel-source-2.4.27-benh/arch/ppc/xmon/start.c
--- kernel-source-2.4.27/arch/ppc/xmon/start.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/xmon/start.c	2004-09-01 20:56:24.425405832 +0200
@@ -12,6 +12,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/sysrq.h>
+#include <linux/delay.h>
 #include <asm/prom.h>
 #include <asm/bootx.h>
 #include <asm/machdep.h>
@@ -28,12 +29,29 @@
 unsigned int TXRDY, RXRDY, DLAB;
 extern void xmon_printf(const char *fmt, ...);
 static int xmon_expect(const char *str, unsigned int timeout);
+extern char cmd_line[512];
 
 static int use_screen;
 static int via_modem;
 static int xmon_use_sccb;
 static struct device_node *channel_node;
 
+/* There are used when hooked via firewire */
+#ifdef CONFIG_XMON_FW
+volatile unsigned int xmon_fw_outbuf_size;
+volatile unsigned char xmon_fw_outbuf[1024];
+volatile unsigned int xmon_fw_oflags;
+volatile unsigned int xmon_fw_iflags;
+volatile unsigned int xmon_fw_idata;
+volatile unsigned int xmon_fw_kick;
+#define XMON_FW_FLAGS_OUT_ENTERED	0x00000001
+#define XMON_FW_FLAGS_OUT_DATA		0x00000002
+#define XMON_FW_FLAGS_OUT_ACK		0x00000004
+#define XMON_FW_FLAGS_IN_ATTACHED	0x00000001
+#define XMON_FW_FLAGS_IN_DATA		0x00000002
+#define XMON_FW_FLAGS_IN_ACK		0x00000004
+#endif
+
 #define TB_SPEED	25000000
 
 static inline unsigned int readtb(void)
@@ -112,7 +130,9 @@
 	volatile unsigned char *base;
 
 	use_screen = 0;
-
+	/* Typically used for firewire debugging */
+	if (strstr(cmd_line, "xmon_noio"))
+		return;
 	if (_machine == _MACH_Pmac) {
 		struct device_node *np;
 		unsigned long addr;
@@ -215,20 +235,21 @@
 	DLAB = 0x80;
 #endif /* platform */
 
+#ifdef CONFIG_MAGIC_SYSRQ
 	__sysrq_put_key_op('x', &sysrq_xmon_op);
+#endif	
 }
 
 static int scc_initialized = 0;
 
 void xmon_init_scc(void);
-extern void pmu_poll(void);
 extern void cuda_poll(void);
 
 static inline void do_poll_adb(void)
 {
 #ifdef CONFIG_ADB_PMU
 	if (sys_ctrler == SYS_CTRLER_PMU)
-		pmu_poll();
+		pmu_poll_adb();
 #endif /* CONFIG_ADB_PMU */
 #ifdef CONFIG_ADB_CUDA
 	if (sys_ctrler == SYS_CTRLER_CUDA)
@@ -236,6 +257,114 @@
 #endif /* CONFIG_ADB_CUDA */
 }
 
+#if 0
+static void
+bx_printf(const char* fmt, ...)
+{
+	static char dbgbuf[2048];
+	va_list ap;
+	int n;
+
+	va_start(ap, fmt);
+	n = vsprintf(dbgbuf, fmt, ap);
+	va_end(ap);
+	btext_drawstring(dbgbuf);
+}
+#endif
+
+#ifdef CONFIG_XMON_FW
+static int
+xmon_fw_write(void* ptr, int nb)
+{
+	char* p = (char *)ptr;
+	int c, i;
+
+	while (nb && (xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED)) {
+		c = (nb > 1024) ? 1024 : nb;
+		memcpy((void *)xmon_fw_outbuf, p, c);
+		xmon_fw_outbuf_size = c;
+		wmb();
+		xmon_fw_oflags |= XMON_FW_FLAGS_OUT_DATA;
+		wmb();
+		for (i=0; i<1000; i++) {
+			rmb();
+			if (xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK)
+				break;
+			mdelay(1);
+		}
+		xmon_fw_oflags &= ~XMON_FW_FLAGS_OUT_DATA;
+		wmb();
+		if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK) == 0) {
+			xmon_fw_iflags = 0;
+			break;
+		}
+		for (i=0; i<1000; i++) {
+			rmb();
+			if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK) == 0)
+				break;
+			mdelay(1);
+		}
+		if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_ACK) != 0) {
+			xmon_fw_iflags = 0;
+			break;
+		}
+		nb -= c;
+		p += c;
+	}
+	return (xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED) != 0;
+}
+
+static int
+xmon_fw_read(void* ptr, int nb)
+{
+	int t, on, i;
+	unsigned int k;
+	char c[3];
+	char* p = (char *)ptr;
+	
+	while (nb) {
+		t = 0;
+		on = 0;
+		while(xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED) {
+			if (xmon_fw_iflags & XMON_FW_FLAGS_IN_DATA)
+				break;
+			if (--t < 0) {
+				on = 1 - on;
+				c[0] = on? 0xdb: 0x20;
+				c[1] = '\b';
+				if (!xmon_fw_write(c, 2))
+					break;
+				t = 2000000;
+			}
+			rmb();
+		}
+		k = xmon_fw_idata & 0xff;
+		xmon_fw_oflags |= XMON_FW_FLAGS_OUT_ACK;
+		wmb();
+		for (i=0; i<1000; i++) {
+			rmb();
+			if ((xmon_fw_iflags & XMON_FW_FLAGS_IN_DATA) == 0)
+				break;
+			mdelay(1);
+		}
+		if (xmon_fw_iflags & XMON_FW_FLAGS_IN_DATA) {
+			xmon_fw_iflags = 0;
+			break;
+		}
+		xmon_fw_oflags &= ~XMON_FW_FLAGS_OUT_ACK;
+		wmb();
+		if (on) {
+			c[0] = 0x20; c[1] = '\b';
+			xmon_fw_write(c, 2);
+		}
+		*(p++) = k;
+		nb--;
+	}
+	return (xmon_fw_iflags & XMON_FW_FLAGS_IN_ATTACHED) != 0;
+}
+
+#endif /* CONFIG_XMON_FW */
+
 int
 xmon_write(void *handle, void *ptr, int nb)
 {
@@ -251,9 +380,17 @@
 		if (--lock_wait == 0)
 			break;
 #endif
-
+#ifdef CONFIG_XMON_FW
+	if (xmon_fw_write(ptr, nb))
+		goto out;
+#endif /* CONFIG_XMON_FW */
 #ifdef CONFIG_BOOTX_TEXT
-	if (use_screen) {
+#ifdef CONFIG_MORE_DEBUG
+	if (1)
+#else
+	if (use_screen)
+#endif
+	{
 		/* write it on the screen */
 		for (i = 0; i < nb; ++i)
 			btext_drawchar(*p++);
@@ -262,6 +399,9 @@
 #endif
 	if (!scc_initialized)
 		xmon_init_scc();
+	if (!sccd)
+		goto out;
+	
 	ct = 0;
 	for (i = 0; i < nb; ++i) {
 		while ((*sccc & TXRDY) == 0)
@@ -354,6 +494,10 @@
     char *p = ptr;
     int i;
 
+#ifdef CONFIG_XMON_FW
+	if (xmon_fw_read(ptr, nb))
+		return nb;
+#endif /* CONFIG_XMON_FW */		
 #ifdef CONFIG_BOOTX_TEXT
     if (use_screen) {
 	for (i = 0; i < nb; ++i)
@@ -363,6 +507,8 @@
 #endif
     if (!scc_initialized)
 	xmon_init_scc();
+    if (sccd == NULL)
+    	return 0;
     for (i = 0; i < nb; ++i) {
 	while ((*sccc & RXRDY) == 0)
 	    do_poll_adb();
@@ -385,7 +531,8 @@
 
 static unsigned char scc_inittab[] = {
     13, 0,		/* set baud rate divisor */
-    12, 1,
+//    12, 1,
+    12, 0,
     14, 1,		/* baud rate gen enable, src=rtxc */
     11, 0x50,		/* clocks = br gen */
     5,  0xea,		/* tx 8 bits, assert DTR & RTS */
@@ -396,6 +543,8 @@
 void
 xmon_init_scc()
 {
+	if (sccd == NULL && channel_node == NULL)
+		return;
 	if ( _machine == _MACH_chrp )
 	{
 		sccd[3] = 0x83; eieio();	/* LCR = 8N1 + DLAB */
@@ -634,11 +783,20 @@
 		pmu_suspend();
 	}
 #endif
+#ifdef CONFIG_XMON_FW
+	xmon_fw_oflags |= XMON_FW_FLAGS_OUT_ENTERED;
+	wmb();
+	xmon_fw_kick = 0;
+#endif /* CONFIG_XMON_FW */
 }
 
 void
 xmon_leave(void)
 {
+#ifdef CONFIG_XMON_FW
+	xmon_fw_oflags &= ~XMON_FW_FLAGS_OUT_ENTERED;
+	wmb();
+#endif /* CONFIG_XMON_FW */
 #ifdef CONFIG_ADB_PMU
 	if (_machine == _MACH_Pmac) {
 		pmu_resume();
diff -urN kernel-source-2.4.27/arch/ppc/xmon/xmon.c kernel-source-2.4.27-benh/arch/ppc/xmon/xmon.c
--- kernel-source-2.4.27/arch/ppc/xmon/xmon.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-benh/arch/ppc/xmon/xmon.c	2004-09-01 20:56:24.427405528 +0200
@@ -209,6 +209,7 @@
 #endif /* CONFIG_SMP */
 	remove_bpts();
 #ifdef CONFIG_PMAC_BACKLIGHT
+	if (_machine == _MACH_Pmac) {
 	if( setjmp(bus_error_jmp) == 0 ) {
 		debugger_fault_handler = handle_fault;
 		sync();
@@ -217,6 +218,7 @@
 		sync();
 	}
 	debugger_fault_handler = 0;
+	}
 #endif	/* CONFIG_PMAC_BACKLIGHT */
 	cmd = cmds(excp);
 	if (cmd == 's') {
diff -urN kernel-source-2.4.27/Documentation/Configure.help kernel-source-2.4.27-benh/Documentation/Configure.help
--- kernel-source-2.4.27/Documentation/Configure.help	2004-08-24 07:53:15.000000000 +0200
+++ kernel-source-2.4.27-benh/Documentation/Configure.help	2004-09-01 20:59:00.018752048 +0200
@@ -28610,6 +28610,30 @@
   hotplug firmware loading support, but a module built outside the kernel tree
   does.
 
+CPU Frequency scaling
+CONFIG_CPU_FREQ
+  Clock scaling allows you to change the clock speed of CPUs on the
+  fly. This is a nice method to save battery power on notebooks,
+  because the lower the clock speed, the less power the CPU consumes.
+
+  For more information, take a look at linux/Documentation/cpufreq or
+  at <http://www.brodo.de/cpufreq/>
+
+  If in doubt, say N.
+
+CONFIG_CPU_FREQ_24_API
+  This enables the /proc/sys/cpu/ sysctl interface for controlling
+  CPUFreq, as known from the 2.4.-kernel patches for CPUFreq. Note
+  that some drivers do not support this interface or offer less
+  functionality. 
+
+  If you say N here, you'll be able to control CPUFreq using the
+  new /proc/cpufreq interface.
+
+  For details, take a look at linux/Documentation/cpufreq. 
+
+  If in doubt, say N.
+
 NatSemi SCx200 support
 CONFIG_SCx200
   This provides basic support for the National Semiconductor SCx200
diff -urN kernel-source-2.4.27/Documentation/cpufreq kernel-source-2.4.27-benh/Documentation/cpufreq
--- kernel-source-2.4.27/Documentation/cpufreq	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/Documentation/cpufreq	2004-09-01 20:56:24.000000000 +0200
@@ -0,0 +1,361 @@
+     CPU frequency and voltage scaling code in the Linux(TM) kernel
+
+
+		         L i n u x    C P U F r e q
+
+
+
+
+		    Dominik Brodowski  <linux@brodo.de>
+		     David Kimdon <dwhedon@debian.org>
+
+
+
+   Clock scaling allows you to change the clock speed of the CPUs on the
+    fly. This is a nice method to save battery power, because the lower
+            the clock speed, the less power the CPU consumes.
+
+
+
+Contents:
+---------
+1.  Supported architectures
+2.  User interface
+2.1   /proc/cpufreq interface  [2.6]
+2.2.  /proc/sys/cpu/ interface [2.4]
+3.  CPUFreq core and interfaces
+3.1   General information
+3.2   CPUFreq notifiers
+3.3   CPUFreq architecture drivers
+4.  Mailing list and Links
+
+
+
+1. Supported architectures
+==========================
+
+ARM:
+    ARM Integrator, SA 1100, SA1110
+--------------------------------
+    This driver will be ported to new CPUFreq core soon, so
+    far it will not work.
+
+
+AMD Elan:
+    SC400, SC410
+--------------------------------
+    You need to specify the highest allowed CPU frequency as 
+    a module parameter ("max_freq") or as boot parameter 
+    ("elanfreq="). Else the available speed range will be 
+    limited to the speed at which the CPU runs while this
+    module is loaded.
+
+
+VIA Cyrix Longhaul:
+    VIA Samuel/CyrixIII, VIA Cyrix Samuel/C3, 
+    VIA Cyrix Ezra, VIA Cyrix Ezra-T
+--------------------------------
+    If you do not want to scale the Front Side Bus or voltage,
+    pass the module parameter "dont_scale_fsb 1" or
+    "dont_scale_voltage 1". Additionally, it is advised that
+    you pass the current Front Side Bus speed (in MHz) to 
+    this module as module parameter "current_fsb", e.g. 
+    "current_fsb 133" for a Front Side Bus speed of 133 MHz.
+
+
+Intel SpeedStep:
+    certain mobile Intel Pentium III (Coppermine), and all mobile
+    Intel Pentium III-M (Tualatin) and mobile Intel Pentium 4 P4-Ms.
+--------------------------------
+    Unfortunately only modern Intel ICH2-M and ICH3-M chipsets are 
+    supported.
+
+
+P4 CPU Clock Modulation:
+    Intel Pentium 4 Xeon processors
+---------------------------------
+    Note that you can only switch the speed of two logical CPUs at
+    once - but each phyiscal CPU may have different throttling levels.
+
+
+PowerNow! K6:
+    mobile AMD K6-2+ / mobile K6-3+:
+--------------------------------
+    No known issues.
+
+
+Transmeta Crusoe Longrun:
+    Transmeta Crusoe processors:
+--------------------------------
+    Does not work with the 2.4. /proc/sys/cpu/ interface.
+
+
+
+2. User Interface
+=================
+
+2.1   /proc/cpufreq interface [2.6]
+***********************************
+
+Starting in the patches for kernel 2.5.33, CPUFreq uses a "policy"
+interface /proc/cpufreq.
+
+When you "cat" this file, you'll find something like:
+
+--
+          minimum CPU frequency  -  maximum CPU frequency  -  policy
+CPU  0       1200000 ( 75%)      -     1600000 (100%)      -  performance
+--
+
+This means the current policy allows this CPU to be run anywhere
+between 1.2 GHz (the value is in kHz) and 1.6 GHz with an eye towards
+performance.
+
+To change the policy, "echo" the desired new policy into
+/proc/cpufreq. Use one of the following formats:
+
+cpu_nr:min_freq:max_freq:policy
+cpu_nr%min_freq%max_freq%policy
+min_freq:max_freq:policy
+min_freq%max_freq%policy
+
+with cpu_nr being the CPU which shall be affected, min_freq and
+max_freq the lower and upper limit of the CPU core frequency in kHz,
+and policy either "performance" or "powersave".
+A few examples:
+
+root@notebook:#echo -n "0:0:0:powersave" > /proc/cpufreq
+     sets the CPU #0 to the lowest supported frequency.
+
+root@notebook:#echo -n "1%100%100%performance" > /proc/cpufreq
+     sets the CPU #1 to the highest supported frequency.
+
+root@notebook:#echo -n "1000000:2000000:performance" > /proc/cpufreq
+     to set the frequency of all CPUs between 1 GHz and 2 GHz and to
+     the policy "performance".
+
+Please note that the values you "echo" into /proc/cpufreq are
+validated first, and may be limited by hardware or thermal
+considerations. Because of this, a read from /proc/cpufreq might 
+differ from what was written into it.
+
+
+When you read /proc/cpufreq for the first time after a CPUFreq driver
+has been initialized, you'll see the "default policy" for this
+driver. If this does not suit your needs, you can pass a boot
+parameter to the cpufreq core. Use the following syntax for this:
+   "cpufreq=min_freq:max_freq:policy", i.e. you may not chose a
+specific CPU and you need to specify the limits in kHz and not in
+per cent.
+
+
+2.2   /proc/cpufreq interface [2.4]
+***********************************
+
+Previsiously (and still available as a config option), CPUFreq used 
+a "sysctl" interface which is located in 
+	/proc/sys/cpu/0/
+	/proc/sys/cpu/1/ ...	(SMP only)
+
+In these directories, you will find three files of importance for
+CPUFreq: speed-max, speed-min and speed: 
+
+speed		    shows the current CPU frequency in kHz, 
+speed-min	    the minimum supported CPU frequency, and
+speed-max	    the maximum supported CPU frequency.
+
+
+To change the CPU frequency, "echo" the desired CPU frequency (in kHz)
+to speed. For example, to set the CPU speed to the lowest/highest
+allowed frequency do:
+
+root@notebook:# cat /proc/sys/cpu/0/speed-min > /proc/sys/cpu/0/speed
+root@notebook:# cat /proc/sys/cpu/0/speed-max > /proc/sys/cpu/0/speed
+
+
+
+3.  CPUFreq core and interfaces
+===============================
+
+3.1   General information
+*************************
+
+The CPUFreq core code is located in linux/kernel/cpufreq.c. This
+cpufreq code offers a standardized interface for the CPUFreq
+architecture drivers (those pieces of code that do actual
+frequency transitions), as well as to "notifiers". These are device
+drivers or other part of the kernel that need to be informed of
+policy changes (like thermal modules like ACPI) or of all
+frequency changes (like timing code) or even need to force certain
+speed limits (like LCD drivers on ARM architecture). Additionally, the
+kernel "constant" loops_per_jiffy is updated on frequency changes
+here.
+
+
+3.2   CPUFreq notifiers
+***********************
+
+CPUFreq notifiers conform to the standard kernel notifier interface.
+See linux/include/linux/notifier.h for details on notifiers.
+
+There are two different CPUFreq notifiers - policy notifiers and
+transition notifiers.
+
+
+3.2.1 CPUFreq policy notifiers
+******************************
+
+These are notified when a new policy is intended to be set. Each
+CPUFreq policy notifier is called three times for a policy transition:
+
+1.) During CPUFREQ_ADJUST all CPUFreq notifiers may change the limit if
+    they see a need for this - may it be thermal considerations or
+    hardware limitations.
+
+2.) During CPUFREQ_INCOMPATIBLE only changes may be done in order to avoid
+    hardware failure.
+
+3.) And during CPUFREQ_NOTIFY all notifiers are informed of the new policy
+   - if two hardware drivers failed to agree on a new policy before this
+   stage, the incompatible hardware shall be shut down, and the user
+   informed of this.
+
+The phase is specified in the second argument to the notifier.
+
+The third argument, a void *pointer, points to a struct cpufreq_policy
+consisting of five values: cpu, min, max, policy and max_cpu_freq. Min 
+and max are the lower and upper frequencies (in kHz) of the new
+policy, policy the new policy, cpu the number of the affected CPU or
+CPUFREQ_ALL_CPUS for all CPUs; and max_cpu_freq the maximum supported
+CPU frequency. This value is given for informational purposes only.
+
+
+3.2.2 CPUFreq transition notifiers
+**********************************
+
+These are notified twice when the CPUfreq driver switches the CPU core
+frequency and this change has any external implications.
+
+The second argument specifies the phase - CPUFREQ_PRECHANGE or
+CPUFREQ_POSTCHANGE.
+
+The third argument is a struct cpufreq_freqs with the following
+values:
+cpu	- number of the affected CPU or CPUFREQ_ALL_CPUS
+old	- old frequency
+new	- new frequency
+
+
+3.3   CPUFreq architecture drivers
+**********************************
+
+CPUFreq architecture drivers are the pieces of kernel code that
+actually perform CPU frequency transitions. These need to be
+initialized separately (separate initcalls), and may be
+modularized. They interact with the CPUFreq core in the following way:
+
+cpufreq_register()
+------------------
+cpufreq_register registers an arch driver to the CPUFreq core. Please
+note that only one arch driver may be registered at any time. -EBUSY
+is returned when an arch driver is already registered. The argument to
+cpufreq_register, struct cpufreq_driver *driver, is described later.
+
+cpufreq_unregister()
+--------------------
+cpufreq_unregister unregisters an arch driver, e.g. on module
+unloading. Please note that there is no check done that this is called
+from the driver which actually registered itself to the core, so
+please only call this function when you are sure the arch driver got
+registered correctly before.
+
+cpufreq_notify_transition()
+---------------------------
+On "dumb" hardware where only fixed frequency can be set, the driver
+must call cpufreq_notify_transition() once before, and once after the
+actual transition.
+
+struct cpufreq_driver
+---------------------
+On initialization, the arch driver is supposed to pass a pointer
+to a struct cpufreq_driver *cpufreq_driver consisting of the following
+entries:
+
+cpufreq_verify_t verify: This is a pointer to a function with the
+	following definition:
+	void verify_function (struct cpufreq_policy *policy).
+	This function must verify the new policy is within the limits
+	supported by the CPU, and at least one supported CPU is within
+	this range. It may be useful to use cpufreq.h /
+	cpufreq_verify_within_limits for this.
+
+cpufreq_setpolicy_t setpolicy: This is a pointer to a function with
+	the following definition:
+	void setpolicy_function (struct cpufreq_policy *policy).
+	This function must set the CPU to the new policy. If it is a
+	"dumb" CPU which only allows fixed frequencies to be set, it
+	shall set it to the lowest within the limit for
+	CPUFREQ_POLICY_POWERSAVE, and to the highest for
+	CPUFREQ_POLICY_PERFORMANCE. Once CONFIG_CPU_FREQ_DYNAMIC is
+	implemented, it can use a dynamic method to adjust the speed
+	between the lower and upper limit.
+
+struct cpufreq_policy   *policy: This is an array of NR_CPUS struct
+	cpufreq_policies, containing the current policies set for these
+	CPUs. Note that policy[0].max_cpu_freq must contain the
+	absolute maximum CPU frequency supported by _all_ CPUs.
+
+In case the driver is expected to run with the 2.4.-style API
+(/proc/sys/cpu/.../), two more values must be passed
+#ifdef CONFIG_CPU_FREQ_24_API
+	unsigned int            cpu_min_freq;
+	unsigned int            cpu_cur_freq[NR_CPUS];
+#endif
+	with cpu_min_freq being the minimum CPU frequency supported by
+	the CPUs; and the entries in cpu_cur_freq reflecting the
+	current speed of the appropriate CPU.
+
+Some Requirements to CPUFreq architecture drivers
+-------------------------------------------------
+* Only call cpufreq_register() when the ability to switch CPU
+  frequencies is _verified_ or can't be missing
+* cpufreq_unregister() may only be called if cpufreq_register() has
+  been successfully(!) called before.
+* kfree() the struct cpufreq_driver only after the call to 
+  cpufreq_unregister(), unless cpufreq_register() failed.
+* Be aware that there is currently no error management in the
+  setpolicy() code in the CPUFreq core. So only call yourself a
+  cpufreq_driver if you are really a working cpufreq_driver!
+
+
+
+4. Mailing list and Links
+*************************
+
+
+Mailing List
+------------
+There is a CPU frequency changing CVS commit and general list where
+you can report bugs, problems or submit patches. To post a message,
+send an email to cpufreq@www.linux.org.uk, to subscribe go to
+http://www.linux.org.uk/mailman/listinfo/cpufreq. Previous post to the
+mailing list are available to subscribers at
+http://www.linux.org.uk/mailman/private/cpufreq/.
+
+
+Links
+-----
+the FTP archives:
+* ftp://ftp.linux.org.uk/pub/linux/cpufreq/
+
+how to access the CVS repository:
+* http://cvs.arm.linux.org.uk/
+
+the CPUFreq Mailing list:
+* http://www.linux.org.uk/mailman/listinfo/cpufreq
+
+Clock and voltage scaling for the SA-1100:
+* http://www.lart.tudelft.nl/projects/scaling
+
+CPUFreq project homepage
+* http://www.brodo.de/cpufreq/
diff -urN kernel-source-2.4.27/Documentation/laptop-mode.sh kernel-source-2.4.27-benh/Documentation/laptop-mode.sh
--- kernel-source-2.4.27/Documentation/laptop-mode.sh	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/Documentation/laptop-mode.sh	2004-09-01 20:56:24.000000000 +0200
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# start of stop laptop mode, best run by a power management daemon when
+# ac gets connected/disconnected from a laptop
+#
+# FIXME: assumes HZ == 100
+
+# age time, in seconds. should be put into a sysconfig file
+MAX_AGE=600
+
+# kernel default dirty buffer age
+DEF_AGE=30
+DEF_UPDATE=5
+
+if [ ! -w /proc/sys/vm/laptop_mode ]; then
+	echo "Kernel is not patched with laptop_mode patch"
+	exit 1
+fi
+
+case "$1" in
+	start)
+		AGE=$((100*$MAX_AGE))
+		echo -n "Starting laptop mode"
+		echo "1" > /proc/sys/vm/laptop_mode
+		echo "30 500 0 0 $AGE $AGE 60 20 0" > /proc/sys/vm/bdflush
+		echo "."
+		;;
+	stop)
+		U_AGE=$((100*$DEF_UPDATE))
+		B_AGE=$((100*$DEF_AGE))
+		echo -n "Stopping laptop mode"
+		echo "0" > /proc/sys/vm/laptop_mode
+		echo "30 500 0 0 $U_AGE $B_AGE 60 20 0" > /proc/sys/vm/bdflush
+		echo "."
+		;;
+	*)
+		echo "$0 {start|stop}"
+		;;
+
+esac
+
+exit 0
diff -urN kernel-source-2.4.27/drivers/block/ll_rw_blk.c kernel-source-2.4.27-benh/drivers/block/ll_rw_blk.c
--- kernel-source-2.4.27/drivers/block/ll_rw_blk.c	2004-04-14 15:05:29.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/block/ll_rw_blk.c	2004-09-01 20:56:24.977321928 +0200
@@ -162,6 +162,12 @@
 	return i;
 }
 
+void blk_queue_activity_fn(request_queue_t *q, activity_fn *fn, void *data)
+{
+	q->activity_fn = fn;
+	q->activity_data = data;
+}
+
 /**
  * blk_cleanup_queue: - release a &request_queue_t when it is no longer needed
  * @q:    the request queue to be released
@@ -544,6 +550,7 @@
 	q->head_active    	= 1;
 
 	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
+	blk_queue_activity_fn(q, NULL, NULL);
 }
 
 #define blkdev_free_rq(list) list_entry((list)->next, struct request, queue);
@@ -859,6 +866,9 @@
 static inline void add_request(request_queue_t * q, struct request * req,
 			       struct list_head *insert_here)
 {
+	if (q->activity_fn)
+		q->activity_fn(q->activity_data, req->cmd);
+
 	drive_stat_acct(req->rq_dev, req->cmd, req->nr_sectors, 1);
 
 	if (!q->plugged && q->head_active && insert_here == &q->queue_head) {
@@ -1318,6 +1328,9 @@
 			kstat.pgpgin += count;
 			break;
 	}
+
+	if (block_dump)
+		printk("%s: %s block %lu/%u on %s\n", current->comm, rw == WRITE ? "WRITE" : "READ", bh->b_rsector, count, kdevname(bh->b_rdev));
 }
 
 /**
diff -urN kernel-source-2.4.27/drivers/char/agp/agpgart_be.c kernel-source-2.4.27-benh/drivers/char/agp/agpgart_be.c
--- kernel-source-2.4.27/drivers/char/agp/agpgart_be.c	2004-08-08 01:26:04.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/char/agp/agpgart_be.c	2004-09-01 20:56:25.226284080 +0200
@@ -52,6 +52,9 @@
 #ifdef CONFIG_X86
 #include <asm/msr.h>
 #endif
+#ifdef CONFIG_AGP_UNINORTH
+#include <asm/uninorth.h>
+#endif
 
 #include <linux/agp_backend.h>
 #include "agp.h"
@@ -81,7 +84,7 @@
 {
 #if defined(__i386__) || defined(__x86_64__)
 	asm volatile ("wbinvd":::"memory");
-#elif defined(__alpha__) || defined(__ia64__) || defined(__sparc__)
+#elif defined(__alpha__) || defined(__ia64__) || defined(__sparc__) || defined(__powerpc__)
 	/* ??? I wonder if we'll really need to flush caches, or if the
 	   core logic can manage to keep the system coherent.  The ARM
 	   speaks only of using `cflush' to get things in memory in
@@ -5924,6 +5927,404 @@
 }
 #endif /* CONFIG_AGP_ATI */
 
+#ifdef CONFIG_AGP_UNINORTH
+
+static int uninorth_fetch_size(void)
+{
+	int i;
+	u32 temp;
+	aper_size_info_32 *values;
+
+	pci_read_config_dword(agp_bridge.dev, UNI_N_CFG_GART_BASE, &temp);
+	temp &= ~(0xfffff000);
+	values = A_SIZE_32(agp_bridge.aperture_sizes);
+
+	for (i = 0; i < agp_bridge.num_aperture_sizes; i++) {
+		if (temp == values[i].size_value) {
+			agp_bridge.previous_size =
+			    agp_bridge.current_size = (void *) (values + i);
+			agp_bridge.aperture_size_idx = i;
+			return values[i].size;
+		}
+	}
+
+	agp_bridge.previous_size =
+	    agp_bridge.current_size = (void *) (values + 1);
+	agp_bridge.aperture_size_idx = 1;
+	return values[1].size;
+
+	return 0;
+}
+
+static void uninorth_tlbflush(agp_memory * mem)
+{
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			UNI_N_CFG_GART_ENABLE | UNI_N_CFG_GART_INVAL);
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			UNI_N_CFG_GART_ENABLE);
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			UNI_N_CFG_GART_ENABLE | UNI_N_CFG_GART_2xRESET);
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			UNI_N_CFG_GART_ENABLE);
+}
+
+static void uninorth_cleanup(void)
+{
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			UNI_N_CFG_GART_ENABLE | UNI_N_CFG_GART_INVAL);
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			0);
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			UNI_N_CFG_GART_2xRESET);
+	pci_write_config_dword(agp_bridge.dev, UNI_N_CFG_GART_CTRL,
+			0);
+}
+
+static int uninorth_configure(void)
+{
+	aper_size_info_32 *current_size;
+	
+	current_size = A_SIZE_32(agp_bridge.current_size);
+
+	printk("agp: configuring for size idx: %d\n", current_size->size_value);
+	
+	/* aperture size and gatt addr */
+	pci_write_config_dword(agp_bridge.dev,
+		UNI_N_CFG_GART_BASE,
+		(agp_bridge.gatt_bus_addr & 0xfffff000)
+			| current_size->size_value);
+
+	/* HACK ALERT
+	 * UniNorth seem to be buggy enough not to handle properly when
+	 * the AGP aperture isn't mapped at bus physical address 0
+	 */
+	agp_bridge.gart_bus_addr = 0;
+	pci_write_config_dword(agp_bridge.dev,
+		UNI_N_CFG_AGP_BASE, agp_bridge.gart_bus_addr);
+	
+	return 0;
+}
+
+static unsigned long uninorth_mask_memory(unsigned long addr, int type)
+{
+	return addr;/* | agp_bridge.masks[0].mask;*/
+}
+
+static int uninorth_insert_memory(agp_memory * mem,
+				     off_t pg_start, int type)
+{
+	int i, j, num_entries;
+	void *temp;
+
+	temp = agp_bridge.current_size;
+	num_entries = A_SIZE_32(temp)->num_entries;
+
+	if (type != 0 || mem->type != 0) {
+		/* The generic routines know nothing of memory types */
+		return -EINVAL;
+	}
+	if ((pg_start + mem->page_count) > num_entries) {
+		return -EINVAL;
+	}
+	j = pg_start;
+
+	while (j < (pg_start + mem->page_count)) {
+		if (!PGE_EMPTY(agp_bridge.gatt_table[j])) {
+			return -EBUSY;
+		}
+		j++;
+	}
+
+	if (mem->is_flushed == FALSE) {
+		CACHE_FLUSH();
+		mem->is_flushed = TRUE;
+	}
+	for (i = 0, j = pg_start; i < mem->page_count; i++, j++) {
+		agp_bridge.gatt_table[j] = cpu_to_le32((mem->memory[i] & 0xfffff000) | 0x00000001UL);
+		flush_dcache_range((unsigned long)__va(mem->memory[i]),
+				   (unsigned long)__va(mem->memory[i])+0x1000);
+	}
+	(void)in_le32((volatile u32*)&agp_bridge.gatt_table[pg_start]);
+	mb();
+	flush_dcache_range((unsigned long)&agp_bridge.gatt_table[pg_start], 
+		(unsigned long)&agp_bridge.gatt_table[pg_start + mem->page_count]);
+
+	agp_bridge.tlb_flush(mem);
+	return 0;
+}
+
+static void uninorth_agp_enable(u32 mode)
+{
+	struct pci_dev *device = NULL;
+	u32 command, scratch, cap_id;
+	u8 cap_ptr;
+
+	pci_read_config_dword(agp_bridge.dev,
+			      agp_bridge.capndx + 4,
+			      &command);
+
+	/*
+	 * PASS1: go throu all devices that claim to be
+	 *        AGP devices and collect their data.
+	 */
+
+	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
+					device)) != NULL) {
+		pci_read_config_dword(device, 0x04, &scratch);
+
+		if (!(scratch & 0x00100000))
+			continue;
+
+		pci_read_config_byte(device, 0x34, &cap_ptr);
+
+		if (cap_ptr != 0x00) {
+			do {
+				pci_read_config_dword(device,
+						      cap_ptr, &cap_id);
+
+				if ((cap_id & 0xff) != 0x02)
+					cap_ptr = (cap_id >> 8) & 0xff;
+			}
+			while (((cap_id & 0xff) != 0x02) && (cap_ptr != 0x00));
+		}
+		if (cap_ptr != 0x00) {
+			/*
+			 * Ok, here we have a AGP device. Disable impossible 
+			 * settings, and adjust the readqueue to the minimum.
+			 */
+
+			pci_read_config_dword(device, cap_ptr + 4, &scratch);
+
+			/* adjust RQ depth */
+			command =
+			    ((command & ~0xff000000) |
+			     min_t(u32, (mode & 0xff000000),
+				 min_t(u32, (command & 0xff000000),
+				     (scratch & 0xff000000))));
+
+			/* disable SBA if it's not supported */
+			if (!((command & 0x00000200) &&
+			      (scratch & 0x00000200) &&
+			      (mode & 0x00000200)))
+				command &= ~0x00000200;
+
+			/* disable FW if it's not supported */
+			if (!((command & 0x00000010) &&
+			      (scratch & 0x00000010) &&
+			      (mode & 0x00000010)))
+				command &= ~0x00000010;
+
+			if (!((command & 4) &&
+			      (scratch & 4) &&
+			      (mode & 4)))
+				command &= ~0x00000004;
+
+			if (!((command & 2) &&
+			      (scratch & 2) &&
+			      (mode & 2)))
+				command &= ~0x00000002;
+
+			if (!((command & 1) &&
+			      (scratch & 1) &&
+			      (mode & 1)))
+				command &= ~0x00000001;
+		}
+	}
+	/*
+	 * PASS2: Figure out the 4X/2X/1X setting and enable the
+	 *        target (our motherboard chipset).
+	 */
+
+	if (command & 4) {
+		command &= ~3;	/* 4X */
+	}
+	if (command & 2) {
+		command &= ~5;	/* 2X */
+	}
+	if (command & 1) {
+		command &= ~6;	/* 1X */
+	}
+	command |= 0x00000100;
+
+	uninorth_tlbflush(NULL);
+
+	do {
+		pci_write_config_dword(agp_bridge.dev,
+				       agp_bridge.capndx + 8,
+				       command);
+		pci_read_config_dword(agp_bridge.dev,
+				       agp_bridge.capndx + 8,
+				       &scratch);
+	} while((scratch & 0x100) == 0);
+
+	/*
+	 * PASS3: Go throu all AGP devices and update the
+	 *        command registers.
+	 */
+
+	while ((device = pci_find_class(PCI_CLASS_DISPLAY_VGA << 8,
+					device)) != NULL) {
+		pci_read_config_dword(device, 0x04, &scratch);
+
+		if (!(scratch & 0x00100000))
+			continue;
+
+		pci_read_config_byte(device, 0x34, &cap_ptr);
+
+		if (cap_ptr != 0x00) {
+			do {
+				pci_read_config_dword(device,
+						      cap_ptr, &cap_id);
+
+				if ((cap_id & 0xff) != 0x02)
+					cap_ptr = (cap_id >> 8) & 0xff;
+			}
+			while (((cap_id & 0xff) != 0x02) && (cap_ptr != 0x00));
+		}
+		if (cap_ptr != 0x00)
+			pci_write_config_dword(device, cap_ptr + 8, command);
+	}
+
+	uninorth_tlbflush(NULL);
+}
+
+static int uninorth_create_gatt_table(void)
+{
+	char *table;
+	char *table_end;
+	int size;
+	int page_order;
+	int num_entries;
+	int i;
+	void *temp;
+	struct page *page;
+
+	/* The generic routines can't handle 2 level gatt's */
+	if (agp_bridge.size_type == LVL2_APER_SIZE) {
+		return -EINVAL;
+	}
+
+	table = NULL;
+	i = agp_bridge.aperture_size_idx;
+	temp = agp_bridge.current_size;
+	size = page_order = num_entries = 0;
+
+	do {
+		size = A_SIZE_32(temp)->size;
+		page_order = A_SIZE_32(temp)->page_order;
+		num_entries = A_SIZE_32(temp)->num_entries;
+
+		table = (char *) __get_free_pages(GFP_KERNEL, page_order);
+
+		if (table == NULL) {
+			i++;
+			agp_bridge.current_size = A_IDX32();
+		} else {
+			agp_bridge.aperture_size_idx = i;
+		}
+	} while ((table == NULL) &&
+			 (i < agp_bridge.num_aperture_sizes));
+
+	if (table == NULL) {
+		return -ENOMEM;
+	}
+	table_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);
+
+	for (page = virt_to_page(table); page <= virt_to_page(table_end); page++)
+		SetPageReserved(page);
+
+	agp_bridge.gatt_table_real = (u32 *) table;
+	agp_bridge.gatt_table = (u32 *)table;
+	agp_bridge.gatt_bus_addr = virt_to_phys(table);
+
+	for (i = 0; i < num_entries; i++)
+		agp_bridge.gatt_table[i] = (u32) agp_bridge.scratch_page;
+
+	flush_dcache_range((unsigned long)table, (unsigned long)table_end);
+
+	return 0;
+}
+
+static int uninorth_free_gatt_table(void)
+{
+	int page_order;
+	char *table, *table_end;
+	void *temp;
+	struct page *page;
+
+	temp = agp_bridge.current_size;
+	page_order = A_SIZE_32(temp)->page_order;
+
+	/* Do not worry about freeing memory, because if this is
+	 * called, then all agp memory is deallocated and removed
+	 * from the table.
+	 */
+
+	table = (char *) agp_bridge.gatt_table_real;
+	table_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);
+
+	for (page = virt_to_page(table); page <= virt_to_page(table_end); page++)
+		ClearPageReserved(page);
+
+	free_pages((unsigned long) agp_bridge.gatt_table_real, page_order);
+
+	return 0;
+}
+
+
+/* Setup function */
+static gatt_mask uninorth_masks[] =
+{
+	{0x00000000, 0}
+};
+
+static aper_size_info_32 uninorth_sizes[7] =
+{
+#if 0 /* Not sure uninorth supports that high aperture sizes */
+	{256, 65536, 6, 64},
+	{128, 32768, 5, 32},
+	{64, 16384, 4, 16},
+#endif	
+	{32, 8192, 3, 8},
+	{16, 4096, 2, 4},
+	{8, 2048, 1, 2},
+	{4, 1024, 0, 1}
+};
+
+static int __init uninorth_setup (struct pci_dev *pdev)
+{
+	agp_bridge.masks = uninorth_masks;
+	agp_bridge.aperture_sizes = (void *)uninorth_sizes;
+	agp_bridge.size_type = U32_APER_SIZE;
+	agp_bridge.num_aperture_sizes = 4; //7;
+	agp_bridge.dev_private_data = NULL;
+	agp_bridge.needs_scratch_page = FALSE;
+	agp_bridge.configure = uninorth_configure;
+	agp_bridge.fetch_size = uninorth_fetch_size;
+	agp_bridge.cleanup = uninorth_cleanup;
+	agp_bridge.tlb_flush = uninorth_tlbflush;
+	agp_bridge.mask_memory = uninorth_mask_memory;
+	agp_bridge.agp_enable = uninorth_agp_enable;
+	agp_bridge.cache_flush = global_cache_flush;
+	agp_bridge.create_gatt_table = uninorth_create_gatt_table;
+	agp_bridge.free_gatt_table = uninorth_free_gatt_table;
+	agp_bridge.insert_memory = uninorth_insert_memory;
+	agp_bridge.remove_memory = agp_generic_remove_memory;
+	agp_bridge.alloc_by_type = agp_generic_alloc_by_type;
+	agp_bridge.free_by_type = agp_generic_free_by_type;
+	agp_bridge.agp_alloc_page = agp_generic_alloc_page;
+	agp_bridge.agp_destroy_page = agp_generic_destroy_page;
+	agp_bridge.suspend = agp_generic_suspend;
+	agp_bridge.resume = agp_generic_resume;
+	agp_bridge.cant_use_aperture = 1;
+
+	return 0;
+	
+	(void) pdev; /* unused */
+}
+
+#endif /* CONFIG_AGP_UNINORTH */
+
 /* per-chipset initialization data.
  * note -- all chipsets for a single vendor MUST be grouped together
  */
@@ -6442,6 +6843,12 @@
 	  "ATI",
 	  "IGP330/340/345/350/M",
 	  ati_generic_setup },
+	{ PCI_DEVICE_ID_ATI_RS200_B,
+	  PCI_VENDOR_ID_ATI,
+	  ATI_RS200,
+	  "ATI",
+	  "IGP330/340/345/350/M",
+	  ati_generic_setup },
 	{ PCI_DEVICE_ID_ATI_RS250,
 	  PCI_VENDOR_ID_ATI,
 	  ATI_RS250,
@@ -6474,6 +6881,33 @@
 	  ati_generic_setup },
 #endif /* CONFIG_AGP_ATI */
 
+#ifdef CONFIG_AGP_UNINORTH
+	{ PCI_DEVICE_ID_APPLE_UNI_N_AGP,
+		PCI_VENDOR_ID_APPLE,
+		APPLE_UNINORTH,
+		"Apple",
+		"UniNorth",
+		uninorth_setup },
+	{ PCI_DEVICE_ID_APPLE_UNI_N_AGP_P,
+		PCI_VENDOR_ID_APPLE,
+		APPLE_UNINORTH,
+		"Apple",
+		"UniNorth/Pangea",
+		uninorth_setup },
+	{ PCI_DEVICE_ID_APPLE_UNI_N_AGP15,
+		PCI_VENDOR_ID_APPLE,
+		APPLE_UNINORTH,
+		"Apple",
+		"UniNorth 1.5",
+		uninorth_setup },
+	{ PCI_DEVICE_ID_APPLE_UNI_N_AGP2,
+		PCI_VENDOR_ID_APPLE,
+		APPLE_UNINORTH,
+		"Apple",
+		"UniNorth 2",
+		uninorth_setup },
+#endif /* CONFIG_AGP_UNINORTH */
+
 	{ 0, }, /* dummy final entry, always present */
 };
 
diff -urN kernel-source-2.4.27/drivers/char/Config.in kernel-source-2.4.27-benh/drivers/char/Config.in
--- kernel-source-2.4.27/drivers/char/Config.in	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/char/Config.in	2004-09-01 20:56:25.228283776 +0200
@@ -367,6 +367,7 @@
       bool '  HP ZX1 AGP support' CONFIG_AGP_HP_ZX1
    fi
    bool '  ATI IGP chipset support' CONFIG_AGP_ATI
+   dep_bool '  Apple UniNorth support' CONFIG_AGP_UNINORTH $CONFIG_ALL_PPC
 fi
 
 mainmenu_option next_comment
diff -urN kernel-source-2.4.27/drivers/i2c/i2c-keywest.c kernel-source-2.4.27-benh/drivers/i2c/i2c-keywest.c
--- kernel-source-2.4.27/drivers/i2c/i2c-keywest.c	2004-02-18 14:36:31.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/i2c/i2c-keywest.c	2004-09-01 20:56:25.386259760 +0200
@@ -26,6 +26,7 @@
     2001/12/13 BenH	New implementation
     2001/12/15 BenH	Add support for "byte" and "quick"
                         transfers. Add i2c_xfer routine.
+    2003/09/21 BenH	Rework state machine with Paulus help
 
     My understanding of the various modes supported by keywest are:
 
@@ -64,11 +65,28 @@
 
 #include "i2c-keywest.h"
 
+#undef POLLED_MODE
+
 #define DBG(x...) do {\
 	if (debug > 0) \
 		printk(KERN_DEBUG "KW:" x); \
 	} while(0)
 
+#define WRONG_STATE(name) do {\
+	if (debug > 0) \
+		printk(KERN_DEBUG "KW: wrong state. Got %s, state: %s (isr: %02x)\n", \
+		       name, __kw_state_names[iface->state], isr); \
+	} while(0)
+
+static const char *__kw_state_names[] = {
+	"state_idle",
+	"state_addr",
+	"state_read",
+	"state_write",
+	"state_stop",
+	"state_dead"
+};
+
 
 MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
 MODULE_DESCRIPTION("I2C driver for Apple's Keywest");
@@ -82,140 +100,174 @@
 
 static struct keywest_iface *ifaces = NULL;
 
+#ifdef POLLED_MODE
+/* Don't schedule, the g5 fan controller is too
+ * timing sensitive
+ */
+static u8
+wait_interrupt(struct keywest_iface* iface)
+{
+	int i;
+	u8 isr;
+	
+	for (i = 0; i < 200000; i++) {
+		isr = read_reg(reg_isr) & KW_I2C_IRQ_MASK;
+		if (isr != 0)
+			return isr;
+		udelay(1);
+	}
+	return isr;
+}
+#endif /* POLLED_MODE */
 
 static void
 do_stop(struct keywest_iface* iface, int result)
 {
-	write_reg(reg_control, read_reg(reg_control) | KW_I2C_CTL_STOP);
+	write_reg(reg_control, KW_I2C_CTL_STOP);
 	iface->state = state_stop;
 	iface->result = result;
 }
 
 /* Main state machine for standard & standard sub mode */
-static int
+static void
 handle_interrupt(struct keywest_iface *iface, u8 isr)
 {
 	int ack;
-	int rearm_timer = 1;
 	
-	DBG("handle_interrupt(), got: %x, status: %x, state: %d\n",
-		isr, read_reg(reg_status), iface->state);
-	if (isr == 0 && iface->state != state_stop) {
-		do_stop(iface, -1);
-		return rearm_timer;
-	}
-	if (isr & KW_I2C_IRQ_STOP && iface->state != state_stop) {
-		iface->result = -1;
-		iface->state = state_stop;
-	}
-	switch(iface->state) {
-	case state_addr:
-		if (!(isr & KW_I2C_IRQ_ADDR)) {
-			do_stop(iface, -1);
-			break;
+	if (isr == 0) {
+		if (iface->state != state_stop) {
+			DBG("KW: Timeout !\n");
+			do_stop(iface, -EIO);
+	}
+		if (iface->state == state_stop) {
+			ack = read_reg(reg_status);
+			if (!(ack & KW_I2C_STAT_BUSY)) {
+				iface->state = state_idle;
+				write_reg(reg_ier, 0x00);
+#ifndef POLLED_MODE
+				complete(&iface->complete);
+#endif /* POLLED_MODE */
+	}
 		}
+		return;
+	}
+
+	if (isr & KW_I2C_IRQ_ADDR) {
 		ack = read_reg(reg_status);
-		DBG("ack on set address: %x\n", ack);
-		if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {
-			do_stop(iface, -1);
-			break;
+		if (iface->state != state_addr) {
+			write_reg(reg_isr, KW_I2C_IRQ_ADDR);
+			WRONG_STATE("KW_I2C_IRQ_ADDR"); 
+			do_stop(iface, -EIO);
+			return;
 		}
+		if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {
+			iface->state = state_stop;		     
+			iface->result = -ENODEV;
+			DBG("KW: NAK on address\n");
+		} else {
 		/* Handle rw "quick" mode */
-		if (iface->datalen == 0)
+			if (iface->datalen == 0) {
 			do_stop(iface, 0);
-		else if (iface->read_write == I2C_SMBUS_READ) {
+			} else if (iface->read_write == I2C_SMBUS_READ) {
 			iface->state = state_read;
 			if (iface->datalen > 1)
-				write_reg(reg_control, read_reg(reg_control)
-					| KW_I2C_CTL_AAK);
+					write_reg(reg_control, KW_I2C_CTL_AAK);
 		} else {
 			iface->state = state_write;
-			DBG("write byte: %x\n", *(iface->data));
 			write_reg(reg_data, *(iface->data++));
 			iface->datalen--;
 		}
-		
-		break;
-	case state_read:
-		if (!(isr & KW_I2C_IRQ_DATA)) {
-			do_stop(iface, -1);
-			break;
 		}
+		write_reg(reg_isr, KW_I2C_IRQ_ADDR);
+	}
+
+	if (isr & KW_I2C_IRQ_DATA) {
+		if (iface->state == state_read) {
 		*(iface->data++) = read_reg(reg_data);
-		DBG("read byte: %x\n", *(iface->data-1));
+			write_reg(reg_isr, KW_I2C_IRQ_DATA);
 		iface->datalen--;
 		if (iface->datalen == 0)
 			iface->state = state_stop;
-		else
+			else if (iface->datalen == 1)
 			write_reg(reg_control, 0);
-		break;
-	case state_write:
-		if (!(isr & KW_I2C_IRQ_DATA)) {
-			do_stop(iface, -1);
-			break;
-		}
+		} else if (iface->state == state_write) {
 		/* Check ack status */
 		ack = read_reg(reg_status);
-		DBG("ack on data write: %x\n", ack);
 		if ((ack & KW_I2C_STAT_LAST_AAK) == 0) {
-			do_stop(iface, -1);
-			break;
-		}
-		if (iface->datalen) {
-			DBG("write byte: %x\n", *(iface->data));
+				DBG("KW: nack on data write (%x): %x\n",
+				    iface->data[-1], ack);
+				do_stop(iface, -EIO);
+			} else if (iface->datalen) {
 			write_reg(reg_data, *(iface->data++));
 			iface->datalen--;
-		} else
-			do_stop(iface, 0);
-		break;
+			} else {
+				write_reg(reg_control, KW_I2C_CTL_STOP);
+				iface->state = state_stop;
+				iface->result = 0;
+			}
+			write_reg(reg_isr, KW_I2C_IRQ_DATA);
+		} else {
+			write_reg(reg_isr, KW_I2C_IRQ_DATA);
+			WRONG_STATE("KW_I2C_IRQ_DATA"); 
+			if (iface->state != state_stop)
+				do_stop(iface, -EIO);
+		}
+	}
 		
-	case state_stop:
-		if (!(isr & KW_I2C_IRQ_STOP) && (++iface->stopretry) < 10)
-			do_stop(iface, -1);
-		else {
-			rearm_timer = 0;
+	if (isr & KW_I2C_IRQ_STOP) {
+		write_reg(reg_isr, KW_I2C_IRQ_STOP);
+		if (iface->state != state_stop) {
+			WRONG_STATE("KW_I2C_IRQ_STOP");
+			iface->result = -EIO;
+		}
 			iface->state = state_idle;
-			write_reg(reg_control, 0x00);
 			write_reg(reg_ier, 0x00);
+#ifndef POLLED_MODE
 			complete(&iface->complete);
-		}
-		break;
+#endif /* POLLED_MODE */			
 	}
 	
-	write_reg(reg_isr, isr);
-
-	return rearm_timer;
+	if (isr & KW_I2C_IRQ_START)
+		write_reg(reg_isr, KW_I2C_IRQ_START);
 }
 
+#ifndef POLLED_MODE
+
 /* Interrupt handler */
 static void
 keywest_irq(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct keywest_iface *iface = (struct keywest_iface *)dev_id;
+	unsigned long flags;
 
-	spin_lock(&iface->lock);
+	spin_lock_irqsave(&iface->lock, flags);
 	del_timer(&iface->timeout_timer);
-	if (handle_interrupt(iface, read_reg(reg_isr))) {
+	handle_interrupt(iface, read_reg(reg_isr));
+	if (iface->state != state_idle) {
 		iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
 		add_timer(&iface->timeout_timer);
 	}
-	spin_unlock(&iface->lock);
+	spin_unlock_irqrestore(&iface->lock, flags);
 }
 
 static void
 keywest_timeout(unsigned long data)
 {
 	struct keywest_iface *iface = (struct keywest_iface *)data;
+	unsigned long flags;
 
 	DBG("timeout !\n");
-	spin_lock_irq(&iface->lock);
-	if (handle_interrupt(iface, read_reg(reg_isr))) {
+	spin_lock_irqsave(&iface->lock, flags);
+	handle_interrupt(iface, read_reg(reg_isr));
+	if (iface->state != state_idle) {
 		iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
 		add_timer(&iface->timeout_timer);
 	}
-	spin_unlock(&iface->lock);
+	spin_unlock_irqrestore(&iface->lock, flags);
 }
 
+#endif /* POLLED_MODE */
+
 /*
  * SMBUS-type transfer entrypoint
  */
@@ -271,25 +323,32 @@
 	    	return -1;
 	}
 
+	/* Turn a standardsub read into a combined mode access */
+ 	if (read_write == I2C_SMBUS_READ
+ 	    && (iface->cur_mode & KW_I2C_MODE_MODE_MASK) == KW_I2C_MODE_STANDARDSUB) {
+ 		iface->cur_mode &= ~KW_I2C_MODE_MODE_MASK;
+ 		iface->cur_mode |= KW_I2C_MODE_COMBINED;
+ 	}
+
 	/* Original driver had this limitation */
 	if (len > 32)
 		len = 32;
 
 	down(&iface->sem);
 
-	DBG("chan: %d, addr: 0x%x, transfer len: %d, read: %d\n",
-		chan->chan_no, addr, len, read_write == I2C_SMBUS_READ);
+	DBG("chan: %d, addr: 0x%x, transfer len: %d, read: %d, mode: %x\n",
+		chan->chan_no, addr, len, read_write == I2C_SMBUS_READ,
+	    iface->cur_mode);
 
 	iface->data = buffer;
 	iface->datalen = len;
 	iface->state = state_addr;
 	iface->result = 0;
-	iface->stopretry = 0;
 	iface->read_write = read_write;
 	
 	/* Setup channel & clear pending irqs */
-	write_reg(reg_mode, iface->cur_mode | (chan->chan_no << 4));
 	write_reg(reg_isr, read_reg(reg_isr));
+	write_reg(reg_mode, iface->cur_mode | (chan->chan_no << 4));
 	write_reg(reg_status, 0);
 
 	/* Set up address and r/w bit */
@@ -301,15 +360,31 @@
 	    || (iface->cur_mode & KW_I2C_MODE_MODE_MASK) == KW_I2C_MODE_COMBINED)
 		write_reg(reg_subaddr, command);
 
+#ifndef POLLED_MODE
 	/* Arm timeout */
 	iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
 	add_timer(&iface->timeout_timer);
+#endif
 
 	/* Start sending address & enable interrupt*/
-	write_reg(reg_control, read_reg(reg_control) | KW_I2C_CTL_XADDR);
+	write_reg(reg_control, KW_I2C_CTL_XADDR);
 	write_reg(reg_ier, KW_I2C_IRQ_MASK);
 
+#ifdef POLLED_MODE
+	DBG("using polled mode...\n");
+	/* State machine, to turn into an interrupt handler */
+	while(iface->state != state_idle) {
+		unsigned long flags;
+
+		u8 isr = wait_interrupt(iface);
+		spin_lock_irqsave(&iface->lock, flags);
+		handle_interrupt(iface, isr);
+		spin_unlock_irqrestore(&iface->lock, flags);
+	}
+#else /* POLLED_MODE */
+	DBG("using interrupt mode...\n");
 	wait_for_completion(&iface->complete);	
+#endif /* POLLED_MODE */	
 
 	rc = iface->result;	
 	DBG("transfer done, result: %d\n", rc);
@@ -368,7 +443,6 @@
 		iface->datalen = pmsg->len;
 		iface->state = state_addr;
 		iface->result = 0;
-		iface->stopretry = 0;
 		if (pmsg->flags & I2C_M_RD)
 			iface->read_write = I2C_SMBUS_READ;
 		else
@@ -381,15 +455,27 @@
 			(addr << 1) |
 			((iface->read_write == I2C_SMBUS_READ) ? 0x01 : 0x00));
 
+#ifndef POLLED_MODE
 		/* Arm timeout */
 		iface->timeout_timer.expires = jiffies + POLL_TIMEOUT;
 		add_timer(&iface->timeout_timer);
+#endif
 
 		/* Start sending address & enable interrupt*/
-		write_reg(reg_control, read_reg(reg_control) | KW_I2C_CTL_XADDR);
 		write_reg(reg_ier, KW_I2C_IRQ_MASK);
+		write_reg(reg_control, KW_I2C_CTL_XADDR);
 
+#ifdef POLLED_MODE
+		DBG("using polled mode...\n");
+		/* State machine, to turn into an interrupt handler */
+		while(iface->state != state_idle) {
+			u8 isr = wait_interrupt(iface);
+			handle_interrupt(iface, isr);
+		}
+#else /* POLLED_MODE */
+		DBG("using interrupt mode...\n");
 		wait_for_completion(&iface->complete);	
+#endif /* POLLED_MODE */	
 
 		rc = iface->result;
 		if (rc == 0)
@@ -448,7 +534,7 @@
 	for (bsteps = 0; (steps & 0x01) == 0; bsteps++)
 		steps >>= 1;
 
-	if (!strcmp(np->parent->name, "uni-n")) {
+	if (np->parent->name[0] == 'u') {
 		nchan = 2;
 		addroffset = 3;
 	} else {
@@ -481,9 +567,11 @@
 		return -ENOMEM;
 	}
 
+#ifndef POLLED_MODE
 	init_timer(&iface->timeout_timer);
 	iface->timeout_timer.function = keywest_timeout;
 	iface->timeout_timer.data = (unsigned long)iface;
+#endif
 
 	/* Select interface rate */
 	iface->cur_mode = KW_I2C_MODE_100KHZ;
@@ -513,14 +601,16 @@
 	write_reg(reg_ier, 0x00);
 	write_reg(reg_isr, KW_I2C_IRQ_MASK);
 
+#ifndef POLLED_MODE
 	/* Request chip interrupt */	
-	rc = request_irq(iface->irq, keywest_irq, 0, "keywest i2c", iface);
+	rc = request_irq(iface->irq, keywest_irq, SA_INTERRUPT, "keywest i2c", iface);
 	if (rc) {
 		printk(KERN_ERR "i2c-keywest: can't get IRQ %d !\n", iface->irq);
 		iounmap((void *)iface->base);
 		kfree(iface);
 		return -ENODEV;
 	}
+#endif /* POLLED_MODE */
 
 	for (i=0; i<nchan; i++) {
 		struct keywest_chan* chan = &iface->channels[i];
@@ -555,8 +645,9 @@
 		}
 	}
 
-	printk(KERN_INFO "Found KeyWest i2c on \"%s\", %d channel%s, stepping: %d bits\n",
-		np->parent->name, nchan, nchan > 1 ? "s" : "", bsteps);
+	printk(KERN_INFO "Found KeyWest i2c on \"%s\", %d channel%s, stepping: %d bits, irq %d\n",
+		np->parent->name, nchan, nchan > 1 ? "s" : "", bsteps,
+	       iface->irq);
 		
 	iface->next = ifaces;
 	ifaces = iface;
@@ -572,16 +663,19 @@
 
 	/* Make sure we stop all activity */
 	down(&iface->sem);
+#ifndef POLLED_MODE
 	spin_lock_irq(&iface->lock);
 	while (iface->state != state_idle) {
 		spin_unlock_irq(&iface->lock);
-		set_task_state(current,TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ/10);
+		schedule();
 		spin_lock_irq(&iface->lock);
 	}
+#endif /* POLLED_MODE */
 	iface->state = state_dead;
+#ifndef POLLED_MODE
 	spin_unlock_irq(&iface->lock);
 	free_irq(iface->irq, iface);
+#endif /* POLLED_MODE */
 	up(&iface->sem);
 
 	/* Release all channels */
diff -urN kernel-source-2.4.27/drivers/i2c/i2c-keywest.h kernel-source-2.4.27-benh/drivers/i2c/i2c-keywest.h
--- kernel-source-2.4.27/drivers/i2c/i2c-keywest.h	2002-02-25 20:37:57.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/i2c/i2c-keywest.h	2004-09-01 20:56:25.387259608 +0200
@@ -64,7 +64,6 @@
 	unsigned		datalen;
 	int			state;
 	int			result;
-	int			stopretry;
 	struct timer_list	timeout_timer;
 	struct completion	complete;
 	struct keywest_iface*	next;
@@ -99,8 +98,7 @@
 {
 	out_8(((volatile u8 *)iface->base)
 		+ (((unsigned)reg) << iface->bsteps), val);
-	(void)__read_reg(iface, reg);
-	udelay(10);
+	(void)__read_reg(iface, reg_subaddr);
 }
 
 #define write_reg(reg, val)	__write_reg(iface, reg, val) 
diff -urN kernel-source-2.4.27/drivers/ide/Config.in kernel-source-2.4.27-benh/drivers/ide/Config.in
--- kernel-source-2.4.27/drivers/ide/Config.in	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/ide/Config.in	2004-09-01 20:56:25.465247752 +0200
@@ -90,6 +90,9 @@
 	 dep_bool '      Probe internal Kauai ATA/100 first' CONFIG_BLK_DEV_IDE_PMAC_ATA100FIRST $CONFIG_BLK_DEV_IDE_PMAC
 	 dep_bool '      PowerMac IDE DMA support' CONFIG_BLK_DEV_IDEDMA_PMAC $CONFIG_BLK_DEV_IDE_PMAC
 	 dep_bool '        Use DMA by default' CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO $CONFIG_BLK_DEV_IDEDMA_PMAC
+	 if [ "$CONFIG_ADB_PMU" = "y" ]; then
+	     bool '      Blink laptop LED on activity' CONFIG_PMU_HD_BLINK
+	 fi
 	 if [ "$CONFIG_BLK_DEV_IDE_PMAC" = "y" ]; then
 	   define_bool CONFIG_BLK_DEV_IDEDMA $CONFIG_BLK_DEV_IDEDMA_PMAC
 	 fi
diff -urN kernel-source-2.4.27/drivers/ide/ide-probe.c kernel-source-2.4.27-benh/drivers/ide/ide-probe.c
--- kernel-source-2.4.27/drivers/ide/ide-probe.c	2004-04-14 15:05:29.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/ide/ide-probe.c	2004-09-01 20:56:25.553234376 +0200
@@ -982,6 +982,13 @@
 	q->queuedata = HWGROUP(drive);
 	blk_init_queue(q, do_ide_request);
 	blk_queue_throttle_sectors(q, 1);
+	/*
+	 * enable led activity for disk drives only
+	 */
+#ifdef CONFIG_PMU_HD_BLINK
+	if (drive->media == ide_disk && HWIF(drive)->led_act)
+		blk_queue_activity_fn(&drive->queue, HWIF(drive)->led_act, drive);
+#endif /* CONFIG_PMU_HD_BLINK */
 }
 
 #undef __IRQ_HELL_SPIN
@@ -1174,6 +1181,9 @@
 
 	units = MAX_DRIVES;
 
+	if (!hwif->rqsize)
+		hwif->rqsize = hwif->addressing ? 128 : 65536;
+
 	minors    = units * (1<<PARTN_BITS);
 	gd        = kmalloc(sizeof(struct gendisk), GFP_KERNEL);
 	if (!gd)
@@ -1203,11 +1213,14 @@
 	max_sectors[hwif->major] = max_sect;
 	max_readahead[hwif->major] = max_ra;
 	for (unit = 0; unit < minors; ++unit) {
+		int max_s = 128;
+
 		*bs++ = BLOCK_SIZE;
-		/*
-		 * IDE can do up to 128K per request == 256
-		 */
-		*max_sect++ = ((hwif->rqsize) ? hwif->rqsize : 128);
+
+		if (max_s > hwif->rqsize)
+			max_s = hwif->rqsize;
+
+		*max_sect++ = max_s;
 		*max_ra++ = vm_max_readahead;
 	}
 
diff -urN kernel-source-2.4.27/drivers/ide/pci/pdc202xx_new.c kernel-source-2.4.27-benh/drivers/ide/pci/pdc202xx_new.c
--- kernel-source-2.4.27/drivers/ide/pci/pdc202xx_new.c	2004-08-08 01:26:04.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/ide/pci/pdc202xx_new.c	2004-09-01 20:56:25.643220696 +0200
@@ -32,6 +32,11 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
+#ifdef CONFIG_ALL_PPC
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#endif
+
 #include "ide_modes.h"
 #include "pdc202xx_new.h"
 
@@ -136,108 +141,6 @@
 	return 0;
 }
 
-static int pdcnew_tune_chipset (ide_drive_t *drive, u8 xferspeed)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct pci_dev *dev	= hwif->pci_dev;
-	u8 drive_pci		= 0x60 + (drive->dn << 2);
-	u8 speed	= ide_rate_filter(pdcnew_ratemask(drive), xferspeed);
-
-	u32			drive_conf;
-	u8			AP, BP, CP, DP;
-	u8			TA = 0, TB = 0, TC = 0;
-
-	if ((drive->media != ide_disk) && (speed < XFER_SW_DMA_0))
-		return -1;
-
-	pci_read_config_dword(dev, drive_pci, &drive_conf);
-	pci_read_config_byte(dev, (drive_pci), &AP);
-	pci_read_config_byte(dev, (drive_pci)|0x01, &BP);
-	pci_read_config_byte(dev, (drive_pci)|0x02, &CP);
-	pci_read_config_byte(dev, (drive_pci)|0x03, &DP);
-
-	if (speed < XFER_SW_DMA_0) {
-		if ((AP & 0x0F) || (BP & 0x07)) {
-			/* clear PIO modes of lower 8421 bits of A Register */
-			pci_write_config_byte(dev, (drive_pci), AP &~0x0F);
-			pci_read_config_byte(dev, (drive_pci), &AP);
-
-			/* clear PIO modes of lower 421 bits of B Register */
-			pci_write_config_byte(dev, (drive_pci)|0x01, BP &~0x07);
-			pci_read_config_byte(dev, (drive_pci)|0x01, &BP);
-
-			pci_read_config_byte(dev, (drive_pci), &AP);
-			pci_read_config_byte(dev, (drive_pci)|0x01, &BP);
-		}
-	} else {
-		if ((BP & 0xF0) && (CP & 0x0F)) {
-			/* clear DMA modes of upper 842 bits of B Register */
-			/* clear PIO forced mode upper 1 bit of B Register */
-			pci_write_config_byte(dev, (drive_pci)|0x01, BP &~0xF0);
-			pci_read_config_byte(dev, (drive_pci)|0x01, &BP);
-
-			/* clear DMA modes of lower 8421 bits of C Register */
-			pci_write_config_byte(dev, (drive_pci)|0x02, CP &~0x0F);
-			pci_read_config_byte(dev, (drive_pci)|0x02, &CP);
-		}
-	}
-
-	pci_read_config_byte(dev, (drive_pci), &AP);
-	pci_read_config_byte(dev, (drive_pci)|0x01, &BP);
-	pci_read_config_byte(dev, (drive_pci)|0x02, &CP);
-
-	switch(speed) {
-		case XFER_UDMA_6:	speed = XFER_UDMA_5;
-		case XFER_UDMA_5:
-		case XFER_UDMA_4:	TB = 0x20; TC = 0x01; break;
-		case XFER_UDMA_2:	TB = 0x20; TC = 0x01; break;
-		case XFER_UDMA_3:
-		case XFER_UDMA_1:	TB = 0x40; TC = 0x02; break;
-		case XFER_UDMA_0:
-		case XFER_MW_DMA_2:	TB = 0x60; TC = 0x03; break;
-		case XFER_MW_DMA_1:	TB = 0x60; TC = 0x04; break;
-		case XFER_MW_DMA_0:
-		case XFER_SW_DMA_2:	TB = 0x60; TC = 0x05; break;
-		case XFER_SW_DMA_1:	TB = 0x80; TC = 0x06; break;
-		case XFER_SW_DMA_0:	TB = 0xC0; TC = 0x0B; break;
-		case XFER_PIO_4:	TA = 0x01; TB = 0x04; break;
-		case XFER_PIO_3:	TA = 0x02; TB = 0x06; break;
-		case XFER_PIO_2:	TA = 0x03; TB = 0x08; break;
-		case XFER_PIO_1:	TA = 0x05; TB = 0x0C; break;
-		case XFER_PIO_0:
-		default:		TA = 0x09; TB = 0x13; break;
-	}
-
-	if (speed < XFER_SW_DMA_0) {
-		pci_write_config_byte(dev, (drive_pci), AP|TA);
-		pci_write_config_byte(dev, (drive_pci)|0x01, BP|TB);
-	} else {
-		pci_write_config_byte(dev, (drive_pci)|0x01, BP|TB);
-		pci_write_config_byte(dev, (drive_pci)|0x02, CP|TC);
-	}
-
-#if PDC202XX_DECODE_REGISTER_INFO
-	pci_read_config_byte(dev, (drive_pci), &AP);
-	pci_read_config_byte(dev, (drive_pci)|0x01, &BP);
-	pci_read_config_byte(dev, (drive_pci)|0x02, &CP);
-	pci_read_config_byte(dev, (drive_pci)|0x03, &DP);
-
-	decode_registers(REG_A, AP);
-	decode_registers(REG_B, BP);
-	decode_registers(REG_C, CP);
-	decode_registers(REG_D, DP);
-#endif /* PDC202XX_DECODE_REGISTER_INFO */
-#if PDC202XX_DEBUG_DRIVE_INFO
-	printk(KERN_DEBUG "%s: %s drive%d 0x%08x ",
-		drive->name, ide_xfer_verbose(speed),
-		drive->dn, drive_conf);
-		pci_read_config_dword(dev, drive_pci, &drive_conf);
-	printk("0x%08x\n", drive_conf);
-#endif /* PDC202XX_DEBUG_DRIVE_INFO */
-
-	return (ide_config_drive_speed(drive, speed));
-}
-
 static int pdcnew_new_tune_chipset (ide_drive_t *drive, u8 xferspeed)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
@@ -251,7 +154,10 @@
 		hwif->OUTB((thold + adj), indexreg);
 		hwif->OUTB((hwif->INB(datareg) & 0x7f), datareg);
 	}
-
+	if (speed >= XFER_UDMA_2) {
+		set_ata2(0x69, 0x25);
+		set_pio(0x27, 0x0d, 0x35);
+	}
 	switch (speed) {
 		case XFER_UDMA_7:
 			speed = XFER_UDMA_6;
@@ -291,7 +197,7 @@
 	if (pio == 5) pio = 4;
 	speed = XFER_PIO_0 + ide_get_best_pio_mode(drive, 255, pio, NULL);
         
-	return ((int) pdcnew_tune_chipset(drive, speed));
+	return ((int) pdcnew_new_tune_chipset(drive, speed));
 }
 
 static void pdcnew_tune_drive (ide_drive_t *drive, u8 pio)
@@ -535,6 +441,46 @@
 	return dev->irq;
 }
 
+#ifdef CONFIG_ALL_PPC
+
+static void apple_kiwi_init(struct pci_dev *pdev)
+{
+	struct device_node *np = pci_device_to_OF_node(pdev);
+	unsigned int class_rev	= 0;
+	unsigned long mmio;
+	u8 conf;
+
+	if (np == NULL || !device_is_compatible(np, "kiwi-root"))
+		return;
+
+	pci_read_config_dword(pdev, PCI_CLASS_REVISION, &class_rev);
+	class_rev &= 0xff;
+
+	if (class_rev >= 0x03) {
+		/* Setup chip magic config stuff (from darwin) */
+		pci_read_config_byte(pdev, 0x40, &conf);
+		pci_write_config_byte(pdev, 0x40, conf | 0x01);
+	}
+	mmio = (unsigned long)ioremap(pci_resource_start(pdev, 5),
+				      pci_resource_len(pdev, 5));
+
+	/* Setup some PLL stuffs */
+	switch (pdev->device) {
+	case PCI_DEVICE_ID_PROMISE_20270:
+		writew(0x0d2b, mmio + 0x1202);
+		mdelay(30);
+		break;
+	case PCI_DEVICE_ID_PROMISE_20271:
+		writew(0x0826, mmio + 0x1202);
+		mdelay(30);
+		break;
+	}
+
+	iounmap((void *)mmio);
+}
+
+#endif /* CONFIG_ALL_PPC */
+
 static void __init init_hwif_pdc202new (ide_hwif_t *hwif)
 {
 	hwif->autodma = 0;
@@ -544,10 +490,7 @@
 	hwif->speedproc = &pdcnew_new_tune_chipset;
 	hwif->resetproc = &pdcnew_new_reset;
 
-	if (!hwif->dma_base) {
 		hwif->drives[0].autotune = hwif->drives[1].autotune = 1;
-		return;
-	}
 
 	hwif->ultra_mask = 0x7f;
 	hwif->mwdma_mask = 0x07;
@@ -564,6 +507,10 @@
 	printk(KERN_DEBUG "%s: %s-pin cable\n",
 		hwif->name, hwif->udma_four ? "80" : "40");
 #endif /* PDC202_DEBUG_CABLE */
+
+#ifdef CONFIG_ALL_PPC
+	apple_kiwi_init(hwif->pci_dev);
+#endif
 }
 
 static void __init init_dma_pdc202new (ide_hwif_t *hwif, unsigned long dmabase)
diff -urN kernel-source-2.4.27/drivers/ide/ppc/pmac.c kernel-source-2.4.27-benh/drivers/ide/ppc/pmac.c
--- kernel-source-2.4.27/drivers/ide/ppc/pmac.c	2003-06-13 16:51:34.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/ide/ppc/pmac.c	2004-09-01 20:56:25.807195768 +0200
@@ -38,10 +38,8 @@
 #include <asm/pmac_feature.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
-#ifdef CONFIG_PMAC_PBOOK
 #include <linux/adb.h>
 #include <linux/pmu.h>
-#endif
 #include "ide_modes.h"
 #include "ide-timing.h"
 
@@ -83,15 +81,17 @@
 	controller_heathrow,	/* Heathrow/Paddington */
 	controller_kl_ata3,	/* KeyLargo ATA-3 */
 	controller_kl_ata4,	/* KeyLargo ATA-4 */
-	controller_un_ata6	/* UniNorth2 ATA-6 */
+	controller_un_ata6,	/* UniNorth2 ATA-6 */
+	controller_k2_ata6	/* K2 ATA-6 */
 };
 
 static const char* model_name[] = {
 	"OHare ATA",	/* OHare based */
 	"Heathrow ATA",	/* Heathrow/Paddington */
-	"KeyLargo ATA-3",	/* KeyLargo ATA-3 */
-	"KeyLargo ATA-4",	/* KeyLargo ATA-4 */
-	"UniNorth ATA-6"	/* UniNorth2 ATA-6 */
+	"KeyLargo ATA-3",	/* KeyLargo ATA-3 (MDMA only) */
+	"KeyLargo ATA-4",	/* KeyLargo ATA-4 (UDMA/66) */
+	"UniNorth ATA-6",	/* UniNorth2 ATA-6 (UDMA/100) */
+	"K2 ATA-6",		/* K2 ATA-6 (UDMA/100) */
 };
 
 /*
@@ -357,6 +357,89 @@
 };
 #endif /* CONFIG_PMAC_PBOOK */
 
+#ifdef CONFIG_PMU_HD_BLINK
+
+/* Set to 50ms */
+#define PMU_HD_BLINK_TIME	(HZ/20)
+
+static struct adb_request pmu_blink_on, pmu_blink_off;
+static spinlock_t pmu_blink_lock;
+static unsigned long pmu_blink_stoptime;
+static int pmu_blink_ledstate;
+static struct timer_list pmu_blink_timer;
+
+static void
+pmu_hd_blink_timeout(unsigned long data)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&pmu_blink_lock, flags);
+
+	/* We may have been triggered again in a racy way, check
+	 * that we really want to switch it off
+	 */
+	if (time_after(pmu_blink_stoptime, jiffies))
+		goto done;
+
+	/* Previous req. not complete, try 50ms more */
+	if (pmu_blink_off.complete == 0)
+		mod_timer(&pmu_blink_timer, jiffies + PMU_HD_BLINK_TIME);
+	else if (pmu_blink_ledstate) {
+		pmu_request(&pmu_blink_off, NULL, 4, 0xee, 4, 0, 0);
+		pmu_blink_ledstate = 0;
+	}
+done:
+	spin_unlock_irqrestore(&pmu_blink_lock, flags);
+}
+
+static void
+pmu_hd_kick_blink(void *data, int rw)
+{
+	unsigned long flags;
+	
+	pmu_blink_stoptime = jiffies + PMU_HD_BLINK_TIME;
+	wmb();
+	mod_timer(&pmu_blink_timer, pmu_blink_stoptime);
+	if (pmu_blink_ledstate == 1)
+		return;
+	spin_lock_irqsave(&pmu_blink_lock, flags);
+	if (pmu_blink_on.complete && !pmu_blink_ledstate) {
+		pmu_request(&pmu_blink_on, NULL, 4, 0xee, 4, 0, 1);
+		pmu_blink_ledstate = 1;
+	}
+	spin_unlock_irqrestore(&pmu_blink_lock, flags);
+}
+
+static int
+pmu_hd_blink_init(void)
+{
+	struct device_node *dt;
+	const char *model;
+
+	if (pmu_get_model() != PMU_KEYLARGO_BASED)
+		return 0;
+	
+	dt = find_devices("device-tree");
+	if (dt == NULL)
+		return 0;
+	model = (const char *)get_property(dt, "model", NULL);
+	if (model == NULL)
+		return 0;
+	if (strncmp(model, "PowerBook", strlen("PowerBook")) != 0 &&
+	    strncmp(model, "iBook", strlen("iBook")) != 0)
+	    	return 0;
+	
+	pmu_blink_on.complete = 1;
+	pmu_blink_off.complete = 1;
+	spin_lock_init(&pmu_blink_lock);
+	init_timer(&pmu_blink_timer);
+	pmu_blink_timer.function = pmu_hd_blink_timeout;
+
+	return 1;
+}
+
+#endif /* CONFIG_PMU_HD_BLINK */
+
 /*
  * N.B. this can't be an initfunc, because the media-bay task can
  * call ide_[un]register at any time.
@@ -441,7 +524,7 @@
 	if (pmif == NULL)
 		return;
 
-	if (pmif->kind == controller_un_ata6)
+	if (pmif->kind == controller_un_ata6 || pmif->kind == controller_k2_ata6)
 		pmac_ide_kauai_selectproc(drive);
 	else
 		pmac_ide_selectproc(drive);
@@ -462,7 +545,7 @@
 	ide_hwif_t *hwif = HWIF(drive);
 	int result = 1;
 	
-	disable_irq(hwif->irq);	/* disable_irq_nosync ?? */
+	disable_irq_nosync(hwif->irq);
 	udelay(1);
 	SELECT_DRIVE(drive);
 	SELECT_MASK(drive, 0);
@@ -549,7 +632,8 @@
 	pio = ide_get_best_pio_mode(drive, pio, 4, &d);
 
 	switch (pmif->kind) {
-	case controller_un_ata6: {
+	case controller_un_ata6:
+	case controller_k2_ata6: {
 		/* 100Mhz cell */
 		u32 tr = kauai_lookup_timing(kauai_pio_timings, d.cycle_time);
 		if (tr == 0)
@@ -676,6 +760,7 @@
 	/* Get the proper timing array for this controller */
 	switch(intf_type) {
 		case controller_un_ata6:
+		case controller_k2_ata6:
 			break;
 		case controller_kl_ata4:
 			tm = mdma_timings_66;
@@ -707,7 +792,8 @@
 #endif
 	}
 	switch(intf_type) {
-	case controller_un_ata6: {
+	case controller_un_ata6:
+	case controller_k2_ata6: {
 		/* 100Mhz cell */
 		u32 tr = kauai_lookup_timing(kauai_mdma_timings, cycleTime);
 		if (tr == 0)
@@ -797,7 +883,8 @@
 	switch(speed) {
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 		case XFER_UDMA_5:
-			if (pmif->kind != controller_un_ata6)
+			if (pmif->kind != controller_un_ata6 &&
+			    pmif->kind != controller_k2_ata6)
 				return 1;
 		case XFER_UDMA_4:
 		case XFER_UDMA_3:
@@ -808,7 +895,8 @@
 		case XFER_UDMA_0:
 			if (pmif->kind == controller_kl_ata4)
 				ret = set_timings_udma_ata4(timings, speed);
-			else if (pmif->kind == controller_un_ata6)
+			else if (pmif->kind == controller_un_ata6
+				 || pmif->kind == controller_k2_ata6)
 				ret = set_timings_udma_ata6(timings, timings2, speed);
 			else
 				ret = 1;		
@@ -853,6 +941,7 @@
 	
 	switch(pmif->kind) {
 		case controller_un_ata6:
+		case controller_k2_ata6:
 			value = 0x08618a92;
 			value2 = 0x00002921;
 			break;
@@ -945,9 +1034,12 @@
 	unsigned long base, regbase;
 	int irq;
 	ide_hwif_t *hwif;
-
+#ifdef CONFIG_PMU_HD_BLINK
+	int has_blink;
+#endif	
 	if (_machine != _MACH_Pmac)
 		return;
+
 	pp = &atas;
 	rp = &removables;
 	p = find_devices("ATA");
@@ -957,6 +1049,14 @@
 		p = find_type_devices("ide");
 	if (p == NULL)
 		p = find_type_devices("ata");
+
+	if (p == NULL)
+		return;
+
+#ifdef CONFIG_PMU_HD_BLINK
+	has_blink = pmu_hd_blink_init();
+#endif /* CONFIG_PMU_HD_BLINK */
+
 	/* Move removable devices such as the media-bay CDROM
 	   on the PB3400 to the end of the list. */
 	for (; p != NULL; p = nextp) {
@@ -996,7 +1096,8 @@
 		 * leave it to the generic PCI driver. Except for U2's
 		 * Kauai ATA
 		 */
-		if (!device_is_compatible(np, "kauai-ata")) {
+		if (!device_is_compatible(np, "kauai-ata")
+		    && !device_is_compatible(np, "K2-UATA")) {
 			for (tp = np->parent; tp != 0; tp = tp->parent)
 				if (tp->type && (strcmp(tp->type, "mac-io") == 0
 						 || strcmp(tp->type, "dbdma") == 0))
@@ -1063,7 +1164,7 @@
 			}
 			pci_set_master(pdev);
 			
-			if (pci_request_regions(pdev, "U2 IDE")) {
+			if (pci_request_regions(pdev, "Kauai ATA")) {
 				printk(KERN_ERR "ide-pmac: Cannot obtain PCI resources\n");
 				continue;
 			}
@@ -1095,6 +1196,9 @@
 		if (device_is_compatible(np, "kauai-ata")) {
 			pmif->kind = controller_un_ata6;
 			pci_set_drvdata(pdev, pmif);
+		} else if (device_is_compatible(np, "K2-UATA")) {
+			pmif->kind = controller_k2_ata6;
+			pci_set_drvdata(pdev, pmif);
 		} else if (device_is_compatible(np, "keylargo-ata")) {
 			if (strcmp(np->name, "ata-4") == 0)
 				pmif->kind = controller_kl_ata4;
@@ -1109,7 +1213,8 @@
 		pmif->aapl_bus_id =  bidp ? *bidp : 0;
 
 		/* Get cable type from device-tree */
-		if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6) {
+		if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6
+		    || pmif->kind == controller_k2_ata6) {
 			char* cable = get_property(np, "cable-type", NULL);
 			if (cable && !strncmp(cable, "80-", 3))
 				pmif->cable_80 = 1;
@@ -1157,12 +1262,17 @@
 		hwif->drives[0].unmask = 1;
 		hwif->drives[1].unmask = 1;
 		hwif->tuneproc = pmac_ide_tuneproc;
-		if (pmif->kind == controller_un_ata6)
+		if (pmif->kind == controller_un_ata6 || pmif->kind == controller_k2_ata6)
 			hwif->selectproc = pmac_ide_kauai_selectproc;
 		else
 			hwif->selectproc = pmac_ide_selectproc;
 		hwif->speedproc = pmac_ide_tune_chipset;
 
+#ifdef CONFIG_PMU_HD_BLINK
+		if (has_blink)
+			hwif->led_act = pmu_hd_kick_blink;
+#endif /* CONFIG_PMU_HD_BLINK */
+
 		printk(KERN_INFO "ide%d: Found Apple %s controller, bus ID %d%s\n",
 			i, model_name[pmif->kind], pmif->aapl_bus_id,
 			in_bay ? " (mediabay)" : "");
@@ -1173,13 +1283,15 @@
 #endif /* CONFIG_PMAC_PBOOK */
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
-		if (np->n_addrs >= 2 || pmif->kind == controller_un_ata6) {
+		if (np->n_addrs >= 2 || pmif->kind == controller_un_ata6
+		    || pmif->kind == controller_k2_ata6) {
 			/* has a DBDMA controller channel */
 			pmac_ide_setup_dma(np, i);
 		}
 		hwif->atapi_dma = 1;
 		switch(pmif->kind) {
 			case controller_un_ata6:
+			case controller_k2_ata6:
 				hwif->ultra_mask = pmif->cable_80 ? 0x3f : 0x07;
 				hwif->mwdma_mask = 0x07;
 				hwif->swdma_mask = 0x00;
@@ -1207,6 +1319,8 @@
 #ifdef CONFIG_PMAC_PBOOK
 	pmu_register_sleep_notifier(&idepmac_sleep_notifier);
 #endif /* CONFIG_PMAC_PBOOK */
+
+	mdelay(IDE_WAKEUP_DELAY_MS);
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
@@ -1475,7 +1589,7 @@
 	timing_local[1] = *timings2;
 	
 	/* Calculate timings for interface */
-	if (pmif->kind == controller_un_ata6)
+	if (pmif->kind == controller_un_ata6 || pmif->kind == controller_k2_ata6)
 		ret = set_timings_udma_ata6(	&timing_local[0],
 						&timing_local[1],
 						mode);
@@ -1529,11 +1643,13 @@
 		short mode;
 		
 		map = XFER_MWDMA;
-		if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6) {
+		if (pmif->kind == controller_kl_ata4 || pmif->kind == controller_un_ata6
+		    || pmif->kind == controller_k2_ata6) {
 			map |= XFER_UDMA;
 			if (pmif->cable_80) {
 				map |= XFER_UDMA_66;
-				if (pmif->kind == controller_un_ata6)
+				if (pmif->kind == controller_un_ata6 ||
+				    pmif->kind == controller_k2_ata6)
 					map |= XFER_UDMA_100;
 			}
 		}
@@ -1786,7 +1902,7 @@
 {
 	struct pmac_ide_hwif *pmif = &pmac_ide[ix];
 
-	if (device_is_compatible(np, "kauai-ata")) {
+	if (device_is_compatible(np, "kauai-ata") || device_is_compatible(np, "K2-UATA")) {
 		pmif->dma_regs = (volatile struct dbdma_regs*)(pmif->mapbase + 0x1000);
 	} else {
 		if (request_OF_resource(np, 1, " (mac-io IDE DMA)") == NULL) {
diff -urN kernel-source-2.4.27/drivers/ide/setup-pci.c kernel-source-2.4.27-benh/drivers/ide/setup-pci.c
--- kernel-source-2.4.27/drivers/ide/setup-pci.c	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/ide/setup-pci.c	2004-09-01 20:56:25.809195464 +0200
@@ -51,6 +51,7 @@
 {
 	int h;
 	ide_hwif_t *hwif;
+	int reserved = ide_reserved_hwifs();
 
 	/*
 	 * Look for a hwif with matching io_base specified using
@@ -90,18 +91,18 @@
 	 */
 	if (bootable) {
 		for (h = 0; h < MAX_HWIFS; ++h) {
-			hwif = &ide_hwifs[h];
+			hwif = ide_hwifs + h;
 			if (hwif->chipset == ide_unknown)
 				return hwif;	/* pick an unused entry */
 		}
 	} else {
-		for (h = 2; h < MAX_HWIFS; ++h) {
+		for (h = reserved; h < MAX_HWIFS; ++h) {
 			hwif = ide_hwifs + h;
 			if (hwif->chipset == ide_unknown)
 				return hwif;	/* pick an unused entry */
 		}
 	}
-	for (h = 0; h < 2; ++h) {
+	for (h = 0; h < reserved; ++h) {
 		hwif = ide_hwifs + h;
 		if (hwif->chipset == ide_unknown)
 			return hwif;	/* pick an unused entry */
diff -urN kernel-source-2.4.27/drivers/macintosh/macserial.c kernel-source-2.4.27-benh/drivers/macintosh/macserial.c
--- kernel-source-2.4.27/drivers/macintosh/macserial.c	2002-08-03 02:39:44.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/macintosh/macserial.c	2004-09-01 20:56:25.968171296 +0200
@@ -59,7 +59,7 @@
 };
 #endif
 
-#define SUPPORT_SERIAL_DMA
+#undef SUPPORT_SERIAL_DMA
 #define MACSERIAL_VERSION	"2.0"
 
 /*
@@ -1134,6 +1134,8 @@
  */
 static void shutdown(struct mac_serial * info)
 {
+	unsigned long flags;
+	
 	OPNDBG("Shutting down serial port %d (irq %d)....\n", info->line,
 	       info->irq);
 
@@ -1142,6 +1144,8 @@
 		return;
 	}
 
+	save_flags(flags); cli(); /* Disable interrupts */
+
 	if (info->has_dma) {
 		del_timer(&info->poll_dma_timer);
 		dbdma_reset(info->tx_dma);
@@ -1151,6 +1155,8 @@
 	}
 	disable_irq(info->irq);
 
+	restore_flags(flags);
+
 	info->pendregs[1] = info->curregs[1] = 0;
 	write_zsreg(info->zs_channel, 1, 0);	/* no interrupts */
 
@@ -1980,6 +1986,7 @@
 		return;
 	}
 	info->flags |= ZILOG_CLOSING;
+	restore_flags(flags);
 	/*
 	 * Save the termios structure, since this port may have
 	 * separate termios for callout and dialin.
@@ -1994,11 +2001,8 @@
 	 */
 	OPNDBG("waiting end of Tx... (timeout:%d)\n", info->closing_wait);
 	tty->closing = 1;
-	if (info->closing_wait != ZILOG_CLOSING_WAIT_NONE) {
-		restore_flags(flags);
+	if (info->closing_wait != ZILOG_CLOSING_WAIT_NONE)
 		tty_wait_until_sent(tty, info->closing_wait);
-		save_flags(flags); cli();
-	}
 
 	/*
 	 * At this point we stop accepting input.  To do this, we
@@ -2017,15 +2021,10 @@
 		 * has completely drained.
 		 */
 		OPNDBG("waiting end of Rx...\n");
-		restore_flags(flags);
 		rs_wait_until_sent(tty, info->timeout);
-		save_flags(flags); cli();
 	}
 
 	shutdown(info);
-	/* restore flags now since shutdown() will have disabled this port's
-	   specific irqs */
-	restore_flags(flags);
 
 	if (tty->driver.flush_buffer)
 		tty->driver.flush_buffer(tty);
@@ -2880,7 +2879,7 @@
 static int __init serial_console_setup(struct console *co, char *options)
 {
 	struct mac_serial *info;
-	int	baud = 38400;
+	int	baud = 57600; /*38400;*/
 	int	bits = 8;
 	int	parity = 'n';
 	int	cflag = CREAD | HUPCL | CLOCAL;
diff -urN kernel-source-2.4.27/drivers/macintosh/Makefile kernel-source-2.4.27-benh/drivers/macintosh/Makefile
--- kernel-source-2.4.27/drivers/macintosh/Makefile	2002-11-29 00:53:13.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/macintosh/Makefile	2004-09-01 20:56:25.969171144 +0200
@@ -35,6 +35,8 @@
 obj-$(CONFIG_INPUT_ADBHID)	+= adbhid.o
 obj-$(CONFIG_PPC_RTC)		+= rtc.o
 obj-$(CONFIG_ANSLCD)		+= ans-lcd.o
+#obj-$(CONFIG_I2C)		+= therm_pismo.o
+#obj-$(CONFIG_I2C)		+= therm_albooks.o
 
 obj-$(CONFIG_ADB_PMU)		+= via-pmu.o
 obj-$(CONFIG_ADB_CUDA)		+= via-cuda.o
@@ -48,6 +50,8 @@
 obj-$(CONFIG_ADB_PMU68K)	+= via-pmu68k.o
 obj-$(CONFIG_ADB_MACIO)		+= macio-adb.o
 
+obj-$(CONFIG_THERM_PM72)        += therm_pm72.o
+
 # The global Rules.make.
 
 include $(TOPDIR)/Rules.make
diff -urN kernel-source-2.4.27/drivers/macintosh/nvram.c kernel-source-2.4.27-benh/drivers/macintosh/nvram.c
--- kernel-source-2.4.27/drivers/macintosh/nvram.c	2004-08-08 01:26:04.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/macintosh/nvram.c	2004-09-01 20:56:26.047159288 +0200
@@ -77,8 +77,8 @@
 	unsigned int cmd, unsigned long arg)
 {
 	switch(cmd) {
-		case PMAC_NVRAM_GET_OFFSET:
-		{
+	case OBSOLETE_PMAC_NVRAM_GET_OFFSET:
+	case IOC_NVRAM_GET_OFFSET: {
 			int part, offset;
 			if (copy_from_user(&part,(void*)arg,sizeof(part))!=0)
 				return -EFAULT;
@@ -89,6 +89,9 @@
 				return -EFAULT;
 			break;
 		}
+	case IOC_NVRAM_SYNC:
+		pmac_nvram_sync();
+		break;
 
 		default:
 			return -EINVAL;
diff -urN kernel-source-2.4.27/drivers/macintosh/therm_pismo.c kernel-source-2.4.27-benh/drivers/macintosh/therm_pismo.c
--- kernel-source-2.4.27/drivers/macintosh/therm_pismo.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/macintosh/therm_pismo.c	2004-09-01 20:56:26.126147280 +0200
@@ -0,0 +1,269 @@
+/*
+ * Device driver for the i2c thermostat found on some laptops
+ *
+ * Copyright (C) 2001 Benjamin Herrenschmidt
+ * 
+ * Actually, there are 2 DS1775R1 on uninorth I2C busses
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/sections.h>
+
+#define DEBUG
+
+#define I2C_THERMOSTAT_ADDR	0x49
+#define I2C_THERMOSTAT_ADDR2	0x48
+#define MAX_THERMOSTATS		4
+
+
+MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
+MODULE_DESCRIPTION("Driver for DS1775 thermostat on Apple laptops");
+MODULE_LICENSE("GPL");
+EXPORT_NO_SYMBOLS;
+
+struct temp_range
+{
+	u8	high;	/* Start the fan */
+	u8	low;	/* Stop the fan */
+};
+
+struct apple_thermal_info {
+	u8			id;			/* Implementation ID */
+	u8			fan_count;		/* Number of fans */
+	u8			thermostat_count;	/* Number of thermostats */
+	u8			unused[5];
+	struct temp_range	ranges[4];		/* Temperature ranges (may be [])*/
+};
+
+struct thermostat {
+	struct i2c_client	clt;
+	int			th_num;
+	// more to come ?
+};
+
+static struct apple_thermal_info *thinfo;
+static struct thermostat* thermostats[MAX_THERMOSTATS];
+static int therm_count;
+
+static int	attach_thermostat(struct i2c_adapter *adapter);
+static int	detach_thermostat(struct i2c_client *client);
+
+/* What is this supposed to be ? registered ? I hate
+ * magic numbers like that ...
+ */
+#define I2C_DRIVERID_THERMOSTAT (0xDEAD)
+
+static struct i2c_driver thermostat_driver = {  
+	name:		"Apple Thermostat",
+	id:		I2C_DRIVERID_THERMOSTAT,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	&attach_thermostat,
+	detach_client:	&detach_thermostat,
+	command:	NULL,
+	inc_use:	NULL,
+	dec_use:	NULL 
+};
+
+static int
+write_reg(struct thermostat* th, int reg, u8* data, int len)
+{
+	u8 tmp[5];
+	int rc;
+	
+	if (len > 4)
+		return -EINVAL;
+	tmp[0] = reg;
+	memcpy(&tmp[1], data, len);
+	rc = i2c_master_send(&th->clt, (const char *)tmp, len+1);
+	if (rc < 0)
+		return rc;
+	if (rc != (len+1))
+		return -ENODEV;
+	return 0;
+}
+
+static int
+read_reg(struct thermostat* th, int reg, u8* data, int len)
+{
+	u8 reg_addr;
+	int rc;
+
+	reg_addr = (u8)reg;
+	rc = i2c_master_send(&th->clt, &reg_addr, 1);
+	if (rc < 0)
+		return rc;
+	if (rc != 1)
+		return -ENODEV;
+	rc = i2c_master_recv(&th->clt, (char *)data, len);
+	if (rc < 0)
+		return rc;
+	if (rc != len)
+		return -ENODEV;
+	return 0;
+}
+
+static int
+attach_one_thermostat(struct i2c_adapter *adapter, int addr, int num)
+{
+	struct thermostat* th;
+	int rc;
+	u16 t, tlo, thi;
+	u8 config;
+	
+	if (therm_count >= MAX_THERMOSTATS) {
+		printk(KERN_WARNING "Skipped thermostat %d (%s:%x), max count reached !\n",
+			num, adapter->name, addr);
+		return -ENODEV;
+	}
+	
+	th = (struct thermostat *)kmalloc(sizeof(struct thermostat), GFP_KERNEL);
+	if (!th)
+		return -ENOMEM;
+	th->clt.addr = addr;
+	th->clt.adapter = adapter;
+	th->clt.driver = &thermostat_driver;
+	th->clt.flags = 0;
+	th->clt.data = (void *)therm_count;
+	th->th_num = num;
+	strcpy(th->clt.name, "thermostat");
+
+	rc = read_reg(th, 1, &config, 1);
+	if (rc < 0) {
+		printk(KERN_ERR "Thermostat %d (%s:%x) failed to read config !\n",
+			num, adapter->name, addr);
+		kfree(th);
+		return -ENODEV;
+	}
+	printk(KERN_INFO "Thermostat %d (%s:%x), config: %02x\n",
+		num, adapter->name, addr, config);
+
+	rc = read_reg(th, 0, (u8 *)&t, 2);
+	if (rc < 0) {
+		printk(KERN_ERR "Thermostat %d (%s:%x) failed to read temp !\n",
+			num, adapter->name, addr);
+		kfree(th);
+		return -ENODEV;
+	}
+	printk(KERN_INFO "Thermostat %d (%s:%x), temp: %04x (about: %d degree C)\n",
+		num, adapter->name, addr, t, t>>8);
+
+	thermostats[therm_count++] = th;
+
+	if (i2c_attach_client(&th->clt)) {
+		printk(KERN_ERR "Thermostat %d (%s:%x), failed to attach client !\n",
+			num, adapter->name, addr);
+		thermostats[--therm_count] = NULL;
+		kfree(th);
+		return -ENODEV;
+	}
+
+	tlo = thi = 0;
+	rc = read_reg(th, 2, (u8 *)&tlo, 2);
+	if (rc < 0) {
+		printk(KERN_WARNING "Thermostat %d (%s:%x) failed to read low threshold !\n",
+			num, adapter->name, addr);
+	}
+	rc = read_reg(th, 3, (u8 *)&thi, 2);
+	if (rc < 0) {
+		printk(KERN_WARNING "Thermostat %d (%s:%x) failed to read high threshold !\n",
+			num, adapter->name, addr);
+	}
+	printk(KERN_INFO "Thermostat %d (%s:%x), tl: %04x (%d degree C), th: %04x (%d degree C)\n",
+		num, adapter->name, addr, tlo, tlo>>8, thi, thi>>8);
+	return 0;
+}
+
+static int
+attach_thermostat(struct i2c_adapter *adapter)
+{
+	unsigned long bus_no;
+	int rc;
+
+	if (strncmp(adapter->name, "uni-n", 5))
+		return 0;
+	bus_no = simple_strtoul(adapter->name + 6, NULL, 10);	
+	rc = attach_one_thermostat(adapter, I2C_THERMOSTAT_ADDR, bus_no);
+	if (!rc && thinfo->thermostat_count > 2)
+		attach_one_thermostat(adapter, I2C_THERMOSTAT_ADDR2, bus_no+2);
+
+	return rc;
+}
+
+static int
+detach_thermostat(struct i2c_client *client)
+{
+	int index = (int)client->data;
+	struct thermostat* th;
+
+	if (index >= MAX_THERMOSTATS || !thermostats[index]) {
+		printk(KERN_ERR "Invalid client in deatch_thermostat()\n");
+		return -ENODEV;
+	}
+	th = thermostats[index];
+	i2c_detach_client(&th->clt);
+	thermostats[index] = NULL;
+	
+	kfree(th);
+
+	return 0;
+}
+
+static int __init
+thermostat_init(void)
+{
+	struct device_node* np;
+
+	if (!machine_is_compatible("PowerBook3,1"))
+		return -ENODEV;
+
+	np = find_devices("power-mgt");
+	if (!np)
+		return -ENODEV;
+	thinfo = (struct apple_thermal_info *)get_property(np, "thermal-info", NULL);
+	if (!thinfo)
+		return -ENODEV;
+		
+#ifdef DEBUG
+	printk(KERN_DEBUG " Thermal Infos found :\n");
+	printk(KERN_DEBUG "   implementation id : %d\n", thinfo->id);
+	printk(KERN_DEBUG "   fan_count         : %d\n", thinfo->fan_count);
+	printk(KERN_DEBUG "   thermostat_count  : %d\n", thinfo->thermostat_count);
+	printk(KERN_DEBUG "   ranges[0]         : %d,%d\n",
+		thinfo->ranges[0].high, thinfo->ranges[0].low);
+	printk(KERN_DEBUG "   ranges[1]         : %d,%d\n",
+		thinfo->ranges[1].high, thinfo->ranges[1].low);
+	printk(KERN_DEBUG "   ranges[2]         : %d,%d\n",
+		thinfo->ranges[2].high, thinfo->ranges[2].low);
+	printk(KERN_DEBUG "   ranges[3]         : %d,%d\n",
+		thinfo->ranges[3].high, thinfo->ranges[3].low);
+#endif
+	/* Check against titaniums & ibooks.... */
+	if (thinfo->id != 1 && thinfo->id != 2) {
+		printk(KERN_ERR "thermostat: design id %d unknown !\n", thinfo->id);
+		return -ENODEV;
+	}
+	
+	return i2c_add_driver(&thermostat_driver);
+}
+
+static void __exit
+thermostat_exit(void)
+{
+	i2c_del_driver(&thermostat_driver);
+}
+
+module_init(thermostat_init);
+module_exit(thermostat_exit);
diff -urN kernel-source-2.4.27/drivers/macintosh/therm_pm72.c kernel-source-2.4.27-benh/drivers/macintosh/therm_pm72.c
--- kernel-source-2.4.27/drivers/macintosh/therm_pm72.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/macintosh/therm_pm72.c	2004-09-01 20:56:26.210134512 +0200
@@ -0,0 +1,1179 @@
+/*
+ * Device driver for the thermostats & fan controller of  the
+ * Apple G5 "PowerMac7,2" desktop machines.
+ *
+ * (c) Copyright IBM Corp. 2003-2004
+ *
+ * Maintained by: Benjamin Herrenschmidt
+ *                <benh@kernel.crashing.org>
+ * 
+ *
+ * The algorithm used is the PID control algorithm, used the same
+ * way the published Darwin code does, using the same values that
+ * are present in the Darwin 7.0 snapshot property lists.
+ *
+ * As far as the CPUs control loops are concerned, I use the
+ * calibration & PID constants provided by the EEPROM,
+ * I do _not_ embed any value from the property lists, as the ones
+ * provided by Darwin 7.0 seem to always have an older version that
+ * what I've seen on the actual computers.
+ * It would be interesting to verify that though. Darwin has a
+ * version code of 1.0.0d11 for all control loops it seems, while
+ * so far, the machines EEPROMs contain a dataset versioned 1.0.0f
+ *
+ * Darwin doesn't provide source to all parts, some missing
+ * bits like the AppleFCU driver or the actual scale of some
+ * of the values returned by sensors had to be "guessed" some
+ * way... or based on what Open Firmware does.
+ *
+ * I didn't yet figure out how to get the slots power consumption
+ * out of the FCU, so that part has not been implemented yet and
+ * the slots fan is set to a fixed 50% PWM, hoping this value is
+ * safe enough ...
+ *
+ * Note: I have observed strange oscillations of the CPU control
+ * loop on a dual G5 here. When idle, the CPU exhaust fan tend to
+ * oscillates slowly (over several minutes) between the minimum
+ * of 300RPMs and approx. 1000 RPMs. I don't know what is causing
+ * this, it could be some incorrect constant or an error in the
+ * way I ported the algorithm, or it could be just normal. I
+ * don't have full understanding on the way Apple tweaked the PID
+ * algorithm for the CPU control, it is definitely not a standard
+ * implementation...
+ *
+ * TODO:  - Check MPU structure version/signature
+ *        - Add things like /sbin/overtemp for non-critical
+ *          overtemp conditions so userland can take some policy
+ *          decisions, like slewing down CPUs
+ *	  - Deal with fan and i2c failures in a better way
+ *
+ * History:
+ *
+ *  Nov. 13, 2003 : 0.5
+ *	- First release
+ *
+ *  Nov. 14, 2003 : 0.6
+ *	- Read fan speed from FCU, low level fan routines now deal
+ *	  with errors & check fan status, though higher level don't
+ *	  do much.
+ *	- Move a bunch of definitions to .h file
+ *
+ *  Nov. 18, 2003 : 0.7
+ *	- Fix build on ppc64 kernel
+ *	- Move back statics definitions to .c file
+ *	- Avoid calling schedule_timeout with a negative number
+ *
+ *  Dec. 18, 2003 : 0.8
+ *	- Fix typo when reading back fan speed on 2 CPU machines
+ *
+ *  Mar. 11, 2004 : 0.9
+ *	- Rework code accessing the ADC chips, make it more robust and
+ *	  closer to the chip spec. Also make sure it is configured properly,
+ *        I've seen yet unexplained cases where on startup, I would have stale
+ *        values in the configuration register
+ *	- Switch back to use of target fan speed for PID, thus lowering
+ *        pressure on i2c
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/wait.h>
+#include <linux/reboot.h>
+#include <linux/kmod.h>
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/sections.h>
+
+#include "therm_pm72.h"
+
+#define VERSION "0.9-lite"
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DBG(args...)	printk(args)
+#else
+#define DBG(args...)	do { } while(0)
+#endif
+
+/*
+ * i2c_driver structure to attach to the host i2c controller
+ */
+
+static int therm_pm72_attach(struct i2c_adapter *adapter);
+static int therm_pm72_detach(struct i2c_client *adapter);
+
+static struct i2c_driver therm_pm72_driver =
+{
+	.name		= "therm_pm72",
+	.id		= 0xDEADBEEF,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= therm_pm72_attach,
+	.detach_client	= therm_pm72_detach,
+};
+
+
+static inline void wait_ms(unsigned int ms)
+{
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout(1 + (ms * HZ + 999) / 1000);
+}
+
+/*
+ * Utility function to create an i2c_client structure and
+ * attach it to one of u3 adapters
+ */
+static struct i2c_client *attach_i2c_chip(int id, const char *name)
+{
+	struct i2c_client *clt;
+	struct i2c_adapter *adap;
+
+	if (id & 0x100)
+		adap = u3_1;
+	else
+		adap = u3_0;
+	if (adap == NULL)
+		return NULL;
+
+	clt = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (clt == NULL)
+		return NULL;
+	memset(clt, 0, sizeof(struct i2c_client));
+
+	clt->addr = (id >> 1) & 0x7f;
+	clt->adapter = adap;
+	clt->driver = &therm_pm72_driver;
+	clt->id = 0xDEADBEEF;
+	strncpy(clt->name, name, 31);
+
+	if (i2c_attach_client(clt)) {
+		printk(KERN_ERR "therm_pm72: Failed to attach to i2c ID 0x%x\n", id);
+		kfree(clt);
+		return NULL;
+	}
+	return clt;
+}
+
+/*
+ * Utility function to get rid of the i2c_client structure
+ * (will also detach from the adapter hopepfully)
+ */
+static void detach_i2c_chip(struct i2c_client *clt)
+{
+	i2c_detach_client(clt);
+	kfree(clt);
+}
+
+/*
+ * Here are the i2c chip access wrappers
+ */
+
+static void initialize_adc(struct cpu_pid_state *state)
+{
+	int rc;
+	u8 buf[2];
+
+	/* Read ADC the configuration register and cache it. We
+	 * also make sure Config2 contains proper values, I've seen
+	 * cases where we got stale grabage in there, thus preventing
+	 * proper reading of conv. values
+	 */
+
+	/* Clear Config2 */
+	buf[0] = 5;
+	buf[1] = 0;
+	i2c_master_send(state->monitor, buf, 2);
+
+	/* Read & cache Config1 */
+	buf[0] = 1;
+	rc = i2c_master_send(state->monitor, buf, 1);
+	if (rc > 0) {
+		rc = i2c_master_recv(state->monitor, buf, 1);
+		if (rc > 0) {
+			state->adc_config = buf[0];
+			DBG("ADC config reg: %02x\n", state->adc_config);
+			/* Disable shutdown mode */
+		       	state->adc_config &= 0xfe;
+			buf[0] = 1;
+			buf[1] = state->adc_config;
+			rc = i2c_master_send(state->monitor, buf, 2);
+		}
+	}
+	if (rc <= 0)
+		printk(KERN_ERR "therm_pm72: Error reading ADC config"
+		       " register !\n");
+}
+
+static int read_smon_adc(struct cpu_pid_state *state, int chan)
+{
+	int rc, data, tries = 0;
+	u8 buf[2];
+
+	for (;;) {
+		/* Set channel */
+		buf[0] = 1;
+		buf[1] = (state->adc_config & 0x1f) | (chan << 5);
+		rc = i2c_master_send(state->monitor, buf, 2);
+		if (rc <= 0)
+			goto error;
+		/* Wait for convertion */
+		wait_ms(1);
+		/* Switch to data register */
+		buf[0] = 4;
+		rc = i2c_master_send(state->monitor, buf, 1);
+		if (rc <= 0)
+			goto error;
+		/* Read result */
+		rc = i2c_master_recv(state->monitor, buf, 2);
+		if (rc < 0)
+			goto error;
+		data = ((u16)buf[0]) << 8 | (u16)buf[1];
+		return data >> 6;
+	error:
+		DBG("Error reading ADC, retrying...\n");
+		if (++tries > 10) {
+			printk(KERN_ERR "therm_pm72: Error reading ADC !\n");
+			return -1;
+		}
+		wait_ms(10);
+	}
+}
+
+static int fan_read_reg(int reg, unsigned char *buf, int nb)
+{
+	int tries, nr, nw;
+
+	buf[0] = reg;
+	tries = 0;
+	for (;;) {
+		nw = i2c_master_send(fcu, buf, 1);
+		if (nw > 0 || (nw < 0 && nw != -EIO) || tries >= 100)
+			break;
+		wait_ms(10);
+		++tries;
+	}
+	if (nw <= 0) {
+		printk(KERN_ERR "Failure writing address to FCU: %d", nw);
+		return -EIO;
+	}
+	tries = 0;
+	for (;;) {
+		nr = i2c_master_recv(fcu, buf, nb);
+		if (nr > 0 || (nr < 0 && nr != ENODEV) || tries >= 100)
+			break;
+		wait_ms(10);
+		++tries;
+	}
+	if (nr <= 0)
+		printk(KERN_ERR "Failure reading data from FCU: %d", nw);
+	return nr;
+}
+
+static int fan_write_reg(int reg, const unsigned char *ptr, int nb)
+{
+	int tries, nw;
+	unsigned char buf[16];
+
+	buf[0] = reg;
+	memcpy(buf+1, ptr, nb);
+	++nb;
+	tries = 0;
+	for (;;) {
+		nw = i2c_master_send(fcu, buf, nb);
+		if (nw > 0 || (nw < 0 && nw != EIO) || tries >= 100)
+			break;
+		wait_ms(10);
+		++tries;
+	}
+	if (nw < 0)
+		printk(KERN_ERR "Failure writing to FCU: %d", nw);
+	return nw;
+}
+
+static int set_rpm_fan(int fan, int rpm)
+{
+	unsigned char buf[2];
+	int rc;
+
+	if (rpm < 300)
+		rpm = 300;
+	else if (rpm > 8191)
+		rpm = 8191;
+	buf[0] = rpm >> 5;
+	buf[1] = rpm << 3;
+	rc = fan_write_reg(0x10 + (fan * 2), buf, 2);
+	if (rc < 0)
+		return -EIO;
+	return 0;
+}
+
+static int get_rpm_fan(int fan, int programmed)
+{
+	unsigned char failure;
+	unsigned char active;
+	unsigned char buf[2];
+	int rc, reg_base;
+
+	rc = fan_read_reg(0xb, &failure, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((failure & (1 << fan)) != 0)
+		return -EFAULT;
+	rc = fan_read_reg(0xd, &active, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((active & (1 << fan)) == 0)
+		return -ENXIO;
+
+	/* Programmed value or real current speed */
+	reg_base = programmed ? 0x10 : 0x11;
+	rc = fan_read_reg(reg_base + (fan * 2), buf, 2);
+	if (rc != 2)
+		return -EIO;
+
+	return (buf[0] << 5) | buf[1] >> 3;
+}
+
+static int set_pwm_fan(int fan, int pwm)
+{
+	unsigned char buf[2];
+	int rc;
+
+	if (pwm < 10)
+		pwm = 10;
+	else if (pwm > 100)
+		pwm = 100;
+	pwm = (pwm * 2559) / 1000;
+	buf[0] = pwm;
+	rc = fan_write_reg(0x30 + (fan * 2), buf, 1);
+	if (rc < 0)
+		return rc;
+	return 0;
+}
+
+static int get_pwm_fan(int fan)
+{
+	unsigned char failure;
+	unsigned char active;
+	unsigned char buf[2];
+	int rc;
+
+	rc = fan_read_reg(0x2b, &failure, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((failure & (1 << fan)) != 0)
+		return -EFAULT;
+	rc = fan_read_reg(0x2d, &active, 1);
+	if (rc != 1)
+		return -EIO;
+	if ((active & (1 << fan)) == 0)
+		return -ENXIO;
+
+	/* Programmed value or real current speed */
+	rc = fan_read_reg(0x30 + (fan * 2), buf, 1);
+	if (rc != 1)
+		return -EIO;
+
+	return (buf[0] * 1000) / 2559;
+}
+
+/*
+ * Utility routine to read the CPU calibration EEPROM data
+ * from the device-tree
+ */
+static int read_eeprom(int cpu, struct mpu_data *out)
+{
+	struct device_node *np;
+	char nodename[64];
+	u8 *data;
+	int len;
+
+	/* prom.c routine for finding a node by path is a bit brain dead
+	 * and requires exact @xxx unit numbers. This is a bit ugly but
+	 * will work for these machines
+	 */
+	sprintf(nodename, "/u3@0,f8000000/i2c@f8001000/cpuid@a%d", cpu ? 2 : 0);
+	np = find_path_device(nodename);
+	if (np == NULL) {
+		printk(KERN_ERR "therm_pm72: Failed to retreive cpuid node from device-tree\n");
+		return -ENODEV;
+	}
+	data = (u8 *)get_property(np, "cpuid", &len);
+	if (data == NULL) {
+		printk(KERN_ERR "therm_pm72: Failed to retreive cpuid property from device-tree\n");
+		return -ENODEV;
+	}
+	memcpy(out, data, sizeof(struct mpu_data));
+	
+	return 0;
+}
+
+/*
+ * CPUs fans control loop
+ */
+static void do_monitor_cpu(struct cpu_pid_state *state)
+{
+	s32 temp, voltage, current_a, power, power_target;
+	s32 integral, derivative, proportional, adj_in_target, sval;
+	s64 integ_p, deriv_p, prop_p, sum; 
+	int i, intake, rc;
+
+	DBG("cpu %d:\n", state->index);
+
+	/* Read current fan status */
+	if (state->index == 0)
+		rc = get_rpm_fan(CPUA_EXHAUST_FAN_RPM_ID, !RPM_PID_USE_ACTUAL_SPEED);
+	else
+		rc = get_rpm_fan(CPUB_EXHAUST_FAN_RPM_ID, !RPM_PID_USE_ACTUAL_SPEED);
+	if (rc < 0) {
+		printk(KERN_WARNING "Error %d reading CPU %d exhaust fan !\n",
+		       rc, state->index);
+		/* XXX What do we do now ? */
+	} else
+		state->rpm = rc;
+	DBG("  current rpm: %d\n", state->rpm);
+
+	/* Get some sensor readings and scale it */
+	temp = read_smon_adc(state, 1);
+	if (temp == -1) {
+		state->overtemp++;
+		return;
+	}
+	voltage = read_smon_adc(state, 3);
+	current_a = read_smon_adc(state, 4);
+
+	/* Fixup temperature according to diode calibration
+	 */
+	DBG("  temp raw: %04x, m_diode: %04x, b_diode: %04x\n",
+	    temp, state->mpu.mdiode, state->mpu.bdiode);
+	temp = ((s32)temp * (s32)state->mpu.mdiode + ((s32)state->mpu.bdiode << 12)) >> 2;
+	state->last_temp = temp;
+	DBG("  temp: %d.%03d\n", FIX32TOPRINT(temp));
+
+	/* Check tmax, increment overtemp if we are there. At tmax+8, we go
+	 * full blown immediately and try to trigger a shutdown
+	 */
+	if (temp >= ((state->mpu.tmax + 8) << 16)) {
+		printk(KERN_WARNING "Warning ! CPU %d temperature way above maximum"
+		       " (%d) !\n",
+		       state->index, temp >> 16);
+		state->overtemp = CPU_MAX_OVERTEMP;
+	} else if (temp > (state->mpu.tmax << 16))
+		state->overtemp++;
+	else
+		state->overtemp = 0;
+	if (state->overtemp >= CPU_MAX_OVERTEMP)
+		critical_state = 1;
+	if (state->overtemp > 0) {
+		state->rpm = state->mpu.rmaxn_exhaust_fan;
+		state->intake_rpm = intake = state->mpu.rmaxn_intake_fan;
+		goto do_set_fans;
+	}
+	
+	/* Scale other sensor values according to fixed scales
+	 * obtained in Darwin and calculate power from I and V
+	 */
+	state->voltage = voltage *= ADC_CPU_VOLTAGE_SCALE;
+	state->current_a = current_a *= ADC_CPU_CURRENT_SCALE;
+	power = (((u64)current_a) * ((u64)voltage)) >> 16;
+
+	/* Calculate power target value (could be done once for all)
+	 * and convert to a 16.16 fp number
+	 */
+	power_target = ((u32)(state->mpu.pmaxh - state->mpu.padjmax)) << 16;
+
+	DBG("  current: %d.%03d, voltage: %d.%03d\n",
+	    FIX32TOPRINT(current_a), FIX32TOPRINT(voltage));
+	DBG("  power: %d.%03d W, target: %d.%03d, error: %d.%03d\n", FIX32TOPRINT(power),
+	    FIX32TOPRINT(power_target), FIX32TOPRINT(power_target - power));
+
+	/* Store temperature and power in history array */
+	state->cur_temp = (state->cur_temp + 1) % CPU_TEMP_HISTORY_SIZE;
+	state->temp_history[state->cur_temp] = temp;
+	state->cur_power = (state->cur_power + 1) % state->count_power;
+	state->power_history[state->cur_power] = power;
+	state->error_history[state->cur_power] = power_target - power;
+	
+	/* If first loop, fill the history table */
+	if (state->first) {
+		for (i = 0; i < (state->count_power - 1); i++) {
+			state->cur_power = (state->cur_power + 1) % state->count_power;
+			state->power_history[state->cur_power] = power;
+			state->error_history[state->cur_power] = power_target - power;
+		}
+		for (i = 0; i < (CPU_TEMP_HISTORY_SIZE - 1); i++) {
+			state->cur_temp = (state->cur_temp + 1) % CPU_TEMP_HISTORY_SIZE;
+			state->temp_history[state->cur_temp] = temp;			
+		}
+		state->first = 0;
+	}
+
+	/* Calculate the integral term normally based on the "power" values */
+	sum = 0;
+	integral = 0;
+	for (i = 0; i < state->count_power; i++)
+		integral += state->error_history[i];
+	integral *= CPU_PID_INTERVAL;
+	DBG("  integral: %08x\n", integral);
+
+	/* Calculate the adjusted input (sense value).
+	 *   G_r is 12.20
+	 *   integ is 16.16
+	 *   so the result is 28.36
+	 *
+	 * input target is mpu.ttarget, input max is mpu.tmax
+	 */
+	integ_p = ((s64)state->mpu.pid_gr) * (s64)integral;
+	DBG("   integ_p: %d\n", (int)(deriv_p >> 36));
+	sval = (state->mpu.tmax << 16) - ((integ_p >> 20) & 0xffffffff);
+	adj_in_target = (state->mpu.ttarget << 16);
+	if (adj_in_target > sval)
+		adj_in_target = sval;
+	DBG("   adj_in_target: %d.%03d, ttarget: %d\n", FIX32TOPRINT(adj_in_target),
+	    state->mpu.ttarget);
+
+	/* Calculate the derivative term */
+	derivative = state->temp_history[state->cur_temp] -
+		state->temp_history[(state->cur_temp + CPU_TEMP_HISTORY_SIZE - 1)
+				    % CPU_TEMP_HISTORY_SIZE];
+	derivative /= CPU_PID_INTERVAL;
+	deriv_p = ((s64)state->mpu.pid_gd) * (s64)derivative;
+	DBG("   deriv_p: %d\n", (int)(deriv_p >> 36));
+	sum += deriv_p;
+
+	/* Calculate the proportional term */
+	proportional = temp - adj_in_target;
+	prop_p = ((s64)state->mpu.pid_gp) * (s64)proportional;
+	DBG("   prop_p: %d\n", (int)(prop_p >> 36));
+	sum += prop_p;
+
+	/* Scale sum */
+	sum >>= 36;
+
+	DBG("   sum: %d\n", (int)sum);
+	state->rpm += (s32)sum;
+
+	if (state->rpm < state->mpu.rminn_exhaust_fan)
+		state->rpm = state->mpu.rminn_exhaust_fan;
+	if (state->rpm > state->mpu.rmaxn_exhaust_fan)
+		state->rpm = state->mpu.rmaxn_exhaust_fan;
+
+	intake = (state->rpm * CPU_INTAKE_SCALE) >> 16;
+	if (intake < state->mpu.rminn_intake_fan)
+		intake = state->mpu.rminn_intake_fan;
+	if (intake > state->mpu.rmaxn_intake_fan)
+		intake = state->mpu.rmaxn_intake_fan;
+	state->intake_rpm = intake;
+
+ do_set_fans:
+	DBG("** CPU %d RPM: %d Ex, %d In, overtemp: %d\n",
+	    state->index, (int)state->rpm, intake, state->overtemp);
+
+	/* We should check for errors, shouldn't we ? But then, what
+	 * do we do once the error occurs ? For FCU notified fan
+	 * failures (-EFAULT) we probably want to notify userland
+	 * some way...
+	 */
+	if (state->index == 0) {
+		set_rpm_fan(CPUA_INTAKE_FAN_RPM_ID, intake);
+		set_rpm_fan(CPUA_EXHAUST_FAN_RPM_ID, state->rpm);
+	} else {
+		set_rpm_fan(CPUB_INTAKE_FAN_RPM_ID, intake);
+		set_rpm_fan(CPUB_EXHAUST_FAN_RPM_ID, state->rpm);
+	}
+}
+
+/*
+ * Initialize the state structure for one CPU control loop
+ */
+static int init_cpu_state(struct cpu_pid_state *state, int index)
+{
+	state->index = index;
+	state->first = 1;
+	state->rpm = 1000;
+	state->overtemp = 0;
+	state->adc_config = 0x00;
+
+	if (index == 0)
+		state->monitor = attach_i2c_chip(SUPPLY_MONITOR_ID, "CPU0_monitor");
+	else if (index == 1)
+		state->monitor = attach_i2c_chip(SUPPLY_MONITORB_ID, "CPU1_monitor");
+	if (state->monitor == NULL)
+		goto fail;
+
+	if (read_eeprom(index, &state->mpu))
+		goto fail;
+
+	state->count_power = state->mpu.tguardband;
+	if (state->count_power > CPU_POWER_HISTORY_SIZE) {
+		printk(KERN_WARNING "Warning ! too many power history slots\n");
+		state->count_power = CPU_POWER_HISTORY_SIZE;
+	}
+	DBG("CPU %d Using %d power history entries\n", index, state->count_power);
+
+	return 0;
+ fail:
+	if (state->monitor)
+		detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+	
+	return -ENODEV;
+}
+
+/*
+ * Dispose of the state data for one CPU control loop
+ */
+static void dispose_cpu_state(struct cpu_pid_state *state)
+{
+	if (state->monitor == NULL)
+		return;
+
+	detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+}
+
+/*
+ * Motherboard backside & U3 heatsink fan control loop
+ */
+static void do_monitor_backside(struct backside_pid_state *state)
+{
+	s32 temp, integral, derivative;
+	s64 integ_p, deriv_p, prop_p, sum; 
+	int i, rc;
+
+	if (--state->ticks != 0)
+		return;
+	state->ticks = BACKSIDE_PID_INTERVAL;
+
+	DBG("backside:\n");
+
+	/* Check fan status */
+	rc = get_pwm_fan(BACKSIDE_FAN_PWM_ID);
+	if (rc < 0) {
+		printk(KERN_WARNING "Error %d reading backside fan !\n", rc);
+		/* XXX What do we do now ? */
+	} else
+		state->pwm = rc;
+	DBG("  current pwm: %d\n", state->pwm);
+
+	/* Get some sensor readings */
+	temp = i2c_smbus_read_byte_data(state->monitor, MAX6690_EXT_TEMP) << 16;
+	state->last_temp = temp;
+	DBG("  temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),
+	    FIX32TOPRINT(BACKSIDE_PID_INPUT_TARGET));
+
+	/* Store temperature and error in history array */
+	state->cur_sample = (state->cur_sample + 1) % BACKSIDE_PID_HISTORY_SIZE;
+	state->sample_history[state->cur_sample] = temp;
+	state->error_history[state->cur_sample] = temp - BACKSIDE_PID_INPUT_TARGET;
+	
+	/* If first loop, fill the history table */
+	if (state->first) {
+		for (i = 0; i < (BACKSIDE_PID_HISTORY_SIZE - 1); i++) {
+			state->cur_sample = (state->cur_sample + 1) %
+				BACKSIDE_PID_HISTORY_SIZE;
+			state->sample_history[state->cur_sample] = temp;
+			state->error_history[state->cur_sample] =
+				temp - BACKSIDE_PID_INPUT_TARGET;
+		}
+		state->first = 0;
+	}
+
+	/* Calculate the integral term */
+	sum = 0;
+	integral = 0;
+	for (i = 0; i < BACKSIDE_PID_HISTORY_SIZE; i++)
+		integral += state->error_history[i];
+	integral *= BACKSIDE_PID_INTERVAL;
+	DBG("  integral: %08x\n", integral);
+	integ_p = ((s64)BACKSIDE_PID_G_r) * (s64)integral;
+	DBG("   integ_p: %d\n", (int)(integ_p >> 36));
+	sum += integ_p;
+
+	/* Calculate the derivative term */
+	derivative = state->error_history[state->cur_sample] -
+		state->error_history[(state->cur_sample + BACKSIDE_PID_HISTORY_SIZE - 1)
+				    % BACKSIDE_PID_HISTORY_SIZE];
+	derivative /= BACKSIDE_PID_INTERVAL;
+	deriv_p = ((s64)BACKSIDE_PID_G_d) * (s64)derivative;
+	DBG("   deriv_p: %d\n", (int)(deriv_p >> 36));
+	sum += deriv_p;
+
+	/* Calculate the proportional term */
+	prop_p = ((s64)BACKSIDE_PID_G_p) * (s64)(state->error_history[state->cur_sample]);
+	DBG("   prop_p: %d\n", (int)(prop_p >> 36));
+	sum += prop_p;
+
+	/* Scale sum */
+	sum >>= 36;
+
+	DBG("   sum: %d\n", (int)sum);
+	state->pwm += (s32)sum;
+	if (state->pwm < BACKSIDE_PID_OUTPUT_MIN)
+		state->pwm = BACKSIDE_PID_OUTPUT_MIN;
+	if (state->pwm > BACKSIDE_PID_OUTPUT_MAX)
+		state->pwm = BACKSIDE_PID_OUTPUT_MAX;
+
+	DBG("** BACKSIDE PWM: %d\n", (int)state->pwm);
+	set_pwm_fan(BACKSIDE_FAN_PWM_ID, state->pwm);
+}
+
+/*
+ * Initialize the state structure for the backside fan control loop
+ */
+static int init_backside_state(struct backside_pid_state *state)
+{
+	state->ticks = 1;
+	state->first = 1;
+	state->pwm = 50;
+
+	state->monitor = attach_i2c_chip(BACKSIDE_MAX_ID, "backside_temp");
+	if (state->monitor == NULL)
+		return -ENODEV;
+
+	return 0;
+}
+
+/*
+ * Dispose of the state data for the backside control loop
+ */
+static void dispose_backside_state(struct backside_pid_state *state)
+{
+	if (state->monitor == NULL)
+		return;
+
+	detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+}
+ 
+/*
+ * Drives bay fan control loop
+ */
+static void do_monitor_drives(struct drives_pid_state *state)
+{
+	s32 temp, integral, derivative;
+	s64 integ_p, deriv_p, prop_p, sum; 
+	int i, rc;
+
+	if (--state->ticks != 0)
+		return;
+	state->ticks = DRIVES_PID_INTERVAL;
+
+	DBG("drives:\n");
+
+	/* Check fan status */
+	rc = get_rpm_fan(DRIVES_FAN_RPM_ID, !RPM_PID_USE_ACTUAL_SPEED);
+	if (rc < 0) {
+		printk(KERN_WARNING "Error %d reading drives fan !\n", rc);
+		/* XXX What do we do now ? */
+	} else
+		state->rpm = rc;
+	DBG("  current rpm: %d\n", state->rpm);
+
+	/* Get some sensor readings */
+	temp = le16_to_cpu(i2c_smbus_read_word_data(state->monitor, DS1775_TEMP)) << 8;
+	state->last_temp = temp;
+	DBG("  temp: %d.%03d, target: %d.%03d\n", FIX32TOPRINT(temp),
+	    FIX32TOPRINT(DRIVES_PID_INPUT_TARGET));
+
+	/* Store temperature and error in history array */
+	state->cur_sample = (state->cur_sample + 1) % DRIVES_PID_HISTORY_SIZE;
+	state->sample_history[state->cur_sample] = temp;
+	state->error_history[state->cur_sample] = temp - DRIVES_PID_INPUT_TARGET;
+	
+	/* If first loop, fill the history table */
+	if (state->first) {
+		for (i = 0; i < (DRIVES_PID_HISTORY_SIZE - 1); i++) {
+			state->cur_sample = (state->cur_sample + 1) %
+				DRIVES_PID_HISTORY_SIZE;
+			state->sample_history[state->cur_sample] = temp;
+			state->error_history[state->cur_sample] =
+				temp - DRIVES_PID_INPUT_TARGET;
+		}
+		state->first = 0;
+	}
+
+	/* Calculate the integral term */
+	sum = 0;
+	integral = 0;
+	for (i = 0; i < DRIVES_PID_HISTORY_SIZE; i++)
+		integral += state->error_history[i];
+	integral *= DRIVES_PID_INTERVAL;
+	DBG("  integral: %08x\n", integral);
+	integ_p = ((s64)DRIVES_PID_G_r) * (s64)integral;
+	DBG("   integ_p: %d\n", (int)(integ_p >> 36));
+	sum += integ_p;
+
+	/* Calculate the derivative term */
+	derivative = state->error_history[state->cur_sample] -
+		state->error_history[(state->cur_sample + DRIVES_PID_HISTORY_SIZE - 1)
+				    % DRIVES_PID_HISTORY_SIZE];
+	derivative /= DRIVES_PID_INTERVAL;
+	deriv_p = ((s64)DRIVES_PID_G_d) * (s64)derivative;
+	DBG("   deriv_p: %d\n", (int)(deriv_p >> 36));
+	sum += deriv_p;
+
+	/* Calculate the proportional term */
+	prop_p = ((s64)DRIVES_PID_G_p) * (s64)(state->error_history[state->cur_sample]);
+	DBG("   prop_p: %d\n", (int)(prop_p >> 36));
+	sum += prop_p;
+
+	/* Scale sum */
+	sum >>= 36;
+
+	DBG("   sum: %d\n", (int)sum);
+	state->rpm += (s32)sum;
+	if (state->rpm < DRIVES_PID_OUTPUT_MIN)
+		state->rpm = DRIVES_PID_OUTPUT_MIN;
+	if (state->rpm > DRIVES_PID_OUTPUT_MAX)
+		state->rpm = DRIVES_PID_OUTPUT_MAX;
+
+	DBG("** DRIVES RPM: %d\n", (int)state->rpm);
+	set_rpm_fan(DRIVES_FAN_RPM_ID, state->rpm);
+}
+
+/*
+ * Initialize the state structure for the drives bay fan control loop
+ */
+static int init_drives_state(struct drives_pid_state *state)
+{
+	state->ticks = 1;
+	state->first = 1;
+	state->rpm = 1000;
+
+	state->monitor = attach_i2c_chip(DRIVES_DALLAS_ID, "drives_temp");
+	if (state->monitor == NULL)
+		return -ENODEV;
+
+	return 0;
+}
+
+/*
+ * Dispose of the state data for the drives control loop
+ */
+static void dispose_drives_state(struct drives_pid_state *state)
+{
+	if (state->monitor == NULL)
+		return;
+
+	detach_i2c_chip(state->monitor);
+	state->monitor = NULL;
+}
+
+static int call_critical_overtemp(void)
+{
+	char *argv[] = { critical_overtemp_path, NULL };
+	static char *envp[] = { "HOME=/",
+				"TERM=linux",
+				"PATH=/sbin:/usr/sbin:/bin:/usr/bin",
+				NULL };
+
+	return call_usermodehelper(critical_overtemp_path, argv, envp);
+}
+
+
+/*
+ * Here's the kernel thread that calls the various control loops
+ */
+static int main_control_loop(void *x)
+{
+	lock_kernel();
+
+        strcpy(current->comm, "kfand");		
+	daemonize();
+	reparent_to_init();
+        sigfillset(&current->blocked);
+ 
+	unlock_kernel();
+ 
+	DBG("main_control_loop started\n");
+
+	down(&driver_lock);
+
+	/* Set the PCI fan once for now */
+	set_pwm_fan(SLOTS_FAN_PWM_ID, SLOTS_FAN_DEFAULT_PWM);
+
+	/* Initialize ADCs */
+	initialize_adc(&cpu_state[0]);
+	if (cpu_state[1].monitor != NULL)
+		initialize_adc(&cpu_state[1]);
+
+	up(&driver_lock);
+
+	while (state == state_attached) {
+		unsigned long elapsed, start;
+
+		start = jiffies;
+
+		down(&driver_lock);
+		do_monitor_cpu(&cpu_state[0]);
+		if (cpu_state[1].monitor != NULL)
+			do_monitor_cpu(&cpu_state[1]);
+		do_monitor_backside(&backside_state);
+		do_monitor_drives(&drives_state);
+		up(&driver_lock);
+
+		if (critical_state == 1) {
+			printk(KERN_WARNING "Temperature control detected a critical condition\n");
+			printk(KERN_WARNING "Attempting to shut down...\n");
+			if (call_critical_overtemp()) {
+				printk(KERN_WARNING "Can't call %s, power off now!\n",
+				       critical_overtemp_path);
+				machine_power_off();
+			}
+		}
+		if (critical_state > 0)
+			critical_state++;
+		if (critical_state > MAX_CRITICAL_STATE) {
+			printk(KERN_WARNING "Shutdown timed out, power off now !\n");
+			machine_power_off();
+		}
+
+		// FIXME: Deal with signals
+		set_current_state(TASK_INTERRUPTIBLE);
+		elapsed = jiffies - start;
+		if (elapsed < HZ)
+			schedule_timeout(HZ - elapsed);
+	}
+
+	DBG("main_control_loop ended\n");
+
+	ctrl_task = 0;
+	complete_and_exit(&ctrl_complete, 0);
+}
+
+/*
+ * Dispose the control loops when tearing down
+ */
+static void dispose_control_loops(void)
+{
+	dispose_cpu_state(&cpu_state[0]);
+	dispose_cpu_state(&cpu_state[1]);
+
+	dispose_backside_state(&backside_state);
+	dispose_drives_state(&drives_state);
+}
+
+/*
+ * Create the control loops. U3-0 i2c bus is up, so we can now
+ * get to the various sensors
+ */
+static int create_control_loops(void)
+{
+	struct device_node *np;
+
+	/* Count CPUs from the device-tree, we don't care how many are
+	 * actually used by Linux
+	 */
+	cpu_count = 0;
+	np = find_type_devices("cpu");
+	while(np) {
+		cpu_count++;
+		np = np->next;
+	}
+
+	DBG("counted %d CPUs in the device-tree\n", cpu_count);
+
+	/* Create control loops for everything. If any fail, everything
+	 * fails
+	 */
+	if (init_cpu_state(&cpu_state[0], 0))
+		goto fail;
+	if (cpu_count > 1 && init_cpu_state(&cpu_state[1], 1))
+		goto fail;
+	if (init_backside_state(&backside_state))
+		goto fail;
+	if (init_drives_state(&drives_state))
+		goto fail;
+
+	DBG("all control loops up !\n");
+
+	return 0;
+	
+ fail:
+	DBG("failure creating control loops, disposing\n");
+
+	dispose_control_loops();
+
+	return -ENODEV;
+}
+
+/*
+ * Start the control loops after everything is up, that is create
+ * the thread that will make them run
+ */
+static void start_control_loops(void)
+{
+	init_completion(&ctrl_complete);
+
+	ctrl_task = kernel_thread(main_control_loop, NULL,
+				  CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
+}
+
+/*
+ * Stop the control loops when tearing down
+ */
+static void stop_control_loops(void)
+{
+	if (ctrl_task != 0)
+		wait_for_completion(&ctrl_complete);
+}
+
+/*
+ * Attach to the i2c FCU after detecting U3-1 bus
+ */
+static int attach_fcu(void)
+{
+	fcu = attach_i2c_chip(FAN_CTRLER_ID, "fcu");
+	if (fcu == NULL)
+		return -ENODEV;
+
+	DBG("FCU attached\n");
+
+	return 0;
+}
+
+/*
+ * Detach from the i2c FCU when tearing down
+ */
+static void detach_fcu(void)
+{
+	if (fcu)
+		detach_i2c_chip(fcu);
+	fcu = NULL;
+}
+
+/*
+ * Attach to the i2c controller. We probe the various chips based
+ * on the device-tree nodes and build everything for the driver to
+ * run, we then kick the driver monitoring thread
+ */
+static int therm_pm72_attach(struct i2c_adapter *adapter)
+{
+	down(&driver_lock);
+
+	/* Check state */
+	if (state == state_detached)
+		state = state_attaching;
+	if (state != state_attaching) {
+		up(&driver_lock);
+		return 0;
+	}
+
+	/* Check if we are looking for one of these */
+	if (u3_0 == NULL && !strcmp(adapter->name, "u3 0")) {
+		u3_0 = adapter;
+		DBG("found U3-0, creating control loops\n");
+		if (create_control_loops())
+			u3_0 = NULL;
+	} else if (u3_1 == NULL && !strcmp(adapter->name, "u3 1")) {
+		u3_1 = adapter;
+		DBG("found U3-1, attaching FCU\n");
+		if (attach_fcu())
+			u3_1 = NULL;
+	}
+	/* We got all we need, start control loops */
+	if (u3_0 != NULL && u3_1 != NULL) {
+		DBG("everything up, starting control loops\n");
+		state = state_attached;
+		start_control_loops();
+	}
+	up(&driver_lock);
+
+	return 0;
+}
+
+/*
+ * Called on every adapter when the driver or the i2c controller
+ * is going away.
+ */
+static int therm_pm72_detach(struct i2c_client *client)
+{
+	int detach_u3_0 = 0;
+	int detach_u3_1 = 0;
+
+	down(&driver_lock);
+
+	/* Gross hack for 2.4 ! */
+	if (client == fcu)
+		detach_u3_1 = 1;
+	else
+		detach_u3_0 = 1;
+
+	if (state != state_detached)
+		state = state_detaching;
+
+	/* Stop control loops if any */
+	DBG("stopping control loops\n");
+	up(&driver_lock);
+	stop_control_loops();
+	down(&driver_lock);
+
+	if (u3_0 != NULL && detach_u3_0) {
+		DBG("lost U3-0, disposing control loops\n");
+		dispose_control_loops();
+		u3_0 = NULL;
+	}
+	
+	if (u3_1 != NULL && detach_u3_1) {
+		DBG("lost U3-1, detaching FCU\n");
+		detach_fcu();
+		u3_1 = NULL;
+	}
+	if (u3_0 == NULL && u3_1 == NULL)
+		state = state_detached;
+
+	up(&driver_lock);
+
+	return 0;
+}
+
+
+/*
+ * Check machine type, attach to i2c controller
+ */
+static int __init therm_pm72_init(void)
+{
+	int rc;
+
+	if (!machine_is_compatible("PowerMac7,2"))
+	    	return -ENODEV;
+
+	state = state_detached;
+
+	printk(KERN_INFO "PowerMac G5 Thermal control driver %s\n", VERSION);
+
+	rc = i2c_add_driver(&therm_pm72_driver);
+	if (rc < 0)
+		return rc;
+	return 0;
+
+
+}
+
+static void __exit therm_pm72_exit(void)
+{
+	i2c_del_driver(&therm_pm72_driver);
+}
+
+module_init(therm_pm72_init);
+module_exit(therm_pm72_exit);
+
+MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
+MODULE_DESCRIPTION("Driver for Apple's PowerMac7,2 G5 thermal control");
+MODULE_LICENSE("GPL");
+
diff -urN kernel-source-2.4.27/drivers/macintosh/therm_pm72.h kernel-source-2.4.27-benh/drivers/macintosh/therm_pm72.h
--- kernel-source-2.4.27/drivers/macintosh/therm_pm72.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/macintosh/therm_pm72.h	2004-09-01 20:56:26.212134208 +0200
@@ -0,0 +1,250 @@
+#ifndef __THERM_PMAC_7_2_H__
+#define __THERM_PMAC_7_2_H__
+
+typedef unsigned short fu16;
+typedef int fs32;
+typedef short fs16;
+
+struct mpu_data
+{
+	u8	signature;		/* 0x00 - EEPROM sig. */
+	u8	bytes_used;		/* 0x01 - Bytes used in eeprom (160 ?) */
+	u8	size;			/* 0x02 - EEPROM size (256 ?) */
+	u8	version;		/* 0x03 - EEPROM version */
+	u32	data_revision;		/* 0x04 - Dataset revision */
+	u8	processor_bin_code[3];	/* 0x08 - Processor BIN code */
+	u8	bin_code_expansion;	/* 0x0b - ??? (padding ?) */
+	u8	processor_num;		/* 0x0c - Number of CPUs on this MPU */
+	u8	input_mul_bus_div;	/* 0x0d - Clock input multiplier/bus divider */
+	u8	reserved1[2];		/* 0x0e - */
+	u32	input_clk_freq_high;	/* 0x10 - Input clock frequency high */
+	u8	cpu_nb_target_cycles;	/* 0x14 - ??? */
+	u8	cpu_statlat;		/* 0x15 - ??? */
+	u8	cpu_snooplat;		/* 0x16 - ??? */
+	u8	cpu_snoopacc;		/* 0x17 - ??? */
+	u8	nb_paamwin;		/* 0x18 - ??? */
+	u8	nb_statlat;		/* 0x19 - ??? */
+	u8	nb_snooplat;		/* 0x1a - ??? */
+	u8	nb_snoopwin;		/* 0x1b - ??? */
+	u8	api_bus_mode;		/* 0x1c - ??? */
+	u8	reserved2[3];		/* 0x1d - */
+	u32	input_clk_freq_low;	/* 0x20 - Input clock frequency low */
+	u8	processor_card_slot;	/* 0x24 - Processor card slot number */
+	u8	reserved3[2];		/* 0x25 - */
+	u8	padjmax;       		/* 0x27 - Max power adjustment (Not in OF!) */
+	u8	ttarget;		/* 0x28 - Target temperature */
+	u8	tmax;			/* 0x29 - Max temperature */
+	u8	pmaxh;			/* 0x2a - Max power */
+	u8	tguardband;		/* 0x2b - Guardband temp ??? Hist. len in OSX */
+	fs32	pid_gp;			/* 0x2c - PID proportional gain */
+	fs32	pid_gr;			/* 0x30 - PID reset gain */
+	fs32	pid_gd;			/* 0x34 - PID derivative gain */
+	fu16	voph;			/* 0x38 - Vop High */
+	fu16	vopl;			/* 0x3a - Vop Low */
+	fs16	nactual_die;		/* 0x3c - nActual Die */
+	fs16	nactual_heatsink;	/* 0x3e - nActual Heatsink */
+	fs16	nactual_system;		/* 0x40 - nActual System */
+	u16	calibration_flags;	/* 0x42 - Calibration flags */
+	fu16	mdiode;			/* 0x44 - Diode M value (scaling factor) */
+	fs16	bdiode;			/* 0x46 - Diode B value (offset) */
+	fs32	theta_heat_sink;	/* 0x48 - Theta heat sink */
+	u16	rminn_intake_fan;	/* 0x4c - Intake fan min RPM */
+	u16	rmaxn_intake_fan;	/* 0x4e - Intake fan max RPM */
+	u16	rminn_exhaust_fan;	/* 0x50 - Exhaust fan min RPM */
+	u16	rmaxn_exhaust_fan;	/* 0x52 - Exhaust fan max RPM */
+	u8	processor_part_num[8];	/* 0x54 - Processor part number */
+	u32	processor_lot_num;	/* 0x5c - Processor lot number */
+	u8	orig_card_sernum[0x10];	/* 0x60 - Card original serial number */
+	u8	curr_card_sernum[0x10];	/* 0x70 - Card current serial number */
+	u8	mlb_sernum[0x18];	/* 0x80 - MLB serial number */
+	u32	checksum1;		/* 0x98 - */
+	u32	checksum2;		/* 0x9c - */	
+}; /* Total size = 0xa0 */
+
+/* Display a 16.16 fixed point value */
+#define FIX32TOPRINT(f)	((f) >> 16),((((f) & 0xffff) * 1000) >> 16)
+
+/*
+ * Maximum number of seconds to be in critical state (after a
+ * normal shutdown attempt). If the machine isn't down after
+ * this counter elapses, we force an immediate machine power
+ * off.
+ */
+#define MAX_CRITICAL_STATE			30
+static char * critical_overtemp_path = "/sbin/critical_overtemp";
+
+/*
+ * This option is "weird" :) Basically, if you define this to 1
+ * the control loop for the RPMs fans (not PWMs) will apply the
+ * correction factor obtained from the PID to the _actual_ RPM
+ * speed read from the FCU.
+ * If you define the below constant to 0, then it will be
+ * applied to the setpoint RPM speed, that is basically the
+ * speed we proviously "asked" for.
+ *
+ * I'm not sure which of these Apple's algorithm is supposed
+ * to use
+ */
+#define RPM_PID_USE_ACTUAL_SPEED		0
+
+/*
+ * i2c IDs. Currently, we hard code those and assume that
+ * the FCU is on U3 bus 1 while all sensors are on U3 bus
+ * 0. This appear to be safe enough for this first version
+ * of the driver, though I would accept any clean patch
+ * doing a better use of the device-tree without turning the
+ * while i2c registration mecanism into a racy mess
+ */
+#define FAN_CTRLER_ID		0x15e
+#define SUPPLY_MONITOR_ID      	0x58
+#define SUPPLY_MONITORB_ID     	0x5a
+#define DRIVES_DALLAS_ID	0x94
+#define BACKSIDE_MAX_ID		0x98
+
+/*
+ * Some MAX6690 & DS1775 register definitions
+ */
+#define MAX6690_INT_TEMP	0
+#define MAX6690_EXT_TEMP	1
+#define DS1775_TEMP		0
+
+/*
+ * Scaling factors for the AD7417 ADC converters (except
+ * for the CPU diode which is obtained from the EEPROM).
+ * Those values are obtained from the property list of
+ * the darwin driver
+ */
+#define ADC_12V_CURRENT_SCALE	0x0320	/* _AD2 */
+#define ADC_CPU_VOLTAGE_SCALE	0x00a0	/* _AD3 */
+#define ADC_CPU_CURRENT_SCALE	0x1f40	/* _AD4 */
+
+/*
+ * PID factors for the U3/Backside fan control loop
+ */
+#define BACKSIDE_FAN_PWM_ID		1
+#define BACKSIDE_PID_G_d		0x02800000
+#define BACKSIDE_PID_G_p		0x00500000
+#define BACKSIDE_PID_G_r		0x00000000
+#define BACKSIDE_PID_INPUT_TARGET	0x00410000
+#define BACKSIDE_PID_INTERVAL		5
+#define BACKSIDE_PID_OUTPUT_MAX		100
+#define BACKSIDE_PID_OUTPUT_MIN		20
+#define BACKSIDE_PID_HISTORY_SIZE	2
+
+struct backside_pid_state
+{
+	int			ticks;
+	struct i2c_client *	monitor;
+	s32		       	sample_history[BACKSIDE_PID_HISTORY_SIZE];
+	s32			error_history[BACKSIDE_PID_HISTORY_SIZE];
+	int			cur_sample;
+	s32			last_temp;
+	int			pwm;
+	int			first;
+};
+
+/*
+ * PID factors for the Drive Bay fan control loop
+ */
+#define DRIVES_FAN_RPM_ID      		2
+#define DRIVES_PID_G_d			0x01e00000
+#define DRIVES_PID_G_p			0x00500000
+#define DRIVES_PID_G_r			0x00000000
+#define DRIVES_PID_INPUT_TARGET		0x00280000
+#define DRIVES_PID_INTERVAL    		5
+#define DRIVES_PID_OUTPUT_MAX		4000
+#define DRIVES_PID_OUTPUT_MIN		300
+#define DRIVES_PID_HISTORY_SIZE		2
+
+struct drives_pid_state
+{
+	int			ticks;
+	struct i2c_client *	monitor;
+	s32	       		sample_history[BACKSIDE_PID_HISTORY_SIZE];
+	s32			error_history[BACKSIDE_PID_HISTORY_SIZE];
+	int			cur_sample;
+	s32			last_temp;
+	int			rpm;
+	int			first;
+};
+
+#define SLOTS_FAN_PWM_ID       		2
+#define	SLOTS_FAN_DEFAULT_PWM		50 /* Do better here ! */
+
+/*
+ * IDs in Darwin for the sensors & fans
+ *
+ * CPU A AD7417_TEMP	10	(CPU A ambient temperature)
+ * CPU A AD7417_AD1	11	(CPU A diode temperature)
+ * CPU A AD7417_AD2	12	(CPU A 12V current)
+ * CPU A AD7417_AD3	13	(CPU A voltage)
+ * CPU A AD7417_AD4	14	(CPU A current)
+ *
+ * CPU A FAKE POWER	48	(I_V_inputs: 13, 14)
+ *
+ * CPU B AD7417_TEMP	15	(CPU B ambient temperature)
+ * CPU B AD7417_AD1	16	(CPU B diode temperature)
+ * CPU B AD7417_AD2	17	(CPU B 12V current)
+ * CPU B AD7417_AD3	18	(CPU B voltage)
+ * CPU B AD7417_AD4	19	(CPU B current)
+ *
+ * CPU B FAKE POWER	49	(I_V_inputs: 18, 19)
+ */
+
+#define CPUA_INTAKE_FAN_RPM_ID		3
+#define CPUA_EXHAUST_FAN_RPM_ID		4
+#define CPUB_INTAKE_FAN_RPM_ID		5
+#define CPUB_EXHAUST_FAN_RPM_ID		6
+
+#define CPU_INTAKE_SCALE		0x0000f852
+#define CPU_TEMP_HISTORY_SIZE		2
+#define CPU_POWER_HISTORY_SIZE		10
+#define CPU_PID_INTERVAL		1
+#define CPU_MAX_OVERTEMP		30
+
+struct cpu_pid_state
+{
+	int			index;
+	struct i2c_client *	monitor;
+	struct mpu_data		mpu;
+	int			overtemp;
+	s32	       		temp_history[CPU_TEMP_HISTORY_SIZE];
+	int			cur_temp;
+	s32			power_history[CPU_POWER_HISTORY_SIZE];
+	s32			error_history[CPU_POWER_HISTORY_SIZE];
+	int			cur_power;
+	int			count_power;
+	int			rpm;
+	int			intake_rpm;
+	s32			voltage;
+	s32			current_a;
+	s32			last_temp;
+	int			first;
+	u8			adc_config;
+};
+
+/*
+ * Driver statics
+ */
+
+static struct i2c_adapter *		u3_0;
+static struct i2c_adapter *		u3_1;
+static struct i2c_client *		fcu;
+static struct cpu_pid_state		cpu_state[2];
+static struct backside_pid_state	backside_state;
+static struct drives_pid_state		drives_state;
+static int				state;
+static int				cpu_count;
+static pid_t				ctrl_task;
+static struct completion		ctrl_complete;
+static int				critical_state;
+static DECLARE_MUTEX(driver_lock);
+
+enum {
+	state_detached,
+	state_attaching,
+	state_attached,
+	state_detaching,
+};
+
+#endif /* __THERM_PMAC_7_2_H__ */
diff -urN kernel-source-2.4.27/drivers/macintosh/therm_windtunnel.c kernel-source-2.4.27-benh/drivers/macintosh/therm_windtunnel.c
--- kernel-source-2.4.27/drivers/macintosh/therm_windtunnel.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/macintosh/therm_windtunnel.c	2004-09-01 20:56:26.370110192 +0200
@@ -0,0 +1,456 @@
+/* 
+ *   Creation Date: <2003/03/14 20:54:13 samuel>
+ *   Time-stamp: <2003/03/15 18:55:53 samuel>
+ *   
+ *	<therm_windtunnel.c>
+ *	
+ *	The G4 "windtunnel" has a single fan controlled by a
+ *	DS1775 fan controller and an ADM1030 thermostat.
+ *
+ *	The fan controller is equipped with a temperature sensor
+ *	which measures the case temperature. The ADM censor
+ *	measures the CPU temperature. This driver tunes the
+ *	behavior of the fan. It is based upon empirical observations
+ *	of the 'AppleFan' driver under OSX.
+ *
+ *	WARNING: This driver has only been testen on Apple's
+ *	1.25 MHz Dual G4 (March 03). Other machines might have
+ *	a different thermal design. It is tuned for a CPU
+ *	temperatur around 57 C.
+ *
+ *   Copyright (C) 2003 Samuel Rydh (samuel@ibrium.se)
+ *
+ *   Loosely based upon 'thermostat.c' written by Benjamin Herrenschmidt
+ *   
+ *   This program is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU General Public License
+ *   as published by the Free Software Foundation
+ *   
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+#include <asm/system.h>
+#include <asm/sections.h>
+
+MODULE_AUTHOR("Samuel Rydh <samuel@ibrium.se>");
+MODULE_DESCRIPTION("Apple G4 (windtunnel) fan driver");
+MODULE_LICENSE("GPL");
+EXPORT_NO_SYMBOLS;
+
+#define LOG_TEMP		0			/* continously log temperature */
+
+/* scan 0x48-0x4f (DS1775) and 0x2c-2x2f (ADM1030) */
+static unsigned short normal_i2c[] = { 0x49, 0x2c, I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { 0x48, 0x4f, 0x2c, 0x2f, I2C_CLIENT_END };
+
+I2C_CLIENT_INSMOD;
+
+#define I2C_DRIVERID_G4FAN	0x9001			/* fixme */
+
+#define THERMOSTAT_CLIENT_ID	1
+#define FAN_CLIENT_ID		2
+
+struct temp_range {
+	u8			high;			/* start the fan */
+	u8			low;			/* stop the fan */
+};
+struct apple_thermal_info {
+	u8			id;			/* implementation ID */
+	u8			fan_count;		/* number of fans */
+	u8			thermostat_count;	/* number of thermostats */
+	u8			unused[5];
+	struct temp_range	ranges[4];		/* temperature ranges (may be [])*/
+};
+
+static int do_detect( struct i2c_adapter *adapter, int addr,
+		      unsigned short flags, int kind );
+
+static struct {
+	struct i2c_client	*thermostat;
+	struct i2c_client	*fan;
+	int			error;
+	struct timer_list	timer;
+
+	int			overheat_temp;		/* 100% fan at this temp */
+	int			overheat_hyst;
+	int			temp;
+	int			casetemp;
+	int			fan_level;		/* active fan_table setting */
+
+	int			downind;
+	int			upind;
+
+	int			r0, r1, r20, r23, r25;	/* saved register */
+} x;
+
+static struct {
+	int			temp;
+	int			fan_setting;
+} fan_up_table[] = {
+	{ 0x0000, 11 },		/* min fan */
+	{ 0x3900, 8 },		/* 57.0 C */
+	{ 0x3a4a, 7 },		/* 58.3 C */
+	{ 0x3ad3, 6 },		/* 58.8 C */
+	{ 0x3b3c, 5 },		/* 59.2 C */
+	{ 0x3b94, 4 },		/* 59.6 C */
+	{ 0x3be3, 3 },		/* 58.9 C */
+	{ 0x3c29, 2 },		/* 59.2 C */
+	{ 0xffff, 1 }		/* on fire */
+};
+static struct {
+	int			temp;
+	int			fan_setting;
+} fan_down_table[] = {
+	{ 0x3700, 11 },		/* 55.0 C */
+	{ 0x374a, 6 },
+	{ 0x3800, 7 },		/* 56.0 C */
+	{ 0x3900, 8 },		/* 57.0 C */
+	{ 0x3a4a, 7 },		/* 58.3 C */
+	{ 0x3ad3, 6 },		/* 58.8 C */
+	{ 0x3b3c, 5 },		/* 59.2 C */
+	{ 0x3b94, 4 },		/* 58.9 C */
+	{ 0x3be3, 3 },		/* 58.9 C */
+	{ 0x3c29, 2 },		/* 59.2 C */
+	{ 0xffff, 1 }
+};
+
+static int
+write_reg( struct i2c_client *cl, int reg, int data, int len )
+{
+	u8 tmp[3];
+
+	if( len < 1 || len > 2 || data < 0 )
+		return -EINVAL;
+
+	tmp[0] = reg;
+	tmp[1] = (len == 1) ? data : (data >> 8);
+	tmp[2] = data;
+	len++;
+	
+	if( i2c_master_send(cl, tmp, len) != len )
+		return -ENODEV;
+	return 0;
+}
+
+static int
+read_reg( struct i2c_client *cl, int reg, int len )
+{
+	u8 buf[2];
+
+	if( len != 1 && len != 2 )
+		return -EINVAL;
+	buf[0] = reg;
+	if( i2c_master_send(cl, buf, 1) != 1 )
+		return -ENODEV;
+	if( i2c_master_recv(cl, buf, len) != len )
+		return -ENODEV;
+	return (len == 2)? ((unsigned int)buf[0] << 8) | buf[1] : buf[0];
+}
+
+
+static void
+print_temp( const char *s, int temp )
+{
+	printk("%s%d.%d C", s ? s : "", temp>>8, (temp & 255)*10/256 );
+}
+
+static void
+tune_fan( int fan_setting )
+{
+	int val = (fan_setting << 3) | 7;
+	x.fan_level = fan_setting;
+	
+	//write_reg( x.fan, 0x24, val, 1 );
+	write_reg( x.fan, 0x25, val, 1 );
+	write_reg( x.fan, 0x20, 0, 1 );
+	print_temp("CPU-temp: ", x.temp );
+	if( x.casetemp )
+		print_temp(", Case: ", x.casetemp );
+	printk("  Tuning fan: %d (%02x)\n", fan_setting, val );
+
+
+static void
+poll_temp( void *param )
+{
+	int temp = read_reg( x.thermostat, 0, 2 );
+	int i, level, casetemp;
+
+	/* this actually occurs when the computer is loaded */
+	if( temp < 0 )
+		goto out;
+
+	casetemp = read_reg(x.fan, 0x0b, 1) << 8;
+	casetemp |= (read_reg(x.fan, 0x06, 1) & 0x7) << 5;
+
+	if( LOG_TEMP && x.temp != temp ) {
+		print_temp("CPU-temp: ", temp );
+		print_temp(", Case: ", casetemp );
+		printk(",  Fan: %d\n", x.fan_level );
+	}
+	x.temp = temp;
+	x.casetemp = casetemp;
+
+	level = -1;
+	for( i=0; (temp & 0xffff) > fan_down_table[i].temp ; i++ )
+		;
+	if( i < x.downind )
+		level = fan_down_table[i].fan_setting;
+	x.downind = i;
+
+	for( i=0; (temp & 0xfffe) >= fan_up_table[i+1].temp ; i++ )
+		;
+	if( x.upind < i )
+		level = fan_up_table[i].fan_setting;
+	x.upind = i;
+
+	if( level >= 0 )
+		tune_fan( level );
+ out:
+	x.timer.expires = jiffies + 8*HZ;
+	add_timer( &x.timer );
+}
+
+static void
+schedule_poll( unsigned long t )
+{
+	static struct tq_struct tqs = {
+		.routine = poll_temp,
+	};
+	schedule_task( &tqs );
+}
+
+/************************************************************************/
+/*	i2c probing and setup						*/
+/************************************************************************/
+
+static int
+do_attach( struct i2c_adapter *adapter )
+{
+	return i2c_probe( adapter, &addr_data, &do_detect );
+}
+
+static int
+do_detach( struct i2c_client *client )
+{
+	int err;
+
+	printk("do_detach: id %d\n", client->id );
+	if( (err=i2c_detach_client(client)) ) {
+		printk("failed to detach thermostat client\n");
+		return err;
+	}
+	kfree( client );
+	return 0;
+}
+
+static struct i2c_driver g4fan_driver = {  
+	.name		= "Apple G4 Thermostat/Fan",
+	.id		= I2C_DRIVERID_G4FAN,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter = &do_attach,
+	.detach_client	= &do_detach,
+	.command	= NULL,
+	.inc_use	= NULL,
+	.dec_use	= NULL 
+};
+
+static int
+detect_fan( struct i2c_client *cl )
+{
+	/* check that this is an ADM1030 */
+	if( read_reg(cl, 0x3d, 1) != 0x30 || read_reg(cl, 0x3e, 1) != 0x41 )
+		goto out;
+	printk("ADM1030 fan controller detected at %02x\n", cl->addr );
+
+	if( x.fan ) {
+		x.error |= 2;
+		goto out;
+	}
+	x.fan = cl;
+	cl->id = FAN_CLIENT_ID;
+	strncpy( cl->name, "ADM1030 fan controller", sizeof(cl->name) );
+
+	if( i2c_attach_client( cl ) )
+		goto out;
+	return 0;
+ out:
+	if( cl != x.fan )
+		kfree( cl );
+	return 0;
+}
+
+static int
+detect_thermostat( struct i2c_client *cl ) 
+{
+	int hyst_temp, os_temp, temp;
+
+	if( (temp=read_reg(cl, 0, 2)) < 0 )
+		goto out;
+	
+	/* temperature sanity check */
+	if( temp < 0x1600 || temp > 0x3c00 )
+		goto out;
+	hyst_temp = read_reg(cl, 2, 2);
+	os_temp = read_reg(cl, 3, 2);
+	if( hyst_temp < 0 || os_temp < 0 )
+		goto out;
+
+	printk("DS1775 digital thermometer detected at %02x\n", cl->addr );
+	print_temp("Temp: ", temp );
+	print_temp("  Hyst: ", hyst_temp );
+	print_temp("  OS: ", os_temp );
+	printk("\n");
+
+	if( x.thermostat ) {
+		x.error |= 1;
+		goto out;
+	}
+	x.temp = temp;
+	x.thermostat = cl;
+	x.overheat_temp = os_temp;
+	x.overheat_hyst = hyst_temp;
+	
+	cl->id = THERMOSTAT_CLIENT_ID;
+	strncpy( cl->name, "DS1775 thermostat", sizeof(cl->name) );
+
+	if( i2c_attach_client( cl ) )
+		goto out;
+	return 0;
+out:
+	kfree( cl );
+	return 0;
+}
+
+static int
+do_detect( struct i2c_adapter *adapter, int addr, unsigned short flags, int kind )
+{
+	struct i2c_client *cl;
+
+	if( strncmp(adapter->name, "uni-n", 5) )
+		return 0;
+	if( !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA | I2C_FUNC_SMBUS_WRITE_BYTE) )
+		return 0;
+
+	if( !(cl=kmalloc( sizeof(struct i2c_client), GFP_KERNEL )) )
+		return -ENOMEM;
+	memset( cl, 0, sizeof(struct i2c_client) );
+
+	cl->addr = addr;
+	cl->data = NULL;
+	cl->adapter = adapter;
+	cl->driver = &g4fan_driver;
+	cl->flags = 0;
+
+	if( addr < 0x48 )
+		return detect_fan( cl );
+	return detect_thermostat( cl );
+}
+
+#define PRINT_REG( r )	printk("reg %02x = %02x\n", r, read_reg(x.fan, r, 1) )
+
+static int __init
+g4fan_init( void )
+{
+	struct apple_thermal_info *info;
+	struct device_node *np;
+	int ret, val;
+	
+	if( !(np=find_devices("power-mgt")) )
+		return -ENODEV;
+	if( !(info=(struct apple_thermal_info*)get_property(np, "thermal-info", NULL)) )
+		return -ENODEV;
+	
+	/* check for G4 "Windtunnel" SMP */
+	if( machine_is_compatible("PowerMac3,6") ) {
+		if( info->id != 3 ) {
+			printk(KERN_ERR "g4fan: design id %d unknown\n", info->id);
+			return -ENODEV;
+		}
+	} else {
+		printk(KERN_ERR "g4fan: unsupported machine type\n");
+		return -ENODEV;
+	}
+	if( (ret=i2c_add_driver(&g4fan_driver)) )
+		return ret;
+
+	if( !x.thermostat || !x.fan ) {
+		i2c_del_driver(&g4fan_driver );
+		return -ENODEV;
+	}
+
+	/* save registers (if we unload the module) */
+	x.r0 = read_reg( x.fan, 0x00, 1 );
+	x.r1 = read_reg( x.fan, 0x01, 1 );
+	x.r20 = read_reg( x.fan, 0x20, 1 );
+	x.r23 = read_reg( x.fan, 0x23, 1 );
+	x.r25 = read_reg( x.fan, 0x25, 1 );
+
+	/* improve measurement resolution (convergence time 1.5s) */
+	if( (val=read_reg( x.thermostat, 1, 1 )) >= 0 ) {
+		val |= 0x60;
+		if( write_reg( x.thermostat, 1, val, 1 ) )
+			printk("Failed writing config register\n");
+	}
+	/* disable interrupts and TAC input */
+	write_reg( x.fan, 0x01, 0x01, 1 );
+	/* enable filter */
+	write_reg( x.fan, 0x23, 0x91, 1 );
+	/* remote temp. controls fan */
+	write_reg( x.fan, 0x00, 0x95, 1 );
+
+	/* The thermostat (which besides measureing temperature controls
+	 * has a THERM output which puts the fan on 100%) is usually
+	 * set to kick in at 80 C (chip default). We reduce this a bit
+	 * to be on the safe side (OSX doesn't)...
+	 */
+	if( x.overheat_temp == (80 << 8) ) {
+		x.overheat_temp = 65 << 8;
+		x.overheat_hyst = 60 << 8;
+		write_reg( x.thermostat, 2, x.overheat_hyst, 2 );
+		write_reg( x.thermostat, 3, x.overheat_temp, 2 );
+
+		print_temp("Reducing overheating limit to ", x.overheat_temp );
+		print_temp(" (Hyst: ", x.overheat_hyst );
+		printk(")\n");
+	}
+
+	/* set an initial fan setting */
+	x.upind = x.downind = 1;
+	tune_fan( fan_up_table[x.upind].fan_setting );
+
+	init_timer( &x.timer );
+	x.timer.expires = jiffies + 8*HZ;
+	x.timer.function = schedule_poll;
+	add_timer( &x.timer );
+	return 0;
+}
+
+static void __exit
+g4fan_exit( void )
+{
+	del_timer( &x.timer );
+
+	write_reg( x.fan, 0x01, x.r1, 1 );
+	write_reg( x.fan, 0x20, x.r20, 1 );
+	write_reg( x.fan, 0x23, x.r23, 1 );
+	write_reg( x.fan, 0x25, x.r25, 1 );
+	write_reg( x.fan, 0x00, x.r0, 1 );
+
+	i2c_del_driver( &g4fan_driver );
+}
+
+module_init(g4fan_init);
+module_exit(g4fan_exit);
+
diff -urN kernel-source-2.4.27/drivers/macintosh/via-pmu.c kernel-source-2.4.27-benh/drivers/macintosh/via-pmu.c
--- kernel-source-2.4.27/drivers/macintosh/via-pmu.c	2003-08-25 13:44:42.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/macintosh/via-pmu.c	2004-09-01 20:56:26.455097272 +0200
@@ -64,6 +64,13 @@
 /* How many iterations between battery polls */
 #define BATTERY_POLLING_COUNT	2
 
+/* Some debugging tools */
+#ifdef CONFIG_XMON
+//#define LIVE_DEBUG(req) ((req) && (req)->data[0] == 0x7d)
+#define LIVE_DEBUG(req) (0)
+static int whacky_debug;
+#endif /* CONFIG_XMON */
+
 static volatile unsigned char *via;
 
 /* VIA registers - spaced 0x200 bytes apart */
@@ -107,6 +114,7 @@
 	intack,
 	reading,
 	reading_intr,
+	locked,
 } pmu_state;
 
 static volatile enum int_data_state {
@@ -134,6 +142,7 @@
 static int pmu_has_adb;
 static unsigned char *gpio_reg = NULL;
 static int gpio_irq = -1;
+static int gpio_irq_enabled = -1;
 static volatile int pmu_suspended = 0;
 static spinlock_t pmu_lock;
 static u8 pmu_intr_mask;
@@ -144,10 +153,13 @@
 static int sleep_in_progress;
 static int can_sleep;
 #endif /* CONFIG_PMAC_PBOOK */
+static unsigned int pmu_irq_stats[11];
 
 static struct proc_dir_entry *proc_pmu_root;
 static struct proc_dir_entry *proc_pmu_info;
+static struct proc_dir_entry *proc_pmu_irqstats;
 static struct proc_dir_entry *proc_pmu_options;
+static int option_server_mode;
 
 #ifdef CONFIG_PMAC_PBOOK
 int pmu_battery_count;
@@ -185,6 +197,8 @@
 static void gpio1_interrupt(int irq, void *arg, struct pt_regs *regs);
 static int proc_get_info(char *page, char **start, off_t off,
 			  int count, int *eof, void *data);
+static int proc_get_irqstats(char *page, char **start, off_t off,
+			  int count, int *eof, void *data);
 #ifdef CONFIG_PMAC_BACKLIGHT
 static int pmu_set_backlight_level(int level, void* data);
 static int pmu_set_backlight_enable(int on, int level, void* data);
@@ -206,7 +220,7 @@
 	pmu_init,
 	pmu_send_request,
 	pmu_adb_autopoll,
-	pmu_poll,
+	pmu_poll_adb,
 	pmu_adb_reset_bus
 };
 #endif /* CONFIG_ADB */
@@ -324,7 +338,8 @@
 		pmu_kind = PMU_PADDINGTON_BASED;
 	else if (device_is_compatible(vias->parent, "heathrow"))
 		pmu_kind = PMU_HEATHROW_BASED;
-	else if (device_is_compatible(vias->parent, "Keylargo")) {
+	else if (device_is_compatible(vias->parent, "Keylargo")
+		 || device_is_compatible(vias->parent, "K2-Keylargo")) {
 		struct device_node *gpio, *gpiop;
 
 		pmu_kind = PMU_KEYLARGO_BASED;
@@ -339,6 +354,8 @@
 		if (gpiop && gpiop->n_addrs) {
 			gpio_reg = ioremap(gpiop->addrs->address, 0x10);
 			gpio = find_devices("extint-gpio1");
+			if (gpio == NULL)
+				gpio = find_devices("pmu-interrupt");
 			if (gpio && gpio->parent == gpiop && gpio->n_intrs)
 				gpio_irq = gpio->intrs[0].line;
 		}
@@ -419,6 +436,7 @@
 	if (pmu_kind == PMU_KEYLARGO_BASED && gpio_irq != -1) {
 		if (request_irq(gpio_irq, gpio1_interrupt, 0, "GPIO1/ADB", (void *)0))
 			printk(KERN_ERR "pmu: can't get irq %d (GPIO1)\n", gpio_irq);
+		gpio_irq_enabled = 1;
 	}
 
 	/* Enable interrupts */
@@ -466,6 +484,8 @@
 		int i;
 		proc_pmu_info = create_proc_read_entry("info", 0, proc_pmu_root,
 					proc_get_info, NULL);
+		proc_pmu_irqstats = create_proc_read_entry("interrupts", 0, proc_pmu_root,
+					proc_get_irqstats, NULL);
 #ifdef CONFIG_PMAC_PBOOK
 		for (i=0; i<pmu_battery_count; i++) {
 			char title[16];
@@ -540,11 +560,22 @@
 
 	/* Read PMU version */
 	pmu_request(&req, NULL, 1, PMU_GET_VERSION);
-	while (!req.complete)
-		pmu_poll();
+	pmu_wait_complete(&req);
 	if (req.reply_len > 0)
 		pmu_version = req.reply[0];
 
+	/* Read server mode setting */
+	if (pmu_kind == PMU_KEYLARGO_BASED) {
+		pmu_request(&req, NULL, 2, PMU_POWER_EVENTS,
+			    PMU_PWR_GET_POWERUP_EVENTS);
+		pmu_wait_complete(&req);
+		if (req.reply_len == 2) {
+			if (req.reply[1] & PMU_PWR_WAKEUP_AC_INSERT)
+				option_server_mode = 1;
+			printk(KERN_INFO "via-pmu: Server Mode is %s\n",
+			       option_server_mode ? "enabled" : "disabled");
+		}
+	}
 	return 1;
 }
 
@@ -563,6 +594,28 @@
 	last_jiffy_stamp(0) = tb_last_stamp = get_tbl();
 }
 
+static void pmu_set_server_mode(int server_mode)
+{
+	struct adb_request req;
+
+	if (pmu_kind != PMU_KEYLARGO_BASED)
+		return;
+
+	option_server_mode = server_mode;
+	pmu_request(&req, NULL, 2, PMU_POWER_EVENTS, PMU_PWR_GET_POWERUP_EVENTS);
+	pmu_wait_complete(&req);
+	if (req.reply_len < 2)
+		return;
+	if (server_mode)
+		pmu_request(&req, NULL, 4, PMU_POWER_EVENTS,
+			    PMU_PWR_SET_POWERUP_EVENTS,
+			    req.reply[0], PMU_PWR_WAKEUP_AC_INSERT); 
+	else
+		pmu_request(&req, NULL, 4, PMU_POWER_EVENTS,
+			    PMU_PWR_CLR_POWERUP_EVENTS,
+			    req.reply[0], PMU_PWR_WAKEUP_AC_INSERT); 
+	pmu_wait_complete(&req);
+}
 
 #ifdef CONFIG_PMAC_PBOOK
 
@@ -745,7 +798,7 @@
 
 #endif /* CONFIG_PMAC_PBOOK */
 
-static int
+static int __pmac
 proc_get_info(char *page, char **start, off_t off,
 		int count, int *eof, void *data)
 {
@@ -762,8 +815,35 @@
 	return p - page;
 }
 
+static int __pmac
+proc_get_irqstats(char *page, char **start, off_t off,
+		  int count, int *eof, void *data)
+{
+	int i;
+	char* p = page;
+	static const char *irq_names[] = {
+		"Total CB1 triggered events",
+		"Total GPIO1 triggered events",
+		"PC-Card eject button",
+		"Sound/Brightness button",
+		"ADB message",
+		"Battery state change",
+		"Environment interrupt",
+		"Tick timer",
+		"Ghost interrupt (zero len)",
+		"Empty interrupt (empty mask)",
+		"Max irqs in a row"
+        };
+
+	for (i=0; i<11; i++) {
+		p += sprintf(p, " %2u: %10u (%s)\n",
+			     i, pmu_irq_stats[i], irq_names[i]);
+	}
+	return p - page;
+}
+
 #ifdef CONFIG_PMAC_PBOOK
-static int
+static int __pmac
 proc_get_batt(char *page, char **start, off_t off,
 		int count, int *eof, void *data)
 {
@@ -788,7 +868,7 @@
 }
 #endif /* CONFIG_PMAC_PBOOK */
 
-static int
+static int __pmac
 proc_read_options(char *page, char **start, off_t off,
 			int count, int *eof, void *data)
 {
@@ -798,11 +878,13 @@
 	if (pmu_kind == PMU_KEYLARGO_BASED && can_sleep)
 		p += sprintf(p, "lid_wakeup=%d\n", option_lid_wakeup);
 #endif /* CONFIG_PMAC_PBOOK */
+	if (pmu_kind == PMU_KEYLARGO_BASED)
+		p += sprintf(p, "server_mode=%d\n", option_server_mode);
 
 	return p - page;
 }
 			
-static int
+static int __pmac
 proc_write_options(struct file *file, const char *buffer,
 			unsigned long count, void *data)
 {
@@ -833,17 +915,22 @@
 	while(*val == ' ')
 		val++;
 #ifdef CONFIG_PMAC_PBOOK
-	if (pmu_kind == PMU_KEYLARGO_BASED && can_sleep) {
+	if (pmu_kind == PMU_KEYLARGO_BASED && can_sleep)
 		if (!strcmp(label, "lid_wakeup"))
 			option_lid_wakeup = ((*val) == '1');
-	}
 #endif /* CONFIG_PMAC_PBOOK */
+	if (pmu_kind == PMU_KEYLARGO_BASED && !strcmp(label, "server_mode")) {
+		int new_value;
+		new_value = ((*val) == '1');
+		if (new_value != option_server_mode)
+			pmu_set_server_mode(new_value);
+	}
 	return fcount;
 }
 
 #ifdef CONFIG_ADB
 /* Send an ADB command */
-static int __openfirmware
+static int __pmac
 pmu_send_request(struct adb_request *req, int sync)
 {
 	int i, ret;
@@ -923,7 +1010,7 @@
 }
 
 /* Enable/disable autopolling */
-static int __openfirmware
+static int __pmac
 pmu_adb_autopoll(int devs)
 {
 	struct adb_request req;
@@ -946,7 +1033,7 @@
 }
 
 /* Reset the ADB bus */
-static int __openfirmware
+static int __pmac
 pmu_adb_reset_bus(void)
 {
 	struct adb_request req;
@@ -971,8 +1058,7 @@
 		printk(KERN_ERR "pmu_adb_reset_bus: pmu_queue_request failed\n");
 		return -EIO;
 	}
-	while (!req.complete)
-		pmu_poll();
+	pmu_wait_complete(&req);
 
 	if (save_autopoll != 0)
 		pmu_adb_autopoll(save_autopoll);
@@ -1008,7 +1094,7 @@
 	return pmu_queue_request(req);
 }
 
-int __openfirmware
+int __pmac
 pmu_queue_request(struct adb_request *req)
 {
 	unsigned long flags;
@@ -1050,7 +1136,7 @@
 static inline void
 wait_for_ack(void)
 {
-	/* Sightly increased the delay, I had one occurence of the message
+	/* Sightly increased the delay, I had one occurrence of the message
 	 * reported
 	 */
 	int timeout = 4000;
@@ -1100,8 +1186,8 @@
 		(*done)(req);
 }
 
-static void __openfirmware
-pmu_start()
+static void __pmac
+pmu_start(void)
 {
 	struct adb_request *req;
 
@@ -1122,17 +1208,32 @@
 	wait_for_ack();
 	/* set the shift register to shift out and send a byte */
 	send_byte(req->data[0]);
+#ifdef CONFIG_XMON
+	if (LIVE_DEBUG(req))
+		xmon_printf("R");
+	else
+		whacky_debug = 0;
+#endif /* CONFIG_XMON */
+}
+
+void __openfirmware
+pmu_poll(void)
+{
+	if (!via)
+		return;
+	if (disable_poll)
+		return;
+	via_pmu_interrupt(0, 0, 0);
 }
 
 void __openfirmware
-pmu_poll()
+pmu_poll_adb(void)
 {
 	if (!via)
 		return;
 	if (disable_poll)
 		return;
 	/* Kicks ADB read when PMU is suspended */
-	if (pmu_suspended)
 		adb_int_pending = 1;
 	do {
 		via_pmu_interrupt(0, 0, 0);
@@ -1140,6 +1241,15 @@
 		|| req_awaiting_reply));
 }
 
+void __openfirmware
+pmu_wait_complete(struct adb_request *req)
+{
+	if (!via)
+		return;
+	while((pmu_state != idle && pmu_state != locked) || !req->complete)
+		via_pmu_interrupt(0, 0, 0);
+}
+
 /* This function loops until the PMU is idle and prevents it from
  * anwsering to ADB interrupts. pmu_request can still be called.
  * This is done to avoid spurrious shutdowns when we know we'll have
@@ -1164,6 +1274,8 @@
 
 	do {
 		spin_unlock_irqrestore(&pmu_lock, flags);
+		if (req_awaiting_reply)
+			adb_int_pending = 1;
 		via_pmu_interrupt(0, 0, 0);
 		spin_lock_irqsave(&pmu_lock, flags);
 		if (!adb_int_pending && pmu_state == idle && !req_awaiting_reply) {
@@ -1174,7 +1286,7 @@
 				pmu_poll();
 #else /* SUSPEND_USES_PMU */
 			if (gpio_irq >= 0)
-				disable_irq(gpio_irq);
+				disable_irq_nosync(gpio_irq);
 			out_8(&via[IER], CB1_INT | IER_CLR);
 			spin_unlock_irqrestore(&pmu_lock, flags);
 #endif /* SUSPEND_USES_PMU */
@@ -1213,19 +1325,50 @@
 }
 
 /* Interrupt data could be the result data from an ADB cmd */
-static void __openfirmware
+static void __pmac
 pmu_handle_data(unsigned char *data, int len, struct pt_regs *regs)
 {
+	unsigned char ints, pirq;
+	int i = 0;
+
 	asleep = 0;
 	if (drop_interrupts || len < 1) {
 		adb_int_pending = 0;
+		pmu_irq_stats[8]++;
+		return;
+	}
+
+	/* Get PMU interrupt mask */
+	ints = data[0];
+
+	/* Record zero interrupts for stats */
+	if (ints == 0)
+		pmu_irq_stats[9]++;
+
+	/* Hack to deal with ADB autopoll flag */
+	if (ints & PMU_INT_ADB)
+		ints &= ~(PMU_INT_ADB_AUTO | PMU_INT_AUTO_SRQ_POLL);
+
+next:
+
+	if (ints == 0) {
+		if (i > pmu_irq_stats[10])
+			pmu_irq_stats[10] = i;
 		return;
 	}
+
+	for (pirq = 0; pirq < 8; pirq++)
+		if (ints & (1 << pirq))
+			break;
+	pmu_irq_stats[pirq]++;
+	i++;
+	ints &= ~(1 << pirq);
+
 	/* Note: for some reason, we get an interrupt with len=1,
 	 * data[0]==0 after each normal ADB interrupt, at least
 	 * on the Pismo. Still investigating...  --BenH
 	 */
-	if (data[0] & PMU_INT_ADB) {
+	if ((1 << pirq) & PMU_INT_ADB) {
 		if ((data[0] & PMU_INT_ADB_AUTO) == 0) {
 			struct adb_request *req = req_awaiting_reply;
 			if (req == 0) {
@@ -1263,32 +1406,40 @@
 				adb_input(data+1, len-1, regs, 1);
 #endif /* CONFIG_ADB */		
 		}
-	} else {
+	}
 		/* Sound/brightness button pressed */
-		if ((data[0] & PMU_INT_SNDBRT) && len == 3) {
+	else if ((1 << pirq) & PMU_INT_SNDBRT) {
 #ifdef CONFIG_PMAC_BACKLIGHT
+		if (len == 3)
 #ifdef CONFIG_INPUT_ADBHID
 			if (!disable_kernel_backlight)
 #endif /* CONFIG_INPUT_ADBHID */
 				set_backlight_level(data[1] >> 4);
 #endif /* CONFIG_PMAC_BACKLIGHT */
 		}
+	/* Tick interrupt */
+	else if ((1 << pirq) & PMU_INT_TICK) {
 #ifdef CONFIG_PMAC_PBOOK
 		/* Environement or tick interrupt, query batteries */
-		if (pmu_battery_count && (data[0] & PMU_INT_TICK)) {
+		if (pmu_battery_count) {
 			if ((--query_batt_timer) == 0) {
 				query_battery_state();
 				query_batt_timer = BATTERY_POLLING_COUNT;
 			}
-		} else if (pmu_battery_count && (data[0] & PMU_INT_ENVIRONMENT))
+		}
+        }
+	else if ((1 << pirq) & PMU_INT_ENVIRONMENT) {
+		if (pmu_battery_count)
 			query_battery_state();
- 		if (data[0])
+			pmu_pass_intr(data, len);
+	} else {
 			pmu_pass_intr(data, len);
 #endif /* CONFIG_PMAC_PBOOK */
 	}
+	goto next;
 }
 
-static struct adb_request* __openfirmware
+static struct adb_request* __pmac
 pmu_sr_intr(struct pt_regs *regs)
 {
 	struct adb_request *req;
@@ -1315,17 +1466,29 @@
 	case sending:
 		req = current_req;
 		if (data_len < 0) {
+#ifdef CONFIG_XMON
+			if (LIVE_DEBUG(req))
+				xmon_printf("s");
+#endif /* CONFIG_XMON */
 			data_len = req->nbytes - 1;
 			send_byte(data_len);
 			break;
 		}
 		if (data_index <= data_len) {
+#ifdef CONFIG_XMON
+			if (LIVE_DEBUG(req))
+				xmon_printf("S");
+#endif /* CONFIG_XMON */
 			send_byte(req->data[data_index++]);
 			break;
 		}
 		req->sent = 1;
 		data_len = pmu_data_len[req->data[0]][1];
 		if (data_len == 0) {
+#ifdef CONFIG_XMON
+			if (LIVE_DEBUG(req))
+				xmon_printf("D");
+#endif /* CONFIG_XMON */
 			pmu_state = idle;
 			current_req = req->next;
 			if (req->reply_expected)
@@ -1333,6 +1496,10 @@
 			else
 				return req;
 		} else {
+#ifdef CONFIG_XMON
+			if (LIVE_DEBUG(req))
+				xmon_printf("-");
+#endif /* CONFIG_XMON */
 			pmu_state = reading;
 			data_index = 0;
 			reply_ptr = req->reply + req->reply_len;
@@ -1346,15 +1513,27 @@
 		pmu_state = reading_intr;
 		reply_ptr = interrupt_data[int_data_last];
 		recv_byte();
+		if (gpio_irq >= 0 && !gpio_irq_enabled) {
+			enable_irq(gpio_irq);
+			gpio_irq_enabled = 1;
+		}
 		break;
 
 	case reading:
 	case reading_intr:
 		if (data_len == -1) {
+#ifdef CONFIG_XMON
+			if (LIVE_DEBUG(current_req))
+				xmon_printf("r");
+#endif /* CONFIG_XMON */
 			data_len = bite;
 			if (bite > 32)
 				printk(KERN_ERR "PMU: bad reply len %d\n", bite);
 		} else if (data_index < 32) {
+#ifdef CONFIG_XMON
+			if (LIVE_DEBUG(current_req))
+				xmon_printf("R");
+#endif /* CONFIG_XMON */
 			reply_ptr[data_index++] = bite;
 		}
 		if (data_index < data_len) {
@@ -1362,14 +1541,28 @@
 			break;
 		}
 
+#ifdef CONFIG_XMON
+		if (LIVE_DEBUG(current_req)) {
+			whacky_debug = 1;
+		       	xmon_printf("D");
+		}
+#endif /* CONFIG_XMON */
 		if (pmu_state == reading_intr) {
 			pmu_state = idle;
 			int_data_state[int_data_last] = int_data_ready;
 			interrupt_data_len[int_data_last] = data_len;
 		} else {
 			req = current_req;
+			/* 
+			 * For PMU sleep and freq change requests, we lock the
+			 * PMU until it's explicitely unlocked. This avoids any
+			 * spurrious event polling getting in
+			 */
 			current_req = req->next;
 			req->reply_len += data_index;
+			if (req->data[0] == PMU_SLEEP || req->data[0] == PMU_CPU_SPEED)
+				pmu_state = locked;
+			else
 			pmu_state = idle;
 			return req;
 		}
@@ -1399,6 +1592,10 @@
 		intr = in_8(&via[IFR]) & (SR_INT | CB1_INT);
 		if (intr == 0)
 			break;
+#ifdef CONFIG_XMON
+		if (whacky_debug)
+			xmon_printf("|%02x|", intr);
+#endif /* CONFIG_XMON */
 		if (++nloop > 1000) {
 			printk(KERN_DEBUG "PMU: stuck in intr loop, "
 			       "intr=%x, ier=%x pmu_state=%d\n",
@@ -1406,8 +1603,10 @@
 			break;
 		}
 		out_8(&via[IFR], intr);
-		if (intr & CB1_INT)
+		if (intr & CB1_INT) {
 			adb_int_pending = 1;
+			pmu_irq_stats[0]++;
+		}
 		if (intr & SR_INT) {
 			req = pmu_sr_intr(regs);
 			if (req)
@@ -1418,6 +1617,10 @@
 recheck:
 	if (pmu_state == idle) {
 		if (adb_int_pending) {
+#ifdef CONFIG_XMON
+			if (whacky_debug)
+				xmon_printf("!A!");
+#endif /* CONFIG_XMON */
 			if (int_data_state[0] == int_data_empty)
 				int_data_last = 0;
 			else if (int_data_state[1] == int_data_empty)
@@ -1432,11 +1635,10 @@
 			wait_for_ack();
 			send_byte(PMU_INT_ACK);
 			adb_int_pending = 0;
-no_free_slot:
-			;	
 		} else if (current_req)
 			pmu_start();
 	}
+no_free_slot:			
 	/* Mark the oldest buffer for flushing */
 	if (int_data_state[!int_data_last] == int_data_ready) {
 		int_data_state[!int_data_last] = int_data_flush;
@@ -1465,17 +1667,42 @@
 	}
 }
 
+void __pmac
+pmu_unlock(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pmu_lock, flags);
+	if (pmu_state == locked)
+		pmu_state = idle;
+	adb_int_pending = 1;
+	spin_unlock_irqrestore(&pmu_lock, flags);
+}
+
+
 static void __openfirmware
 gpio1_interrupt(int irq, void *arg, struct pt_regs *regs)
 {
+	unsigned long flags;
+
+	/* XXX FIXME: Do not hard code 0x9 offset, get it from
+	 * device-tree
+	 */
 	if ((in_8(gpio_reg + 0x9) & 0x02) == 0) {
+		spin_lock_irqsave(&pmu_lock, flags);
+		if (gpio_irq_enabled > 0) {
+			disable_irq_nosync(gpio_irq);
+			gpio_irq_enabled = 0;
+		}
+		pmu_irq_stats[1]++;
 		adb_int_pending = 1;
+		spin_unlock_irqrestore(&pmu_lock, flags);
 		via_pmu_interrupt(0, 0, 0);
 	}
 }
 
 #ifdef CONFIG_PMAC_BACKLIGHT
-static int backlight_to_bright[] = {
+static int backlight_to_bright[] __pmacdata = {
 	0x7f, 0x46, 0x42, 0x3e, 0x3a, 0x36, 0x32, 0x2e,
 	0x2a, 0x26, 0x22, 0x1e, 0x1a, 0x16, 0x12, 0x0e
 };
@@ -1491,13 +1718,11 @@
 	if (on) {
 		pmu_request(&req, NULL, 2, PMU_BACKLIGHT_BRIGHT,
 			    backlight_to_bright[level]);
-		while (!req.complete)
-			pmu_poll();
+		pmu_wait_complete(&req);
 	}
 	pmu_request(&req, NULL, 2, PMU_POWER_CTRL,
 		    PMU_POW_BACKLIGHT | (on ? PMU_POW_ON : PMU_POW_OFF));
-	while (!req.complete)
-		pmu_poll();
+       	pmu_wait_complete(&req);
 
 	return 0;
 }
@@ -1521,7 +1746,7 @@
 }
 #endif /* CONFIG_PMAC_BACKLIGHT */
 
-void __openfirmware
+void __pmac
 pmu_enable_irled(int on)
 {
 	struct adb_request req;
@@ -1533,11 +1758,10 @@
 
 	pmu_request(&req, NULL, 2, PMU_POWER_CTRL, PMU_POW_IRLED |
 	    (on ? PMU_POW_ON : PMU_POW_OFF));
-	while (!req.complete)
-		pmu_poll();
+	pmu_wait_complete(&req);
 }
 
-void __openfirmware
+void __pmac
 pmu_restart(void)
 {
 	struct adb_request req;
@@ -1554,13 +1778,12 @@
 	}
 
 	pmu_request(&req, NULL, 1, PMU_RESET);
-	while(!req.complete || (pmu_state != idle))
-		pmu_poll();
+	pmu_wait_complete(&req);
 	for (;;)
 		;
 }
 
-void __openfirmware
+void __pmac
 pmu_shutdown(void)
 {
 	struct adb_request req;
@@ -1572,14 +1795,17 @@
 	if (pmu_kind != PMU_KEYLARGO_BASED) {
 		pmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, PMU_INT_ADB |
 						PMU_INT_TICK );
-		while(!req.complete)
-			pmu_poll();
+		pmu_wait_complete(&req);
+	} else {
+		/* Disable server mode on shutdown or we'll just
+		 * wake up again
+		 */
+		pmu_set_server_mode(0);
 	}
 
 	pmu_request(&req, NULL, 5, PMU_SHUTDOWN,
 		    'M', 'A', 'T', 'T');
-	while(!req.complete || (pmu_state != idle))
-		pmu_poll();
+	pmu_wait_complete(&req);
 	for (;;)
 		;
 }
@@ -2245,6 +2471,7 @@
 	set_context(current->active_mm->context, current->active_mm->pgd);
 
 	/* Power things up */
+	pmu_unlock();
 	pmu_request(&req, NULL, 2, PMU_SET_INTR_MASK, 0xfc);
 	while (!req.complete)
 		pmu_poll();
@@ -2410,6 +2637,7 @@
 	//pbook_pci_restore();
 
 #ifdef DEBUG_SLEEP
+	pmu_unlock();
 	pmu_blink(2);
 #endif		
 	/* Restore L2 cache */
@@ -2423,6 +2651,7 @@
 	set_context(current->active_mm->context, current->active_mm->pgd);
 
 	/* Tell PMU we are ready */
+	pmu_unlock();
 	pmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);
 	while (!req.complete)
 		pmu_poll();
@@ -2555,10 +2784,7 @@
 	out_be32(mem_ctrl_sleep, 0x3f);
 	pmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,0,0);
 	pbook_pci_restore();
-
-	/* wait for the PMU interrupt sequence to complete */
-	while (asleep)
-		mb();
+	pmu_unlock();
 
 	/* reenable interrupts */
 	pmac_sleep_restore_intrs();
@@ -2921,8 +3147,11 @@
 
 EXPORT_SYMBOL(pmu_request);
 EXPORT_SYMBOL(pmu_poll);
+EXPORT_SYMBOL(pmu_poll_adb);
+EXPORT_SYMBOL(pmu_wait_complete);
 EXPORT_SYMBOL(pmu_suspend);
 EXPORT_SYMBOL(pmu_resume);
+EXPORT_SYMBOL(pmu_unlock);
 EXPORT_SYMBOL(pmu_i2c_combined_read);
 EXPORT_SYMBOL(pmu_i2c_stdsub_write);
 EXPORT_SYMBOL(pmu_i2c_simple_read);
diff -urN kernel-source-2.4.27/drivers/net/irda/irda-usb.c kernel-source-2.4.27-benh/drivers/net/irda/irda-usb.c
--- kernel-source-2.4.27/drivers/net/irda/irda-usb.c	2004-02-18 14:36:31.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/net/irda/irda-usb.c	2004-09-01 20:56:26.542084048 +0200
@@ -1386,6 +1386,9 @@
 		WARNING("usb-irda: bad class_descriptor type\n");
 	}
 	else {
+		le16_to_cpus (&(desc->wBaudRate));
+		le16_to_cpus (&(desc->bcdSpecRevision));        
+		
 #ifdef IU_DUMP_CLASS_DESC
 		irda_usb_dump_class_desc(desc);
 #endif	/* IU_DUMP_CLASS_DESC */
diff -urN kernel-source-2.4.27/drivers/net/Makefile kernel-source-2.4.27-benh/drivers/net/Makefile
--- kernel-source-2.4.27/drivers/net/Makefile	2004-08-08 01:26:04.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/net/Makefile	2004-09-01 20:56:26.544083744 +0200
@@ -17,7 +17,7 @@
 
 export-objs     :=	8390.o arlan.o aironet4500_core.o aironet4500_card.o \
 			ppp_async.o ppp_generic.o slhc.o pppox.o auto_irq.o \
-			net_init.o mii.o
+			net_init.o mii.o sungem_phy.o
 list-multi	:=	rcpci.o
 rcpci-objs	:=	rcpci45.o rclanmtl.o
 
@@ -67,7 +67,7 @@
 obj-$(CONFIG_SUNQE) += sunqe.o
 obj-$(CONFIG_SUNBMAC) += sunbmac.o
 obj-$(CONFIG_MYRI_SBUS) += myri_sbus.o
-obj-$(CONFIG_SUNGEM) += sungem.o
+obj-$(CONFIG_SUNGEM) += sungem.o sungem_phy.o
 
 obj-$(CONFIG_MACE) += mace.o
 obj-$(CONFIG_BMAC) += bmac.o
diff -urN kernel-source-2.4.27/drivers/net/ne2k-pci.c kernel-source-2.4.27-benh/drivers/net/ne2k-pci.c
--- kernel-source-2.4.27/drivers/net/ne2k-pci.c	2004-04-14 15:05:30.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/net/ne2k-pci.c	2004-09-01 20:56:26.622071888 +0200
@@ -70,8 +70,6 @@
 #if defined(__powerpc__)
 #define inl_le(addr)  le32_to_cpu(inl(addr))
 #define inw_le(addr)  le16_to_cpu(inw(addr))
-#define insl insl_ns
-#define outsl outsl_ns
 #endif
 
 #define PFX DRV_NAME ": "
diff -urN kernel-source-2.4.27/drivers/net/pcnet32.c kernel-source-2.4.27-benh/drivers/net/pcnet32.c
--- kernel-source-2.4.27/drivers/net/pcnet32.c	2004-08-08 01:26:05.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/net/pcnet32.c	2004-09-01 20:56:26.781047720 +0200
@@ -1072,7 +1072,7 @@
 	break;
     case 0x2625:
 	chipname = "PCnet/FAST III 79C973"; /* PCI */
-	fdx = 1; mii = 1;
+	fdx = 1; mii = 1; fset = 1;
 	break;
     case 0x2626:
 	chipname = "PCnet/Home 79C978"; /* PCI */
diff -urN kernel-source-2.4.27/drivers/net/sungem.c kernel-source-2.4.27-benh/drivers/net/sungem.c
--- kernel-source-2.4.27/drivers/net/sungem.c	2004-04-14 15:05:30.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/net/sungem.c	2004-09-01 20:56:26.871034040 +0200
@@ -63,12 +63,20 @@
 #include <asm/pmac_feature.h>
 #endif
 
+#include "sungem_phy.h"
 #include "sungem.h"
 
+/* Stripping FCS is causing problems, disabled for now */
+#undef STRIP_FCS
+
 #define DEFAULT_MSG	(NETIF_MSG_DRV		| \
 			 NETIF_MSG_PROBE	| \
 			 NETIF_MSG_LINK)
 
+#define ADVERTISE_MASK	(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full | \
+			 SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full | \
+			 SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)
+
 #define DRV_NAME	"sungem"
 #define DRV_VERSION	"0.97"
 #define DRV_RELDATE	"3/20/02"
@@ -81,28 +89,10 @@
 MODULE_DESCRIPTION("Sun GEM Gbit ethernet driver");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(gem_debug, "i");
-MODULE_PARM_DESC(gem_debug, "bitmapped message enable number");
-MODULE_PARM(link_mode, "i");
-MODULE_PARM_DESC(link_mode, "default link mode");
-
-int gem_debug = -1;
-static int link_mode;
-
-static u16 link_modes[] __devinitdata = {
-	BMCR_ANENABLE,			/* 0 : autoneg */
-	0,				/* 1 : 10bt half duplex */
-	BMCR_SPEED100,			/* 2 : 100bt half duplex */
-	BMCR_SPD2, /* bcm54xx only */   /* 3 : 1000bt half duplex */
-	BMCR_FULLDPLX,			/* 4 : 10bt full duplex */
-	BMCR_SPEED100|BMCR_FULLDPLX,	/* 5 : 100bt full duplex */
-	BMCR_SPD2|BMCR_FULLDPLX		/* 6 : 1000bt full duplex */
-};
-
 #define GEM_MODULE_NAME	"gem"
 #define PFX GEM_MODULE_NAME ": "
 
-static struct pci_device_id gem_pci_tbl[] __devinitdata = {
+static struct pci_device_id gem_pci_tbl[] = {
 	{ PCI_VENDOR_ID_SUN, PCI_DEVICE_ID_SUN_GEM,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 
@@ -119,12 +109,16 @@
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_UNI_N_GMACP,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_UNI_N_GMAC2,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_K2_GMAC,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 	{0, }
 };
 
 MODULE_DEVICE_TABLE(pci, gem_pci_tbl);
 
-static u16 __phy_read(struct gem *gp, int reg, int phy_addr)
+static u16 __phy_read(struct gem *gp, int phy_addr, int reg)
 {
 	u32 cmd;
 	int limit = 10000;
@@ -150,12 +144,18 @@
 	return cmd & MIF_FRAME_DATA;
 }
 
+static inline int _phy_read(struct net_device *dev, int mii_id, int reg)
+{
+	struct gem *gp = dev->priv;
+	return __phy_read(gp, mii_id, reg);
+}
+
 static inline u16 phy_read(struct gem *gp, int reg)
 {
-	return __phy_read(gp, reg, gp->mii_phy_addr);
+	return __phy_read(gp, gp->mii_phy_addr, reg);
 }
 
-static void __phy_write(struct gem *gp, int reg, u16 val, int phy_addr)
+static void __phy_write(struct gem *gp, int phy_addr, int reg, u16 val)
 {
 	u32 cmd;
 	int limit = 10000;
@@ -177,9 +177,15 @@
 	}
 }
 
+static inline void _phy_write(struct net_device *dev, int mii_id, int reg, int val)
+{
+	struct gem *gp = dev->priv;
+	__phy_write(gp, mii_id, reg, val & 0xffff);
+}
+
 static inline void phy_write(struct gem *gp, int reg, u16 val)
 {
-	__phy_write(gp, reg, val, gp->mii_phy_addr);
+	__phy_write(gp, gp->mii_phy_addr, reg, val);
 }
 
 static void gem_handle_mif_event(struct gem *gp, u32 reg_val, u32 changed_bits)
@@ -228,10 +234,11 @@
 	if (pcs_miistat & PCS_MIISTAT_LS) {
 		printk(KERN_INFO "%s: PCS link is now up.\n",
 		       dev->name);
+		netif_carrier_on(gp->dev);
 	} else {
 		printk(KERN_INFO "%s: PCS link is now down.\n",
 		       dev->name);
-
+		netif_carrier_off(gp->dev);
 		/* If this happens and the link timer is not running,
 		 * reset so we re-negotiate.
 		 */
@@ -400,6 +407,10 @@
 			gp->dev->name, rxmac_stat);
 
 	if (rxmac_stat & MAC_RXSTAT_OFLW) {
+		u32 smac = readl(gp->regs + MAC_SMACHINE);
+
+		printk(KERN_ERR "%s: RX MAC fifo overflow smac[%08x].\n",
+				dev->name, smac);
 		gp->net_stats.rx_over_errors++;
 		gp->net_stats.rx_fifo_errors++;
 
@@ -912,7 +923,7 @@
 		/* We must give this initial chunk to the device last.
 		 * Otherwise we could race with the device.
 		 */
-		first_len = skb->len - skb->data_len;
+		first_len = skb_headlen(skb);
 		first_mapping = pci_map_page(gp->pdev, virt_to_page(skb->data),
 					     ((unsigned long) skb->data & ~PAGE_MASK),
 					     first_len, PCI_DMA_TODEVICE);
@@ -1025,7 +1036,7 @@
 	} while (val & (GREG_SWRST_TXRST | GREG_SWRST_RXRST));
 
 	if (limit <= 0)
-		printk(KERN_ERR "gem: SW reset is ghetto.\n");
+		printk(KERN_ERR "%s: SW reset is ghetto.\n", gp->dev->name);
 }
 
 /* Must be invoked under gp->lock. */
@@ -1052,136 +1063,118 @@
 
 }
 
-/* Link modes of the BCM5400 PHY */
-static int phy_BCM5400_link_table[8][3] = {
-	{ 0, 0, 0 },	/* No link */
-	{ 0, 0, 0 },	/* 10BT Half Duplex */
-	{ 1, 0, 0 },	/* 10BT Full Duplex */
-	{ 0, 1, 0 },	/* 100BT Half Duplex */
-	{ 0, 1, 0 },	/* 100BT Half Duplex */
-	{ 1, 1, 0 },	/* 100BT Full Duplex*/
-	{ 1, 0, 1 },	/* 1000BT */
-	{ 1, 0, 1 },	/* 1000BT */
-};
 
 /* Must be invoked under gp->lock. */
+// XXX dbl check what that function should do when called on PCS PHY
 static void gem_begin_auto_negotiation(struct gem *gp, struct ethtool_cmd *ep)
 {
-	u16 ctl;
+	u32 advertise, features;
+	int autoneg;
+	int speed;
+	int duplex;
+
+	if (gp->phy_type != phy_mii_mdio0 &&
+     	    gp->phy_type != phy_mii_mdio1)
+     	    	goto non_mii;
+
+	/* Setup advertise */
+	if (found_mii_phy(gp))
+		features = gp->phy_mii.def->features;
+	else
+		features = 0;
+
+	advertise = features & ADVERTISE_MASK;
+	if (gp->phy_mii.advertising != 0)
+		advertise &= gp->phy_mii.advertising;
+
+	autoneg = gp->want_autoneg;
+	speed = gp->phy_mii.speed;
+	duplex = gp->phy_mii.duplex;
 	
 	/* Setup link parameters */
 	if (!ep)
 		goto start_aneg;
 	if (ep->autoneg == AUTONEG_ENABLE) {
-		/* TODO: parse ep->advertising */
-		gp->link_advertise |= (ADVERTISE_10HALF | ADVERTISE_10FULL);
-		gp->link_advertise |= (ADVERTISE_100HALF | ADVERTISE_100FULL);
-		/* Can I advertise gigabit here ? I'd need BCM PHY docs... */
-		gp->link_cntl = BMCR_ANENABLE;
+		advertise = ep->advertising;
+		autoneg = 1;
 	} else {
-		gp->link_cntl = 0;
-		if (ep->speed == SPEED_100)
-			gp->link_cntl |= BMCR_SPEED100;
-		else if (ep->speed == SPEED_1000 && gp->gigabit_capable)
-			/* Hrm... check if this is right... */
-			gp->link_cntl |= BMCR_SPD2;
-		if (ep->duplex == DUPLEX_FULL)
-			gp->link_cntl |= BMCR_FULLDPLX;
+		autoneg = 0;
+		speed = ep->speed;
+		duplex = ep->duplex;
 	}
 
 start_aneg:
-	if (!gp->hw_running)
+	/* Sanitize settings based on PHY capabilities */
+	if ((features & SUPPORTED_Autoneg) == 0)
+		autoneg = 0;
+	if (speed == SPEED_1000 &&
+	    !(features & (SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)))
+		speed = SPEED_100;
+	if (speed == SPEED_100 &&
+	    !(features & (SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full)))
+		speed = SPEED_10;
+	if (duplex == DUPLEX_FULL &&
+	    !(features & (SUPPORTED_1000baseT_Full |
+	    		  SUPPORTED_100baseT_Full |
+	    		  SUPPORTED_10baseT_Full)))
+	    	duplex = DUPLEX_HALF;
+	if (speed == 0)
+		speed = SPEED_10;
+	
+	/* If HW is down, we don't try to actually setup the PHY, we
+	 * just store the settings
+	 */
+	if (!gp->hw_running) {
+		gp->phy_mii.autoneg = gp->want_autoneg = autoneg;
+		gp->phy_mii.speed = speed;
+		gp->phy_mii.duplex = duplex;
 		return;
+	}
 
 	/* Configure PHY & start aneg */
-	ctl = phy_read(gp, MII_BMCR);
-	ctl &= ~(BMCR_FULLDPLX|BMCR_SPEED100|BMCR_ANENABLE);
-	ctl |= gp->link_cntl;
-	if (ctl & BMCR_ANENABLE) {
-		ctl |= BMCR_ANRESTART;
+	gp->want_autoneg = autoneg;
+	if (autoneg) {
+		if (found_mii_phy(gp))
+			gp->phy_mii.def->ops->setup_aneg(&gp->phy_mii, advertise);
 		gp->lstate = link_aneg;
 	} else {
+		if (found_mii_phy(gp))
+			gp->phy_mii.def->ops->setup_forced(&gp->phy_mii, speed, duplex);
 		gp->lstate = link_force_ok;
 	}
-	phy_write(gp, MII_BMCR, ctl);
 
+non_mii:
 	gp->timer_ticks = 0;
 	mod_timer(&gp->link_timer, jiffies + ((12 * HZ) / 10));
 }
 
-/* Must be invoked under gp->lock. */
-static void gem_read_mii_link_mode(struct gem *gp, int *fd, int *spd, int *pause)
-{
-	u32 val;
-
-	*fd = 0;
-	*spd = 10;
-	*pause = 0;
-	
-	if (gp->phy_mod == phymod_bcm5400 ||
-	    gp->phy_mod == phymod_bcm5401 ||
-	    gp->phy_mod == phymod_bcm5411) {
-		int link_mode;	
-
-	    	val = phy_read(gp, MII_BCM5400_AUXSTATUS);
-		link_mode = ((val & MII_BCM5400_AUXSTATUS_LINKMODE_MASK) >>
-			     MII_BCM5400_AUXSTATUS_LINKMODE_SHIFT);
-		*fd = phy_BCM5400_link_table[link_mode][0];
-		*spd = phy_BCM5400_link_table[link_mode][2] ?
-			1000 :
-			(phy_BCM5400_link_table[link_mode][1] ? 100 : 10);
-		val = phy_read(gp, MII_LPA);
-		if (val & LPA_PAUSE)
-			*pause = 1;
-	} else {
-		val = phy_read(gp, MII_LPA);
-
-		if (val & (LPA_10FULL | LPA_100FULL))
-			*fd = 1;
-		if (val & (LPA_100FULL | LPA_100HALF))
-			*spd = 100;
-
-		if (gp->phy_mod == phymod_m1011) {
-			val = phy_read(gp, 0x0a);
-			if (val & 0xc00)
-				*spd = 1000;
-			if (val & 0x800)
-				*fd = 1;
-		}
-	}
-}
-
 /* A link-up condition has occurred, initialize and enable the
  * rest of the chip.
  *
  * Must be invoked under gp->lock.
  */
-static void gem_set_link_modes(struct gem *gp)
+static int gem_set_link_modes(struct gem *gp)
 {
 	u32 val;
 	int full_duplex, speed, pause;
 
 	full_duplex = 0;
-	speed = 10;
+	speed = SPEED_10;
 	pause = 0;
 
-	if (gp->phy_type == phy_mii_mdio0 ||
-	    gp->phy_type == phy_mii_mdio1) {
-		val = phy_read(gp, MII_BMCR);
-		if (val & BMCR_ANENABLE)
-			gem_read_mii_link_mode(gp, &full_duplex, &speed, &pause);
-		else {
-			if (val & BMCR_FULLDPLX)
-				full_duplex = 1;
-			if (val & BMCR_SPEED100)
-				speed = 100;
-		}
-	} else {
+	if (found_mii_phy(gp)) {
+	    	if (gp->phy_mii.def->ops->read_link(&gp->phy_mii))
+	    		return 1;
+		full_duplex = (gp->phy_mii.duplex == DUPLEX_FULL);
+		speed = gp->phy_mii.speed;
+		pause = gp->phy_mii.pause;
+	} else if (gp->phy_type == phy_serialink ||
+	    	   gp->phy_type == phy_serdes) {
 		u32 pcs_lpa = readl(gp->regs + PCS_MIILP);
 
 		if (pcs_lpa & PCS_MIIADV_FD)
 			full_duplex = 1;
-		speed = 1000;
+		speed = SPEED_1000;
 	}
 
 	if (netif_msg_link(gp))
@@ -1205,7 +1198,7 @@
 		val |= MAC_XIFCFG_FLED;
 	}
 
-	if (speed == 1000)
+	if (speed == SPEED_1000)
 		val |= (MAC_XIFCFG_GMII);
 
 	writel(val, gp->regs + MAC_XIFCFG);
@@ -1213,7 +1206,7 @@
 	/* If gigabit and half-duplex, enable carrier extension
 	 * mode.  Else, disable it.
 	 */
-	if (speed == 1000 && !full_duplex) {
+	if (speed == SPEED_1000 && !full_duplex) {
 		val = readl(gp->regs + MAC_TXCFG);
 		writel(val | MAC_TXCFG_TCE, gp->regs + MAC_TXCFG);
 
@@ -1261,51 +1254,58 @@
 	writel(val, gp->regs + MAC_MCCFG);
 
 	gem_start_dma(gp);
+
+	return 0;
 }
 
 /* Must be invoked under gp->lock. */
 static int gem_mdio_link_not_up(struct gem *gp)
 {
-	u16 val;
-	
-	if (gp->lstate == link_force_ret) {
+	switch (gp->lstate) {
+	case link_force_ret:
 		if (netif_msg_link(gp))
 			printk(KERN_INFO "%s: Autoneg failed again, keeping"
 				" forced mode\n", gp->dev->name);
-		phy_write(gp, MII_BMCR, gp->link_fcntl);
+		gp->phy_mii.def->ops->setup_forced(&gp->phy_mii,
+			gp->last_forced_speed, DUPLEX_HALF);
 		gp->timer_ticks = 5;
 		gp->lstate = link_force_ok;
-	} else if (gp->lstate == link_aneg) {
-		val = phy_read(gp, MII_BMCR);
-
+		return 0;
+	case link_aneg:
+		/* We try forced modes after a failed aneg only on PHYs that don't
+		 * have "magic_aneg" bit set, which means they internally do the
+		 * while forced-mode thingy. On these, we just restart aneg
+		 */
+		if (gp->phy_mii.def->magic_aneg)
+			return 1;
 		if (netif_msg_link(gp))
 			printk(KERN_INFO "%s: switching to forced 100bt\n",
 				gp->dev->name);
 		/* Try forced modes. */
-		val &= ~(BMCR_ANRESTART | BMCR_ANENABLE);
-		val &= ~(BMCR_FULLDPLX);
-		val |= BMCR_SPEED100;
-		phy_write(gp, MII_BMCR, val);
+		gp->phy_mii.def->ops->setup_forced(&gp->phy_mii, SPEED_100,
+			DUPLEX_HALF);
 		gp->timer_ticks = 5;
 		gp->lstate = link_force_try;
-	} else {
+		return 0;
+	case link_force_try:
 		/* Downgrade from 100 to 10 Mbps if necessary.
 		 * If already at 10Mbps, warn user about the
 		 * situation every 10 ticks.
 		 */
-		val = phy_read(gp, MII_BMCR);
-		if (val & BMCR_SPEED100) {
-			val &= ~BMCR_SPEED100;
-			phy_write(gp, MII_BMCR, val);
+		if (gp->phy_mii.speed == SPEED_100) {
+			gp->phy_mii.def->ops->setup_forced(&gp->phy_mii, SPEED_10,
+				DUPLEX_HALF);
 			gp->timer_ticks = 5;
 			if (netif_msg_link(gp))
 				printk(KERN_INFO "%s: switching to forced 10bt\n",
 					gp->dev->name);
+			return 0;
 		} else
 			return 1;
-	}
+	default:
 	return 0;
 }
+}
 
 static void gem_init_rings(struct gem *);
 static void gem_init_hw(struct gem *, int);
@@ -1344,6 +1344,7 @@
 static void gem_link_timer(unsigned long data)
 {
 	struct gem *gp = (struct gem *) data;
+	int restart_aneg = 0;
 
 	if (!gp->hw_running)
 		return;
@@ -1356,42 +1357,42 @@
 	if (gp->reset_task_pending)
 		goto restart;
 	    	
-	if (gp->phy_type == phy_mii_mdio0 ||
-	    gp->phy_type == phy_mii_mdio1) {
-		u16 val = phy_read(gp, MII_BMSR);
-		u16 cntl = phy_read(gp, MII_BMCR);
-		int up;
+	if (gp->phy_type == phy_serialink ||
+	    gp->phy_type == phy_serdes) {
+		u32 val = readl(gp->regs + PCS_MIISTAT);
 
-		/* When using autoneg, we really wait for ANEGCOMPLETE or we may
-		 * get a "transcient" incorrect link state
-		 */
-		if (cntl & BMCR_ANENABLE)
-			up = (val & (BMSR_ANEGCOMPLETE | BMSR_LSTATUS)) == (BMSR_ANEGCOMPLETE | BMSR_LSTATUS);
-		else
-			up = (val & BMSR_LSTATUS) != 0;
-		if (up) {
+		if (!(val & PCS_MIISTAT_LS))
+			val = readl(gp->regs + PCS_MIISTAT);
+
+		if ((val & PCS_MIISTAT_LS) != 0) {
+			gp->lstate = link_up;
+			netif_carrier_on(gp->dev);
+			if (gp->opened)
+				(void)gem_set_link_modes(gp);
+		}
+		goto restart;
+	}
+	if (found_mii_phy(gp) && gp->phy_mii.def->ops->poll_link(&gp->phy_mii)) {
 			/* Ok, here we got a link. If we had it due to a forced
 			 * fallback, and we were configured for autoneg, we do
 			 * retry a short autoneg pass. If you know your hub is
 			 * broken, use ethtool ;)
 			 */
-			if (gp->lstate == link_force_try && (gp->link_cntl & BMCR_ANENABLE)) {
+		if (gp->lstate == link_force_try && gp->want_autoneg) {
 				gp->lstate = link_force_ret;
-				gp->link_fcntl = phy_read(gp, MII_BMCR);
+			gp->last_forced_speed = gp->phy_mii.speed;
 				gp->timer_ticks = 5;
 				if (netif_msg_link(gp))
 					printk(KERN_INFO "%s: Got link after fallback, retrying"
 						" autoneg once...\n", gp->dev->name);
-				phy_write(gp, MII_BMCR,
-					  gp->link_fcntl | BMCR_ANENABLE | BMCR_ANRESTART);
+			gp->phy_mii.def->ops->setup_aneg(&gp->phy_mii, gp->phy_mii.advertising);
 			} else if (gp->lstate != link_up) {
 				gp->lstate = link_up;
-				if (gp->opened)
-					gem_set_link_modes(gp);
+			netif_carrier_on(gp->dev);
+			if (gp->opened && gem_set_link_modes(gp))
+				restart_aneg = 1;
 			}
 		} else {
-			int restart = 0;
-
 			/* If the link was previously up, we restart the
 			 * whole process
 			 */
@@ -1400,30 +1401,21 @@
 				if (netif_msg_link(gp))
 					printk(KERN_INFO "%s: Link down\n",
 						gp->dev->name);
+			netif_carrier_off(gp->dev);
 				gp->reset_task_pending = 2;
 				schedule_task(&gp->reset_task);
-				restart = 1;
-			} else if (++gp->timer_ticks > 10)
-				restart = gem_mdio_link_not_up(gp);
-
-			if (restart) {
-				gem_begin_auto_negotiation(gp, NULL);
-				goto out_unlock;
-			}
+			restart_aneg = 1;
+		} else if (++gp->timer_ticks > 10) {
+			if (found_mii_phy(gp))
+				restart_aneg = gem_mdio_link_not_up(gp);
+			else
+				restart_aneg = 1;
 		}
-	} else {
-		u32 val = readl(gp->regs + PCS_MIISTAT);
-
-		if (!(val & PCS_MIISTAT_LS))
-			val = readl(gp->regs + PCS_MIISTAT);
-
-		if ((val & PCS_MIISTAT_LS) != 0) {
-			gp->lstate = link_up;
-			if (gp->opened)
-				gem_set_link_modes(gp);
 		}
+	if (restart_aneg) {
+		gem_begin_auto_negotiation(gp, NULL);
+		goto out_unlock;
 	}
-
 restart:
 	mod_timer(&gp->link_timer, jiffies + ((12 * HZ) / 10));
 out_unlock:
@@ -1530,150 +1522,10 @@
 }
 
 /* Must be invoked under gp->lock. */
-static int gem_reset_one_mii_phy(struct gem *gp, int phy_addr)
-{
-	u16 val;
-	int limit = 10000;
-	
-	val = __phy_read(gp, MII_BMCR, phy_addr);
-	val &= ~BMCR_ISOLATE;
-	val |= BMCR_RESET;
-	__phy_write(gp, MII_BMCR, val, phy_addr);
-
-	udelay(100);
-
-	while (limit--) {
-		val = __phy_read(gp, MII_BMCR, phy_addr);
-		if ((val & BMCR_RESET) == 0)
-			break;
-		udelay(10);
-	}
-	if ((val & BMCR_ISOLATE) && limit > 0)
-		__phy_write(gp, MII_BMCR, val & ~BMCR_ISOLATE, phy_addr);
-	
-	return (limit <= 0);
-}
-
-/* Must be invoked under gp->lock. */
-static void gem_init_bcm5201_phy(struct gem *gp)
-{
-	u16 data;
-
-	data = phy_read(gp, MII_BCM5201_MULTIPHY);
-	data &= ~MII_BCM5201_MULTIPHY_SUPERISOLATE;
-	phy_write(gp, MII_BCM5201_MULTIPHY, data);
-}
-
-/* Must be invoked under gp->lock. */
-static void gem_init_bcm5400_phy(struct gem *gp)
-{
-	u16 data;
-
-	/* Configure for gigabit full duplex */
-	data = phy_read(gp, MII_BCM5400_AUXCONTROL);
-	data |= MII_BCM5400_AUXCONTROL_PWR10BASET;
-	phy_write(gp, MII_BCM5400_AUXCONTROL, data);
-	
-	data = phy_read(gp, MII_BCM5400_GB_CONTROL);
-	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
-	phy_write(gp, MII_BCM5400_GB_CONTROL, data);
-	
-	mdelay(10);
-
-	/* Reset and configure cascaded 10/100 PHY */
-	gem_reset_one_mii_phy(gp, 0x1f);
-	
-	data = __phy_read(gp, MII_BCM5201_MULTIPHY, 0x1f);
-	data |= MII_BCM5201_MULTIPHY_SERIALMODE;
-	__phy_write(gp, MII_BCM5201_MULTIPHY, data, 0x1f);
-
-	data = phy_read(gp, MII_BCM5400_AUXCONTROL);
-	data &= ~MII_BCM5400_AUXCONTROL_PWR10BASET;
-	phy_write(gp, MII_BCM5400_AUXCONTROL, data);
-}
-
-/* Must be invoked under gp->lock. */
-static void gem_init_bcm5401_phy(struct gem *gp)
-{
-	u16 data;
-	int rev;
-
-	rev = phy_read(gp, MII_PHYSID2) & 0x000f;
-	if (rev == 0 || rev == 3) {
-		/* Some revisions of 5401 appear to need this
-		 * initialisation sequence to disable, according
-		 * to OF, "tap power management"
-		 * 
-		 * WARNING ! OF and Darwin don't agree on the
-		 * register addresses. OF seem to interpret the
-		 * register numbers below as decimal
-		 *
-		 * Note: This should (and does) match tg3_init_5401phy_dsp
-		 *       in the tg3.c driver. -DaveM
-		 */
-		phy_write(gp, 0x18, 0x0c20);
-		phy_write(gp, 0x17, 0x0012);
-		phy_write(gp, 0x15, 0x1804);
-		phy_write(gp, 0x17, 0x0013);
-		phy_write(gp, 0x15, 0x1204);
-		phy_write(gp, 0x17, 0x8006);
-		phy_write(gp, 0x15, 0x0132);
-		phy_write(gp, 0x17, 0x8006);
-		phy_write(gp, 0x15, 0x0232);
-		phy_write(gp, 0x17, 0x201f);
-		phy_write(gp, 0x15, 0x0a20);
-	}
-	
-	/* Configure for gigabit full duplex */
-	data = phy_read(gp, MII_BCM5400_GB_CONTROL);
-	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
-	phy_write(gp, MII_BCM5400_GB_CONTROL, data);
-
-	mdelay(1);
-
-	/* Reset and configure cascaded 10/100 PHY */
-	gem_reset_one_mii_phy(gp, 0x1f);
-	
-	data = __phy_read(gp, MII_BCM5201_MULTIPHY, 0x1f);
-	data |= MII_BCM5201_MULTIPHY_SERIALMODE;
-	__phy_write(gp, MII_BCM5201_MULTIPHY, data, 0x1f);
-}
-
-/* Must be invoked under gp->lock. */
-static void gem_init_bcm5411_phy(struct gem *gp)
-{
-	u16 data;
-
-	/* Here's some more Apple black magic to setup
-	 * some voltage stuffs.
-	 */
-	phy_write(gp, 0x1c, 0x8c23);
-	phy_write(gp, 0x1c, 0x8ca3);
-	phy_write(gp, 0x1c, 0x8c23);
-
-	/* Here, Apple seems to want to reset it, do
-	 * it as well
-	 */
-	phy_write(gp, MII_BMCR, BMCR_RESET);
-
-	/* Start autoneg */
-	phy_write(gp, MII_BMCR,
-		  (BMCR_ANENABLE | BMCR_FULLDPLX |
-		   BMCR_ANRESTART | BMCR_SPD2));
-
-	data = phy_read(gp, MII_BCM5400_GB_CONTROL);
-	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
-	phy_write(gp, MII_BCM5400_GB_CONTROL, data);
-}
-
-/* Must be invoked under gp->lock. */
 static void gem_init_phy(struct gem *gp)
 {
 	u32 mifcfg;
 
-	if (!gp->wake_on_lan && gp->phy_mod == phymod_bcm5201)
-		phy_write(gp, MII_BCM5201_INTERRUPT, 0);
-
 	/* Revert MIF CFG setting done on stop_phy */
 	mifcfg = readl(gp->regs + MIF_CFG);
 	mifcfg &= ~MIF_CFG_BBMODE;
@@ -1681,9 +1533,34 @@
 	
 #ifdef CONFIG_ALL_PPC
 	if (gp->pdev->vendor == PCI_VENDOR_ID_APPLE) {
-		int i;
+		int i, j;
 
+		/* Those delay sucks, the HW seem to love them though, I'll
+		 * serisouly consider breaking some locks here to be able
+		 * to schedule instead
+		 */
 		pmac_call_feature(PMAC_FTR_GMAC_PHY_RESET, gp->of_node, 0, 0);
+		mdelay(10);
+		for (j = 0; j < 3; j++) {
+			/* Some PHYs used by apple have problem getting back to us,
+			 * we _know_ it's actually at addr 0 or 1, that's a hack, but
+			 * it helps to do that reset now. I suspect some motherboards
+			 * don't wire the PHY reset line properly, thus the PHY doesn't
+			 * come back with the above pmac_call_feature.
+			 */
+			gp->mii_phy_addr = 0;
+			phy_write(gp, MII_BMCR, BMCR_RESET);
+			gp->mii_phy_addr = 1;
+			phy_write(gp, MII_BMCR, BMCR_RESET);
+			/* We should probably break some locks here and schedule... */
+			mdelay(10);
+			
+			/* On K2, we only probe the internal PHY at address 1, other
+			 * addresses tend to return garbage.
+			 */
+			if (gp->pdev->device == PCI_DEVICE_ID_APPLE_K2_GMAC)
+				break;
+
 		for (i = 0; i < 32; i++) {
 			gp->mii_phy_addr = i;
 			if (phy_read(gp, MII_BMCR) != 0xffff)
@@ -1692,7 +1569,9 @@
 		if (i == 32) {
 			printk(KERN_WARNING "%s: GMAC PHY not responding !\n",
 			       gp->dev->name);
-			return;
+				gp->mii_phy_addr = 0;
+			} else
+				break;
 		}
 	}
 #endif /* CONFIG_ALL_PPC */
@@ -1716,79 +1595,12 @@
 
 	if (gp->phy_type == phy_mii_mdio0 ||
 	    gp->phy_type == phy_mii_mdio1) {
-		u32 phy_id;
-		u16 val;
-	
-		/* Take PHY out of isloate mode and reset it. */
-		gem_reset_one_mii_phy(gp, gp->mii_phy_addr);
-
-		phy_id = (phy_read(gp, MII_PHYSID1) << 16 | phy_read(gp, MII_PHYSID2))
-			 	& 0xfffffff0;
-		printk(KERN_INFO "%s: MII PHY ID: %x ", gp->dev->name, phy_id);
-		switch(phy_id) {
-		case 0x406210:
-			gp->phy_mod = phymod_bcm5201;
-			gem_init_bcm5201_phy(gp);
-			printk("BCM 5201\n");
-			break;
-
-		case 0x4061e0:
-			printk("BCM 5221\n");
-			gp->phy_mod = phymod_bcm5221;
-			break;
-
-		case 0x206040:
-			printk("BCM 5400\n");
-			gp->phy_mod = phymod_bcm5400;
-			gem_init_bcm5400_phy(gp);
-			gp->gigabit_capable = 1;
-			break;
+	    	// XXX check for errors
+		mii_phy_probe(&gp->phy_mii, gp->mii_phy_addr);
 
-		case 0x206050:
-			printk("BCM 5401\n");
-			gp->phy_mod = phymod_bcm5401;
-			gem_init_bcm5401_phy(gp);
-			gp->gigabit_capable = 1;
-			break;
-
-		case 0x206070:
-			printk("BCM 5411\n");
-			gp->phy_mod = phymod_bcm5411;
-			gem_init_bcm5411_phy(gp);
-			gp->gigabit_capable = 1;
-			break;
-		case 0x1410c60:
-			printk("M1011 (Marvel ?)\n");
-			gp->phy_mod = phymod_m1011;
-			gp->gigabit_capable = 1;
-			break;
-
-		case 0x18074c0:
-			printk("Lucent\n");
-			gp->phy_mod = phymod_generic;
-			break;
-
-		case 0x437420:
-			printk("Enable Semiconductor\n");
-			gp->phy_mod = phymod_generic;
-			break;
-
-		default:
-			printk("Unknown (Using generic mode)\n");
-			gp->phy_mod = phymod_generic;
-			break;
-		};
-
-		/* Init advertisement and enable autonegotiation. */
-		val = phy_read(gp, MII_BMCR);
-		val &= ~BMCR_ANENABLE;
-		phy_write(gp, MII_BMCR, val);
-		udelay(10);
-		
-		phy_write(gp, MII_ADVERTISE,
-			  phy_read(gp, MII_ADVERTISE) |
-			  (ADVERTISE_10HALF | ADVERTISE_10FULL |
-			   ADVERTISE_100HALF | ADVERTISE_100FULL));
+		/* Init PHY */
+		if (gp->phy_mii.def && gp->phy_mii.def->ops->init)
+			gp->phy_mii.def->ops->init(&gp->phy_mii);
 	} else {
 		u32 val;
 		int limit;
@@ -1845,13 +1657,7 @@
 		else
 			val |= PCS_SCTRL_LOOP;
 		writel(val, gp->regs + PCS_SCTRL);
-		gp->gigabit_capable = 1;
 	}
-
-	/* BMCR_SPD2 is a broadcom 54xx specific thing afaik */
-	if (gp->phy_mod != phymod_bcm5400 && gp->phy_mod != phymod_bcm5401 &&
-	    gp->phy_mod != phymod_bcm5411)
-	    	gp->link_cntl &= ~BMCR_SPD2;
 }
 
 /* Must be invoked under gp->lock. */
@@ -1940,8 +1746,6 @@
 {
 	unsigned char *e = &gp->dev->dev_addr[0];
 
-	if (gp->pdev->vendor == PCI_VENDOR_ID_SUN &&
-	    gp->pdev->device == PCI_DEVICE_ID_SUN_GEM)
 		writel(0x1bf0, gp->regs + MAC_SNDPAUSE);
 
 	writel(0x00, gp->regs + MAC_IPG0);
@@ -1979,7 +1783,9 @@
 	writel(0, gp->regs + MAC_AF0MSK);
 
 	gp->mac_rx_cfg = gem_setup_multicast(gp);
-
+#ifdef STRIP_FCS
+	gp->mac_rx_cfg |= MAC_RXCFG_SFCS;
+#endif
 	writel(0, gp->regs + MAC_NCOLL);
 	writel(0, gp->regs + MAC_FASUCC);
 	writel(0, gp->regs + MAC_ECOLL);
@@ -2016,6 +1822,8 @@
 /* Must be invoked under gp->lock. */
 static void gem_init_pause_thresholds(struct gem *gp)
 {
+       	u32 cfg;
+
 	/* Calculate pause thresholds.  Setting the OFF threshold to the
 	 * full RX fifo size effectively disables PAUSE generation which
 	 * is what we do for 10/100 only GEMs which have FIFOs too small
@@ -2032,16 +1840,27 @@
 		gp->rx_pause_on = on;
 	}
 
-	{
-		u32 cfg;
 
+	/* Configure the chip "burst" DMA mode & enable some
+	 * HW bug fixes on Apple version
+	 */
 		cfg  = 0;
+       	if (gp->pdev->vendor == PCI_VENDOR_ID_APPLE)
+		cfg |= GREG_CFG_RONPAULBIT | GREG_CFG_ENBUG2FIX;
 #if !defined(CONFIG_SPARC64) && !defined(CONFIG_ALPHA)
 		cfg |= GREG_CFG_IBURST;
 #endif
 		cfg |= ((31 << 1) & GREG_CFG_TXDMALIM);
 		cfg |= ((31 << 6) & GREG_CFG_RXDMALIM);
 		writel(cfg, gp->regs + GREG_CFG);
+
+	/* If Infinite Burst didn't stick, then use different
+	 * thresholds (and Apple bug fixes don't exist)
+	 */
+	if (!(readl(gp->regs + GREG_CFG) & GREG_CFG_IBURST)) {
+		cfg = ((2 << 1) & GREG_CFG_TXDMALIM);
+		cfg |= ((8 << 6) & GREG_CFG_RXDMALIM);
+		writel(cfg, gp->regs + GREG_CFG);
 	}
 }
 
@@ -2155,14 +1974,17 @@
 		/* Default aneg parameters */
 		gp->timer_ticks = 0;
 		gp->lstate = link_down;
+		netif_carrier_off(gp->dev);
 
 		/* Can I advertise gigabit here ? I'd need BCM PHY docs... */
 		gem_begin_auto_negotiation(gp, NULL);
 	} else {
-		if (gp->lstate == link_up)
+		if (gp->lstate == link_up) {
+			netif_carrier_on(gp->dev);
 			gem_set_link_modes(gp);
 	}
 }
+}
 
 #ifdef CONFIG_ALL_PPC
 /* Enable the chip's clock and make sure it's config space is
@@ -2182,8 +2004,10 @@
 	pci_read_config_word(gp->pdev, PCI_COMMAND, &cmd);
 	cmd |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE;
     	pci_write_config_word(gp->pdev, PCI_COMMAND, cmd);
+	if (gp->pdev->device != PCI_DEVICE_ID_APPLE_K2_GMAC) {
     	pci_write_config_byte(gp->pdev, PCI_LATENCY_TIMER, 6);
     	pci_write_config_byte(gp->pdev, PCI_CACHE_LINE_SIZE, 8);
+	}
 
 	mdelay(1);
 	
@@ -2210,9 +2034,6 @@
 {
 	u32 mifcfg;
 
-	if (!gp->wake_on_lan && gp->phy_mod == phymod_bcm5201)
-		phy_write(gp, MII_BCM5201_INTERRUPT, 0);
-
 	/* Make sure we aren't polling PHY status change. We
 	 * don't currently use that feature though
 	 */
@@ -2220,13 +2041,13 @@
 	mifcfg &= ~MIF_CFG_POLL;
 	writel(mifcfg, gp->regs + MIF_CFG);
 
-	/* Here's a strange hack used by both MacOS 9 and X */
-	phy_write(gp, MII_LPA, phy_read(gp, MII_LPA));
-
 	if (gp->wake_on_lan) {
 		/* Setup wake-on-lan */
-	} else
+	} else {
 		writel(0, gp->regs + MAC_RXCFG);
+		(void)readl(gp->regs + MAC_RXCFG);
+		mdelay(4);
+	}
 	writel(0, gp->regs + MAC_TXCFG);
 	writel(0, gp->regs + MAC_XIFCFG);
 	writel(0, gp->regs + TXDMA_CFG);
@@ -2236,21 +2057,12 @@
 		gem_stop(gp);
 		writel(MAC_TXRST_CMD, gp->regs + MAC_TXRST);
 		writel(MAC_RXRST_CMD, gp->regs + MAC_RXRST);
-		if (gp->phy_mod == phymod_bcm5400 || gp->phy_mod == phymod_bcm5401 ||
-		    gp->phy_mod == phymod_bcm5411) {
-#if 0 /* Commented out in Darwin... someone has those dawn docs ? */
-			phy_write(gp, MII_BMCR, BMCR_PDOWN);
-#endif
-		} else if (gp->phy_mod == phymod_bcm5201 || gp->phy_mod == phymod_bcm5221) {
-#if 0 /* Commented out in Darwin... someone has those dawn docs ? */
-			u16 val = phy_read(gp, MII_BCM5201_AUXMODE2)
-			phy_write(gp, MII_BCM5201_AUXMODE2,
-				  val & ~MII_BCM5201_AUXMODE2_LOWPOWER);
-#endif				
-			phy_write(gp, MII_BCM5201_MULTIPHY, MII_BCM5201_MULTIPHY_SUPERISOLATE);
-		} else if (gp->phy_mod == phymod_m1011)
-			phy_write(gp, MII_BMCR, BMCR_PDOWN);
+	}
+
+	if (found_mii_phy(gp) && gp->phy_mii.def->ops->suspend)
+		gp->phy_mii.def->ops->suspend(&gp->phy_mii, 0 /* wake on lan options */);
 
+	if (!gp->wake_on_lan) {
 		/* According to Apple, we must set the MDIO pins to this begnign
 		 * state or we may 1) eat more current, 2) damage some PHYs
 		 */
@@ -2552,7 +2364,11 @@
 	netif_stop_queue(dev);
 
 	rxcfg = readl(gp->regs + MAC_RXCFG);
-	gp->mac_rx_cfg = rxcfg_new = gem_setup_multicast(gp);
+	rxcfg_new = gem_setup_multicast(gp);
+#ifdef STRIP_FCS
+	rxcfg_new |= MAC_RXCFG_SFCS;
+#endif
+	gp->mac_rx_cfg = rxcfg_new;
 	
 	writel(rxcfg & ~MAC_RXCFG_ENAB, gp->regs + MAC_RXCFG);
 	while (readl(gp->regs + MAC_RXCFG) & MAC_RXCFG_ENAB) {
@@ -2577,8 +2393,6 @@
 static int gem_ethtool_ioctl(struct net_device *dev, void *ep_user)
 {
 	struct gem *gp = dev->priv;
-	u16 bmcr;
-	int full_duplex, speed, pause;
 	struct ethtool_cmd ecmd;
 
 	if (copy_from_user(&ecmd, ep_user, sizeof(ecmd)))
@@ -2586,7 +2400,7 @@
 		
 	switch(ecmd.cmd) {
         case ETHTOOL_GDRVINFO: {
-		struct ethtool_drvinfo info = { cmd: ETHTOOL_GDRVINFO };
+		struct ethtool_drvinfo info = { .cmd = ETHTOOL_GDRVINFO };
 
 		strncpy(info.driver, DRV_NAME, ETHTOOL_BUSINFO_LEN);
 		strncpy(info.version, DRV_VERSION, ETHTOOL_BUSINFO_LEN);
@@ -2601,41 +2415,36 @@
 	}
 
 	case ETHTOOL_GSET:
-		ecmd.supported =
-			(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
-			 SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
-			 SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII);
-
-		if (gp->gigabit_capable)
-			ecmd.supported |=
-				(SUPPORTED_1000baseT_Half |
-				 SUPPORTED_1000baseT_Full);
+		if (gp->phy_type == phy_mii_mdio0 ||
+	     	    gp->phy_type == phy_mii_mdio1) {
+	     	    	if (gp->phy_mii.def)
+	     	    		ecmd.supported = gp->phy_mii.def->features;
+	     	    	else
+	     	    		ecmd.supported = SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full;
 
 		/* XXX hardcoded stuff for now */
 		ecmd.port = PORT_MII;
 		ecmd.transceiver = XCVR_EXTERNAL;
 		ecmd.phy_address = 0; /* XXX fixed PHYAD */
 
-		/* Record PHY settings if HW is on. */
+			/* Return current PHY settings */
 		spin_lock_irq(&gp->lock);
-		if (gp->hw_running) {
-			bmcr = phy_read(gp, MII_BMCR);
-			gem_read_mii_link_mode(gp, &full_duplex, &speed, &pause);
-		} else
-			bmcr = 0;
+			ecmd.autoneg = gp->want_autoneg;
+			ecmd.speed = gp->phy_mii.speed;
+			ecmd.duplex = gp->phy_mii.duplex;			
+			ecmd.advertising = gp->phy_mii.advertising;
+			/* If we started with a forced mode, we don't have a default
+			 * advertise set, we need to return something sensible so
+			 * userland can re-enable autoneg properly */
+			if (ecmd.advertising == 0)
+				ecmd.advertising = ecmd.supported;
 		spin_unlock_irq(&gp->lock);
-		if (bmcr & BMCR_ANENABLE) {
-			ecmd.autoneg = AUTONEG_ENABLE;
-			ecmd.speed = speed == 10 ? SPEED_10 : (speed == 1000 ? SPEED_1000 : SPEED_100);
-			ecmd.duplex = full_duplex ? DUPLEX_FULL : DUPLEX_HALF;
-		} else {
-			ecmd.autoneg = AUTONEG_DISABLE;
-			ecmd.speed =
-				(bmcr & BMCR_SPEED100) ?
-				SPEED_100 : SPEED_10;
-			ecmd.duplex =
-				(bmcr & BMCR_FULLDPLX) ?
-				DUPLEX_FULL : DUPLEX_HALF;
+		} else { // XXX PCS ?
+	     	    ecmd.supported =
+			(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+			 SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+			 SUPPORTED_Autoneg);
+		    ecmd.advertising = ecmd.supported;
 		}
 		if (copy_to_user(ep_user, &ecmd, sizeof(ecmd)))
 			return -EFAULT;
@@ -2647,8 +2456,13 @@
 		    ecmd.autoneg != AUTONEG_DISABLE)
 			return -EINVAL;
 
+		if (ecmd.autoneg == AUTONEG_ENABLE &&
+		    ecmd.advertising == 0)
+		    	return -EINVAL;
+
 		if (ecmd.autoneg == AUTONEG_DISABLE &&
-		    ((ecmd.speed != SPEED_100 &&
+		    ((ecmd.speed != SPEED_1000 &&
+		      ecmd.speed != SPEED_100 &&
 		      ecmd.speed != SPEED_10) ||
 		     (ecmd.duplex != DUPLEX_HALF &&
 		      ecmd.duplex != DUPLEX_FULL)))
@@ -2662,7 +2476,7 @@
 		return 0;
 
 	case ETHTOOL_NWAY_RST:
-		if ((gp->link_cntl & BMCR_ANENABLE) == 0)
+		if (!gp->want_autoneg)
 			return -EINVAL;
 
 		/* Restart link process. */
@@ -2678,7 +2492,7 @@
 
 	/* get link status */
 	case ETHTOOL_GLINK: {
-		struct ethtool_value edata = { cmd: ETHTOOL_GLINK };
+		struct ethtool_value edata = { .cmd = ETHTOOL_GLINK };
 
 		edata.data = (gp->lstate == link_up);
 		if (copy_to_user(ep_user, &edata, sizeof(edata)))
@@ -2688,7 +2502,7 @@
 
 	/* get message-level */
 	case ETHTOOL_GMSGLVL: {
-		struct ethtool_value edata = { cmd: ETHTOOL_GMSGLVL };
+		struct ethtool_value edata = { .cmd = ETHTOOL_GMSGLVL };
 
 		edata.data = gp->msg_enable;
 		if (copy_to_user(ep_user, &edata, sizeof(edata)))
@@ -2766,15 +2580,21 @@
 		/* Fallthrough... */
 
 	case SIOCGMIIREG:		/* Read MII PHY register. */
-		data->val_out = __phy_read(gp, data->reg_num & 0x1f, data->phy_id & 0x1f);
+		if (!gp->hw_running)
+			rc = -EIO;
+		else {
+			data->val_out = __phy_read(gp, data->phy_id & 0x1f, data->reg_num & 0x1f);
 		rc = 0;
+		}
 		break;
 
 	case SIOCSMIIREG:		/* Write MII PHY register. */
-		if (!capable(CAP_NET_ADMIN)) {
+		if (!capable(CAP_NET_ADMIN))
 			rc = -EPERM;
-		} else {
-			__phy_write(gp, data->reg_num & 0x1f, data->val_in, data->phy_id & 0x1f);
+		else if (!gp->hw_running)
+			rc = -EIO;
+		else {
+			__phy_write(gp, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);
 			rc = 0;
 		}
 		break;
@@ -2874,7 +2694,14 @@
 	if (addr == NULL) {
 		printk("\n");
 		printk(KERN_ERR "%s: can't get mac-address\n", dev->name);
-		return -1;
+		dev->dev_addr[0] = 0x00;
+		dev->dev_addr[1] = 0x11;
+		dev->dev_addr[2] = 0x22;
+		dev->dev_addr[3] = 0x33;
+		dev->dev_addr[4] = 0x44;
+		dev->dev_addr[5] = 0x55;
+		//		return -1;
+		return 0;
 	}
 	memcpy(dev->dev_addr, addr, MAX_ADDR_LEN);
 #else
@@ -2920,7 +2747,7 @@
 	 */
 	if (pdev->vendor == PCI_VENDOR_ID_SUN &&
 	    pdev->device == PCI_DEVICE_ID_SUN_GEM &&
-	    !pci_set_dma_mask(pdev, (u64) 0xffffffffffffffff)) {
+	    !pci_set_dma_mask(pdev, (u64) 0xffffffffffffffffULL)) {
 		pci_using_dac = 1;
 	} else {
 		err = pci_set_dma_mask(pdev, (u64) 0xffffffff);
@@ -2960,7 +2787,7 @@
 	dev->base_addr = (long) pdev;
 	gp->dev = dev;
 
-	gp->msg_enable = (gem_debug < 0 ? DEFAULT_MSG : gem_debug);
+	gp->msg_enable = DEFAULT_MSG;
 
 	spin_lock_init(&gp->lock);
 	init_MUTEX(&gp->pm_sem);
@@ -2976,13 +2803,9 @@
 	INIT_TQUEUE(&gp->pm_task, gem_pm_task, gp);
 	INIT_TQUEUE(&gp->reset_task, gem_reset_task, gp);
 	
-	/* Default link parameters */
-	if (link_mode >= 0 && link_mode <= 6)
-		gp->link_cntl = link_modes[link_mode];
-	else
-		gp->link_cntl = BMCR_ANENABLE;
 	gp->lstate = link_down;
 	gp->timer_ticks = 0;
+	netif_carrier_off(dev);
 
 	gp->regs = (unsigned long) ioremap(gemreg_base, gemreg_len);
 	if (gp->regs == 0UL) {
@@ -3003,16 +2826,18 @@
 	gem_stop(gp);
 	spin_unlock_irq(&gp->lock);
 
+	/* Fill up the mii_phy structure (even if we won't use it) */
+	gp->phy_mii.dev = dev;
+	gp->phy_mii.mdio_read = _phy_read;
+	gp->phy_mii.mdio_write = _phy_write;
+
+	/* By default, we start with autoneg */
+	gp->want_autoneg = 1;
+	
 	if (gem_check_invariants(gp))
 		goto err_out_iounmap;
 
-	spin_lock_irq(&gp->lock);
-	gp->hw_running = 1;
-	gem_init_phy(gp);
-	gem_begin_auto_negotiation(gp, NULL);
-	spin_unlock_irq(&gp->lock);
-
-	/* It is guarenteed that the returned buffer will be at least
+	/* It is guaranteed that the returned buffer will be at least
 	 * PAGE_SIZE aligned.
 	 */
 	gp->init_block = (struct gem_init_block *)
@@ -3044,6 +2869,18 @@
 		       i == 5 ? ' ' : ':');
 	printk("\n");
 
+	/* Detect & init PHY, start autoneg */
+	spin_lock_irq(&gp->lock);
+	gp->hw_running = 1;
+	gem_init_phy(gp);
+	gem_begin_auto_negotiation(gp, NULL);
+	spin_unlock_irq(&gp->lock);
+
+	if (gp->phy_type == phy_mii_mdio0 ||
+     	    gp->phy_type == phy_mii_mdio1)
+		printk(KERN_INFO "%s: Found %s PHY\n", dev->name, 
+			gp->phy_mii.def ? gp->phy_mii.def->name : "no");
+
 	pci_set_drvdata(pdev, dev);
 
 	dev->open = gem_open;
diff -urN kernel-source-2.4.27/drivers/net/sungem.h kernel-source-2.4.27-benh/drivers/net/sungem.h
--- kernel-source-2.4.27/drivers/net/sungem.h	2002-08-03 02:39:44.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/net/sungem.h	2004-09-01 20:56:26.951021880 +0200
@@ -28,6 +28,9 @@
 #define GREG_CFG_IBURST		0x00000001	/* Infinite Burst		*/
 #define GREG_CFG_TXDMALIM	0x0000003e	/* TX DMA grant limit		*/
 #define GREG_CFG_RXDMALIM	0x000007c0	/* RX DMA grant limit		*/
+#define GREG_CFG_RONPAULBIT	0x00000800	/* Use mem read multiple for PCI read
+						 * after infinite burst (Apple) */
+#define GREG_CFG_ENBUG2FIX	0x00001000	/* Fix Rx hang after overflow */
 
 /* Global Interrupt Status Register.
  *
@@ -805,14 +808,14 @@
 	u64	buffer;
 };
 
-#define TXDCTRL_BUFSZ	0x0000000000007fff	/* Buffer Size		*/
-#define TXDCTRL_CSTART	0x00000000001f8000	/* CSUM Start Offset	*/
-#define TXDCTRL_COFF	0x000000001fe00000	/* CSUM Stuff Offset	*/
-#define TXDCTRL_CENAB	0x0000000020000000	/* CSUM Enable		*/
-#define TXDCTRL_EOF	0x0000000040000000	/* End of Frame		*/
-#define TXDCTRL_SOF	0x0000000080000000	/* Start of Frame	*/
-#define TXDCTRL_INTME	0x0000000100000000	/* "Interrupt Me"	*/
-#define TXDCTRL_NOCRC	0x0000000200000000	/* No CRC Present	*/
+#define TXDCTRL_BUFSZ	0x0000000000007fffULL	/* Buffer Size		*/
+#define TXDCTRL_CSTART	0x00000000001f8000ULL	/* CSUM Start Offset	*/
+#define TXDCTRL_COFF	0x000000001fe00000ULL	/* CSUM Stuff Offset	*/
+#define TXDCTRL_CENAB	0x0000000020000000ULL	/* CSUM Enable		*/
+#define TXDCTRL_EOF	0x0000000040000000ULL	/* End of Frame		*/
+#define TXDCTRL_SOF	0x0000000080000000ULL	/* Start of Frame	*/
+#define TXDCTRL_INTME	0x0000000100000000ULL	/* "Interrupt Me"	*/
+#define TXDCTRL_NOCRC	0x0000000200000000ULL	/* No CRC Present	*/
 
 /* GEM requires that RX descriptors are provided four at a time,
  * aligned.  Also, the RX ring may not wrap around.  This means that
@@ -840,13 +843,13 @@
 	u64	buffer;
 };
 
-#define RXDCTRL_TCPCSUM	0x000000000000ffff	/* TCP Pseudo-CSUM	*/
-#define RXDCTRL_BUFSZ	0x000000007fff0000	/* Buffer Size		*/
-#define RXDCTRL_OWN	0x0000000080000000	/* GEM owns this entry	*/
-#define RXDCTRL_HASHVAL	0x0ffff00000000000	/* Hash Value		*/
-#define RXDCTRL_HPASS	0x1000000000000000	/* Passed Hash Filter	*/
-#define RXDCTRL_ALTMAC	0x2000000000000000	/* Matched ALT MAC	*/
-#define RXDCTRL_BAD	0x4000000000000000	/* Frame has bad CRC	*/
+#define RXDCTRL_TCPCSUM	0x000000000000ffffULL	/* TCP Pseudo-CSUM	*/
+#define RXDCTRL_BUFSZ	0x000000007fff0000ULL	/* Buffer Size		*/
+#define RXDCTRL_OWN	0x0000000080000000ULL	/* GEM owns this entry	*/
+#define RXDCTRL_HASHVAL	0x0ffff00000000000ULL	/* Hash Value		*/
+#define RXDCTRL_HPASS	0x1000000000000000ULL	/* Passed Hash Filter	*/
+#define RXDCTRL_ALTMAC	0x2000000000000000ULL	/* Matched ALT MAC	*/
+#define RXDCTRL_BAD	0x4000000000000000ULL	/* Frame has bad CRC	*/
 
 #define RXDCTRL_FRESH(gp)	\
 	((((RX_BUF_ALLOC_SIZE(gp) - RX_OFFSET) << 16) & RXDCTRL_BUFSZ) | \
@@ -936,16 +939,6 @@
 	phy_serdes,
 };
 
-enum gem_phy_model {
-	phymod_generic,
-	phymod_bcm5201,
-	phymod_bcm5221,
-	phymod_bcm5400,
-	phymod_bcm5401,
-	phymod_bcm5411,
-	phymod_m1011,
-};
-
 enum link_state {
 	link_down = 0,	/* No link, will retry */
 	link_aneg,	/* Autoneg in progress */
@@ -980,21 +973,20 @@
 	struct net_device_stats net_stats;
 
 	enum gem_phy_type	phy_type;
-	enum gem_phy_model	phy_mod;
+	struct mii_phy		phy_mii;
+	
 	int			tx_fifo_sz;
 	int			rx_fifo_sz;
 	int			rx_pause_off;
 	int			rx_pause_on;
 	int			mii_phy_addr;
-	int			gigabit_capable;
 
 	u32			mac_rx_cfg;
 	u32			swrst_base;
 
 	/* Autoneg & PHY control */
-	int			link_cntl;
-	int			link_advertise;
-	int			link_fcntl;
+	int			want_autoneg;
+	int			last_forced_speed;
 	enum link_state		lstate;
 	struct timer_list	link_timer;
 	int			timer_ticks;
@@ -1014,6 +1006,9 @@
 #endif
 };
 
+#define found_mii_phy(gp) ((gp->phy_type == phy_mii_mdio0 || gp->phy_type == phy_mii_mdio1) \
+				&& gp->phy_mii.def && gp->phy_mii.def->ops)
+			
 #define ALIGNED_RX_SKB_ADDR(addr) \
         ((((unsigned long)(addr) + (64UL - 1UL)) & ~(64UL - 1UL)) - (unsigned long)(addr))
 static __inline__ struct sk_buff *gem_alloc_skb(int size, int gfp_flags)
diff -urN kernel-source-2.4.27/drivers/net/sungem_phy.c kernel-source-2.4.27-benh/drivers/net/sungem_phy.c
--- kernel-source-2.4.27/drivers/net/sungem_phy.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/net/sungem_phy.c	2004-09-01 20:56:27.033009416 +0200
@@ -0,0 +1,867 @@
+/*
+ * PHY drivers for the sungem ethernet driver.
+ * 
+ * This file could be shared with other drivers.
+ * 
+ * (c) 2002, Benjamin Herrenscmidt (benh@kernel.crashing.org)
+ *
+ * TODO:
+ *  - Implement WOL
+ *  - Add support for PHYs that provide an IRQ line
+ *  - Eventually moved the entire polling state machine in
+ *    there (out of the eth driver), so that it can easily be
+ *    skipped on PHYs that implement it in hardware.
+ *  - On LXT971 & BCM5201, Apple uses some chip specific regs
+ *    to read the link status. Figure out why and if it makes
+ *    sense to do the same (magic aneg ?)
+ *  - Apple has some additional power management code for some
+ *    Broadcom PHYs that they "hide" from the OpenSource version
+ *    of darwin, still need to reverse engineer that
+ */
+
+#include <linux/config.h>
+
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/delay.h>
+
+#include "sungem_phy.h"
+
+/* Link modes of the BCM5400 PHY */
+static int phy_BCM5400_link_table[8][3] = {
+	{ 0, 0, 0 },	/* No link */
+	{ 0, 0, 0 },	/* 10BT Half Duplex */
+	{ 1, 0, 0 },	/* 10BT Full Duplex */
+	{ 0, 1, 0 },	/* 100BT Half Duplex */
+	{ 0, 1, 0 },	/* 100BT Half Duplex */
+	{ 1, 1, 0 },	/* 100BT Full Duplex*/
+	{ 1, 0, 1 },	/* 1000BT */
+	{ 1, 0, 1 },	/* 1000BT */
+};
+
+static inline int __phy_read(struct mii_phy* phy, int id, int reg)
+{
+	return phy->mdio_read(phy->dev, id, reg);
+}
+
+static inline void __phy_write(struct mii_phy* phy, int id, int reg, int val)
+{
+	phy->mdio_write(phy->dev, id, reg, val);
+}
+
+static inline int phy_read(struct mii_phy* phy, int reg)
+{
+	return phy->mdio_read(phy->dev, phy->mii_id, reg);
+}
+
+static inline void phy_write(struct mii_phy* phy, int reg, int val)
+{
+	phy->mdio_write(phy->dev, phy->mii_id, reg, val);
+}
+
+static int reset_one_mii_phy(struct mii_phy* phy, int phy_id)
+{
+	u16 val;
+	int limit = 10000;
+	
+	val = __phy_read(phy, phy_id, MII_BMCR);
+	val &= ~(BMCR_ISOLATE | BMCR_PDOWN);
+	val |= BMCR_RESET;
+	__phy_write(phy, phy_id, MII_BMCR, val);
+
+	udelay(100);
+
+	while (limit--) {
+		val = __phy_read(phy, phy_id, MII_BMCR);
+		if ((val & BMCR_RESET) == 0)
+			break;
+		udelay(10);
+	}
+	if ((val & BMCR_ISOLATE) && limit > 0)
+		__phy_write(phy, phy_id, MII_BMCR, val & ~BMCR_ISOLATE);
+	
+	return (limit <= 0);
+}
+
+static int bcm5201_init(struct mii_phy* phy)
+{
+	u16 data;
+
+	data = phy_read(phy, MII_BCM5201_MULTIPHY);
+	data &= ~MII_BCM5201_MULTIPHY_SUPERISOLATE;
+	phy_write(phy, MII_BCM5201_MULTIPHY, data);
+
+	return 0;
+}
+
+static int bcm5201_suspend(struct mii_phy* phy, int wol_options)
+{
+	if (!wol_options)
+		phy_write(phy, MII_BCM5201_INTERRUPT, 0);
+
+	/* Here's a strange hack used by both MacOS 9 and X */
+	phy_write(phy, MII_LPA, phy_read(phy, MII_LPA));
+	
+	if (!wol_options) {
+#if 0 /* Commented out in Darwin... someone has those dawn docs ? */
+		u16 val = phy_read(phy, MII_BCM5201_AUXMODE2)
+		phy_write(phy, MII_BCM5201_AUXMODE2,
+			  val & ~MII_BCM5201_AUXMODE2_LOWPOWER);
+#endif			
+		phy_write(phy, MII_BCM5201_MULTIPHY, MII_BCM5201_MULTIPHY_SUPERISOLATE);
+	}
+
+	return 0;
+}
+
+static int bcm5221_init(struct mii_phy* phy)
+{
+	u16 data;
+
+	data = phy_read(phy, MII_BCM5221_TEST);
+	phy_write(phy, MII_BCM5221_TEST,
+		data | MII_BCM5221_TEST_ENABLE_SHADOWS);
+
+	data = phy_read(phy, MII_BCM5221_SHDOW_AUX_STAT2);
+	phy_write(phy, MII_BCM5221_SHDOW_AUX_STAT2,
+		data | MII_BCM5221_SHDOW_AUX_STAT2_APD);
+
+	data = phy_read(phy, MII_BCM5221_SHDOW_AUX_MODE4);
+	phy_write(phy, MII_BCM5221_SHDOW_AUX_MODE4,
+		data | MII_BCM5221_SHDOW_AUX_MODE4_CLKLOPWR);
+
+	data = phy_read(phy, MII_BCM5221_TEST);
+	phy_write(phy, MII_BCM5221_TEST,
+		data & ~MII_BCM5221_TEST_ENABLE_SHADOWS);
+
+	return 0;
+}
+
+static int bcm5400_init(struct mii_phy* phy)
+{
+	u16 data;
+
+	/* Configure for gigabit full duplex */
+	data = phy_read(phy, MII_BCM5400_AUXCONTROL);
+	data |= MII_BCM5400_AUXCONTROL_PWR10BASET;
+	phy_write(phy, MII_BCM5400_AUXCONTROL, data);
+	
+	data = phy_read(phy, MII_BCM5400_GB_CONTROL);
+	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
+	phy_write(phy, MII_BCM5400_GB_CONTROL, data);
+	
+	mdelay(10);
+
+	/* Reset and configure cascaded 10/100 PHY */
+	(void)reset_one_mii_phy(phy, 0x1f);
+	
+	data = __phy_read(phy, 0x1f, MII_BCM5201_MULTIPHY);
+	data |= MII_BCM5201_MULTIPHY_SERIALMODE;
+	__phy_write(phy, 0x1f, MII_BCM5201_MULTIPHY, data);
+
+	data = phy_read(phy, MII_BCM5400_AUXCONTROL);
+	data &= ~MII_BCM5400_AUXCONTROL_PWR10BASET;
+	phy_write(phy, MII_BCM5400_AUXCONTROL, data);
+
+	return 0;
+}
+
+static int bcm5400_suspend(struct mii_phy* phy, int wol_options)
+{
+#if 0 /* Commented out in Darwin... someone has those dawn docs ? */
+	phy_write(phy, MII_BMCR, BMCR_PDOWN);
+#endif
+	return 0;
+}
+
+static int bcm5401_init(struct mii_phy* phy)
+{
+	u16 data;
+	int rev;
+
+	rev = phy_read(phy, MII_PHYSID2) & 0x000f;
+	if (rev == 0 || rev == 3) {
+		/* Some revisions of 5401 appear to need this
+		 * initialisation sequence to disable, according
+		 * to OF, "tap power management"
+		 * 
+		 * WARNING ! OF and Darwin don't agree on the
+		 * register addresses. OF seem to interpret the
+		 * register numbers below as decimal
+		 *
+		 * Note: This should (and does) match tg3_init_5401phy_dsp
+		 *       in the tg3.c driver. -DaveM
+		 */
+		phy_write(phy, 0x18, 0x0c20);
+		phy_write(phy, 0x17, 0x0012);
+		phy_write(phy, 0x15, 0x1804);
+		phy_write(phy, 0x17, 0x0013);
+		phy_write(phy, 0x15, 0x1204);
+		phy_write(phy, 0x17, 0x8006);
+		phy_write(phy, 0x15, 0x0132);
+		phy_write(phy, 0x17, 0x8006);
+		phy_write(phy, 0x15, 0x0232);
+		phy_write(phy, 0x17, 0x201f);
+		phy_write(phy, 0x15, 0x0a20);
+	}
+	
+	/* Configure for gigabit full duplex */
+	data = phy_read(phy, MII_BCM5400_GB_CONTROL);
+	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
+	phy_write(phy, MII_BCM5400_GB_CONTROL, data);
+
+	mdelay(10);
+
+	/* Reset and configure cascaded 10/100 PHY */
+	(void)reset_one_mii_phy(phy, 0x1f);
+	
+	data = __phy_read(phy, 0x1f, MII_BCM5201_MULTIPHY);
+	data |= MII_BCM5201_MULTIPHY_SERIALMODE;
+	__phy_write(phy, 0x1f, MII_BCM5201_MULTIPHY, data);
+
+	return 0;
+}
+
+static int bcm5401_suspend(struct mii_phy* phy, int wol_options)
+{
+#if 0 /* Commented out in Darwin... someone has those dawn docs ? */
+	phy_write(phy, MII_BMCR, BMCR_PDOWN);
+#endif
+	return 0;
+}
+
+static int bcm5411_init(struct mii_phy* phy)
+{
+	u16 data;
+
+	/* Here's some more Apple black magic to setup
+	 * some voltage stuffs.
+	 */
+	phy_write(phy, 0x1c, 0x8c23);
+	phy_write(phy, 0x1c, 0x8ca3);
+	phy_write(phy, 0x1c, 0x8c23);
+
+	/* Here, Apple seems to want to reset it, do
+	 * it as well
+	 */
+	phy_write(phy, MII_BMCR, BMCR_RESET);
+	phy_write(phy, MII_BMCR, 0x1340);
+
+	data = phy_read(phy, MII_BCM5400_GB_CONTROL);
+	data |= MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP;
+	phy_write(phy, MII_BCM5400_GB_CONTROL, data);
+
+	mdelay(10);
+
+	/* Reset and configure cascaded 10/100 PHY */
+	(void)reset_one_mii_phy(phy, 0x1f);
+	
+	return 0;
+}
+
+static int bcm5411_suspend(struct mii_phy* phy, int wol_options)
+{
+	phy_write(phy, MII_BMCR, BMCR_PDOWN);
+
+	return 0;
+}
+
+static int bcm5421_init(struct mii_phy* phy)
+{
+	u16 data;
+	int rev;
+
+	rev = phy_read(phy, MII_PHYSID2) & 0x000f;
+	if (rev == 0) {
+		/* This is borrowed from MacOS
+		 */
+		phy_write(phy, 0x18, 0x1007);
+		data = phy_read(phy, 0x18);
+		phy_write(phy, 0x18, data | 0x0400);
+		phy_write(phy, 0x18, 0x0007);
+		data = phy_read(phy, 0x18);
+		phy_write(phy, 0x18, data | 0x0800);
+		phy_write(phy, 0x17, 0x000a);
+		data = phy_read(phy, 0x15);
+		phy_write(phy, 0x15, data | 0x0200);
+	}
+#if 0
+	/* This has to be verified before I enable it */
+	/* Enable automatic low-power */
+	phy_write(phy, 0x1c, 0x9002);
+	phy_write(phy, 0x1c, 0xa821);
+	phy_write(phy, 0x1c, 0x941d);
+#endif
+	return 0;
+}
+
+static int bcm5421k2_init(struct mii_phy* phy)
+{
+	/* Init code borrowed from OF */
+	phy_write(phy, 4, 0x01e1);
+	phy_write(phy, 9, 0x0300);
+
+	return 0;
+}
+
+static int bcm54xx_setup_aneg(struct mii_phy *phy, u32 advertise)
+{
+	u16 ctl, adv;
+	
+	phy->autoneg = 1;
+	phy->speed = SPEED_10;
+	phy->duplex = DUPLEX_HALF;
+	phy->pause = 0;
+	phy->advertising = advertise;
+
+	/* Setup standard advertise */
+	adv = phy_read(phy, MII_ADVERTISE);
+	adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+	if (advertise & ADVERTISED_10baseT_Half)
+		adv |= ADVERTISE_10HALF;
+	if (advertise & ADVERTISED_10baseT_Full)
+		adv |= ADVERTISE_10FULL;
+	if (advertise & ADVERTISED_100baseT_Half)
+		adv |= ADVERTISE_100HALF;
+	if (advertise & ADVERTISED_100baseT_Full)
+		adv |= ADVERTISE_100FULL;
+	phy_write(phy, MII_ADVERTISE, adv);
+
+	/* Setup 1000BT advertise */
+	adv = phy_read(phy, MII_1000BASETCONTROL);
+	adv &= ~(MII_1000BASETCONTROL_FULLDUPLEXCAP|MII_1000BASETCONTROL_HALFDUPLEXCAP);
+	if (advertise & SUPPORTED_1000baseT_Half)
+		adv |= MII_1000BASETCONTROL_HALFDUPLEXCAP;
+	if (advertise & SUPPORTED_1000baseT_Full)
+		adv |= MII_1000BASETCONTROL_FULLDUPLEXCAP;
+	phy_write(phy, MII_1000BASETCONTROL, adv);
+
+	/* Start/Restart aneg */
+	ctl = phy_read(phy, MII_BMCR);
+	ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	phy_write(phy, MII_BMCR, ctl);
+
+	return 0;
+}
+
+static int bcm54xx_setup_forced(struct mii_phy *phy, int speed, int fd)
+{
+	u16 ctl;
+	
+	phy->autoneg = 0;
+	phy->speed = speed;
+	phy->duplex = fd;
+	phy->pause = 0;
+
+	ctl = phy_read(phy, MII_BMCR);
+	ctl &= ~(BMCR_FULLDPLX|BMCR_SPEED100|BMCR_SPD2|BMCR_ANENABLE);
+
+	/* First reset the PHY */
+	phy_write(phy, MII_BMCR, ctl | BMCR_RESET);
+
+	/* Select speed & duplex */
+	switch(speed) {
+	case SPEED_10:
+		break;
+	case SPEED_100:
+		ctl |= BMCR_SPEED100;
+		break;
+	case SPEED_1000:
+		ctl |= BMCR_SPD2;
+	}
+	if (fd == DUPLEX_FULL)
+		ctl |= BMCR_FULLDPLX;
+
+	// XXX Should we set the sungem to GII now on 1000BT ?
+	
+	phy_write(phy, MII_BMCR, ctl);
+
+	return 0;
+}
+
+static int bcm54xx_read_link(struct mii_phy *phy)
+{
+	int link_mode;	
+	u16 val;
+	
+	if (phy->autoneg) {
+	    	val = phy_read(phy, MII_BCM5400_AUXSTATUS);
+		link_mode = ((val & MII_BCM5400_AUXSTATUS_LINKMODE_MASK) >>
+			     MII_BCM5400_AUXSTATUS_LINKMODE_SHIFT);
+		phy->duplex = phy_BCM5400_link_table[link_mode][0] ? DUPLEX_FULL : DUPLEX_HALF;
+		phy->speed = phy_BCM5400_link_table[link_mode][2] ?
+				SPEED_1000 :
+				(phy_BCM5400_link_table[link_mode][1] ? SPEED_100 : SPEED_10);
+		val = phy_read(phy, MII_LPA);
+		phy->pause = ((val & LPA_PAUSE) != 0);
+	}
+	/* On non-aneg, we assume what we put in BMCR is the speed,
+	 * though magic-aneg shouldn't prevent this case from occurring
+	 */
+
+	return 0;
+}
+
+static int marvell_setup_aneg(struct mii_phy *phy, u32 advertise)
+{
+	u16 ctl, adv;
+	
+	phy->autoneg = 1;
+	phy->speed = SPEED_10;
+	phy->duplex = DUPLEX_HALF;
+	phy->pause = 0;
+	phy->advertising = advertise;
+
+	/* Setup standard advertise */
+	adv = phy_read(phy, MII_ADVERTISE);
+	adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+	if (advertise & ADVERTISED_10baseT_Half)
+		adv |= ADVERTISE_10HALF;
+	if (advertise & ADVERTISED_10baseT_Full)
+		adv |= ADVERTISE_10FULL;
+	if (advertise & ADVERTISED_100baseT_Half)
+		adv |= ADVERTISE_100HALF;
+	if (advertise & ADVERTISED_100baseT_Full)
+		adv |= ADVERTISE_100FULL;
+	phy_write(phy, MII_ADVERTISE, adv);
+
+	/* Setup 1000BT advertise & enable crossover detect
+	 * XXX How do we advertise 1000BT ? Darwin source is
+	 * confusing here, they read from specific control and
+	 * write to control... Someone has specs for those
+	 * beasts ?
+	 */
+	adv = phy_read(phy, MII_M1011_PHY_SPEC_CONTROL);
+	adv |= MII_M1011_PHY_SPEC_CONTROL_AUTO_MDIX;
+	adv &= ~(MII_1000BASETCONTROL_FULLDUPLEXCAP |
+			MII_1000BASETCONTROL_HALFDUPLEXCAP);
+	if (advertise & SUPPORTED_1000baseT_Half)
+		adv |= MII_1000BASETCONTROL_HALFDUPLEXCAP;
+	if (advertise & SUPPORTED_1000baseT_Full)
+		adv |= MII_1000BASETCONTROL_FULLDUPLEXCAP;
+	phy_write(phy, MII_1000BASETCONTROL, adv);
+
+	/* Start/Restart aneg */
+	ctl = phy_read(phy, MII_BMCR);
+	ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	phy_write(phy, MII_BMCR, ctl);
+
+	return 0;
+}
+
+static int marvell_setup_forced(struct mii_phy *phy, int speed, int fd)
+{
+	u16 ctl, ctl2;
+	
+	phy->autoneg = 0;
+	phy->speed = speed;
+	phy->duplex = fd;
+	phy->pause = 0;
+
+	ctl = phy_read(phy, MII_BMCR);
+	ctl &= ~(BMCR_FULLDPLX|BMCR_SPEED100|BMCR_SPD2|BMCR_ANENABLE);
+	ctl |= BMCR_RESET;
+
+	/* Select speed & duplex */
+	switch(speed) {
+	case SPEED_10:
+		break;
+	case SPEED_100:
+		ctl |= BMCR_SPEED100;
+		break;
+	/* I'm not sure about the one below, again, Darwin source is
+	 * quite confusing and I lack chip specs
+	 */
+	case SPEED_1000:
+		ctl |= BMCR_SPD2;
+	}
+	if (fd == DUPLEX_FULL)
+		ctl |= BMCR_FULLDPLX;
+
+	/* Disable crossover. Again, the way Apple does it is strange,
+	 * though I don't assume they are wrong ;)
+	 */
+	ctl2 = phy_read(phy, MII_M1011_PHY_SPEC_CONTROL);
+	ctl2 &= ~(MII_M1011_PHY_SPEC_CONTROL_MANUAL_MDIX |
+		MII_M1011_PHY_SPEC_CONTROL_AUTO_MDIX |
+		MII_1000BASETCONTROL_FULLDUPLEXCAP |
+		MII_1000BASETCONTROL_HALFDUPLEXCAP);
+	if (speed == SPEED_1000)
+		ctl2 |= (fd == DUPLEX_FULL) ?
+			MII_1000BASETCONTROL_FULLDUPLEXCAP :
+			MII_1000BASETCONTROL_HALFDUPLEXCAP;
+	phy_write(phy, MII_1000BASETCONTROL, ctl2);
+
+	// XXX Should we set the sungem to GII now on 1000BT ?
+	
+	phy_write(phy, MII_BMCR, ctl);
+
+	return 0;
+}
+
+static int marvell_read_link(struct mii_phy *phy)
+{
+	u16 status;
+
+	if (phy->autoneg) {
+		status = phy_read(phy, MII_M1011_PHY_SPEC_STATUS);
+		if ((status & MII_M1011_PHY_SPEC_STATUS_RESOLVED) == 0)
+			return -EAGAIN;
+		if (status & MII_M1011_PHY_SPEC_STATUS_1000)
+			phy->speed = SPEED_1000;
+		else if (status & MII_M1011_PHY_SPEC_STATUS_100)
+			phy->speed = SPEED_100;
+		else
+			phy->speed = SPEED_10;
+		if (status & MII_M1011_PHY_SPEC_STATUS_FULLDUPLEX)
+			phy->duplex = DUPLEX_FULL;
+		else
+			phy->duplex = DUPLEX_HALF;
+		phy->pause = 0; /* XXX Check against spec ! */
+	}
+	/* On non-aneg, we assume what we put in BMCR is the speed,
+	 * though magic-aneg shouldn't prevent this case from occurring
+	 */
+
+	return 0;
+}
+
+static int genmii_setup_aneg(struct mii_phy *phy, u32 advertise)
+{
+	u16 ctl, adv;
+	
+	phy->autoneg = 1;
+	phy->speed = SPEED_10;
+	phy->duplex = DUPLEX_HALF;
+	phy->pause = 0;
+	phy->advertising = advertise;
+
+	/* Setup standard advertise */
+	adv = phy_read(phy, MII_ADVERTISE);
+	adv &= ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+	if (advertise & ADVERTISED_10baseT_Half)
+		adv |= ADVERTISE_10HALF;
+	if (advertise & ADVERTISED_10baseT_Full)
+		adv |= ADVERTISE_10FULL;
+	if (advertise & ADVERTISED_100baseT_Half)
+		adv |= ADVERTISE_100HALF;
+	if (advertise & ADVERTISED_100baseT_Full)
+		adv |= ADVERTISE_100FULL;
+	phy_write(phy, MII_ADVERTISE, adv);
+
+	/* Start/Restart aneg */
+	ctl = phy_read(phy, MII_BMCR);
+	ctl |= (BMCR_ANENABLE | BMCR_ANRESTART);
+	phy_write(phy, MII_BMCR, ctl);
+
+	return 0;
+}
+
+static int genmii_setup_forced(struct mii_phy *phy, int speed, int fd)
+{
+	u16 ctl;
+	
+	phy->autoneg = 0;
+	phy->speed = speed;
+	phy->duplex = fd;
+	phy->pause = 0;
+
+	ctl = phy_read(phy, MII_BMCR);
+	ctl &= ~(BMCR_FULLDPLX|BMCR_SPEED100|BMCR_ANENABLE);
+
+	/* First reset the PHY */
+	phy_write(phy, MII_BMCR, ctl | BMCR_RESET);
+
+	/* Select speed & duplex */
+	switch(speed) {
+	case SPEED_10:
+		break;
+	case SPEED_100:
+		ctl |= BMCR_SPEED100;
+		break;
+	case SPEED_1000:
+	default:
+		return -EINVAL;
+	}
+	if (fd == DUPLEX_FULL)
+		ctl |= BMCR_FULLDPLX;
+	phy_write(phy, MII_BMCR, ctl);
+
+	return 0;
+}
+
+static int genmii_poll_link(struct mii_phy *phy)
+{
+	u16 status;
+	
+	(void)phy_read(phy, MII_BMSR);
+	status = phy_read(phy, MII_BMSR);
+	if ((status & BMSR_LSTATUS) == 0)
+		return 0;
+	if (phy->autoneg && !(status & BMSR_ANEGCOMPLETE))
+		return 0;
+	return 1;
+}
+
+static int genmii_read_link(struct mii_phy *phy)
+{
+	u16 lpa;
+
+	if (phy->autoneg) {
+		lpa = phy_read(phy, MII_LPA);
+
+		if (lpa & (LPA_10FULL | LPA_100FULL))
+			phy->duplex = DUPLEX_FULL;
+		else
+			phy->duplex = DUPLEX_HALF;
+		if (lpa & (LPA_100FULL | LPA_100HALF))
+			phy->speed = SPEED_100;
+		else
+			phy->speed = SPEED_10;
+		phy->pause = 0;
+	}
+	/* On non-aneg, we assume what we put in BMCR is the speed,
+	 * though magic-aneg shouldn't prevent this case from occurring
+	 */
+
+	 return 0;
+}
+
+
+#define MII_BASIC_FEATURES	(SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full | \
+				 SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full | \
+				 SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII)
+#define MII_GBIT_FEATURES	(MII_BASIC_FEATURES | \
+				 SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)
+
+/* Broadcom BCM 5201 */
+static struct mii_phy_ops bcm5201_phy_ops = {
+	.init		= bcm5201_init,
+	.suspend	= bcm5201_suspend,
+	.setup_aneg	= genmii_setup_aneg,
+	.setup_forced	= genmii_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= genmii_read_link,
+};
+
+static struct mii_phy_def bcm5201_phy_def = {
+	.phy_id		= 0x00406210,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5201",
+	.features	= MII_BASIC_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5201_phy_ops
+};
+
+/* Broadcom BCM 5221 */
+static struct mii_phy_ops bcm5221_phy_ops = {
+	.suspend	= bcm5201_suspend,
+	.init		= bcm5221_init,
+	.setup_aneg	= genmii_setup_aneg,
+	.setup_forced	= genmii_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= genmii_read_link,
+};
+
+static struct mii_phy_def bcm5221_phy_def = {
+	.phy_id		= 0x004061e0,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5221",
+	.features	= MII_BASIC_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5221_phy_ops
+};
+
+/* Broadcom BCM 5400 */
+static struct mii_phy_ops bcm5400_phy_ops = {
+	.init		= bcm5400_init,
+	.suspend	= bcm5400_suspend,
+	.setup_aneg	= bcm54xx_setup_aneg,
+	.setup_forced	= bcm54xx_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= bcm54xx_read_link,
+};
+
+static struct mii_phy_def bcm5400_phy_def = {
+	.phy_id		= 0x00206040,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5400",
+	.features	= MII_GBIT_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5400_phy_ops
+};
+
+/* Broadcom BCM 5401 */
+static struct mii_phy_ops bcm5401_phy_ops = {
+	.init		= bcm5401_init,
+	.suspend	= bcm5401_suspend,
+	.setup_aneg	= bcm54xx_setup_aneg,
+	.setup_forced	= bcm54xx_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= bcm54xx_read_link,
+};
+
+static struct mii_phy_def bcm5401_phy_def = {
+	.phy_id		= 0x00206050,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5401",
+	.features	= MII_GBIT_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5401_phy_ops
+};
+
+/* Broadcom BCM 5411 */
+static struct mii_phy_ops bcm5411_phy_ops = {
+	.init		= bcm5411_init,
+	.suspend	= bcm5411_suspend,
+	.setup_aneg	= bcm54xx_setup_aneg,
+	.setup_forced	= bcm54xx_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= bcm54xx_read_link,
+};
+
+static struct mii_phy_def bcm5411_phy_def = {
+	.phy_id		= 0x00206070,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5411",
+	.features	= MII_GBIT_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5411_phy_ops
+};
+
+/* Broadcom BCM 5421 */
+static struct mii_phy_ops bcm5421_phy_ops = {
+	.init		= bcm5421_init,
+	.suspend	= bcm5411_suspend,
+	.setup_aneg	= bcm54xx_setup_aneg,
+	.setup_forced	= bcm54xx_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= bcm54xx_read_link,
+};
+
+static struct mii_phy_def bcm5421_phy_def = {
+	.phy_id		= 0x002060e0,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5421",
+	.features	= MII_GBIT_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5421_phy_ops
+};
+
+/* Broadcom BCM 5421 built-in K2 */
+static struct mii_phy_ops bcm5421k2_phy_ops = {
+	.init		= bcm5421k2_init,
+	.suspend	= bcm5411_suspend,
+	.setup_aneg	= bcm54xx_setup_aneg,
+	.setup_forced	= bcm54xx_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= bcm54xx_read_link,
+};
+
+static struct mii_phy_def bcm5421k2_phy_def = {
+	.phy_id		= 0x002062e0,
+	.phy_id_mask	= 0xfffffff0,
+	.name		= "BCM5421-K2",
+	.features	= MII_GBIT_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &bcm5421k2_phy_ops
+};
+
+/* Marvell 88E1101 (Apple seem to deal with 2 different revs,
+ * I masked out the 8 last bits to get both, but some specs
+ * would be useful here) --BenH.
+ */
+static struct mii_phy_ops marvell_phy_ops = {
+	.setup_aneg	= marvell_setup_aneg,
+	.setup_forced	= marvell_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= marvell_read_link
+};
+
+static struct mii_phy_def marvell_phy_def = {
+	.phy_id		= 0x01410c00,
+	.phy_id_mask	= 0xffffff00,
+	.name		= "Marvell 88E1101",
+	.features	= MII_GBIT_FEATURES,
+	.magic_aneg	= 1,
+	.ops		= &marvell_phy_ops
+};
+
+/* Generic implementation for most 10/100 PHYs */
+static struct mii_phy_ops generic_phy_ops = {
+	.setup_aneg	= genmii_setup_aneg,
+	.setup_forced	= genmii_setup_forced,
+	.poll_link	= genmii_poll_link,
+	.read_link	= genmii_read_link
+};
+
+static struct mii_phy_def genmii_phy_def = {
+	.phy_id		= 0x00000000,
+	.phy_id_mask	= 0x00000000,
+	.name		= "Generic MII",
+	.features	= MII_BASIC_FEATURES,
+	.magic_aneg	= 0,
+	.ops		= &generic_phy_ops
+};
+
+static struct mii_phy_def* mii_phy_table[] = {
+	&bcm5201_phy_def,
+	&bcm5221_phy_def,
+	&bcm5400_phy_def,
+	&bcm5401_phy_def,
+	&bcm5411_phy_def,
+	&bcm5421_phy_def,
+	&bcm5421k2_phy_def,
+	&marvell_phy_def,
+	&genmii_phy_def,
+	NULL
+};
+
+int mii_phy_probe(struct mii_phy *phy, int mii_id)
+{
+	int rc;
+	u32 id;
+	struct mii_phy_def* def;
+	int i;
+
+	/* We do not reset the mii_phy structure as the driver
+	 * may re-probe the PHY regulary
+	 */
+	phy->mii_id = mii_id;
+	
+	/* Take PHY out of isloate mode and reset it. */
+	rc = reset_one_mii_phy(phy, mii_id);
+	if (rc)
+		goto fail;
+
+	/* Read ID and find matching entry */	
+	id = (phy_read(phy, MII_PHYSID1) << 16 | phy_read(phy, MII_PHYSID2));
+	printk(KERN_DEBUG "PHY ID: %x, addr: %x\n", id, mii_id);
+	for (i=0; (def = mii_phy_table[i]) != NULL; i++)
+		if ((id & def->phy_id_mask) == def->phy_id)
+			break;
+	/* Should never be NULL (we have a generic entry), but... */
+	if (def == NULL)
+		goto fail;
+
+	phy->def = def;
+	
+	return 0;
+fail:
+	phy->speed = 0;
+	phy->duplex = 0;
+	phy->pause = 0;
+	phy->advertising = 0;
+	return -ENODEV;
+}
+
+EXPORT_SYMBOL(mii_phy_probe);
+MODULE_LICENSE("GPL");
+
diff -urN kernel-source-2.4.27/drivers/net/sungem_phy.h kernel-source-2.4.27-benh/drivers/net/sungem_phy.h
--- kernel-source-2.4.27/drivers/net/sungem_phy.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/net/sungem_phy.h	2004-09-01 20:56:27.035009112 +0200
@@ -0,0 +1,116 @@
+#ifndef __SUNGEM_PHY_H__
+#define __SUNGEM_PHY_H__
+
+struct mii_phy;
+
+/* Operations supported by any kind of PHY */
+struct mii_phy_ops
+{
+	int		(*init)(struct mii_phy *phy);
+	int		(*suspend)(struct mii_phy *phy, int wol_options);
+	int		(*setup_aneg)(struct mii_phy *phy, u32 advertise);
+	int		(*setup_forced)(struct mii_phy *phy, int speed, int fd);
+	int		(*poll_link)(struct mii_phy *phy);
+	int		(*read_link)(struct mii_phy *phy);
+};
+
+/* Structure used to statically define an mii/gii based PHY */
+struct mii_phy_def
+{
+	u32				phy_id;		/* Concatenated ID1 << 16 | ID2 */
+	u32				phy_id_mask;	/* Significant bits */
+	u32				features;	/* Ethtool SUPPORTED_* defines */
+	int				magic_aneg;	/* Autoneg does all speed test for us */
+	const char*			name;
+	const struct mii_phy_ops*	ops;
+};
+
+/* An instance of a PHY, partially borrowed from mii_if_info */
+struct mii_phy
+{
+	struct mii_phy_def*	def;
+	int			advertising;
+	int			mii_id;
+
+	/* 1: autoneg enabled, 0: disabled */
+	int			autoneg;
+
+	/* forced speed & duplex (no autoneg)
+	 * partner speed & duplex & pause (autoneg)
+	 */
+	int			speed;
+	int			duplex;
+	int			pause;
+
+	/* Provided by host chip */
+	struct net_device*	dev;
+	int (*mdio_read) (struct net_device *dev, int mii_id, int reg);
+	void (*mdio_write) (struct net_device *dev, int mii_id, int reg, int val);
+};
+
+/* Pass in a struct mii_phy with dev, mdio_read and mdio_write
+ * filled, the remaining fields will be filled on return
+ */
+extern int mii_phy_probe(struct mii_phy *phy, int mii_id);
+
+
+/* MII definitions missing from mii.h */
+
+#define BMCR_SPD2	0x0040		/* Gigabit enable (bcm54xx)	*/
+#define LPA_PAUSE	0x0400
+
+/* More PHY registers (model specific) */
+
+/* MII BCM5201 MULTIPHY interrupt register */
+#define MII_BCM5201_INTERRUPT			0x1A
+#define MII_BCM5201_INTERRUPT_INTENABLE		0x4000
+
+#define MII_BCM5201_AUXMODE2			0x1B
+#define MII_BCM5201_AUXMODE2_LOWPOWER		0x0008
+
+#define MII_BCM5201_MULTIPHY                    0x1E
+
+/* MII BCM5201 MULTIPHY register bits */
+#define MII_BCM5201_MULTIPHY_SERIALMODE         0x0002
+#define MII_BCM5201_MULTIPHY_SUPERISOLATE       0x0008
+
+/* MII BCM5221 Additional registers */
+#define MII_BCM5221_TEST			0x1f
+#define MII_BCM5221_TEST_ENABLE_SHADOWS		0x0080
+#define MII_BCM5221_SHDOW_AUX_STAT2		0x1b
+#define MII_BCM5221_SHDOW_AUX_STAT2_APD		0x0020
+#define MII_BCM5221_SHDOW_AUX_MODE4		0x1a
+#define MII_BCM5221_SHDOW_AUX_MODE4_CLKLOPWR	0x0004
+
+/* MII BCM5400 1000-BASET Control register */
+#define MII_BCM5400_GB_CONTROL			0x09
+#define MII_BCM5400_GB_CONTROL_FULLDUPLEXCAP	0x0200
+
+/* MII BCM5400 AUXCONTROL register */
+#define MII_BCM5400_AUXCONTROL                  0x18
+#define MII_BCM5400_AUXCONTROL_PWR10BASET       0x0004
+
+/* MII BCM5400 AUXSTATUS register */
+#define MII_BCM5400_AUXSTATUS                   0x19
+#define MII_BCM5400_AUXSTATUS_LINKMODE_MASK     0x0700
+#define MII_BCM5400_AUXSTATUS_LINKMODE_SHIFT    8  
+
+/* 1000BT control (Marvell & BCM54xx at least) */
+#define MII_1000BASETCONTROL			0x09
+#define MII_1000BASETCONTROL_FULLDUPLEXCAP	0x0200
+#define MII_1000BASETCONTROL_HALFDUPLEXCAP	0x0100
+
+/* Marvell 88E1011 PHY control */
+#define MII_M1011_PHY_SPEC_CONTROL		0x10
+#define MII_M1011_PHY_SPEC_CONTROL_MANUAL_MDIX	0x20
+#define MII_M1011_PHY_SPEC_CONTROL_AUTO_MDIX	0x40
+
+/* Marvell 88E1011 PHY status */
+#define MII_M1011_PHY_SPEC_STATUS		0x11
+#define MII_M1011_PHY_SPEC_STATUS_1000		0x8000
+#define MII_M1011_PHY_SPEC_STATUS_100		0x4000
+#define MII_M1011_PHY_SPEC_STATUS_SPD_MASK	0xc000
+#define MII_M1011_PHY_SPEC_STATUS_FULLDUPLEX	0x2000
+#define MII_M1011_PHY_SPEC_STATUS_RESOLVED	0x0800
+
+#endif /* __SUNGEM_PHY_H__ */
diff -urN kernel-source-2.4.27/drivers/net/tulip/tulip_core.c kernel-source-2.4.27-benh/drivers/net/tulip/tulip_core.c
--- kernel-source-2.4.27/drivers/net/tulip/tulip_core.c	2004-08-08 01:26:05.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/net/tulip/tulip_core.c	2004-09-01 20:56:27.191985248 +0200
@@ -477,6 +477,15 @@
 	} else
 		tulip_select_media(dev, 1);
 
+	/* check for Apple 100BaseTX card and disable loops */
+	if ((dev->dev_addr[0] == 0x00) &&
+	    (dev->dev_addr[1] == 0x05) &&
+	    (dev->dev_addr[2] == 0x02) &&
+	    (tp->chip_id == DC21140)) {
+		outl(0x10f, ioaddr + CSR12);
+		outl(0x03, ioaddr + CSR12);
+	}
+	
 	/* Start the chip's Tx to process setup frame. */
 	tulip_stop_rxtx(tp);
 	barrier();
diff -urN kernel-source-2.4.27/drivers/pci/pci.c kernel-source-2.4.27-benh/drivers/pci/pci.c
--- kernel-source-2.4.27/drivers/pci/pci.c	2004-08-08 01:26:05.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/pci/pci.c	2004-09-01 20:56:27.271973088 +0200
@@ -28,7 +28,7 @@
 #include <asm/page.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 
-#undef DEBUG
+#define DEBUG
 
 #ifdef DEBUG
 #define DBG(x...) printk(x)
@@ -1062,16 +1062,23 @@
 	unsigned int pos, reg, next;
 	u32 l, sz;
 	struct resource *res;
+	int is_kl = (dev->device == 0x22 && dev->vendor == 0x106b);
 
+	if (is_kl)
+		howmany = 1;
 	for(pos=0; pos<howmany; pos = next) {
 		next = pos+1;
 		res = &dev->resource[pos];
 		res->name = dev->name;
 		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
 		pci_read_config_dword(dev, reg, &l);
+		if (is_kl)
+			sz = 0x00080000;
+		else {
 		pci_write_config_dword(dev, reg, ~0);
 		pci_read_config_dword(dev, reg, &sz);
 		pci_write_config_dword(dev, reg, l);
+		}
 		if (!sz || sz == 0xffffffff)
 			continue;
 		if (l == 0xffffffff)
@@ -1312,7 +1319,7 @@
 		if (!pass)
 			return max;
 		pci_read_config_word(dev, PCI_COMMAND, &cr);
-		pci_write_config_word(dev, PCI_COMMAND, 0x0000);
+		//pci_write_config_word(dev, PCI_COMMAND, 0x0000);
 		pci_write_config_word(dev, PCI_STATUS, 0xffff);
 
 		child = pci_add_new_bus(bus, dev, ++max);
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/awacs_defs.h kernel-source-2.4.27-benh/drivers/sound/dmasound/awacs_defs.h
--- kernel-source-2.4.27/drivers/sound/dmasound/awacs_defs.h	2002-02-25 20:38:04.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/awacs_defs.h	2004-09-01 20:56:27.272972936 +0200
@@ -168,8 +168,9 @@
 
 #define RATE_LOW	1	/* HIGH = 48kHz, etc;  LOW = 44.1kHz, etc. */
 
-
+/*******************/
 /* Burgundy values */
+/*******************/
 
 #define MASK_ADDR_BURGUNDY_INPSEL21 (0x11 << 12)
 #define MASK_ADDR_BURGUNDY_INPSEL3 (0x12 << 12)
@@ -232,4 +233,19 @@
 #define DEF_BURGUNDY_ATTENLINEOUT (0xCC)
 #define DEF_BURGUNDY_ATTENHP (0xCC)
 
+/*********************/
+/* i2s layout values */
+/*********************/
+
+#define I2S_REG_INT_CTL			0x00
+#define I2S_REG_SERIAL_FORMAT		0x10
+#define I2S_REG_CODEC_MSG_OUT		0x20
+#define I2S_REG_CODEC_MSG_IN		0x30
+#define I2S_REG_FRAME_COUNT		0x40
+#define I2S_REG_FRAME_MATCH		0x50
+#define I2S_REG_DATAWORD_SIZES		0x60
+#define I2S_REG_PEAKLEVEL_SEL		0x70
+#define I2S_REG_PEAKLEVEL_IN0		0x80
+#define I2S_REG_PEAKLEVEL_IN1		0x90
+
 #endif /* _AWACS_DEFS_H_ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/Config.in kernel-source-2.4.27-benh/drivers/sound/dmasound/Config.in
--- kernel-source-2.4.27/drivers/sound/dmasound/Config.in	2002-02-25 20:38:04.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/Config.in	2004-09-01 20:56:27.350961080 +0200
@@ -27,13 +27,27 @@
 fi
 
 # the new dmasound_pmac driver needs access to the i2c bus
+# and nvram.
 if [ "$CONFIG_DMASOUND_PMAC" = "y" ] ; then
+   if [ "$CONFIG_I2C" != "y" ]; then
    define_tristate CONFIG_I2C y
+   fi
+   if [ "$CONFIG_I2C_KEYWEST" != "y" ]; then
    define_tristate CONFIG_I2C_KEYWEST y
+   fi
+   if [ "$CONFIG_NVRAM" != "y" -a "$CONFIG_NVRAM" != "m" ]; then
+      define_tristate CONFIG_NVRAM y
+   fi
 else
    if [ "$CONFIG_DMASOUND_PMAC" = "m" ] ; then
+      if [ "$CONFIG_I2C" != "y" -a "$CONFIG_I2C" != "m" ]; then
    define_tristate CONFIG_I2C m
+      fi
+      if [ "$CONFIG_I2C_KEYWEST" != "y" -a "$CONFIG_I2C_KEYWEST" != "m" ]; then
    define_tristate CONFIG_I2C_KEYWEST m
    fi
+      if [ "$CONFIG_NVRAM" != "y" -a "$CONFIG_NVRAM" != "m" ]; then
+         define_tristate CONFIG_NVRAM y
+      fi
+   fi
 fi
-
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/dmasound_awacs.c kernel-source-2.4.27-benh/drivers/sound/dmasound/dmasound_awacs.c
--- kernel-source-2.4.27/drivers/sound/dmasound/dmasound_awacs.c	2002-08-03 02:39:44.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/dmasound_awacs.c	2004-09-01 20:56:27.447946336 +0200
@@ -88,10 +88,14 @@
 
 #include "awacs_defs.h"
 #include "dmasound.h"
+#include "tas3001c.h"
+#include "tas3004.h"
+#include "tas_common.h"
 
 #define DMASOUND_AWACS_REVISION	0
 #define DMASOUND_AWACS_EDITION	7
 
+#define AWACS_SNAPPER   110	/* fake revision # for snapper */
 #define AWACS_BURGUNDY	100	/* fake revision # for burgundy */
 #define AWACS_TUMBLER    90	/* fake revision # for tumbler */
 #define AWACS_DACA	 80	/* fake revision # for daca (ibook) */
@@ -102,11 +106,13 @@
  */
 static int awacs_irq, awacs_tx_irq, awacs_rx_irq;
 static volatile struct awacs_regs *awacs;
+static volatile u32 *i2s;
 static volatile struct dbdma_regs *awacs_txdma, *awacs_rxdma;
 static int awacs_rate_index;
 static int awacs_subframe;
 static int awacs_spkr_vol;
 static struct device_node* awacs_node;
+static struct device_node* i2s_node;
 
 static char awacs_name[64];
 static int awacs_revision;
@@ -163,6 +169,8 @@
 static int cd_lev = 0x6363 ; /* 99 % */
 static int line_lev = 0 ;
 
+static int hdp_connected = 0;
+
 /*
  * Stuff for outputting a beep.  The values range from -327 to +327
  * so we can multiply by an amplitude in the range 0..100 to get a
@@ -293,19 +301,6 @@
 extern int daca_enter_sleep(void);
 extern int daca_leave_sleep(void);
 
-extern int tas_init(void);
-extern int tas_cleanup(void);
-extern int tumbler_set_volume(uint left_vol, uint right_vol);
-extern void tumbler_get_volume(uint * left_vol, uint  *right_vol);
-extern void tumbler_set_treble(int treble);
-extern void tumbler_get_treble(int *treble);
-extern void tumbler_set_bass(int bass);
-extern void tumbler_get_bass(int *bass);
-extern void tumbler_set_pcm_lvl(int pcm_lvl);
-extern void tumbler_get_pcm_lvl(int *pcm_lvl);
-extern int tumbler_enter_sleep(void);
-extern int tumbler_leave_sleep(void);
-
 #define TRY_LOCK()	\
 	if ((rc = down_interruptible(&dmasound_sem)) != 0)	\
 		return rc;
@@ -332,7 +327,7 @@
 }
 
 
-/*** AE - TUMBLER START *********************************************************/
+/*** AE - TUMBLER / SNAPPER START ************************************************/
 
 
 int gpio_audio_reset, gpio_audio_reset_pol;
@@ -394,17 +389,22 @@
 	return ((pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, gpio_addr, 0) & 0x02) !=0);
 }
 
+/*
+ * Headphone interrupt via GPIO (Tumbler, Snapper, DACA)
+ */
 static void
 headphone_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	if (read_audio_gpio(gpio_headphone_detect) == gpio_headphone_detect_pol) {
 		printk(KERN_INFO "Audio jack plugged, muting speakers.\n");
-		write_audio_gpio(gpio_amp_mute, gpio_amp_mute_pol);
 		write_audio_gpio(gpio_headphone_mute, !gpio_headphone_mute_pol);
+		write_audio_gpio(gpio_amp_mute, gpio_amp_mute_pol);
+		tas_output_device_change(sound_device_id,TAS_OUTPUT_HEADPHONES,0);
 	} else {
 		printk(KERN_INFO "Audio jack unplugged, enabling speakers.\n");
 		write_audio_gpio(gpio_amp_mute, !gpio_amp_mute_pol);
 		write_audio_gpio(gpio_headphone_mute, gpio_headphone_mute_pol);
+		tas_output_device_change(sound_device_id,TAS_OUTPUT_INTERNAL_SPKR,0);
 	}
 }
 
@@ -412,7 +412,7 @@
 /* Initialize tumbler */
 
 static int
-awacs_tumbler_init(void)
+tas_dmasound_init(void)
 {
 	setup_audio_gpio(
 		"audio-hw-reset",
@@ -469,15 +469,124 @@
 
 
 static int
-awacs_tumbler_cleanup(void)
+tas_dmasound_cleanup(void)
 {
 	if (gpio_headphone_irq)
 		free_irq(gpio_headphone_irq, 0);
 	return 0;
 }
 
+/* We don't support 48k yet */
+static int tas_freqs[1] = { 44100 } ;
+static int tas_freqs_ok[1] = { 1 } ;
 
-/*** AE - TUMBLER END *********************************************************/
+/* don't know what to do really - just have to leave it where
+ * OF left things
+*/
+
+static int
+tas_set_frame_rate(void)
+{
+	if (i2s) {
+		out_le32(i2s + (I2S_REG_SERIAL_FORMAT >> 2), 0x41190000);
+		out_le32(i2s + (I2S_REG_DATAWORD_SIZES >> 2), 0x02000200);
+	}
+	dmasound.hard.speed = 44100 ;
+	awacs_rate_index = 0 ;
+	return 44100 ;
+}
+
+static int
+tas_mixer_ioctl(u_int cmd, u_long arg)
+{
+	int data;
+	int rc;
+
+        rc=tas_device_ioctl(cmd, arg);
+        if (rc != -EINVAL) {
+        	return rc;
+        }
+
+        if ((cmd & ~0xff) == MIXER_WRITE(0) &&
+            tas_supported_mixers() & (1<<(cmd & 0xff))) {
+		rc = get_user(data, (int *)(arg));
+                if (rc<0) return rc;
+		tas_set_mixer_level(cmd & 0xff, data);
+		tas_get_mixer_level(cmd & 0xff, &data);
+		return ioctl_return2((int *)(arg), data);
+        }
+        if ((cmd & ~0xff) == MIXER_READ(0) &&
+            tas_supported_mixers() & (1<<(cmd & 0xff))) {
+		tas_get_mixer_level(cmd & 0xff, &data);
+		return ioctl_return2((int *)(arg), data);
+        }
+
+	switch(cmd) {
+	case SOUND_MIXER_READ_DEVMASK:
+		data = tas_supported_mixers() | SOUND_MASK_SPEAKER;
+		rc = IOCTL_OUT(arg, data);
+		break;
+	case SOUND_MIXER_READ_STEREODEVS:
+		data = tas_stereo_mixers();
+		rc = IOCTL_OUT(arg, data);
+		break;
+	case SOUND_MIXER_READ_CAPS:
+		rc = IOCTL_OUT(arg, 0);
+		break;
+	case SOUND_MIXER_READ_RECMASK:
+		data = 0;
+		rc = IOCTL_OUT(arg, data);
+		break;
+	case SOUND_MIXER_READ_RECSRC:
+		data = 0;
+		rc = IOCTL_OUT(arg, data);
+		break;
+	case SOUND_MIXER_WRITE_RECSRC:
+ 		IOCTL_IN(arg, data);
+		data =0;
+ 		rc = IOCTL_OUT(arg, data);
+ 		break;
+	case SOUND_MIXER_WRITE_SPEAKER:	/* really bell volume */
+ 		IOCTL_IN(arg, data);
+ 		beep_vol = data & 0xff;
+ 		/* fall through */
+	case SOUND_MIXER_READ_SPEAKER:
+		rc = IOCTL_OUT(arg, (beep_vol<<8) | beep_vol);
+ 		break;
+	case SOUND_MIXER_OUTMASK:
+	case SOUND_MIXER_OUTSRC:
+	default:
+		rc = -EINVAL;
+	}
+
+	return rc;
+}
+
+static void __init
+tas_init_frame_rates(unsigned int *prop, unsigned int l)
+{
+	int i ;
+	if (prop) {
+		for (i=0; i<1; i++)
+			tas_freqs_ok[i] = 0;
+		for (l /= sizeof(int); l > 0; --l) {
+			unsigned int r = *prop++;
+			/* Apple 'Fixed' format */
+			if (r >= 0x10000)
+				r >>= 16;
+			for (i = 0; i < 1; ++i) {
+				if (r == tas_freqs[i]) {
+					tas_freqs_ok[i] = 1;
+					break;
+				}
+			}
+		}
+	}
+	/* else we assume that all the rates are available */
+}
+
+
+/*** AE - TUMBLER / SNAPPER END ************************************************/
 
 
 
@@ -509,8 +618,10 @@
 
 static int __init PMacIrqInit(void)
 {
-	if (request_irq(awacs_irq, pmac_awacs_intr, 0, "Built-in Sound misc", 0)
-	    || request_irq(awacs_tx_irq, pmac_awacs_tx_intr, 0, "Built-in Sound out", 0)
+	if (awacs)
+		if (request_irq(awacs_irq, pmac_awacs_intr, 0, "Built-in Sound misc", 0))
+			return 0;
+	if (request_irq(awacs_tx_irq, pmac_awacs_tx_intr, 0, "Built-in Sound out", 0)
 	    || request_irq(awacs_rx_irq, pmac_awacs_rx_intr, 0, "Built-in Sound in", 0))
 		return 0;
 	return 1;
@@ -523,23 +634,28 @@
 	DBDMA_DO_STOP(awacs_txdma);
 	DBDMA_DO_STOP(awacs_rxdma);
 
+	if (awacs)
 	/* disable interrupts from awacs interface */
 	out_le32(&awacs->control, in_le32(&awacs->control) & 0xfff);
 
 	/* Switch off the sound clock */
 	pmac_call_feature(PMAC_FTR_SOUND_CHIP_ENABLE, awacs_node, 0, 0);
 	/* Make sure proper bits are set on pismo & tipb */
-	if (machine_is_compatible("PowerBook3,1") ||
-	    machine_is_compatible("PowerBook3,2")) {
+	if ((machine_is_compatible("PowerBook3,1") ||
+	    machine_is_compatible("PowerBook3,2")) && awacs) {
 		awacs_reg[1] |= MASK_PAROUT0 | MASK_PAROUT1;
 		awacs_write(MASK_ADDR1 | awacs_reg[1]);
 		wait_ms(200);
 	}
+	if (awacs)
 	free_irq(awacs_irq, 0);
 	free_irq(awacs_tx_irq, 0);
 	free_irq(awacs_rx_irq, 0);
-	/* all OF versions I've seen use this value */
+	
+	if (awacs)
 	iounmap((void *)awacs);
+	if (i2s)
+		iounmap((void *)i2s);
 	iounmap((void *)awacs_txdma);
 	iounmap((void *)awacs_rxdma);
 
@@ -555,7 +671,9 @@
 		kfree(beep_dbdma_cmd_space);
 	if (beep_buf) {
 		kfree(beep_buf);
+#ifdef CONFIG_VT
 		kd_mksound = orig_mksound;
+#endif		
 	}
 #ifdef CONFIG_PMAC_PBOOK
 	pmu_unregister_sleep_notifier(&awacs_sleep_notifier);
@@ -569,26 +687,16 @@
 	DBDMA_DO_STOP(awacs_txdma);
 }
 
-static int tumbler_freqs[2] = { 48000, 44100 } ;
-static int tumbler_freqs_ok[2] = { 1, 1 } ;
-
-/* don't know what to do really - just have to leave it where
- * OF left things
-*/
-
-static int tumbler_set_frame_rate(void)
-{
-	dmasound.hard.speed = 44100 ;
-	awacs_rate_index = 0 ;
-	return 44100 ;
-}
-
 /* don't know what to do really - just have to leave it where
  * OF left things
 */
 
 static int daca_set_frame_rate(void)
 {
+	if (i2s) {
+		out_le32(i2s + (I2S_REG_SERIAL_FORMAT >> 2), 0x41190000);
+		out_le32(i2s + (I2S_REG_DATAWORD_SIZES >> 2), 0x02000200);
+	}
 	dmasound.hard.speed = 44100 ;
 	awacs_rate_index = 0 ;
 	return 44100 ;
@@ -599,7 +707,8 @@
 };
 static int awacs_freqs_ok[8] = { 1, 1, 1, 1, 1, 1, 1, 1 };
 
-static int awacs_set_frame_rate(int desired, int catch_r)
+static int
+awacs_set_frame_rate(int desired, int catch_r)
 {
 	int tolerance, i = 8 ;
 	/*
@@ -623,13 +732,9 @@
 	return dmasound.hard.speed;
 }
 
-static int burgundy_frame_rates = 1 ;
-static int burgundy_set_frame_rate(void)
+static int
+burgundy_set_frame_rate(void)
 {
-#ifdef DEBUG_DMASOUND
-if (burgundy_frame_rates > 1)
-	printk("dmasound_pmac: warning Burgundy had more than one frame rate\n");
-#endif
 	awacs_rate_index = 0 ;
 	awacs_reg[1] = (awacs_reg[1] & ~MASK_SAMPLERATE) ;
 	/* XXX disable error interrupt on burgundy for now */
@@ -637,24 +742,24 @@
 	return 44100 ;
 }
 
-static int set_frame_rate(int desired, int catch_r)
+static int
+set_frame_rate(int desired, int catch_r)
 {
 	switch (awacs_revision) {
 		case AWACS_BURGUNDY:
-			dmasound.hard.speed =
-			  burgundy_set_frame_rate();
+			dmasound.hard.speed = burgundy_set_frame_rate();
 			break ;
 		case AWACS_TUMBLER:
-			dmasound.hard.speed =
-			  tumbler_set_frame_rate();
+		case AWACS_SNAPPER:
+			dmasound.hard.speed = tas_set_frame_rate();
 			break ;
 		case AWACS_DACA:
 			dmasound.hard.speed =
 			  daca_set_frame_rate();
 			break ;
 		default:
-			dmasound.hard.speed =
-			  awacs_set_frame_rate(desired, catch_r);
+			dmasound.hard.speed = awacs_set_frame_rate(desired,
+						catch_r);
 			break ;
 	}
 	return dmasound.hard.speed ;
@@ -704,10 +809,12 @@
 		dmasound.trans_write = &transAwacsExpand;
 	dmasound.trans_read = &transAwacsNormalRead;
 
+	if (awacs) {
 	if (hw_can_byteswap && (dmasound.hard.format == AFMT_S16_LE))
 		out_le32(&awacs->byteswap, BS_VAL);
 	else
 		out_le32(&awacs->byteswap, 0);
+	}
 
 	expand_bal = -dmasound.soft.speed;
 }
@@ -793,7 +900,20 @@
 
 static int PMacSetVolume(int volume)
 {
-	return awacs_volume_setter(volume, 2, MASK_AMUTE, 6);
+	printk(KERN_WARNING "Bogus call to PMacSetVolume !\n");
+	return 0;
+}
+
+static void awacs_setup_for_beep(int speed)
+{
+	out_le32(&awacs->control,
+		 (in_le32(&awacs->control) & ~0x1f00)
+		 | ((speed > 0 ? speed : awacs_rate_index) << 8));
+
+	if (hw_can_byteswap && (dmasound.hard.format == AFMT_S16_LE) && speed == -1)
+		out_le32(&awacs->byteswap, BS_VAL);
+	else
+		out_le32(&awacs->byteswap, 0);
 }
 
 static void __PMacPlay(void)
@@ -816,15 +936,8 @@
 		out_le32(&awacs_txdma->control, (RUN|PAUSE|FLUSH|WAKE) << 16);
 		while ( (in_le32(&awacs_txdma->status) & RUN) && count--)
 			udelay(1);
-		/* FIXME: check that this is OK for other chip sets */
-		out_le32(&awacs->control,
-			 (in_le32(&awacs->control) & ~0x1f00)
-			 | (awacs_rate_index << 8));
-
-		if (hw_can_byteswap && (dmasound.hard.format == AFMT_S16_LE))
-			out_le32(&awacs->byteswap, BS_VAL);
-		else
-			out_le32(&awacs->byteswap, 0);
+		if (awacs)
+			awacs_setup_for_beep(-1);
 		out_le32(&awacs_txdma->cmdptr,
 			 virt_to_bus(&(awacs_tx_cmds[next_frg])));
 
@@ -925,6 +1038,7 @@
 {
 	int i = write_sq.front;
 	int stat;
+	int i_nowrap = write_sq.front;
 	volatile struct dbdma_cmd *cp;
 	/* != 0 when we are dealing with a DEAD xfer */
 	static int emergency_in_use = 0 ;
@@ -981,6 +1095,7 @@
 			emergency_in_use = 0 ; /* done that */
 		--write_sq.count;
 		--write_sq.active;
+		i_nowrap++;
 		if (++i >= write_sq.max_count)
 			i = 0;
 	}
@@ -993,7 +1108,7 @@
 	}
 
 	/* if we used some data up then wake the writer to supply some more*/
-	if (i != write_sq.front)
+	if (i_nowrap != write_sq.front)
 		WAKE_UP(write_sq.action_queue);
 	write_sq.front = i;
 
@@ -1090,9 +1205,26 @@
 pmac_awacs_intr(int irq, void *devid, struct pt_regs *regs)
 {
 	int ctrl = in_le32(&awacs->control);
+	int status = in_le32(&awacs->codec_stat);
+	int r1;
 
 	if (ctrl & MASK_PORTCHG) {
-		/* do something when headphone is plugged/unplugged? */
+		/* tested on Screamer, should work on others too */
+		if (awacs_revision == AWACS_SCREAMER) {
+			if (((status & MASK_HDPCONN) >> 3) && (hdp_connected == 0)) {
+				hdp_connected = 1;
+				
+				r1 = awacs_reg[1] | MASK_SPKMUTE;
+				awacs_reg[1] = r1;
+				awacs_write(r1 | MASK_ADDR_MUTE);
+			} else if (((status & MASK_HDPCONN) >> 3 == 0) && (hdp_connected == 1)) {
+				hdp_connected = 0;
+				
+				r1 = awacs_reg[1] & ~MASK_SPKMUTE;
+				awacs_reg[1] = r1;
+				awacs_write(r1 | MASK_ADDR_MUTE);
+			}
+		}
 	}
 	if (ctrl & MASK_CNTLERR) {
 		int err = (in_le32(&awacs->codec_stat) & MASK_ERRCODE) >> 16;
@@ -1108,7 +1240,7 @@
 awacs_write(int val)
 {
 	int count = 300 ;
-	if (awacs_revision >= AWACS_DACA)
+	if (awacs_revision >= AWACS_DACA || !awacs)
 		return ;
 
 	while ((in_le32(&awacs->codec_ctrl) & MASK_NEWECMD) && count--)
@@ -1131,14 +1263,8 @@
 		out_le32(&awacs_txdma->control, (RUN|PAUSE|FLUSH|WAKE) << 16);
 		while ((in_le32(&awacs_txdma->status) & RUN) && count--)
 			udelay(1);
-		/* FIXME: check this is OK for DACA, Tumbler */
-		out_le32(&awacs->control,
-			 (in_le32(&awacs->control) & ~0x1f00)
-			 | (awacs_rate_index << 8));
-		if (hw_can_byteswap && (dmasound.hard.format == AFMT_S16_LE))
-			out_le32(&awacs->byteswap, BS_VAL);
-		else
-			out_le32(&awacs->byteswap, 0);
+		if (awacs)
+			awacs_setup_for_beep(-1);
 		beep_playing = 0;
 	}
 	restore_flags(flags);
@@ -1233,11 +1359,8 @@
 		out_le32(&awacs_txdma->control, (RUN|WAKE|FLUSH|PAUSE) << 16);
 		while ((in_le32(&awacs_txdma->status) & RUN) && count--)
 			udelay(1); /* timeout > 2 samples at lowest rate*/
-		/* FIXME: check this is OK on DACA, Tumbler */
-		out_le32(&awacs->control,
-			 (in_le32(&awacs->control) & ~0x1f00)
-			 | (beep_speed << 8));
-		out_le32(&awacs->byteswap, 0); /* force BE */
+		if (awacs)
+			awacs_setup_for_beep(beep_speed);
 		out_le32(&awacs_txdma->cmdptr, virt_to_bus(beep_dbdma_cmd));
 		(void)in_le32(&awacs_txdma->status);
 		out_le32(&awacs_txdma->control, RUN | (RUN << 16));
@@ -1263,11 +1386,13 @@
 		awacs_write(awacs_reg[1] + MASK_ADDR1);
 		awacs_write(awacs_reg[7] + MASK_ADDR7);
 	}
+	if (awacs) {
 	if (hw_can_byteswap && (dmasound.hard.format == AFMT_S16_LE))
 		out_le32(&awacs->byteswap, BS_VAL);
 	else
 		out_le32(&awacs->byteswap, 0);
 }
+}
 
 #ifdef CONFIG_PMAC_PBOOK
 /*
@@ -1293,9 +1418,18 @@
 		/* stop rx - if going - a bit of a daft user... but */
 		out_le32(&awacs_rxdma->control, (RUN|WAKE|FLUSH << 16));
 		/* deny interrupts */
+		if (awacs)
+			disable_irq(awacs_irq);
+		disable_irq(awacs_tx_irq);
+		disable_irq(awacs_rx_irq);
+		/* Chip specific sleep code */
 		switch (awacs_revision) {
 			case AWACS_TUMBLER:
-				tumbler_enter_sleep(); /* Stub for now */
+			case AWACS_SNAPPER:
+				write_audio_gpio(gpio_headphone_mute, gpio_headphone_mute_pol);
+				write_audio_gpio(gpio_amp_mute, gpio_amp_mute_pol);
+				tas_enter_sleep();
+				write_audio_gpio(gpio_audio_reset, gpio_audio_reset_pol);
 				break ;
 			case AWACS_DACA:
 				daca_enter_sleep();
@@ -1308,17 +1442,14 @@
 				out_le32(&awacs->control, 0x11) ;
 				break ;
 		}
-		disable_irq(awacs_irq);
-		disable_irq(awacs_tx_irq);
-		disable_irq(awacs_rx_irq);
 		/* Disable sound clock */
 		pmac_call_feature(PMAC_FTR_SOUND_CHIP_ENABLE, awacs_node, 0, 0);
 		/* According to Darwin, we do that after turning off the sound
 		 * chip clock. All this will have to be cleaned up once we properly
 		 * parse the OF sound-objects
 		 */
-		if (machine_is_compatible("PowerBook3,1") ||
-		    machine_is_compatible("PowerBook3,2")) {
+		if ((machine_is_compatible("PowerBook3,1") ||
+		    machine_is_compatible("PowerBook3,2")) && awacs) {
 			awacs_reg[1] |= MASK_PAROUT0 | MASK_PAROUT1;
 			awacs_write(MASK_ADDR1 | awacs_reg[1]);
 			wait_ms(200);
@@ -1327,8 +1458,8 @@
 	case PBOOK_WAKE:
 		/* Enable sound clock */
 		pmac_call_feature(PMAC_FTR_SOUND_CHIP_ENABLE, awacs_node, 0, 1);
-		if (machine_is_compatible("PowerBook3,1") ||
-		    machine_is_compatible("PowerBook3,2")) {
+		if ((machine_is_compatible("PowerBook3,1") ||
+		    machine_is_compatible("PowerBook3,2")) && awacs) {
 			wait_ms(100);
 			awacs_reg[1] &= ~(MASK_PAROUT0 | MASK_PAROUT1);
 			awacs_write(MASK_ADDR1 | awacs_reg[1]);
@@ -1338,8 +1469,15 @@
  		/* restore settings */
 		switch (awacs_revision) {
 			case AWACS_TUMBLER:
+			case AWACS_SNAPPER:
+				write_audio_gpio(gpio_headphone_mute, gpio_headphone_mute_pol);
+				write_audio_gpio(gpio_amp_mute, gpio_amp_mute_pol);
+				write_audio_gpio(gpio_audio_reset, gpio_audio_reset_pol);
+				wait_ms(100);
+				write_audio_gpio(gpio_audio_reset, !gpio_audio_reset_pol);
+				wait_ms(150);
+				tas_leave_sleep(); /* Stub for now */
 				headphone_intr(0,0,0);
-				tumbler_leave_sleep(); /* Stub for now */
 				break;
 			case AWACS_DACA:
 				wait_ms(10); /* Check this !!! */
@@ -1354,17 +1492,20 @@
 				break ;
 		}
 		/* Recalibrate chip */
-		if (awacs_revision == AWACS_SCREAMER)
+		if (awacs_revision == AWACS_SCREAMER && awacs)
 			awacs_recalibrate();
 		/* Make sure dma is stopped */
 		PMacSilence();
+		if (awacs)
 		enable_irq(awacs_irq);
 		enable_irq(awacs_tx_irq);
  		enable_irq(awacs_rx_irq);
+ 		if (awacs) {
  		/* OK, allow ints back again */
  		out_le32(&awacs->control, MASK_IEPC
  		 	| (awacs_rate_index << 8) | 0x11
  			 | (awacs_revision < AWACS_DACA ? MASK_IEE: 0));
+ 		}
  		if (macio_base && is_pbook_g3) {
 			/* FIXME: should restore the setup we had...*/
 			out_8(macio_base + 0x37, 3);
@@ -1952,7 +2093,7 @@
 	case SOUND_MIXER_READ_SPEAKER:
 		data = awacs_burgundy_rcb(MASK_ADDR_BURGUNDY_ATTENSPEAKER);
 		data = (((data & 0xf)*100)/16) + ((((data>>4)*100)/16)<<8);
-		rc = IOCTL_OUT(arg, ~data);
+		rc = IOCTL_OUT(arg, (~data) & 0x0000ffff);
 		break;
 	case SOUND_MIXER_WRITE_ALTPCM:	/* really bell volume */
 		IOCTL_IN(arg, data);
@@ -2007,89 +2148,6 @@
 	return rc;
 }
 
-static int tumbler_mixer_ioctl(u_int cmd, u_long arg)
-{
-	int data;
-	int rc;
-
-	/* We are, we are, we are... Tumbler (and very dumb) */
-	/* Ok, we're not THAT dumb anymore, but still pretty dumb :-) */
-
-	switch(cmd) {
-	case SOUND_MIXER_READ_DEVMASK:
-		data =  SOUND_MASK_VOLUME | SOUND_MASK_ALTPCM |
-			SOUND_MASK_BASS | SOUND_MASK_TREBLE |
-			SOUND_MASK_PCM;
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_READ_RECMASK:
-		data = 0;
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_READ_RECSRC:
-		data = 0;
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_WRITE_RECSRC:
-		IOCTL_IN(arg, data);
-		data =0;
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_READ_STEREODEVS:
-		data = SOUND_MASK_VOLUME | SOUND_MASK_PCM;
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_READ_CAPS:
-		rc = IOCTL_OUT(arg, 0);
-		break;
-	case SOUND_MIXER_WRITE_BASS:
-		IOCTL_IN(arg, data);
-		tumbler_set_bass(data);
-		/* Fall through */
-	case SOUND_MIXER_READ_BASS:
-		tumbler_get_bass(&data);
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_WRITE_TREBLE:
-		IOCTL_IN(arg, data);
-		tumbler_set_treble(data);
-		/* Fall through */
-	case SOUND_MIXER_READ_TREBLE:
-		tumbler_get_treble(&data);
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_WRITE_PCM:
-		IOCTL_IN(arg, data);
-		tumbler_set_pcm_lvl(data);
-		/* Fall through */
-	case SOUND_MIXER_READ_PCM:
-		tumbler_get_pcm_lvl(&data);
-		IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_WRITE_VOLUME:
-		IOCTL_IN(arg, data);
-		tumbler_set_volume(data, data);
-		/* Fall through */
-	case SOUND_MIXER_READ_VOLUME:
-		tumbler_get_volume(& data, &data);
-		rc = IOCTL_OUT(arg, data);
-		break;
-	case SOUND_MIXER_WRITE_ALTPCM:	/* really bell volume */
-		IOCTL_IN(arg, data);
-		beep_vol = data & 0xff;
-		/* fall through */
-	case SOUND_MIXER_READ_ALTPCM:
-		rc = IOCTL_OUT(arg, beep_vol);
-		break;
-	case SOUND_MIXER_OUTMASK:
-	case SOUND_MIXER_OUTSRC:
-	default:
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
 static int daca_mixer_ioctl(u_int cmd, u_long arg)
 {
 	int data;
@@ -2154,7 +2212,8 @@
 			rc = daca_mixer_ioctl(cmd, arg);
 			break;
 		case AWACS_TUMBLER:
-			rc = tumbler_mixer_ioctl(cmd, arg);
+		case AWACS_SNAPPER:
+			rc = tas_mixer_ioctl(cmd, arg);
 			break ;
 		default: /* ;-)) */
 			rc = awacs_mixer_ioctl(cmd, arg);
@@ -2171,7 +2230,9 @@
 		case AWACS_TUMBLER:
 		  printk("AE-Init tumbler mixer\n");
 		  break ;
-		  
+		case AWACS_SNAPPER:
+		  printk("AE-Init snapper mixer\n");
+		  break ;
 		case AWACS_DACA:
 		case AWACS_BURGUNDY:
 			break ;	/* don't know yet */
@@ -2362,12 +2423,12 @@
 			len += sprintf(b,"44100 ") ;
 			break ;
 		case AWACS_TUMBLER:
-			for (i=0; i<2; i++){
-				if (tumbler_freqs_ok[i])
-					len += sprintf(b+len,"%d ", tumbler_freqs[i]) ;
+		case AWACS_SNAPPER:
+			for (i=0; i<1; i++){
+				if (tas_freqs_ok[i])
+					len += sprintf(b+len,"%d ", tas_freqs[i]) ;
 			}
 			break ;
-
 		case AWACS_AWACS:
 		case AWACS_SCREAMER:
 		default:
@@ -2469,8 +2530,8 @@
   code that looks for chip properties knows how to go about it.
 */
 
-static struct device_node
-__init *get_snd_io_node(void)
+static struct device_node* __init
+get_snd_io_node(void)
 {
 	struct device_node *np = NULL;
 
@@ -2491,7 +2552,7 @@
 	 * this seems to be what iBooks (& Tumbler) have.
 	 */
 	if (np == NULL)
-		np = find_devices("i2s-a");
+		np = i2s_node = find_devices("i2s-a");
 
 	/* if we didn't find this - perhaps we are on an early model
 	 * which _only_ has an 'awacs' node
@@ -2511,8 +2572,8 @@
    we have to deduce the info other ways for these.
 */
 
-static struct device_node
-__init *get_snd_info_node(struct device_node *io)
+static struct device_node* __init
+get_snd_info_node(struct device_node *io)
 {
 	struct device_node *info;
 
@@ -2526,8 +2587,8 @@
 /* Find out what type of codec we have.
 */
 
-static int
-__init get_codec_type(struct device_node *info)
+static int __init
+get_codec_type(struct device_node *info)
 {
 	/* already set if pre-davbus model and info will be NULL */
 	int codec = awacs_revision ;
@@ -2544,14 +2605,16 @@
 			codec = AWACS_DACA;
 		if (device_is_compatible(info, "tumbler"))
 			codec = AWACS_TUMBLER;
+		if (device_is_compatible(info, "snapper"))
+			codec = AWACS_SNAPPER;
 	}
 	return codec ;
 }
 
 /* find out what type, if any, of expansion card we have
 */
-static void
-__init get_expansion_type(void)
+static void __init
+get_expansion_type(void)
 {
 	if (find_devices("perch") != NULL)
 		has_perch = 1;
@@ -2569,8 +2632,8 @@
  *       Set dmasound.mach.max_dsp_rate on the basis of these routines.
 */
 
-static void
-__init init_awacs_frame_rates(unsigned int *prop, unsigned int l)
+static void __init
+awacs_init_frame_rates(unsigned int *prop, unsigned int l)
 {
 	int i ;
 	if (prop) {
@@ -2592,31 +2655,8 @@
 	/* else we assume that all the rates are available */
 }
 
-static void
-__init init_tumbler_frame_rates(unsigned int *prop, unsigned int l)
-{
-	int i ;
-	if (prop) {
-		for (i=0; i<2; i++)
-			tumbler_freqs_ok[i] = 0;
-		for (l /= sizeof(int); l > 0; --l) {
-			unsigned int r = *prop++;
-			/* Apple 'Fixed' format */
-			if (r >= 0x10000)
-				r >>= 16;
-			for (i = 0; i < 2; ++i) {
-				if (r == tumbler_freqs[i]) {
-					tumbler_freqs_ok[i] = 1;
-					break;
-				}
-			}
-		}
-	}
-	/* else we assume that all the rates are available */
-}
-
-static void
-__init init_burgundy_frame_rates(unsigned int *prop, unsigned int l)
+static void __init
+burgundy_init_frame_rates(unsigned int *prop, unsigned int l)
 {
 	int temp[9] ;
 	int i = 0 ;
@@ -2641,8 +2681,8 @@
 #endif
 }
 
-static void
-__init init_daca_frame_rates(unsigned int *prop, unsigned int l)
+static void __init
+daca_init_frame_rates(unsigned int *prop, unsigned int l)
 {
 	int temp[9] ;
 	int i = 0 ;
@@ -2668,21 +2708,22 @@
 #endif
 }
 
-static void
-__init init_frame_rates(unsigned int *prop, unsigned int l)
+static void __init
+init_frame_rates(unsigned int *prop, unsigned int l)
 {
 	switch (awacs_revision){
 		case AWACS_TUMBLER:
-			init_tumbler_frame_rates(prop, l);
+		case AWACS_SNAPPER:
+			tas_init_frame_rates(prop, l);
 			break ;
 		case AWACS_DACA:
-			init_daca_frame_rates(prop, l);
+			daca_init_frame_rates(prop, l);
 			break ;
 		case AWACS_BURGUNDY:
-			init_burgundy_frame_rates(prop, l);
+			burgundy_init_frame_rates(prop, l);
 			break ;
-		default: /* ;-))) */
-			init_awacs_frame_rates(prop, l);
+		default:
+			awacs_init_frame_rates(prop, l);
 			break ;
 	}
 }
@@ -2690,11 +2731,11 @@
 /* find things/machines that can't do mac-io byteswap
 */
 
-static void
-__init set_hw_byteswap(struct device_node *io)
+static void __init
+set_hw_byteswap(struct device_node *io)
 {
 	struct device_node *mio ;
-	unsigned int *p, kl = 0 ;
+	unsigned int kl = 0 ;
 
 	/* if seems that Keylargo can't byte-swap  */
 
@@ -2741,9 +2782,11 @@
 		if( beep_dbdma_cmd_space ) kfree(beep_dbdma_cmd_space) ;
 		return -ENOMEM ;
 	}
+#ifdef CONFIG_VT
 	/* OK, we should be safe to claim the mksound vector now */
 	orig_mksound = kd_mksound;
 	kd_mksound = awacs_mksound;
+#endif
 	return 0 ;
 }
 
@@ -2839,6 +2882,9 @@
 	}
 
 	/* all OF versions I've seen use this value */
+	if (i2s_node)
+		i2s = (u32 *)ioremap(io->addrs[0].address, 0x1000);
+	else
 	awacs = (volatile struct awacs_regs *)
 		ioremap(io->addrs[0].address, 0x1000);
 	awacs_txdma = (volatile struct dbdma_regs *)
@@ -2846,16 +2892,16 @@
 	awacs_rxdma = (volatile struct dbdma_regs *)
 		ioremap(io->addrs[2].address, 0x100);
 
-#ifdef CONFIG_PMAC_PBOOK
 	/* first of all make sure that the chip is powered up....*/
 	pmac_call_feature(PMAC_FTR_SOUND_CHIP_ENABLE, io, 0, 1);
-	if (awacs_revision == AWACS_SCREAMER)
+	if (awacs_revision == AWACS_SCREAMER && awacs)
 		awacs_recalibrate();
-#endif
+
 	awacs_irq = io->intrs[0].line;
 	awacs_tx_irq = io->intrs[1].line;
 	awacs_rx_irq = io->intrs[2].line;
 
+	/* Hack for legacy crap that will be killed someday */
 	awacs_node = io;
 
 	/* if we have an awacs or screamer - probe the chip to make
@@ -2907,6 +2953,7 @@
 		init_frame_rates(prop, l) ;
 	}
 	
+	if (awacs)
 	out_le32(&awacs->control, 0x11); /* set everything quiesent */
 
 	set_hw_byteswap(io) ; /* figure out if the h/w can do it */
@@ -2942,8 +2989,19 @@
 #ifdef CONFIG_KMOD
 			request_module("i2c-keywest");
 #endif /* CONFIG_KMOD */	
-			awacs_tumbler_init();
-			tas_init();
+                        tas_register_driver(&tas3001c_hooks);
+			tas_init(I2C_DRIVERID_TAS3001C, I2C_DRIVERNAME_TAS3001C);
+			tas_dmasound_init();
+			tas_post_init();
+			break ;
+		case AWACS_SNAPPER:
+#ifdef CONFIG_KMOD
+			request_module("i2c-keywest");
+#endif /* CONFIG_KMOD */	
+                        tas_register_driver(&tas3004_hooks);
+			tas_init(I2C_DRIVERID_TAS3004,I2C_DRIVERNAME_TAS3004);
+			tas_dmasound_init();
+			tas_post_init();
 			break ;
 		case AWACS_DACA:
 #ifdef CONFIG_KMOD
@@ -3028,11 +3086,15 @@
 		dmasound.mach.hardware_afmts = AFMT_S16_BE ;
 
 	/* shut out chips that do output only.
-	   may need to extend this to machines which have no inputs - even tho'
-	   they use screamer - IIRC one of the powerbooks is like this.
+	 * may need to extend this to machines which have no inputs - even tho'
+	 * they use screamer - IIRC one of the powerbooks is like this.
+	 *
+	 * FIXME: Actually, some TUMBLER and SNAPPER do have inputs...  
 	*/
 
-	if (awacs_revision != AWACS_TUMBLER && awacs_revision != AWACS_DACA) {
+	if (awacs_revision != AWACS_TUMBLER &&
+            awacs_revision != AWACS_SNAPPER &&
+            awacs_revision != AWACS_DACA) {
 		dmasound.mach.capabilities = DSP_CAP_DUPLEX ;
 		dmasound.mach.record = PMacRecord ;
 	}
@@ -3050,6 +3112,9 @@
 		case AWACS_TUMBLER:
 			sprintf(awacs_name, "PowerMac Tumbler ") ;
 			break ;
+		case AWACS_SNAPPER:
+			sprintf(awacs_name, "PowerMac Snapper ") ;
+			break ;
 		case AWACS_SCREAMER:
 			sprintf(awacs_name, "PowerMac Screamer ") ;
 			break ;
@@ -3066,7 +3131,8 @@
 {
 	switch (awacs_revision) {
 		case AWACS_TUMBLER:
-			awacs_tumbler_cleanup();
+		case AWACS_SNAPPER:
+			tas_dmasound_cleanup();
 			tas_cleanup();
 			break ;
 		case AWACS_DACA:
@@ -3081,3 +3147,10 @@
 
 module_init(dmasound_awacs_init);
 module_exit(dmasound_awacs_cleanup);
+/*
+ * Local Variables:
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/Makefile kernel-source-2.4.27-benh/drivers/sound/dmasound/Makefile
--- kernel-source-2.4.27/drivers/sound/dmasound/Makefile	2002-02-25 20:38:04.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/Makefile	2004-09-01 20:56:27.449946032 +0200
@@ -13,7 +13,8 @@
 
 list-multi := dmasound_pmac.o
 
-dmasound_pmac-objs := dmasound_awacs.o trans_16.o tas3001c.o dac3550a.o
+dmasound_pmac-objs := dmasound_awacs.o trans_16.o dac3550a.o tas_common.o \
+			tas3001c.o tas3001c_tables.o tas3004.o tas3004_tables.o
 
 obj-$(CONFIG_DMASOUND)        += dmasound_core.o
 obj-$(CONFIG_DMASOUND_ATARI)  += dmasound_atari.o
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas3001c.c kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3001c.c
--- kernel-source-2.4.27/drivers/sound/dmasound/tas3001c.c	2002-02-25 20:38:05.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3001c.c	2004-09-01 20:56:27.544931592 +0200
@@ -45,403 +45,854 @@
 #include <linux/types.h>
 #include <linux/i2c.h>
 #include <linux/init.h>
+#include <linux/soundcard.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
 #include <asm/io.h>
 #include <asm/prom.h>
 
 #include "dmasound.h"
+#include "tas_common.h"
 #include "tas3001c.h"
 
-#define I2C_DRIVERID_TAS (0xFEBA)
+#include "tas_ioctl.h"
 
-#define TAS_VERSION	"0.3"
-#define TAS_DATE	"20011214"
+#define TAS3001C_BIQUAD_FILTER_COUNT  6
+#define TAS3001C_BIQUAD_CHANNEL_COUNT 2
 
-#define TAS_SETTING_MAX	100
+#define VOL_DEFAULT	(100 * 4 / 5)
+#define INPUT_DEFAULT	(100 * 4 / 5)
+#define BASS_DEFAULT	(100 / 2)
+#define TREBLE_DEFAULT	(100 / 2)
+
+struct tas3001c_data_t {
+	struct tas_data_t super;
+	int device_id;
+	int output_id;
+	int speaker_id;
+	struct tas_drce_t drce_state;
+};
 
-#define VOL_DEFAULT	(((((TAS_SETTING_MAX*4)/5)<<0)<<8) | (((TAS_SETTING_MAX*4)/5)<<0))
-#define INPUT_DEFAULT	(((TAS_SETTING_MAX*4)/5)<<0)
-#define BASS_DEFAULT	((TAS_SETTING_MAX/2)<<0)
-#define TREBLE_DEFAULT	((TAS_SETTING_MAX/2)<<0)
 
-static struct i2c_client * tumbler_client = NULL;
+static const union tas_biquad_t
+tas3001c_eq_unity={
+	buf: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 }
+};
 
-int tumbler_enter_sleep(void);
-int tumbler_leave_sleep(void);
 
-static int tas_attach_adapter(struct i2c_adapter *adapter);
-static int tas_detect_client(struct i2c_adapter *adapter, int address);
-static int tas_detach_client(struct i2c_client *client);
+static inline unsigned char db_to_regval(short db) {
+	int r=0;
 
-/* Unique ID allocation */
-static int tas_id;
-static int tas_initialized;
+	r=(db+0x59a0) / 0x60;
 
-static struct device_node* tas_node;
-static u8 tas_i2c_address = 0x34;
+	if (r < 0x91) return 0x91;
+	if (r > 0xef) return 0xef;
+	return r;
+}
 
-struct tas_data_t {
-	uint left_vol;		/* left volume */
-	uint right_vol;		/* right volume */
-	uint treble;		/* treble */
-	uint bass;		/* bass */
-	uint pcm_level;		/* pcm level */
-};
+static inline short quantize_db(short db) {
+	return db_to_regval(db) * 0x60 - 0x59a0;
+}
 
-struct i2c_driver tas_driver = {  
-	name:		"TAS3001C driver  V 0.3",
-	id:		I2C_DRIVERID_TAS,
-	flags:		I2C_DF_NOTIFY,
-	attach_adapter:	&tas_attach_adapter,
-	detach_client:	&tas_detach_client,
-	command:	NULL,
-	inc_use:	NULL, /* &tas_inc_use, */
-	dec_use:	NULL  /* &tas_dev_use  */
-};
 
-int
-tumbler_get_volume(uint * left_vol, uint  *right_vol)
+static inline int
+register_width(enum tas3001c_reg_t r)
 {
-	struct tas_data_t *data;
+	switch(r) {
+	case TAS3001C_REG_MCR:
+ 	case TAS3001C_REG_TREBLE:
+	case TAS3001C_REG_BASS:
+		return 1;
 
-	if (!tumbler_client)
-		return -1;
+	case TAS3001C_REG_DRC:
+		return 2;
+
+	case TAS3001C_REG_MIXER1:
+	case TAS3001C_REG_MIXER2:
+		return 3;
 
-	data = (struct tas_data_t *) (tumbler_client->data);
-	*left_vol = data->left_vol;
-	*right_vol = data->right_vol;
+	case TAS3001C_REG_VOLUME:
+		return 6;
+
+	case TAS3001C_REG_LEFT_BIQUAD0:
+	case TAS3001C_REG_LEFT_BIQUAD1:
+	case TAS3001C_REG_LEFT_BIQUAD2:
+	case TAS3001C_REG_LEFT_BIQUAD3:
+	case TAS3001C_REG_LEFT_BIQUAD4:
+	case TAS3001C_REG_LEFT_BIQUAD5:
+	case TAS3001C_REG_LEFT_BIQUAD6:
 	
+	case TAS3001C_REG_RIGHT_BIQUAD0:
+	case TAS3001C_REG_RIGHT_BIQUAD1:
+	case TAS3001C_REG_RIGHT_BIQUAD2:
+	case TAS3001C_REG_RIGHT_BIQUAD3:
+	case TAS3001C_REG_RIGHT_BIQUAD4:
+	case TAS3001C_REG_RIGHT_BIQUAD5:
+	case TAS3001C_REG_RIGHT_BIQUAD6:
+		return 15;
+
+	default:
 	return 0;
 }
+}
 
-int
-tumbler_set_register(uint reg, uint size, char *block)
-{
-	if (i2c_smbus_write_block_data(tumbler_client, reg, size, block) < 0) {
-		printk("tas3001c: I2C write failed \n");  
-		return -1; 
+static int
+tas3001c_write_register(	struct tas3001c_data_t *self,
+				enum tas3001c_reg_t reg_num,
+				char *data,
+				uint write_mode)
+{
+	if (reg_num==TAS3001C_REG_MCR ||
+	    reg_num==TAS3001C_REG_BASS ||
+	    reg_num==TAS3001C_REG_TREBLE) {
+		return tas_write_byte_register(&self->super,
+					       (uint)reg_num,
+					       *data,
+					       write_mode);
+	} else {
+		return tas_write_register(&self->super,
+					  (uint)reg_num,
+					  register_width(reg_num),
+					  data,
+					  write_mode);
 	}
-	return 0;
 }
 
-int
-tumbler_get_pcm_lvl(uint *pcm_lvl)
+static int
+tas3001c_sync_register(	struct tas3001c_data_t *self,
+			enum tas3001c_reg_t reg_num)
 {
-	struct tas_data_t *data;
-
-	if (!tumbler_client)
-		return -1;
+	if (reg_num==TAS3001C_REG_MCR ||
+	    reg_num==TAS3001C_REG_BASS ||
+	    reg_num==TAS3001C_REG_TREBLE) {
+		return tas_sync_byte_register(&self->super,
+					      (uint)reg_num,
+					      register_width(reg_num));
+	} else {
+		return tas_sync_register(&self->super,
+					 (uint)reg_num,
+					 register_width(reg_num));
+	}
+}
 
-	data = (struct tas_data_t *) (tumbler_client->data);
-	*pcm_lvl = data->pcm_level;
+static int
+tas3001c_read_register(	struct tas3001c_data_t *self,
+			enum tas3001c_reg_t reg_num,
+			char *data,
+			uint write_mode)
+{
+	return tas_read_register(&self->super,
+				 (uint)reg_num,
+				 register_width(reg_num),
+				 data);
+}
+
+static inline int
+tas3001c_fast_load(struct tas3001c_data_t *self, int fast)
+{
+	if (fast)
+		self->super.shadow[TAS3001C_REG_MCR][0] |= 0x80;
+	else
+		self->super.shadow[TAS3001C_REG_MCR][0] &= 0x7f;
+	return tas3001c_sync_register(self,TAS3001C_REG_MCR);
+}
+
+static uint
+tas3001c_supported_mixers(struct tas3001c_data_t *self)
+{
+	return SOUND_MASK_VOLUME |
+		SOUND_MASK_PCM |
+		SOUND_MASK_ALTPCM |
+		SOUND_MASK_TREBLE |
+		SOUND_MASK_BASS;
+	}
 
+static int
+tas3001c_mixer_is_stereo(struct tas3001c_data_t *self,int mixer)
+{
+	switch(mixer) {
+	case SOUND_MIXER_VOLUME:
+		return 1;
+	default:
 	return 0;
 }
+}
 
-int
-tumbler_get_treble(uint *treble)
+static uint
+tas3001c_stereo_mixers(struct tas3001c_data_t *self)
 {
-	struct tas_data_t *data;
+	uint r=tas3001c_supported_mixers(self);
+	uint i;
+	
+	for (i=1; i<SOUND_MIXER_NRDEVICES; i++)
+		if (r&(1<<i) && !tas3001c_mixer_is_stereo(self,i))
+			r &= ~(1<<i);
+	return r;
+}
 
-	if (!tumbler_client)
+static int
+tas3001c_get_mixer_level(struct tas3001c_data_t *self,int mixer,uint *level)
+{
+	if (!self)
 		return -1;
 
-	data = (struct tas_data_t *) (tumbler_client->data);
-	*treble = data->treble;
-	
+	*level=self->super.mixer[mixer];
+
 	return 0;
 }
 
-int
-tumbler_get_bass(uint *bass)
+static int
+tas3001c_set_mixer_level(struct tas3001c_data_t *self,int mixer,uint level)
 {
-	struct tas_data_t *data;
+	int rc;
+	tas_shadow_t *shadow;
+
+	uint temp;
+	uint offset=0;
 
-	if (!tumbler_client)
+	if (!self)
 		return -1;
+	
+	shadow=self->super.shadow;
 
-	data = (struct tas_data_t *) (tumbler_client->data);
-	*bass = data->bass;
+	if (!tas3001c_mixer_is_stereo(self,mixer))
+		level = tas_mono_to_stereo(level);
 
+	switch(mixer) {
+	case SOUND_MIXER_VOLUME:
+		temp = tas3001c_gain.master[level&0xff];
+		shadow[TAS3001C_REG_VOLUME][0] = (temp >> 16) & 0xff;
+		shadow[TAS3001C_REG_VOLUME][1] = (temp >> 8)  & 0xff;
+		shadow[TAS3001C_REG_VOLUME][2] = (temp >> 0)  & 0xff;
+		temp = tas3001c_gain.master[(level>>8)&0xff];
+		shadow[TAS3001C_REG_VOLUME][3] = (temp >> 16) & 0xff;
+		shadow[TAS3001C_REG_VOLUME][4] = (temp >> 8)  & 0xff;
+		shadow[TAS3001C_REG_VOLUME][5] = (temp >> 0)  & 0xff;
+		rc = tas3001c_sync_register(self,TAS3001C_REG_VOLUME);
+		break;
+	case SOUND_MIXER_ALTPCM:
+		/* tas3001c_fast_load(self, 1); */
+		level = tas_mono_to_stereo(level);
+		temp = tas3001c_gain.mixer[level&0xff];
+		shadow[TAS3001C_REG_MIXER2][offset+0] = (temp >> 16) & 0xff;
+		shadow[TAS3001C_REG_MIXER2][offset+1] = (temp >> 8)  & 0xff;
+		shadow[TAS3001C_REG_MIXER2][offset+2] = (temp >> 0)  & 0xff;
+		rc = tas3001c_sync_register(self,TAS3001C_REG_MIXER2);
+		/* tas3001c_fast_load(self, 0); */
+		break;
+	case SOUND_MIXER_PCM:
+		/* tas3001c_fast_load(self, 1); */
+		level = tas_mono_to_stereo(level);
+		temp = tas3001c_gain.mixer[level&0xff];
+		shadow[TAS3001C_REG_MIXER1][offset+0] = (temp >> 16) & 0xff;
+		shadow[TAS3001C_REG_MIXER1][offset+1] = (temp >> 8)  & 0xff;
+		shadow[TAS3001C_REG_MIXER1][offset+2] = (temp >> 0)  & 0xff;
+		rc = tas3001c_sync_register(self,TAS3001C_REG_MIXER1);
+		/* tas3001c_fast_load(self, 0); */
+		break;
+	case SOUND_MIXER_TREBLE:
+		temp = tas3001c_gain.treble[level&0xff];
+		shadow[TAS3001C_REG_TREBLE][0]=temp&0xff;
+		rc = tas3001c_sync_register(self,TAS3001C_REG_TREBLE);
+		break;
+	case SOUND_MIXER_BASS:
+		temp = tas3001c_gain.bass[level&0xff];
+		shadow[TAS3001C_REG_BASS][0]=temp&0xff;
+		rc = tas3001c_sync_register(self,TAS3001C_REG_BASS);
+		break;
+	default:
+		rc = -1;
+		break;
+	}
+	if (rc < 0)
+		return rc;
+	self->super.mixer[mixer]=level;
 	return 0;
 }
 
-int
-tumbler_set_bass(uint bass)
+static int
+tas3001c_leave_sleep(struct tas3001c_data_t *self)
 {
-	uint cur_bass_pers = bass;
-	char block;
-	struct tas_data_t *data;
+	unsigned char mcr = (1<<6)+(2<<4)+(2<<2);
 
-	if (!tumbler_client)
+	if (!self)
 		return -1;
 
-	data = (struct tas_data_t *) (tumbler_client->data);
+	/* Make sure something answers on the i2c bus */
+	if (tas3001c_write_register(self, TAS3001C_REG_MCR, &mcr,
+	    WRITE_NORMAL|FORCE_WRITE) < 0)
+	    	return -1;
 
-	bass &= 0xff;
-	if (bass > TAS_SETTING_MAX)
-		bass = TAS_SETTING_MAX;
-	bass = ((bass * 72) / TAS_SETTING_MAX) << 0;
-	bass = tas_bass_table[bass];
-	block = (bass >> 0)  & 0xff;
+	tas3001c_fast_load(self, 1);
+
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD0);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD1);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD2);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD3);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD4);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD5);
+
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD0);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD1);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD2);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD3);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD4);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD5);
+
+	tas3001c_fast_load(self, 0);
+
+	(void)tas3001c_sync_register(self,TAS3001C_REG_BASS);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_TREBLE);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER1);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER2);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_VOLUME);
 
-	if (tumbler_set_register(TAS_SET_BASS, &block) < 0) {
-		printk("tas3001c: failed to set bass \n");  
-		return -1; 
-	}
-	data->bass = cur_bass_pers;
 	return 0;
 }
 
-int
-tumbler_set_treble(uint treble)
+static int
+tas3001c_enter_sleep(struct tas3001c_data_t *self)
 {
-	uint cur_treble_pers = treble;
-	char block;
-	struct tas_data_t *data;
-
-	if (!tumbler_client)
+	/* Stub for now, but I have the details on low-power mode */
+	if (!self)
 		return -1;
+	return 0;
+}
+
+static int
+tas3001c_sync_biquad(	struct tas3001c_data_t *self,
+			u_int channel,
+			u_int filter)
+{
+	enum tas3001c_reg_t reg;
 
-	data = (struct tas_data_t *) (tumbler_client->data);
+	if (channel >= TAS3001C_BIQUAD_CHANNEL_COUNT ||
+	    filter  >= TAS3001C_BIQUAD_FILTER_COUNT) return -EINVAL;
 
-	treble &= 0xff;
-	if (treble > TAS_SETTING_MAX)
-		treble = TAS_SETTING_MAX;
-	treble = ((treble * 72) / TAS_SETTING_MAX) << 0;
-	treble = tas_treble_table[treble];
-	block = (treble >> 0)  & 0xff;
+	reg=( channel ? TAS3001C_REG_RIGHT_BIQUAD0 : TAS3001C_REG_LEFT_BIQUAD0 ) + filter;
 
-	if (tumbler_set_register(TAS_SET_TREBLE, &block) < 0) {
-		printk("tas3001c: failed to set treble \n");  
-		return -1; 
+	return tas3001c_sync_register(self,reg);
 	}
-	data->treble = cur_treble_pers;
+
+static int
+tas3001c_write_biquad_shadow(	struct tas3001c_data_t *self,
+				u_int channel,
+				u_int filter,
+				const union tas_biquad_t *biquad)
+{
+	tas_shadow_t *shadow=self->super.shadow;
+	enum tas3001c_reg_t reg;
+
+	if (channel >= TAS3001C_BIQUAD_CHANNEL_COUNT ||
+	    filter  >= TAS3001C_BIQUAD_FILTER_COUNT) return -EINVAL;
+
+	reg=( channel ? TAS3001C_REG_RIGHT_BIQUAD0 : TAS3001C_REG_LEFT_BIQUAD0 ) + filter;
+
+	SET_4_20(shadow[reg], 0,biquad->coeff.b0);
+	SET_4_20(shadow[reg], 3,biquad->coeff.b1);
+	SET_4_20(shadow[reg], 6,biquad->coeff.b2);
+	SET_4_20(shadow[reg], 9,biquad->coeff.a1);
+	SET_4_20(shadow[reg],12,biquad->coeff.a2);
+
 	return 0;
 }
 
-int
-tumbler_set_pcm_lvl(uint pcm_lvl)
+static int
+tas3001c_write_biquad(	struct tas3001c_data_t *self,
+			u_int channel,
+			u_int filter,
+			const union tas_biquad_t *biquad)
 {
-	uint pcm_lvl_pers = pcm_lvl;
-	unsigned char block[3];
-	struct tas_data_t *data;
+	int rc;
 
-	if (!tumbler_client)
-		return -1;
+	rc=tas3001c_write_biquad_shadow(self, channel, filter, biquad);
+	if (rc < 0) return rc;
+
+	return tas3001c_sync_biquad(self, channel, filter);
+}
 
-	data = (struct tas_data_t *) (tumbler_client->data);
+static int
+tas3001c_write_biquad_list(	struct tas3001c_data_t *self,
+				u_int filter_count,
+				u_int flags,
+				struct tas_biquad_ctrl_t *biquads)
+{
+	int i;
+	int rc;
 
-	pcm_lvl &= 0xff;
-	if (pcm_lvl > TAS_SETTING_MAX)
-		pcm_lvl = TAS_SETTING_MAX;
-	pcm_lvl = ((pcm_lvl * 176) / TAS_SETTING_MAX) << 0;
+	if (flags & TAS_BIQUAD_FAST_LOAD) tas3001c_fast_load(self,1);
 
-	pcm_lvl = tas_input_table[pcm_lvl];
+	for (i=0; i<filter_count; i++) {
+		rc=tas3001c_write_biquad(self,
+					 biquads[i].channel,
+					 biquads[i].filter,
+					 &biquads[i].data);
+		if (rc < 0) break;
+	}
 
-	block[0] = (pcm_lvl >> 16) & 0xff;
-	block[1] = (pcm_lvl >> 8)  & 0xff;
-	block[2] = (pcm_lvl >> 0)  & 0xff;
+	if (flags & TAS_BIQUAD_FAST_LOAD) {
+		tas3001c_fast_load(self,0);
 
-	if (tumbler_set_register(TAS_SET_MIXER1, block) < 0) {
-		printk("tas3001c: failed to set input level \n");  
-		return -1; 
+		(void)tas3001c_sync_register(self,TAS3001C_REG_BASS);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_TREBLE);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER1);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER2);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_VOLUME);
 	}
-	data->pcm_level = pcm_lvl_pers;
 
-	return 0;
+	return rc;
+}
+
+static int
+tas3001c_read_biquad(	struct tas3001c_data_t *self,
+			u_int channel,
+			u_int filter,
+			union tas_biquad_t *biquad)
+{
+	tas_shadow_t *shadow=self->super.shadow;
+	enum tas3001c_reg_t reg;
+
+	if (channel >= TAS3001C_BIQUAD_CHANNEL_COUNT ||
+	    filter  >= TAS3001C_BIQUAD_FILTER_COUNT) return -EINVAL;
+
+	reg=( channel ? TAS3001C_REG_RIGHT_BIQUAD0 : TAS3001C_REG_LEFT_BIQUAD0 ) + filter;
+
+	biquad->coeff.b0=GET_4_20(shadow[reg], 0);
+	biquad->coeff.b1=GET_4_20(shadow[reg], 3);
+	biquad->coeff.b2=GET_4_20(shadow[reg], 6);
+	biquad->coeff.a1=GET_4_20(shadow[reg], 9);
+	biquad->coeff.a2=GET_4_20(shadow[reg],12);
+
+	return 0;	
 }
 
-int
-tumbler_set_volume(uint left_vol, uint right_vol)
+static int
+tas3001c_eq_rw(	struct tas3001c_data_t *self,
+		u_int cmd,
+		u_long arg)
 {
-	uint left_vol_pers = left_vol;
-	uint right_vol_pers = right_vol;
-	unsigned char block[6];
-	struct tas_data_t *data;
+	int rc;
+	struct tas_biquad_ctrl_t biquad;
 
-	if (!tumbler_client)
-		return -1;
+	if (copy_from_user((void *)&biquad, (const void *)arg, sizeof(struct tas_biquad_ctrl_t))) {
+		return -EFAULT;
+	}
 
-	data = (struct tas_data_t *) (tumbler_client->data);
+	if (cmd & SIOC_IN) {
+		rc=tas3001c_write_biquad(self, biquad.channel, biquad.filter, &biquad.data);
+		if (rc != 0) return rc;
+	}
 
-	left_vol &= 0xff;
-	if (left_vol > TAS_SETTING_MAX)
-		left_vol = TAS_SETTING_MAX;
+	if (cmd & SIOC_OUT) {
+		rc=tas3001c_read_biquad(self, biquad.channel, biquad.filter, &biquad.data);
+		if (rc != 0) return rc;
+
+		if (copy_to_user((void *)arg, (const void *)&biquad, sizeof(struct tas_biquad_ctrl_t))) {
+			return -EFAULT;
+	}
 
-	right_vol = (right_vol >> 8) & 0xff;
-	if (right_vol > TAS_SETTING_MAX)
-		right_vol = TAS_SETTING_MAX;
+	}
+	return 0;
+}
 
-	left_vol = ((left_vol * 176) / TAS_SETTING_MAX) << 0;
-	right_vol = ((right_vol * 176) / TAS_SETTING_MAX) << 0;
+static int
+tas3001c_eq_list_rw(	struct tas3001c_data_t *self,
+			u_int cmd,
+			u_long arg)
+{
+	int rc;
+	int filter_count;
+	int flags;
+	int i,j;
+	char sync_required[2][6];
+	struct tas_biquad_ctrl_t biquad;
+
+	memset(sync_required,0,sizeof(sync_required));
+
+	if (copy_from_user((void *)&filter_count,
+			   (const void *)arg + offsetof(struct tas_biquad_ctrl_list_t,filter_count),
+			   sizeof(int))) {
+		return -EFAULT;
+	}
 
-	left_vol = tas_volume_table[left_vol];
-	right_vol = tas_volume_table[right_vol];
+	if (copy_from_user((void *)&flags,
+			   (const void *)arg + offsetof(struct tas_biquad_ctrl_list_t,flags),
+			   sizeof(int))) {
+		return -EFAULT;
+	}
 
-	block[0] = (left_vol >> 16) & 0xff;
-	block[1] = (left_vol >> 8)  & 0xff;
-	block[2] = (left_vol >> 0)  & 0xff;
+	if (cmd & SIOC_IN) {
+	}
 
-	block[3] = (right_vol >> 16) & 0xff;
-	block[4] = (right_vol >> 8)  & 0xff;
-	block[5] = (right_vol >> 0)  & 0xff;
+	for (i=0; i < filter_count; i++) {
+		if (copy_from_user((void *)&biquad,
+				   (const void *)arg + offsetof(struct tas_biquad_ctrl_list_t, biquads[i]),
+				   sizeof(struct tas_biquad_ctrl_t))) {
+			return -EFAULT;
+		}
+
+		if (cmd & SIOC_IN) {
+			sync_required[biquad.channel][biquad.filter]=1;
+			rc=tas3001c_write_biquad_shadow(self, biquad.channel, biquad.filter, &biquad.data);
+			if (rc != 0) return rc;
+		}
+
+		if (cmd & SIOC_OUT) {
+			rc=tas3001c_read_biquad(self, biquad.channel, biquad.filter, &biquad.data);
+			if (rc != 0) return rc;
+
+			if (copy_to_user((void *)arg + offsetof(struct tas_biquad_ctrl_list_t, biquads[i]),
+					 (const void *)&biquad,
+					 sizeof(struct tas_biquad_ctrl_t))) {
+				return -EFAULT;
+			}
+		}
+	}
 
-	if (tumbler_set_register(TAS_SET_VOLUME, block) < 0) {
-		printk("tas3001c: failed to set volume \n");  
-		return -1; 
+	if (cmd & SIOC_IN) {
+		if (flags & TAS_BIQUAD_FAST_LOAD) tas3001c_fast_load(self,1);
+		for (i=0; i<2; i++) {
+			for (j=0; j<6; j++) {
+				if (sync_required[i][j]) {
+					rc=tas3001c_sync_biquad(self, i, j);
+					if (rc < 0) return rc;
+				}
+			}
+		}
+		if (flags & TAS_BIQUAD_FAST_LOAD) {
+			tas3001c_fast_load(self,0);
+			/* now we need to set up the mixers again,
+			   because leaving fast mode resets them. */
+			(void)tas3001c_sync_register(self,TAS3001C_REG_BASS);
+			(void)tas3001c_sync_register(self,TAS3001C_REG_TREBLE);
+			(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER1);
+			(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER2);
+			(void)tas3001c_sync_register(self,TAS3001C_REG_VOLUME);
+		}
 	}
-	data->left_vol = left_vol_pers;
-	data->right_vol = right_vol_pers;
 
 	return 0;
 }
 
-int
-tumbler_leave_sleep(void)
+static int
+tas3001c_update_drce(	struct tas3001c_data_t *self,
+			int flags,
+			struct tas_drce_t *drce)
 {
-	/* Stub for now, but I have the details on low-power mode */
-	if (!tumbler_client)
-		return -1;
+	tas_shadow_t *shadow;
+	shadow=self->super.shadow;
 
-	return 0;
+	shadow[TAS3001C_REG_DRC][1] = 0xc1;
+
+	if (flags & TAS_DRCE_THRESHOLD) {
+		self->drce_state.threshold=quantize_db(drce->threshold);
+		shadow[TAS3001C_REG_DRC][2] = db_to_regval(self->drce_state.threshold);
 }
 
-int
-tumbler_enter_sleep(void)
-{
-	/* Stub for now, but I have the details on low-power mode */
-	if (!tumbler_client)
-		return -1;
+	if (flags & TAS_DRCE_ENABLE) {
+		self->drce_state.enable = drce->enable;
+	}
 
-	return 0;
+	if (!self->drce_state.enable) {
+		shadow[TAS3001C_REG_DRC][0] = 0xf0;
+	}
+
+#ifdef DEBUG_DRCE
+	printk("DRCE IOCTL: set [ ENABLE:%x THRESH:%x\n",
+	       self->drce_state.enable,
+	       self->drce_state.threshold);
+
+	printk("DRCE IOCTL: reg [ %02x %02x ]\n",
+	       (unsigned char)shadow[TAS3001C_REG_DRC][0],
+	       (unsigned char)shadow[TAS3001C_REG_DRC][1]);
+#endif
+
+	return tas3001c_sync_register(self, TAS3001C_REG_DRC);
 }
 
 static int
-tas_attach_adapter(struct i2c_adapter *adapter)
+tas3001c_drce_rw(	struct tas3001c_data_t *self,
+			u_int cmd,
+			u_long arg)
 {
-	if (!strncmp(adapter->name, "mac-io", 6))
-		tas_detect_client(adapter, tas_i2c_address);
+	int rc;
+	struct tas_drce_ctrl_t drce_ctrl;
+
+	if (copy_from_user((void *)&drce_ctrl,
+			   (const void *)arg,
+			   sizeof(struct tas_drce_ctrl_t))) {
+		return -EFAULT;
+	}
+
+#ifdef DEBUG_DRCE
+	printk("DRCE IOCTL: input [ FLAGS:%x ENABLE:%x THRESH:%x\n",
+	       drce_ctrl.flags,
+	       drce_ctrl.data.enable,
+	       drce_ctrl.data.threshold);
+#endif
+
+	if (cmd & SIOC_IN) {
+		rc = tas3001c_update_drce(self, drce_ctrl.flags, &drce_ctrl.data);
+		if (rc < 0)
+			return rc;
+	}
+
+	if (cmd & SIOC_OUT) {
+		if (drce_ctrl.flags & TAS_DRCE_ENABLE)
+			drce_ctrl.data.enable = self->drce_state.enable;
+
+		if (drce_ctrl.flags & TAS_DRCE_THRESHOLD)
+			drce_ctrl.data.threshold = self->drce_state.threshold;
+
+		if (copy_to_user((void *)arg,
+				 (const void *)&drce_ctrl,
+				 sizeof(struct tas_drce_ctrl_t))) {
+			return -EFAULT;
+		}
+	}
 
 	return 0;
 }
 
-static int
-tas_init_client(struct i2c_client * new_client)
+static void
+tas3001c_update_device_parameters(struct tas3001c_data_t *self)
 {
-	/* Make sure something answers on the i2c bus
-	*/
+	int i,j;
 
-	if (i2c_smbus_write_byte_data(new_client, 1, (1<<6)+(2<<4)+(2<<2)+0) < 0)
-		return -1;
+	if (!self) return;
+
+	if (self->output_id == TAS_OUTPUT_HEADPHONES) {
+		tas3001c_fast_load(self, 1);
+
+		for (i=0; i<TAS3001C_BIQUAD_CHANNEL_COUNT; i++) {
+			for (j=0; j<TAS3001C_BIQUAD_FILTER_COUNT; j++) {
+				tas3001c_write_biquad(self, i, j, &tas3001c_eq_unity);
+			}
+		}
+
+		tas3001c_fast_load(self, 0);
+
+		(void)tas3001c_sync_register(self,TAS3001C_REG_BASS);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_TREBLE);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER1);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_MIXER2);
+		(void)tas3001c_sync_register(self,TAS3001C_REG_VOLUME);
+
+		return;
+	}
+
+	for (i=0; tas3001c_eq_prefs[i]; i++) {
+		struct tas_eq_pref_t *eq = tas3001c_eq_prefs[i];
+
+		if (eq->device_id == self->device_id &&
+		    (eq->output_id == 0 || eq->output_id == self->output_id) &&
+		    (eq->speaker_id == 0 || eq->speaker_id == self->speaker_id)) {
+
+			tas3001c_update_drce(self, TAS_DRCE_ALL, eq->drce);
+			tas3001c_write_biquad_list(self, eq->filter_count, TAS_BIQUAD_FAST_LOAD, eq->biquads);
+
+			break;
+		}
+	}
+}
+
+static void
+tas3001c_device_change_handler(void *self)
+{
+	if (!self) return;
+
+	tas3001c_update_device_parameters((struct tas3001c_data_t *)self);
+}
 
-	tumbler_client = new_client;
+static struct tq_struct device_change_task;
+
+static int
+tas3001c_output_device_change(	struct tas3001c_data_t *self,
+				int device_id,
+				int output_id,
+				int speaker_id)
+{
+	self->device_id=device_id;
+	self->output_id=output_id;
+	self->speaker_id=speaker_id;
 
-	tumbler_set_volume(VOL_DEFAULT, VOL_DEFAULT);
-	tumbler_set_pcm_lvl(INPUT_DEFAULT);
-	tumbler_set_bass(BASS_DEFAULT);
-	tumbler_set_treble(TREBLE_DEFAULT);
+	schedule_task(&device_change_task);
 
 	return 0;
 }
 
 static int
-tas_detect_client(struct i2c_adapter *adapter, int address)
-{
-	int rc = 0;
-	struct i2c_client *new_client;
-	struct tas_data_t *data;
-	const char *client_name = "tas 3001c Digital Equalizer";
+tas3001c_device_ioctl(	struct tas3001c_data_t *self,
+			u_int cmd,
+			u_long arg)
+{
+	switch (cmd) {
+	case TAS_READ_EQ:
+	case TAS_WRITE_EQ:
+		return tas3001c_eq_rw(self, cmd, arg);
+
+	case TAS_READ_EQ_LIST:
+	case TAS_WRITE_EQ_LIST:
+		return tas3001c_eq_list_rw(self, cmd, arg);
 
-	new_client = kmalloc(
-			     sizeof(struct i2c_client) + sizeof(struct tas_data_t),
-			     GFP_KERNEL);
-	if (!new_client) {
-		rc = -ENOMEM;
-		goto bail;
-	}
+	case TAS_READ_EQ_FILTER_COUNT:
+		put_user(TAS3001C_BIQUAD_FILTER_COUNT, (uint *)(arg));
+		return 0;
 
-	/* This is tricky, but it will set the data to the right value. */
-	new_client->data = new_client + 1;
-	data = (struct tas_data_t *) (new_client->data);
+	case TAS_READ_EQ_CHANNEL_COUNT:
+		put_user(TAS3001C_BIQUAD_CHANNEL_COUNT, (uint *)(arg));
+		return 0;
 
-	new_client->addr = address;
-	new_client->data = data;
-	new_client->adapter = adapter;
-	new_client->driver = &tas_driver;
-	new_client->flags = 0;
+	case TAS_READ_DRCE:
+	case TAS_WRITE_DRCE:
+		return tas3001c_drce_rw(self, cmd, arg);
 
-	strcpy(new_client->name,client_name);
+	case TAS_READ_DRCE_CAPS:
+		put_user(TAS_DRCE_ENABLE | TAS_DRCE_THRESHOLD, (uint *)(arg));
+		return 0;
 
-	new_client->id = tas_id++; /* Automatically unique */
+	case TAS_READ_DRCE_MIN:
+	case TAS_READ_DRCE_MAX: {
+		struct tas_drce_ctrl_t drce_ctrl;
+
+		if (copy_from_user((void *)&drce_ctrl,
+				   (const void *)arg,
+				   sizeof(struct tas_drce_ctrl_t))) {
+			return -EFAULT;
+	}
 
-	if (tas_init_client(new_client)) {
-		rc = -ENODEV;
-		goto bail;
+		if (drce_ctrl.flags & TAS_DRCE_THRESHOLD) {
+			if (cmd == TAS_READ_DRCE_MIN) {
+				drce_ctrl.data.threshold=-36<<8;
+			} else {
+				drce_ctrl.data.threshold=-6<<8;
 	}
+		}
 
-	/* Tell the i2c layer a new client has arrived */
-	if (i2c_attach_client(new_client)) {
-		rc = -ENODEV;
-		goto bail;
+		if (copy_to_user((void *)arg,
+				 (const void *)&drce_ctrl,
+				 sizeof(struct tas_drce_ctrl_t))) {
+			return -EFAULT;
+		}
 	}
-bail:
-	if (rc && new_client)
-		kfree(new_client);
-	return rc;
+	}
+
+	return -EINVAL;
 }
 
 static int
-tas_detach_client(struct i2c_client *client)
+tas3001c_init_mixer(struct tas3001c_data_t *self)
 {
-	if (client == tumbler_client)
-		tumbler_client = NULL;
+	unsigned char mcr = (1<<6)+(2<<4)+(2<<2);
+
+	/* Make sure something answers on the i2c bus */
+	if (tas3001c_write_register(self, TAS3001C_REG_MCR, &mcr,
+	    WRITE_NORMAL|FORCE_WRITE) < 0)
+		return -1;
+
+	tas3001c_fast_load(self, 1);
+
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD0);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD1);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD2);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD3);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD4);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD5);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_RIGHT_BIQUAD6);
+
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD0);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD1);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD2);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD3);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD4);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD5);
+	(void)tas3001c_sync_register(self,TAS3001C_REG_LEFT_BIQUAD6);
+
+	tas3001c_fast_load(self, 0);
 
-	i2c_detach_client(client);
-	kfree(client);
+	tas3001c_set_mixer_level(self, SOUND_MIXER_VOLUME, VOL_DEFAULT<<8 | VOL_DEFAULT);
+	tas3001c_set_mixer_level(self, SOUND_MIXER_PCM, INPUT_DEFAULT<<8 | INPUT_DEFAULT);
+	tas3001c_set_mixer_level(self, SOUND_MIXER_ALTPCM, 0);
+
+	tas3001c_set_mixer_level(self, SOUND_MIXER_BASS, BASS_DEFAULT);
+	tas3001c_set_mixer_level(self, SOUND_MIXER_TREBLE, TREBLE_DEFAULT);
 
 	return 0;
 }
 
-int
-tas_cleanup(void)
+static int
+tas3001c_uninit_mixer(struct tas3001c_data_t *self)
 {
-	if (!tas_initialized)
-		return -ENODEV;
-	i2c_del_driver(&tas_driver);
-	tas_initialized = 0;
+	tas3001c_set_mixer_level(self, SOUND_MIXER_VOLUME, 0);
+	tas3001c_set_mixer_level(self, SOUND_MIXER_PCM,    0);
+	tas3001c_set_mixer_level(self, SOUND_MIXER_ALTPCM, 0);
+
+	tas3001c_set_mixer_level(self, SOUND_MIXER_BASS,   0);
+	tas3001c_set_mixer_level(self, SOUND_MIXER_TREBLE, 0);
 
 	return 0;
 }
 
-int
-tas_init(void)
+static int
+tas3001c_init(struct i2c_client *client)
 {
-	int rc;
-	u32* paddr;
+	struct tas3001c_data_t *self;
+	int i,j;
 
-	if (tas_initialized)
-		return 0;
-
-	tas_node = find_devices("deq");
-	if (tas_node == NULL)
-		return -ENODEV;
-
-	printk(KERN_INFO "tas3001c driver version %s (%s)\n",TAS_VERSION,TAS_DATE);
-	paddr = (u32 *)get_property(tas_node, "i2c-address", NULL);
-	if (paddr) {
-		tas_i2c_address = (*paddr) >> 1;
-		printk(KERN_INFO "using i2c address: 0x%x from device-tree\n",
-		       tas_i2c_address);
-	} else    
-		printk(KERN_INFO "using i2c address: 0x%x (default)\n", tas_i2c_address);
-
-	if ((rc = i2c_add_driver(&tas_driver))) {
-		printk("tas3001c: Driver registration failed, module not inserted.\n");
-		tas_cleanup();
-		return rc;
+	self = kmalloc(sizeof(struct tas3001c_data_t) +
+			TAS3001C_REG_MAX * sizeof(tas_shadow_t),
+			GFP_KERNEL);
+	if (self == NULL)
+		return -ENOMEM;
+	client->data = (void *)self;
+	self->super.client = client;
+	self->super.shadow = (tas_shadow_t *)(self+1);
+
+	self->output_id=TAS_OUTPUT_HEADPHONES;
+	self->device_id=0;
+	self->speaker_id=0;
+
+	for (i=0; i<TAS3001C_BIQUAD_CHANNEL_COUNT; i++) {
+		for (j=0; j<TAS3001C_BIQUAD_FILTER_COUNT; j++) {
+			tas3001c_write_biquad_shadow(self, i, j, &tas3001c_eq_unity);
+		}
 	}
-	tas_initialized = 1;
+	INIT_TQUEUE(&device_change_task, tas3001c_device_change_handler, (void *)self);
+
 	return 0;
 }
+
+static void
+tas3001c_uninit(struct tas3001c_data_t *self)
+{
+	tas3001c_uninit_mixer(self);
+	kfree(self);
+}
+
+struct tas_driver_hooks_t tas3001c_hooks = {
+	init:                   (tas_hook_init_t)tas3001c_init,
+	post_init:              (tas_hook_post_init_t)tas3001c_init_mixer,
+	uninit:                 (tas_hook_uninit_t)tas3001c_uninit,
+
+	get_mixer_level:        (tas_hook_get_mixer_level_t)tas3001c_get_mixer_level,
+	set_mixer_level:        (tas_hook_set_mixer_level_t)tas3001c_set_mixer_level,
+
+	enter_sleep:            (tas_hook_enter_sleep_t)tas3001c_enter_sleep,
+	leave_sleep:            (tas_hook_leave_sleep_t)tas3001c_leave_sleep,
+
+	supported_mixers:       (tas_hook_supported_mixers_t)tas3001c_supported_mixers,
+	mixer_is_stereo:        (tas_hook_mixer_is_stereo_t)tas3001c_mixer_is_stereo,
+	stereo_mixers:          (tas_hook_stereo_mixers_t)tas3001c_stereo_mixers,
+
+	output_device_change:   (tas_hook_output_device_change_t)tas3001c_output_device_change,
+
+	device_ioctl:           (tas_hook_device_ioctl_t)tas3001c_device_ioctl
+};
+
+/*
+ * Local Variables:
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas3001c.h kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3001c.h
--- kernel-source-2.4.27/drivers/sound/dmasound/tas3001c.h	2002-02-25 20:38:05.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3001c.h	2004-09-01 20:56:27.627918976 +0200
@@ -9,240 +9,56 @@
  * Written by Christopher C. Chimelis <chris@debian.org>
  */
 
-#ifndef _tas3001c_h_
-#define _tas3001c_h_
+#ifndef _TAS3001C_H_
+#define _TAS3001C_H_
 
-/*
- * Macros that correspond to the registers that we write to
- * when setting the various values.
- */
-#define TAS_DRC			0x02	/* DRC		*/
-#define TAS_VOLUME		0x04	/* Volume	*/
-#define TAS_TREBLE		0x05	/* Treble	*/
-#define TAS_BASS		0x06	/* Bass		*/
-#define TAS_MIXER1		0x07	/* PCM line	*/
-#define TAS_MIXER2		0x08	/* Input (Unk)	*/
-
-/*
- * Macros that define various arguments to tas_set_register()
- */
-#define TAS_SET_DRC		TAS_DRC, 2
-#define TAS_SET_VOLUME		TAS_VOLUME, 6
-#define TAS_SET_TREBLE		TAS_TREBLE, 1
-#define TAS_SET_BASS		TAS_BASS, 1
-#define TAS_SET_MIXER1		TAS_MIXER1, 3
-#define TAS_SET_MIXER2		TAS_MIXER2, 3
+#include <linux/types.h>
 
+#include "tas_common.h"
+#include "tas_eq_prefs.h"
 
 /*
- * tas_volume_table contains lookup values for the volume settings
- * for tumbler.  This is straight from the programming manual
- * for the chip, however, it's zero-sourced for your shopping pleasure
- * (meaning, you'll have to compute the difference between the desired
- * dB and the index value of the proper setting.
- *
- * This table should've been replaced by the formula:
- * 	dB = 20 log(x)
- * but, since there's no log() or supporting functions like exp(),
- * my implementation of the above won't work. Yeah, I could do it
- * the hard way, but this table is just easier :-)
- *
- * For reference, -70 dB = tas_volume_table[0]
+ * Macros that correspond to the registers that we write to
+ * when setting the various values.
  */
 
-static unsigned int tas_volume_table[] = {
-	0x00000015,	0x00000016,	0x00000017,	/* -70.0, -69.5, -69.0 */
-	0x00000019,	0x0000001a,	0x0000001c,	/* -68.5, -68.0, -67.5 */
-	0x0000001d,	0x0000001f,	0x00000021,	/* -67.0, -66.5, -66.0 */
-	0x00000023,	0x00000025,	0x00000027,	/* -65.5, -65.0, -64.5 */
-	0x00000029,	0x0000002c,	0x0000002e,	/* -64.0, -63.5, -63.0 */
-	0x00000031,	0x00000034,	0x00000037,	/* -62.5, -62.0, -61.5 */
-	0x0000003a,	0x0000003e,	0x00000042,	/* -61.0, -60.5, -60.0 */
-	0x00000045,	0x0000004a,	0x0000004e,	/* -59.5, -59.0, -58.5 */
-	0x00000053,	0x00000057,	0x0000005d,	/* -58.0, -57.5, -57.0 */
-	0x00000062,	0x00000068,	0x0000006e,	/* -56.5, -56.0, -55.5 */
-	0x00000075,	0x0000007b,	0x00000083,	/* -55.0, -54.5, -54.0 */
-	0x0000008b,	0x00000093,	0x0000009b,	/* -53.5, -53.0, -52.5 */
-	0x000000a5,	0x000000ae,	0x000000b9,	/* -52.0, -51.5, -51.0 */
-	0x000000c4,	0x000000cf,	0x000000dc,	/* -50.5, -50.0, -49.5 */
-	0x000000e9,	0x000000f6,	0x00000105,	/* -49.0, -48.5, -48.0 */
-	0x00000114,	0x00000125,	0x00000136,	/* -47.5, -47.0, -46.5 */
-	0x00000148,	0x0000015c,	0x00000171,	/* -46.0, -45.5, -45.0 */
-	0x00000186,	0x0000019e,	0x000001b6,	/* -44.5, -44.0, -43.5 */
-	0x000001d0,	0x000001eb,	0x00000209,	/* -43.0, -42.5, -42.0 */
-	0x00000227,	0x00000248,	0x0000026b,	/* -41.5, -41.0, -40.5 */
-	0x0000028f,	0x000002b6,	0x000002df,	/* -40.0, -39.5, -39.0 */
-	0x0000030b,	0x00000339,	0x0000036a,	/* -38.5, -38.0, -37.5 */
-	0x0000039e,	0x000003d5,	0x0000040f,	/* -37.0, -36.5, -36.0 */
-	0x0000044c,	0x0000048d,	0x000004d2,	/* -35.5, -35.0, -34.5 */
-	0x0000051c,	0x00000569,	0x000005bb,	/* -34.0, -33.5, -33.0 */
-	0x00000612,	0x0000066e,	0x000006d0,	/* -32.5, -32.0, -31.5 */
-	0x00000737,	0x000007a5,	0x00000818,	/* -31.0, -30.5, -30.0 */
-	0x00000893,	0x00000915,	0x0000099f,	/* -29.5, -29.0, -28.5 */
-	0x00000a31,	0x00000acc,	0x00000b6f,	/* -28.0, -27.5, -27.0 */
-	0x00000c1d,	0x00000cd5,	0x00000d97,	/* -26.5, -26.0, -25.5 */
-	0x00000e65,	0x00000f40,	0x00001027,	/* -25.0, -24.5, -24.0 */
-	0x0000111c,	0x00001220,	0x00001333,	/* -23.5, -23.0, -22.5 */
-	0x00001456,	0x0000158a,	0x000016d1,	/* -22.0, -21.5, -21.0 */
-	0x0000182b,	0x0000199a,	0x00001b1e,	/* -20.5, -20.0, -19.5 */
-	0x00001cb9,	0x00001e6d,	0x0000203a,	/* -19.0, -18.5, -18.0 */
-	0x00002223,	0x00002429,	0x0000264e,	/* -17.5, -17.0, -16.5 */
-	0x00002893,	0x00002afa,	0x00002d86,	/* -16.0, -15.5, -15.0 */
-	0x00003039,	0x00003314,	0x0000361b,	/* -14.5, -14.0, -13.5 */
-	0x00003950,	0x00003cb5,	0x0000404e,	/* -13.0, -12.5, -12.0 */
-	0x0000441d,	0x00004827,	0x00004c6d,	/* -11.5, -11.0, -10.5 */
-	0x000050f4,	0x000055c0,	0x00005ad5,	/* -10.0, -09.5, -09.0 */
-	0x00006037,	0x000065ea,	0x00006bf4,	/* -08.5, -08.0, -07.5 */
-	0x0000725a,	0x00007920,	0x0000804e,	/* -07.0, -06.5, -06.0 */
-	0x000087e8,	0x00008ff6,	0x0000987d,	/* -05.5, -05.0, -04.5 */
-	0x0000a186,	0x0000ab19,	0x0000b53c,	/* -04.0, -03.5, -03.0 */
-	0x0000bff9,	0x0000cb59,	0x0000d766,	/* -02.5, -02.0, -01.5 */
-	0x0000e429,	0x0000f1ae,	0x00010000,	/* -01.0, -00.5,  00.0 */
-	0x00010f2b,	0x00011f3d,	0x00013042,	/* +00.5, +01.0, +01.5 */
-	0x00014249,	0x00015562,	0x0001699c,	/* +02.0, +02.5, +03.0 */
-	0x00017f09,	0x000195bc,	0x0001adc6,	/* +03.5, +04.0, +04.5 */
-	0x0001c73d,	0x0001e237,	0x0001feca,	/* +05.0, +05.5, +06.0 */
-	0x00021d0e,	0x00023d1d,	0x00025f12,	/* +06.5, +07.0, +07.5 */
-	0x0002830b,	0x0002a925,	0x0002d182,	/* +08.0, +08.5, +09.0 */
-	0x0002fc42,	0x0003298b,	0x00035983,	/* +09.5, +10.0, +10.5 */
-	0x00038c53,	0x0003c225,	0x0003fb28,	/* +11.0, +11.5, +12.0 */
-	0x0004378b,	0x00047783,	0x0004bb44,	/* +12.5, +13.0, +13.5 */
-	0x0005030a,	0x00054f10,	0x00059f98,	/* +14.0, +14.5, +15.0 */
-	0x0005f4e5,	0x00064f40,	0x0006aef6,	/* +15.5, +16.0, +16.5 */
-	0x00071457,	0x00077fbb,	0x0007f17b	/* +17.0, +17.5, +18.0 */
-};
+#define TAS3001C_VERSION	"0.3"
+#define TAS3001C_DATE	        "20011214"
 
-/* tas_treble_table[] is a lookup table that holds the values to drop into
- * the treble setting register on the TAS.  Again, there is a formula for
- * this one, but we use this instead due to lack of real math functions
- * in the kernel.
- */
-static char tas_treble_table[] = {
-	0x96,		0x95,		0x94,	/* -18.0, -17.5, -17.0 */
-	0x93,		0x92,		0x91,	/* -16.5, -16.0, -15.5 */
-	0x90,		0x8f,		0x8e,	/* -15.0, -14.5, -14.0 */
-	0x8d,		0x8c,		0x8b,	/* -13.5, -13.0, -12.5 */
-	0x8a,		0x89,		0x88,	/* -12.0, -11.5, -11.0 */
-	0x87,		0x86,		0x85,	/* -10.5, -10.0, -09.5 */
-	0x84,		0x83,		0x82,	/* -09.0, -08.5, -08.0 */
-	0x81,		0x80,		0x7f,	/* -07.5, -07.0, -06.5 */
-	0x7e,		0x7d,		0x7c,	/* -06.0, -05.5, -05.0 */
-	0x7b,		0x7a,		0x79,	/* -04.5, -04.0, -03.5 */
-	0x78,		0x77,		0x76,	/* -03.0, -02.5, -02.0 */
-	0x75,		0x74,		0x73,	/* -01.5, -01.0, -00.5 */
-	0x72,		0x71,		0x70,	/*  00.0, +00.5, +01.0 */
-	0x6e,		0x6d,		0x6c,	/* +01.5, +02.0, +02.5 */
-	0x6b,		0x69,		0x68,	/* +03.0, +03.5, +04.0 */
-	0x66,		0x65,		0x63,	/* +04.5, +05.0, +05.5 */
-	0x62,		0x60,		0x5e,	/* +06.0, +06.5, +07.0 */
-	0x5c,		0x5a,		0x57,	/* +07.5, +08.0, +08.5 */
-	0x55,		0x52,		0x4f,	/* +09.0, +09.5, +10.0 */
-	0x4c,		0x49,		0x45,	/* +10.5, +11.0, +11.5 */
-	0x42,		0x3e,		0x3a,	/* +12.0, +12.5, +13.0 */
-	0x36,		0x32,		0x2d,	/* +13.5, +14.0, +14.5 */
-	0x28,		0x22,		0x1c,	/* +15.0, +15.5, +16.0 */
-	0x16,		0x10,		0x09,	/* +16.5, +17.0, +17.5 */
-	0x01					/* +18.0	       */
-};
+#define I2C_DRIVERNAME_TAS3001C "TAS3001c driver V " TAS3001C_VERSION
+#define I2C_DRIVERID_TAS3001C   (I2C_DRIVERID_TAS_BASE+0)
 
-/* tas_bass_table[] is a lookup table that holds the values to drop into
- * the bass setting register on the TAS.  Again, there is a formula for
- * this one, but we use this instead due to lack of real math functions
- * in the kernel.
- */
-static char tas_bass_table[] = {
-	0x86,		0x82,		0x7f,	/* -18.0, -17.5, -17.0 */
-	0x7d,		0x7a,		0x78,	/* -16.5, -16.0, -15.5 */
-	0x76,		0x74,		0x72,	/* -15.0, -14.5, -14.0 */
-	0x70,		0x6e,		0x6d,   /* -13.5, -13.0, -12.5 */
-	0x6b,		0x69,		0x66,	/* -12.0, -11.5, -11.0 */
-	0x64,		0x61,		0x5f,	/* -10.5, -10.0, -09.5 */
-	0x5d,		0x5c,		0x5a,	/* -09.0, -08.5, -08.0 */
-	0x59,		0x58,		0x56,	/* -07.5, -07.0, -06.5 */
-	0x55,		0x54,		0x53,	/* -06.0, -05.5, -05.0 */
-	0x51,		0x4f,		0x4d,	/* -04.5, -04.0, -03.5 */
-	0x4b,		0x49,		0x46,	/* -03.0, -02.5, -02.0 */
-	0x44,		0x42,		0x40,	/* -01.5, -01.0, -00.5 */
-	0x3e,		0x3c,		0x3b,	/*  00.0, +00.5, +01.0 */
-	0x39,		0x38,		0x36,	/* +01.5, +02.0, +02.5 */
-	0x35,		0x33,		0x31,	/* +03.0, +03.5, +04.0 */
-	0x30,		0x2e,		0x2c,	/* +04.5, +05.0, +05.5 */
-	0x2b,		0x29,		0x28,	/* +06.0, +06.5, +07.0 */
-	0x26,		0x25,		0x23,	/* +07.5, +08.0, +08.5 */
-	0x21,		0x1f,		0x1c,	/* +09.0, +09.5, +10.0 */
-	0x19,		0x18,		0x17,	/* +10.5, +11.0, +11.5 */
-	0x16,		0x14,		0x13,	/* +12.0, +12.5, +13.0 */
-	0x12,		0x10,		0x0f,	/* +13.5, +14.0, +14.5 */
-	0x0d,		0x0b,		0x0a,	/* +15.0, +15.5, +16.0 */
-	0x08,		0x06,		0x03,	/* +16.5, +17.0, +17.5 */
-	0x01					/* +18.0	       */
-};
+extern  struct tas_driver_hooks_t tas3001c_hooks;
+extern struct tas_gain_t tas3001c_gain;
+extern struct tas_eq_pref_t *tas3001c_eq_prefs[];
+
+enum tas3001c_reg_t {
+  TAS3001C_REG_MCR                    = 0x01,
+  TAS3001C_REG_DRC                    = 0x02,
+
+  TAS3001C_REG_VOLUME                 = 0x04,
+  TAS3001C_REG_TREBLE                 = 0x05,
+  TAS3001C_REG_BASS                   = 0x06,
+  TAS3001C_REG_MIXER1                 = 0x07,
+  TAS3001C_REG_MIXER2                 = 0x08,
+
+  TAS3001C_REG_LEFT_BIQUAD0           = 0x0a,
+  TAS3001C_REG_LEFT_BIQUAD1           = 0x0b,
+  TAS3001C_REG_LEFT_BIQUAD2           = 0x0c,
+  TAS3001C_REG_LEFT_BIQUAD3           = 0x0d,
+  TAS3001C_REG_LEFT_BIQUAD4           = 0x0e,
+  TAS3001C_REG_LEFT_BIQUAD5           = 0x0f,
+  TAS3001C_REG_LEFT_BIQUAD6           = 0x10,
+  
+  TAS3001C_REG_RIGHT_BIQUAD0          = 0x13,
+  TAS3001C_REG_RIGHT_BIQUAD1          = 0x14,
+  TAS3001C_REG_RIGHT_BIQUAD2          = 0x15,
+  TAS3001C_REG_RIGHT_BIQUAD3          = 0x16,
+  TAS3001C_REG_RIGHT_BIQUAD4          = 0x17,
+  TAS3001C_REG_RIGHT_BIQUAD5          = 0x18,
+  TAS3001C_REG_RIGHT_BIQUAD6          = 0x19,
 
-/* tas_input_table[] is a lookup table that holds the values to drop into
- * the setting registers on the TAS for "mixers 1 & 2" (which are the input
- * lines).  Again, there is a formula for these, but we use this instead
- * due to lack of real math functions in the kernel.
- */
-static unsigned int tas_input_table[] = {
-	0x00014b,	0x00015f,	0x000174,	/* -70.0, -69.5, -69.0 */
-	0x00018a,	0x0001a1,	0x0001ba,	/* -68.5, -68.0, -67.5 */
-	0x0001d4,	0x0001f0,	0x00020d,	/* -67.0, -66.5, -66.0 */
-	0x00022c,	0x00024d,	0x000270,	/* -65.5, -65.0, -64.5 */
-	0x000295,	0x0002bc,	0x0002e6,	/* -64.0, -63.5, -63.0 */
-	0x000312,	0x000340,	0x000372,	/* -62.5, -62.0, -61.5 */
-	0x0003a6,	0x0003dd,	0x000418,	/* -61.0, -60.5, -60.0 */
-	0x000456,	0x000498,	0x0004de,	/* -59.5, -59.0, -58.5 */
-	0x000528,	0x000576,	0x0005c9,	/* -58.0, -57.5, -57.0 */
-	0x000620,	0x00067d,	0x0006e0,	/* -56.5, -56.0, -55.5 */
-	0x000748,	0x0007b7,	0x00082c,	/* -55.0, -54.5, -54.0 */
-	0x0008a8,	0x00092b,	0x0009b6,	/* -53.5, -53.0, -52.5 */
-	0x000a49,	0x000ae5,	0x000b8b,	/* -52.0, -51.5, -51.0 */
-	0x000c3a,	0x000cf3,	0x000db8,	/* -50.5, -50.0, -49.5 */
-	0x000e88,	0x000f64,	0x00104e,	/* -49.0, -48.5, -48.0 */
-	0x001145,	0x00124b,	0x001361,	/* -47.5, -47.0, -46.5 */
-	0x001487,	0x0015be,	0x001708,	/* -46.0, -45.5, -45.0 */
-	0x001865,	0x0019d8,	0x001b60,	/* -44.5, -44.0, -43.5 */
-	0x001cff,	0x001eb7,	0x002089,	/* -43.0, -42.5, -42.0 */
-	0x002276,	0x002481,	0x0026ab,	/* -41.5, -41.0, -40.5 */
-	0x0028f5,	0x002b63,	0x002df5,	/* -40.0, -39.5, -39.0 */
-	0x0030ae,	0x003390,	0x00369e,	/* -38.5, -38.0, -37.5 */
-	0x0039db,	0x003d49,	0x0040ea,	/* -37.0, -36.5, -36.0 */
-	0x0044c3,	0x0048d6,	0x004d27,	/* -35.5, -35.0, -34.5 */
-	0x0051b9,	0x005691,	0x005bb2,	/* -34.0, -33.5, -33.0 */
-	0x006121,	0x0066e3,	0x006cfb,	/* -32.5, -32.0, -31.5 */
-	0x007370,	0x007a48,	0x008186,	/* -31.0, -30.5, -30.0 */
-	0x008933,	0x009154,	0x0099f1,	/* -29.5, -29.0, -28.5 */
-	0x00a310,	0x00acba,	0x00b6f6,	/* -28.0, -27.5, -27.0 */
-	0x00c1cd,	0x00cd49,	0x00d973,	/* -26.5, -26.0, -25.5 */
-	0x00e655,	0x00f3fb,	0x010270,	/* -25.0, -24.5, -24.0 */
-	0x0111c0,	0x0121f9,	0x013328,	/* -23.5, -23.0, -22.5 */
-	0x01455b,	0x0158a2,	0x016d0e,	/* -22.0, -21.5, -21.0 */
-	0x0182af,	0x019999,	0x01b1de,	/* -20.5, -20.0, -19.5 */
-	0x01cb94,	0x01e6cf,	0x0203a7,	/* -19.0, -18.5, -18.0 */
-	0x022235,	0x024293,	0x0264db,	/* -17.5, -17.0, -16.5 */
-	0x02892c,	0x02afa3,	0x02d862,	/* -16.0, -15.5, -15.0 */
-	0x03038a,	0x033142,	0x0361af,	/* -14.5, -14.0, -13.5 */
-	0x0394fa,	0x03cb50,	0x0404de,	/* -13.0, -12.5, -12.0 */
-	0x0441d5,	0x048268,	0x04c6d0,	/* -11.5, -11.0, -10.5 */
-	0x050f44,	0x055c04,	0x05ad50,	/* -10.0, -09.5, -09.0 */
-	0x06036e,	0x065ea5,	0x06bf44,	/* -08.5, -08.0, -07.5 */
-	0x07259d,	0x079207,	0x0804dc,	/* -07.0, -06.5, -06.0 */
-	0x087e80,	0x08ff59,	0x0987d5,	/* -05.5, -05.0, -04.5 */
-	0x0a1866,	0x0ab189,	0x0b53be,	/* -04.0, -03.5, -03.0 */
-	0x0bff91,	0x0cb591,	0x0d765a,	/* -02.5, -02.0, -01.5 */
-	0x0e4290,	0x0f1adf,	0x100000,	/* -01.0, -00.5,  00.0 */
-	0x10f2b4,	0x11f3c9,	0x13041a,	/* +00.5, +01.0, +01.5 */
-	0x14248e,	0x15561a,	0x1699c0,	/* +02.0, +02.5, +03.0 */
-	0x17f094,	0x195bb8,	0x1adc61,	/* +03.5, +04.0, +04.5 */
-	0x1c73d5,	0x1e236d,	0x1fec98,	/* +05.0, +05.5, +06.0 */
-	0x21d0d9,	0x23d1cd,	0x25f125,	/* +06.5, +07.0, +07.5 */
-	0x2830af,	0x2a9254,	0x2d1818,	/* +08.0, +08.5, +09.0 */
-	0x2fc420,	0x3298b0,	0x35982f,	/* +09.5, +10.0, +10.5 */
-	0x38c528,	0x3c224c,	0x3fb278,	/* +11.0, +11.5, +12.0 */
-	0x437880,	0x477828,	0x4bb446,	/* +12.5, +13.0, +13.5 */
-	0x5030a1,	0x54f106,	0x59f980,	/* +14.0, +14.5, +15.0 */
-	0x5f4e52,	0x64f403,	0x6aef5d,	/* +15.5, +16.0, +16.5 */
-	0x714575,	0x77fbaa,	0x7f17af	/* +17.0, +17.5, +18.0 */
+  TAS3001C_REG_MAX                    = 0x20
 };
 
-#endif /* _tas3001c_h_ */
+#endif /* _TAS3001C_H_ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas3001c_tables.c kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3001c_tables.c
--- kernel-source-2.4.27/drivers/sound/dmasound/tas3001c_tables.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3001c_tables.c	2004-09-01 20:56:27.709906512 +0200
@@ -0,0 +1,375 @@
+#include "tas_common.h"
+#include "tas_eq_prefs.h"
+
+static struct tas_drce_t eqp_0e_2_1_drce = {
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -15.33  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_0e_2_1_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0FCAD3, 0xE06A58, 0x0FCAD3, 0xE06B09, 0x0F9657 } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x041731, 0x082E63, 0x041731, 0xFD8D08, 0x02CFBD } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0FFDC7, 0xE0524C, 0x0FBFAA, 0xE0524C, 0x0FBD72 } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0F3D35, 0xE228CA, 0x0EC7B2, 0xE228CA, 0x0E04E8 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x0FCEBF, 0xE181C2, 0x0F2656, 0xE181C2, 0x0EF516 } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0EC417, 0x073E22, 0x0B0633, 0x073E22, 0x09CA4A } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0FCAD3, 0xE06A58, 0x0FCAD3, 0xE06B09, 0x0F9657 } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x041731, 0x082E63, 0x041731, 0xFD8D08, 0x02CFBD } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0FFDC7, 0xE0524C, 0x0FBFAA, 0xE0524C, 0x0FBD72 } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0F3D35, 0xE228CA, 0x0EC7B2, 0xE228CA, 0x0E04E8 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x0FCEBF, 0xE181C2, 0x0F2656, 0xE181C2, 0x0EF516 } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0EC417, 0x073E22, 0x0B0633, 0x073E22, 0x09CA4A } } },
+};
+
+static struct tas_eq_pref_t eqp_0e_2_1 = {
+  sample_rate:  44100,
+  device_id:    0x0e,
+  output_id:    TAS_OUTPUT_EXTERNAL_SPKR,
+  speaker_id:   0x01,
+
+  drce:         &eqp_0e_2_1_drce,
+
+  filter_count: 12,
+  biquads:      eqp_0e_2_1_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_10_1_0_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -12.46  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_10_1_0_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0F4A12, 0xE16BDA, 0x0F4A12, 0xE173F0, 0x0E9C3A } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x02DD54, 0x05BAA8, 0x02DD54, 0xF8001D, 0x037532 } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0E2FC7, 0xE4D5DC, 0x0D7477, 0xE4D5DC, 0x0BA43F } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0E7899, 0xE67CCA, 0x0D0E93, 0xE67CCA, 0x0B872D } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0F4A12, 0xE16BDA, 0x0F4A12, 0xE173F0, 0x0E9C3A } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x02DD54, 0x05BAA8, 0x02DD54, 0xF8001D, 0x037532 } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0E2FC7, 0xE4D5DC, 0x0D7477, 0xE4D5DC, 0x0BA43F } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0E7899, 0xE67CCA, 0x0D0E93, 0xE67CCA, 0x0B872D } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 } } },
+};
+
+static struct tas_eq_pref_t eqp_10_1_0 = {
+  sample_rate:  44100,
+  device_id:    0x10,
+  output_id:    TAS_OUTPUT_INTERNAL_SPKR,
+  speaker_id:   0x00,
+
+  drce:         &eqp_10_1_0_drce,
+
+  filter_count: 12,
+  biquads:      eqp_10_1_0_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_15_2_1_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -15.33  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_15_2_1_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0FE143, 0xE05204, 0x0FCCC5, 0xE05266, 0x0FAE6B } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x102383, 0xE03A03, 0x0FA325, 0xE03A03, 0x0FC6A8 } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0FF2AB, 0xE06285, 0x0FB20A, 0xE06285, 0x0FA4B5 } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0F544D, 0xE35971, 0x0D8F3A, 0xE35971, 0x0CE388 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x13E1D3, 0xF3ECB5, 0x042227, 0xF3ECB5, 0x0803FA } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0AC119, 0x034181, 0x078AB1, 0x034181, 0x024BCA } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0FE143, 0xE05204, 0x0FCCC5, 0xE05266, 0x0FAE6B } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x102383, 0xE03A03, 0x0FA325, 0xE03A03, 0x0FC6A8 } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0FF2AB, 0xE06285, 0x0FB20A, 0xE06285, 0x0FA4B5 } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0F544D, 0xE35971, 0x0D8F3A, 0xE35971, 0x0CE388 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x13E1D3, 0xF3ECB5, 0x042227, 0xF3ECB5, 0x0803FA } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0AC119, 0x034181, 0x078AB1, 0x034181, 0x024BCA } } },
+};
+
+static struct tas_eq_pref_t eqp_15_2_1 = {
+  sample_rate:  44100,
+  device_id:    0x15,
+  output_id:    TAS_OUTPUT_EXTERNAL_SPKR,
+  speaker_id:   0x01,
+
+  drce:         &eqp_15_2_1_drce,
+
+  filter_count: 12,
+  biquads:      eqp_15_2_1_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_15_1_0_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: 0.0     * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_15_1_0_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0FAD08, 0xE0A5EF, 0x0FAD08, 0xE0A79D, 0x0F5BBE } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x04B38D, 0x09671B, 0x04B38D, 0x000F71, 0x02BEC5 } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0FDD32, 0xE0A56F, 0x0F8A69, 0xE0A56F, 0x0F679C } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0FD284, 0xE135FB, 0x0F2161, 0xE135FB, 0x0EF3E5 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x0E81B1, 0xE6283F, 0x0CE49D, 0xE6283F, 0x0B664F } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0F2D62, 0xE98797, 0x0D1E19, 0xE98797, 0x0C4B7B } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0FAD08, 0xE0A5EF, 0x0FAD08, 0xE0A79D, 0x0F5BBE } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x04B38D, 0x09671B, 0x04B38D, 0x000F71, 0x02BEC5 } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0FDD32, 0xE0A56F, 0x0F8A69, 0xE0A56F, 0x0F679C } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0FD284, 0xE135FB, 0x0F2161, 0xE135FB, 0x0EF3E5 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x0E81B1, 0xE6283F, 0x0CE49D, 0xE6283F, 0x0B664F } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0F2D62, 0xE98797, 0x0D1E19, 0xE98797, 0x0C4B7B } } },
+};
+
+static struct tas_eq_pref_t eqp_15_1_0 = {
+  sample_rate:  44100,
+  device_id:    0x15,
+  output_id:    TAS_OUTPUT_INTERNAL_SPKR,
+  speaker_id:   0x00,
+
+  drce:         &eqp_15_1_0_drce,
+
+  filter_count: 12,
+  biquads:      eqp_15_1_0_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_0f_2_1_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -15.33  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_0f_2_1_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0FE143, 0xE05204, 0x0FCCC5, 0xE05266, 0x0FAE6B } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x102383, 0xE03A03, 0x0FA325, 0xE03A03, 0x0FC6A8 } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0FF2AB, 0xE06285, 0x0FB20A, 0xE06285, 0x0FA4B5 } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0F544D, 0xE35971, 0x0D8F3A, 0xE35971, 0x0CE388 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x13E1D3, 0xF3ECB5, 0x042227, 0xF3ECB5, 0x0803FA } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0AC119, 0x034181, 0x078AB1, 0x034181, 0x024BCA } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0FE143, 0xE05204, 0x0FCCC5, 0xE05266, 0x0FAE6B } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x102383, 0xE03A03, 0x0FA325, 0xE03A03, 0x0FC6A8 } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0FF2AB, 0xE06285, 0x0FB20A, 0xE06285, 0x0FA4B5 } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0F544D, 0xE35971, 0x0D8F3A, 0xE35971, 0x0CE388 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x13E1D3, 0xF3ECB5, 0x042227, 0xF3ECB5, 0x0803FA } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0AC119, 0x034181, 0x078AB1, 0x034181, 0x024BCA } } },
+};
+
+static struct tas_eq_pref_t eqp_0f_2_1 = {
+  sample_rate:  44100,
+  device_id:    0x0f,
+  output_id:    TAS_OUTPUT_EXTERNAL_SPKR,
+  speaker_id:   0x01,
+
+  drce:         &eqp_0f_2_1_drce,
+
+  filter_count: 12,
+  biquads:      eqp_0f_2_1_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_0f_1_0_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -15.33  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_0f_1_0_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0FCAD3, 0xE06A58, 0x0FCAD3, 0xE06B09, 0x0F9657 } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x041731, 0x082E63, 0x041731, 0xFD8D08, 0x02CFBD } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0FFDC7, 0xE0524C, 0x0FBFAA, 0xE0524C, 0x0FBD72 } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0F3D35, 0xE228CA, 0x0EC7B2, 0xE228CA, 0x0E04E8 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x0FCEBF, 0xE181C2, 0x0F2656, 0xE181C2, 0x0EF516 } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0EC417, 0x073E22, 0x0B0633, 0x073E22, 0x09CA4A } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0FCAD3, 0xE06A58, 0x0FCAD3, 0xE06B09, 0x0F9657 } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x041731, 0x082E63, 0x041731, 0xFD8D08, 0x02CFBD } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0FFDC7, 0xE0524C, 0x0FBFAA, 0xE0524C, 0x0FBD72 } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0F3D35, 0xE228CA, 0x0EC7B2, 0xE228CA, 0x0E04E8 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x0FCEBF, 0xE181C2, 0x0F2656, 0xE181C2, 0x0EF516 } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0EC417, 0x073E22, 0x0B0633, 0x073E22, 0x09CA4A } } },
+};
+
+static struct tas_eq_pref_t eqp_0f_1_0 = {
+  sample_rate:  44100,
+  device_id:    0x0f,
+  output_id:    TAS_OUTPUT_INTERNAL_SPKR,
+  speaker_id:   0x00,
+
+  drce:         &eqp_0f_1_0_drce,
+
+  filter_count: 12,
+  biquads:      eqp_0f_1_0_biquads
+};
+
+/* ======================================================================== */
+
+static uint tas3001c_master_tab[]={
+	       0x0,       0x75,       0x9c,       0xbb,
+	      0xdb,       0xfb,      0x11e,      0x143,
+	     0x16b,      0x196,      0x1c3,      0x1f5,
+	     0x229,      0x263,      0x29f,      0x2e1,
+	     0x328,      0x373,      0x3c5,      0x41b,
+	     0x478,      0x4dc,      0x547,      0x5b8,
+	     0x633,      0x6b5,      0x740,      0x7d5,
+	     0x873,      0x91c,      0x9d2,      0xa92,
+	     0xb5e,      0xc39,      0xd22,      0xe19,
+	     0xf20,     0x1037,     0x1161,     0x129e,
+	    0x13ed,     0x1551,     0x16ca,     0x185d,
+	    0x1a08,     0x1bcc,     0x1dac,     0x1fa7,
+	    0x21c1,     0x23fa,     0x2655,     0x28d6,
+	    0x2b7c,     0x2e4a,     0x3141,     0x3464,
+	    0x37b4,     0x3b35,     0x3ee9,     0x42d3,
+	    0x46f6,     0x4b53,     0x4ff0,     0x54ce,
+	    0x59f2,     0x5f5f,     0x6519,     0x6b24,
+	    0x7183,     0x783c,     0x7f53,     0x86cc,
+	    0x8ead,     0x96fa,     0x9fba,     0xa8f2,
+	    0xb2a7,     0xbce1,     0xc7a5,     0xd2fa,
+	    0xdee8,     0xeb75,     0xf8aa,    0x1068e,
+	   0x1152a,    0x12487,    0x134ad,    0x145a5,
+	   0x1577b,    0x16a37,    0x17df5,    0x192bd,
+	   0x1a890,    0x1bf7b,    0x1d78d,    0x1f0d1,
+	   0x20b55,    0x22727,    0x24456,    0x262f2,
+	   0x2830b
+};
+
+static uint tas3001c_mixer_tab[]={
+	       0x0,      0x748,      0x9be,      0xbaf,
+	     0xda4,      0xfb1,     0x11de,     0x1431,
+	    0x16ad,     0x1959,     0x1c37,     0x1f4b,
+	    0x2298,     0x2628,     0x29fb,     0x2e12,
+	    0x327d,     0x3734,     0x3c47,     0x41b4,
+	    0x4787,     0x4dbe,     0x546d,     0x5b86,
+	    0x632e,     0x6b52,     0x7400,     0x7d54,
+	    0x873b,     0x91c6,     0x9d1a,     0xa920,
+	    0xb5e5,     0xc38c,     0xd21b,     0xe18f,
+	    0xf1f5,    0x1036a,    0x1160f,    0x129d6,
+	   0x13ed0,    0x1550c,    0x16ca0,    0x185c9,
+	   0x1a07b,    0x1bcc3,    0x1dab9,    0x1fa75,
+	   0x21c0f,    0x23fa3,    0x26552,    0x28d64,
+	   0x2b7c9,    0x2e4a2,    0x31411,    0x3463b,
+	   0x37b44,    0x3b353,    0x3ee94,    0x42d30,
+	   0x46f55,    0x4b533,    0x4fefc,    0x54ce5,
+	   0x59f25,    0x5f5f6,    0x65193,    0x6b23c,
+	   0x71835,    0x783c3,    0x7f52c,    0x86cc0,
+	   0x8eacc,    0x96fa5,    0x9fba0,    0xa8f1a,
+	   0xb2a71,    0xbce0a,    0xc7a4a,    0xd2fa0,
+	   0xdee7b,    0xeb752,    0xf8a9f,   0x1068e4,
+	  0x1152a3,   0x12486a,   0x134ac8,   0x145a55,
+	  0x1577ac,   0x16a370,   0x17df51,   0x192bc2,
+	  0x1a88f8,   0x1bf7b7,   0x1d78c9,   0x1f0d04,
+	  0x20b542,   0x227268,   0x244564,   0x262f26,
+	  0x2830af
+};
+
+static uint tas3001c_treble_tab[]={
+	      0x96,       0x95,       0x95,       0x94,
+	      0x93,       0x92,       0x92,       0x91,
+	      0x90,       0x90,       0x8f,       0x8e,
+	      0x8d,       0x8d,       0x8c,       0x8b,
+	      0x8a,       0x8a,       0x89,       0x88,
+	      0x88,       0x87,       0x86,       0x85,
+	      0x85,       0x84,       0x83,       0x83,
+	      0x82,       0x81,       0x80,       0x80,
+	      0x7f,       0x7e,       0x7e,       0x7d,
+	      0x7c,       0x7b,       0x7b,       0x7a,
+	      0x79,       0x78,       0x78,       0x77,
+	      0x76,       0x76,       0x75,       0x74,
+	      0x73,       0x73,       0x72,       0x71,
+	      0x71,       0x70,       0x6e,       0x6d,
+	      0x6d,       0x6c,       0x6b,       0x6a,
+	      0x69,       0x68,       0x67,       0x66,
+	      0x65,       0x63,       0x62,       0x62,
+	      0x60,       0x5f,       0x5d,       0x5c,
+	      0x5a,       0x58,       0x56,       0x55,
+	      0x53,       0x51,       0x4f,       0x4c,
+	      0x4a,       0x48,       0x45,       0x43,
+	      0x40,       0x3d,       0x3a,       0x37,
+	      0x35,       0x32,       0x2e,       0x2a,
+	      0x27,       0x22,       0x1e,       0x1a,
+	      0x15,       0x11,        0xc,        0x7,
+	       0x1
+};
+
+static uint tas3001c_bass_tab[]={
+	      0x86,       0x83,       0x81,       0x7f,
+	      0x7d,       0x7b,       0x79,       0x78,
+	      0x76,       0x75,       0x74,       0x72,
+	      0x71,       0x6f,       0x6e,       0x6d,
+	      0x6c,       0x6b,       0x69,       0x67,
+	      0x65,       0x64,       0x61,       0x60,
+	      0x5e,       0x5d,       0x5c,       0x5b,
+	      0x5a,       0x59,       0x58,       0x57,
+	      0x56,       0x55,       0x55,       0x54,
+	      0x53,       0x52,       0x50,       0x4f,
+	      0x4d,       0x4c,       0x4b,       0x49,
+	      0x47,       0x45,       0x44,       0x42,
+	      0x41,       0x3f,       0x3e,       0x3d,
+	      0x3c,       0x3b,       0x39,       0x38,
+	      0x37,       0x36,       0x35,       0x34,
+	      0x33,       0x31,       0x30,       0x2f,
+	      0x2e,       0x2c,       0x2b,       0x2b,
+	      0x29,       0x28,       0x27,       0x26,
+	      0x25,       0x24,       0x22,       0x21,
+	      0x20,       0x1e,       0x1c,       0x19,
+	      0x18,       0x18,       0x17,       0x16,
+	      0x15,       0x14,       0x13,       0x12,
+	      0x11,       0x10,        0xf,        0xe,
+	       0xd,        0xb,        0xa,        0x9,
+	       0x8,        0x6,        0x4,        0x2,
+	       0x1
+};
+
+struct tas_gain_t tas3001c_gain = {
+  master: tas3001c_master_tab,
+  treble: tas3001c_treble_tab,
+  bass:   tas3001c_bass_tab,
+  mixer:  tas3001c_mixer_tab
+};
+
+struct tas_eq_pref_t *tas3001c_eq_prefs[]={
+  &eqp_0e_2_1,
+  &eqp_10_1_0,
+  &eqp_15_2_1,
+  &eqp_15_1_0,
+  &eqp_0f_2_1,
+  &eqp_0f_1_0,
+  NULL
+};
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas3004.c kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3004.c
--- kernel-source-2.4.27/drivers/sound/dmasound/tas3004.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3004.c	2004-09-01 20:56:27.794893592 +0200
@@ -0,0 +1,1173 @@
+/*
+ * Driver for the i2c/i2s based TA3004 sound chip used
+ * on some Apple hardware. Also known as "snapper".
+ *
+ * Tobias Sargeant <tobias.sargeant@bigpond.com>
+ * Based upon tas3001c.c by Christopher C. Chimelis <chris@debian.org>:
+ *
+ *   TODO:
+ *   -----
+ *   * Enable control over input line 2 (is this connected?)
+ *   * Implement sleep support (at least mute everything and
+ *   * set gains to minimum during sleep)
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ioport.h>
+#include <linux/sysctl.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/soundcard.h>
+#include <linux/interrupt.h>
+
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+
+#include "dmasound.h"
+#include "tas_common.h"
+#include "tas3004.h"
+
+#include "tas_ioctl.h"
+
+/* #define DEBUG_DRCE */
+
+#define TAS3004_BIQUAD_FILTER_COUNT  7
+#define TAS3004_BIQUAD_CHANNEL_COUNT 2
+
+#define VOL_DEFAULT	(100 * 4 / 5)
+#define INPUT_DEFAULT	(100 * 4 / 5)
+#define BASS_DEFAULT	(100 / 2)
+#define TREBLE_DEFAULT	(100 / 2)
+
+struct tas3004_data_t {
+	struct tas_data_t super;
+	int device_id;
+	int output_id;
+	int speaker_id;
+	struct tas_drce_t drce_state;
+};
+
+#define MAKE_TIME(sec,usec) (((sec)<<12) + (50000+(usec/10)*(1<<12))/100000)
+
+#define MAKE_RATIO(i,f) (((i)<<8) + ((500+(f)*(1<<8))/1000))
+
+
+static const union tas_biquad_t
+tas3004_eq_unity={
+	buf: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 }
+};
+
+
+static const struct tas_drce_t
+tas3004_drce_min={
+	enable:		1,
+	above:		{ val: MAKE_RATIO(16,0),	expand:0 },
+	below:		{ val: MAKE_RATIO(2,0),		expand:0 },
+	threshold:	-0x59a0,
+	energy:		MAKE_TIME(0,  1700),
+	attack:		MAKE_TIME(0,  1700),
+	decay:		MAKE_TIME(0,  1700)
+};
+
+
+static const struct tas_drce_t
+tas3004_drce_max={
+	enable:		1,
+	above:		{ val: MAKE_RATIO(1,500),	expand:1 },
+	below:		{ val: MAKE_RATIO(2,0),		expand:1 },
+	threshold:	-0x0,
+	energy:		MAKE_TIME(2,400000),
+	attack:		MAKE_TIME(2,400000),
+	decay:		MAKE_TIME(2,400000)
+};
+
+
+static const unsigned short time_constants[]={
+	MAKE_TIME(0,  1700),
+	MAKE_TIME(0,  3500),
+	MAKE_TIME(0,  6700),
+	MAKE_TIME(0, 13000),
+	MAKE_TIME(0, 26000),
+	MAKE_TIME(0, 53000),
+	MAKE_TIME(0,106000),
+	MAKE_TIME(0,212000),
+	MAKE_TIME(0,425000),
+	MAKE_TIME(0,850000),
+	MAKE_TIME(1,700000),
+	MAKE_TIME(2,400000),
+};
+
+static const unsigned short above_threshold_compression_ratio[]={
+	MAKE_RATIO( 1, 70),
+	MAKE_RATIO( 1,140),
+	MAKE_RATIO( 1,230),
+	MAKE_RATIO( 1,330),
+	MAKE_RATIO( 1,450),
+	MAKE_RATIO( 1,600),
+	MAKE_RATIO( 1,780),
+	MAKE_RATIO( 2,  0),
+	MAKE_RATIO( 2,290),
+	MAKE_RATIO( 2,670),
+	MAKE_RATIO( 3,200),
+	MAKE_RATIO( 4,  0),
+	MAKE_RATIO( 5,330),
+	MAKE_RATIO( 8,  0),
+	MAKE_RATIO(16,  0),
+};
+
+static const unsigned short above_threshold_expansion_ratio[]={
+	MAKE_RATIO(1, 60),
+	MAKE_RATIO(1,130),
+	MAKE_RATIO(1,190),
+	MAKE_RATIO(1,250),
+	MAKE_RATIO(1,310),
+	MAKE_RATIO(1,380),
+	MAKE_RATIO(1,440),
+	MAKE_RATIO(1,500)
+};
+
+static const unsigned short below_threshold_compression_ratio[]={
+	MAKE_RATIO(1, 70),
+	MAKE_RATIO(1,140),
+	MAKE_RATIO(1,230),
+	MAKE_RATIO(1,330),
+	MAKE_RATIO(1,450),
+	MAKE_RATIO(1,600),
+	MAKE_RATIO(1,780),
+	MAKE_RATIO(2,  0)
+};
+
+static const unsigned short below_threshold_expansion_ratio[]={
+	MAKE_RATIO(1, 60),
+	MAKE_RATIO(1,130),
+	MAKE_RATIO(1,190),
+	MAKE_RATIO(1,250),
+	MAKE_RATIO(1,310),
+	MAKE_RATIO(1,380),
+	MAKE_RATIO(1,440),
+	MAKE_RATIO(1,500),
+	MAKE_RATIO(1,560),
+	MAKE_RATIO(1,630),
+	MAKE_RATIO(1,690),
+	MAKE_RATIO(1,750),
+	MAKE_RATIO(1,810),
+	MAKE_RATIO(1,880),
+	MAKE_RATIO(1,940),
+	MAKE_RATIO(2,  0)
+};
+
+static inline int
+search(	unsigned short val,
+	const unsigned short *arr,
+	const int arrsize) {
+	/*
+	 * This could be a binary search, but for small tables,
+	 * a linear search is likely to be faster
+	 */
+
+	int i;
+
+	for (i=0; i < arrsize; i++)
+		if (arr[i] >= val)
+			goto _1;
+	return arrsize-1;
+ _1:
+	if (i == 0)
+		return 0;
+	return (arr[i]-val < val-arr[i-1]) ? i : i-1;
+}
+
+#define SEARCH(a, b) search(a, b, ARRAY_SIZE(b))
+
+static inline int
+time_index(unsigned short time) {
+	return SEARCH(time, time_constants);
+}
+
+
+static inline int
+above_threshold_compression_index(unsigned short ratio) {
+	return SEARCH(ratio, above_threshold_compression_ratio);
+}
+
+
+static inline int
+above_threshold_expansion_index(unsigned short ratio) {
+	return SEARCH(ratio, above_threshold_expansion_ratio);
+}
+
+
+static inline int
+below_threshold_compression_index(unsigned short ratio) {
+	return SEARCH(ratio, below_threshold_compression_ratio);
+}
+
+
+static inline int
+below_threshold_expansion_index(unsigned short ratio) {
+	return SEARCH(ratio, below_threshold_expansion_ratio);
+}
+
+
+static inline unsigned char db_to_regval(short db) {
+	int r=0;
+
+	r=(db+0x59a0) / 0x60;
+
+	if (r < 0x91) return 0x91;
+	if (r > 0xef) return 0xef;
+	return r;
+}
+
+
+static inline short quantize_db(short db) {
+	return db_to_regval(db) * 0x60 - 0x59a0;
+}
+
+
+static inline int
+register_width(enum tas3004_reg_t r)
+{
+	switch(r) {
+	case TAS3004_REG_MCR:
+ 	case TAS3004_REG_TREBLE:
+	case TAS3004_REG_BASS:
+	case TAS3004_REG_ANALOG_CTRL:
+	case TAS3004_REG_TEST1:
+	case TAS3004_REG_TEST2:
+	case TAS3004_REG_MCR2:
+		return 1;
+
+	case TAS3004_REG_LEFT_LOUD_BIQUAD_GAIN:
+	case TAS3004_REG_RIGHT_LOUD_BIQUAD_GAIN:
+		return 3;
+
+	case TAS3004_REG_DRC:
+	case TAS3004_REG_VOLUME:
+		return 6;
+
+	case TAS3004_REG_LEFT_MIXER:
+	case TAS3004_REG_RIGHT_MIXER:
+		return 9;
+
+	case TAS3004_REG_TEST:
+		return 10;
+
+	case TAS3004_REG_LEFT_BIQUAD0:
+	case TAS3004_REG_LEFT_BIQUAD1:
+	case TAS3004_REG_LEFT_BIQUAD2:
+	case TAS3004_REG_LEFT_BIQUAD3:
+	case TAS3004_REG_LEFT_BIQUAD4:
+	case TAS3004_REG_LEFT_BIQUAD5:
+	case TAS3004_REG_LEFT_BIQUAD6:
+
+	case TAS3004_REG_RIGHT_BIQUAD0:
+	case TAS3004_REG_RIGHT_BIQUAD1:
+	case TAS3004_REG_RIGHT_BIQUAD2:
+	case TAS3004_REG_RIGHT_BIQUAD3:
+	case TAS3004_REG_RIGHT_BIQUAD4:
+	case TAS3004_REG_RIGHT_BIQUAD5:
+	case TAS3004_REG_RIGHT_BIQUAD6:
+
+	case TAS3004_REG_LEFT_LOUD_BIQUAD:
+	case TAS3004_REG_RIGHT_LOUD_BIQUAD:
+		return 15;
+
+	default:
+		return 0;
+	}
+}
+
+
+static int
+tas3004_write_register(	struct tas3004_data_t *self,
+			enum tas3004_reg_t reg_num,
+			char *data,
+			uint write_mode)
+{
+	if (reg_num==TAS3004_REG_MCR ||
+	    reg_num==TAS3004_REG_BASS ||
+	    reg_num==TAS3004_REG_TREBLE) {
+		return tas_write_byte_register(&self->super,
+					       (uint)reg_num,
+					       *data,
+					       write_mode);
+	} else {
+		return tas_write_register(&self->super,
+					  (uint)reg_num,
+					  register_width(reg_num),
+					  data,
+					  write_mode);
+	}
+}
+
+
+static int
+tas3004_sync_register(	struct tas3004_data_t *self,
+			enum tas3004_reg_t reg_num)
+{
+	if (reg_num==TAS3004_REG_MCR ||
+	    reg_num==TAS3004_REG_BASS ||
+	    reg_num==TAS3004_REG_TREBLE) {
+		return tas_sync_byte_register(&self->super,
+					      (uint)reg_num,
+					      register_width(reg_num));
+	} else {
+		return tas_sync_register(&self->super,
+					 (uint)reg_num,
+					 register_width(reg_num));
+	}
+}
+
+
+static int
+tas3004_read_register(	struct tas3004_data_t *self,
+			enum tas3004_reg_t reg_num,
+			char *data,
+			uint write_mode)
+{
+	return tas_read_register(&self->super,
+				 (uint)reg_num,
+				 register_width(reg_num),
+				 data);
+}
+
+
+static inline int
+tas3004_fast_load(struct tas3004_data_t *self, int fast)
+{
+	if (fast)
+		self->super.shadow[TAS3004_REG_MCR][0] |= 0x80;
+	else
+		self->super.shadow[TAS3004_REG_MCR][0] &= 0x7f;
+	return tas3004_sync_register(self,TAS3004_REG_MCR);
+}
+
+
+static uint
+tas3004_supported_mixers(struct tas3004_data_t *self)
+{
+	return SOUND_MASK_VOLUME |
+		SOUND_MASK_PCM |
+		SOUND_MASK_ALTPCM |
+		SOUND_MASK_IMIX |
+		SOUND_MASK_TREBLE |
+		SOUND_MASK_BASS;
+}
+
+
+static int
+tas3004_mixer_is_stereo(struct tas3004_data_t *self, int mixer)
+{
+	switch(mixer) {
+	case SOUND_MIXER_VOLUME:
+	case SOUND_MIXER_PCM:
+	case SOUND_MIXER_ALTPCM:
+	case SOUND_MIXER_IMIX:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+
+static uint
+tas3004_stereo_mixers(struct tas3004_data_t *self)
+{
+	uint r = tas3004_supported_mixers(self);
+	uint i;
+	
+	for (i=1; i<SOUND_MIXER_NRDEVICES; i++)
+		if (r&(1<<i) && !tas3004_mixer_is_stereo(self,i))
+			r &= ~(1<<i);
+	return r;
+}
+
+
+static int
+tas3004_get_mixer_level(struct tas3004_data_t *self, int mixer, uint *level)
+{
+	if (!self)
+		return -1;
+
+	*level = self->super.mixer[mixer];
+
+	return 0;
+}
+
+
+static int
+tas3004_set_mixer_level(struct tas3004_data_t *self, int mixer, uint level)
+{
+	int rc;
+	tas_shadow_t *shadow;
+	uint temp;
+	uint offset=0;
+
+	if (!self)
+		return -1;
+
+	shadow = self->super.shadow;
+
+	if (!tas3004_mixer_is_stereo(self,mixer))
+		level = tas_mono_to_stereo(level);
+	switch(mixer) {
+	case SOUND_MIXER_VOLUME:
+		temp = tas3004_gain.master[level&0xff];
+		SET_4_20(shadow[TAS3004_REG_VOLUME], 0, temp);
+		temp = tas3004_gain.master[(level>>8)&0xff];
+		SET_4_20(shadow[TAS3004_REG_VOLUME], 3, temp);
+		rc = tas3004_sync_register(self,TAS3004_REG_VOLUME);
+		break;
+	case SOUND_MIXER_IMIX:
+		offset += 3;
+	case SOUND_MIXER_ALTPCM:
+		offset += 3;
+	case SOUND_MIXER_PCM:
+		/*
+		 * Don't load these in fast mode. The documentation
+		 * says it can be done in either mode, but testing it
+		 * shows that fast mode produces ugly clicking.
+		*/
+		/* tas3004_fast_load(self,1); */
+		temp = tas3004_gain.mixer[level&0xff];
+		SET_4_20(shadow[TAS3004_REG_LEFT_MIXER], offset, temp);
+		temp = tas3004_gain.mixer[(level>>8)&0xff];
+		SET_4_20(shadow[TAS3004_REG_RIGHT_MIXER], offset, temp);
+		rc = tas3004_sync_register(self,TAS3004_REG_LEFT_MIXER);
+		if (rc == 0)
+			rc=tas3004_sync_register(self,TAS3004_REG_RIGHT_MIXER);
+		/* tas3004_fast_load(self,0); */
+		break;
+	case SOUND_MIXER_TREBLE:
+		temp = tas3004_gain.treble[level&0xff];
+		shadow[TAS3004_REG_TREBLE][0]=temp&0xff;
+		rc = tas3004_sync_register(self,TAS3004_REG_TREBLE);
+		break;
+	case SOUND_MIXER_BASS:
+		temp = tas3004_gain.bass[level&0xff];
+		shadow[TAS3004_REG_BASS][0]=temp&0xff;
+		rc = tas3004_sync_register(self,TAS3004_REG_BASS);
+		break;
+	default:
+		rc = -1;
+		break;
+	}
+	if (rc < 0)
+		return rc;
+	self->super.mixer[mixer] = level;
+	
+	return 0;
+}
+
+
+static int
+tas3004_leave_sleep(struct tas3004_data_t *self)
+{
+	unsigned char mcr = (1<<6)+(2<<4)+(2<<2);
+
+	if (!self)
+		return -1;
+
+	/* Make sure something answers on the i2c bus */
+	if (tas3004_write_register(self, TAS3004_REG_MCR, &mcr,
+	    WRITE_NORMAL | FORCE_WRITE) < 0)
+		return -1;
+
+	tas3004_fast_load(self, 1);
+
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD0);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD1);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD2);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD3);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD4);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD5);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD6);
+
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD0);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD1);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD2);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD3);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD4);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD5);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD6);
+
+	tas3004_fast_load(self, 0);
+
+	(void)tas3004_sync_register(self,TAS3004_REG_VOLUME);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_MIXER);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_MIXER);
+	(void)tas3004_sync_register(self,TAS3004_REG_TREBLE);
+	(void)tas3004_sync_register(self,TAS3004_REG_BASS);
+
+	return 0;
+}
+
+
+static int
+tas3004_enter_sleep(struct tas3004_data_t *self)
+{
+	if (!self)
+		return -1; 
+	return 0;
+}
+
+
+static int
+tas3004_sync_biquad(	struct tas3004_data_t *self,
+			u_int channel,
+			u_int filter)
+{
+	enum tas3004_reg_t reg;
+
+	if (channel >= TAS3004_BIQUAD_CHANNEL_COUNT ||
+	    filter  >= TAS3004_BIQUAD_FILTER_COUNT) return -EINVAL;
+
+	reg=( channel ? TAS3004_REG_RIGHT_BIQUAD0 : TAS3004_REG_LEFT_BIQUAD0 ) + filter;
+
+	return tas3004_sync_register(self,reg);
+}
+
+
+static int
+tas3004_write_biquad_shadow(	struct tas3004_data_t *self,
+				u_int channel,
+				u_int filter,
+				const union tas_biquad_t *biquad)
+{
+	tas_shadow_t *shadow=self->super.shadow;
+	enum tas3004_reg_t reg;
+
+	if (channel >= TAS3004_BIQUAD_CHANNEL_COUNT ||
+	    filter  >= TAS3004_BIQUAD_FILTER_COUNT) return -EINVAL;
+
+	reg=( channel ? TAS3004_REG_RIGHT_BIQUAD0 : TAS3004_REG_LEFT_BIQUAD0 ) + filter;
+
+	SET_4_20(shadow[reg], 0,biquad->coeff.b0);
+	SET_4_20(shadow[reg], 3,biquad->coeff.b1);
+	SET_4_20(shadow[reg], 6,biquad->coeff.b2);
+	SET_4_20(shadow[reg], 9,biquad->coeff.a1);
+	SET_4_20(shadow[reg],12,biquad->coeff.a2);
+
+	return 0;
+}
+
+
+static int
+tas3004_write_biquad(	struct tas3004_data_t *self,
+			u_int channel,
+			u_int filter,
+			const union tas_biquad_t *biquad)
+{
+	int rc;
+
+	rc=tas3004_write_biquad_shadow(self, channel, filter, biquad);
+	if (rc < 0) return rc;
+
+	return tas3004_sync_biquad(self, channel, filter);
+}
+
+
+static int
+tas3004_write_biquad_list(	struct tas3004_data_t *self,
+				u_int filter_count,
+				u_int flags,
+				struct tas_biquad_ctrl_t *biquads)
+{
+	int i;
+	int rc;
+
+	if (flags & TAS_BIQUAD_FAST_LOAD) tas3004_fast_load(self,1);
+
+	for (i=0; i<filter_count; i++) {
+		rc=tas3004_write_biquad(self,
+					biquads[i].channel,
+					biquads[i].filter,
+					&biquads[i].data);
+		if (rc < 0) break;
+	}
+
+	if (flags & TAS_BIQUAD_FAST_LOAD) tas3004_fast_load(self,0);
+
+	return rc;
+}
+
+
+static int
+tas3004_read_biquad(	struct tas3004_data_t *self,
+			u_int channel,
+			u_int filter,
+			union tas_biquad_t *biquad)
+{
+	tas_shadow_t *shadow=self->super.shadow;
+	enum tas3004_reg_t reg;
+
+	if (channel >= TAS3004_BIQUAD_CHANNEL_COUNT ||
+	    filter  >= TAS3004_BIQUAD_FILTER_COUNT) return -EINVAL;
+
+	reg=( channel ? TAS3004_REG_RIGHT_BIQUAD0 : TAS3004_REG_LEFT_BIQUAD0 ) + filter;
+
+	biquad->coeff.b0=GET_4_20(shadow[reg], 0);
+	biquad->coeff.b1=GET_4_20(shadow[reg], 3);
+	biquad->coeff.b2=GET_4_20(shadow[reg], 6);
+	biquad->coeff.a1=GET_4_20(shadow[reg], 9);
+	biquad->coeff.a2=GET_4_20(shadow[reg],12);
+	
+	return 0;	
+}
+
+
+static int
+tas3004_eq_rw(	struct tas3004_data_t *self,
+		u_int cmd,
+		u_long arg)
+{
+	int rc;
+	struct tas_biquad_ctrl_t biquad;
+
+	if (copy_from_user((void *)&biquad, (const void *)arg, sizeof(struct tas_biquad_ctrl_t))) {
+		return -EFAULT;
+	}
+
+	if (cmd & SIOC_IN) {
+		rc=tas3004_write_biquad(self, biquad.channel, biquad.filter, &biquad.data);
+		if (rc != 0) return rc;
+	}
+
+	if (cmd & SIOC_OUT) {
+		rc=tas3004_read_biquad(self, biquad.channel, biquad.filter, &biquad.data);
+		if (rc != 0) return rc;
+
+		if (copy_to_user((void *)arg, (const void *)&biquad, sizeof(struct tas_biquad_ctrl_t))) {
+			return -EFAULT;
+		}
+
+	}
+	return 0;
+}
+
+
+static int
+tas3004_eq_list_rw(	struct tas3004_data_t *self,
+			u_int cmd,
+			u_long arg)
+{
+	int rc = 0;
+	int filter_count;
+	int flags;
+	int i,j;
+	char sync_required[TAS3004_BIQUAD_CHANNEL_COUNT][TAS3004_BIQUAD_FILTER_COUNT];
+	struct tas_biquad_ctrl_t biquad;
+
+	memset(sync_required,0,sizeof(sync_required));
+
+	if (copy_from_user((void *)&filter_count,
+			   (const void *)arg + offsetof(struct tas_biquad_ctrl_list_t,filter_count),
+			   sizeof(int))) {
+		return -EFAULT;
+	}
+
+	if (copy_from_user((void *)&flags,
+			   (const void *)arg + offsetof(struct tas_biquad_ctrl_list_t,flags),
+			   sizeof(int))) {
+		return -EFAULT;
+	}
+
+	if (cmd & SIOC_IN) {
+	}
+
+	for (i=0; i < filter_count; i++) {
+		if (copy_from_user((void *)&biquad,
+				   (const void *)arg + offsetof(struct tas_biquad_ctrl_list_t, biquads[i]),
+				   sizeof(struct tas_biquad_ctrl_t))) {
+			return -EFAULT;
+		}
+
+		if (cmd & SIOC_IN) {
+			sync_required[biquad.channel][biquad.filter]=1;
+			rc=tas3004_write_biquad_shadow(self, biquad.channel, biquad.filter, &biquad.data);
+			if (rc != 0) return rc;
+		}
+
+		if (cmd & SIOC_OUT) {
+			rc=tas3004_read_biquad(self, biquad.channel, biquad.filter, &biquad.data);
+			if (rc != 0) return rc;
+
+			if (copy_to_user((void *)arg + offsetof(struct tas_biquad_ctrl_list_t, biquads[i]),
+					 (const void *)&biquad,
+					 sizeof(struct tas_biquad_ctrl_t))) {
+				return -EFAULT;
+			}
+		}
+	}
+
+	if (cmd & SIOC_IN) {
+		/*
+		 * This is OK for the tas3004. For the
+		 * tas3001c, going into fast load mode causes
+		 * the treble and bass to be reset to 0dB, and
+		 * volume controls to be muted.
+		 */
+		if (flags & TAS_BIQUAD_FAST_LOAD) tas3004_fast_load(self,1);
+		for (i=0; i<TAS3004_BIQUAD_CHANNEL_COUNT; i++) {
+			for (j=0; j<TAS3004_BIQUAD_FILTER_COUNT; j++) {
+				if (sync_required[i][j]) {
+					rc=tas3004_sync_biquad(self, i, j);
+					if (rc < 0) goto out;
+				}
+			}
+		}
+	out:
+		if (flags & TAS_BIQUAD_FAST_LOAD)
+			tas3004_fast_load(self,0);
+	}
+
+	return rc;
+}
+
+
+static int
+tas3004_update_drce(	struct tas3004_data_t *self,
+			int flags,
+			struct tas_drce_t *drce)
+{
+	tas_shadow_t *shadow;
+	int i;
+	shadow=self->super.shadow;
+
+	if (flags & TAS_DRCE_ABOVE_RATIO) {
+		self->drce_state.above.expand = drce->above.expand;
+		if (drce->above.val == (1<<8)) {
+			self->drce_state.above.val = 1<<8;
+			shadow[TAS3004_REG_DRC][0] = 0x02;
+					
+		} else if (drce->above.expand) {
+			i=above_threshold_expansion_index(drce->above.val);
+			self->drce_state.above.val=above_threshold_expansion_ratio[i];
+			shadow[TAS3004_REG_DRC][0] = 0x0a + (i<<3);
+		} else {
+			i=above_threshold_compression_index(drce->above.val);
+			self->drce_state.above.val=above_threshold_compression_ratio[i];
+			shadow[TAS3004_REG_DRC][0] = 0x08 + (i<<3);
+		}
+	}
+
+	if (flags & TAS_DRCE_BELOW_RATIO) {
+		self->drce_state.below.expand = drce->below.expand;
+		if (drce->below.val == (1<<8)) {
+			self->drce_state.below.val = 1<<8;
+			shadow[TAS3004_REG_DRC][1] = 0x02;
+					
+		} else if (drce->below.expand) {
+			i=below_threshold_expansion_index(drce->below.val);
+			self->drce_state.below.val=below_threshold_expansion_ratio[i];
+			shadow[TAS3004_REG_DRC][1] = 0x08 + (i<<3);
+		} else {
+			i=below_threshold_compression_index(drce->below.val);
+			self->drce_state.below.val=below_threshold_compression_ratio[i];
+			shadow[TAS3004_REG_DRC][1] = 0x0a + (i<<3);
+		}
+	}
+
+	if (flags & TAS_DRCE_THRESHOLD) {
+		self->drce_state.threshold=quantize_db(drce->threshold);
+		shadow[TAS3004_REG_DRC][2] = db_to_regval(self->drce_state.threshold);
+	}
+
+	if (flags & TAS_DRCE_ENERGY) {
+		i=time_index(drce->energy);
+		self->drce_state.energy=time_constants[i];
+		shadow[TAS3004_REG_DRC][3] = 0x40 + (i<<4);
+	}
+
+	if (flags & TAS_DRCE_ATTACK) {
+		i=time_index(drce->attack);
+		self->drce_state.attack=time_constants[i];
+		shadow[TAS3004_REG_DRC][4] = 0x40 + (i<<4);
+	}
+
+	if (flags & TAS_DRCE_DECAY) {
+		i=time_index(drce->decay);
+		self->drce_state.decay=time_constants[i];
+		shadow[TAS3004_REG_DRC][5] = 0x40 + (i<<4);
+	}
+
+	if (flags & TAS_DRCE_ENABLE) {
+		self->drce_state.enable = drce->enable;
+	}
+
+	if (!self->drce_state.enable) {
+		shadow[TAS3004_REG_DRC][0] |= 0x01;
+	}
+
+#ifdef DEBUG_DRCE
+	printk("DRCE: set [ ENABLE:%x ABOVE:%x/%x BELOW:%x/%x THRESH:%x ENERGY:%x ATTACK:%x DECAY:%x\n",
+	       self->drce_state.enable,
+	       self->drce_state.above.expand,self->drce_state.above.val,
+	       self->drce_state.below.expand,self->drce_state.below.val,
+	       self->drce_state.threshold,
+	       self->drce_state.energy,
+	       self->drce_state.attack,
+	       self->drce_state.decay);
+
+	printk("DRCE: reg [ %02x %02x %02x %02x %02x %02x ]\n",
+	       (unsigned char)shadow[TAS3004_REG_DRC][0],
+	       (unsigned char)shadow[TAS3004_REG_DRC][1],
+	       (unsigned char)shadow[TAS3004_REG_DRC][2],
+	       (unsigned char)shadow[TAS3004_REG_DRC][3],
+	       (unsigned char)shadow[TAS3004_REG_DRC][4],
+	       (unsigned char)shadow[TAS3004_REG_DRC][5]);
+#endif
+
+	return tas3004_sync_register(self, TAS3004_REG_DRC);
+}
+
+
+static int
+tas3004_drce_rw(	struct tas3004_data_t *self,
+			u_int cmd,
+			u_long arg)
+{
+	int rc;
+	struct tas_drce_ctrl_t drce_ctrl;
+
+	if (copy_from_user((void *)&drce_ctrl,
+			   (const void *)arg,
+			   sizeof(struct tas_drce_ctrl_t))) {
+		return -EFAULT;
+	}
+
+#ifdef DEBUG_DRCE
+	printk("DRCE: input [ FLAGS:%x ENABLE:%x ABOVE:%x/%x BELOW:%x/%x THRESH:%x ENERGY:%x ATTACK:%x DECAY:%x\n",
+	       drce_ctrl.flags,
+	       drce_ctrl.data.enable,
+	       drce_ctrl.data.above.expand,drce_ctrl.data.above.val,
+	       drce_ctrl.data.below.expand,drce_ctrl.data.below.val,
+	       drce_ctrl.data.threshold,
+	       drce_ctrl.data.energy,
+	       drce_ctrl.data.attack,
+	       drce_ctrl.data.decay);
+#endif
+
+	if (cmd & SIOC_IN) {
+		rc = tas3004_update_drce(self, drce_ctrl.flags, &drce_ctrl.data);
+		if (rc < 0) return rc;
+	}
+
+	if (cmd & SIOC_OUT) {
+		if (drce_ctrl.flags & TAS_DRCE_ENABLE)
+			drce_ctrl.data.enable = self->drce_state.enable;
+		if (drce_ctrl.flags & TAS_DRCE_ABOVE_RATIO)
+			drce_ctrl.data.above = self->drce_state.above;
+		if (drce_ctrl.flags & TAS_DRCE_BELOW_RATIO)
+			drce_ctrl.data.below = self->drce_state.below;
+		if (drce_ctrl.flags & TAS_DRCE_THRESHOLD)
+			drce_ctrl.data.threshold = self->drce_state.threshold;
+		if (drce_ctrl.flags & TAS_DRCE_ENERGY)
+			drce_ctrl.data.energy = self->drce_state.energy;
+		if (drce_ctrl.flags & TAS_DRCE_ATTACK)
+			drce_ctrl.data.attack = self->drce_state.attack;
+		if (drce_ctrl.flags & TAS_DRCE_DECAY)
+			drce_ctrl.data.decay = self->drce_state.decay;
+
+		if (copy_to_user((void *)arg,
+				 (const void *)&drce_ctrl,
+				 sizeof(struct tas_drce_ctrl_t))) {
+			return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+
+static void
+tas3004_update_device_parameters(struct tas3004_data_t *self)
+{
+	char data;
+	int i;
+
+	if (!self) return;
+
+	if (self->output_id == TAS_OUTPUT_HEADPHONES) {
+		/* turn on allPass when headphones are plugged in */
+		data = 0x02;
+	} else {
+		data = 0x00;
+	}
+
+	tas3004_write_register(self, TAS3004_REG_MCR2, &data, WRITE_NORMAL | FORCE_WRITE);
+
+	for (i=0; tas3004_eq_prefs[i]; i++) {
+		struct tas_eq_pref_t *eq = tas3004_eq_prefs[i];
+
+		if (eq->device_id == self->device_id &&
+		    (eq->output_id == 0 || eq->output_id == self->output_id) &&
+		    (eq->speaker_id == 0 || eq->speaker_id == self->speaker_id)) {
+
+			tas3004_update_drce(self, TAS_DRCE_ALL, eq->drce);
+			tas3004_write_biquad_list(self, eq->filter_count, TAS_BIQUAD_FAST_LOAD, eq->biquads);
+
+			break;
+		}
+	}
+}
+
+static void
+tas3004_device_change_handler(void *self)
+{
+	if (!self) return;
+
+	tas3004_update_device_parameters((struct tas3004_data_t *)self);
+}
+
+static struct tq_struct device_change_task;
+
+static int
+tas3004_output_device_change(	struct tas3004_data_t *self,
+				int device_id,
+				int output_id,
+				int speaker_id)
+{
+	self->device_id=device_id;
+	self->output_id=output_id;
+	self->speaker_id=speaker_id;
+
+	schedule_task(&device_change_task);
+
+	return 0;
+}
+
+
+static int
+tas3004_device_ioctl(	struct tas3004_data_t *self,
+			u_int cmd,
+			u_long arg)
+{
+	switch (cmd) {
+	case TAS_READ_EQ:
+	case TAS_WRITE_EQ:
+		return tas3004_eq_rw(self, cmd, arg);
+
+	case TAS_READ_EQ_LIST:
+	case TAS_WRITE_EQ_LIST:
+		return tas3004_eq_list_rw(self, cmd, arg);
+
+	case TAS_READ_EQ_FILTER_COUNT:
+		put_user(TAS3004_BIQUAD_FILTER_COUNT, (uint *)(arg));
+		return 0;
+
+	case TAS_READ_EQ_CHANNEL_COUNT:
+		put_user(TAS3004_BIQUAD_CHANNEL_COUNT, (uint *)(arg));
+		return 0;
+
+	case TAS_READ_DRCE:
+	case TAS_WRITE_DRCE:
+		return tas3004_drce_rw(self, cmd, arg);
+
+	case TAS_READ_DRCE_CAPS:
+		put_user(TAS_DRCE_ENABLE         |
+			 TAS_DRCE_ABOVE_RATIO    |
+			 TAS_DRCE_BELOW_RATIO    |
+			 TAS_DRCE_THRESHOLD      |
+			 TAS_DRCE_ENERGY         |
+			 TAS_DRCE_ATTACK         |
+			 TAS_DRCE_DECAY,
+			 (uint *)(arg));
+		return 0;
+
+	case TAS_READ_DRCE_MIN:
+	case TAS_READ_DRCE_MAX: {
+		struct tas_drce_ctrl_t drce_ctrl;
+		const struct tas_drce_t *drce_copy;
+
+		if (copy_from_user((void *)&drce_ctrl,
+				   (const void *)arg,
+				   sizeof(struct tas_drce_ctrl_t))) {
+			return -EFAULT;
+		}
+
+		if (cmd == TAS_READ_DRCE_MIN) {
+			drce_copy=&tas3004_drce_min;
+		} else {
+			drce_copy=&tas3004_drce_max;
+		}
+
+		if (drce_ctrl.flags & TAS_DRCE_ABOVE_RATIO) {
+			drce_ctrl.data.above=drce_copy->above;
+		}
+		if (drce_ctrl.flags & TAS_DRCE_BELOW_RATIO) {
+			drce_ctrl.data.below=drce_copy->below;
+		}
+		if (drce_ctrl.flags & TAS_DRCE_THRESHOLD) {
+			drce_ctrl.data.threshold=drce_copy->threshold;
+		}
+		if (drce_ctrl.flags & TAS_DRCE_ENERGY) {
+			drce_ctrl.data.energy=drce_copy->energy;
+		}
+		if (drce_ctrl.flags & TAS_DRCE_ATTACK) {
+			drce_ctrl.data.attack=drce_copy->attack;
+		}
+		if (drce_ctrl.flags & TAS_DRCE_DECAY) {
+			drce_ctrl.data.decay=drce_copy->decay;
+		}
+
+		if (copy_to_user((void *)arg,
+				 (const void *)&drce_ctrl,
+				 sizeof(struct tas_drce_ctrl_t))) {
+			return -EFAULT;
+		}
+	}
+	}
+
+	return -EINVAL;
+}
+
+
+static int
+tas3004_init_mixer(struct tas3004_data_t *self)
+{
+	unsigned char mcr = (1<<6)+(2<<4)+(2<<2);
+
+	/* Make sure something answers on the i2c bus */
+	if (tas3004_write_register(self, TAS3004_REG_MCR, &mcr,
+	    WRITE_NORMAL | FORCE_WRITE) < 0)
+		return -1;
+
+	tas3004_fast_load(self, 1);
+
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD0);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD1);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD2);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD3);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD4);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD5);
+	(void)tas3004_sync_register(self,TAS3004_REG_RIGHT_BIQUAD6);
+
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD0);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD1);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD2);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD3);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD4);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD5);
+	(void)tas3004_sync_register(self,TAS3004_REG_LEFT_BIQUAD6);
+
+	tas3004_sync_register(self, TAS3004_REG_DRC);
+
+	tas3004_sync_register(self, TAS3004_REG_MCR2);
+
+	tas3004_fast_load(self, 0);
+
+	tas3004_set_mixer_level(self, SOUND_MIXER_VOLUME, VOL_DEFAULT<<8 | VOL_DEFAULT);
+	tas3004_set_mixer_level(self, SOUND_MIXER_PCM, INPUT_DEFAULT<<8 | INPUT_DEFAULT);
+	tas3004_set_mixer_level(self, SOUND_MIXER_ALTPCM, 0);
+	tas3004_set_mixer_level(self, SOUND_MIXER_IMIX, 0);
+
+	tas3004_set_mixer_level(self, SOUND_MIXER_BASS, BASS_DEFAULT);
+	tas3004_set_mixer_level(self, SOUND_MIXER_TREBLE, TREBLE_DEFAULT);
+
+	return 0;
+}
+
+
+static int
+tas3004_uninit_mixer(struct tas3004_data_t *self)
+{
+	tas3004_set_mixer_level(self, SOUND_MIXER_VOLUME, 0);
+	tas3004_set_mixer_level(self, SOUND_MIXER_PCM, 0);
+	tas3004_set_mixer_level(self, SOUND_MIXER_ALTPCM, 0);
+	tas3004_set_mixer_level(self, SOUND_MIXER_IMIX, 0);
+
+	tas3004_set_mixer_level(self, SOUND_MIXER_BASS, 0);
+	tas3004_set_mixer_level(self, SOUND_MIXER_TREBLE, 0);
+
+	return 0;
+}
+
+
+static int
+tas3004_init(struct i2c_client *client)
+{
+	char drce_init[]={ 0x69, 0x22, 0x9f, 0xb0, 0x60, 0xa0 };
+	char mcr2 = 0;
+
+	struct tas3004_data_t *self;
+	int i, j;
+
+	self = kmalloc(sizeof(struct tas3004_data_t) +
+			TAS3004_REG_MAX * sizeof(tas_shadow_t),
+			GFP_KERNEL);
+	if (self == NULL)
+		return -ENOMEM;
+
+	memset(self,
+	       0,
+	       sizeof(struct tas3004_data_t) +
+	       TAS3004_REG_MAX * sizeof(tas_shadow_t));
+
+	client->data = (void *)self;
+
+	self->super.client = client;
+	self->super.shadow = (tas_shadow_t *)(self+1);
+
+	self->output_id=TAS_OUTPUT_HEADPHONES;
+	self->device_id=0;
+	self->speaker_id=0;
+
+	for (i=0; i<TAS3004_BIQUAD_CHANNEL_COUNT; i++) {
+		for (j=0; j<TAS3004_BIQUAD_FILTER_COUNT; j++) {
+			tas3004_write_biquad_shadow(self, i, j, &tas3004_eq_unity);
+		}
+	}
+
+	tas3004_write_register(self, TAS3004_REG_MCR2, &mcr2, WRITE_SHADOW);
+	tas3004_write_register(self, TAS3004_REG_DRC, drce_init, WRITE_SHADOW);
+
+	INIT_TQUEUE(&device_change_task, tas3004_device_change_handler, (void *)self);
+
+	return 0;
+}
+
+
+static void 
+tas3004_uninit(struct tas3004_data_t *self)
+{
+	tas3004_uninit_mixer(self);
+	kfree(self);
+}
+
+
+struct tas_driver_hooks_t tas3004_hooks = {
+	init:                   (tas_hook_init_t)tas3004_init,
+	post_init:              (tas_hook_post_init_t)tas3004_init_mixer,
+	uninit:                 (tas_hook_uninit_t)tas3004_uninit,
+
+	get_mixer_level:        (tas_hook_get_mixer_level_t)tas3004_get_mixer_level,
+	set_mixer_level:        (tas_hook_set_mixer_level_t)tas3004_set_mixer_level,
+
+	enter_sleep:            (tas_hook_enter_sleep_t)tas3004_enter_sleep,
+	leave_sleep:            (tas_hook_leave_sleep_t)tas3004_leave_sleep,
+
+	supported_mixers:       (tas_hook_supported_mixers_t)tas3004_supported_mixers,
+	mixer_is_stereo:        (tas_hook_mixer_is_stereo_t)tas3004_mixer_is_stereo,
+	stereo_mixers:          (tas_hook_stereo_mixers_t)tas3004_stereo_mixers,
+
+	output_device_change:   (tas_hook_output_device_change_t)tas3004_output_device_change,
+
+	device_ioctl:           (tas_hook_device_ioctl_t)tas3004_device_ioctl
+};
+
+/*
+ * Local Variables:
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas3004.h kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3004.h
--- kernel-source-2.4.27/drivers/sound/dmasound/tas3004.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3004.h	2004-09-01 20:56:27.795893440 +0200
@@ -0,0 +1,77 @@
+/*
+ * Header file for the i2c/i2s based TA3004 sound chip used
+ * on some Apple hardware. Also known as "tumbler".
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive
+ *  for more details.
+ *
+ * Written by Christopher C. Chimelis <chris@debian.org>
+ */
+
+#ifndef _TAS3004_H_
+#define _TAS3004_H_
+
+#include <linux/types.h>
+
+#include "tas_common.h"
+#include "tas_eq_prefs.h"
+
+/*
+ * Macros that correspond to the registers that we write to
+ * when setting the various values.
+ */
+
+#define TAS3004_VERSION	        "0.3"
+#define TAS3004_DATE	        "20011214"
+
+#define I2C_DRIVERNAME_TAS3004 "TAS3004 driver V " TAS3004_VERSION
+#define I2C_DRIVERID_TAS3004    (I2C_DRIVERID_TAS_BASE+1)
+
+extern  struct tas_driver_hooks_t tas3004_hooks;
+extern struct tas_gain_t tas3004_gain;
+extern struct tas_eq_pref_t *tas3004_eq_prefs[];
+
+enum tas3004_reg_t {
+  TAS3004_REG_MCR                    = 0x01,
+  TAS3004_REG_DRC                    = 0x02,
+
+  TAS3004_REG_VOLUME                 = 0x04,
+  TAS3004_REG_TREBLE                 = 0x05,
+  TAS3004_REG_BASS                   = 0x06,
+  TAS3004_REG_LEFT_MIXER             = 0x07,
+  TAS3004_REG_RIGHT_MIXER            = 0x08,
+
+  TAS3004_REG_LEFT_BIQUAD0           = 0x0a,
+  TAS3004_REG_LEFT_BIQUAD1           = 0x0b,
+  TAS3004_REG_LEFT_BIQUAD2           = 0x0c,
+  TAS3004_REG_LEFT_BIQUAD3           = 0x0d,
+  TAS3004_REG_LEFT_BIQUAD4           = 0x0e,
+  TAS3004_REG_LEFT_BIQUAD5           = 0x0f,
+  TAS3004_REG_LEFT_BIQUAD6           = 0x10,
+  
+  TAS3004_REG_RIGHT_BIQUAD0          = 0x13,
+  TAS3004_REG_RIGHT_BIQUAD1          = 0x14,
+  TAS3004_REG_RIGHT_BIQUAD2          = 0x15,
+  TAS3004_REG_RIGHT_BIQUAD3          = 0x16,
+  TAS3004_REG_RIGHT_BIQUAD4          = 0x17,
+  TAS3004_REG_RIGHT_BIQUAD5          = 0x18,
+  TAS3004_REG_RIGHT_BIQUAD6          = 0x19,
+
+  TAS3004_REG_LEFT_LOUD_BIQUAD       = 0x21,
+  TAS3004_REG_RIGHT_LOUD_BIQUAD      = 0x22,
+
+  TAS3004_REG_LEFT_LOUD_BIQUAD_GAIN  = 0x23,
+  TAS3004_REG_RIGHT_LOUD_BIQUAD_GAIN = 0x24,
+
+  TAS3004_REG_TEST                   = 0x29,
+
+  TAS3004_REG_ANALOG_CTRL            = 0x40,
+  TAS3004_REG_TEST1                  = 0x41,
+  TAS3004_REG_TEST2                  = 0x42,
+  TAS3004_REG_MCR2                   = 0x43,
+
+  TAS3004_REG_MAX                    = 0x44
+};
+
+#endif /* _TAS3004_H_ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas3004_tables.c kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3004_tables.c
--- kernel-source-2.4.27/drivers/sound/dmasound/tas3004_tables.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas3004_tables.c	2004-09-01 20:56:27.879880672 +0200
@@ -0,0 +1,301 @@
+#include "tas3004.h"
+#include "tas_eq_prefs.h"
+
+static struct tas_drce_t eqp_17_1_0_drce={
+    enable:    1,
+    above:     { val: 3.0 * (1<<8), expand: 0 },
+    below:     { val: 1.0 * (1<<8), expand: 0 },
+    threshold: -19.12  * (1<<8),
+    energy:    2.4     * (1<<12),
+    attack:    0.013   * (1<<12),
+    decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_17_1_0_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0fd0d4, 0xe05e56, 0x0fd0d4, 0xe05ee1, 0x0fa234 } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x0910d7, 0x088e1a, 0x030651, 0x01dcb1, 0x02c892 } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0ff895, 0xe0970b, 0x0f7f00, 0xe0970b, 0x0f7795 } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0fd1c4, 0xe1ac22, 0x0ec8cf, 0xe1ac22, 0x0e9a94 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x0f7c1c, 0xe3cc03, 0x0df786, 0xe3cc03, 0x0d73a2 } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x11fb92, 0xf5a1a0, 0x073cd2, 0xf5a1a0, 0x093865 } } },
+  { channel: 0, filter: 6, data: { coeff: { 0x0e17a9, 0x068b6c, 0x08a0e5, 0x068b6c, 0x06b88e } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0fd0d4, 0xe05e56, 0x0fd0d4, 0xe05ee1, 0x0fa234 } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x0910d7, 0x088e1a, 0x030651, 0x01dcb1, 0x02c892 } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0ff895, 0xe0970b, 0x0f7f00, 0xe0970b, 0x0f7795 } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0fd1c4, 0xe1ac22, 0x0ec8cf, 0xe1ac22, 0x0e9a94 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x0f7c1c, 0xe3cc03, 0x0df786, 0xe3cc03, 0x0d73a2 } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x11fb92, 0xf5a1a0, 0x073cd2, 0xf5a1a0, 0x093865 } } },
+  { channel: 1, filter: 6, data: { coeff: { 0x0e17a9, 0x068b6c, 0x08a0e5, 0x068b6c, 0x06b88e } } }
+};
+
+static struct tas_eq_pref_t eqp_17_1_0 = {
+  sample_rate:  44100,
+  device_id:    0x17,
+  output_id:    TAS_OUTPUT_INTERNAL_SPKR,
+  speaker_id:   0x00,
+
+  drce:         &eqp_17_1_0_drce,
+
+  filter_count: 14,
+  biquads:      eqp_17_1_0_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_18_1_0_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -13.14  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_18_1_0_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0f5514, 0xe155d7, 0x0f5514, 0xe15cfa, 0x0eb14b } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x06ec33, 0x02abe3, 0x015eef, 0xf764d9, 0x03922d } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0ef5f2, 0xe67d1f, 0x0bcf37, 0xe67d1f, 0x0ac529 } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0db050, 0xe5be4d, 0x0d0c78, 0xe5be4d, 0x0abcc8 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x0f1298, 0xe64ec6, 0x0cc03e, 0xe64ec6, 0x0bd2d7 } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0c641a, 0x06537a, 0x08d155, 0x06537a, 0x053570 } } },
+  { channel: 0, filter: 6, data: { coeff: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0f5514, 0xe155d7, 0x0f5514, 0xe15cfa, 0x0eb14b } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x06ec33, 0x02abe3, 0x015eef, 0xf764d9, 0x03922d } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0ef5f2, 0xe67d1f, 0x0bcf37, 0xe67d1f, 0x0ac529 } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0db050, 0xe5be4d, 0x0d0c78, 0xe5be4d, 0x0abcc8 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x0f1298, 0xe64ec6, 0x0cc03e, 0xe64ec6, 0x0bd2d7 } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0c641a, 0x06537a, 0x08d155, 0x06537a, 0x053570 } } },
+  { channel: 1, filter: 6, data: { coeff: { 0x100000, 0x000000, 0x000000, 0x000000, 0x000000 } } }
+};
+
+static struct tas_eq_pref_t eqp_18_1_0 = {
+  sample_rate:  44100,
+  device_id:    0x18,
+  output_id:    TAS_OUTPUT_INTERNAL_SPKR,
+  speaker_id:   0x00,
+
+  drce:         &eqp_18_1_0_drce,
+
+  filter_count: 14,
+  biquads:      eqp_18_1_0_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_1a_1_0_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -10.75  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_1a_1_0_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0fb8fd, 0xe08e04, 0x0fb8fd, 0xe08f40, 0x0f7336 } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x06371d, 0x0c6e3a, 0x06371d, 0x05bfd3, 0x031ca2 } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0fa1c0, 0xe18692, 0x0f030e, 0xe18692, 0x0ea4ce } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0fe495, 0xe17eff, 0x0f0452, 0xe17eff, 0x0ee8e7 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x100857, 0xe7e71c, 0x0e9599, 0xe7e71c, 0x0e9df1 } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0fb26e, 0x06a82c, 0x0db2b4, 0x06a82c, 0x0d6522 } } },
+  { channel: 0, filter: 6, data: { coeff: { 0x11419d, 0xf06cbf, 0x0a4f6e, 0xf06cbf, 0x0b910c } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0fb8fd, 0xe08e04, 0x0fb8fd, 0xe08f40, 0x0f7336 } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x06371d, 0x0c6e3a, 0x06371d, 0x05bfd3, 0x031ca2 } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0fa1c0, 0xe18692, 0x0f030e, 0xe18692, 0x0ea4ce } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0fe495, 0xe17eff, 0x0f0452, 0xe17eff, 0x0ee8e7 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x100857, 0xe7e71c, 0x0e9599, 0xe7e71c, 0x0e9df1 } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0fb26e, 0x06a82c, 0x0db2b4, 0x06a82c, 0x0d6522 } } },
+  { channel: 1, filter: 6, data: { coeff: { 0x11419d, 0xf06cbf, 0x0a4f6e, 0xf06cbf, 0x0b910c } } }
+};
+
+static struct tas_eq_pref_t eqp_1a_1_0 = {
+  sample_rate:  44100,
+  device_id:    0x1a,
+  output_id:    TAS_OUTPUT_INTERNAL_SPKR,
+  speaker_id:   0x00,
+
+  drce:         &eqp_1a_1_0_drce,
+
+  filter_count: 14,
+  biquads:      eqp_1a_1_0_biquads
+};
+
+/* ======================================================================== */
+
+static struct tas_drce_t eqp_1c_1_0_drce={
+  enable:    1,
+  above:     { val: 3.0 * (1<<8), expand: 0 },
+  below:     { val: 1.0 * (1<<8), expand: 0 },
+  threshold: -14.34  * (1<<8),
+  energy:    2.4     * (1<<12),
+  attack:    0.013   * (1<<12),
+  decay:     0.212   * (1<<12),
+};
+
+static struct tas_biquad_ctrl_t eqp_1c_1_0_biquads[]={
+  { channel: 0, filter: 0, data: { coeff: { 0x0f4f95, 0xe160d4, 0x0f4f95, 0xe1686e, 0x0ea6c5 } } },
+  { channel: 0, filter: 1, data: { coeff: { 0x066b92, 0x0290d4, 0x0148a0, 0xf6853f, 0x03bfc7 } } },
+  { channel: 0, filter: 2, data: { coeff: { 0x0f57dc, 0xe51c91, 0x0dd1cb, 0xe51c91, 0x0d29a8 } } },
+  { channel: 0, filter: 3, data: { coeff: { 0x0df1cb, 0xe4fa84, 0x0d7cdc, 0xe4fa84, 0x0b6ea7 } } },
+  { channel: 0, filter: 4, data: { coeff: { 0x0eba36, 0xe6aa48, 0x0b9f52, 0xe6aa48, 0x0a5989 } } },
+  { channel: 0, filter: 5, data: { coeff: { 0x0caf02, 0x05ef9d, 0x084beb, 0x05ef9d, 0x04faee } } },
+  { channel: 0, filter: 6, data: { coeff: { 0x0fc686, 0xe22947, 0x0e4b5d, 0xe22947, 0x0e11e4 } } },
+
+  { channel: 1, filter: 0, data: { coeff: { 0x0f4f95, 0xe160d4, 0x0f4f95, 0xe1686e, 0x0ea6c5 } } },
+  { channel: 1, filter: 1, data: { coeff: { 0x066b92, 0x0290d4, 0x0148a0, 0xf6853f, 0x03bfc7 } } },
+  { channel: 1, filter: 2, data: { coeff: { 0x0f57dc, 0xe51c91, 0x0dd1cb, 0xe51c91, 0x0d29a8 } } },
+  { channel: 1, filter: 3, data: { coeff: { 0x0df1cb, 0xe4fa84, 0x0d7cdc, 0xe4fa84, 0x0b6ea7 } } },
+  { channel: 1, filter: 4, data: { coeff: { 0x0eba36, 0xe6aa48, 0x0b9f52, 0xe6aa48, 0x0a5989 } } },
+  { channel: 1, filter: 5, data: { coeff: { 0x0caf02, 0x05ef9d, 0x084beb, 0x05ef9d, 0x04faee } } },
+  { channel: 1, filter: 6, data: { coeff: { 0x0fc686, 0xe22947, 0x0e4b5d, 0xe22947, 0x0e11e4 } } }
+};
+
+static struct tas_eq_pref_t eqp_1c_1_0 = {
+  sample_rate:  44100,
+  device_id:    0x1c,
+  output_id:    TAS_OUTPUT_INTERNAL_SPKR,
+  speaker_id:   0x00,
+
+  drce:         &eqp_1c_1_0_drce,
+
+  filter_count: 14,
+  biquads:      eqp_1c_1_0_biquads
+};
+
+/* ======================================================================== */
+
+static uint tas3004_master_tab[]={
+	       0x0,       0x75,       0x9c,       0xbb,
+	      0xdb,       0xfb,      0x11e,      0x143,
+	     0x16b,      0x196,      0x1c3,      0x1f5,
+	     0x229,      0x263,      0x29f,      0x2e1,
+	     0x328,      0x373,      0x3c5,      0x41b,
+	     0x478,      0x4dc,      0x547,      0x5b8,
+	     0x633,      0x6b5,      0x740,      0x7d5,
+	     0x873,      0x91c,      0x9d2,      0xa92,
+	     0xb5e,      0xc39,      0xd22,      0xe19,
+	     0xf20,     0x1037,     0x1161,     0x129e,
+	    0x13ed,     0x1551,     0x16ca,     0x185d,
+	    0x1a08,     0x1bcc,     0x1dac,     0x1fa7,
+	    0x21c1,     0x23fa,     0x2655,     0x28d6,
+	    0x2b7c,     0x2e4a,     0x3141,     0x3464,
+	    0x37b4,     0x3b35,     0x3ee9,     0x42d3,
+	    0x46f6,     0x4b53,     0x4ff0,     0x54ce,
+	    0x59f2,     0x5f5f,     0x6519,     0x6b24,
+	    0x7183,     0x783c,     0x7f53,     0x86cc,
+	    0x8ead,     0x96fa,     0x9fba,     0xa8f2,
+	    0xb2a7,     0xbce1,     0xc7a5,     0xd2fa,
+	    0xdee8,     0xeb75,     0xf8aa,    0x1068e,
+	   0x1152a,    0x12487,    0x134ad,    0x145a5,
+	   0x1577b,    0x16a37,    0x17df5,    0x192bd,
+	   0x1a890,    0x1bf7b,    0x1d78d,    0x1f0d1,
+	   0x20b55,    0x22727,    0x24456,    0x262f2,
+	   0x2830b
+};
+
+static uint tas3004_mixer_tab[]={
+	       0x0,      0x748,      0x9be,      0xbaf,
+	     0xda4,      0xfb1,     0x11de,     0x1431,
+	    0x16ad,     0x1959,     0x1c37,     0x1f4b,
+	    0x2298,     0x2628,     0x29fb,     0x2e12,
+	    0x327d,     0x3734,     0x3c47,     0x41b4,
+	    0x4787,     0x4dbe,     0x546d,     0x5b86,
+	    0x632e,     0x6b52,     0x7400,     0x7d54,
+	    0x873b,     0x91c6,     0x9d1a,     0xa920,
+	    0xb5e5,     0xc38c,     0xd21b,     0xe18f,
+	    0xf1f5,    0x1036a,    0x1160f,    0x129d6,
+	   0x13ed0,    0x1550c,    0x16ca0,    0x185c9,
+	   0x1a07b,    0x1bcc3,    0x1dab9,    0x1fa75,
+	   0x21c0f,    0x23fa3,    0x26552,    0x28d64,
+	   0x2b7c9,    0x2e4a2,    0x31411,    0x3463b,
+	   0x37b44,    0x3b353,    0x3ee94,    0x42d30,
+	   0x46f55,    0x4b533,    0x4fefc,    0x54ce5,
+	   0x59f25,    0x5f5f6,    0x65193,    0x6b23c,
+	   0x71835,    0x783c3,    0x7f52c,    0x86cc0,
+	   0x8eacc,    0x96fa5,    0x9fba0,    0xa8f1a,
+	   0xb2a71,    0xbce0a,    0xc7a4a,    0xd2fa0,
+	   0xdee7b,    0xeb752,    0xf8a9f,   0x1068e4,
+	  0x1152a3,   0x12486a,   0x134ac8,   0x145a55,
+	  0x1577ac,   0x16a370,   0x17df51,   0x192bc2,
+	  0x1a88f8,   0x1bf7b7,   0x1d78c9,   0x1f0d04,
+	  0x20b542,   0x227268,   0x244564,   0x262f26,
+	  0x2830af
+};
+
+static uint tas3004_treble_tab[]={
+	      0x96,       0x95,       0x95,       0x94,
+	      0x93,       0x92,       0x92,       0x91,
+	      0x90,       0x90,       0x8f,       0x8e,
+	      0x8d,       0x8d,       0x8c,       0x8b,
+	      0x8a,       0x8a,       0x89,       0x88,
+	      0x88,       0x87,       0x86,       0x85,
+	      0x85,       0x84,       0x83,       0x83,
+	      0x82,       0x81,       0x80,       0x80,
+	      0x7f,       0x7e,       0x7e,       0x7d,
+	      0x7c,       0x7b,       0x7b,       0x7a,
+	      0x79,       0x78,       0x78,       0x77,
+	      0x76,       0x76,       0x75,       0x74,
+	      0x73,       0x73,       0x72,       0x71,
+	      0x71,       0x68,       0x45,       0x5b,
+	      0x6d,       0x6c,       0x6b,       0x6a,
+	      0x69,       0x68,       0x67,       0x66,
+	      0x65,       0x63,       0x62,       0x62,
+	      0x60,       0x5e,       0x5c,       0x5b,
+	      0x59,       0x57,       0x55,       0x53,
+	      0x52,       0x4f,       0x4d,       0x4a,
+	      0x48,       0x46,       0x43,       0x40,
+	      0x3d,       0x3a,       0x36,       0x33,
+	      0x2f,       0x2c,       0x27,       0x23,
+	      0x1f,       0x1a,       0x15,        0xf,
+	       0x8,        0x5,        0x2,        0x1,
+	       0x1
+};
+
+static uint tas3004_bass_tab[]={
+	      0x96,       0x95,       0x95,       0x94,
+	      0x93,       0x92,       0x92,       0x91,
+	      0x90,       0x90,       0x8f,       0x8e,
+	      0x8d,       0x8d,       0x8c,       0x8b,
+	      0x8a,       0x8a,       0x89,       0x88,
+	      0x88,       0x87,       0x86,       0x85,
+	      0x85,       0x84,       0x83,       0x83,
+	      0x82,       0x81,       0x80,       0x80,
+	      0x7f,       0x7e,       0x7e,       0x7d,
+	      0x7c,       0x7b,       0x7b,       0x7a,
+	      0x79,       0x78,       0x78,       0x77,
+	      0x76,       0x76,       0x75,       0x74,
+	      0x73,       0x73,       0x72,       0x71,
+	      0x70,       0x6f,       0x6e,       0x6d,
+	      0x6c,       0x6b,       0x6a,       0x6a,
+	      0x69,       0x67,       0x66,       0x66,
+	      0x65,       0x63,       0x62,       0x62,
+	      0x61,       0x60,       0x5e,       0x5d,
+	      0x5b,       0x59,       0x57,       0x55,
+	      0x53,       0x51,       0x4f,       0x4c,
+	      0x4a,       0x48,       0x46,       0x44,
+	      0x41,       0x3e,       0x3b,       0x38,
+	      0x36,       0x33,       0x2f,       0x2b,
+	      0x28,       0x24,       0x20,       0x1c,
+	      0x17,       0x12,        0xd,        0x7,
+	       0x1
+};
+
+struct tas_gain_t tas3004_gain={
+  master: tas3004_master_tab,
+  treble: tas3004_treble_tab,
+  bass:   tas3004_bass_tab,
+  mixer:  tas3004_mixer_tab
+};
+
+struct tas_eq_pref_t *tas3004_eq_prefs[]={
+  &eqp_17_1_0,
+  &eqp_18_1_0,
+  &eqp_1a_1_0,
+  &eqp_1c_1_0,
+  NULL
+};
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas_common.c kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_common.c
--- kernel-source-2.4.27/drivers/sound/dmasound/tas_common.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_common.c	2004-09-01 20:56:27.961868208 +0200
@@ -0,0 +1,256 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ioport.h>
+#include <linux/sysctl.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/soundcard.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+
+#include "tas_common.h"
+
+#define CALL0(proc)								\
+	do {									\
+		struct tas_data_t *self;					\
+		if (!tas_client || driver_hooks == NULL)			\
+			return -1;						\
+		self = (struct tas_data_t *)tas_client->data;			\
+		if (driver_hooks->proc)						\
+			return driver_hooks->proc(self);			\
+		else								\
+			return -EINVAL;						\
+	} while (0)
+
+#define CALL(proc,arg...)							\
+	do {									\
+		struct tas_data_t *self;					\
+		if (!tas_client || driver_hooks == NULL)			\
+			return -1;						\
+		self = (struct tas_data_t *)tas_client->data;			\
+		if (driver_hooks->proc)						\
+			return driver_hooks->proc(self, ## arg);		\
+		else								\
+			return -EINVAL;						\
+	} while (0)
+
+
+static u8 tas_i2c_address = 0x34;
+static struct i2c_client * tas_client = NULL;
+
+static int tas_initialized = 0;
+static struct device_node* tas_node = NULL;
+
+static int tas_attach_adapter(struct i2c_adapter *);
+static int tas_detach_client(struct i2c_client *);
+
+struct i2c_driver tas_driver = {
+	name:		"",
+	id:             0,
+	flags:		I2C_DF_NOTIFY,
+	attach_adapter:	&tas_attach_adapter,
+	detach_client:	&tas_detach_client,
+	command:	NULL,
+	inc_use:	NULL,
+	dec_use:	NULL
+};
+
+struct tas_driver_hooks_t *driver_hooks;
+
+int
+tas_register_driver(struct tas_driver_hooks_t *hooks)
+{
+	driver_hooks = hooks;
+	return 0;
+}
+
+int
+tas_get_mixer_level(int mixer, uint *level)
+{
+	CALL(get_mixer_level,mixer,level);
+}
+
+int
+tas_set_mixer_level(int mixer,uint level)
+{
+	CALL(set_mixer_level,mixer,level);
+}
+
+int
+tas_enter_sleep(void)
+{
+	CALL0(enter_sleep);
+}
+
+int
+tas_leave_sleep(void)
+{
+	CALL0(leave_sleep);
+}
+
+int
+tas_supported_mixers(void)
+{
+	CALL0(supported_mixers);
+}
+
+int
+tas_mixer_is_stereo(int mixer)
+{
+	CALL(mixer_is_stereo,mixer);
+}
+
+int
+tas_stereo_mixers(void)
+{
+	CALL0(stereo_mixers);
+}
+
+int
+tas_output_device_change(int device_id,int layout_id,int speaker_id)
+{
+	CALL(output_device_change,device_id,layout_id,speaker_id);
+}
+
+int
+tas_device_ioctl(u_int cmd, u_long arg)
+{
+	CALL(device_ioctl,cmd,arg);
+}
+
+int
+tas_post_init(void)
+{
+	CALL0(post_init);
+}
+
+static int
+tas_detect_client(struct i2c_adapter *adapter, int address)
+{
+	int rc = 0;
+	struct i2c_client *new_client;
+	struct tas_data_t *data;
+	const char *client_name = "tas Digital Equalizer";
+
+	if (driver_hooks == NULL) {
+		printk(KERN_ERR "tas_detect_client called with no hooks !\n");
+		return -ENODEV;
+	}
+	
+	new_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if (!new_client) {
+		rc = -ENOMEM;
+		goto bail;
+	}
+
+	new_client->data = NULL;
+
+	new_client->addr = address;
+	new_client->data = data;
+	new_client->adapter = adapter;
+	new_client->driver = &tas_driver;
+	new_client->flags = 0;
+
+	strcpy(new_client->name,client_name);
+
+	new_client->id = 0; /* Only one instance supported */
+
+        if (driver_hooks->init && driver_hooks->init(new_client)) {
+		rc = -ENODEV;
+		goto bail;
+	}
+
+	/* Tell the i2c layer a new client has arrived */
+	if (i2c_attach_client(new_client)) {
+        	if (driver_hooks->uninit)
+			driver_hooks->uninit((struct tas_data_t *)new_client->data);
+		rc = -ENODEV;
+		goto bail;
+	}
+
+	tas_client = new_client;
+bail:
+	if (rc && new_client) {
+		tas_client = NULL;
+		kfree(new_client);
+	}
+	return rc;
+}
+
+static int
+tas_attach_adapter(struct i2c_adapter *adapter)
+{
+	if (!strncmp(adapter->name, "mac-io", 6))
+		return tas_detect_client(adapter, tas_i2c_address);
+	return 0;
+}
+
+static int
+tas_detach_client(struct i2c_client *client)
+{
+	if (client == tas_client) {
+		driver_hooks->uninit((struct tas_data_t *)client->data);
+
+		i2c_detach_client(client);
+		kfree(client);
+	}
+	return 0;
+}
+
+int __init
+tas_cleanup(void)
+{
+	if (!tas_initialized)
+		return -ENODEV;
+	i2c_del_driver(&tas_driver);
+	tas_initialized = 0;
+
+	return 0;
+}
+
+int __init
+tas_init(int driver_id, const char *driver_name)
+{
+	int rc;
+	u32* paddr;
+
+	if (tas_initialized)
+		return 0;
+
+        strncpy(tas_driver.name,driver_name,31);
+        tas_driver.name[31]=0;
+        tas_driver.id=driver_id;
+
+	tas_node = find_devices("deq");
+	if (tas_node == NULL)
+		return -ENODEV;
+
+	printk(KERN_INFO "tas driver [%s])\n",tas_driver.name);
+	paddr = (u32 *)get_property(tas_node, "i2c-address", NULL);
+	if (paddr) {
+		tas_i2c_address = (*paddr) >> 1;
+		printk(KERN_INFO "using i2c address: 0x%x from device-tree\n",
+		       tas_i2c_address);
+	} else    
+		printk(KERN_INFO "using i2c address: 0x%x (default)\n", tas_i2c_address);
+
+	if ((rc = i2c_add_driver(&tas_driver))) {
+		printk("tas: Driver registration failed, module not inserted.\n");
+		tas_cleanup();
+		return rc;
+	}
+	tas_initialized = 1;
+	return 0;
+}
+/*
+ * Local Variables:
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas_common.h kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_common.h
--- kernel-source-2.4.27/drivers/sound/dmasound/tas_common.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_common.h	2004-09-01 20:56:27.963867904 +0200
@@ -0,0 +1,284 @@
+#ifndef _TAS_COMMON_H_
+#define _TAS_COMMON_H_
+
+#include <linux/i2c.h>
+#include <linux/soundcard.h>
+#include <asm/string.h>
+
+#define I2C_DRIVERID_TAS_BASE   (0xFEBA)
+
+#define SET_4_20(shadow, offset, val)                        \
+	do {                                                 \
+		(shadow)[(offset)+0] = ((val) >> 16) & 0xff; \
+		(shadow)[(offset)+1] = ((val) >> 8)  & 0xff; \
+		(shadow)[(offset)+2] = ((val) >> 0)  & 0xff; \
+	} while (0)
+
+#define GET_4_20(shadow, offset)                             \
+	(((u_int)((shadow)[(offset)+0]) << 16) |             \
+	 ((u_int)((shadow)[(offset)+1]) <<  8) |             \
+	 ((u_int)((shadow)[(offset)+2]) <<  0))
+
+
+#define TAS_BIQUAD_FAST_LOAD 0x01
+
+#define TAS_DRCE_ENABLE           0x01
+#define TAS_DRCE_ABOVE_RATIO      0x02
+#define TAS_DRCE_BELOW_RATIO      0x04
+#define TAS_DRCE_THRESHOLD        0x08
+#define TAS_DRCE_ENERGY           0x10
+#define TAS_DRCE_ATTACK           0x20
+#define TAS_DRCE_DECAY            0x40
+
+#define TAS_DRCE_ALL              0x7f
+
+
+#define TAS_OUTPUT_HEADPHONES     0x00
+#define TAS_OUTPUT_INTERNAL_SPKR  0x01
+#define TAS_OUTPUT_EXTERNAL_SPKR  0x02
+
+
+union tas_biquad_t {
+	struct {
+		int b0,b1,b2,a1,a2;
+	} coeff;
+	int buf[5];
+};
+
+struct tas_biquad_ctrl_t {
+	u_int channel:4;
+	u_int filter:4;
+
+	union tas_biquad_t data;
+};
+
+struct tas_biquad_ctrl_list_t {
+	int flags;
+	int filter_count;
+	struct tas_biquad_ctrl_t biquads[0];
+};
+
+struct tas_ratio_t {
+	unsigned short val;    /* 8.8                        */
+	unsigned short expand; /* 0 = compress, !0 = expand. */
+};
+
+struct tas_drce_t {
+	unsigned short enable;
+	struct tas_ratio_t above;
+	struct tas_ratio_t below;
+	short threshold;       /* dB,       8.8 signed    */
+	unsigned short energy; /* seconds,  4.12 unsigned */
+	unsigned short attack; /* seconds,  4.12 unsigned */
+	unsigned short decay;  /* seconds,  4.12 unsigned */
+};
+
+struct tas_drce_ctrl_t {
+	uint flags;
+
+	struct tas_drce_t data;
+};
+
+struct tas_gain_t
+{
+  unsigned int *master;
+  unsigned int *treble;
+  unsigned int *bass;
+  unsigned int *mixer;
+};
+
+typedef char tas_shadow_t[16];
+
+struct tas_data_t
+{
+	struct i2c_client *client;
+	tas_shadow_t *shadow;
+	uint mixer[SOUND_MIXER_NRDEVICES];
+};
+
+typedef int (*tas_hook_init_t)(struct i2c_client *);
+typedef int (*tas_hook_post_init_t)(struct tas_data_t *);
+typedef void (*tas_hook_uninit_t)(struct tas_data_t *);
+
+typedef int (*tas_hook_get_mixer_level_t)(struct tas_data_t *,int,uint *);
+typedef int (*tas_hook_set_mixer_level_t)(struct tas_data_t *,int,uint);
+
+typedef int (*tas_hook_enter_sleep_t)(struct tas_data_t *);
+typedef int (*tas_hook_leave_sleep_t)(struct tas_data_t *);
+
+typedef int (*tas_hook_supported_mixers_t)(struct tas_data_t *);
+typedef int (*tas_hook_mixer_is_stereo_t)(struct tas_data_t *,int);
+typedef int (*tas_hook_stereo_mixers_t)(struct tas_data_t *);
+
+typedef int (*tas_hook_output_device_change_t)(struct tas_data_t *,int,int,int);
+typedef int (*tas_hook_device_ioctl_t)(struct tas_data_t *,u_int,u_long);
+
+struct tas_driver_hooks_t {
+	/*
+	 * All hardware initialisation must be performed in
+	 * post_init(), as tas_dmasound_init() does a hardware reset.
+	 *
+	 * init() is called before tas_dmasound_init() so that
+	 * ouput_device_change() is always called after i2c driver
+	 * initialisation. The implication is that
+	 * output_device_change() must cope with the fact that it
+	 * may be called before post_init().
+	 */
+
+	tas_hook_init_t                   init;
+	tas_hook_post_init_t              post_init;
+	tas_hook_uninit_t                 uninit;
+
+	tas_hook_get_mixer_level_t        get_mixer_level;
+	tas_hook_set_mixer_level_t        set_mixer_level;
+
+	tas_hook_enter_sleep_t            enter_sleep;
+	tas_hook_leave_sleep_t            leave_sleep;
+
+	tas_hook_supported_mixers_t       supported_mixers;
+	tas_hook_mixer_is_stereo_t        mixer_is_stereo;
+	tas_hook_stereo_mixers_t          stereo_mixers;
+
+	tas_hook_output_device_change_t   output_device_change;
+	tas_hook_device_ioctl_t           device_ioctl;
+};
+
+enum tas_write_mode_t {
+	WRITE_HW     = 0x01,
+	WRITE_SHADOW = 0x02,
+	WRITE_NORMAL = 0x03,
+	FORCE_WRITE  = 0x04
+};
+
+static inline uint
+tas_mono_to_stereo(uint mono)
+{
+	mono &=0xff;
+	return mono | (mono<<8);
+}
+
+/*
+ * Todo: make these functions a bit more efficient !
+ */
+static inline int
+tas_write_register(	struct tas_data_t *self,
+			uint reg_num,
+			uint reg_width,
+			char *data,
+			uint write_mode)
+{
+	int rc;
+
+	if (reg_width==0 || data==NULL || self==NULL)
+		return -EINVAL;
+	if (!(write_mode & FORCE_WRITE) &&
+	    !memcmp(data,self->shadow[reg_num],reg_width))
+	    	return 0;
+
+	if (write_mode & WRITE_SHADOW)
+		memcpy(self->shadow[reg_num],data,reg_width);
+	if (write_mode & WRITE_HW) {
+		rc=i2c_smbus_write_block_data(self->client,
+					      reg_num,
+					      reg_width,
+					      data);
+		if (rc < 0) {
+			printk("tas: I2C block write failed \n");  
+			return rc; 
+		}
+	}
+	return 0;
+}
+
+static inline int
+tas_sync_register(	struct tas_data_t *self,
+			uint reg_num,
+			uint reg_width)
+{
+	int rc;
+
+	if (reg_width==0 || self==NULL)
+		return -EINVAL;
+	rc=i2c_smbus_write_block_data(self->client,
+				      reg_num,
+				      reg_width,
+				      self->shadow[reg_num]);
+	if (rc < 0) {
+		printk("tas: I2C block write failed \n");
+		return rc;
+	}
+	return 0;
+}
+
+static inline int
+tas_write_byte_register(	struct tas_data_t *self,
+				uint reg_num,
+				char data,
+				uint write_mode)
+{
+	if (self==NULL)
+		return -1;
+	if (!(write_mode & FORCE_WRITE) && data != self->shadow[reg_num][0])
+		return 0;
+	if (write_mode & WRITE_SHADOW)
+		self->shadow[reg_num][0]=data;
+	if (write_mode & WRITE_HW) {
+		if (i2c_smbus_write_byte_data(self->client, reg_num, data) < 0) {
+			printk("tas: I2C byte write failed \n");  
+			return -1; 
+		}
+	}
+	return 0;
+}
+
+static inline int
+tas_sync_byte_register(	struct tas_data_t *self,
+			uint reg_num,
+			uint reg_width)
+{
+	if (reg_width==0 || self==NULL)
+		return -1;
+	if (i2c_smbus_write_byte_data(
+	    self->client, reg_num, self->shadow[reg_num][0]) < 0) {
+		printk("tas: I2C byte write failed \n");
+		return -1;
+	}
+	return 0;
+}
+
+static inline int
+tas_read_register(	struct tas_data_t *self,
+			uint reg_num,
+			uint reg_width,
+			char *data)
+{
+	if (reg_width==0 || data==NULL || self==NULL)
+		return -1;
+	memcpy(data,self->shadow[reg_num],reg_width);
+	return 0;
+}
+
+extern int tas_register_driver(struct tas_driver_hooks_t *hooks);
+
+extern int tas_get_mixer_level(int mixer,uint *level);
+extern int tas_set_mixer_level(int mixer,uint level);
+extern int tas_enter_sleep(void);
+extern int tas_leave_sleep(void);
+extern int tas_supported_mixers(void);
+extern int tas_mixer_is_stereo(int mixer);
+extern int tas_stereo_mixers(void);
+extern int tas_output_device_change(int,int,int);
+extern int tas_device_ioctl(u_int, u_long);
+
+extern int tas_cleanup(void);
+extern int tas_init(int driver_id,const char *driver_name);
+extern int tas_post_init(void);
+
+#endif /* _TAS_COMMON_H_ */
+/*
+ * Local Variables:
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas_eq_prefs.h kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_eq_prefs.h
--- kernel-source-2.4.27/drivers/sound/dmasound/tas_eq_prefs.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_eq_prefs.h	2004-09-01 20:56:28.043855744 +0200
@@ -0,0 +1,24 @@
+#ifndef _TAS_EQ_PREFS_H_
+#define _TAS_EQ_PREFS_H_
+
+struct tas_eq_pref_t {
+	u_int sample_rate;
+	u_int device_id;
+	u_int output_id;
+	u_int speaker_id;
+
+	struct tas_drce_t *drce;
+
+	u_int filter_count;
+	struct tas_biquad_ctrl_t *biquads;
+};
+
+#endif /* _TAS_EQ_PREFS_H_ */
+
+/*
+ * Local Variables:
+ * tab-width: 8
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN kernel-source-2.4.27/drivers/sound/dmasound/tas_ioctl.h kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_ioctl.h
--- kernel-source-2.4.27/drivers/sound/dmasound/tas_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/sound/dmasound/tas_ioctl.h	2004-09-01 20:56:28.123843584 +0200
@@ -0,0 +1,24 @@
+#ifndef _TAS_IOCTL_H_
+#define _TAS_IOCTL_H_
+
+#include <linux/i2c.h>
+#include <linux/soundcard.h>
+
+
+#define TAS_READ_EQ              _SIOR('t',0,struct tas_biquad_ctrl_t)
+#define TAS_WRITE_EQ             _SIOW('t',0,struct tas_biquad_ctrl_t)
+
+#define TAS_READ_EQ_LIST         _SIOR('t',1,struct tas_biquad_ctrl_t)
+#define TAS_WRITE_EQ_LIST        _SIOW('t',1,struct tas_biquad_ctrl_t)
+
+#define TAS_READ_EQ_FILTER_COUNT  _SIOR('t',2,int)
+#define TAS_READ_EQ_CHANNEL_COUNT _SIOR('t',3,int)
+
+#define TAS_READ_DRCE            _SIOR('t',4,struct tas_drce_ctrl_t)
+#define TAS_WRITE_DRCE           _SIOW('t',4,struct tas_drce_ctrl_t)
+
+#define TAS_READ_DRCE_CAPS       _SIOR('t',5,int)
+#define TAS_READ_DRCE_MIN        _SIOR('t',6,int)
+#define TAS_READ_DRCE_MAX        _SIOR('t',7,int)
+
+#endif
diff -urN kernel-source-2.4.27/drivers/usb/host/usb-ohci.h kernel-source-2.4.27-benh/drivers/usb/host/usb-ohci.h
--- kernel-source-2.4.27/drivers/usb/host/usb-ohci.h	2004-04-14 15:05:33.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/usb/host/usb-ohci.h	2004-09-01 20:56:28.125843280 +0200
@@ -58,7 +58,7 @@
 
 	dma_addr_t dma;
 	__u32 unused[3];
-} __attribute((aligned(16)));
+} __attribute((aligned(32)));
 typedef struct ed ed_t;
 
  
@@ -567,7 +567,7 @@
 		return -ENOMEM;
 	ohci->dev_cache = pci_pool_create ("ohci_dev", ohci->ohci_dev,
 		sizeof (struct ohci_device),
-		16 /* byte alignment */,
+		32 /* byte alignment */,
 		0 /* no page-crossing issues */,
 		GFP_KERNEL | OHCI_MEM_FLAGS);
 	if (!ohci->dev_cache)
diff -urN kernel-source-2.4.27/drivers/usb/storage/scsiglue.c kernel-source-2.4.27-benh/drivers/usb/storage/scsiglue.c
--- kernel-source-2.4.27/drivers/usb/storage/scsiglue.c	2004-08-08 01:26:05.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/usb/storage/scsiglue.c	2004-09-01 20:56:28.287818656 +0200
@@ -75,16 +75,19 @@
 {
 	struct us_data *us;
 	char local_name[32];
-	/* Note: this function gets called with io_request_lock spinlock helt! */
+	spin_unlock_irq(&io_request_lock);
+	
 	/* This is not nice at all, but how else are we to get the
 	 * data here? */
 	us = (struct us_data *)sht->proc_dir;
 
 	/* set up the name of our subdirectory under /proc/scsi/ */
 	sprintf(local_name, "usb-storage-%d", us->host_number);
-	sht->proc_name = kmalloc (strlen(local_name) + 1, GFP_ATOMIC);
-	if (!sht->proc_name) 
+	sht->proc_name = kmalloc (strlen(local_name) + 1, GFP_KERNEL);
+	if (!sht->proc_name) {
+		spin_lock_irq(&io_request_lock);
 		return 0;
+	}
 	strcpy(sht->proc_name, local_name);
 
 	/* we start with no /proc directory entry */
@@ -95,12 +98,14 @@
 	if (us->host) {
 		us->host->hostdata[0] = (unsigned long)us;
 		us->host_no = us->host->host_no;
+		spin_lock_irq(&io_request_lock);
 		return 1;
 	}
 
 	/* odd... didn't register properly.  Abort and free pointers */
 	kfree(sht->proc_name);
 	sht->proc_name = NULL;
+	spin_lock_irq(&io_request_lock);
 	return 0;
 }
 
diff -urN kernel-source-2.4.27/drivers/video/aty/atyfb_base.c kernel-source-2.4.27-benh/drivers/video/aty/atyfb_base.c
--- kernel-source-2.4.27/drivers/video/aty/atyfb_base.c	2004-02-18 14:36:31.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/aty/atyfb_base.c	2004-09-01 20:56:28.374805432 +0200
@@ -106,7 +106,7 @@
 /*
  * Debug flags.
  */
-#undef DEBUG
+#define DEBUG
 
 /* Make sure n * PAGE_SIZE is protected at end of Aperture for GUI-regs */
 /*  - must be large enough to catch all GUI-Regs   */
@@ -1480,6 +1480,8 @@
         return -EINVAL;
     par->crtc.xoffset = xoffset;
     par->crtc.yoffset = yoffset;
+    if (info->asleep)
+	    return 0;
     set_off_pitch(par, info);
     return 0;
 }
@@ -1872,6 +1874,7 @@
                         }
                         break;
                 case PBOOK_SLEEP_NOW:
+			acquire_console_sem();
                         if (currcon >= 0)
                                 fb_display[currcon].dispsw = &fbcon_dummy;
                         if (info->blitter_may_be_busy)
@@ -1887,13 +1890,16 @@
 
                         /* Blank display and LCD */
                         atyfbcon_blank(VESA_POWERDOWN+1, (struct fb_info *)info);
-
+			info->asleep = 1;
                         /* Set chip to "suspend" mode */
                         result = aty_power_mgmt(1, info);
+			release_console_sem();
                         break;
                 case PBOOK_WAKE:
                         /* Wakeup chip */
+			acquire_console_sem();
                         result = aty_power_mgmt(0, info);
+			info->asleep = 0;
 
                         /* Restore fb content */                        
                         if (info->save_framebuffer) {
@@ -1908,7 +1914,9 @@
                                         info, info->current_par.crtc.bpp,
                                         info->current_par.accel_flags & FB_ACCELF_TEXT);
                         }
+			set_off_pitch(&info->current_par, info);
                         atyfbcon_blank(0, (struct fb_info *)info);
+			release_console_sem();
                         break;
                 }
         }
@@ -3213,6 +3221,9 @@
     struct fb_info_aty *info = (struct fb_info_aty *)fb;
     u8 gen_cntl;
 
+    if (info->asleep)
+	    return;
+
 #ifdef CONFIG_PMAC_BACKLIGHT
     if ((_machine == _MACH_Pmac) && blank)
         set_backlight_enable(0);
diff -urN kernel-source-2.4.27/drivers/video/aty/atyfb.h kernel-source-2.4.27-benh/drivers/video/aty/atyfb.h
--- kernel-source-2.4.27/drivers/video/aty/atyfb.h	2003-11-28 19:26:20.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/aty/atyfb.h	2004-09-01 20:56:28.375805280 +0200
@@ -179,6 +179,7 @@
     unsigned char *save_framebuffer;
     unsigned long save_pll[64];
 #endif
+    int asleep;
 };
 
 
diff -urN kernel-source-2.4.27/drivers/video/aty/mach64_cursor.c kernel-source-2.4.27-benh/drivers/video/aty/mach64_cursor.c
--- kernel-source-2.4.27/drivers/video/aty/mach64_cursor.c	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/aty/mach64_cursor.c	2004-09-01 20:56:28.456792968 +0200
@@ -54,7 +54,7 @@
 	const u8 *blue = cursor_color_map;
 	int i;
 
-	if (!c)
+	if (!c || fb->asleep)
 		return;
 
 #ifdef __sparc__
@@ -81,7 +81,7 @@
 	u8 *ram, m, b;
 	int x, y;
 
-	if (!c)
+	if (!c || fb->asleep)
 		return;
 
 #ifdef __sparc__
@@ -118,7 +118,7 @@
 	u16 xoff, yoff;
 	int x, y;
 
-	if (!c)
+	if (!c || fb->asleep)
 		return;
 
 #ifdef __sparc__
@@ -301,9 +301,11 @@
 	    c->mask[i][height-1] = (j >= 8) ? 0xff : (0xff << (8 - j));
 	}
 
+	if (!fb->asleep) {
 	aty_set_cursor_color(fb);
 	aty_set_cursor_shape(fb);
     }
+    }
     return 1;
 }
 
diff -urN kernel-source-2.4.27/drivers/video/aty128fb.c kernel-source-2.4.27-benh/drivers/video/aty128fb.c
--- kernel-source-2.4.27/drivers/video/aty128fb.c	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/aty128fb.c	2004-09-01 20:56:28.548778984 +0200
@@ -55,7 +55,7 @@
 #include <linux/ioport.h>
 #include <asm/io.h>
 
-#ifdef CONFIG_PPC
+#ifdef CONFIG_ALL_PPC
 #include <asm/prom.h>
 #include <asm/pci-bridge.h>
 #include <video/macmodes.h>
@@ -101,7 +101,7 @@
 #define DBG(fmt, args...)
 #endif
 
-#ifndef CONFIG_PPC
+#ifndef CONFIG_ALL_PPC
 /* default mode */
 static struct fb_var_screeninfo default_var __initdata = {
     /* 640x480, 60 Hz, Non-Interlaced (25.175 MHz dotclock) */
@@ -111,7 +111,7 @@
     0, FB_VMODE_NONINTERLACED
 };
 
-#else /* CONFIG_PPC */
+#else /* CONFIG_ALL_PPC */
 /* default to 1024x768 at 75Hz on PPC - this will work
  * on the iMac, the usual 640x480 @ 60Hz doesn't. */
 static struct fb_var_screeninfo default_var = {
@@ -121,7 +121,7 @@
     0, 0, -1, -1, 0, 12699, 160, 32, 28, 1, 96, 3,
     FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT, FB_VMODE_NONINTERLACED
 };
-#endif /* CONFIG_PPC */
+#endif /* CONFIG_ALL_PPC */
 
 /* default modedb mode */
 /* 640x480, 60 Hz, Non-Interlaced (25.172 MHz dotclock) */
@@ -171,7 +171,7 @@
  };
 
 /* packed BIOS settings */
-#ifndef CONFIG_PPC
+#ifndef CONFIG_ALL_PPC
 typedef struct {
 	u8 clock_chip_type;
 	u8 struct_size;
@@ -196,7 +196,7 @@
 	u32 XCLK_min_freq;
 	u32 XCLK_max_freq;
 } __attribute__ ((packed)) PLL_BLOCK;
-#endif /* !CONFIG_PPC */
+#endif /* !CONFIG_ALL_PPC */
 
 /* onboard memory information */
 struct aty128_meminfo {
@@ -233,7 +233,7 @@
 
 static char *mode_option __initdata = NULL;
 
-#ifdef CONFIG_PPC
+#ifdef CONFIG_ALL_PPC
 static int default_vmode __initdata = VMODE_1024_768_60;
 static int default_cmode __initdata = CMODE_8;
 #endif
@@ -397,7 +397,7 @@
                                const struct aty128_chip_info *aci);
 static struct fb_info_aty128 *aty128_board_list_add(struct fb_info_aty128
 				*board_list, struct fb_info_aty128 *new_node);
-#if !defined(CONFIG_PPC) && !defined(__sparc__)
+#if !defined(CONFIG_ALL_PPC) && !defined(__sparc__)
 static void __init aty128_get_pllinfo(struct fb_info_aty128 *info,
 			char *bios_seg);
 static char __init *aty128find_ROM(struct fb_info_aty128 *info);
@@ -1778,7 +1778,7 @@
             mtrr = 0;
         }
 #endif
-#ifdef CONFIG_PPC
+#ifdef CONFIG_ALL_PPC
         /* vmode and cmode depreciated */
 	else if (!strncmp(this_opt, "vmode:", 6)) {
             unsigned int vmode = simple_strtoul(this_opt+6, NULL, 0);
@@ -1801,7 +1801,7 @@
 		break;
             }
         }
-#endif /* CONFIG_PPC */
+#endif /* CONFIG_ALL_PPC */
         else
             mode_option = this_opt;
     }
@@ -1858,7 +1858,7 @@
 #endif
     
     var = default_var;
-#ifdef CONFIG_PPC
+#ifdef CONFIG_ALL_PPC
     if (_machine == _MACH_Pmac) {
         if (mode_option) {
             if (!mac_find_mode(&var, &info->fb_info, mode_option, 8))
@@ -1897,7 +1897,7 @@
                 var = default_var;
         }
     } else
-#endif /* CONFIG_PPC */
+#endif /* CONFIG_ALL_PPC */
     {
         if (fb_find_mode(&var, &info->fb_info, mode_option, NULL, 0,
                           &defaultmode, 8) == 0)
@@ -2011,7 +2011,7 @@
 	struct fb_info_aty128 *info = NULL;
 	unsigned long fb_addr, reg_addr;
 	int err;
-#if !defined(CONFIG_PPC) && !defined(__sparc__)
+#if !defined(CONFIG_ALL_PPC) && !defined(__sparc__)
 	char *bios_seg = NULL;
 #endif
 
@@ -2074,7 +2074,7 @@
 		goto err_out;
 	}
 
-#if !defined(CONFIG_PPC) && !defined(__sparc__)
+#if !defined(CONFIG_ALL_PPC) && !defined(__sparc__)
 	if (!(bios_seg = aty128find_ROM(info)))
 		printk(KERN_INFO "aty128fb: Rage128 BIOS not located. "
 					"Guessing...\n");
@@ -2126,7 +2126,7 @@
 
 
 /* PPC and Sparc cannot read video ROM */
-#if !defined(CONFIG_PPC) && !defined(__sparc__)
+#if !defined(CONFIG_ALL_PPC) && !defined(__sparc__)
 static char __init
 *aty128find_ROM(struct fb_info_aty128 *info)
 {
@@ -2225,14 +2225,14 @@
 			info->constants.dotclock);
 
 }           
-#endif /* !CONFIG_PPC */
+#endif /* !CONFIG_ALL_PPC */
 
 
 /* fill in known card constants if pll_block is not available */
 static void __init
 aty128_timings(struct fb_info_aty128 *info)
 {
-#ifdef CONFIG_PPC
+#ifdef CONFIG_ALL_PPC
     /* instead of a table lookup, assume OF has properly
      * setup the PLL registers and use their values
      * to set the XCLK values and reference divider values */
@@ -2247,7 +2247,7 @@
     if (!info->constants.dotclock)
         info->constants.dotclock = 2950;
 
-#ifdef CONFIG_PPC
+#ifdef CONFIG_ALL_PPC
     x_mpll_ref_fb_div = aty_ld_pll(X_MPLL_REF_FB_DIV);
     xclk_cntl = aty_ld_pll(XCLK_CNTL) & 0x7;
     Nx = (x_mpll_ref_fb_div & 0x00ff00) >> 8;
@@ -2475,9 +2475,9 @@
 #define ATY_MIRROR_CRT_ON	0x00000002
 
 /* out param: u32*	backlight value: 0 to 15 */
-#define FBIO_ATY128_GET_MIRROR	_IOR('@', 1, sizeof(__u32*))
+#define FBIO_ATY128_GET_MIRROR	_IOR('@', 1, __u32)
 /* in param: u32*	backlight value: 0 to 15 */
-#define FBIO_ATY128_SET_MIRROR	_IOW('@', 2, sizeof(__u32*))
+#define FBIO_ATY128_SET_MIRROR	_IOW('@', 2, __u32)
 
 static int aty128fb_ioctl(struct inode *inode, struct file *file, u_int cmd,
 		       u_long arg, int con, struct fb_info *info)
diff -urN kernel-source-2.4.27/drivers/video/Config.in kernel-source-2.4.27-benh/drivers/video/Config.in
--- kernel-source-2.4.27/drivers/video/Config.in	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/Config.in	2004-09-01 20:56:28.631766368 +0200
@@ -73,7 +73,7 @@
       dep_bool '  Apple "valkyrie" display support' CONFIG_FB_VALKYRIE $CONFIG_ALL_PPC
       bool '  Chips 65550 display support' CONFIG_FB_CT65550
       bool '  IMS Twin Turbo display support' CONFIG_FB_IMSTT
-      bool '  S3 Trio display support' CONFIG_FB_S3TRIO
+      dep_bool '  S3 Trio display support' CONFIG_FB_S3TRIO $CONFIG_ALL_PPC
       tristate '  VGA 16-color graphics console' CONFIG_FB_VGA16
    fi
    if [ "$CONFIG_PARISC" = "y" ]; then
@@ -312,7 +312,7 @@
 	   "$CONFIG_FB_TX3912" = "y" -o \
 	   "$CONFIG_FB_SIS" = "y" -o "$CONFIG_FB_NEOMAGIC" = "y" -o \
 	   "$CONFIG_FB_STI" = "y" -o "$CONFIG_FB_HP300" = "y" -o \
-	   "$CONFIG_FB_INTEL" = "y" ]; then
+	   "$CONFIG_FB_INTEL" = "y" -o "$CONFIG_FB_IMSTT" = "y" ]; then
 	 define_tristate CONFIG_FBCON_CFB8 y
       else
 	 if [ "$CONFIG_FB_ACORN" = "m" -o "$CONFIG_FB_ATARI" = "m" -o \
@@ -354,7 +354,8 @@
 	   "$CONFIG_FB_CYBER2000" = "y" -o "$CONFIG_FB_3DFX" = "y"  -o \
 	   "$CONFIG_FB_SIS" = "y" -o "$CONFIG_FB_SA1100" = "y" -o \
 	   "$CONFIG_FB_PVR2" = "y" -o "$CONFIG_FB_VOODOO1" = "y" -o \
-	   "$CONFIG_FB_NEOMAGIC" = "y" -o "$CONFIG_FB_INTEL" = "y" ]; then
+	   "$CONFIG_FB_NEOMAGIC" = "y" -o "$CONFIG_FB_INTEL" = "y" -o \
+	   "$CONFIG_FB_IMSTT" = "y"  ]; then
 	 define_tristate CONFIG_FBCON_CFB16 y
       else
 	 if [ "$CONFIG_FB_ATARI" = "m" -o "$CONFIG_FB_ATY" = "m" -o \
@@ -381,7 +382,8 @@
 	   "$CONFIG_FB_MATROX" = "y" -o "$CONFIG_FB_PM2" = "y" -o \
            "$CONFIG_FB_ATY128" = "y" -o "$CONFIG_FB_RADEON" = "y" -o \
 	   "$CONFIG_FB_CYBER2000" = "y" -o "$CONFIG_FB_PVR2" = "y" -o \
-	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_NEOMAGIC" = "y" ]; then
+	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_NEOMAGIC" = "y" -o \
+	   "$CONFIG_FB_IMSTT" = "y"  ]; then
 	 define_tristate CONFIG_FBCON_CFB24 y
       else
 	 if [ "$CONFIG_FB_ATY" = "m" -o "$CONFIG_FB_VIRTUAL" = "m" -o \
@@ -405,7 +407,8 @@
 	   "$CONFIG_FB_INTEL" = "y" -o \
 	   "$CONFIG_FB_3DFX" = "y" -o "$CONFIG_FB_SIS" = "y" -o \
 	   "$CONFIG_FB_VOODOO1" = "y" -o "$CONFIG_FB_CYBER2000" = "y" -o \
-	   "$CONFIG_FB_STI" = "y"  -o "$CONFIG_FB_INTEL" = "y" ]; then
+	   "$CONFIG_FB_STI" = "y"  -o "$CONFIG_FB_INTEL" = "y" -o \
+	   "$CONFIG_FB_IMSTT" = "y" ]; then
 	 define_tristate CONFIG_FBCON_CFB32 y
       else
 	 if [ "$CONFIG_FB_ATARI" = "m" -o "$CONFIG_FB_ATY" = "m" -o \
diff -urN kernel-source-2.4.27/drivers/video/imsttfb.c kernel-source-2.4.27-benh/drivers/video/imsttfb.c
--- kernel-source-2.4.27/drivers/video/imsttfb.c	2002-02-25 20:38:07.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/imsttfb.c	2004-09-01 20:56:28.714753752 +0200
@@ -444,6 +444,20 @@
 };
 
 /*
+ * DEBUG
+ */
+void imstt_print_bin(const char *c, __u32 i) {
+	unsigned int j;
+	printk("%s =  \n", c);
+	for(j = sizeof(i) * 8;j;j--) {
+		printk("%d",(i >> (j - 1)) & 1);
+		if(!((j-1) % 8)) printk(" ");
+	}
+	printk("\n");
+	return;
+}
+
+/*
  * PCI driver prototypes
  */
 static int imsttfb_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
@@ -1913,6 +1927,24 @@
 {
 	struct fb_info_imstt *p;
 	unsigned long addr, size;
+	int err;
+#ifdef CONFIG_ALL_PPC
+	struct device_node *dp;
+	
+	dp = pci_device_to_OF_node(pdev);
+	if(dp)
+		printk(KERN_INFO "%s: OF name %s\n",__FUNCTION__, dp->name);
+	else {
+		printk(KERN_ERR "imsttfb: no OF node for pci device\n");
+		return -ENODEV;
+	}
+#endif
+	
+	if ((err = pci_enable_device(pdev))) {
+		printk(KERN_ERR "imsttfb: Cannot enable PCI device: %d\n",
+				err);
+		return -ENODEV;
+	}
 
 	addr = pci_resource_start (pdev, 0);
 	size = pci_resource_len (pdev, 0);
@@ -1935,13 +1967,19 @@
 	switch (pdev->device) {
 		case PCI_DEVICE_ID_IMS_TT128: /* IMS,tt128mbA */
 			p->ramdac = IBM;
+#ifdef CONFIG_ALL_PPC
+			if ((strcmp(dp->name, "IMS,tt128mb8") == 0) ||
+				(strcmp(dp->name, "IMS,tt128mb8A") == 0))
+				p->ramdac = TVP;
+#endif
 			break;
 		case PCI_DEVICE_ID_IMS_TT3D:  /* IMS,tt3d */
 			p->ramdac = TVP;
 			break;
 		default:
-			printk(KERN_INFO "imsttfb: Device 0x%lx unknown, "
+			printk(KERN_INFO "imsttfb: Device 0x%x unknown, "
 					 "contact maintainer.\n", pdev->device);
+			kfree(p);
 			return -ENODEV;
 	}
 
diff -urN kernel-source-2.4.27/drivers/video/offb.c kernel-source-2.4.27-benh/drivers/video/offb.c
--- kernel-source-2.4.27/drivers/video/offb.c	2002-02-25 20:38:07.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/offb.c	2004-09-01 20:56:28.716753448 +0200
@@ -448,6 +448,10 @@
 		unsigned long regbase = dp->addrs[1].address;
 		info->cmap_adr = ioremap(regbase, 0x1FFF);
 		info->cmap_type = cmap_radeon;
+	} else if (dp && !strncmp(name, "ATY,BlueStar", 12)) {
+		unsigned long regbase = dp->addrs[2].address;
+		info->cmap_adr = ioremap(regbase, 0x1FFF);
+		info->cmap_type = cmap_radeon;
 	} else if (!strncmp(name, "ATY,", 4)) {
 		/* Hrm... this is bad... any recent ATI not covered
 		 * by the previous cases will get there, while this
diff -urN kernel-source-2.4.27/drivers/video/radeonfb.c kernel-source-2.4.27-benh/drivers/video/radeonfb.c
--- kernel-source-2.4.27/drivers/video/radeonfb.c	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/radeonfb.c	2004-09-01 20:56:28.887727456 +0200
@@ -208,6 +208,7 @@
 	RADEON_Le,
 	RADEON_Lf,
 	RADEON_Lg,
+	RADEON__c,
 	RADEON_ND,
 	RADEON_NE,
 	RADEON_NF,
@@ -215,10 +216,26 @@
 	RADEON_AE,
 	RADEON_AF,
 	RADEON_AD,
+	RADEON_AH,
+	RADEON_AI,
+	RADEON_AJ,
+	RADEON_AK,
 	RADEON_NH,
 	RADEON_NI,
+	RADEON_NJ,
+	RADEON_NK,
 	RADEON_AP,
+	RADEON_AQ,
 	RADEON_AR,
+	RADEON_AS,
+	RADEON_AT,
+	RADEON_AV,
+	RADEON_NP,
+	RADEON_NQ,
+	RADEON_NR,
+	RADEON_NS,
+	RADEON_NT,
+	RADEON_NV,
 };
 
 enum radeon_arch {
@@ -234,6 +251,7 @@
 	RADEON_R300,
 	RADEON_R350,
 	RADEON_RV350,
+	RADEON_M10
 };
 
 static struct radeon_chip_info {
@@ -269,6 +287,7 @@
 	{ "M9 Le", RADEON_M9 },
 	{ "M9 Lf", RADEON_M9 },
 	{ "M9 Lg", RADEON_M9 },
+	{ "M9+", RADEON_M9 },
 	{ "9700 ND", RADEON_R300 },
 	{ "9700 NE", RADEON_R300 },
 	{ "9700 NF", RADEON_R350 },
@@ -276,10 +295,26 @@
 	{ "9700 AE", RADEON_R300 },
 	{ "9700 AF", RADEON_R300 },
 	{ "9500 AD", RADEON_R300 },
+	{ "9800 AH", RADEON_R350 },
+	{ "9800 AI", RADEON_R350 },
+	{ "9800 AJ", RADEON_R350 },
+	{ "9800 AK", RADEON_R350 },
 	{ "9800 NH", RADEON_R350 },
 	{ "9800 NI", RADEON_R350 },
+	{ "9800 NJ", RADEON_R350 },
+	{ "9800 NK", RADEON_R350 },
 	{ "9600 AP", RADEON_RV350 },
+	{ "9600 AQ", RADEON_RV350 },
 	{ "9600 AR", RADEON_RV350 },
+	{ "9600 AS", RADEON_RV350 },
+	{ "9600 AT", RADEON_RV350 },
+	{ "9600 AV", RADEON_RV350 },
+	{ "M10/11 NP", RADEON_M10 },
+	{ "M10/11 NQ", RADEON_M10 },
+	{ "M10/11 NR", RADEON_M10 },
+	{ "M10/11 NS", RADEON_M10 },
+	{ "M10/11 NT", RADEON_M10 },
+	{ "M10/11 NV", RADEON_M10 },
 };
 
 
@@ -321,20 +356,37 @@
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_Le, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_Le},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_Lf, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_Lf},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_Lg, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_Lg},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON__c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON__c},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_ND, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_ND},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NE},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NF},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NG, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NG},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AE},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AF, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AF},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AH, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AH},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AI, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AI},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AJ, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AJ},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AK, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AK},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NH, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NH},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NI, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NI},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NJ, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NJ},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NK, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NK},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_Y_, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_Y_},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_Ya, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_Ya},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_Yd, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_Yd},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AD, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AD},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AP, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AP},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AQ, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AQ},
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AR, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AR},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AS, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AS},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AT, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AT},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_AV, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_AV},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NP, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NP},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NQ, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NQ},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NR, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NR},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NS, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NS},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NT, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NT},
+	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_NV, PCI_ANY_ID, PCI_ANY_ID, 0, 0, RADEON_NV},
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, radeonfb_pci_table);
@@ -509,6 +561,7 @@
 	int got_dfpinfo;
 
 	int hasCRTC2;
+	int is_mobility;
 	int crtDisp_type;
 	int dviDisp_type;
 
@@ -1700,6 +1753,16 @@
 			rinfo->hasCRTC2 = 1;
 			break;
 	}
+	switch(rinfo->arch) {
+	case RADEON_M6:
+	case RADEON_M7:
+	case RADEON_M9:
+	case RADEON_M10:
+		rinfo->is_mobility = 1;
+		break;
+	default:
+		rinfo->is_mobility = 0;
+	}
 
 	if (mirror)
 		printk("radeonfb: mirroring display to CRT\n");
@@ -1789,10 +1852,7 @@
 #if !defined(__powerpc__)
 	radeon_get_moninfo(rinfo);
 #else
-	switch (rinfo->arch) {
-		case RADEON_M6:
-		case RADEON_M7:
-		case RADEON_M9:
+	if (rinfo->is_mobility) {
 			/* If forced to no-LCD, we shut down the backlight */
 			if (force_nolcd) {
 #ifdef CONFIG_PMAC_BACKLIGHT
@@ -1800,13 +1860,11 @@
 #endif
 			} else {
 				rinfo->dviDisp_type = MT_LCD;
-				break;
+			goto mon_detected;
 			}
-			/* Fall through */
-		default:
-			radeon_get_moninfo(rinfo);
-			break;
 	}
+	radeon_get_moninfo(rinfo);
+ mon_detected:
 #endif
 
 	radeon_get_EDID(rinfo);
@@ -1890,9 +1948,12 @@
 
 
 #ifdef CONFIG_PMAC_BACKLIGHT
-	if (rinfo->dviDisp_type == MT_LCD)
+	if (rinfo->dviDisp_type == MT_LCD) {
 		register_backlight_controller(&radeon_backlight_controller,
 					      rinfo, "ati");
+		register_backlight_controller(&radeon_backlight_controller,
+					      rinfo, "mnca");
+	}
 #endif
 
 	printk ("radeonfb: ATI Radeon %s %s %d MB\n", rinfo->name, rinfo->ram_type,
@@ -2581,14 +2642,8 @@
 		 * TODO:  set mirror accordingly for non-Mobility chipsets with 2 CRTC's
 		 */
 		case FBIO_RADEON_SET_MIRROR:
-			switch (rinfo->arch) {
-				case RADEON_M6:
-				case RADEON_M7:
-				case RADEON_M9:
-					break;
-				default:
+			if (!rinfo->is_mobility)
 					return -EINVAL;
-			}
 
 			rc = get_user(value, (__u32*)arg);
 
@@ -2624,14 +2679,8 @@
 			return 0;
 
 		case FBIO_RADEON_GET_MIRROR:
-			switch (rinfo->arch) {
-				case RADEON_M6:
-				case RADEON_M7:
-				case RADEON_M9:
-					break;
-				default:
+			if (!rinfo->is_mobility)
 					return -EINVAL;
-			}
 
 			tmp = INREG(LVDS_GEN_CNTL);
 			if ((LVDS_ON | LVDS_BLON) & tmp)
@@ -2965,6 +3014,8 @@
 	/* Gross hack for iBook with M7 until I find out a proper fix */
 	if (machine_is_compatible("PowerBook4,3") && rinfo->arch == RADEON_M7)
 		regs->ppll_div_3 = 0x000600ad;
+	if (machine_is_compatible("PowerBook6,3") && rinfo->arch == RADEON_M9)
+		regs->ppll_div_3 = 0x000600ad;
 #endif /* CONFIG_ALL_PPC */
 
 	RTRACE("post div = 0x%x\n", rinfo->post_div);
@@ -2982,12 +3033,6 @@
 	u8 hsync_fudge_fp[] = {2, 2, 0, 0, 5, 5};
 	u32 sync, h_sync_pol, v_sync_pol, dotClock, pixClock;
 	unsigned int freq;
-#if 0
-        unsigned int xclk_freq, vclk_freq;
-        int xclk_per_trans, xclk_per_trans_precise;
-        int useable_precision, roff, ron;
-        int min_bits;
-#endif
 	int format = 0;
 	int hsync_start, hsync_fudge, bytpp, hsync_wid, vsync_wid;
 	int primary_mon = PRIMARY_MONITOR(rinfo);
@@ -3169,42 +3214,6 @@
 
 	newmode.vclk_ecp_cntl = rinfo->init_state.vclk_ecp_cntl;
 
-#if 0
-	/* DDA */
-	/* XXX: Figure out if there is really a DDA on radeons ! I think there
-	 * isn't actually...
-	 */
-	vclk_freq = round_div(rinfo->pll.ref_clk * rinfo->fb_div,
-			      rinfo->pll.ref_div * rinfo->post_div);
-	xclk_freq = rinfo->pll.xclk;
-
-	xclk_per_trans = round_div(xclk_freq * 128, vclk_freq * mode->bits_per_pixel);
-
-	min_bits = min_bits_req(xclk_per_trans);
-	useable_precision = min_bits + 1;
-
-	xclk_per_trans_precise = round_div((xclk_freq * 128) << (11 - useable_precision),
-					   vclk_freq * mode->bits_per_pixel);
-
-	ron = (4 * rinfo->ram.mb + 3 * _max(rinfo->ram.trcd - 2, 0) +
-	       2 * rinfo->ram.trp + rinfo->ram.twr + rinfo->ram.cl + rinfo->ram.tr2w +
-	       xclk_per_trans) << (11 - useable_precision);
-	roff = xclk_per_trans_precise * (32 - 4);
-
-	RTRACE("ron = %d, roff = %d\n", ron, roff);
-	RTRACE("vclk_freq = %d, per = %d\n", vclk_freq, xclk_per_trans_precise);
-
-	if ((ron + rinfo->ram.rloop) >= roff) {
-		printk("radeonfb: error ron out of range\n");
-		return;
-	}
-
-	newmode.dda_config = (xclk_per_trans_precise |
-			      (useable_precision << 16) |
-			      (rinfo->ram.rloop << 20));
-	newmode.dda_on_off = (ron << 16) | roff;
-#endif
-
 	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
 		unsigned int hRatio, vRatio;
 
@@ -3304,8 +3313,10 @@
 
 static void radeon_write_pll_regs(struct radeonfb_info *rinfo, struct radeon_regs *mode)
 {
+	int i;
+
 	/* Workaround from XFree */
-	if (rinfo->arch < RADEON_R300) {
+	if (rinfo->is_mobility) {
 	        /* A temporal workaround for the occational blanking on certain laptop panels. 
 	           This appears to related to the PLL divider registers (fail to lock?).  
 		   It occurs even when all dividers are the same with their old settings.  
@@ -3318,31 +3329,65 @@
             		return;
 	}
 
-	while ((INREG(CLOCK_CNTL_INDEX) & PPLL_DIV_SEL_MASK) !=
-	       PPLL_DIV_SEL_MASK) {
-		OUTREGP(CLOCK_CNTL_INDEX, PPLL_DIV_SEL_MASK, 0xffff);
-	}
-
-	OUTPLLP(PPLL_CNTL, PPLL_RESET, 0xffff);
+	/* Swich VCKL clock input to CPUCLK so it stays fed while PPLL updates*/
+	OUTPLLP(VCLK_ECP_CNTL, VCLK_SRC_SEL_CPUCLK, ~VCLK_SRC_SEL_MASK);
 
-	while ((INPLL(PPLL_REF_DIV) & PPLL_REF_DIV_MASK) !=
-	       (mode->ppll_ref_div & PPLL_REF_DIV_MASK)) {
-		OUTPLLP(PPLL_REF_DIV, mode->ppll_ref_div, ~PPLL_REF_DIV_MASK);
+	/* Reset PPLL & enable atomic update */
+	OUTPLLP(PPLL_CNTL,
+		PPLL_RESET | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN,
+		~(PPLL_RESET | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN));
+
+	/* Switch to PPLL div 3 */
+	OUTREGP(CLOCK_CNTL_INDEX, PPLL_DIV_SEL_MASK, ~PPLL_DIV_SEL_MASK);
+
+	/* Set PPLL ref. div */
+	if (rinfo->arch == RADEON_R300 ||
+	    rinfo->arch == RADEON_R350 ||
+	    rinfo->arch == RADEON_RV350 ||
+	    rinfo->arch == RADEON_M10) {
+		if (mode->ppll_ref_div & R300_PPLL_REF_DIV_ACC_MASK) {
+			/* When restoring console mode, use saved PPLL_REF_DIV
+			 * setting.
+			 */
+			OUTPLLP(PPLL_REF_DIV, mode->ppll_ref_div, 0);
+		} else {
+			/* R300 uses ref_div_acc field as real ref divider */
+			OUTPLLP(PPLL_REF_DIV,
+				(mode->ppll_ref_div << R300_PPLL_REF_DIV_ACC_SHIFT), 
+				~R300_PPLL_REF_DIV_ACC_MASK);
 	}
+	} else
+		OUTPLLP(PPLL_REF_DIV, mode->ppll_ref_div, ~PPLL_REF_DIV_MASK);
 
-	while ((INPLL(PPLL_DIV_3) & PPLL_FB3_DIV_MASK) !=
-	       (mode->ppll_div_3 & PPLL_FB3_DIV_MASK)) {
+	/* Set PPLL divider 3 & post divider*/
 		OUTPLLP(PPLL_DIV_3, mode->ppll_div_3, ~PPLL_FB3_DIV_MASK);
-	}
-
-	while ((INPLL(PPLL_DIV_3) & PPLL_POST3_DIV_MASK) !=
-	       (mode->ppll_div_3 & PPLL_POST3_DIV_MASK)) {
 		OUTPLLP(PPLL_DIV_3, mode->ppll_div_3, ~PPLL_POST3_DIV_MASK);
-	}
+
+	/* Write update */
+	while (INPLL(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R)
+		;
+	OUTPLLP(PPLL_REF_DIV, PPLL_ATOMIC_UPDATE_W, ~PPLL_ATOMIC_UPDATE_W);
+
+	/* Wait read update complete */
+	/* FIXME: Certain revisions of R300 can't recover here.  Not sure of
+	   the cause yet, but this workaround will mask the problem for now.
+	   Other chips usually will pass at the very first test, so the
+	   workaround shouldn't have any effect on them. */
+	for (i = 0; (i < 10000 && INPLL(PPLL_REF_DIV) & PPLL_ATOMIC_UPDATE_R); i++)
+		;
 
 	OUTPLL(HTOTAL_CNTL, 0);
 
-	OUTPLLP(PPLL_CNTL, 0, ~PPLL_RESET);
+	/* Clear reset & atomic update */
+	OUTPLLP(PPLL_CNTL, 0,
+		~(PPLL_RESET | PPLL_SLEEP | PPLL_ATOMIC_UPDATE_EN | PPLL_VGA_ATOMIC_UPDATE_EN));
+
+	/* Let the clock to lock */
+	/* FIXME: Schedule here */
+	mdelay(5);
+
+	/* Switch back VCLK source to PPLL */
+	OUTPLLP(VCLK_ECP_CNTL, VCLK_SRC_SEL_PPLLCLK, ~VCLK_SRC_SEL_MASK);
 }
 
 static void radeon_write_mode (struct radeonfb_info *rinfo,
@@ -3375,16 +3420,14 @@
 	OUTREG(CRTC_PITCH, mode->crtc_pitch);
 	OUTREG(SURFACE_CNTL, mode->surface_cntl);
 
-	radeon_write_pll_regs(rinfo, mode);
+	/* Set surface registers to "sane" values */
+	for (i=0; i<8; i++) {
+		OUTREG(SURFACE0_LOWER_BOUND + 0x10*i, 0);
+		OUTREG(SURFACE0_UPPER_BOUND + 0x10*i, 0x1f);
+		OUTREG(SURFACE0_INFO + 0x10*i, 0);
+	}
 
-#if 0
-	/* Those don't seem to actually exist in radeon's, despite some drivers still
-	 * apparently trying to fill them, including some ATI sample codes ...
-	 * Can someone confirm what's up ? --BenH.
-	 */
-	OUTREG(DDA_CONFIG, mode->dda_config);
-	OUTREG(DDA_ON_OFF, mode->dda_on_off);
-#endif
+	radeon_write_pll_regs(rinfo, mode);
 
 	if ((primary_mon == MT_DFP) || (primary_mon == MT_LCD)) {
 		OUTREG(FP_CRTC_H_TOTAL_DISP, mode->fp_crtc_h_total_disp);
@@ -3453,13 +3496,15 @@
 {
 	struct radeonfb_info *rinfo = (struct radeonfb_info *)data;
 	unsigned int lvds_gen_cntl = INREG(LVDS_GEN_CNTL);
+	unsigned long tmpPixclksCntl = INPLL(PIXCLKS_CNTL);
 	int* conv_table;
 
 	/* Pardon me for that hack... maybe some day we can figure
 	 * out in what direction backlight should work on a given
 	 * panel ?
 	 */
-	if ((rinfo->arch == RADEON_M7 || rinfo->arch == RADEON_M9)
+	if ((rinfo->arch == RADEON_M7 || rinfo->arch == RADEON_M9 ||
+	     rinfo->arch == RADEON_M10)
 		&& !machine_is_compatible("PowerBook4,3"))
 		conv_table = backlight_conv_m7;
 	else
@@ -3472,7 +3517,7 @@
 			lvds_gen_cntl &= ~LVDS_BLON;
 			OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
 			(void)INREG(LVDS_GEN_CNTL);
-			mdelay(10);
+			mdelay(20); /* Ouch ! FIXME */
 			lvds_gen_cntl |= LVDS_BLON;
 			OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
 		}
@@ -3482,16 +3527,20 @@
 		lvds_gen_cntl |= (LVDS_ON | LVDS_EN);
 		lvds_gen_cntl &= ~LVDS_DISPLAY_DIS;
 	} else {
+		if (rinfo->is_mobility)
+			OUTPLLP(PIXCLKS_CNTL, 0, ~PIXCLK_LVDS_ALWAYS_ONb);
 		lvds_gen_cntl &= ~LVDS_BL_MOD_LEVEL_MASK;
 		lvds_gen_cntl |= (conv_table[0] <<
 				  LVDS_BL_MOD_LEVEL_SHIFT);
 		lvds_gen_cntl |= LVDS_DISPLAY_DIS;
 		OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
-		udelay(10);
+		mdelay(20); /* Ouch ! FIXME */
 		lvds_gen_cntl &= ~(LVDS_ON | LVDS_EN | LVDS_BLON | LVDS_DIGON);
 	}
 
 	OUTREG(LVDS_GEN_CNTL, lvds_gen_cntl);
+	if (rinfo->is_mobility)
+		OUTPLL(PIXCLKS_CNTL, tmpPixclksCntl);
 	rinfo->init_state.lvds_gen_cntl &= ~LVDS_STATE_MASK;
 	rinfo->init_state.lvds_gen_cntl |= (lvds_gen_cntl & LVDS_STATE_MASK);
 
diff -urN kernel-source-2.4.27/drivers/video/radeon.h kernel-source-2.4.27-benh/drivers/video/radeon.h
--- kernel-source-2.4.27/drivers/video/radeon.h	2003-08-25 13:44:42.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/radeon.h	2004-09-01 20:56:28.972714536 +0200
@@ -469,6 +469,17 @@
 #define BUS_READ_BURST                             0x40000000
 #define BUS_RDY_READ_DLY                           0x80000000
 
+/* PIXCLKS_CNTL */
+#define PIX2CLK_SRC_SEL_MASK                       0x03
+#define PIX2CLK_SRC_SEL_CPUCLK                     0x00
+#define PIX2CLK_SRC_SEL_PSCANCLK                   0x01
+#define PIX2CLK_SRC_SEL_BYTECLK                    0x02
+#define PIX2CLK_SRC_SEL_P2PLLCLK                   0x03
+#define PIX2CLK_ALWAYS_ONb                         (1<<6)
+#define PIX2CLK_DAC_ALWAYS_ONb                     (1<<7)
+#define PIXCLK_TV_SRC_SEL                          (1 << 8)
+#define PIXCLK_LVDS_ALWAYS_ONb                     (1 << 14)
+#define PIXCLK_TMDS_ALWAYS_ONb                     (1 << 15)
 
 /* CLOCK_CNTL_INDEX bit constants */
 #define PLL_WR_EN                                  0x00000080
@@ -808,6 +819,11 @@
 #define MRDCKA1_RESET                              0x00020000
 
 /* VCLK_ECP_CNTL constants */
+#define VCLK_SRC_SEL_MASK                          0x03
+#define VCLK_SRC_SEL_CPUCLK                        0x00
+#define VCLK_SRC_SEL_PSCANCLK                      0x01
+#define VCLK_SRC_SEL_BYTECLK	                   0x02
+#define VCLK_SRC_SEL_PPLLCLK			   0x03
 #define PIXCLK_ALWAYS_ONb                          0x00000040
 #define PIXCLK_DAC_ALWAYS_ONb                      0x00000080
 
@@ -874,6 +890,7 @@
 #define DEFAULT_TILE_MASK		0xc0000000
 #define	PPLL_DIV_SEL_MASK		0x00000300
 #define	PPLL_RESET			0x00000001
+#define	PPLL_SLEEP			0x00000002
 #define PPLL_ATOMIC_UPDATE_EN		0x00010000
 #define PPLL_REF_DIV_MASK		0x000003ff
 #define	PPLL_FB3_DIV_MASK		0x000007ff
@@ -881,6 +898,8 @@
 #define PPLL_ATOMIC_UPDATE_R		0x00008000
 #define PPLL_ATOMIC_UPDATE_W		0x00008000
 #define	PPLL_VGA_ATOMIC_UPDATE_EN	0x00020000
+#define R300_PPLL_REF_DIV_ACC_MASK	(0x3ff << 18)
+#define R300_PPLL_REF_DIV_ACC_SHIFT	18
 
 #define GUI_ACTIVE			0x80000000
 
diff -urN kernel-source-2.4.27/drivers/video/riva/accel.c kernel-source-2.4.27-benh/drivers/video/riva/accel.c
--- kernel-source-2.4.27/drivers/video/riva/accel.c	2004-08-08 01:26:05.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/riva/accel.c	2004-09-01 20:56:28.974714232 +0200
@@ -14,6 +14,7 @@
 
 inline void wait_for_idle(struct rivafb_info *rinfo)
 {
+	mb();
 	while (rinfo->riva.Busy(&rinfo->riva));
 }
 
@@ -48,7 +49,9 @@
 
 	RIVA_FIFO_FREE(rinfo->riva, Bitmap, 2);
 	rinfo->riva.Bitmap->UnclippedRectangle[0].TopLeft     = (sx << 16) | sy; 
+	wmb();
 	rinfo->riva.Bitmap->UnclippedRectangle[0].WidthHeight = (width << 16) | height;
+	wmb();
 }
 
 static void fbcon_riva_bmove(struct display *p, int sy, int sx, int dy, int dx,
@@ -66,6 +69,7 @@
 	RIVA_FIFO_FREE(rinfo->riva, Blt, 3);
 	rinfo->riva.Blt->TopLeftSrc  = (sy << 16) | sx;
 	rinfo->riva.Blt->TopLeftDst  = (dy << 16) | dx;
+	wmb();
 	rinfo->riva.Blt->WidthHeight = (height  << 16) | width;
 
 	wait_for_idle(rinfo);
@@ -141,7 +145,9 @@
         rinfo->riva.Bitmap->Color1E           = fgx;
         rinfo->riva.Bitmap->WidthHeightInE  = (h << 16) | 32;
         rinfo->riva.Bitmap->WidthHeightOutE = (h << 16) | 32;
+	wmb();
         rinfo->riva.Bitmap->PointE          = (yy << 16) | (xx & 0xFFFF);
+	wmb();
 	
 	d = &rinfo->riva.Bitmap->MonochromeData01E;
 	for (i = h; i > 0; i-=16) {
@@ -151,10 +157,19 @@
 			cnt = i;
 		RIVA_FIFO_FREE(rinfo->riva, Bitmap, cnt);
 		for (j = 0; j < cnt; j++) {
-			if (w <= 8) 
+			if (w <= 8) {
+#ifdef __BIG_ENDIAN
+				cdat2 = (*cdat++) << 24;
+#else
 				cdat2 = *cdat++;
-			else
+#endif				
+			} else {
+#ifdef __BIG_ENDIAN
 				cdat2 = *((u16*)cdat)++;
+#else
+				cdat2 = (*((u16*)cdat)++) << 16;
+#endif			
+			}
 			fbcon_reverse_order(&cdat2);
 			d[j] = cdat2;
 		}
@@ -228,9 +243,11 @@
 
 	RIVA_FIFO_FREE(rinfo->riva, Rop, 1);
 	rinfo->riva.Rop->Rop3 = 0x66; // XOR
+	wmb();
 	riva_rectfill(rinfo, yy, xx, fontheight(p), fontwidth(p), 0x0f);
 	RIVA_FIFO_FREE(rinfo->riva, Rop, 1);
 	rinfo->riva.Rop->Rop3 = 0xCC; // back to COPY
+	wmb();
 }
 
 static void fbcon_riva8_clear_margins(struct vc_data *conp, struct display *p,
@@ -243,17 +260,10 @@
 	setup:		fbcon_riva8_setup,
 	bmove:		fbcon_riva_bmove,
 	clear:		fbcon_riva8_clear,
-#ifdef __BIG_ENDIAN
-	putc:		fbcon_cfb8_putc,
-	putcs:		fbcon_cfb8_putcs,
-	revc:		fbcon_cfb8_revc,
-	clear_margins:	fbcon_cfb8_clear_margins,
-#else
 	putc:		fbcon_riva8_putc,
 	putcs:		fbcon_riva8_putcs,
 	revc:		fbcon_riva8_revc,
 	clear_margins:	fbcon_riva8_clear_margins,
-#endif	
 	fontwidthmask:	FONTWIDTHRANGE(4, 16)
 };
 #endif
@@ -268,9 +278,11 @@
 
 	RIVA_FIFO_FREE(rinfo->riva, Rop, 1);
 	rinfo->riva.Rop->Rop3 = 0x66; // XOR
+	wmb();
 	riva_rectfill(rinfo, yy, xx, fontheight(p), fontwidth(p), 0xffffffff);
 	RIVA_FIFO_FREE(rinfo->riva, Rop, 1);
 	rinfo->riva.Rop->Rop3 = 0xCC; // back to COPY
+	wmb();
 }
 #endif
 
@@ -353,17 +365,10 @@
 	setup:		fbcon_riva16_setup,
 	bmove:		fbcon_riva_bmove,
 	clear:		fbcon_riva16_clear,
-#ifdef __BIG_ENDIAN
-	putc:		fbcon_cfb16_putc,
-	putcs:		fbcon_cfb16_putcs,
-	revc:		fbcon_cfb16_revc,
-	clear_margins:	fbcon_cfb16_clear_margins,
-#else
 	putc:		fbcon_riva16_putc,
 	putcs:		fbcon_riva16_putcs,
 	revc:		fbcon_riva1632_revc,
 	clear_margins:	fbcon_riva16_clear_margins,
-#endif
 	fontwidthmask:	FONTWIDTHRANGE(4, 16)
 };
 #endif
@@ -434,17 +439,10 @@
 	setup:		fbcon_riva32_setup,
 	bmove:		fbcon_riva_bmove,
 	clear:		fbcon_riva32_clear,
-#ifdef __BIG_ENDIAN
-	putc:		fbcon_cfb32_putc,
-	putcs:		fbcon_cfb32_putcs,
-	revc:		fbcon_cfb32_revc,
-	clear_margins:	fbcon_cfb32_clear_margins,
-#else
 	putc:		fbcon_riva32_putc,
 	putcs:		fbcon_riva32_putcs,
 	revc:		fbcon_riva1632_revc,
 	clear_margins:	fbcon_riva32_clear_margins,
-#endif
 	fontwidthmask:	FONTWIDTHRANGE(4, 16)
 };
 #endif
diff -urN kernel-source-2.4.27/drivers/video/riva/fbdev.c kernel-source-2.4.27-benh/drivers/video/riva/fbdev.c
--- kernel-source-2.4.27/drivers/video/riva/fbdev.c	2004-08-08 01:26:05.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/riva/fbdev.c	2004-09-01 20:56:29.221676688 +0200
@@ -55,10 +55,13 @@
 #error This driver requires PCI support.
 #endif
 
-
+#include <linux/adb.h>
+#include <linux/pmu.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
 
 /* version number of this driver */
-#define RIVAFB_VERSION "0.9.4"
+#define RIVAFB_VERSION "0.9.4b"
 
 
 
@@ -131,23 +134,43 @@
 	CH_RIVA_128 = 0,
 	CH_RIVA_TNT,
 	CH_RIVA_TNT2,
-	CH_RIVA_UTNT2,	/* UTNT2 */
-	CH_RIVA_VTNT2,	/* VTNT2 */
-	CH_RIVA_UVTNT2,	/* VTNT2 */
-	CH_RIVA_ITNT2,	/* ITNT2 */
+	CH_RIVA_UTNT2,
+	CH_RIVA_VTNT2,
+	CH_RIVA_UVTNT2,
+	CH_RIVA_ITNT2,
 	CH_GEFORCE_SDR,
 	CH_GEFORCE_DDR,
 	CH_QUADRO,
 	CH_GEFORCE2_MX,
+	CH_GEFORCE2_MX2,
+	CH_GEFORCE2_GO,
 	CH_QUADRO2_MXR,
 	CH_GEFORCE2_GTS,
+	CH_GEFORCE2_GTS2,
 	CH_GEFORCE2_ULTRA,
 	CH_QUADRO2_PRO,
-	CH_GEFORCE2_GO,
+	CH_GEFORCE4_MX_460,
+	CH_GEFORCE4_MX_440,
+	CH_GEFORCE4_MX_420,
+	CH_GEFORCE4_440_GO,
+	CH_GEFORCE4_420_GO,
+	CH_GEFORCE4_420_GO_M32,
+	CH_QUADRO4_500XGL,
+	CH_GEFORCE4_440_GO_M64,
+	CH_QUADRO4_200,
+	CH_QUADRO4_550XGL,
+	CH_QUADRO4_500_GOGL,
+	CH_IGEFORCE2,
         CH_GEFORCE3,
         CH_GEFORCE3_1,
         CH_GEFORCE3_2,
-        CH_QUADRO_DDC
+	CH_QUADRO_DDC,
+	CH_GEFORCE4_TI_4600,
+	CH_GEFORCE4_TI_4400,
+	CH_GEFORCE4_TI_4200,
+	CH_QUADRO4_900XGL,
+	CH_QUADRO4_750XGL,
+	CH_QUADRO4_700XGL
 };
 
 /* directly indexed by riva_chips enum, above */
@@ -166,15 +189,35 @@
 	{ "GeForce-DDR", NV_ARCH_10},
 	{ "Quadro", NV_ARCH_10},
 	{ "GeForce2-MX", NV_ARCH_10},
+	{ "GeForce2-MX", NV_ARCH_10 },
+	{ "GeForce2-GO", NV_ARCH_10 },
 	{ "Quadro2-MXR", NV_ARCH_10},
 	{ "GeForce2-GTS", NV_ARCH_10},
+	{ "GeForce2-GTS", NV_ARCH_10 },
 	{ "GeForce2-ULTRA", NV_ARCH_10},
 	{ "Quadro2-PRO", NV_ARCH_10},
-        { "GeForce2-Go", NV_ARCH_10},
+	{ "GeForce4-MX-460", NV_ARCH_20 },
+	{ "GeForce4-MX-440", NV_ARCH_20 },
+	{ "GeForce4-MX-420", NV_ARCH_20 },
+	{ "GeForce4-440-GO", NV_ARCH_20 },
+	{ "GeForce4-420-GO", NV_ARCH_20 },
+	{ "GeForce4-420-GO-M32", NV_ARCH_20 },
+	{ "Quadro4-500-XGL", NV_ARCH_20 },
+	{ "GeForce4-440-GO-M64", NV_ARCH_20 },
+	{ "Quadro4-200", NV_ARCH_20 },
+	{ "Quadro4-550-XGL", NV_ARCH_20 },
+	{ "Quadro4-500-GOGL", NV_ARCH_20 },
+	{ "GeForce2", NV_ARCH_20 },
         { "GeForce3", NV_ARCH_20}, 
         { "GeForce3 Ti 200", NV_ARCH_20},
         { "GeForce3 Ti 500", NV_ARCH_20},
-        { "Quadro DDC", NV_ARCH_20}
+	{ "Quadro DDC", NV_ARCH_20 },
+	{ "GeForce4 Ti 4600", NV_ARCH_20 },
+	{ "GeForce4 Ti 4400", NV_ARCH_20 },
+	{ "GeForce4 Ti 4200", NV_ARCH_20 },
+	{ "Quadro4-900-XGL", NV_ARCH_20 },
+	{ "Quadro4-750-XGL", NV_ARCH_20 },
+	{ "Quadro4-700-XGL", NV_ARCH_20 }
 };
 
 static struct pci_device_id rivafb_pci_tbl[] __devinitdata = {
@@ -201,19 +244,43 @@
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_MX },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX2,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_MX },
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_MX2 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_GO,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_GO },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO2_MXR },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_GTS },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_GTS },
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_GTS2 },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_ULTRA },
 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO2_PRO },
-        { PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE2_GO,
-          PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE2_GO },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_460,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_MX_460 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_MX_440 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_420,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_MX_420 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_440_GO },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_420_GO },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO_M32,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_420_GO_M32 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_500XGL,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO4_500XGL },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO_M64,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_440_GO_M64 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_200,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO4_200 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_550XGL,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO4_550XGL },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_500_GOGL,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO4_500_GOGL },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_IGEFORCE2,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_IGEFORCE2 },
         { PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE3,
           PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE3 },
         { PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE3_1,
@@ -222,6 +289,18 @@
           PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE3_2 },
         { PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO_DDC,
           PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO_DDC },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4600,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_TI_4600 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4400,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_TI_4400 },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4200,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_GEFORCE4_TI_4200 },
+ 	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_900XGL,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO4_900XGL },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_750XGL,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO4_750XGL },
+	{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_QUADRO4_700XGL,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, CH_QUADRO4_700XGL },
 	{ 0, } /* terminate list */
 };
 MODULE_DEVICE_TABLE(pci, rivafb_pci_tbl);
@@ -278,12 +357,14 @@
 
 /* command line data, set in rivafb_setup() */
 static char fontname[40] __initdata = { 0 };
-static char noaccel __initdata = 0;
-static char nomove = 0;
-static char nohwcursor __initdata = 0;
-static char noblink = 0;
+static int noaccel __initdata = 0;
+static int nomove = 0;
+static int nohwcursor __initdata = 0;
+static int noblink = 0;
+static int flatpanel __initdata = -1; /* Autodetect later */
+static int forceCRTC __initdata = -1;
 #ifdef CONFIG_MTRR
-static char nomtrr __initdata = 0;
+static int nomtrr __initdata = 0;
 #endif
 
 #ifndef MODULE
@@ -342,7 +423,93 @@
 	0xEB							/* MISC */
 };
 
+/*
+ * Here is some specific support for the eMac machine
+ * 
+ * This machine is "special" because of it's ivad2 display
+ * controller and fixed horizontal timing requirements.
+ * 
+ * Right now, all I do is to set a fixed working 1024x768
+ * mode at boot (I also have a 1280x960 at hand, if you
+ * prefer...).
+ * 
+ * I expect to do things better in a future 2.5 version
+ * though.
+ * 
+ * I also turn off the screen during blanking using IVAD
+ * i2c accesses, that's the basis we can use to later
+ * implement full IVAD support (geometry setting,
+ * brightness, ...).
+ */
+#if defined(CONFIG_ALL_PPC) && defined(CONFIG_ADB_PMU)
+
+static int ivad_iic_addr = -1;
+
+/* Default mode for eMac */
+static struct fb_var_screeninfo emac_default_var = {
+	xres:		1024,
+	yres:		768,
+	xres_virtual:	1024,
+	yres_virtual:	768,
+	xoffset:	0,
+	yoffset:	0,
+	bits_per_pixel:	8,
+	grayscale:	0,
+	red:		{0, 6, 0},
+	green:		{0, 6, 0},
+	blue:		{0, 6, 0},
+	transp:		{0, 0, 0},
+	nonstd:		0,
+	activate:	0,
+	height:		-1,
+	width:		-1,
+	accel_flags:	0,
+	pixclock:	10081,
+	left_margin:	208,
+	right_margin:	48,
+	upper_margin:	31,
+	lower_margin:	1,
+	hsync_len:	96,
+	vsync_len:	3,
+	sync:		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	vmode:		FB_VMODE_NONINTERLACED
+};
+
+static void
+init_ivad(void)
+{
+	if (machine_is_compatible("PowerMac4,4")) {
+		struct device_node* np = find_devices("ivad2");
+		unsigned int* prop;
+		
+		if (np == NULL)
+			return;
+		prop = (unsigned int*)get_property(np, "iic-address", NULL);
+		if (np == NULL) {
+			printk(KERN_INFO "IVAD2 found but has no iic-address property !\n");
+			return;
+		}
+		ivad_iic_addr = *prop;
+		printk(KERN_INFO "Found IVAD2, iic address is: 0x%02x\n", ivad_iic_addr);
+		rivafb_default_var = emac_default_var;
+	}
+}
 
+#define IVAD_CONTRAST_REG	0x00
+
+static void
+set_ivad_contrast(u8 contrast)
+{
+	int rc;
+
+	if (ivad_iic_addr < 0)
+		return;
+	rc = pmu_i2c_stdsub_write(PMU_I2C_BUS_POWER, ivad_iic_addr, IVAD_CONTRAST_REG, &contrast, 1);
+	if (rc < 0)
+		printk(KERN_ERR "IVAD2: Can't set contrast !\n");
+}
+
+#endif /* defined(CONFIG_ALL_PPC) && defined(CONFIG_ADB_PMU) */
 
 /* ------------------------------------------------------------------------- *
  *
@@ -445,7 +612,7 @@
 	if (rinfo->cursor->vbl_cnt && --rinfo->cursor->vbl_cnt == 0) {
 		rinfo->cursor->on ^= 1;
 		if (rinfo->cursor->on)
-			*(rinfo->riva.CURSORPOS) = (rinfo->cursor->pos.x & 0xFFFF)
+			rinfo->riva.PRAMDAC[0x0000300/4] = (rinfo->cursor->pos.x & 0xFFFF)
 						   | (rinfo->cursor->pos.y << 16);
 		rinfo->riva.ShowHideCursor(&rinfo->riva, rinfo->cursor->on);
 		if (!noblink)
@@ -646,7 +813,7 @@
 		if (c->last_move_delay <= 1) { /* rapid cursor movement */
 			c->vbl_cnt = CURSOR_SHOW_DELAY;
 		} else {
-			*(rinfo->riva.CURSORPOS) = (x & 0xFFFF) | (y << 16);
+			rinfo->riva.PRAMDAC[0x0000300/4] = (x & 0xFFFF) | (y << 16);
 			rinfo->riva.ShowHideCursor(&rinfo->riva, 1);
 			if (!noblink) c->vbl_cnt = CURSOR_HIDE_DELAY;
 			c->on = 1;
@@ -886,9 +1053,10 @@
 	hEnd = (hDisplaySize + video_mode->right_margin +
 		video_mode->hsync_len) / 8 - 1;
 	hTotal = (hDisplaySize + video_mode->right_margin +
-		  video_mode->hsync_len + video_mode->left_margin) / 8 - 1;
+		  video_mode->hsync_len + video_mode->left_margin) / 8 - 5;
 	hBlankStart = hDisplay;
-	hBlankEnd = hTotal;
+	hBlankEnd = hTotal + 4;
+
 	height = video_mode->yres_virtual;
 	vDisplay = video_mode->yres - 1;
 	vStart = video_mode->yres + video_mode->lower_margin - 1;
@@ -897,28 +1065,12 @@
 	vTotal = video_mode->yres + video_mode->lower_margin +
 		 video_mode->vsync_len + video_mode->upper_margin + 2;
 	vBlankStart = vDisplay;
-	vBlankEnd = vTotal;
+	vBlankEnd = vTotal + 1;
 	dotClock = 1000000000 / video_mode->pixclock;
 
 	memcpy(&newmode, &reg_template, sizeof(struct riva_regs));
 
-	newmode.ext.screen = SetBitField(hBlankEnd,6:6,4:4)
-                  | SetBitField(vBlankStart,10:10,3:3)
-                  | SetBitField(vStart,10:10,2:2)
-                  | SetBitField(vDisplay,10:10,1:1)
-                  | SetBitField(vTotal,10:10,0:0);
-    
-    	newmode.ext.horiz  = SetBitField(hTotal,8:8,0:0)
-                  | SetBitField(hDisplay,8:8,1:1)
-                  | SetBitField(hBlankStart,8:8,2:2)
-                  | SetBitField(hStart,8:8,3:3);
-
-    	newmode.ext.extra  = SetBitField(vTotal,11:11,0:0)
-                    | SetBitField(vDisplay,11:11,2:2)
-                    | SetBitField(vStart,11:11,4:4)
-                    | SetBitField(vBlankStart,11:11,6:6);
-
-	if (rinfo->riva.flatPanel) {
+	if (rinfo->FlatPanel) {
 		vStart = vTotal - 3;
 		vEnd = vTotal - 2;
 		vBlankStart = vStart;
@@ -927,11 +1079,10 @@
 		hBlankEnd = hTotal + 4;
 	}
 
-	newmode.crtc[0x0] = Set8Bits (hTotal - 4);
+	newmode.crtc[0x0] = Set8Bits (hTotal); 
 	newmode.crtc[0x1] = Set8Bits (hDisplay);
 	newmode.crtc[0x2] = Set8Bits (hBlankStart);
-	newmode.crtc[0x3] = SetBitField(hBlankEnd,4:0,4:0)
-                | SetBit(7);
+	newmode.crtc[0x3] = SetBitField (hBlankEnd, 4: 0, 4:0) | SetBit (7);
 	newmode.crtc[0x4] = Set8Bits (hStart);
 	newmode.crtc[0x5] = SetBitField (hBlankEnd, 5: 5, 7:7)
  		| SetBitField (hEnd, 4: 0, 4:0);
@@ -1463,6 +1614,12 @@
 
 	accel = v.accel_flags & FB_ACCELF_TEXT;
 
+	/* Accel seem to not work properly on GeForce4's yet...*/
+	if (rivainfo->riva.Architecture == NV_ARCH_20) {
+		v.accel_flags &= ~FB_ACCELF_TEXT;
+		accel = 0;
+	}
+
 	switch (v.bits_per_pixel) {
 #ifdef FBCON_HAS_CFB8
 	case 1 ... 8:
@@ -1802,6 +1959,13 @@
 			vesa |= 0xc0;
 			break;
 		}
+#if defined(CONFIG_ALL_PPC) && defined(CONFIG_ADB_PMU)
+		set_ivad_contrast(0);
+#endif
+	} else {
+#if defined(CONFIG_ALL_PPC) && defined(CONFIG_ADB_PMU)
+		set_ivad_contrast(0xff);
+#endif
 	}
 
 	SEQout(rinfo, 0x01, tmp);
@@ -1877,6 +2041,14 @@
 
 	riva_set_dispsw(rinfo, disp);
 
+	if (disp->var.accel_flags & FB_ACCELF_TEXT) {
+		if (nomove)
+			disp->scrollmode = SCROLL_YNOMOVE;
+		else
+			disp->scrollmode = 0;
+	} else
+		disp->scrollmode = SCROLL_YREDRAW;
+
 	DPRINTK("EXIT, returning 0\n");
 	return 0;
 
@@ -1913,18 +2085,36 @@
 }
 
 #ifdef CONFIG_ALL_PPC
+/*
+ * For now we only retreive EDID for flat panels, we'll fix that
+ * once we know what to do of non-flat panel EDIDs, that is typically
+ * in 2.5 --BenH.
+ */
 static int riva_get_EDID_OF(struct rivafb_info *rinfo)
 {
 	struct device_node *dp;
 	unsigned char *pedid = NULL;
+        unsigned char *disptype = NULL;
+        static char *propnames[] = {
+        	"DFP,EDID", "LCD,EDID", "EDID", "EDID1", "EDID,B", "EDID,A", NULL };
+        int i;  
 
 	dp = pci_device_to_OF_node(rinfo->pd);
-	pedid = (unsigned char *)get_property(dp, "EDID,B", 0);
-
-	if (pedid) {
+        for (; dp != NULL; dp = dp->child) {
+               	disptype = (unsigned char *)get_property(dp, "display-type", NULL);
+                if (disptype == NULL)
+                	continue;
+                if (strncmp(disptype, "LCD", 3) != 0)
+                	continue;
+                for (i = 0; propnames[i] != NULL; ++i) {
+                        pedid = (unsigned char *)
+                                get_property(dp, propnames[i], NULL);
+                        if (pedid != NULL) {
 		rinfo->EDID = pedid;
 		return 1;
-	} else
+                        }
+                }
+        }
 		return 0;
 }
 #endif /* CONFIG_ALL_PPC */
@@ -1959,7 +2149,8 @@
                         rinfo->vAct_high = 1;
 	}
 
-	printk("rivafb: detected DFP panel size from EDID: %dx%d\n",
+	printk(KERN_INFO PFX
+			"detected DFP panel size from EDID: %dx%d\n", 
 		rinfo->panel_xres, rinfo->panel_yres);
 
 	rinfo->got_dfpinfo = 1;
@@ -2020,7 +2211,8 @@
 	if (riva_dfp_parse_EDID(rinfo))
 		riva_update_default_var(rinfo);
 
-	rinfo->riva.flatPanel = rinfo->got_dfpinfo;
+	if (rinfo->FlatPanel == -1 && rinfo->got_dfpinfo == 1) /* if user specified flatpanel, we respect that */
+		rinfo->FlatPanel = 1;
 }
 
 
@@ -2049,6 +2241,14 @@
 	rinfo->drvr_name = rci->name;
 	rinfo->riva.Architecture = rci->arch_rev;
 
+	rinfo->Chipset = (pd->vendor << 16) | pd->device;
+	printk(KERN_INFO PFX "nVidia device/chipset %X\n", rinfo->Chipset);
+	
+	rinfo->FlatPanel = flatpanel;
+	if (flatpanel == 1)
+		printk(KERN_INFO PFX "flatpanel support enabled\n");
+	rinfo->forceCRTC = forceCRTC;
+	
 	rinfo->pd = pd;
 	rinfo->base0_region_size = pci_resource_len(pd, 0);
 	rinfo->base1_region_size = pci_resource_len(pd, 1);
@@ -2065,100 +2265,65 @@
 	rinfo->ctrl_base_phys = pci_resource_start(rinfo->pd, 0);
 	rinfo->fb_base_phys = pci_resource_start(rinfo->pd, 1);
 
+	if (!request_mem_region(rinfo->ctrl_base_phys,
+				rinfo->base0_region_size, "rivafb")) {
+		printk(KERN_ERR PFX "cannot reserve MMIO region\n");
+		goto err_out_kfree;
+	}
+
 	rinfo->ctrl_base = ioremap(rinfo->ctrl_base_phys,
 				   rinfo->base0_region_size);
 	if (!rinfo->ctrl_base) {
 		printk(KERN_ERR PFX "cannot ioremap MMIO base\n");
-		goto err_out_free_base1;
+		goto err_out_free_base0;
 	}
 	
 	riva_get_EDID(rinfo);
 
 	riva_get_dfpinfo(rinfo);
 
-	rinfo->riva.EnableIRQ = 0;
-	rinfo->riva.PRAMDAC = (unsigned *)(rinfo->ctrl_base + 0x00680000);
-	rinfo->riva.PFB = (unsigned *)(rinfo->ctrl_base + 0x00100000);
-	rinfo->riva.PFIFO = (unsigned *)(rinfo->ctrl_base + 0x00002000);
-	rinfo->riva.PGRAPH = (unsigned *)(rinfo->ctrl_base + 0x00400000);
-	rinfo->riva.PEXTDEV = (unsigned *)(rinfo->ctrl_base + 0x00101000);
-	rinfo->riva.PTIMER = (unsigned *)(rinfo->ctrl_base + 0x00009000);
-	rinfo->riva.PMC = (unsigned *)(rinfo->ctrl_base + 0x00000000);
-	rinfo->riva.FIFO = (unsigned *)(rinfo->ctrl_base + 0x00800000);
-
-	rinfo->riva.PCIO = (U008 *)(rinfo->ctrl_base + 0x00601000);
-	rinfo->riva.PDIO = (U008 *)(rinfo->ctrl_base + 0x00681000);
-	rinfo->riva.PVIO = (U008 *)(rinfo->ctrl_base + 0x000C0000);
-
-	rinfo->riva.IO = (MISCin(rinfo) & 0x01) ? 0x3D0 : 0x3B0;
-
-	if (rinfo->riva.Architecture == NV_ARCH_03) {
-		/*
-		 * We have to map the full BASE_1 aperture for Riva128's
-		 * because they use the PRAMIN set in "framebuffer" space
+	switch (rinfo->riva.Architecture) {
+	case NV_ARCH_03:
+		/* Riva128's PRAMIN is in the "framebuffer" space
+		 * Since these cards were never made with more than 8 megabytes
+		 * we can safely allocate this seperately.
 		 */
-		if (!request_mem_region(rinfo->fb_base_phys,
-					rinfo->base1_region_size, "rivafb")) {
-			printk(KERN_ERR PFX "cannot reserve FB region\n");
-			goto err_out_free_base0;
-		}
-	
-		rinfo->fb_base = ioremap(rinfo->fb_base_phys,
-					 rinfo->base1_region_size);
-		if (!rinfo->fb_base) {
-			printk(KERN_ERR PFX "cannot ioremap FB base\n");
+		if (!request_mem_region(rinfo->fb_base_phys + 0x00C00000,
+					 0x00008000, "rivafb")) {
+			printk(KERN_ERR PFX "cannot reserve PRAMIN region\n");
 			goto err_out_iounmap_ctrl;
 		}
+		rinfo->riva.PRAMIN = ioremap(rinfo->fb_base_phys + 0x00C00000,
+				 0x00008000);
+		if (!rinfo->riva.PRAMIN) {
+			printk(KERN_ERR PFX "cannot ioremap PRAMIN region\n");
+			goto err_out_free_nv3_pramin;
 	}
-
-
-	switch (rinfo->riva.Architecture) {
-	case NV_ARCH_03:
-		rinfo->riva.PRAMIN = (unsigned *)(rinfo->fb_base + 0x00C00000);
 		break;
 	case NV_ARCH_04:
 	case NV_ARCH_10:
 	case NV_ARCH_20:
-		rinfo->riva.PCRTC = (unsigned *)(rinfo->ctrl_base + 0x00600000);
+		rinfo->riva.PCRTC0 = (unsigned *)(rinfo->ctrl_base + 0x00600000);
 		rinfo->riva.PRAMIN = (unsigned *)(rinfo->ctrl_base + 0x00710000);
 		break;
 	}
 
-#if defined(__powerpc__)
-	/*
-	 * XXX Mac cards use the second DAC for the panel
-	 */
-	if (rinfo->riva.flatPanel) {
-		printk("rivafb: using second CRTC\n");
-		rinfo->riva.PCIO = rinfo->riva.PCIO + 0x2000;
-		rinfo->riva.PCRTC = rinfo->riva.PCRTC + 0x800;
-		rinfo->riva.PRAMDAC = rinfo->riva.PRAMDAC + 0x800;
-		rinfo->riva.PDIO = rinfo->riva.PDIO + 0x2000;
-	}
-#endif
-
-	RivaGetConfig(&rinfo->riva);
+	riva_common_setup(rinfo);
 
 	rinfo->ram_amount = rinfo->riva.RamAmountKBytes * 1024;
 	rinfo->dclk_max = rinfo->riva.MaxVClockFreqKHz * 1000;
 
-	if (rinfo->riva.Architecture != NV_ARCH_03) {
-		/*
-		 * Now the _normal_ chipsets can just map the amount of
-		 * real physical ram instead of the whole aperture
-		 */
 		if (!request_mem_region(rinfo->fb_base_phys,
 					rinfo->ram_amount, "rivafb")) {
 			printk(KERN_ERR PFX "cannot reserve FB region\n");
-			goto err_out_free_base0;
+		goto err_out_iounmap_nv3_pramin;
 		}
 	
 		rinfo->fb_base = ioremap(rinfo->fb_base_phys,
 					 rinfo->ram_amount);
 		if (!rinfo->fb_base) {
 			printk(KERN_ERR PFX "cannot ioremap FB base\n");
-			goto err_out_iounmap_ctrl;
-		}
+		goto err_out_free_base1;
 	}
 
 #ifdef CONFIG_MTRR
@@ -2215,10 +2380,16 @@
 	rivafb_exit_cursor(rinfo);
 /* err_out_iounmap_fb: */
 	iounmap(rinfo->fb_base);
+err_out_free_base1:
+	release_mem_region(rinfo->fb_base_phys, rinfo->ram_amount);
+err_out_iounmap_nv3_pramin:
+	if (rinfo->riva.Architecture == NV_ARCH_03) 
+		iounmap((caddr_t)rinfo->riva.PRAMIN);
+err_out_free_nv3_pramin:
+	if (rinfo->riva.Architecture == NV_ARCH_03)
+		release_mem_region(rinfo->fb_base_phys + 0x00C00000, 0x00008000);
 err_out_iounmap_ctrl:
 	iounmap(rinfo->ctrl_base);
-err_out_free_base1:
-	release_mem_region(rinfo->fb_base_phys, rinfo->base1_region_size);
 err_out_free_base0:
 	release_mem_region(rinfo->ctrl_base_phys, rinfo->base0_region_size);
 err_out_kfree:
@@ -2256,6 +2427,11 @@
 	release_mem_region(board->fb_base_phys,
 			   board->ram_amount);
 
+	if (board->riva.Architecture == NV_ARCH_03) {
+		iounmap((caddr_t)board->riva.PRAMIN);
+		release_mem_region(board->fb_base_phys + 0x00C00000, 0x00008000);
+	}
+	
 	kfree(board);
 
 	pci_set_drvdata(pd, NULL);
@@ -2301,6 +2477,16 @@
 		} else if (!strncmp(this_opt, "nomtrr", 6)) {
 			nomtrr = 1;
 #endif
+		} else if (!strncmp(this_opt, "forceCRTC", 9)) {
+			char *p;
+			
+			p = this_opt + 9;
+			if (!*p || !*(++p)) continue; 
+			forceCRTC = *p - '0';
+			if (forceCRTC < 0 || forceCRTC > 1) 
+				forceCRTC = -1;
+		} else if (!strncmp(this_opt, "flatpanel", 9)) {
+			flatpanel = 1;
 		} else if (!strncmp(this_opt, "nohwcursor", 10)) {
 			nohwcursor = 1;
 		} else
@@ -2331,9 +2517,13 @@
 #ifdef MODULE
 	if (font) strncpy(fontname, font, sizeof(fontname)-1);
 #endif
+#if defined(CONFIG_ALL_PPC) && defined(CONFIG_ADB_PMU)
+	init_ivad();
+#endif	
 	err = pci_module_init(&rivafb_driver);
 	if (err)
 		return err;
+	pci_register_driver(&rivafb_driver);
 	return 0;
 }
 
@@ -2357,6 +2547,11 @@
 MODULE_PARM_DESC(nohwcursor, "Disables hardware cursor (0 or 1=disabled) (default=0)");
 MODULE_PARM(noblink, "i");
 MODULE_PARM_DESC(noblink, "Disables hardware cursor blinking (0 or 1=disabled) (default=0)");
+MODULE_PARM(flatpanel, "i");
+MODULE_PARM_DESC(flatpanel, "Enables experimental flat panel support for some chipsets. (0 or 1=enabled) (default=0)");
+MODULE_PARM(forceCRTC, "i");
+MODULE_PARM_DESC(forceCRTC, "Forces usage of a particular CRTC in case autodetection fails. (0 or 1) (default=autodetect)");
+
 #ifdef CONFIG_MTRR
 MODULE_PARM(nomtrr, "i");
 MODULE_PARM_DESC(nomtrr, "Disables MTRR support (0 or 1=disabled) (default=0)");
@@ -2364,5 +2559,5 @@
 #endif /* MODULE */
 
 MODULE_AUTHOR("Ani Joshi, maintainer");
-MODULE_DESCRIPTION("Framebuffer driver for nVidia Riva 128, TNT, TNT2");
+MODULE_DESCRIPTION("Framebuffer driver for nVidia Riva 128, TNT, TNT2, and the GeForce series");
 MODULE_LICENSE("GPL");
diff -urN kernel-source-2.4.27/drivers/video/riva/Makefile kernel-source-2.4.27-benh/drivers/video/riva/Makefile
--- kernel-source-2.4.27/drivers/video/riva/Makefile	2001-02-03 21:48:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/riva/Makefile	2004-09-01 20:56:29.313662704 +0200
@@ -9,7 +9,7 @@
 
 O_TARGET := rivafb.o
 
-obj-y    := fbdev.o riva_hw.o accel.o
+obj-y    := fbdev.o nv_setup.o riva_hw.o accel.o
 obj-m    := $(O_TARGET)
 
 include $(TOPDIR)/Rules.make
diff -urN kernel-source-2.4.27/drivers/video/riva/nv_setup.c kernel-source-2.4.27-benh/drivers/video/riva/nv_setup.c
--- kernel-source-2.4.27/drivers/video/riva/nv_setup.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/riva/nv_setup.c	2004-09-01 20:56:29.399649632 +0200
@@ -0,0 +1,262 @@
+/* $XConsortium: nv_driver.c /main/3 1996/10/28 05:13:37 kaleb $ */
+/*
+ * Copyright 1996-1997  David J. McKay
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * GPL licensing note -- nVidia is allowing a liberal interpretation of
+ * the documentation restriction above, to merely say that this nVidia's
+ * copyright and disclaimer should be included with all code derived
+ * from this source.  -- Jeff Garzik <jgarzik@mandrakesoft.com>, 01/Nov/99 
+ */
+
+/* Hacked together from mga driver and 3.3.4 NVIDIA driver by Jarno Paananen
+   <jpaana@s2.org> */
+
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_setup.c,v 1.18 2002/08/0
+5 20:47:06 mvojkovi Exp $ */
+
+#include <linux/delay.h>
+#include <linux/pci_ids.h>
+#include "nv_type.h"
+#include "rivafb.h"
+#include "nvreg.h"
+
+
+#ifndef CONFIG_PCI		/* sanity check */
+#error This driver requires PCI support.
+#endif
+
+#define PFX "rivafb: "
+
+static inline unsigned char MISCin(struct rivafb_info *rinfo)
+{
+	return (VGA_RD08(rinfo->riva.PVIO, 0x3cc));
+}
+
+static Bool 
+riva_is_connected(struct rivafb_info *rinfo, Bool second)
+{
+	volatile U032 *PRAMDAC = rinfo->riva.PRAMDAC0;
+	U032 reg52C, reg608;
+	Bool present;
+
+	if(second) PRAMDAC += 0x800;
+
+	reg52C = PRAMDAC[0x052C/4];
+	reg608 = PRAMDAC[0x0608/4];
+
+	PRAMDAC[0x0608/4] = reg608 & ~0x00010000;
+
+	PRAMDAC[0x052C/4] = reg52C & 0x0000FEEE;
+	mdelay(1); 
+	PRAMDAC[0x052C/4] |= 1;
+
+	rinfo->riva.PRAMDAC0[0x0610/4] = 0x94050140;
+	rinfo->riva.PRAMDAC0[0x0608/4] |= 0x00001000;
+
+	mdelay(1);
+
+	present = (PRAMDAC[0x0608/4] & (1 << 28)) ? TRUE : FALSE;
+
+	rinfo->riva.PRAMDAC0[0x0608/4] &= 0x0000EFFF;
+
+	PRAMDAC[0x052C/4] = reg52C;
+	PRAMDAC[0x0608/4] = reg608;
+
+	return present;
+}
+
+static void
+riva_override_CRTC(struct rivafb_info *rinfo)
+{
+	printk(KERN_INFO PFX
+		"Detected CRTC controller %i being used\n",
+		rinfo->SecondCRTC ? 1 : 0);
+
+	if(rinfo->forceCRTC != -1) {
+		printk(KERN_INFO PFX
+			"Forcing usage of CRTC %i\n", rinfo->forceCRTC);
+		rinfo->SecondCRTC = rinfo->forceCRTC;
+	}
+}
+
+static void
+riva_is_second(struct rivafb_info *rinfo)
+{
+	if(rinfo->FlatPanel == 1) {
+		switch(rinfo->Chipset & 0xffff) {
+		case 0x0174:
+		case 0x0175:
+		case 0x0176:
+		case 0x0177:
+		case 0x0179:
+		case 0x017C:
+		case 0x017D:
+		case 0x0186:
+		case 0x0187:
+		/* this might not be a good default for the chips below */
+		case 0x0286:
+		case 0x028C:
+		case 0x0316:
+		case 0x0317:
+		case 0x031A:
+		case 0x031B:
+		case 0x031C:
+		case 0x031D:
+		case 0x031E:
+		case 0x031F:
+		case 0x0324:
+		case 0x0325:
+		case 0x0328:
+		case 0x0329:
+		case 0x032C:
+		case 0x032D:
+			rinfo->SecondCRTC = TRUE;
+			break;
+		default:
+			rinfo->SecondCRTC = FALSE;
+			break;
+		}
+	} else {
+		if(riva_is_connected(rinfo, 0)) {
+			if(rinfo->riva.PRAMDAC0[0x0000052C/4] & 0x100)
+				rinfo->SecondCRTC = TRUE;
+			else
+				rinfo->SecondCRTC = FALSE;
+		} else 
+		if (riva_is_connected(rinfo, 1)) {
+			if(rinfo->riva.PRAMDAC0[0x0000252C/4] & 0x100)
+				rinfo->SecondCRTC = TRUE;
+			else
+				rinfo->SecondCRTC = FALSE;
+		} else /* default */
+			rinfo->SecondCRTC = FALSE;
+	}
+
+	riva_override_CRTC(rinfo);
+}
+
+void
+riva_common_setup(struct rivafb_info *rinfo)
+{
+	rinfo->riva.EnableIRQ = 0;
+	rinfo->riva.PRAMDAC0 = (unsigned *)(rinfo->ctrl_base + 0x00680000);
+	rinfo->riva.PFB = (unsigned *)(rinfo->ctrl_base + 0x00100000);
+	rinfo->riva.PFIFO = (unsigned *)(rinfo->ctrl_base + 0x00002000);
+	rinfo->riva.PGRAPH = (unsigned *)(rinfo->ctrl_base + 0x00400000);
+	rinfo->riva.PEXTDEV = (unsigned *)(rinfo->ctrl_base + 0x00101000);
+	rinfo->riva.PTIMER = (unsigned *)(rinfo->ctrl_base + 0x00009000);
+	rinfo->riva.PMC = (unsigned *)(rinfo->ctrl_base + 0x00000000);
+	rinfo->riva.FIFO = (unsigned *)(rinfo->ctrl_base + 0x00800000);
+	rinfo->riva.PCIO0 = (U008 *)(rinfo->ctrl_base + 0x00601000);
+	rinfo->riva.PDIO0 = (U008 *)(rinfo->ctrl_base + 0x00681000);
+	rinfo->riva.PVIO = (U008 *)(rinfo->ctrl_base + 0x000C0000);
+
+	rinfo->riva.IO = (MISCin(rinfo) & 0x01) ? 0x3D0 : 0x3B0;
+	
+	if(rinfo->FlatPanel == -1) {
+		switch(rinfo->Chipset) {
+		case 0x0112:   /* known laptop chips */
+		case 0x0174:
+		case 0x0175:
+		case 0x0176:
+		case 0x0177:
+		case 0x0179:
+		case 0x017C:
+		case 0x017D:
+		case 0x0186:
+		case 0x0187:
+		case 0x0286:
+		case 0x028C:
+		case 0x0316:
+		case 0x0317:
+		case 0x031A:
+		case 0x031B:
+		case 0x031C:
+		case 0x031D:
+		case 0x031E:
+		case 0x031F:
+		case 0x0324:
+		case 0x0325:
+		case 0x0328:
+		case 0x0329:
+		case 0x032C:
+		case 0x032D:
+			printk(KERN_INFO PFX 
+				"On a laptop.  Assuming Digital Flat Panel\n");
+			rinfo->FlatPanel = 1;
+			break;
+		default:
+			break;
+		}
+	}
+	
+	switch (rinfo->Chipset & 0x0ff0) {
+	case 0x0110:
+		if (rinfo->Chipset == NV_CHIP_GEFORCE2_GO)
+			rinfo->SecondCRTC = TRUE; 
+#if defined(__powerpc__)
+		if (rinfo->FlatPanel == 1)
+			rinfo->SecondCRTC = TRUE;
+#endif
+		riva_override_CRTC(rinfo);
+		break;
+	case 0x0170:
+	case 0x0180:
+	case 0x01F0:
+	case 0x0250:
+	case 0x0280:
+	case 0x0300:
+	case 0x0310:
+	case 0x0320:
+	case 0x0330:
+	case 0x0340:
+		riva_is_second(rinfo);
+		break;
+	default:
+		break;
+	}
+
+	if (rinfo->riva.Architecture == NV_ARCH_03)
+		rinfo->riva.PCRTC = rinfo->riva.PCRTC0 = rinfo->riva.PGRAPH;
+
+	if (rinfo->SecondCRTC) {
+		rinfo->riva.PCIO = rinfo->riva.PCIO0 + 0x2000;
+		rinfo->riva.PCRTC = rinfo->riva.PCRTC0 + 0x800;
+		rinfo->riva.PRAMDAC = rinfo->riva.PRAMDAC0 + 0x800;
+		rinfo->riva.PDIO = rinfo->riva.PDIO0 + 0x2000;
+	} else {
+		rinfo->riva.PCIO = rinfo->riva.PCIO0;
+		rinfo->riva.PCRTC = rinfo->riva.PCRTC0;
+		rinfo->riva.PRAMDAC = rinfo->riva.PRAMDAC0;
+		rinfo->riva.PDIO = rinfo->riva.PDIO0;
+	}
+
+	RivaGetConfig(&rinfo->riva, rinfo->Chipset);
+
+	if (rinfo->FlatPanel == -1) {
+		/* Fix me, need x86 DDC code */
+		rinfo->FlatPanel = 0;
+	}
+	rinfo->riva.flatPanel = (rinfo->FlatPanel > 0) ? TRUE : FALSE;
+}
+
diff -urN kernel-source-2.4.27/drivers/video/riva/nv_type.h kernel-source-2.4.27-benh/drivers/video/riva/nv_type.h
--- kernel-source-2.4.27/drivers/video/riva/nv_type.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/drivers/video/riva/nv_type.h	2004-09-01 20:56:29.401649328 +0200
@@ -0,0 +1,58 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_type.h,v 1.35 2002/08/05 20:47:06 mvojkovi Exp $ */
+
+#ifndef __NV_STRUCT_H__
+#define __NV_STRUCT_H__
+
+#define NV_CHIP_RIVA_128            ((PCI_VENDOR_ID_NVIDIA_SGS << 16)| PCI_DEVICE_ID_NVIDIA_RIVA128)
+#define NV_CHIP_TNT                 ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_TNT)
+#define NV_CHIP_TNT2                ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_TNT2)
+#define NV_CHIP_UTNT2               ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_UTNT2)
+#define NV_CHIP_VTNT2               ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_VTNT2)
+#define NV_CHIP_UVTNT2              ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_UVTNT2)
+#define NV_CHIP_ITNT2               ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_ITNT2)
+#define NV_CHIP_GEFORCE_256         ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_GEFORCE_256)
+#define NV_CHIP_GEFORCE_DDR         ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_GEFORCE_DDR)
+#define NV_CHIP_QUADRO              ((PCI_VENDOR_ID_NVIDIA << 16)| PCI_DEVICE_ID_NVIDIA_QUADRO)
+#define NV_CHIP_GEFORCE2_MX         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX)
+#define NV_CHIP_GEFORCE2_MX_100     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_MX_100)
+#define NV_CHIP_QUADRO2_MXR         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO2_MXR)
+#define NV_CHIP_GEFORCE2_GO         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_GO)
+#define NV_CHIP_GEFORCE2_GTS        ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS)
+#define NV_CHIP_GEFORCE2_TI         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_TI)
+#define NV_CHIP_GEFORCE2_ULTRA      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA)
+#define NV_CHIP_QUADRO2_PRO         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO)
+#define NV_CHIP_GEFORCE4_MX_460     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_460)
+#define NV_CHIP_GEFORCE4_MX_440     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440)
+#define NV_CHIP_GEFORCE4_MX_420     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_420)
+#define NV_CHIP_GEFORCE4_440_GO     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO)
+#define NV_CHIP_GEFORCE4_420_GO     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO)
+#define NV_CHIP_GEFORCE4_420_GO_M32 ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO_M32)
+#define NV_CHIP_QUADRO4_500XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_500XGL)
+#define NV_CHIP_GEFORCE4_440_GO_M64 ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO_M64)
+#define NV_CHIP_QUADRO4_200         ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_200)
+#define NV_CHIP_QUADRO4_550XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_550XGL)
+#define NV_CHIP_QUADRO4_500_GOGL    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_500_GOGL)
+#define NV_CHIP_0x0180              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0180)
+#define NV_CHIP_0x0181              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0181)
+#define NV_CHIP_0x0182              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0182)
+#define NV_CHIP_0x0188              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0188)
+#define NV_CHIP_0x018A              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x018A)
+#define NV_CHIP_0x018B              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x018B)
+#define NV_CHIP_IGEFORCE2           ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_IGEFORCE2)
+#define NV_CHIP_0x01F0              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x01F0)
+#define NV_CHIP_GEFORCE3            ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE3)
+#define NV_CHIP_GEFORCE3_TI_200     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE3_TI_200)
+#define NV_CHIP_GEFORCE3_TI_500     ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE3_TI_500)
+#define NV_CHIP_QUADRO_DCC          ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO_DCC)
+#define NV_CHIP_GEFORCE4_TI_4600    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4600)
+#define NV_CHIP_GEFORCE4_TI_4400    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4400)
+#define NV_CHIP_GEFORCE4_TI_4200    ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4200)
+#define NV_CHIP_QUADRO4_900XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_900XGL)
+#define NV_CHIP_QUADRO4_750XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_750XGL)
+#define NV_CHIP_QUADRO4_700XGL      ((PCI_VENDOR_ID_NVIDIA << 16) | PCI_DEVICE_ID_NVIDIA_QUADRO4_700XGL)
+#define NV_CHIP_0x0280              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0280)
+#define NV_CHIP_0x0281              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0281)
+#define NV_CHIP_0x0288              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0288)
+#define NV_CHIP_0x0289              ((PCI_VENDOR_ID_NVIDIA << 16) | 0x0289)
+
+#endif /* __NV_STRUCT_H__ */
diff -urN kernel-source-2.4.27/drivers/video/riva/rivafb.h kernel-source-2.4.27-benh/drivers/video/riva/rivafb.h
--- kernel-source-2.4.27/drivers/video/riva/rivafb.h	2003-06-13 16:51:37.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/riva/rivafb.h	2004-09-01 20:56:29.487636256 +0200
@@ -92,6 +92,12 @@
 #ifdef CONFIG_MTRR
 	struct { int vram; int vram_valid; } mtrr;
 #endif
+	unsigned int Chipset;
+	int forceCRTC;
+	Bool SecondCRTC;
+	int FlatPanel;
 };
 
+void riva_common_setup(struct rivafb_info*);
+
 #endif /* __RIVAFB_H */
diff -urN kernel-source-2.4.27/drivers/video/riva/riva_hw.c kernel-source-2.4.27-benh/drivers/video/riva/riva_hw.c
--- kernel-source-2.4.27/drivers/video/riva/riva_hw.c	2003-06-13 16:51:37.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/riva/riva_hw.c	2004-09-01 20:56:29.665609200 +0200
@@ -41,13 +41,17 @@
  * GPL licensing note -- nVidia is allowing a liberal interpretation of
  * the documentation restriction above, to merely say that this nVidia's
  * copyright and disclaimer should be included with all code derived
- * from this source.  -- Jeff Garzik <jgarzik@pobox.com>, 01/Nov/99 
+ * from this source.  -- Jeff Garzik <jgarzik@mandrakesoft.com>, 01/Nov/99 
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_hw.c,v 1.8 2000/02/08 17:19:11 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_hw.c,v 1.33 2002/08/05 20:47:06 mvojkovi Exp $ */
 
+#include <linux/pci_ids.h>
+#include <linux/pci.h>
 #include "riva_hw.h"
 #include "riva_tbl.h"
+#include "nv_type.h"
+
 /*
  * This file is an OS-agnostic file used to make RIVA 128 and RIVA TNT
  * operate identically (except TNT has more memory and better 3D quality.
@@ -73,32 +77,39 @@
 {
     return ((chip->Rop->FifoFree < chip->FifoEmptyCount) || (chip->PGRAPH[0x00000700/4] & 0x01));
 }
-static void nv3LockUnlock
+
+static void vgaLockUnlock
 (
     RIVA_HW_INST *chip,
-    int           LockUnlock
+    int           Lock
 )
 {
-    VGA_WR08(chip->PVIO, 0x3C4, 0x06);
-    VGA_WR08(chip->PVIO, 0x3C5, LockUnlock ? 0x99 : 0x57);
+    U008 cr11;
+    VGA_WR08(chip->PCIO, 0x3D4, 0x11);
+    cr11 = VGA_RD08(chip->PCIO, 0x3D5);
+    if(Lock) cr11 |= 0x80;
+    else cr11 &= ~0x80;
+    VGA_WR08(chip->PCIO, 0x3D5, cr11);
 }
-static void nv4LockUnlock
+static void nv3LockUnlock
 (
     RIVA_HW_INST *chip,
-    int           LockUnlock
+    int           Lock
 )
 {
-    VGA_WR08(chip->PCIO, 0x3D4, 0x1F);
-    VGA_WR08(chip->PCIO, 0x3D5, LockUnlock ? 0x99 : 0x57);
+    VGA_WR08(chip->PVIO, 0x3C4, 0x06);
+    VGA_WR08(chip->PVIO, 0x3C5, Lock ? 0x99 : 0x57);
+    vgaLockUnlock(chip, Lock);
 }
-static void nv10LockUnlock
+static void nv4LockUnlock
 (
     RIVA_HW_INST *chip,
-    int           LockUnlock
+    int           Lock
 )
 {
     VGA_WR08(chip->PCIO, 0x3D4, 0x1F);
-    VGA_WR08(chip->PCIO, 0x3D5, LockUnlock ? 0x99 : 0x57);
+    VGA_WR08(chip->PCIO, 0x3D5, Lock ? 0x99 : 0x57);
+    vgaLockUnlock(chip, Lock);
 }
 
 static int ShowHideCursor
@@ -107,13 +118,13 @@
     int           ShowHide
 )
 {
-    int current;
-    current                     =  chip->CurrentState->cursor1;
+    int cursor;
+    cursor                      =  chip->CurrentState->cursor1;
     chip->CurrentState->cursor1 = (chip->CurrentState->cursor1 & 0xFE) |
 	                          (ShowHide & 0x01);
     VGA_WR08(chip->PCIO, 0x3D4, 0x31);
     VGA_WR08(chip->PCIO, 0x3D5, chip->CurrentState->cursor1);
-    return (current & 0x01);
+    return (cursor & 0x01);
 }
 
 /****************************************************************************\
@@ -604,7 +615,7 @@
     nv3_sim_state sim_data;
     unsigned int M, N, P, pll, MClk;
     
-    pll = chip->PRAMDAC[0x00000504/4];
+    pll = chip->PRAMDAC0[0x00000504/4]; 
     M = (pll >> 0) & 0xFF; N = (pll >> 8) & 0xFF; P = (pll >> 16) & 0x0F;
     MClk = (N * chip->CrystalFreqKHz / M) >> P;
     sim_data.pix_bpp        = (char)pixelDepth;
@@ -791,10 +802,10 @@
     nv4_sim_state sim_data;
     unsigned int M, N, P, pll, MClk, NVClk, cfg1;
 
-    pll = chip->PRAMDAC[0x00000504/4];
+    pll = chip->PRAMDAC0[0x00000504/4];
     M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
     MClk  = (N * chip->CrystalFreqKHz / M) >> P;
-    pll = chip->PRAMDAC[0x00000500/4];
+    pll = chip->PRAMDAC0[0x00000500/4];
     M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
     NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
     cfg1 = chip->PFB[0x00000204/4];
@@ -1052,10 +1063,10 @@
     nv10_sim_state sim_data;
     unsigned int M, N, P, pll, MClk, NVClk, cfg1;
 
-    pll = chip->PRAMDAC[0x00000504/4];
+    pll = chip->PRAMDAC0[0x00000504/4];
     M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
     MClk  = (N * chip->CrystalFreqKHz / M) >> P;
-    pll = chip->PRAMDAC[0x00000500/4];
+    pll = chip->PRAMDAC0[0x00000500/4];
     M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
     NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
     cfg1 = chip->PFB[0x00000204/4];
@@ -1081,6 +1092,57 @@
     }
 }
 
+static void nForceUpdateArbitrationSettings
+(
+    unsigned      VClk,
+    unsigned      pixelDepth,
+    unsigned     *burst,
+    unsigned     *lwm,
+    RIVA_HW_INST *chip
+)
+{
+    nv10_fifo_info fifo_data;
+    nv10_sim_state sim_data;
+    unsigned int M, N, P, pll, MClk, NVClk;
+    unsigned int uMClkPostDiv;
+    struct pci_dev *dev;
+
+    dev = pci_find_slot(0, 3);
+    pci_read_config_dword(dev, 0x6C, &uMClkPostDiv);
+    uMClkPostDiv = (uMClkPostDiv >> 8) & 0xf;
+
+    if(!uMClkPostDiv) uMClkPostDiv = 4;
+    MClk = 400000 / uMClkPostDiv;
+
+    pll = chip->PRAMDAC0[0x00000500/4];
+    M = (pll >> 0)  & 0xFF; N = (pll >> 8)  & 0xFF; P = (pll >> 16) & 0x0F;
+    NVClk  = (N * chip->CrystalFreqKHz / M) >> P;
+    sim_data.pix_bpp        = (char)pixelDepth;
+    sim_data.enable_video   = 0;
+    sim_data.enable_mp      = 0;
+
+    dev = pci_find_slot(0, 1);
+    pci_read_config_dword(dev, 0x7C, &sim_data.memory_type);
+    sim_data.memory_type    = (sim_data.memory_type >> 12) & 1;
+
+    sim_data.memory_width   = 64;
+    sim_data.mem_latency    = 3;
+    sim_data.mem_aligned    = 1;
+    sim_data.mem_page_miss  = 10;
+    sim_data.gr_during_vid  = 0;
+    sim_data.pclk_khz       = VClk;
+    sim_data.mclk_khz       = MClk;
+    sim_data.nvclk_khz      = NVClk;
+    nv10CalcArbitration(&fifo_data, &sim_data);
+    if (fifo_data.valid)
+    {
+        int  b = fifo_data.graphics_burst_size >> 4;
+        *burst = 0;
+        while (b >>= 1) (*burst)++;
+        *lwm   = fifo_data.graphics_lwm >> 3;
+    }
+}
+
 /****************************************************************************\
 *                                                                            *
 *                          RIVA Mode State Routines                          *
@@ -1093,7 +1155,6 @@
 static int CalcVClock
 (
     int           clockIn,
-    int           double_scan,
     int          *clockOut,
     int          *mOut,
     int          *nOut,
@@ -1109,18 +1170,16 @@
     DeltaOld = 0xFFFFFFFF;
 
     VClk     = (unsigned)clockIn;
-    if (double_scan)
-        VClk *= 2;
     
-    if (chip->CrystalFreqKHz == 14318)
+    if (chip->CrystalFreqKHz == 13500)
     {
-        lowM  = 8;
-        highM = 14 - (chip->Architecture == NV_ARCH_03);
+        lowM  = 7;
+        highM = 13 - (chip->Architecture == NV_ARCH_03);
     }
     else
     {
-        lowM  = 7;
-        highM = 13 - (chip->Architecture == NV_ARCH_03);
+        lowM  = 8;
+        highM = 14 - (chip->Architecture == NV_ARCH_03);
     }                      
 
     highP = 4 - (chip->Architecture == NV_ARCH_03);
@@ -1131,7 +1190,8 @@
         {
             for (M = lowM; M <= highM; M++)
             {
-                N    = (VClk * M / chip->CrystalFreqKHz) << P;
+                N    = (VClk << P) * M / chip->CrystalFreqKHz;
+                if(N <= 255) {
                 Freq = (chip->CrystalFreqKHz * N / M) >> P;
                 if (Freq > VClk)
                     DeltaNew = Freq - VClk;
@@ -1148,6 +1208,7 @@
             }
         }
     }
+    }
     return (DeltaOld != 0xFFFFFFFF);
 }
 /*
@@ -1161,15 +1222,7 @@
     int            bpp,
     int            width,
     int            hDisplaySize,
-    int            hDisplay,
-    int            hStart,
-    int            hEnd,
-    int            hTotal,
     int            height,
-    int            vDisplay,
-    int            vStart,
-    int            vEnd,
-    int            vTotal,
     int            dotClock
 )
 {
@@ -1177,15 +1230,14 @@
     /*
      * Save mode parameters.
      */
-    state->bpp    = bpp;
+    state->bpp    = bpp;    /* this is not bitsPerPixel, it's 8,15,16,32 */
     state->width  = width;
     state->height = height;
     /*
      * Extended RIVA registers.
      */
     pixelDepth = (bpp + 1)/8;
-    CalcVClock(dotClock, hDisplaySize < 512,  /* double scan? */
-               &VClk, &m, &n, &p, chip);
+    CalcVClock(dotClock, &VClk, &m, &n, &p, chip);
 
     switch (chip->Architecture)
     {
@@ -1221,28 +1273,37 @@
             break;
         case NV_ARCH_10:
 	case NV_ARCH_20:
+            if((chip->Chipset == NV_CHIP_IGEFORCE2) ||
+               (chip->Chipset == NV_CHIP_0x01F0))
+            {
+                nForceUpdateArbitrationSettings(VClk,
+                                          pixelDepth * 8,
+                                         &(state->arbitration0),
+                                         &(state->arbitration1),
+                                          chip);
+            } else {
             nv10UpdateArbitrationSettings(VClk, 
                                           pixelDepth * 8, 
                                          &(state->arbitration0),
                                          &(state->arbitration1),
                                           chip);
-            state->cursor0  = 0x00;
-            state->cursor1  = 0xFC;
-            state->cursor2  = 0x00000000;
+            }
+            state->cursor0  = 0x80 | (chip->CursorStart >> 17);
+            state->cursor1  = (chip->CursorStart >> 11) << 2;
+            state->cursor2  = chip->CursorStart >> 24;
             state->pllsel   = 0x10000700;
             state->config   = chip->PFB[0x00000200/4];
             state->general  = bpp == 16 ? 0x00101100 : 0x00100100;
             state->repaint1 = hDisplaySize < 1280 ? 0x04 : 0x00;
             break;
     }
+
+    /* Paul Richards: below if block borks things in kernel for some reason */
+    /* if((bpp != 8) && (chip->Architecture != NV_ARCH_03))
+    state->general |= 0x00000030; */
+
     state->vpll     = (p << 16) | (n << 8) | m;
-    state->screen   = ((hTotal   & 0x040) >> 2)
-                    | ((vDisplay & 0x400) >> 7)
-                    | ((vStart   & 0x400) >> 8)
-                    | ((vDisplay & 0x400) >> 9)
-                    | ((vTotal   & 0x400) >> 10);
     state->repaint0 = (((width/8)*pixelDepth) & 0x700) >> 3;
-    state->horiz    = hTotal     < 260 ? 0x00 : 0x01;
     state->pixel    = pixelDepth > 2   ? 3    : pixelDepth;
     state->offset0  =
     state->offset1  =
@@ -1396,6 +1457,12 @@
             break;
         case NV_ARCH_10:
 	case NV_ARCH_20:
+            if(chip->twoHeads) {
+               VGA_WR08(chip->PCIO, 0x03D4, 0x44);
+               VGA_WR08(chip->PCIO, 0x03D5, state->crtcOwner);
+               chip->LockUnlock(chip, 0);
+            }
+
             LOAD_FIXED_STATE(nv10,PFIFO);
             LOAD_FIXED_STATE(nv10,PRAMIN);
             LOAD_FIXED_STATE(nv10,PGRAPH);
@@ -1449,15 +1516,28 @@
 		chip->PGRAPH[0x000009A4/4] = chip->PFB[0x00000200/4];
 		chip->PGRAPH[0x000009A8/4] = chip->PFB[0x00000204/4];
 	    }
+            if(chip->twoHeads) {
+               chip->PCRTC0[0x00000860/4] = state->head;
+               chip->PCRTC0[0x00002860/4] = state->head2;
+            }
+            chip->PRAMDAC[0x00000404/4] |= (1 << 25);
+
+            chip->PMC[0x00008704/4] = 1;
+            chip->PMC[0x00008140/4] = 0;
+            chip->PMC[0x00008920/4] = 0;
+            chip->PMC[0x00008924/4] = 0;
+            chip->PMC[0x00008908/4] = 0x01ffffff;
+            chip->PMC[0x0000890C/4] = 0x01ffffff;
+            chip->PMC[0x00001588/4] = 0;
 
 	    chip->PFB[0x00000240/4] = 0;
 	    chip->PFB[0x00000244/4] = 0;
 	    chip->PFB[0x00000248/4] = 0;
 	    chip->PFB[0x0000024C/4] = 0;
 	    chip->PFB[0x00000250/4] = 0;
-	    chip->PFB[0x00000244/4] = 0;
-	    chip->PFB[0x00000248/4] = 0;
-	    chip->PFB[0x0000024C/4] = 0;
+            chip->PFB[0x00000254/4] = 0;
+            chip->PFB[0x00000258/4] = 0;
+            chip->PFB[0x0000025C/4] = 0;
 
             chip->PGRAPH[0x00000B00/4] = chip->PFB[0x00000240/4];
             chip->PGRAPH[0x00000B04/4] = chip->PFB[0x00000244/4];
@@ -1533,15 +1613,26 @@
             for (i = 0; i < 4; i++)
                 chip->PGRAPH[0x00000F54/4] = 0x00000000;
 
+            chip->PCRTC[0x00000810/4] = state->cursorConfig;
+
 	    if (chip->flatPanel) {
-		VGA_WR08(chip->PCIO, 0x3d4, 0x53);
-		VGA_WR08(chip->PCIO, 0x3d5, 0);
-		VGA_WR08(chip->PCIO, 0x3d4, 0x54);
-		VGA_WR08(chip->PCIO, 0x3d5, 0);
-		VGA_WR08(chip->PCIO, 0x3d4, 0x21);
-		VGA_WR08(chip->PCIO, 0x3d5, 0xfa);
+               if((chip->Chipset & 0x0ff0) == 0x0110) {
+                   chip->PRAMDAC[0x0528/4] = state->dither;
+               } else 
+               if((chip->Chipset & 0x0ff0) >= 0x0170) {
+                   chip->PRAMDAC[0x083C/4] = state->dither;
 	    }
-            break;
+            
+               VGA_WR08(chip->PCIO, 0x03D4, 0x53);
+               VGA_WR08(chip->PCIO, 0x03D5, 0);
+               VGA_WR08(chip->PCIO, 0x03D4, 0x54);
+               VGA_WR08(chip->PCIO, 0x03D5, 0);
+               VGA_WR08(chip->PCIO, 0x03D4, 0x21);
+               VGA_WR08(chip->PCIO, 0x03D5, 0xfa);
+            }
+
+            VGA_WR08(chip->PCIO, 0x03D4, 0x41);
+            VGA_WR08(chip->PCIO, 0x03D5, state->extra);
     }
     LOAD_FIXED_STATE(Riva,FIFO);
     UpdateFifoState(chip);
@@ -1566,25 +1657,26 @@
     VGA_WR08(chip->PCIO, 0x03D5, state->cursor0);
     VGA_WR08(chip->PCIO, 0x03D4, 0x31);
     VGA_WR08(chip->PCIO, 0x03D5, state->cursor1);
-    VGA_WR08(chip->PCIO, 0x03D4, 0x41);
-    VGA_WR08(chip->PCIO, 0x03D5, state->extra);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);
+    VGA_WR08(chip->PCIO, 0x03D5, state->cursor2);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x39);
+    VGA_WR08(chip->PCIO, 0x03D5, state->interlace);
 
     if (!chip->flatPanel) {
-        chip->PRAMDAC[0x00000508/4]  = state->vpll;
-        chip->PRAMDAC[0x00000520/4]  = state->vpll2;
-        chip->PRAMDAC[0x0000050C/4]  = state->pllsel;
+       chip->PRAMDAC0[0x00000508/4] = state->vpll;
+       chip->PRAMDAC0[0x0000050C/4] = state->pllsel;
+       if(chip->twoHeads)
+          chip->PRAMDAC0[0x00000520/4] = state->vpll2;
     } else {
 	chip->PRAMDAC[0x00000848/4]  = state->scale;
     }
-    chip->PRAMDAC[0x00000300/4]  = state->cursor2;
-    chip->PRAMDAC[0x00000508/4]  = state->vpll;
-    chip->PRAMDAC[0x0000050C/4]  = state->pllsel;
     chip->PRAMDAC[0x00000600/4]  = state->general;
+
     /*
      * Turn off VBlank enable and reset.
      */
-    *(chip->VBLANKENABLE) = 0;
-    *(chip->VBLANK)       = chip->VBlankBit;
+    chip->PCRTC[0x00000140/4] = 0;
+    chip->PCRTC[0x00000100/4] = chip->VBlankBit;
     /*
      * Set interrupt enable.
      */    
@@ -1627,12 +1719,13 @@
     state->cursor0      = VGA_RD08(chip->PCIO, 0x03D5);
     VGA_WR08(chip->PCIO, 0x03D4, 0x31);
     state->cursor1      = VGA_RD08(chip->PCIO, 0x03D5);
-    VGA_WR08(chip->PCIO, 0x03D4, 0x41);
-    state->extra        = VGA_RD08(chip->PCIO, 0x03D5);
-    state->cursor2      = chip->PRAMDAC[0x00000300/4];
-    state->vpll         = chip->PRAMDAC[0x00000508/4];
-    state->vpll2        = chip->PRAMDAC[0x00000520/4];
-    state->pllsel       = chip->PRAMDAC[0x0000050C/4];
+    VGA_WR08(chip->PCIO, 0x03D4, 0x2F);
+    state->cursor2      = VGA_RD08(chip->PCIO, 0x03D5);
+    VGA_WR08(chip->PCIO, 0x03D4, 0x39);
+    state->interlace    = VGA_RD08(chip->PCIO, 0x03D5);
+    state->vpll         = chip->PRAMDAC0[0x00000508/4];
+    state->vpll2        = chip->PRAMDAC0[0x00000520/4];
+    state->pllsel       = chip->PRAMDAC0[0x0000050C/4];
     state->general      = chip->PRAMDAC[0x00000600/4];
     state->scale	= chip->PRAMDAC[0x00000848/4];
     state->config       = chip->PFB[0x00000200/4];
@@ -1668,6 +1761,22 @@
             state->pitch1   = chip->PGRAPH[0x00000674/4];
             state->pitch2   = chip->PGRAPH[0x00000678/4];
             state->pitch3   = chip->PGRAPH[0x0000067C/4];
+            if(chip->twoHeads) {
+               state->head     = chip->PCRTC0[0x00000860/4];
+               state->head2    = chip->PCRTC0[0x00002860/4];
+               VGA_WR08(chip->PCIO, 0x03D4, 0x44);
+               state->crtcOwner = VGA_RD08(chip->PCIO, 0x03D5);
+            }
+            VGA_WR08(chip->PCIO, 0x03D4, 0x41);
+            state->extra = VGA_RD08(chip->PCIO, 0x03D5);
+            state->cursorConfig = chip->PCRTC[0x00000810/4];
+
+            if((chip->Chipset & 0x0ff0) == 0x0110) {
+                state->dither = chip->PRAMDAC[0x0528/4];
+            } else 
+            if((chip->Chipset & 0x0ff0) >= 0x0170) {
+                state->dither = chip->PRAMDAC[0x083C/4];
+            }
             break;
     }
 }
@@ -1677,6 +1786,15 @@
     unsigned      start
 )
 {
+    chip->PCRTC[0x800/4] = start;
+}
+
+static void SetStartAddress3
+(
+    RIVA_HW_INST *chip,
+    unsigned      start
+)
+{
     int offset = start >> 2;
     int pan    = (start & 3) << 1;
     unsigned char tmp;
@@ -1857,11 +1975,8 @@
                 break;
         }
     }        
-    chip->CrystalFreqKHz   = (chip->PEXTDEV[0x00000000/4] & 0x00000020) ? 14318 : 13500;
+    chip->CrystalFreqKHz   = (chip->PEXTDEV[0x00000000/4] & 0x00000040) ? 14318 : 13500;
     chip->CURSOR           = &(chip->PRAMIN[0x00008000/4 - 0x0800/4]);
-    chip->CURSORPOS        = &(chip->PRAMDAC[0x0300/4]);
-    chip->VBLANKENABLE     = &(chip->PGRAPH[0x0140/4]);
-    chip->VBLANK           = &(chip->PGRAPH[0x0100/4]);
     chip->VBlankBit        = 0x00000100;
     chip->MaxVClockFreqKHz = 256000;
     /*
@@ -1872,7 +1987,7 @@
     chip->CalcStateExt    = CalcStateExt;
     chip->LoadStateExt    = LoadStateExt;
     chip->UnloadStateExt  = UnloadStateExt;
-    chip->SetStartAddress = SetStartAddress;
+    chip->SetStartAddress = SetStartAddress3;
     chip->SetSurfaces2D   = nv3SetSurfaces2D;
     chip->SetSurfaces3D   = nv3SetSurfaces3D;
     chip->LockUnlock      = nv3LockUnlock;
@@ -1920,9 +2035,6 @@
     }
     chip->CrystalFreqKHz   = (chip->PEXTDEV[0x00000000/4] & 0x00000040) ? 14318 : 13500;
     chip->CURSOR           = &(chip->PRAMIN[0x00010000/4 - 0x0800/4]);
-    chip->CURSORPOS        = &(chip->PRAMDAC[0x0300/4]);
-    chip->VBLANKENABLE     = &(chip->PCRTC[0x0140/4]);
-    chip->VBLANK           = &(chip->PCRTC[0x0100/4]);
     chip->VBlankBit        = 0x00000001;
     chip->MaxVClockFreqKHz = 350000;
     /*
@@ -1940,15 +2052,31 @@
 }
 static void nv10GetConfig
 (
-    RIVA_HW_INST *chip
+    RIVA_HW_INST *chip,
+    unsigned int chipset
 )
 {
-#if defined(__BIG_ENDIAN)
+    struct pci_dev* dev;
+    int amt;
+
+#ifdef __BIG_ENDIAN
+    /* turn on big endian register access */
+    if(!(chip->PMC[0x00000004/4] & 0x01000001))
     chip->PMC[0x00000004/4] = 0x01000001;
 #endif
+
     /*
      * Fill in chip configuration.
      */
+    if(chipset == NV_CHIP_IGEFORCE2) {
+        dev = pci_find_slot(0, 1);
+        pci_read_config_dword(dev, 0x7C, &amt);
+        chip->RamAmountKBytes = (((amt >> 6) & 31) + 1) * 1024;
+    } else if(chipset == NV_CHIP_0x01F0) {
+        dev = pci_find_slot(0, 1);
+        pci_read_config_dword(dev, 0x84, &amt);
+        chip->RamAmountKBytes = (((amt >> 4) & 127) + 1) * 1024;
+    } else {
     switch ((chip->PFB[0x0000020C/4] >> 20) & 0x000000FF)
     {
         case 0x02:
@@ -1976,6 +2104,7 @@
             chip->RamAmountKBytes = 1024 * 16;
             break;
     }
+    }
     switch ((chip->PFB[0x00000000/4] >> 3) & 0x00000003)
     {
         case 3:
@@ -1985,11 +2114,29 @@
             chip->RamBandwidthKBytesPerSec = 1000000;
             break;
     }
-    chip->CrystalFreqKHz   = (chip->PEXTDEV[0x00000000/4] & 0x00000040) ? 14318 : 13500;
-    chip->CURSOR           = &(chip->PRAMIN[0x00010000/4 - 0x0800/4]);
-    chip->CURSORPOS        = &(chip->PRAMDAC[0x0300/4]);
-    chip->VBLANKENABLE     = &(chip->PCRTC[0x0140/4]);
-    chip->VBLANK           = &(chip->PCRTC[0x0100/4]);
+    chip->CrystalFreqKHz = (chip->PEXTDEV[0x0000/4] & (1 << 6)) ? 14318 :
+                                                                  13500;
+
+    switch (chipset & 0x0ff0) {
+    case 0x0170:
+    case 0x0180:
+    case 0x01F0:
+    case 0x0250:
+    case 0x0280:
+    case 0x0300:
+    case 0x0310:
+    case 0x0320:
+    case 0x0330:
+    case 0x0340:
+       if(chip->PEXTDEV[0x0000/4] & (1 << 22))
+           chip->CrystalFreqKHz = 27000;
+       break;
+    default:
+       break;
+    }
+
+    chip->CursorStart      = (chip->RamAmountKBytes - 128) * 1024;
+    chip->CURSOR           = NULL;  /* can't set this here */
     chip->VBlankBit        = 0x00000001;
     chip->MaxVClockFreqKHz = 350000;
     /*
@@ -2003,11 +2150,31 @@
     chip->SetStartAddress = SetStartAddress;
     chip->SetSurfaces2D   = nv10SetSurfaces2D;
     chip->SetSurfaces3D   = nv10SetSurfaces3D;
-    chip->LockUnlock      = nv10LockUnlock;
+    chip->LockUnlock      = nv4LockUnlock;
+
+    switch(chipset & 0x0ff0) {
+    case 0x0110:
+    case 0x0170:
+    case 0x0180:
+    case 0x01F0:
+    case 0x0250:
+    case 0x0280:
+    case 0x0300:
+    case 0x0310:
+    case 0x0320:
+    case 0x0330:
+    case 0x0340:
+        chip->twoHeads = TRUE;
+        break;
+    default:
+        chip->twoHeads = FALSE;
+        break;
+    }
 }
 int RivaGetConfig
 (
-    RIVA_HW_INST *chip
+    RIVA_HW_INST *chip,
+    unsigned int chipset
 )
 {
     /*
@@ -2027,11 +2194,12 @@
             break;
         case NV_ARCH_10:
 	case NV_ARCH_20:
-            nv10GetConfig(chip);
+            nv10GetConfig(chip, chipset);
             break;
         default:
             return (-1);
     }
+    chip->Chipset = chipset;
     /*
      * Fill in FIFO pointers.
      */
diff -urN kernel-source-2.4.27/drivers/video/riva/riva_hw.h kernel-source-2.4.27-benh/drivers/video/riva/riva_hw.h
--- kernel-source-2.4.27/drivers/video/riva/riva_hw.h	2003-06-13 16:51:37.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/riva/riva_hw.h	2004-09-01 20:56:29.747596736 +0200
@@ -41,14 +41,28 @@
  * GPL licensing note -- nVidia is allowing a liberal interpretation of
  * the documentation restriction above, to merely say that this nVidia's
  * copyright and disclaimer should be included with all code derived
- * from this source.  -- Jeff Garzik <jgarzik@pobox.com>, 01/Nov/99 
+ * from this source.  -- Jeff Garzik <jgarzik@mandrakesoft.com>, 01/Nov/99 
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_hw.h,v 1.6 2000/02/08 17:19:12 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_hw.h,v 1.21 2002/10/14 18:22:46 mvojkovi Exp $ */
 #ifndef __RIVA_HW_H__
 #define __RIVA_HW_H__
 #define RIVA_SW_VERSION 0x00010003
 
+#ifndef Bool
+typedef int Bool;
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef NULL
+#define NULL 0
+#endif
+
 /*
  * Typedefs to force certain sized values.
  */
@@ -397,6 +411,9 @@
 *                                                                           *
 \***************************************************************************/
 
+#define FP_ENABLE  1
+#define FP_DITHER  2
+
 struct _riva_hw_inst;
 struct _riva_hw_state;
 /*
@@ -409,6 +426,7 @@
      */
     U032 Architecture;
     U032 Version;
+    U032 Chipset;
     U032 CrystalFreqKHz;
     U032 RamAmountKBytes;
     U032 MaxVClockFreqKHz;
@@ -418,12 +436,15 @@
     U032 VBlankBit;
     U032 FifoFreeCount;
     U032 FifoEmptyCount;
+    U032 CursorStart;
     U032 flatPanel;
+    Bool twoHeads;
     /*
      * Non-FIFO registers.
      */
+    volatile U032 *PCRTC0;
     volatile U032 *PCRTC;
-    volatile U032 *PRAMDAC;
+    volatile U032 *PRAMDAC0;
     volatile U032 *PFB;
     volatile U032 *PFIFO;
     volatile U032 *PGRAPH;
@@ -433,17 +454,17 @@
     volatile U032 *PRAMIN;
     volatile U032 *FIFO;
     volatile U032 *CURSOR;
-    volatile U032 *CURSORPOS;
-    volatile U032 *VBLANKENABLE;
-    volatile U032 *VBLANK;
+    volatile U008 *PCIO0;
     volatile U008 *PCIO;
     volatile U008 *PVIO;
+    volatile U008 *PDIO0;
     volatile U008 *PDIO;
+    volatile U032 *PRAMDAC;
     /*
      * Common chip functions.
      */
     int  (*Busy)(struct _riva_hw_inst *);
-    void (*CalcStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *,int,int,int,int,int,int,int,int,int,int,int,int,int);
+    void (*CalcStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *,int,int,int,int,int);
     void (*LoadStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *);
     void (*UnloadStateExt)(struct _riva_hw_inst *,struct _riva_hw_state *);
     void (*SetStartAddress)(struct _riva_hw_inst *,U032);
@@ -476,10 +497,12 @@
     U032 bpp;
     U032 width;
     U032 height;
+    U032 interlace;
     U032 repaint0;
     U032 repaint1;
     U032 screen;
     U032 scale;
+    U032 dither;
     U032 extra;
     U032 pixel;
     U032 horiz;
@@ -489,7 +512,11 @@
     U032 vpll2;
     U032 pllsel;
     U032 general;
+    U032 crtcOwner;
+    U032 head; 
+    U032 head2; 
     U032 config;
+    U032 cursorConfig;	
     U032 cursor0;
     U032 cursor1;
     U032 cursor2;
@@ -505,15 +532,23 @@
 /*
  * External routines.
  */
-int RivaGetConfig(RIVA_HW_INST *);
+int RivaGetConfig(RIVA_HW_INST *, unsigned int);
 /*
  * FIFO Free Count. Should attempt to yield processor if RIVA is busy.
  */
 
+/*
+ * The mb()'s work around some lockup problems I experienced with some
+ * GeForceII MX cards, neither I nor Mark Vojkovich knows for sure what's
+ * going on there. --BenH
+ */ 
 #define RIVA_FIFO_FREE(hwinst,hwptr,cnt)                           \
 {                                                                  \
-   while ((hwinst).FifoFreeCount < (cnt))                          \
+    while ((hwinst).FifoFreeCount < (cnt)) {                        \
+    	mb();                                              \
+    	mb();	                                            \
 	(hwinst).FifoFreeCount = (hwinst).hwptr->FifoFree >> 2;        \
+    } \
    (hwinst).FifoFreeCount -= (cnt);                                \
 }
 #endif /* __RIVA_HW_H__ */
diff -urN kernel-source-2.4.27/drivers/video/riva/riva_tbl.h kernel-source-2.4.27-benh/drivers/video/riva/riva_tbl.h
--- kernel-source-2.4.27/drivers/video/riva/riva_tbl.h	2003-06-13 16:51:37.000000000 +0200
+++ kernel-source-2.4.27-benh/drivers/video/riva/riva_tbl.h	2004-09-01 20:56:29.750596280 +0200
@@ -41,10 +41,12 @@
  * GPL licensing note -- nVidia is allowing a liberal interpretation of
  * the documentation restriction above, to merely say that this nVidia's
  * copyright and disclaimer should be included with all code derived
- * from this source.  -- Jeff Garzik <jgarzik@pobox.com>, 01/Nov/99 
+ * from this source.  -- Jeff Garzik <jgarzik@mandrakesoft.com>, 01/Nov/99 
  */
 
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_tbl.h,v 1.5 2000/02/08 17:19:12 dawes Exp $ */
+/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/riva_tbl.h,v 1.9 2002/01/30 01:35:03 mvojkovi Exp $ */
+
+
 /*
  * RIVA Fixed Functionality Init Tables.
  */
@@ -69,6 +71,7 @@
     {0x00001800, 0x80000010},
     {0x00002000, 0x80000011},
     {0x00002800, 0x80000012},
+    {0x00003000, 0x80000016},
     {0x00003800, 0x80000013}
 };
 static unsigned nv3TablePFIFO[][2] =
@@ -174,6 +177,8 @@
     {0x00000249, 0x00CC0346},
     {0x0000024C, 0x80000013},
     {0x0000024D, 0x00D70347},
+    {0x00000258, 0x80000016},
+    {0x00000259, 0x00CA034C},
     {0x00000D05, 0x00000000},
     {0x00000D06, 0x00000000},
     {0x00000D07, 0x00000000},
@@ -210,7 +215,10 @@
     {0x00000D2C, 0x10830200},
     {0x00000D2D, 0x00000000},
     {0x00000D2E, 0x00000000},
-    {0x00000D2F, 0x00000000} 
+    {0x00000D2F, 0x00000000},
+    {0x00000D31, 0x00000000},
+    {0x00000D32, 0x00000000},
+    {0x00000D33, 0x00000000}
 };
 static unsigned nv3TablePRAMIN_8BPP[][2] =
 {
@@ -222,7 +230,8 @@
     {0x00000D10, 0x10118203},
     {0x00000D14, 0x10110203},
     {0x00000D18, 0x10110203},
-    {0x00000D1C, 0x10419208}
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118203}
 };
 static unsigned nv3TablePRAMIN_15BPP[][2] =
 {
@@ -234,7 +243,8 @@
     {0x00000D10, 0x10118200},
     {0x00000D14, 0x10110200},
     {0x00000D18, 0x10110200},
-    {0x00000D1C, 0x10419208}
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118200}
 };
 static unsigned nv3TablePRAMIN_32BPP[][2] =
 {
@@ -246,7 +256,8 @@
     {0x00000D10, 0x10118201},
     {0x00000D14, 0x10110201},
     {0x00000D18, 0x10110201},
-    {0x00000D1C, 0x10419208}
+    {0x00000D1C, 0x10419208},
+    {0x00000D30, 0x10118201}
 };
 static unsigned nv4TableFIFO[][2] =
 {
@@ -370,6 +381,8 @@
     {0x00000009, 0x80011149},
     {0x0000000A, 0x80000015},
     {0x0000000B, 0x8001114A},
+    {0x0000000C, 0x80000016},
+    {0x0000000D, 0x8001114F},
     {0x00000020, 0x80000000},
     {0x00000021, 0x80011142},
     {0x00000022, 0x80000001},
@@ -437,7 +450,10 @@
     {0x00000537, 0x00000000},
     {0x00000538, 0x0000005B},
     {0x0000053A, 0x11401140},
-    {0x0000053B, 0x00000000} 
+    {0x0000053B, 0x00000000},
+    {0x0000053C, 0x0300A01C},
+    {0x0000053E, 0x11401140},
+    {0x0000053F, 0x00000000}
 };
 static unsigned nv4TablePRAMIN_8BPP[][2] =
 {
@@ -452,7 +468,8 @@
     {0x0000052D, 0x00000302},
     {0x0000052E, 0x00000302},
     {0x00000535, 0x00000000},
-    {0x00000539, 0x00000000} 
+    {0x00000539, 0x00000000},
+    {0x0000053D, 0x00000302}
 };
 static unsigned nv4TablePRAMIN_15BPP[][2] =
 {
@@ -467,7 +484,8 @@
     {0x0000052D, 0x00000902},
     {0x0000052E, 0x00000902},
     {0x00000535, 0x00000702},
-    {0x00000539, 0x00000702} 
+    {0x00000539, 0x00000702},
+    {0x0000053D, 0x00000902}
 };
 static unsigned nv4TablePRAMIN_16BPP[][2] =
 {
@@ -482,7 +500,8 @@
     {0x0000052D, 0x00000C02},
     {0x0000052E, 0x00000C02},
     {0x00000535, 0x00000702},
-    {0x00000539, 0x00000702} 
+    {0x00000539, 0x00000702},
+    {0x0000053D, 0x00000C02}
 };
 static unsigned nv4TablePRAMIN_32BPP[][2] =
 {
@@ -497,7 +516,8 @@
     {0x0000052D, 0x00000E02},
     {0x0000052E, 0x00000E02},
     {0x00000535, 0x00000E02},
-    {0x00000539, 0x00000E02} 
+    {0x00000539, 0x00000E02},
+    {0x0000053D, 0x00000E02}
 };
 static unsigned nv10TableFIFO[][2] =
 {
@@ -810,6 +830,8 @@
     {0x00000009, 0x80011149},
     {0x0000000A, 0x80000015},
     {0x0000000B, 0x8001114A},
+    {0x0000000C, 0x80000016},
+    {0x0000000D, 0x80011150},
     {0x00000020, 0x80000000},
     {0x00000021, 0x80011142},
     {0x00000022, 0x80000001},
diff -urN kernel-source-2.4.27/fs/jbd/transaction.c kernel-source-2.4.27-benh/fs/jbd/transaction.c
--- kernel-source-2.4.27/fs/jbd/transaction.c	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/fs/jbd/transaction.c	2004-09-01 20:56:29.000000000 +0200
@@ -56,7 +56,11 @@
 	transaction->t_journal = journal;
 	transaction->t_state = T_RUNNING;
 	transaction->t_tid = journal->j_transaction_sequence++;
-	transaction->t_expires = jiffies + journal->j_commit_interval;
+	/*
+	 * have to do it here, otherwise changed age_buffers since boot
+	 * wont have any effect
+	 */
+	transaction->t_expires = jiffies + get_buffer_flushtime();
 	INIT_LIST_HEAD(&transaction->t_jcb);
 
 	if (journal->j_commit_interval) {
diff -urN kernel-source-2.4.27/include/asm-ppc/atomic.h kernel-source-2.4.27-benh/include/asm-ppc/atomic.h
--- kernel-source-2.4.27/include/asm-ppc/atomic.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/atomic.h	2004-09-01 20:56:29.915571200 +0200
@@ -18,9 +18,12 @@
 extern void atomic_set_mask(unsigned long mask, unsigned long *addr);
 
 #ifdef CONFIG_SMP
-#define SMP_ISYNC	"\n\tisync"
+#define SMP_ISYNC	"\n\tisync\n"
+//#define SMP_EIEIO	"\n\teieio\n"
+#define SMP_EIEIO	"\n\tsync\n"
 #else
 #define SMP_ISYNC
+#define SMP_EIEIO
 #endif
 
 /* Erratum #77 on the 405 means we need a sync or dcbt before every stwcx.
@@ -52,6 +55,7 @@
 	int t;
 
 	__asm__ __volatile__(
+	SMP_EIEIO
 "1:	lwarx	%0,0,%2		# atomic_add_return\n\
 	add	%0,%1,%0\n"
 	PPC405_ERR77(0,%2)
@@ -85,6 +89,7 @@
 	int t;
 
 	__asm__ __volatile__(
+	SMP_EIEIO
 "1:	lwarx	%0,0,%2		# atomic_sub_return\n\
 	subf	%0,%1,%0\n"
 	PPC405_ERR77(0,%2)
@@ -118,6 +123,7 @@
 	int t;
 
 	__asm__ __volatile__(
+	SMP_EIEIO
 "1:	lwarx	%0,0,%1		# atomic_inc_return\n\
 	addic	%0,%0,1\n"
 	PPC405_ERR77(0,%1)
@@ -151,6 +157,7 @@
 	int t;
 
 	__asm__ __volatile__(
+	SMP_EIEIO
 "1:	lwarx	%0,0,%1		# atomic_dec_return\n\
 	addic	%0,%0,-1\n"
 	PPC405_ERR77(0,%1)
@@ -176,6 +183,7 @@
 	int t;
 
 	__asm__ __volatile__(
+	SMP_EIEIO
 "1:	lwarx	%0,0,%1		# atomic_dec_if_positive\n\
 	addic.	%0,%0,-1\n\
 	blt-	2f\n"
diff -urN kernel-source-2.4.27/include/asm-ppc/elf.h kernel-source-2.4.27-benh/include/asm-ppc/elf.h
--- kernel-source-2.4.27/include/asm-ppc/elf.h	2003-06-13 16:51:38.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/elf.h	2004-09-01 20:56:29.995559040 +0200
@@ -10,7 +10,7 @@
 
 #define ELF_NGREG	48	/* includes nip, msr, lr, etc. */
 #define ELF_NFPREG	33	/* includes fpscr */
-#define ELF_NVRREG	33	/* includes vscr */
+#define ELF_NVRREG	33	/* includes vscr & vrsave */
 
 /*
  * These are used to set parameters in the core dumps.
diff -urN kernel-source-2.4.27/include/asm-ppc/hardirq.h kernel-source-2.4.27-benh/include/asm-ppc/hardirq.h
--- kernel-source-2.4.27/include/asm-ppc/hardirq.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/hardirq.h	2004-09-01 20:56:29.996558888 +0200
@@ -54,12 +54,24 @@
 extern unsigned volatile long global_irq_lock;
 extern atomic_t global_irq_count;
 
+#ifdef CONFIG_DEBUG_SPINLOCK
+extern int debug_long_irqlock;
+extern void print_backtrace(unsigned long *sp);
+#endif /* CONFIG_DEBUG_SPINLOCK */
+
 static inline void release_irqlock(int cpu)
 {
 	/* if we didn't own the irq lock, just ignore.. */
 	if (global_irq_holder == (unsigned char) cpu) {
 		global_irq_holder = NO_PROC_ID;
 		clear_bit(0,&global_irq_lock);
+#ifdef CONFIG_DEBUG_SPINLOCK
+		if (debug_long_irqlock) {
+			debug_long_irqlock = 0;
+			printk("Release long irq lock\n");
+			print_backtrace(NULL);
+		}
+#endif /* CONFIG_DEBUG_SPINLOCK */
 	}
 }
 
@@ -69,6 +81,7 @@
 
 	++local_irq_count(cpu);
 	atomic_inc(&global_irq_count);
+	smp_mb__after_atomic_inc();
 	while (test_bit(0,&global_irq_lock)) {
 		if (cpu == global_irq_holder) {
 			printk("uh oh, interrupt while we hold global irq lock! (CPU %d)\n", cpu);
@@ -79,6 +92,9 @@
 		}
 		if (loops-- == 0) {
 			printk("do_IRQ waiting for irq lock (holder=%d)\n", global_irq_holder);
+#ifdef CONFIG_DEBUG_SPINLOCK
+			debug_long_irqlock = 1;
+#endif
 #ifdef CONFIG_XMON
 			xmon(0);
 #endif
@@ -88,6 +104,7 @@
 
 static inline void hardirq_exit(int cpu)
 {
+	smp_mb__after_atomic_dec();
 	atomic_dec(&global_irq_count);
 	--local_irq_count(cpu);
 }
diff -urN kernel-source-2.4.27/include/asm-ppc/highmem.h kernel-source-2.4.27-benh/include/asm-ppc/highmem.h
--- kernel-source-2.4.27/include/asm-ppc/highmem.h	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/include/asm-ppc/highmem.h	2004-09-01 20:56:30.076546728 +0200
@@ -28,7 +28,7 @@
 #include <asm/pgtable.h>
 
 /* undef for production */
-#define HIGHMEM_DEBUG 1
+#define HIGHMEM_DEBUG 0
 
 extern pte_t *kmap_pte;
 extern pgprot_t kmap_prot;
diff -urN kernel-source-2.4.27/include/asm-ppc/ide.h kernel-source-2.4.27-benh/include/asm-ppc/ide.h
--- kernel-source-2.4.27/include/asm-ppc/ide.h	2003-06-13 16:51:38.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/ide.h	2004-09-01 20:56:30.077546576 +0200
@@ -34,6 +34,7 @@
                                      ide_ioreg_t data_port,
                                      ide_ioreg_t ctrl_port,
                                      int *irq);
+        int         (*reserved_hwifs)(void);
 };
 
 extern struct ide_machdep_calls ppc_ide_md;
@@ -112,6 +113,17 @@
 #define IDE_ARCH_ACK_INTR 1
 #endif
 
+/*
+ * How many IDE slots are "reserved" for bootable devices
+ */
+#define IDE_ARCH_RESERVED_HWIFS 1
+static inline int ide_reserved_hwifs(void)
+{
+	if (ppc_ide_md.reserved_hwifs)
+		return ppc_ide_md.reserved_hwifs();
+	return 2;
+}
+
 #endif /* __KERNEL__ */
 
 #endif /* __ASMPPC_IDE_H */
diff -urN kernel-source-2.4.27/include/asm-ppc/io.h kernel-source-2.4.27-benh/include/asm-ppc/io.h
--- kernel-source-2.4.27/include/asm-ppc/io.h	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/include/asm-ppc/io.h	2004-09-01 20:56:30.159534112 +0200
@@ -288,9 +288,15 @@
 /* Enforce in-order execution of data I/O.
  * No distinction between read/write on PPC; use eieio for all three.
  */
+#if 0
 #define iobarrier_rw() eieio()
 #define iobarrier_r()  eieio()
 #define iobarrier_w()  eieio()
+#endif
+extern inline void io_barrier(void)
+{
+	__asm__ __volatile__ ("sync" : : : "memory");
+}
 
 /*
  * 8, 16 and 32 bit, big and little endian I/O operations, with barrier.
@@ -312,7 +318,7 @@
 
 extern inline void out_8(volatile unsigned char *addr, int val)
 {
-	__asm__ __volatile__("stb%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
+	__asm__ __volatile__("sync; stb%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
 }
 
 extern inline int in_le16(volatile unsigned short *addr)
@@ -338,13 +344,13 @@
 
 extern inline void out_le16(volatile unsigned short *addr, int val)
 {
-	__asm__ __volatile__("sthbrx %1,0,%2; eieio" : "=m" (*addr) :
+	__asm__ __volatile__("sync; sthbrx %1,0,%2; eieio" : "=m" (*addr) :
 			      "r" (val), "r" (addr));
 }
 
 extern inline void out_be16(volatile unsigned short *addr, int val)
 {
-	__asm__ __volatile__("sth%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
+	__asm__ __volatile__("sync; sth%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
 }
 
 extern inline unsigned in_le32(volatile unsigned *addr)
@@ -370,13 +376,13 @@
 
 extern inline void out_le32(volatile unsigned *addr, int val)
 {
-	__asm__ __volatile__("stwbrx %1,0,%2; eieio" : "=m" (*addr) :
+	__asm__ __volatile__("sync; stwbrx %1,0,%2; eieio" : "=m" (*addr) :
 			     "r" (val), "r" (addr));
 }
 
 extern inline void out_be32(volatile unsigned *addr, int val)
 {
-	__asm__ __volatile__("stw%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
+	__asm__ __volatile__("sync; stw%U0%X0 %1,%0; eieio" : "=m" (*addr) : "r" (val));
 }
 
 static inline int check_signature(unsigned long io_addr,
diff -urN kernel-source-2.4.27/include/asm-ppc/nvram.h kernel-source-2.4.27-benh/include/asm-ppc/nvram.h
--- kernel-source-2.4.27/include/asm-ppc/nvram.h	2003-06-13 16:51:38.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/nvram.h	2004-09-01 20:56:30.160533960 +0200
@@ -41,11 +41,15 @@
 
 /* Return partition offset in nvram */
 extern int	pmac_get_partition(int partition);
+extern void	pmac_nvram_sync(void);
 
 /* Direct access to XPRAM */
 extern u8	pmac_xpram_read(int xpaddr);
 extern void	pmac_xpram_write(int xpaddr, u8 data);
 
+/* Sync nvram to HW */
+extern void	pmac_nvram_sync(void);
+
 /* Some offsets in XPRAM */
 #define PMAC_XPRAM_MACHINE_LOC	0xe4
 #define PMAC_XPRAM_SOUND_VOLUME	0x08
@@ -58,7 +62,11 @@
 };
 
 /* /dev/nvram ioctls */
-#define PMAC_NVRAM_GET_OFFSET	_IOWR('p', 0x40, int) /* Get NVRAM partition offset */
+#define OBSOLETE_PMAC_NVRAM_GET_OFFSET \
+				_IOWR('p', 0x40, int)
+
+#define IOC_NVRAM_GET_OFFSET	_IOWR('p', 0x42, int)	/* Get NVRAM partition offset */
+#define IOC_NVRAM_SYNC		_IO('p', 0x43)		/* Sync NVRAM image */
 
 #endif
 #endif /* __KERNEL__ */
diff -urN kernel-source-2.4.27/include/asm-ppc/open_pic.h kernel-source-2.4.27-benh/include/asm-ppc/open_pic.h
--- kernel-source-2.4.27/include/asm-ppc/open_pic.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/open_pic.h	2004-09-01 20:56:30.161533808 +0200
@@ -21,8 +21,12 @@
  *  Non-offset'ed vector numbers
  */
 
-#define OPENPIC_VEC_TIMER	64	/* and up */
-#define OPENPIC_VEC_IPI		72	/* and up */
+//#define OPENPIC_VEC_TIMER	64	/* and up */
+//#define OPENPIC_VEC_IPI		72	/* and up */
+//#define OPENPIC_VEC_SPURIOUS	127
+
+#define OPENPIC_VEC_TIMER	110	/* and up */
+#define OPENPIC_VEC_IPI		118	/* and up */
 #define OPENPIC_VEC_SPURIOUS	127
 
 /* OpenPIC IRQ controller structure */
@@ -66,5 +70,33 @@
 		return 0;
 	}
 }
-/*extern int open_pic_irq_offset;*/
+
+/* Support for second openpic on G5 macs */
+
+#define PMAC_OPENPIC2_OFFSET	128
+
+#define OPENPIC2_VEC_TIMER	110	/* and up */
+#define OPENPIC2_VEC_IPI	118	/* and up */
+#define OPENPIC2_VEC_SPURIOUS	127
+
+
+extern void* OpenPIC2_Addr;
+
+/* Exported functions */
+extern void openpic2_set_sources(int first_irq, int num_irqs, void *isr);
+extern void openpic2_init(int linux_irq_offset);
+extern void openpic2_init_nmi_irq(u_int irq);
+extern void openpic2_hookup_cascade(u_int irq, char *name,
+				   int (*cascade_fn)(struct pt_regs *));
+extern u_int openpic2_irq(void);
+extern void openpic2_eoi(void);
+extern void openpic2_request_IPIs(void);
+extern void do_openpic2_setup_cpu(void);
+extern int openpic2_get_irq(struct pt_regs *regs);
+extern void openpic2_reset_processor_phys(u_int cpumask);
+extern void openpic2_setup_ISU(int isu_num, unsigned long addr);
+extern void openpic2_cause_IPI(u_int ipi, u_int cpumask);
+extern void smp_openpic2_message_pass(int target, int msg, unsigned long data,
+				     int wait);
+
 #endif /* _PPC_KERNEL_OPEN_PIC_H */
diff -urN kernel-source-2.4.27/include/asm-ppc/page.h kernel-source-2.4.27-benh/include/asm-ppc/page.h
--- kernel-source-2.4.27/include/asm-ppc/page.h	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/include/asm-ppc/page.h	2004-09-01 20:56:30.241521648 +0200
@@ -34,7 +34,9 @@
 #include <asm/system.h> /* for xmon definition */
 
 #ifdef CONFIG_XMON
+extern void xmon_printf(const char *fmt, ...);
 #define BUG() do { \
+	xmon_printf("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
 	printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
 	xmon(0); \
 } while (0)
diff -urN kernel-source-2.4.27/include/asm-ppc/pgalloc.h kernel-source-2.4.27-benh/include/asm-ppc/pgalloc.h
--- kernel-source-2.4.27/include/asm-ppc/pgalloc.h	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/include/asm-ppc/pgalloc.h	2004-09-01 20:56:30.243521344 +0200
@@ -68,6 +68,7 @@
 	return ret;
 }
 
+#ifndef CONFIG_DEBUG_NOPGTABLECACHE
 extern __inline__ pgd_t *get_pgd_fast(void)
 {
         unsigned long *ret;
@@ -87,14 +88,20 @@
         pgd_quicklist = (unsigned long *) pgd;
         pgtable_cache_size++;
 }
+#endif
 
 extern __inline__ void free_pgd_slow(pgd_t *pgd)
 {
 	free_page((unsigned long)pgd);
 }
 
+#ifdef CONFIG_DEBUG_NOPGTABLECACHE
+#define pgd_free(pgd)		free_pgd_slow(pgd)
+#define pgd_alloc(mm)		get_pgd_slow()
+#else
 #define pgd_free(pgd)		free_pgd_fast(pgd)
 #define pgd_alloc(mm)		get_pgd_fast()
+#endif
 
 /*
  * We don't have any real pmd's, and this code never triggers because
@@ -120,6 +127,13 @@
 	return pte;
 }
 
+#ifdef CONFIG_DEBUG_NOPGTABLECACHE
+static inline pte_t *pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
+{
+	return NULL;
+}
+#else
+
 static inline pte_t *pte_alloc_one_fast(struct mm_struct *mm, unsigned long address)
 {
         unsigned long *ret;
@@ -138,6 +152,7 @@
         pte_quicklist = (unsigned long *) pte;
         pgtable_cache_size++;
 }
+#endif
 
 extern __inline__ void pte_free_slow(pte_t *pte)
 {
diff -urN kernel-source-2.4.27/include/asm-ppc/pmac_feature.h kernel-source-2.4.27-benh/include/asm-ppc/pmac_feature.h
--- kernel-source-2.4.27/include/asm-ppc/pmac_feature.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/pmac_feature.h	2004-09-01 20:56:30.323509184 +0200
@@ -96,8 +96,8 @@
 #define PMAC_TYPE_UNKNOWN_CORE99	0x5f
 
 /* MacRisc2 with UniNorth 2.0 */
-#define PMAC_TYPE_RACKMAC		0x80	/* XServe */
-#define PMAC_TYPE_WINDTUNNEL		0x81
+#define PMAC_TYPE_RACKMAC		0x80	/* XServes (all) */
+#define PMAC_TYPE_WINDTUNNEL		0x81	/* Windtunnel */
 
 /* MacRISC2 machines based on the Pangea chipset
  */
@@ -110,6 +110,10 @@
  */
 #define PMAC_TYPE_UNKNOWN_INTREPID	0x11f	/* Generic */
 
+/* MacRISC4 / G5 machines
+ */
+#define PMAC_TYPE_POWERMAC_G5		0x150	/* First tower */
+
 /*
  * Motherboard flags
  */
diff -urN kernel-source-2.4.27/include/asm-ppc/ppc4xx_serial.h kernel-source-2.4.27-benh/include/asm-ppc/ppc4xx_serial.h
--- kernel-source-2.4.27/include/asm-ppc/ppc4xx_serial.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/include/asm-ppc/ppc4xx_serial.h	2004-09-01 20:56:30.324509032 +0200
@@ -0,0 +1,101 @@
+/*
+ *    Copyright 2000 MontaVista Software Inc.
+ *	PPC405GP modifications
+ * 	Author: MontaVista Software, Inc.
+ *         	frank_rowand@mvista.com or source@mvista.com
+ * 	   	debbie_chu@mvista.com
+ *
+ *    Module name: ppc405_serial.h
+ *
+ *    Description:
+ *      Macros, definitions, and data structures specific to the IBM PowerPC
+ *      405 on-chip serial port devices.
+ */
+
+#ifdef __KERNEL__
+#ifndef __ASMPPC_PPC4xx_SERIAL_H
+#define __ASMPPC_PPC4xx_SERIAL_H
+
+#include <linux/config.h>
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+#define RS_TABLE_SIZE	64
+#else
+#define RS_TABLE_SIZE	4
+#endif
+
+#define PPC405GP_UART0_INT	0
+#define PPC405GP_UART1_INT	1
+
+/*
+** 405GP UARTs are *not* PCI devices, so need to specify a non-pci memory
+** address and an io_type of SERIAL_IO_MEM.
+*/
+
+#define PPC405GP_UART0_IO_BASE	(u8 *) 0xef600300
+#define PPC405GP_UART1_IO_BASE	(u8 *) 0xef600400
+
+/*
+**  - there is no config option for this
+**  - this name could be more informative
+**  - also see arch/ppc/kernel/ppc405_serial.c
+**
+** #define CONFIG_PPC405GP_INTERNAL_CLOCK
+*/
+#ifdef	CONFIG_PPC405GP_INTERNAL_CLOCK
+#define BASE_BAUD		201600
+#else
+#define BASE_BAUD		691200
+#endif
+
+
+#ifdef CONFIG_SERIAL_DETECT_IRQ
+#define STD_COM_FLAGS	(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ)
+#define STD_COM4_FLAGS	(ASYNC_BOOT_AUTOCONF | ASYNC_AUTO_IRQ)
+#else
+#define STD_COM_FLAGS	(ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#define STD_COM4_FLAGS	(ASYNC_BOOT_AUTOCONF)
+#endif
+
+
+#ifdef CONFIG_STB03XXX
+
+#define UART0_IO_BASE 0x40040000
+#define UART0_INT     20
+
+#define STD_SERIAL_PORT_DFNS \
+    /* ttyS0 */ \
+    { 0, BASE_BAUD, 0, UART0_INT, STD_COM_FLAGS, 0, 0, 0, 0, 0, 0, 0, \
+    UART0_IO_BASE, 0, 0, 0, {}, {}, {}, SERIAL_IO_MEM, NULL },
+
+#elif defined(CONFIG_UART1_DFLT_CONSOLE)
+
+#define STD_SERIAL_PORT_DFNS \
+    /* ttyS1 */ \
+    { 0, BASE_BAUD, 0, PPC405GP_UART1_INT, STD_COM_FLAGS, 0, 0, 0, 0, 0, 0, 0, \
+    PPC405GP_UART1_IO_BASE, 0, 0, 0, {}, {}, {}, SERIAL_IO_MEM, NULL },        \
+    /* ttyS0 */ \
+    { 0, BASE_BAUD, 0, PPC405GP_UART0_INT, STD_COM_FLAGS, 0, 0, 0, 0, 0, 0, 0, \
+    PPC405GP_UART0_IO_BASE, 0, 0, 0, {}, {}, {}, SERIAL_IO_MEM, NULL },
+
+#else
+
+#define STD_SERIAL_PORT_DFNS \
+    /* ttyS0 */ \
+    { 0, BASE_BAUD, 0, PPC405GP_UART0_INT, STD_COM_FLAGS, 0, 0, 0, 0, 0, 0, 0, \
+    PPC405GP_UART0_IO_BASE, 0, 0, 0, {}, {}, {}, SERIAL_IO_MEM, NULL },        \
+    /* ttyS1 */ \
+    { 0, BASE_BAUD, 0, PPC405GP_UART1_INT, STD_COM_FLAGS, 0, 0, 0, 0, 0, 0, 0, \
+    PPC405GP_UART1_IO_BASE, 0, 0, 0, {}, {}, {}, SERIAL_IO_MEM, NULL },
+
+#endif
+
+
+#define SERIAL_PORT_DFNS     \
+	STD_SERIAL_PORT_DFNS \
+	{}
+
+
+
+#endif	/* __ASMPPC_PPC4xx_SERIAL_H */
+#endif /* __KERNEL__ */
diff -urN kernel-source-2.4.27/include/asm-ppc/processor.h kernel-source-2.4.27-benh/include/asm-ppc/processor.h
--- kernel-source-2.4.27/include/asm-ppc/processor.h	2004-04-14 15:05:40.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/processor.h	2004-09-01 20:56:30.406496568 +0200
@@ -296,6 +296,8 @@
 #define	  HID1_ABE	(1<<10)		/* 7450 Address Broadcast Enable */
 #define	SPRN_HID2	0x3F8	/* Hardware Implementation Register 2 */
 #define	SPRN_IABR	0x3F2	/* Instruction Address Breakpoint Register */
+#define SPRN_HID4	0x3F4		/* 970 HID4 */
+#define SPRN_HID5	0x3F6		/* 970 HID5 */
 #ifdef CONFIG_BOOKE
 #define	SPRN_IAC1	0x138	/* Book E Instruction Address Compare 1 */
 #define	SPRN_IAC2	0x139	/* Book E Instruction Address Compare 2 */
@@ -445,6 +447,7 @@
 #define	SPRN_TBRU	0x10D	/* Time Base Read Upper Register (user, R/O) */
 #define	SPRN_TBWL	0x11C	/* Time Base Lower Register (super, R/W) */
 #define	SPRN_TBWU	0x11D	/* Time Base Upper Register (super, R/W) */
+#define SPRN_HIOR	0x137	/* 970 Hypervisor interrupt offset */
 #ifdef CONFIG_BOOKE
 #define	SPRN_TCR	0x154	/* Book E Timer Control Register */
 #else
diff -urN kernel-source-2.4.27/include/asm-ppc/semaphore.h kernel-source-2.4.27-benh/include/asm-ppc/semaphore.h
--- kernel-source-2.4.27/include/asm-ppc/semaphore.h	2003-06-13 16:51:38.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/semaphore.h	2004-09-01 20:56:30.408496264 +0200
@@ -87,9 +87,8 @@
 	/*
 	 * Try to get the semaphore, take the slow path if we fail.
 	 */
-	if (atomic_dec_return(&sem->count) < 0)
+	if (unlikely(atomic_dec_return(&sem->count) < 0))
 		__down(sem);
-	smp_wmb();
 }
 
 extern inline int down_interruptible(struct semaphore * sem)
@@ -100,23 +99,18 @@
 	CHECK_MAGIC(sem->__magic);
 #endif
 
-	if (atomic_dec_return(&sem->count) < 0)
+	if (unlikely(atomic_dec_return(&sem->count) < 0))
 		ret = __down_interruptible(sem);
-	smp_wmb();
 	return ret;
 }
 
 extern inline int down_trylock(struct semaphore * sem)
 {
-	int ret;
-
 #if WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 
-	ret = atomic_dec_if_positive(&sem->count) < 0;
-	smp_wmb();
-	return ret;
+	return atomic_dec_if_positive(&sem->count) < 0;
 }
 
 extern inline void up(struct semaphore * sem)
@@ -125,8 +119,7 @@
 	CHECK_MAGIC(sem->__magic);
 #endif
 
-	smp_wmb();
-	if (atomic_inc_return(&sem->count) <= 0)
+	if (unlikely(atomic_inc_return(&sem->count) <= 0))
 		__up(sem);
 }
 
diff -urN kernel-source-2.4.27/include/asm-ppc/smp.h kernel-source-2.4.27-benh/include/asm-ppc/smp.h
--- kernel-source-2.4.27/include/asm-ppc/smp.h	2003-06-13 16:51:38.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/smp.h	2004-09-01 20:56:30.488484104 +0200
@@ -17,6 +17,8 @@
 
 #ifndef __ASSEMBLY__
 
+#define cpu_online(cpu) (cpu_online_map & (1<<(cpu)))
+
 struct cpuinfo_PPC {
 	unsigned long loops_per_jiffy;
 	unsigned long pvr;
@@ -69,6 +71,8 @@
 
 #else /* !(CONFIG_SMP) */
 
+#define cpu_online(cpu) ((cpu) == 0)
+
 #endif /* !(CONFIG_SMP) */
 
 #endif /* !(_PPC_SMP_H) */
diff -urN kernel-source-2.4.27/include/asm-ppc/spinlock.h kernel-source-2.4.27-benh/include/asm-ppc/spinlock.h
--- kernel-source-2.4.27/include/asm-ppc/spinlock.h	2003-06-13 16:51:38.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/spinlock.h	2004-09-01 20:56:30.489483952 +0200
@@ -70,7 +70,7 @@
 
 static inline void spin_unlock(spinlock_t *lock)
 {
-	__asm__ __volatile__("eieio		# spin_unlock": : :"memory");
+	__asm__ __volatile__("sync		# spin_unlock": : :"memory");
 	lock->lock = 0;
 }
 
@@ -144,7 +144,7 @@
 	unsigned int tmp;
 
 	__asm__ __volatile__(
-	"eieio			# read_unlock\n\
+	"sync			# read_unlock\n\
 1:	lwarx	%0,0,%1\n\
 	addic	%0,%0,-1\n"
 	PPC405_ERR77(0,%1)
@@ -178,7 +178,7 @@
 
 static __inline__ void write_unlock(rwlock_t *rw)
 {
-	__asm__ __volatile__("eieio		# write_unlock": : :"memory");
+	__asm__ __volatile__("sync		# write_unlock": : :"memory");
 	rw->lock = 0;
 }
 
diff -urN kernel-source-2.4.27/include/asm-ppc/uninorth.h kernel-source-2.4.27-benh/include/asm-ppc/uninorth.h
--- kernel-source-2.4.27/include/asm-ppc/uninorth.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-benh/include/asm-ppc/uninorth.h	2004-09-01 20:56:30.490483800 +0200
@@ -131,5 +131,20 @@
 
 /* Uninorth 1.5 rev. has additional perf. monitor registers at 0xf00-0xf50 */
 
+/*
+ * U3 specific registers
+ */
+ 
+ 
+/* U3 Toggle */
+#define U3_TOGGLE_REG                   0x00e0
+#define U3_PMC_START_STOP               0x0001
+#define U3_MPIC_RESET                   0x0002
+#define U3_MPIC_OUTPUT_ENABLE           0x0004
+ 
+/* U3 API PHY Config 1 */
+#define U3_API_PHY_CONFIG_1             0x23030
+ 
+
 #endif /* __ASM_UNINORTH_H__ */
 #endif /* __KERNEL__ */
diff -urN kernel-source-2.4.27/include/linux/agp_backend.h kernel-source-2.4.27-benh/include/linux/agp_backend.h
--- kernel-source-2.4.27/include/linux/agp_backend.h	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/include/linux/agp_backend.h	2004-09-01 20:56:30.000000000 +0200
@@ -101,7 +101,8 @@
 	ATI_RS300_100,
 	ATI_RS300_133,
 	ATI_RS300_166,
-	ATI_RS300_200
+	ATI_RS300_200,
+	APPLE_UNINORTH
 };
 
 typedef struct _agp_version {
diff -urN kernel-source-2.4.27/include/linux/blkdev.h kernel-source-2.4.27-benh/include/linux/blkdev.h
--- kernel-source-2.4.27/include/linux/blkdev.h	2004-02-18 14:36:32.000000000 +0100
+++ kernel-source-2.4.27-benh/include/linux/blkdev.h	2004-09-01 20:56:30.000000000 +0200
@@ -63,6 +63,8 @@
 typedef int (make_request_fn) (request_queue_t *q, int rw, struct buffer_head *bh);
 typedef void (plug_device_fn) (request_queue_t *q, kdev_t device);
 typedef void (unplug_device_fn) (void *q);
+typedef void (activity_fn) (void *data, int rw);
+
 
 struct request_list {
 	unsigned int count;
@@ -114,12 +116,16 @@
 	merge_requests_fn	* merge_requests_fn;
 	make_request_fn		* make_request_fn;
 	plug_device_fn		* plug_device_fn;
+	activity_fn		* activity_fn;
+
 	/*
 	 * The queue owner gets to use this for whatever they like.
 	 * ll_rw_blk doesn't touch it.
 	 */
 	void			* queuedata;
 
+	void			* activity_data;
+
 	/*
 	 * This is used to remove the plug when tq_disk runs.
 	 */
@@ -246,6 +252,7 @@
 extern void blk_queue_throttle_sectors(request_queue_t *, int);
 extern void blk_queue_make_request(request_queue_t *, make_request_fn *);
 extern void generic_unplug_device(void *);
+extern void blk_queue_activity_fn(request_queue_t *, activity_fn *, void *);
 extern inline int blk_seg_merge_ok(struct buffer_head *, struct buffer_head *);
 
 extern int * blk_size[MAX_BLKDEV];
diff -urN kernel-source-2.4.27/include/linux/cpufreq.h kernel-source-2.4.27-benh/include/linux/cpufreq.h
--- kernel-source-2.4.27/include/linux/cpufreq.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/include/linux/cpufreq.h	2004-09-01 20:56:30.000000000 +0200
@@ -0,0 +1,247 @@
+/*
+ *  linux/include/linux/cpufreq.h
+ *
+ *  Copyright (C) 2001 Russell King
+ *            (C) 2002 Dominik Brodowski <linux@brodo.de>
+ *            
+ *
+ * $Id: cpufreq.h,v 1.29 2002/11/11 15:35:47 db Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _LINUX_CPUFREQ_H
+#define _LINUX_CPUFREQ_H
+
+#include <linux/config.h>
+#include <linux/notifier.h>
+#include <linux/threads.h>
+
+
+/*********************************************************************
+ *                     CPUFREQ NOTIFIER INTERFACE                    *
+ *********************************************************************/
+
+int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
+int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
+
+#define CPUFREQ_TRANSITION_NOTIFIER     (0)
+#define CPUFREQ_POLICY_NOTIFIER         (1)
+
+#define CPUFREQ_ALL_CPUS        ((NR_CPUS))
+
+
+/********************** cpufreq policy notifiers *********************/
+
+#define CPUFREQ_POLICY_POWERSAVE        (1)
+#define CPUFREQ_POLICY_PERFORMANCE      (2)
+
+/* values here are CPU kHz so that hardware which doesn't run with some
+ * frequencies can complain without having to guess what per cent / per
+ * mille means. */
+struct cpufreq_policy {
+	unsigned int            cpu;    /* cpu nr or CPUFREQ_ALL_CPUS */
+	unsigned int            min;    /* in kHz */
+	unsigned int            max;    /* in kHz */
+        unsigned int            policy; /* see above */
+	unsigned int            max_cpu_freq; /* for information */
+};
+
+#define CPUFREQ_ADJUST          (0)
+#define CPUFREQ_INCOMPATIBLE    (1)
+#define CPUFREQ_NOTIFY          (2)
+
+
+/******************** cpufreq transition notifiers *******************/
+
+#define CPUFREQ_PRECHANGE	(0)
+#define CPUFREQ_POSTCHANGE	(1)
+
+struct cpufreq_freqs {
+	unsigned int cpu;      /* cpu nr or CPUFREQ_ALL_CPUS */
+	unsigned int old;
+	unsigned int new;
+};
+
+
+/**
+ * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch safe)
+ * @old:   old value
+ * @div:   divisor
+ * @mult:  multiplier
+ *
+ * Needed for loops_per_jiffy and similar calculations.  We do it 
+ * this way to avoid math overflow on 32-bit machines.  This will
+ * become architecture dependent once high-resolution-timer is
+ * merged (or any other thing that introduces sc_math.h).
+ *
+ *    new = old * mult / div
+ */
+static inline unsigned long cpufreq_scale(unsigned long old, u_int div, u_int mult)
+{
+	unsigned long val, carry;
+
+	mult /= 100;
+	div  /= 100;
+        val   = (old / div) * mult;
+        carry = old % div;
+	carry = carry * mult / div;
+
+	return carry + val;
+};
+
+
+/*********************************************************************
+ *                      DYNAMIC CPUFREQ INTERFACE                    *
+ *********************************************************************/
+#ifdef CONFIG_CPU_FREQ_DYNAMIC
+/* TBD */
+#endif /* CONFIG_CPU_FREQ_DYNAMIC */
+
+
+/*********************************************************************
+ *                      CPUFREQ DRIVER INTERFACE                     *
+ *********************************************************************/
+
+typedef int (*cpufreq_policy_t)          (struct cpufreq_policy *policy);
+
+struct cpufreq_driver {
+	/* needed by all drivers */
+	cpufreq_policy_t        verify;
+	cpufreq_policy_t        setpolicy;
+	struct cpufreq_policy   *policy;
+#ifdef CONFIG_CPU_FREQ_DYNAMIC
+	/* TBD */
+#endif
+	/* 2.4. compatible API */
+#ifdef CONFIG_CPU_FREQ_24_API
+	unsigned int            cpu_min_freq[NR_CPUS];
+	unsigned int            cpu_cur_freq[NR_CPUS];
+#endif
+};
+
+int cpufreq_register(struct cpufreq_driver *driver_data);
+int cpufreq_unregister(void);
+
+void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
+
+
+static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max) 
+{
+	if (policy->min < min)
+		policy->min = min;
+	if (policy->max < min)
+		policy->max = min;
+	if (policy->min > max)
+		policy->min = max;
+	if (policy->max > max)
+		policy->max = max;
+	if (policy->min > policy->max)
+		policy->min = policy->max;
+	return;
+}
+
+/*********************************************************************
+ *                        CPUFREQ 2.6. INTERFACE                     *
+ *********************************************************************/
+int cpufreq_set_policy(struct cpufreq_policy *policy);
+int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
+
+#ifdef CONFIG_PM
+int cpufreq_restore(void);
+#endif
+
+
+#ifdef CONFIG_CPU_FREQ_24_API
+/*********************************************************************
+ *                        CPUFREQ 2.4. INTERFACE                     *
+ *********************************************************************/
+int cpufreq_setmax(unsigned int cpu);
+int cpufreq_set(unsigned int kHz, unsigned int cpu);
+unsigned int cpufreq_get(unsigned int cpu);
+
+/* /proc/sys/cpu */
+enum {
+	CPU_NR   = 1,           /* compatibilty reasons */
+	CPU_NR_0 = 1,
+	CPU_NR_1 = 2,
+	CPU_NR_2 = 3,
+	CPU_NR_3 = 4,
+	CPU_NR_4 = 5,
+	CPU_NR_5 = 6,
+	CPU_NR_6 = 7,
+	CPU_NR_7 = 8,
+	CPU_NR_8 = 9,
+	CPU_NR_9 = 10,
+	CPU_NR_10 = 11,
+	CPU_NR_11 = 12,
+	CPU_NR_12 = 13,
+	CPU_NR_13 = 14,
+	CPU_NR_14 = 15,
+	CPU_NR_15 = 16,
+	CPU_NR_16 = 17,
+	CPU_NR_17 = 18,
+	CPU_NR_18 = 19,
+	CPU_NR_19 = 20,
+	CPU_NR_20 = 21,
+	CPU_NR_21 = 22,
+	CPU_NR_22 = 23,
+	CPU_NR_23 = 24,
+	CPU_NR_24 = 25,
+	CPU_NR_25 = 26,
+	CPU_NR_26 = 27,
+	CPU_NR_27 = 28,
+	CPU_NR_28 = 29,
+	CPU_NR_29 = 30,
+	CPU_NR_30 = 31,
+	CPU_NR_31 = 32,
+};
+
+/* /proc/sys/cpu/{0,1,...,(NR_CPUS-1)} */
+enum {
+	CPU_NR_FREQ_MAX = 1,
+	CPU_NR_FREQ_MIN = 2,
+	CPU_NR_FREQ = 3,
+};
+
+#define CTL_CPU_VARS_SPEED_MAX(cpunr) { \
+                .ctl_name	= CPU_NR_FREQ_MAX, \
+                .data		= &cpu_max_freq[cpunr], \
+                .procname	= "speed-max", \
+                .maxlen		= sizeof(cpu_max_freq[cpunr]),\
+                .mode		= 0444, \
+                .proc_handler	= proc_dointvec, }
+
+#define CTL_CPU_VARS_SPEED_MIN(cpunr) { \
+                .ctl_name	= CPU_NR_FREQ_MIN, \
+                .data		= &cpu_min_freq[cpunr], \
+                .procname	= "speed-min", \
+                .maxlen		= sizeof(cpu_min_freq[cpunr]),\
+                .mode		= 0444, \
+                .proc_handler	= proc_dointvec, }
+
+#define CTL_CPU_VARS_SPEED(cpunr) { \
+                .ctl_name	= CPU_NR_FREQ, \
+                .procname	= "speed", \
+                .mode		= 0644, \
+                .proc_handler	= cpufreq_procctl, \
+                .strategy	= cpufreq_sysctl, \
+                .extra1		= (void*) (cpunr), }
+
+#define CTL_TABLE_CPU_VARS(cpunr) static ctl_table ctl_cpu_vars_##cpunr[] = {\
+                CTL_CPU_VARS_SPEED_MAX(cpunr), \
+                CTL_CPU_VARS_SPEED_MIN(cpunr), \
+                CTL_CPU_VARS_SPEED(cpunr),  \
+                { .ctl_name = 0, }, }
+
+/* the ctl_table entry for each CPU */
+#define CPU_ENUM(s) { \
+                .ctl_name	= (CPU_NR + s), \
+                .procname	= #s, \
+                .mode		= 0555, \
+                .child		= ctl_cpu_vars_##s }
+
+#endif /* CONFIG_CPU_FREQ_24_API */
+
+#endif /* _LINUX_CPUFREQ_H */
diff -urN kernel-source-2.4.27/include/linux/ioport.h kernel-source-2.4.27-benh/include/linux/ioport.h
--- kernel-source-2.4.27/include/linux/ioport.h	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/include/linux/ioport.h	2004-09-01 20:56:30.000000000 +0200
@@ -85,6 +85,7 @@
 
 extern int check_resource(struct resource *root, unsigned long, unsigned long);
 extern int request_resource(struct resource *root, struct resource *new);
+extern struct resource * ____request_resource(struct resource *root, struct resource *new);
 extern int release_resource(struct resource *new);
 extern int allocate_resource(struct resource *root, struct resource *new,
 			     unsigned long size,
diff -urN kernel-source-2.4.27/include/linux/mm.h kernel-source-2.4.27-benh/include/linux/mm.h
--- kernel-source-2.4.27/include/linux/mm.h	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/include/linux/mm.h	2004-09-01 20:56:30.000000000 +0200
@@ -637,11 +637,25 @@
 	return gfp_mask;
 }
 	
-/* vma is the first one with  address < vma->vm_end,
- * and even  address < vma->vm_start. Have to extend vma. */
-static inline int expand_stack(struct vm_area_struct * vma, unsigned long address)
+extern int heap_stack_gap;
+
+/*
+ * vma is the first one with  address < vma->vm_end,
+ * and even  address < vma->vm_start. Have to extend vma.
+ *
+ * Locking: vm_start can decrease under you if you only hold
+ * the read semaphore, you either need the write semaphore
+ * or both the read semaphore and the page_table_lock acquired
+ * if you want vm_start consistent. vm_end and the vma layout
+ * are just consistent with only the read semaphore acquired
+ * instead.
+ */
+#define EXPAND_STACK_HAS_3_ARGS
+static inline int expand_stack(struct vm_area_struct * vma, unsigned long address,
+			       struct vm_area_struct * prev_vma)
 {
 	unsigned long grow;
+	int err = -ENOMEM;
 
 	/*
 	 * vma->vm_start/vm_end cannot change under us because the caller is required
@@ -649,20 +663,23 @@
 	 * before relocating the vma range ourself.
 	 */
 	address &= PAGE_MASK;
+	if (prev_vma && prev_vma->vm_end + (heap_stack_gap << PAGE_SHIFT) > address)
+		goto out;
  	spin_lock(&vma->vm_mm->page_table_lock);
 	grow = (vma->vm_start - address) >> PAGE_SHIFT;
 	if (vma->vm_end - address > current->rlim[RLIMIT_STACK].rlim_cur ||
-	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur) {
-		spin_unlock(&vma->vm_mm->page_table_lock);
-		return -ENOMEM;
-	}
+	    ((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur)
+		goto out_unlock;
 	vma->vm_start = address;
 	vma->vm_pgoff -= grow;
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
 		vma->vm_mm->locked_vm += grow;
+	err = 0;
+ out_unlock:
 	spin_unlock(&vma->vm_mm->page_table_lock);
-	return 0;
+ out:
+	return err;
 }
 
 /* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
diff -urN kernel-source-2.4.27/include/linux/pci_ids.h kernel-source-2.4.27-benh/include/linux/pci_ids.h
--- kernel-source-2.4.27/include/linux/pci_ids.h	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/include/linux/pci_ids.h	2004-09-01 20:56:30.000000000 +0200
@@ -299,11 +299,21 @@
 /* Radeon R300 (9500) */
 #define PCI_DEVICE_ID_ATI_RADEON_AD	0x4144
 /* Radeon R350 (9800) */
+#define PCI_DEVICE_ID_ATI_RADEON_AH	0x4148
+#define PCI_DEVICE_ID_ATI_RADEON_AI	0x4149
+#define PCI_DEVICE_ID_ATI_RADEON_AJ	0x414a
+#define PCI_DEVICE_ID_ATI_RADEON_AK	0x414b
 #define PCI_DEVICE_ID_ATI_RADEON_NH	0x4e48
 #define PCI_DEVICE_ID_ATI_RADEON_NI	0x4e49
+#define PCI_DEVICE_ID_ATI_RADEON_NJ	0x4e4a
+#define PCI_DEVICE_ID_ATI_RADEON_NK	0x4e4b
 /* Radeon RV350 (9600) */
 #define PCI_DEVICE_ID_ATI_RADEON_AP	0x4150
+#define PCI_DEVICE_ID_ATI_RADEON_AQ	0x4151
 #define PCI_DEVICE_ID_ATI_RADEON_AR	0x4152
+#define PCI_DEVICE_ID_ATI_RADEON_AS	0x4153
+#define PCI_DEVICE_ID_ATI_RADEON_AT	0x4154
+#define PCI_DEVICE_ID_ATI_RADEON_AV	0x4156
 /* Radeon M6 */
 #define PCI_DEVICE_ID_ATI_RADEON_LY	0x4c59
 #define PCI_DEVICE_ID_ATI_RADEON_LZ	0x4c5a
@@ -315,6 +325,16 @@
 #define PCI_DEVICE_ID_ATI_RADEON_Le	0x4c65
 #define PCI_DEVICE_ID_ATI_RADEON_Lf	0x4c66
 #define PCI_DEVICE_ID_ATI_RADEON_Lg	0x4c67
+/* Radeon M9+ */
+#define PCI_DEVICE_ID_ATI_RADEON__c	0x5c63
+/* Radeon M10/M11 */
+#define PCI_DEVICE_ID_ATI_RADEON_NP	0x4e50
+#define PCI_DEVICE_ID_ATI_RADEON_NQ	0x4e51
+#define PCI_DEVICE_ID_ATI_RADEON_NR	0x4e52
+#define PCI_DEVICE_ID_ATI_RADEON_NS	0x4e53
+#define PCI_DEVICE_ID_ATI_RADEON_NT	0x4e54
+#define PCI_DEVICE_ID_ATI_RADEON_NV	0x4e56
+
 /* RadeonIGP */
 #define PCI_DEVICE_ID_ATI_RADEON_IGP	0xCAB0
 /* ATI IXP Chipset */
@@ -407,6 +427,7 @@
 #define PCI_DEVICE_ID_IBM_MPIC		0x0046
 #define PCI_DEVICE_ID_IBM_3780IDSP	0x007d
 #define PCI_DEVICE_ID_IBM_CHUKAR	0x0096
+#define PCI_DEVICE_ID_IBM_CPC700	0x00f9
 #define PCI_DEVICE_ID_IBM_CPC710_PCI64	0x00fc
 #define PCI_DEVICE_ID_IBM_CPC710_PCI32	0x0105
 #define	PCI_DEVICE_ID_IBM_405GP		0x0156
@@ -759,6 +780,10 @@
 #define PCI_DEVICE_ID_APPLE_UNI_N_AGP_P	0x0027
 #define PCI_DEVICE_ID_APPLE_UNI_N_AGP15	0x002d
 #define PCI_DEVICE_ID_APPLE_UNI_N_FW2	0x0030
+#define PCI_DEVICE_ID_APPLE_UNI_N_GMAC2	0x0032
+#define PCI_DEVICE_ID_APPLE_UNI_N_AGP2	0x0034
+#define PCI_DEVICE_ID_APPLE_KEYLARGO_I	0x003e
+#define PCI_DEVICE_ID_APPLE_K2_GMAC	0x004c
 #define PCI_DEVICE_ID_APPLE_TIGON3	0x1645
 
 #define PCI_VENDOR_ID_YAMAHA		0x1073
@@ -1010,6 +1035,17 @@
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE2_GTS2	0x0151
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE2_ULTRA	0x0152
 #define PCI_DEVICE_ID_NVIDIA_QUADRO2_PRO	0x0153
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_460 		0x0170
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_440 		0x0171
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_MX_420 		0x0172
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO		0x0174
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO		0x0175
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_420_GO_M32	0x0176
+#define PCI_DEVICE_ID_NVIDIA_QUADRO4_500XGL		0x0178
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_440_GO_M64	0x0179
+#define PCI_DEVICE_ID_NVIDIA_QUADRO4_200		0x017A
+#define PCI_DEVICE_ID_NVIDIA_QUADRO4_550XGL		0x017B
+#define PCI_DEVICE_ID_NVIDIA_QUADRO4_500_GOGL		0x017C
 #define PCI_DEVICE_ID_NVIDIA_IGEFORCE2		0x01a0
 #define PCI_DEVICE_ID_NVIDIA_NFORCE		0x01a4
 #define PCI_DEVICE_ID_NVIDIA_MCP1_AUDIO		0x01b1
@@ -1019,6 +1055,12 @@
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE3_1		0x0201
 #define PCI_DEVICE_ID_NVIDIA_GEFORCE3_2		0x0202
 #define PCI_DEVICE_ID_NVIDIA_QUADRO_DDC		0x0203
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4600		0x0250
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4400		0x0251
+#define PCI_DEVICE_ID_NVIDIA_GEFORCE4_TI_4200		0x0253
+#define PCI_DEVICE_ID_NVIDIA_QUADRO4_900XGL		0x0258
+#define PCI_DEVICE_ID_NVIDIA_QUADRO4_750XGL		0x0259
+#define PCI_DEVICE_ID_NVIDIA_QUADRO4_700XGL		0x025B
 
 #define PCI_VENDOR_ID_IMS		0x10e0
 #define PCI_DEVICE_ID_IMS_8849		0x8849
diff -urN kernel-source-2.4.27/include/linux/pmu.h kernel-source-2.4.27-benh/include/linux/pmu.h
--- kernel-source-2.4.27/include/linux/pmu.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-benh/include/linux/pmu.h	2004-09-01 20:56:30.000000000 +0200
@@ -69,6 +69,8 @@
 /* Bits in the environement message (either obtained via PMU_GET_COVER,
  * or via PMU_INT_ENVIRONMENT on core99 */
 #define PMU_ENV_LID_CLOSED	0x01	/* The lid is closed */
+#define PMU_ENV_AC_POWER	0x04	/* AC power is present */
+#define PMU_ENV_BATTERY_PRESENT	0x10	/* Any battery present */
 
 /* I2C related definitions */
 #define PMU_I2C_MODE_SIMPLE	0
@@ -143,6 +145,8 @@
 		void (*done)(struct adb_request *), int nbytes, ...);
 
 extern void pmu_poll(void);
+extern void pmu_poll_adb(void); /* For use by xmon */
+extern void pmu_wait_complete(struct adb_request *req);
 
 /* For use before switching interrupts off for a long time;
  * warning: not stackable
@@ -154,6 +158,7 @@
 
 extern void pmu_restart(void);
 extern void pmu_shutdown(void);
+extern void pmu_unlock(void);
 
 extern int pmu_present(void);
 extern int pmu_get_model(void);
diff -urN kernel-source-2.4.27/include/linux/sysctl.h kernel-source-2.4.27-benh/include/linux/sysctl.h
--- kernel-source-2.4.27/include/linux/sysctl.h	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/include/linux/sysctl.h	2004-09-01 20:56:31.000000000 +0200
@@ -157,6 +157,7 @@
 	VM_MAPPED_RATIO=20,     /* amount of unfreeable pages that triggers swapout */
 	VM_LAPTOP_MODE=21,	/* kernel in laptop flush mode */
 	VM_BLOCK_DUMP=22,	/* dump fs activity to log */
+	VM_HEAP_STACK_GAP=23,	/* silent-stack-overflow */
 };
 
 
diff -urN kernel-source-2.4.27/include/linux/wait.h kernel-source-2.4.27-benh/include/linux/wait.h
--- kernel-source-2.4.27/include/linux/wait.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-benh/include/linux/wait.h	2004-09-01 20:56:31.000000000 +0200
@@ -90,11 +90,17 @@
  * spurious .aligns.
  */
 #if WAITQUEUE_DEBUG
+#ifdef CONFIG_XMON
+extern void xmon_printf(const char* fmt, ...);
+#define wqbug_printf	xmon_printf
+#else
+#define wqbug_printf	printk
+#endif
 #define WQ_BUG()	BUG()
 #define CHECK_MAGIC(x)							\
 	do {									\
 		if ((x) != (long)&(x)) {					\
-			printk("bad magic %lx (should be %lx), ",		\
+			wqbug_printf("bad magic %lx (should be %lx), ",		\
 				(long)x, (long)&(x));				\
 			WQ_BUG();						\
 		}								\
@@ -102,7 +108,7 @@
 #define CHECK_MAGIC_WQHEAD(x)							\
 	do {									\
 		if ((x)->__magic != (long)&((x)->__magic)) {			\
-			printk("bad magic %lx (should be %lx, creator %lx), ",	\
+			wqbug_printf("bad magic %lx (should be %lx, creator %lx), ",	\
 			(x)->__magic, (long)&((x)->__magic), (x)->__creator);	\
 			WQ_BUG();						\
 		}								\
diff -urN kernel-source-2.4.27/init/main.c kernel-source-2.4.27-benh/init/main.c
--- kernel-source-2.4.27/init/main.c	2004-08-24 07:53:15.000000000 +0200
+++ kernel-source-2.4.27-benh/init/main.c	2004-09-01 20:56:31.211374208 +0200
@@ -162,7 +162,7 @@
    better than 1% */
 #define LPS_PREC 8
 
-void __init calibrate_delay(void)
+void /*__init*/ calibrate_delay(void)
 {
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
diff -urN kernel-source-2.4.27/kernel/cpufreq.c kernel-source-2.4.27-benh/kernel/cpufreq.c
--- kernel-source-2.4.27/kernel/cpufreq.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/kernel/cpufreq.c	2004-09-01 20:56:31.291362048 +0200
@@ -0,0 +1,1130 @@
+/*
+ *  linux/kernel/cpufreq.c
+ *
+ *  Copyright (C) 2001 Russell King
+ *            (C) 2002 Dominik Brodowski <linux@brodo.de>
+ *
+ *  $Id: cpufreq.c,v 1.50 2002/11/11 15:35:48 db Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/notifier.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <asm/system.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/ctype.h>
+#include <linux/proc_fs.h>
+
+#include <asm/uaccess.h>
+
+#ifdef CONFIG_CPU_FREQ_24_API
+#include <linux/sysctl.h>
+#endif
+
+
+/**
+ * The "cpufreq driver" - the arch- or hardware-dependend low
+ * level driver of CPUFreq support, and its locking mutex. 
+ * cpu_max_freq is in kHz.
+ */
+static struct cpufreq_driver   	*cpufreq_driver;
+static DECLARE_MUTEX            (cpufreq_driver_sem);
+
+
+/**
+ * Two notifier lists: the "policy" list is involved in the 
+ * validation process for a new CPU frequency policy; the 
+ * "transition" list for kernel code that needs to handle
+ * changes to devices when the CPU clock speed changes.
+ * The mutex locks both lists. If both cpufreq_driver_sem
+ * and cpufreq_notifier_sem need to be hold, get cpufreq_driver_sem
+ * first.
+ */
+static struct notifier_block    *cpufreq_policy_notifier_list;
+static struct notifier_block    *cpufreq_transition_notifier_list;
+static DECLARE_MUTEX            (cpufreq_notifier_sem);
+
+
+/**
+ * The cpufreq default policy. Can be set by a "cpufreq=..." command
+ * line option.
+ */
+static struct cpufreq_policy default_policy = {
+	.cpu    = CPUFREQ_ALL_CPUS,
+	.min    = 0,
+	.max    = 0,
+	.policy = 0,
+};
+
+
+#ifdef CONFIG_CPU_FREQ_24_API
+/**
+ * A few values needed by the 2.4.-compatible API
+ */
+static unsigned int     cpu_max_freq[NR_CPUS];
+static unsigned int     cpu_min_freq[NR_CPUS];
+static unsigned int     cpu_cur_freq[NR_CPUS];
+#endif
+
+
+
+/*********************************************************************
+ *                              2.6. API                             *
+ *********************************************************************/
+
+/**
+ * cpufreq_parse_policy - parse a policy string
+ * @input_string: the string to parse.
+ * @policy: the policy written inside input_string
+ *
+ * This function parses a "policy string" - something the user echo'es into
+ * /proc/cpufreq or gives as boot parameter - into a struct cpufreq_policy.
+ * If there are invalid/missing entries, they are replaced with current
+ * cpufreq policy.
+ */
+static int cpufreq_parse_policy(char input_string[42], struct cpufreq_policy *policy)
+{
+	unsigned int            min = 0;
+	unsigned int            max = 0;
+	unsigned int            cpu = 0;
+	char			policy_string[42] = {'\0'};
+	struct cpufreq_policy   current_policy;
+	unsigned int            result = -EFAULT;
+	unsigned int            i = 0;
+
+	if (!policy)
+		return -EINVAL;
+
+	policy->min = 0;
+	policy->max = 0;
+	policy->policy = 0;
+	policy->cpu = CPUFREQ_ALL_CPUS;
+
+	if (sscanf(input_string, "%d:%d:%d:%s", &cpu, &min, &max, policy_string) == 4) 
+	{
+		policy->min = min;
+		policy->max = max;
+		policy->cpu = cpu;
+		result = 0;
+		goto scan_policy;
+	}
+	if (sscanf(input_string, "%d%%%d%%%d%%%s", &cpu, &min, &max, policy_string) == 4)
+	{
+		if (!cpufreq_get_policy(&current_policy, cpu)) {
+			policy->min = (min * current_policy.max_cpu_freq) / 100;
+			policy->max = (max * current_policy.max_cpu_freq) / 100;
+			policy->cpu = cpu;
+			result = 0;
+			goto scan_policy;
+		}
+	}
+
+	if (sscanf(input_string, "%d:%d:%s", &min, &max, policy_string) == 3) 
+	{
+		policy->min = min;
+		policy->max = max;
+		result = 0;
+		goto scan_policy;
+	}
+
+	if (sscanf(input_string, "%d%%%d%%%s", &min, &max, policy_string) == 3)
+	{
+		if (!cpufreq_get_policy(&current_policy, cpu)) {
+			policy->min = (min * current_policy.max_cpu_freq) / 100;
+			policy->max = (max * current_policy.max_cpu_freq) / 100;
+			result = 0;
+			goto scan_policy;
+		}
+	}
+
+	return -EINVAL;
+
+scan_policy:
+
+	for (i=0;i<sizeof(policy_string);i++){
+		if (policy_string[i]=='\0')
+			break;
+		policy_string[i] = tolower(policy_string[i]);
+	}
+
+	if (!strncmp(policy_string, "powersave", 6) ||  
+            !strncmp(policy_string, "eco", 3) ||       
+	    !strncmp(policy_string, "batter", 6) ||
+	    !strncmp(policy_string, "low", 3)) 
+	{
+		result = 0;
+		policy->policy = CPUFREQ_POLICY_POWERSAVE;
+	}
+	else if (!strncmp(policy_string, "performance",6) ||
+	    !strncmp(policy_string, "high",4) ||
+	    !strncmp(policy_string, "full",4))
+	{
+		result = 0;
+		policy->policy = CPUFREQ_POLICY_PERFORMANCE;
+	}
+	else if (!cpufreq_get_policy(&current_policy, policy->cpu))
+	{
+		policy->policy = current_policy.policy;
+	}
+	else
+	{
+		policy->policy = 0;
+	}
+
+	return result;
+}
+
+
+/*
+ * cpufreq command line parameter.  Must be hard values (kHz)
+ *  cpufreq=1000000:2000000:PERFORMANCE   
+ * to set the default CPUFreq policy.
+ */
+static int __init cpufreq_setup(char *str)
+{
+	cpufreq_parse_policy(str, &default_policy);
+	default_policy.cpu = CPUFREQ_ALL_CPUS;
+	return 1;
+}
+__setup("cpufreq=", cpufreq_setup);
+
+
+#ifdef CONFIG_PROC_FS
+
+/**
+ * cpufreq_proc_read - read /proc/cpufreq
+ *
+ * This function prints out the current cpufreq policy.
+ */
+static int cpufreq_proc_read (
+	char			*page,
+	char			**start,
+	off_t			off,
+	int 			count,
+	int 			*eof,
+	void			*data)
+{
+	char			*p = page;
+	int			len = 0;
+	struct cpufreq_policy   policy;
+	unsigned int            min_pctg = 0;
+	unsigned int            max_pctg = 0;
+	unsigned int            i = 0;
+
+	if (off != 0)
+		goto end;
+
+	p += sprintf(p, "          minimum CPU frequency  -  maximum CPU frequency  -  policy\n");
+	for (i=0;i<NR_CPUS;i++) {
+		if (!cpu_online(i))
+			continue;
+
+		cpufreq_get_policy(&policy, i);
+
+		if (!policy.max_cpu_freq)
+			continue;
+
+		min_pctg = (policy.min * 100) / policy.max_cpu_freq;
+		max_pctg = (policy.max * 100) / policy.max_cpu_freq;
+
+		p += sprintf(p, "CPU%3d    %9d kHz (%3d %%)  -  %9d kHz (%3d %%)  -  ",
+			     i , policy.min, min_pctg, policy.max, max_pctg);
+		switch (policy.policy) {
+		case CPUFREQ_POLICY_POWERSAVE:
+			p += sprintf(p, "powersave\n");
+			break;
+		case CPUFREQ_POLICY_PERFORMANCE:
+			p += sprintf(p, "performance\n");
+			break;
+		default:
+			p += sprintf(p, "INVALID\n");
+			break;
+		}
+	}
+end:
+	len = (p - page);
+	if (len <= off+count) 
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) 
+		len = count;
+	if (len<0) 
+		len = 0;
+
+	return len;
+}
+
+
+/**
+ * cpufreq_proc_write - handles writing into /proc/cpufreq
+ *
+ * This function calls the parsing script and then sets the policy
+ * accordingly.
+ */
+static int cpufreq_proc_write (
+        struct file		*file,
+        const char		*buffer,
+        unsigned long		count,
+        void			*data)
+{
+	int                     result = 0;
+	char			proc_string[42] = {'\0'};
+	struct cpufreq_policy   policy;
+
+
+	if ((count > sizeof(proc_string) - 1))
+		return -EINVAL;
+	
+	if (copy_from_user(proc_string, buffer, count))
+		return -EFAULT;
+	
+	proc_string[count] = '\0';
+
+	result = cpufreq_parse_policy(proc_string, &policy);
+	if (result)
+		return -EFAULT;
+
+	cpufreq_set_policy(&policy);
+
+	return count;
+}
+
+
+/**
+ * cpufreq_proc_init - add "cpufreq" to the /proc root directory
+ *
+ * This function adds "cpufreq" to the /proc root directory.
+ */
+static unsigned int cpufreq_proc_init (void)
+{
+	struct proc_dir_entry *entry = NULL;
+
+        /* are these acceptable values? */
+	entry = create_proc_entry("cpufreq", S_IFREG|S_IRUGO|S_IWUSR, 
+				  &proc_root);
+
+	if (!entry) {
+		printk(KERN_ERR "unable to create /proc/cpufreq entry\n");
+		return -EIO;
+	} else {
+		entry->read_proc = cpufreq_proc_read;
+		entry->write_proc = cpufreq_proc_write;
+	}
+
+	return 0;
+}
+
+
+/**
+ * cpufreq_proc_exit - removes "cpufreq" from the /proc root directory.
+ *
+ * This function removes "cpufreq" from the /proc root directory.
+ */
+static void cpufreq_proc_exit (void)
+{
+	remove_proc_entry("cpufreq", &proc_root);
+	return;
+}
+#endif /* CONFIG_PROC_FS */
+
+
+
+/*********************************************************************
+ *                        2.4. COMPATIBLE API                        *
+ *********************************************************************/
+
+#ifdef CONFIG_CPU_FREQ_24_API
+/** 
+ * cpufreq_set - set the CPU frequency
+ * @freq: target frequency in kHz
+ * @cpu: CPU for which the frequency is to be set
+ *
+ * Sets the CPU frequency to freq.
+ */
+int cpufreq_set(unsigned int freq, unsigned int cpu)
+{
+	struct cpufreq_policy policy;
+	down(&cpufreq_driver_sem);
+	if (!cpufreq_driver || !cpu_max_freq) {
+		up(&cpufreq_driver_sem);
+		return -EINVAL;
+	}
+
+	policy.min = freq;
+	policy.max = freq;
+	policy.policy = CPUFREQ_POLICY_POWERSAVE;
+	policy.cpu = cpu;
+	
+	up(&cpufreq_driver_sem);
+
+	return cpufreq_set_policy(&policy);
+}
+EXPORT_SYMBOL_GPL(cpufreq_set);
+
+
+/** 
+ * cpufreq_setmax - set the CPU to the maximum frequency
+ * @cpu - affected cpu;
+ *
+ * Sets the CPU frequency to the maximum frequency supported by
+ * this CPU.
+ */
+int cpufreq_setmax(unsigned int cpu)
+{
+	if (!cpu_online(cpu) && (cpu != CPUFREQ_ALL_CPUS))
+		return -EINVAL;
+	return cpufreq_set(cpu_max_freq[cpu], cpu);
+}
+EXPORT_SYMBOL_GPL(cpufreq_setmax);
+
+
+/** 
+ * cpufreq_get - get the current CPU frequency (in kHz)
+ * @cpu: CPU number - currently without effect.
+ *
+ * Get the CPU current (static) CPU frequency
+ */
+unsigned int cpufreq_get(unsigned int cpu)
+{
+	if (!cpu_online(cpu))
+		return -EINVAL;
+	return cpu_cur_freq[cpu];
+}
+EXPORT_SYMBOL(cpufreq_get);
+
+
+#ifdef CONFIG_SYSCTL
+
+
+/*********************** cpufreq_sysctl interface ********************/
+static int
+cpufreq_procctl(ctl_table *ctl, int write, struct file *filp,
+		void *buffer, size_t *lenp)
+{
+	char buf[16], *p;
+	int cpu = (int) ctl->extra1;
+	int len, left = *lenp;
+
+	if (!left || (filp->f_pos && !write) || !cpu_online(cpu)) {
+		*lenp = 0;
+		return 0;
+	}
+
+	if (write) {
+		unsigned int freq;
+
+		len = left;
+		if (left > sizeof(buf))
+			left = sizeof(buf);
+		if (copy_from_user(buf, buffer, left))
+			return -EFAULT;
+		buf[sizeof(buf) - 1] = '\0';
+
+		freq = simple_strtoul(buf, &p, 0);
+		cpufreq_set(freq, cpu);
+	} else {
+		len = sprintf(buf, "%d\n", cpufreq_get(cpu));
+		if (len > left)
+			len = left;
+		if (copy_to_user(buffer, buf, len))
+			return -EFAULT;
+	}
+
+	*lenp = len;
+	filp->f_pos += len;
+	return 0;
+}
+
+static int
+cpufreq_sysctl(ctl_table *table, int *name, int nlen,
+	       void *oldval, size_t *oldlenp,
+	       void *newval, size_t newlen, void **context)
+{
+	int cpu = (int) table->extra1;
+
+	if (!cpu_online(cpu))
+		return -EINVAL;
+
+	if (oldval && oldlenp) {
+		size_t oldlen;
+
+		if (get_user(oldlen, oldlenp))
+			return -EFAULT;
+
+		if (oldlen != sizeof(unsigned int))
+			return -EINVAL;
+
+		if (put_user(cpufreq_get(cpu), (unsigned int *)oldval) ||
+		    put_user(sizeof(unsigned int), oldlenp))
+			return -EFAULT;
+	}
+	if (newval && newlen) {
+		unsigned int freq;
+
+		if (newlen != sizeof(unsigned int))
+			return -EINVAL;
+
+		if (get_user(freq, (unsigned int *)newval))
+			return -EFAULT;
+
+		cpufreq_set(freq, cpu);
+	}
+	return 1;
+}
+
+/* ctl_table ctl_cpu_vars_{0,1,...,(NR_CPUS-1)} */
+/* due to NR_CPUS tweaking, a lot of if/endifs are required, sorry */
+        CTL_TABLE_CPU_VARS(0);
+#if NR_CPUS > 1
+	CTL_TABLE_CPU_VARS(1);
+#endif
+#if NR_CPUS > 2
+	CTL_TABLE_CPU_VARS(2);
+#endif
+#if NR_CPUS > 3
+	CTL_TABLE_CPU_VARS(3);
+#endif
+#if NR_CPUS > 4
+	CTL_TABLE_CPU_VARS(4);
+#endif
+#if NR_CPUS > 5
+	CTL_TABLE_CPU_VARS(5);
+#endif
+#if NR_CPUS > 6
+	CTL_TABLE_CPU_VARS(6);
+#endif
+#if NR_CPUS > 7
+	CTL_TABLE_CPU_VARS(7);
+#endif
+#if NR_CPUS > 8
+	CTL_TABLE_CPU_VARS(8);
+#endif
+#if NR_CPUS > 9
+	CTL_TABLE_CPU_VARS(9);
+#endif
+#if NR_CPUS > 10
+	CTL_TABLE_CPU_VARS(10);
+#endif
+#if NR_CPUS > 11
+	CTL_TABLE_CPU_VARS(11);
+#endif
+#if NR_CPUS > 12
+	CTL_TABLE_CPU_VARS(12);
+#endif
+#if NR_CPUS > 13
+	CTL_TABLE_CPU_VARS(13);
+#endif
+#if NR_CPUS > 14
+	CTL_TABLE_CPU_VARS(14);
+#endif
+#if NR_CPUS > 15
+	CTL_TABLE_CPU_VARS(15);
+#endif
+#if NR_CPUS > 16
+	CTL_TABLE_CPU_VARS(16);
+#endif
+#if NR_CPUS > 17
+	CTL_TABLE_CPU_VARS(17);
+#endif
+#if NR_CPUS > 18
+	CTL_TABLE_CPU_VARS(18);
+#endif
+#if NR_CPUS > 19
+	CTL_TABLE_CPU_VARS(19);
+#endif
+#if NR_CPUS > 20
+	CTL_TABLE_CPU_VARS(20);
+#endif
+#if NR_CPUS > 21
+	CTL_TABLE_CPU_VARS(21);
+#endif
+#if NR_CPUS > 22
+	CTL_TABLE_CPU_VARS(22);
+#endif
+#if NR_CPUS > 23
+	CTL_TABLE_CPU_VARS(23);
+#endif
+#if NR_CPUS > 24
+	CTL_TABLE_CPU_VARS(24);
+#endif
+#if NR_CPUS > 25
+	CTL_TABLE_CPU_VARS(25);
+#endif
+#if NR_CPUS > 26
+	CTL_TABLE_CPU_VARS(26);
+#endif
+#if NR_CPUS > 27
+	CTL_TABLE_CPU_VARS(27);
+#endif
+#if NR_CPUS > 28
+	CTL_TABLE_CPU_VARS(28);
+#endif
+#if NR_CPUS > 29
+	CTL_TABLE_CPU_VARS(29);
+#endif
+#if NR_CPUS > 30
+	CTL_TABLE_CPU_VARS(30);
+#endif
+#if NR_CPUS > 31
+	CTL_TABLE_CPU_VARS(31);
+#endif
+#if NR_CPUS > 32
+#error please extend CPU enumeration
+#endif
+
+/* due to NR_CPUS tweaking, a lot of if/endifs are required, sorry */
+static ctl_table ctl_cpu_table[NR_CPUS + 1] = {
+	CPU_ENUM(0),
+#if NR_CPUS > 1
+	CPU_ENUM(1),
+#endif
+#if NR_CPUS > 2
+	CPU_ENUM(2),
+#endif
+#if NR_CPUS > 3
+	CPU_ENUM(3),
+#endif
+#if NR_CPUS > 4
+	CPU_ENUM(4),
+#endif
+#if NR_CPUS > 5
+	CPU_ENUM(5),
+#endif
+#if NR_CPUS > 6
+	CPU_ENUM(6),
+#endif
+#if NR_CPUS > 7
+	CPU_ENUM(7),
+#endif
+#if NR_CPUS > 8
+	CPU_ENUM(8),
+#endif
+#if NR_CPUS > 9
+	CPU_ENUM(9),
+#endif
+#if NR_CPUS > 10
+	CPU_ENUM(10),
+#endif
+#if NR_CPUS > 11
+	CPU_ENUM(11),
+#endif
+#if NR_CPUS > 12
+	CPU_ENUM(12),
+#endif
+#if NR_CPUS > 13
+	CPU_ENUM(13),
+#endif
+#if NR_CPUS > 14
+	CPU_ENUM(14),
+#endif
+#if NR_CPUS > 15
+	CPU_ENUM(15),
+#endif
+#if NR_CPUS > 16
+	CPU_ENUM(16),
+#endif
+#if NR_CPUS > 17
+	CPU_ENUM(17),
+#endif
+#if NR_CPUS > 18
+	CPU_ENUM(18),
+#endif
+#if NR_CPUS > 19
+	CPU_ENUM(19),
+#endif
+#if NR_CPUS > 20
+	CPU_ENUM(20),
+#endif
+#if NR_CPUS > 21
+	CPU_ENUM(21),
+#endif
+#if NR_CPUS > 22
+	CPU_ENUM(22),
+#endif
+#if NR_CPUS > 23
+	CPU_ENUM(23),
+#endif
+#if NR_CPUS > 24
+	CPU_ENUM(24),
+#endif
+#if NR_CPUS > 25
+	CPU_ENUM(25),
+#endif
+#if NR_CPUS > 26
+	CPU_ENUM(26),
+#endif
+#if NR_CPUS > 27
+	CPU_ENUM(27),
+#endif
+#if NR_CPUS > 28
+	CPU_ENUM(28),
+#endif
+#if NR_CPUS > 29
+	CPU_ENUM(29),
+#endif
+#if NR_CPUS > 30
+	CPU_ENUM(30),
+#endif
+#if NR_CPUS > 31
+	CPU_ENUM(31),
+#endif
+#if NR_CPUS > 32
+#error please extend CPU enumeration
+#endif
+	{
+		.ctl_name	= 0,
+	}
+};
+
+static ctl_table ctl_cpu[2] = {
+	{
+		.ctl_name	= CTL_CPU,
+		.procname	= "cpu",
+		.mode		= 0555,
+		.child		= ctl_cpu_table,
+	},
+	{
+		.ctl_name	= 0,
+	}
+};
+
+struct ctl_table_header *cpufreq_sysctl_table;
+
+static inline void cpufreq_sysctl_init(void)
+{
+	cpufreq_sysctl_table = register_sysctl_table(ctl_cpu, 0);
+}
+
+static inline void cpufreq_sysctl_exit(void)
+{
+	unregister_sysctl_table(cpufreq_sysctl_table);
+}
+
+#else
+#define cpufreq_sysctl_init()
+#define cpufreq_sysctl_exit()
+#endif /* CONFIG_SYSCTL */
+#endif /* CONFIG_CPU_FREQ_24_API */
+
+
+
+/*********************************************************************
+ *                     NOTIFIER LISTS INTERFACE                      *
+ *********************************************************************/
+
+/**
+ *	cpufreq_register_notifier - register a driver with cpufreq
+ *	@nb: notifier function to register
+ *      @list: CPUFREQ_TRANSITION_NOTIFIER or CPUFREQ_POLICY_NOTIFIER
+ *
+ *	Add a driver to one of two lists: either a list of drivers that 
+ *      are notified about clock rate changes (once before and once after
+ *      the transition), or a list of drivers that are notified about
+ *      changes in cpufreq policy.
+ *
+ *	This function may sleep, and has the same return conditions as
+ *	notifier_chain_register.
+ */
+int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)
+{
+	int ret;
+
+	down(&cpufreq_notifier_sem);
+	switch (list) {
+	case CPUFREQ_TRANSITION_NOTIFIER:
+		ret = notifier_chain_register(&cpufreq_transition_notifier_list, nb);
+		break;
+	case CPUFREQ_POLICY_NOTIFIER:
+		ret = notifier_chain_register(&cpufreq_policy_notifier_list, nb);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	up(&cpufreq_notifier_sem);
+
+	return ret;
+}
+EXPORT_SYMBOL(cpufreq_register_notifier);
+
+
+/**
+ *	cpufreq_unregister_notifier - unregister a driver with cpufreq
+ *	@nb: notifier block to be unregistered
+ *      @list: CPUFREQ_TRANSITION_NOTIFIER or CPUFREQ_POLICY_NOTIFIER
+ *
+ *	Remove a driver from the CPU frequency notifier list.
+ *
+ *	This function may sleep, and has the same return conditions as
+ *	notifier_chain_unregister.
+ */
+int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list)
+{
+	int ret;
+
+	down(&cpufreq_notifier_sem);
+	switch (list) {
+	case CPUFREQ_TRANSITION_NOTIFIER:
+		ret = notifier_chain_unregister(&cpufreq_transition_notifier_list, nb);
+		break;
+	case CPUFREQ_POLICY_NOTIFIER:
+		ret = notifier_chain_unregister(&cpufreq_policy_notifier_list, nb);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	up(&cpufreq_notifier_sem);
+
+	return ret;
+}
+EXPORT_SYMBOL(cpufreq_unregister_notifier);
+
+
+
+/*********************************************************************
+ *                          POLICY INTERFACE                         *
+ *********************************************************************/
+
+/**
+ * cpufreq_get_policy - get the current cpufreq_policy
+ * @policy: struct cpufreq_policy into which the current cpufreq_policy is written
+ *
+ * Reads the current cpufreq policy.
+ */
+int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu)
+{
+	down(&cpufreq_driver_sem);
+	if (!cpufreq_driver  || !policy || 
+	    (cpu >= NR_CPUS) || (!cpu_online(cpu))) {
+		up(&cpufreq_driver_sem);
+		return -EINVAL;
+	}
+	
+	policy->min    = cpufreq_driver->policy[cpu].min;
+	policy->max    = cpufreq_driver->policy[cpu].max;
+	policy->policy = cpufreq_driver->policy[cpu].policy;
+	policy->max_cpu_freq = cpufreq_driver->policy[cpu].max_cpu_freq;
+	policy->cpu    = cpu;
+
+	up(&cpufreq_driver_sem);
+
+	return 0;
+}
+EXPORT_SYMBOL(cpufreq_get_policy);
+
+
+/**
+ *	cpufreq_set_policy - set a new CPUFreq policy
+ *	@policy: policy to be set.
+ *
+ *	Sets a new CPU frequency and voltage scaling policy.
+ */
+int cpufreq_set_policy(struct cpufreq_policy *policy)
+{
+	unsigned int i;
+	int ret;
+
+	down(&cpufreq_driver_sem);
+	if (!cpufreq_driver || !cpufreq_driver->verify || 
+	    !cpufreq_driver->setpolicy || !policy ||
+	    (policy->cpu > NR_CPUS)) {
+		up(&cpufreq_driver_sem);
+		return -EINVAL;
+	}
+
+	if (policy->cpu == CPUFREQ_ALL_CPUS)
+		policy->max_cpu_freq = cpufreq_driver->policy[0].max_cpu_freq;
+	else
+		policy->max_cpu_freq = cpufreq_driver->policy[policy->cpu].max_cpu_freq;
+
+
+	/* verify the cpu speed can be set within this limit */
+	ret = cpufreq_driver->verify(policy);
+	if (ret) {
+		up(&cpufreq_driver_sem);
+		return ret;
+	}
+
+	down(&cpufreq_notifier_sem);
+
+	/* adjust if neccessary - all reasons */
+	notifier_call_chain(&cpufreq_policy_notifier_list, CPUFREQ_ADJUST,
+			    policy);
+
+	/* adjust if neccessary - hardware incompatibility*/
+	notifier_call_chain(&cpufreq_policy_notifier_list, CPUFREQ_INCOMPATIBLE,
+			    policy);
+
+	/* verify the cpu speed can be set within this limit,
+	   which might be different to the first one */
+	ret = cpufreq_driver->verify(policy);
+	if (ret) {
+		up(&cpufreq_notifier_sem);
+		up(&cpufreq_driver_sem);
+		return ret;
+	}
+
+	/* notification of the new policy */
+	notifier_call_chain(&cpufreq_policy_notifier_list, CPUFREQ_NOTIFY,
+			    policy);
+
+	up(&cpufreq_notifier_sem);
+
+	if (policy->cpu == CPUFREQ_ALL_CPUS) {
+		for (i=0;i<NR_CPUS;i++) {
+			cpufreq_driver->policy[i].min    = policy->min;
+			cpufreq_driver->policy[i].max    = policy->max;
+			cpufreq_driver->policy[i].policy = policy->policy;
+		} 
+	} else {
+		cpufreq_driver->policy[policy->cpu].min    = policy->min;
+		cpufreq_driver->policy[policy->cpu].max    = policy->max;
+		cpufreq_driver->policy[policy->cpu].policy = policy->policy;
+	}
+
+#ifdef CONFIG_CPU_FREQ_24_API
+	if (policy->cpu == CPUFREQ_ALL_CPUS) {
+		for (i=0;i<NR_CPUS;i++)
+			cpu_cur_freq[i] = policy->max;
+	} else
+		cpu_cur_freq[policy->cpu] = policy->max;
+#endif
+
+	ret = cpufreq_driver->setpolicy(policy);
+	
+	up(&cpufreq_driver_sem);
+
+	return ret;
+}
+EXPORT_SYMBOL(cpufreq_set_policy);
+
+
+
+/*********************************************************************
+ *                    DYNAMIC CPUFREQ SWITCHING                      *
+ *********************************************************************/
+#ifdef CONFIG_CPU_FREQ_DYNAMIC
+/* TBD */
+#endif /* CONFIG_CPU_FREQ_DYNAMIC */
+
+
+
+/*********************************************************************
+ *            EXTERNALLY AFFECTING FREQUENCY CHANGES                 *
+ *********************************************************************/
+
+/**
+ * adjust_jiffies - adjust the system "loops_per_jiffy"
+ *
+ * This function alters the system "loops_per_jiffy" for the clock
+ * speed change. Note that loops_per_jiffy is only updated if all
+ * CPUs are affected - else there is a need for per-CPU loops_per_jiffy
+ * values which are provided by various architectures. 
+ */
+static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
+{
+	if ((val == CPUFREQ_PRECHANGE  && ci->old < ci->new) ||
+	    (val == CPUFREQ_POSTCHANGE && ci->old > ci->new))
+		if (ci->cpu == CPUFREQ_ALL_CPUS)
+			loops_per_jiffy = cpufreq_scale(loops_per_jiffy, ci->old, ci->new);
+}
+
+
+/**
+ * cpufreq_notify_transition - call notifier chain and adjust_jiffies on frequency transition
+ *
+ * This function calls the transition notifiers and the "adjust_jiffies" function. It is called
+ * twice on all CPU frequency changes that have external effects. 
+ */
+void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state)
+{
+	down(&cpufreq_notifier_sem);
+	switch (state) {
+	case CPUFREQ_PRECHANGE:
+		notifier_call_chain(&cpufreq_transition_notifier_list, CPUFREQ_PRECHANGE, freqs);
+		adjust_jiffies(CPUFREQ_PRECHANGE, freqs);		
+		break;
+	case CPUFREQ_POSTCHANGE:
+		adjust_jiffies(CPUFREQ_POSTCHANGE, freqs);
+		notifier_call_chain(&cpufreq_transition_notifier_list, CPUFREQ_POSTCHANGE, freqs);
+#ifdef CONFIG_CPU_FREQ_24_API
+		if (freqs->cpu == CPUFREQ_ALL_CPUS) {
+			int i;
+			for (i=0;i<NR_CPUS;i++)
+				cpu_cur_freq[i] = freqs->new;
+		} else
+			cpu_cur_freq[freqs->cpu] = freqs->new;
+#endif
+		break;
+	}
+	up(&cpufreq_notifier_sem);
+}
+EXPORT_SYMBOL_GPL(cpufreq_notify_transition);
+
+
+
+/*********************************************************************
+ *               REGISTER / UNREGISTER CPUFREQ DRIVER                *
+ *********************************************************************/
+
+/**
+ * cpufreq_register - register a CPU Frequency driver
+ * @driver_data: A struct cpufreq_driver containing the values submitted by the CPU Frequency driver.
+ *
+ *   Registers a CPU Frequency driver to this core code. This code 
+ * returns zero on success, -EBUSY when another driver got here first
+ * (and isn't unregistered in the meantime). 
+ *
+ */
+int cpufreq_register(struct cpufreq_driver *driver_data)
+{
+	unsigned int            ret;
+	unsigned int            i;
+	struct cpufreq_policy   policy;
+
+	if (cpufreq_driver)
+		return -EBUSY;
+	
+	if (!driver_data || !driver_data->verify || 
+	    !driver_data->setpolicy)
+		return -EINVAL;
+
+	down(&cpufreq_driver_sem);
+	cpufreq_driver        = driver_data;
+	
+	/* check for a default policy - if it exists, use it on _all_ CPUs*/
+	for (i=0; i<NR_CPUS; i++)
+	{
+		if (default_policy.policy)
+			cpufreq_driver->policy[i].policy = default_policy.policy;
+		if (default_policy.min)
+			cpufreq_driver->policy[i].min = default_policy.min;
+		if (default_policy.max)
+			cpufreq_driver->policy[i].max = default_policy.max;
+	}
+
+	/* set default policy on all CPUs. Must be called per-CPU and not
+	 * with CPUFREQ_ALL_CPUs as there might be no common policy for all
+	 * CPUs (UltraSPARC etc.)
+	 */
+	for (i=0; i<NR_CPUS; i++)
+	{
+		policy.policy = cpufreq_driver->policy[i].policy;
+		policy.min    = cpufreq_driver->policy[i].min;
+		policy.max    = cpufreq_driver->policy[i].max;
+		policy.cpu    = i;
+		up(&cpufreq_driver_sem);
+		ret = cpufreq_set_policy(&policy);
+		down(&cpufreq_driver_sem);
+		if (ret) {
+			cpufreq_driver = NULL;
+			up(&cpufreq_driver_sem);
+			return ret;
+		}
+	}
+
+	up(&cpufreq_driver_sem);
+
+	cpufreq_proc_init();
+
+#ifdef CONFIG_CPU_FREQ_24_API
+ 	down(&cpufreq_driver_sem);
+	for (i=0; i<NR_CPUS; i++) 
+	{
+		cpu_min_freq[i] = driver_data->cpu_min_freq[i];
+		cpu_max_freq[i] = driver_data->policy[i].max_cpu_freq;
+		cpu_cur_freq[i] = driver_data->cpu_cur_freq[i];
+	}
+	up(&cpufreq_driver_sem);
+
+	cpufreq_sysctl_init();
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cpufreq_register);
+
+
+/**
+ * cpufreq_unregister - unregister the current CPUFreq driver
+ *
+ *    Unregister the current CPUFreq driver. Only call this if you have 
+ * the right to do so, i.e. if you have succeeded in initialising before!
+ * Returns zero if successful, and -EINVAL if the cpufreq_driver is
+ * currently not initialised.
+ */
+int cpufreq_unregister(void)
+{
+	down(&cpufreq_driver_sem);
+
+	if (!cpufreq_driver) {
+		up(&cpufreq_driver_sem);
+		return -EINVAL;
+	}
+
+	cpufreq_driver = NULL;
+
+	up(&cpufreq_driver_sem);
+
+	cpufreq_proc_exit();
+
+#ifdef CONFIG_CPU_FREQ_24_API
+	cpufreq_sysctl_exit();
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(cpufreq_unregister);
+
+
+#ifdef CONFIG_PM
+/**
+ *	cpufreq_restore - restore the CPU clock frequency after resume
+ *
+ *	Restore the CPU clock frequency so that our idea of the current
+ *	frequency reflects the actual hardware.
+ */
+int cpufreq_restore(void)
+{
+	struct cpufreq_policy policy;
+	unsigned int i;
+	unsigned int ret = 0;
+
+	if (in_interrupt())
+		panic("cpufreq_restore() called from interrupt context!");
+
+	for (i=0;i<NR_CPUS;i++) {
+		if (!cpu_online(i))
+			continue;
+
+		down(&cpufreq_driver_sem);
+		if (!cpufreq_driver) {
+			up(&cpufreq_driver_sem);
+			return 0;
+		}
+	
+		policy.min    = cpufreq_driver->policy[i].min;
+		policy.max    = cpufreq_driver->policy[i].max;
+		policy.policy = cpufreq_driver->policy[i].policy;
+		policy.cpu    = i;
+		up(&cpufreq_driver_sem);
+
+		ret += cpufreq_set_policy(&policy);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cpufreq_restore);
+#else
+#define cpufreq_restore()
+#endif /* CONFIG_PM */
+
diff -urN kernel-source-2.4.27/kernel/Makefile kernel-source-2.4.27-benh/kernel/Makefile
--- kernel-source-2.4.27/kernel/Makefile	2004-08-24 07:53:15.000000000 +0200
+++ kernel-source-2.4.27-benh/kernel/Makefile	2004-09-01 20:56:31.292361896 +0200
@@ -9,7 +9,7 @@
 
 O_TARGET := kernel.o
 
-export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o printk.o fork.o
+export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o printk.o fork.o cpufreq.o
 
 obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o \
 	    module.o exit.o itimer.o info.o time.o softirq.o resource.o \
@@ -19,6 +19,7 @@
 obj-$(CONFIG_UID16) += uid16.o
 obj-$(CONFIG_MODULES) += ksyms.o
 obj-$(CONFIG_PM) += pm.o
+obj-$(CONFIG_CPU_FREQ) += cpufreq.o
 
 ifneq ($(CONFIG_IA64),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff -urN kernel-source-2.4.27/kernel/panic.c kernel-source-2.4.27-benh/kernel/panic.c
--- kernel-source-2.4.27/kernel/panic.c	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-benh/kernel/panic.c	2004-09-01 20:56:31.293361744 +0200
@@ -51,6 +51,10 @@
 #if defined(CONFIG_ARCH_S390)
         unsigned long caller = (unsigned long) __builtin_return_address(0);
 #endif
+#ifdef CONFIG_BOOTX_TEXT
+	extern int force_printk_to_btext;
+	force_printk_to_btext = 1;
+#endif
 
 #ifdef CONFIG_VT
 	disable_console_blank();
diff -urN kernel-source-2.4.27/kernel/printk.c kernel-source-2.4.27-benh/kernel/printk.c
--- kernel-source-2.4.27/kernel/printk.c	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/kernel/printk.c	2004-09-01 20:56:31.367350496 +0200
@@ -26,7 +26,10 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>			/* For in_interrupt() */
 #include <linux/config.h>
-
+#include <linux/delay.h>
+#ifdef CONFIG_BOOTX_TEXT
+#include <asm/btext.h>
+#endif
 #include <asm/uaccess.h>
 
 #if !defined(CONFIG_LOG_BUF_SHIFT) || (CONFIG_LOG_BUF_SHIFT == 0)
@@ -66,6 +69,7 @@
 };
 
 int oops_in_progress;
+int __slow_boot;
 
 /*
  * console_sem protects the console_drivers list, and also
@@ -416,6 +420,9 @@
 	char *p;
 	static char printk_buf[1024];
 	static int log_level_unknown = 1;
+#ifdef CONFIG_BOOTX_TEXT
+	extern int force_printk_to_btext;
+#endif
 
 	if (oops_in_progress) {
 		/* If a crash is occurring, make sure we can't deadlock */
@@ -431,7 +438,10 @@
 	va_start(args, fmt);
 	printed_len = vsnprintf(printk_buf, sizeof(printk_buf), fmt, args);
 	va_end(args);
-
+#ifdef CONFIG_BOOTX_TEXT
+	if (force_printk_to_btext)
+		btext_drawstring(printk_buf);
+#endif /* CONFIG_BOOTX_TEXT */
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
 	 * appropriate log level tags, we insert them here
@@ -526,6 +536,8 @@
 		con_start = log_end;		/* Flush */
 		spin_unlock_irqrestore(&logbuf_lock, flags);
 		call_console_drivers(_con_start, _log_end);
+		if (__slow_boot)
+			mdelay(500);
 	}
 	console_may_schedule = 0;
 	up(&console_sem);
diff -urN kernel-source-2.4.27/kernel/resource.c kernel-source-2.4.27-benh/kernel/resource.c
--- kernel-source-2.4.27/kernel/resource.c	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/kernel/resource.c	2004-09-01 20:56:31.369350192 +0200
@@ -163,9 +163,24 @@
 	write_lock(&resource_lock);
 	conflict = __request_resource(root, new);
 	write_unlock(&resource_lock);
+	if (conflict) {
+		printk("resource conflict with: %lx..%lx (%lx), name: %s\n",
+			conflict->start, conflict->end, conflict->flags,
+			conflict->name ? conflict->name : "<NULL>");
+	}
 	return conflict ? -EBUSY : 0;
 }
 
+struct resource *____request_resource(struct resource *root, struct resource *new)
+{
+	struct resource *conflict;
+
+	write_lock(&resource_lock);
+	conflict = __request_resource(root, new);
+	write_unlock(&resource_lock);
+	return conflict;
+}
+
 int release_resource(struct resource *old)
 {
 	int retval;
diff -urN kernel-source-2.4.27/kernel/sysctl.c kernel-source-2.4.27-benh/kernel/sysctl.c
--- kernel-source-2.4.27/kernel/sysctl.c	2004-08-08 01:26:06.000000000 +0200
+++ kernel-source-2.4.27-benh/kernel/sysctl.c	2004-09-01 20:56:31.444338792 +0200
@@ -305,6 +305,8 @@
 	 &pgt_cache_water, 2*sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_PAGE_CLUSTER, "page-cluster", 
 	 &page_cluster, sizeof(int), 0644, NULL, &proc_dointvec},
+	{VM_HEAP_STACK_GAP, "heap-stack-gap", 
+	 &heap_stack_gap, sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_MIN_READAHEAD, "min-readahead",
 	&vm_min_readahead,sizeof(int), 0644, NULL, &proc_dointvec},
 	{VM_MAX_READAHEAD, "max-readahead",
diff -urN kernel-source-2.4.27/MAINTAINERS kernel-source-2.4.27-benh/MAINTAINERS
--- kernel-source-2.4.27/MAINTAINERS	2004-08-24 07:53:15.000000000 +0200
+++ kernel-source-2.4.27-benh/MAINTAINERS	2004-09-01 20:56:31.670304440 +0200
@@ -1376,7 +1376,7 @@
 NVIDIA (RIVA) FRAMEBUFFER DRIVER
 P:	Ani Joshi
 M:	ajoshi@kernel.crashing.org
-L:	linux-nvidia@lists.surfsouth.com
+L:      linux-fbdev-devel@lists.sourceforge.net
 S:	Maintained
 
 OLYMPIC NETWORK DRIVER
diff -urN kernel-source-2.4.27/mm/highmem.c kernel-source-2.4.27-benh/mm/highmem.c
--- kernel-source-2.4.27/mm/highmem.c	2003-06-13 16:51:39.000000000 +0200
+++ kernel-source-2.4.27-benh/mm/highmem.c	2004-09-01 20:56:31.672304136 +0200
@@ -121,6 +121,17 @@
 		}
 	}
 	vaddr = PKMAP_ADDR(last_pkmap_nr);
+#if defined(HIGHMEM_DEBUG) && defined(CONFIG_6xx)
+	if (pte_val(pkmap_page_table[last_pkmap_nr]) & _PAGE_HASHPTE) {
+		printk("WARNING: Mapping a high PTE on a filled hash slot!\n");
+		printk("vaddr: %08lx\n", vaddr);
+#ifdef CONFIG_XMON
+		xmon_printf("Mapping a high PTE on a filled hash slot!\n");
+		xmon_printf("vaddr: %08lx\n", vaddr);
+		xmon(NULL);
+#endif
+	}
+#endif
 	set_pte(&(pkmap_page_table[last_pkmap_nr]), mk_pte(page, kmap_prot));
 
 	pkmap_count[last_pkmap_nr] = 1;
diff -urN kernel-source-2.4.27/mm/memory.c kernel-source-2.4.27-benh/mm/memory.c
--- kernel-source-2.4.27/mm/memory.c	2003-11-28 19:26:21.000000000 +0100
+++ kernel-source-2.4.27-benh/mm/memory.c	2004-09-01 20:56:31.817282096 +0200
@@ -102,6 +102,24 @@
 		return;
 	}
 	pte = pte_offset(dir, 0);
+#ifdef CONFIG_DEBUG_CHECK_PMD_FREE
+	{
+		int i;
+		for (i=0;i<PTRS_PER_PTE;i++) {
+			if ((pte_val(*pte) & _PAGE_HASHPTE) != 0) {
+				printk("ERROR: Non-clear HASHPTE in free_one_pmd()\n");
+				printk("current=%s\n", current->comm);
+#ifdef CONFIG_XMON
+				xmon_printf("ERROR: Non-clear HASHPTE in free_one_pmd()\n");
+				xmon(NULL);
+#endif
+			}
+			pte++;
+		}
+			
+	}
+	pte = pte_offset(dir, 0);
+#endif
 	pmd_clear(dir);
 	pte_free(pte);
 }
@@ -812,8 +830,13 @@
 		address = (address + PGDIR_SIZE) & PGDIR_MASK;
 		dir++;
 	} while (address && (address < end));
+#ifdef CONFIG_DEBUG_FLUSHWITHLOCK
+	flush_tlb_range(mm, beg, end);
+#endif
 	spin_unlock(&mm->page_table_lock);
+#ifndef CONFIG_DEBUG_FLUSHWITHLOCK
 	flush_tlb_range(mm, beg, end);
+#endif
 	return error;
 }
 
@@ -894,8 +917,13 @@
 		from = (from + PGDIR_SIZE) & PGDIR_MASK;
 		dir++;
 	} while (from && (from < end));
+#ifdef CONFIG_DEBUG_FLUSHWITHLOCK
+	flush_tlb_range(mm, beg, end);
+#endif
 	spin_unlock(&mm->page_table_lock);
+#ifndef CONFIG_DEBUG_FLUSHWITHLOCK
 	flush_tlb_range(mm, beg, end);
+#endif
 	return error;
 }
 
diff -urN kernel-source-2.4.27/mm/mmap.c kernel-source-2.4.27-benh/mm/mmap.c
--- kernel-source-2.4.27/mm/mmap.c	2004-02-18 14:36:32.000000000 +0100
+++ kernel-source-2.4.27-benh/mm/mmap.c	2004-09-01 20:56:31.891270848 +0200
@@ -46,6 +46,7 @@
 };
 
 int sysctl_overcommit_memory;
+int heap_stack_gap = 1;
 int max_map_count = DEFAULT_MAX_MAP_COUNT;
 
 /* Check that a process has enough memory to allocate a
@@ -636,9 +637,15 @@
 
 	for (vma = find_vma(current->mm, addr); ; vma = vma->vm_next) {
 		/* At this point:  (!vma || addr < vma->vm_end). */
+		unsigned long __heap_stack_gap;
 		if (TASK_SIZE - len < addr)
 			return -ENOMEM;
-		if (!vma || addr + len <= vma->vm_start)
+		if (!vma)
+			return addr;
+		__heap_stack_gap = 0;
+		if (vma->vm_flags & VM_GROWSDOWN)
+			__heap_stack_gap = heap_stack_gap << PAGE_SHIFT;
+		if (addr + len + __heap_stack_gap <= vma->vm_start)
 			return addr;
 		addr = vma->vm_end;
 	}
@@ -747,7 +754,7 @@
 
 struct vm_area_struct * find_extend_vma(struct mm_struct * mm, unsigned long addr)
 {
-	struct vm_area_struct * vma;
+	struct vm_area_struct * vma, * prev_vma;
 	unsigned long start;
 
 	addr &= PAGE_MASK;
@@ -759,7 +766,8 @@
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		return NULL;
 	start = vma->vm_start;
-	if (expand_stack(vma, addr))
+	find_vma_prev(mm, addr, &prev_vma);
+	if (expand_stack(vma, addr, prev_vma))
 		return NULL;
 	if (vma->vm_flags & VM_LOCKED) {
 		make_pages_present(addr, start);
diff -urN kernel-source-2.4.27/README.BENH kernel-source-2.4.27-benh/README.BENH
--- kernel-source-2.4.27/README.BENH	1970-01-01 01:00:00.000000000 +0100
+++ kernel-source-2.4.27-benh/README.BENH	2004-09-01 20:56:31.892270696 +0200
@@ -0,0 +1,27 @@
+Welcome to my PowerMac tree.
+
+In addition to the standard feature set of kernel.org's 2.4.23, this
+tree includes fixes/updates that didn't make it into 2.4.23, including all
+of what was present as of 2.4.22-ben2. Some of the major additions are:
+
+ - G5 support (though 2.6 is recommended on G5s anyway)
+ - Laptop mode patch (Jens Axboe). See Documentation/laptop_mode.sh script
+ - Andrea Arcangeli's silent-stack-overflow patch
+ - CPU Frequency switching support on some laptops
+ - Support for UniNorth AGP in the agpgart driver (though it's strongly
+   recommended that you use Michel's Danzer DRM module for that to work
+   properly)
+ - Support for blinking the laptop LED on internal HD activity
+   (Jens and me)
+ - Improved support for lba48 capable disks (Jens Axboe)
+ - Updated rivafb with support for more cards & eMac
+ - Updated sungem driver, supports more chips & recent PHYs
+ - Updated dmasound driver to support tumbler & snapper
+ - Add reporting of OF device path of IDE interfaces in /proc/ide
+ - Fixes for CompactFlash cards
+ - Fixes to vmlinux.coff oldworld wrapper
+ - Better TB sync code for 2 CPU machines from Samuel Rydth
+ - Hardware TB sync on core99 (dual G4s)
+ - Initial support for iBook G4
+ - Fix for Promise IDE controller on Xserve's
+
