diff -urN kernel-source-2.4.27/arch/ppc/kernel/pci.c kernel-source-2.4.27-pegasos/arch/ppc/kernel/pci.c
--- kernel-source-2.4.27/arch/ppc/kernel/pci.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-pegasos/arch/ppc/kernel/pci.c	2004-09-01 21:07:12.149936736 +0200
@@ -1280,6 +1280,8 @@
 #ifdef CONFIG_ALL_PPC
 	if (machine_is_compatible("MacRISC"))
 		bus_offset = 0x10;
+	else if (machine_has_name("Pegasos2", 8))
+		bus_offset = 0x10;
 	else
 #endif
 		bus_offset = 1;
diff -urN kernel-source-2.4.27/arch/ppc/kernel/prom.c kernel-source-2.4.27-pegasos/arch/ppc/kernel/prom.c
--- kernel-source-2.4.27/arch/ppc/kernel/prom.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-pegasos/arch/ppc/kernel/prom.c	2004-09-01 21:07:12.151936432 +0200
@@ -894,6 +894,20 @@
 	return device_is_compatible(root, compat);
 }
 
+/* Indicates whether the root node name */
+int
+machine_has_name(const char *name, int namelen)
+{
+	struct device_node *root;
+	const char* machine;
+
+	root = find_path_device("/");
+	if (root == 0)
+		return 0;
+	machine = (char *) get_property(root, "model", NULL);
+	return (strncmp(machine, name, namelen) == 0);
+}
+
 /*
  * Construct and return a list of the device_nodes with a given type
  * and compatible property.
diff -urN kernel-source-2.4.27/arch/ppc/kernel/prom_init.c kernel-source-2.4.27-pegasos/arch/ppc/kernel/prom_init.c
--- kernel-source-2.4.27/arch/ppc/kernel/prom_init.c	2003-11-28 19:26:19.000000000 +0100
+++ kernel-source-2.4.27-pegasos/arch/ppc/kernel/prom_init.c	2004-09-01 21:07:12.153936128 +0200
@@ -765,6 +765,9 @@
 	char *p, *d;
  	unsigned long phys;
 	void *result[3];
+	char model[32];
+	phandle node;
+	int rc;
 
  	/* Default */
  	phys = (unsigned long) &_stext;
@@ -856,6 +859,10 @@
 	prom_print("from prom_init\n");
 	prom_stdout = 0;
 
+	node = call_prom("finddevice", 1, 1, "/");
+	rc = call_prom("getprop", 4, 1, node, "model",model, sizeof(model));
+	if (rc > 0 && !strncmp(model, "Pegasos", 7)) phys = 0x00010000;
+
 	return phys;
 }
 
diff -urN kernel-source-2.4.27/arch/ppc/platforms/chrp_pci.c kernel-source-2.4.27-pegasos/arch/ppc/platforms/chrp_pci.c
--- kernel-source-2.4.27/arch/ppc/platforms/chrp_pci.c	2003-06-13 16:51:31.000000000 +0200
+++ kernel-source-2.4.27-pegasos/arch/ppc/platforms/chrp_pci.c	2004-09-01 21:07:12.155935824 +0200
@@ -158,6 +158,111 @@
 	rtas_write_config_dword
 };
 
+
+/*
+ * Access functions for PCI config space on Pegasos 2 host bridge.
+ */
+
+#define PEG2_PCI_OP(rw, size, type, op, mask, btrw)		   	     \
+int __chrp								     \
+peg2_pci_##rw##_config_##size(struct pci_dev *dev, int offset, type val)     \
+{									     \
+	struct pci_controller *hose = dev->sysdata;			     \
+	u32 msr;							     \
+	u32 data;							     \
+	volatile unsigned int *f118 = hose->cfg_peg2_magic;		     \
+	volatile unsigned int *f11c = (unsigned int *) f118 + 1;	     \
+									     \
+	/* We won't write on device 0 and only read byte 0-15 of func 0 */   \
+	if (dev->bus->number == 0 || dev->bus->number == 0x10) {	     \
+		if (dev->devfn == 0) {					     \
+			if (btrw & 1) {					     \
+				return PCIBIOS_SUCCESSFUL;		     \
+			} else if (offset > 0xf) {			     \
+				val = (type) 0x0;			     \
+				return PCIBIOS_SUCCESSFUL;		     \
+			}						     \
+		} else if ((dev->devfn >> 3) == 0) {			     \
+			return PCIBIOS_DEVICE_NOT_FOUND;		     \
+		}							     \
+	}								     \
+									     \
+	if (hose->bus_offset == 0x10) {					     \
+		/* Disable cpu interrupts */				     \
+		msr = mfmsr();						     \
+		mtmsr(msr & ~MSR_EE);					     \
+		/* Enable PCI -> AGP idsel mapping */			     \
+		cfg_write(0x8000, f118, u32, out_be32);			     \
+	}								     \
+									     \
+	data = 0x80000000 | ((dev->bus->number - hose->bus_offset) << 16)    \
+		  | (dev->devfn << 8) | (offset & 0xff);		     \
+	cfg_write(data, hose->cfg_addr, u32, out_le32);			     \
+	cfg_##rw(val, hose->cfg_data + (offset & mask), type, op);   	     \
+									     \
+	if (hose->bus_offset == 0x10) {					     \
+		/* Enable PCI -> AGP idsel mapping */			     \
+		cfg_write(0x8000, f11c, u32, out_be32);	 		     \
+		/* Disable cpu interrupts */				     \
+		mtmsr(msr);						     \
+	}								     \
+									     \
+	return PCIBIOS_SUCCESSFUL;					     \
+}
+
+PEG2_PCI_OP(read, byte, u8 *, in_8, 3, 0)
+PEG2_PCI_OP(read, word, u16 *, in_le16, 2, 0)
+PEG2_PCI_OP(read, dword, u32 *, in_le32, 0, 0)
+PEG2_PCI_OP(write, byte, u8, out_8, 3, 1)
+PEG2_PCI_OP(write, word, u16, out_le16, 2, 1)
+PEG2_PCI_OP(write, dword, u32, out_le32, 0, 1)
+
+static struct pci_ops peg2_pci_ops __chrpdata =
+{
+	peg2_pci_read_config_byte,
+	peg2_pci_read_config_word,
+	peg2_pci_read_config_dword,
+	peg2_pci_write_config_byte,
+	peg2_pci_write_config_word,
+	peg2_pci_write_config_dword
+};
+
+static void __init
+setup_peg2(struct pci_controller *hose, struct device_node *dev)
+{
+	pci_assign_all_busses = 1;
+	if (strncmp(dev->full_name, "/pci@80000000", 13) == 0) {
+		setup_indirect_pci(hose, 0xf1000c78, 0xf1000c7c);
+		hose->ops = &peg2_pci_ops;
+		hose->cfg_addr = (unsigned int *) ioremap(0xf1000c78, 8);
+		hose->cfg_data = (unsigned char *) hose->cfg_addr + 4;
+	} else if (strncmp(dev->full_name, "/pci@C0000000", 13) == 0) {
+		hose->ops = &peg2_pci_ops;
+		hose->cfg_addr = (unsigned int *) ioremap(0xf1000cf8, 8);
+		hose->cfg_data = (unsigned char *) hose->cfg_addr + 4;
+		hose->cfg_peg2_magic = (unsigned int *) ioremap(0xf100f118, 8);
+		hose->bus_offset = 0x10;
+	} else
+		printk("Pegasos 2 unknown pci bridge detected %s, type %s, full name %s at %08x, ints %d\n",
+			dev->name, dev->type, dev->full_name, dev->n_addrs, dev->n_intrs);
+}
+
+void __init
+peg2_pcibios_fixup(void)
+{
+	struct pci_dev *dev = NULL;
+	int i;
+
+	/* Not the right please, but let's do it from here for now */
+	while ((dev = pci_find_device(PCI_VENDOR_ID_MARVELL, PCI_DEVICE_ID_MARVELL_MV6430, dev))) {
+		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+			dev->resource[i].flags = 0;
+			dev->resource[i].start = 0;
+			dev->resource[i].end = 0;
+		}
+	}
+}
+
 int __init
 hydra_init(void)
 {
@@ -291,7 +396,7 @@
 	struct pci_controller *hose;
 	unsigned int *dma;
 	char *model, *machine;
-	int is_longtrail = 0, is_mot = 0;
+	int is_longtrail = 0, is_mot = 0, is_pegasos = 0;
 	struct device_node *root = find_path_device("/");
 
 	/*
@@ -303,6 +408,9 @@
 	if (machine != NULL) {
 		is_longtrail = strncmp(machine, "IBM,LongTrail", 13) == 0;
 		is_mot = strncmp(machine, "MOT", 3) == 0;
+		/*is_pegasos = strncmp(machine, "Pegasos", 7) == 0;*/
+		if (strncmp(machine, "Pegasos2", 8) == 0) is_pegasos = 2;
+		else if (strncmp(machine, "Pegasos", 7) == 0) is_pegasos = 1;
 	}
 	for (dev = root->child; dev != NULL; dev = dev->sibling) {
 		if (dev->type == NULL || strcmp(dev->type, "pci") != 0)
@@ -365,6 +473,10 @@
 					pci_dram_offset = *dma;
 				}
 			}
+		} else if (is_pegasos == 1) {
+			setup_indirect_pci(hose, 0xfec00cf8, 0xfee00cfc);
+		} else if (is_pegasos == 2) {
+			setup_peg2(hose, dev);
 		} else {
 			printk("No methods for %s (model %s), using RTAS\n",
 			       dev->full_name, model);
@@ -387,6 +499,10 @@
                ppc_md.pcibios_fixup = longtrail_pcibios_fixup;
        else if (chrp_is_briq)
                ppc_md.pcibios_fixup = briq_pcibios_fixup;
+       
+       /* Pegasos has no OpenPic */
+       else if (is_pegasos)
+               ppc_md.pcibios_fixup = peg2_pcibios_fixup;
        else
                ppc_md.pcibios_fixup = chrp_pcibios_fixup;
 }
diff -urN kernel-source-2.4.27/arch/ppc/platforms/chrp_setup.c kernel-source-2.4.27-pegasos/arch/ppc/platforms/chrp_setup.c
--- kernel-source-2.4.27/arch/ppc/platforms/chrp_setup.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-pegasos/arch/ppc/platforms/chrp_setup.c	2004-09-01 21:07:12.157935520 +0200
@@ -220,6 +220,37 @@
 	}
 }
 
+void pegasos_set_l2cr(void)
+{
+	struct device_node *root = find_path_device("/");
+	char *machine;
+	struct device_node *np;
+	int l2cr_value;
+
+	/* On Pegasos, enable the l2 cache if needed, as the OF forgets it */
+	if (root == NULL)
+		return;
+	machine = get_property(root, "model", NULL);
+	if (machine == NULL)
+		return;
+	if (strncmp(machine, "Pegasos", 7) == 0) {
+		/* Enable L2 cache if needed */
+		np = find_type_devices("cpu");
+		if (np != NULL) {
+			unsigned int *l2cr = (unsigned int *)
+				get_property (np, "l2cr", NULL);
+			if (l2cr == NULL) {
+				printk ("Pegasos l2cr : no cpu l2cr property found\n");
+				return;
+			}
+			if (!((*l2cr) & 0x80000000)) {
+				printk ("Pegasos l2cr : L2 cache was not active, activating\n");
+				_set_L2CR(0);
+				_set_L2CR((*l2cr) | 0x80000000);
+			}
+		}
+	}
+}
 
 void __init
 chrp_setup_arch(void)
@@ -242,6 +273,9 @@
 	/* Lookup PCI host bridges */
 	chrp_find_bridges();
 
+	/* On pegasos, enable the L2 cache if not already done by OF */
+	pegasos_set_l2cr();
+
 #ifndef CONFIG_PPC64BRIDGE
 	/*
 	 *  Temporary fixes for PCI devices.
@@ -440,8 +474,28 @@
 	i8259_init(intack);
 }
 
+static void __init
+pegasos_init_irq_8259(unsigned long intack)
+{
+	int i;
+	
+	ppc_md.get_irq = i8259_irq;
+	for (i = 0; i < NUM_8259_INTERRUPTS; i++) {
+		if (i<16) {
+			/* byte access */
+			unsigned int port = 0x4d0 + (i >> 3);
+			/* ask HW directly */
+			irq_desc[i].status |= (((inb(port) >> (i & 7)) & 1) ? IRQ_LEVEL : 0 );
+		}
+		irq_desc[i].handler = &i8259_pic;
+	}
+	i8259_init(intack);
+}
+
 void __init chrp_init_IRQ(void)
 {
+	struct device_node *root = find_path_device("/");
+	char *machine;
 	struct device_node *np;
 	unsigned long intack = 0;
 	struct device_node *main_irq_ctrler = NULL;
@@ -471,6 +525,10 @@
 			main_irq_ctrler = find_phandle(*irq_ctrler_ph);
 	}
 
+	machine = get_property(root, "model", NULL);
+	if (main_irq_ctrler == NULL && (strncmp(machine, "Pegasos", 7) == 0))
+		pegasos_init_irq_8259(intack);
+	else
 	if (main_irq_ctrler && device_is_compatible(main_irq_ctrler, "8259"))
 		chrp_init_irq_8259(intack);
 	else
@@ -570,7 +628,10 @@
 	ppc_md.show_cpuinfo   = chrp_show_cpuinfo;
 	ppc_md.irq_cannonicalize = chrp_irq_cannonicalize;
 	ppc_md.init_IRQ       = chrp_init_IRQ;
-	ppc_md.get_irq        = openpic_get_irq;
+	if (strncmp(machine, "Pegasos", 7) == 0)
+		ppc_md.get_irq = i8259_irq;
+	else
+		ppc_md.get_irq = openpic_get_irq;
 
 	ppc_md.init           = chrp_init2;
 
diff -urN kernel-source-2.4.27/arch/ppc/platforms/chrp_time.c kernel-source-2.4.27-pegasos/arch/ppc/platforms/chrp_time.c
--- kernel-source-2.4.27/arch/ppc/platforms/chrp_time.c	2003-08-25 13:44:40.000000000 +0200
+++ kernel-source-2.4.27-pegasos/arch/ppc/platforms/chrp_time.c	2004-09-01 21:07:12.157935520 +0200
@@ -41,8 +41,11 @@
 	int base;
 
 	rtcs = find_compatible_devices("rtc", "pnpPNP,b00");
+	if (rtcs == NULL)
+		rtcs = find_compatible_devices("rtc", "ds1385-rtc");
 	if (rtcs == NULL || rtcs->addrs == NULL)
 		return 0;
+
 	base = rtcs->addrs[0].address;
 	nvram_as1 = 0;
 	nvram_as0 = base;
diff -urN kernel-source-2.4.27/drivers/ide/pci/via82cxxx.c kernel-source-2.4.27-pegasos/drivers/ide/pci/via82cxxx.c
--- kernel-source-2.4.27/drivers/ide/pci/via82cxxx.c	2003-08-25 13:44:41.000000000 +0200
+++ kernel-source-2.4.27-pegasos/drivers/ide/pci/via82cxxx.c	2004-09-01 21:07:12.231924272 +0200
@@ -90,6 +90,7 @@
 	{ "vt82c586b",	PCI_DEVICE_ID_VIA_82C586_0, 0x30, 0x3f, VIA_UDMA_33 | VIA_SET_FIFO },
 	{ "vt82c586a",	PCI_DEVICE_ID_VIA_82C586_0, 0x20, 0x2f, VIA_UDMA_33 | VIA_SET_FIFO },
 	{ "vt82c586",	PCI_DEVICE_ID_VIA_82C586_0, 0x00, 0x0f, VIA_UDMA_NONE | VIA_SET_FIFO },
+	{ "vt82c586c",  PCI_DEVICE_ID_VIA_82C586_1, 0x00, 0xff, VIA_UDMA_33 | VIA_SET_FIFO },
 	{ "vt82c576",	PCI_DEVICE_ID_VIA_82C576,   0x00, 0x2f, VIA_UDMA_NONE | VIA_SET_FIFO | VIA_NO_UNMASK },
 	{ "vt82c576",	PCI_DEVICE_ID_VIA_82C576,   0x00, 0x2f, VIA_UDMA_NONE | VIA_SET_FIFO | VIA_NO_UNMASK | VIA_BAD_ID },
 	{ NULL }
@@ -588,6 +589,8 @@
 	hwif->tuneproc = &via82cxxx_tune_drive;
 	hwif->speedproc = &via_set_drive;
 
+	hwif->irq = hwif->channel ? 15 : 14;
+
 	for (i = 0; i < 2; i++) {
 		hwif->drives[i].io_32bit = 1;
 		hwif->drives[i].unmask = (via_config->flags & VIA_NO_UNMASK) ? 0 : 1;
diff -urN kernel-source-2.4.27/drivers/net/via-rhine.c kernel-source-2.4.27-pegasos/drivers/net/via-rhine.c
--- kernel-source-2.4.27/drivers/net/via-rhine.c	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-pegasos/drivers/net/via-rhine.c	2004-09-01 21:07:12.234923816 +0200
@@ -750,7 +750,7 @@
 
 	if (!is_valid_ether_addr(dev->dev_addr)) {
 		printk(KERN_ERR "Invalid MAC address for card #%d\n", card_idx);
-		goto err_out_unmap;
+		/*goto err_out_unmap;*/
 	}
 
 	if (chip_id == VT6102) {
diff -urN kernel-source-2.4.27/include/asm-ppc/pci-bridge.h kernel-source-2.4.27-pegasos/include/asm-ppc/pci-bridge.h
--- kernel-source-2.4.27/include/asm-ppc/pci-bridge.h	2003-08-25 13:44:44.000000000 +0200
+++ kernel-source-2.4.27-pegasos/include/asm-ppc/pci-bridge.h	2004-09-01 21:07:12.239923056 +0200
@@ -85,6 +85,9 @@
 	 */
 	struct resource io_space;
 	struct resource mem_space;
+
+	/* Pegasos 2 magic mapping */
+	volatile unsigned int *cfg_peg2_magic;
 };
 
 /* These are used for config access before all the PCI probing
diff -urN kernel-source-2.4.27/include/linux/pci_ids.h kernel-source-2.4.27-pegasos/include/linux/pci_ids.h
--- kernel-source-2.4.27/include/linux/pci_ids.h	2004-08-24 07:53:14.000000000 +0200
+++ kernel-source-2.4.27-pegasos/include/linux/pci_ids.h	2004-09-01 21:07:12.238923208 +0200
@@ -1330,10 +1330,12 @@
 #define PCI_SUBDEVICE_ID_KEYSPAN_SX2	0x5334
 
 #define PCI_VENDOR_ID_GALILEO		0x11ab
+#define PCI_VENDOR_ID_MARVELL		0x11ab
 #define PCI_DEVICE_ID_GALILEO_GT64011	0x4146
 #define PCI_DEVICE_ID_GALILEO_GT64111	0x4146
 #define PCI_DEVICE_ID_GALILEO_GT96100	0x9652
 #define PCI_DEVICE_ID_GALILEO_GT96100A	0x9653
+#define PCI_DEVICE_ID_MARVELL_MV6430	0x6460
 
 #define PCI_VENDOR_ID_LITEON		0x11ad
 #define PCI_DEVICE_ID_LITEON_LNE100TX	0x0002
