diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/include/asm-m68k/cacheflush.h linux-2.6.13/include/asm-m68k/cacheflush.h
--- linux-2.6.13-i386/include/asm-m68k/cacheflush.h	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/include/asm-m68k/cacheflush.h	2005-08-30 16:36:03.000000000 +0200
@@ -130,20 +130,25 @@
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
 #define flush_dcache_mmap_unlock(mapping)	do { } while (0)
 #define flush_icache_page(vma, page)	__flush_page_to_ram(page_address(page))
-#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
-
-#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
-	do {							\
-		flush_cache_page(vma, vaddr, page_to_pfn(page));\
-		memcpy(dst, src, len);				\
-	} while (0)
-
-#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
-	do {							\
-		flush_cache_page(vma, vaddr, page_to_pfn(page));\
-		memcpy(dst, src, len);				\
-	} while (0)
 
+extern void flush_icache_user_range(struct vm_area_struct *vma, struct page *page,
+				    unsigned long addr, int len);
 extern void flush_icache_range(unsigned long address, unsigned long endaddr);
 
+static inline void copy_to_user_page(struct vm_area_struct *vma,
+				     struct page *page, unsigned long vaddr,
+				     void *dst, void *src, int len)
+{
+	flush_cache_page(vma, vaddr, page_to_pfn(page));
+	memcpy(dst, src, len);
+	flush_icache_user_range(vma, page, vaddr, len);
+}
+static inline void copy_from_user_page(struct vm_area_struct *vma,
+				       struct page *page, unsigned long vaddr,
+				       void *dst, void *src, int len)
+{
+	flush_cache_page(vma, vaddr, page_to_pfn(page));
+	memcpy(dst, src, len);
+}
+
 #endif /* _M68K_CACHEFLUSH_H */
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/include/asm-m68k/io.h linux-2.6.13/include/asm-m68k/io.h
--- linux-2.6.13-i386/include/asm-m68k/io.h	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/include/asm-m68k/io.h	2005-06-19 16:35:42.000000000 +0200
@@ -324,8 +324,6 @@
 #define writel(val,addr) out_le32((addr),(val))
 #endif
 
-#define mmiowb()
-
 static inline void *ioremap(unsigned long physaddr, unsigned long size)
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/include/asm-m68k/processor.h linux-2.6.13/include/asm-m68k/processor.h
--- linux-2.6.13-i386/include/asm-m68k/processor.h	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/include/asm-m68k/processor.h	2005-05-30 16:33:26.000000000 +0200
@@ -14,6 +14,7 @@
 #define current_text_addr() ({ __label__ _l; _l: &&_l;})
 
 #include <linux/config.h>
+#include <linux/thread_info.h>
 #include <asm/segment.h>
 #include <asm/fpu.h>
 #include <asm/ptrace.h>
@@ -55,17 +56,6 @@
 #endif
 #define TASK_UNMAPPED_ALIGN(addr, off)	PAGE_ALIGN(addr)
 
-struct task_work {
-	unsigned char sigpending;
-	unsigned char notify_resume;	/* request for notification on
-					   userspace execution resumption */
-	char          need_resched;
-	unsigned char delayed_trace;	/* single step a syscall */
-	unsigned char syscall_trace;	/* count of syscall interceptors */
-	unsigned char memdie;		/* task was selected to be killed */
-	unsigned char pad[2];
-};
-
 struct thread_struct {
 	unsigned long  ksp;		/* kernel stack pointer */
 	unsigned long  usp;		/* user stack pointer */
@@ -78,7 +68,7 @@
 	unsigned long  fp[8*3];
 	unsigned long  fpcntl[3];	/* fp control regs */
 	unsigned char  fpstate[FPSTATESIZE];  /* floating point state */
-	struct task_work work;
+	struct thread_info info;
 };
 
 #define INIT_THREAD  {							\
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/include/asm-m68k/serial.h linux-2.6.13/include/asm-m68k/serial.h
--- linux-2.6.13-i386/include/asm-m68k/serial.h	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/include/asm-m68k/serial.h	2005-08-30 16:36:03.000000000 +0200
@@ -26,9 +26,11 @@
 #define STD_COM4_FLAGS ASYNC_BOOT_AUTOCONF
 #endif
 
+#ifdef CONFIG_ISA
 #define SERIAL_PORT_DFNS			\
 	/* UART CLK   PORT IRQ     FLAGS        */			\
 	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
 	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS },	/* ttyS1 */	\
 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
 	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
+#endif
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/include/asm-m68k/string.h linux-2.6.13/include/asm-m68k/string.h
--- linux-2.6.13-i386/include/asm-m68k/string.h	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/include/asm-m68k/string.h	2005-08-30 16:36:03.000000000 +0200
@@ -80,43 +80,6 @@
   return( (char *) s);
 }
 
-#if 0
-#define __HAVE_ARCH_STRPBRK
-static inline char *strpbrk(const char *cs,const char *ct)
-{
-  const char *sc1,*sc2;
-
-  for( sc1 = cs; *sc1 != '\0'; ++sc1)
-    for( sc2 = ct; *sc2 != '\0'; ++sc2)
-      if (*sc1 == *sc2)
-	return((char *) sc1);
-  return( NULL );
-}
-#endif
-
-#if 0
-#define __HAVE_ARCH_STRSPN
-static inline size_t strspn(const char *s, const char *accept)
-{
-  const char *p;
-  const char *a;
-  size_t count = 0;
-
-  for (p = s; *p != '\0'; ++p)
-    {
-      for (a = accept; *a != '\0'; ++a)
-        if (*p == *a)
-          break;
-      if (*a == '\0')
-        return count;
-      else
-        ++count;
-    }
-
-  return count;
-}
-#endif
-
 /* strstr !! */
 
 #define __HAVE_ARCH_STRLEN
@@ -173,370 +136,18 @@
 }
 
 #define __HAVE_ARCH_MEMSET
-/*
- * This is really ugly, but its highly optimizatiable by the
- * compiler and is meant as compensation for gcc's missing
- * __builtin_memset(). For the 680[23]0	it might be worth considering
- * the optimal number of misaligned writes compared to the number of
- * tests'n'branches needed to align the destination address. The
- * 680[46]0 doesn't really care due to their copy-back caches.
- *						10/09/96 - Jes Sorensen
- */
-static inline void * __memset_g(void * s, int c, size_t count)
-{
-  void *xs = s;
-  size_t temp;
-
-  if (!count)
-    return xs;
-
-  c &= 0xff;
-  c |= c << 8;
-  c |= c << 16;
-
-  if (count < 36){
-	  long *ls = s;
-
-	  switch(count){
-	  case 32: case 33: case 34: case 35:
-		  *ls++ = c;
-	  case 28: case 29: case 30: case 31:
-		  *ls++ = c;
-	  case 24: case 25: case 26: case 27:
-		  *ls++ = c;
-	  case 20: case 21: case 22: case 23:
-		  *ls++ = c;
-	  case 16: case 17: case 18: case 19:
-		  *ls++ = c;
-	  case 12: case 13: case 14: case 15:
-		  *ls++ = c;
-	  case 8: case 9: case 10: case 11:
-		  *ls++ = c;
-	  case 4: case 5: case 6: case 7:
-		  *ls++ = c;
-		  break;
-	  default:
-		  break;
-	  }
-	  s = ls;
-	  if (count & 0x02){
-		  short *ss = s;
-		  *ss++ = c;
-		  s = ss;
-	  }
-	  if (count & 0x01){
-		  char *cs = s;
-		  *cs++ = c;
-		  s = cs;
-	  }
-	  return xs;
-  }
-
-  if ((long) s & 1)
-    {
-      char *cs = s;
-      *cs++ = c;
-      s = cs;
-      count--;
-    }
-  if (count > 2 && (long) s & 2)
-    {
-      short *ss = s;
-      *ss++ = c;
-      s = ss;
-      count -= 2;
-    }
-  temp = count >> 2;
-  if (temp)
-    {
-      long *ls = s;
-      temp--;
-      do
-	*ls++ = c;
-      while (temp--);
-      s = ls;
-    }
-  if (count & 2)
-    {
-      short *ss = s;
-      *ss++ = c;
-      s = ss;
-    }
-  if (count & 1)
-    {
-      char *cs = s;
-      *cs = c;
-    }
-  return xs;
-}
-
-/*
- * __memset_page assumes that data is longword aligned. Most, if not
- * all, of these page sized memsets are performed on page aligned
- * areas, thus we do not need to check if the destination is longword
- * aligned. Of course we suffer a serious performance loss if this is
- * not the case but I think the risk of this ever happening is
- * extremely small. We spend a lot of time clearing pages in
- * get_empty_page() so I think it is worth it anyway. Besides, the
- * 680[46]0 do not really care about misaligned writes due to their
- * copy-back cache.
- *
- * The optimized case for the 680[46]0 is implemented using the move16
- * instruction. My tests showed that this implementation is 35-45%
- * faster than the original implementation using movel, the only
- * caveat is that the destination address must be 16-byte aligned.
- *                                            01/09/96 - Jes Sorensen
- */
-static inline void * __memset_page(void * s,int c,size_t count)
-{
-  unsigned long data, tmp;
-  void *xs = s;
-
-  c = c & 255;
-  data = c | (c << 8);
-  data |= data << 16;
-
-#ifdef CPU_M68040_OR_M68060_ONLY
-
-  if (((unsigned long) s) & 0x0f)
-	  __memset_g(s, c, count);
-  else{
-	  unsigned long *sp = s;
-	  *sp++ = data;
-	  *sp++ = data;
-	  *sp++ = data;
-	  *sp++ = data;
-
-	  __asm__ __volatile__("1:\t"
-			       ".chip 68040\n\t"
-			       "move16 %2@+,%0@+\n\t"
-			       ".chip 68k\n\t"
-			       "subqw  #8,%2\n\t"
-			       "subqw  #8,%2\n\t"
-			       "dbra   %1,1b\n\t"
-			       : "=a" (sp), "=d" (tmp)
-			       : "a" (s), "0" (sp), "1" ((count - 16) / 16 - 1)
-			       );
-  }
-
-#else
-  __asm__ __volatile__("1:\t"
-		       "movel %2,%0@+\n\t"
-		       "movel %2,%0@+\n\t"
-		       "movel %2,%0@+\n\t"
-		       "movel %2,%0@+\n\t"
-		       "movel %2,%0@+\n\t"
-		       "movel %2,%0@+\n\t"
-		       "movel %2,%0@+\n\t"
-		       "movel %2,%0@+\n\t"
-		       "dbra  %1,1b\n\t"
-		       : "=a" (s), "=d" (tmp)
-		       : "d" (data), "0" (s), "1" (count / 32 - 1)
-		       );
-#endif
-
-  return xs;
-}
-
-extern void *memset(void *,int,__kernel_size_t);
-
-#define __memset_const(s,c,count) \
-((count==PAGE_SIZE) ? \
-  __memset_page((s),(c),(count)) : \
-  __memset_g((s),(c),(count)))
-
-#define memset(s, c, count) \
-(__builtin_constant_p(count) ? \
- __memset_const((s),(c),(count)) : \
- __memset_g((s),(c),(count)))
+extern void *memset(void *, int, __kernel_size_t);
+#define memset(d, c, n) __builtin_memset(d, c, n)
 
 #define __HAVE_ARCH_MEMCPY
-extern void * memcpy(void *, const void *, size_t );
-/*
- * __builtin_memcpy() does not handle page-sized memcpys very well,
- * thus following the same assumptions as for page-sized memsets, this
- * function copies page-sized areas using an unrolled loop, without
- * considering alignment.
- *
- * For the 680[46]0 only kernels we use the move16 instruction instead
- * as it writes through the data-cache, invalidating the cache-lines
- * touched. In this way we do not use up the entire data-cache (well,
- * half of it on the 68060) by copying a page. An unrolled loop of two
- * move16 instructions seem to the fastest. The only caveat is that
- * both source and destination must be 16-byte aligned, if not we fall
- * back to the generic memcpy function.  - Jes
- */
-static inline void * __memcpy_page(void * to, const void * from, size_t count)
-{
-  unsigned long tmp;
-  void *xto = to;
-
-#ifdef CPU_M68040_OR_M68060_ONLY
-
-  if (((unsigned long) to | (unsigned long) from) & 0x0f)
-	  return memcpy(to, from, count);
-
-  __asm__ __volatile__("1:\t"
-		       ".chip 68040\n\t"
-		       "move16 %1@+,%0@+\n\t"
-		       "move16 %1@+,%0@+\n\t"
-		       ".chip 68k\n\t"
-		       "dbra  %2,1b\n\t"
-		       : "=a" (to), "=a" (from), "=d" (tmp)
-		       : "0" (to), "1" (from) , "2" (count / 32 - 1)
-		       );
-#else
-  __asm__ __volatile__("1:\t"
-		       "movel %1@+,%0@+\n\t"
-		       "movel %1@+,%0@+\n\t"
-		       "movel %1@+,%0@+\n\t"
-		       "movel %1@+,%0@+\n\t"
-		       "movel %1@+,%0@+\n\t"
-		       "movel %1@+,%0@+\n\t"
-		       "movel %1@+,%0@+\n\t"
-		       "movel %1@+,%0@+\n\t"
-		       "dbra  %2,1b\n\t"
-		       : "=a" (to), "=a" (from), "=d" (tmp)
-		       : "0" (to), "1" (from) , "2" (count / 32 - 1)
-		       );
-#endif
-  return xto;
-}
-
-#define __memcpy_const(to, from, n) \
-((n==PAGE_SIZE) ? \
-  __memcpy_page((to),(from),(n)) : \
-  __builtin_memcpy((to),(from),(n)))
-
-#define memcpy(to, from, n) \
-(__builtin_constant_p(n) ? \
- __memcpy_const((to),(from),(n)) : \
- memcpy((to),(from),(n)))
+extern void *memcpy(void *, const void *, __kernel_size_t);
+#define memcpy(d, s, n) __builtin_memcpy(d, s, n)
 
 #define __HAVE_ARCH_MEMMOVE
-static inline void * memmove(void * dest,const void * src, size_t n)
-{
-  void *xdest = dest;
-  size_t temp;
-
-  if (!n)
-    return xdest;
-
-  if (dest < src)
-    {
-      if ((long) dest & 1)
-	{
-	  char *cdest = dest;
-	  const char *csrc = src;
-	  *cdest++ = *csrc++;
-	  dest = cdest;
-	  src = csrc;
-	  n--;
-	}
-      if (n > 2 && (long) dest & 2)
-	{
-	  short *sdest = dest;
-	  const short *ssrc = src;
-	  *sdest++ = *ssrc++;
-	  dest = sdest;
-	  src = ssrc;
-	  n -= 2;
-	}
-      temp = n >> 2;
-      if (temp)
-	{
-	  long *ldest = dest;
-	  const long *lsrc = src;
-	  temp--;
-	  do
-	    *ldest++ = *lsrc++;
-	  while (temp--);
-	  dest = ldest;
-	  src = lsrc;
-	}
-      if (n & 2)
-	{
-	  short *sdest = dest;
-	  const short *ssrc = src;
-	  *sdest++ = *ssrc++;
-	  dest = sdest;
-	  src = ssrc;
-	}
-      if (n & 1)
-	{
-	  char *cdest = dest;
-	  const char *csrc = src;
-	  *cdest = *csrc;
-	}
-    }
-  else
-    {
-      dest = (char *) dest + n;
-      src = (const char *) src + n;
-      if ((long) dest & 1)
-	{
-	  char *cdest = dest;
-	  const char *csrc = src;
-	  *--cdest = *--csrc;
-	  dest = cdest;
-	  src = csrc;
-	  n--;
-	}
-      if (n > 2 && (long) dest & 2)
-	{
-	  short *sdest = dest;
-	  const short *ssrc = src;
-	  *--sdest = *--ssrc;
-	  dest = sdest;
-	  src = ssrc;
-	  n -= 2;
-	}
-      temp = n >> 2;
-      if (temp)
-	{
-	  long *ldest = dest;
-	  const long *lsrc = src;
-	  temp--;
-	  do
-	    *--ldest = *--lsrc;
-	  while (temp--);
-	  dest = ldest;
-	  src = lsrc;
-	}
-      if (n & 2)
-	{
-	  short *sdest = dest;
-	  const short *ssrc = src;
-	  *--sdest = *--ssrc;
-	  dest = sdest;
-	  src = ssrc;
-	}
-      if (n & 1)
-	{
-	  char *cdest = dest;
-	  const char *csrc = src;
-	  *--cdest = *--csrc;
-	}
-    }
-  return xdest;
-}
+extern void *memmove(void *, const void *, __kernel_size_t);
 
 #define __HAVE_ARCH_MEMCMP
-extern int memcmp(const void * ,const void * ,size_t );
-#define memcmp(cs, ct, n) \
-(__builtin_constant_p(n) ? \
- __builtin_memcmp((cs),(ct),(n)) : \
- memcmp((cs),(ct),(n)))
-
-#define __HAVE_ARCH_MEMCHR
-static inline void *memchr(const void *cs, int c, size_t count)
-{
-	/* Someone else can optimize this, I don't care - tonym@mac.linux-m68k.org */
-	unsigned char *ret = (unsigned char *)cs;
-	for(;count>0;count--,ret++)
-		if(*ret == c) return ret;
-
-	return NULL;
-}
+extern int memcmp(const void *, const void *, __kernel_size_t);
+#define memcmp(d, s, n) __builtin_memcmp(d, s, n)
 
 #endif /* _M68K_STRING_H_ */
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/include/asm-m68k/thread_info.h linux-2.6.13/include/asm-m68k/thread_info.h
--- linux-2.6.13-i386/include/asm-m68k/thread_info.h	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/include/asm-m68k/thread_info.h	2005-08-30 16:36:04.000000000 +0200
@@ -2,17 +2,15 @@
 #define _ASM_M68K_THREAD_INFO_H
 
 #include <asm/types.h>
-#include <asm/processor.h>
 #include <asm/page.h>
 
 struct thread_info {
 	struct task_struct	*task;		/* main task structure */
+	unsigned long		flags;
 	struct exec_domain	*exec_domain;	/* execution domain */
 	int			preempt_count;	/* 0 => preemptable, <0 => BUG */
 	__u32 cpu; /* should always be 0 on m68k */
 	struct restart_block    restart_block;
-
-	__u8			supervisor_stack[0];
 };
 
 #define PREEMPT_ACTIVE		0x4000000
@@ -28,91 +26,34 @@
 
 /* THREAD_SIZE should be 8k, so handle differently for 4k and 8k machines */
 #if PAGE_SHIFT == 13 /* 8k machines */
-#define alloc_thread_info(tsk)   ((struct thread_info *)__get_free_pages(GFP_KERNEL,0))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),0)
+#define alloc_thread_stack(tsk) ((void *)__get_free_pages(GFP_KERNEL,0))
+#define free_thread_stack(ti)  free_pages((unsigned long)(ti),0)
 #else /* otherwise assume 4k pages */
-#define alloc_thread_info(tsk)   ((struct thread_info *)__get_free_pages(GFP_KERNEL,1))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),1)
+#define alloc_thread_stack(tsk) ((void *)__get_free_pages(GFP_KERNEL,1))
+#define free_thread_stack(ti)  free_pages((unsigned long)(ti),1)
 #endif /* PAGE_SHIFT == 13 */
 
 //#define init_thread_info	(init_task.thread.info)
 #define init_stack		(init_thread_union.stack)
 
-#define current_thread_info()	(current->thread_info)
+#define task_thread_info(tsk)	(&(tsk)->thread.info)
+#define current_thread_info()	task_thread_info(current)
 
+#define setup_thread_stack(p, org) ({			\
+	*(struct task_struct **)(p)->stack = (p);	\
+	task_thread_info(p)->task = (p);		\
+})
 
 #define __HAVE_THREAD_FUNCTIONS
 
-#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
-#define TIF_DELAYED_TRACE	1	/* single step a syscall */
-#define TIF_NOTIFY_RESUME	2	/* resumption notification requested */
-#define TIF_SIGPENDING		3	/* signal pending */
-#define TIF_NEED_RESCHED	4	/* rescheduling necessary */
-#define TIF_MEMDIE		5
-
-extern int thread_flag_fixme(void);
-
-/*
- * flag set/clear/test wrappers
- * - pass TIF_xxxx constants to these functions
+/* entry.S relies on these definitions!
+ * bits 0-7 are tested at every exception exit
+ * bits 8-15 are also tested at syscall exit
  */
-
-#define __set_tsk_thread_flag(tsk, flag, val) ({	\
-	switch (flag) {					\
-	case TIF_SIGPENDING:				\
-		tsk->thread.work.sigpending = val;	\
-		break;					\
-	case TIF_NEED_RESCHED:				\
-		tsk->thread.work.need_resched = val;	\
-		break;					\
-	case TIF_SYSCALL_TRACE:				\
-		tsk->thread.work.syscall_trace = val;	\
-		break;					\
-	case TIF_MEMDIE:				\
-		tsk->thread.work.memdie = val;		\
-		break;					\
-	default:					\
-		thread_flag_fixme();			\
-	}						\
-})
-
-#define __get_tsk_thread_flag(tsk, flag) ({		\
-	int ___res;					\
-	switch (flag) {					\
-	case TIF_SIGPENDING:				\
-		___res = tsk->thread.work.sigpending;	\
-		break;					\
-	case TIF_NEED_RESCHED:				\
-		___res = tsk->thread.work.need_resched;	\
-		break;					\
-	case TIF_SYSCALL_TRACE:				\
-		___res = tsk->thread.work.syscall_trace;\
-		break;					\
-	case TIF_MEMDIE:				\
-		___res = tsk->thread.work.memdie;\
-		break;					\
-	default:					\
-		___res = thread_flag_fixme();		\
-	}						\
-	___res;						\
-})
-
-#define __get_set_tsk_thread_flag(tsk, flag, val) ({	\
-	int __res = __get_tsk_thread_flag(tsk, flag);	\
-	__set_tsk_thread_flag(tsk, flag, val);		\
-	__res;						\
-})
-
-#define set_tsk_thread_flag(tsk, flag) __set_tsk_thread_flag(tsk, flag, ~0)
-#define clear_tsk_thread_flag(tsk, flag) __set_tsk_thread_flag(tsk, flag, 0)
-#define test_and_set_tsk_thread_flag(tsk, flag) __get_set_tsk_thread_flag(tsk, flag, ~0)
-#define test_tsk_thread_flag(tsk, flag) __get_tsk_thread_flag(tsk, flag)
-
-#define set_thread_flag(flag) set_tsk_thread_flag(current, flag)
-#define clear_thread_flag(flag) clear_tsk_thread_flag(current, flag)
-#define test_thread_flag(flag) test_tsk_thread_flag(current, flag)
-
-#define set_need_resched() set_thread_flag(TIF_NEED_RESCHED)
-#define clear_need_resched() clear_thread_flag(TIF_NEED_RESCHED)
+#define TIF_SIGPENDING		6	/* signal pending */
+#define TIF_NEED_RESCHED	7	/* rescheduling necessary */
+#define TIF_DELAYED_TRACE	14	/* single step a syscall */
+#define TIF_SYSCALL_TRACE	15	/* syscall trace active */
+#define TIF_MEMDIE		16
 
 #endif	/* _ASM_M68K_THREAD_INFO_H */
