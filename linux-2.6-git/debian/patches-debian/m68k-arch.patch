diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/Kconfig linux-2.6.13/arch/m68k/Kconfig
--- linux-2.6.13-i386/arch/m68k/Kconfig	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/Kconfig	2005-10-12 16:31:22.000000000 +0200
@@ -613,7 +613,7 @@
 
 config SERIAL167
 	bool "CD2401 support for MVME166/7 serial ports"
-	depends on MVME16x && BROKEN
+	depends on MVME16x
 	help
 	  This is the driver for the serial ports on the Motorola MVME166,
 	  167, and 172 boards.  Everyone using one of these boards should say
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/amiga/config.c linux-2.6.13/arch/m68k/amiga/config.c
--- linux-2.6.13-i386/arch/m68k/amiga/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/amiga/config.c	2005-10-12 16:31:23.000000000 +0200
@@ -431,9 +431,6 @@
   mach_floppy_setup    = amiga_floppy_setup;
 #endif
   mach_reset           = amiga_reset;
-#ifdef CONFIG_DUMMY_CONSOLE
-  conswitchp           = &dummy_con;
-#endif
 #if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
   mach_beep            = amiga_mksound;
 #endif
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/apollo/config.c linux-2.6.13/arch/m68k/apollo/config.c
--- linux-2.6.13-i386/arch/m68k/apollo/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/apollo/config.c	2005-10-12 16:31:23.000000000 +0200
@@ -176,9 +176,6 @@
 	mach_set_clock_mmss  = dn_dummy_set_clock_mmss; /* */
 	mach_process_int     = dn_process_int;
 	mach_reset	     = dn_dummy_reset;  /* */
-#ifdef CONFIG_DUMMY_CONSOLE
-        conswitchp           = &dummy_con;
-#endif
 #ifdef CONFIG_HEARTBEAT
 	mach_heartbeat = dn_heartbeat;
 #endif
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/atari/config.c linux-2.6.13/arch/m68k/atari/config.c
--- linux-2.6.13-i386/arch/m68k/atari/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/atari/config.c	2005-10-12 16:31:23.000000000 +0200
@@ -247,9 +247,6 @@
 #ifdef CONFIG_ATARI_FLOPPY
     mach_floppy_setup	 = atari_floppy_setup;
 #endif
-#ifdef CONFIG_DUMMY_CONSOLE
-    conswitchp	         = &dummy_con;
-#endif
     mach_max_dma_address = 0xffffff;
 #if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
     mach_beep          = atari_mksound;
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/fpsp040/skeleton.S linux-2.6.13/arch/m68k/fpsp040/skeleton.S
--- linux-2.6.13-i386/arch/m68k/fpsp040/skeleton.S	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/fpsp040/skeleton.S	2005-05-30 16:31:21.000000000 +0200
@@ -381,10 +381,8 @@
 .Lnotkern:
 	SAVE_ALL_INT
 	GET_CURRENT(%d0)
-	tstb	%curptr@(TASK_NEEDRESCHED)
-	jne	ret_from_exception	| deliver signals,
-					| reschedule etc..
-	RESTORE_ALL
+	| deliver signals, reschedule etc..
+	jra	ret_from_exception
 
 |
 |	mem_write --- write to user or supervisor address space
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/hp300/config.c linux-2.6.13/arch/m68k/hp300/config.c
--- linux-2.6.13-i386/arch/m68k/hp300/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/hp300/config.c	2005-10-12 16:31:23.000000000 +0200
@@ -261,9 +261,6 @@
 #ifdef CONFIG_HEARTBEAT
 	mach_heartbeat       = hp300_pulse;
 #endif
-#ifdef CONFIG_DUMMY_CONSOLE
-	conswitchp	     = &dummy_con;
-#endif
 	mach_max_dma_address = 0xffffffff;
 
 	if (hp300_model >= HP_330 && hp300_model <= HP_433S && hp300_model != HP_350) {
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/ifpsp060/iskeleton.S linux-2.6.13/arch/m68k/ifpsp060/iskeleton.S
--- linux-2.6.13-i386/arch/m68k/ifpsp060/iskeleton.S	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/ifpsp060/iskeleton.S	2005-05-30 16:31:22.000000000 +0200
@@ -75,10 +75,8 @@
 .Lnotkern:
 	SAVE_ALL_INT
 	GET_CURRENT(%d0)
-	tstb	%curptr@(TASK_NEEDRESCHED)
-	jne	ret_from_exception	| deliver signals,
-					| reschedule etc..
-	RESTORE_ALL
+	| deliver signals, reschedule etc..
+	jra	ret_from_exception
 
 |
 | _060_real_chk():
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/kernel/asm-offsets.c linux-2.6.13/arch/m68k/kernel/asm-offsets.c
--- linux-2.6.13-i386/arch/m68k/kernel/asm-offsets.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/kernel/asm-offsets.c	2005-05-30 16:31:22.000000000 +0200
@@ -25,12 +25,8 @@
 	DEFINE(TASK_STATE, offsetof(struct task_struct, state));
 	DEFINE(TASK_FLAGS, offsetof(struct task_struct, flags));
 	DEFINE(TASK_PTRACE, offsetof(struct task_struct, ptrace));
-	DEFINE(TASK_WORK, offsetof(struct task_struct, thread.work));
-	DEFINE(TASK_NEEDRESCHED, offsetof(struct task_struct, thread.work.need_resched));
-	DEFINE(TASK_SYSCALL_TRACE, offsetof(struct task_struct, thread.work.syscall_trace));
-	DEFINE(TASK_SIGPENDING, offsetof(struct task_struct, thread.work.sigpending));
-	DEFINE(TASK_NOTIFY_RESUME, offsetof(struct task_struct, thread.work.notify_resume));
 	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
+	DEFINE(TASK_INFO, offsetof(struct task_struct, thread.info));
 	DEFINE(TASK_MM, offsetof(struct task_struct, mm));
 	DEFINE(TASK_ACTIVE_MM, offsetof(struct task_struct, active_mm));
 
@@ -45,6 +41,10 @@
 	DEFINE(THREAD_FPCNTL, offsetof(struct thread_struct, fpcntl));
 	DEFINE(THREAD_FPSTATE, offsetof(struct thread_struct, fpstate));
 
+	/* offsets into the thread_info struct */
+	DEFINE(TINFO_PREEMPT, offsetof(struct thread_info, preempt_count));
+	DEFINE(TINFO_FLAGS, offsetof(struct thread_info, flags));
+
 	/* offsets into the pt_regs */
 	DEFINE(PT_D0, offsetof(struct pt_regs, d0));
 	DEFINE(PT_ORIG_D0, offsetof(struct pt_regs, orig_d0));
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/kernel/bios32.c linux-2.6.13/arch/m68k/kernel/bios32.c
--- linux-2.6.13-i386/arch/m68k/kernel/bios32.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/kernel/bios32.c	2004-10-20 16:38:00.000000000 +0200
@@ -285,7 +285,7 @@
 
 	DBG_DEVS(("layout_bus: starting bus %d\n", bus->number));
 
-	if (!bus->devices && !bus->children)
+	if (list_empty(&bus->devices) && list_empty(&bus->children))
 		return;
 
 	/*
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/kernel/entry.S linux-2.6.13/arch/m68k/kernel/entry.S
--- linux-2.6.13-i386/arch/m68k/kernel/entry.S	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/kernel/entry.S	2005-05-30 16:31:22.000000000 +0200
@@ -44,9 +44,7 @@
 
 #include <asm/offsets.h>
 
-.globl system_call, buserr, trap
-.globl resume, ret_from_exception
-.globl ret_from_signal
+.globl system_call, buserr, trap, resume
 .globl inthandler, sys_call_table
 .globl sys_fork, sys_clone, sys_vfork
 .globl ret_from_interrupt, bad_interrupt
@@ -58,7 +56,7 @@
 	movel	%sp,%sp@-		| stack frame pointer argument
 	bsrl	buserr_c
 	addql	#4,%sp
-	jra	ret_from_exception
+	jra	.Lret_from_exception
 
 ENTRY(trap)
 	SAVE_ALL_INT
@@ -66,7 +64,7 @@
 	movel	%sp,%sp@-		| stack frame pointer argument
 	bsrl	trap_c
 	addql	#4,%sp
-	jra	ret_from_exception
+	jra	.Lret_from_exception
 
 	| After a fork we jump here directly from resume,
 	| so that %d1 contains the previous task
@@ -75,30 +73,31 @@
 	movel	%d1,%sp@-
 	jsr	schedule_tail
 	addql	#4,%sp
-	jra	ret_from_exception
+	jra	.Lret_from_exception
 
-badsys:
-	movel	#-ENOSYS,%sp@(PT_D0)
-	jra	ret_from_exception
-
-do_trace:
+do_trace_entry:
 	movel	#-ENOSYS,%sp@(PT_D0)	| needed for strace
 	subql	#4,%sp
 	SAVE_SWITCH_STACK
 	jbsr	syscall_trace
 	RESTORE_SWITCH_STACK
 	addql	#4,%sp
-	movel	%sp@(PT_ORIG_D0),%d1
-	movel	#-ENOSYS,%d0
-	cmpl	#NR_syscalls,%d1
-	jcc	1f
-	jbsr	@(sys_call_table,%d1:l:4)@(0)
-1:	movel	%d0,%sp@(PT_D0)		| save the return value
-	subql	#4,%sp			| dummy return address
+	movel	%sp@(PT_ORIG_D0),%d0
+	cmpl	#NR_syscalls,%d0
+	jcs	syscall
+badsys:
+	movel	#-ENOSYS,%sp@(PT_D0)
+	jra	ret_from_syscall
+
+do_trace_exit:
+	subql	#4,%sp
 	SAVE_SWITCH_STACK
 	jbsr	syscall_trace
+	RESTORE_SWITCH_STACK
+	addql	#4,%sp
+	jra	.Lret_from_exception
 
-ret_from_signal:
+ENTRY(ret_from_signal)
 	RESTORE_SWITCH_STACK
 	addql	#4,%sp
 /* on 68040 complete pending writebacks if any */
@@ -111,7 +110,7 @@
 	addql	#4,%sp
 1:
 #endif
-	jra	ret_from_exception
+	jra	.Lret_from_exception
 
 ENTRY(system_call)
 	SAVE_ALL_SYS
@@ -120,30 +119,34 @@
 	| save top of frame
 	movel	%sp,%curptr@(TASK_THREAD+THREAD_ESP0)
 
-	tstb	%curptr@(TASK_SYSCALL_TRACE)
-	jne	do_trace
+	| syscall trace?
+	tstb	%curptr@(TASK_INFO+TINFO_FLAGS+2)
+	jmi	do_trace_entry
 	cmpl	#NR_syscalls,%d0
 	jcc	badsys
+syscall:
 	jbsr	@(sys_call_table,%d0:l:4)@(0)
 	movel	%d0,%sp@(PT_D0)		| save the return value
-
+ret_from_syscall:
 	|oriw	#0x0700,%sr
-	movel	%curptr@(TASK_WORK),%d0
+	movew	%curptr@(TASK_INFO+TINFO_FLAGS+2),%d0
 	jne	syscall_exit_work
 1:	RESTORE_ALL
 
 syscall_exit_work:
 	btst	#5,%sp@(PT_SR)		| check if returning to kernel
 	bnes	1b			| if so, skip resched, signals
-	tstw	%d0
-	jeq	do_signal_return
-	tstb	%d0
-	jne	do_delayed_trace
-
+	lslw	#1,%d0
+	jcs	do_trace_exit
+	jmi	do_delayed_trace
+	lslw	#8,%d0
+	jmi	do_signal_return
 	pea	resume_userspace
-	jmp	schedule
+	jra	schedule
+
 
-ret_from_exception:
+ENTRY(ret_from_exception)
+.Lret_from_exception:
 	btst	#5,%sp@(PT_SR)		| check if returning to kernel
 	bnes	1f			| if so, skip resched, signals
 	| only allow interrupts when we are really the last one on the
@@ -152,19 +155,18 @@
 	andw	#ALLOWINT,%sr
 
 resume_userspace:
-	movel	%curptr@(TASK_WORK),%d0
-	lsrl	#8,%d0
+	moveb	%curptr@(TASK_INFO+TINFO_FLAGS+3),%d0
 	jne	exit_work
 1:	RESTORE_ALL
 
 exit_work:
 	| save top of frame
 	movel	%sp,%curptr@(TASK_THREAD+THREAD_ESP0)
-	tstb	%d0
-	jeq	do_signal_return
-
+	lslb	#1,%d0
+	jmi	do_signal_return
 	pea	resume_userspace
-	jmp	schedule
+	jra	schedule
+
 
 do_signal_return:
 	|andw	#ALLOWINT,%sr
@@ -254,7 +256,7 @@
 
 	/* check if we need to do software interrupts */
 	tstl	irq_stat+CPUSTAT_SOFTIRQ_PENDING
-	jeq	ret_from_exception
+	jeq	.Lret_from_exception
 	pea	ret_from_exception
 	jra	do_softirq
 
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/kernel/m68k_ksyms.c linux-2.6.13/arch/m68k/kernel/m68k_ksyms.c
--- linux-2.6.13-i386/arch/m68k/kernel/m68k_ksyms.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/kernel/m68k_ksyms.c	2005-08-30 16:31:36.000000000 +0200
@@ -74,9 +74,6 @@
 EXPORT_SYMBOL(__ashldi3);
 EXPORT_SYMBOL(__ashrdi3);
 EXPORT_SYMBOL(__lshrdi3);
-EXPORT_SYMBOL(memcpy);
-EXPORT_SYMBOL(memset);
-EXPORT_SYMBOL(memcmp);
 EXPORT_SYMBOL(memscan);
 EXPORT_SYMBOL(__muldi3);
 
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/kernel/process.c linux-2.6.13/arch/m68k/kernel/process.c
--- linux-2.6.13-i386/arch/m68k/kernel/process.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/kernel/process.c	2005-08-30 16:31:36.000000000 +0200
@@ -239,7 +239,7 @@
 	unsigned long stack_offset, *retp;
 
 	stack_offset = THREAD_SIZE - sizeof(struct pt_regs);
-	childregs = (struct pt_regs *) ((unsigned long) (p->thread_info) + stack_offset);
+	childregs = (struct pt_regs *) ((unsigned long)p->stack + stack_offset);
 
 	*childregs = *regs;
 	childregs->d0 = 0;
@@ -384,7 +384,7 @@
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_page = (unsigned long)(p->thread_info);
+	stack_page = (unsigned long)p->stack;
 	fp = ((struct switch_stack *)p->thread.ksp)->a6;
 	do {
 		if (fp < stack_page+sizeof(struct thread_info) ||
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/kernel/ptrace.c linux-2.6.13/arch/m68k/kernel/ptrace.c
--- linux-2.6.13-i386/arch/m68k/kernel/ptrace.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/kernel/ptrace.c	2005-06-19 16:32:04.000000000 +0200
@@ -95,7 +95,7 @@
 	if (regno == PT_USP)
 		addr = &task->thread.usp;
 	else if (regno < sizeof(regoff)/sizeof(regoff[0]))
-		addr = (unsigned long *) (task->thread.esp0 + regoff[regno]);
+		addr = (unsigned long *)(task->thread.esp0 + regoff[regno]);
 	else
 		return -1;
 	*addr = data;
@@ -103,48 +103,56 @@
 }
 
 /*
- * Called by kernel/ptrace.c when detaching..
- *
  * Make sure the single step bit is not set.
  */
-void ptrace_disable(struct task_struct *child)
+static inline void singlestep_disable(struct task_struct *child)
 {
-	unsigned long tmp;
-	/* make sure the single step bit is not set. */
-	tmp = get_reg(child, PT_SR) & ~(TRACE_BITS << 16);
+	unsigned long tmp = get_reg(child, PT_SR) & ~(TRACE_BITS << 16);
 	put_reg(child, PT_SR, tmp);
-	child->thread.work.delayed_trace = 0;
-	child->thread.work.syscall_trace = 0;
+	clear_tsk_thread_flag(child, TIF_DELAYED_TRACE);
+}
+
+/*
+ * Called by kernel/ptrace.c when detaching..
+ */
+void ptrace_disable(struct task_struct *child)
+{
+	singlestep_disable(child);
+	clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
 }
 
 asmlinkage int sys_ptrace(long request, long pid, long addr, long data)
 {
 	struct task_struct *child;
-	int ret;
+	unsigned long tmp;
+	int i, ret = 0;
 
 	lock_kernel();
-	ret = -EPERM;
 	if (request == PTRACE_TRACEME) {
 		/* are we already being traced? */
-		if (current->ptrace & PT_PTRACED)
+		if (current->ptrace & PT_PTRACED) {
+			ret = -EPERM;
 			goto out;
+		}
 		/* set the ptrace bit in the process flags. */
 		current->ptrace |= PT_PTRACED;
-		ret = 0;
 		goto out;
 	}
-	ret = -ESRCH;
 	read_lock(&tasklist_lock);
 	child = find_task_by_pid(pid);
 	if (child)
 		get_task_struct(child);
 	read_unlock(&tasklist_lock);
-	if (!child)
+	if (unlikely(!child)) {
+		ret = -ESRCH;
 		goto out;
+	}
 
-	ret = -EPERM;
-	if (pid == 1)		/* you may not mess with init */
+	/* you may not mess with init */
+	if (unlikely(pid == 1)) {
+		ret = -EPERM;
 		goto out_tsk;
+	}
 
 	if (request == PTRACE_ATTACH) {
 		ret = ptrace_attach(child);
@@ -152,234 +160,175 @@
 	}
 
 	ret = ptrace_check_attach(child, request == PTRACE_KILL);
-	if (ret < 0)
+	if (ret)
 		goto out_tsk;
 
 	switch (request) {
 	/* when I and D space are separate, these will need to be fixed. */
-		case PTRACE_PEEKTEXT: /* read word at location addr. */
-		case PTRACE_PEEKDATA: {
-			unsigned long tmp;
-			int copied;
-
-			copied = access_process_vm(child, addr, &tmp, sizeof(tmp), 0);
-			ret = -EIO;
-			if (copied != sizeof(tmp))
-				break;
-			ret = put_user(tmp,(unsigned long *) data);
-			break;
-		}
+	case PTRACE_PEEKTEXT:	/* read word at location addr. */
+	case PTRACE_PEEKDATA:
+		i = access_process_vm(child, addr, &tmp, sizeof(tmp), 0);
+		if (i != sizeof(tmp))
+			goto out_eio;
+		ret = put_user(tmp, (unsigned long *)data);
+		break;
 
 	/* read the word at location addr in the USER area. */
-		case PTRACE_PEEKUSR: {
-			unsigned long tmp;
-
-			ret = -EIO;
-			if ((addr & 3) || addr < 0 ||
-			    addr > sizeof(struct user) - 3)
-				break;
-
-			tmp = 0;  /* Default return condition */
-			addr = addr >> 2; /* temporary hack. */
-			ret = -EIO;
-			if (addr < 19) {
-				tmp = get_reg(child, addr);
-				if (addr == PT_SR)
-					tmp >>= 16;
-			} else if (addr >= 21 && addr < 49) {
-				tmp = child->thread.fp[addr - 21];
-#ifdef CONFIG_M68KFPU_EMU
-				/* Convert internal fpu reg representation
-				 * into long double format
-				 */
-				if (FPU_IS_EMU && (addr < 45) && !(addr % 3))
-					tmp = ((tmp & 0xffff0000) << 15) |
-					      ((tmp & 0x0000ffff) << 16);
-#endif
-			} else
-				break;
-			ret = put_user(tmp,(unsigned long *) data);
-			break;
-		}
-
-      /* when I and D space are separate, this will have to be fixed. */
-		case PTRACE_POKETEXT: /* write the word at location addr. */
-		case PTRACE_POKEDATA:
-			ret = 0;
-			if (access_process_vm(child, addr, &data, sizeof(data), 1) == sizeof(data))
-				break;
-			ret = -EIO;
-			break;
-
-		case PTRACE_POKEUSR: /* write the word at location addr in the USER area */
-			ret = -EIO;
-			if ((addr & 3) || addr < 0 ||
-			    addr > sizeof(struct user) - 3)
-				break;
-
-			addr = addr >> 2; /* temporary hack. */
-
-			if (addr == PT_SR) {
-				data &= SR_MASK;
-				data <<= 16;
-				data |= get_reg(child, PT_SR) & ~(SR_MASK << 16);
-			}
-			if (addr < 19) {
-				if (put_reg(child, addr, data))
-					break;
-				ret = 0;
-				break;
-			}
-			if (addr >= 21 && addr < 48)
-			{
-#ifdef CONFIG_M68KFPU_EMU
-				/* Convert long double format
-				 * into internal fpu reg representation
-				 */
-				if (FPU_IS_EMU && (addr < 45) && !(addr % 3)) {
-					data = (unsigned long)data << 15;
-					data = (data & 0xffff0000) |
-					       ((data & 0x0000ffff) >> 1);
-				}
-#endif
-				child->thread.fp[addr - 21] = data;
-				ret = 0;
-			}
-			break;
-
-		case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
-		case PTRACE_CONT: { /* restart after signal. */
-			long tmp;
-
-			ret = -EIO;
-			if (!valid_signal(data))
-				break;
-			if (request == PTRACE_SYSCALL) {
-					child->thread.work.syscall_trace = ~0;
-			} else {
-					child->thread.work.syscall_trace = 0;
-			}
-			child->exit_code = data;
-			/* make sure the single step bit is not set. */
-			tmp = get_reg(child, PT_SR) & ~(TRACE_BITS << 16);
-			put_reg(child, PT_SR, tmp);
-			child->thread.work.delayed_trace = 0;
-			wake_up_process(child);
-			ret = 0;
-			break;
-		}
-
-/*
- * make the child exit.  Best I can do is send it a sigkill.
- * perhaps it should be put in the status that it wants to
- * exit.
- */
-		case PTRACE_KILL: {
-			long tmp;
-
-			ret = 0;
-			if (child->exit_state == EXIT_ZOMBIE) /* already dead */
-				break;
-			child->exit_code = SIGKILL;
-	/* make sure the single step bit is not set. */
-			tmp = get_reg(child, PT_SR) & ~(TRACE_BITS << 16);
-			put_reg(child, PT_SR, tmp);
-			child->thread.work.delayed_trace = 0;
-			wake_up_process(child);
-			break;
-		}
-
-		case PTRACE_SINGLESTEP: {  /* set the trap flag. */
-			long tmp;
-
-			ret = -EIO;
-			if (!valid_signal(data))
-				break;
-			child->thread.work.syscall_trace = 0;
-			tmp = get_reg(child, PT_SR) | (TRACE_BITS << 16);
-			put_reg(child, PT_SR, tmp);
-			child->thread.work.delayed_trace = 1;
-
-			child->exit_code = data;
-	/* give it a chance to run. */
-			wake_up_process(child);
-			ret = 0;
-			break;
-		}
+	case PTRACE_PEEKUSR:
+		if (addr & 3)
+			goto out_eio;
+		addr >>= 2;	/* temporary hack. */
+
+		if (addr >= 0 && addr < 19) {
+			tmp = get_reg(child, addr);
+			if (addr == PT_SR)
+				tmp >>= 16;
+		} else if (addr >= 21 && addr < 49) {
+			tmp = child->thread.fp[addr - 21];
+			/* Convert internal fpu reg representation
+			 * into long double format
+			 */
+			if (FPU_IS_EMU && (addr < 45) && !(addr % 3))
+				tmp = ((tmp & 0xffff0000) << 15) |
+				      ((tmp & 0x0000ffff) << 16);
+		} else
+			break;
+		ret = put_user(tmp, (unsigned long *)data);
+		break;
+
+	/* when I and D space are separate, this will have to be fixed. */
+	case PTRACE_POKETEXT:	/* write the word at location addr. */
+	case PTRACE_POKEDATA:
+		if (access_process_vm(child, addr, &data, sizeof(data), 1) != sizeof(data))
+			goto out_eio;
+		break;
+
+	case PTRACE_POKEUSR:	/* write the word at location addr in the USER area */
+		if (addr & 3)
+			goto out_eio;
+		addr >>= 2;	/* temporary hack. */
+
+		if (addr == PT_SR) {
+			data &= SR_MASK;
+			data <<= 16;
+			data |= get_reg(child, PT_SR) & ~(SR_MASK << 16);
+		} else if (addr >= 0 && addr < 19) {
+			if (put_reg(child, addr, data))
+				goto out_eio;
+		} else if (addr >= 21 && addr < 48) {
+			/* Convert long double format
+			 * into internal fpu reg representation
+			 */
+			if (FPU_IS_EMU && (addr < 45) && !(addr % 3)) {
+				data = (unsigned long)data << 15;
+				data = (data & 0xffff0000) |
+				       ((data & 0x0000ffff) >> 1);
+			}
+			child->thread.fp[addr - 21] = data;
+		} else
+			goto out_eio;
+		break;
+
+	case PTRACE_SYSCALL:	/* continue and stop at next (return from) syscall */
+	case PTRACE_CONT:	/* restart after signal. */
+		if (!valid_signal(data))
+			goto out_eio;
+
+		if (request == PTRACE_SYSCALL)
+			set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		else
+			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		child->exit_code = data;
+		singlestep_disable(child);
+		wake_up_process(child);
+		break;
 
-		case PTRACE_DETACH:	/* detach a process that was attached. */
-			ret = ptrace_detach(child, data);
+	/*
+	 * make the child exit.  Best I can do is send it a sigkill.
+	 * perhaps it should be put in the status that it wants to
+	 * exit.
+	 */
+	case PTRACE_KILL:
+		if (child->exit_state == EXIT_ZOMBIE) /* already dead */
 			break;
-
-		case PTRACE_GETREGS: { /* Get all gp regs from the child. */
-			int i;
-			unsigned long tmp;
-			for (i = 0; i < 19; i++) {
-			    tmp = get_reg(child, i);
-			    if (i == PT_SR)
+		child->exit_code = SIGKILL;
+		singlestep_disable(child);
+		wake_up_process(child);
+		break;
+
+	case PTRACE_SINGLESTEP:	/* set the trap flag. */
+		if (!valid_signal(data))
+			goto out_eio;
+
+		clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		tmp = get_reg(child, PT_SR) | (TRACE_BITS << 16);
+		put_reg(child, PT_SR, tmp);
+		set_tsk_thread_flag(child, TIF_DELAYED_TRACE);
+
+		child->exit_code = data;
+		/* give it a chance to run. */
+		wake_up_process(child);
+		break;
+
+	case PTRACE_DETACH:	/* detach a process that was attached. */
+		ret = ptrace_detach(child, data);
+		break;
+
+	case PTRACE_GETREGS:	/* Get all gp regs from the child. */
+		for (i = 0; i < 19; i++) {
+			tmp = get_reg(child, i);
+			if (i == PT_SR)
 				tmp >>= 16;
-			    if (put_user(tmp, (unsigned long *) data)) {
-				ret = -EFAULT;
+			ret = put_user(tmp, (unsigned long *)data);
+			if (ret)
 				break;
-			    }
-			    data += sizeof(long);
-			}
-			ret = 0;
-			break;
+			data += sizeof(long);
 		}
+		break;
 
-		case PTRACE_SETREGS: { /* Set all gp regs in the child. */
-			int i;
-			unsigned long tmp;
-			for (i = 0; i < 19; i++) {
-			    if (get_user(tmp, (unsigned long *) data)) {
-				ret = -EFAULT;
+	case PTRACE_SETREGS:	/* Set all gp regs in the child. */
+		for (i = 0; i < 19; i++) {
+			ret = get_user(tmp, (unsigned long *)data);
+			if (ret)
 				break;
-			    }
-			    if (i == PT_SR) {
+			if (i == PT_SR) {
 				tmp &= SR_MASK;
 				tmp <<= 16;
 				tmp |= get_reg(child, PT_SR) & ~(SR_MASK << 16);
-			    }
-			    put_reg(child, i, tmp);
-			    data += sizeof(long);
 			}
-			ret = 0;
-			break;
-		}
-
-		case PTRACE_GETFPREGS: { /* Get the child FPU state. */
-			ret = 0;
-			if (copy_to_user((void *)data, &child->thread.fp,
-					 sizeof(struct user_m68kfp_struct)))
-				ret = -EFAULT;
-			break;
+			put_reg(child, i, tmp);
+			data += sizeof(long);
 		}
+		break;
 
-		case PTRACE_SETFPREGS: { /* Set the child FPU state. */
-			ret = 0;
-			if (copy_from_user(&child->thread.fp, (void *)data,
-					   sizeof(struct user_m68kfp_struct)))
-				ret = -EFAULT;
-			break;
-		}
-
-		default:
-			ret = ptrace_request(child, request, addr, data);
-			break;
+	case PTRACE_GETFPREGS:	/* Get the child FPU state. */
+		if (copy_to_user((void *)data, &child->thread.fp,
+				 sizeof(struct user_m68kfp_struct)))
+			ret = -EFAULT;
+		break;
+
+	case PTRACE_SETFPREGS:	/* Set the child FPU state. */
+		if (copy_from_user(&child->thread.fp, (void *)data,
+				   sizeof(struct user_m68kfp_struct)))
+			ret = -EFAULT;
+		break;
+
+	default:
+		ret = ptrace_request(child, request, addr, data);
+		break;
 	}
 out_tsk:
 	put_task_struct(child);
 out:
 	unlock_kernel();
 	return ret;
+out_eio:
+	ret = -EIO;
+	goto out_tsk;
 }
 
 asmlinkage void syscall_trace(void)
 {
-	if (!current->thread.work.delayed_trace &&
-	    !current->thread.work.syscall_trace)
-		return;
 	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
 				 ? 0x80 : 0));
 	/*
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/kernel/setup.c linux-2.6.13/arch/m68k/kernel/setup.c
--- linux-2.6.13-i386/arch/m68k/kernel/setup.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/kernel/setup.c	2005-10-12 16:31:24.000000000 +0200
@@ -280,6 +280,10 @@
 	    }
 	}
 
+#ifdef CONFIG_DUMMY_CONSOLE
+	conswitchp = &dummy_con;
+#endif
+
 	switch (m68k_machtype) {
 #ifdef CONFIG_AMIGA
 	    case MACH_AMIGA:
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/lib/Makefile linux-2.6.13/arch/m68k/lib/Makefile
--- linux-2.6.13-i386/arch/m68k/lib/Makefile	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/lib/Makefile	2005-08-30 16:31:36.000000000 +0200
@@ -5,4 +5,4 @@
 EXTRA_AFLAGS := -traditional
 
 lib-y		:= ashldi3.o ashrdi3.o lshrdi3.o muldi3.o \
-			checksum.o memcmp.o memcpy.o memset.o semaphore.o
+			checksum.o string.o semaphore.o
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/lib/memcmp.c linux-2.6.13/arch/m68k/lib/memcmp.c
--- linux-2.6.13-i386/arch/m68k/lib/memcmp.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/lib/memcmp.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-#include <linux/types.h>
-
-int memcmp(const void * cs,const void * ct,size_t count)
-{
-  const unsigned char *su1, *su2;
-
-  for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
-    if (*su1 != *su2)
-      return((*su1 < *su2) ? -1 : +1);
-  return(0);
-}
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/lib/memcpy.c linux-2.6.13/arch/m68k/lib/memcpy.c
--- linux-2.6.13-i386/arch/m68k/lib/memcpy.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/lib/memcpy.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-#include <linux/types.h>
-
-void * memcpy(void * to, const void * from, size_t n)
-{
-  void *xto = to;
-  size_t temp, temp1;
-
-  if (!n)
-    return xto;
-  if ((long) to & 1)
-    {
-      char *cto = to;
-      const char *cfrom = from;
-      *cto++ = *cfrom++;
-      to = cto;
-      from = cfrom;
-      n--;
-    }
-  if (n > 2 && (long) to & 2)
-    {
-      short *sto = to;
-      const short *sfrom = from;
-      *sto++ = *sfrom++;
-      to = sto;
-      from = sfrom;
-      n -= 2;
-    }
-  temp = n >> 2;
-  if (temp)
-    {
-      long *lto = to;
-      const long *lfrom = from;
-
-      __asm__ __volatile__("movel %2,%3\n\t"
-			   "andw  #7,%3\n\t"
-			   "lsrl  #3,%2\n\t"
-			   "negw  %3\n\t"
-			   "jmp   %%pc@(1f,%3:w:2)\n\t"
-			   "4:\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "1:\t"
-			   "dbra  %2,4b\n\t"
-			   "clrw  %2\n\t"
-			   "subql #1,%2\n\t"
-			   "jpl   4b\n\t"
-			   : "=a" (lfrom), "=a" (lto), "=d" (temp),
-			   "=&d" (temp1)
-			   : "0" (lfrom), "1" (lto), "2" (temp)
-			   );
-      to = lto;
-      from = lfrom;
-    }
-  if (n & 2)
-    {
-      short *sto = to;
-      const short *sfrom = from;
-      *sto++ = *sfrom++;
-      to = sto;
-      from = sfrom;
-    }
-  if (n & 1)
-    {
-      char *cto = to;
-      const char *cfrom = from;
-      *cto = *cfrom;
-    }
-  return xto;
-}
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/lib/memset.c linux-2.6.13/arch/m68k/lib/memset.c
--- linux-2.6.13-i386/arch/m68k/lib/memset.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/lib/memset.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-#include <linux/types.h>
-
-void * memset(void * s, int c, size_t count)
-{
-  void *xs = s;
-  size_t temp, temp1;
-
-  if (!count)
-    return xs;
-  c &= 0xff;
-  c |= c << 8;
-  c |= c << 16;
-  if ((long) s & 1)
-    {
-      char *cs = s;
-      *cs++ = c;
-      s = cs;
-      count--;
-    }
-  if (count > 2 && (long) s & 2)
-    {
-      short *ss = s;
-      *ss++ = c;
-      s = ss;
-      count -= 2;
-    }
-  temp = count >> 2;
-  if (temp)
-    {
-      long *ls = s;
-
-      __asm__ __volatile__("movel %1,%2\n\t"
-			   "andw  #7,%2\n\t"
-			   "lsrl  #3,%1\n\t"
-			   "negw  %2\n\t"
-			   "jmp   %%pc@(2f,%2:w:2)\n\t"
-			   "1:\t"
-			   "movel %3,%0@+\n\t"
-			   "movel %3,%0@+\n\t"
-			   "movel %3,%0@+\n\t"
-			   "movel %3,%0@+\n\t"
-			   "movel %3,%0@+\n\t"
-			   "movel %3,%0@+\n\t"
-			   "movel %3,%0@+\n\t"
-			   "movel %3,%0@+\n\t"
-			   "2:\t"
-			   "dbra  %1,1b\n\t"
-			   "clrw  %1\n\t"
-			   "subql #1,%1\n\t"
-			   "jpl   1b\n\t"
-			   : "=a" (ls), "=d" (temp), "=&d" (temp1)
-			   : "d" (c), "0" (ls), "1" (temp)
-			   );
-      s = ls;
-    }
-  if (count & 2)
-    {
-      short *ss = s;
-      *ss++ = c;
-      s = ss;
-    }
-  if (count & 1)
-    {
-      char *cs = s;
-      *cs = c;
-    }
-  return xs;
-}
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/lib/string.c linux-2.6.13/arch/m68k/lib/string.c
--- linux-2.6.13-i386/arch/m68k/lib/string.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13/arch/m68k/lib/string.c	2005-08-30 13:26:30.000000000 +0200
@@ -0,0 +1,237 @@
+
+#include <linux/types.h>
+#include <linux/module.h>
+
+void *memset(void *s, int c, size_t count)
+{
+	void *xs = s;
+	size_t temp, temp1;
+
+	if (!count)
+		return xs;
+	c &= 0xff;
+	c |= c << 8;
+	c |= c << 16;
+	if ((long)s & 1) {
+		char *cs = s;
+		*cs++ = c;
+		s = cs;
+		count--;
+	}
+	if (count > 2 && (long)s & 2) {
+		short *ss = s;
+		*ss++ = c;
+		s = ss;
+		count -= 2;
+	}
+	temp = count >> 2;
+	if (temp) {
+		long *ls = s;
+
+		asm volatile (
+			"	movel %1,%2\n"
+			"	andw  #7,%2\n"
+			"	lsrl  #3,%1\n"
+			"	negw  %2\n"
+			"	jmp   %%pc@(2f,%2:w:2)\n"
+			"1:	movel %3,%0@+\n"
+			"	movel %3,%0@+\n"
+			"	movel %3,%0@+\n"
+			"	movel %3,%0@+\n"
+			"	movel %3,%0@+\n"
+			"	movel %3,%0@+\n"
+			"	movel %3,%0@+\n"
+			"	movel %3,%0@+\n"
+			"2:	dbra  %1,1b\n"
+			"	clrw  %1\n"
+			"	subql #1,%1\n"
+			"	jpl   1b"
+			: "=a" (ls), "=d" (temp), "=&d" (temp1)
+			: "d" (c), "0" (ls), "1" (temp));
+		s = ls;
+	}
+	if (count & 2) {
+		short *ss = s;
+		*ss++ = c;
+		s = ss;
+	}
+	if (count & 1) {
+		char *cs = s;
+		*cs = c;
+	}
+	return xs;
+}
+EXPORT_SYMBOL(memset);
+
+void *memcpy(void *to, const void *from, size_t n)
+{
+	void *xto = to;
+	size_t temp, temp1;
+
+	if (!n)
+		return xto;
+	if ((long)to & 1) {
+		char *cto = to;
+		const char *cfrom = from;
+		*cto++ = *cfrom++;
+		to = cto;
+		from = cfrom;
+		n--;
+	}
+	if (n > 2 && (long)to & 2) {
+		short *sto = to;
+		const short *sfrom = from;
+		*sto++ = *sfrom++;
+		to = sto;
+		from = sfrom;
+		n -= 2;
+	}
+	temp = n >> 2;
+	if (temp) {
+		long *lto = to;
+		const long *lfrom = from;
+
+		asm volatile (
+			"	movel %2,%3\n"
+			"	andw  #7,%3\n"
+			"	lsrl  #3,%2\n"
+			"	negw  %3\n"
+			"	jmp   %%pc@(1f,%3:w:2)\n"
+			"4:	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"1:	dbra  %2,4b\n"
+			"	clrw  %2\n"
+			"	subql #1,%2\n"
+			"	jpl   4b"
+			: "=a" (lfrom), "=a" (lto), "=d" (temp), "=&d" (temp1)
+			: "0" (lfrom), "1" (lto), "2" (temp));
+		to = lto;
+		from = lfrom;
+	}
+	if (n & 2) {
+		short *sto = to;
+		const short *sfrom = from;
+		*sto++ = *sfrom++;
+		to = sto;
+		from = sfrom;
+	}
+	if (n & 1) {
+		char *cto = to;
+		const char *cfrom = from;
+		*cto = *cfrom;
+	}
+	return xto;
+}
+EXPORT_SYMBOL(memcpy);
+
+void *memmove(void *dest, const void *src, size_t n)
+{
+	void *xdest = dest;
+	size_t temp;
+
+	if (!n)
+		return xdest;
+
+	if (dest < src) {
+		if ((long)dest & 1) {
+			char *cdest = dest;
+			const char *csrc = src;
+			*cdest++ = *csrc++;
+			dest = cdest;
+			src = csrc;
+			n--;
+		}
+		if (n > 2 && (long)dest & 2) {
+			short *sdest = dest;
+			const short *ssrc = src;
+			*sdest++ = *ssrc++;
+			dest = sdest;
+			src = ssrc;
+			n -= 2;
+		}
+		temp = n >> 2;
+		if (temp) {
+			long *ldest = dest;
+			const long *lsrc = src;
+			temp--;
+			do
+				*ldest++ = *lsrc++;
+			while (temp--);
+			dest = ldest;
+			src = lsrc;
+		}
+		if (n & 2) {
+			short *sdest = dest;
+			const short *ssrc = src;
+			*sdest++ = *ssrc++;
+			dest = sdest;
+			src = ssrc;
+		}
+		if (n & 1) {
+			char *cdest = dest;
+			const char *csrc = src;
+			*cdest = *csrc;
+		}
+	} else {
+		dest = (char *)dest + n;
+		src = (const char *)src + n;
+		if ((long)dest & 1) {
+			char *cdest = dest;
+			const char *csrc = src;
+			*--cdest = *--csrc;
+			dest = cdest;
+			src = csrc;
+			n--;
+		}
+		if (n > 2 && (long)dest & 2) {
+			short *sdest = dest;
+			const short *ssrc = src;
+			*--sdest = *--ssrc;
+			dest = sdest;
+			src = ssrc;
+			n -= 2;
+		}
+		temp = n >> 2;
+		if (temp) {
+			long *ldest = dest;
+			const long *lsrc = src;
+			temp--;
+			do
+				*--ldest = *--lsrc;
+			while (temp--);
+			dest = ldest;
+			src = lsrc;
+		}
+		if (n & 2) {
+			short *sdest = dest;
+			const short *ssrc = src;
+			*--sdest = *--ssrc;
+			dest = sdest;
+			src = ssrc;
+		}
+		if (n & 1) {
+			char *cdest = dest;
+			const char *csrc = src;
+			*--cdest = *--csrc;
+		}
+	}
+	return xdest;
+}
+EXPORT_SYMBOL(memmove);
+
+int memcmp(const void *cs, const void *ct, size_t count)
+{
+	const unsigned char *su1, *su2;
+
+	for (su1 = cs, su2 = ct; count > 0; ++su1, ++su2, count--)
+		if (*su1 != *su2)
+			return *su1 < *su2 ? -1 : +1;
+	return 0;
+}
+EXPORT_SYMBOL(memcmp);
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/mac/config.c linux-2.6.13/arch/m68k/mac/config.c
--- linux-2.6.13-i386/arch/m68k/mac/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/mac/config.c	2005-10-12 16:31:24.000000000 +0200
@@ -212,9 +212,6 @@
 	mach_reset           = mac_reset;
 	mach_halt            = mac_poweroff;
 	mach_power_off       = mac_poweroff;
-#ifdef CONFIG_DUMMY_CONSOLE
-	conswitchp	         = &dummy_con;
-#endif
 	mach_max_dma_address = 0xffffffff;
 #if 0
 	mach_debug_init	 = mac_debug_init;
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/mm/Makefile linux-2.6.13/arch/m68k/mm/Makefile
--- linux-2.6.13-i386/arch/m68k/mm/Makefile	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/mm/Makefile	2004-02-06 14:59:40.000000000 +0100
@@ -2,7 +2,7 @@
 # Makefile for the linux m68k-specific parts of the memory manager.
 #
 
-obj-y		:= init.o fault.o hwtest.o
+obj-y		:= cache.o init.o fault.o hwtest.o
 
 obj-$(CONFIG_MMU_MOTOROLA)	+= kmap.o memory.o motorola.o
 obj-$(CONFIG_MMU_SUN3)		+= sun3kmap.o sun3mmu.o
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/mm/cache.c linux-2.6.13/arch/m68k/mm/cache.c
--- linux-2.6.13-i386/arch/m68k/mm/cache.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.13/arch/m68k/mm/cache.c	2005-08-30 16:31:37.000000000 +0200
@@ -0,0 +1,118 @@
+/*
+ *  linux/arch/m68k/mm/cache.c
+ *
+ *  Instruction cache handling
+ *
+ *  Copyright (C) 1995  Hamish Macdonald
+ */
+
+#include <linux/module.h>
+#include <asm/pgalloc.h>
+#include <asm/traps.h>
+
+
+static unsigned long virt_to_phys_slow(unsigned long vaddr)
+{
+	if (CPU_IS_060) {
+		unsigned long paddr;
+
+		/* The PLPAR instruction causes an access error if the translation
+		 * is not possible. To catch this we use the same exception mechanism
+		 * as for user space accesses in <asm/uaccess.h>. */
+		asm volatile (".chip 68060\n"
+			      "1: plpar (%0)\n"
+			      ".chip 68k\n"
+			      "2:\n"
+			      ".section .fixup,\"ax\"\n"
+			      "   .even\n"
+			      "3: sub.l %0,%0\n"
+			      "   jra 2b\n"
+			      ".previous\n"
+			      ".section __ex_table,\"a\"\n"
+			      "   .align 4\n"
+			      "   .long 1b,3b\n"
+			      ".previous"
+			      : "=a" (paddr)
+			      : "0" (vaddr));
+		return paddr;
+	} else if (CPU_IS_040) {
+		unsigned long mmusr;
+
+		asm volatile (".chip 68040\n\t"
+			      "ptestr (%1)\n\t"
+			      "movec %%mmusr, %0\n\t"
+			      ".chip 68k"
+			      : "=r" (mmusr)
+			      : "a" (vaddr));
+
+		if (mmusr & MMU_R_040)
+			return (mmusr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
+	} else {
+		unsigned short mmusr;
+		unsigned long *descaddr;
+
+		asm volatile ("ptestr %3,%2@,#7,%0\n\t"
+			      "pmove %%psr,%1@"
+			      : "=a&" (descaddr)
+			      : "a" (&mmusr), "a" (vaddr), "d" (get_fs().seg));
+		if (mmusr & (MMU_I|MMU_B|MMU_L))
+			return 0;
+		descaddr = phys_to_virt((unsigned long)descaddr);
+		switch (mmusr & MMU_NUM) {
+		case 1:
+			return (*descaddr & 0xfe000000) | (vaddr & 0x01ffffff);
+		case 2:
+			return (*descaddr & 0xfffc0000) | (vaddr & 0x0003ffff);
+		case 3:
+			return (*descaddr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
+		}
+	}
+	return 0;
+}
+
+/* Push n pages at kernel virtual address and clear the icache */
+/* RZ: use cpush %bc instead of cpush %dc, cinv %ic */
+void flush_icache_range(unsigned long address, unsigned long endaddr)
+{
+
+	if (CPU_IS_040_OR_060) {
+		address &= PAGE_MASK;
+
+		do {
+			asm volatile ("nop\n\t"
+				      ".chip 68040\n\t"
+				      "cpushp %%bc,(%0)\n\t"
+				      ".chip 68k"
+				      : : "a" (virt_to_phys_slow(address)));
+			address += PAGE_SIZE;
+		} while (address < endaddr);
+	} else {
+		unsigned long tmp;
+		asm volatile ("movec %%cacr,%0\n\t"
+			      "orw %1,%0\n\t"
+			      "movec %0,%%cacr"
+			      : "=&d" (tmp)
+			      : "di" (FLUSH_I));
+	}
+}
+EXPORT_SYMBOL(flush_icache_range);
+
+void flush_icache_user_range(struct vm_area_struct *vma, struct page *page,
+			     unsigned long addr, int len)
+{
+	if (CPU_IS_040_OR_060) {
+		asm volatile ("nop\n\t"
+			      ".chip 68040\n\t"
+			      "cpushp %%bc,(%0)\n\t"
+			      ".chip 68k"
+			      : : "a" (page_to_phys(page)));
+	} else {
+		unsigned long tmp;
+		asm volatile ("movec %%cacr,%0\n\t"
+			      "orw %1,%0\n\t"
+			      "movec %0,%%cacr"
+			      : "=&d" (tmp)
+			      : "di" (FLUSH_I));
+	}
+}
+
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/mm/memory.c linux-2.6.13/arch/m68k/mm/memory.c
--- linux-2.6.13-i386/arch/m68k/mm/memory.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/mm/memory.c	2004-10-03 16:35:42.000000000 +0200
@@ -354,110 +354,6 @@
 #endif
 }
 
-static unsigned long virt_to_phys_slow(unsigned long vaddr)
-{
-	if (CPU_IS_060) {
-		mm_segment_t fs = get_fs();
-		unsigned long paddr;
-
-		set_fs(get_ds());
-
-		/* The PLPAR instruction causes an access error if the translation
-		 * is not possible. To catch this we use the same exception mechanism
-		 * as for user space accesses in <asm/uaccess.h>. */
-		asm volatile (".chip 68060\n"
-			      "1: plpar (%0)\n"
-			      ".chip 68k\n"
-			      "2:\n"
-			      ".section .fixup,\"ax\"\n"
-			      "   .even\n"
-			      "3: sub.l %0,%0\n"
-			      "   jra 2b\n"
-			      ".previous\n"
-			      ".section __ex_table,\"a\"\n"
-			      "   .align 4\n"
-			      "   .long 1b,3b\n"
-			      ".previous"
-			      : "=a" (paddr)
-			      : "0" (vaddr));
-		set_fs(fs);
-		return paddr;
-	} else if (CPU_IS_040) {
-		mm_segment_t fs = get_fs();
-		unsigned long mmusr;
-
-		set_fs(get_ds());
-
-		asm volatile (".chip 68040\n\t"
-			      "ptestr (%1)\n\t"
-			      "movec %%mmusr, %0\n\t"
-			      ".chip 68k"
-			      : "=r" (mmusr)
-			      : "a" (vaddr));
-		set_fs(fs);
-
-		if (mmusr & MMU_R_040)
-			return (mmusr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
-	} else {
-		unsigned short mmusr;
-		unsigned long *descaddr;
-
-		asm volatile ("ptestr #5,%2@,#7,%0\n\t"
-			      "pmove %%psr,%1@"
-			      : "=a&" (descaddr)
-			      : "a" (&mmusr), "a" (vaddr));
-		if (mmusr & (MMU_I|MMU_B|MMU_L))
-			return 0;
-		descaddr = phys_to_virt((unsigned long)descaddr);
-		switch (mmusr & MMU_NUM) {
-		case 1:
-			return (*descaddr & 0xfe000000) | (vaddr & 0x01ffffff);
-		case 2:
-			return (*descaddr & 0xfffc0000) | (vaddr & 0x0003ffff);
-		case 3:
-			return (*descaddr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
-		}
-	}
-	return 0;
-}
-
-/* Push n pages at kernel virtual address and clear the icache */
-/* RZ: use cpush %bc instead of cpush %dc, cinv %ic */
-void flush_icache_range(unsigned long address, unsigned long endaddr)
-{
-	if (CPU_IS_040_OR_060) {
-		address &= PAGE_MASK;
-
-		if (address >= PAGE_OFFSET && address < (unsigned long)high_memory) {
-			do {
-				asm volatile ("nop\n\t"
-					      ".chip 68040\n\t"
-					      "cpushp %%bc,(%0)\n\t"
-					      ".chip 68k"
-					      : : "a" (virt_to_phys((void *)address)));
-				address += PAGE_SIZE;
-			} while (address < endaddr);
-		} else {
-			do {
-				asm volatile ("nop\n\t"
-					      ".chip 68040\n\t"
-					      "cpushp %%bc,(%0)\n\t"
-					      ".chip 68k"
-					      : : "a" (virt_to_phys_slow(address)));
-				address += PAGE_SIZE;
-			} while (address < endaddr);
-		}
-	} else {
-		unsigned long tmp;
-		asm volatile ("movec %%cacr,%0\n\t"
-			      "orw %1,%0\n\t"
-			      "movec %0,%%cacr"
-			      : "=&d" (tmp)
-			      : "di" (FLUSH_I));
-	}
-}
-
-
 #ifndef CONFIG_SINGLE_MEMORY_CHUNK
 int mm_end_of_chunk (unsigned long addr, int len)
 {
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/q40/config.c linux-2.6.13/arch/m68k/q40/config.c
--- linux-2.6.13-i386/arch/m68k/q40/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/q40/config.c	2005-10-12 16:31:25.000000000 +0200
@@ -194,9 +194,6 @@
     mach_heartbeat = q40_heartbeat;
 #endif
     mach_halt = q40_halt;
-#ifdef CONFIG_DUMMY_CONSOLE
-    conswitchp = &dummy_con;
-#endif
 
     /* disable a few things that SMSQ might have left enabled */
     q40_disable_irqs();
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/sun3/config.c linux-2.6.13/arch/m68k/sun3/config.c
--- linux-2.6.13-i386/arch/m68k/sun3/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/sun3/config.c	2005-10-12 16:31:25.000000000 +0200
@@ -160,9 +160,6 @@
 	mach_hwclk           =  sun3_hwclk;
 	mach_halt	     =  sun3_halt;
 	mach_get_hardware_list = sun3_get_hardware_list;
-#if defined(CONFIG_DUMMY_CONSOLE)
-	conswitchp	     = &dummy_con;
-#endif
 
 	memory_start = ((((int)&_end) + 0x2000) & ~0x1fff);
 // PROM seems to want the last couple of physical pages. --m
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/arch/m68k/sun3x/config.c linux-2.6.13/arch/m68k/sun3x/config.c
--- linux-2.6.13-i386/arch/m68k/sun3x/config.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/arch/m68k/sun3x/config.c	2005-10-12 16:31:25.000000000 +0200
@@ -71,10 +71,6 @@
 	mach_get_model       = sun3_get_model;
 	mach_get_hardware_list = sun3x_get_hardware_list;
 
-#ifdef CONFIG_DUMMY_CONSOLE
-	conswitchp	     = &dummy_con;
-#endif
-
 	sun3_intreg = (unsigned char *)SUN3X_INTREG;
 
 	/* only the serial console is known to work anyway... */
