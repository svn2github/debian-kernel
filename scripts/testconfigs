#!/usr/bin/python
# testconfigs - test all flavour configs by running oldconfig on them; if it
# hangs for any reason, you're missing some config options.
#
#    Copyright (c) 2005  Andres Salomon <dilinger@debian.org>
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

import os
import glob
import string

class Kernel:
	def __init__(self, root = ''):
		if root:
			self.root = root
		else:
			self.root = '.'  # os.getcwd() may be more portable?

	def is_source_tree(self):
		"""
		Ensure that the current working directory is the root of a
		source tree.
		"""
		try:
			os.stat('%s/scripts/kconfig/conf.c' % self.root)
		except:
			return 0
		return 1

	def is_debianized(self):
		"""
		Determine whether the source tree we're in is a proper
		Debian-ized source tree or not.
		"""
		try:
			os.stat('%s/debian/changelog' % self.root)
			os.stat('%s/debian/control' % self.root)
			os.stat('%s/debian/arch/config' % self.root)
		except:
			return 0
		return 1
	
	def arches(self):
		"""
		Return a list of all architectures that we have (Debian)
		config directories for.
		"""
		base = '%s/debian/arch' % self.root
		testdir = (lambda entry: os.path.isdir(base + '/%s' % entry))
		return filter(testdir, os.listdir(base))
	
	def subarches(self):
		pass  # one of these days we'll implement this..
	
	def flavours(self, arch = ''):
		"""
		Return a list of flavours for a given architecture; or, if none is
		supplied, a list of all flavours for all archs.
		"""
		arches = []
		if arch:
			arches += [ arch ]
		else:
			arches = self.arches()
		
		flavours = []
		for a in arches:
			base = '%s/debian/arch/%s' % (self.root, a)
			flav = glob.glob1(base, 'config.*')
			flavours += [ string.replace(f, 'config.', '') for f in flav ]
		return flavours
	
	def is_valid_dotconfig(self):
		"""
		Test whether there are any options in the kernel kconfig that are not
		answered/set in the existing .config file.
		"""
		c = glob.glob1(self.root, '.config.*')
		if len(c) != 1:
			raise RuntimeError('Cannot find arch/flavour config file')
		a, f = c[0].split('.')[2:4]
		cmd = 'make silentoldconfig ARCH=' + self.to_upstream_arch(a, f)
		if os.system(cmd + ' </dev/null >/dev/null 2>&1') is 0:
			return 1
		return 0
	
	def gen_dotconfig(self, arch, flavour):
		"""
		Create a .config file given an arch and flavour.
		"""
		# XXX: missing subarch support
		map(os.unlink, glob.glob1(self.root, '.config*'))

		base = '%s/debian/arch' % self.root
		fp = open('%s/.config' % self.root, 'w')
		for c in [ '%s/config' % base,
				'%s/%s/config' % (base, arch),
				'%s/%s/config.%s' % (base, arch, flavour) ]:
			if os.path.isfile(c):
				config = open(c, 'r')
				fp.write(config.read())
				config.close()
		fp.close()
		os.link('%s/.config' % self.root,
				'%s/.config.%s.%s' % (self.root, arch, flavour))

	def to_upstream_arch(self, arch, flavour):
		"""
		What debian calls an arch does not always map directly to
		what upstream calls an arch; for example, what we call amd64
		is upstream's x86_64.  Even worse, some of our flavours run
		across multiple upstream arches; for example, our sparc
		flavours are actually upstream's "sparc" and "sparc64" arches.

		This methods takes a debian arch and flavour, and returns the
		corresponding upstream arch.
		"""

		archmap = {
			'amd64': 'x86_64',
			'hppa': 'parisc',
		}
		flavourmap = {
			'sparc64': 'sparc64',
			'sparc64-smp': 'sparc64',
			'powerpc': 'ppc',
			'powerpc-smp': 'ppc',
			'powerpc64': 'ppc64',
		}

		if flavour in flavourmap:
			return flavourmap[flavour]
		if arch in archmap:
			return archmap[arch]
		return arch

if __name__ == '__main__':
	k = Kernel()
	if not k.is_source_tree():
		raise RuntimeError('This script must be run from the top-level of a kernel source tree!')
	for arch in k.arches():
		for flavour in k.flavours(arch):
			k.gen_dotconfig(arch, flavour)
			if not k.is_valid_dotconfig():
				print '[ERROR]: %s flavour (for arch %s) is incomplete!' % (arch, flavour)
			else:
				print "[SUCCESS] arch: %s, flavour: %s" % (arch, flavour)
