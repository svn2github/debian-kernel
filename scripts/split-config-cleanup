#!/bin/sh

set -e
#set -x

scriptname="`basename $0`"
function printhelp() {
	echo 'Usage: $scriptname [options] <config dir> [<flavour>]'
	echo
	echo '  if flavour is omitted then all flavours are found'
	echo '  (flavour is actually a shell pattern, so powerpc* works too)'
	echo
	echo 'Options:'
	echo '  -f|--full  Strip from arch-specific files options defined more generic too'
	echo '             This potentially breaks other arches, so is off by default'
}

function find_duplicate_options() {
	# Scan configfile(s) for kernel options, both defined and undefined
	# Emit options mentioned more than once
	egrep -h '^([^# ]|.* is not set)' "$@" \
		| sed -e 's/[# ]*//' -e 's/[= ].*//' | sort | uniq -d
}

function find_option_values() {
	# Scan configfile(s) for a single kernel option
	# Emit full config lines of each possible setting of the option
	option="$1"
	shift
	grep -h -F "$option" "$@" \
		| sort -u
}

function scan_configfile() {
	file="$1"
	find_duplicate_options "$file" | (
		while read option; do
			find_option_values "$option" "$file" | (
				while read value; do
					echo "duplicate: $option: $value"
				done
			)
		done
	)
}

function strip_duplicate_options() {
	# Strip from bloatfile all but last of each entry on stdin
	bloatfile="$1"
	while read option; do
		tac "$bloatfile" > "$bloatfile.tmp"
		perl -ni -e "print and next unless /^$option[= ]/; \$n++; print if \$n==1;" "$bloatfile.tmp"
		tac "$bloatfile.tmp" > "$bloatfile"
		rm "$bloatfile.tmp"
	done
}

function strip_all_options() {
	# Strip all entries in optionfile from bloatfile
	optionfile="$1"
	bloatfile="$2"
	if [ -s "$bloatfile" ]; then
		mv "$bloatfile" "$bloatfile.tmp"
		grep -F -v -f "$optionfile" "$bloatfile.tmp" > "$bloatfile"
		rm "$bloatfile.tmp"
	fi
}

if [ $# -lt 1 ] || [ $# -gt 2 ]; then
	echo 'ERROR: Wrong number of options provided!'
	echo
	printhelp
	exit 1
fi

full=''
case "$1" in
    -h|--help)
	printhelp
	exit 0
	;;
    -f|--full)
	full="true"
	shift
	;;
esac

configdir="$1"
flavour="$2"

if [ -z "$flavour" ]; then
	flavour="*"
fi

paths="`find "$configdir" -mindepth 2 -maxdepth 2 -name "config.$flavour"`"

if [ -z "$paths" ]; then
	echo 'ERROR: No flavours found (did you provide the correct config dir?)!'
	echo
	printhelp
	exit 1
fi

TMPCONFIG=`mktemp -t "$scriptname.XXXXXX"` || exit 1

for path in $paths; do

## Collect all options: Add them to $options and `sort -u` the list
# Collect all $duplicate_options and `sort -u` the list
# For each of $duplicate_options collect $values_${option} and $value_{0,1,2...}_${option} for each value
# Ask what 

	basedir="$(dirname "$(dirname "$path")")"
	arch="$(basename "$(dirname "$path")")"
	subarch="$(basename "$path" | sed 's/^config\.//')"
	echo -n "cleaning $arch/$subarch..."
	# Cleanup each individual file
	for file in "$basedir/config" "$basedir/$arch/config" "$basedir/$arch/config.$subarch"; do
#		cat "$file" > "$TMPCONFIG"
		scan_configfile "$file"
		# Collect dupes
#		strip_duplicate_options
#		cat "$TMPCONFIG" > "$file"
	done
exit 1
	if [ -n "$full" ]; then
		echo -n '.'
		# Clean subarch file
		cat "$basedir/config" "$basedir/$arch/config" "$basedir/$arch/config.$subarch" > "$TMPCONFIG"
		find_duplicate_options
		strip_all_options
		cat "$TMPCONFIG" > "$basedir/$arch/config.$subarch"
		echo -n '.'
		# Clean arch file
		cat "$basedir/config" "$basedir/$arch/config" > "$TMPCONFIG"
		find_duplicate_options
		strip_all_options
		cat "$TMPCONFIG" > "$basedir/$arch/config"
	fi
	echo ' Done!'
done

rm "$TMPCONFIG" "$TMPDUPES"
