# origin: dilinger (BitKeeper)
# cset: 1.2103 (2.6) key=423bb97clhqMvFL08P6JJ_Jc27TAAA
# URL: http://linux.bkbits.net:8080/linux-2.6/cset@423bb97clhqMvFL08P6JJ_Jc27TAAA
# inclusion: upstream
# descrition: [PATCH] Possible AMD8111e free irq issue
# revision date: Fri, 08 Apr 2005 14:54:47 +0900
#
# S rset: ChangeSet|1.2102..1.2103
# I rset: drivers/net/amd8111e.c|1.30..1.31
#
# Key:
# S: Skipped  ChangeSet file only
# O: Original Followed by Updated
# U: Updated  Included with updated range of versions
# I: Included Included verbatim
# E: Excluded Excluded on request from user
# D: Deleted  Manually deleted by subsequent user edit
# R: Revised  Manually revised by subsequent user edit
#
#
# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2005/03/18 21:32:44-08:00 dilinger@debian.org 
#   [PATCH] Possible AMD8111e free irq issue
#   
#   It seems to me that if in the amd8111e_open() fuction dev->irq isn't
#   zero and the irq request succeeds it might not get released anymore.
#   
#   Specifically, on failure of the amd8111e_restart() call the function
#   returns -ENOMEM without releasing the irq. The amd8111e_restart()
#   function can fail because of various pci_alloc_consistent() and
#   dev_alloc_skb() calls in amd8111e_init_ring() which is being
#   called by amd8111e_restart.
#   
#   1374     if(dev->irq ==0 || request_irq(dev->irq, amd8111e_interrupt, SA_SHIRQ,
#   1375                      dev->name, dev))
#   1376         return -EAGAIN;
#   
#   Signed-off-by: Jeff Garzik <jgarzik@pobox.com>
#   Signed-off-by: Chris Wright <chrisw@osdl.org>
#   Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
# 
# drivers/net/amd8111e.c
#   2005/03/09 20:29:47-08:00 dilinger@debian.org +2 -0
#   Possible AMD8111e free irq issue
# 
#
===== drivers/net/amd8111e.c 1.30 vs 1.31 =====
--- 1.30/drivers/net/amd8111e.c	2005-01-11 01:52:26 +09:00
+++ 1.31/drivers/net/amd8111e.c	2005-03-10 13:29:47 +09:00
@@ -1381,6 +1381,8 @@ static int amd8111e_open(struct net_devi
 
 	if(amd8111e_restart(dev)){
 		spin_unlock_irq(&lp->lock);
+		if (dev->irq)
+			free_irq(dev->irq, dev);
 		return -ENOMEM;
 	}
 	/* Start ipg timer */
