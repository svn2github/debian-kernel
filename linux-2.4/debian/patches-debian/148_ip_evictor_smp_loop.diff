# origin: davem (BitKeeper)
# cset: 1.1449.16.2 (2.4) key=4123c971hKzmQKDWgBjD2OMQ5pd0Jw
# URL: http://linux.bkbits.net:8080/linux-2.4/cset@4123c971hKzmQKDWgBjD2OMQ5pd0Jw
# inclusion: upstream
# descrition: [IPV4]: Fix theoretical loop on SMP in ip_evictor().
# revision date: Tue, 22 Mar 2005 17:54:23 +0900
#
# S rset: ChangeSet|1.1449.16.1..1.1449.16.2
# I rset: net/ipv4/ip_fragment.c|1.8..1.9
#
# Key:
# S: Skipped  ChangeSet file only
# O: Original Followed by Updated
# U: Updated  Included with updated range of versions
# I: Included Included verbatim
# E: Excluded Excluded on request from user
# D: Deleted  Manually deleted by subsequent user edit
# R: Revised  Manually revised by subsequent user edit
#
#
# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/18 14:26:09-07:00 davem@nuts.davemloft.net 
#   [IPV4]: Fix theoretical loop on SMP in ip_evictor().
#   
#   Snapshot the amount of work to do, and just do it.
#   In this way we avoid a theoretical loop whereby
#   one cpu sits in ip_evictor() tossing fragments
#   while another keeps adding a fragment just as we
#   bring ip_frag_mem  down below the low threshold.
#   
#   Signed-off-by: David S. Miller <davem@redhat.com>
# 
# net/ipv4/ip_fragment.c
#   2004/08/18 14:25:49-07:00 davem@nuts.davemloft.net +22 -15
#   [IPV4]: Fix theoretical loop on SMP in ip_evictor().
#   
#   Snapshot the amount of work to do, and just do it.
#   In this way we avoid a theoretical loop whereby
#   one cpu sits in ip_evictor() tossing fragments
#   while another keeps adding a fragment just as we
#   bring ip_frag_mem  down below the low threshold.
#   
#   Signed-off-by: David S. Miller <davem@redhat.com>
# 
#
===== net/ipv4/ip_fragment.c 1.8 vs 1.9 =====
--- 1.8/net/ipv4/ip_fragment.c	2003-05-28 16:49:28 +09:00
+++ 1.9/net/ipv4/ip_fragment.c	2004-08-19 06:25:49 +09:00
@@ -168,14 +168,18 @@ static void ipfrag_secret_rebuild(unsign
 atomic_t ip_frag_mem = ATOMIC_INIT(0);	/* Memory used for fragments */
 
 /* Memory Tracking Functions. */
-static __inline__ void frag_kfree_skb(struct sk_buff *skb)
+static __inline__ void frag_kfree_skb(struct sk_buff *skb, int *work)
 {
+	if (work)
+		*work -= skb->truesize;
 	atomic_sub(skb->truesize, &ip_frag_mem);
 	kfree_skb(skb);
 }
 
-static __inline__ void frag_free_queue(struct ipq *qp)
+static __inline__ void frag_free_queue(struct ipq *qp, int *work)
 {
+	if (work)
+		*work -= sizeof(struct ipq);
 	atomic_sub(sizeof(struct ipq), &ip_frag_mem);
 	kfree(qp);
 }
@@ -194,7 +198,7 @@ static __inline__ struct ipq *frag_alloc
 /* Destruction primitives. */
 
 /* Complete destruction of ipq. */
-static void ip_frag_destroy(struct ipq *qp)
+static void ip_frag_destroy(struct ipq *qp, int *work)
 {
 	struct sk_buff *fp;
 
@@ -206,18 +210,18 @@ static void ip_frag_destroy(struct ipq *
 	while (fp) {
 		struct sk_buff *xp = fp->next;
 
-		frag_kfree_skb(fp);
+		frag_kfree_skb(fp, work);
 		fp = xp;
 	}
 
 	/* Finally, release the queue descriptor itself. */
-	frag_free_queue(qp);
+	frag_free_queue(qp, work);
 }
 
-static __inline__ void ipq_put(struct ipq *ipq)
+static __inline__ void ipq_put(struct ipq *ipq, int *work)
 {
 	if (atomic_dec_and_test(&ipq->refcnt))
-		ip_frag_destroy(ipq);
+		ip_frag_destroy(ipq, work);
 }
 
 /* Kill ipq entry. It is not destroyed immediately,
@@ -242,10 +246,13 @@ static void ip_evictor(void)
 {
 	struct ipq *qp;
 	struct list_head *tmp;
+	int work;
 
-	for(;;) {
-		if (atomic_read(&ip_frag_mem) <= sysctl_ipfrag_low_thresh)
-			return;
+	work = atomic_read(&ip_frag_mem) - sysctl_ipfrag_low_thresh;
+	if (work <= 0)
+		return;
+
+	while (work > 0) {
 		read_lock(&ipfrag_lock);
 		if (list_empty(&ipq_lru_list)) {
 			read_unlock(&ipfrag_lock);
@@ -261,7 +268,7 @@ static void ip_evictor(void)
 			ipq_kill(qp);
 		spin_unlock(&qp->lock);
 
-		ipq_put(qp);
+		ipq_put(qp, &work);
 		IP_INC_STATS_BH(IpReasmFails);
 	}
 }
@@ -293,7 +300,7 @@ static void ip_expire(unsigned long arg)
 	}
 out:
 	spin_unlock(&qp->lock);
-	ipq_put(qp);
+	ipq_put(qp, NULL);
 }
 
 /* Creation primitives. */
@@ -316,7 +323,7 @@ static struct ipq *ip_frag_intern(unsign
 			atomic_inc(&qp->refcnt);
 			write_unlock(&ipfrag_lock);
 			qp_in->last_in |= COMPLETE;
-			ipq_put(qp_in);
+			ipq_put(qp_in, NULL);
 			return qp;
 		}
 	}
@@ -505,7 +512,7 @@ static void ip_frag_queue(struct ipq *qp
 				qp->fragments = next;
 
 			qp->meat -= free_it->len;
-			frag_kfree_skb(free_it);
+			frag_kfree_skb(free_it, NULL);
 		}
 	}
 
@@ -656,7 +663,7 @@ struct sk_buff *ip_defrag(struct sk_buff
 			ret = ip_frag_reasm(qp, dev);
 
 		spin_unlock(&qp->lock);
-		ipq_put(qp);
+		ipq_put(qp, NULL);
 		return ret;
 	}
 
