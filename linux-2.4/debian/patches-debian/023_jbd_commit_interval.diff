# origin: EA/ACL upstream
# cset: n/a
# inclusion: not suitable for mainline
# description: this hunk actually belongs in ea_acl.diff
# revision date: 2004-09-04

diff -urN kernel-source-2.4.26/fs/jbd/journal.c kernel-source-2.4.26-1/fs/jbd/journal.c
--- kernel-source-2.4.26/fs/jbd/journal.c	2004-04-14 23:05:40.000000000 +1000
+++ kernel-source-2.4.26-1/fs/jbd/journal.c	2004-04-11 20:59:07.000000000 +1000
@@ -48,9 +48,7 @@
 EXPORT_SYMBOL(journal_get_undo_access);
 EXPORT_SYMBOL(journal_dirty_data);
 EXPORT_SYMBOL(journal_dirty_metadata);
-#if 0
 EXPORT_SYMBOL(journal_release_buffer);
-#endif
 EXPORT_SYMBOL(journal_forget);
 #if 0
 EXPORT_SYMBOL(journal_sync_buffer);
diff -urN kernel-source-2.4.26/fs/jbd/transaction.c kernel-source-2.4.26-1/fs/jbd/transaction.c
--- kernel-source-2.4.26/fs/jbd/transaction.c	2004-02-19 00:36:31.000000000 +1100
+++ kernel-source-2.4.26-1/fs/jbd/transaction.c	2004-02-22 20:28:31.000000000 +1100
@@ -628,6 +628,7 @@
 	error = 0;
 
 	spin_lock(&journal_datalist_lock);
+	handle->h_last_buffer_credits = 0;
 
 	/* The buffer is already part of this transaction if
 	 * b_transaction or b_next_transaction points to it. */
@@ -646,6 +647,7 @@
 
 		J_ASSERT_JH(jh, handle->h_buffer_credits > 0);
 		handle->h_buffer_credits--;
+		handle->h_last_buffer_credits++;
 		goto done_locked;
 	}
 	
@@ -721,6 +723,7 @@
 
 	J_ASSERT(handle->h_buffer_credits > 0);
 	handle->h_buffer_credits--;
+	handle->h_last_buffer_credits++;
 
 	/* Finally, if the buffer is not journaled right now, we need to
 	 * make sure it doesn't get written to disk before the caller
@@ -1176,41 +1179,30 @@
 	return 0;
 }
 
-#if 0
 /* 
  * journal_release_buffer: undo a get_write_access without any buffer
  * updates, if the update decided in the end that it didn't need access.
  *
  * journal_get_write_access() can block, so it is quite possible for a
  * journaling component to decide after the write access is returned
- * that global state has changed and the update is no longer required.  */
+ * that global state has changed and the update is no longer required.
+ *
+ * We leave the buffer attached to t_reserved_list because even though this
+ * handle doesn't want it, some other concurrent handle may want to journal
+ * this buffer.  If that handle is curently in between get_write_access() and
+ * journal_dirty_metadata() then it expects the buffer to be reserved.  If
+ * we were to rip it off t_reserved_list here, the other handle will explode
+ * when journal_dirty_metadata is presented with a non-reserved buffer.
+ *
+ * If nobody really wants to journal this buffer then it will be thrown
+ * away at the start of commit.
+ */
 
 void journal_release_buffer (handle_t *handle, struct buffer_head *bh)
 {
-	transaction_t *transaction = handle->h_transaction;
-	journal_t *journal = transaction->t_journal;
-	struct journal_head *jh = bh2jh(bh);
-
-	lock_journal(journal);
-	JBUFFER_TRACE(jh, "entry");
-
-	/* If the buffer is reserved but not modified by this
-	 * transaction, then it is safe to release it.  In all other
-	 * cases, just leave the buffer as it is. */
-
-	spin_lock(&journal_datalist_lock);
-	if (jh->b_jlist == BJ_Reserved && jh->b_transaction == transaction &&
-	    !buffer_jdirty(jh2bh(jh))) {
-		JBUFFER_TRACE(jh, "unused: refiling it");
-		handle->h_buffer_credits++;
-		__journal_refile_buffer(jh);
-	}
-	spin_unlock(&journal_datalist_lock);
-
-	JBUFFER_TRACE(jh, "exit");
-	unlock_journal(journal);
+	BUFFER_TRACE(bh, "entry");
+	handle->h_buffer_credits += handle->h_last_buffer_credits;
 }
-#endif
 
 /** 
  * void journal_forget() - bforget() for potentially-journaled buffers.


diff -urN kernel-source-2.4.26/include/linux/jbd.h kernel-source-2.4.26-1/include/linux/jbd.h
--- kernel-source-2.4.26/include/linux/jbd.h	2003-06-14 00:51:38.000000000 +1000
+++ kernel-source-2.4.26-1/include/linux/jbd.h	2004-04-17 13:32:30.000000000 +1000
@@ -359,6 +359,10 @@
 	/* Number of remaining buffers we are allowed to dirty: */
 	int			h_buffer_credits;
 
+	/* Number of credits consumed by the last journal_get_write_access
+	   or get_undo_access operation */
+	int			h_last_buffer_credits;
+
 	/* Reference count on this handle */
 	int			h_ref;
 
