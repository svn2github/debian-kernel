# origin: chrisw (BitKeeper)
# cset: 1.2095 (2.6) key=4233d3c5YkBpjko54dEwE4WPIndnLg
# URL: http://linux.bkbits.net:8080/linux-2.6/cset@4233d3c5YkBpjko54dEwE4WPIndnLg
# inclusion: upstream
# descrition: [PATCH] sis900 kernel oops fix
# revision date: Fri, 08 Apr 2005 14:52:30 +0900
#
# S rset: ChangeSet|1.2094..1.2095
# R rset: drivers/net/sis900.c|1.62..1.63
#
# Key:
# S: Skipped  ChangeSet file only
# O: Original Followed by Updated
# U: Updated  Included with updated range of versions
# I: Included Included verbatim
# E: Excluded Excluded on request from user
# D: Deleted  Manually deleted by subsequent user edit
# R: Revised  Manually revised by subsequent user edit
#
#
# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2005/03/12 21:46:45-08:00 chrisw@osdl.org 
#   [PATCH] sis900 kernel oops fix
#   
#   Backport of fix described below.
#   
#     From: Herbert Xu <herbert@gondor.apana.org.au>
#   
#     Fix bug #4223.
#   
#     OK, this happened because we got preempted before sis900_mii_probe
#     finished setting the sis_priv->mii.  Theoretically this can happen
#     with SMP as well but I suppose the number of SMP machines with sis900
#     is fairly small.
#   
#     Anyway, the fix is to make sure that sis900_mii_probe is done before
#     the device can be opened.  This patch does it by moving the setup
#     before register_netdevice.
#   
#     Since the netdev name is not available before register_netdev, I've
#     changed the relevant printk's to use pci_name instead.  Note that
#     one of those printk's may be called after register_netdev as well.
#   
#   Signed-off-by: Chris Wright <chrisw@osdl.org>
#   Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
# 
# drivers/net/sis900.c
#   2005/03/10 12:23:49-08:00 chrisw@osdl.org +14 -16
#   sis900 kernel oops fix
# 
#
--- a/drivers/net/sis900.c	2004-08-08 08:26:05.000000000 +0900
+++ b/drivers/net/sis900.c	2005-04-13 15:21:47.000000000 +0900
@@ -233,7 +233,7 @@ static int __devinit sis900_get_mac_addr
 	signature = (u16) read_eeprom(ioaddr, EEPROMSignature);    
 	if (signature == 0xffff || signature == 0x0000) {
 		printk (KERN_INFO "%s: Error EERPOM read %x\n", 
-			net_dev->name, signature);
+			pci_name(pci_dev), signature);
 		return 0;
 	}
 
@@ -264,7 +264,8 @@ static int __devinit sis630e_get_mac_add
 	if (!isa_bridge) {
 		isa_bridge = pci_find_device(PCI_VENDOR_ID_SI, 0x0018, isa_bridge);
 		if (!isa_bridge) {
-			printk("%s: Can not find ISA bridge\n", net_dev->name);
+			printk(KERN_WARNING "%s: Can not find ISA bridge\n",
+				pci_name(pci_dev));
 			return 0;
 		}
 	}
@@ -449,10 +450,6 @@ static int __devinit sis900_probe (struc
 	net_dev->tx_timeout = sis900_tx_timeout;
 	net_dev->watchdog_timeo = TX_TIMEOUT;
 	net_dev->ethtool_ops = &sis900_ethtool_ops;
-	
-	ret = register_netdev(net_dev);
-	if (ret)
-		goto err_unmap_rx;
 		
 	/* Get Mac address according to the chip revision */
 	pci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &revision);
@@ -469,7 +466,7 @@ static int __devinit sis900_probe (struc
 
 	if (ret == 0) {
 		ret = -ENODEV;
-		goto err_out_unregister;
+		goto err_unmap_rx;
 	}
 	
 	/* 630ET : set the mii access mode as software-mode */
@@ -479,7 +476,7 @@ static int __devinit sis900_probe (struc
 	/* probe for mii transceiver */
 	if (sis900_mii_probe(net_dev) == 0) {
 		ret = -ENODEV;
-		goto err_out_unregister;
+		goto err_unmap_rx;
 	}
 
 	/* save our host bridge revision */
@@ -487,6 +484,10 @@ static int __devinit sis900_probe (struc
 	if (dev)
 		pci_read_config_byte(dev, PCI_CLASS_REVISION, &sis_priv->host_bridge_rev);
 
+	ret = register_netdev(net_dev);
+	if (ret)
+		goto err_unmap_rx;
+
 	/* print some information about our NIC */
 	printk(KERN_INFO "%s: %s at %#lx, IRQ %d, ", net_dev->name,
 	       card_name, ioaddr, net_dev->irq);
@@ -496,8 +497,6 @@ static int __devinit sis900_probe (struc
 
 	return 0;
 
- err_out_unregister:
- 	unregister_netdev(net_dev);
  err_unmap_rx:
 	pci_free_consistent(pci_dev, RX_TOTAL_SIZE, sis_priv->rx_ring,
 		sis_priv->rx_ring_dma);
@@ -524,6 +523,7 @@ static int __devinit sis900_probe (struc
 static int __init sis900_mii_probe (struct net_device * net_dev)
 {
 	struct sis900_private * sis_priv = net_dev->priv;
+	const char *dev_name = pci_name(sis_priv->pci_dev);
 	u16 poll_bit = MII_STAT_LINK, status = 0;
 	unsigned long timeout = jiffies + 5 * HZ;
 	int phy_addr;
@@ -573,18 +573,17 @@ static int __init sis900_mii_probe (stru
 					mii_phy->phy_types =
 						(mii_status & (MII_STAT_CAN_TX_FDX | MII_STAT_CAN_TX)) ? LAN : HOME;
 				printk(KERN_INFO "%s: %s transceiver found at address %d.\n",
-				       net_dev->name, mii_chip_table[i].name, phy_addr);
+				       dev_name, mii_chip_table[i].name, phy_addr);
 				break;
 			}
 			
 		if( !mii_chip_table[i].phy_id1 )
 			printk(KERN_INFO "%s: Unknown PHY transceiver found at address %d.\n",
-			       net_dev->name, phy_addr);			
+			       dev_name, phy_addr);			
 	}
 	
 	if (sis_priv->mii == NULL) {
-		printk(KERN_INFO "%s: No MII transceivers found!\n",
-		       net_dev->name);
+		printk(KERN_INFO "%s: No MII transceivers found!\n", dev_name);
 		return 0;
 	}
 
@@ -608,7 +607,8 @@ static int __init sis900_mii_probe (stru
 			schedule_timeout(0);
 			poll_bit ^= (mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS) & poll_bit);
 			if (time_after_eq(jiffies, timeout)) {
-				printk(KERN_WARNING "%s: reset phy and link down now\n", net_dev->name);
+				printk(KERN_WARNING "%s: reset phy and link down now\n", 
+						dev_name);
 				return -ETIME;
 			}
 		}
@@ -671,7 +671,7 @@ static u16 sis900_default_phy(struct net
 	if( sis_priv->mii != default_phy ){
 		sis_priv->mii = default_phy;
 		sis_priv->cur_phy = default_phy->phy_addr;
-		printk(KERN_INFO "%s: Using transceiver found at address %d as default\n", net_dev->name,sis_priv->cur_phy);
+		printk(KERN_INFO "%s: Using transceiver found at address %d as default\n", pci_name(sis_priv->pci_dev), sis_priv->cur_phy);
 	}
 	
 	status = mdio_read(net_dev, sis_priv->cur_phy, MII_CONTROL);
