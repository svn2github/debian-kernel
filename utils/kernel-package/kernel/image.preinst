#! /usr/bin/perl
#                              -*- Mode: Cperl -*-
# image.preinst ---
# Author           : Manoj Srivastava ( srivasta@tiamat.datasync.com )
# Created On       : Sun Jun 14 03:38:02 1998
# Created On Node  : tiamat.datasync.com
# Last Modified By : Manoj Srivastava
# Last Modified On : Thu Sep 22 14:01:04 2005
# Last Machine Used: glaurung.internal.golden-gryphon.com
# Update Count     : 72
# Status           : Unknown, Use with caution!
# HISTORY          :
# Description      :
#
#

#
#use strict; #for debugging

$|=1;

# Predefined values:
my $version         = "=V";
my $link_in_boot   = "=B";     # Should be empty, mostly
my $no_symlink      = "=S";     # Should be empty, mostly
my $reverse_symlink = "=R";     # Should be empty, mostly
my $do_symlink     = "Yes";	# target machine defined
my $do_boot_enable  = "Yes";	# target machine defined
my $do_bootfloppy   = "Yes";	# target machine defined
my $do_bootloader   = "Yes";	# target machine defined
my $move_image      = '';       # target machine defined
my $mkimage         = "=M";     # command to generate the initrd image
my $do_initrd       = '';       # target machine defined
my $warn_initrd     = 'YES';    # target machine defined
my $kimage          = "=K";     # Should be empty, mostly
my $loader          = "=L";     # lilo, silo, quik, palo, vmelilo, nettrom
                                # or elilo
my $image_dir       = "=D";     # where the image is located
my $clobber_modules = '';       # target machine defined
my $initrd          = "=I";     # initrd kernel
my $use_hard_links  = '';       # hardlinks do not wirk across fs boundaries
my $postinst_hook   = '';       #Normally we do not
my $postrm_hook     = '';       #Normally we do not
my $preinst_hook    = '';       #Normally we do not
my $prerm_hook      = '';       #Normally we do not
my $minimal_swap    = '';       # Do not swap symlinks
my $ignore_depmod_err = '';    # normally we do not
my $relink_src_link   = 'YES';	# There is no harm in checking the link
my $relink_build_link = 'YES'; # There is no harm in checking the link
my $force_build_link  = '';	 # There is no harm in checking the link
my $official_image    = "=OF"; # only true for official images
my $arch              = "=A";  #  should be same as dpkg --print-installation-architecture
my $kernel_arch       = "=B";
my $ramdisk	      = "/usr/sbin/mkinitrd /usr/sbin/mkinitrd.yaird /usr/sbin/mkinitramfs";

my $Loader          = "NoLOADER"; #
$Loader             = "LILO"     if $loader =~ /^lilo/io;
$Loader             = "SILO"     if $loader =~ /^silo/io;
$Loader             = "QUIK"     if $loader =~ /^quik/io;
$Loader             = "yaboot"   if $loader =~ /^yaboot/io;
$Loader             = "PALO"     if $loader =~ /^palo/io;
$Loader             = "NETTROM"  if $loader =~ /^nettrom/io;
$Loader             = "VMELILO"  if $loader =~ /^vmelilo/io;
$Loader             = "ZIPL"     if $loader =~ /^zipl/io;
$Loader             = "ELILO"    if $loader =~ /^elilo/io;


#known variables
my @boilerplate     = ();
my @silotemplate    = ();
my @quiktemplate    = ();
my @palotemplate    = ();
my @vmelilotemplate = ();
my $bootdevice      = '';
my $rootdevice      = '';
my $rootdisk        = '';
my $rootpartition   = '';
my $image_dest      = "/";
my $realimageloc    = "/$image_dir/";
my $have_conffile   = "";
my $CONF_LOC        = '/etc/kernel-img.conf';
my $relative_links  = '';
my $silent_modules  = '';
my $silent_loader   = '';
my $modules_base    = '/lib/modules';

die "Pre inst Internal error. Aborting." unless $version;

exit 0 if $ARGV[0] =~ /abort-upgrade/;
exit 1 unless $ARGV[0] =~ /(install|upgrade)/;

# Official images may silently upgrade
if ($official_image =~ /^\s*YES\s*$/o
    && ($ARGV[0] =~ /upgrade/ || $arch =~ m/powerpc/)) {
    $silent_modules = 'Yes';
  }

# remove multiple leading slashes; make sure there is at least one.
$realimageloc  =~ s|^/*|/|o;
$realimageloc  =~ s|/+|/|o;

if (-r "$CONF_LOC" && -f "$CONF_LOC"  ) {
  if (open(CONF, "$CONF_LOC")) {
    while (<CONF>) {
      chomp;
      s/\#.*$//g;
      next if /^\s*$/;

      $do_symlink      = "" if /do_symlinks\s*=\s*(no|false|0)\s*$/ig;
      $no_symlink      = "" if /no_symlinks\s*=\s*(no|false|0)\s*$/ig;
      $reverse_symlink = "" if /reverse_symlinks\s*=\s*(no|false|0)\s*$/ig;
      $link_in_boot    = "" if /image_in_boot\s*=\s*(no|false|0)\s*$/ig;
      $link_in_boot    = "" if /link_in_boot\s*=\s*(no|false|0)\s*$/ig;
      $move_image      = "" if /move_image\s*=\s*(no|false|0)\s*$/ig;
      $clobber_modules = '' if /clobber_modules\s*=\s*(no|false|0)\s*$/ig;
      $do_boot_enable  = '' if /do_boot_enable\s*=\s*(no|false|0)\s*$/ig;
      $do_bootfloppy   = '' if /do_bootfloppy\s*=\s*(no|false|0)\s*$/ig;
      $do_bootloader   = '' if /do_bootloader\s*=\s*(no|false|0)\s*$/ig;
      $do_initrd       = '' if /do_initrd\s*=\s*(no|false|0)\s*$/ig;
      $warn_initrd     = '' if /warn_initrd\s*=\s*(no|false|0)\s*$/ig;
      $relative_links  = '' if /relative_links \s*=\s*(no|false|0)\s*$/ig;
      $use_hard_links  = '' if /use_hard_links\s*=\s*(no|false|0)\s*$/ig;
      $silent_modules  = '' if /silent_modules\s*=\s*(no|false|0)\s*$/ig;
      $silent_loader   = '' if /silent_loader\s*=\s*(no|false|0)\s*$/ig;
      $minimal_swap    = '' if /minimal_swap\s*=\s*(no|false|0)\s*$/ig;
      $ignore_depmod_err = '' if /ignore_depmod_err\s*=\s*(no|false|0)\s*$/ig;
      $relink_src_link   = '' if /relink_src_link\s*=\s*(no|false|0)\s*$/ig;
      $relink_build_link = '' if /relink_build_link\s*=\s*(no|false|0)\s*$/ig;
      $force_build_link = '' if /force_build_link\s*=\s*(no|false|0)\s*$/ig;

      $do_symlink      = "Yes" if /do_symlinks\s*=\s*(yes|true|1)\s*$/ig;
      $no_symlink      = "Yes" if /no_symlinks\s*=\s*(yes|true|1)\s*$/ig;
      $reverse_symlink = "Yes" if /reverse_symlinks\s*=\s*(yes|true|1)\s*$/ig;
      $link_in_boot    = "Yes" if /image_in_boot\s*=\s*(yes|true|1)\s*$/ig;
      $link_in_boot    = "Yes" if /link_in_boot\s*=\s*(yes|true|1)\s*$/ig;
      $move_image      = "Yes" if /move_image\s*=\s*(yes|true|1)\s*$/ig;
      $clobber_modules = "Yes" if /clobber_modules\s*=\s*(yes|true|1)\s*$/ig;
      $do_boot_enable  = "Yes" if /do_boot_enable\s*=\s*(yes|true|1)\s*$/ig;
      $do_bootfloppy   = "Yes" if /do_bootfloppy\s*=\s*(yes|true|1)\s*$/ig;
      $do_bootloader   = "Yes" if /do_bootloader\s*=\s*(yes|true|1)\s*$/ig;
      $relative_links  = "Yes" if /relative_links\s*=\s*(yes|true|1)\s*$/ig;
      $do_initrd       = "Yes" if /do_initrd\s*=\s*(yes|true|1)\s*$/ig;
      $warn_initrd     = "Yes" if /warn_initrd\s*=\s*(yes|true|1)\s*$/ig;
      $use_hard_links  = "Yes" if /use_hard_links\s*=\s*(yes|true|1)\s*$/ig;
      $silent_modules  = 'Yes' if /silent_modules\s*=\s*(yes|true|1)\s*$/ig;
      $silent_loader   = 'Yes' if /silent_loader\s*=\s*(yes|true|1)\s*$/ig;
      $minimal_swap    = 'Yes' if /minimal_swap\s*=\s*(yes|true|1)\s*$/ig;
      $ignore_depmod_err = 'Yes' if /ignore_depmod_err\s*=\s*(yes|true|1)\s*$/ig;
      $relink_src_link   = 'Yes' if /relink_src_link\s*=\s*(yes|true|1)\s*$/ig;
      $relink_build_link = 'Yes' if /relink_build_link\s*=\s*(yes|true|1)\s*$/ig;
      $force_build_link = 'Yes' if /force_build_link\s*=\s*(yes|true|1)\s*$/ig;

      $image_dest      = "$1"  if /image_dest\s*=\s*(\S+)/ig;
      $postinst_hook   = "$1"  if /postinst_hook\s*=\s*(\S+)/ig;
      $postrm_hook     = "$1"  if /postrm_hook\s*=\s*(\S+)/ig;
      $preinst_hook    = "$1"  if /preinst_hook\s*=\s*(\S+)/ig;
      $prerm_hook      = "$1"  if /prerm_hook\s*=\s*(\S+)/ig;
      $mkimage         = "$1"  if /mkimage\s*=\s*(.+)$/ig;
      $ramdisk         = "$1"  if /ramdisk\s*=\s*(.+)/ig;
    }
    close CONF;
    $have_conffile = "Yes";
    $have_conffile = "Yes";	# stop perl complaining
  }
}

if ($do_initrd)    {   $warn_initrd = '';   }
if (!$warn_initrd) {   $do_initrd   = "YES";}

$ENV{KERNEL_ARCH}=$kernel_arch if $kernel_arch;


# About to upgrade this package from version $2 TO THIS VERSION.
# "prerm upgrade" has already been called for the old version of
# this package.

# For some versions of kernel-package, we had this warning in the
# postinst, but the rules did not really interpolate the value in.
# Here is a sanity check.
my $pattern = "=" . "I";
$initrd=~ s/^$pattern$//;

if ($initrd) {
  chomp (my $hostversion = `uname -r`);
  my @ramdisklist =
    grep {
      my $ret = system ("$_ --supported-host-version=$hostversion --supported-target-version=$version 1>/dev/null 2>&1");
      -x and (
        $ret == 0 or (
	  $ret == 1 and (
            (($_ eq "/usr/sbin/mkinitrd") and
	     (system ("dpkg", "--compare-versions", "$version", "lt", "2.6.13") == 0)) or
            (($_ eq "/usr/sbin/mkinitramfs") and
	     (system ("dpkg", "--compare-versions", "$version", "lt", "2.6.12") == 1)) or
            (($_ eq "/usr/sbin/mkinitrd.yaird") and
	     (system ("dpkg", "--compare-versions", "$version", "lt", "2.6.8") == 1) and
	     (system ("dpkg", "--compare-versions", "$hostversion", "lt", "2.6.8") == 1))
	  )
	)
      )
    }
    (split (/ /, $ramdisk));

  my $ramdiskorig = $ramdisk;
  $ramdisk = shift @ramdisklist;

  if (! -e $ramdisk) {
    print STDERR <<EOERROR;

You are attempting to install an initrd kernel image (version
$version) while running a kernel of version $hostversion, but
you have no suitable ramdisk generation tool installed among 
$ramdiskorig.  This will break the installation, unless a
suitable ramdisk generation tool is also being installed right
now.

EOERROR
  ;
    warn "Could not find $ramdisk.";
  }
}


if ($initrd && !$do_initrd) {
    print STDERR <<EOF;

You are attempting to install an initrd kernel image (version $version)
This will not work unless you have configured your boot loader to use
initrd. (An initrd image is a kernel image that expects to use an INITial
Ram Disk to mount a minimal root file system into RAM and use that for
booting).

EOF
    if ($loader =~ m/^lilo/i) {
      print STDERR "   As a reminder, in order to configure LILO, you need\n";
      print STDERR "   to add an 'initrd=/initrd.img' to the image=/vmlinuz\n";
      print STDERR "   stanza of your /etc/lilo.conf\n";
    }
    elsif ($loader =~ m/^elilo/i) {
      print STDERR "   As a reminder, in order to configure ELILO, you need\n";
      print STDERR "   to add an 'initrd=/initrd.img' to the image=/vmlinuz\n";
      print STDERR "   stanza of your /etc/elilo.conf\n";
    }
    print STDERR <<EOF;

I repeat, You need to configure your boot loader -- please read your
bootloader documentation for details on how to add initrd images.

If you have already done so, and you wish to get rid of this message,
please put
  "do_initrd = Yes"
in /etc/kernel-img.conf. Note that this is optional, but if you do not,
you will continue to see this message whenever you install a kernel
image using initrd.
EOF
    if (-f "/etc/lilo.conf"){
      my $ramdisk_found = 0;
      open (CONF, "/etc/lilo.conf")  or warn "Can't open /etc/lilo.conf: $!";
      while (<CONF>) {
	chomp;
	if (m/^(\s*ramdisk\s*=\s*0)/g) {
	  print STDERR
	    "In addition, the line\n\t\"$1\"\nshould be removed or commented.";
	  last;
	}
      }
      close CONF;
    }
    print STDERR "Do you want to stop now? [Y/n]";
    my $answer = <STDIN>;
    $answer =~ s/^\s+//;
    $answer =~ s/\s+$//;
    print STDERR "Ok, Aborting\n" unless $answer =~ /^n/i;
    exit 1 unless  $answer =~ /^n/i;
}


sub check {
  my $version = shift;
  my $lib_modules="$modules_base/$version";

  if (-d "$lib_modules") {
    opendir(DIR, $lib_modules) || die "can’t opendir $lib_modules: $!";
    my @children = readdir(DIR);
    if ($#children == 1)          { return 1; } # empty dir
    if ($#children  > 2)          { return 0; } # ., .., build are OK

    my @dirs  = grep { -d "$lib_modules/$_" } @children;
    if ($#dirs > 1)               { return 0; } # we have subdirs

    my @links = grep { -l "$lib_modules/$_" } @children;
    if ($#links == 0) {
      if ($links[0] =~ /^build$/) { return 1; } # has build symlink, is all.
      else                        { return 0; } # Bad name
    }
    elsif ($#links > -1)          { return 0; } # spurious symlinks

    my @files = grep { -f "$lib_modules/$_" } @children;
    if ($#files > -1)             { return 0; } # Should only have a symlink
  }
  else                            { return 1; } # No such dir
  return 0;                                     # Should not get here
}

# If this is an official image, and only a build symlink exists, allow
# it to be clobbered.
if ($official_image =~ /^\s*YES\s*$/o && check($version)) { 
  $silent_modules = 'YES';
  if (-d "$modules_base/$version" && -l "$modules_base/$version/build" ) {
    rename("$modules_base/$version/build", "$modules_base/$version/build.save") ||
      die "failed to move $modules_base/$version/build:$!";
  }
}

if (-d "$modules_base/$version") {
  if ($clobber_modules) {
    my $ret = system("mv $modules_base/$version $modules_base/${version}_$$");
    if ($ret) {
      print STDERR <<EOF;
You are attempting to install a kernel image (version $version)
However, the directory $modules_base/$version still exists.

As you have instructed, an attempt was made to move the directory out
of the way. Unfortunately, There was a problem moving
$modules_base/$version to $modules_base/${version}_$$.

I suggest you move $modules_base/$version out of the way manually,
and then try re-installing this image.

I am aborting.
EOF
      ;
      exit 1;
    }
  }
  elsif ($silent_modules !~ m/YES/i) {
    print STDERR <<EOF;
You are attempting to install a kernel image (version $version)
However, the directory $modules_base/$version still exists.  If this
directory belongs to a previous =ST-image-$version package, and if
you have deselected some modules, or installed standalone modules
packages, this could be bad. However, if this directory exists because
you are also installing some stand alone modules right now, and they
got unpacked before I did, then this is pretty benign.  Unfortunately,
I can not tell the difference.

If $modules_base/$version belongs to a old install of
=ST-image-$version, then this is your last chance to abort the
installation of this kernel image (nothing has been changed yet).

If this directory is because of stand alone modules being installed
right now, or if it does belong to an older =ST-image-$version
package but you know what you are doing, and if you feel that this
image should be installed despite this anomaly, Please answer n to the
question.

Otherwise, I suggest you move $modules_base/$version out of the way,
perhaps to $modules_base/$version.old or something, and then try
re-installing this image.
EOF
  ;
    print STDERR "Do you want to stop now? [Y/n]";
    my $answer = <STDIN>;
    $answer =~ s/^\s+//;
    $answer =~ s/\s+$//;
    print STDERR "Ok, Aborting\n" unless $answer =~ /^n/i;
    exit 1 unless  $answer =~ /^n/i;
  }
  else {
    print STDERR <<EOF;
The directory $modules_base/$version still exists. Continuing as directed.
EOF
  ;
  }
}

if ( -f "$modules_base/$version/modules.dep" ) {
  my $running = '';
  chop($running=`uname -r`);
  if ($running eq $version) {
    print STDERR <<"EOFERR";

 You are attempting to install a kernel version that is the same as
 the version you are currently running (version $running). The modules
 list is quite likely to have been changed, and the modules dependency
 file $modules_base/$version/modules.dep needs to be re-built. It can
 not be built correctly right now, since the module list for the
 running kernel are likely to be different from the kernel installed.
 I am creating a new modules.dep file, but that may not be
 correct. It shall be regenerated correctly at next reboot.

 I repeat: you have to reboot in order for the modules file to be
 created correctly. Until you reboot, it may be impossible to load
 some modules. Reboot as soon as this install is finished (Do not
 reboot right now, since you may not be able to boot back up until
 installation is over, but boot immediately after). I can not stress
 that too much. You need to reboot soon.

EOFERR
    ;
    if ($silent_modules !~ m/YES/i) {
      my $answer='';
      print "Please Hit return to continue.  ";
      $answer=<STDIN>;
    }
  }
}



## Run user hook script here, if any
if (-x "$preinst_hook") {
    system ("$preinst_hook", $version, $realimageloc . "$kimage-$version") &&
	die "User hook script $preinst_hook failed";
}
if (-d "/etc/kernel/preinst.d") {
  system ("run-parts", "--verbose", "--exit-on-error", "--arg=$version",
          "--arg=$realimageloc" . "$kimage-$version",
          "/etc/kernel/preinst.d") &&
            die "Failed to process /etc/kernel/preinst.d";
}
if (-d "/etc/kernel/preinst.d/$version") {
  system ("run-parts", "--verbose", "--exit-on-error", "--arg=$version",
          "--arg=$realimageloc" . "$kimage-$version",
          "/etc/kernel/preinst.d/$version") &&
            die "Failed to process /etc/kernel/preinst.d/$version";
}

exit 0
