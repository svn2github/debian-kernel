<section id="spec">
  <title>Goals, features, to do</title>
  <para>
    The purpose in life of a tool like <application>Yaird</application>
    is to produce an initial boot image that loads the required modules
    to allow a booting kernel to access the root file system and from
    there use the startup scripts to get to the default run level.
    This means that hardly any drivers need to be compiled into the kernel
    itself, so a distribution can produce a kernel with a large amount of
    modules that will run unchanged on practically any hardware, without
    introducing a large number of unused drivers that would waste RAM.
    In a sense, the initial boot image customises the kernel to the hardware
    it happens to be running on.
  </para>

  <para>
    That purpose still leaves a lot of room to optimise for different
    goals: as an example, you could attempt to make the generated
    image as small as possible, or you could attempt to make the
    generated image so flexible that it will boot on any hardware.
    This chapter discusses the goals that determined the design, the
    resulting features, and what's still left to do.
  </para>

  <para>
    The goals<footnote>
      <para>
	Well, not really.  I started this thingy to show off a small
	algorithm to find required modules based on sysfs information.
	To make that a credible demonstration, the small algorithm
	turned out to need a lot of scaffolding to turn it into a
	working program ...
      </para>
    </footnote>
    of <application>Yaird</application> are as follows:
    <itemizedlist>

      <listitem>
	<para>
	  Be free, as in GPL.
	</para>
      </listitem>

      <listitem>
	<para>
	  Be maintainable.  Small functions with documented arguments
	  and result are better than a shell script full of constructs
	  like <code>eval "awk | bash | tac 3>&amp;7"</code>.
	</para>
      </listitem>

      <listitem>
	<para>
	  Be secure and reliable.  The application should stop with an error
	  message at the slightest provocation, rather than run the
	  risk of producing a non-booting initrd image.
	  The application should not open loopholes that allow the 'bad
	  guys' to modify the image, gain access to raw devices or
	  overwrite system files.
	</para>
      </listitem>

      <listitem>
	<para>
	  Be distribution agnostic.  Fedora and Debian run similar
	  kernels and similar startup scripts, so there's little
	  reason why the glue between the two levels should be
	  completely different.
	</para>
      </listitem>

      <listitem>
	<para>
	  Have limited footprint.  The tools needed to build and run
	  the application should be few and widely available, with a
	  preference for tools that are installed anyway.
	</para>
      </listitem>

      <listitem>
	<para>
	  Be future proof.  Future kernels may use different modules
	  and may change device numbers; the application should need
	  no changes to cope with such migrations.
	</para>
      </listitem>

      <listitem>
	<para>
	  Promote code reuse.  Make functions side-effect free and
	  independent of context, so that it's easy to package the
	  core as a library that can be reused in other applications.
	</para>
      </listitem>

      <listitem>
	<para>
	  Generate small images.  The application should accurately
	  detect what modules are needed to get the root file system
	  running and include only those modules on the generated
	  image.<footnote>
	      <para>
		An alternative and equally interesting exercise would be
		an attempt to generate a universal initrd that could be
		distributed together with the kernel.  Such an image
		would most likely be based on udev/hotplug.
	      </para>
	    </footnote>
	  </para>
	</listitem>

    </itemizedlist>
  </para>

  <para>
    Requirements:
    <itemizedlist>

      <listitem>
	<para>
	  Linux 2.6.8 or later, both when running
	  <application>yaird</application> and when running the generated
	  image.  By limiting the goal to support only recent kernels,
	  we can drastically reduce the number of special cases and
	  knowledge about modules in the application.
	</para>
      </listitem>

      <listitem>
	<para>
	  A version of <application>modprobe</application> suitable
	  for 2.6 kernels.
	</para>
      </listitem>

      <listitem>
	<para>
	  Sysfs and procfs, both on the old and on the
	  new kernel.
	</para>
      </listitem>

      <listitem>
	<para>
	  Perl and the HTML-Template module.
	</para>
      </listitem>

    </itemizedlist>
  </para>

  <para>
    To achieve these goals, the following features are implemented:
    <itemizedlist>

      <listitem>
	<para>
	  Templating system to tune the generated image to a
	  given distribution; templates for Debian and Fedora FC3
	  included.
	</para>
      </listitem>

      <listitem>
	<para>
	  Interprets <filename>/etc/fstab</filename>, including
	  details such as octal escapes, <code>ignore</code> and
	  <code>noauto</code> keywords, and &mdash; for ext3 and reiser
	  file systems &mdash; label and uuid detection.
	  Where applicable, options in <filename>/etc/fstab</filename>
	  are used in the generated image.
	</para>
      </listitem>

      <listitem>
	<para>
	  Supports volume management via LVM2; activates only the volume
	  group required for the root file system.
	</para>
      </listitem>

      <listitem>
	<para>
	  Supports software RAID via mdadm; activates only required
	  devices.
	</para>
      </listitem>

      <listitem>
	<para>
	  Supports encrypted filesystems via cryptsetup and
	  cryptsetup-luks.
	</para>
      </listitem>

      <listitem>
	<para>
	  Supports NFS root filesystems.
	</para>
      </listitem>

      <listitem>
	<para>
	  Understands SATA, IDE devices.
	</para>
      </listitem>

      <listitem>
	<para>
	  Generated image does not use hard coded device
	  numbers.<footnote>
	    <para>
	      Except where the distribution depends on it;
	      there are some issues with mdadm in Debian.
	    </para>
	  </footnote>
	</para>
      </listitem>

      <listitem>
	<para>
	  Image generation understands how included executables may
	  depend on symbolic links and shared libraries.  Shared libraries
	  work for both glibc and klibc.
	</para>
      </listitem>

      <listitem>
	<para>
	  Support input devices such as USB keyboard, if the input
	  device supports sysfs.
	  Input devices are needed in the initial image to supply
	  a password for encrypted root disk and to do debugging.
	</para>
      </listitem>

      <listitem>
	<para>
	  Basic support for kernel command line as passed by the boot
	  loader.  Interprets init=, ro, rw.
	</para>
      </listitem>

      <listitem>
	<para>
	  Module aliases and options as specified in
	  <filename>/etc/modprobe.d</filename> are supported.
	</para>
      </listitem>

      <listitem>
	<para>
	  Interprets the blacklist information from hotplug.
	</para>
      </listitem>

      <listitem>
	<para>
	  Interprets the kernel configuration file that defines whether a
	  component is built in, available as a module or unavailable.
	  By maintaining a mapping between module name and config
	  parameter for selected modules, we avoid error messages if
	  for instance a required file system is built into the kernel.
	</para>
      </listitem>

      <listitem>
	<para>
	  Supports initramfs, both in Debian and Fedora versions.
	  An example template using the older initrd model
	  is included for Debian.
	</para>
      </listitem>

      <listitem>
	<para>
	  Does not require devfs in either the old or the new kernel.
	</para>
      </listitem>

      <listitem>
	<para>
	  Behaviour of the generated image can be tuned using
	  configuration files.
	</para>
      </listitem>

    </itemizedlist>
  </para>

  <para>
    Obviously, this tool is far from complete.  Here's a list of
    features that still need to be implemented:
    <itemizedlist>

      <listitem>
	<para>
	  Understands USB and SCSI storage, no special provisions
	  are needed for code generation, but it's not tested yet.
	</para>
      </listitem>

      <listitem>
	<para>
	  EVMS, an alternative user level interface to LVM2 and MD,
	  is not supported yet.
	</para>
      </listitem>

      <listitem>
	<para>
	  Swsusp is not supported yet.
	</para>
      </listitem>

      <listitem>
	<para>
	  Firewire and DASD are not supported.
	</para>
      </listitem>

      <listitem>
	<para>
	  Loopback file systems are not supported yet.
	</para>
      </listitem>

      <listitem>
	<para>
	  Filesystems encrypted via loopaes are not supported yet.
	</para>
      </listitem>

    </itemizedlist>
  </para>

</section>                                                                       
