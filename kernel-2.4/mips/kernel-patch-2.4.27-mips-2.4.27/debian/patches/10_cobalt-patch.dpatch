#! /bin/sh -e
## 10_cobalt-patch.dpatch by Karsten Merker <karsten@excalibur.cologne.de>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Cobalt fixes for 2.4 from http://www.colonel-panic.org/cobalt-mips/
## DP: cobalt-patch-2.4.x-20040411

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p1 ${patch_opts} < $0;;
    -unpatch) patch -R -p1 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

diff -urN linux.cvs/arch/mips/cobalt/pci.c linux.pdh/arch/mips/cobalt/pci.c
--- linux.cvs/arch/mips/cobalt/pci.c	2003-07-05 14:17:03.000000000 +0100
+++ linux.pdh/arch/mips/cobalt/pci.c	2004-04-11 16:27:59.000000000 +0100
@@ -212,15 +219,25 @@
 	 */
 	pci_read_config_word(dev, PCI_REVISION_ID, &galileo_id);
 	galileo_id &= 0xff;     /* mask off class info */
+#if 0
 	if (galileo_id >= 0x10) {
 		/* New Galileo, assumes PCI stop line to VIA is connected. */
 		GALILEO_OUTL(0x4020, GT_PCI0_TOR_OFS);
 	} else if (galileo_id == 0x1 || galileo_id == 0x2) {
+#endif
+	{
 		signed int timeo;
 		/* XXX WE MUST DO THIS ELSE GALILEO LOCKS UP! -DaveM */
 		timeo = GALILEO_INL(GT_PCI0_TOR_OFS);
 		/* Old Galileo, assumes PCI STOP line to VIA is disconnected. */
-		GALILEO_OUTL(0xffff, GT_PCI0_TOR_OFS);
+		GALILEO_OUTL(
+			     (0xff << 16) |          /* retry count */
+			     (0xff << 8) |           /* timeout 1   */
+			     0xff,                   /* timeout 0   */
+			     GT_PCI0_TOR_OFS);
+
+		/* enable PCI retry exceeded interrupt */
+		GALILEO_OUTL(GALILEO_INTR_RETRY_CTR | GALILEO_INL(GT_INTRMASK_OFS), GT_INTRMASK_OFS);
 	}
 }
 
Index: linux/include/asm-mips/cobalt/cobalt.h
===================================================================
--- linux.orig/include/asm-mips/cobalt/cobalt.h 2005-04-10 13:16:12.000000000 +0100
+++ linux/include/asm-mips/cobalt/cobalt.h      2005-04-10 13:16:12.000000000 +0100
@@ -89,6 +89,7 @@
 #define GALILEO_OUTL(val, port)	outl(val, GALILEO_REG(port))
 
 #define GALILEO_T0EXP		0x0100
+#define GALILEO_INTR_RETRY_CTR (1 << 20)
 #define GALILEO_ENTC0		0x01
 #define GALILEO_SELTC0		0x02
 
diff -urN linux.cvs/arch/mips/cobalt/setup.c linux.pdh/arch/mips/cobalt/setup.c
--- linux.cvs/arch/mips/cobalt/setup.c	2003-07-05 14:17:03.000000000 +0100
+++ linux.pdh/arch/mips/cobalt/setup.c	2004-04-11 17:50:11.000000000 +0100
@@ -34,6 +34,8 @@
 extern struct rtc_ops std_rtc_ops;
 extern struct ide_ops std_ide_ops;
 
+extern int cobalt_board_id;
+
 
 char arcs_cmdline[CL_SIZE] = {
  "console=ttyS0,115200 "
@@ -49,6 +51,16 @@
 
 const char *get_system_type(void)
 {
+	switch (cobalt_board_id) {
+		case COBALT_BRD_ID_QUBE1:
+			return "Cobalt Qube";
+		case COBALT_BRD_ID_RAQ1:
+			return "Cobalt RaQ";
+		case COBALT_BRD_ID_QUBE2:
+			return "Cobalt Qube2";
+		case COBALT_BRD_ID_RAQ2:
+			return "Cobalt RaQ2";
+	}
 	return "MIPS Cobalt";
 }
 
@@ -98,13 +110,96 @@
 	/*ns16550_setup_console();*/
 }
 
+#ifdef CONFIG_BLK_DEV_INITRD
+
+static int __init initrd_setup(unsigned long memsz)
+{
+	extern unsigned long initrd_start, initrd_end;
+	extern char __rd_start, __rd_end;
+
+	unsigned long start, size, phys;
+	char *ptr;
+
+	if (!memcmp(arcs_cmdline, "initrd=", 7))
+		ptr = arcs_cmdline;
+	else {
+		ptr = strstr(arcs_cmdline, " initrd=");
+		if (!ptr)
+			return 0;
+		++ptr;
+	}
+
+	size = simple_strtoul(ptr + 7, &ptr, 16);
+	if (*ptr != '@')
+		goto invalid;
+
+	start = simple_strtoul(ptr + 1, &ptr, 16);
+	if (*ptr && *ptr != ' ')
+		goto invalid;
+
+	phys = CPHYSADDR(start);
+	if (phys + size > memsz) {
+invalid:
+		printk(KERN_WARNING "initrd: command line parameter invalid\n");
+		return 0;
+	}
+
+	if (!size)
+		return 0;
+
+	/* an embedded ramdisk overrides us (arch/mips/kernel/setup.c) */
+
+	if (&__rd_start != &__rd_end) {
+		printk(KERN_WARNING "initrd: overridden by embedded ramdisk\n");
+		return 0;
+	}
+
+	initrd_start = start;
+	initrd_end = start + size;
+
+	add_memory_region(0x0, phys, BOOT_MEM_RAM);
+	add_memory_region(phys, size, BOOT_MEM_RESERVED);
+	phys += size;
+	add_memory_region(phys, memsz - phys, BOOT_MEM_RAM);
+
+	return 1;
+}
+
+#endif /* CONFIG_BLK_DEV_INITRD */
+
 /* Prom init. We read our one and only communication with the
-    firmware. Grab the amount of installed memory */
-void __init prom_init(int argc)
+    firmware. Grab the amount of installed memory.
+    Better boot loaders pass a command line too :-) */
+void __init prom_init(int argc, char *argv[])
 {
+	int indx, posn, nchr;
+	unsigned long memsz;
+
 	mips_machgroup = MACH_GROUP_COBALT;
 
-	add_memory_region(0x0, argc & 0x7fffffff, BOOT_MEM_RAM);
+	memsz = argc & 0x7fff0000;
+	argc &= 0xffff;
+
+	if (argc) {
+		arcs_cmdline[0] = '\0';
+		posn = 0;
+		for (indx = 1; indx < argc; ++indx) {
+			nchr = strlen(argv[indx]);
+			if (posn + 1 + nchr + 1 > sizeof(arcs_cmdline))
+				break;
+			if (posn)
+				arcs_cmdline[posn++] = ' ';
+			strcpy(arcs_cmdline + posn, argv[indx]);
+			posn += nchr;
+		}
+	}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (!initrd_setup(memsz))
+#endif
+	{
+		add_memory_region(0x0, memsz, BOOT_MEM_RAM);
+	}
 }
 
 void __init prom_free_prom_memory(void)
diff -urN linux.cvs/arch/mips/defconfig-cobalt linux.pdh/arch/mips/defconfig-cobalt
--- linux.cvs/arch/mips/defconfig-cobalt	2004-03-15 20:50:55.000000000 +0000
+++ linux.pdh/arch/mips/defconfig-cobalt	2004-04-11 16:27:59.000000000 +0100
@@ -13,7 +13,9 @@
 #
 # Loadable module support
 #
-# CONFIG_MODULES is not set
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
 
 #
 # Machine selection
@@ -168,7 +170,7 @@
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
 # CONFIG_BLK_DEV_SX8 is not set
-CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
 # CONFIG_BLK_DEV_INITRD is not set
@@ -624,15 +626,15 @@
 #
 # CONFIG_CODA_FS is not set
 # CONFIG_INTERMEZZO_FS is not set
-CONFIG_NFS_FS=y
+# CONFIG_NFS_FS is not set
 # CONFIG_NFS_V3 is not set
 # CONFIG_NFS_DIRECTIO is not set
 # CONFIG_ROOT_NFS is not set
 # CONFIG_NFSD is not set
 # CONFIG_NFSD_V3 is not set
 # CONFIG_NFSD_TCP is not set
-CONFIG_SUNRPC=y
-CONFIG_LOCKD=y
+# CONFIG_SUNRPC is not set
+# CONFIG_LOCKD is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
@@ -648,22 +650,8 @@
 #
 # Partition Types
 #
-CONFIG_PARTITION_ADVANCED=y
-# CONFIG_ACORN_PARTITION is not set
-# CONFIG_OSF_PARTITION is not set
-# CONFIG_AMIGA_PARTITION is not set
-# CONFIG_ATARI_PARTITION is not set
-# CONFIG_MAC_PARTITION is not set
+# CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
-# CONFIG_BSD_DISKLABEL is not set
-# CONFIG_MINIX_SUBPARTITION is not set
-# CONFIG_SOLARIS_X86_PARTITION is not set
-# CONFIG_UNIXWARE_DISKLABEL is not set
-# CONFIG_LDM_PARTITION is not set
-CONFIG_SGI_PARTITION=y
-# CONFIG_ULTRIX_PARTITION is not set
-# CONFIG_SUN_PARTITION is not set
-# CONFIG_EFI_PARTITION is not set
 # CONFIG_SMB_NLS is not set
 # CONFIG_NLS is not set
 
@@ -695,7 +683,7 @@
 #
 # Kernel hacking
 #
-CONFIG_CROSSCOMPILE=y
+# CONFIG_CROSSCOMPILE is not set
 # CONFIG_RUNTIME_DEBUG is not set
 # CONFIG_KGDB is not set
 # CONFIG_GDB_CONSOLE is not set
diff -urN linux.cvs/arch/mips/ld.script.in linux.pdh/arch/mips/ld.script.in
--- linux.cvs/arch/mips/ld.script.in	2004-02-06 15:14:07.000000000 +0000
+++ linux.pdh/arch/mips/ld.script.in	2004-04-11 16:27:59.000000000 +0100
@@ -30,6 +30,10 @@
   __ksymtab : { *(__ksymtab) }
   __stop___ksymtab = .;
 
+  __start___kallsyms = .;	/* All kernel symbols */
+  __kallsyms : { *(__kallsyms) }
+  __stop___kallsyms = .;
+
   _etext = .;
 
   . = ALIGN(8192);
diff -urN linux.cvs/arch/mips/lib/dump_tlb.c linux.pdh/arch/mips/lib/dump_tlb.c
--- linux.cvs/arch/mips/lib/dump_tlb.c	2004-02-11 15:05:10.000000000 +0000
+++ linux.pdh/arch/mips/lib/dump_tlb.c	2004-04-11 16:27:59.000000000 +0100
@@ -32,6 +32,7 @@
 	case PM_256M:	return "256Mb";
 #endif
 	}
+	return "???";
 }
 
 void dump_tlb(int first, int last)
diff -urN linux.cvs/arch/mips/lib/rtc-no.c linux.pdh/arch/mips/lib/rtc-no.c
--- linux.cvs/arch/mips/lib/rtc-no.c	2004-01-08 18:31:49.000000000 +0000
+++ linux.pdh/arch/mips/lib/rtc-no.c	2004-04-11 16:27:59.000000000 +0100
@@ -29,5 +29,3 @@
     .rtc_write_data = (void *) &shouldnt_happen,
     .rtc_bcd_mode   = (void *) &shouldnt_happen
 };
-
-EXPORT_SYMBOL(rtc_ops);
diff -urN linux.cvs/drivers/net/tulip/eeprom.c linux.pdh/drivers/net/tulip/eeprom.c
--- linux.cvs/drivers/net/tulip/eeprom.c	2003-02-25 22:03:08.000000000 +0000
+++ linux.pdh/drivers/net/tulip/eeprom.c	2004-04-11 16:27:59.000000000 +0100
@@ -62,6 +62,22 @@
 	 */
 	{ 0x1e00, 0x0000, 0x000b, 0x8f01, 0x0103, 0x0300, 0x0821, 0x000, 0x0001, 0x0000, 0x01e1 }
   },
+  {"Cobalt Microserver", 0, 0x10, 0xE0, {0x1e00, /* 0 == controller #, 1e == offset	*/
+					 0x0000, /* 0 == high offset, 0 == gap		*/
+					 0x0800, /* Default Autoselect			*/
+					 0x8001, /* 1 leaf, extended type, bogus len	*/
+					 0x0003, /* Type 3 (MII), PHY #0		*/
+					 0x0400, /* 0 init instr, 4 reset instr		*/
+					 0x0801, /* Set control mode, GP0 output	*/
+					 0x0000, /* Drive GP0 Low (RST is active low)	*/
+					 0x0800, /* control mode, GP0 input (undriven)	*/
+					 0x0000, /* clear control mode			*/
+					 0x7800, /* 100TX FDX + HDX, 10bT FDX + HDX	*/
+					 0x01e0, /* Advertise all above			*/
+					 0x5000, /* FDX all above			*/
+					 0x1800, /* Set fast TTM in 100bt modes		*/
+					 0x0000, /* PHY cannot be unplugged		*/
+  }},
   {0, 0, 0, 0, {}}};
 
 
diff -urN linux.cvs/drivers/net/tulip/media.c linux.pdh/drivers/net/tulip/media.c
--- linux.cvs/drivers/net/tulip/media.c	2003-02-25 22:03:08.000000000 +0000
+++ linux.pdh/drivers/net/tulip/media.c	2004-04-11 16:27:59.000000000 +0100
@@ -400,6 +400,9 @@
 	}
 
 	tp->csr6 = new_csr6 | (tp->csr6 & 0xfdff) | (tp->full_duplex ? 0x0200 : 0);
+
+	udelay(1000);
+
 	return;
 }
 
diff -urN linux.cvs/drivers/net/tulip/tulip_core.c linux.pdh/drivers/net/tulip/tulip_core.c
--- linux.cvs/drivers/net/tulip/tulip_core.c	2003-11-19 18:49:50.000000000 +0000
+++ linux.pdh/drivers/net/tulip/tulip_core.c	2004-04-11 16:27:59.000000000 +0100
@@ -1595,8 +1595,8 @@
                     (PCI_SLOT(pdev->devfn) == 12))) {
                        /* Cobalt MAC address in first EEPROM locations. */
                        sa_offset = 0;
-                       /* No media table either */
-                       tp->flags &= ~HAS_MEDIA_TABLE;
+		       /* Ensure our media table fixup get's applied */
+		       memcpy(ee_data + 16, ee_data, 8);
                }
 #endif
 #ifdef __hppa__
diff -urN linux.cvs/include/asm-mips/cobalt/ide.h linux.pdh/include/asm-mips/cobalt/ide.h
--- linux.cvs/include/asm-mips/cobalt/ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.pdh/include/asm-mips/cobalt/ide.h	2004-04-11 16:27:59.000000000 +0100
@@ -0,0 +1,71 @@
+/*
+ * PIO "in" transfers can cause D-cache lines to be allocated
+ * to the data being read. If the target is the page cache then
+ * the kernel can create a user space mapping of the same page
+ * without flushing it from the D-cache. This has large potential
+ * to create cache aliases. The Cobalts seem to trigger this
+ * problem easily.
+ *
+ * MIPs doesn't have a flush_dcache_range() so we roll
+ * our own.
+ *
+ * -- pdh
+ */
+
+#include <asm/r4kcache.h>
+
+static inline void __flush_dcache(void)
+{
+	unsigned long dc_size, dc_line, addr, end;
+
+	dc_size = current_cpu_data.dcache.ways << current_cpu_data.dcache.waybit;
+	dc_line = current_cpu_data.dcache.linesz;
+
+	addr = KSEG0;
+	end = addr + dc_size;
+
+	for (; addr < end; addr += dc_line)
+		flush_dcache_line_indexed(addr);
+}
+
+static inline void __flush_dcache_range(unsigned long start, unsigned long end)
+{
+	unsigned long dc_size, dc_line, addr;
+
+	dc_size = current_cpu_data.dcache.ways << current_cpu_data.dcache.waybit;
+	dc_line = current_cpu_data.dcache.linesz;
+
+	addr = start & ~(dc_line - 1);
+	end += dc_line - 1;
+
+	if (end - addr < dc_size)
+		for (; addr < end; addr += dc_line)
+			flush_dcache_line(addr);
+	else
+		__flush_dcache();
+}
+
+static inline void __ide_insw(unsigned long port, void *addr, unsigned int count)
+{
+	__insw(port, addr, count);
+
+	__flush_dcache_range((unsigned long) addr, (unsigned long) addr + count * 2);
+}
+
+static inline void __ide_insl(unsigned long port, void *addr, unsigned int count)
+{
+	__insl(port, addr, count);
+
+	__flush_dcache_range((unsigned long) addr, (unsigned long) addr + count * 4);
+}
+
+#undef insw
+#undef insl
+
+#define insw(p,a,n)		__ide_insw((p),(a),(n))
+#define insl(p,a,n)		__ide_insl((p),(a),(n))
+
+#define __ide_mm_insw(p,a,n)	do{BUG();}while(0)
+#define __ide_mm_insl(p,a,n)	do{BUG();}while(0)
+#define __ide_mm_outsw(p,a,n)	do{BUG();}while(0)
+#define __ide_mm_outsl(p,a,n)	do{BUG();}while(0)
diff -urN linux.cvs/include/asm-mips/ide.h linux.pdh/include/asm-mips/ide.h
--- linux.cvs/include/asm-mips/ide.h	2003-07-15 16:08:33.000000000 +0100
+++ linux.pdh/include/asm-mips/ide.h	2004-04-11 17:21:40.000000000 +0100
@@ -68,7 +68,11 @@
 #define ide_ack_intr(hwif)	((hwif)->hw.ack_intr ? (hwif)->hw.ack_intr(hwif) : 1)
 #endif
 
+#ifdef CONFIG_MIPS_COBALT
+#include <asm/cobalt/ide.h>
+#else
 #include <asm-generic/ide_iops.h>
+#endif
 
 #endif /* __KERNEL__ */
 
diff -urN linux.cvs/include/linux/udf_fs_sb.h linux.pdh/include/linux/udf_fs_sb.h
--- linux.cvs/include/linux/udf_fs_sb.h	2002-06-26 23:36:46.000000000 +0100
+++ linux.pdh/include/linux/udf_fs_sb.h	2004-04-11 16:27:59.000000000 +0100
@@ -18,7 +18,7 @@
 #ifndef _UDF_FS_SB_H
 #define _UDF_FS_SB_H 1
 
-#pragma pack(1)
+//#pragma pack(1)
 
 #define UDF_MAX_BLOCK_LOADED	8
 
@@ -31,13 +31,13 @@
 {
 	__u16	s_packet_len;
 	struct buffer_head *s_spar_map[4];
-};
+} __attribute__((packed));
 
 struct udf_virtual_data
 {
 	__u32	s_num_entries;
 	__u16	s_start_offset;
-};
+} __attribute__((packed));
 
 struct udf_bitmap
 {
@@ -45,7 +45,7 @@
 	__u32			s_extPosition;
 	__u16			s_nr_groups;
 	struct buffer_head 	**s_block_bitmap;
-};
+} __attribute__((packed));
 
 struct udf_part_map
 {
@@ -71,9 +71,9 @@
 	__u32	(*s_partition_func)(struct super_block *, __u32, __u16, __u32);
 	__u16	s_volumeseqnum;
 	__u16	s_partition_flags;
-};
+} __attribute__((packed));
 
-#pragma pack()
+//#pragma pack()
 
 struct udf_sb_info
 {
