#! /bin/sh -e
## 00_linux-mips.dpatch by Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Diff between kernel.org 2.4.27 and linux-mips.org, CVS tag
## DP: linux_2_4, date 2004-08-15.

if [ $# -lt 1 ]; then
    echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
    -patch) patch -p1 ${patch_opts} < $0;;
    -unpatch) patch -R -p1 ${patch_opts} < $0;;
    *)
        echo "`basename $0`: script expects -patch|-unpatch as argument" >&2
        exit 1;;
esac

exit 0

diff -urpNX ../2.4.26/dontdiff linux-2.4.27/Documentation/mips/time.README linux-mips-cvs-20040815/Documentation/mips/time.README
--- linux-2.4.27/Documentation/mips/time.README	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/Documentation/mips/time.README	2004-08-15 08:05:27.000000000 +0200
@@ -30,6 +30,7 @@ So we allow boards using 
 However, it is expected every board will move to the new time.c in the near
 future.
 
+In Linux 2.5 and Linux 2.4.26 CONFIG_OLD_TIME_C was removed.
 
 WHAT THE NEW CODE PROVIDES?
 --------------------------- 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/MAINTAINERS linux-mips-cvs-20040815/MAINTAINERS
--- linux-2.4.27/MAINTAINERS	2004-08-08 01:26:04.000000000 +0200
+++ linux-mips-cvs-20040815/MAINTAINERS	2004-08-15 08:05:22.000000000 +0200
@@ -1485,13 +1485,6 @@ L:	linux-mips@linux-mips.org
 W:	http://www.realitydiluted.com/projects/nino
 S:	Maintained
 
-PHILIPS NINO PALM PC
-P:	Steven Hill
-M:	sjhill@realitydiluted.com
-L:	linux-mips@oss.sgi.com
-W:	http://www.realitydiluted.com/projects/nino
-S:	Maintained
-
 PNP SUPPORT
 P:	Tom Lees
 M:	tom@lpsg.demon.co.uk
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/Makefile linux-mips-cvs-20040815/arch/mips/Makefile
--- linux-2.4.27/arch/mips/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/Makefile	2004-08-15 08:05:44.000000000 +0200
@@ -28,6 +28,8 @@ ifdef CONFIG_CROSSCOMPILE
 CROSS_COMPILE	= $(tool-prefix)
 endif
 
+MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
+
 check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
 
 #
@@ -44,7 +46,7 @@ check_gcc = $(shell if $(CC) $(1) -S -o 
 GCCFLAGS	:= -I $(TOPDIR)/include/asm/gcc
 GCCFLAGS	+= -G 0 -mno-abicalls -fno-pic -pipe
 GCCFLAGS	+= $(call check_gcc, -finline-limit=100000,)
-LINKFLAGS	+= -G 0 -static # -N
+LINKFLAGS	+= -G 0 -static -m $(ld-emul) -n
 MODFLAGS	+= -mlong-calls
 
 ifdef CONFIG_DEBUG_INFO
@@ -98,6 +100,11 @@ while :; do \
 	gas_abi=; gas_opt=; gas_cpu=; gas_isa=; \
 	break; \
 done; \
+if test "$$gcc_opt" = -march= && test -n "$$gcc_abi"; then \
+	$(CC) $$gcc_abi $$gcc_opt$$gcc_cpu -S -o /dev/null \
+		-xc /dev/null > /dev/null 2>&1 && \
+		gcc_isa=; \
+fi; \
 echo $$gcc_abi $$gcc_opt$$gcc_cpu $$gcc_isa $$gas_abi $$gas_opt$$gas_cpu $$gas_isa)
 
 #
@@ -249,6 +256,13 @@ SUBDIRS       += arch/mips/au1000/db1x00
 LOADADDR      += 0x80100000
 endif
 
+ifdef CONFIG_MIPS_DB1550
+LIBS          += arch/mips/au1000/db1x00/db1x00.o \
+                 arch/mips/au1000/common/au1000.o
+SUBDIRS       += arch/mips/au1000/db1x00 arch/mips/au1000/common
+LOADADDR      += 0x80100000
+endif
+
 ifdef CONFIG_MIPS_DB1100
 LIBS          += arch/mips/au1000/db1x00/db1x00.o \
                  arch/mips/au1000/common/au1000.o
@@ -463,6 +477,12 @@ SUBDIRS		+= arch/mips/momentum/ocelot_c
 LOADADDR	:= 0x80100000
 endif
 
+ifdef CONFIG_PMC_BIG_SUR
+CORE_FILES	+= arch/mips/pmc-sierra/big_sur/big_sur.o
+SUBDIRS		+= arch/mips/pmc-sierra/big_sur
+LOADADDR	:= 0x80100000
+endif
+
 ifdef CONFIG_MOMENCO_JAGUAR_ATX
 LIBS		+= arch/mips/momentum/jaguar_atx/jaguar_atx.o
 SUBDIRS		+= arch/mips/momentum/jaguar_atx
@@ -723,8 +743,6 @@ rom.bin rom.sw: vmlinux
 	$(MAKE) -C arch/$(ARCH)/lasat/image $@
 endif
 
-MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
-
 vmlinux.ecoff: vmlinux
 	@$(MAKEBOOT) $@
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/Makefile linux-mips-cvs-20040815/arch/mips/au1000/common/Makefile
--- linux-2.4.27/arch/mips/au1000/common/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/Makefile	2004-08-15 08:05:44.000000000 +0200
@@ -18,8 +18,10 @@ O_TARGET := au1000.o
 
 export-objs		= prom.o clocks.o power.o usbdev.o
 
-obj-y := prom.o int-handler.o dma.o irq.o puts.o time.o reset.o \
-	clocks.o power.o setup.o sleeper.o
+obj-y := prom.o int-handler.o irq.o puts.o time.o reset.o cputable.o \
+	au1xxx_irqmap.o clocks.o power.o setup.o sleeper.o dma.o dbdma.o
+  
+export-objs += dma.o dbdma.o
 
 obj-$(CONFIG_AU1X00_USB_DEVICE) += usbdev.o
 obj-$(CONFIG_KGDB) += dbg_io.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/au1xxx_irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/common/au1xxx_irqmap.c
--- linux-2.4.27/arch/mips/au1000/common/au1xxx_irqmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/au1xxx_irqmap.c	2004-08-15 08:05:44.000000000 +0200
@@ -0,0 +1,223 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Au1xxx processor specific IRQ tables
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel_stat.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+
+#include <asm/bitops.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+#include <asm/au1000.h>
+
+/* The IC0 interrupt table.  This is processor, rather than
+ * board dependent, so no reason to keep this info in the board
+ * dependent files.
+ *
+ * Careful if you change match 2 request!
+ * The interrupt handler is called directly from the low level dispatch code.
+ */
+au1xxx_irq_map_t au1xxx_ic0_map[] = {
+
+#if defined(CONFIG_SOC_AU1000)
+	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_UART2_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
+
+#elif defined(CONFIG_SOC_AU1500)
+
+	{ AU1500_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1500_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1500_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1500_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
+
+#elif defined(CONFIG_SOC_AU1100)
+
+	{ AU1100_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1100_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1100_SD_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1100_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1100_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	/*{ AU1000_GPIO215_208_INT, INTC_INT_HIGH_LEVEL, 0},*/
+	{ AU1100_LCD_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
+
+#elif defined(CONFIG_SOC_AU1550)
+
+	{ AU1550_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1550_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1550_DDMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_CRYPTO_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1550_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1550_PCI_RST_INT, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1550_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_PSC0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_PSC2_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_PSC3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1550_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_NAND_INT, INTC_INT_RISE_EDGE, 0},
+	{ AU1550_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1550_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1550_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+
+#elif defined(CONFIG_SOC_AU1200)
+
+	{ AU1200_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_SWT_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_SD_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_DDMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_MAE_BE_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_MAE_FE_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_PSC0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_AES_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_CAMERA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_TOY_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{ AU1200_RTC_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+	{ AU1200_NAND_INT, INTC_INT_RISE_EDGE, 0},
+	{ AU1200_USB_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_LCD_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_MAE_BOTH_INT, INTC_INT_HIGH_LEVEL, 0},
+
+#else
+#error "Error: Unknown Alchemy SOC"
+#endif
+
+};
+
+int au1xxx_ic0_nr_irqs = sizeof(au1xxx_ic0_map)/sizeof(au1xxx_irq_map_t);
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/clocks.c linux-mips-cvs-20040815/arch/mips/au1000/common/clocks.c
--- linux-2.4.27/arch/mips/au1000/common/clocks.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/clocks.c	2004-08-15 08:05:44.000000000 +0200
@@ -95,4 +95,5 @@ unsigned int get_au1x00_lcd_clock(void)
 	return lcd_clock;
 }
 
+EXPORT_SYMBOL(get_au1x00_speed);
 EXPORT_SYMBOL(get_au1x00_lcd_clock);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/cputable.c linux-mips-cvs-20040815/arch/mips/au1000/common/cputable.c
--- linux-2.4.27/arch/mips/au1000/common/cputable.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/cputable.c	2004-08-15 08:05:44.000000000 +0200
@@ -0,0 +1,57 @@
+/*
+ *  arch/mips/au1000/common/cputable.c
+ *
+ *  Copyright (C) 2004 Dan Malek (dan@embeddededge.com)
+ *	Copied from PowerPC and updated for Alchemy Au1xxx processors.
+ *
+ *  Copyright (C) 2001 Ben. Herrenschmidt (benh@kernel.crashing.org)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/threads.h>
+#include <linux/init.h>
+#include <asm/au1000.h>
+
+struct cpu_spec* cur_cpu_spec[NR_CPUS];
+
+/* With some thought, we can probably use the mask to reduce the
+ * size of the table.
+ */
+struct cpu_spec	cpu_specs[] = {
+    { 0xffffffff, 0x00030100, "Au1000 DA", 1, 0 },
+    { 0xffffffff, 0x00030201, "Au1000 HA", 1, 0 },
+    { 0xffffffff, 0x00030202, "Au1000 HB", 1, 0 },
+    { 0xffffffff, 0x00030203, "Au1000 HC", 1, 1 },
+    { 0xffffffff, 0x00030204, "Au1000 HD", 1, 1 },
+    { 0xffffffff, 0x01030200, "Au1500 AB", 1, 1 },
+    { 0xffffffff, 0x01030201, "Au1500 AC", 0, 1 },
+    { 0xffffffff, 0x01030202, "Au1500 AD", 0, 1 },
+    { 0xffffffff, 0x02030200, "Au1100 AB", 1, 1 },
+    { 0xffffffff, 0x02030201, "Au1100 BA", 1, 1 },
+    { 0xffffffff, 0x02030202, "Au1100 BC", 1, 1 },
+    { 0xffffffff, 0x02030203, "Au1100 BD", 0, 1 },
+    { 0xffffffff, 0x02030204, "Au1100 BE", 0, 1 },
+    { 0xffffffff, 0x03030200, "Au1550 AA", 0, 1 },
+    { 0xffffffff, 0x04030200, "Au1200 AA", 0, 1 },
+    { 0x00000000, 0x00000000, "Unknown Au1xxx", 1, 0 },
+};
+
+void
+set_cpuspec(void)
+{
+	struct	cpu_spec *sp;
+	u32	prid;
+
+	prid = read_c0_prid();
+	sp = cpu_specs;
+	while ((prid & sp->prid_mask) != sp->prid_value)
+		sp++;
+	cur_cpu_spec[0] = sp;
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/dbdma.c linux-mips-cvs-20040815/arch/mips/au1000/common/dbdma.c
--- linux-2.4.27/arch/mips/au1000/common/dbdma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/dbdma.c	2004-08-15 08:05:45.000000000 +0200
@@ -0,0 +1,834 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *      The Descriptor Based DMA channel manager that first appeared
+ *	on the Au1550.  I started with dma.c, but I think all that is
+ *	left is this initial comment :-)
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <asm/au1000.h>
+#include <asm/au1xxx_dbdma.h>
+#include <asm/system.h>
+
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+
+/*
+ * The Descriptor Based DMA supports up to 16 channels.
+ *
+ * There are 32 devices defined. We keep an internal structure
+ * of devices using these channels, along with additional
+ * information.
+ *
+ * We allocate the descriptors and allow access to them through various
+ * functions.  The drivers allocate the data buffers and assign them
+ * to the descriptors.
+ */
+static spinlock_t au1xxx_dbdma_spin_lock = SPIN_LOCK_UNLOCKED;
+
+/* I couldn't find a macro that did this......
+*/
+#define ALIGN_ADDR(x, a)	((((u32)(x)) + (a-1)) & ~(a-1))
+
+static volatile dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
+static int dbdma_initialized;
+static void au1xxx_dbdma_init(void);
+
+typedef struct dbdma_device_table {
+	u32		dev_id;
+	u32		dev_flags;
+	u32		dev_tsize;
+	u32		dev_devwidth;
+	u32		dev_physaddr;		/* If FIFO */
+	u32		dev_intlevel;
+	u32		dev_intpolarity;
+} dbdev_tab_t;
+
+typedef struct dbdma_chan_config {
+	u32			chan_flags;
+	u32			chan_index;
+	dbdev_tab_t		*chan_src;
+	dbdev_tab_t		*chan_dest;
+	au1x_dma_chan_t		*chan_ptr;
+	au1x_ddma_desc_t	*chan_desc_base;
+	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
+	void			*chan_callparam;
+	void (*chan_callback)(int, void *, struct pt_regs *);
+} chan_tab_t;
+
+#define	DEV_FLAGS_INUSE		(1 << 0)
+#define	DEV_FLAGS_ANYUSE	(1 << 1)
+#define DEV_FLAGS_OUT		(1 << 2)
+#define DEV_FLAGS_IN		(1 << 3)
+
+static dbdev_tab_t dbdev_tab[] = {
+#ifdef CONFIG_SOC_AU1550
+	/* UARTS */
+	{ DSCR_CMD0_UART0_TX, DEV_FLAGS_OUT, 0, 8, 0x11100004, 0, 0 },
+	{ DSCR_CMD0_UART0_RX, DEV_FLAGS_IN, 0, 8, 0x11100000, 0, 0 },
+	{ DSCR_CMD0_UART3_TX, DEV_FLAGS_OUT, 0, 8, 0x11400004, 0, 0 },
+	{ DSCR_CMD0_UART3_RX, DEV_FLAGS_IN, 0, 8, 0x11400000, 0, 0 },
+
+	/* EXT DMA */
+	{ DSCR_CMD0_DMA_REQ0, 0, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_DMA_REQ1, 0, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_DMA_REQ2, 0, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_DMA_REQ3, 0, 0, 0, 0x00000000, 0, 0 },
+
+	/* USB DEV */
+	{ DSCR_CMD0_USBDEV_RX0, DEV_FLAGS_IN, 4, 8, 0x10200000, 0, 0 },
+	{ DSCR_CMD0_USBDEV_TX0, DEV_FLAGS_OUT, 4, 8, 0x10200004, 0, 0 },
+	{ DSCR_CMD0_USBDEV_TX1, DEV_FLAGS_OUT, 4, 8, 0x10200008, 0, 0 },
+	{ DSCR_CMD0_USBDEV_TX2, DEV_FLAGS_OUT, 4, 8, 0x1020000c, 0, 0 },
+	{ DSCR_CMD0_USBDEV_RX3, DEV_FLAGS_IN, 4, 8, 0x10200010, 0, 0 },
+	{ DSCR_CMD0_USBDEV_RX4, DEV_FLAGS_IN, 4, 8, 0x10200014, 0, 0 },
+
+	/* PSC 0 */
+	{ DSCR_CMD0_PSC0_TX, DEV_FLAGS_OUT, 0, 0, 0x11a0001c, 0, 0 },
+	{ DSCR_CMD0_PSC0_RX, DEV_FLAGS_IN, 0, 0, 0x11a0001c, 0, 0 },
+
+	/* PSC 1 */
+	{ DSCR_CMD0_PSC1_TX, DEV_FLAGS_OUT, 0, 0, 0x11b0001c, 0, 0 },
+	{ DSCR_CMD0_PSC1_RX, DEV_FLAGS_IN, 0, 0, 0x11b0001c, 0, 0 },
+
+	/* PSC 2 */
+	{ DSCR_CMD0_PSC2_TX, DEV_FLAGS_OUT, 0, 0, 0x10a0001c, 0, 0 },
+	{ DSCR_CMD0_PSC2_RX, DEV_FLAGS_IN, 0, 0, 0x10a0001c, 0, 0 },
+
+	/* PSC 3 */
+	{ DSCR_CMD0_PSC3_TX, DEV_FLAGS_OUT, 0, 0, 0x10b0001c, 0, 0 },
+	{ DSCR_CMD0_PSC3_RX, DEV_FLAGS_IN, 0, 0, 0x10b0001c, 0, 0 },
+
+	{ DSCR_CMD0_PCI_WRITE, 0, 0, 0, 0x00000000, 0, 0 },	/* PCI */
+	{ DSCR_CMD0_NAND_FLASH, 0, 0, 0, 0x00000000, 0, 0 },	/* NAND */
+
+	/* MAC 0 */
+	{ DSCR_CMD0_MAC0_RX, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_MAC0_TX, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
+
+	/* MAC 1 */
+	{ DSCR_CMD0_MAC1_RX, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_MAC1_TX, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
+
+#endif /* CONFIG_SOC_AU1550 */
+
+#ifdef CONFIG_SOC_AU1200
+	{ DSCR_CMD0_UART0_TX, DEV_FLAGS_OUT, 0, 8, 0x11100004, 0, 0 },
+	{ DSCR_CMD0_UART0_RX, DEV_FLAGS_IN, 0, 8, 0x11100000, 0, 0 },
+	{ DSCR_CMD0_UART1_TX, DEV_FLAGS_OUT, 0, 8, 0x11200004, 0, 0 },
+	{ DSCR_CMD0_UART1_RX, DEV_FLAGS_IN, 0, 8, 0x11200000, 0, 0 },
+
+	{ DSCR_CMD0_DMA_REQ0, 0, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_DMA_REQ1, 0, 0, 0, 0x00000000, 0, 0 },
+
+	{ DSCR_CMD0_MAE_BE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_MAE_FE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_MAE_BOTH, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_LCD, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+
+	{ DSCR_CMD0_SDMS_TX0, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX0, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_SDMS_TX1, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_SDMS_RX1, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+
+	{ DSCR_CMD0_AES_TX, DEV_FLAGS_OUT, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_AES_RX, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+
+	{ DSCR_CMD0_PSC0_TX, DEV_FLAGS_OUT, 0, 0, 0x11a0001c, 0, 0 },
+	{ DSCR_CMD0_PSC0_RX, DEV_FLAGS_IN, 0, 0, 0x11a0001c, 0, 0 },
+	{ DSCR_CMD0_PSC0_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+
+	{ DSCR_CMD0_PSC1_TX, DEV_FLAGS_OUT, 0, 0, 0x11b0001c, 0, 0 },
+	{ DSCR_CMD0_PSC1_RX, DEV_FLAGS_IN, 0, 0, 0x11b0001c, 0, 0 },
+	{ DSCR_CMD0_PSC1_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+
+	{ DSCR_CMD0_CIM_RXA, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_CIM_RXB, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_CIM_RXC, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_CIM_SYNC, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+
+	{ DSCR_CMD0_NAND_FLASH, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
+
+#endif // CONFIG_SOC_AU1200
+
+	{ DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+	{ DSCR_CMD0_ALWAYS, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
+};
+
+#define DBDEV_TAB_SIZE (sizeof(dbdev_tab) / sizeof(dbdev_tab_t))
+
+static chan_tab_t *chan_tab_ptr[NUM_DBDMA_CHANS];
+
+static dbdev_tab_t *
+find_dbdev_id (u32 id)
+{
+	int i;
+	dbdev_tab_t *p;
+	for (i = 0; i < DBDEV_TAB_SIZE; ++i) {
+		p = &dbdev_tab[i];
+		if (p->dev_id == id)
+			return p;
+	}
+	return NULL;
+}
+
+/* Allocate a channel and return a non-zero descriptor if successful.
+*/
+u32
+au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
+       void (*callback)(int, void *, struct pt_regs *), void *callparam)
+{
+	unsigned long   flags;
+	u32		used, chan, rv;
+	u32		dcp;
+	int		i;
+	dbdev_tab_t	*stp, *dtp;
+	chan_tab_t	*ctp;
+	volatile au1x_dma_chan_t *cp;
+
+	/* We do the intialization on the first channel allocation.
+	 * We have to wait because of the interrupt handler initialization
+	 * which can't be done successfully during board set up.
+	 */
+	if (!dbdma_initialized)
+		au1xxx_dbdma_init();
+	dbdma_initialized = 1;
+
+	if ((srcid > DSCR_NDEV_IDS) || (destid > DSCR_NDEV_IDS))
+		return 0;
+	
+	if ((stp = find_dbdev_id(srcid)) == NULL) return 0;
+	if ((dtp = find_dbdev_id(destid)) == NULL) return 0;
+
+	used = 0;
+	rv = 0;
+
+	/* Check to see if we can get both channels.
+	*/
+	spin_lock_irqsave(&au1xxx_dbdma_spin_lock, flags);
+	if (!(stp->dev_flags & DEV_FLAGS_INUSE) ||
+	     (stp->dev_flags & DEV_FLAGS_ANYUSE)) {
+	     	/* Got source */
+		stp->dev_flags |= DEV_FLAGS_INUSE;
+		if (!(dtp->dev_flags & DEV_FLAGS_INUSE) ||
+		     (dtp->dev_flags & DEV_FLAGS_ANYUSE)) {
+			/* Got destination */
+			dtp->dev_flags |= DEV_FLAGS_INUSE;
+		}
+		else {
+			/* Can't get dest.  Release src.
+			*/
+			stp->dev_flags &= ~DEV_FLAGS_INUSE;
+			used++;
+		}
+	}
+	else {
+		used++;
+	}
+	spin_unlock_irqrestore(&au1xxx_dbdma_spin_lock, flags);
+
+	if (!used) {
+		/* Let's see if we can allocate a channel for it.
+		*/
+		ctp = NULL;
+		chan = 0;
+		spin_lock_irqsave(&au1xxx_dbdma_spin_lock, flags);
+		for (i=0; i<NUM_DBDMA_CHANS; i++) {
+			if (chan_tab_ptr[i] == NULL) {
+				/* If kmalloc fails, it is caught below same
+				 * as a channel not available.
+				 */
+				ctp = (chan_tab_t *)kmalloc(sizeof(chan_tab_t), GFP_KERNEL);
+				chan_tab_ptr[i] = ctp;
+				ctp->chan_index = chan = i;
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&au1xxx_dbdma_spin_lock, flags);
+
+		if (ctp != NULL) {
+			memset(ctp, 0, sizeof(chan_tab_t));
+			dcp = DDMA_CHANNEL_BASE;
+			dcp += (0x0100 * chan);
+			ctp->chan_ptr = (au1x_dma_chan_t *)dcp;
+			cp = (volatile au1x_dma_chan_t *)dcp;
+			ctp->chan_src = stp;
+			ctp->chan_dest = dtp;
+			ctp->chan_callback = callback;
+			ctp->chan_callparam = callparam;
+
+			/* Initialize channel configuration.
+			*/
+			i = 0;
+			if (stp->dev_intlevel)
+				i |= DDMA_CFG_SED;
+			if (stp->dev_intpolarity)
+				i |= DDMA_CFG_SP;
+			if (dtp->dev_intlevel)
+				i |= DDMA_CFG_DED;
+			if (dtp->dev_intpolarity)
+				i |= DDMA_CFG_DP;
+			cp->ddma_cfg = i;
+			au_sync();
+
+			/* Return a non-zero value that can be used to
+			 * find the channel information in subsequent
+			 * operations.
+			 */
+			rv = (u32)(&chan_tab_ptr[chan]);
+		}
+		else {
+			/* Release devices.
+			*/
+			stp->dev_flags &= ~DEV_FLAGS_INUSE;
+			dtp->dev_flags &= ~DEV_FLAGS_INUSE;
+		}
+	}
+	return rv;
+}
+
+/* Set the device width if source or destination is a FIFO.
+ * Should be 8, 16, or 32 bits.
+ */
+u32
+au1xxx_dbdma_set_devwidth(u32 chanid, int bits)
+{
+	u32		rv;
+	chan_tab_t	*ctp;
+	dbdev_tab_t	*stp, *dtp;
+
+	ctp = *((chan_tab_t **)chanid);
+	stp = ctp->chan_src;
+	dtp = ctp->chan_dest;
+	rv = 0;
+
+	if (stp->dev_flags & DEV_FLAGS_IN) {	/* Source in fifo */
+		rv = stp->dev_devwidth;
+		stp->dev_devwidth = bits;
+	}
+	if (dtp->dev_flags & DEV_FLAGS_OUT) {	/* Destination out fifo */
+		rv = dtp->dev_devwidth;
+		dtp->dev_devwidth = bits;
+	}
+
+	return rv;
+}
+
+/* Allocate a descriptor ring, initializing as much as possible.
+*/
+u32
+au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
+{
+	int			i;
+	u32			desc_base, srcid, destid;
+	u32			cmd0, cmd1, src1, dest1;
+	u32			src0, dest0;
+	chan_tab_t		*ctp;
+	dbdev_tab_t		*stp, *dtp;
+	au1x_ddma_desc_t	*dp;
+
+	/* I guess we could check this to be within the
+	 * range of the table......
+	 */
+	ctp = *((chan_tab_t **)chanid);
+	stp = ctp->chan_src;
+	dtp = ctp->chan_dest;
+
+	/* The descriptors must be 32-byte aligned.  There is a
+	 * possibility the allocation will give us such an address,
+	 * and if we try that first we are likely to not waste larger
+	 * slabs of memory.
+	 */
+	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t), GFP_KERNEL);
+	if (desc_base == 0)
+		return 0;
+	
+	if (desc_base & 0x1f) {
+		/* Lost....do it again, allocate extra, and round
+		 * the address base.
+		 */
+		kfree((const void *)desc_base);
+		i = entries * sizeof(au1x_ddma_desc_t);
+		i += (sizeof(au1x_ddma_desc_t) - 1);
+		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL)) == 0)
+			return 0;
+
+		desc_base = ALIGN_ADDR(desc_base, sizeof(au1x_ddma_desc_t));
+	}
+	dp = (au1x_ddma_desc_t *)desc_base;
+
+	/* Keep track of the base descriptor.
+	*/
+	ctp->chan_desc_base = dp;
+
+	/* Initialize the rings with as much information as we know.
+	 */
+	srcid = stp->dev_id;
+	destid = dtp->dev_id;
+
+	cmd0 = cmd1 = src1 = dest1 = 0;
+	src0 = dest0 = 0;
+
+	cmd0 |= DSCR_CMD0_SID(srcid);
+	cmd0 |= DSCR_CMD0_DID(destid);
+	cmd0 |= DSCR_CMD0_IE | DSCR_CMD0_CV;
+	cmd0 |= DSCR_CMD0_ST(DSCR_CMD0_ST_CURRENT);
+
+	switch (stp->dev_devwidth) {
+	case 8:
+		cmd0 |= DSCR_CMD0_SW(DSCR_CMD0_BYTE);
+		break;
+	case 16:
+		cmd0 |= DSCR_CMD0_SW(DSCR_CMD0_HALFWORD);
+		break;
+	case 32:
+	default:
+		cmd0 |= DSCR_CMD0_SW(DSCR_CMD0_WORD);
+		break;
+	}
+
+	switch (dtp->dev_devwidth) {
+	case 8:
+		cmd0 |= DSCR_CMD0_DW(DSCR_CMD0_BYTE);
+		break;
+	case 16:
+		cmd0 |= DSCR_CMD0_DW(DSCR_CMD0_HALFWORD);
+		break;
+	case 32:
+	default:
+		cmd0 |= DSCR_CMD0_DW(DSCR_CMD0_WORD);
+		break;
+	}
+
+	/* If the device is marked as an in/out FIFO, ensure it is
+	 * set non-coherent.
+	 */
+	if (stp->dev_flags & DEV_FLAGS_IN)
+		cmd0 |= DSCR_CMD0_SN;		/* Source in fifo */
+	if (dtp->dev_flags & DEV_FLAGS_OUT)
+		cmd0 |= DSCR_CMD0_DN;		/* Destination out fifo */
+
+	/* Set up source1.  For now, assume no stride and increment.
+	 * A channel attribute update can change this later.
+	 */
+	switch (stp->dev_tsize) {
+	case 1:
+		src1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE1);
+		break;
+	case 2:
+		src1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE2);
+		break;
+	case 4:
+		src1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE4);
+		break;
+	case 8:
+	default:
+		src1 |= DSCR_SRC1_STS(DSCR_xTS_SIZE8);
+		break;
+	}
+
+	/* If source input is fifo, set static address.
+	*/
+	if (stp->dev_flags & DEV_FLAGS_IN) {
+		src0 = stp->dev_physaddr;
+		src1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);
+	}
+
+	/* Set up dest1.  For now, assume no stride and increment.
+	 * A channel attribute update can change this later.
+	 */
+	switch (dtp->dev_tsize) {
+	case 1:
+		dest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE1);
+		break;
+	case 2:
+		dest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE2);
+		break;
+	case 4:
+		dest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE4);
+		break;
+	case 8:
+	default:
+		dest1 |= DSCR_DEST1_DTS(DSCR_xTS_SIZE8);
+		break;
+	}
+
+	/* If destination output is fifo, set static address.
+	*/
+	if (dtp->dev_flags & DEV_FLAGS_OUT) {
+		dest0 = dtp->dev_physaddr;
+		dest1 |= DSCR_DEST1_DAM(DSCR_xAM_STATIC);
+	}
+	
+	for (i=0; i<entries; i++) {
+		dp->dscr_cmd0 = cmd0;
+		dp->dscr_cmd1 = cmd1;
+		dp->dscr_source0 = src0;
+		dp->dscr_source1 = src1;
+		dp->dscr_dest0 = dest0;
+		dp->dscr_dest1 = dest1;
+		dp->dscr_stat = 0;
+		dp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(dp + 1));
+		dp++;
+	}
+	
+	/* Make last descrptor point to the first.
+	*/
+	dp--;
+	dp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(ctp->chan_desc_base));
+	ctp->get_ptr = ctp->put_ptr = ctp->cur_ptr = ctp->chan_desc_base;
+
+	return (u32)(ctp->chan_desc_base);
+}
+
+/* Put a source buffer into the DMA ring.
+ * This updates the source pointer and byte count.  Normally used
+ * for memory to fifo transfers.
+ */
+u32
+au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes)
+{
+	chan_tab_t		*ctp;
+	au1x_ddma_desc_t	*dp;
+
+	/* I guess we could check this to be within the
+	 * range of the table......
+	 */
+	ctp = *((chan_tab_t **)chanid);
+
+	/* We should have multiple callers for a particular channel,
+	 * an interrupt doesn't affect this pointer nor the descriptor,
+	 * so no locking should be needed.
+	 */
+	dp = ctp->put_ptr;
+
+	/* If the descriptor is valid, we are way ahead of the DMA
+	 * engine, so just return an error condition.
+	 */
+	if (dp->dscr_cmd0 & DSCR_CMD0_V) {
+		return 0;
+	}
+	
+	/* Load up buffer address and byte count.
+	*/
+	dp->dscr_source0 = virt_to_phys(buf);
+	dp->dscr_cmd1 = nbytes;
+	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
+	ctp->chan_ptr->ddma_dbell = 0xffffffff;	/* Make it go */
+	
+	/* Get next descriptor pointer.
+	*/
+	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+
+	/* return something not zero.
+	*/
+	return nbytes;
+}
+
+/* Put a destination buffer into the DMA ring.
+ * This updates the destination pointer and byte count.  Normally used
+ * to place an empty buffer into the ring for fifo to memory transfers.
+ */
+u32
+au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes)
+{
+	chan_tab_t		*ctp;
+	au1x_ddma_desc_t	*dp;
+
+	/* I guess we could check this to be within the
+	 * range of the table......
+	 */
+	ctp = *((chan_tab_t **)chanid);
+
+	/* We should have multiple callers for a particular channel,
+	 * an interrupt doesn't affect this pointer nor the descriptor,
+	 * so no locking should be needed.
+	 */
+	dp = ctp->put_ptr;
+
+	/* If the descriptor is valid, we are way ahead of the DMA
+	 * engine, so just return an error condition.
+	 */
+	if (dp->dscr_cmd0 & DSCR_CMD0_V)
+		return 0;
+	
+	/* Load up buffer address and byte count.
+	*/
+	dp->dscr_dest0 = virt_to_phys(buf);
+	dp->dscr_cmd1 = nbytes;
+	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
+	
+	/* Get next descriptor pointer.
+	*/
+	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+
+	/* return something not zero.
+	*/
+	return nbytes;
+}
+
+/* Get a destination buffer into the DMA ring.
+ * Normally used to get a full buffer from the ring during fifo
+ * to memory transfers.  This does not set the valid bit, you will
+ * have to put another destination buffer to keep the DMA going.
+ */
+u32
+au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes)
+{
+	chan_tab_t		*ctp;
+	au1x_ddma_desc_t	*dp;
+	u32			rv;
+
+	/* I guess we could check this to be within the
+	 * range of the table......
+	 */
+	ctp = *((chan_tab_t **)chanid);
+
+	/* We should have multiple callers for a particular channel,
+	 * an interrupt doesn't affect this pointer nor the descriptor,
+	 * so no locking should be needed.
+	 */
+	dp = ctp->get_ptr;
+
+	/* If the descriptor is valid, we are way ahead of the DMA
+	 * engine, so just return an error condition.
+	 */
+	if (dp->dscr_cmd0 & DSCR_CMD0_V)
+		return 0;
+	
+	/* Return buffer address and byte count.
+	*/
+	*buf = (void *)(phys_to_virt(dp->dscr_dest0));
+	*nbytes = dp->dscr_cmd1;
+	rv = dp->dscr_stat;
+	
+	/* Get next descriptor pointer.
+	*/
+	ctp->get_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+
+	/* return something not zero.
+	*/
+	return rv;
+}
+
+void
+au1xxx_dbdma_stop(u32 chanid)
+{
+	chan_tab_t	*ctp;
+	volatile au1x_dma_chan_t *cp;
+	int halt_timeout = 0;
+
+	ctp = *((chan_tab_t **)chanid);
+
+	cp = ctp->chan_ptr;
+	cp->ddma_cfg &= ~DDMA_CFG_EN;	/* Disable channel */
+	au_sync();
+	while (!(cp->ddma_stat & DDMA_STAT_H)) {
+		udelay(1);
+		halt_timeout++;
+		if (halt_timeout > 100) {
+			printk("warning: DMA channel won't halt\n");
+			break;
+		}
+	}
+	/* clear current desc valid and doorbell */
+	cp->ddma_stat |= (DDMA_STAT_DB | DDMA_STAT_V);
+	au_sync();
+}
+
+/* Start using the current descriptor pointer.  If the dbdma encounters
+ * a not valid descriptor, it will stop.  In this case, we can just
+ * continue by adding a buffer to the list and starting again.
+ */
+void
+au1xxx_dbdma_start(u32 chanid)
+{
+	chan_tab_t	*ctp;
+	volatile au1x_dma_chan_t *cp;
+
+	ctp = *((chan_tab_t **)chanid);
+
+	cp = ctp->chan_ptr;
+	cp->ddma_desptr = virt_to_phys(ctp->cur_ptr);
+	cp->ddma_cfg |= DDMA_CFG_EN;	/* Enable channel */
+	au_sync();
+	cp->ddma_dbell = 0xffffffff;	/* Make it go */
+	au_sync();
+}
+
+void
+au1xxx_dbdma_reset(u32 chanid)
+{
+	chan_tab_t		*ctp;
+	au1x_ddma_desc_t	*dp;
+
+	au1xxx_dbdma_stop(chanid);
+
+	ctp = *((chan_tab_t **)chanid);
+	ctp->get_ptr = ctp->put_ptr = ctp->cur_ptr = ctp->chan_desc_base;
+
+	/* Run through the descriptors and reset the valid indicator.
+	*/
+	dp = ctp->chan_desc_base;
+
+	do {
+		dp->dscr_cmd0 &= ~DSCR_CMD0_V;
+		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+	} while (dp != ctp->chan_desc_base);
+}
+
+u32
+au1xxx_get_dma_residue(u32 chanid)
+{
+	chan_tab_t	*ctp;
+	volatile au1x_dma_chan_t *cp;
+	u32		rv;
+
+	ctp = *((chan_tab_t **)chanid);
+	cp = ctp->chan_ptr;
+
+	/* This is only valid if the channel is stopped.
+	*/
+	rv = cp->ddma_bytecnt;
+	au_sync();
+
+	return rv;
+}
+
+void
+au1xxx_dbdma_chan_free(u32 chanid)
+{
+	chan_tab_t	*ctp;
+	dbdev_tab_t	*stp, *dtp;
+
+	ctp = *((chan_tab_t **)chanid);
+	stp = ctp->chan_src;
+	dtp = ctp->chan_dest;
+
+	au1xxx_dbdma_stop(chanid);
+
+	if (ctp->chan_desc_base != NULL)
+		kfree(ctp->chan_desc_base);
+	
+	stp->dev_flags &= ~DEV_FLAGS_INUSE;
+	dtp->dev_flags &= ~DEV_FLAGS_INUSE;
+	chan_tab_ptr[ctp->chan_index] = NULL;
+
+	kfree(ctp);
+}
+
+static void
+dbdma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	u32	intstat;
+	u32	chan_index;
+	chan_tab_t		*ctp;
+	au1x_ddma_desc_t	*dp;
+	volatile au1x_dma_chan_t *cp;
+
+	intstat = dbdma_gptr->ddma_intstat;
+	au_sync();
+	chan_index = au_ffs(intstat) - 1;
+
+	ctp = chan_tab_ptr[chan_index];
+	cp = ctp->chan_ptr;
+	dp = ctp->cur_ptr;
+
+	/* Reset interrupt.
+	*/
+	cp->ddma_irq = 0;
+	au_sync();
+
+	if (ctp->chan_callback)
+		(ctp->chan_callback)(irq, ctp->chan_callparam, regs);
+
+	ctp->cur_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+	
+}
+
+static void
+au1xxx_dbdma_init(void)
+{
+	dbdma_gptr->ddma_config = 0;
+	dbdma_gptr->ddma_throttle = 0;
+	dbdma_gptr->ddma_inten = 0xffff;
+	au_sync();
+
+	if (request_irq(AU1550_DDMA_INT, dbdma_interrupt, SA_INTERRUPT,
+			"Au1xxx dbdma", (void *)dbdma_gptr))
+		printk("Can't get 1550 dbdma irq");
+}
+
+void
+au1xxx_dbdma_dump(u32 chanid)
+{
+	chan_tab_t		*ctp;
+	au1x_ddma_desc_t	*dp;
+	dbdev_tab_t		*stp, *dtp;
+	volatile au1x_dma_chan_t *cp;
+
+	ctp = *((chan_tab_t **)chanid);
+	stp = ctp->chan_src;
+	dtp = ctp->chan_dest;
+	cp = ctp->chan_ptr;
+
+	printk("Chan %x, stp %x (dev %d)  dtp %x (dev %d) \n",
+		(u32)ctp, (u32)stp, stp - dbdev_tab, (u32)dtp, dtp - dbdev_tab);
+	printk("desc base %x, get %x, put %x, cur %x\n",
+		(u32)(ctp->chan_desc_base), (u32)(ctp->get_ptr),
+		(u32)(ctp->put_ptr), (u32)(ctp->cur_ptr));
+	
+	printk("dbdma chan %x\n", (u32)cp);
+	printk("cfg %08x, desptr %08x, statptr %08x\n",
+		cp->ddma_cfg, cp->ddma_desptr, cp->ddma_statptr);
+	printk("dbell %08x, irq %08x, stat %08x, bytecnt %08x\n",
+		cp->ddma_dbell, cp->ddma_irq, cp->ddma_stat, cp->ddma_bytecnt);
+
+
+	/* Run through the descriptors
+	*/
+	dp = ctp->chan_desc_base;
+
+	do {
+		printk("dp %08x, cmd0 %08x, cmd1 %08x\n",
+			(u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
+		printk("src0 %08x, src1 %08x, dest0 %08x\n",
+			dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0);
+		printk("dest1 %08x, stat %08x, nxtptr %08x\n",
+			dp->dscr_dest1, dp->dscr_stat, dp->dscr_nxtptr);
+		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+	} while (dp != ctp->chan_desc_base);
+}
+
+#endif /* defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200) */
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/dma.c linux-mips-cvs-20040815/arch/mips/au1000/common/dma.c
--- linux-2.4.27/arch/mips/au1000/common/dma.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/dma.c	2004-05-05 14:38:38.000000000 +0200
@@ -40,6 +40,8 @@
 #include <asm/au1000_dma.h>
 #include <asm/system.h>
 
+#include <linux/module.h>
+
 #if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
 
 /*
@@ -73,7 +75,7 @@ struct dma_chan au1000_dma_table[NUM_AU1
 };
 
 // Device FIFO addresses and default DMA modes
-static const struct {
+static const struct dma_dev {
 	unsigned int fifo_addr;
 	unsigned int dma_mode;
 } dma_dev_table[DMA_NUM_DEV] = {
@@ -120,12 +122,19 @@ int au1000_dma_read_proc(char *buf, char
 	return len;
 }
 
+// Device FIFO addresses and default DMA modes - 2nd bank
+static const struct dma_dev dma_dev_table_bank2[DMA_NUM_DEV_BANK2] = {
+	{SD0_XMIT_FIFO, DMA_DS | DMA_DW8},		// coherent
+	{SD0_RECV_FIFO, DMA_DS | DMA_DR | DMA_DW8},	// coherent
+	{SD1_XMIT_FIFO, DMA_DS | DMA_DW8},		// coherent
+	{SD1_RECV_FIFO, DMA_DS | DMA_DR | DMA_DW8}	// coherent
+};
 
 void dump_au1000_dma_channel(unsigned int dmanr)
 {
 	struct dma_chan *chan;
 
-	if (dmanr > NUM_AU1000_DMA_CHANNELS)
+	if (dmanr >= NUM_AU1000_DMA_CHANNELS)
 		return;
 	chan = &au1000_dma_table[dmanr];
 
@@ -156,10 +165,16 @@ int request_au1000_dma(int dev_id, const
 		       void *irq_dev_id)
 {
 	struct dma_chan *chan;
+	const struct dma_dev *dev;
 	int i, ret;
 
-	if (dev_id < 0 || dev_id >= DMA_NUM_DEV)
+#if defined(CONFIG_SOC_AU1100)
+	if (dev_id < 0 || dev_id >= (DMA_NUM_DEV + DMA_NUM_DEV_BANK2))
 		return -EINVAL;
+#else
+ 	if (dev_id < 0 || dev_id >= DMA_NUM_DEV)
+ 		return -EINVAL;
+#endif
 
 	for (i = 0; i < NUM_AU1000_DMA_CHANNELS; i++) {
 		if (au1000_dma_table[i].dev_id < 0)
@@ -170,6 +185,13 @@ int request_au1000_dma(int dev_id, const
 
 	chan = &au1000_dma_table[i];
 
+	if (dev_id >= DMA_NUM_DEV) {
+		dev_id -= DMA_NUM_DEV;
+		dev = &dma_dev_table_bank2[dev_id];
+	} else {
+		dev = &dma_dev_table[dev_id];
+	}
+
 	if (irqhandler) {
 		chan->irq = AU1000_DMA_INT_BASE + i;
 		chan->irq_dev = irq_dev_id;
@@ -188,8 +210,8 @@ int request_au1000_dma(int dev_id, const
 	chan->io = DMA_CHANNEL_BASE + i * DMA_CHANNEL_LEN;
 	chan->dev_id = dev_id;
 	chan->dev_str = dev_str;
-	chan->fifo_addr = dma_dev_table[dev_id].fifo_addr;
-	chan->mode = dma_dev_table[dev_id].dma_mode;
+	chan->fifo_addr = dev->fifo_addr;
+	chan->mode = dev->dma_mode;
 
 	/* initialize the channel before returning */
 	init_dma(i);
@@ -213,4 +235,9 @@ void free_au1000_dma(unsigned int dmanr)
 	chan->irq_dev = NULL;
 	chan->dev_id = -1;
 }
+
+EXPORT_SYMBOL(free_au1000_dma);
+EXPORT_SYMBOL(au1000_dma_table);
+EXPORT_SYMBOL(request_au1000_dma);
+
 #endif // AU1000 AU1500 AU1100
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/irq.c linux-mips-cvs-20040815/arch/mips/au1000/common/irq.c
--- linux-2.4.27/arch/mips/au1000/common/irq.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/irq.c	2004-03-05 06:23:49.000000000 +0100
@@ -94,107 +94,6 @@ extern void counter0_irq(int irq, void *
 
 static spinlock_t irq_lock = SPIN_LOCK_UNLOCKED;
 
-static void setup_local_irq(unsigned int irq_nr, int type, int int_req)
-{
-	if (irq_nr > AU1000_MAX_INTR) return;
-	/* Config2[n], Config1[n], Config0[n] */
-	if (irq_nr > AU1000_LAST_INTC0_INT) {
-		switch (type) {
-			case INTC_INT_RISE_EDGE: /* 0:0:1 */
-				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG0SET);
-				break;
-			case INTC_INT_FALL_EDGE: /* 0:1:0 */
-				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG1SET);
-				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
-				break;
-			case INTC_INT_RISE_AND_FALL_EDGE: /* 0:1:1 */
-				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG1SET);
-				au_writel(1<<(irq_nr-32), IC1_CFG0SET);
-				break;
-			case INTC_INT_HIGH_LEVEL: /* 1:0:1 */
-				au_writel(1<<(irq_nr-32), IC1_CFG2SET);
-				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG0SET);
-				break;
-			case INTC_INT_LOW_LEVEL: /* 1:1:0 */
-				au_writel(1<<(irq_nr-32), IC1_CFG2SET);
-				au_writel(1<<(irq_nr-32), IC1_CFG1SET);
-				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
-				break;
-			case INTC_INT_DISABLED: /* 0:0:0 */
-				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
-				break;
-			default: /* disable the interrupt */
-				printk("unexpected int type %d (irq %d)\n", type, irq_nr);
-				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
-				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
-				return;
-		}
-		if (int_req) /* assign to interrupt request 1 */
-			au_writel(1<<(irq_nr-32), IC1_ASSIGNCLR);
-		else	     /* assign to interrupt request 0 */
-			au_writel(1<<(irq_nr-32), IC1_ASSIGNSET);
-		au_writel(1<<(irq_nr-32), IC1_SRCSET);
-		au_writel(1<<(irq_nr-32), IC1_MASKCLR);
-		au_writel(1<<(irq_nr-32), IC1_WAKECLR);
-	}
-	else {
-		switch (type) {
-			case INTC_INT_RISE_EDGE: /* 0:0:1 */
-				au_writel(1<<irq_nr, IC0_CFG2CLR);
-				au_writel(1<<irq_nr, IC0_CFG1CLR);
-				au_writel(1<<irq_nr, IC0_CFG0SET);
-				break;
-			case INTC_INT_FALL_EDGE: /* 0:1:0 */
-				au_writel(1<<irq_nr, IC0_CFG2CLR);
-				au_writel(1<<irq_nr, IC0_CFG1SET);
-				au_writel(1<<irq_nr, IC0_CFG0CLR);
-				break;
-			case INTC_INT_RISE_AND_FALL_EDGE: /* 0:1:1 */
-				au_writel(1<<irq_nr, IC0_CFG2CLR);
-				au_writel(1<<irq_nr, IC0_CFG1SET);
-				au_writel(1<<irq_nr, IC0_CFG0SET);
-				break;
-			case INTC_INT_HIGH_LEVEL: /* 1:0:1 */
-				au_writel(1<<irq_nr, IC0_CFG2SET);
-				au_writel(1<<irq_nr, IC0_CFG1CLR);
-				au_writel(1<<irq_nr, IC0_CFG0SET);
-				break;
-			case INTC_INT_LOW_LEVEL: /* 1:1:0 */
-				au_writel(1<<irq_nr, IC0_CFG2SET);
-				au_writel(1<<irq_nr, IC0_CFG1SET);
-				au_writel(1<<irq_nr, IC0_CFG0CLR);
-				break;
-			case INTC_INT_DISABLED: /* 0:0:0 */
-				au_writel(1<<irq_nr, IC0_CFG0CLR);
-				au_writel(1<<irq_nr, IC0_CFG1CLR);
-				au_writel(1<<irq_nr, IC0_CFG2CLR);
-				break;
-			default: /* disable the interrupt */
-				printk("unexpected int type %d (irq %d)\n", type, irq_nr);
-				au_writel(1<<irq_nr, IC0_CFG0CLR);
-				au_writel(1<<irq_nr, IC0_CFG1CLR);
-				au_writel(1<<irq_nr, IC0_CFG2CLR);
-				return;
-		}
-		if (int_req) /* assign to interrupt request 1 */
-			au_writel(1<<irq_nr, IC0_ASSIGNCLR);
-		else	     /* assign to interrupt request 0 */
-			au_writel(1<<irq_nr, IC0_ASSIGNSET);
-		au_writel(1<<irq_nr, IC0_SRCSET);
-		au_writel(1<<irq_nr, IC0_MASKCLR);
-		au_writel(1<<irq_nr, IC0_WAKECLR);
-	}
-	au_sync();
-}
-
 
 static unsigned int startup_irq(unsigned int irq_nr)
 {
@@ -410,6 +309,117 @@ void startup_match20_interrupt(void)
 }
 #endif
 
+static void setup_local_irq(unsigned int irq_nr, int type, int int_req)
+{
+	if (irq_nr > AU1000_MAX_INTR) return;
+	/* Config2[n], Config1[n], Config0[n] */
+	if (irq_nr > AU1000_LAST_INTC0_INT) {
+		switch (type) {
+			case INTC_INT_RISE_EDGE: /* 0:0:1 */
+				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG0SET);
+				irq_desc[irq_nr].handler = &rise_edge_irq_type;
+				break;
+			case INTC_INT_FALL_EDGE: /* 0:1:0 */
+				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG1SET);
+				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
+				irq_desc[irq_nr].handler = &fall_edge_irq_type;
+				break;
+			case INTC_INT_RISE_AND_FALL_EDGE: /* 0:1:1 */
+				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG1SET);
+				au_writel(1<<(irq_nr-32), IC1_CFG0SET);
+				irq_desc[irq_nr].handler = &either_edge_irq_type;
+				break;
+			case INTC_INT_HIGH_LEVEL: /* 1:0:1 */
+				au_writel(1<<(irq_nr-32), IC1_CFG2SET);
+				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG0SET);
+				irq_desc[irq_nr].handler = &level_irq_type;
+				break;
+			case INTC_INT_LOW_LEVEL: /* 1:1:0 */
+				au_writel(1<<(irq_nr-32), IC1_CFG2SET);
+				au_writel(1<<(irq_nr-32), IC1_CFG1SET);
+				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
+				irq_desc[irq_nr].handler = &level_irq_type;
+				break;
+			case INTC_INT_DISABLED: /* 0:0:0 */
+				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
+				break;
+			default: /* disable the interrupt */
+				printk("unexpected int type %d (irq %d)\n", type, irq_nr);
+				au_writel(1<<(irq_nr-32), IC1_CFG0CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG1CLR);
+				au_writel(1<<(irq_nr-32), IC1_CFG2CLR);
+				return;
+		}
+		if (int_req) /* assign to interrupt request 1 */
+			au_writel(1<<(irq_nr-32), IC1_ASSIGNCLR);
+		else	     /* assign to interrupt request 0 */
+			au_writel(1<<(irq_nr-32), IC1_ASSIGNSET);
+		au_writel(1<<(irq_nr-32), IC1_SRCSET);
+		au_writel(1<<(irq_nr-32), IC1_MASKCLR);
+		au_writel(1<<(irq_nr-32), IC1_WAKECLR);
+	}
+	else {
+		switch (type) {
+			case INTC_INT_RISE_EDGE: /* 0:0:1 */
+				au_writel(1<<irq_nr, IC0_CFG2CLR);
+				au_writel(1<<irq_nr, IC0_CFG1CLR);
+				au_writel(1<<irq_nr, IC0_CFG0SET);
+				irq_desc[irq_nr].handler = &rise_edge_irq_type;
+				break;
+			case INTC_INT_FALL_EDGE: /* 0:1:0 */
+				au_writel(1<<irq_nr, IC0_CFG2CLR);
+				au_writel(1<<irq_nr, IC0_CFG1SET);
+				au_writel(1<<irq_nr, IC0_CFG0CLR);
+				irq_desc[irq_nr].handler = &fall_edge_irq_type;
+				break;
+			case INTC_INT_RISE_AND_FALL_EDGE: /* 0:1:1 */
+				au_writel(1<<irq_nr, IC0_CFG2CLR);
+				au_writel(1<<irq_nr, IC0_CFG1SET);
+				au_writel(1<<irq_nr, IC0_CFG0SET);
+				irq_desc[irq_nr].handler = &either_edge_irq_type;
+				break;
+			case INTC_INT_HIGH_LEVEL: /* 1:0:1 */
+				au_writel(1<<irq_nr, IC0_CFG2SET);
+				au_writel(1<<irq_nr, IC0_CFG1CLR);
+				au_writel(1<<irq_nr, IC0_CFG0SET);
+				irq_desc[irq_nr].handler = &level_irq_type;
+				break;
+			case INTC_INT_LOW_LEVEL: /* 1:1:0 */
+				au_writel(1<<irq_nr, IC0_CFG2SET);
+				au_writel(1<<irq_nr, IC0_CFG1SET);
+				au_writel(1<<irq_nr, IC0_CFG0CLR);
+				irq_desc[irq_nr].handler = &level_irq_type;
+				break;
+			case INTC_INT_DISABLED: /* 0:0:0 */
+				au_writel(1<<irq_nr, IC0_CFG0CLR);
+				au_writel(1<<irq_nr, IC0_CFG1CLR);
+				au_writel(1<<irq_nr, IC0_CFG2CLR);
+				break;
+			default: /* disable the interrupt */
+				printk("unexpected int type %d (irq %d)\n", type, irq_nr);
+				au_writel(1<<irq_nr, IC0_CFG0CLR);
+				au_writel(1<<irq_nr, IC0_CFG1CLR);
+				au_writel(1<<irq_nr, IC0_CFG2CLR);
+				return;
+		}
+		if (int_req) /* assign to interrupt request 1 */
+			au_writel(1<<irq_nr, IC0_ASSIGNCLR);
+		else	     /* assign to interrupt request 0 */
+			au_writel(1<<irq_nr, IC0_ASSIGNSET);
+		au_writel(1<<irq_nr, IC0_SRCSET);
+		au_writel(1<<irq_nr, IC0_MASKCLR);
+		au_writel(1<<irq_nr, IC0_WAKECLR);
+	}
+	au_sync();
+}
+
 
 void __init init_IRQ(void)
 {
@@ -417,7 +427,9 @@ void __init init_IRQ(void)
 	unsigned long cp0_status;
 	au1xxx_irq_map_t *imp;
 	extern au1xxx_irq_map_t au1xxx_irq_map[];
+	extern au1xxx_irq_map_t au1xxx_ic0_map[];
 	extern int au1xxx_nr_irqs;
+	extern int au1xxx_ic0_nr_irqs;
 
 	cp0_status = read_c0_status();
 	memset(irq_desc, 0, sizeof(irq_desc));
@@ -425,45 +437,43 @@ void __init init_IRQ(void)
 
 	init_generic_irq();
 
-	for (i = 0; i <= AU1000_MAX_INTR; i++) {
-		/* default is active high, level interrupt */
-		setup_local_irq(i, INTC_INT_HIGH_LEVEL, 0);
-		irq_desc[i].handler = &level_irq_type;
+	/* Initialize interrupt controllers to a safe state.
+	*/
+	au_writel(0xffffffff, IC0_CFG0CLR);
+	au_writel(0xffffffff, IC0_CFG1CLR);
+	au_writel(0xffffffff, IC0_CFG2CLR);
+	au_writel(0xffffffff, IC0_MASKCLR);
+	au_writel(0xffffffff, IC0_ASSIGNSET);
+	au_writel(0xffffffff, IC0_WAKECLR);
+	au_writel(0xffffffff, IC0_SRCSET);
+	au_writel(0xffffffff, IC0_FALLINGCLR);
+	au_writel(0xffffffff, IC0_RISINGCLR);
+	au_writel(0x00000000, IC0_TESTBIT);
+
+	au_writel(0xffffffff, IC1_CFG0CLR);
+	au_writel(0xffffffff, IC1_CFG1CLR);
+	au_writel(0xffffffff, IC1_CFG2CLR);
+	au_writel(0xffffffff, IC1_MASKCLR);
+	au_writel(0xffffffff, IC1_ASSIGNSET);
+	au_writel(0xffffffff, IC1_WAKECLR);
+	au_writel(0xffffffff, IC1_SRCSET);
+	au_writel(0xffffffff, IC1_FALLINGCLR);
+	au_writel(0xffffffff, IC1_RISINGCLR);
+	au_writel(0x00000000, IC1_TESTBIT);
+
+	/* Initialize IC0, which is fixed per processor.
+	*/
+	imp = au1xxx_ic0_map;
+	for (i=0; i<au1xxx_ic0_nr_irqs; i++) {
+		setup_local_irq(imp->im_irq, imp->im_type, imp->im_request);
+		imp++;
 	}
 
 	/* Now set up the irq mapping for the board.
 	*/
 	imp = au1xxx_irq_map;
 	for (i=0; i<au1xxx_nr_irqs; i++) {
-
 		setup_local_irq(imp->im_irq, imp->im_type, imp->im_request);
-
-		switch (imp->im_type) {
-
-		case INTC_INT_HIGH_LEVEL:
-			irq_desc[imp->im_irq].handler = &level_irq_type;
-			break;
-
-		case INTC_INT_LOW_LEVEL:
-			irq_desc[imp->im_irq].handler = &level_irq_type;
-			break;
-
-		case INTC_INT_RISE_EDGE:
-			irq_desc[imp->im_irq].handler = &rise_edge_irq_type;
-			break;
-
-		case INTC_INT_FALL_EDGE:
-			irq_desc[imp->im_irq].handler = &fall_edge_irq_type;
-			break;
-
-		case INTC_INT_RISE_AND_FALL_EDGE:
-			irq_desc[imp->im_irq].handler = &either_edge_irq_type;
-			break;
-
-		default:
-			panic("Unknown au1xxx irq map");
-			break;
-		}
 		imp++;
 	}
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/pci_fixup.c linux-mips-cvs-20040815/arch/mips/au1000/common/pci_fixup.c
--- linux-2.4.27/arch/mips/au1000/common/pci_fixup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/pci_fixup.c	2004-05-02 00:47:21.000000000 +0200
@@ -54,9 +54,7 @@
 #endif
 
 static void fixup_resource(int r_num, struct pci_dev *dev) ;
-#if defined( CONFIG_SOC_AU1500 ) || defined( CONFIG_SOC_AU1550 )
 static unsigned long virt_io_addr;
-#endif
 
 void __init pcibios_fixup_resources(struct pci_dev *dev)
 {
@@ -66,8 +64,6 @@ void __init pcibios_fixup_resources(stru
 void __init pcibios_fixup(void)
 {
 #if defined( CONFIG_SOC_AU1500 ) || defined( CONFIG_SOC_AU1550 )
-	int i;
-	struct pci_dev *dev;
 	
 	virt_io_addr = (unsigned long)ioremap(Au1500_PCI_IO_START, 
 			Au1500_PCI_IO_END - Au1500_PCI_IO_START + 1);
@@ -106,9 +102,10 @@ void __init pcibios_fixup(void)
 void __init pcibios_fixup_irqs(void)
 {
 #if defined( CONFIG_SOC_AU1500 ) || defined( CONFIG_SOC_AU1550 )
-	unsigned int slot, func;
+	unsigned int slot;
 	unsigned char pin;
 	struct pci_dev *dev;
+	extern int au1xxx_pci_irqmap(struct pci_dev *dev, unsigned char idsel, unsigned char pin);
 
 	pci_for_each_dev(dev) {
 		if (dev->bus->number != 0)
@@ -116,26 +113,9 @@ void __init pcibios_fixup_irqs(void)
 
 		dev->irq = 0xff;
 		slot = PCI_SLOT(dev->devfn);
-#if defined( CONFIG_SOC_AU1500 )
-		switch (slot) {
-			case 12:
-			case 13:
-			default:
-				dev->irq = AU1000_PCI_INTA;
-				break;
-		}
-#elif defined( CONFIG_SOC_AU1550 )
-		switch (slot) {
-			default:
-			case 12:
-				dev->irq = AU1000_PCI_INTA;
-				break;
-			case 13:
-				dev->irq = AU1000_PCI_INTB;
-				break;
-		}
-#endif
-
+		pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
+		dev->irq = au1xxx_pci_irqmap(dev, slot, pin);
+		//printk("Bus %d Dev %d Pin %d Irq %d\n", dev->bus->number, slot, pin, dev->irq);
 		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
 		DBG("slot %d irq %d\n", slot, dev->irq);
 	}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/power.c linux-mips-cvs-20040815/arch/mips/au1000/common/power.c
--- linux-2.4.27/arch/mips/au1000/common/power.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/power.c	2004-05-05 14:38:38.000000000 +0200
@@ -319,7 +319,7 @@ static int pm_do_freq(ctl_table * ctl, i
 	unsigned long val, pll;
 #define TMPBUFLEN 64
 #define MAX_CPU_FREQ 396
-	char buf[8], *p;
+	char buf[TMPBUFLEN], *p;
 	unsigned long flags, intc0_mask, intc1_mask;
 	unsigned long old_baud_base, old_cpu_freq, baud_rate, old_clk,
 	    old_refresh;
@@ -357,7 +357,7 @@ static int pm_do_freq(ctl_table * ctl, i
 		old_cpu_freq = get_au1x00_speed();
 
 		new_cpu_freq = pll * 12 * 1000000;
-		new_baud_base = (new_cpu_freq / 4) / 16;
+	        new_baud_base =  (new_cpu_freq / (2 * ((int)(au_readl(SYS_POWERCTRL)&0x03) + 2) * 16));
 		set_au1x00_speed(new_cpu_freq);
 		set_au1x00_uart_baud_base(new_baud_base);
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/prom.c linux-mips-cvs-20040815/arch/mips/au1000/common/prom.c
--- linux-2.4.27/arch/mips/au1000/common/prom.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/prom.c	2004-02-22 00:11:20.000000000 +0100
@@ -68,6 +68,11 @@ void  prom_init_cmdline(void)
 	actr = 1; /* Always ignore argv[0] */
 
 	cp = &(arcs_cmdline[0]);
+#ifdef CONFIG_CMDLINE_BOOL
+	strcpy(cp, CONFIG_CMDLINE);
+	cp += strlen(CONFIG_CMDLINE);
+	*cp++ = ' ';
+#endif
 	while(actr < prom_argc) {
 	        strcpy(cp, prom_argv[actr]);
 		cp += strlen(prom_argv[actr]);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/reset.c linux-mips-cvs-20040815/arch/mips/au1000/common/reset.c
--- linux-2.4.27/arch/mips/au1000/common/reset.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/reset.c	2004-08-15 08:05:46.000000000 +0200
@@ -42,6 +42,7 @@ extern int au_sleep(void);
 void au1000_restart(char *command)
 {
 	/* Set all integrated peripherals to disabled states */
+	extern void board_reset (void);
 	u32 prid = read_c0_prid();
 
 	printk(KERN_NOTICE "\n** Resetting Integrated Peripherals\n");
@@ -120,6 +121,29 @@ void au1000_restart(char *command)
 		au_writel(0x00, 0xb1900064); /* sys_auxpll */
 		au_writel(0x00, 0xb1900100); /* sys_pininputen */
 		break;
+	case 0x03000000: /* Au1550 */
+		au_writel(0x00, 0xb1a00004); /* psc 0 */
+		au_writel(0x00, 0xb1b00004); /* psc 1 */
+		au_writel(0x00, 0xb0a00004); /* psc 2 */
+		au_writel(0x00, 0xb0b00004); /* psc 3 */
+		au_writel(0x00, 0xb017fffc); /* usbh_enable */
+		au_writel(0x00, 0xb0200058); /* usbd_enable */
+		au_writel(0x00, 0xb4004104); /* mac dma */
+		au_writel(0x00, 0xb4004114); /* mac dma */
+		au_writel(0x00, 0xb4004124); /* mac dma */
+		au_writel(0x00, 0xb4004134); /* mac dma */
+		au_writel(0x00, 0xb1520000); /* macen0 */
+		au_writel(0x00, 0xb1520004); /* macen1 */
+		au_writel(0x00, 0xb1100100); /* uart0_enable */
+		au_writel(0x00, 0xb1200100); /* uart1_enable */
+		au_writel(0x00, 0xb1400100); /* uart3_enable */
+		au_writel(0x00, 0xb1900020); /* sys_freqctrl0 */
+		au_writel(0x00, 0xb1900024); /* sys_freqctrl1 */
+		au_writel(0x00, 0xb1900028); /* sys_clksrc */
+		au_writel(0x10, 0xb1900060); /* sys_cpupll */
+		au_writel(0x00, 0xb1900064); /* sys_auxpll */
+		au_writel(0x00, 0xb1900100); /* sys_pininputen */
+		break;
 
 	default:
 		break;
@@ -130,18 +154,26 @@ void au1000_restart(char *command)
 	flush_cache_all();
 	write_c0_wired(0);
 
-#if defined(CONFIG_MIPS_PB1500) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500)
-	/* Do a HW reset if the board can do it */
-
-	au_writel(0x00000000, 0xAE00001C);
-#endif
+	/* Give board a chance to do a hardware reset */
+	board_reset();
 
+	/* Jump to the beggining in case board_reset() is empty */
 	__asm__ __volatile__("jr\t%0"::"r"(0xbfc00000));
 }
 
 void au1000_halt(void)
 {
+#if defined(CONFIG_MIPS_PB1550)
+	/* power off system */
+	printk("\n** Powering off Pb1550\n");
+	au_writew(au_readw(0xAF00001C) | (3<<14), 0xAF00001C); 
+	au_sync();
+	while(1); /* should not get here */
+#endif
 	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+#ifdef CONFIG_MIPS_MIRAGE
+	au_writel((1 << 26) | (1 << 10), GPIO2_OUTPUT);
+#endif
 #ifdef CONFIG_PM
 	au_sleep();
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/setup.c linux-mips-cvs-20040815/arch/mips/au1000/common/setup.c
--- linux-2.4.27/arch/mips/au1000/common/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/setup.c	2004-05-02 00:47:21.000000000 +0200
@@ -52,6 +52,7 @@ extern void * __rd_start, * __rd_end;
 #endif
 
 #ifdef CONFIG_BLK_DEV_IDE
+extern struct ide_ops no_ide_ops;
 extern struct ide_ops std_ide_ops;
 extern struct ide_ops *ide_ops;
 #endif
@@ -64,22 +65,47 @@ extern void au1000_halt(void);
 extern void au1000_power_off(void);
 extern struct resource ioport_resource;
 extern struct resource iomem_resource;
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_SOC_AU1500)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && (defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550))
 extern phys_t (*fixup_bigphys_addr)(phys_t phys_addr, phys_t size);
 static phys_t au1500_fixup_bigphys_addr(phys_t phys_addr, phys_t size);
 #endif
 extern void au1xxx_time_init(void);
 extern void au1xxx_timer_setup(void);
+extern void set_cpuspec(void);
 
 void __init au1x00_setup(void)
 {
+	struct	cpu_spec *sp;
 	char *argptr;
+	unsigned long prid, cpupll, bclk;
 
-	/* Various early Au1000 Errata corrected by this */
-	set_c0_config(1<<19); /* Config[OD] */
+	set_cpuspec();
+	sp = cur_cpu_spec[0];
 
 	board_setup();  /* board specific setup */
 
+	prid = read_c0_prid();
+	cpupll = (au_readl(0xB1900060) & 0x3F) * 12;
+
+	printk("%s (PRId %08X) @ %dMHZ\n", sp->cpu_name, prid, cpupll);
+
+	bclk = sp->cpu_bclk;
+	if (bclk) {
+		/* Enable BCLK switching */
+		bclk = au_readl(0xB190003C);
+		au_writel(bclk | 0x60, 0xB190003C);
+		printk("BCLK switching enabled!\n");
+	}
+
+	if (sp->cpu_od) {
+		/* Various early Au1000 Errata corrected by this */
+		set_c0_config(1<<19); /* Set Config[OD] */
+	}
+	else {
+		/* Clear to obtain best system bus performance */
+		clear_c0_config(1<<19); /* Clear Config[OD] */
+ 	}
+
 	argptr = prom_getcmdline();
 
 #ifdef CONFIG_AU1X00_SERIAL_CONSOLE
@@ -128,7 +154,7 @@ void __init au1x00_setup(void)
 	_machine_restart = au1000_restart;
 	_machine_halt = au1000_halt;
 	_machine_power_off = au1000_power_off;
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_SOC_AU1500)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && (defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550))
 	fixup_bigphys_addr = au1500_fixup_bigphys_addr;
 #endif
 
@@ -185,7 +211,7 @@ void __init au1x00_setup(void)
 #ifdef CONFIG_BLK_DEV_IDE
 	/* Board setup takes precedence for unique devices.
 	*/
-	if (ide_ops == NULL)
+	if ((ide_ops == NULL) || (ide_ops == &no_ide_ops))
 		ide_ops = &std_ide_ops;
 #endif
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/common/time.c linux-mips-cvs-20040815/arch/mips/au1000/common/time.c
--- linux-2.4.27/arch/mips/au1000/common/time.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/common/time.c	2004-08-15 08:05:46.000000000 +0200
@@ -49,10 +49,6 @@
 #include <linux/mc146818rtc.h>
 #include <linux/timex.h>
 
-#if !defined(CONFIG_NEW_TIME_C)
-#error "Alchemy processors need CONFIG_NEW_TIME_C defined"
-#endif
-
 extern void startup_match20_interrupt(void);
 extern void do_softirq(void);
 extern volatile unsigned long wall_jiffies;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/csb250/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/csb250/irqmap.c
--- linux-2.4.27/arch/mips/au1000/csb250/irqmap.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/csb250/irqmap.c	2004-03-05 06:23:49.000000000 +0100
@@ -48,53 +48,13 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
 
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_205, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_207, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
-	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
 };
 
 int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/db1x00/Makefile linux-mips-cvs-20040815/arch/mips/au1000/db1x00/Makefile
--- linux-2.4.27/arch/mips/au1000/db1x00/Makefile	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/db1x00/Makefile	2004-03-10 00:53:24.000000000 +0100
@@ -10,13 +10,11 @@
 # unless it's something special (ie not a .c file).
 #
 
-.S.s:
-	$(CPP) $(CFLAGS) $< -o $*.s
-.S.o:
-	$(CC) $(CFLAGS) -c $< -o $*.o
+USE_STANDARD_AS_RULE := true
 
 O_TARGET := db1x00.o
 
 obj-y := init.o board_setup.o irqmap.o
+obj-$(CONFIG_WM97XX_COMODULE) += mirage_ts.o
 
 include $(TOPDIR)/Rules.make
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/db1x00/board_setup.c linux-mips-cvs-20040815/arch/mips/au1000/db1x00/board_setup.c
--- linux-2.4.27/arch/mips/au1000/db1x00/board_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/db1x00/board_setup.c	2004-08-15 08:05:46.000000000 +0200
@@ -48,14 +48,22 @@
 
 extern struct rtc_ops no_rtc_ops;
 
+/* not correct for db1550 */
 static BCSR * const bcsr = (BCSR *)0xAE000000;
 
+void board_reset (void)
+{
+	/* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
+	au_writel(0x00000000, 0xAE00001C);
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
 
 	rtc_ops = &no_rtc_ops;
 
+	/* not valid for 1550 */
 #ifdef CONFIG_AU1X00_USB_DEVICE
 	// 2nd USB port is USB device
 	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8000);
@@ -73,6 +81,35 @@ void __init board_setup(void)
 #endif
 	au_writel(0, 0xAE000010); /* turn off pcmcia power */
 
+#ifdef CONFIG_MIPS_MIRAGE
+	/* enable GPIO[31:0] inputs */
+	au_writel(0, SYS_PININPUTEN);
+
+	/* GPIO[20] is output, tristate the other input primary GPIO's */
+	au_writel((u32)(~(1<<20)), SYS_TRIOUTCLR);
+
+	/* set GPIO[210:208] instead of SSI_0 */
+	pin_func = au_readl(SYS_PINFUNC) | (u32)(1);
+
+	/* set GPIO[215:211] for LED's */
+	pin_func |= (u32)((5<<2));
+
+	/* set GPIO[214:213] for more LED's */
+	pin_func |= (u32)((5<<12));
+
+	/* set GPIO[207:200] instead of PCMCIA/LCD */
+	pin_func |= (u32)((3<<17));
+	au_writel(pin_func, SYS_PINFUNC);
+
+	/* Enable speaker amplifier.  This should
+	 * be part of the audio driver.
+	 */
+	au_writel(au_readl(GPIO2_DIR) | 0x200, GPIO2_DIR);
+	au_writel(0x02000200, GPIO2_OUTPUT);
+#endif
+
+	au_sync();
+
 #ifdef CONFIG_MIPS_DB1000
     printk("AMD Alchemy Au1000/Db1000 Board\n");
 #endif
@@ -88,4 +125,7 @@ void __init board_setup(void)
 #ifdef CONFIG_MIPS_MIRAGE
     printk("AMD Alchemy Mirage Board\n");
 #endif
+#ifdef CONFIG_MIPS_DB1550
+    printk("AMD Alchemy Au1550/Db1550 Board\n");
+#endif
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/db1x00/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/db1x00/irqmap.c
--- linux-2.4.27/arch/mips/au1000/db1x00/irqmap.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/db1x00/irqmap.c	2004-05-02 00:47:22.000000000 +0200
@@ -48,71 +48,95 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_MIRAGE)
-	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-#endif
+
 #ifndef CONFIG_MIPS_MIRAGE
-	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
+#ifdef CONFIG_MIPS_DB1550
+	{ AU1000_GPIO_3, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 IRQ#
+	{ AU1000_GPIO_5, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 IRQ#
+#else
+	{ AU1000_GPIO_0, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 Fully_Interted#
+	{ AU1000_GPIO_1, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 STSCHG#
+	{ AU1000_GPIO_2, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 IRQ#
+
+	{ AU1000_GPIO_3, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 Fully_Interted#
+	{ AU1000_GPIO_4, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 STSCHG#
+	{ AU1000_GPIO_5, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 IRQ#
 #endif
+#else
+	{ AU1000_GPIO_7, INTC_INT_RISE_EDGE, 0 }, /* touchscreen pendown */
+#endif
+};
 
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
+#ifdef CONFIG_PCI
 
 #ifdef CONFIG_SOC_AU1500
-	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
+#define INTA AU1000_PCI_INTA
+#define INTB AU1000_PCI_INTB
+#define INTC AU1000_PCI_INTC
+#define INTD AU1000_PCI_INTD
+#endif
+
+#ifdef CONFIG_SOC_AU1550
+#define INTA AU1550_PCI_INTA
+#define INTB AU1550_PCI_INTB
+#define INTC AU1550_PCI_INTC
+#define INTD AU1550_PCI_INTD
 #endif
 
+#define INTX 0xFF /* not valid */
+
+int __init
+au1xxx_pci_irqmap(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	/*
+	 *	PCI IDSEL/INTPIN->INTLINE
+	 *	A       B       C       D
+	 */
 #ifdef CONFIG_MIPS_DB1500
-	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1500_GPIO_205, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1500_GPIO_207, INTC_INT_LOW_LEVEL, 0 },
+	static char pci_irq_table[][4] =
+	{
+		{INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT371   */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+	};
+	const long min_idsel = 12, max_idsel = 13, irqs_per_slot = 4;
 #endif
 
-#ifndef CONFIG_MIPS_MIRAGE
-	{ AU1000_GPIO_0, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 Fully_Interted#
-	{ AU1000_GPIO_1, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 STSCHG#
-	{ AU1000_GPIO_2, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 0 IRQ#
+#ifdef CONFIG_MIPS_BOSPORUS
+	static char pci_irq_table[][4] =
+	{
+		{INTA, INTB, INTX, INTX},   /* IDSEL 11 - miniPCI  */
+		{INTA, INTX, INTX, INTX},   /* IDSEL 12 - SN1741   */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+	};
+	const long min_idsel = 11, max_idsel = 13, irqs_per_slot = 4;
+#endif
 
-	{ AU1000_GPIO_3, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 Fully_Interted#
-	{ AU1000_GPIO_4, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 STSCHG#
-	{ AU1000_GPIO_5, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card 1 IRQ#
+#ifdef CONFIG_MIPS_MIRAGE
+	static char pci_irq_table[][4] =
+	{
+		{INTD, INTX, INTX, INTX},   /* IDSEL 11 - SMI VGX */
+		{INTX, INTX, INTC, INTX},   /* IDSEL 12 - PNX1300 */
+		{INTA, INTB, INTX, INTX},   /* IDSEL 13 - miniPCI */
+	};
+	const long min_idsel = 11, max_idsel = 13, irqs_per_slot = 4;
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+	static char pci_irq_table[][4] =
+	{
+		{INTC, INTX, INTX, INTX},   /* IDSEL 11 - on-board HPT371    */
+		{INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+	};
+	const long min_idsel = 11, max_idsel = 13, irqs_per_slot = 4;
+#endif
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1500)
+	return PCI_IRQ_TABLE_LOOKUP;
+#else
+	return 0;
 #endif
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
-	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
 };
+#endif
 
-int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/db1x00/mirage_ts.c linux-mips-cvs-20040815/arch/mips/au1000/db1x00/mirage_ts.c
--- linux-2.4.27/arch/mips/au1000/db1x00/mirage_ts.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/db1x00/mirage_ts.c	2004-02-22 00:11:54.000000000 +0100
@@ -0,0 +1,263 @@
+/*
+ * linux/arch/mips/au1000/db1x00/mirage_ts.c
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Glue between Mirage board-specific touchscreen pieces
+ *	and generic Wolfson Codec touchscreen support.
+ *
+ *	Based on pb1100_ts.c used in Hydrogen II.
+ *
+ * Copyright (c) 2003 Embedded Edge, LLC
+ *		dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED	  ``AS	IS'' AND   ANY	EXPRESS OR IMPLIED
+ *  WARRANTIES,	  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO	EVENT  SHALL   THE AUTHOR  BE	 LIABLE FOR ANY	  DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED	  TO, PROCUREMENT OF  SUBSTITUTE GOODS	OR SERVICES; LOSS OF
+ *  USE, DATA,	OR PROFITS; OR	BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN	 CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+
+#include <asm/segment.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <asm/au1000.h>
+
+/*
+ *  Imported interface to Wolfson Codec driver.
+ */
+extern void *wm97xx_ts_get_handle(int which);
+extern int wm97xx_ts_ready(void* ts_handle);
+extern void wm97xx_ts_set_cal(void* ts_handle, int xscale, int xtrans, int yscale, int ytrans);
+extern u16 wm97xx_ts_get_ac97(void* ts_handle, u8 reg);
+extern void wm97xx_ts_set_ac97(void* ts_handle, u8 reg, u16 val);
+extern int wm97xx_ts_read_data(void* ts_handle, long* x, long* y, long* pressure);
+extern void wm97xx_ts_send_data(void* ts_handle, long x, long y, long z);
+
+int wm97xx_comodule_present = 1;
+
+
+#define TS_NAME "mirage_ts"
+
+#define err(format, arg...) printk(KERN_ERR TS_NAME ": " format "\n" , ## arg)
+#define info(format, arg...) printk(KERN_INFO TS_NAME ": " format "\n" , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING TS_NAME ": " format "\n" , ## arg)
+#define DPRINTK(format, arg...) printk(__FUNCTION__ ": " format "\n" , ## arg)
+
+
+#define PEN_DOWN_IRQ	AU1000_GPIO_7
+
+static struct task_struct *ts_task = 0;
+static DECLARE_COMPLETION(ts_complete);
+static DECLARE_WAIT_QUEUE_HEAD(pendown_wait);
+
+#ifdef CONFIG_WM97XX_FIVEWIRETS
+static int release_pressure = 1;
+#else
+static int release_pressure = 50;
+#endif
+
+typedef struct {
+   long x;
+   long y;
+} DOWN_EVENT;
+
+#define SAMPLE_RATE	50	/* samples per second */
+#define PEN_DEBOUNCE	5	/* samples for settling - fn of SAMPLE_RATE */
+#define PEN_UP_TIMEOUT	10	/* in seconds */
+#define PEN_UP_SETTLE	5	/* samples per second */
+
+static struct {
+	int xscale;
+	int xtrans;
+	int yscale;
+	int ytrans;
+} mirage_ts_cal =
+{
+#if 0
+	xscale:   84,
+	xtrans: -157,
+	yscale:   66,
+	ytrans: -150,
+#else
+	xscale:   84,
+	xtrans: -150,
+	yscale:   66,
+	ytrans: -146,
+#endif
+};
+
+
+static void pendown_irq(int irqnr, void *devid, struct pt_regs *regs)
+{
+//DPRINTK("got one 0x%x", au_readl(SYS_PINSTATERD));
+	wake_up(&pendown_wait);
+}
+
+static int ts_thread(void *id)
+{
+	static int pen_was_down = 0;
+	static DOWN_EVENT pen_xy;
+	long x, y, z;
+	void *ts;	/* handle */
+	struct task_struct *tsk = current;
+	int timeout = HZ / SAMPLE_RATE;
+
+	ts_task = tsk;
+
+	daemonize();
+	tsk->tty = NULL;
+	tsk->policy = SCHED_FIFO;
+	tsk->rt_priority = 1;
+	strcpy(tsk->comm, "touchscreen");
+
+	/* only want to receive SIGKILL */
+	spin_lock_irq(&tsk->sigmask_lock);
+	siginitsetinv(&tsk->blocked, sigmask(SIGKILL));
+	recalc_sigpending(tsk);
+	spin_unlock_irq(&tsk->sigmask_lock);
+
+	/* get handle for codec */
+	ts = wm97xx_ts_get_handle(0);
+
+	/* proceed only after everybody is ready */
+	while ( ! wm97xx_ts_ready(ts) ) {
+		/* give a little time for initializations to complete */
+		interruptible_sleep_on_timeout(&pendown_wait, HZ / 4);
+	}
+
+	/* board-specific calibration */
+	wm97xx_ts_set_cal(ts,
+			mirage_ts_cal.xscale,
+			mirage_ts_cal.xtrans,
+			mirage_ts_cal.yscale,
+			mirage_ts_cal.ytrans);
+
+	/* route Wolfson pendown interrupts to our GPIO */
+	au_sync();
+	wm97xx_ts_set_ac97(ts, 0x4c, wm97xx_ts_get_ac97(ts, 0x4c) & ~0x0008);
+	au_sync();
+	wm97xx_ts_set_ac97(ts, 0x56, wm97xx_ts_get_ac97(ts, 0x56) & ~0x0008);
+	au_sync();
+	wm97xx_ts_set_ac97(ts, 0x52, wm97xx_ts_get_ac97(ts, 0x52) | 0x2008);
+	au_sync();
+
+	for (;;) {
+		interruptible_sleep_on_timeout(&pendown_wait, timeout);
+		disable_irq(PEN_DOWN_IRQ);
+		if (signal_pending(tsk)) {
+			break;
+		}
+
+		/* read codec */
+		if (!wm97xx_ts_read_data(ts, &x, &y, &z))
+			z = 0;	/* treat no-data and pen-up the same */
+
+		if (signal_pending(tsk)) {
+			break;
+		}
+
+		if (z >= release_pressure) {
+			y = ~y;	/* top to bottom */
+			if (pen_was_down > 1 /*&& pen_was_down < PEN_DEBOUNCE*/) {//THXXX
+				/* bounce ? */
+				x = pen_xy.x;
+				y = pen_xy.y;
+				--pen_was_down;
+			} else if (pen_was_down <= 1) {
+				pen_xy.x = x;
+				pen_xy.y = y;
+				if (pen_was_down)
+					wm97xx_ts_send_data(ts, x, y, z);
+				pen_was_down = PEN_DEBOUNCE;
+			}
+			//wm97xx_ts_send_data(ts, x, y, z);
+			timeout = HZ / SAMPLE_RATE;
+		} else {
+			if (pen_was_down) {
+				if (--pen_was_down)
+					z = release_pressure;
+				else //THXXX
+				wm97xx_ts_send_data(ts, pen_xy.x, pen_xy.y, z);
+			}
+			/* The pendown signal takes some time to settle after
+			 * reading the pen pressure so wait a little
+			 * before enabling the pen.
+			 */
+			if (! pen_was_down) {
+//				interruptible_sleep_on_timeout(&pendown_wait, HZ / PEN_UP_SETTLE);
+				timeout = HZ * PEN_UP_TIMEOUT;
+			}
+		}
+		enable_irq(PEN_DOWN_IRQ);
+	}
+	enable_irq(PEN_DOWN_IRQ);
+	ts_task = NULL;
+	complete(&ts_complete);
+	return 0;
+}
+
+static int __init ts_mirage_init(void)
+{
+	int ret;
+
+	/* pen down signal is connected to GPIO 7 */
+
+	ret = request_irq(PEN_DOWN_IRQ, pendown_irq, 0, "ts-pendown", NULL);
+	if (ret) {
+		err("unable to get pendown irq%d: [%d]", PEN_DOWN_IRQ, ret);
+		return ret;
+	}
+
+	lock_kernel();
+	ret = kernel_thread(ts_thread, NULL, CLONE_FS | CLONE_FILES);
+	if (ret < 0) {
+		unlock_kernel();
+		return ret;
+	}
+	unlock_kernel();
+
+	info("Mirage touchscreen IRQ initialized.");
+
+	return 0;
+}
+
+static void __exit ts_mirage_exit(void)
+{
+	if (ts_task) {
+		send_sig(SIGKILL, ts_task, 1);
+		wait_for_completion(&ts_complete);
+	}
+
+	free_irq(PEN_DOWN_IRQ, NULL);
+}
+
+module_init(ts_mirage_init);
+module_exit(ts_mirage_exit);
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/hydrogen3/Makefile linux-mips-cvs-20040815/arch/mips/au1000/hydrogen3/Makefile
--- linux-2.4.27/arch/mips/au1000/hydrogen3/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/hydrogen3/Makefile	2004-03-10 00:53:24.000000000 +0100
@@ -10,10 +10,7 @@
 # unless it's something special (ie not a .c file).
 #
 
-.S.s:
-	$(CPP) $(CFLAGS) $< -o $*.s
-.S.o:
-	$(CC) $(CFLAGS) -c $< -o $*.o
+USE_STANDARD_AS_RULE := true
 
 O_TARGET := hydrogen3.o
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/hydrogen3/board_setup.c linux-mips-cvs-20040815/arch/mips/au1000/hydrogen3/board_setup.c
--- linux-2.4.27/arch/mips/au1000/hydrogen3/board_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/hydrogen3/board_setup.c	2004-08-15 08:05:46.000000000 +0200
@@ -44,10 +44,13 @@
 #include <asm/reboot.h>
 #include <asm/pgtable.h>
 #include <asm/au1000.h>
-#include <asm/db1x00.h>
 
 extern struct rtc_ops no_rtc_ops;
 
+void board_reset (void)
+{
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/hydrogen3/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/hydrogen3/irqmap.c
--- linux-2.4.27/arch/mips/au1000/hydrogen3/irqmap.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/hydrogen3/irqmap.c	2004-03-05 06:23:49.000000000 +0100
@@ -48,43 +48,9 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
 
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
-
-//	{ AU1500_GPIO_205, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
-	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	/* { AU1500_GPIO_205, INTC_INT_LOW_LEVEL, 0 }, */
+	{ AU1000_GPIO_21, INTC_INT_LOW_LEVEL, 0 },
 };
 
 int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/mtx-1/Makefile linux-mips-cvs-20040815/arch/mips/au1000/mtx-1/Makefile
--- linux-2.4.27/arch/mips/au1000/mtx-1/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/mtx-1/Makefile	2004-03-10 00:53:24.000000000 +0100
@@ -11,10 +11,7 @@
 # unless it's something special (ie not a .c file).
 #
 
-.S.s:
-	$(CPP) $(CFLAGS) $< -o $*.s
-.S.o:
-	$(CC) $(CFLAGS) -c $< -o $*.o
+USE_STANDARD_AS_RULE := true
 
 O_TARGET := mtx-1.o
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/mtx-1/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/mtx-1/irqmap.c
--- linux-2.4.27/arch/mips/au1000/mtx-1/irqmap.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/mtx-1/irqmap.c	2004-05-02 00:47:22.000000000 +0200
@@ -47,47 +47,37 @@
 #include <asm/system.h>
 #include <asm/au1000.h>
 
+/* Need to define this.
+*/
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
+	{ 0, 0, 0}
+};
 
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
+int au1xxx_nr_irqs = 0;
 
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
+#ifdef CONFIG_PCI
 
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
+#define INTA AU1000_PCI_INTA
+#define INTB AU1000_PCI_INTB
+#define INTC AU1000_PCI_INTC
+#define INTD AU1000_PCI_INTD
+#define INTX 0xFF /* not valid */
+
+int __init
+au1xxx_pci_irqmap(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	/*
+	 *	PCI IDSEL/INTPIN->INTLINE
+	 *	A       B       C       D
 	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{
+		{INTA, INTB, INTC, INTD},   /* IDSEL 0 */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 1 */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 2 */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 3 */
+	};
+	const long min_idsel = 0, max_idsel = 3, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
 };
-
-int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+#endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1000/board_setup.c linux-mips-cvs-20040815/arch/mips/au1000/pb1000/board_setup.c
--- linux-2.4.27/arch/mips/au1000/pb1000/board_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1000/board_setup.c	2004-08-15 08:05:46.000000000 +0200
@@ -54,6 +54,10 @@
 
 extern struct rtc_ops no_rtc_ops;
 
+void board_reset (void)
+{
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func, static_cfg0;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1000/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/pb1000/irqmap.c
--- linux-2.4.27/arch/mips/au1000/pb1000/irqmap.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1000/irqmap.c	2004-03-15 02:31:43.000000000 +0100
@@ -48,49 +48,7 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART2_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
-
 	{ AU1000_GPIO_15, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
-	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
 };
 
 int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1100/board_setup.c linux-mips-cvs-20040815/arch/mips/au1000/pb1100/board_setup.c
--- linux-2.4.27/arch/mips/au1000/pb1100/board_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1100/board_setup.c	2004-08-15 08:05:46.000000000 +0200
@@ -56,6 +56,12 @@
 extern struct rtc_ops pb1500_rtc_ops;
 #endif
 
+void board_reset (void)
+{
+    /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
+    au_writel(0x00000000, 0xAE00001C);
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1100/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/pb1100/irqmap.c
--- linux-2.4.27/arch/mips/au1000/pb1100/irqmap.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1100/irqmap.c	2004-03-15 02:31:43.000000000 +0100
@@ -48,53 +48,10 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_GPIO_9, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card Fully_Interted#
 	{ AU1000_GPIO_10, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card STSCHG#
 	{ AU1000_GPIO_11, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card IRQ#
 	{ AU1000_GPIO_13, INTC_INT_LOW_LEVEL, 0 }, // DC_IRQ#
-	{ AU1000_GPIO_23, INTC_INT_LOW_LEVEL, 0 }, // 2-wire SCL
-
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
-	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
 };
 
 int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1500/board_setup.c linux-mips-cvs-20040815/arch/mips/au1000/pb1500/board_setup.c
--- linux-2.4.27/arch/mips/au1000/pb1500/board_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1500/board_setup.c	2004-08-15 08:05:46.000000000 +0200
@@ -56,6 +56,12 @@
 extern struct rtc_ops pb1500_rtc_ops;
 #endif
 
+void board_reset (void)
+{
+    /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
+    au_writel(0x00000000, 0xAE00001C);
+}
+
 void __init board_setup(void)
 {
 	u32 pin_func;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1500/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/pb1500/irqmap.c
--- linux-2.4.27/arch/mips/au1000/pb1500/irqmap.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1500/irqmap.c	2004-05-02 00:47:24.000000000 +0200
@@ -48,53 +48,37 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_205, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1500_GPIO_207, INTC_INT_LOW_LEVEL, 0 },
+};
 
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
+#ifdef CONFIG_PCI
+
+#define INTA AU1000_PCI_INTA
+#define INTB AU1000_PCI_INTB
+#define INTC AU1000_PCI_INTC
+#define INTD AU1000_PCI_INTD
+#define INTX 0xFF /* not valid */
+
+int __init
+au1xxx_pci_irqmap(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	/*
+	 *	PCI IDSEL/INTPIN->INTLINE
+	 *	A       B       C       D
 	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
+	{
+		{INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT370   */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+	};
+	const long min_idsel = 12, max_idsel = 13, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
 };
+#endif
 
-int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1550/Makefile linux-mips-cvs-20040815/arch/mips/au1000/pb1550/Makefile
--- linux-2.4.27/arch/mips/au1000/pb1550/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1550/Makefile	2004-03-10 00:53:25.000000000 +0100
@@ -10,10 +10,7 @@
 # unless it's something special (ie not a .c file).
 #
 
-.S.s:
-	$(CPP) $(CFLAGS) $< -o $*.s
-.S.o:
-	$(CC) $(CFLAGS) -c $< -o $*.o
+USE_STANDARD_AS_RULE := true
 
 O_TARGET := pb1550.o
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1550/board_setup.c linux-mips-cvs-20040815/arch/mips/au1000/pb1550/board_setup.c
--- linux-2.4.27/arch/mips/au1000/pb1550/board_setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1550/board_setup.c	2004-08-15 08:05:46.000000000 +0200
@@ -44,24 +44,31 @@
 #include <asm/reboot.h>
 #include <asm/pgtable.h>
 #include <asm/au1000.h>
-#include <asm/db1x00.h>
+#include <asm/pb1550.h>
 
 extern struct rtc_ops no_rtc_ops;
 
-static BCSR * const bcsr = (BCSR *)0xB3000000;
+void board_reset (void)
+{
+    /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
+	au_writew(au_readw(0xAF00001C) & ~(1<<15), 0xAF00001C);
+}
 
 void __init board_setup(void)
 {
 	u32 pin_func;
 	rtc_ops = &no_rtc_ops;
 
-#ifdef CONFIG_AU1X00_USB_DEVICE
-	// 2nd USB port is USB device
-	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8000);
+	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+	 * but it is board specific code, so put it here.
+	 */
+	pin_func = au_readl(SYS_PINFUNC);
+	au_sync();
+	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
 	au_writel(pin_func, SYS_PINFUNC);
-#endif
 
 	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
+	au_sync();
 
-    printk("AMD Alchemy Pb1550 Board\n");
+	printk("AMD Alchemy Pb1550 Board\n");
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1550/init.c linux-mips-cvs-20040815/arch/mips/au1000/pb1550/init.c
--- linux-2.4.27/arch/mips/au1000/pb1550/init.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1550/init.c	2004-01-30 08:25:37.000000000 +0100
@@ -46,7 +46,7 @@ extern char *prom_getenv(char *envname);
 
 const char *get_system_type(void)
 {
-	return "AMD Alchemy PbAu1550";
+	return "AMD Alchemy Au1550/Pb1550";
 }
 
 int __init prom_init(int argc, char **argv, char **envp, int *prom_vec)
@@ -64,7 +64,7 @@ int __init prom_init(int argc, char **ar
 
 	memsize_str = prom_getenv("memsize");
 	if (!memsize_str) {
-		memsize = 0x04000000;
+		memsize = 0x08000000;
 	} else {
 		memsize = simple_strtol(memsize_str, NULL, 0);
 	}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/pb1550/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/pb1550/irqmap.c
--- linux-2.4.27/arch/mips/au1000/pb1550/irqmap.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/au1000/pb1550/irqmap.c	2004-05-02 00:47:24.000000000 +0200
@@ -48,46 +48,35 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1550_UART0_INT, 	INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PCI_INTA, 		INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_PCI_INTB, 		INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_DDMA_INT, 		INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_CRYPTO_INT, 	INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PCI_INTC, 		INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_PCI_INTD, 		INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_PCI_RST_INT, 	INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_UART1_INT, 	INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_UART3_INT, 	INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC0_INT, 		INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC1_INT, 		INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC2_INT, 		INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC3_INT, 		INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_TOY_INT, 		INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH0_INT,INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_TOY_MATCH1_INT,INTC_INT_RISE_EDGE, 0 },
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
-	 */
-	{ AU1550_TOY_MATCH2_INT,INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_INT, 		INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH0_INT,INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH1_INT,INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH2_INT,INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_RTC_MATCH2_INT,INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_NAND_INT, 		INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_USB_HOST_INT,  INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_MAC0_DMA_INT,  INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_MAC1_DMA_INT,  INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_GPIO_0, INTC_INT_LOW_LEVEL, 0 },
+	{ AU1000_GPIO_1, INTC_INT_LOW_LEVEL, 0 },
+};
+
+int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
 
 
+#ifdef CONFIG_PCI
+
+#define INTA AU1550_PCI_INTA
+#define INTB AU1550_PCI_INTB
+#define INTC AU1550_PCI_INTC
+#define INTD AU1550_PCI_INTD
+#define INTX 0xFF /* invalid */
+
+int __init
+au1xxx_pci_irqmap(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
 	/*
-	 *  Need to define platform dependant GPIO ints here
+	 *	PCI IDSEL/INTPIN->INTLINE
+	 *	A       B       C       D
 	 */
-	#warning PbAu1550 needs GPIO Interrupts defined
-
+    {
+		{INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+	};
+	const long min_idsel = 12, max_idsel = 13, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
 };
+#endif
 
-int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/xxs1500/Makefile linux-mips-cvs-20040815/arch/mips/au1000/xxs1500/Makefile
--- linux-2.4.27/arch/mips/au1000/xxs1500/Makefile	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/xxs1500/Makefile	2004-03-10 00:53:24.000000000 +0100
@@ -10,10 +10,7 @@
 # unless it's something special (ie not a .c file).
 #
 
-.S.s:
-	$(CPP) $(CFLAGS) $< -o $*.s
-.S.o:
-	$(CC) $(CFLAGS) -c $< -o $*.o
+USE_STANDARD_AS_RULE := true
 
 O_TARGET := xxs1500.o
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/au1000/xxs1500/irqmap.c linux-mips-cvs-20040815/arch/mips/au1000/xxs1500/irqmap.c
--- linux-2.4.27/arch/mips/au1000/xxs1500/irqmap.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/au1000/xxs1500/irqmap.c	2004-05-02 00:47:24.000000000 +0200
@@ -48,29 +48,7 @@
 #include <asm/au1000.h>
 
 au1xxx_irq_map_t au1xxx_irq_map[] = {
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
 	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
-
-	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
@@ -83,24 +61,31 @@ au1xxx_irq_map_t au1xxx_irq_map[] = {
 	{ AU1000_GPIO_3, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_GPIO_4, INTC_INT_LOW_LEVEL, 0 }, /* CF interrupt */
 	{ AU1000_GPIO_5, INTC_INT_LOW_LEVEL, 0 },
-
-	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_USB_DEV_REQ_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-
-	/* Careful if you change match 2 request!
-	 * The interrupt handler is called directly
-	 * from the low level dispatch code.
-	 */
-	{ AU1000_TOY_MATCH2_INT, INTC_INT_RISE_EDGE, 1 },
 };
 
 int au1xxx_nr_irqs = sizeof(au1xxx_irq_map)/sizeof(au1xxx_irq_map_t);
+
+#ifdef CONFIG_PCI
+
+#define INTA AU1000_PCI_INTA
+#define INTB AU1000_PCI_INTB
+#define INTC AU1000_PCI_INTC
+#define INTD AU1000_PCI_INTD
+#define INTX 0xFF /* not valid */
+
+int __init
+au1xxx_pci_irqmap(struct pci_dev *dev, unsigned char idsel, unsigned char pin)
+{
+	static char pci_irq_table[][4] =
+	/*
+	 *	PCI IDSEL/INTPIN->INTLINE
+	 *	A       B       C       D
+	 */
+	{
+		{INTA, INTX, INTX, INTX},   /* IDSEL 12 */
+		{INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+	};
+	const long min_idsel = 12, max_idsel = 13, irqs_per_slot = 4;
+	return PCI_IRQ_TABLE_LOOKUP;
+};
+#endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/boot/addinitrd.c linux-mips-cvs-20040815/arch/mips/boot/addinitrd.c
--- linux-2.4.27/arch/mips/boot/addinitrd.c	2002-11-29 00:53:09.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/boot/addinitrd.c	2004-08-15 08:05:47.000000000 +0200
@@ -2,6 +2,8 @@
  * addinitrd - program to add a initrd image to an ecoff kernel
  *
  * (C) 1999 Thomas Bogendoerfer
+ * minor modifications, cleanup: Guido Guenther <agx@sigxcpu.org>
+ *
  */
 
 #include <sys/types.h>
@@ -54,7 +56,7 @@ int main (int argc, char *argv[])
 		exit (1);
 	}
 
-	if ((fd_vmlinux = open (argv[1],O_RDWR)) < 0)
+	if ((fd_vmlinux = open (argv[1],O_RDONLY)) < 0)
 		 die ("open vmlinux");
 	if (read (fd_vmlinux, &efile, sizeof efile) != sizeof efile)
 		die ("read file header");
@@ -78,6 +80,11 @@ int main (int argc, char *argv[])
 			swab = 1;
 	}
 
+	/* make sure we have an empty data segment for the initrd */
+	if( eaout.dsize || esecs[1].s_size ) {
+		fprintf(2,"Data segment not empty. Giving up!");
+		exit(1);
+	}
 	if ((fd_initrd = open (argv[2], O_RDONLY)) < 0)
 		die ("open initrd");
 	if (fstat (fd_initrd, &st) < 0)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/config-shared.in linux-mips-cvs-20040815/arch/mips/config-shared.in
--- linux-2.4.27/arch/mips/config-shared.in	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/config-shared.in	2004-08-15 08:05:44.000000000 +0200
@@ -25,10 +25,8 @@ dep_bool 'Support for Alchemy Mirage boa
 dep_bool 'Support for Alchemy Db1000 board' CONFIG_MIPS_DB1000 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1100 board' CONFIG_MIPS_DB1100 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Db1500 board' CONFIG_MIPS_DB1500 $CONFIG_MIPS32
+dep_bool 'Support for Alchemy Db1550 board' CONFIG_MIPS_DB1550 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1000 board' CONFIG_MIPS_PB1000 $CONFIG_MIPS32
-if [ "$CONFIG_MIPS_PB1000" = "y" ]; then
-   bool '  Support for PCI AUTO Config' CONFIG_PCI_AUTO
-fi
 dep_bool 'Support for Alchemy PB1100 board' CONFIG_MIPS_PB1100 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy PB1500 board' CONFIG_MIPS_PB1500 $CONFIG_MIPS32
 dep_bool 'Support for Alchemy Hydrogen3 board' CONFIG_MIPS_HYDROGEN3 $CONFIG_MIPS32
@@ -39,10 +37,8 @@ dep_bool 'Support for Cogent CSB250 boar
 dep_bool 'Support for BAGET MIPS series (EXPERIMENTAL)' CONFIG_BAGET_MIPS $CONFIG_MIPS32 $CONFIG_EXPERIMENTAL
 bool 'Support for CASIO CASSIOPEIA E-10/15/55/65' CONFIG_CASIO_E55
 dep_bool 'Support for Cobalt Server (EXPERIMENTAL)' CONFIG_MIPS_COBALT $CONFIG_EXPERIMENTAL
-if [ "$CONFIG_MIPS32" = "y" ]; then
+if [ "$CONFIG_MIPS32" = "y" -o "$CONFIG_EXPERIMENTAL" = "y" ]; then
    bool 'Support for DECstations' CONFIG_DECSTATION
-else
-   dep_bool 'Support for DECstations (EXPERIMENTAL)' CONFIG_DECSTATION $CONFIG_EXPERIMENTAL
 fi
 dep_bool 'Support for Galileo EV64120 Evaluation board (EXPERIMENTAL)' CONFIG_MIPS_EV64120 $CONFIG_EXPERIMENTAL
 if [ "$CONFIG_MIPS_EV64120" = "y" ]; then
@@ -64,6 +60,9 @@ if [ "$CONFIG_LASAT" = "y" ]; then
    tristate '  PICVUE LCD display driver' CONFIG_PICVUE
    dep_tristate '   PICVUE LCD display driver /proc interface' CONFIG_PICVUE_PROC $CONFIG_PICVUE
    bool '  DS1603 RTC driver' CONFIG_DS1603
+   if [ "$CONFIG_DS1603" = "y" ]; then
+      define_bool CONFIG_MIPS_RTC y
+   fi
    bool '  LASAT sysctl interface' CONFIG_LASAT_SYSCTL
 fi
 bool 'Support for ITE 8172G board' CONFIG_MIPS_ITE8172
@@ -78,6 +77,7 @@ bool 'Support for Momentum Ocelot board'
 bool 'Support for Momentum Ocelot-G board' CONFIG_MOMENCO_OCELOT_G
 bool 'Support for Momentum Ocelot-C and -CS boards' CONFIG_MOMENCO_OCELOT_C
 bool 'Support for Momentum Jaguar-ATX boards' CONFIG_MOMENCO_JAGUAR_ATX
+bool 'Support for PMC-Sierra Big Sur board' CONFIG_PMC_BIG_SUR
 bool 'Support PMC-Sierra Yosemite board' CONFIG_PMC_YOSEMITE
 if [ "$CONFIG_PMC_YOSEMITE" = "y" ]; then
    bool '  Hypertransport Support for PMC-Sierra Yosemite'  CONFIG_HYPERTRANSPORT
@@ -191,19 +191,6 @@ if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]
    bool '   Support for SB1/SOC profiling - SB1/SCD perf counters' CONFIG_SIBYTE_SB1250_PROF
    bool '   Support for ZBbus profiling' CONFIG_SIBYTE_TBPROF
 
-   if [ "$CONFIG_SIBYTE_SB1250" = "y" -o \
-        "$CONFIG_SIBYTE_BCM1125" = "y" -o \
-        "$CONFIG_SIBYTE_BCM1125H" = "y" ]; then
-      bool '   Support for BCM1250/BCM1125 onchip PCI controller' CONFIG_PCI
-   fi
-
-   if [ "$CONFIG_SIBYTE_SB1250" = "y" -o \
-        "$CONFIG_SIBYTE_BCM1125H" = "y" ]; then
-      if [ "$CONFIG_PCI" = "y" ]; then
-         define_bool CONFIG_SIBYTE_HAS_LDT y
-      fi
-   fi
-
    if [ "$CONFIG_SIBYTE_SWARM" = "y" -o \
         "$CONFIG_SIBYTE_LITTLESUR" = "y" -o \
         "$CONFIG_SIBYTE_PTSWARM" = "y" -o \
@@ -246,11 +233,9 @@ if [ "$CONFIG_ACER_PICA_61" = "y" ]; the
    define_bool CONFIG_MIPS_JAZZ y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_OLD_TIME_C y
 fi
 if [ "$CONFIG_CASIO_E55" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_ISA y
    define_bool CONFIG_DUMMY_KEYB y
@@ -259,29 +244,18 @@ fi
 if [ "$CONFIG_MIPS_MIRAGE" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
 if [ "$CONFIG_MIPS_BOSPORUS" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
 if [ "$CONFIG_MIPS_PB1000" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1000 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_SWAP_IO_SPACE_W y
@@ -290,10 +264,6 @@ fi
 if [ "$CONFIG_MIPS_PB1100" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1100 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_PCI_AUTO n
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_SWAP_IO_SPACE_W y
@@ -302,21 +272,12 @@ fi
 if [ "$CONFIG_MIPS_PB1500" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
 if [ "$CONFIG_MIPS_DB1000" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1000 y
-   define_bool CONFIG_NEW_TIME_C y
-   # CONFIG_PCI needed for USB
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO n
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_SWAP_IO_SPACE y
@@ -324,19 +285,18 @@ fi
 if [ "$CONFIG_MIPS_DB1500" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
+   define_bool CONFIG_NONCOHERENT_IO y
+   define_bool CONFIG_PC_KEYB y
+fi
+if [ "$CONFIG_MIPS_DB1550" = "y" ]; then
+   define_bool CONFIG_SOC_AU1X00 y
+   define_bool CONFIG_SOC_AU1550 y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
 if [ "$CONFIG_MIPS_DB1100" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1100 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_SWAP_IO_SPACE y
@@ -344,9 +304,6 @@ fi
 if [ "$CONFIG_MIPS_HYDROGEN3" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1100 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_SWAP_IO_SPACE y
@@ -354,39 +311,23 @@ fi
 if [ "$CONFIG_MIPS_XXS1500" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
 if [ "$CONFIG_MIPS_MTX1" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
 if [ "$CONFIG_COGENT_CSB250" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1500 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
 if [ "$CONFIG_MIPS_PB1550" = "y" ]; then
    define_bool CONFIG_SOC_AU1X00 y
    define_bool CONFIG_SOC_AU1550 y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_NONCOHERENT_IO n
    define_bool CONFIG_PC_KEYB y
 fi
@@ -394,53 +335,37 @@ if [ "$CONFIG_MIPS_COBALT" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
    define_bool CONFIG_COBALT_LCD y
    define_bool CONFIG_I8259 y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
 if [ "$CONFIG_DECSTATION" = "y" ]; then
+   define_bool CONFIG_EARLY_PRINTK y
    define_bool CONFIG_BOOT_ELF32 y
    define_bool CONFIG_IRQ_CPU y
    define_int CONFIG_L1_CACHE_SHIFT 4
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
 if [ "$CONFIG_MIPS_EV64120" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_MIPS_GT64120 y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_OLD_TIME_C y
 fi
 if [ "$CONFIG_MIPS_EV96100" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_MIPS_GT64120 y
    define_bool CONFIG_MIPS_GT96100 y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
 fi
 if [ "$CONFIG_MIPS_IVR" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_IT8172_CIR y
-   define_bool CONFIG_NEW_TIME_C y
 fi
 if [ "$CONFIG_HP_LASERJET" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
-   #not yet define_bool CONFIG_PCI_AUTO y
 fi
 if [ "$CONFIG_IBM_WORKPAD" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_ISA y
    define_bool CONFIG_SCSI n
@@ -448,21 +373,15 @@ fi
 if [ "$CONFIG_LASAT" = "y" ]; then
    define_bool CONFIG_BOARD_SCACHE y
    define_bool CONFIG_R5000_CPU_SCACHE y
-   define_bool CONFIG_PCI y
    define_bool CONFIG_MIPS_GT64120 y
    define_bool CONFIG_MIPS_NILE4 y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_NEW_TIME_C y
 fi
 if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_IT8712 y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_IT8172_CIR y
-   define_bool CONFIG_NEW_TIME_C y
 fi
 if [ "$CONFIG_MIPS_ATLAS" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
@@ -470,9 +389,7 @@ if [ "$CONFIG_MIPS_ATLAS" = "y" ]; then
    define_bool CONFIG_MIPS_BONITO64 y
    define_bool CONFIG_MIPS_GT64120 y
    define_bool CONFIG_MIPS_MSC y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
 fi
@@ -486,7 +403,6 @@ if [ "$CONFIG_MIPS_MAGNUM_4000" = "y" -o
    define_bool CONFIG_MIPS_JAZZ y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_OLD_TIME_C y
 fi
 if [ "$CONFIG_MIPS_MALTA" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
@@ -496,59 +412,50 @@ if [ "$CONFIG_MIPS_MALTA" = "y" ]; then
    define_bool CONFIG_MIPS_GT64120 y
    define_bool CONFIG_MIPS_MSC y
    define_int CONFIG_L1_CACHE_SHIFT 5
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_PCI y
 fi
 if [ "$CONFIG_MIPS_SEAD" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
    define_int CONFIG_L1_CACHE_SHIFT 5
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI n
 fi
 if [ "$CONFIG_MOMENCO_OCELOT" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_SYSCLK_100 y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_OLD_TIME_C y
 fi
 if [ "$CONFIG_MOMENCO_OCELOT_G" = "y" ]; then
-   define_bool CONFIG_PCI y
+   define_bool CONFIG_IRQ_CPU y
+   define_bool CONFIG_IRQ_CPU_RM7K y
+   define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_SYSCLK_100 y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
-   define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_OLD_TIME_C y
 fi
 if [ "$CONFIG_MOMENCO_OCELOT_C" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_SWAP_IO_SPACE y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_NEW_TIME_C y
+   define_bool CONFIG_BOOT_ELF32 y
+fi
+if [ "$CONFIG_PMC_BIG_SUR" = "y" ]; then
    define_bool CONFIG_BOOT_ELF32 y
 fi
 if [ "$CONFIG_MOMENCO_JAGUAR_ATX" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_SWAP_IO_SPACE y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_BOOT_ELF32 y
 fi
 
 if [ "$CONFIG_PMC_YOSEMITE" = "y" ]; then
-   define_bool CONFIG_PCI y
    define_bool CONFIG_SWAP_IO_SPACE y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_BOOT_ELF32 y
    define_bool CONFIG_HIGHMEM y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
 
@@ -557,55 +464,37 @@ if [ "$CONFIG_DDB5074" = "y" ]; then
    define_bool CONFIG_I8259 y
    define_bool CONFIG_ISA y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_PCI y
 fi
 if [ "$CONFIG_DDB5476"  = "y" ]; then
    define_bool CONFIG_ISA y
-   define_bool CONFIG_PCI y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_IRQ_CPU y
    define_bool CONFIG_I8259 y
    define_bool CONFIG_HAVE_STD_PC_SERIAL_PORT y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
 fi
 if [ "$CONFIG_DDB5477" = "y" ]; then
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_PCI y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_PC_KEYB y
    define_bool CONFIG_I8259 y
 fi
 if [ "$CONFIG_NEC_OSPREY" = "y" ]; then
    define_bool CONFIG_VR4181 y
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_DUMMY_KEYB y
    define_bool CONFIG_SCSI n
 fi
 if [ "$CONFIG_NEC_EAGLE" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_DUMMY_KEYB y
    define_bool CONFIG_SCSI n
 fi
 if [ "$CONFIG_NINO" = "y" ]; then
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
@@ -618,7 +507,6 @@ if [ "$CONFIG_SGI_IP22" = "y" ]; then
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_IRQ_CPU y
    define_int CONFIG_L1_CACHE_SHIFT 5
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_PC_KEYB y
 fi
@@ -627,12 +515,9 @@ if [ "$CONFIG_SGI_IP27" = "y" ]; then
    define_bool CONFIG_ARC64 y
    define_int CONFIG_L1_CACHE_SHIFT 7
    #define_bool CONFIG_MAPPED_PCI_IO y
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
    define_bool CONFIG_QL_ISP_A64 y
 fi
 if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_DUMMY_KEYB y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
@@ -645,46 +530,28 @@ if [ "$CONFIG_SNI_RM200_PCI" = "y" ]; th
    define_bool CONFIG_I8259 y
    define_bool CONFIG_ISA y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_OLD_TIME_C y
    define_bool CONFIG_PC_KEYB y
-   define_bool CONFIG_PCI y
 fi
 if [ "$CONFIG_TANBAC_TB0226" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_DUMMY_KEYB y
    define_bool CONFIG_SERIAL_MANY_PORTS y
 fi
 if [ "$CONFIG_TANBAC_TB0229" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_DUMMY_KEYB y
    define_bool CONFIG_SERIAL_MANY_PORTS y
 fi
 if [ "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
    define_bool CONFIG_TOSHIBA_BOARDS y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_PC_KEYB y
 fi
 if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" ]; then
-   define_bool CONFIG_NEW_TIME_C y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_SWAP_IO_SPACE_W y
    define_bool CONFIG_SWAP_IO_SPACE_L y
    define_bool CONFIG_ISA y
@@ -692,21 +559,12 @@ if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" ];
 fi
 if [ "$CONFIG_VICTOR_MPC30X" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
-   define_bool CONFIG_DUMMY_KEYB y
    define_bool CONFIG_SCSI n
 fi
 if [ "$CONFIG_ZAO_CAPCELLA" = "y" ]; then
    define_bool CONFIG_IRQ_CPU y
-   define_bool CONFIG_NEW_TIME_C y
    define_bool CONFIG_NONCOHERENT_IO y
-   define_bool CONFIG_PCI y
-   define_bool CONFIG_NEW_PCI y
-   define_bool CONFIG_PCI_AUTO y
    define_bool CONFIG_DUMMY_KEYB y
    define_bool CONFIG_SCSI n
 fi
@@ -752,12 +610,7 @@ if [ "$CONFIG_SMP_CAPABLE" = "y" ]; then
    bool '  Multi-Processing support' CONFIG_SMP
 fi
  
-if [ "$CONFIG_CPU_MIPS32" = "y" ]; then
-   define_bool CONFIG_CPU_HAS_PREFETCH y
-   bool '  Support for Virtual Tagged I-cache' CONFIG_VTAG_ICACHE
-fi
-
-if [ "$CONFIG_CPU_MIPS64" = "y" ]; then
+if [ "$CONFIG_CPU_MIPS32" = "y" -o "$CONFIG_CPU_MIPS64" = "y" ]; then
    define_bool CONFIG_CPU_HAS_PREFETCH y
    bool '  Support for Virtual Tagged I-cache' CONFIG_VTAG_ICACHE
 fi
@@ -903,15 +756,51 @@ fi
 
 bool 'Networking support' CONFIG_NET
 
+if [ "$CONFIG_ACER_PICA_61" = "y" -o \
+     "$CONFIG_CASIO_E55" = "y" -o \
+     "$CONFIG_DECSTATION" = "y" -o \
+     "$CONFIG_IBM_WORKPAD" = "y" -o \
+     "$CONFIG_MIPS_MAGNUM_4000" = "y" -o \
+     "$CONFIG_MIPS_SEAD" = "y" -o \
+     "$CONFIG_NINO" = "y" -o \
+     "$CONFIG_OLIVETTI_M700" = "y" -o \
+     "$CONFIG_SGI_IP22" = "y" ]; then
+   define_bool CONFIG_PCI n
+else
+   bool 'PCI bus support' CONFIG_PCI
+   dep_bool '    New PCI bus code' CONFIG_PCI_NEW $CONFIG_PCI
+   if [ "$CONFIG_HP_LASERJET" = "y" -o \
+        "$CONFIG_LASAT" = "y" -o \
+        "$CONFIG_MIPS_ATLAS" = "y" -o \
+        "$CONFIG_MIPS_COBALT" = "y" -o \
+        "$CONFIG_MIPS_DB1000" = "y" -o \
+        "$CONFIG_MIPS_DB1100" = "y" -o \
+        "$CONFIG_MIPS_EV64120" = "y" -o \
+        "$CONFIG_MIPS_HYDROGEN3" = "y" -o \
+        "$CONFIG_MIPS_MALTA" = "y" -o \
+        "$CONFIG_MIPS_PB1100" = "y" -o \
+        "$CONFIG_MOMENCO_OCELOT" = "y" -o \
+        "$CONFIG_NEC_OSPREY" = "y" -o \
+        "$CONFIG_PMC_YOSEMITE" = "y" -o \
+        "$CONFIG_SIBYTE_SWARM" = "y" -o \
+	"$CONFIG_SNI_RM200_PCI" = "y" ]; then
+      define_bool CONFIG_PCI_AUTO n
+   else
+      define_bool CONFIG_PCI_AUTO y
+   fi
+fi
+if [ "$CONFIG_SIBYTE_SB1250" = "y" -o \
+     "$CONFIG_SIBYTE_BCM1125H" = "y" ]; then
+   if [ "$CONFIG_PCI" = "y" ]; then
+      define_bool CONFIG_SIBYTE_HAS_LDT y
+   fi
+fi
+
 if [ "$CONFIG_SGI_IP22" = "y" -o "$CONFIG_MIPS_MAGNUM_4000" = "y" -o \
      "$CONFIG_OLIVETTI_M700" = "y" -o "$CONFIG_SNI_RM200_PCI" = "y" ]; then
    bool 'EISA bus support' CONFIG_EISA
 fi
 
-if [ "$CONFIG_PCI" != "y" ]; then
-   define_bool CONFIG_PCI n
-fi
-
 source drivers/pci/Config.in
 
 if [ "$CONFIG_EISA" = "y" -a "$CONFIG_ISA" != "y" ]; then
@@ -957,6 +846,11 @@ fi
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Select task to kill on out of memory condition' CONFIG_OOM_KILLER
 
+bool 'Default bootloader kernel arguments' CONFIG_CMDLINE_BOOL
+if [ "$CONFIG_CMDLINE_BOOL" = "y" ] ; then
+  string 'Initial kernel command string' CONFIG_CMDLINE ""
+fi
+
 if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
    bool 'Power Management support' CONFIG_PM
 fi
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/dec/ecc-berr.c linux-mips-cvs-20040815/arch/mips/dec/ecc-berr.c
--- linux-2.4.27/arch/mips/dec/ecc-berr.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/dec/ecc-berr.c	2004-02-09 19:09:17.000000000 +0100
@@ -74,7 +74,7 @@ static int dec_ecc_be_backend(struct pt_
 
 	if (!(erraddr & KN0X_EAR_VALID)) {
 		/* No idea what happened. */
-		printk(KERN_ALERT "Unindentified bus error %s.\n", kind);
+		printk(KERN_ALERT "Unidentified bus error %s.\n", kind);
 		return action;
 	}
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/dec/prom/Makefile linux-mips-cvs-20040815/arch/mips/dec/prom/Makefile
--- linux-2.4.27/arch/mips/dec/prom/Makefile	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/dec/prom/Makefile	2004-02-11 16:17:08.000000000 +0100
@@ -12,7 +12,7 @@ USE_STANDARD_AS_RULE := true
 
 L_TARGET  = rexlib.a
 
-obj-y			+= init.o memory.o cmdline.o identify.o
+obj-y			+= init.o memory.o cmdline.o identify.o console.o
 
 obj-$(CONFIG_MIPS32)	+= locore.o
 obj-$(CONFIG_MIPS64)	+= call_o32.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/dec/prom/cmdline.c linux-mips-cvs-20040815/arch/mips/dec/prom/cmdline.c
--- linux-2.4.27/arch/mips/dec/prom/cmdline.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/dec/prom/cmdline.c	2004-02-11 16:17:08.000000000 +0100
@@ -2,6 +2,7 @@
  * cmdline.c: read the command line passed to us by the PROM.
  *
  * Copyright (C) 1998 Harald Koerfgen
+ * Copyright (C) 2002, 2004  Maciej W. Rozycki
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -35,6 +36,6 @@ void __init prom_init_cmdline(s32 argc, 
 	}
 
 #ifdef PROM_DEBUG
-	prom_printf("arcs_cmdline: %s\n", &(arcs_cmdline[0]));
+	printk("arcs_cmdline: %s\n", &(arcs_cmdline[0]));
 #endif
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/dec/prom/console.c linux-mips-cvs-20040815/arch/mips/dec/prom/console.c
--- linux-2.4.27/arch/mips/dec/prom/console.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/dec/prom/console.c	2004-02-11 16:17:08.000000000 +0100
@@ -0,0 +1,55 @@
+/*
+ *	arch/mips/dec/prom/console.c
+ *
+ *	DECstation PROM-based early console support.
+ *
+ *	Copyright (C) 2004  Maciej W. Rozycki
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+
+#include <asm/dec/prom.h>
+
+static void __init prom_console_write(struct console *con, const char *s,
+				      unsigned int c)
+{
+	static char sfmt[] __initdata = "%%%us";
+	char fmt[13];
+
+	snprintf(fmt, sizeof(fmt), sfmt, c);
+	prom_printf(fmt, s);
+}
+
+static struct console promcons __initdata = {
+	.name	= "prom",
+	.write	= prom_console_write,
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
+};
+
+static int promcons_output __initdata = 0;
+
+void __init register_prom_console(void)
+{
+	if (!promcons_output) {
+		promcons_output = 1;
+		register_console(&promcons);
+	}
+}
+
+void __init unregister_prom_console(void)
+{
+	if (promcons_output) {
+		unregister_console(&promcons);
+		promcons_output = 0;
+	}
+}
+
+void disable_early_printk(void)
+	__attribute__((alias("unregister_prom_console")));
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/dec/prom/identify.c linux-mips-cvs-20040815/arch/mips/dec/prom/identify.c
--- linux-2.4.27/arch/mips/dec/prom/identify.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/dec/prom/identify.c	2004-02-11 16:17:08.000000000 +0100
@@ -2,7 +2,7 @@
  * identify.c: machine identification code.
  *
  * Copyright (C) 1998 Harald Koerfgen and Paul M. Antoine
- * Copyright (C) 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2002, 2003, 2004  Maciej W. Rozycki
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -100,11 +100,13 @@ void __init prom_identify_arch(u32 magic
 	u32 dec_sysid;
 
 	if (!prom_is_rex(magic)) {
-		dec_sysid = simple_strtoul(prom_getenv("systype"), (char **)0, 0);
+		dec_sysid = simple_strtoul(prom_getenv("systype"),
+					   (char **)0, 0);
 	} else {
 		dec_sysid = rex_getsysid();
 		if (dec_sysid == 0) {
-			prom_printf("Zero sysid returned from PROMs! Assuming PMAX-like machine.\n");
+			printk("Zero sysid returned from PROM! "
+			       "Assuming a PMAX-like machine.\n");
 			dec_sysid = 1;
 		}
 	}
@@ -163,10 +165,8 @@ void __init prom_identify_arch(u32 magic
 	}
 
 	if (mips_machtype == MACH_DSUNKNOWN)
-		prom_printf("This is an %s, id is %x\n",
-			    dec_system_strings[mips_machtype],
-			    dec_systype);
+		printk("This is an %s, id is %x\n",
+		       dec_system_strings[mips_machtype], dec_systype);
 	else
-		prom_printf("This is a %s\n",
-			    dec_system_strings[mips_machtype]);
+		printk("This is a %s\n", dec_system_strings[mips_machtype]);
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/dec/prom/init.c linux-mips-cvs-20040815/arch/mips/dec/prom/init.c
--- linux-2.4.27/arch/mips/dec/prom/init.c	2003-08-25 13:44:39.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/dec/prom/init.c	2004-02-11 16:17:08.000000000 +0100
@@ -2,10 +2,11 @@
  * init.c: PROM library initialisation code.
  *
  * Copyright (C) 1998 Harald Koerfgen
- * Copyright (C) 2002  Maciej W. Rozycki
+ * Copyright (C) 2002, 2004  Maciej W. Rozycki
  */
 #include <linux/config.h>
 #include <linux/init.h>
+#include <linux/string.h>
 #include <linux/types.h>
 
 #include <asm/bootinfo.h>
@@ -34,7 +35,7 @@ int (*__pmax_close)(int);
 
 
 /*
- * Detect which PROM's the DECSTATION has, and set the callback vectors
+ * Detect which PROM the DECSTATION has, and set the callback vectors
  * appropriately.
  */
 void __init which_prom(s32 magic, s32 *prom_vec)
@@ -84,9 +85,15 @@ void __init which_prom(s32 magic, s32 *p
 int __init prom_init(s32 argc, s32 *argv, u32 magic, s32 *prom_vec)
 {
 	extern void dec_machine_halt(void);
+	static char cpu_msg[] __initdata =
+		"Sorry, this kernel is compiled for a wrong CPU type!\n";
+	static char r3k_msg[] __initdata =
+		"Please recompile with \"CONFIG_CPU_R3000 = y\".\n";
+	static char r4k_msg[] __initdata =
+		"Please recompile with \"CONFIG_CPU_R4x00 = y\".\n";
 
 	/*
-	 * Determine which PROM's we have
+	 * Determine which PROM we have
 	 * (and therefore which machine we're on!)
 	 */
 	which_prom(magic, prom_vec);
@@ -94,12 +101,15 @@ int __init prom_init(s32 argc, s32 *argv
 	if (prom_is_rex(magic))
 		rex_clear_cache();
 
+	/* Register the early console.  */
+	register_prom_console();
+
 	/* Were we compiled with the right CPU option? */
 #if defined(CONFIG_CPU_R3000)
 	if ((current_cpu_data.cputype == CPU_R4000SC) ||
 	    (current_cpu_data.cputype == CPU_R4400SC)) {
-		prom_printf("Sorry, this kernel is compiled for the wrong CPU type!\n");
-		prom_printf("Please recompile with \"CONFIG_CPU_R4x00 = y\"\n");
+		printk(cpu_msg);
+		printk(r4k_msg);
 		dec_machine_halt();
 	}
 #endif
@@ -107,8 +117,8 @@ int __init prom_init(s32 argc, s32 *argv
 #if defined(CONFIG_CPU_R4X00)
 	if ((current_cpu_data.cputype == CPU_R3000) ||
 	    (current_cpu_data.cputype == CPU_R3000A)) {
-		prom_printf("Sorry, this kernel is compiled for the wrong CPU type!\n");
-		prom_printf("Please recompile with \"CONFIG_CPU_R3000 = y\"\n");
+		printk(cpu_msg);
+		printk(r3k_msg);
 		dec_machine_halt();
 	}
 #endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/dec/setup.c linux-mips-cvs-20040815/arch/mips/dec/setup.c
--- linux-2.4.27/arch/mips/dec/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/dec/setup.c	2004-08-15 08:05:47.000000000 +0200
@@ -137,9 +137,9 @@ extern void dec_timer_setup(struct irqac
 void __init decstation_setup(void)
 {
 #ifdef CONFIG_BLK_DEV_INITRD
-       ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-       initrd_start = (unsigned long)&__rd_start;
-       initrd_end = (unsigned long)&__rd_end;
+	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+	initrd_start = (unsigned long)&__rd_start;
+	initrd_end = (unsigned long)&__rd_end;
 #endif
 	board_be_init = dec_be_init;
 	board_time_init = dec_time_init;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig linux-mips-cvs-20040815/arch/mips/defconfig
--- linux-2.4.27/arch/mips/defconfig	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -81,7 +84,6 @@ CONFIG_BOOT_ELF32=y
 CONFIG_SWAP_IO_SPACE_L=y
 CONFIG_IRQ_CPU=y
 CONFIG_L1_CACHE_SHIFT=5
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -123,8 +125,8 @@ CONFIG_CPU_HAS_SYNC=y
 CONFIG_BINFMT_IRIX=y
 CONFIG_ARC_CONSOLE=y
 CONFIG_NET=y
-# CONFIG_EISA is not set
 # CONFIG_PCI is not set
+# CONFIG_EISA is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -145,6 +147,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -174,6 +177,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -220,7 +224,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -313,6 +316,14 @@ CONFIG_SGIWD93_SCSI=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
@@ -449,6 +460,7 @@ CONFIG_VT_CONSOLE=y
 # CONFIG_SERIAL is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -511,13 +523,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
 # CONFIG_INDYDOG is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 CONFIG_DS1286=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-atlas linux-mips-cvs-20040815/arch/mips/defconfig-atlas
--- linux-2.4.27/arch/mips/defconfig-atlas	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-atlas	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_MIPS_ATLAS=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -76,9 +79,7 @@ CONFIG_L1_CACHE_SHIFT=5
 CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_MSC=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
 # CONFIG_MIPS_AU1000 is not set
@@ -121,6 +122,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -142,6 +146,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -171,6 +176,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -218,7 +224,6 @@ CONFIG_IP_PNP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -309,6 +314,14 @@ CONFIG_SD_EXTRA_DEVS=40
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -420,6 +433,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -509,6 +523,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -551,7 +566,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-bosporus linux-mips-cvs-20040815/arch/mips/defconfig-bosporus
--- linux-2.4.27/arch/mips/defconfig-bosporus	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-bosporus	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_MIPS_BOSPORUS=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_BOSPORUS=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,11 +78,7 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
 CONFIG_PC_KEYB=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -120,6 +119,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -138,6 +140,10 @@ CONFIG_HOTPLUG=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -151,6 +157,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -200,7 +207,8 @@ CONFIG_MTD_BOSPORUS=y
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -252,6 +260,7 @@ CONFIG_MTD_BOSPORUS=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -354,7 +363,6 @@ CONFIG_IP_NF_MANGLE=m
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -447,6 +455,14 @@ CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -656,6 +672,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -720,7 +737,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -930,7 +946,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-capcella linux-mips-cvs-20040815/arch/mips/defconfig-capcella
--- linux-2.4.27/arch/mips/defconfig-capcella	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-capcella	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -74,11 +77,7 @@ CONFIG_ZAO_CAPCELLA=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_DUMMY_KEYB=y
 # CONFIG_SCSI is not set
 # CONFIG_MIPS_AU1000 is not set
@@ -117,6 +116,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -138,6 +140,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -167,6 +170,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -213,7 +217,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -294,6 +297,7 @@ CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -373,6 +377,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -463,6 +468,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -521,13 +527,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDT is not set
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-cobalt linux-mips-cvs-20040815/arch/mips/defconfig-cobalt
--- linux-2.4.27/arch/mips/defconfig-cobalt	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-cobalt	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_MIPS_COBALT=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -74,8 +77,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_BOOT_ELF32=y
 CONFIG_COBALT_LCD=y
 CONFIG_I8259=y
-CONFIG_PCI=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -113,6 +114,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -134,6 +138,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -163,6 +168,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -205,7 +211,6 @@ CONFIG_INET=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -295,6 +300,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -323,6 +329,7 @@ CONFIG_BLK_DEV_VIA82CXXX=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -404,6 +411,7 @@ CONFIG_TULIP=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -493,6 +501,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=16
 
@@ -535,7 +544,6 @@ CONFIG_UNIX98_PTY_COUNT=16
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-csb250 linux-mips-cvs-20040815/arch/mips/defconfig-csb250
--- linux-2.4.27/arch/mips/defconfig-csb250	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-csb250	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 CONFIG_COGENT_CSB250=y
@@ -52,6 +54,7 @@ CONFIG_COGENT_CSB250=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -121,6 +120,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -137,9 +139,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-# CONFIG_PCMCIA_PB1X00 is not set
-CONFIG_PCMCIA_DB1X00=y
-# CONFIG_PCMCIA_XXS1500 is not set
 
 #
 # PCI Hotplug Support
@@ -147,6 +146,10 @@ CONFIG_PCMCIA_DB1X00=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -160,6 +163,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -190,6 +194,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -252,7 +257,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -342,6 +346,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -370,6 +375,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -546,6 +552,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -610,7 +617,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -844,7 +850,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-db1000 linux-mips-cvs-20040815/arch/mips/defconfig-db1000
--- linux-2.4.27/arch/mips/defconfig-db1000	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-db1000	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 CONFIG_MIPS_DB1000=y
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_DB1000=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1000=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-# CONFIG_PCI_AUTO is not set
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 CONFIG_SWAP_IO_SPACE=y
@@ -121,6 +120,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+# CONFIG_PCI_AUTO is not set
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -137,9 +139,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-# CONFIG_PCMCIA_PB1X00 is not set
-CONFIG_PCMCIA_DB1X00=y
-# CONFIG_PCMCIA_XXS1500 is not set
 
 #
 # PCI Hotplug Support
@@ -147,6 +146,10 @@ CONFIG_PCMCIA_DB1X00=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -160,6 +163,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -211,7 +215,8 @@ CONFIG_MTD_CFI_AMDSTD=y
 CONFIG_MTD_DB1X00=y
 CONFIG_MTD_DB1X00_BOOT=y
 CONFIG_MTD_DB1X00_USER=y
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -263,6 +268,7 @@ CONFIG_MTD_DB1X00_USER=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -325,7 +331,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -406,6 +411,7 @@ CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -626,6 +632,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -690,7 +697,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -890,6 +896,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -979,7 +986,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-db1100 linux-mips-cvs-20040815/arch/mips/defconfig-db1100
--- linux-2.4.27/arch/mips/defconfig-db1100	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-db1100	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 CONFIG_MIPS_DB1100=y
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_DB1100=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,9 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1100=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 CONFIG_SWAP_IO_SPACE=y
@@ -120,6 +120,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,9 +139,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-# CONFIG_PCMCIA_PB1X00 is not set
-CONFIG_PCMCIA_DB1X00=y
-# CONFIG_PCMCIA_XXS1500 is not set
 
 #
 # PCI Hotplug Support
@@ -146,6 +146,10 @@ CONFIG_PCMCIA_DB1X00=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -159,6 +163,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -210,7 +215,8 @@ CONFIG_MTD_CFI_AMDSTD=y
 CONFIG_MTD_DB1X00=y
 # CONFIG_MTD_DB1X00_BOOT is not set
 CONFIG_MTD_DB1X00_USER=y
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -262,6 +268,7 @@ CONFIG_MTD_DB1X00_USER=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -324,7 +331,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -405,6 +411,7 @@ CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -625,6 +632,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -689,7 +697,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -930,6 +937,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -1019,7 +1027,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-db1500 linux-mips-cvs-20040815/arch/mips/defconfig-db1500
--- linux-2.4.27/arch/mips/defconfig-db1500	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-db1500	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 CONFIG_MIPS_DB1500=y
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_DB1500=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -120,6 +119,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,9 +138,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-# CONFIG_PCMCIA_PB1X00 is not set
-CONFIG_PCMCIA_DB1X00=y
-# CONFIG_PCMCIA_XXS1500 is not set
 
 #
 # PCI Hotplug Support
@@ -146,6 +145,10 @@ CONFIG_PCMCIA_DB1X00=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -159,6 +162,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -189,6 +193,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -251,7 +256,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -341,6 +345,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -369,6 +374,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -545,6 +551,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -609,7 +616,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -766,6 +772,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -855,7 +862,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-db1550 linux-mips-cvs-20040815/arch/mips/defconfig-db1550
--- linux-2.4.27/arch/mips/defconfig-db1550	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-db1550	2004-08-15 08:05:44.000000000 +0200
@@ -0,0 +1,1082 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_MIPS=y
+CONFIG_MIPS32=y
+# CONFIG_MIPS64 is not set
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Machine selection
+#
+# CONFIG_ACER_PICA_61 is not set
+# CONFIG_MIPS_BOSPORUS is not set
+# CONFIG_MIPS_MIRAGE is not set
+# CONFIG_MIPS_DB1000 is not set
+# CONFIG_MIPS_DB1100 is not set
+# CONFIG_MIPS_DB1500 is not set
+CONFIG_MIPS_DB1550=y
+# CONFIG_MIPS_PB1000 is not set
+# CONFIG_MIPS_PB1100 is not set
+# CONFIG_MIPS_PB1500 is not set
+# CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
+# CONFIG_MIPS_XXS1500 is not set
+# CONFIG_MIPS_MTX1 is not set
+# CONFIG_COGENT_CSB250 is not set
+# CONFIG_BAGET_MIPS is not set
+# CONFIG_CASIO_E55 is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_HP_LASERJET is not set
+# CONFIG_IBM_WORKPAD is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MAGNUM_4000 is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+# CONFIG_MOMENCO_OCELOT_G is not set
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_NEC_EAGLE is not set
+# CONFIG_OLIVETTI_M700 is not set
+# CONFIG_NINO is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+# CONFIG_TANBAC_TB0226 is not set
+# CONFIG_TANBAC_TB0229 is not set
+# CONFIG_TOSHIBA_JMR3927 is not set
+# CONFIG_TOSHIBA_RBTX4927 is not set
+# CONFIG_VICTOR_MPC30X is not set
+# CONFIG_ZAO_CAPCELLA is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_SOC_AU1X00=y
+CONFIG_SOC_AU1550=y
+CONFIG_NONCOHERENT_IO=y
+CONFIG_PC_KEYB=y
+# CONFIG_MIPS_AU1000 is not set
+
+#
+# CPU selection
+#
+CONFIG_CPU_MIPS32=y
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+# CONFIG_CPU_RM7000 is not set
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_CPU_HAS_PREFETCH=y
+# CONFIG_VTAG_ICACHE is not set
+CONFIG_64BIT_PHYS_ADDR=y
+# CONFIG_CPU_ADVANCED is not set
+CONFIG_CPU_HAS_LLSC=y
+# CONFIG_CPU_HAS_LLDSCD is not set
+# CONFIG_CPU_HAS_WB is not set
+CONFIG_CPU_HAS_SYNC=y
+
+#
+# General setup
+#
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
+# CONFIG_PCI_NAMES is not set
+# CONFIG_ISA is not set
+# CONFIG_TC is not set
+# CONFIG_MCA is not set
+# CONFIG_SBUS is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+# CONFIG_CARDBUS is not set
+# CONFIG_TCIC is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+CONFIG_PCMCIA_AU1X00=m
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
+CONFIG_SYSVIPC=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+CONFIG_KCORE_ELF=y
+# CONFIG_KCORE_AOUT is not set
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_ELF=y
+# CONFIG_MIPS32_COMPAT is not set
+# CONFIG_MIPS32_O32 is not set
+# CONFIG_MIPS32_N32 is not set
+# CONFIG_BINFMT_ELF32 is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
+# CONFIG_PM is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PB1000 is not set
+# CONFIG_MTD_PB1500 is not set
+# CONFIG_MTD_PB1100 is not set
+# CONFIG_MTD_BOSPORUS is not set
+# CONFIG_MTD_XXS1500 is not set
+# CONFIG_MTD_MTX1 is not set
+# CONFIG_MTD_DB1X00 is not set
+CONFIG_MTD_PB1550=y
+CONFIG_MTD_PB1550_BOOT=y
+CONFIG_MTD_PB1550_USER=y
+# CONFIG_MTD_HYDROGEN3 is not set
+# CONFIG_MTD_MIRAGE is not set
+# CONFIG_MTD_CSTM_MIPS_IXX is not set
+# CONFIG_MTD_OCELOT is not set
+# CONFIG_MTD_LASAT is not set
+# CONFIG_MTD_PCI is not set
+# CONFIG_MTD_PCMCIA is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+CONFIG_MTD_NAND_IDS=m
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play configuration
+#
+# CONFIG_PNP is not set
+# CONFIG_ISAPNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_PARIDE is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_CISS_SCSI_TAPE is not set
+# CONFIG_CISS_MONITOR_THREAD is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_BLK_STATS is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID5 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_BLK_DEV_LVM is not set
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_INET_ECN is not set
+# CONFIG_SYN_COOKIES is not set
+
+#
+#   IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_NF_COMPAT_IPCHAINS is not set
+# CONFIG_IP_NF_COMPAT_IPFWADM is not set
+
+#
+#   IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+
+#
+#  
+#
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+
+#
+# Appletalk devices
+#
+# CONFIG_DEV_APPLETALK is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_LLC is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+# CONFIG_PHONE_IXJ is not set
+# CONFIG_PHONE_IXJ_PCMCIA is not set
+
+#
+# ATA/IDE/MFM/RLL support
+#
+CONFIG_IDE=y
+
+#
+# IDE, ATA and ATAPI Block devices
+#
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_IDEDISK_STROKE is not set
+# CONFIG_BLK_DEV_IDECS is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_CMD640_ENHANCED is not set
+# CONFIG_BLK_DEV_ISAPNP is not set
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_BLK_DEV_GENERIC=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+# CONFIG_IDEDMA_PCI_AUTO is not set
+# CONFIG_IDEDMA_ONLYDISK is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_PCI_WIP is not set
+# CONFIG_BLK_DEV_ADMA100 is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_WDC_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_HPT34X_AUTODMA is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_PDC202XX_OLD=y
+CONFIG_PDC202XX_BURST=y
+CONFIG_BLK_DEV_PDC202XX_NEW=y
+# CONFIG_PDC202XX_FORCE is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_CHIPSETS is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_IDEDMA_IVB is not set
+# CONFIG_DMA_NONPCI is not set
+CONFIG_BLK_DEV_PDC202XX=y
+# CONFIG_BLK_DEV_ATARAID is not set
+# CONFIG_BLK_DEV_ATARAID_PDC is not set
+# CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
+# CONFIG_BLK_DEV_ATARAID_SII is not set
+
+#
+# SCSI support
+#
+# CONFIG_SCSI is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+# CONFIG_FUSION_BOOT is not set
+# CONFIG_FUSION_ISENSE is not set
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LAN is not set
+
+#
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+# CONFIG_I2O_PCI is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_LAN is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MIPS_AU1X00_ENET=y
+# CONFIG_BCM5222_DUAL_PHY is not set
+# CONFIG_SUNLANCE is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNBMAC is not set
+# CONFIG_SUNQE is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_NET_PCI is not set
+# CONFIG_NET_POCKET is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_MYRI_SBUS is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PLIP is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+CONFIG_PPPOE=m
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# PCMCIA network device support
+#
+# CONFIG_NET_PCMCIA is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input core support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_KEYBDEV=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_UINPUT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+# CONFIG_SERIAL is not set
+# CONFIG_SERIAL_EXTENDED is not set
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_DIGI is not set
+# CONFIG_ESPSERIAL is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+# CONFIG_SERIAL_TX3912 is not set
+# CONFIG_SERIAL_TX3912_CONSOLE is not set
+# CONFIG_SERIAL_TXX9 is not set
+# CONFIG_SERIAL_TXX9_CONSOLE is not set
+CONFIG_AU1X00_UART=y
+CONFIG_AU1X00_SERIAL_CONSOLE=y
+# CONFIG_AU1X00_USB_TTY is not set
+# CONFIG_AU1X00_USB_RAW is not set
+# CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_UNIX98_PTY_COUNT=256
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Mice
+#
+# CONFIG_BUSMOUSE is not set
+# CONFIG_MOUSE is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_GAMEPORT is not set
+# CONFIG_INPUT_NS558 is not set
+# CONFIG_INPUT_LIGHTNING is not set
+# CONFIG_INPUT_PCIGAME is not set
+# CONFIG_INPUT_CS461X is not set
+# CONFIG_INPUT_EMU10K1 is not set
+# CONFIG_INPUT_SERIO is not set
+# CONFIG_INPUT_SERPORT is not set
+
+#
+# Joysticks
+#
+# CONFIG_INPUT_ANALOG is not set
+# CONFIG_INPUT_A3D is not set
+# CONFIG_INPUT_ADI is not set
+# CONFIG_INPUT_COBRA is not set
+# CONFIG_INPUT_GF2K is not set
+# CONFIG_INPUT_GRIP is not set
+# CONFIG_INPUT_INTERACT is not set
+# CONFIG_INPUT_TMDC is not set
+# CONFIG_INPUT_SIDEWINDER is not set
+# CONFIG_INPUT_IFORCE_USB is not set
+# CONFIG_INPUT_IFORCE_232 is not set
+# CONFIG_INPUT_WARRIOR is not set
+# CONFIG_INPUT_MAGELLAN is not set
+# CONFIG_INPUT_SPACEORB is not set
+# CONFIG_INPUT_SPACEBALL is not set
+# CONFIG_INPUT_STINGER is not set
+# CONFIG_INPUT_DB9 is not set
+# CONFIG_INPUT_GAMECON is not set
+# CONFIG_INPUT_TURBOGRAFX is not set
+# CONFIG_QIC02_TAPE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_IPMI_PANIC_EVENT is not set
+# CONFIG_IPMI_DEVICE_INTERFACE is not set
+# CONFIG_IPMI_KCS is not set
+# CONFIG_IPMI_WATCHDOG is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_SCx200 is not set
+# CONFIG_SCx200_GPIO is not set
+# CONFIG_AMD_PM768 is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+
+#
+# Direct Rendering Manager (XFree86 DRI support)
+#
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_PCMCIA_SERIAL_CS is not set
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_AU1X00_GPIO is not set
+# CONFIG_TS_AU1X00_ADS7846 is not set
+
+#
+# File systems
+#
+# CONFIG_QUOTA is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_ADFS_FS_RW is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BEFS_DEBUG is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+# CONFIG_UMSDOS_FS is not set
+CONFIG_VFAT_FS=y
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_CRAMFS is not set
+CONFIG_TMPFS=y
+CONFIG_RAMFS=y
+# CONFIG_ISO9660_FS is not set
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_NTFS_FS is not set
+# CONFIG_NTFS_RW is not set
+# CONFIG_HPFS_FS is not set
+CONFIG_PROC_FS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVFS_MOUNT is not set
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS=y
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX4FS_RW is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_EXT2_FS=y
+# CONFIG_SYSV_FS is not set
+# CONFIG_UDF_FS is not set
+# CONFIG_UDF_RW is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_UFS_FS_WRITE is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_XFS_QUOTA is not set
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_TRACE is not set
+# CONFIG_XFS_DEBUG is not set
+
+#
+# Network File Systems
+#
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_SUNRPC=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_SMB_FS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_NCPFS_PACKET_SIGNING is not set
+# CONFIG_NCPFS_IOCTL_LOCKING is not set
+# CONFIG_NCPFS_STRONG is not set
+# CONFIG_NCPFS_NFS_NS is not set
+# CONFIG_NCPFS_OS2_NS is not set
+# CONFIG_NCPFS_SMALLDOS is not set
+# CONFIG_NCPFS_NLS is not set
+# CONFIG_NCPFS_EXTRAS is not set
+# CONFIG_ZISOFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_SMB_NLS is not set
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Console drivers
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+
+#
+# Frame-buffer support
+#
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_CLGEN is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_INTEL is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_E1356 is not set
+# CONFIG_FB_IT8181 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+CONFIG_FBCON_CFB8=y
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+# CONFIG_FBCON_FONTWIDTH8_ONLY is not set
+# CONFIG_FBCON_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_AU1X00 is not set
+CONFIG_SOUND_AU1550_PSC=y
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+# CONFIG_SOUND_WM97XX is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+
+#
+#   SCSI support is needed for USB Storage
+#
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+
+#
+#   Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
+
+#
+# Support for USB gadgets
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BLUEZ is not set
+
+#
+# Kernel hacking
+#
+CONFIG_CROSSCOMPILE=y
+# CONFIG_RUNTIME_DEBUG is not set
+# CONFIG_KGDB is not set
+# CONFIG_GDB_CONSOLE is not set
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_MIPS_UNCACHED is not set
+CONFIG_LOG_BUF_SHIFT=0
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_FW_LOADER is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ddb5476 linux-mips-cvs-20040815/arch/mips/defconfig-ddb5476
--- linux-2.4.27/arch/mips/defconfig-ddb5476	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ddb5476	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 CONFIG_DDB5476=y
@@ -72,14 +75,10 @@ CONFIG_DDB5476=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_ISA=y
-CONFIG_PCI=y
 CONFIG_PC_KEYB=y
 CONFIG_IRQ_CPU=y
 CONFIG_I8259=y
 CONFIG_HAVE_STD_PC_SERIAL_PORT=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -117,6 +116,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -137,6 +139,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -166,6 +169,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -211,7 +215,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -301,6 +304,7 @@ CONFIG_BLK_DEV_IDEPCI=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -328,6 +332,7 @@ CONFIG_BLK_DEV_IDEPCI=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -412,6 +417,7 @@ CONFIG_EEPRO100=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 CONFIG_NE2K_PCI=y
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -507,6 +513,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -553,7 +560,6 @@ CONFIG_PSMOUSE=y
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ddb5477 linux-mips-cvs-20040815/arch/mips/defconfig-ddb5477
--- linux-2.4.27/arch/mips/defconfig-ddb5477	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ddb5477	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -72,12 +75,8 @@ CONFIG_DDB5477_BUS_FREQUENCY=0
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_PCI=y
-CONFIG_NEW_TIME_C=y
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI_AUTO=y
 CONFIG_PC_KEYB=y
 CONFIG_I8259=y
 # CONFIG_MIPS_AU1000 is not set
@@ -116,6 +115,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -137,6 +139,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -166,6 +169,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -211,7 +215,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -339,6 +342,7 @@ CONFIG_TULIP=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -428,6 +432,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -470,7 +475,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-decstation linux-mips-cvs-20040815/arch/mips/defconfig-decstation
--- linux-2.4.27/arch/mips/defconfig-decstation	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-decstation	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_DECSTATION=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -73,10 +76,10 @@ CONFIG_DECSTATION=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_EARLY_PRINTK=y
 CONFIG_BOOT_ELF32=y
 CONFIG_IRQ_CPU=y
 CONFIG_L1_CACHE_SHIFT=4
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -133,6 +136,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -162,6 +166,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -207,7 +212,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -299,6 +303,14 @@ CONFIG_SCSI_DECNCR=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
@@ -460,6 +472,7 @@ CONFIG_SERIAL_DEC=y
 CONFIG_SERIAL_DEC_CONSOLE=y
 CONFIG_DZ=y
 CONFIG_ZS=y
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -502,7 +515,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-e55 linux-mips-cvs-20040815/arch/mips/defconfig-e55
--- linux-2.4.27/arch/mips/defconfig-e55	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-e55	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_CASIO_E55=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -74,7 +77,6 @@ CONFIG_CASIO_E55=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_ISA=y
 CONFIG_DUMMY_KEYB=y
@@ -135,6 +137,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -164,6 +167,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -207,7 +211,6 @@ CONFIG_IP_MULTICAST=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -287,6 +290,7 @@ CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -418,6 +422,7 @@ CONFIG_SERIAL_MANY_PORTS=y
 # CONFIG_SERIAL_MULTIPORT is not set
 # CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -476,13 +481,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDT is not set
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-eagle linux-mips-cvs-20040815/arch/mips/defconfig-eagle
--- linux-2.4.27/arch/mips/defconfig-eagle	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-eagle	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,11 +78,7 @@ CONFIG_VRC4173=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_DUMMY_KEYB=y
 # CONFIG_SCSI is not set
 # CONFIG_MIPS_AU1000 is not set
@@ -118,6 +117,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -141,6 +143,10 @@ CONFIG_PCMCIA_VRC4173=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -154,6 +160,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -209,7 +216,8 @@ CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -261,6 +269,7 @@ CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -307,7 +316,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -388,6 +396,7 @@ CONFIG_BLK_DEV_IDECS=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -467,6 +476,7 @@ CONFIG_PCNET32=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -573,6 +583,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -635,13 +646,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDT is not set
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -882,7 +891,6 @@ CONFIG_USB_PEGASUS=y
 CONFIG_USB_RTL8150=y
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ev64120 linux-mips-cvs-20040815/arch/mips/defconfig-ev64120
--- linux-2.4.27/arch/mips/defconfig-ev64120	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ev64120	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_MODULES=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -56,6 +58,7 @@ CONFIG_SYSCLK_100=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -77,10 +80,8 @@ CONFIG_SYSCLK_100=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_PCI=y
 CONFIG_MIPS_GT64120=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_OLD_TIME_C=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -119,6 +120,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -140,6 +144,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -169,6 +174,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -213,7 +219,6 @@ CONFIG_IP_PNP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -339,6 +344,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 CONFIG_NE2K_PCI=y
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -435,6 +441,7 @@ CONFIG_SERIAL=y
 # CONFIG_SERIAL_CONSOLE is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ev96100 linux-mips-cvs-20040815/arch/mips/defconfig-ev96100
--- linux-2.4.27/arch/mips/defconfig-ev96100	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ev96100	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_MODULES=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_EV96100=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -73,12 +76,9 @@ CONFIG_MIPS_EV96100=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_PCI=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_GT96100=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI_AUTO=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
 # CONFIG_MIPS_AU1000 is not set
@@ -122,6 +122,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -143,6 +146,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -172,6 +176,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -216,7 +221,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -345,6 +349,7 @@ CONFIG_TULIP=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -434,6 +439,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-hp-lj linux-mips-cvs-20040815/arch/mips/defconfig-hp-lj
--- linux-2.4.27/arch/mips/defconfig-hp-lj	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-hp-lj	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_HP_LASERJET=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -74,10 +77,7 @@ CONFIG_HP_LASERJET=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -115,6 +115,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,6 +139,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -188,7 +192,8 @@ CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -242,6 +247,7 @@ CONFIG_MTD_NAND_IDS=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -287,7 +293,6 @@ CONFIG_IP_PNP_DHCP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -377,6 +382,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -405,6 +411,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -486,6 +493,7 @@ CONFIG_TULIP=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -587,6 +595,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
@@ -628,7 +637,6 @@ CONFIG_SERIAL_CONSOLE=y
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-hydrogen3 linux-mips-cvs-20040815/arch/mips/defconfig-hydrogen3
--- linux-2.4.27/arch/mips/defconfig-hydrogen3	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-hydrogen3	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 CONFIG_MIPS_HYDROGEN3=y
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_HYDROGEN3=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,9 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1100=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 CONFIG_SWAP_IO_SPACE=y
@@ -120,6 +120,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,9 +139,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-# CONFIG_PCMCIA_PB1X00 is not set
-CONFIG_PCMCIA_DB1X00=y
-# CONFIG_PCMCIA_XXS1500 is not set
 
 #
 # PCI Hotplug Support
@@ -146,6 +146,10 @@ CONFIG_PCMCIA_DB1X00=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -159,6 +163,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -208,7 +213,8 @@ CONFIG_MTD_CFI_AMDSTD=y
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-CONFIG_MTD_HYDIII=y
+# CONFIG_MTD_PB1550 is not set
+CONFIG_MTD_HYDROGEN3=y
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -260,6 +266,7 @@ CONFIG_MTD_HYDIII=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -322,7 +329,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -403,6 +409,7 @@ CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -526,51 +533,7 @@ CONFIG_PPPOE=m
 #
 # IrDA (infrared) support
 #
-CONFIG_IRDA=y
-
-#
-# IrDA protocols
-#
-CONFIG_IRLAN=m
-# CONFIG_IRNET is not set
-CONFIG_IRCOMM=m
-# CONFIG_IRDA_ULTRA is not set
-
-#
-# IrDA options
-#
-CONFIG_IRDA_CACHE_LAST_LSAP=y
-CONFIG_IRDA_FAST_RR=y
-# CONFIG_IRDA_DEBUG is not set
-
-#
-# Infrared-port device drivers
-#
-
-#
-# SIR device drivers
-#
-# CONFIG_IRTTY_SIR is not set
-# CONFIG_IRPORT_SIR is not set
-
-#
-# Dongle support
-#
-# CONFIG_DONGLE is not set
-
-#
-# FIR device drivers
-#
-# CONFIG_USB_IRDA is not set
-# CONFIG_NSC_FIR is not set
-# CONFIG_WINBOND_FIR is not set
-# CONFIG_TOSHIBA_OLD is not set
-# CONFIG_TOSHIBA_FIR is not set
-CONFIG_AU1000_FIR=m
-# CONFIG_SMC_IRCC_FIR is not set
-# CONFIG_ALI_FIR is not set
-# CONFIG_VLSI_FIR is not set
-# CONFIG_VIA_IRCC_FIR is not set
+# CONFIG_IRDA is not set
 
 #
 # ISDN subsystem
@@ -623,6 +586,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+CONFIG_MIPS_HYDROGEN3_BUTTONS=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -687,7 +651,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -928,6 +891,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -1017,7 +981,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ip22 linux-mips-cvs-20040815/arch/mips/defconfig-ip22
--- linux-2.4.27/arch/mips/defconfig-ip22	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ip22	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -81,7 +84,6 @@ CONFIG_BOOT_ELF32=y
 CONFIG_SWAP_IO_SPACE_L=y
 CONFIG_IRQ_CPU=y
 CONFIG_L1_CACHE_SHIFT=5
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -123,8 +125,8 @@ CONFIG_CPU_HAS_SYNC=y
 CONFIG_BINFMT_IRIX=y
 CONFIG_ARC_CONSOLE=y
 CONFIG_NET=y
-# CONFIG_EISA is not set
 # CONFIG_PCI is not set
+# CONFIG_EISA is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -145,6 +147,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -174,6 +177,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -220,7 +224,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -313,6 +316,14 @@ CONFIG_SGIWD93_SCSI=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
@@ -449,6 +460,7 @@ CONFIG_VT_CONSOLE=y
 # CONFIG_SERIAL is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -511,13 +523,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
 # CONFIG_INDYDOG is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 CONFIG_DS1286=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-it8172 linux-mips-cvs-20040815/arch/mips/defconfig-it8172
--- linux-2.4.27/arch/mips/defconfig-it8172	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-it8172	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -53,6 +55,7 @@ CONFIG_MIPS_ITE8172=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -74,14 +77,10 @@ CONFIG_MIPS_ITE8172=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_PCI=y
 CONFIG_IT8712=y
 CONFIG_PC_KEYB=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI_AUTO=y
 CONFIG_IT8172_CIR=y
-CONFIG_NEW_TIME_C=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -118,6 +117,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -139,6 +141,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -191,7 +194,8 @@ CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -243,6 +247,7 @@ CONFIG_MTD_PHYSMAP_BUSWIDTH=4
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -288,7 +293,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -378,6 +382,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -407,6 +412,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -488,6 +494,7 @@ CONFIG_TULIP=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -581,6 +588,7 @@ CONFIG_SERIAL_CONSOLE=y
 CONFIG_PC_KEYB=y
 # CONFIG_IT8172_SCR0 is not set
 # CONFIG_IT8172_SCR1 is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -623,7 +631,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ivr linux-mips-cvs-20040815/arch/mips/defconfig-ivr
--- linux-2.4.27/arch/mips/defconfig-ivr	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ivr	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_IVR=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -73,13 +76,9 @@ CONFIG_MIPS_IVR=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_PCI=y
 CONFIG_PC_KEYB=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI_AUTO=y
 CONFIG_IT8172_CIR=y
-CONFIG_NEW_TIME_C=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -116,6 +115,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -137,6 +139,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -166,6 +169,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -211,7 +215,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -301,6 +304,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -330,6 +334,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -411,6 +416,7 @@ CONFIG_TULIP=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -506,6 +512,7 @@ CONFIG_SERIAL_CONSOLE=y
 CONFIG_QTRONIX_KEYBOARD=y
 CONFIG_IT8172_CIR=y
 # CONFIG_IT8172_SCR0 is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -570,7 +577,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -782,7 +788,6 @@ CONFIG_USB_HID=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-jmr3927 linux-mips-cvs-20040815/arch/mips/defconfig-jmr3927
--- linux-2.4.27/arch/mips/defconfig-jmr3927	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-jmr3927	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -72,10 +75,6 @@ CONFIG_TOSHIBA_JMR3927=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_TOSHIBA_BOARDS=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
@@ -115,6 +114,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,6 +138,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -165,6 +168,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -210,7 +214,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -336,6 +339,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -448,6 +452,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 CONFIG_TXX927_SERIAL=y
 CONFIG_TXX927_SERIAL_CONSOLE=y
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
@@ -489,7 +494,6 @@ CONFIG_TXX927_SERIAL_CONSOLE=y
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 CONFIG_DS1742=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-lasat linux-mips-cvs-20040815/arch/mips/defconfig-lasat
--- linux-2.4.27/arch/mips/defconfig-lasat	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-lasat	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -46,6 +48,7 @@ CONFIG_LASAT=y
 CONFIG_PICVUE=y
 CONFIG_PICVUE_PROC=y
 CONFIG_DS1603=y
+CONFIG_MIPS_RTC=y
 CONFIG_LASAT_SYSCTL=y
 # CONFIG_MIPS_ITE8172 is not set
 # CONFIG_MIPS_ATLAS is not set
@@ -56,6 +59,7 @@ CONFIG_LASAT_SYSCTL=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -79,11 +83,9 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_BOARD_SCACHE=y
 CONFIG_R5000_CPU_SCACHE=y
-CONFIG_PCI=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_NILE4=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_NEW_TIME_C=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -121,6 +123,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -142,6 +147,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -191,7 +197,8 @@ CONFIG_MTD_CFI_AMDSTD=y
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -243,6 +250,7 @@ CONFIG_MTD_LASAT=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -284,7 +292,6 @@ CONFIG_INET=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -374,6 +381,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 CONFIG_BLK_DEV_CMD64X=y
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -402,6 +410,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -481,6 +490,7 @@ CONFIG_PCNET32=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -570,6 +580,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -612,7 +623,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-malta linux-mips-cvs-20040815/arch/mips/defconfig-malta
--- linux-2.4.27/arch/mips/defconfig-malta	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-malta	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_MALTA=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -80,12 +83,10 @@ CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_MSC=y
 CONFIG_L1_CACHE_SHIFT=5
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
 CONFIG_PC_KEYB=y
-CONFIG_PCI=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -125,6 +126,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -146,6 +150,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -175,6 +180,7 @@ CONFIG_BLK_DEV_FD=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -220,7 +226,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -311,6 +316,14 @@ CONFIG_SD_EXTRA_DEVS=40
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -416,6 +429,7 @@ CONFIG_PCNET32=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -505,6 +519,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -547,7 +562,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-mirage linux-mips-cvs-20040815/arch/mips/defconfig-mirage
--- linux-2.4.27/arch/mips/defconfig-mirage	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-mirage	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_MIPS_MIRAGE=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_MIRAGE=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,11 +78,7 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
 CONFIG_PC_KEYB=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -120,6 +119,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -138,6 +140,10 @@ CONFIG_HOTPLUG=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -151,12 +157,86 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+CONFIG_CMDLINE_BOOL=y
+CONFIG_CMDLINE="root=/dev/mtdblock0 rw ip=off"
 # CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PB1000 is not set
+# CONFIG_MTD_PB1500 is not set
+# CONFIG_MTD_PB1100 is not set
+# CONFIG_MTD_BOSPORUS is not set
+# CONFIG_MTD_XXS1500 is not set
+# CONFIG_MTD_MTX1 is not set
+# CONFIG_MTD_DB1X00 is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
+CONFIG_MTD_MIRAGE=y
+# CONFIG_MTD_CSTM_MIPS_IXX is not set
+# CONFIG_MTD_OCELOT is not set
+# CONFIG_MTD_LASAT is not set
+# CONFIG_MTD_PCI is not set
+# CONFIG_MTD_PCMCIA is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
 
 #
 # Parallel port support
@@ -181,6 +261,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -243,7 +324,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -385,7 +465,19 @@ CONFIG_PPPOE=m
 #
 # Wireless LAN (non-hamradio)
 #
-# CONFIG_NET_RADIO is not set
+CONFIG_NET_RADIO=y
+# CONFIG_STRIP is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_ARLAN is not set
+# CONFIG_AIRONET4500 is not set
+# CONFIG_AIRONET4500_NONCS is not set
+# CONFIG_AIRONET4500_PROC is not set
+# CONFIG_AIRO is not set
+# CONFIG_HERMES is not set
+# CONFIG_PLX_HERMES is not set
+# CONFIG_TMD_HERMES is not set
+# CONFIG_PCI_HERMES is not set
+CONFIG_NET_WIRELESS=y
 
 #
 # Token Ring devices
@@ -461,19 +553,33 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
 #
 # I2C support
 #
-# CONFIG_I2C is not set
+CONFIG_I2C=y
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_PHILIPSPAR is not set
+# CONFIG_I2C_ELV is not set
+# CONFIG_I2C_VELLEMAN is not set
+# CONFIG_SCx200_I2C is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_ALGOPCF is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_PROC=y
 
 #
 # Mice
 #
 # CONFIG_BUSMOUSE is not set
-# CONFIG_MOUSE is not set
+CONFIG_MOUSE=y
+CONFIG_PSMOUSE=y
+# CONFIG_82C710_MOUSE is not set
+# CONFIG_PC110_PAD is not set
+# CONFIG_MK712_MOUSE is not set
 
 #
 # Joysticks
@@ -525,7 +631,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -570,7 +675,8 @@ CONFIG_AUTOFS_FS=y
 # CONFIG_VFAT_FS is not set
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
-# CONFIG_JFFS2_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
 # CONFIG_CRAMFS is not set
 CONFIG_TMPFS=y
 CONFIG_RAMFS=y
@@ -653,7 +759,50 @@ CONFIG_MSDOS_PARTITION=y
 #
 # Frame-buffer support
 #
-# CONFIG_FB is not set
+CONFIG_FB=y
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_CLGEN is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_INTEL is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_E1356 is not set
+# CONFIG_FB_IT8181 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_FBCON_ADVANCED=y
+# CONFIG_FBCON_MFB is not set
+# CONFIG_FBCON_CFB2 is not set
+# CONFIG_FBCON_CFB4 is not set
+CONFIG_FBCON_CFB8=y
+CONFIG_FBCON_CFB16=y
+# CONFIG_FBCON_CFB24 is not set
+# CONFIG_FBCON_CFB32 is not set
+# CONFIG_FBCON_AFB is not set
+# CONFIG_FBCON_ILBM is not set
+# CONFIG_FBCON_IPLAN2P2 is not set
+# CONFIG_FBCON_IPLAN2P4 is not set
+# CONFIG_FBCON_IPLAN2P8 is not set
+# CONFIG_FBCON_MAC is not set
+# CONFIG_FBCON_VGA_PLANES is not set
+# CONFIG_FBCON_VGA is not set
+# CONFIG_FBCON_HGA is not set
+CONFIG_FBCON_FONTWIDTH8_ONLY=y
+CONFIG_FBCON_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
 
 #
 # Sound
@@ -676,6 +825,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -684,7 +834,7 @@ CONFIG_SOUND_AU1X00=y
 # CONFIG_SOUND_OSS is not set
 # CONFIG_SOUND_TVMIXER is not set
 # CONFIG_SOUND_AD1980 is not set
-# CONFIG_SOUND_WM97XX is not set
+CONFIG_SOUND_WM97XX=y
 
 #
 # USB support
@@ -765,7 +915,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
@@ -819,6 +968,6 @@ CONFIG_LOG_BUF_SHIFT=0
 # Library routines
 #
 # CONFIG_CRC32 is not set
-CONFIG_ZLIB_INFLATE=m
-CONFIG_ZLIB_DEFLATE=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
 # CONFIG_FW_LOADER is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-mpc30x linux-mips-cvs-20040815/arch/mips/defconfig-mpc30x
--- linux-2.4.27/arch/mips/defconfig-mpc30x	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-mpc30x	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,12 +78,7 @@ CONFIG_VRC4173=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
-CONFIG_DUMMY_KEYB=y
 # CONFIG_SCSI is not set
 # CONFIG_MIPS_AU1000 is not set
 
@@ -118,6 +116,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -139,6 +140,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -168,6 +170,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -214,7 +217,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -396,6 +398,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -439,7 +442,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -671,7 +673,6 @@ CONFIG_USB_PEGASUS=y
 CONFIG_USB_RTL8150=y
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-mtx-1 linux-mips-cvs-20040815/arch/mips/defconfig-mtx-1
--- linux-2.4.27/arch/mips/defconfig-mtx-1	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-mtx-1	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 CONFIG_MIPS_MTX1=y
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_MTX1=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -119,6 +118,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -140,6 +142,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -189,7 +192,8 @@ CONFIG_MTD_CFI_AMDSTD=y
 # CONFIG_MTD_XXS1500 is not set
 CONFIG_MTD_MTX1=y
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -241,6 +245,7 @@ CONFIG_MTD_MTX1=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=m
@@ -356,7 +361,6 @@ CONFIG_IP_NF_ARPFILTER=m
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 CONFIG_VLAN_8021Q=m
@@ -389,12 +393,14 @@ CONFIG_NET_SCHED=y
 CONFIG_NET_SCH_CBQ=m
 CONFIG_NET_SCH_HTB=m
 # CONFIG_NET_SCH_CSZ is not set
+# CONFIG_NET_SCH_HFSC is not set
 CONFIG_NET_SCH_PRIO=m
 CONFIG_NET_SCH_RED=m
 CONFIG_NET_SCH_SFQ=m
 CONFIG_NET_SCH_TEQL=m
 CONFIG_NET_SCH_TBF=m
 CONFIG_NET_SCH_GRED=m
+# CONFIG_NET_SCH_NETEM is not set
 CONFIG_NET_SCH_DSMARK=m
 CONFIG_NET_SCH_INGRESS=m
 CONFIG_NET_QOS=y
@@ -471,6 +477,14 @@ CONFIG_SR_EXTRA_DEVS=2
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -677,6 +691,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -719,7 +734,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -817,6 +831,7 @@ CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_SMB_FS=m
 # CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_SMB_UNIX is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
 # CONFIG_NCPFS_IOCTL_LOCKING is not set
@@ -934,6 +949,7 @@ CONFIG_SOUND=m
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_AU1X00 is not set
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -1065,7 +1081,6 @@ CONFIG_USB_PEGASUS=m
 CONFIG_USB_RTL8150=m
 CONFIG_USB_KAWETH=m
 CONFIG_USB_CATC=m
-# CONFIG_USB_AX8817X is not set
 CONFIG_USB_CDCETHER=m
 CONFIG_USB_USBNET=m
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-nino linux-mips-cvs-20040815/arch/mips/defconfig-nino
--- linux-2.4.27/arch/mips/defconfig-nino	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-nino	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -76,7 +79,6 @@ CONFIG_NINO_8MB=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -134,6 +136,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -163,6 +166,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -211,7 +215,6 @@ CONFIG_INET=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -334,6 +337,7 @@ CONFIG_SERIAL_TX3912_CONSOLE=y
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
@@ -375,7 +379,6 @@ CONFIG_SERIAL_TX3912_CONSOLE=y
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ocelot linux-mips-cvs-20040815/arch/mips/defconfig-ocelot
--- linux-2.4.27/arch/mips/defconfig-ocelot	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ocelot	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_MOMENCO_OCELOT=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -71,12 +74,10 @@ CONFIG_MOMENCO_OCELOT=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_PCI=y
 CONFIG_SYSCLK_100=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_OLD_TIME_C=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -118,6 +119,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -139,6 +143,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -188,7 +193,8 @@ CONFIG_MTD_JEDEC=y
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 CONFIG_MTD_OCELOT=y
@@ -245,6 +251,7 @@ CONFIG_MTD_NAND_IDS=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -289,7 +296,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -415,6 +421,7 @@ CONFIG_EEPRO100=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -504,6 +511,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-osprey linux-mips-cvs-20040815/arch/mips/defconfig-osprey
--- linux-2.4.27/arch/mips/defconfig-osprey	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-osprey	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,7 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_VR4181=y
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_DUMMY_KEYB=y
 # CONFIG_SCSI is not set
@@ -116,6 +118,8 @@ CONFIG_CPU_HAS_SYNC=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
 # CONFIG_PCI is not set
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -136,6 +140,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -165,6 +170,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -210,7 +216,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -381,6 +386,7 @@ CONFIG_SERIAL_MANY_PORTS=y
 # CONFIG_SERIAL_MULTIPORT is not set
 # CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -424,7 +430,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-pb1000 linux-mips-cvs-20040815/arch/mips/defconfig-pb1000
--- linux-2.4.27/arch/mips/defconfig-pb1000	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-pb1000	2004-08-15 08:05:44.000000000 +0200
@@ -26,11 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 CONFIG_MIPS_PB1000=y
-CONFIG_PCI_AUTO=y
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -53,6 +54,7 @@ CONFIG_PCI_AUTO=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -76,9 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1000=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 CONFIG_SWAP_IO_SPACE_W=y
@@ -122,6 +121,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -138,9 +140,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-CONFIG_PCMCIA_PB1X00=y
-# CONFIG_PCMCIA_DB1X00 is not set
-# CONFIG_PCMCIA_XXS1500 is not set
 
 #
 # PCI Hotplug Support
@@ -148,6 +147,10 @@ CONFIG_PCMCIA_PB1X00=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -161,6 +164,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -210,7 +214,8 @@ CONFIG_MTD_PB1000=y
 # CONFIG_MTD_XXS1500 is not set
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -262,6 +267,7 @@ CONFIG_MTD_PB1000=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -307,7 +313,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -388,6 +393,7 @@ CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -612,6 +618,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -676,7 +683,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -877,6 +883,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -966,7 +973,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-pb1100 linux-mips-cvs-20040815/arch/mips/defconfig-pb1100
--- linux-2.4.27/arch/mips/defconfig-pb1100	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-pb1100	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 CONFIG_MIPS_PB1100=y
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_PB1100=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1100=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-# CONFIG_PCI_AUTO is not set
-CONFIG_NEW_PCI=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 CONFIG_SWAP_IO_SPACE_W=y
@@ -122,6 +121,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+# CONFIG_PCI_AUTO is not set
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -143,6 +145,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -194,7 +197,8 @@ CONFIG_MTD_PB1100=y
 CONFIG_MTD_PB1500_BOOT=y
 CONFIG_MTD_PB1500_USER=y
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -246,6 +250,7 @@ CONFIG_MTD_PB1500_USER=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -308,7 +313,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -389,6 +393,7 @@ CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -604,6 +609,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -668,7 +674,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -767,6 +772,7 @@ CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_SMB_FS=m
 # CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_SMB_UNIX is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
 # CONFIG_NCPFS_IOCTL_LOCKING is not set
@@ -906,6 +912,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 # CONFIG_SOUND_AU1X00 is not set
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -995,7 +1002,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-pb1500 linux-mips-cvs-20040815/arch/mips/defconfig-pb1500
--- linux-2.4.27/arch/mips/defconfig-pb1500	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-pb1500	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 CONFIG_MIPS_PB1500=y
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_PB1500=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -120,6 +119,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,9 +138,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-CONFIG_PCMCIA_PB1X00=y
-# CONFIG_PCMCIA_DB1X00 is not set
-# CONFIG_PCMCIA_XXS1500 is not set
 
 #
 # PCI Hotplug Support
@@ -146,6 +145,10 @@ CONFIG_PCMCIA_PB1X00=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -159,6 +162,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -210,7 +214,8 @@ CONFIG_MTD_PB1500=y
 CONFIG_MTD_PB1500_BOOT=y
 # CONFIG_MTD_PB1500_USER is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -262,6 +267,7 @@ CONFIG_MTD_PB1500_BOOT=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -324,7 +330,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -414,6 +419,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -442,6 +448,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -523,6 +530,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -663,6 +671,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -727,7 +736,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -832,6 +840,7 @@ CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_SMB_FS=m
 # CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_SMB_UNIX is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
 # CONFIG_NCPFS_IOCTL_LOCKING is not set
@@ -972,6 +981,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -1061,7 +1071,6 @@ CONFIG_USB_HIDINPUT=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-pb1550 linux-mips-cvs-20040815/arch/mips/defconfig-pb1550
--- linux-2.4.27/arch/mips/defconfig-pb1550	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-pb1550	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+CONFIG_MIPS_PB1550=y
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1550=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 # CONFIG_NONCOHERENT_IO is not set
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -120,14 +119,36 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
 # CONFIG_SBUS is not set
-# CONFIG_HOTPLUG is not set
-# CONFIG_PCMCIA is not set
+CONFIG_HOTPLUG=y
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=m
+# CONFIG_CARDBUS is not set
+# CONFIG_TCIC is not set
+# CONFIG_I82092 is not set
+# CONFIG_I82365 is not set
+CONFIG_PCMCIA_AU1X00=m
+
+#
+# PCI Hotplug Support
+#
 # CONFIG_HOTPLUG_PCI is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ is not set
+# CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -141,12 +162,89 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
 # Memory Technology Devices (MTD)
 #
-# CONFIG_MTD is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+# CONFIG_MTD_AMDSTD is not set
+# CONFIG_MTD_SHARP is not set
+# CONFIG_MTD_JEDEC is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PB1000 is not set
+# CONFIG_MTD_PB1500 is not set
+# CONFIG_MTD_PB1100 is not set
+# CONFIG_MTD_BOSPORUS is not set
+# CONFIG_MTD_XXS1500 is not set
+# CONFIG_MTD_MTX1 is not set
+# CONFIG_MTD_DB1X00 is not set
+CONFIG_MTD_PB1550=y
+CONFIG_MTD_PB1550_BOOT=y
+CONFIG_MTD_PB1550_USER=y
+# CONFIG_MTD_HYDROGEN3 is not set
+# CONFIG_MTD_MIRAGE is not set
+# CONFIG_MTD_CSTM_MIPS_IXX is not set
+# CONFIG_MTD_OCELOT is not set
+# CONFIG_MTD_LASAT is not set
+# CONFIG_MTD_PCI is not set
+# CONFIG_MTD_PCMCIA is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC1000 is not set
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOCPROBE is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=m
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+CONFIG_MTD_NAND_IDS=m
 
 #
 # Parallel port support
@@ -171,6 +269,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -233,7 +332,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -291,10 +389,10 @@ CONFIG_BLK_DEV_IDE=y
 #
 # CONFIG_BLK_DEV_HD_IDE is not set
 # CONFIG_BLK_DEV_HD is not set
-# CONFIG_BLK_DEV_IDEDISK is not set
+CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
 # CONFIG_IDEDISK_STROKE is not set
-# CONFIG_BLK_DEV_IDECS is not set
+CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -323,6 +421,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -353,6 +452,7 @@ CONFIG_BLK_DEV_PDC202XX=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -464,58 +564,19 @@ CONFIG_PPPOE=m
 # CONFIG_WAN is not set
 
 #
-# Amateur Radio support
+# PCMCIA network device support
 #
-# CONFIG_HAMRADIO is not set
+# CONFIG_NET_PCMCIA is not set
 
 #
-# IrDA (infrared) support
-#
-CONFIG_IRDA=y
-
-#
-# IrDA protocols
-#
-CONFIG_IRLAN=m
-# CONFIG_IRNET is not set
-CONFIG_IRCOMM=m
-# CONFIG_IRDA_ULTRA is not set
-
-#
-# IrDA options
-#
-CONFIG_IRDA_CACHE_LAST_LSAP=y
-CONFIG_IRDA_FAST_RR=y
-# CONFIG_IRDA_DEBUG is not set
-
-#
-# Infrared-port device drivers
-#
-
-#
-# SIR device drivers
-#
-# CONFIG_IRTTY_SIR is not set
-# CONFIG_IRPORT_SIR is not set
-
-#
-# Dongle support
+# Amateur Radio support
 #
-# CONFIG_DONGLE is not set
+# CONFIG_HAMRADIO is not set
 
 #
-# FIR device drivers
+# IrDA (infrared) support
 #
-# CONFIG_USB_IRDA is not set
-# CONFIG_NSC_FIR is not set
-# CONFIG_WINBOND_FIR is not set
-# CONFIG_TOSHIBA_OLD is not set
-# CONFIG_TOSHIBA_FIR is not set
-CONFIG_AU1000_FIR=m
-# CONFIG_SMC_IRCC_FIR is not set
-# CONFIG_ALI_FIR is not set
-# CONFIG_VLSI_FIR is not set
-# CONFIG_VIA_IRCC_FIR is not set
+# CONFIG_IRDA is not set
 
 #
 # ISDN subsystem
@@ -568,6 +629,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -632,7 +694,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -647,6 +708,12 @@ CONFIG_UNIX98_PTY_COUNT=256
 # Direct Rendering Manager (XFree86 DRI support)
 #
 # CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_PCMCIA_SERIAL_CS is not set
+# CONFIG_SYNCLINK_CS is not set
 # CONFIG_AU1X00_GPIO is not set
 # CONFIG_TS_AU1X00_ADS7846 is not set
 
@@ -677,7 +744,8 @@ CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
-# CONFIG_JFFS2_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
 # CONFIG_CRAMFS is not set
 CONFIG_TMPFS=y
 CONFIG_RAMFS=y
@@ -848,12 +916,135 @@ CONFIG_FONT_8x16=y
 #
 # Sound
 #
-# CONFIG_SOUND is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_MIDI_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_ICH is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_AU1X00 is not set
+CONFIG_SOUND_AU1550_PSC=y
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_MIDI_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_TVMIXER is not set
+# CONFIG_SOUND_AD1980 is not set
+# CONFIG_SOUND_WM97XX is not set
 
 #
 # USB support
 #
-# CONFIG_USB is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_BANDWIDTH is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_UHCI is not set
+# CONFIG_USB_UHCI_ALT is not set
+CONFIG_USB_OHCI=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_BLUETOOTH is not set
+# CONFIG_USB_MIDI is not set
+
+#
+#   SCSI support is needed for USB Storage
+#
+# CONFIG_USB_STORAGE is not set
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# USB Human Interface Devices (HID)
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_DC2XX is not set
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_SCANNER is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_HPUSBSCSI is not set
+
+#
+# USB Multimedia devices
+#
+
+#
+#   Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network adaptors
+#
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_CDCETHER is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_USS720 is not set
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_TIGL is not set
+# CONFIG_USB_BRLVGER is not set
+# CONFIG_USB_LCD is not set
 
 #
 # Support for USB gadgets
@@ -886,5 +1077,6 @@ CONFIG_LOG_BUF_SHIFT=0
 # Library routines
 #
 # CONFIG_CRC32 is not set
-CONFIG_ZLIB_INFLATE=m
-CONFIG_ZLIB_DEFLATE=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_FW_LOADER is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-rbtx4927 linux-mips-cvs-20040815/arch/mips/defconfig-rbtx4927
--- linux-2.4.27/arch/mips/defconfig-rbtx4927	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-rbtx4927	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -71,10 +74,6 @@ CONFIG_TOSHIBA_RBTX4927=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
 CONFIG_ISA=y
@@ -115,6 +114,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -135,6 +137,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -164,6 +167,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -208,7 +212,6 @@ CONFIG_IP_PNP_DHCP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -346,6 +349,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -460,6 +464,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 CONFIG_SERIAL_TXX9=y
 CONFIG_SERIAL_TXX9_CONSOLE=y
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
@@ -501,7 +506,6 @@ CONFIG_SERIAL_TXX9_CONSOLE=y
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 CONFIG_DS1742=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-rm200 linux-mips-cvs-20040815/arch/mips/defconfig-rm200
--- linux-2.4.27/arch/mips/defconfig-rm200	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-rm200	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -79,9 +82,7 @@ CONFIG_ARC_PROMLIB=y
 CONFIG_I8259=y
 CONFIG_ISA=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_OLD_TIME_C=y
 CONFIG_PC_KEYB=y
-CONFIG_PCI=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -120,6 +121,9 @@ CONFIG_CPU_HAS_SYNC=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 # CONFIG_ARC_CONSOLE is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 CONFIG_EISA=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_TC is not set
@@ -141,6 +145,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -170,6 +175,7 @@ CONFIG_BLK_DEV_FD=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -212,7 +218,6 @@ CONFIG_INET=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -333,6 +338,7 @@ CONFIG_VT_CONSOLE=y
 # CONFIG_SERIAL is not set
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-sb1250-swarm linux-mips-cvs-20040815/arch/mips/defconfig-sb1250-swarm
--- linux-2.4.27/arch/mips/defconfig-sb1250-swarm	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-sb1250-swarm	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -84,7 +87,6 @@ CONFIG_SIBYTE_CFE=y
 # CONFIG_SIBYTE_BW_TRACE is not set
 # CONFIG_SIBYTE_SB1250_PROF is not set
 # CONFIG_SIBYTE_TBPROF is not set
-# CONFIG_PCI is not set
 CONFIG_SIBYTE_GENBUS_IDE=y
 CONFIG_SMP_CAPABLE=y
 # CONFIG_SNI_RM200_PCI is not set
@@ -97,7 +99,6 @@ CONFIG_SMP_CAPABLE=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_NEW_TIME_C=y
 CONFIG_DUMMY_KEYB=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
@@ -146,6 +147,8 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
 # CONFIG_PCI is not set
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -166,6 +169,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -195,6 +199,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -237,7 +242,6 @@ CONFIG_INET=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -318,6 +322,7 @@ CONFIG_BLK_DEV_IDE_SIBYTE=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -460,6 +465,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 CONFIG_SIBYTE_SB1250_DUART=y
 CONFIG_SIBYTE_SB1250_DUART_CONSOLE=y
 CONFIG_SERIAL_CONSOLE=y
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -502,7 +508,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-sead linux-mips-cvs-20040815/arch/mips/defconfig-sead
--- linux-2.4.27/arch/mips/defconfig-sead	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-sead	2004-08-15 08:05:44.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_MIPS_SEAD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -73,9 +76,7 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_BOOT_ELF32=y
 CONFIG_L1_CACHE_SHIFT=5
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-# CONFIG_PCI is not set
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -136,6 +137,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -165,6 +167,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -239,6 +242,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
@@ -280,7 +284,6 @@ CONFIG_SERIAL_CONSOLE=y
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-tb0226 linux-mips-cvs-20040815/arch/mips/defconfig-tb0226
--- linux-2.4.27/arch/mips/defconfig-tb0226	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-tb0226	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -74,11 +77,7 @@ CONFIG_TANBAC_TB0226=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_DUMMY_KEYB=y
 CONFIG_SERIAL_MANY_PORTS=y
 # CONFIG_MIPS_AU1000 is not set
@@ -117,6 +116,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -138,6 +140,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -167,6 +170,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -213,7 +217,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -306,6 +309,14 @@ CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -411,6 +422,7 @@ CONFIG_EEPRO100=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -501,6 +513,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -559,13 +572,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDT is not set
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -793,7 +804,6 @@ CONFIG_USB_STORAGE=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-tb0229 linux-mips-cvs-20040815/arch/mips/defconfig-tb0229
--- linux-2.4.27/arch/mips/defconfig-tb0229	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-tb0229	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,11 +78,7 @@ CONFIG_TANBAC_TB0219=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_DUMMY_KEYB=y
 CONFIG_SERIAL_MANY_PORTS=y
 # CONFIG_MIPS_AU1000 is not set
@@ -118,6 +117,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -139,6 +141,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -168,6 +171,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -215,7 +219,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -349,6 +352,7 @@ CONFIG_EEPRO100=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 CONFIG_8139CP=y
@@ -439,6 +443,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -497,13 +502,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDT is not set
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-ti1500 linux-mips-cvs-20040815/arch/mips/defconfig-ti1500
--- linux-2.4.27/arch/mips/defconfig-ti1500	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-ti1500	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 CONFIG_MIPS_XXS1500=y
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_XXS1500=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -120,6 +119,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,9 +138,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-# CONFIG_PCMCIA_PB1X00 is not set
-# CONFIG_PCMCIA_DB1X00 is not set
-CONFIG_PCMCIA_XXS1500=y
 
 #
 # PCI Hotplug Support
@@ -146,6 +145,10 @@ CONFIG_PCMCIA_XXS1500=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -159,6 +162,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -208,7 +212,8 @@ CONFIG_MTD_CFI_AMDSTD=y
 CONFIG_MTD_XXS1500=y
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -260,6 +265,7 @@ CONFIG_MTD_XXS1500=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -322,7 +328,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -403,6 +408,7 @@ CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -590,6 +596,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -659,7 +666,6 @@ CONFIG_I2C_PROC=m
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -761,6 +767,7 @@ CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_SMB_FS=m
 # CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_SMB_UNIX is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
 # CONFIG_NCPFS_IOCTL_LOCKING is not set
@@ -899,6 +906,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
@@ -988,7 +996,6 @@ CONFIG_USB_HIDDEV=y
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_KAWETH is not set
 # CONFIG_USB_CATC is not set
-# CONFIG_USB_AX8817X is not set
 # CONFIG_USB_CDCETHER is not set
 # CONFIG_USB_USBNET is not set
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-workpad linux-mips-cvs-20040815/arch/mips/defconfig-workpad
--- linux-2.4.27/arch/mips/defconfig-workpad	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-workpad	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -53,6 +55,7 @@ CONFIG_IBM_WORKPAD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,7 +78,6 @@ CONFIG_IBM_WORKPAD=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_IRQ_CPU=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_ISA=y
 # CONFIG_SCSI is not set
@@ -135,6 +137,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -164,6 +167,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -207,7 +211,6 @@ CONFIG_IP_MULTICAST=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -287,6 +290,7 @@ CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -418,6 +422,7 @@ CONFIG_SERIAL_MANY_PORTS=y
 # CONFIG_SERIAL_MULTIPORT is not set
 # CONFIG_HUB6 is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_VR41XX_KIU is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
@@ -476,13 +481,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDT is not set
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-xxs1500 linux-mips-cvs-20040815/arch/mips/defconfig-xxs1500
--- linux-2.4.27/arch/mips/defconfig-xxs1500	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-xxs1500	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 CONFIG_MIPS_XXS1500=y
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_XXS1500=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -75,10 +78,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_SOC_AU1X00=y
 CONFIG_SOC_AU1500=y
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
-CONFIG_NEW_PCI=y
-CONFIG_PCI_AUTO=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -120,6 +119,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+CONFIG_PCI_NEW=y
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -136,9 +138,6 @@ CONFIG_PCMCIA=m
 # CONFIG_I82092 is not set
 # CONFIG_I82365 is not set
 CONFIG_PCMCIA_AU1X00=m
-# CONFIG_PCMCIA_PB1X00 is not set
-# CONFIG_PCMCIA_DB1X00 is not set
-CONFIG_PCMCIA_XXS1500=y
 
 #
 # PCI Hotplug Support
@@ -146,6 +145,10 @@ CONFIG_PCMCIA_XXS1500=y
 # CONFIG_HOTPLUG_PCI is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ is not set
 # CONFIG_HOTPLUG_PCI_COMPAQ_NVRAM is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_HOTPLUG_PCI_SHPC_POLL_EVENT_MODE is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_PCIE_POLL_EVENT_MODE is not set
 CONFIG_SYSVIPC=y
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
@@ -159,6 +162,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 # CONFIG_PM is not set
 
 #
@@ -208,7 +212,8 @@ CONFIG_MTD_CFI_AMDSTD=y
 CONFIG_MTD_XXS1500=y
 # CONFIG_MTD_MTX1 is not set
 # CONFIG_MTD_DB1X00 is not set
-# CONFIG_MTD_HYDIII is not set
+# CONFIG_MTD_PB1550 is not set
+# CONFIG_MTD_HYDROGEN3 is not set
 # CONFIG_MTD_MIRAGE is not set
 # CONFIG_MTD_CSTM_MIPS_IXX is not set
 # CONFIG_MTD_OCELOT is not set
@@ -260,6 +265,7 @@ CONFIG_MTD_XXS1500=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -322,7 +328,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -412,6 +417,7 @@ CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_WDC_ALI15X3 is not set
 # CONFIG_BLK_DEV_AMD74XX is not set
 # CONFIG_AMD74XX_OVERRIDE is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
 # CONFIG_BLK_DEV_CMD64X is not set
 # CONFIG_BLK_DEV_TRIFLEX is not set
 # CONFIG_BLK_DEV_CY82C693 is not set
@@ -440,6 +446,7 @@ CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_ATARAID is not set
 # CONFIG_BLK_DEV_ATARAID_PDC is not set
 # CONFIG_BLK_DEV_ATARAID_HPT is not set
+# CONFIG_BLK_DEV_ATARAID_MEDLEY is not set
 # CONFIG_BLK_DEV_ATARAID_SII is not set
 
 #
@@ -521,6 +528,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -659,6 +667,7 @@ CONFIG_AU1X00_SERIAL_CONSOLE=y
 # CONFIG_AU1X00_USB_TTY is not set
 # CONFIG_AU1X00_USB_RAW is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -701,7 +710,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -803,6 +811,7 @@ CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_SMB_FS=m
 # CONFIG_SMB_NLS_DEFAULT is not set
+# CONFIG_SMB_UNIX is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_NCPFS_PACKET_SIGNING is not set
 # CONFIG_NCPFS_IOCTL_LOCKING is not set
@@ -901,6 +910,7 @@ CONFIG_SOUND=y
 # CONFIG_SOUND_RME96XX is not set
 # CONFIG_SOUND_SONICVIBES is not set
 CONFIG_SOUND_AU1X00=y
+# CONFIG_SOUND_AU1550_PSC is not set
 # CONFIG_SOUND_TRIDENT is not set
 # CONFIG_SOUND_MSNDCLAS is not set
 # CONFIG_SOUND_MSNDPIN is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/defconfig-yosemite linux-mips-cvs-20040815/arch/mips/defconfig-yosemite
--- linux-2.4.27/arch/mips/defconfig-yosemite	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/defconfig-yosemite	2004-08-15 08:05:44.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -115,6 +118,8 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
 # CONFIG_PCI is not set
+# CONFIG_PCI_NEW is not set
+CONFIG_PCI_AUTO=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -135,6 +140,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_ELF32 is not set
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -164,6 +170,7 @@ CONFIG_BINFMT_ELF=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -209,7 +216,6 @@ CONFIG_IP_PNP_DHCP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -301,6 +307,14 @@ CONFIG_CHR_DEV_SG=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
@@ -458,6 +472,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/Makefile linux-mips-cvs-20040815/arch/mips/kernel/Makefile
--- linux-2.4.27/arch/mips/kernel/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/Makefile	2004-08-15 08:05:48.000000000 +0200
@@ -12,11 +12,11 @@ all:	kernel.o head.o init_task.o
 
 O_TARGET := kernel.o
 
-export-objs	= irq.o mips_ksyms.o pci-dma.o setup.o semaphore.o smp.o
+export-objs	= irq.o mips_ksyms.o pci-dma.o setup.o semaphore.o smp.o time.o
 
 obj-y		+= branch.o cpu-probe.o irq.o process.o signal.o entry.o \
 		   traps.o ptrace.o reset.o semaphore.o setup.o syscall.o \
-		   sysmips.o ipc.o scall_o32.o unaligned.o
+		   sysmips.o ipc.o scall_o32.o time.o unaligned.o
 
 obj-$(CONFIG_MODULES)		+= mips_ksyms.o
 
@@ -42,12 +42,7 @@ obj-$(CONFIG_SMP)		+= smp.o
 
 obj-$(CONFIG_I8259)		+= i8259.o
 obj-$(CONFIG_IRQ_CPU)		+= irq_cpu.o
-
-# transition from old time.c to new time.c
-# some boards uses old-time.c, some use time.c, and some use their own ones
-export-objs			+= old-time.o time.o
-obj-$(CONFIG_OLD_TIME_C)	+= old-time.o
-obj-$(CONFIG_NEW_TIME_C)	+= time.o
+obj-$(CONFIG_IRQ_CPU_RM7K)	+= irq-rm7000.o
 
 obj-$(CONFIG_BINFMT_IRIX)	+= irixelf.o irixioctl.o irixsig.o sysirix.o \
 				   irixinv.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/cpu-probe.c linux-mips-cvs-20040815/arch/mips/kernel/cpu-probe.c
--- linux-2.4.27/arch/mips/kernel/cpu-probe.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/cpu-probe.c	2004-08-15 08:05:48.000000000 +0200
@@ -43,14 +43,21 @@ extern void (*au1k_wait_ptr)(void);
 void au1k_wait(void)
 {
 #ifdef CONFIG_PM
+	unsigned long addr;
 	/* using the wait instruction makes CP0 counter unusable */
-	__asm__(".set\tmips3\n\t"
+	__asm__("la %0,au1k_wait\n\t"
+		".set mips3\n\t"
+		"cache 0x14,0(%0)\n\t"
+		"cache 0x14,32(%0)\n\t"
+		"sync\n\t"
+		"nop\n\t"
 		"wait\n\t"
 		"nop\n\t"
 		"nop\n\t"
 		"nop\n\t"
 		"nop\n\t"
-		".set\tmips0");
+		".set mips0\n\t"
+		: : "r" (addr));
 #else
 	__asm__("nop\n\t"
 		"nop");
@@ -97,6 +104,7 @@ static inline void check_wait(void)
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
+	case CPU_AU1550:
 		if (au1k_wait_ptr != NULL) {
 			cpu_wait = au1k_wait_ptr;
 			printk(" available.\n");
@@ -170,8 +178,7 @@ static inline void cpu_probe_legacy(stru
 	case PRID_IMP_R2000:
 		c->cputype = CPU_R2000;
 		c->isa_level = MIPS_CPU_ISA_I;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX |
-		             MIPS_CPU_LLSC;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX;
 		if (__cpu_has_fpu())
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
@@ -185,17 +192,24 @@ static inline void cpu_probe_legacy(stru
 		else
 			c->cputype = CPU_R3000;
 		c->isa_level = MIPS_CPU_ISA_I;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX |
-		             MIPS_CPU_LLSC;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX; 
 		if (__cpu_has_fpu())
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
 		break;
 	case PRID_IMP_R4000:
-		if ((c->processor_id & 0xff) >= PRID_REV_R4400)
-			c->cputype = CPU_R4400SC;
-		else
-			c->cputype = CPU_R4000SC;
+		if (read_c0_config() & CONF_SC) {
+			if ((c->processor_id & 0xff) >= PRID_REV_R4400)
+				c->cputype = CPU_R4400PC;
+			else
+				c->cputype = CPU_R4000PC;
+		} else {
+			if ((c->processor_id & 0xff) >= PRID_REV_R4400)
+				c->cputype = CPU_R4400SC;
+			else
+				c->cputype = CPU_R4000SC;
+		}
+
 		c->isa_level = MIPS_CPU_ISA_III;
 		c->options = R4K_OPTS | MIPS_CPU_FPU | MIPS_CPU_32FPR |
 		             MIPS_CPU_WATCH | MIPS_CPU_VCE |
@@ -476,6 +490,7 @@ static inline void cpu_probe_mips(struct
 static inline void cpu_probe_alchemy(struct cpuinfo_mips *c)
 {
 	decode_config1(c);
+	c->options |= MIPS_CPU_PREFETCH;
 	switch (c->processor_id & 0xff00) {
 	case PRID_IMP_AU1_REV1:
 	case PRID_IMP_AU1_REV2:
@@ -492,6 +507,9 @@ static inline void cpu_probe_alchemy(str
 		case 3:
 			c->cputype = CPU_AU1550;
 			break;
+		case 4:
+			c->cputype = CPU_AU1200;
+			break;
 		default:
 			panic("Unknown Au Core!");
 			break;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/gdb-low.S linux-mips-cvs-20040815/arch/mips/kernel/gdb-low.S
--- linux-2.4.27/arch/mips/kernel/gdb-low.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/kernel/gdb-low.S	2004-08-15 08:05:48.000000000 +0200
@@ -283,7 +283,7 @@
 		lw	v0,GDB_FR_HI(sp)
 		lw	v1,GDB_FR_LO(sp)
 		mthi	v0
-		mtlo	v0
+		mtlo	v1
 		lw	ra,GDB_FR_REG31(sp)
 		lw	fp,GDB_FR_REG30(sp)
 		lw	gp,GDB_FR_REG28(sp)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/irq-rm7000.c linux-mips-cvs-20040815/arch/mips/kernel/irq-rm7000.c
--- linux-2.4.27/arch/mips/kernel/irq-rm7000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/irq-rm7000.c	2004-03-12 17:01:18.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2003 Ralf Baechle
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Handler for RM7000 extended interrupts.  These are a non-standard
+ * feature so we handle them separately from standard interrupts.
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+static int irq_base;
+
+static inline void unmask_rm7k_irq(unsigned int irq)
+{
+	set_c0_intcontrol(0x100 << (irq - irq_base));
+}
+
+static inline void mask_rm7k_irq(unsigned int irq)
+{
+	clear_c0_intcontrol(0x100 << (irq - irq_base));
+}
+
+static inline void rm7k_cpu_irq_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	unmask_rm7k_irq(irq);
+	local_irq_restore(flags);
+}
+
+static void rm7k_cpu_irq_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	mask_rm7k_irq(irq);
+	local_irq_restore(flags);
+}
+
+static unsigned int rm7k_cpu_irq_startup(unsigned int irq)
+{
+	rm7k_cpu_irq_enable(irq);
+
+	return 0;
+}
+
+#define	rm7k_cpu_irq_shutdown	rm7k_cpu_irq_disable
+
+/*
+ * While we ack the interrupt interrupts are disabled and thus we don't need
+ * to deal with concurrency issues.  Same for rm7k_cpu_irq_end.
+ */
+static void rm7k_cpu_irq_ack(unsigned int irq)
+{
+	mask_rm7k_irq(irq);
+}
+
+static void rm7k_cpu_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		unmask_rm7k_irq(irq);
+}
+
+static hw_irq_controller rm7k_irq_controller = {
+	"RM7000",
+	rm7k_cpu_irq_startup,
+	rm7k_cpu_irq_shutdown,
+	rm7k_cpu_irq_enable,
+	rm7k_cpu_irq_disable,
+	rm7k_cpu_irq_ack,
+	rm7k_cpu_irq_end,
+};
+
+void __init rm7k_cpu_irq_init(int base)
+{
+	int i;
+
+	clear_c0_intcontrol(0x00000f00);		/* Mask all */
+
+	for (i = base; i < base + 4; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &rm7k_irq_controller;
+	}
+
+	irq_base = base;
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/irq_cpu.c linux-mips-cvs-20040815/arch/mips/kernel/irq_cpu.c
--- linux-2.4.27/arch/mips/kernel/irq_cpu.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/kernel/irq_cpu.c	2004-02-11 16:08:46.000000000 +0100
@@ -2,6 +2,8 @@
  * Copyright 2001 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
  *
+ * Copyright (C) 2001 Ralf Baechle
+ *
  * This file define the irq handler for MIPS CPU interrupts.
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -13,9 +15,12 @@
 /*
  * Almost all MIPS CPUs define 8 interrupt sources.  They are typically
  * level triggered (i.e., cannot be cleared from CPU; must be cleared from
- * device).  The first two are software interrupts.  The last one is
- * usually the CPU timer interrupt if counter register is present or, for
- * CPUs with an external FPU, by convention it's the FPU exception interrupt.
+ * device).  The first two are software interrupts which we don't really
+ * use or support.  The last one is usually the CPU timer interrupt if
+ * counter register is present or, for CPUs with an external FPU, by
+ * convention it's the FPU exception interrupt.
+ *
+ * Don't even think about using this on SMP.  You have been warned.
  *
  * This file exports one global function:
  *	void mips_cpu_irq_init(int irq_base);
@@ -26,18 +31,37 @@
 
 #include <asm/irq_cpu.h>
 #include <asm/mipsregs.h>
+#include <asm/system.h>
+
+static int mips_cpu_irq_base;
+
+static inline void unmask_mips_irq(unsigned int irq)
+{
+	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
+	set_c0_status(0x100 << (irq - mips_cpu_irq_base));
+}
 
-static int mips_cpu_irq_base = -1;
+static inline void mask_mips_irq(unsigned int irq)
+{
+	clear_c0_status(0x100 << (irq - mips_cpu_irq_base));
+}
 
-static void mips_cpu_irq_enable(unsigned int irq)
+static inline void mips_cpu_irq_enable(unsigned int irq)
 {
-	clear_c0_cause( 1 << (irq - mips_cpu_irq_base + 8));
-	set_c0_status(1 << (irq - mips_cpu_irq_base + 8));
+	unsigned long flags;
+
+	local_irq_save(flags);
+	unmask_mips_irq(irq);
+	local_irq_restore(flags);
 }
 
 static void mips_cpu_irq_disable(unsigned int irq)
 {
-	clear_c0_status(1 << (irq - mips_cpu_irq_base + 8));
+	unsigned long flags;
+
+	local_irq_save(flags);
+	mask_mips_irq(irq);
+	local_irq_restore(flags);
 }
 
 static unsigned int mips_cpu_irq_startup(unsigned int irq)
@@ -49,21 +73,22 @@ static unsigned int mips_cpu_irq_startup
 
 #define	mips_cpu_irq_shutdown	mips_cpu_irq_disable
 
+/*
+ * While we ack the interrupt interrupts are disabled and thus we don't need
+ * to deal with concurrency issues.  Same for mips_cpu_irq_end.
+ */
 static void mips_cpu_irq_ack(unsigned int irq)
 {
-	/* although we attempt to clear the IP bit in cause register, I think
-	 * usually it is cleared by device (irq source)
-	 */
-	clear_c0_cause(1 << (irq - mips_cpu_irq_base + 8));
+	/* Only necessary for soft interrupts */
+	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
 
-	/* disable this interrupt - so that we safe proceed to the handler */
-	mips_cpu_irq_disable(irq);
+	mask_mips_irq(irq);
 }
 
 static void mips_cpu_irq_end(unsigned int irq)
 {
 	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
-		mips_cpu_irq_enable(irq);
+		unmask_mips_irq(irq);
 }
 
 static hw_irq_controller mips_cpu_irq_controller = {
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/old-time.c linux-mips-cvs-20040815/arch/mips/kernel/old-time.c
--- linux-2.4.27/arch/mips/kernel/old-time.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/kernel/old-time.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,521 +0,0 @@
-/*
- * Copyright (C) 1991, 1992, 1995  Linus Torvalds
- * Copyright (C) 1996 - 2000  Ralf Baechle
- * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
- *
- * Don't use.  Deprecated.  Dead meat.
- */
-#include <linux/config.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <linux/interrupt.h>
-#include <linux/kernel_stat.h>
-
-#include <asm/bootinfo.h>
-#include <asm/cpu.h>
-#include <asm/mipsregs.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-
-#include <linux/mc146818rtc.h>
-#include <linux/timex.h>
-
-extern volatile unsigned long wall_jiffies;
-unsigned long r4k_interval;
-extern rwlock_t xtime_lock;
-
-/*
- * Change this if you have some constant time drift
- */
-/* This is the value for the PC-style PICs. */
-/* #define USECS_PER_JIFFY (1000020/HZ) */
-
-/* This is for machines which generate the exact clock. */
-#define USECS_PER_JIFFY (1000000/HZ)
-
-/* Cycle counter value at the previous timer interrupt.. */
-
-static unsigned int timerhi, timerlo;
-
-/*
- * On MIPS only R4000 and better have a cycle counter.
- *
- * FIXME: Does playing with the RP bit in c0_status interfere with this code?
- */
-static unsigned long do_fast_gettimeoffset(void)
-{
-	u32 count;
-	unsigned long res, tmp;
-
-	/* Last jiffy when do_fast_gettimeoffset() was called. */
-	static unsigned long last_jiffies;
-	unsigned long quotient;
-
-	/*
-	 * Cached "1/(clocks per usec)*2^32" value.
-	 * It has to be recalculated once each jiffy.
-	 */
-	static unsigned long cached_quotient;
-
-	tmp = jiffies;
-
-	quotient = cached_quotient;
-
-	if (tmp && last_jiffies != tmp) {
-		last_jiffies = tmp;
-		__asm__(".set\tnoreorder\n\t"
-			".set\tnoat\n\t"
-			".set\tmips3\n\t"
-			"lwu\t%0,%2\n\t"
-			"dsll32\t$1,%1,0\n\t"
-			"or\t$1,$1,%0\n\t"
-			"ddivu\t$0,$1,%3\n\t"
-			"mflo\t$1\n\t"
-			"dsll32\t%0,%4,0\n\t"
-			"nop\n\t"
-			"ddivu\t$0,%0,$1\n\t"
-			"mflo\t%0\n\t"
-			".set\tmips0\n\t"
-			".set\tat\n\t"
-			".set\treorder"
-			:"=&r" (quotient)
-			:"r" (timerhi),
-			 "m" (timerlo),
-			 "r" (tmp),
-			 "r" (USECS_PER_JIFFY));
-		cached_quotient = quotient;
-	}
-
-	/* Get last timer tick in absolute kernel time */
-	count = read_c0_count();
-
-	/* .. relative to previous jiffy (32 bits is enough) */
-	count -= timerlo;
-
-	__asm__("multu\t%1,%2\n\t"
-		"mfhi\t%0"
-		:"=r" (res)
-		:"r" (count),
-		 "r" (quotient));
-
-	/*
- 	 * Due to possible jiffies inconsistencies, we need to check
-	 * the result so that we'll get a timer that is monotonic.
-	 */
-	if (res >= USECS_PER_JIFFY)
-		res = USECS_PER_JIFFY-1;
-
-	return res;
-}
-
-/* This function must be called with interrupts disabled
- * It was inspired by Steve McCanne's microtime-i386 for BSD.  -- jrs
- *
- * However, the pc-audio speaker driver changes the divisor so that
- * it gets interrupted rather more often - it loads 64 into the
- * counter rather than 11932! This has an adverse impact on
- * do_gettimeoffset() -- it stops working! What is also not
- * good is that the interval that our timer function gets called
- * is no longer 10.0002 ms, but 9.9767 ms. To get around this
- * would require using a different timing source. Maybe someone
- * could use the RTC - I know that this can interrupt at frequencies
- * ranging from 8192Hz to 2Hz. If I had the energy, I'd somehow fix
- * it so that at startup, the timer code in sched.c would select
- * using either the RTC or the 8253 timer. The decision would be
- * based on whether there was any other device around that needed
- * to trample on the 8253. I'd set up the RTC to interrupt at 1024 Hz,
- * and then do some jiggery to have a version of do_timer that
- * advanced the clock by 1/1024 s. Every time that reached over 1/100
- * of a second, then do all the old code. If the time was kept correct
- * then do_gettimeoffset could just return 0 - there is no low order
- * divider that can be accessed.
- *
- * Ideally, you would be able to use the RTC for the speaker driver,
- * but it appears that the speaker driver really needs interrupt more
- * often than every 120 us or so.
- *
- * Anyway, this needs more thought....		pjsg (1993-08-28)
- *
- * If you are really that interested, you should be reading
- * comp.protocols.time.ntp!
- */
-
-#define TICK_SIZE tick
-
-static unsigned long do_slow_gettimeoffset(void)
-{
-	int count;
-
-	static int count_p = LATCH;    /* for the first call after boot */
-	static unsigned long jiffies_p;
-
-	/*
-	 * cache volatile jiffies temporarily; we have IRQs turned off.
-	 */
-	unsigned long jiffies_t;
-
-	/* timer count may underflow right here */
-	outb_p(0x00, 0x43);	/* latch the count ASAP */
-
-	count = inb_p(0x40);	/* read the latched count */
-
-	/*
-	 * We do this guaranteed double memory access instead of a _p
-	 * postfix in the previous port access. Wheee, hackady hack
-	 */
-	jiffies_t = jiffies;
-
-	count |= inb_p(0x40) << 8;
-
-	/*
-	 * avoiding timer inconsistencies (they are rare, but they happen)...
-	 * there are two kinds of problems that must be avoided here:
-	 *  1. the timer counter underflows
-	 *  2. hardware problem with the timer, not giving us continuous time,
-	 *     the counter does small "jumps" upwards on some Pentium systems,
-	 *     (see c't 95/10 page 335 for Neptun bug.)
-	 */
-
-	if( jiffies_t == jiffies_p ) {
-		if( count > count_p ) {
-			/* the nutcase */
-
-			outb_p(0x0A, 0x20);
-
-			/* assumption about timer being IRQ1 */
-			if (inb(0x20) & 0x01) {
-				/*
-				 * We cannot detect lost timer interrupts ...
-				 * well, that's why we call them lost, don't we? :)
-				 * [hmm, on the Pentium and Alpha we can ... sort of]
-				 */
-				count -= LATCH;
-			} else {
-				printk("do_slow_gettimeoffset(): hardware timer problem?\n");
-			}
-		}
-	} else
-		jiffies_p = jiffies_t;
-
-	count_p = count;
-
-	count = ((LATCH-1) - count) * TICK_SIZE;
-	count = (count + LATCH/2) / LATCH;
-
-	return count;
-}
-
-static unsigned long (*do_gettimeoffset)(void) = do_slow_gettimeoffset;
-
-/*
- * This version of gettimeofday has near microsecond resolution.
- */
-void do_gettimeofday(struct timeval *tv)
-{
-	unsigned long flags;
-
-	read_lock_irqsave (&xtime_lock, flags);
-	*tv = xtime;
-	tv->tv_usec += do_gettimeoffset();
-
-	/*
-	 * xtime is atomically updated in timer_bh. jiffies - wall_jiffies
-	 * is nonzero if the timer bottom half hasnt executed yet.
-	 */
-	if (jiffies - wall_jiffies)
-		tv->tv_usec += USECS_PER_JIFFY;
-
-	read_unlock_irqrestore (&xtime_lock, flags);
-
-	if (tv->tv_usec >= 1000000) {
-		tv->tv_usec -= 1000000;
-		tv->tv_sec++;
-	}
-}
-
-void do_settimeofday(struct timeval *tv)
-{
-	write_lock_irq (&xtime_lock);
-
-	/* This is revolting. We need to set the xtime.tv_usec
-	 * correctly. However, the value in this location is
-	 * is value at the last tick.
-	 * Discover what correction gettimeofday
-	 * would have done, and then undo it!
-	 */
-	tv->tv_usec -= do_gettimeoffset();
-
-	if (tv->tv_usec < 0) {
-		tv->tv_usec += 1000000;
-		tv->tv_sec--;
-	}
-
-	xtime = *tv;
-	time_adjust = 0;		/* stop active adjtime() */
-	time_status |= STA_UNSYNC;
-	time_maxerror = NTP_PHASE_LIMIT;
-	time_esterror = NTP_PHASE_LIMIT;
-
-	write_unlock_irq (&xtime_lock);
-}
-
-/*
- * In order to set the CMOS clock precisely, set_rtc_mmss has to be
- * called 500 ms after the second nowtime has started, because when
- * nowtime is written into the registers of the CMOS clock, it will
- * jump to the next second precisely 500 ms later. Check the Motorola
- * MC146818A or Dallas DS12887 data sheet for details.
- *
- * BUG: This routine does not handle hour overflow properly; it just
- *      sets the minutes. Usually you won't notice until after reboot!
- */
-static int set_rtc_mmss(unsigned long nowtime)
-{
-	int retval = 0;
-	int real_seconds, real_minutes, cmos_minutes;
-	unsigned char save_control, save_freq_select;
-
-	save_control = CMOS_READ(RTC_CONTROL); /* tell the clock it's being set */
-	CMOS_WRITE((save_control|RTC_SET), RTC_CONTROL);
-
-	save_freq_select = CMOS_READ(RTC_FREQ_SELECT); /* stop and reset prescaler */
-	CMOS_WRITE((save_freq_select|RTC_DIV_RESET2), RTC_FREQ_SELECT);
-
-	cmos_minutes = CMOS_READ(RTC_MINUTES);
-	if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
-		BCD_TO_BIN(cmos_minutes);
-
-	/*
-	 * since we're only adjusting minutes and seconds,
-	 * don't interfere with hour overflow. This avoids
-	 * messing with unknown time zones but requires your
-	 * RTC not to be off by more than 15 minutes
-	 */
-	real_seconds = nowtime % 60;
-	real_minutes = nowtime / 60;
-	if (((abs(real_minutes - cmos_minutes) + 15)/30) & 1)
-		real_minutes += 30;		/* correct for half hour time zone */
-	real_minutes %= 60;
-
-	if (abs(real_minutes - cmos_minutes) < 30) {
-		if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-			BIN_TO_BCD(real_seconds);
-			BIN_TO_BCD(real_minutes);
-		}
-		CMOS_WRITE(real_seconds,RTC_SECONDS);
-		CMOS_WRITE(real_minutes,RTC_MINUTES);
-	} else {
-		printk(KERN_WARNING
-		       "set_rtc_mmss: can't update from %d to %d\n",
-		       cmos_minutes, real_minutes);
- 		retval = -1;
-	}
-
-	/* The following flags have to be released exactly in this order,
-	 * otherwise the DS12887 (popular MC146818A clone with integrated
-	 * battery and quartz) will not reset the oscillator and will not
-	 * update precisely 500 ms later. You won't find this mentioned in
-	 * the Dallas Semiconductor data sheets, but who believes data
-	 * sheets anyway ...                           -- Markus Kuhn
-	 */
-	CMOS_WRITE(save_control, RTC_CONTROL);
-	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
-
-	return retval;
-}
-
-/* last time the cmos clock got updated */
-static long last_rtc_update;
-
-/*
- * timer_interrupt() needs to keep up the real-time clock,
- * as well as call the "do_timer()" routine every clocktick
- */
-static void inline
-timer_interrupt(int irq, void *dev_id, struct pt_regs * regs)
-{
-#ifdef CONFIG_DDB5074
-	static unsigned cnt, period, dist;
-
-	if (cnt == 0 || cnt == dist)
-	    ddb5074_led_d2(1);
-	else if (cnt == 7 || cnt == dist+7)
-	    ddb5074_led_d2(0);
-
-	if (++cnt > period) {
-	    cnt = 0;
-	    /* The hyperbolic function below modifies the heartbeat period
-	     * length in dependency of the current (5min) load. It goes
-	     * through the points f(0)=126, f(1)=86, f(5)=51,
-	     * f(inf)->30. */
-	     period = ((672<<FSHIFT)/(5*avenrun[0]+(7<<FSHIFT))) + 30;
-	     dist = period / 4;
-	}
-#endif
-	if(!user_mode(regs)) {
-		if (prof_buffer && current->pid) {
-			extern int _stext;
-			unsigned long pc = regs->cp0_epc;
-
-			pc -= (unsigned long) &_stext;
-			pc >>= prof_shift;
-			/*
-			 * Dont ignore out-of-bounds pc values silently,
-			 * put them into the last histogram slot, so if
-			 * present, they will show up as a sharp peak.
-			 */
-			if (pc > prof_len-1)
-				pc = prof_len-1;
-			atomic_inc((atomic_t *)&prof_buffer[pc]);
-		}
-	}
-	do_timer(regs);
-
-	/*
-	 * If we have an externally synchronized Linux clock, then update
-	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
-	 * called as close as possible to 500 ms before the new second starts.
-	 */
-	read_lock (&xtime_lock);
-	if ((time_status & STA_UNSYNC) == 0 &&
-	    xtime.tv_sec > last_rtc_update + 660 &&
-	    xtime.tv_usec >= 500000 - ((unsigned) tick) / 2 &&
-	    xtime.tv_usec <= 500000 + ((unsigned) tick) / 2) {
-		if (set_rtc_mmss(xtime.tv_sec) == 0)
-			last_rtc_update = xtime.tv_sec;
-		else
-			/* do it again in 60 s */
-			last_rtc_update = xtime.tv_sec - 600;
-	}
-
-	/*
-	 * As we return to user mode fire off the other CPU schedulers.. this
-	 * is basically because we don't yet share IRQ's around. This message
-	 * is rigged to be safe on the 386 - basically it's a hack, so don't
-	 * look closely for now..
-	 */
-	/*smp_message_pass(MSG_ALL_BUT_SELF, MSG_RESCHEDULE, 0L, 0); */
-	read_unlock (&xtime_lock);
-}
-
-static inline void
-r4k_timer_interrupt(int irq, void *dev_id, struct pt_regs * regs)
-{
-	unsigned int count;
-
-	/*
-	 * The cycle counter is only 32 bit which is good for about
-	 * a minute at current count rates of upto 150MHz or so.
-	 */
-	count = read_c0_count();
-	timerhi += (count < timerlo);	/* Wrap around */
-	timerlo = count;
-
-#ifdef CONFIG_SGI_IP22
-	/* Since we don't get anything but r4k timer interrupts, we need to
-	 * set this up so that we'll get one next time. Fortunately since we
-	 * have timerhi/timerlo, we don't care so much if we miss one. So
-	 * we need only ask for the next in r4k_interval counts. On other
-	 * archs we have a real timer, so we don't want this.
-	 */
-	write_c0_compare(
-				  (unsigned long) (count + r4k_interval));
-        kstat.irqs[0][irq]++;
-#endif
-
-	timer_interrupt(irq, dev_id, regs);
-
-	if (!jiffies)
-	{
-		/*
-		 * If jiffies has overflowed in this timer_interrupt we must
-		 * update the timer[hi]/[lo] to make do_fast_gettimeoffset()
-		 * quotient calc still valid. -arca
-		 */
-		timerhi = timerlo = 0;
-	}
-}
-
-void indy_r4k_timer_interrupt (struct pt_regs *regs)
-{
-	int cpu = smp_processor_id();
-	int irq = 7;
-
-	irq_enter(cpu, irq);
-	r4k_timer_interrupt(irq, NULL, regs);
-	irq_exit(cpu, irq);
-
-	if (softirq_pending(cpu))
-		do_softirq();
-}
-
-struct irqaction irq0  = { timer_interrupt, SA_INTERRUPT, 0,
-                                  "timer", NULL, NULL};
-
-
-void (*board_time_init)(struct irqaction *irq);
-
-void __init time_init(void)
-{
-	unsigned int epoch = 0, year, mon, day, hour, min, sec;
-	int i;
-
-	/* The Linux interpretation of the CMOS clock register contents:
-	 * When the Update-In-Progress (UIP) flag goes from 1 to 0, the
-	 * RTC registers show the second which has precisely just started.
-	 * Let's hope other operating systems interpret the RTC the same way.
-	 */
-	/* read RTC exactly on falling edge of update flag */
-	for (i = 0 ; i < 1000000 ; i++)	/* may take up to 1 second... */
-		if (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP)
-			break;
-	for (i = 0 ; i < 1000000 ; i++)	/* must try at least 2.228 ms */
-		if (!(CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP))
-			break;
-	do { /* Isn't this overkill ? UIP above should guarantee consistency */
-		sec = CMOS_READ(RTC_SECONDS);
-		min = CMOS_READ(RTC_MINUTES);
-		hour = CMOS_READ(RTC_HOURS);
-		day = CMOS_READ(RTC_DAY_OF_MONTH);
-		mon = CMOS_READ(RTC_MONTH);
-		year = CMOS_READ(RTC_YEAR);
-	} while (sec != CMOS_READ(RTC_SECONDS));
-	if (!(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
-	  {
-	    BCD_TO_BIN(sec);
-	    BCD_TO_BIN(min);
-	    BCD_TO_BIN(hour);
-	    BCD_TO_BIN(day);
-	    BCD_TO_BIN(mon);
-	    BCD_TO_BIN(year);
-	  }
-
-	/* Attempt to guess the epoch.  This is the same heuristic as in rtc.c so
-	   no stupid things will happen to timekeeping.  Who knows, maybe Ultrix
-  	   also uses 1952 as epoch ...  */
-	if (year > 10 && year < 44) {
-		epoch = 1980;
-	} else if (year < 96) {
-		epoch = 1952;
-	}
-	year += epoch;
-
-	write_lock_irq (&xtime_lock);
-	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
-	xtime.tv_usec = 0;
-	write_unlock_irq (&xtime_lock);
-
-	if (cpu_has_counter) {
-		write_c0_count(0);
-		do_gettimeoffset = do_fast_gettimeoffset;
-		irq0.handler = r4k_timer_interrupt;
-	}
-
-	board_time_init(&irq0);
-}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/proc.c linux-mips-cvs-20040815/arch/mips/kernel/proc.c
--- linux-2.4.27/arch/mips/kernel/proc.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/proc.c	2004-08-15 08:05:48.000000000 +0200
@@ -48,7 +48,6 @@ static const char *cpu_name[] = {
 	[CPU_R4640]	"R4640",
 	[CPU_NEVADA]	"Nevada",
 	[CPU_RM7000]	"RM7000",
-	[CPU_RM9000]	"RM9000",
 	[CPU_R5432]	"R5432",
 	[CPU_4KC]	"MIPS 4Kc",
         [CPU_5KC]	"MIPS 5Kc",
@@ -58,23 +57,27 @@ static const char *cpu_name[] = {
 	[CPU_TX3922]	"TX3922",
 	[CPU_TX3927]	"TX3927",
 	[CPU_AU1000]	"Au1000",
-	[CPU_AU1500]	"Au1500",
 	[CPU_4KEC]	"MIPS 4KEc",
 	[CPU_4KSC]	"MIPS 4KSc",
 	[CPU_VR41XX]	"NEC Vr41xx",
 	[CPU_R5500]	"R5500",
 	[CPU_TX49XX]	"TX49xx",
+	[CPU_AU1500]	"Au1500",
 	[CPU_20KC]	"MIPS 20Kc",
-	[CPU_24K]	"MIPS 24K",
-	[CPU_25KF]	"MIPS 25Kf",
 	[CPU_VR4111]	"NEC VR4111",
 	[CPU_VR4121]	"NEC VR4121",
 	[CPU_VR4122]	"NEC VR4122",
 	[CPU_VR4131]	"NEC VR4131",
-	[CPU_VR4133]	"NEC VR4133",
 	[CPU_VR4181]	"NEC VR4181",
 	[CPU_VR4181A]	"NEC VR4181A",
-	[CPU_SR71000]	"Sandcraft SR71000"
+	[CPU_AU1100]	"Au1100",
+	[CPU_SR71000]	"Sandcraft SR71000",
+	[CPU_RM9000]	"RM9000",
+	[CPU_25KF]	"MIPS 25Kf",
+	[CPU_VR4133]	"NEC VR4133",
+	[CPU_AU1550]	"Au1550",
+	[CPU_24K]	"MIPS 24K",
+	[CPU_AU1200]	"Au1200",
 };
 
 
@@ -116,7 +119,7 @@ static int show_cpuinfo(struct seq_file 
 	              cpu_has_watch ? "yes" : "no");
 
 	sprintf(fmt, "VCE%%c exceptions\t\t: %s\n",
-	        cpu_has_vce ? "%d" : "not available");
+	        cpu_has_vce ? "%u" : "not available");
 	seq_printf(m, fmt, 'D', vced_count);
 	seq_printf(m, fmt, 'I', vcei_count);
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/scall_o32.S linux-mips-cvs-20040815/arch/mips/kernel/scall_o32.S
--- linux-2.4.27/arch/mips/kernel/scall_o32.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/scall_o32.S	2004-05-05 14:38:39.000000000 +0200
@@ -31,8 +31,8 @@ NESTED(handle_sys, PT_SIZE, sp)
 
 	sltiu	t0, v0, MAX_SYSCALL_NO + 1 # check syscall number
 	addiu	t1, 4			# skip to next instruction
-	beqz	t0, illegal_syscall
 	sw	t1, PT_EPC(sp)
+	beqz	t0, illegal_syscall
 
 	/* XXX Put both in one cacheline, should save a bit. */
 	sll	t0, v0, 2
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/setup.c linux-mips-cvs-20040815/arch/mips/kernel/setup.c
--- linux-2.4.27/arch/mips/kernel/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/setup.c	2004-05-05 15:11:20.000000000 +0200
@@ -40,6 +40,7 @@
 #include <asm/system.h>
 
 struct cpuinfo_mips cpu_data[NR_CPUS];
+EXPORT_SYMBOL(cpu_data);
 
 /*
  * There are several bus types available for MIPS machines.  "RISC PC"
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/signal.c linux-mips-cvs-20040815/arch/mips/kernel/signal.c
--- linux-2.4.27/arch/mips/kernel/signal.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/kernel/signal.c	2004-03-03 04:42:00.000000000 +0100
@@ -382,7 +382,7 @@ static inline void * get_sigframe(struct
  	sp -= 32;
 
 	/* This is the X/Open sanctioned signal stack switching.  */
-	if ((ka->sa.sa_flags & SA_ONSTACK) && ! on_sig_stack(sp))
+	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
                 sp = current->sas_ss_sp + current->sas_ss_size;
 
 	return (void *)((sp - frame_size) & ALMASK);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/smp.c linux-mips-cvs-20040815/arch/mips/kernel/smp.c
--- linux-2.4.27/arch/mips/kernel/smp.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/smp.c	2004-05-02 00:47:29.000000000 +0200
@@ -52,6 +52,9 @@ int __cpu_number_map[NR_CPUS];
 int __cpu_logical_map[NR_CPUS];
 cycles_t cacheflush_time;
 
+EXPORT_SYMBOL(__cpu_number_map);
+EXPORT_SYMBOL(__cpu_logical_map);
+
 void __init smp_callin(void)
 {
 #if 0
@@ -110,6 +113,7 @@ int smp_call_function (void (*func) (voi
 
 	spin_lock(&smp_call_lock);
 	call_data = &data;
+	wmb();
 
 	/* Send a message to all other CPUs and wait for them to respond */
 	for (i = 0; i < smp_num_cpus; i++)
@@ -283,7 +287,6 @@ void flush_tlb_page(struct vm_area_struc
 
 EXPORT_SYMBOL(smp_num_cpus);
 EXPORT_SYMBOL(flush_tlb_page);
-EXPORT_SYMBOL(cpu_data);
 EXPORT_SYMBOL(synchronize_irq);
 EXPORT_SYMBOL(kernel_flag);
 EXPORT_SYMBOL(__global_sti);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/syscall.c linux-mips-cvs-20040815/arch/mips/kernel/syscall.c
--- linux-2.4.27/arch/mips/kernel/syscall.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/kernel/syscall.c	2004-08-15 08:05:48.000000000 +0200
@@ -39,7 +39,7 @@ extern asmlinkage int (*do_syscalls)(str
 extern syscall_t sys_call_table[];
 extern unsigned char sys_narg_table[];
 
-asmlinkage int sys_pipe(struct pt_regs regs)
+asmlinkage int sys_pipe(volatile struct pt_regs regs)
 {
 	int fd[2];
 	int error, res;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/sysirix.c linux-mips-cvs-20040815/arch/mips/kernel/sysirix.c
--- linux-2.4.27/arch/mips/kernel/sysirix.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/kernel/sysirix.c	2004-08-15 08:05:48.000000000 +0200
@@ -928,8 +928,8 @@ asmlinkage int irix_getdomainname(char *
 		return error;
 
 	down_read(&uts_sem);
-	if(len > (__NEW_UTS_LEN - 1))
-		len = __NEW_UTS_LEN - 1;
+	if (len > __NEW_UTS_LEN)
+		len = __NEW_UTS_LEN;
 	error = 0;
 	if (copy_to_user(name, system_utsname.domainname, len))
 		error = -EFAULT;
@@ -1712,7 +1712,7 @@ asmlinkage int irix_statvfs64(char *fnam
 
 	printk("[%s:%d] Wheee.. irix_statvfs(%s,%p)\n",
 	       current->comm, current->pid, fname, buf);
-	error = verify_area(VERIFY_WRITE, buf, sizeof(struct irix_statvfs));
+	error = verify_area(VERIFY_WRITE, buf, sizeof(struct irix_statvfs64));
 	if(error)
 		goto out;
 	error = user_path_walk(fname, &nd);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/kernel/traps.c linux-mips-cvs-20040815/arch/mips/kernel/traps.c
--- linux-2.4.27/arch/mips/kernel/traps.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/kernel/traps.c	2004-08-15 08:05:48.000000000 +0200
@@ -9,7 +9,7 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2000, 01 MIPS Technologies, Inc.
- * Copyright (C) 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2002, 2003, 2004  Maciej W. Rozycki
  */
 #include <linux/config.h>
 #include <linux/init.h>
@@ -22,6 +22,7 @@
 
 #include <asm/bootinfo.h>
 #include <asm/branch.h>
+#include <asm/break.h>
 #include <asm/cpu.h>
 #include <asm/fpu.h>
 #include <asm/cachectl.h>
@@ -352,7 +353,7 @@ asmlinkage void do_be(struct pt_regs *re
 	int action = MIPS_BE_FATAL;
 
 	if (data && !user_mode(regs))
-		fixup = search_dbe_table(regs->cp0_epc);
+		fixup = search_dbe_table(exception_epc(regs));
 
 	if (fixup)
 		action = MIPS_BE_FIXUP;
@@ -596,9 +597,12 @@ asmlinkage void do_bp(struct pt_regs *re
 	/*
 	 * There is the ancient bug in the MIPS assemblers that the break
 	 * code starts left to bit 16 instead to bit 6 in the opcode.
-	 * Gas is bug-compatible ...
+	 * Gas is bug-compatible, but not always, grrr...
+	 * We handle both cases with a simple heuristics.  --macro
 	 */
-	bcode = ((opcode >> 16) & ((1 << 20) - 1));
+	bcode = ((opcode >> 6) & ((1 << 20) - 1));
+	if (bcode < (1 << 10))
+		bcode <<= 10;
 
 	/*
 	 * (A short test says that IRIX 5.3 sends SIGTRAP for all break
@@ -607,9 +611,9 @@ asmlinkage void do_bp(struct pt_regs *re
 	 * But should we continue the brokenness???  --macro
 	 */
 	switch (bcode) {
-	case 6:
-	case 7:
-		if (bcode == 7)
+	case BRK_OVERFLOW << 10:
+	case BRK_DIVZERO << 10:
+		if (bcode == (BRK_DIVZERO << 10))
 			info.si_code = FPE_INTDIV;
 		else
 			info.si_code = FPE_INTOVF;
@@ -633,7 +637,7 @@ asmlinkage void do_tr(struct pt_regs *re
 
 	/* Immediate versions don't provide a code.  */
 	if (!(opcode & OPCODE))
-		tcode = ((opcode >> 6) & ((1 << 20) - 1));
+		tcode = ((opcode >> 6) & ((1 << 10) - 1));
 
 	/*
 	 * (A short test says that IRIX 5.3 sends SIGTRAP for all trap
@@ -642,9 +646,9 @@ asmlinkage void do_tr(struct pt_regs *re
 	 * But should we continue the brokenness???  --macro
 	 */
 	switch (tcode) {
-	case 6:
-	case 7:
-		if (tcode == 7)
+	case BRK_OVERFLOW:
+	case BRK_DIVZERO:
+		if (tcode == BRK_DIVZERO)
 			info.si_code = FPE_INTDIV;
 		else
 			info.si_code = FPE_INTOVF;
@@ -933,8 +937,7 @@ void __init trap_init(void)
 		memcpy((void *)(KSEG0 + 0x300), &except_vec_ejtag_debug, 0x80);
 
 	/*
-	 * Only some CPUs have the watch exceptions or a dedicated
-	 * interrupt vector.
+	 * Only some CPUs have the watch exceptions.
 	 */
 	if (cpu_has_watch)
 		set_except_vector(23, handle_watch);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/lasat/ds1603.c linux-mips-cvs-20040815/arch/mips/lasat/ds1603.c
--- linux-2.4.27/arch/mips/lasat/ds1603.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/lasat/ds1603.c	2004-05-05 14:38:39.000000000 +0200
@@ -51,14 +51,14 @@ static void rtc_cycle_clock(unsigned lon
 {
 	data |= ds1603->clk;
 	rtc_reg_write(data);
-	ndelay(250);
+	lasat_ndelay(250);
 	if (ds1603->data_reversed)
 		data &= ~ds1603->data;
 	else
 		data |= ds1603->data;
 	data &= ~ds1603->clk;
 	rtc_reg_write(data);
-	ndelay(250 + ds1603->huge_delay);
+	lasat_ndelay(250 + ds1603->huge_delay);
 }
 
 static void rtc_write_databit(unsigned int bit)
@@ -72,7 +72,7 @@ static void rtc_write_databit(unsigned i
 		data &= ~ds1603->data;
 
 	rtc_reg_write(data);
-	ndelay(50 + ds1603->huge_delay);
+	lasat_ndelay(50 + ds1603->huge_delay);
 	rtc_cycle_clock(data);
 }
 
@@ -125,13 +125,13 @@ static void rtc_init_op(void)
 
 	rtc_reg_write(rtc_reg_read() & ~ds1603->clk);
 
-	ndelay(50);
+	lasat_ndelay(50);
 }
 
 static void rtc_end_op(void)
 {
 	rtc_nrst_low();
-	ndelay(1000);
+	lasat_ndelay(1000);
 }
 
 /* interface */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/lasat/image/Makefile linux-mips-cvs-20040815/arch/mips/lasat/image/Makefile
--- linux-2.4.27/arch/mips/lasat/image/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/lasat/image/Makefile	2004-05-02 00:47:30.000000000 +0200
@@ -24,12 +24,13 @@ KERNEL_ENTRY = $(shell $(NM) $(KERNEL_IM
 
 LDSCRIPT= -Tromscript.normal
 
-AFLAGS_head.o = -D_kernel_start=0x$(KERNEL_START) \
+HEAD_DEFINES = -D_kernel_start=0x$(KERNEL_START) \
 		-D_kernel_entry=0x$(KERNEL_ENTRY) \
 		-D VERSION="\"$(Version)\"" \
 		-D TIMESTAMP=$(shell date +%s) 
 
-head.o: $(KERNEL_IMAGE)
+head.o: head.S $(KERNEL_IMAGE)
+	$(CC) -fno-pic $(HEAD_DEFINES) -I$(TOPDIR)/include -c -o $@ $<
 
 OBJECTS= head.o kImage.o
 
@@ -44,7 +45,7 @@ rom:	$(OBJECTS)
 	$(LD) $(LDFLAGS) $(LDSCRIPT) -o rom $(OBJECTS) 
 
 %.o: %.gz
-	$(LD) -r -o $@ -b binary $<
+	$(LD) $(LDFLAGS) -r -o $@ -b binary $<
 
 %.gz: %.bin
 	gzip -cf -9 $< > $@
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/ld.script.in linux-mips-cvs-20040815/arch/mips/ld.script.in
--- linux-2.4.27/arch/mips/ld.script.in	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/ld.script.in	2004-05-05 15:11:20.000000000 +0200
@@ -10,6 +10,7 @@ SECTIONS
     _ftext = . ;
     *(.text)
     *(.rodata)
+    *(.rodata.*)
     *(.rodata1)
     /* .gnu.warning sections are handled specially by elf32.em.  */
     *(.gnu.warning)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/lib/dump_tlb.c linux-mips-cvs-20040815/arch/mips/lib/dump_tlb.c
--- linux-2.4.27/arch/mips/lib/dump_tlb.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/lib/dump_tlb.c	2004-05-05 15:11:20.000000000 +0200
@@ -11,13 +11,13 @@
 #include <linux/string.h>
 
 #include <asm/bootinfo.h>
-#include <asm/cpu.h>
 #include <asm/cachectl.h>
+#include <asm/cpu.h>
 #include <asm/mipsregs.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
 
-static inline const char *msg2str(unsigned int mask)
+static inline const char *msk2str(unsigned int mask)
 {
 	switch (mask) {
 	case PM_4K:	return "4kb";
@@ -36,15 +36,15 @@ static inline const char *msg2str(unsign
 
 void dump_tlb(int first, int last)
 {
-	int	i;
 	unsigned int pagemask, c0, c1, asid;
 	unsigned long long entrylo0, entrylo1;
 	unsigned long entryhi;
+	int	i;
 
 	asid = read_c0_entryhi() & 0xff;
 
 	printk("\n");
-	for(i=first;i<=last;i++) {
+	for (i = first; i <= last; i++) {
 		write_c0_index(i);
 		__asm__ __volatile__(
 			".set\tmips3\n\t"
@@ -65,7 +65,7 @@ void dump_tlb(int first, int last)
 			/*
 			 * Only print entries in use
 			 */
-			printk("Index: %2d pgmask=%s ", i, msg2str(pagemask));
+			printk("Index: %2d pgmask=%s ", i, msk2str(pagemask));
 
 			c0 = (entrylo0 >> 3) & 7;
 			c1 = (entrylo1 >> 3) & 7;
@@ -109,8 +109,7 @@ void dump_tlb_wired(void)
 		"nop;nop;nop;nop;nop;nop;nop\n\t"	\
 		".set\treorder");
 
-void
-dump_tlb_addr(unsigned long addr)
+void dump_tlb_addr(unsigned long addr)
 {
 	unsigned long flags, oldpid;
 	int index;
@@ -135,14 +134,12 @@ dump_tlb_addr(unsigned long addr)
 	dump_tlb(index, index);
 }
 
-void
-dump_tlb_nonwired(void)
+void dump_tlb_nonwired(void)
 {
 	dump_tlb(read_c0_wired(), current_cpu_data.tlbsize - 1);
 }
 
-void
-dump_list_process(struct task_struct *t, void *address)
+void dump_list_process(struct task_struct *t, void *address)
 {
 	pgd_t	*page_dir, *pgd;
 	pmd_t	*pmd;
@@ -194,14 +191,12 @@ dump_list_process(struct task_struct *t,
 	printk("\n");
 }
 
-void
-dump_list_current(void *address)
+void dump_list_current(void *address)
 {
 	dump_list_process(current, address);
 }
 
-unsigned int
-vtop(void *address)
+unsigned int vtop(void *address)
 {
 	pgd_t	*pgd;
 	pmd_t	*pmd;
@@ -218,14 +213,14 @@ vtop(void *address)
 	return paddr;
 }
 
-void
-dump16(unsigned long *p)
+void dump16(unsigned long *p)
 {
 	int i;
 
-	for(i=0;i<8;i++)
-	{
-		printk("*%8p = %08lx, ", p, *p); p++;
-		printk("*%8p = %08lx\n", p, *p); p++;
+	for (i = 0; i < 8; i++) {
+		printk("*%08lx == %08lx, ", (unsigned long)p, *p);
+		p++;
+		printk("*%08lx == %08lx\n", (unsigned long)p, *p);
+		p++;
 	}
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/lib/r3k_dump_tlb.c linux-mips-cvs-20040815/arch/mips/lib/r3k_dump_tlb.c
--- linux-2.4.27/arch/mips/lib/r3k_dump_tlb.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/lib/r3k_dump_tlb.c	2004-02-11 16:05:10.000000000 +0100
@@ -19,8 +19,7 @@
 
 extern int r3k_have_wired_reg;	/* defined in tlb-r3k.c */
 
-void
-dump_tlb(int first, int last)
+void dump_tlb(int first, int last)
 {
 	int	i;
 	unsigned int asid;
@@ -28,8 +27,7 @@ dump_tlb(int first, int last)
 
 	asid = read_c0_entryhi() & 0xfc0;
 
-	for(i=first;i<=last;i++)
-	{
+	for (i = first; i <= last; i++) {
 		write_c0_index(i<<8);
 		__asm__ __volatile__(
 			".set\tnoreorder\n\t"
@@ -63,14 +61,12 @@ dump_tlb(int first, int last)
 	write_c0_entryhi(asid);
 }
 
-void
-dump_tlb_all(void)
+void dump_tlb_all(void)
 {
 	dump_tlb(0, current_cpu_data.tlbsize - 1);
 }
 
-void
-dump_tlb_wired(void)
+void dump_tlb_wired(void)
 {
 	int wired = r3k_have_wired_reg ? read_c0_wired() : 8;
 
@@ -78,8 +74,7 @@ dump_tlb_wired(void)
 	dump_tlb(0, wired - 1);
 }
 
-void
-dump_tlb_addr(unsigned long addr)
+void dump_tlb_addr(unsigned long addr)
 {
 	unsigned long flags, oldpid;
 	int index;
@@ -101,15 +96,13 @@ dump_tlb_addr(unsigned long addr)
 	dump_tlb(index, index);
 }
 
-void
-dump_tlb_nonwired(void)
+void dump_tlb_nonwired(void)
 {
 	int wired = r3k_have_wired_reg ? read_c0_wired() : 8;
 	dump_tlb(wired, current_cpu_data.tlbsize - 1);
 }
 
-void
-dump_list_process(struct task_struct *t, void *address)
+void dump_list_process(struct task_struct *t, void *address)
 {
 	pgd_t	*page_dir, *pgd;
 	pmd_t	*pmd;
@@ -148,14 +141,12 @@ dump_list_process(struct task_struct *t,
 	printk("\n");
 }
 
-void
-dump_list_current(void *address)
+void dump_list_current(void *address)
 {
 	dump_list_process(current, address);
 }
 
-unsigned int
-vtop(void *address)
+unsigned int vtop(void *address)
 {
 	pgd_t	*pgd;
 	pmd_t	*pmd;
@@ -172,16 +163,14 @@ vtop(void *address)
 	return paddr;
 }
 
-void
-dump16(unsigned long *p)
+void dump16(unsigned long *p)
 {
 	int i;
 
-	for(i=0;i<8;i++)
-	{
-		printk("*%08lx == %08lx, ",
-		       (unsigned long)p, (unsigned long)*p++);
-		printk("*%08lx == %08lx\n",
-		       (unsigned long)p, (unsigned long)*p++);
+	for (i = 0; i < 8; i++) {
+		printk("*%08lx == %08lx, ", (unsigned long)p, *p);
+		p++;
+		printk("*%08lx == %08lx\n", (unsigned long)p, *p);
+		p++;
 	}
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/math-emu/cp1emu.c linux-mips-cvs-20040815/arch/mips/math-emu/cp1emu.c
--- linux-2.4.27/arch/mips/math-emu/cp1emu.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/math-emu/cp1emu.c	2004-08-15 08:05:48.000000000 +0200
@@ -529,9 +529,9 @@ static int cop1Emulate(struct pt_regs *x
 		if (MIPSInst_FUNC(ir) != movc_op)
 			return SIGILL;
 		cond = fpucondbit[MIPSInst_RT(ir) >> 2];
-		if (((ctx->sr & cond) != 0) != ((MIPSInst_RT(ir) & 1) != 0))
-			return 0;
-		xcp->regs[MIPSInst_RD(ir)] = xcp->regs[MIPSInst_RS(ir)];
+		if (((ctx->sr & cond) != 0) == ((MIPSInst_RT(ir) & 1) != 0))
+			xcp->regs[MIPSInst_RD(ir)] =
+				xcp->regs[MIPSInst_RS(ir)];
 		break;
 #endif
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/Makefile linux-mips-cvs-20040815/arch/mips/mm/Makefile
--- linux-2.4.27/arch/mips/mm/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/Makefile	2004-08-15 08:05:49.000000000 +0200
@@ -10,7 +10,8 @@ USE_STANDARD_AS_RULE := true
 
 O_TARGET := mm.o
 
-export-objs			+= cache.o ioremap.o loadmmu.o remap.o
+export-objs			:= cache.o ioremap.o loadmmu.o remap.o \
+				   tlb-r4k.o tlb-sb1.o
 obj-y				+= cache.o extable.o init.o ioremap.o fault.o \
 				   loadmmu.o
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/c-r3k.c linux-mips-cvs-20040815/arch/mips/mm/c-r3k.c
--- linux-2.4.27/arch/mips/mm/c-r3k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/c-r3k.c	2004-03-17 01:47:37.000000000 +0100
@@ -311,6 +311,9 @@ static void r3k_flush_cache_sigtramp(uns
 
 static void r3k_dma_cache_wback_inv(unsigned long start, unsigned long size)
 {
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	iob();
 	r3k_flush_dcache_range(start, start + size);
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/c-r4k.c linux-mips-cvs-20040815/arch/mips/mm/c-r4k.c
--- linux-2.4.27/arch/mips/mm/c-r4k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/c-r4k.c	2004-08-15 08:05:49.000000000 +0200
@@ -42,12 +42,13 @@ static struct bcache_ops no_sc_ops = {
 
 struct bcache_ops *bcops = &no_sc_ops;
 
+#define cpu_is_r4600_v1_x()	((read_c0_prid() & 0xfffffff0) == 0x2010)
+#define cpu_is_r4600_v2_x()	((read_c0_prid() & 0xfffffff0) == 0x2020)
+
 #define R4600_HIT_CACHEOP_WAR_IMPL					\
 do {									\
-	if (R4600_V2_HIT_CACHEOP_WAR &&					\
-	    (read_c0_prid() & 0xfff0) == 0x2020) {	/* R4600 V2.0 */\
+	if (R4600_V2_HIT_CACHEOP_WAR && cpu_is_r4600_v2_x())		\
 		*(volatile unsigned long *)KSEG1;			\
-	}								\
 	if (R4600_V1_HIT_CACHEOP_WAR)					\
 		__asm__ __volatile__("nop;nop;nop;nop");		\
 } while (0)
@@ -104,6 +105,15 @@ static inline void r4k_blast_dcache_setu
 #define CACHE32_UNROLL32_ALIGN	JUMP_TO_ALIGN(10) /* 32 * 32 = 1024 */
 #define CACHE32_UNROLL32_ALIGN2	JUMP_TO_ALIGN(11)
 
+static inline void blast_r4600_v1_icache32(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	blast_icache32();
+	local_irq_restore(flags);
+}
+
 static inline void tx49_blast_icache32(void)
 {
 	unsigned long start = KSEG0;
@@ -125,6 +135,15 @@ static inline void tx49_blast_icache32(v
 			cache32_unroll32(addr|ws,Index_Invalidate_I);
 }
 
+static inline void blast_icache32_r4600_v1_page_indexed(unsigned long page)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	blast_icache32_page_indexed(page);
+	local_irq_restore(flags);
+}
+
 static inline void tx49_blast_icache32_page_indexed(unsigned long page)
 {
 	unsigned long start = page;
@@ -168,11 +187,17 @@ static inline void r4k_blast_icache_page
 
 	if (ic_lsize == 16)
 		r4k_blast_icache_page_indexed = blast_icache16_page_indexed;
-	else if (ic_lsize == 32 && TX49XX_ICACHE_INDEX_INV_WAR)
-		r4k_blast_icache_page_indexed = tx49_blast_icache32_page_indexed;
-	else if (ic_lsize == 32)
-		r4k_blast_icache_page_indexed = blast_icache32_page_indexed;
-	else if (ic_lsize == 64)
+	else if (ic_lsize == 32) {
+		if (TX49XX_ICACHE_INDEX_INV_WAR)
+			r4k_blast_icache_page_indexed =
+				tx49_blast_icache32_page_indexed;
+		else if (R4600_V1_INDEX_ICACHEOP_WAR && cpu_is_r4600_v1_x())
+			r4k_blast_icache_page_indexed =
+				blast_icache32_r4600_v1_page_indexed;
+		else
+			r4k_blast_icache_page_indexed =
+				blast_icache32_page_indexed;
+	} else if (ic_lsize == 64)
 		r4k_blast_icache_page_indexed = blast_icache64_page_indexed;
 }
 
@@ -184,11 +209,14 @@ static inline void r4k_blast_icache_setu
 
 	if (ic_lsize == 16)
 		r4k_blast_icache = blast_icache16;
-	else if (ic_lsize == 32 && TX49XX_ICACHE_INDEX_INV_WAR)
-		r4k_blast_icache = tx49_blast_icache32;
-	else if (ic_lsize == 32)
-		r4k_blast_icache = blast_icache32;
-	else if (ic_lsize == 64)
+	else if (ic_lsize == 32) {
+		if (R4600_V1_INDEX_ICACHEOP_WAR && cpu_is_r4600_v1_x())
+			r4k_blast_icache = blast_r4600_v1_icache32;
+		else if (TX49XX_ICACHE_INDEX_INV_WAR)
+			r4k_blast_icache = tx49_blast_icache32;
+		else if (ic_lsize == 32)
+			r4k_blast_icache = blast_icache32;
+	} else if (ic_lsize == 64)
 		r4k_blast_icache = blast_icache64;
 }
 
@@ -352,6 +380,7 @@ static void r4k_flush_data_cache_page(un
 static void r4k_flush_icache_range(unsigned long start, unsigned long end)
 {
 	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
+	unsigned long ic_lsize = current_cpu_data.icache.linesz;
 	unsigned long addr, aend;
 
 	if (!cpu_has_ic_fills_f_dc) {
@@ -374,14 +403,14 @@ static void r4k_flush_icache_range(unsig
 	if (end - start > icache_size)
 		r4k_blast_icache();
 	else {
-		addr = start & ~(dc_lsize - 1);
-		aend = (end - 1) & ~(dc_lsize - 1);
+		addr = start & ~(ic_lsize - 1);
+		aend = (end - 1) & ~(ic_lsize - 1);
 		while (1) {
 			/* Hit_Invalidate_I */
 			protected_flush_icache_line(addr);
 			if (addr == aend)
 				break;
-			addr += dc_lsize;
+			addr += ic_lsize;
 		}
 	}
 }
@@ -445,6 +474,9 @@ static void r4k_dma_cache_wback_inv(unsi
 {
 	unsigned long end, a;
 
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	if (cpu_has_subset_pcaches) {
 		unsigned long sc_lsize = current_cpu_data.scache.linesz;
 
@@ -492,6 +524,9 @@ static void r4k_dma_cache_inv(unsigned l
 {
 	unsigned long end, a;
 
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	if (cpu_has_subset_pcaches) {
 		unsigned long sc_lsize = current_cpu_data.scache.linesz;
 
@@ -754,7 +789,10 @@ static void __init probe_pcache(void)
 		c->dcache.ways = 4;
 		c->dcache.waybit = ffs(dcache_size / c->dcache.ways) - 1;
 
-		c->options |= MIPS_CPU_CACHE_CDEX_P | MIPS_CPU_PREFETCH;
+#if !defined(CONFIG_SMP) || !defined(RM9000_CDEX_SMP_WAR)
+		c->options |= MIPS_CPU_CACHE_CDEX_P;
+#endif
+		c->options |= MIPS_CPU_PREFETCH;
 		break;
 
 	default:
@@ -937,10 +975,8 @@ static void __init setup_scache(void)
 	 * Linux memory managment.
 	 */
 	switch (c->cputype) {
-	case CPU_R4000PC:
 	case CPU_R4000SC:
 	case CPU_R4000MC:
-	case CPU_R4400PC:
 	case CPU_R4400SC:
 	case CPU_R4400MC:
 		probe_scache_kseg1 = (probe_func_t) (KSEG1ADDR(&probe_scache));
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/c-sb1.c linux-mips-cvs-20040815/arch/mips/mm/c-sb1.c
--- linux-2.4.27/arch/mips/mm/c-sb1.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/c-sb1.c	2004-05-02 00:47:30.000000000 +0200
@@ -2,6 +2,7 @@
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
  * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
+ * Copyright (C) 2004  Maciej W. Rozycki
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -231,8 +232,8 @@ static void sb1_flush_cache_page(struct 
 	local_sb1_flush_cache_page(vma, addr);
 }
 #else
-void sb1_flush_cache_page(struct vm_area_struct *vma, unsigned long addr);
-asm("sb1_flush_cache_page = local_sb1_flush_cache_page");
+void sb1_flush_cache_page(struct vm_area_struct *vma, unsigned long addr)
+	__attribute__((alias("local_sb1_flush_cache_page")));
 #endif
 
 /*
@@ -280,8 +281,8 @@ static void local_sb1___flush_cache_all(
 }
 
 #ifdef CONFIG_SMP
-extern void sb1___flush_cache_all_ipi(void *ignored);
-asm("sb1___flush_cache_all_ipi = local_sb1___flush_cache_all");
+void sb1___flush_cache_all_ipi(void *ignored)
+	__attribute__((alias("local_sb1___flush_cache_all")));
 
 static void sb1___flush_cache_all(void)
 {
@@ -289,8 +290,8 @@ static void sb1___flush_cache_all(void)
 	local_sb1___flush_cache_all();
 }
 #else
-extern void sb1___flush_cache_all(void);
-asm("sb1___flush_cache_all = local_sb1___flush_cache_all");
+void sb1___flush_cache_all(void)
+	__attribute__((alias("local_sb1___flush_cache_all")));
 #endif
 
 /*
@@ -340,8 +341,8 @@ void sb1_flush_icache_range(unsigned lon
 	local_sb1_flush_icache_range(start, end);
 }
 #else
-void sb1_flush_icache_range(unsigned long start, unsigned long end);
-asm("sb1_flush_icache_range = local_sb1_flush_icache_range");
+void sb1_flush_icache_range(unsigned long start, unsigned long end)
+	__attribute__((alias("local_sb1_flush_icache_range")));
 #endif
 
 /*
@@ -398,8 +399,8 @@ static void sb1_flush_icache_page(struct
 	local_sb1_flush_icache_page(vma, page);
 }
 #else
-void sb1_flush_icache_page(struct vm_area_struct *vma, struct page *page);
-asm("sb1_flush_icache_page = local_sb1_flush_icache_page");
+void sb1_flush_icache_page(struct vm_area_struct *vma, struct page *page)
+	__attribute__((alias("local_sb1_flush_icache_page")));
 #endif
 
 /*
@@ -447,8 +448,8 @@ static void sb1_flush_cache_sigtramp(uns
 	smp_call_function(sb1_flush_cache_sigtramp_ipi, (void *) addr, 1, 1);
 }
 #else
-void sb1_flush_cache_sigtramp(unsigned long addr);
-asm("sb1_flush_cache_sigtramp = local_sb1_flush_cache_sigtramp");
+void sb1_flush_cache_sigtramp(unsigned long addr)
+	__attribute__((alias("local_sb1_flush_cache_sigtramp")));
 #endif
 
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/c-tx39.c linux-mips-cvs-20040815/arch/mips/mm/c-tx39.c
--- linux-2.4.27/arch/mips/mm/c-tx39.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/c-tx39.c	2004-03-17 01:47:37.000000000 +0100
@@ -69,6 +69,9 @@ static void tx39h_dma_cache_wback_inv(un
 	unsigned long end, a;
 	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
 
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	iob();
 	a = addr & ~(dc_lsize - 1);
 	end = (addr + size - 1) & ~(dc_lsize - 1);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/ioremap.c linux-mips-cvs-20040815/arch/mips/mm/ioremap.c
--- linux-2.4.27/arch/mips/mm/ioremap.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/mm/ioremap.c	2004-02-25 23:09:23.000000000 +0100
@@ -162,7 +162,7 @@ void * __ioremap(phys_t phys_addr, phys_
 	 */
 	offset = phys_addr & ~PAGE_MASK;
 	phys_addr &= PAGE_MASK;
-	size = PAGE_ALIGN(last_addr) - phys_addr;
+	size = PAGE_ALIGN(last_addr + 1) - phys_addr;
 
 	/*
 	 * Ok, go for it..
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/pg-r4k.c linux-mips-cvs-20040815/arch/mips/mm/pg-r4k.c
--- linux-2.4.27/arch/mips/mm/pg-r4k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/pg-r4k.c	2004-03-05 03:18:15.000000000 +0100
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
  */
 #include <linux/config.h>
 #include <linux/init.h>
@@ -11,6 +11,7 @@
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/module.h>
+#include <linux/proc_fs.h>
 
 #include <asm/cacheops.h>
 #include <asm/inst.h>
@@ -25,28 +26,30 @@
 #include <asm/cpu.h>
 #include <asm/war.h>
 
+#define half_scache_line_size()		(cpu_scache_line_size() >> 1)
+
 /*
  * Maximum sizes:
  *
- * R4000 16 bytes D-cache, 128 bytes S-cache:		0x78 bytes
- * R4600 v1.7:						0x5c bytes
- * R4600 v2.0:						0x60 bytes
- * With prefetching, 16 byte strides			0xa0 bytes
+ * R4000 128 bytes S-cache:		0x58 bytes
+ * R4600 v1.7:				0x5c bytes
+ * R4600 v2.0:				0x60 bytes
+ * With prefetching, 16 byte strides	0xa0 bytes
  */
 
-static unsigned int clear_page_array[0xa0 / 4];
+static unsigned int clear_page_array[0x130 / 4];
 
 void clear_page(void * page) __attribute__((alias("clear_page_array")));
 
 /*
  * Maximum sizes:
  *
- * R4000 16 bytes D-cache, 128 bytes S-cache:		0xbc bytes
- * R4600 v1.7:						0x80 bytes
- * R4600 v2.0:						0x84 bytes
- * With prefetching, 16 byte strides			0xb8 bytes
+ * R4000 128 bytes S-cache:		0x11c bytes
+ * R4600 v1.7:				0x080 bytes
+ * R4600 v2.0:				0x07c bytes
+ * With prefetching, 16 byte strides	0x0b8 bytes
  */
-static unsigned int copy_page_array[0xb8 / 4];
+static unsigned int copy_page_array[0x148 / 4];
 
 void copy_page(void *to, void *from) __attribute__((alias("copy_page_array")));
 
@@ -67,12 +70,58 @@ static int pref_offset_copy  __initdata 
 static unsigned int pref_src_mode __initdata;
 static unsigned int pref_dst_mode __initdata;
 
-static int has_scache __initdata = 0;
-static int load_offset __initdata = 0;
-static int store_offset __initdata = 0;
+static int load_offset __initdata;
+static int store_offset __initdata;
 
 static unsigned int __initdata *dest, *epc;
 
+static unsigned int instruction_pending;
+static union mips_instruction delayed_mi;
+
+static void __init emit_instruction(union mips_instruction mi)
+{
+	if (instruction_pending)
+		*epc++ = delayed_mi.word;
+
+	instruction_pending = 1;
+	delayed_mi = mi;
+}
+
+static inline void flush_delay_slot_or_nop(void)
+{
+	if (instruction_pending) {
+		*epc++ = delayed_mi.word;
+		instruction_pending = 0;
+		return;
+	}
+
+	*epc++ = 0;
+}
+
+static inline unsigned int *label(void)
+{
+	if (instruction_pending) {
+		*epc++ = delayed_mi.word;
+		instruction_pending = 0;
+	}
+
+	return epc;
+}
+
+static inline void build_insn_word(unsigned int word)
+{
+	union mips_instruction mi;
+
+	mi.word		 = word;
+
+	emit_instruction(mi);
+}
+
+static inline void build_nop(void)
+{
+	build_insn_word(0);			/* nop */
+}
+
 static inline void build_src_pref(int advance)
 {
 	if (!(load_offset & (cpu_dcache_line_size() - 1))) {
@@ -83,25 +132,28 @@ static inline void build_src_pref(int ad
 		mi.i_format.rt         = pref_src_mode;
 		mi.i_format.simmediate = load_offset + advance;
 
-		*epc++ = mi.word;
+		emit_instruction(mi);
 	}
 }
 
 static inline void __build_load_reg(int reg)
 {
 	union mips_instruction mi;
+	unsigned int width;
 
-	if (cpu_has_64bit_registers)
+	if (cpu_has_64bit_registers) {
 		mi.i_format.opcode     = ld_op;
-	else
+		width = 8;
+	} else {
 		mi.i_format.opcode     = lw_op;
+		width = 4;
+	}
 	mi.i_format.rs         = 5;		/* $a1 */
-	mi.i_format.rt         = reg;		/* $zero */
+	mi.i_format.rt         = reg;		/* $reg */
 	mi.i_format.simmediate = load_offset;
 
-	load_offset += (cpu_has_64bit_registers ? 8 : 4);
-
-	*epc++ = mi.word;
+	load_offset += width;
+	emit_instruction(mi);
 }
 
 static inline void build_load_reg(int reg)
@@ -122,87 +174,71 @@ static inline void build_dst_pref(int ad
 		mi.i_format.rt         = pref_dst_mode;
 		mi.i_format.simmediate = store_offset + advance;
 
-		*epc++ = mi.word;
+		emit_instruction(mi);
 	}
 }
 
-static inline void build_cdex(void)
+static inline void build_cdex_s(void)
 {
 	union mips_instruction mi;
 
-	if (cpu_has_cache_cdex_s &&
-	    !(store_offset & (cpu_scache_line_size() - 1))) {
+	if ((store_offset & (cpu_scache_line_size() - 1)))
+		return;
 
-		mi.c_format.opcode     = cache_op;
-		mi.c_format.rs         = 4;	/* $a0 */
-		mi.c_format.c_op       = 3;	/* Create Dirty Exclusive */
-		mi.c_format.cache      = 3;	/* Secondary Data Cache */
-		mi.c_format.simmediate = store_offset;
+	mi.c_format.opcode     = cache_op;
+	mi.c_format.rs         = 4;		/* $a0 */
+	mi.c_format.c_op       = 3;		/* Create Dirty Exclusive */
+	mi.c_format.cache      = 3;		/* Secondary Data Cache */
+	mi.c_format.simmediate = store_offset;
 
-		*epc++ = mi.word;
-	}
+	emit_instruction(mi);
+}
+
+static inline void build_cdex_p(void)
+{
+	union mips_instruction mi;
 
 	if (store_offset & (cpu_dcache_line_size() - 1))
 		return;
 
 	if (R4600_V1_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2010)) {
-		*epc++ = 0;			/* nop */
-		*epc++ = 0;			/* nop */
-		*epc++ = 0;			/* nop */
-		*epc++ = 0;			/* nop */
+		build_nop();
+		build_nop();
+		build_nop();
+		build_nop();
 	}
 
+	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+		build_insn_word(0x8c200000);	/* lw      $zero, ($at) */
+
 	mi.c_format.opcode     = cache_op;
 	mi.c_format.rs         = 4;		/* $a0 */
 	mi.c_format.c_op       = 3;		/* Create Dirty Exclusive */
 	mi.c_format.cache      = 1;		/* Data Cache */
 	mi.c_format.simmediate = store_offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
-static inline void __build_store_zero_reg(void)
+static void __build_store_reg(int reg)
 {
 	union mips_instruction mi;
+	unsigned int width;
 
-	if (cpu_has_64bits)
+	if (cpu_has_64bit_gp_regs ||
+	    (cpu_has_64bit_zero_reg && reg == 0)) {
 		mi.i_format.opcode     = sd_op;
-	else
-		mi.i_format.opcode     = sw_op;
-	mi.i_format.rs         = 4;		/* $a0 */
-	mi.i_format.rt         = 0;		/* $zero */
-	mi.i_format.simmediate = store_offset;
-
-	store_offset += (cpu_has_64bits ? 8 : 4);
-
-	*epc++ = mi.word;
-}
-
-static inline void __build_store_reg(int reg)
-{
-	union mips_instruction mi;
-	int reg_size;
-
-#ifdef CONFIG_MIPS32
-	if (cpu_has_64bit_registers && reg == 0) {
-		mi.i_format.opcode     = sd_op;
-		reg_size               = 8;
+		width = 8;
 	} else {
 		mi.i_format.opcode     = sw_op;
-		reg_size               = 4;
+		width = 4;
 	}
-#endif
-#ifdef CONFIG_MIPS64
-	mi.i_format.opcode     = sd_op;
-	reg_size               = 8;
-#endif
 	mi.i_format.rs         = 4;		/* $a0 */
-	mi.i_format.rt         = reg;		/* $zero */
+	mi.i_format.rt         = reg;		/* $reg */
 	mi.i_format.simmediate = store_offset;
 
-	store_offset += reg_size;
-
-	*epc++ = mi.word;
+	store_offset += width;
+	emit_instruction(mi);
 }
 
 static inline void build_store_reg(int reg)
@@ -212,13 +248,15 @@ static inline void build_store_reg(int r
 			build_dst_pref(pref_offset_copy);
 		else
 			build_dst_pref(pref_offset_clear);
+	else if (cpu_has_cache_cdex_s)
+		build_cdex_s();
 	else if (cpu_has_cache_cdex_p)
-		build_cdex();
+		build_cdex_p();
 
 	__build_store_reg(reg);
 }
 
-static inline void build_addiu_at_a0(unsigned long offset)
+static inline void build_addiu_a2_a0(unsigned long offset)
 {
 	union mips_instruction mi;
 
@@ -226,10 +264,10 @@ static inline void build_addiu_at_a0(uns
 
 	mi.i_format.opcode     = cpu_has_64bit_addresses ? daddiu_op : addiu_op;
 	mi.i_format.rs         = 4;		/* $a0 */
-	mi.i_format.rt         = 1;		/* $at */
+	mi.i_format.rt         = 6;		/* $a2 */
 	mi.i_format.simmediate = offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
 static inline void build_addiu_a1(unsigned long offset)
@@ -245,7 +283,7 @@ static inline void build_addiu_a1(unsign
 
 	load_offset -= offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
 static inline void build_addiu_a0(unsigned long offset)
@@ -261,7 +299,7 @@ static inline void build_addiu_a0(unsign
 
 	store_offset -= offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
 static inline void build_bne(unsigned int *dest)
@@ -269,16 +307,12 @@ static inline void build_bne(unsigned in
 	union mips_instruction mi;
 
 	mi.i_format.opcode = bne_op;
-	mi.i_format.rs     = 1;			/* $at */
+	mi.i_format.rs     = 6;			/* $a2 */
 	mi.i_format.rt     = 4;			/* $a0 */
 	mi.i_format.simmediate = dest - epc - 1;
 
 	*epc++ = mi.word;
-}
-
-static inline void build_nop(void)
-{
-	*epc++ = 0;
+	flush_delay_slot_or_nop();
 }
 
 static inline void build_jr_ra(void)
@@ -293,19 +327,34 @@ static inline void build_jr_ra(void)
 	mi.r_format.func   = jr_op;
 
 	*epc++ = mi.word;
+	flush_delay_slot_or_nop();
 }
 
 void __init build_clear_page(void)
 {
+	unsigned int loop_start;
+
 	epc = (unsigned int *) &clear_page_array;
+	instruction_pending = 0;
+	store_offset = 0;
 
 	if (cpu_has_prefetch) {
 		switch (current_cpu_data.cputype) {
+		case CPU_RM9000:
+			/*
+			 * As a workaround for erratum G105 which make the
+			 * PrepareForStore hint unusable we fall back to
+			 * StoreRetained on the RM9000.  Once it is known which
+			 * versions of the RM9000 we'll be able to condition-
+			 * alize this.
+			 */
+
 		case CPU_R10000:
 		case CPU_R12000:
 			pref_src_mode = Pref_LoadStreamed;
 			pref_dst_mode = Pref_StoreRetained;
 			break;
+
 		default:
 			pref_src_mode = Pref_LoadStreamed;
 			pref_dst_mode = Pref_PrepareForStore;
@@ -313,64 +362,50 @@ void __init build_clear_page(void)
 		}
 	}
 
-	build_addiu_at_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_clear : 0));
+	build_addiu_a2_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_clear : 0));
 
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020)) {
-		*epc++ = 0x40026000;		/* mfc0    $v0, $12	*/
-		*epc++ = 0x34410001;		/* ori     $at, v0, 0x1	*/
-		*epc++ = 0x38210001;		/* xori    $at, at, 0x1	*/
-		*epc++ = 0x40816000;		/* mtc0    $at, $12	*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x3c01a000;		/* lui     $at, 0xa000  */
-		*epc++ = 0x8c200000;		/* lw      $zero, ($at) */
-	}
+	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+		build_insn_word(0x3c01a000);	/* lui     $at, 0xa000  */
 
-dest = epc;
-	build_store_reg(0);
-	build_store_reg(0);
-	build_store_reg(0);
-	build_store_reg(0);
-	if (has_scache && cpu_scache_line_size() == 128) {
+dest = label();
+	do {
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
-	}
+	} while (store_offset < half_scache_line_size());
 	build_addiu_a0(2 * store_offset);
-	build_store_reg(0);
-	build_store_reg(0);
-	if (has_scache && cpu_scache_line_size() == 128) {
+	loop_start = store_offset;
+	do {
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
-	}
-	build_store_reg(0);
+	} while ((store_offset - loop_start) < half_scache_line_size());
 	build_bne(dest);
-	 build_store_reg(0);
 
 	if (cpu_has_prefetch && pref_offset_clear) {
-		build_addiu_at_a0(pref_offset_clear);
-	dest = epc;
-		__build_store_reg(0);
-		__build_store_reg(0);
-		__build_store_reg(0);
-		__build_store_reg(0);
+		build_addiu_a2_a0(pref_offset_clear);
+	dest = label();
+		loop_start = store_offset;
+		do {
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_addiu_a0(2 * store_offset);
-		__build_store_reg(0);
-		__build_store_reg(0);
-		__build_store_reg(0);
+		loop_start = store_offset;
+		do {
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_bne(dest);
-		 __build_store_reg(0);
 	}
 
 	build_jr_ra();
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
-		*epc++ = 0x40826000;		/* mtc0    $v0, $12	*/
-	else
-		build_nop();
 
 	flush_icache_range((unsigned long)&clear_page_array,
 	                   (unsigned long) epc);
@@ -380,32 +415,20 @@ dest = epc;
 
 void __init build_copy_page(void)
 {
+	unsigned int loop_start;
+
 	epc = (unsigned int *) &copy_page_array;
+	store_offset = load_offset = 0;
+	instruction_pending = 0;
 
-	build_addiu_at_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_copy : 0));
+	build_addiu_a2_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_copy : 0));
 
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020)) {
-		*epc++ = 0x40026000;		/* mfc0    $v0, $12	*/
-		*epc++ = 0x34410001;		/* ori     $at, v0, 0x1	*/
-		*epc++ = 0x38210001;		/* xori    $at, at, 0x1	*/
-		*epc++ = 0x40816000;		/* mtc0    $at, $12	*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x3c01a000;		/* lui     $at, 0xa000  */
-		*epc++ = 0x8c200000;		/* lw      $zero, ($at) */
-	}
+	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+		build_insn_word(0x3c01a000);	/* lui     $at, 0xa000  */
 
-dest = epc;
-	build_load_reg( 8);
-	build_load_reg( 9);
-	build_load_reg(10);
-	build_load_reg(11);
-	build_store_reg( 8);
-	build_store_reg( 9);
-	build_store_reg(10);
-	build_store_reg(11);
-	if (has_scache && cpu_scache_line_size() == 128) {
+dest = label();
+	loop_start = store_offset;
+	do {
 		build_load_reg( 8);
 		build_load_reg( 9);
 		build_load_reg(10);
@@ -414,18 +437,11 @@ dest = epc;
 		build_store_reg( 9);
 		build_store_reg(10);
 		build_store_reg(11);
-	}
+	} while ((store_offset - loop_start) < half_scache_line_size());
 	build_addiu_a0(2 * store_offset);
 	build_addiu_a1(2 * load_offset);
-	build_load_reg( 8);
-	build_load_reg( 9);
-	build_load_reg(10);
-	build_load_reg(11);
-	build_store_reg( 8);
-	build_store_reg( 9);
-	build_store_reg(10);
-	if (has_scache && cpu_scache_line_size() == 128) {
-		build_store_reg(11);
+	loop_start = store_offset;
+	do {
 		build_load_reg( 8);
 		build_load_reg( 9);
 		build_load_reg(10);
@@ -433,39 +449,44 @@ dest = epc;
 		build_store_reg( 8);
 		build_store_reg( 9);
 		build_store_reg(10);
-	}
+		build_store_reg(11);
+	} while ((store_offset - loop_start) < half_scache_line_size());
 	build_bne(dest);
-	 build_store_reg(11);
 
 	if (cpu_has_prefetch && pref_offset_copy) {
-		build_addiu_at_a0(pref_offset_copy);
-	dest = epc;
-		__build_load_reg( 8);
-		__build_load_reg( 9);
-		__build_load_reg(10);
-		__build_load_reg(11);
-		__build_store_reg( 8);
-		__build_store_reg( 9);
-		__build_store_reg(10);
-		__build_store_reg(11);
+		build_addiu_a2_a0(pref_offset_copy);
+	dest = label();
+		loop_start = store_offset;
+		do {
+			__build_load_reg( 8);
+			__build_load_reg( 9);
+			__build_load_reg(10);
+			__build_load_reg(11);
+			__build_store_reg( 8);
+			__build_store_reg( 9);
+			__build_store_reg(10);
+			__build_store_reg(11);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_addiu_a0(2 * store_offset);
 		build_addiu_a1(2 * load_offset);
-		__build_load_reg( 8);
-		__build_load_reg( 9);
-		__build_load_reg(10);
-		__build_load_reg(11);
-		__build_store_reg( 8);
-		__build_store_reg( 9);
-		__build_store_reg(10);
+		loop_start = store_offset;
+		do {
+			__build_load_reg( 8);
+			__build_load_reg( 9);
+			__build_load_reg(10);
+			__build_load_reg(11);
+			__build_store_reg( 8);
+			__build_store_reg( 9);
+			__build_store_reg(10);
+			__build_store_reg(11);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_bne(dest);
-		 __build_store_reg(11);
 	}
 
 	build_jr_ra();
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
-		*epc++ = 0x40826000;		/* mtc0    $v0, $12	*/
-	else
-		build_nop();
+
+	flush_icache_range((unsigned long)&copy_page_array,
+	                   (unsigned long) epc);
 
 	BUG_ON(epc > copy_page_array + ARRAY_SIZE(copy_page_array));
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/sc-ip22.c linux-mips-cvs-20040815/arch/mips/mm/sc-ip22.c
--- linux-2.4.27/arch/mips/mm/sc-ip22.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/mm/sc-ip22.c	2004-03-17 01:47:37.000000000 +0100
@@ -65,8 +65,8 @@ static void indy_sc_wback_invalidate(uns
 	printk("indy_sc_wback_invalidate[%08lx,%08lx]", addr, size);
 #endif
 
-	if (!size)
-		return;
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
 
 	/* Which lines to flush?  */
 	first_line = SC_INDEX(addr);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/sc-r5k.c linux-mips-cvs-20040815/arch/mips/mm/sc-r5k.c
--- linux-2.4.27/arch/mips/mm/sc-r5k.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/mm/sc-r5k.c	2004-03-17 01:47:37.000000000 +0100
@@ -47,6 +47,9 @@ static void r5k_dma_cache_inv_sc(unsigne
 {
 	unsigned long end, a;
 
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	if (size >= scache_size) {
 		blast_r5000_scache();
 		return;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/sc-rm7k.c linux-mips-cvs-20040815/arch/mips/mm/sc-rm7k.c
--- linux-2.4.27/arch/mips/mm/sc-rm7k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/sc-rm7k.c	2004-03-17 16:32:08.000000000 +0100
@@ -1,8 +1,11 @@
 /*
  * sc-rm7k.c: RM7000 cache management functions.
  *
- * Copyright (C) 1997, 2001, 2003 Ralf Baechle (ralf@gnu.org),
+ * Copyright (C) 1997, 2001, 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
  */
+
+#undef DEBUG
+
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
@@ -17,8 +20,6 @@
 #define sc_lsize	32
 #define tc_pagesize	(32*128)
 
-static unsigned long scache_way_size = 32;		/* HACKKKKK!!! */
-
 /* Secondary cache parameters. */
 #define scache_size	(256*1024)	/* Fixed to 256KiB on RM7000 */
 
@@ -36,9 +37,10 @@ static void rm7k_sc_wback_inv(unsigned l
 {
 	unsigned long end, a;
 
-#ifdef DEBUG_CACHE
-	printk("rm7k_sc_wback_inv[%08lx,%08lx]", addr, size);
-#endif
+	pr_debug("rm7k_sc_wback_inv[%08lx,%08lx]", addr, size);
+
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
 
 	a = addr & ~(sc_lsize - 1);
 	end = (addr + size - 1) & ~(sc_lsize - 1);
@@ -66,9 +68,10 @@ static void rm7k_sc_inv(unsigned long ad
 {
 	unsigned long end, a;
 
-#ifdef DEBUG_CACHE
-	printk("rm7k_sc_inv[%08lx,%08lx]", addr, size);
-#endif
+	pr_debug("rm7k_sc_inv[%08lx,%08lx]", addr, size);
+
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
 
 	a = addr & ~(sc_lsize - 1);
 	end = (addr + size - 1) & ~(sc_lsize - 1);
@@ -107,16 +110,16 @@ static void rm7k_sc_inv(unsigned long ad
  *
  * It seems we get our kicks from relying on unguaranteed behaviour in GCC
  */
-static __init void rm7k_sc_enable(void)
+static __init void __rm7k_sc_enable(void)
 {
 	int i;
 
-	set_c0_config(1<<3);				/* CONF_SE */
+	set_c0_config(1 << 3);				/* CONF_SE */
 
 	write_c0_taglo(0);
 	write_c0_taghi(0);
 
-	for (i=0; i<scache_size; i+=sc_lsize) {
+	for (i = 0; i < scache_size; i += sc_lsize) {
 		__asm__ __volatile__ (
 		      ".set noreorder\n\t"
 		      ".set mips3\n\t"
@@ -124,11 +127,21 @@ static __init void rm7k_sc_enable(void)
 		      ".set mips0\n\t"
 		      ".set reorder"
 		      :
-		      : "r" (KSEG0ADDR(i)),
-		        "i" (Index_Store_Tag_SD));
+		      : "r" (KSEG0ADDR(i)), "i" (Index_Store_Tag_SD));
 	}
 }
 
+static __init void rm7k_sc_enable(void)
+{
+	void (*func)(void) = (void *) KSEG1ADDR(&__rm7k_sc_enable);
+
+	if (read_c0_config() & 0x08)			/* CONF_SE */
+		return;
+
+	printk(KERN_INFO "Enabling secondary cache...");
+	func();
+}
+
 static void rm7k_sc_disable(void)
 {
 	clear_c0_config(1<<3);				/* CONF_SE */
@@ -136,22 +149,17 @@ static void rm7k_sc_disable(void)
 
 static inline int __init rm7k_sc_probe(void)
 {
-	void (*func)(void) = KSEG1ADDR(&rm7k_sc_enable);
 	unsigned int config = read_c0_config();
 
 	if ((config >> 31) & 1)
 		return 0;
 
-	printk(KERN_INFO "Secondary cache size %ldK, linesize %ld bytes.\n",
+	printk(KERN_INFO "Secondary cache size %dK, linesize %d bytes.\n",
 	       (scache_size >> 10), sc_lsize);
 
 	if ((config >> 3) & 1)                          /* CONF_SE */
 		return 1;
 
-	printk(KERN_INFO "Enabling secondary cache...");
-	func();
-	printk("  done\n");
-
 	/*
 	 * While we're at it let's deal with the tertiary cache.
 	 */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/tlb-r4k.c linux-mips-cvs-20040815/arch/mips/mm/tlb-r4k.c
--- linux-2.4.27/arch/mips/mm/tlb-r4k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/tlb-r4k.c	2004-08-15 08:05:49.000000000 +0200
@@ -21,6 +21,7 @@
 #include <asm/cpu.h>
 #include <asm/bootinfo.h>
 #include <asm/mmu_context.h>
+#include <linux/module.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
 
@@ -46,7 +47,7 @@ void local_flush_tlb_all(void)
 
 	local_irq_save(flags);
 	/* Save old context and create impossible VPN2 value */
-	old_ctx = (read_c0_entryhi() & 0xff);
+	old_ctx = read_c0_entryhi();
 	write_c0_entrylo0(0);
 	write_c0_entrylo1(0);
 	BARRIER;
@@ -100,7 +101,7 @@ void local_flush_tlb_range(struct mm_str
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
 		if (size <= current_cpu_data.tlbsize/2) {
-			int oldpid = read_c0_entryhi() & ASID_MASK;
+			int oldpid = read_c0_entryhi();
 			int newpid = cpu_asid(cpu, mm);
 
 			start &= (PAGE_MASK << 1);
@@ -148,7 +149,7 @@ void local_flush_tlb_page(struct vm_area
 		newpid = cpu_asid(cpu, vma->vm_mm);
 		page &= (PAGE_MASK << 1);
 		local_irq_save(flags);
-		oldpid = (read_c0_entryhi() & 0xff);
+		oldpid = read_c0_entryhi();
 		write_c0_entryhi(page | newpid);
 		BARRIER;
 		tlb_probe();
@@ -180,7 +181,7 @@ void local_flush_tlb_one(unsigned long p
 	int oldpid, idx;
 
 	page &= (PAGE_MASK << 1);
-	oldpid = read_c0_entryhi() & ASID_MASK;
+	oldpid = read_c0_entryhi();
 
 	local_irq_save(flags);
 	write_c0_entryhi(page);
@@ -200,6 +201,8 @@ void local_flush_tlb_one(unsigned long p
 	local_irq_restore(flags);
 }
 
+EXPORT_SYMBOL(local_flush_tlb_one);
+
 /* We will need multiple versions of update_mmu_cache(), one that just
  * updates the TLB with the new pte(s), and another which also checks
  * for the R4k "end of page" hardware bug and does the needy.
@@ -265,6 +268,7 @@ static void r4k_update_mmu_cache_hwbug(s
 				       unsigned long address, pte_t pte)
 {
 	unsigned long flags;
+	unsigned int asid;
 	pgd_t *pgdp;
 	pmd_t *pmdp;
 	pte_t *ptep;
@@ -272,7 +276,8 @@ static void r4k_update_mmu_cache_hwbug(s
 
 	local_irq_save(flags);
 	address &= (PAGE_MASK << 1);
-	write_c0_entryhi(address | (read_c0_entryhi() & 0xff));
+	asid = read_c0_entryhi() & ASID_MASK;
+	write_c0_entryhi(address | asid);
 	pgdp = pgd_offset(vma->vm_mm, address);
 	tlb_probe();
 	pmdp = pmd_offset(pgdp, address);
@@ -300,7 +305,7 @@ void __init add_wired_entry(unsigned lon
 
 	local_irq_save(flags);
 	/* Save old context and create impossible VPN2 value */
-	old_ctx = read_c0_entryhi() & 0xff;
+	old_ctx = read_c0_entryhi();
 	old_pagemask = read_c0_pagemask();
 	wired = read_c0_wired();
 	write_c0_wired(wired + 1);
@@ -340,7 +345,7 @@ __init int add_temporary_entry(unsigned 
 
 	local_irq_save(flags);
 	/* Save old context and create impossible VPN2 value */
-	old_ctx = read_c0_entryhi() & 0xff;
+	old_ctx = read_c0_entryhi();
 	old_pagemask = read_c0_pagemask();
 	wired = read_c0_wired();
 	if (--temp_tlb_entry < wired) {
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/mm/tlb-sb1.c linux-mips-cvs-20040815/arch/mips/mm/tlb-sb1.c
--- linux-2.4.27/arch/mips/mm/tlb-sb1.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/mm/tlb-sb1.c	2004-08-15 08:05:49.000000000 +0200
@@ -18,6 +18,7 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 #include <linux/config.h>
+#include <linux/module.h>
 #include <linux/init.h>
 #include <asm/mmu_context.h>
 #include <asm/bootinfo.h>
@@ -118,7 +119,7 @@ void local_flush_tlb_all(void)
  * with the firmware, go back and give all the entries invalid addresses with
  * the normal flush routine.  Wired entries will be killed as well!
  */
-void sb1_sanitize_tlb(void)
+static void __init sb1_sanitize_tlb(void)
 {
 	int entry;
 	long addr = 0;
@@ -238,6 +239,9 @@ void local_flush_tlb_one(unsigned long p
 	local_irq_restore(flags);
 }
 
+/* The highmem code wants this. */
+EXPORT_SYMBOL(local_flush_tlb_one);
+
 /* All entries common to a mm share an asid.  To effectively flush
    these entries, we just bump the asid. */
 void local_flush_tlb_mm(struct mm_struct *mm)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/momentum/jaguar_atx/Makefile linux-mips-cvs-20040815/arch/mips/momentum/jaguar_atx/Makefile
--- linux-2.4.27/arch/mips/momentum/jaguar_atx/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/momentum/jaguar_atx/Makefile	2004-03-10 00:53:25.000000000 +0100
@@ -6,10 +6,7 @@
 # unless it's something special (ie not a .c file).
 #
 
-.S.s:
-	$(CPP) $(CFLAGS) $< -o $*.s
-.S.o:
-	$(CC) $(CFLAGS) -c $< -o $*.o
+USE_STANDARD_AS_RULE := true
 
 O_TARGET:= jaguar_atx.o
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/momentum/jaguar_atx/int-handler.S linux-mips-cvs-20040815/arch/mips/momentum/jaguar_atx/int-handler.S
--- linux-2.4.27/arch/mips/momentum/jaguar_atx/int-handler.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/momentum/jaguar_atx/int-handler.S	2004-03-10 00:13:47.000000000 +0100
@@ -13,7 +13,6 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-#define __ASSEMBLY__
 #include <linux/config.h>
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/momentum/ocelot_c/int-handler.S linux-mips-cvs-20040815/arch/mips/momentum/ocelot_c/int-handler.S
--- linux-2.4.27/arch/mips/momentum/ocelot_c/int-handler.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/momentum/ocelot_c/int-handler.S	2004-03-10 00:13:47.000000000 +0100
@@ -12,7 +12,6 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-#define __ASSEMBLY__
 #include <linux/config.h>
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/momentum/ocelot_g/int-handler.S linux-mips-cvs-20040815/arch/mips/momentum/ocelot_g/int-handler.S
--- linux-2.4.27/arch/mips/momentum/ocelot_g/int-handler.S	2002-11-29 00:53:10.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/momentum/ocelot_g/int-handler.S	2004-03-10 00:13:47.000000000 +0100
@@ -9,7 +9,6 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-#define __ASSEMBLY__
 #include <linux/config.h>
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/momentum/ocelot_g/irq.c linux-mips-cvs-20040815/arch/mips/momentum/ocelot_g/irq.c
--- linux-2.4.27/arch/mips/momentum/ocelot_g/irq.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/momentum/ocelot_g/irq.c	2004-08-15 08:05:49.000000000 +0200
@@ -47,93 +47,6 @@
 #include <asm/mipsregs.h>
 #include <asm/system.h>
 
-
-static spinlock_t rm7000_irq_lock = SPIN_LOCK_UNLOCKED;
-
-/* Function for careful CP0 interrupt mask access */
-static inline void modify_cp0_intmask(unsigned clr_mask_in, unsigned set_mask_in)
-{
-	unsigned long status;
-	unsigned clr_mask;
-	unsigned set_mask;
-
-	/* do the low 8 bits first */
-	clr_mask = 0xff & clr_mask_in;
-	set_mask = 0xff & set_mask_in;
-	status = read_c0_status();
-	status &= ~((clr_mask & 0xFF) << 8);
-	status |= (set_mask & 0xFF) << 8;
-	write_c0_status(status);
-
-	/* do the high 8 bits */
-	clr_mask = 0xff & (clr_mask_in >> 8);
-	set_mask = 0xff & (set_mask_in >> 8);
-	status = read_c0_intcontrol();
-	status &= ~((clr_mask & 0xFF) << 8);
-	status |= (set_mask & 0xFF) << 8;
-	write_c0_intrcontrol(status);
-}
-
-static inline void mask_irq(unsigned int irq)
-{
-	modify_cp0_intmask(irq, 0);
-}
-
-static inline void unmask_irq(unsigned int irq)
-{
-	modify_cp0_intmask(0, irq);
-}
-
-static void enable_cp7000_irq(unsigned int irq)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&rm7000_irq_lock, flags);
-	unmask_irq(1 << irq);
-	spin_unlock_irqrestore(&rm7000_irq_lock, flags);
-}
-
-static unsigned int startup_cp7000_irq(unsigned int irq)
-{
-	enable_cp7000_irq(irq);
-
-	return 0;				/* never anything pending */
-}
-
-static void disable_cp7000_irq(unsigned int irq)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&rm7000_irq_lock, flags);
-	mask_irq(1 << irq);
-	spin_unlock_irqrestore(&rm7000_irq_lock, flags);
-}
-
-#define shutdown_cp7000_irq disable_cp7000_irq
-
-static void mask_and_ack_cp7000_irq(unsigned int irq)
-{
-	mask_irq(1 << irq);
-}
-
-static void end_cp7000_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-		unmask_irq(1 << irq);
-}
-
-static struct hw_interrupt_type cp7000_hpcdma_irq_type = {
-	"CP7000",
-	startup_cp7000_irq,
-	shutdown_cp7000_irq,
-	enable_cp7000_irq,
-	disable_cp7000_irq,
-	mask_and_ack_cp7000_irq,
-	end_cp7000_irq,
-	NULL
-};
-
-
 extern asmlinkage void ocelot_handle_int(void);
 extern void gt64240_irq_init(void);
 
@@ -151,14 +64,8 @@ void __init init_IRQ(void)
 	/* Sets the first-level interrupt dispatcher. */
 	set_except_vector(0, ocelot_handle_int);
 	init_generic_irq();
-
-	for (i = 0; i <= 15; i++) {
-		irq_desc[i].status	= IRQ_DISABLED;
-		irq_desc[i].action	= 0;
-		irq_desc[i].depth	= 1;
-		irq_desc[i].handler	= &cp7000_hpcdma_irq_type;
-	}
-
+	mips_cpu_irq_init(0);
+	rm7k_cpu_irq_init(8);
 	gt64240_irq_init();
 
 #ifdef CONFIG_KGDB
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pci/Makefile linux-mips-cvs-20040815/arch/mips/pci/Makefile
--- linux-2.4.27/arch/mips/pci/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/pci/Makefile	2004-08-15 08:05:49.000000000 +0200
@@ -8,8 +8,6 @@
 
 O_TARGET 			:= pci-core.o
 
-export-objs			= pci.o
-
 obj-$(CONFIG_MIPS_BONITO64)	+= ops-bonito64.o
 obj-$(CONFIG_MIPS_GT64120)	+= ops-gt64120.o
 obj-$(CONFIG_MIPS_MSC)		+= ops-msc.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pci/pci.c linux-mips-cvs-20040815/arch/mips/pci/pci.c
--- linux-2.4.27/arch/mips/pci/pci.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/pci/pci.c	2004-03-16 16:03:32.000000000 +0100
@@ -129,7 +129,7 @@ int pcibios_enable_device(struct pci_dev
 	return pcibios_enable_resources(dev, mask);
 }
 
-#ifdef CONFIG_NEW_PCI
+#ifdef CONFIG_PCI_NEW
 /*
  * Named PCI new and about to die before it's old :-)
  *
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/Makefile linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/Makefile
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/Makefile	2004-04-21 02:19:18.000000000 +0200
@@ -0,0 +1,11 @@
+#
+# Makefile for the PMC-Sierra Big Sur
+#
+
+USE_STANDARD_AS_RULE := true
+
+O_TARGET:= big_sur.o
+
+obj-y  += int-handler.o irq.o big_sur_irq.o
+
+include $(TOPDIR)/Rules.make
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/big_sur_irq.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/big_sur_irq.c
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/big_sur_irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/big_sur_irq.c	2004-04-21 02:19:18.000000000 +0200
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2004 PMC-Sierra Inc.
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * arch/mips/pmc-sierra/big_sur/big_sur_irq.c
+ *     Interrupt routines for Xilinx system controller.  Interrupt numbers 
+ *     are assigned from BIG_SUR_IRQ_BASE to BIG_SUR_IRQ_BASE + 10
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <asm/ptrace.h>
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "xilinx_irq.h"
+
+#define	BIG_SUR_IRQ_BASE	16
+
+/* mask off an interrupt -- 1 is enable, 0 is disable */
+static inline void mask_big_sur_irq(unsigned int irq)
+{
+	unsigned long reg_data;
+	
+	reg_data = BIG_SUR_READ(BIG_SUR_INTERRUPT_MASK_1);
+	reg_data &= ~(1 << (irq - BIG_SUR_IRQ_BASE));
+	BIG_SUR_WRITE(BIG_SUR_INTERRUPT_MASK_1, reg_data);
+}
+
+/* unmask an interrupt -- 1 is enable, 0 is disable */
+static inline void unmask_big_sur_irq(unsigned int irq)
+{
+	unsigned long reg_data;
+
+	reg_data = BIG_SUR_READ(BIG_SUR_INTERRUPT_MASK_1);
+	reg_data |= (1 << (irq - BIG_SUR_IRQ_BASE));
+	BIG_SUR_WRITE(BIG_SUR_INTERRUPT_MASK_1, reg_data);
+}
+
+/* Enable IRQ on the Xilinx FPGA */
+static void enable_big_sur_irq(unsigned int irq)
+{
+	unmask_big_sur_irq(irq);
+}
+
+/* Initialize IRQ on the Xilinx FPGA */
+static unsigned int startup_big_sur_irq(unsigned int irq)
+{
+	unmask_big_sur_irq(irq);
+	return 0;
+}
+
+/* Disable the IRQ on the Xilinx FPGA */
+static void disable_big_sur_irq(unsigned int irq)
+{
+	mask_big_sur_irq(irq);
+}
+
+/* Mask and ack an IRQ on the Xilinx FPGA */
+static void mask_and_ack_big_sur_irq(unsigned int irq)
+{
+	mask_big_sur_irq(irq);
+}
+
+/* End IRQ processing on the Xilinx FPGA */
+static void end_big_sur_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		unmask_big_sur_irq(irq);
+}
+
+/*
+ * Main interrupt handler for the Xilinx FPGA on the 
+ * Big Sur board. These interrupts could be coming
+ * from the IDE, PCI, UART etc.
+ */
+void big_sur_irq_handler(struct pt_regs *regs)
+{
+	unsigned long reg_data;
+
+	reg_data = BIG_SUR_READ(BIG_SUR_INTERRUPT_STATUS_1);
+	
+	/* Now check for the UART 1 interrupts */
+	if (reg_data & 0x38)
+		do_IRQ(BIG_SUR_UART1_IRQ + BIG_SUR_IRQ_BASE, regs);
+
+	/* Now check for the UART 2 interrupts */
+	if (reg_data & 0x1c0)
+		do_IRQ(BIG_SUR_UART2_IRQ + BIG_SUR_IRQ_BASE, regs);
+
+	/* Now check for the Timer interrupt */
+	if (reg_data & 0x800)
+		do_IRQ(BIG_SUR_TIMER_IRQ + BIG_SUR_IRQ_BASE, regs);
+
+	/* Now check for the PCI interrupt, INTA */
+	if (reg_data & 0x2)
+		do_IRQ(BIG_SUR_PCI_IRQ + BIG_SUR_IRQ_BASE, regs);
+
+	/* Now check for the IDE interrupts */
+	if (reg_data & 0x1)
+		do_IRQ(BIG_SUR_IDE_IRQ + BIG_SUR_IRQ_BASE, regs);
+}
+
+#define	shutdown_big_sur_irq	disable_big_sur_irq
+
+struct hw_interrupt_type big_sur_irq_type = {
+	"BIG-SUR",
+	startup_big_sur_irq,
+	shutdown_big_sur_irq,
+	enable_big_sur_irq,
+	disable_big_sur_irq,
+	mask_and_ack_big_sur_irq,
+	end_big_sur_irq,
+	NULL
+};
+
+void big_sur_irq_init(void)
+{
+	int i;
+
+	/* Reset irq handlers pointers to NULL */
+	for (i = BIG_SUR_IRQ_BASE; i < (BIG_SUR_IRQ_BASE + 10); i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 2;
+		irq_desc[i].handler = &big_sur_irq_type;
+	}
+}
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/int-handler.S linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/int-handler.S
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/int-handler.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/int-handler.S	2004-04-21 02:19:18.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2004 PMC-Sierra Inc. 
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * First-level interrupt dispatcher for the PMC-Sierra Big Sur board that
+ * has the Xilinx system controller.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ * First level interrupt dispatcher for the Big Sur board
+ */
+		.align	5
+		NESTED(big_sur_handle_int, PT_SIZE, sp)
+		SAVE_ALL
+		CLI
+		.set	at
+		mfc0	t0, CP0_CAUSE  
+		mfc0	t2, CP0_STATUS
+
+		and	t0, t2
+        
+		andi	t1, t0, STATUSF_IP0	/* sw0 software interrupt */
+		bnez	t1, ll_sw0_irq
+		andi	t1, t0, STATUSF_IP1	/* sw1 software interrupt */
+		bnez	t1, ll_sw1_irq
+		andi	t1, t0, STATUSF_IP3	/* int1 hardware line */
+		bnez	t1, ll_xilinx_irq
+
+		.set	reorder
+
+		/* wrong alarm or masked ... */
+		j	spurious_interrupt
+		nop
+		END(big_sur_handle_int)
+
+		.align	5
+ll_sw0_irq:
+		li	a0, 0
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+ll_sw1_irq:
+		li	a0, 1
+		move	a1, sp
+		jal	do_IRQ
+		j	ret_from_irq
+ll_xilinx_irq:
+		li	a0, 2
+		move	a1, sp
+		jal	big_sur_irq_handler
+		j	ret_from_irq
+		
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/irq.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/irq.c
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/irq.c	2004-04-21 02:19:18.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <asm/bootinfo.h>
+#include <asm/mipsregs.h>
+
+static spinlock_t irq_lock = SPIN_LOCK_UNLOCKED;
+
+extern asmlinkage void big_sur_handle_int(void);
+extern void big_sur_irq_init(void);
+
+void __init init_IRQ(void)
+{
+	/*
+	 * Clear all of the interrupts while we change the able around a bit.
+	 * int-handler is not on bootstrap
+	 */
+	clear_c0_status(ST0_IM);
+
+	/* Sets the first-level interrupt dispatcher. */
+	set_except_vector(0, big_sur_handle_int);
+	init_generic_irq();
+
+	mips_cpu_irq_init(0);
+	big_sur_irq_init();
+
+#ifdef CONFIG_REMOTE_DEBUG
+	printk("start kgdb ...\n");
+	set_debug_traps();
+	breakpoint();	/* you may move this line to whereever you want :-) */
+#endif
+#ifdef CONFIG_GDB_CONSOLE
+	register_gdb_console();
+#endif
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/prom.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/prom.c
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/prom.c	2004-05-27 23:25:22.000000000 +0200
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2004 PMC-Sierra Inc.
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+
+/* PMON Call Vectors */
+struct callvectors {
+int	(*open) (char*, int, int);
+int	(*close) (int);
+int	(*read) (int, void*, int);
+int	(*write) (int, void*, int);
+off_t	(*lseek) (int, off_t, int);
+int	(*printf) (const char*, ...);
+void	(*cacheflush) (void);
+char*	(*gets) (char*);
+};
+
+struct callvectors* debug_vectors;
+char arcs_cmdline[CL_SIZE];
+extern unsigned long cpu_clock;
+unsigned char big_sur_mac_addr_base[6] = "00:11:22:33:44:aa";
+
+const char *get_system_type(void)
+{
+	return "Big Sur";
+}
+
+void __init prom_init(int argc, char **arg, char **env, struct callvectors *cv)
+{
+	int i;
+
+	debug_vectors = cv;
+
+	/* PMON args begin with a g that stands for go */
+	arcs_cmdline[0] = '\0';
+	for (i = 1; i < argc; i++) {
+		if (strlen(arcs_cmdline) + strlen(arg[i] + 1)
+			>= sizeof(arcs_cmdline))
+				break;
+
+		strcat(arcs_cmdline, arg[i]);
+		strcat(arcs_cmdline, " ");
+	}
+
+	while (*env) {
+		if (strncmp("cpuclock", *env, strlen("cpuclock")) == 0) {
+			cpu_clock = simple_strtol(*env + strlen("cpuclock="),
+						NULL, 10);
+		}
+		env++;
+	}
+
+	mips_machgroup = MACH_GROUP_PMC;
+	mips_machtype = MACH_PMC_BIG_SUR;
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
+
+void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
+{
+}
+	
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/reset.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/reset.c
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/reset.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/reset.c	2004-05-27 23:25:22.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2004 PMC-Sierra Inc.
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <asm/processor.h>
+
+void big_sur_restart(char *command)
+{
+	/* FIXME: For now, fail regardless */
+	printk(KERN_NOTICE "Watchdog reset failed\n");
+}
+
+void big_sur_halt(void)
+{
+	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
+	while (1)
+		__asm__(".set\tmips3\n\t"
+			"wait\n\t"
+			".set\tmips0");
+}
+
+void big_sur_power_off(void)
+{
+	big_sur_halt();
+}
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/setup.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/setup.c
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/setup.c	2004-05-27 23:25:22.000000000 +0200
@@ -0,0 +1,202 @@
+/*
+ * Copyright 2004 PMC-Sierra Inc.
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/irq.h>
+#include <linux/time.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <asm/irq.h>
+#include <asm/processor.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+#include <asm/addrspace.h>
+
+#include "setup.h"
+
+unsigned long cpu_clock;
+
+extern void big_sur_restart(char *command);
+extern void big_sur_halt(void);
+extern void big_sur_power_off(void);
+
+void __init bus_error_init(void)
+{
+	/* Do Nothing */
+}
+
+void big_sur_timer_setup(struct irqaction *irq)
+{
+	/* Rm7000 timer and not the Xilinx timer */
+	setup_irq(7, irq);
+}
+
+#define	EPOCH		2000
+#define	BCD_TO_BIN(val)	(((val)&15) + ((val)>>4)*10)
+#define	BIN_TO_BCD(val)	((((val)/10)<<4) + (val)%10)
+
+static int rtc_ds_get_time(void)
+{
+	unsigned int year, month, day, hour, minute, second;
+	unsigned int century;
+
+	BIG_SUR_RTC_WRITE(0x40, 0x7f8);
+
+	second = BCD_TO_BIN(BIG_SUR_RTC_READ(0x7f8 + 1) & 0x7f);
+	minute = BCD_TO_BIN(BIG_SUR_RTC_READ(0x7f8 + 2));
+	hour = BCD_TO_BIN(BIG_SUR_RTC_READ(0x7f8 + 3));
+	day = BCD_TO_BIN(BIG_SUR_RTC_READ(0x7f8 + 5));
+	month = BCD_TO_BIN(BIG_SUR_RTC_READ(0x7f8 + 6));
+	year = BCD_TO_BIN(BIG_SUR_RTC_READ(0x7f8 + 7));
+	century = BCD_TO_BIN(BIG_SUR_RTC_READ(0x7f8) & 0x3f);
+
+	BIG_SUR_RTC_WRITE(0, 0x7f8);
+	year += century * 100;
+
+	return mktime(year, month, day, hour, minute, second);
+}
+
+extern void to_tm(unsigned long tim, struct rtc_time * tm);
+
+static int rtc_ds_set_time(unsigned long t)
+{
+	struct rtc_time tm;
+	u8 year, month, day, hour, minute, second;
+	u8 cmos_year, cmos_month, cmos_day, cmos_hour, cmos_minute, cmos_second;
+	int cmos_century;
+
+	BIG_SUR_RTC_WRITE(0x40, 0x7f8);
+	cmos_second = (u8)(BIG_SUR_RTC_READ(0x7f8 + 1) & 0x7f);
+	cmos_minute = (u8)(BIG_SUR_RTC_READ(0x7f8 + 2));
+	cmos_hour = (u8)(BIG_SUR_RTC_READ(0x7f8 + 3));
+	cmos_day = (u8)(BIG_SUR_RTC_READ(0x7f8 + 4));
+	cmos_month = (u8)(BIG_SUR_RTC_READ(0x7f8 + 6));
+	cmos_year = (u8)(BIG_SUR_RTC_READ(0x7f8 + 7));
+	cmos_century = BIG_SUR_RTC_READ(0x7f8) & 0x3f;
+
+	BIG_SUR_RTC_WRITE(0x80, 0x7f8);
+
+	to_tm(t, &tm);
+	
+	year = BIN_TO_BCD(tm.tm_year - EPOCH);
+	if (year != cmos_year) {
+		BIG_SUR_RTC_WRITE(year, (0x7f8 + 7));
+	}
+
+	month = BIN_TO_BCD(tm.tm_mon);
+	if (month != (cmos_month & 0x1f)) {
+		BIG_SUR_RTC_WRITE((month & 0x1f) | (cmos_month & ~0x1f), (0x7f8 + 6));	
+	}
+
+	day = BIN_TO_BCD(tm.tm_mday);
+	if (day != cmos_day) {
+		BIG_SUR_RTC_WRITE(day, (0x7f8 + 5));
+	}
+
+	if (cmos_hour & 0x40) {
+		hour = 0x40;
+		if (tm.tm_hour > 12) {
+			hour |= 0x20 | (BIN_TO_BCD(hour - 12) & 0x1f);
+		}
+		else {
+			hour |= BIN_TO_BCD(tm.tm_hour);
+		}
+	}
+	else {
+		hour = BIN_TO_BCD(tm.tm_hour) & 0x3f;
+	}
+
+	if (hour != cmos_hour) {
+		BIG_SUR_RTC_WRITE(hour, (0x7f8 + 3));
+	}
+
+	minute = BIN_TO_BCD(tm.tm_min);
+	if (minute !=  cmos_minute) {
+		BIG_SUR_RTC_WRITE(minute, (0x7f8 + 2));
+	}
+
+	second = BIN_TO_BCD(tm.tm_sec);
+	if (second !=  cmos_second) {
+		BIG_SUR_RTC_WRITE(second, (0x7f8 + 1));
+	}
+
+	BIG_SUR_RTC_WRITE(cmos_century, 0x7f8);
+
+	return 0;
+}
+
+void rtc_init(void)
+{
+	u8 seconds;
+
+	/* set the function pointers */
+	rtc_get_time = rtc_ds_get_time;
+	rtc_set_time = rtc_ds_set_time;
+
+	BIG_SUR_RTC_WRITE(0x40, 0x7f8);
+	seconds = (u8)(BIG_SUR_RTC_READ(0x7f8 + 1) & 0x7f);
+	BIG_SUR_RTC_WRITE(0x80, 0x7f8);
+	BIG_SUR_RTC_WRITE(seconds, (0x7f8 + 1));
+	BIG_SUR_RTC_WRITE(0, 0x7f8);
+}
+
+void big_sur_time_init(void)
+{
+	mips_counter_frequency = cpu_clock / 2;
+	board_timer_setup = big_sur_timer_setup;
+
+	/* 
+	 * The RTC device off the Xilinx System Controller
+	 * is the DS1742
+	 */
+	
+	rtc_init();
+}
+
+void __init pmc_big_sur_setup(void)
+{
+	board_time_init = big_sur_time_init;
+
+	_machine_restart = big_sur_restart;
+	_machine_halt = big_sur_halt;
+	_machine_power_off = big_sur_power_off;
+
+	printk("PMC-Sierra Big Sur Board \n");
+
+	/* Add 256 MB. Thats all it can support */
+	add_memory_region(0x00000000, 0x10000000, BOOT_MEM_RAM);
+
+	/* Configure the IDE interface, if needed */
+#ifdef	CONFIG_BLK_DEV_IDE_BIG_SUR
+	/* 
+	 * ATA Timing register, sample IORDY. The device operates
+	 * in PIO 0 mode and the slave device is disabled
+	 */
+	*(volatile u_int32_t *)((KSEG1ADDR(0x1B300000)) + 0x40) = 0x2;
+#endif
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/big_sur/xilinx_irq.h linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/xilinx_irq.h
--- linux-2.4.27/arch/mips/pmc-sierra/big_sur/xilinx_irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/big_sur/xilinx_irq.h	2004-04-21 02:19:18.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2003 PMC-Sierra
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * Board specific definititions for the PMC-Sierra Big Sur
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __XILINX_IRQ_H__
+#define	__XILINX_IRQ_H__
+
+#define BIG_SUR_BASE	0xfb000000
+
+#define BIG_SUR_WRITE(ofs, data)	\
+	*(volatile u32 *)(BIG_SUR_BASE + ofs) = data
+
+#define BIG_SUR_READ(ofs)	*(volatile u32 *)(BIG_SUR_BASE + ofs)
+
+#define	BIG_SUR_INTERRUPT_MASK_1	0x0c00
+#define	BIG_SUR_INTERRUPT_STATUS_1	0x0d00
+#define	BIG_SUR_UART1_IRQ
+#define	BIG_SUR_UART2_IRQ
+#define	BIG_SUR_TIMER_IRQ
+#define	BIG_SUR_PCI_IRQ
+#define	BIG_SUR_IDE_IRQ
+
+#endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/yosemite/Makefile linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/Makefile
--- linux-2.4.27/arch/mips/pmc-sierra/yosemite/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/Makefile	2004-05-05 14:38:40.000000000 +0200
@@ -2,15 +2,13 @@
 # Makefile for the PMC-Sierra Titan 
 #
 
-.S.s:
-	$(CPP) $(CFLAGS) $< -o $*.s
-.S.o:
-	$(CC) $(CFLAGS) -c $< -o $*.o
+USE_STANDARD_AS_RULE := true
 
 O_TARGET:= titan.o
 
 obj-y    += irq-handler.o irq.o i2c-yosemite.o prom.o setup.o
 
+obj-$(CONFIG_KGDB)		+= dbg_io.o
 obj-$(CONFIG_PCI)		+= pci-irq.o pci.o
 obj-$(CONFIG_SMP)          	+= smp.o
 obj-$(CONFIG_HYPERTRANSPORT)	+= ht-irq.o ht.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/yosemite/dbg_io.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/dbg_io.c
--- linux-2.4.27/arch/mips/pmc-sierra/yosemite/dbg_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/dbg_io.c	2004-04-21 00:58:57.000000000 +0200
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2003 PMC-Sierra
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Support for KGDB for the Yosemite board. We make use of single serial
+ * port to be used for KGDB as well as console. The second serial port
+ * seems to be having a problem. Single IRQ is allocated for both the 
+ * ports. Hence, the interrupt routing code needs to figure out whether
+ * the interrupt came from channel A or B.
+ */
+
+#include <linux/config.h>
+
+#if defined(CONFIG_KGDB)
+#include <asm/serial.h>
+
+/*
+ * Baud rate, Parity, Data and Stop bit settings for the 
+ * serial port on the Yosemite. Note that the Early printk
+ * patch has been added. So, we should be all set to go
+ */
+#define	YOSEMITE_BAUD_2400	2400
+#define	YOSEMITE_BAUD_4800	4800
+#define	YOSEMITE_BAUD_9600	9600
+#define	YOSEMITE_BAUD_19200	19200
+#define	YOSEMITE_BAUD_38400	38400
+#define	YOSEMITE_BAUD_57600	57600
+#define	YOSEMITE_BAUD_115200	115200
+
+#define	YOSEMITE_PARITY_NONE	0
+#define	YOSEMITE_PARITY_ODD	0x08
+#define	YOSEMITE_PARITY_EVEN	0x18
+#define	YOSEMITE_PARITY_MARK	0x28
+#define	YOSEMITE_PARITY_SPACE	0x38
+
+#define	YOSEMITE_DATA_5BIT	0x0
+#define	YOSEMITE_DATA_6BIT	0x1
+#define	YOSEMITE_DATA_7BIT	0x2
+#define	YOSEMITE_DATA_8BIT	0x3
+
+#define	YOSEMITE_STOP_1BIT	0x0
+#define	YOSEMITE_STOP_2BIT	0x4
+
+/* This is crucial */
+#define	SERIAL_REG_OFS		0x1
+
+#define	SERIAL_RCV_BUFFER	0x0
+#define	SERIAL_TRANS_HOLD	0x0
+#define	SERIAL_SEND_BUFFER	0x0
+#define	SERIAL_INTR_ENABLE	(1 * SERIAL_REG_OFS)
+#define	SERIAL_INTR_ID		(2 * SERIAL_REG_OFS)
+#define	SERIAL_DATA_FORMAT	(3 * SERIAL_REG_OFS)
+#define	SERIAL_LINE_CONTROL	(3 * SERIAL_REG_OFS)
+#define	SERIAL_MODEM_CONTROL	(4 * SERIAL_REG_OFS)
+#define	SERIAL_RS232_OUTPUT	(4 * SERIAL_REG_OFS)
+#define	SERIAL_LINE_STATUS	(5 * SERIAL_REG_OFS)
+#define	SERIAL_MODEM_STATUS	(6 * SERIAL_REG_OFS)
+#define	SERIAL_RS232_INPUT	(6 * SERIAL_REG_OFS)
+#define	SERIAL_SCRATCH_PAD	(7 * SERIAL_REG_OFS)
+
+#define	SERIAL_DIVISOR_LSB	(0 * SERIAL_REG_OFS)
+#define	SERIAL_DIVISOR_MSB	(1 * SERIAL_REG_OFS)
+
+/*
+ * Functions to READ and WRITE to serial port 0
+ */
+#define	SERIAL_READ(ofs)		(*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE + ofs)))
+
+#define	SERIAL_WRITE(ofs, val)		((*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE + ofs))) = val)
+
+/*
+ * Functions to READ and WRITE to serial port 1
+ */
+#define	SERIAL_READ_1(ofs)		(*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE_1 + ofs)
+
+#define	SERIAL_WRITE_1(ofs, val)	((*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE_1 + ofs))) = val)
+
+/*
+ * Second serial port initialization
+ */
+void init_second_port(void)
+{
+	/* Disable Interrupts */
+	SERIAL_WRITE_1(SERIAL_LINE_CONTROL, 0x0);
+	SERIAL_WRITE_1(SERIAL_INTR_ENABLE, 0x0);
+
+	{
+		unsigned int divisor;
+
+		SERIAL_WRITE_1(SERIAL_LINE_CONTROL, 0x80);
+		divisor = TITAN_SERIAL_BASE_BAUD / YOSEMITE_BAUD_115200;
+		SERIAL_WRITE_1(SERIAL_DIVISOR_LSB, divisor & 0xff);
+
+		SERIAL_WRITE_1(SERIAL_DIVISOR_MSB, (divisor & 0xff00) >> 8);
+		SERIAL_WRITE_1(SERIAL_LINE_CONTROL, 0x0);
+	}
+
+	SERIAL_WRITE_1(SERIAL_DATA_FORMAT, YOSEMITE_DATA_8BIT | 
+					   YOSEMITE_PARITY_NONE | 
+					   YOSEMITE_STOP_1BIT);
+
+	/* Enable Interrupts */
+	SERIAL_WRITE_1(SERIAL_INTR_ENABLE, 0xf);
+}
+
+/* Initialize the serial port for KGDB debugging */
+void debugInit(unsigned int baud, unsigned char data, unsigned char parity, 
+		unsigned char stop)
+{
+	/* Disable Interrupts */
+	SERIAL_WRITE(SERIAL_LINE_CONTROL, 0x0);
+	SERIAL_WRITE(SERIAL_INTR_ENABLE, 0x0);
+
+	{
+		unsigned int divisor;
+
+		SERIAL_WRITE(SERIAL_LINE_CONTROL, 0x80);
+
+		divisor = TITAN_SERIAL_BASE_BAUD / baud;
+		SERIAL_WRITE(SERIAL_DIVISOR_LSB, divisor & 0xff);
+
+		SERIAL_WRITE(SERIAL_DIVISOR_MSB, (divisor & 0xff00) >> 8);
+		SERIAL_WRITE(SERIAL_LINE_CONTROL, 0x0);
+	}
+
+	SERIAL_WRITE(SERIAL_DATA_FORMAT, data | parity | stop);
+}
+
+static int remoteDebugInitialized = 0;
+
+unsigned char getDebugChar(void)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		debugInit(YOSEMITE_BAUD_115200,
+			  YOSEMITE_DATA_8BIT,
+			  YOSEMITE_PARITY_NONE, YOSEMITE_STOP_1BIT);
+	}
+
+	while ((SERIAL_READ(SERIAL_LINE_STATUS) & 0x1) == 0);
+	return SERIAL_READ(SERIAL_RCV_BUFFER);
+}
+
+int putDebugChar(unsigned char byte)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		debugInit(YOSEMITE_BAUD_115200,
+			  YOSEMITE_DATA_8BIT,
+			  YOSEMITE_PARITY_NONE, YOSEMITE_STOP_1BIT);
+	}
+
+	while((SERIAL_READ(SERIAL_LINE_STATUS) & 0x20) == 0);
+	SERIAL_WRITE(SERIAL_SEND_BUFFER, byte);
+
+	return 1;
+}
+#endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/yosemite/ht-irq.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/ht-irq.c
--- linux-2.4.27/arch/mips/pmc-sierra/yosemite/ht-irq.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/ht-irq.c	2004-03-04 02:18:40.000000000 +0100
@@ -23,30 +23,194 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+/*
+ * Currently there is support for:
+ *  Alliance Sipackets HT-PCI bridge
+ *  PLX HT-PCI bridge
+ *  Altera Hypertransport device
+ */
+
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
+#include <linux/version.h>
 #include <linux/init.h>
+#include <linux/pci_ids.h>
 #include <asm/pci.h>
 
+/* PLX Specific Defines */
+#ifdef CONFIG_PLX_HT_BRIDGE
+
+#define AMD_VENDOR_ID           0x1022
+#define AMD_DEVICE_ID           0x7450
+#define AMD_IOAPIC_ID           0x7451
+
+/* RDR Registers and Index */
+#define AMD_RDR_INDEX           0xb8
+#define AMD_RDR_VALUE           0xbc
+
+/* AMD RDR Index for INTX# */
+#define AMD_RDR_INTA            0x80100008
+#define AMD_RDR_INTB            0x80120008
+#define AMD_RDR_INTC            0x80140008
+#define AMD_RDR_INTD            0x80160008
+
+#endif
+
 /*
  * HT Bus fixup for the Titan
- * XXX IRQ values need to change based on the board layout
  */
 void __init titan_ht_pcibios_fixup_bus(struct pci_bus *bus)
 {
         struct pci_bus *current_bus = bus;
         struct pci_dev *devices;
         struct list_head *devices_link;
+	unsigned long cmd;
 
 	list_for_each(devices_link, &(current_bus->devices)) {
                 devices = pci_dev_b(devices_link);
                 if (devices == NULL)
                         continue;
-	}
 
+		/*
+		 * Set the device IRQ to 3. This coressponds to 
+		 * hardware interrupt line 0 and processor 
+		 * interrupt line 0
+		 */
+		devices->irq = 3;
+	}
 	/*
-	 * PLX and SPKT related changes go here
-	 */
+         * Turn on IO SPACE, MEM SPACE and BUS MASTER among
+         * other things
+         */
+
+	if (devices->vendor == PCI_VENDOR_ID_SIPACKETS) {
+
+		bus->ops->read_word(devices, PCI_COMMAND, &cmd);
+	        cmd |= 0x17;
+        	bus->ops->write_word(devices, PCI_COMMAND, cmd); 
+
+#ifdef CONFIG_SPKT_HT_BRIDGE
+		/*
+        	 * Configure the Block #0, #1, #2 and #3 
+		 * for interrupt routing
+        	 */
+		printk(KERN_INFO "Fixing SiPKT HT-PCI IOAPIC \n");
+
+#if 0 
+		/* Interrupt Routing Diagnostics */
+		bus->ops->write_byte(devices, 0xc2, 0x48); 
+#endif
+
+		/* 
+		 * The following are the config options:
+		 * Polarity is active low
+		 * Destination mode is logical
+		 * Destination processor is core 0
+		 * Message type is Fixed
+		 * Interrupt Vector configured to PIRQ 0
+		 */
+		bus->ops->write_dword(devices, 0xa0, 0xc0c1c0c0);
+		bus->ops->write_dword(devices, 0xa4, 0xc0c3c0c2);
+		bus->ops->write_dword(devices, 0xa8, 0xc0c1c0c0);
+		bus->ops->write_dword(devices, 0xac, 0xc0c3c0c2);
+		bus->ops->write_dword(devices, 0xb0, 0xc0c1c0c0);
+		bus->ops->write_dword(devices, 0xb4, 0xc0c3c0c2);
+		bus->ops->write_dword(devices, 0xb8, 0xc0c1c0c0);
+		bus->ops->write_dword(devices, 0xbc, 0xc0c3c0c2);
+
+		bus->ops->write_byte(devices, 0xc3, 0x47);
+		bus->ops->write_byte(devices, 0xc4, 0x47);
+		bus->ops->write_byte(devices, 0xc5, 0x47);
+		bus->ops->write_byte(devices, 0xc6, 0x47);
 
+		printk(KERN_ERR "Done configuring interrupts \n");
+
+#ifdef CONFIG_HT_LEVEL_TRIGGER
+		/*
+		 * Support for Level Triggered mode 
+		 */
+		bus->ops->write_dword(devices, 0xa0, 0xc0c5c0c4);
+		bus->ops->write_dword(devices, 0xa4, 0xc0c7c0c6);
+		bus->ops->write_dword(devices, 0xa8, 0xc0c5c0c4);
+		bus->ops->write_dword(devices, 0xaC, 0xc0c7c0c6);
+#endif
+		/* Set the cacheline size to 8 */
+		bus->ops->write_byte(devices, 0x0c, 0x08); 
+
+		/* Set the Prefetch related configuration */
+		bus->ops->write_dword(devices, 0x60, 0x0f3f0cff); 
+		bus->ops->read_dword(devices, 0x60, &cmd);
+
+		printk(KERN_ERR "Done configuring the Read Prefetch \n");
+#endif
+	
+#ifdef CONFIG_PLX_HT_BRIDGE
+		/*
+	         * For the HT-PCIX bridge, we need to make changes to
+        	 * the IO space limits. Note that this is valid only for
+	         * the AMD 7450 PLX bridge. Hence we need to compare with
+        	 * that
+	         */
+		if (devices->vendor == AMD_VENDOR_ID &&
+			devices->device == AMD_DEVICE_ID) {
+			printk(KERN_INFO "AMD HT-PCIX bridge found  ");
+
+			/*
+			 * These are the RDR (Redirection Registers) for the 
+			 * AMD 8131 IOAPIC
+			 */
+	
+			/* INTA# */
+			bus->ops->write_dword(devices, AMD_RDR_INDEX, AMD_RDR_INTA);
+			bus->ops->write_dword(devices, AMD_RDR_VALUE, 0xf8200140);
+
+			/* INTB# */
+			bus->ops->write_dword(devices, AMD_RDR_INDEX, AMD_RDR_INTB);
+			bus->ops->write_dword(devices, AMD_RDR_VALUE, 0xf8200140);
+
+			/* INTC# */
+			bus->ops->write_dword(devices, AMD_RDR_INDEX, AMD_RDR_INTC);
+			bus->ops->write_dword(devices, AMD_RDR_VALUE, 0xf8200140);
+
+			/* INTD# */
+			bus->ops->write_dword(devices, AMD_RDR_INDEX, AMD_RDR_INTD);
+			bus->ops->write_dword(devices, AMD_RDR_VALUE, 0xf8200140);
+
+			/* Enable the Prefetching, MRM and MRL */
+			bus->ops->read_dword(devices, 0x4c, &val);
+			val |= 0x00001dc0;
+			bus->ops->write_dword(devices, 0x4c, val);
+		}
+
+		if (devices->vendor == AMD_VENDOR_ID &&
+			devices->device == AMD_IOAPIC_ID) {
+			printk("AMD 8131 IO APIC Fixup \n");
+
+			/* Turn the IOAPIC ON */
+			bus->ops->write_dword(devices, 0x44, 0x00000003);
+		}
+#endif /* CONFIG_PLX_HT_BRIDGE */
+#ifdef CONFIG_ALTERA_HT_BRIDGE
+		if ( (devices->vendor == PCI_VENDOR_ID_ALTERA) &&
+			(devices->device == PCI_DEVICE_ID_ALTERA_HT_BRIDGE)) {
+			printk(KERN_INFO "Found an Altera HT device, fixing up \n");
+		}
+
+		/* Check if the Link Initialization completed successfully */
+		bus->ops->read_dword(devices, 0x44, &val);
+		if (!(val & 0x20))
+			printk(KERN_ERR "Link Initialization Error !! \n");
+#endif /* CONFIG_ALTERA_HT_BRIDGE */
+
+		/* enable master */
+		if (((current_bus->number != 0) && (current_bus->number != 1))
+				|| (PCI_SLOT(devices->devfn) != 0)) {
+			bus->ops->read_word(devices, PCI_COMMAND, &cmd);
+			cmd |= PCI_COMMAND_MASTER;
+			bus->ops->write_word(devices, PCI_COMMAND, cmd);
+		}
+
+	}
 }
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/yosemite/ht.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/ht.c
--- linux-2.4.27/arch/mips/pmc-sierra/yosemite/ht.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/ht.c	2004-03-04 02:18:40.000000000 +0100
@@ -28,6 +28,8 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/delay.h>
 #include <asm/pci.h>
 #include <asm/io.h>
 
@@ -36,7 +38,6 @@
 
 #ifdef CONFIG_HYPERTRANSPORT
 
-
 /*
  * This function check if the Hypertransport Link Initialization completed. If
  * it did, then proceed further with scanning bus #2
@@ -47,7 +48,6 @@ static __inline__ int check_titan_htlink
 
         val = *(volatile u_int32_t *)(RM9000x2_HTLINK_REG);
         if (val & 0x00000020)
-                /* HT Link Initialization completed */
                 return 1;
         else
                 return 0;
@@ -57,25 +57,41 @@ static int titan_ht_config_read_dword(st
                                              int offset, u32* val)
 {
         int dev, bus, func;
-        uint32_t address_reg, data_reg;
-        uint32_t address;
+        volatile uint32_t address;
+	unsigned long reg_data;
 
         bus = device->bus->number;
         dev = PCI_SLOT(device->devfn);
         func = PCI_FUNC(device->devfn);
 
-	/* XXX Need to change the Bus # */
-        if (bus > 2)
-                address = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |
-                                                        0x80000000 | 0x1;
-        else
-                address = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;
-
-        address_reg = RM9000x2_OCD_HTCFGA;
-        data_reg =  RM9000x2_OCD_HTCFGD;
+	if (bus != 0)
+		address = (bus << 16) | (dev << 11) | (func << 8) | 
+				(offset & 0xfc) | 0x80000000 | 0x1;
+	else
+		address = (bus << 16) | (dev << 11) | (func << 8) |
+				(offset & 0xfc) | 0x80000000;
+	
+	/*
+	 * RM9000 HT Errata: Issue back to back HT config
+	 * transcations. Issue a BIU sync before and 
+	 * after the HT cycle
+	 */
+
+	reg_data = *(volatile u_int32_t *)(0xfb0000f0);
+	reg_data |= 0x2;
+	*(volatile u_int32_t *)(0xfb0000f0) = reg_data;
+
+	udelay(30);
+
+	*(volatile u_int32_t *)(0xfb0006f8) = address;
+	*(val) = *(volatile u_int32_t *)(0xfb0006fc);
+
+	udelay(30);
+
+	reg_data = *(volatile u_int32_t *)(0xfb0000f0);
+        reg_data |= 0x2;
+        *(volatile u_int32_t *)(0xfb0000f0) = reg_data;
 
-        RM9K_WRITE(address_reg, address);
-        RM9K_READ(data_reg, val);
 
         return PCIBIOS_SUCCESSFUL;
 }
@@ -85,30 +101,25 @@ static int titan_ht_config_read_word(str
                                              int offset, u16* val)
 {
         int dev, bus, func;
-        uint32_t address_reg, data_reg;
-        uint32_t address;
+        volatile uint32_t address_reg, data_reg;
+        uint32_t address, *val1 = kmalloc(sizeof(uint32_t), GFP_KERNEL);
 
         bus = device->bus->number;
         dev = PCI_SLOT(device->devfn);
         func = PCI_FUNC(device->devfn);
 
-	/* XXX Need to change the Bus # */
-        if (bus > 2)
-                address = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |
-                                                0x80000000 | 0x1;
-        else
-                address = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;
+	address =  (bus << 16) | (dev << 11) | (func << 8) | 
+			(offset & 0xfc) | 0x80000000;
 
         address_reg = RM9000x2_OCD_HTCFGA;
         data_reg =  RM9000x2_OCD_HTCFGD;
 
+	titan_ht_config_read_dword(device, offset, val1);
+
         if ((offset & 0x3) == 0)
-                offset = 0x2;
+		*val = (*val1 & 0x0000ffff);
         else
-                offset = 0x0;
-
-        RM9K_WRITE(address_reg, address);
-        RM9K_READ_16(data_reg + offset, val);
+		*val = (*val1 & 0xffff0000) >> 16;
 
         return PCIBIOS_SUCCESSFUL;
 }
@@ -131,99 +142,103 @@ static int titan_ht_config_read_byte(str
                                              int offset, u8* val)
 {
         int dev, bus, func;
-        uint32_t address_reg, data_reg;
-        uint32_t address;
-        int offset1;
+        volatile uint32_t address_reg, data_reg;
+        uint32_t address, *val1 = kmalloc(sizeof(uint32_t), GFP_KERNEL);
 
         bus = device->bus->number;
         dev = PCI_SLOT(device->devfn);
         func = PCI_FUNC(device->devfn);
 
-	/* XXX Need to change the Bus # */
-        if (bus > 2)
-                address = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |
-                                                        0x80000000 | 0x1;
-        else
-                address = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;
+        address = (bus << 16) | (dev << 11) | (func << 8) | 
+			(offset & 0xfc) | 0x80000000;
 
         address_reg = RM9000x2_OCD_HTCFGA;
         data_reg =  RM9000x2_OCD_HTCFGD;
 
-        RM9K_WRITE(address_reg, address);
+	titan_ht_config_read_dword(device, offset, val1);
 
         if ((offset & 0x3) == 0) {
-                offset1 = 0x3;
+		*val = (*val1 & 0x000000ff);
         }
         if ((offset & 0x3) == 1) {
-                offset1 = 0x2;
+		*val = ((*val1 & 0x0000ff00) >> 8);
         }
         if ((offset & 0x3) == 2) {
-                offset1 = 0x1;
+		*val = ((*val1 & 0x00ff0000) >> 16);
         }
         if ((offset & 0x3) == 3) {
-                offset1 = 0x0;
-        }
-        RM9K_READ_8(data_reg + offset1, val);
+		*val = ((*val1 & 0xff000000) >> 24);
+        } 
 
         return PCIBIOS_SUCCESSFUL;
 }
 
 
 static int titan_ht_config_write_dword(struct pci_dev *device,
-                                             int offset, u8 val)
+                                             int offset, u32 val)
 {
         int dev, bus, func;
-        uint32_t address_reg, data_reg;
-        uint32_t address;
+        volatile uint32_t address;
+	unsigned long reg_data;
 
         bus = device->bus->number;
         dev = PCI_SLOT(device->devfn);
         func = PCI_FUNC(device->devfn);
 
-	/* XXX Need to change the Bus # */
-        if (bus > 2)
-                address = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |
-                                                        0x80000000 | 0x1;
-        else
-              address = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;
-
-        address_reg = RM9000x2_OCD_HTCFGA;
-        data_reg =  RM9000x2_OCD_HTCFGD;
-
-        RM9K_WRITE(address_reg, address);
-        RM9K_WRITE(data_reg, val);
+	if (bus != 0)        
+		address = (bus << 16) | (dev << 11) | (func << 8) | 
+				(offset & 0xfc) | 0x80000000 | 0x1;
+	else
+		address = (bus << 16) | (dev << 11) | (func << 8) |
+				(offset & 0xfc) | 0x80000000;
+
+	reg_data = *(volatile u_int32_t *)(0xfb0000f0);
+        reg_data |= 0x2;
+        *(volatile u_int32_t *)(0xfb0000f0) = reg_data;
+	
+	udelay(30);
+
+	*(volatile u_int32_t *)(0xfb0006f8) = address;
+        *(volatile u_int32_t *)(0xfb0006fc) = val;
+
+	udelay(30);
+
+	reg_data = *(volatile u_int32_t *)(0xfb0000f0);
+        reg_data |= 0x2;
+        *(volatile u_int32_t *)(0xfb0000f0) = reg_data;
 
         return PCIBIOS_SUCCESSFUL;
 }
 
 static int titan_ht_config_write_word(struct pci_dev *device,
-                                             int offset, u8 val)
+                                             int offset, u16 val)
 {
         int dev, bus, func;
-        uint32_t address_reg, data_reg;
-        uint32_t address;
+        volatile uint32_t address_reg, data_reg;
+        uint32_t address, val1, val2;
 
         bus = device->bus->number;
         dev = PCI_SLOT(device->devfn);
         func = PCI_FUNC(device->devfn);
 
-	/* XXX Need to change the Bus # */
-        if (bus > 2)
-                address = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |
-                                0x80000000 | 0x1;
-        else
-                address = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;
+        address = (bus << 16) | (dev << 11) | (func << 8) | 
+			(offset & 0xfc) | 0x80000000;
 
         address_reg = RM9000x2_OCD_HTCFGA;
         data_reg =  RM9000x2_OCD_HTCFGD;
 
-        if ((offset & 0x3) == 0)
-                offset = 0x2;
-        else
-                offset = 0x0;
+	titan_ht_config_read_dword(device, offset, &val2);
+
+        if ((offset & 0x3) == 0) {
+		val2 = ( (val2 & ~(0x0000ffff)) | val);
+	}
+	else {
+		val1 = val;
+		val1 = (val1 << 16);
+		val2 = ( (val2 & ~(0xffff0000)) | val1);
+	}
 
-        RM9K_WRITE(address_reg, address);
-        RM9K_WRITE_16(data_reg + offset, val);
+	titan_ht_config_write_dword(device, offset, val2);
 
         return PCIBIOS_SUCCESSFUL;
 }
@@ -232,44 +247,49 @@ static int titan_ht_config_write_byte(st
                                              int offset, u8 val)
 {
         int dev, bus, func;
-        uint32_t address_reg, data_reg;
-        uint32_t address;
+        volatile uint32_t address_reg, data_reg;
+        uint32_t address, val1, val2;
         int offset1;
 
         bus = device->bus->number;
         dev = PCI_SLOT(device->devfn);
         func = PCI_FUNC(device->devfn);
 
-	/* XXX Need to change the Bus # */
-        if (bus > 2)
-                address = (bus << 16) | (dev << 11) | (func << 8) | (offset & 0xfc) |
-                                0x80000000 | 0x1;
-        else
-                address = (dev << 11) | (func << 8) | (offset & 0xfc) | 0x80000000;
+        address = (bus << 16) | (dev << 11) | (func << 8) | 
+			(offset & 0xfc) | 0x80000000;
 
         address_reg = RM9000x2_OCD_HTCFGA;
         data_reg =  RM9000x2_OCD_HTCFGD;
 
-        RM9K_WRITE(address_reg, address);
+	titan_ht_config_read_dword(device, offset, &val2);
 
         if ((offset & 0x3) == 0) {
-             offset1 = 0x3;
+		val1 = val;
+		val2 = ( (val2 & ~(0x000000ff)) | val1);
         }
         if ((offset & 0x3) == 1) {
-             offset1 = 0x2;
+		val1 = val;
+		val1 = val1 << 8;
+		val2 = ( (val2 & ~(0x0000ff00)) | val1);
         }
         if ((offset & 0x3) == 2) {
-             offset1 = 0x1;
+		val1 = val;
+		val1 = val1 << 16;
+		val2 = ( (val2 & ~(0x00ff0000)) | val1);
         }
         if ((offset & 0x3) == 3) {
-            offset1 = 0x0;
+		val1 = val;
+		val1 = val1 << 24;
+		val2 = ( (val2 & ~(0xff000000)) | val1);
         }
 
-        RM9K_WRITE_8(data_reg + offset1, val);
+	titan_ht_config_write_dword(device, offset, val2);
         return PCIBIOS_SUCCESSFUL;
 }
 
-
+/*
+ * Bus mastering capabilities for the HT device
+ */
 static void titan_pcibios_set_master(struct pci_dev *dev)
 {
         u16 cmd;
@@ -289,6 +309,7 @@ int pcibios_enable_resources(struct pci_
 {
         u16 cmd, old_cmd;
         u8 tmp1;
+	u32 reg_data;
         int idx;
         struct resource *r;
         int bus = dev->bus->number;
@@ -300,10 +321,11 @@ int pcibios_enable_resources(struct pci_
         for (idx = 0; idx < 6; idx++) {
                 r = &dev->resource[idx];
                 if (!r->start && r->end) {
+			printk("%x    %x \n", r->start,  r->end);
                         printk(KERN_ERR
                                "PCI: Device %s not available because of "
                                "resource collisions\n", dev->slot_name);
-                        return -EINVAL;
+			return -EINVAL;
                 }
                 if (r->flags & IORESOURCE_IO)
                         cmd |= PCI_COMMAND_IO;
@@ -346,8 +368,6 @@ int pcibios_enable_device(struct pci_dev
         return pcibios_enable_resources(dev);
 }
 
-
-
 void pcibios_update_resource(struct pci_dev *dev, struct resource *root,
                              struct resource *res, int resource)
 {
@@ -404,6 +424,9 @@ void pcibios_align_resource(void *data, 
         }
 }
 
+/*
+ * PCI structure
+ */
 struct pci_ops titan_pci_ops = {
         titan_ht_config_read_byte,
         titan_ht_config_read_word,
@@ -425,17 +448,20 @@ void __init pcibios_fixup_bus(struct pci
 
 void __init pcibios_init(void)
 {
+	/*
+	 * IO space accesses for the device
+	 */
+	set_io_port_base(KSEG1);
+
+	/* 
+	 * IO and MEM space values
+	 */
+	ioport_resource.start = 0xe0000000;
+        ioport_resource.end   = 0xe0000000 + 0x01000000 - 1;
+        iomem_resource.start  = 0xd0000000;
+        iomem_resource.end    = 0xd0000000 + 0x0f000000 - 1;
 
-        /* Reset PCI I/O and PCI MEM values */
-	/* XXX Need to add the proper values here */
-        ioport_resource.start = 0xe0000000;
-        ioport_resource.end   = 0xe0000000 + 0x20000000 - 1;
-        iomem_resource.start  = 0xc0000000;
-        iomem_resource.end    = 0xc0000000 + 0x20000000 - 1;
-
-	/* XXX Need to add bus values */
-        pci_scan_bus(2, &titan_pci_ops, NULL);
-        pci_scan_bus(3, &titan_pci_ops, NULL);
+        pci_scan_bus(0, &titan_pci_ops, NULL);
 }
 
 /*
@@ -444,15 +470,13 @@ void __init pcibios_init(void)
 char *pcibios_setup(char *str)
 {
         printk(KERN_INFO "rr: pcibios_setup\n");
-        /* Nothing to do for now.  */
 
         return str;
 }
 
 unsigned __init int pcibios_assign_all_busses(void)
 {
-        /* We want to use the PCI bus detection done by PMON */
-        return 0;
+        return 1;
 }
 
 #endif /* CONFIG_HYPERTRANSPORT */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/yosemite/irq-handler.S linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/irq-handler.S
--- linux-2.4.27/arch/mips/pmc-sierra/yosemite/irq-handler.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/irq-handler.S	2004-03-10 00:13:47.000000000 +0100
@@ -10,7 +10,6 @@
  * option) any later version.
  */
 
-#define __ASSEMBLY__
 #include <linux/config.h>
 #include <asm/asm.h>
 #include <asm/mipsregs.h>
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/pmc-sierra/yosemite/irq.c linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/irq.c
--- linux-2.4.27/arch/mips/pmc-sierra/yosemite/irq.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/pmc-sierra/yosemite/irq.c	2004-05-05 14:38:40.000000000 +0200
@@ -87,7 +87,7 @@ static inline void modify_cp0_intmask(un
         set_mask = 0xff & set_mask_in;
         status = read_c0_status();
         status &= ~((clr_mask & 0xFF) << 8);
-        status |= (set_mask & 0xFF) << 8 | 0x0000FF00;
+        status |= (set_mask & 0xFF) << 8;
         write_c0_status(status);
 
         /* do the high 8 bits */
@@ -96,6 +96,7 @@ static inline void modify_cp0_intmask(un
         status = read_32bit_cp0_set1_register(CP0_S1_INTCONTROL);
         status &= ~((clr_mask & 0xFF) << 8);
         status |= (set_mask & 0xFF) << 8;
+	status |= (1 << 13);
         write_32bit_cp0_set1_register(CP0_S1_INTCONTROL, status);
 }
 
@@ -224,6 +225,17 @@ done:
 		do_IRQ(irq, regs);	
 }
 
+static struct irqaction unused_irq =
+	{ no_action, SA_INTERRUPT, 0, "unused", NULL, NULL };
+
+extern unsigned long exception_handlers[32];
+
+#ifdef CONFIG_KGDB
+extern void init_second_port(void);
+extern void breakpoint(void);
+extern void set_debug_traps(void);
+#endif
+
 /*
  * Initialize the next level interrupt handler
  */
@@ -237,11 +249,37 @@ void __init init_IRQ(void)
 	set_except_vector(0, titan_handle_int);
 	init_generic_irq();
 
-	for (i = 0; i < 13; i++) {
+	for (i = 0; i < 12; i++) {
                 irq_desc[i].status      = IRQ_DISABLED;
                 irq_desc[i].action      = 0;
                 irq_desc[i].depth       = 1;
                 irq_desc[i].handler     = &rm9000_hpcdma_irq_type;
         }
+
+#ifdef CONFIG_KGDB
+	/* At this point, initialize the second serial port */
+	init_second_port();
+	printk("Start kgdb ... \n");
+	set_debug_traps();
+	breakpoint();
+#endif
+
+#ifdef CONFIG_GDB_CONSOLE
+	register_gdb_console();
+#endif
 }
 
+#ifdef CONFIG_KGDB
+/* 
+ * The 16550 DUART has two ports, but is allocated one IRQ 
+ * for the serial console. Hence, a generic framework for
+ * serial IRQ routing in place. Currently, just calls the 
+ * do_IRQ fuction. But, going in the future, need to check
+ * DUART registers for channel A and B, then decide the 
+ * appropriate action
+ */
+asmlinkage void yosemite_kgdb_irq(int irq, struct pt_regs *regs)
+{
+	do_IRQ(irq, regs);
+}
+#endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/ramdisk/Makefile linux-mips-cvs-20040815/arch/mips/ramdisk/Makefile
--- linux-2.4.27/arch/mips/ramdisk/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/ramdisk/Makefile	2004-08-15 08:05:49.000000000 +0200
@@ -10,6 +10,6 @@ O_FORMAT = $(shell $(OBJDUMP) -i | head 
 img = $(CONFIG_EMBEDDED_RAMDISK_IMAGE)
 ramdisk.o: $(subst ",,$(img)) ld.script
 	echo "O_FORMAT:  " $(O_FORMAT)
-	$(LD) -T ld.script -b binary --oformat $(O_FORMAT) -o $@ $(img)
+	$(LD) $(LDFLAGS) -T ld.script -b binary --oformat $(O_FORMAT) -o $@ $(img)
 
 include $(TOPDIR)/Rules.make
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/sgi-ip27/Makefile linux-mips-cvs-20040815/arch/mips/sgi-ip27/Makefile
--- linux-2.4.27/arch/mips/sgi-ip27/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/sgi-ip27/Makefile	2004-05-02 00:47:31.000000000 +0200
@@ -6,6 +6,8 @@ USE_STANDARD_AS_RULE := true
 
 O_TARGET = ip27.o
 
+export-objs := ip27-init.o ip27-memory.o
+
 obj-y	:= ip27-berr.o ip27-console.o ip27-irq.o ip27-init.o ip27-irq-glue.o \
 	   ip27-klconfig.o ip27-klnuma.o ip27-memory.o ip27-nmi.o ip27-pci.o \
 	   ip27-reset.o ip27-setup.o ip27-timer.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/sgi-ip27/ip27-init.c linux-mips-cvs-20040815/arch/mips/sgi-ip27/ip27-init.c
--- linux-2.4.27/arch/mips/sgi-ip27/ip27-init.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/sgi-ip27/ip27-init.c	2004-05-02 00:47:31.000000000 +0200
@@ -13,6 +13,8 @@
 #include <linux/sched.h>
 #include <linux/mmzone.h>	/* for numnodes */
 #include <linux/mm.h>
+#include <linux/module.h>
+
 #include <asm/cpu.h>
 #include <asm/pgalloc.h>
 #include <asm/pgtable.h>
@@ -55,11 +57,15 @@ static atomic_t numstarted = ATOMIC_INIT
 static int router_distance;
 nasid_t master_nasid = INVALID_NASID;
 
+EXPORT_SYMBOL(master_nasid);
+
 cnodeid_t	nasid_to_compact_node[MAX_NASIDS];
 nasid_t		compact_to_nasid_node[MAX_COMPACT_NODES];
 cnodeid_t	cpuid_to_compact_node[MAXCPUS];
 char		node_distances[MAX_COMPACT_NODES][MAX_COMPACT_NODES];
 
+EXPORT_SYMBOL(nasid_to_compact_node);
+
 hubreg_t get_region(cnodeid_t cnode)
 {
 	if (fine_mode)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/sgi-ip27/ip27-memory.c linux-mips-cvs-20040815/arch/mips/sgi-ip27/ip27-memory.c
--- linux-2.4.27/arch/mips/sgi-ip27/ip27-memory.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/sgi-ip27/ip27-memory.c	2004-05-02 00:47:31.000000000 +0200
@@ -15,6 +15,7 @@
 #include <linux/mm.h>
 #include <linux/bootmem.h>
 #include <linux/swap.h>
+#include <linux/module.h>
 
 #include <asm/page.h>
 #include <asm/bootinfo.h>
@@ -40,6 +41,8 @@ static pfn_t numpages;
 plat_pg_data_t *plat_node_data[MAX_COMPACT_NODES];
 bootmem_data_t plat_node_bdata[MAX_COMPACT_NODES];
 
+EXPORT_SYMBOL(plat_node_data);
+
 int numa_debug(void)
 {
 	printk("NUMA debug\n");
@@ -47,6 +50,8 @@ int numa_debug(void)
 	return(0);
 }
 
+EXPORT_SYMBOL(numa_debug);
+
 /*
  * Return the number of pages of memory provided by the given slot
  * on the specified node.
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/sgi-ip27/ip27-timer.c linux-mips-cvs-20040815/arch/mips/sgi-ip27/ip27-timer.c
--- linux-2.4.27/arch/mips/sgi-ip27/ip27-timer.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/sgi-ip27/ip27-timer.c	2004-05-02 00:47:31.000000000 +0200
@@ -51,9 +51,8 @@ static int set_rtc_mmss(unsigned long no
 	struct m48t35_rtc *rtc;
 	nasid_t nid;
 
-	nid = get_nasid();
-	rtc = (struct m48t35_rtc *)(KL_CONFIG_CH_CONS_INFO(nid)->memory_base +
-							IOC3_BYTEBUS_DEV0);
+	rtc = (struct m48t35_rtc *)
+	(KL_CONFIG_CH_CONS_INFO(master_nasid)->memory_base + IOC3_BYTEBUS_DEV0);
 
 	spin_lock(&rtc_lock);
 	rtc->control |= M48T35_RTC_READ;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/sibyte/cfe/smp.c linux-mips-cvs-20040815/arch/mips/sibyte/cfe/smp.c
--- linux-2.4.27/arch/mips/sibyte/cfe/smp.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/sibyte/cfe/smp.c	2004-05-02 00:47:31.000000000 +0200
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
+ * Copyright (C) 2004  Maciej W. Rozycki
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -26,7 +27,7 @@
 
 /* Boot all other cpus in the system, initialize them, and
    bring them into the boot fn */
-void prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp)
+int prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp)
 {
 	int retval;
 	
@@ -34,6 +35,8 @@ void prom_boot_secondary(int cpu, unsign
 	if (retval != 0) {
 		printk("cfe_start_cpu(%i) returned %i\n" , cpu, retval);
 	}
+
+	return retval;
 }
 
 void prom_init_secondary(void)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/sibyte/sb1250/irq_handler.S linux-mips-cvs-20040815/arch/mips/sibyte/sb1250/irq_handler.S
--- linux-2.4.27/arch/mips/sibyte/sb1250/irq_handler.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/sibyte/sb1250/irq_handler.S	2004-08-15 08:05:51.000000000 +0200
@@ -125,7 +125,7 @@
 	 * check the 1250 interrupt registers to figure out what to do
 	 * Need to detect which CPU we're on, now that smp_affinity is supported.
 	 */
-	la	v0, KSEG1 + A_IMR_CPU0_BASE
+	PTR_LA	v0, KSEG1 + A_IMR_CPU0_BASE
 #ifdef CONFIG_SMP
 	lw	t1, TASK_PROCESSOR($28)
 	sll	t1, IMR_REGISTER_SPACING_SHIFT
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/sibyte/sb1250/smp.c linux-mips-cvs-20040815/arch/mips/sibyte/sb1250/smp.c
--- linux-2.4.27/arch/mips/sibyte/sb1250/smp.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/sibyte/sb1250/smp.c	2004-05-02 00:47:31.000000000 +0200
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2001 Broadcom Corporation
+ * Copyright (C) 2004  Maciej W. Rozycki
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -138,7 +139,7 @@ void __init smp_boot_cpus(void)
 	 * This loop attempts to compensate for "holes" in the CPU
 	 * numbering.  It's overkill, but general.
 	 */
-	for (i = 1; i < smp_num_cpus; ) {
+	for (i = 1; i < smp_num_cpus && cur_cpu < NR_CPUS; i++) {
 		struct task_struct *p;
 		struct pt_regs regs;
 		printk("Starting CPU %d... ", i);
@@ -158,15 +159,20 @@ void __init smp_boot_cpus(void)
 		unhash_process(p);
 
 		do {
+			int status;
+
 			/* Iterate until we find a CPU that comes up */
 			cur_cpu++;
-			prom_boot_secondary(cur_cpu,
-					    (unsigned long)p + KERNEL_STACK_SIZE - 32,
-					    (unsigned long)p);
+			status = prom_boot_secondary(cur_cpu,
+						    (unsigned long)p +
+						    KERNEL_STACK_SIZE - 32,
+						    (unsigned long)p);
+			if (status == 0) {
+				__cpu_number_map[cur_cpu] = i;
+				__cpu_logical_map[i] = cur_cpu;
+				break;
+			}
 		} while (cur_cpu < NR_CPUS);
-		__cpu_number_map[cur_cpu] = i;
-		__cpu_logical_map[i] = cur_cpu;
-		i++;
 	}
 
 	/* Wait for everyone to come up */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/casio-e55/ide-e55.c linux-mips-cvs-20040815/arch/mips/vr41xx/casio-e55/ide-e55.c
--- linux-2.4.27/arch/mips/vr41xx/casio-e55/ide-e55.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/casio-e55/ide-e55.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * IDE routines for typical pc-like standard configurations
- * for the CASIO CASSIOPEIA E-55/65.
- *
- * Copyright (C) 1998, 1999, 2001 by Ralf Baechle
- */
-/*
- * Changes:
- *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>  Sun, 24 Feb 2002
- *  - Added CASIO CASSIOPEIA E-55/65 support.
- */
-#include <linux/sched.h>
-#include <linux/ide.h>
-#include <linux/ioport.h>
-#include <linux/hdreg.h>
-#include <asm/ptrace.h>
-#include <asm/hdreg.h>
-
-static int e55_ide_default_irq(ide_ioreg_t base)
-{
-	return 40;
-}
-
-static ide_ioreg_t e55_ide_default_io_base(int index)
-{
-	switch (index) {
-		case 0: return 0xc1f0;
-		case 1: return 0xc170;
-		case 2: return 0xc1e8;
-		case 3: return 0xc168;
-		case 4: return 0xc1e0;
-		case 5: return 0xc160;
-	}
-	return 0;
-}
-
-static void e55_ide_init_hwif_ports(hw_regs_t *hw, ide_ioreg_t data_port,
-                                    ide_ioreg_t ctrl_port, int *irq)
-{
-	ide_ioreg_t reg = data_port;
-	int i;
-
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw->io_ports[i] = reg;
-		reg += 1;
-	}
-	if (ctrl_port) {
-		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
-	} else {
-		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
-	}
-	if (irq != NULL)
-		*irq = 0;
-	hw->io_ports[IDE_IRQ_OFFSET] = 0;
-}
-
-static int e55_ide_request_irq(unsigned int irq,
-                               void (*handler)(int,void *, struct pt_regs *),
-                               unsigned long flags, const char *device,
-                               void *dev_id)
-{
-	return request_irq(irq, handler, flags, device, dev_id);
-}			
-
-static void e55_ide_free_irq(unsigned int irq, void *dev_id)
-{
-	free_irq(irq, dev_id);
-}
-
-static int e55_ide_check_region(ide_ioreg_t from, unsigned int extent)
-{
-	return check_region(from, extent);
-}
-
-static void e55_ide_request_region(ide_ioreg_t from, unsigned int extent,
-                                   const char *name)
-{
-	request_region(from, extent, name);
-}
-
-static void e55_ide_release_region(ide_ioreg_t from, unsigned int extent)
-{
-	release_region(from, extent);
-}
-
-struct ide_ops e55_ide_ops = {
-	&e55_ide_default_irq,
-	&e55_ide_default_io_base,
-	&e55_ide_init_hwif_ports,
-	&e55_ide_request_irq,
-	&e55_ide_free_irq,
-	&e55_ide_check_region,
-	&e55_ide_request_region,
-	&e55_ide_release_region
-};
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/casio-e55/setup.c linux-mips-cvs-20040815/arch/mips/vr41xx/casio-e55/setup.c
--- linux-2.4.27/arch/mips/vr41xx/casio-e55/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/casio-e55/setup.c	2004-02-13 18:22:22.000000000 +0100
@@ -1,33 +1,31 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/casio-e55/setup.c
+ *  setup.c, Setup for the CASIO CASSIOPEIA E-11/15/55/65.
  *
- * BRIEF MODULE DESCRIPTION
- *	Setup for the CASIO CASSIOPEIA E-11/15/55/65.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/init.h>
 #include <linux/console.h>
 #include <linux/ide.h>
+#include <linux/init.h>
 #include <linux/ioport.h>
 
-#include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/vr41xx/e55.h>
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern unsigned long initrd_start, initrd_end;
-extern void * __rd_start, * __rd_end;
-#endif
-
 void __init casio_e55_setup(void)
 {
 	set_io_port_base(IO_PORT_BASE);
@@ -36,16 +34,6 @@ void __init casio_e55_setup(void)
 	iomem_resource.start = IO_MEM_RESOURCE_START;
 	iomem_resource.end = IO_MEM_RESOURCE_END;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	initrd_start = (unsigned long)&__rd_start;
-	initrd_end = (unsigned long)&__rd_end;
-#endif
-
-	_machine_restart = vr41xx_restart;
-	_machine_halt = vr41xx_halt;
-	_machine_power_off = vr41xx_power_off;
-
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
 
@@ -58,8 +46,10 @@ void __init casio_e55_setup(void)
 #endif
 
 	vr41xx_bcu_init();
-
 	vr41xx_cmu_init();
+	vr41xx_pmu_init();
 
+#ifdef CONFIG_SERIAL
 	vr41xx_siu_init(SIU_RS232C, 0);
+#endif
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/Makefile linux-mips-cvs-20040815/arch/mips/vr41xx/common/Makefile
--- linux-2.4.27/arch/mips/vr41xx/common/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/Makefile	2004-02-13 18:22:22.000000000 +0100
@@ -12,7 +12,7 @@ all: vr41xx.o
 
 O_TARGET := vr41xx.o
 
-obj-y := bcu.o cmu.o giu.o icu.o int-handler.o ksyms.o reset.o rtc.o
+obj-y := bcu.o cmu.o giu.o icu.o int-handler.o ksyms.o pmu.o rtc.o
 
 export-objs := ksyms.o vrc4171.o vrc4173.o
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/cmu.c linux-mips-cvs-20040815/arch/mips/vr41xx/common/cmu.c
--- linux-2.4.27/arch/mips/vr41xx/common/cmu.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/cmu.c	2004-02-17 13:08:55.000000000 +0100
@@ -40,6 +40,7 @@
  *  - Added support for NEC VR4133.
  */
 #include <linux/init.h>
+#include <linux/spinlock.h>
 #include <linux/types.h>
 
 #include <asm/cpu.h>
@@ -66,16 +67,19 @@
  #define MSKMAC0	0x0002
  #define MSKMAC1	0x0004
 
-static u32 vr41xx_cmu_base;
-static u16 cmuclkmsk, cmuclkmsk2;
+static uint32_t cmu_base;
+static uint16_t cmuclkmsk, cmuclkmsk2;
+static spinlock_t cmu_lock;
 
-#define read_cmuclkmsk()	readw(vr41xx_cmu_base)
+#define read_cmuclkmsk()	readw(cmu_base)
 #define read_cmuclkmsk2()	readw(CMUCLKMSK2)
-#define write_cmuclkmsk()	writew(cmuclkmsk, vr41xx_cmu_base)
+#define write_cmuclkmsk()	writew(cmuclkmsk, cmu_base)
 #define write_cmuclkmsk2()	writew(cmuclkmsk2, CMUCLKMSK2)
 
-void vr41xx_clock_supply(unsigned int clock)
+void vr41xx_supply_clock(unsigned int clock)
 {
+	spin_lock_irq(&cmu_lock);
+
 	switch (clock) {
 	case PIU_CLOCK:
 		cmuclkmsk |= MSKPIU;
@@ -129,10 +133,14 @@ void vr41xx_clock_supply(unsigned int cl
 		write_cmuclkmsk2();
 	else
 		write_cmuclkmsk();
+
+	spin_unlock_irq(&cmu_lock);
 }
 
-void vr41xx_clock_mask(unsigned int clock)
+void vr41xx_mask_clock(unsigned int clock)
 {
+	spin_lock_irq(&cmu_lock);
+
 	switch (clock) {
 	case PIU_CLOCK:
 		cmuclkmsk &= ~MSKPIU;
@@ -198,6 +206,8 @@ void vr41xx_clock_mask(unsigned int cloc
 		write_cmuclkmsk2();
 	else
 		write_cmuclkmsk();
+
+	spin_unlock_irq(&cmu_lock);
 }
 
 void __init vr41xx_cmu_init(void)
@@ -205,14 +215,14 @@ void __init vr41xx_cmu_init(void)
 	switch (current_cpu_data.cputype) {
         case CPU_VR4111:
         case CPU_VR4121:
-                vr41xx_cmu_base = CMUCLKMSK_TYPE1;
+                cmu_base = CMUCLKMSK_TYPE1;
                 break;
         case CPU_VR4122:
         case CPU_VR4131:
-                vr41xx_cmu_base = CMUCLKMSK_TYPE2;
+                cmu_base = CMUCLKMSK_TYPE2;
                 break;
         case CPU_VR4133:
-                vr41xx_cmu_base = CMUCLKMSK_TYPE2;
+                cmu_base = CMUCLKMSK_TYPE2;
 		cmuclkmsk2 = read_cmuclkmsk2();
                 break;
 	default:
@@ -221,4 +231,6 @@ void __init vr41xx_cmu_init(void)
         }
 
 	cmuclkmsk = read_cmuclkmsk();
+
+	spin_lock_init(&cmu_lock);
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/ksyms.c linux-mips-cvs-20040815/arch/mips/vr41xx/common/ksyms.c
--- linux-2.4.27/arch/mips/vr41xx/common/ksyms.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/ksyms.c	2004-02-17 13:08:55.000000000 +0100
@@ -25,6 +25,9 @@
 EXPORT_SYMBOL(vr41xx_get_vtclock_frequency);
 EXPORT_SYMBOL(vr41xx_get_tclock_frequency);
 
+EXPORT_SYMBOL(vr41xx_supply_clock);
+EXPORT_SYMBOL(vr41xx_mask_clock);
+
 EXPORT_SYMBOL(vr41xx_set_intassign);
 
 EXPORT_SYMBOL(vr41xx_set_rtclong1_cycle);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/pciu.c linux-mips-cvs-20040815/arch/mips/vr41xx/common/pciu.c
--- linux-2.4.27/arch/mips/vr41xx/common/pciu.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/pciu.c	2004-02-17 13:08:55.000000000 +0100
@@ -1,40 +1,17 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/common/pciu.c
+ * arch/mips/vr41xx/common/pciu.c
  *
- * BRIEF MODULE DESCRIPTION
- *	PCI Control Unit routines for the NEC VR4100 series.
+ * PCI Control Unit routines for the NEC VR4100 series.
  *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
  *
- * Copyright 2001,2002 MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * 2001-2003 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
  */
 /*
  * Changes:
- *  Paul Mundt <lethal@chaoticdreams.org>
- *  - Fix deadlock-causing PCIU access race for VR4131.
- *
  *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
  *  - New creation, NEC VR4122 and VR4131 are supported.
  */
@@ -42,7 +19,6 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/types.h>
-#include <linux/delay.h>
 
 #include <asm/cpu.h>
 #include <asm/io.h>
@@ -60,49 +36,48 @@ static inline int vr41xx_pci_config_acce
 		/*
 		 * Type 0 configuration
 		 */
-		if (PCI_SLOT(dev_fn) < 11 || PCI_SLOT(dev_fn) > 31 || where > 255)
-			return -1;
+		if (PCI_SLOT(dev_fn) < 11 || PCI_SLOT(dev_fn) > 31 || where > 0xff)
+			return -EINVAL;
 
-		writel((1UL << PCI_SLOT(dev_fn))|
+		writel((1U << PCI_SLOT(dev_fn))	|
 		       (PCI_FUNC(dev_fn) << 8)	|
 		       (where & 0xfc),
 		       PCICONFAREG);
-	}
-	else {
+	} else {
 		/*
 		 * Type 1 configuration
 		 */
-		if (PCI_SLOT(dev_fn) > 31 || where > 255)
-			return -1;
+		if (PCI_SLOT(dev_fn) > 31 || where > 0xff)
+			return -EINVAL;
 
 		writel((bus << 16)	|
 		       (dev_fn << 8)	|
 		       (where & 0xfc)	|
-		       1UL,
+		       1U,
 		       PCICONFAREG);
 	}
 
 	return 0;
 }
 
-static int vr41xx_pci_read_config_byte(struct pci_dev *dev, int where, u8 *val)
+static int vr41xx_pci_config_read_byte(struct pci_dev *dev, int where, uint8_t *val)
 {
-	u32 data;
+	uint32_t data;
 
 	*val = 0xff;
 	if (vr41xx_pci_config_access(dev, where) < 0)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	data = readl(PCICONFDREG);
-	*val = (u8)(data >> ((where & 3) << 3));
+	*val = (uint8_t)(data >> ((where & 3) << 3));
 
 	return PCIBIOS_SUCCESSFUL;
 
 }
 
-static int vr41xx_pci_read_config_word(struct pci_dev *dev, int where, u16 *val)
+static int vr41xx_pci_config_read_word(struct pci_dev *dev, int where, uint16_t *val)
 {
-	u32 data;
+	uint32_t data;
 
 	*val = 0xffff;
 	if (where & 1)
@@ -112,12 +87,12 @@ static int vr41xx_pci_read_config_word(s
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	data = readl(PCICONFDREG);
-	*val = (u16)(data >> ((where & 2) << 3));
+	*val = (uint16_t)(data >> ((where & 2) << 3));
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int vr41xx_pci_read_config_dword(struct pci_dev *dev, int where, u32 *val)
+static int vr41xx_pci_config_read_dword(struct pci_dev *dev, int where, uint32_t *val)
 {
 	*val = 0xffffffff;
 	if (where & 3)
@@ -131,9 +106,9 @@ static int vr41xx_pci_read_config_dword(
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int vr41xx_pci_write_config_byte(struct pci_dev *dev, int where, u8 val)
+static int vr41xx_pci_config_write_byte(struct pci_dev *dev, int where, uint8_t val)
 {
-	u32 data;
+	uint32_t data;
 	int shift;
 
 	if (vr41xx_pci_config_access(dev, where) < 0)
@@ -141,17 +116,16 @@ static int vr41xx_pci_write_config_byte(
 
 	data = readl(PCICONFDREG);
 	shift = (where & 3) << 3;
-	data &= ~(0xff << shift);
-	data |= (((u32)val) << shift);
-
+	data &= ~(0xffU << shift);
+	data |= (uint32_t)val << shift;
 	writel(data, PCICONFDREG);
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int vr41xx_pci_write_config_word(struct pci_dev *dev, int where, u16 val)
+static int vr41xx_pci_config_write_word(struct pci_dev *dev, int where, uint16_t val)
 {
-	u32 data;
+	uint32_t data;
 	int shift;
 
 	if (where & 1)
@@ -162,14 +136,14 @@ static int vr41xx_pci_write_config_word(
 
 	data = readl(PCICONFDREG);
 	shift = (where & 2) << 3;
-	data &= ~(0xffff << shift);
-	data |= (((u32)val) << shift);
+	data &= ~(0xffffU << shift);
+	data |= (uint32_t)val << shift;
 	writel(data, PCICONFDREG);
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int vr41xx_pci_write_config_dword(struct pci_dev *dev, int where, u32 val)
+static int vr41xx_pci_config_write_dword(struct pci_dev *dev, int where, uint32_t val)
 {
 	if (where & 3)
 		return PCIBIOS_BAD_REGISTER_NUMBER;
@@ -183,35 +157,32 @@ static int vr41xx_pci_write_config_dword
 }
 
 struct pci_ops vr41xx_pci_ops = {
-	vr41xx_pci_read_config_byte,
-	vr41xx_pci_read_config_word,
-	vr41xx_pci_read_config_dword,
-	vr41xx_pci_write_config_byte,
-	vr41xx_pci_write_config_word,
-	vr41xx_pci_write_config_dword
+	.read_byte	= vr41xx_pci_config_read_byte,
+	.read_word	= vr41xx_pci_config_read_word,
+	.read_dword	= vr41xx_pci_config_read_dword,
+	.write_byte	= vr41xx_pci_config_write_byte,
+	.write_word	= vr41xx_pci_config_write_word,
+	.write_dword	= vr41xx_pci_config_write_dword,
 };
 
 void __init vr41xx_pciu_init(struct vr41xx_pci_address_map *map)
 {
 	struct vr41xx_pci_address_space *s;
 	unsigned long vtclock;
-	u32 config;
-	int n;
+	uint32_t config;
 
-	if (!map)
+	if (map == NULL)
 		return;
 
 	/* Disable PCI interrupt */
 	writew(0, MPCIINTREG);
 
 	/* Supply VTClock to PCIU */
-	vr41xx_clock_supply(PCIU_CLOCK);
+	vr41xx_supply_clock(PCIU_CLOCK);
 
-	/*
-	 * Sleep for 1us after setting MSKPPCIU bit in CMUCLKMSK
-	 * before doing any PCIU access to avoid deadlock on VR4131.
-	 */
-	udelay(1);
+	/* Dummy read/write, waiting for supply of VTClock. */
+	readw(MPCIINTREG);
+	writew(0, MPCIINTREG);
 
 	/* Select PCI clock */
 	vtclock = vr41xx_get_vtclock_frequency();
@@ -225,7 +196,7 @@ void __init vr41xx_pciu_init(struct vr41
 		printk(KERN_INFO "Warning: PCI Clock is over 33MHz.\n");
 
 	/* Supply PCI clock by PCI bus */
-	vr41xx_clock_supply(PCI_CLOCK);
+	vr41xx_supply_clock(PCI_CLOCK);
 
 	/*
 	 * Set PCI memory & I/O space address conversion registers
@@ -233,48 +204,52 @@ void __init vr41xx_pciu_init(struct vr41
 	 */
 	if (map->mem1 != NULL) {
 		s = map->mem1;
-		config = (s->internal_base & 0xff000000) |
-		         ((s->address_mask & 0x7f000000) >> 11) | (1UL << 12) |
-		         ((s->pci_base & 0xff000000) >> 24);
+		config = (s->internal_base & INTERNAL_BUS_BASE_ADDRESS)	|
+		         ((s->address_mask >> 11) & ADDRESS_MASK)	|
+		         PCI_ACCESS_ENABLE				|
+		         ((s->pci_base >> 24) & PCI_ADDRESS_SETTING);
 		writel(config, PCIMMAW1REG);
 	}
 	if (map->mem2 != NULL) {
 		s = map->mem2;
-		config = (s->internal_base & 0xff000000) |
-		         ((s->address_mask & 0x7f000000) >> 11) | (1UL << 12) |
-		         ((s->pci_base & 0xff000000) >> 24);
+		config = (s->internal_base & INTERNAL_BUS_BASE_ADDRESS)	|
+		         ((s->address_mask >> 11) & ADDRESS_MASK)	|
+		         PCI_ACCESS_ENABLE				|
+		         ((s->pci_base >> 24) & PCI_ADDRESS_SETTING);
 		writel(config, PCIMMAW2REG);
 	}
 	if (map->io != NULL) {
 		s = map->io;
-		config = (s->internal_base & 0xff000000) |
-		         ((s->address_mask & 0x7f000000) >> 11) | (1UL << 12) |
-		         ((s->pci_base & 0xff000000) >> 24);
+		config = (s->internal_base & INTERNAL_BUS_BASE_ADDRESS) |
+		         ((s->address_mask >> 11) & ADDRESS_MASK) |
+		         PCI_ACCESS_ENABLE |
+		         ((s->pci_base >> 24) & PCI_ADDRESS_SETTING);
 		writel(config, PCIMIOAWREG);
 	}
 
 	/* Set target memory windows */
-	writel(0x00081000, PCITAW1REG);
-	writel(0UL, PCITAW2REG);
-	pciu_write_config_dword(PCI_BASE_ADDRESS_0, 0UL);
-	pciu_write_config_dword(PCI_BASE_ADDRESS_1, 0UL);
+	writel(0x00081000U, PCITAW1REG);
+	writel(0U, PCITAW2REG);
+
+	pciu_write_config_dword(PCI_BASE_ADDRESS_0, 0U);
+	pciu_write_config_dword(PCI_BASE_ADDRESS_1, 0U);
 
 	/* Clear bus error */
-	n = readl(BUSERRADREG);
+	readl(BUSERRADREG);
 
 	if (current_cpu_data.cputype == CPU_VR4122) {
-		writel(0UL, PCITRDYVREG);
-		pciu_write_config_dword(PCI_CACHE_LINE_SIZE, 0x0000f804);
+		writel(0U, PCITRDYVREG);
+		pciu_write_config_byte(PCI_LATENCY_TIMER, 0xf8);
 	} else {
-		writel(100UL, PCITRDYVREG);
-		pciu_write_config_dword(PCI_CACHE_LINE_SIZE, 0x00008004);
+		writel(100U, PCITRDYVREG);
+		pciu_write_config_byte(PCI_LATENCY_TIMER, 0x80);
 	}
 
 	writel(CONFIG_DONE, PCIENREG);
-	pciu_write_config_dword(PCI_COMMAND,
-	                        PCI_COMMAND_IO |
-	                        PCI_COMMAND_MEMORY |
-	                        PCI_COMMAND_MASTER |
-	                        PCI_COMMAND_PARITY |
-	                        PCI_COMMAND_SERR);
+	pciu_write_config_word(PCI_COMMAND,
+	                       PCI_COMMAND_IO |
+	                       PCI_COMMAND_MEMORY |
+	                       PCI_COMMAND_MASTER |
+	                       PCI_COMMAND_PARITY |
+	                       PCI_COMMAND_SERR);
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/pciu.h linux-mips-cvs-20040815/arch/mips/vr41xx/common/pciu.h
--- linux-2.4.27/arch/mips/vr41xx/common/pciu.h	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/pciu.h	2004-02-10 14:09:09.000000000 +0100
@@ -1,34 +1,14 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/common/pciu.h
+ * arch/mips/vr41xx/common/pciu.h
  *
- * BRIEF MODULE DESCRIPTION
- *	Include file for PCI Control Unit of the NEC VR4100 series.
+ * Include file for PCI Control Unit of the NEC VR4100 series.
  *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
  *
- * Copyright 2002 MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * 2002-2003 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
  */
 /*
  * Changes:
@@ -41,24 +21,24 @@
 #include <linux/config.h>
 #include <asm/addrspace.h>
 
-#define BIT(x)	(1 << (x))
+#define BIT(x)	(1U << (x))
 
 #define PCIMMAW1REG			KSEG1ADDR(0x0f000c00)
 #define PCIMMAW2REG			KSEG1ADDR(0x0f000c04)
 #define PCITAW1REG			KSEG1ADDR(0x0f000c08)
 #define PCITAW2REG			KSEG1ADDR(0x0f000c0c)
 #define PCIMIOAWREG			KSEG1ADDR(0x0f000c10)
-#define INTERNAL_BUS_BASE_ADDRESS	0xff000000
-#define ADDRESS_MASK			0x000fe000
+#define INTERNAL_BUS_BASE_ADDRESS	0xff000000U
+#define ADDRESS_MASK			0x000fe000U
 #define PCI_ACCESS_ENABLE		BIT(12)
-#define PCI_ADDRESS_SETTING		0x000000ff
+#define PCI_ADDRESS_SETTING		0x000000ffU
 
 #define PCICONFDREG			KSEG1ADDR(0x0f000c14)
 #define PCICONFAREG			KSEG1ADDR(0x0f000c18)
 #define PCIMAILREG			KSEG1ADDR(0x0f000c1c)
 
 #define BUSERRADREG			KSEG1ADDR(0x0f000c24)
-#define ERROR_ADDRESS			0xfffffffc
+#define ERROR_ADDRESS			0xfffffffcU
 
 #define INTCNTSTAREG			KSEG1ADDR(0x0f000c28)
 #define MABTCLR				BIT(31)
@@ -72,91 +52,102 @@
 #define EAREQ				BIT(0)
 
 #define PCIRECONTREG			KSEG1ADDR(0x0f000c30)
-#define RTRYCNT				0x000000ff
+#define RTRYCNT				0xffU
 
 #define PCIENREG			KSEG1ADDR(0x0f000c34)
 #define CONFIG_DONE			BIT(2)
 
 #define PCICLKSELREG			KSEG1ADDR(0x0f000c38)
-#define EQUAL_VTCLOCK			0x00000002
-#define HALF_VTCLOCK			0x00000000
-#define QUARTER_VTCLOCK			0x00000001
+#define EQUAL_VTCLOCK			0x2U
+#define HALF_VTCLOCK			0x0U
+#define QUARTER_VTCLOCK			0x1U
 
 #define PCITRDYVREG			KSEG1ADDR(0x0f000c3c)
 
 #define PCICLKRUNREG			KSEG1ADDR(0x0f000c60)
 
-#define PCIU_CONFIGREGS_BASE		KSEG1ADDR(0x0f000d00)
 #define VENDORIDREG			KSEG1ADDR(0x0f000d00)
-#define DEVICEIDREG			KSEG1ADDR(0x0f000d00)
-#define COMMANDREG			KSEG1ADDR(0x0f000d04)
-#define STATUSREG			KSEG1ADDR(0x0f000d04)
-#define REVIDREG			KSEG1ADDR(0x0f000d08)
-#define CLASSREG			KSEG1ADDR(0x0f000d08)
-#define CACHELSREG			KSEG1ADDR(0x0f000d0c)
-#define LATTIMEREG			KSEG1ADDR(0x0f000d0c)
-#define MAILBAREG			KSEG1ADDR(0x0f000d10)
-#define PCIMBA1REG			KSEG1ADDR(0x0f000d14)
-#define PCIMBA2REG			KSEG1ADDR(0x0f000d18)
-#define INTLINEREG			KSEG1ADDR(0x0f000d3c)
-#define INTPINREG			KSEG1ADDR(0x0f000d3c)
-#define RETVALREG			KSEG1ADDR(0x0f000d40)
-#define PCIAPCNTREG			KSEG1ADDR(0x0f000d40)
 
 #define MPCIINTREG			KSEG1ADDR(0x0f0000b2)
 
 #define MAX_PCI_CLOCK			33333333
 
-static inline int pciu_read_config_byte(int where, u8 *val)
+static inline int pciu_read_config_byte(int where, uint8_t *val)
 {
-	u32 data;
+	uint32_t data;
 
-	data = readl(PCIU_CONFIGREGS_BASE + where);
-	*val = (u8)(data >> ((where & 3) << 3));
+	if (where > 0xff)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = readl(VENDORIDREG + (where & 0xfc));
+	*val = (uint8_t)(data >> ((where & 3) << 3));
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static inline int pciu_read_config_word(int where, u16 *val)
+static inline int pciu_read_config_word(int where, uint16_t *val)
 {
-	u32 data;
+	uint32_t data;
 
-	if (where & 1)
+	if (where > 0xff || (where & 1))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	data = readl(PCIU_CONFIGREGS_BASE + where);
-	*val = (u16)(data >> ((where & 2) << 3));
+	data = readl(VENDORIDREG + (where & 0xfc));
+	*val = (uint16_t)(data >> ((where & 2) << 3));
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static inline int pciu_read_config_dword(int where, u32 *val)
+static inline int pciu_read_config_dword(int where, uint32_t *val)
 {
-	if (where & 3)
+	if (where > 0xff || (where & 3))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	*val = readl(PCIU_CONFIGREGS_BASE + where);
+	*val = readl(VENDORIDREG + where);
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static inline int pciu_write_config_byte(int where, u8 val)
+static inline int pciu_write_config_byte(int where, uint8_t val)
 {
-	writel(val, PCIU_CONFIGREGS_BASE + where);
+	uint32_t data;
+	int shift;
+
+	if (where > 0xff)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = readl(VENDORIDREG + (where & 0xfc));
+	shift = (where & 3) << 3;
+	data &= ~(0xffU << shift);
+	data |= (uint32_t)val << shift;
+	writel(data, VENDORIDREG + (where & 0xfc));
 
 	return 0;
 }
 
-static inline int pciu_write_config_word(int where, u16 val)
+static inline int pciu_write_config_word(int where, uint16_t val)
 {
-	writel(val, PCIU_CONFIGREGS_BASE + where);
+	uint32_t data;
+	int shift;
+
+	if (where > 0xff || (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = readl(VENDORIDREG + (where & 0xfc));
+	shift = (where & 2) << 3;
+	data &= ~(0xffffU << shift);
+	data |= (uint32_t)val << shift;
+	writel(data, VENDORIDREG + (where & 0xfc));
 
 	return 0;
 }
 
-static inline int pciu_write_config_dword(int where, u32 val)
+static inline int pciu_write_config_dword(int where, uint32_t val)
 {
-	writel(val, PCIU_CONFIGREGS_BASE + where);
+	if (where > 0xff || (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	writel(val, VENDORIDREG + where);
 
 	return 0;
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/pmu.c linux-mips-cvs-20040815/arch/mips/vr41xx/common/pmu.c
--- linux-2.4.27/arch/mips/vr41xx/common/pmu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/pmu.c	2004-02-13 18:22:22.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ *  pmu.c, Power Management Unit routines for NEC VR4100 series.
+ *
+ *  Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/types.h>
+
+#include <asm/cpu.h>
+#include <asm/io.h>
+#include <asm/reboot.h>
+#include <asm/system.h>
+
+#define PMUCNT2REG	KSEG1ADDR(0x0f0000c6)
+ #define SOFTRST	0x0010
+
+static inline void software_reset(void)
+{
+	uint16_t val;
+
+	switch (current_cpu_data.cputype) {
+	case CPU_VR4122:
+	case CPU_VR4131:
+	case CPU_VR4133:
+		val = readw(PMUCNT2REG);
+		val |= SOFTRST;
+		writew(val, PMUCNT2REG);
+		break;
+	default:
+		break;
+	}
+}
+
+static void vr41xx_restart(char *command)
+{
+	local_irq_disable();
+	software_reset();
+	printk(KERN_NOTICE "\nYou can reset your system\n");
+	while (1) ;
+}
+
+static void vr41xx_halt(void)
+{
+	local_irq_disable();
+	printk(KERN_NOTICE "\nYou can turn off the power supply\n");
+	while (1) ;
+}
+
+static void vr41xx_power_off(void)
+{
+	local_irq_disable();
+	printk(KERN_NOTICE "\nYou can turn off the power supply\n");
+	while (1) ;
+}
+
+void __init vr41xx_pmu_init(void)
+{
+	_machine_restart = vr41xx_restart;
+	_machine_halt = vr41xx_halt;
+	_machine_power_off = vr41xx_power_off;
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/serial.c linux-mips-cvs-20040815/arch/mips/vr41xx/common/serial.c
--- linux-2.4.27/arch/mips/vr41xx/common/serial.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/serial.c	2004-02-17 13:08:55.000000000 +0100
@@ -145,7 +145,7 @@ void __init vr41xx_siu_init(int interfac
 	if (early_serial_setup(&s) != 0)
 		printk(KERN_ERR "SIU setup failed!\n");
 
-	vr41xx_clock_supply(SIU_CLOCK);
+	vr41xx_supply_clock(SIU_CLOCK);
 
 	vr41xx_serial_ports++;
 }
@@ -171,7 +171,7 @@ void __init vr41xx_dsiu_init(void)
 	if (early_serial_setup(&s) != 0)
 		printk(KERN_ERR "DSIU setup failed!\n");
 
-	vr41xx_clock_supply(DSIU_CLOCK);
+	vr41xx_supply_clock(DSIU_CLOCK);
 
 	writew(INTDSIU, MDSIUINTREG);
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/common/vrc4173.c linux-mips-cvs-20040815/arch/mips/vr41xx/common/vrc4173.c
--- linux-2.4.27/arch/mips/vr41xx/common/vrc4173.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/common/vrc4173.c	2004-02-09 21:53:23.000000000 +0100
@@ -1,34 +1,14 @@
 /*
- * FILE NAME
- *	drivers/char/vrc4173.c
- * 
- * BRIEF MODULE DESCRIPTION
- *	NEC VRC4173 driver for NEC VR4122/VR4131.
+ * arch/mips/vr41xx/common/vrc4173.c
  *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
+ * NEC VRC4173 driver for NEC VR4122/VR4131.
  *
- * Copyright 2001,2002 MontaVista Software Inc.
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * 2001-2003 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
  */
 #include <linux/config.h>
 #include <linux/init.h>
@@ -36,6 +16,7 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/pci.h>
+#include <linux/spinlock.h>
 #include <linux/types.h>
 
 #include <asm/vr41xx/vr41xx.h>
@@ -45,100 +26,292 @@ MODULE_DESCRIPTION("NEC VRC4173 driver f
 MODULE_AUTHOR("Yoichi Yuasa <yyuasa@mvista.com>");
 MODULE_LICENSE("GPL");
 
+EXPORT_SYMBOL(vrc4173_io_offset);
+EXPORT_SYMBOL(vrc4173_supply_clock);
+EXPORT_SYMBOL(vrc4173_mask_clock);
+EXPORT_SYMBOL(vrc4173_select_function);
+
 #define VRC4173_CMUCLKMSK	0x040
+ #define MSKPIU			0x0001
+ #define MSKKIU			0x0002
+ #define MSKAIU			0x0004
+ #define MSKPS2CH1		0x0008
+ #define MSKPS2CH2		0x0010
+ #define MSKUSB			0x0020
+ #define MSKCARD1		0x0040
+ #define MSKCARD2		0x0080
+ #define MSKAC97		0x0100
+ #define MSK48MUSB		0x0400
+ #define MSK48MPIN		0x0800
+ #define MSK48MOSC		0x1000
 #define VRC4173_CMUSRST		0x042
-
-#define VRC4173_SELECTREG	0x09e
+ #define USBRST			0x0001
+ #define CARD1RST		0x0002
+ #define CARD2RST		0x0004
+ #define AC97RST		0x0008
 
 #define VRC4173_SYSINT1REG	0x060
 #define VRC4173_MSYSINT1REG	0x06c
 
+#define VRC4173_SELECTREG	0x09e
+
 static struct pci_device_id vrc4173_table[] __devinitdata = {
-	{PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_VRC4173, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0, }
+	{	.vendor		= PCI_VENDOR_ID_NEC,
+		.device		= PCI_DEVICE_ID_NEC_VRC4173,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,			},
+	{	.vendor		= 0,				},
 };
 
 unsigned long vrc4173_io_offset = 0;
 
-EXPORT_SYMBOL(vrc4173_io_offset);
-
-static u16 vrc4173_cmuclkmsk;
 static int vrc4173_initialized;
+static uint16_t vrc4173_cmuclkmsk;
+static uint16_t vrc4173_selectreg;
+static spinlock_t vrc4173_cmu_lock;
+static spinlock_t vrc4173_giu_lock;
 
-void vrc4173_clock_supply(u16 mask)
+static inline void set_cmusrst(uint16_t val)
+{
+	uint16_t cmusrst;
+
+	cmusrst = vrc4173_inw(VRC4173_CMUSRST);
+	cmusrst |= val;
+	vrc4173_outw(cmusrst, VRC4173_CMUSRST);
+}
+
+static inline void clear_cmusrst(uint16_t val)
+{
+	uint16_t cmusrst;
+
+	cmusrst = vrc4173_inw(VRC4173_CMUSRST);
+	cmusrst &= ~val;
+	vrc4173_outw(cmusrst, VRC4173_CMUSRST);
+}
+
+void vrc4173_supply_clock(unsigned int clock)
 {
 	if (vrc4173_initialized) {
-		vrc4173_cmuclkmsk |= mask;
+		spin_lock_irq(&vrc4173_cmu_lock);
+
+		switch (clock) {
+		case VRC4173_PIU_CLOCK:
+			vrc4173_cmuclkmsk |= MSKPIU;
+			break;
+		case VRC4173_KIU_CLOCK:
+			vrc4173_cmuclkmsk |= MSKKIU;
+			break;
+		case VRC4173_AIU_CLOCK:
+			vrc4173_cmuclkmsk |= MSKAIU;
+			break;
+		case VRC4173_PS2_CH1_CLOCK:
+			vrc4173_cmuclkmsk |= MSKPS2CH1;
+			break;
+		case VRC4173_PS2_CH2_CLOCK:
+			vrc4173_cmuclkmsk |= MSKPS2CH2;
+			break;
+		case VRC4173_USBU_PCI_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk |= MSKUSB;
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			set_cmusrst(CARD1RST);
+			vrc4173_cmuclkmsk |= MSKCARD1;
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			set_cmusrst(CARD2RST);
+			vrc4173_cmuclkmsk |= MSKCARD2;
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			set_cmusrst(AC97RST);
+			vrc4173_cmuclkmsk |= MSKAC97;
+			break;
+		case VRC4173_USBU_48MHz_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk |= MSK48MUSB;
+			break;
+		case VRC4173_EXT_48MHz_CLOCK:
+			if (vrc4173_cmuclkmsk & MSK48MOSC)
+				vrc4173_cmuclkmsk |= MSK48MPIN;
+			else
+				printk(KERN_WARNING
+				       "vrc4173_supply_clock: "
+				       "Please supply VRC4173_48MHz_CLOCK first "
+				       "rather than VRC4173_EXT_48MHz_CLOCK.\n");
+			break;
+		case VRC4173_48MHz_CLOCK:
+			vrc4173_cmuclkmsk |= MSK48MOSC;
+			break;
+		default:
+			printk(KERN_WARNING
+			       "vrc4173_supply_clock: Invalid CLOCK value %u\n", clock);
+			break;
+		}
+
 		vrc4173_outw(vrc4173_cmuclkmsk, VRC4173_CMUCLKMSK);
+
+		switch (clock) {
+		case VRC4173_USBU_PCI_CLOCK:
+		case VRC4173_USBU_48MHz_CLOCK:
+			clear_cmusrst(USBRST);
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			clear_cmusrst(CARD1RST);
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			clear_cmusrst(CARD2RST);
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			clear_cmusrst(AC97RST);
+			break;
+		default:
+			break;
+		}
+
+		spin_unlock_irq(&vrc4173_cmu_lock);
 	}
 }
 
-void vrc4173_clock_mask(u16 mask)
+void vrc4173_mask_clock(unsigned int clock)
 {
 	if (vrc4173_initialized) {
-		vrc4173_cmuclkmsk &= ~mask;
+		spin_lock_irq(&vrc4173_cmu_lock);
+
+		switch (clock) {
+		case VRC4173_PIU_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKPIU;
+			break;
+		case VRC4173_KIU_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKKIU;
+			break;
+		case VRC4173_AIU_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKAIU;
+			break;
+		case VRC4173_PS2_CH1_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKPS2CH1;
+			break;
+		case VRC4173_PS2_CH2_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKPS2CH2;
+			break;
+		case VRC4173_USBU_PCI_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk &= ~MSKUSB;
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			set_cmusrst(CARD1RST);
+			vrc4173_cmuclkmsk &= ~MSKCARD1;
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			set_cmusrst(CARD2RST);
+			vrc4173_cmuclkmsk &= ~MSKCARD2;
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			set_cmusrst(AC97RST);
+			vrc4173_cmuclkmsk &= ~MSKAC97;
+			break;
+		case VRC4173_USBU_48MHz_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk &= ~MSK48MUSB;
+			break;
+		case VRC4173_EXT_48MHz_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSK48MPIN;
+			break;
+		case VRC4173_48MHz_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSK48MOSC;
+			break;
+		default:
+			printk(KERN_WARNING "vrc4173_mask_clock: Invalid CLOCK value %u\n", clock);
+			break;
+		}
+
 		vrc4173_outw(vrc4173_cmuclkmsk, VRC4173_CMUCLKMSK);
+
+		switch (clock) {
+		case VRC4173_USBU_PCI_CLOCK:
+		case VRC4173_USBU_48MHz_CLOCK:
+			clear_cmusrst(USBRST);
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			clear_cmusrst(CARD1RST);
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			clear_cmusrst(CARD2RST);
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			clear_cmusrst(AC97RST);
+			break;
+		default:
+			break;
+		}
+
+		spin_unlock_irq(&vrc4173_cmu_lock);
 	}
 }
 
 static inline void vrc4173_cmu_init(void)
 {
 	vrc4173_cmuclkmsk = vrc4173_inw(VRC4173_CMUCLKMSK);
-}
 
-EXPORT_SYMBOL(vrc4173_clock_supply);
-EXPORT_SYMBOL(vrc4173_clock_mask);
+	spin_lock_init(&vrc4173_cmu_lock);
+}
 
 void vrc4173_select_function(int func)
 {
-	u16 val;
-
 	if (vrc4173_initialized) {
-		val = vrc4173_inw(VRC4173_SELECTREG);
+		spin_lock_irq(&vrc4173_giu_lock);
+
 		switch(func) {
 		case PS2CH1_SELECT:
-			val |= 0x0004;
+			vrc4173_selectreg |= 0x0004;
 			break;
 		case PS2CH2_SELECT:
-			val |= 0x0002;
+			vrc4173_selectreg |= 0x0002;
 			break;
 		case TOUCHPANEL_SELECT:
-			val &= 0x0007;
+			vrc4173_selectreg &= 0x0007;
 			break;
 		case KIU8_SELECT:
-			val &= 0x000e;
+			vrc4173_selectreg &= 0x000e;
 			break;
 		case KIU10_SELECT:
-			val &= 0x000c;
+			vrc4173_selectreg &= 0x000c;
 			break;
 		case KIU12_SELECT:
-			val &= 0x0008;
+			vrc4173_selectreg &= 0x0008;
 			break;
 		case GPIO_SELECT:
-			val |= 0x0008;
+			vrc4173_selectreg |= 0x0008;
 			break;
 		}
-		vrc4173_outw(val, VRC4173_SELECTREG);
+
+		vrc4173_outw(vrc4173_selectreg, VRC4173_SELECTREG);
+
+		spin_unlock_irq(&vrc4173_giu_lock);
 	}
 }
 
-EXPORT_SYMBOL(vrc4173_select_function);
+static inline void vrc4173_giu_init(void)
+{
+	vrc4173_selectreg = vrc4173_inw(VRC4173_SELECTREG);
+
+	spin_lock_init(&vrc4173_giu_lock);
+}
 
 static void enable_vrc4173_irq(unsigned int irq)
 {
-	u16 val;
+	uint16_t val;
 
 	val = vrc4173_inw(VRC4173_MSYSINT1REG);
-	val |= (u16)1 << (irq - VRC4173_IRQ_BASE);
+	val |= (uint16_t)1 << (irq - VRC4173_IRQ_BASE);
 	vrc4173_outw(val, VRC4173_MSYSINT1REG);
 }
 
 static void disable_vrc4173_irq(unsigned int irq)
 {
-	u16 val;
+	uint16_t val;
 
 	val = vrc4173_inw(VRC4173_MSYSINT1REG);
-	val &= ~((u16)1 << (irq - VRC4173_IRQ_BASE));
+	val &= ~((uint16_t)1 << (irq - VRC4173_IRQ_BASE));
 	vrc4173_outw(val, VRC4173_MSYSINT1REG);
 }
 
@@ -158,19 +331,18 @@ static void end_vrc4173_irq(unsigned int
 }
 
 static struct hw_interrupt_type vrc4173_irq_type = {
-	"VRC4173",
-	startup_vrc4173_irq,
-	shutdown_vrc4173_irq,
-	enable_vrc4173_irq,
-	disable_vrc4173_irq,
-	ack_vrc4173_irq,
-	end_vrc4173_irq,
-	NULL
+	.typename	= "VRC4173",
+	.startup	= startup_vrc4173_irq,
+	.shutdown	= shutdown_vrc4173_irq,
+	.enable		= enable_vrc4173_irq,
+	.disable	= disable_vrc4173_irq,
+	.ack		= ack_vrc4173_irq,
+	.end		= end_vrc4173_irq,
 };
 
 static int vrc4173_get_irq_number(int irq)
 {
-	u16 status, mask;
+	uint16_t status, mask;
 	int i;
 
         status = vrc4173_inw(VRC4173_SYSINT1REG);
@@ -180,18 +352,18 @@ static int vrc4173_get_irq_number(int ir
 	if (status) {
 		for (i = 0; i < 16; i++)
 			if (status & (0x0001 << i))
-				return VRC4173_IRQ_BASE + i;
+				return VRC4173_IRQ(i);
 	}
 
 	return -EINVAL;
 }
 
-static inline void vrc4173_icu_init(int cascade_irq)
+static inline int vrc4173_icu_init(int cascade_irq)
 {
 	int i;
 
 	if (cascade_irq < GIU_IRQ(0) || cascade_irq > GIU_IRQ(15))
-		return;
+		return -EINVAL;
 	
 	vrc4173_outw(0, VRC4173_MSYSINT1REG);
 
@@ -200,33 +372,38 @@ static inline void vrc4173_icu_init(int 
 
 	for (i = VRC4173_IRQ_BASE; i <= VRC4173_IRQ_LAST; i++)
                 irq_desc[i].handler = &vrc4173_irq_type;
+
+	return 0;
 }
 
-static int __devinit vrc4173_probe(struct pci_dev *pdev,
-                                   const struct pci_device_id *ent)
+static int __devinit vrc4173_probe(struct pci_dev *dev,
+                                   const struct pci_device_id *id)
 {
 	unsigned long start, flags;
 	int err;
 
-	if ((err = pci_enable_device(pdev)) < 0) {
-		printk(KERN_ERR "vrc4173: failed to enable device -- err=%d\n", err);
+	err = pci_enable_device(dev);
+	if (err < 0) {
+		printk(KERN_ERR "vrc4173: Failed to enable PCI device, aborting\n");
 		return err;
 	}
 
-	pci_set_master(pdev);
+	pci_set_master(dev);
 
-	start = pci_resource_start(pdev, 0);
-	if (!start) {
-		printk(KERN_ERR "vrc4173:No PCI I/O resources, aborting\n");
-		return -ENODEV;
+	start = pci_resource_start(dev, 0);
+	if (start == 0) {
+		printk(KERN_ERR "vrc4173:No such PCI I/O resource, aborting\n");
+		return -ENXIO;
 	}
 
-	if (!start || (((flags = pci_resource_flags(pdev, 0)) & IORESOURCE_IO) == 0)) {
-		printk(KERN_ERR "vrc4173: No PCI I/O resources, aborting\n");
-		return -ENODEV;
+	flags = pci_resource_flags(dev, 0);
+	if ((flags & IORESOURCE_IO) == 0) {
+		printk(KERN_ERR "vrc4173: No such PCI I/O resource, aborting\n");
+		return -ENXIO;
 	}
 
-	if ((err = pci_request_regions(pdev, "NEC VRC4173")) < 0) {
+	err = pci_request_regions(dev, "NEC VRC4173");
+	if (err < 0) {
 		printk(KERN_ERR "vrc4173: PCI resources are busy, aborting\n");
 		return err;
 	}
@@ -234,33 +411,46 @@ static int __devinit vrc4173_probe(struc
 	set_vrc4173_io_offset(start);
 
 	vrc4173_cmu_init();
+	vrc4173_giu_init();
 
-	vrc4173_icu_init(pdev->irq);
+	err = vrc4173_icu_init(dev->irq);
+	if (err < 0) {
+		printk(KERN_ERR "vrc4173: Invalid IRQ %d, aborting\n", dev->irq);
+		return err;
+	}
 
-	if ((err = vr41xx_cascade_irq(pdev->irq, vrc4173_get_irq_number)) < 0) {
-		printk(KERN_ERR
-		       "vrc4173: IRQ resource %d is busy, aborting\n", pdev->irq);
+	err = vr41xx_cascade_irq(dev->irq, vrc4173_get_irq_number);
+	if (err < 0) {
+		printk(KERN_ERR "vrc4173: IRQ resource %d is busy, aborting\n", dev->irq);
 		return err;
 	}
 
 	printk(KERN_INFO
-	       "NEC VRC4173 at 0x%#08lx, IRQ is cascaded to %d\n", start, pdev->irq);
+	       "NEC VRC4173 at 0x%#08lx, IRQ is cascaded to %d\n", start, dev->irq);
 
 	return 0;
 }
 
+static void vrc4173_remove(struct pci_dev *dev)
+{
+	free_irq(dev->irq, NULL);
+
+	pci_release_regions(dev);
+}
+
 static struct pci_driver vrc4173_driver = {
-	name:		"NEC VRC4173",
-	probe:		vrc4173_probe,
-	remove:		NULL,
-	id_table:	vrc4173_table,
+	.name		= "NEC VRC4173",
+	.probe		= vrc4173_probe,
+	.remove		= vrc4173_remove,
+	.id_table	= vrc4173_table,
 };
 
 static int __devinit vrc4173_init(void)
 {
 	int err;
 
-	if ((err = pci_module_init(&vrc4173_driver)) < 0)
+	err = pci_module_init(&vrc4173_driver);
+	if (err < 0)
 		return err;
 
 	vrc4173_initialized = 1;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/ibm-workpad/ide-workpad.c linux-mips-cvs-20040815/arch/mips/vr41xx/ibm-workpad/ide-workpad.c
--- linux-2.4.27/arch/mips/vr41xx/ibm-workpad/ide-workpad.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/ibm-workpad/ide-workpad.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * IDE routines for typical pc-like standard configurations for the IBM WorkPad z50.
- *
- * Copyright (C) 1998, 1999, 2001 by Ralf Baechle
- */
-/*
- * Changes:
- *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>  Sun, 24 Feb 2002
- *  - Added IBM WorkPad z50 support.
- */
-#include <linux/sched.h>
-#include <linux/ide.h>
-#include <linux/ioport.h>
-#include <linux/hdreg.h>
-#include <asm/ptrace.h>
-#include <asm/hdreg.h>
-
-static int workpad_ide_default_irq(ide_ioreg_t base)
-{
-	return 49;
-}
-
-static ide_ioreg_t workpad_ide_default_io_base(int index)
-{
-	switch (index) {
-		case 0: return 0x1f0;
-		case 1: return 0x170;
-		case 2: return 0x1e8;
-		case 3: return 0x168;
-		case 4: return 0x1e0;
-		case 5: return 0x160;
-	}
-	return 0;
-}
-
-static void workpad_ide_init_hwif_ports(hw_regs_t *hw, ide_ioreg_t data_port,
-                                        ide_ioreg_t ctrl_port, int *irq)
-{
-	ide_ioreg_t reg = data_port;
-	int i;
-
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw->io_ports[i] = reg;
-		reg += 1;
-	}
-	if (ctrl_port) {
-		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
-	} else {
-		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
-	}
-	if (irq != NULL)
-		*irq = 0;
-	hw->io_ports[IDE_IRQ_OFFSET] = 0;
-}
-
-static int workpad_ide_request_irq(unsigned int irq,
-                                   void (*handler)(int,void *, struct pt_regs *),
-                                   unsigned long flags, const char *device,
-                                   void *dev_id)
-{
-	return request_irq(irq, handler, SA_SHIRQ, device, dev_id);
-}			
-
-static void workpad_ide_free_irq(unsigned int irq, void *dev_id)
-{
-	free_irq(irq, dev_id);
-}
-
-static int workpad_ide_check_region(ide_ioreg_t from, unsigned int extent)
-{
-	return check_region(from, extent);
-}
-
-static void workpad_ide_request_region(ide_ioreg_t from, unsigned int extent,
-                                       const char *name)
-{
-	request_region(from, extent, name);
-}
-
-static void workpad_ide_release_region(ide_ioreg_t from, unsigned int extent)
-{
-	release_region(from, extent);
-}
-
-struct ide_ops workpad_ide_ops = {
-	&workpad_ide_default_irq,
-	&workpad_ide_default_io_base,
-	&workpad_ide_init_hwif_ports,
-	&workpad_ide_request_irq,
-	&workpad_ide_free_irq,
-	&workpad_ide_check_region,
-	&workpad_ide_request_region,
-	&workpad_ide_release_region
-};
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/ibm-workpad/setup.c linux-mips-cvs-20040815/arch/mips/vr41xx/ibm-workpad/setup.c
--- linux-2.4.27/arch/mips/vr41xx/ibm-workpad/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/ibm-workpad/setup.c	2004-02-13 18:22:22.000000000 +0100
@@ -1,33 +1,31 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/workpad/setup.c
+ *  setup.c, Setup for the IBM WorkPad z50.
  *
- * BRIEF MODULE DESCRIPTION
- *	Setup for the IBM WorkPad z50.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/init.h>
 #include <linux/console.h>
 #include <linux/ide.h>
+#include <linux/init.h>
 #include <linux/ioport.h>
 
-#include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/vr41xx/workpad.h>
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern unsigned long initrd_start, initrd_end;
-extern void * __rd_start, * __rd_end;
-#endif
-
 void __init ibm_workpad_setup(void)
 {
 	set_io_port_base(IO_PORT_BASE);
@@ -36,16 +34,6 @@ void __init ibm_workpad_setup(void)
 	iomem_resource.start = IO_MEM_RESOURCE_START;
 	iomem_resource.end = IO_MEM_RESOURCE_END;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	initrd_start = (unsigned long)&__rd_start;
-	initrd_end = (unsigned long)&__rd_end;
-#endif
-
-	_machine_restart = vr41xx_restart;
-	_machine_halt = vr41xx_halt;
-	_machine_power_off = vr41xx_power_off;
-
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
 
@@ -58,8 +46,10 @@ void __init ibm_workpad_setup(void)
 #endif
 
 	vr41xx_bcu_init();
-
 	vr41xx_cmu_init();
+	vr41xx_pmu_init();
 
+#ifdef CONFIG_SERIAL
 	vr41xx_siu_init(SIU_RS232C, 0);
+#endif
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/nec-eagle/ide-eagle.c linux-mips-cvs-20040815/arch/mips/vr41xx/nec-eagle/ide-eagle.c
--- linux-2.4.27/arch/mips/vr41xx/nec-eagle/ide-eagle.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/nec-eagle/ide-eagle.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * IDE routines for typical pc-like standard configurations
- * for the NEC Eagle/Hawk board.
- *
- * Copyright (C) 1998, 1999, 2001 by Ralf Baechle
- */
-/*
- * Changes:
- *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
- *  Fri,  5 Apr 2002
- *  - Added support for NEC Hawk.
- *
- *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
- *  Fri,  1 Mar 2002
- *  - Added support for NEC Eagle.
- */
-#include <linux/sched.h>
-#include <linux/ide.h>
-#include <linux/ioport.h>
-#include <linux/hdreg.h>
-#include <asm/ptrace.h>
-#include <asm/hdreg.h>
-
-static int eagle_ide_default_irq(ide_ioreg_t base)
-{
-	return 0;
-}
-
-static ide_ioreg_t eagle_ide_default_io_base(int index)
-{
-	return 0;
-}
-
-static void eagle_ide_init_hwif_ports(hw_regs_t *hw, ide_ioreg_t data_port,
-                                      ide_ioreg_t ctrl_port, int *irq)
-{
-	ide_ioreg_t reg = data_port;
-	int i;
-
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw->io_ports[i] = reg;
-		reg += 1;
-	}
-	if (ctrl_port) {
-		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
-	} else {
-		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
-	}
-	if (irq != NULL)
-		*irq = 0;
-	hw->io_ports[IDE_IRQ_OFFSET] = 0;
-}
-
-static int eagle_ide_request_irq(unsigned int irq,
-                                 void (*handler)(int,void *, struct pt_regs *),
-                                 unsigned long flags, const char *device,
-                                 void *dev_id)
-{
-	return request_irq(irq, handler, SA_SHIRQ, device, dev_id);
-}
-
-static void eagle_ide_free_irq(unsigned int irq, void *dev_id)
-{
-	free_irq(irq, dev_id);
-}
-
-static int eagle_ide_check_region(ide_ioreg_t from, unsigned int extent)
-{
-	return check_region(from, extent);
-}
-
-static void eagle_ide_request_region(ide_ioreg_t from, unsigned int extent,
-                                     const char *name)
-{
-	request_region(from, extent, name);
-}
-
-static void eagle_ide_release_region(ide_ioreg_t from, unsigned int extent)
-{
-	release_region(from, extent);
-}
-
-struct ide_ops eagle_ide_ops = {
-	&eagle_ide_default_irq,
-	&eagle_ide_default_io_base,
-	&eagle_ide_init_hwif_ports,
-	&eagle_ide_request_irq,
-	&eagle_ide_free_irq,
-	&eagle_ide_check_region,
-	&eagle_ide_request_region,
-	&eagle_ide_release_region
-};
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/nec-eagle/setup.c linux-mips-cvs-20040815/arch/mips/vr41xx/nec-eagle/setup.c
--- linux-2.4.27/arch/mips/vr41xx/nec-eagle/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/nec-eagle/setup.c	2004-02-13 18:22:22.000000000 +0100
@@ -1,34 +1,14 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/nec-eagle/setup.c
+ * arch/mips/vr41xx/nec-eagle/setup.c
  *
- * BRIEF MODULE DESCRIPTION
- *	Setup for the NEC Eagle/Hawk board.
+ * Setup for the NEC Eagle/Hawk board.
  *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
+ * Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
  *
- * Copyright 2001,2002 MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * 2001-2004 (c) MontaVista, Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
  */
 /*
  * Changes:
@@ -40,21 +20,15 @@
  *  - New creation, NEC Eagle is supported.
  */
 #include <linux/config.h>
-#include <linux/init.h>
 #include <linux/console.h>
 #include <linux/ide.h>
+#include <linux/init.h>
 #include <linux/ioport.h>
 
 #include <asm/pci_channel.h>
-#include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/vr41xx/eagle.h>
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern unsigned long initrd_start, initrd_end;
-extern void * __rd_start, * __rd_end;
-#endif
-
 extern void eagle_irq_init(void);
 
 #ifdef CONFIG_PCI
@@ -75,8 +49,6 @@ static struct resource vr41xx_pci_mem_re
 	IORESOURCE_MEM
 };
 
-extern struct pci_ops vr41xx_pci_ops;
-
 struct pci_channel mips_pci_channels[] = {
 	{&vr41xx_pci_ops, &vr41xx_pci_io_resource, &vr41xx_pci_mem_resource, 0, 256},
 	{NULL, NULL, NULL, 0, 0}
@@ -115,16 +87,6 @@ void __init nec_eagle_setup(void)
 	iomem_resource.start = IO_MEM1_RESOURCE_START;
 	iomem_resource.end = IO_MEM2_RESOURCE_END;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	initrd_start = (unsigned long)&__rd_start;
-	initrd_end = (unsigned long)&__rd_end;
-#endif
-
-	_machine_restart = vr41xx_restart;
-	_machine_halt = vr41xx_halt;
-	_machine_power_off = vr41xx_power_off;
-
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
 
@@ -139,8 +101,8 @@ void __init nec_eagle_setup(void)
 #endif
 
 	vr41xx_bcu_init();
-
 	vr41xx_cmu_init();
+	vr41xx_pmu_init();
 
 #ifdef CONFIG_SERIAL
 	vr41xx_dsiu_init();
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/tanbac-tb0226/setup.c linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0226/setup.c
--- linux-2.4.27/arch/mips/vr41xx/tanbac-tb0226/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0226/setup.c	2004-02-13 18:22:22.000000000 +0100
@@ -1,33 +1,31 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/tanbac-tb0226/setup.c
+ *  setup.c, Setup for the TANBAC TB0226.
  *
- * BRIEF MODULE DESCRIPTION
- *	Setup for the TANBAC TB0226.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002,2003 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/init.h>
 #include <linux/console.h>
+#include <linux/init.h>
 #include <linux/ioport.h>
 
 #include <asm/pci_channel.h>
-#include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/vr41xx/tb0226.h>
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern unsigned long initrd_start, initrd_end;
-extern void * __rd_start, * __rd_end;
-#endif
-
 #ifdef CONFIG_PCI
 static struct resource vr41xx_pci_io_resource = {
 	"PCI I/O space",
@@ -43,8 +41,6 @@ static struct resource vr41xx_pci_mem_re
 	IORESOURCE_MEM
 };
 
-extern struct pci_ops vr41xx_pci_ops;
-
 struct pci_channel mips_pci_channels[] = {
 	{&vr41xx_pci_ops, &vr41xx_pci_io_resource, &vr41xx_pci_mem_resource, 0, 256},
 	{NULL, NULL, NULL, 0, 0}
@@ -83,16 +79,6 @@ void __init tanbac_tb0226_setup(void)
 	iomem_resource.start = IO_MEM1_RESOURCE_START;
 	iomem_resource.end = IO_MEM2_RESOURCE_END;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	initrd_start = (unsigned long)&__rd_start;
-	initrd_end = (unsigned long)&__rd_end;
-#endif
-
-	_machine_restart = vr41xx_restart;
-	_machine_halt = vr41xx_halt;
-	_machine_power_off = vr41xx_power_off;
-
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
 
@@ -101,10 +87,12 @@ void __init tanbac_tb0226_setup(void)
 #endif
 
 	vr41xx_bcu_init();
-
 	vr41xx_cmu_init();
+	vr41xx_pmu_init();
 
+#ifdef CONFIG_SERIAL
 	vr41xx_siu_init(SIU_RS232C, 0);
+#endif
 
 #ifdef CONFIG_PCI
 	vr41xx_pciu_init(&pci_address_map);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/tanbac-tb0229/Makefile linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0229/Makefile
--- linux-2.4.27/arch/mips/vr41xx/tanbac-tb0229/Makefile	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0229/Makefile	2004-02-13 18:22:22.000000000 +0100
@@ -12,8 +12,9 @@ O_TARGET := tb0229.o
 
 all: tb0229.o
 
-obj-y	:= init.o setup.o reboot.o
+obj-y	:= init.o setup.o
 
-obj-$(CONFIG_PCI)	+= pci_fixup.o
+obj-$(CONFIG_PCI)		+= pci_fixup.o
+obj-$(CONFIG_TANBAC_TB0219)	+= reboot.o
 
 include $(TOPDIR)/Rules.make
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/tanbac-tb0229/reboot.c linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0229/reboot.c
--- linux-2.4.27/arch/mips/vr41xx/tanbac-tb0229/reboot.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0229/reboot.c	2004-02-13 18:22:22.000000000 +0100
@@ -16,15 +16,11 @@
 #include <asm/io.h>
 #include <asm/vr41xx/tb0229.h>
 
-#define tb0229_hard_reset()	writew(0, TB0219_RESET_REGS)
+#define tb0219_hard_reset()	writew(0, TB0219_RESET_REGS)
 
-void tanbac_tb0229_restart(char *command)
+void tanbac_tb0219_restart(char *command)
 {
-#ifdef CONFIG_TANBAC_TB0219
 	local_irq_disable();
-	tb0229_hard_reset();
+	tb0219_hard_reset();
 	while (1);
-#else
-	vr41xx_restart(command);
-#endif
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/tanbac-tb0229/setup.c linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0229/setup.c
--- linux-2.4.27/arch/mips/vr41xx/tanbac-tb0229/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/tanbac-tb0229/setup.c	2004-02-13 18:22:22.000000000 +0100
@@ -1,24 +1,26 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/tanbac-tb0229/setup.c
+ *  setup.c, Setup for the TANBAC TB0229 (VR4131DIMM)
  *
- * BRIEF MODULE DESCRIPTION
- *	Setup for the TANBAC TB0229 (VR4131DIMM)
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002,2003 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  Modified for TANBAC TB0229:
+ *  Copyright (C) 2003 Megasolution Inc.  <matsu@megasolution.jp>
  *
- * Modified for TANBAC TB0229:
- * Copyright 2003 Megasolution Inc.
- *                matsu@megasolution.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/blk.h>
 #include <linux/console.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
@@ -28,10 +30,6 @@
 #include <asm/time.h>
 #include <asm/vr41xx/tb0229.h>
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern void * __rd_start, * __rd_end;
-#endif
-
 #ifdef CONFIG_PCI
 static struct resource vr41xx_pci_io_resource = {
 	.name	= "PCI I/O space",
@@ -47,8 +45,6 @@ static struct resource vr41xx_pci_mem_re
 	.flags	= IORESOURCE_MEM,
 };
 
-extern struct pci_ops vr41xx_pci_ops;
-
 struct pci_channel mips_pci_channels[] = {
 	{	.pci_ops	= &vr41xx_pci_ops,
 		.io_resource	= &vr41xx_pci_io_resource,
@@ -95,16 +91,6 @@ void __init tanbac_tb0229_setup(void)
 	iomem_resource.start = IO_MEM1_RESOURCE_START;
 	iomem_resource.end = IO_MEM2_RESOURCE_END;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	initrd_start = (unsigned long)&__rd_start;
-	initrd_end = (unsigned long)&__rd_end;
-#endif
-
-	_machine_restart = tanbac_tb0229_restart;
-	_machine_halt = vr41xx_halt;
-	_machine_power_off = vr41xx_power_off;
-
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
 
@@ -113,14 +99,19 @@ void __init tanbac_tb0229_setup(void)
 #endif
 
 	vr41xx_bcu_init();
-
 	vr41xx_cmu_init();
+	vr41xx_pmu_init();
 
+#ifdef CONFIG_SERIAL
 	vr41xx_siu_init(SIU_RS232C, 0);
 	vr41xx_dsiu_init();
+#endif
 
 #ifdef CONFIG_PCI
 	vr41xx_pciu_init(&pci_address_map);
 #endif
-}
 
+#ifdef CONFIG_TANBAC_TB0219
+	_machine_restart = tanbac_tb0219_restart;
+#endif
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/victor-mpc30x/ide-mpc30x.c linux-mips-cvs-20040815/arch/mips/vr41xx/victor-mpc30x/ide-mpc30x.c
--- linux-2.4.27/arch/mips/vr41xx/victor-mpc30x/ide-mpc30x.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/victor-mpc30x/ide-mpc30x.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * IDE routines for typical pc-like standard configurations
- * for the ZAO Networks Capcella.
- *
- * Copyright (C) 1998, 1999, 2001 by Ralf Baechle
- */
-/*
- * Changes:
- *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>  Fri, 23 Aug 2002
- *  - Added Victor MP-C303/304 support.
- */
-#include <linux/sched.h>
-#include <linux/ide.h>
-#include <linux/ioport.h>
-#include <linux/hdreg.h>
-#include <asm/ptrace.h>
-#include <asm/hdreg.h>
-
-static int mpc30x_ide_default_irq(ide_ioreg_t base)
-{
-	return 0;
-}
-
-static ide_ioreg_t mpc30x_ide_default_io_base(int index)
-{
-	return 0;
-}
-
-static void mpc30x_ide_init_hwif_ports(hw_regs_t *hw, ide_ioreg_t data_port,
-                                       ide_ioreg_t ctrl_port, int *irq)
-{
-	ide_ioreg_t reg = data_port;
-	int i;
-
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw->io_ports[i] = reg;
-		reg += 1;
-	}
-	if (ctrl_port) {
-		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
-	} else {
-		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
-	}
-	if (irq != NULL)
-		*irq = 0;
-	hw->io_ports[IDE_IRQ_OFFSET] = 0;
-}
-
-static int mpc30x_ide_request_irq(unsigned int irq,
-                                  void (*handler)(int,void *, struct pt_regs *),
-                                  unsigned long flags, const char *device,
-                                  void *dev_id)
-{
-	return request_irq(irq, handler, flags, device, dev_id);
-}
-
-static void mpc30x_ide_free_irq(unsigned int irq, void *dev_id)
-{
-	free_irq(irq, dev_id);
-}
-
-static int mpc30x_ide_check_region(ide_ioreg_t from, unsigned int extent)
-{
-	return check_region(from, extent);
-}
-
-static void mpc30x_ide_request_region(ide_ioreg_t from, unsigned int extent,
-                                      const char *name)
-{
-	request_region(from, extent, name);
-}
-
-static void mpc30x_ide_release_region(ide_ioreg_t from, unsigned int extent)
-{
-	release_region(from, extent);
-}
-
-struct ide_ops mpc30x_ide_ops = {
-	&mpc30x_ide_default_irq,
-	&mpc30x_ide_default_io_base,
-	&mpc30x_ide_init_hwif_ports,
-	&mpc30x_ide_request_irq,
-	&mpc30x_ide_free_irq,
-	&mpc30x_ide_check_region,
-	&mpc30x_ide_request_region,
-	&mpc30x_ide_release_region
-};
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/victor-mpc30x/setup.c linux-mips-cvs-20040815/arch/mips/vr41xx/victor-mpc30x/setup.c
--- linux-2.4.27/arch/mips/vr41xx/victor-mpc30x/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/victor-mpc30x/setup.c	2004-02-13 18:22:22.000000000 +0100
@@ -1,34 +1,32 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/victor-mpc30x/setup.c
+ *  setup.c, Setup for the Victor MP-C303/304.
  *
- * BRIEF MODULE DESCRIPTION
- *	Setup for the Victor MP-C303/304.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/init.h>
 #include <linux/console.h>
 #include <linux/ide.h>
+#include <linux/init.h>
 #include <linux/ioport.h>
 
 #include <asm/pci_channel.h>
-#include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/vr41xx/mpc30x.h>
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern unsigned long initrd_start, initrd_end;
-extern void * __rd_start, * __rd_end;
-#endif
-
 #ifdef CONFIG_PCI
 static struct resource vr41xx_pci_io_resource = {
 	"PCI I/O space",
@@ -44,8 +42,6 @@ static struct resource vr41xx_pci_mem_re
 	IORESOURCE_MEM
 };
 
-extern struct pci_ops vr41xx_pci_ops;
-
 struct pci_channel mips_pci_channels[] = {
 	{&vr41xx_pci_ops, &vr41xx_pci_io_resource, &vr41xx_pci_mem_resource, 0, 256},
 	{NULL, NULL, NULL, 0, 0}
@@ -84,16 +80,6 @@ void __init victor_mpc30x_setup(void)
 	iomem_resource.start = IO_MEM1_RESOURCE_START;
 	iomem_resource.end = IO_MEM2_RESOURCE_END;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	initrd_start = (unsigned long)&__rd_start;
-	initrd_end = (unsigned long)&__rd_end;
-#endif
-
-	_machine_restart = vr41xx_restart;
-	_machine_halt = vr41xx_halt;
-	_machine_power_off = vr41xx_power_off;
-
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
 
@@ -106,10 +92,12 @@ void __init victor_mpc30x_setup(void)
 #endif
 
 	vr41xx_bcu_init();
-
 	vr41xx_cmu_init();
+	vr41xx_pmu_init();
 
+#ifdef CONFIG_SERIAL
 	vr41xx_siu_init(SIU_RS232C, 0);
+#endif
 
 #ifdef CONFIG_PCI
 	vr41xx_pciu_init(&pci_address_map);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/zao-capcella/ide-capcella.c linux-mips-cvs-20040815/arch/mips/vr41xx/zao-capcella/ide-capcella.c
--- linux-2.4.27/arch/mips/vr41xx/zao-capcella/ide-capcella.c	2002-11-29 00:53:10.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/zao-capcella/ide-capcella.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * IDE routines for typical pc-like standard configurations
- * for the ZAO Networks Capcella.
- *
- * Copyright (C) 1998, 1999, 2001 by Ralf Baechle
- */
-/*
- * Changes:
- *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>  Sun, 24 Feb 2002
- *  - Added ZAO Networks Capcella support.
- */
-#include <linux/sched.h>
-#include <linux/ide.h>
-#include <linux/ioport.h>
-#include <linux/hdreg.h>
-#include <asm/ptrace.h>
-#include <asm/hdreg.h>
-
-static int capcella_ide_default_irq(ide_ioreg_t base)
-{
-	switch (base) {
-	case 0x8300: return 42;
-	}
-
-	return 0;
-}
-
-static ide_ioreg_t capcella_ide_default_io_base(int index)
-{
-	switch (index) {
-	case 0: return 0x8300;
-	}
-
-	return 0;
-}
-
-static void capcella_ide_init_hwif_ports(hw_regs_t *hw, ide_ioreg_t data_port,
-                                         ide_ioreg_t ctrl_port, int *irq)
-{
-	ide_ioreg_t reg = data_port;
-	int i;
-
-	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
-		hw->io_ports[i] = reg;
-		reg += 1;
-	}
-	if (ctrl_port) {
-		hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
-	} else {
-		hw->io_ports[IDE_CONTROL_OFFSET] = hw->io_ports[IDE_DATA_OFFSET] + 0x206;
-	}
-	if (irq != NULL)
-		*irq = 0;
-	hw->io_ports[IDE_IRQ_OFFSET] = 0;
-}
-
-static int capcella_ide_request_irq(unsigned int irq,
-                                    void (*handler)(int,void *, struct pt_regs *),
-                                    unsigned long flags, const char *device,
-                                    void *dev_id)
-{
-	return request_irq(irq, handler, flags, device, dev_id);
-}
-
-static void capcella_ide_free_irq(unsigned int irq, void *dev_id)
-{
-	free_irq(irq, dev_id);
-}
-
-static int capcella_ide_check_region(ide_ioreg_t from, unsigned int extent)
-{
-	return check_region(from, extent);
-}
-
-static void capcella_ide_request_region(ide_ioreg_t from, unsigned int extent,
-                                        const char *name)
-{
-	request_region(from, extent, name);
-}
-
-static void capcella_ide_release_region(ide_ioreg_t from, unsigned int extent)
-{
-	release_region(from, extent);
-}
-
-struct ide_ops capcella_ide_ops = {
-	&capcella_ide_default_irq,
-	&capcella_ide_default_io_base,
-	&capcella_ide_init_hwif_ports,
-	&capcella_ide_request_irq,
-	&capcella_ide_free_irq,
-	&capcella_ide_check_region,
-	&capcella_ide_request_region,
-	&capcella_ide_release_region
-};
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips/vr41xx/zao-capcella/setup.c linux-mips-cvs-20040815/arch/mips/vr41xx/zao-capcella/setup.c
--- linux-2.4.27/arch/mips/vr41xx/zao-capcella/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips/vr41xx/zao-capcella/setup.c	2004-02-13 18:22:22.000000000 +0100
@@ -1,34 +1,32 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/zao-capcella/setup.c
+ *  setup.c, Setup for the ZAO Networks Capcella.
  *
- * BRIEF MODULE DESCRIPTION
- *	Setup for the ZAO Networks Capcella.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/init.h>
 #include <linux/console.h>
 #include <linux/ide.h>
+#include <linux/init.h>
 #include <linux/ioport.h>
 
 #include <asm/pci_channel.h>
-#include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/vr41xx/capcella.h>
 
-#ifdef CONFIG_BLK_DEV_INITRD
-extern unsigned long initrd_start, initrd_end;
-extern void * __rd_start, * __rd_end;
-#endif
-
 #ifdef CONFIG_PCI
 static struct resource vr41xx_pci_io_resource = {
 	"PCI I/O space",
@@ -44,8 +42,6 @@ static struct resource vr41xx_pci_mem_re
 	IORESOURCE_MEM
 };
 
-extern struct pci_ops vr41xx_pci_ops;
-
 struct pci_channel mips_pci_channels[] = {
 	{&vr41xx_pci_ops, &vr41xx_pci_io_resource, &vr41xx_pci_mem_resource, 0, 256},
 	{NULL, NULL, NULL, 0, 0}
@@ -84,16 +80,6 @@ void __init zao_capcella_setup(void)
 	iomem_resource.start = IO_MEM1_RESOURCE_START;
 	iomem_resource.end = IO_MEM2_RESOURCE_END;
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
-	initrd_start = (unsigned long)&__rd_start;
-	initrd_end = (unsigned long)&__rd_end;
-#endif
-
-	_machine_restart = vr41xx_restart;
-	_machine_halt = vr41xx_halt;
-	_machine_power_off = vr41xx_power_off;
-
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
 
@@ -106,11 +92,13 @@ void __init zao_capcella_setup(void)
 #endif
 
 	vr41xx_bcu_init();
-
 	vr41xx_cmu_init();
+	vr41xx_pmu_init();
 
+#ifdef CONFIG_SERIAL
 	vr41xx_siu_init(SIU_RS232C, 0);
 	vr41xx_dsiu_init();
+#endif
 
 #ifdef CONFIG_PCI
 	vr41xx_pciu_init(&pci_address_map);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/Makefile linux-mips-cvs-20040815/arch/mips64/Makefile
--- linux-2.4.27/arch/mips64/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/Makefile	2004-03-24 18:07:37.000000000 +0100
@@ -26,6 +26,9 @@ ifdef CONFIG_CROSSCOMPILE
 CROSS_COMPILE	= $(tool-prefix)
 endif
 
+check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
+check_gas = $(shell if $(CC) $(1) -Wa,-Z -c -o /dev/null -xassembler /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
+
 #
 # The ELF GCC uses -G 0 -mabicalls -fpic as default.  We don't need PIC
 # code in the kernel since it only slows down the whole thing.  For the
@@ -37,9 +40,9 @@ endif
 # crossformat linking we rely on the elf2ecoff tool for format conversion.
 #
 GCCFLAGS	:= -I $(TOPDIR)/include/asm/gcc
-GCCFLAGS	+= -mabi=64 -G 0 -mno-abicalls -fno-pic -Wa,--trap -pipe
+GCCFLAGS	+= -G 0 -mno-abicalls -fno-pic -Wa,--trap -pipe
 GCCFLAGS	+= $(call check_gcc, -finline-limit=100000,)
-LINKFLAGS	+= -G 0 -static # -N
+LINKFLAGS	+= -G 0 -static -n
 MODFLAGS	+= -mlong-calls
 
 ifdef CONFIG_DEBUG_INFO
@@ -49,9 +52,6 @@ GCCFLAGS	+= -mno-sched-prolog -fno-omit-
 endif
 endif
 
-check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
-check_gas = $(shell if $(CC) $(1) -Wa,-Z -c -o /dev/null -xassembler /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
-
 #
 # Use: $(call set_gccflags,<cpu0>,<isa0>,<cpu1>,<isa1>)
 #
@@ -76,6 +76,7 @@ while :; do \
 	done; \
 	break; \
 done; \
+gcc_abi=-mabi=64; \
 gcc_cpu=$$cpu; gcc_isa=$$isa; \
 gas_cpu=$$cpu; gas_isa=-Wa,$$isa; \
 while :; do \
@@ -87,7 +88,12 @@ while :; do \
 	gas_opt=; gas_cpu=; gas_isa=; \
 	break; \
 done; \
-echo $$gcc_opt$$gcc_cpu $$gcc_isa $$gas_opt$$gas_cpu $$gas_isa)
+if test "$$gcc_opt" = -march=; then \
+	$(CC) $$gcc_abi $$gcc_opt$$gcc_cpu -S -o /dev/null \
+		-xc /dev/null > /dev/null 2>&1 && \
+		gcc_isa=; \
+fi; \
+echo $$gcc_abi $$gcc_opt$$gcc_cpu $$gcc_isa $$gas_opt$$gas_cpu $$gas_isa)
 
 #
 # CPU-dependent compiler/assembler options for optimization.
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig linux-mips-cvs-20040815/arch/mips64/defconfig
--- linux-2.4.27/arch/mips64/defconfig	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig	2004-08-15 08:05:51.000000000 +0200
@@ -8,12 +8,14 @@ CONFIG_MIPS64=y
 #
 # Code maturity level options
 #
-# CONFIG_EXPERIMENTAL is not set
+CONFIG_EXPERIMENTAL=y
 
 #
 # Loadable module support
 #
-# CONFIG_MODULES is not set
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
 
 #
 # Machine selection
@@ -24,10 +26,12 @@ CONFIG_MIPS64=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +54,7 @@ CONFIG_MIPS64=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -81,8 +86,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_BOOT_ELF64=y
 CONFIG_ARC64=y
 CONFIG_L1_CACHE_SHIFT=7
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
 CONFIG_QL_ISP_A64=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -107,6 +110,8 @@ CONFIG_CPU_R10000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_SMP=y
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -122,6 +127,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_BINFMT_IRIX is not set
 # CONFIG_MIPS_INSANE_LARGE is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -143,6 +151,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -172,6 +181,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -196,8 +206,9 @@ CONFIG_BINFMT_ELF32=y
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
 CONFIG_NETLINK_DEV=y
-# CONFIG_NETFILTER is not set
-# CONFIG_FILTER is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
 CONFIG_UNIX=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
@@ -206,35 +217,199 @@ CONFIG_IP_PNP=y
 # CONFIG_IP_PNP_DHCP is not set
 # CONFIG_IP_PNP_BOOTP is not set
 # CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_INET_ECN is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_INET_ECN=y
 # CONFIG_SYN_COOKIES is not set
-# CONFIG_VLAN_8021Q is not set
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+# CONFIG_IP_NF_MATCH_UNCLEAN is not set
+# CONFIG_IP_NF_MATCH_OWNER is not set
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+# CONFIG_IP_NF_TARGET_MIRROR is not set
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_LOCAL=y
+# CONFIG_IP_NF_NAT_SNMP_BASIC is not set
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_IP_NF_COMPAT_IPCHAINS=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_COMPAT_IPFWADM=m
+CONFIG_IP_NF_NAT_NEEDED=y
+
+#
+#   IP: Virtual Server Configuration
+#
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IPV6=m
+
+#
+#   IPv6: Netfilter Configuration
+#
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_LIMIT=m
+CONFIG_IP6_NF_MATCH_MAC=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_MULTIPORT=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_MARK=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AHESP=m
+CONFIG_IP6_NF_MATCH_LENGTH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_MARK=m
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_ATM is not set
+CONFIG_VLAN_8021Q=m
 
 #
 #  
 #
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
+CONFIG_IPX=m
+# CONFIG_IPX_INTERN is not set
+CONFIG_ATALK=m
 
 #
 # Appletalk devices
 #
-# CONFIG_DEV_APPLETALK is not set
-# CONFIG_DECNET is not set
-# CONFIG_BRIDGE is not set
+CONFIG_DEV_APPLETALK=y
+# CONFIG_COPS_DAYNA is not set
+# CONFIG_COPS_TANGENT is not set
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
+CONFIG_DECNET=m
+CONFIG_DECNET_SIOCGIFCONF=y
+CONFIG_DECNET_ROUTER=y
+CONFIG_DECNET_ROUTE_FWMARK=y
+CONFIG_BRIDGE=m
+CONFIG_X25=m
+CONFIG_LAPB=m
+# CONFIG_LLC is not set
+CONFIG_NET_DIVERT=y
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
 
 #
 # QoS and/or fair queueing
 #
-# CONFIG_NET_SCHED is not set
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_CSZ=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+# CONFIG_NET_SCH_NETEM is not set
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_CLS_POLICE is not set
 
 #
 # Network testing
 #
-# CONFIG_NET_PKTGEN is not set
+CONFIG_NET_PKTGEN=m
 
 #
 # Telephony Support
@@ -259,10 +434,12 @@ CONFIG_SCSI=y
 #
 CONFIG_BLK_DEV_SD=y
 CONFIG_SD_EXTRA_DEVS=40
-CONFIG_CHR_DEV_ST=y
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=4
+CONFIG_CHR_DEV_SG=m
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
@@ -281,6 +458,7 @@ CONFIG_SCSI_LOGGING=y
 # CONFIG_SCSI_AHA152X is not set
 # CONFIG_SCSI_AHA1542 is not set
 # CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
 # CONFIG_SCSI_AIC7XXX is not set
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_SCSI_AIC7XXX_OLD is not set
@@ -290,6 +468,14 @@ CONFIG_SCSI_LOGGING=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -321,6 +507,7 @@ CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_SCSI_T128 is not set
 # CONFIG_SCSI_U14_34F is not set
 # CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
 
 #
 # Fusion MPT device support
@@ -332,6 +519,11 @@ CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_FUSION_LAN is not set
 
 #
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
 # Network device support
 #
 CONFIG_NETDEVICES=y
@@ -344,6 +536,7 @@ CONFIG_NETDEVICES=y
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
 
 #
 # Ethernet (10 or 100Mbit)
@@ -378,6 +571,7 @@ CONFIG_SGI_IOC3_ETH=y
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
 # CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
 # CONFIG_PLIP is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
@@ -392,6 +586,8 @@ CONFIG_SGI_IOC3_ETH=y
 #
 # CONFIG_TR is not set
 # CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
 
 #
 # Wan interfaces
@@ -401,7 +597,34 @@ CONFIG_SGI_IOC3_ETH=y
 #
 # Amateur Radio support
 #
-# CONFIG_HAMRADIO is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+CONFIG_AX25=m
+CONFIG_AX25_DAMA_SLAVE=y
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+
+#
+# AX.25 network device drivers
+#
+
+#
+# AX.25 network device drivers
+#
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+# CONFIG_SCC_DELAY is not set
+# CONFIG_SCC_TRXECHO is not set
+# CONFIG_BAYCOM_SER_FDX is not set
+# CONFIG_BAYCOM_SER_HDX is not set
+# CONFIG_BAYCOM_PAR is not set
+# CONFIG_BAYCOM_EPP is not set
+# CONFIG_SOUNDMODEM is not set
+# CONFIG_YAM is not set
 
 #
 # IrDA (infrared) support
@@ -431,6 +654,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -473,8 +697,7 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
-CONFIG_SGI_IP27_RTC=y
+CONFIG_SGI_IP27_RTC=m
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -493,11 +716,11 @@ CONFIG_SGI_IP27_RTC=y
 #
 # File systems
 #
-# CONFIG_QUOTA is not set
-# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
 CONFIG_AUTOFS_FS=y
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_REISERFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
 # CONFIG_ADFS_FS is not set
@@ -511,43 +734,43 @@ CONFIG_AUTOFS_FS=y
 CONFIG_EXT3_FS=y
 CONFIG_JBD=y
 # CONFIG_JBD_DEBUG is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_MSDOS_FS is not set
-# CONFIG_UMSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_UMSDOS_FS=m
+CONFIG_VFAT_FS=m
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
 # CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_TMPFS is not set
+CONFIG_CRAMFS=m
+CONFIG_TMPFS=y
 CONFIG_RAMFS=y
-# CONFIG_ISO9660_FS is not set
-# CONFIG_JOLIET is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_JFS_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_JFS_FS=m
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_NTFS_FS is not set
+CONFIG_MINIX_FS=m
+CONFIG_VXFS_FS=m
+CONFIG_NTFS_FS=m
 # CONFIG_NTFS_RW is not set
-# CONFIG_HPFS_FS is not set
+CONFIG_HPFS_FS=m
 CONFIG_PROC_FS=y
 # CONFIG_DEVFS_FS is not set
 # CONFIG_DEVFS_MOUNT is not set
 # CONFIG_DEVFS_DEBUG is not set
 CONFIG_DEVPTS_FS=y
-# CONFIG_QNX4FS_FS is not set
+CONFIG_QNX4FS_FS=m
 # CONFIG_QNX4FS_RW is not set
-# CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ROMFS_FS=m
+CONFIG_EXT2_FS=m
+CONFIG_SYSV_FS=m
+CONFIG_UDF_FS=m
 # CONFIG_UDF_RW is not set
-# CONFIG_UFS_FS is not set
+CONFIG_UFS_FS=m
 # CONFIG_UFS_FS_WRITE is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_XFS_QUOTA is not set
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
 # CONFIG_XFS_RT is not set
 # CONFIG_XFS_TRACE is not set
 # CONFIG_XFS_DEBUG is not set
@@ -561,23 +784,25 @@ CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_ROOT_NFS=y
-# CONFIG_NFSD is not set
-# CONFIG_NFSD_V3 is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
 # CONFIG_NFSD_TCP is not set
 CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_SMB_FS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_NCPFS_PACKET_SIGNING is not set
-# CONFIG_NCPFS_IOCTL_LOCKING is not set
-# CONFIG_NCPFS_STRONG is not set
-# CONFIG_NCPFS_NFS_NS is not set
-# CONFIG_NCPFS_OS2_NS is not set
-# CONFIG_NCPFS_SMALLDOS is not set
-# CONFIG_NCPFS_NLS is not set
-# CONFIG_NCPFS_EXTRAS is not set
-# CONFIG_ZISOFS_FS is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_SMB_UNIX=y
+CONFIG_NCP_FS=m
+CONFIG_NCPFS_PACKET_SIGNING=y
+CONFIG_NCPFS_IOCTL_LOCKING=y
+CONFIG_NCPFS_STRONG=y
+CONFIG_NCPFS_NFS_NS=y
+CONFIG_NCPFS_OS2_NS=y
+CONFIG_NCPFS_SMALLDOS=y
+CONFIG_NCPFS_NLS=y
+CONFIG_NCPFS_EXTRAS=y
+CONFIG_ZISOFS_FS=m
 
 #
 # Partition Types
@@ -598,8 +823,50 @@ CONFIG_SGI_PARTITION=y
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
 # CONFIG_EFI_PARTITION is not set
-# CONFIG_SMB_NLS is not set
-# CONFIG_NLS is not set
+CONFIG_SMB_NLS=y
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
 
 #
 # Multimedia devices
@@ -647,5 +914,5 @@ CONFIG_LOG_BUF_SHIFT=0
 # Library routines
 #
 # CONFIG_CRC32 is not set
-# CONFIG_ZLIB_INFLATE is not set
+CONFIG_ZLIB_INFLATE=m
 # CONFIG_ZLIB_DEFLATE is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-atlas linux-mips-cvs-20040815/arch/mips64/defconfig-atlas
--- linux-2.4.27/arch/mips64/defconfig-atlas	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-atlas	2004-08-15 08:05:51.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_MIPS_ATLAS=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -76,9 +79,7 @@ CONFIG_L1_CACHE_SHIFT=5
 CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_MSC=y
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_PCI=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
 # CONFIG_MIPS_AU1000 is not set
@@ -119,6 +120,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -140,6 +144,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -169,6 +174,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -215,7 +221,6 @@ CONFIG_IP_PNP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -306,6 +311,14 @@ CONFIG_SD_EXTRA_DEVS=40
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -456,6 +469,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -498,7 +512,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-decstation linux-mips-cvs-20040815/arch/mips64/defconfig-decstation
--- linux-2.4.27/arch/mips64/defconfig-decstation	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-decstation	2004-08-15 08:05:51.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_DECSTATION=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -71,10 +74,10 @@ CONFIG_DECSTATION=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_EARLY_PRINTK=y
 CONFIG_BOOT_ELF32=y
 CONFIG_IRQ_CPU=y
 CONFIG_L1_CACHE_SHIFT=4
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -134,6 +137,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -163,6 +167,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -208,7 +213,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -300,6 +304,14 @@ CONFIG_SCSI_DECNCR=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
@@ -460,6 +472,7 @@ CONFIG_SERIAL_DEC=y
 CONFIG_SERIAL_DEC_CONSOLE=y
 # CONFIG_DZ is not set
 CONFIG_ZS=y
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -502,7 +515,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-ip22 linux-mips-cvs-20040815/arch/mips64/defconfig-ip22
--- linux-2.4.27/arch/mips64/defconfig-ip22	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-ip22	2004-08-15 08:05:51.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -81,7 +84,6 @@ CONFIG_BOOT_ELF32=y
 CONFIG_SWAP_IO_SPACE_L=y
 CONFIG_IRQ_CPU=y
 CONFIG_L1_CACHE_SHIFT=5
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_PC_KEYB=y
 # CONFIG_MIPS_AU1000 is not set
@@ -123,8 +125,8 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_ARC_CONSOLE=y
 CONFIG_NET=y
-# CONFIG_EISA is not set
 # CONFIG_PCI is not set
+# CONFIG_EISA is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -145,6 +147,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -174,6 +177,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -220,7 +224,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -313,6 +316,14 @@ CONFIG_SGIWD93_SCSI=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
@@ -472,6 +483,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
 CONFIG_IP22_SERIAL=y
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -534,13 +546,11 @@ CONFIG_WATCHDOG=y
 # CONFIG_WDTPCI is not set
 # CONFIG_MACHZ_WDT is not set
 # CONFIG_INDYDOG is not set
-# CONFIG_AMD7XX_TCO is not set
 # CONFIG_SCx200 is not set
 # CONFIG_SCx200_GPIO is not set
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 CONFIG_DS1286=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-ip27 linux-mips-cvs-20040815/arch/mips64/defconfig-ip27
--- linux-2.4.27/arch/mips64/defconfig-ip27	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-ip27	2004-08-15 08:05:51.000000000 +0200
@@ -8,12 +8,14 @@ CONFIG_MIPS64=y
 #
 # Code maturity level options
 #
-# CONFIG_EXPERIMENTAL is not set
+CONFIG_EXPERIMENTAL=y
 
 #
 # Loadable module support
 #
-# CONFIG_MODULES is not set
+CONFIG_MODULES=y
+CONFIG_MODVERSIONS=y
+CONFIG_KMOD=y
 
 #
 # Machine selection
@@ -24,10 +26,12 @@ CONFIG_MIPS64=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +54,7 @@ CONFIG_MIPS64=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -81,8 +86,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_BOOT_ELF64=y
 CONFIG_ARC64=y
 CONFIG_L1_CACHE_SHIFT=7
-CONFIG_NEW_TIME_C=y
-CONFIG_PCI=y
 CONFIG_QL_ISP_A64=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -107,6 +110,8 @@ CONFIG_CPU_R10000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_SMP=y
 # CONFIG_64BIT_PHYS_ADDR is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -122,6 +127,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_BINFMT_IRIX is not set
 # CONFIG_MIPS_INSANE_LARGE is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+CONFIG_PCI_AUTO=y
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -143,6 +151,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -172,6 +181,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -196,8 +206,9 @@ CONFIG_BINFMT_ELF32=y
 CONFIG_PACKET=y
 CONFIG_PACKET_MMAP=y
 CONFIG_NETLINK_DEV=y
-# CONFIG_NETFILTER is not set
-# CONFIG_FILTER is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_FILTER=y
 CONFIG_UNIX=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
@@ -206,35 +217,199 @@ CONFIG_IP_PNP=y
 # CONFIG_IP_PNP_DHCP is not set
 # CONFIG_IP_PNP_BOOTP is not set
 # CONFIG_IP_PNP_RARP is not set
-# CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
-# CONFIG_IP_MROUTE is not set
-# CONFIG_INET_ECN is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_INET_ECN=y
 # CONFIG_SYN_COOKIES is not set
-# CONFIG_VLAN_8021Q is not set
+
+#
+#   IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=m
+CONFIG_IP_NF_FTP=m
+CONFIG_IP_NF_AMANDA=m
+CONFIG_IP_NF_TFTP=m
+CONFIG_IP_NF_IRC=m
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_LIMIT=m
+CONFIG_IP_NF_MATCH_MAC=m
+CONFIG_IP_NF_MATCH_PKTTYPE=m
+CONFIG_IP_NF_MATCH_MARK=m
+CONFIG_IP_NF_MATCH_MULTIPORT=m
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_DSCP=m
+CONFIG_IP_NF_MATCH_AH_ESP=m
+CONFIG_IP_NF_MATCH_LENGTH=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_MATCH_TCPMSS=m
+CONFIG_IP_NF_MATCH_HELPER=m
+CONFIG_IP_NF_MATCH_STATE=m
+CONFIG_IP_NF_MATCH_CONNTRACK=m
+# CONFIG_IP_NF_MATCH_UNCLEAN is not set
+# CONFIG_IP_NF_MATCH_OWNER is not set
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+# CONFIG_IP_NF_TARGET_MIRROR is not set
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_NAT_AMANDA=m
+CONFIG_IP_NF_NAT_LOCAL=y
+# CONFIG_IP_NF_NAT_SNMP_BASIC is not set
+CONFIG_IP_NF_NAT_IRC=m
+CONFIG_IP_NF_NAT_FTP=m
+CONFIG_IP_NF_NAT_TFTP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_DSCP=m
+CONFIG_IP_NF_TARGET_MARK=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_IP_NF_COMPAT_IPCHAINS=m
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_COMPAT_IPFWADM=m
+CONFIG_IP_NF_NAT_NEEDED=y
+
+#
+#   IP: Virtual Server Configuration
+#
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IPV6=m
+
+#
+#   IPv6: Netfilter Configuration
+#
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_LIMIT=m
+CONFIG_IP6_NF_MATCH_MAC=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_MULTIPORT=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP6_NF_MATCH_MARK=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_AHESP=m
+CONFIG_IP6_NF_MATCH_LENGTH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_TARGET_MARK=m
+# CONFIG_KHTTPD is not set
+
+#
+#    SCTP Configuration (EXPERIMENTAL)
+#
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_ATM is not set
+CONFIG_VLAN_8021Q=m
 
 #
 #  
 #
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
+CONFIG_IPX=m
+# CONFIG_IPX_INTERN is not set
+CONFIG_ATALK=m
 
 #
 # Appletalk devices
 #
-# CONFIG_DEV_APPLETALK is not set
-# CONFIG_DECNET is not set
-# CONFIG_BRIDGE is not set
+CONFIG_DEV_APPLETALK=y
+# CONFIG_COPS_DAYNA is not set
+# CONFIG_COPS_TANGENT is not set
+CONFIG_IPDDP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IPDDP_DECAP=y
+CONFIG_DECNET=m
+CONFIG_DECNET_SIOCGIFCONF=y
+CONFIG_DECNET_ROUTER=y
+CONFIG_DECNET_ROUTE_FWMARK=y
+CONFIG_BRIDGE=m
+CONFIG_X25=m
+CONFIG_LAPB=m
+# CONFIG_LLC is not set
+CONFIG_NET_DIVERT=y
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
 
 #
 # QoS and/or fair queueing
 #
-# CONFIG_NET_SCHED is not set
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_CSZ=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+# CONFIG_NET_SCH_NETEM is not set
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_QOS=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+# CONFIG_NET_CLS_POLICE is not set
 
 #
 # Network testing
 #
-# CONFIG_NET_PKTGEN is not set
+CONFIG_NET_PKTGEN=m
 
 #
 # Telephony Support
@@ -259,10 +434,12 @@ CONFIG_SCSI=y
 #
 CONFIG_BLK_DEV_SD=y
 CONFIG_SD_EXTRA_DEVS=40
-CONFIG_CHR_DEV_ST=y
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_SR_EXTRA_DEVS=4
+CONFIG_CHR_DEV_SG=m
 
 #
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
@@ -281,6 +458,7 @@ CONFIG_SCSI_LOGGING=y
 # CONFIG_SCSI_AHA152X is not set
 # CONFIG_SCSI_AHA1542 is not set
 # CONFIG_SCSI_AHA1740 is not set
+# CONFIG_SCSI_AACRAID is not set
 # CONFIG_SCSI_AIC7XXX is not set
 # CONFIG_SCSI_AIC79XX is not set
 # CONFIG_SCSI_AIC7XXX_OLD is not set
@@ -290,6 +468,14 @@ CONFIG_SCSI_LOGGING=y
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -321,6 +507,7 @@ CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_SCSI_T128 is not set
 # CONFIG_SCSI_U14_34F is not set
 # CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
 
 #
 # Fusion MPT device support
@@ -332,6 +519,11 @@ CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_FUSION_LAN is not set
 
 #
+# IEEE 1394 (FireWire) support (EXPERIMENTAL)
+#
+# CONFIG_IEEE1394 is not set
+
+#
 # Network device support
 #
 CONFIG_NETDEVICES=y
@@ -344,6 +536,7 @@ CONFIG_NETDEVICES=y
 # CONFIG_BONDING is not set
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
 
 #
 # Ethernet (10 or 100Mbit)
@@ -378,6 +571,7 @@ CONFIG_SGI_IOC3_ETH=y
 # CONFIG_SK98LIN is not set
 # CONFIG_TIGON3 is not set
 # CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
 # CONFIG_PLIP is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
@@ -392,6 +586,8 @@ CONFIG_SGI_IOC3_ETH=y
 #
 # CONFIG_TR is not set
 # CONFIG_NET_FC is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
 
 #
 # Wan interfaces
@@ -401,7 +597,34 @@ CONFIG_SGI_IOC3_ETH=y
 #
 # Amateur Radio support
 #
-# CONFIG_HAMRADIO is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+CONFIG_AX25=m
+CONFIG_AX25_DAMA_SLAVE=y
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+
+#
+# AX.25 network device drivers
+#
+
+#
+# AX.25 network device drivers
+#
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+# CONFIG_SCC_DELAY is not set
+# CONFIG_SCC_TRXECHO is not set
+# CONFIG_BAYCOM_SER_FDX is not set
+# CONFIG_BAYCOM_SER_HDX is not set
+# CONFIG_BAYCOM_PAR is not set
+# CONFIG_BAYCOM_EPP is not set
+# CONFIG_SOUNDMODEM is not set
+# CONFIG_YAM is not set
 
 #
 # IrDA (infrared) support
@@ -431,6 +654,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -473,8 +697,7 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
-CONFIG_SGI_IP27_RTC=y
+CONFIG_SGI_IP27_RTC=m
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -493,11 +716,11 @@ CONFIG_SGI_IP27_RTC=y
 #
 # File systems
 #
-# CONFIG_QUOTA is not set
-# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTA=y
+CONFIG_QFMT_V2=y
 CONFIG_AUTOFS_FS=y
-# CONFIG_AUTOFS4_FS is not set
-# CONFIG_REISERFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
 # CONFIG_ADFS_FS is not set
@@ -511,43 +734,43 @@ CONFIG_AUTOFS_FS=y
 CONFIG_EXT3_FS=y
 CONFIG_JBD=y
 # CONFIG_JBD_DEBUG is not set
-# CONFIG_FAT_FS is not set
-# CONFIG_MSDOS_FS is not set
-# CONFIG_UMSDOS_FS is not set
-# CONFIG_VFAT_FS is not set
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_UMSDOS_FS=m
+CONFIG_VFAT_FS=m
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
 # CONFIG_JFFS2_FS is not set
-# CONFIG_CRAMFS is not set
-# CONFIG_TMPFS is not set
+CONFIG_CRAMFS=m
+CONFIG_TMPFS=y
 CONFIG_RAMFS=y
-# CONFIG_ISO9660_FS is not set
-# CONFIG_JOLIET is not set
-# CONFIG_ZISOFS is not set
-# CONFIG_JFS_FS is not set
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_JFS_FS=m
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_VXFS_FS is not set
-# CONFIG_NTFS_FS is not set
+CONFIG_MINIX_FS=m
+CONFIG_VXFS_FS=m
+CONFIG_NTFS_FS=m
 # CONFIG_NTFS_RW is not set
-# CONFIG_HPFS_FS is not set
+CONFIG_HPFS_FS=m
 CONFIG_PROC_FS=y
 # CONFIG_DEVFS_FS is not set
 # CONFIG_DEVFS_MOUNT is not set
 # CONFIG_DEVFS_DEBUG is not set
 CONFIG_DEVPTS_FS=y
-# CONFIG_QNX4FS_FS is not set
+CONFIG_QNX4FS_FS=m
 # CONFIG_QNX4FS_RW is not set
-# CONFIG_ROMFS_FS is not set
-CONFIG_EXT2_FS=y
-# CONFIG_SYSV_FS is not set
-# CONFIG_UDF_FS is not set
+CONFIG_ROMFS_FS=m
+CONFIG_EXT2_FS=m
+CONFIG_SYSV_FS=m
+CONFIG_UDF_FS=m
 # CONFIG_UDF_RW is not set
-# CONFIG_UFS_FS is not set
+CONFIG_UFS_FS=m
 # CONFIG_UFS_FS_WRITE is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_XFS_QUOTA is not set
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
 # CONFIG_XFS_RT is not set
 # CONFIG_XFS_TRACE is not set
 # CONFIG_XFS_DEBUG is not set
@@ -561,23 +784,25 @@ CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 # CONFIG_NFS_DIRECTIO is not set
 CONFIG_ROOT_NFS=y
-# CONFIG_NFSD is not set
-# CONFIG_NFSD_V3 is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V3=y
 # CONFIG_NFSD_TCP is not set
 CONFIG_SUNRPC=y
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
-# CONFIG_SMB_FS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_NCPFS_PACKET_SIGNING is not set
-# CONFIG_NCPFS_IOCTL_LOCKING is not set
-# CONFIG_NCPFS_STRONG is not set
-# CONFIG_NCPFS_NFS_NS is not set
-# CONFIG_NCPFS_OS2_NS is not set
-# CONFIG_NCPFS_SMALLDOS is not set
-# CONFIG_NCPFS_NLS is not set
-# CONFIG_NCPFS_EXTRAS is not set
-# CONFIG_ZISOFS_FS is not set
+CONFIG_SMB_FS=m
+# CONFIG_SMB_NLS_DEFAULT is not set
+CONFIG_SMB_UNIX=y
+CONFIG_NCP_FS=m
+CONFIG_NCPFS_PACKET_SIGNING=y
+CONFIG_NCPFS_IOCTL_LOCKING=y
+CONFIG_NCPFS_STRONG=y
+CONFIG_NCPFS_NFS_NS=y
+CONFIG_NCPFS_OS2_NS=y
+CONFIG_NCPFS_SMALLDOS=y
+CONFIG_NCPFS_NLS=y
+CONFIG_NCPFS_EXTRAS=y
+CONFIG_ZISOFS_FS=m
 
 #
 # Partition Types
@@ -598,8 +823,50 @@ CONFIG_SGI_PARTITION=y
 # CONFIG_ULTRIX_PARTITION is not set
 # CONFIG_SUN_PARTITION is not set
 # CONFIG_EFI_PARTITION is not set
-# CONFIG_SMB_NLS is not set
-# CONFIG_NLS is not set
+CONFIG_SMB_NLS=y
+CONFIG_NLS=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
 
 #
 # Multimedia devices
@@ -647,5 +914,5 @@ CONFIG_LOG_BUF_SHIFT=0
 # Library routines
 #
 # CONFIG_CRC32 is not set
-# CONFIG_ZLIB_INFLATE is not set
+CONFIG_ZLIB_INFLATE=m
 # CONFIG_ZLIB_DEFLATE is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-jaguar linux-mips-cvs-20040815/arch/mips64/defconfig-jaguar
--- linux-2.4.27/arch/mips64/defconfig-jaguar	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-jaguar	2004-08-15 08:05:51.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -115,6 +118,8 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
 # CONFIG_PCI is not set
+# CONFIG_PCI_NEW is not set
+CONFIG_PCI_AUTO=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -135,6 +140,7 @@ CONFIG_MIPS32_N32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -164,6 +170,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -209,7 +216,6 @@ CONFIG_IP_PNP_DHCP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -395,6 +401,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-malta linux-mips-cvs-20040815/arch/mips64/defconfig-malta
--- linux-2.4.27/arch/mips64/defconfig-malta	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-malta	2004-08-15 08:05:51.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_MIPS_MALTA=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -80,12 +83,10 @@ CONFIG_MIPS_BONITO64=y
 CONFIG_MIPS_GT64120=y
 CONFIG_MIPS_MSC=y
 CONFIG_L1_CACHE_SHIFT=5
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
 CONFIG_PC_KEYB=y
-CONFIG_PCI=y
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -123,6 +124,9 @@ CONFIG_CPU_HAS_SYNC=y
 #
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 CONFIG_PCI_NAMES=y
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -144,6 +148,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -173,6 +178,7 @@ CONFIG_BLK_DEV_FD=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -218,7 +224,6 @@ CONFIG_IP_PNP_BOOTP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -309,6 +314,14 @@ CONFIG_SD_EXTRA_DEVS=40
 # CONFIG_SCSI_AM53C974 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_MEGARAID2 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_SATA_SVW is not set
+# CONFIG_SCSI_SATA_PROMISE is not set
+# CONFIG_SCSI_SATA_SX4 is not set
+# CONFIG_SCSI_SATA_SIL is not set
+# CONFIG_SCSI_SATA_SIS is not set
+# CONFIG_SCSI_SATA_VIA is not set
+# CONFIG_SCSI_SATA_VITESSE is not set
 # CONFIG_SCSI_BUSLOGIC is not set
 # CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
@@ -459,6 +472,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -501,7 +515,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 CONFIG_RTC=y
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-ocelotc linux-mips-cvs-20040815/arch/mips64/defconfig-ocelotc
--- linux-2.4.27/arch/mips64/defconfig-ocelotc	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-ocelotc	2004-08-15 08:05:51.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 CONFIG_MOMENCO_OCELOT_C=y
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -73,10 +76,8 @@ CONFIG_MOMENCO_OCELOT_C=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_PCI=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_NONCOHERENT_IO=y
-CONFIG_NEW_TIME_C=y
 CONFIG_BOOT_ELF32=y
 # CONFIG_MIPS_AU1000 is not set
 
@@ -119,6 +120,9 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
+CONFIG_PCI=y
+# CONFIG_PCI_NEW is not set
+CONFIG_PCI_AUTO=y
 # CONFIG_PCI_NAMES is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
@@ -140,6 +144,7 @@ CONFIG_MIPS32_N32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -169,6 +174,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_BLK_DEV_NBD=y
 # CONFIG_BLK_DEV_RAM is not set
@@ -214,7 +220,6 @@ CONFIG_IP_PNP_DHCP=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -330,6 +335,7 @@ CONFIG_NET_PCI=y
 # CONFIG_FEALNX is not set
 # CONFIG_NATSEMI is not set
 # CONFIG_NE2K_PCI is not set
+# CONFIG_FORCEDETH is not set
 # CONFIG_NE3210 is not set
 # CONFIG_ES3210 is not set
 # CONFIG_8139CP is not set
@@ -445,6 +451,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_SERIAL_TXX9 is not set
 # CONFIG_SERIAL_TXX9_CONSOLE is not set
 # CONFIG_TXX927_SERIAL is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -487,7 +494,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-CONFIG_MIPS_RTC=y
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-sb1250-swarm linux-mips-cvs-20040815/arch/mips64/defconfig-sb1250-swarm
--- linux-2.4.27/arch/mips64/defconfig-sb1250-swarm	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-sb1250-swarm	2004-08-15 08:05:51.000000000 +0200
@@ -26,10 +26,12 @@ CONFIG_KMOD=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -52,6 +54,7 @@ CONFIG_KMOD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -84,7 +87,6 @@ CONFIG_SIBYTE_CFE=y
 # CONFIG_SIBYTE_BW_TRACE is not set
 # CONFIG_SIBYTE_SB1250_PROF is not set
 # CONFIG_SIBYTE_TBPROF is not set
-# CONFIG_PCI is not set
 CONFIG_SIBYTE_GENBUS_IDE=y
 CONFIG_SMP_CAPABLE=y
 # CONFIG_SNI_RM200_PCI is not set
@@ -97,7 +99,6 @@ CONFIG_SMP_CAPABLE=y
 # CONFIG_HIGHMEM is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
-CONFIG_NEW_TIME_C=y
 CONFIG_DUMMY_KEYB=y
 CONFIG_SWAP_IO_SPACE_W=y
 CONFIG_SWAP_IO_SPACE_L=y
@@ -146,6 +147,8 @@ CONFIG_CPU_HAS_SYNC=y
 # CONFIG_BINFMT_IRIX is not set
 CONFIG_NET=y
 # CONFIG_PCI is not set
+# CONFIG_PCI_NEW is not set
+# CONFIG_PCI_AUTO is not set
 # CONFIG_ISA is not set
 # CONFIG_TC is not set
 # CONFIG_MCA is not set
@@ -166,6 +169,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -195,6 +199,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
 # CONFIG_BLK_DEV_RAM is not set
@@ -237,7 +242,6 @@ CONFIG_INET=y
 #
 #    SCTP Configuration (EXPERIMENTAL)
 #
-CONFIG_IPV6_SCTP__=y
 # CONFIG_IP_SCTP is not set
 # CONFIG_ATM is not set
 # CONFIG_VLAN_8021Q is not set
@@ -426,6 +430,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 CONFIG_SIBYTE_SB1250_DUART=y
 CONFIG_SIBYTE_SB1250_DUART_CONSOLE=y
 CONFIG_SERIAL_CONSOLE=y
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
@@ -468,7 +473,6 @@ CONFIG_UNIX98_PTY_COUNT=256
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/defconfig-sead linux-mips-cvs-20040815/arch/mips64/defconfig-sead
--- linux-2.4.27/arch/mips64/defconfig-sead	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/defconfig-sead	2004-08-15 08:05:51.000000000 +0200
@@ -24,10 +24,12 @@ CONFIG_EXPERIMENTAL=y
 # CONFIG_MIPS_DB1000 is not set
 # CONFIG_MIPS_DB1100 is not set
 # CONFIG_MIPS_DB1500 is not set
+# CONFIG_MIPS_DB1550 is not set
 # CONFIG_MIPS_PB1000 is not set
 # CONFIG_MIPS_PB1100 is not set
 # CONFIG_MIPS_PB1500 is not set
 # CONFIG_MIPS_HYDROGEN3 is not set
+# CONFIG_MIPS_PB1550 is not set
 # CONFIG_MIPS_XXS1500 is not set
 # CONFIG_MIPS_MTX1 is not set
 # CONFIG_COGENT_CSB250 is not set
@@ -50,6 +52,7 @@ CONFIG_MIPS_SEAD=y
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_BIG_SUR is not set
 # CONFIG_PMC_YOSEMITE is not set
 # CONFIG_DDB5074 is not set
 # CONFIG_DDB5476 is not set
@@ -73,9 +76,7 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_BOOT_ELF32=y
 CONFIG_L1_CACHE_SHIFT=5
-CONFIG_NEW_TIME_C=y
 CONFIG_NONCOHERENT_IO=y
-# CONFIG_PCI is not set
 # CONFIG_MIPS_AU1000 is not set
 
 #
@@ -134,6 +135,7 @@ CONFIG_MIPS32_O32=y
 CONFIG_BINFMT_ELF32=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_OOM_KILLER is not set
+# CONFIG_CMDLINE_BOOL is not set
 
 #
 # Memory Technology Devices (MTD)
@@ -163,6 +165,7 @@ CONFIG_BINFMT_ELF32=y
 # CONFIG_CISS_MONITOR_THREAD is not set
 # CONFIG_BLK_DEV_DAC960 is not set
 # CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_SX8 is not set
 CONFIG_BLK_DEV_LOOP=y
 # CONFIG_BLK_DEV_NBD is not set
 CONFIG_BLK_DEV_RAM=y
@@ -237,6 +240,7 @@ CONFIG_SERIAL=y
 CONFIG_SERIAL_CONSOLE=y
 # CONFIG_SERIAL_EXTENDED is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_MIPS_HYDROGEN3_BUTTONS is not set
 # CONFIG_UNIX98_PTYS is not set
 
 #
@@ -278,7 +282,6 @@ CONFIG_SERIAL_CONSOLE=y
 # CONFIG_AMD_PM768 is not set
 # CONFIG_NVRAM is not set
 # CONFIG_RTC is not set
-# CONFIG_MIPS_RTC is not set
 # CONFIG_DTLK is not set
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/Makefile linux-mips-cvs-20040815/arch/mips64/kernel/Makefile
--- linux-2.4.27/arch/mips64/kernel/Makefile	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/Makefile	2004-08-15 08:05:52.000000000 +0200
@@ -17,11 +17,11 @@ export-objs	= irq.o mips64_ksyms.o pci-d
 obj-y		:= branch.o cpu-probe.o entry.o irq.o proc.o process.o \
 		   ptrace.o r4k_cache.o r4k_fpu.o r4k_genex.o r4k_switch.o \
 		   reset.o scall_64.o semaphore.o setup.o signal.o syscall.o \
-		   traps.o unaligned.o
+		   time.o traps.o unaligned.o
 
 obj-$(CONFIG_I8259)		+= i8259.o
 obj-$(CONFIG_IRQ_CPU)		+= irq_cpu.o
-obj-$(CONFIG_NEW_TIME_C)	+= time.o
+obj-$(CONFIG_IRQ_CPU_RM7K)	+= irq-rm7000.o
 
 obj-$(CONFIG_MODULES)		+= mips64_ksyms.o
 obj-$(CONFIG_MIPS32_COMPAT)	+= linux32.o signal32.o ioctl32.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/cpu-probe.c linux-mips-cvs-20040815/arch/mips64/kernel/cpu-probe.c
--- linux-2.4.27/arch/mips64/kernel/cpu-probe.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/cpu-probe.c	2004-08-15 08:05:52.000000000 +0200
@@ -274,7 +274,7 @@ static inline void check_daddi(void)
 	extern asmlinkage void handle_daddi_ov(void);
 	unsigned long flags;
 	void *handler;
-	long v;
+	long v, tmp;
 
 	printk("Checking for the daddi bug... ");
 
@@ -294,13 +294,15 @@ static inline void check_daddi(void)
 		".set	noat\n\t"
 		".set	noreorder\n\t"
 		".set	nomacro\n\t"
+		"addiu	%1, $0, %2\n\t"
+		"dsrl	%1, %1, 1\n\t"
 #ifdef HAVE_AS_SET_DADDI
 		".set	daddi\n\t"
 #endif
-		"daddi	%0, %1, %2\n\t"
+		"daddi	%0, %1, %3\n\t"
 		".set	pop"
-		: "=r" (v)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		: "=r" (v), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 	set_except_vector(12, handler);
 	local_irq_restore(flags);
 
@@ -314,9 +316,11 @@ static inline void check_daddi(void)
 	local_irq_save(flags);
 	handler = set_except_vector(12, handle_daddi_ov);
 	asm volatile(
-		"daddi	%0, %1, %2"
-		: "=r" (v)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		"addiu	%1, $0, %2\n\t"
+		"dsrl	%1, %1, 1\n\t"
+		"daddi	%0, %1, %3"
+		: "=r" (v), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 	set_except_vector(12, handler);
 	local_irq_restore(flags);
 
@@ -337,7 +341,7 @@ static inline void check_daddi(void)
 
 static inline void check_daddiu(void)
 {
-	long v, w;
+	long v, w, tmp;
 
 	printk("Checking for the daddiu bug... ");
 
@@ -362,15 +366,17 @@ static inline void check_daddiu(void)
 		".set	noat\n\t"
 		".set	noreorder\n\t"
 		".set	nomacro\n\t"
+		"addiu	%2, $0, %3\n\t"
+		"dsrl	%2, %2, 1\n\t"
 #ifdef HAVE_AS_SET_DADDI
 		".set	daddi\n\t"
 #endif
-		"daddiu	%0, %2, %3\n\t"
-		"addiu	%1, $0, %3\n\t"
+		"daddiu	%0, %2, %4\n\t"
+		"addiu	%1, $0, %4\n\t"
 		"daddu	%1, %2\n\t"
 		".set	pop"
-		: "=&r" (v), "=&r" (w)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		: "=&r" (v), "=&r" (w), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 
 	if (v == w) {
 		printk("no.\n");
@@ -380,11 +386,13 @@ static inline void check_daddiu(void)
 	printk("yes, workaround... ");
 
 	asm volatile(
-		"daddiu	%0, %2, %3\n\t"
-		"addiu	%1, $0, %3\n\t"
+		"addiu	%2, $0, %3\n\t"
+		"dsrl	%2, %2, 1\n\t"
+		"daddiu	%0, %2, %4\n\t"
+		"addiu	%1, $0, %4\n\t"
 		"daddu	%1, %2"
-		: "=&r" (v), "=&r" (w)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		: "=&r" (v), "=&r" (w), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 
 	if (v == w) {
 		printk("yes.\n");
@@ -462,8 +470,7 @@ static inline void cpu_probe_legacy(stru
 	case PRID_IMP_R2000:
 		c->cputype = CPU_R2000;
 		c->isa_level = MIPS_CPU_ISA_I;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX |
-		             MIPS_CPU_LLSC;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX;
 		if (__cpu_has_fpu())
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
@@ -477,17 +484,24 @@ static inline void cpu_probe_legacy(stru
 		else
 			c->cputype = CPU_R3000;
 		c->isa_level = MIPS_CPU_ISA_I;
-		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX |
-		             MIPS_CPU_LLSC;
+		c->options = MIPS_CPU_TLB | MIPS_CPU_NOFPUEX; 
 		if (__cpu_has_fpu())
 			c->options |= MIPS_CPU_FPU;
 		c->tlbsize = 64;
 		break;
 	case PRID_IMP_R4000:
-		if ((c->processor_id & 0xff) >= PRID_REV_R4400)
-			c->cputype = CPU_R4400SC;
-		else
-			c->cputype = CPU_R4000SC;
+		if (read_c0_config() & CONF_SC) {
+			if ((c->processor_id & 0xff) >= PRID_REV_R4400)
+				c->cputype = CPU_R4400PC;
+			else
+				c->cputype = CPU_R4000PC;
+		} else {
+			if ((c->processor_id & 0xff) >= PRID_REV_R4400)
+				c->cputype = CPU_R4400SC;
+			else
+				c->cputype = CPU_R4000SC;
+		}
+
 		c->isa_level = MIPS_CPU_ISA_III;
 		c->options = R4K_OPTS | MIPS_CPU_FPU | MIPS_CPU_32FPR |
 		             MIPS_CPU_WATCH | MIPS_CPU_VCE |
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/gdb-low.S linux-mips-cvs-20040815/arch/mips64/kernel/gdb-low.S
--- linux-2.4.27/arch/mips64/kernel/gdb-low.S	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips64/kernel/gdb-low.S	2004-08-15 08:05:52.000000000 +0200
@@ -283,7 +283,7 @@
 		ld	v0,GDB_FR_HI(sp)
 		ld	v1,GDB_FR_LO(sp)
 		mthi	v0
-		mtlo	v0
+		mtlo	v1
 		ld	ra,GDB_FR_REG31(sp)
 		ld	fp,GDB_FR_REG30(sp)
 		ld	gp,GDB_FR_REG28(sp)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/ioctl32.c linux-mips-cvs-20040815/arch/mips64/kernel/ioctl32.c
--- linux-2.4.27/arch/mips64/kernel/ioctl32.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/ioctl32.c	2004-08-15 08:05:52.000000000 +0200
@@ -44,6 +44,7 @@
 #include <linux/blkpg.h>
 #include <linux/blk.h>
 #include <linux/elevator.h>
+#include <linux/file.h>
 #include <linux/rtc.h>
 #include <linux/pci.h>
 #if defined(CONFIG_BLK_DEV_LVM) || defined(CONFIG_BLK_DEV_LVM_MODULE)
@@ -1817,7 +1818,6 @@ static struct ioctl32_list ioctl32_handl
 	IOCTL32_DEFAULT(_IOR('v' , BASE_VIDIOCPRIVATE+6, int)),
 	IOCTL32_DEFAULT(_IOR('v' , BASE_VIDIOCPRIVATE+7, int)),
 
-#ifdef CONFIG_NET
 	/* Socket level stuff */
 	IOCTL32_DEFAULT(FIOSETOWN),
 	IOCTL32_DEFAULT(SIOCSPGRP),
@@ -2079,6 +2079,7 @@ static struct ioctl32_list ioctl32_handl
 	IOCTL32_DEFAULT(SOUND_MIXER_SETLEVELS),
 	IOCTL32_DEFAULT(OSS_GETVERSION),
 
+#ifdef CONFIG_NET
 	/* And these ioctls need translation */
 	IOCTL32_HANDLER(SIOCGIFNAME, dev_ifname32),
 	IOCTL32_HANDLER(SIOCGIFCONF, dev_ifconf),
@@ -2120,7 +2121,6 @@ static struct ioctl32_list ioctl32_handl
 	 */
 	IOCTL32_HANDLER(SIOCRTMSG, ret_einval),
 	IOCTL32_HANDLER(SIOCGSTAMP, do_siocgstamp),
-
 #endif /* CONFIG_NET */
 
 	IOCTL32_HANDLER(BLKRAGET, w_long),
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/irq-rm7000.c linux-mips-cvs-20040815/arch/mips64/kernel/irq-rm7000.c
--- linux-2.4.27/arch/mips64/kernel/irq-rm7000.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/irq-rm7000.c	2004-03-12 17:01:18.000000000 +0100
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2003 Ralf Baechle
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Handler for RM7000 extended interrupts.  These are a non-standard
+ * feature so we handle them separately from standard interrupts.
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+static int irq_base;
+
+static inline void unmask_rm7k_irq(unsigned int irq)
+{
+	set_c0_intcontrol(0x100 << (irq - irq_base));
+}
+
+static inline void mask_rm7k_irq(unsigned int irq)
+{
+	clear_c0_intcontrol(0x100 << (irq - irq_base));
+}
+
+static inline void rm7k_cpu_irq_enable(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	unmask_rm7k_irq(irq);
+	local_irq_restore(flags);
+}
+
+static void rm7k_cpu_irq_disable(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	mask_rm7k_irq(irq);
+	local_irq_restore(flags);
+}
+
+static unsigned int rm7k_cpu_irq_startup(unsigned int irq)
+{
+	rm7k_cpu_irq_enable(irq);
+
+	return 0;
+}
+
+#define	rm7k_cpu_irq_shutdown	rm7k_cpu_irq_disable
+
+/*
+ * While we ack the interrupt interrupts are disabled and thus we don't need
+ * to deal with concurrency issues.  Same for rm7k_cpu_irq_end.
+ */
+static void rm7k_cpu_irq_ack(unsigned int irq)
+{
+	mask_rm7k_irq(irq);
+}
+
+static void rm7k_cpu_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		unmask_rm7k_irq(irq);
+}
+
+static hw_irq_controller rm7k_irq_controller = {
+	"RM7000",
+	rm7k_cpu_irq_startup,
+	rm7k_cpu_irq_shutdown,
+	rm7k_cpu_irq_enable,
+	rm7k_cpu_irq_disable,
+	rm7k_cpu_irq_ack,
+	rm7k_cpu_irq_end,
+};
+
+void __init rm7k_cpu_irq_init(int base)
+{
+	int i;
+
+	clear_c0_intcontrol(0x00000f00);		/* Mask all */
+
+	for (i = base; i < base + 4; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &rm7k_irq_controller;
+	}
+
+	irq_base = base;
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/irq_cpu.c linux-mips-cvs-20040815/arch/mips64/kernel/irq_cpu.c
--- linux-2.4.27/arch/mips64/kernel/irq_cpu.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips64/kernel/irq_cpu.c	2004-02-11 16:08:49.000000000 +0100
@@ -16,18 +16,20 @@
  * Almost all MIPS CPUs define 8 interrupt sources.  They are typically
  * level triggered (i.e., cannot be cleared from CPU; must be cleared from
  * device).  The first two are software interrupts which we don't really
- * use or support.  The last one is usually cpu timer interrupt if a counter
- * register is present.
+ * use or support.  The last one is usually the CPU timer interrupt if
+ * counter register is present or, for CPUs with an external FPU, by
+ * convention it's the FPU exception interrupt.
  *
  * Don't even think about using this on SMP.  You have been warned.
  *
  * This file exports one global function:
- *	mips_cpu_irq_init(u32 irq_base);
+ *	void mips_cpu_irq_init(int irq_base);
  */
+#include <linux/init.h>
 #include <linux/interrupt.h>
-#include <linux/types.h>
 #include <linux/kernel.h>
 
+#include <asm/irq_cpu.h>
 #include <asm/mipsregs.h>
 #include <asm/system.h>
 
@@ -78,7 +80,7 @@ static unsigned int mips_cpu_irq_startup
 static void mips_cpu_irq_ack(unsigned int irq)
 {
 	/* Only necessary for soft interrupts */
-	clear_c0_cause(1 << (irq - mips_cpu_irq_base + 8));
+	clear_c0_cause(0x100 << (irq - mips_cpu_irq_base));
 
 	mask_mips_irq(irq);
 }
@@ -90,7 +92,7 @@ static void mips_cpu_irq_end(unsigned in
 }
 
 static hw_irq_controller mips_cpu_irq_controller = {
-	"CPU_irq",
+	"MIPS",
 	mips_cpu_irq_startup,
 	mips_cpu_irq_shutdown,
 	mips_cpu_irq_enable,
@@ -101,9 +103,9 @@ static hw_irq_controller mips_cpu_irq_co
 };
 
 
-void mips_cpu_irq_init(u32 irq_base)
+void __init mips_cpu_irq_init(int irq_base)
 {
-	u32 i;
+	int i;
 
 	for (i = irq_base; i < irq_base + 8; i++) {
 		irq_desc[i].status = IRQ_DISABLED;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/linux32.c linux-mips-cvs-20040815/arch/mips64/kernel/linux32.c
--- linux-2.4.27/arch/mips64/kernel/linux32.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/linux32.c	2004-08-15 08:05:52.000000000 +0200
@@ -2166,9 +2166,10 @@ do_sys32_shmctl (int first, int second, 
 
 static inline void *alloc_user_space(long len)
 {
-	unsigned long sp = (unsigned long) current + THREAD_SIZE - 32;
+	struct pt_regs *regs = (struct pt_regs *)
+		((unsigned long) current + THREAD_SIZE - 32) - 1;
  
-	return (void *) (sp - len);
+	return (void *) (regs->regs[29] - len);
 }
 
 static int sys32_semtimedop(int semid, struct sembuf *tsems, int nsems,
@@ -3097,36 +3098,378 @@ asmlinkage long sys32_socketcall(int cal
 
 #ifdef CONFIG_MODULES
 
-/* From sparc64 */
+extern asmlinkage unsigned long sys_create_module(const char *name_user, size_t size);
 
-struct kernel_sym32 {
-        u32 value;
-        char name[60];
+asmlinkage unsigned long sys32_create_module(const char *name_user, __kernel_size_t32 size)
+{
+	return sys_create_module(name_user, (size_t)size);
+}
+
+extern asmlinkage int sys_init_module(const char *name_user, struct module *mod_user);
+
+/* Hey, when you're trying to init module, take time and prepare us a nice 64bit
+ * module structure, even if from 32bit modutils... Why to pollute kernel... :))
+ */
+asmlinkage int sys32_init_module(const char *name_user, struct module *mod_user)
+{
+	return sys_init_module(name_user, mod_user);
+}
+
+extern asmlinkage int sys_delete_module(const char *name_user);
+
+asmlinkage int sys32_delete_module(const char *name_user)
+{
+	return sys_delete_module(name_user);
+}
+
+struct module_info32 {
+	u32 addr;
+	u32 size;
+	u32 flags;
+	s32 usecount;
 };
 
+/* Query various bits about modules.  */
+
+static inline long
+get_mod_name(const char *user_name, char **buf)
+{
+	unsigned long page;
+	long retval;
+
+	if ((unsigned long)user_name >= TASK_SIZE
+	    && !segment_eq(get_fs (), KERNEL_DS))
+		return -EFAULT;
+
+	page = __get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	retval = strncpy_from_user((char *)page, user_name, PAGE_SIZE);
+	if (retval > 0) {
+		if (retval < PAGE_SIZE) {
+			*buf = (char *)page;
+			return retval;
+		}
+		retval = -ENAMETOOLONG;
+	} else if (!retval)
+		retval = -EINVAL;
+
+	free_page(page);
+	return retval;
+}
+
+static inline void
+put_mod_name(char *buf)
+{
+	free_page((unsigned long)buf);
+}
+
+static __inline__ struct module *find_module(const char *name)
+{
+	struct module *mod;
+
+	for (mod = module_list; mod ; mod = mod->next) {
+		if (mod->flags & MOD_DELETED)
+			continue;
+		if (!strcmp(mod->name, name))
+			break;
+	}
+
+	return mod;
+}
+
+static int
+qm_modules(char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	struct module *mod;
+	size_t nmod, space, len;
+
+	nmod = space = 0;
+
+	for (mod = module_list; mod->next != NULL; mod = mod->next, ++nmod) {
+		len = strlen(mod->name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+		if (copy_to_user(buf, mod->name, len))
+			return -EFAULT;
+		buf += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	if (put_user(nmod, ret))
+		return -EFAULT;
+	else
+		return 0;
+
+calc_space_needed:
+	space += len;
+	while ((mod = mod->next)->next != NULL)
+		space += strlen(mod->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static int
+qm_deps(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	size_t i, space, len;
+
+	if (mod->next == NULL)
+		return -EINVAL;
+	if (!MOD_CAN_QUERY(mod))
+		return put_user(0, ret);
+
+	space = 0;
+	for (i = 0; i < mod->ndeps; ++i) {
+		const char *dep_name = mod->deps[i].dep->name;
+
+		len = strlen(dep_name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+		if (copy_to_user(buf, dep_name, len))
+			return -EFAULT;
+		buf += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	return put_user(i, ret);
+
+calc_space_needed:
+	space += len;
+	while (++i < mod->ndeps)
+		space += strlen(mod->deps[i].dep->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static int
+qm_refs(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	size_t nrefs, space, len;
+	struct module_ref *ref;
+
+	if (mod->next == NULL)
+		return -EINVAL;
+	if (!MOD_CAN_QUERY(mod))
+		if (put_user(0, ret))
+			return -EFAULT;
+		else
+			return 0;
+
+	space = 0;
+	for (nrefs = 0, ref = mod->refs; ref ; ++nrefs, ref = ref->next_ref) {
+		const char *ref_name = ref->ref->name;
+
+		len = strlen(ref_name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+		if (copy_to_user(buf, ref_name, len))
+			return -EFAULT;
+		buf += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	if (put_user(nrefs, ret))
+		return -EFAULT;
+	else
+		return 0;
+
+calc_space_needed:
+	space += len;
+	while ((ref = ref->next_ref) != NULL)
+		space += strlen(ref->ref->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static inline int
+qm_symbols(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	size_t i, space, len;
+	struct module_symbol *s;
+	char *strings;
+	unsigned *vals;
+
+	if (!MOD_CAN_QUERY(mod))
+		if (put_user(0, ret))
+			return -EFAULT;
+		else
+			return 0;
+
+	space = mod->nsyms * 2*sizeof(u32);
+
+	i = len = 0;
+	s = mod->syms;
+
+	if (space > bufsize)
+		goto calc_space_needed;
+
+	if (!access_ok(VERIFY_WRITE, buf, space))
+		return -EFAULT;
+
+	bufsize -= space;
+	vals = (unsigned *)buf;
+	strings = buf+space;
+
+	for (; i < mod->nsyms ; ++i, ++s, vals += 2) {
+		len = strlen(s->name)+1;
+		if (len > bufsize)
+			goto calc_space_needed;
+
+		if (copy_to_user(strings, s->name, len)
+		    || __put_user(s->value, vals+0)
+		    || __put_user(space, vals+1))
+			return -EFAULT;
+
+		strings += len;
+		bufsize -= len;
+		space += len;
+	}
+
+	if (put_user(i, ret))
+		return -EFAULT;
+	else
+		return 0;
+
+calc_space_needed:
+	for (; i < mod->nsyms; ++i, ++s)
+		space += strlen(s->name)+1;
+
+	if (put_user(space, ret))
+		return -EFAULT;
+	else
+		return -ENOSPC;
+}
+
+static inline int
+qm_info(struct module *mod, char *buf, size_t bufsize, __kernel_size_t32 *ret)
+{
+	int error = 0;
+
+	if (mod->next == NULL)
+		return -EINVAL;
+
+	if (sizeof(struct module_info32) <= bufsize) {
+		struct module_info32 info;
+		info.addr = (unsigned long)mod;
+		info.size = mod->size;
+		info.flags = mod->flags;
+		info.usecount =
+			((mod_member_present(mod, can_unload)
+			  && mod->can_unload)
+			 ? -1 : atomic_read(&mod->uc.usecount));
+
+		if (copy_to_user(buf, &info, sizeof(struct module_info32)))
+			return -EFAULT;
+	} else
+		error = -ENOSPC;
+
+	if (put_user(sizeof(struct module_info32), ret))
+		return -EFAULT;
+
+	return error;
+}
+
+asmlinkage int sys32_query_module(char *name_user, int which, char *buf, __kernel_size_t32 bufsize, u32 ret)
+{
+	struct module *mod;
+	int err;
+
+	lock_kernel();
+	if (name_user == 0) {
+		/* This finds "kernel_module" which is not exported. */
+		for(mod = module_list; mod->next != NULL; mod = mod->next)
+			;
+	} else {
+		long namelen;
+		char *name;
+
+		if ((namelen = get_mod_name(name_user, &name)) < 0) {
+			err = namelen;
+			goto out;
+		}
+		err = -ENOENT;
+		if (namelen == 0) {
+			/* This finds "kernel_module" which is not exported. */
+			for(mod = module_list; mod->next != NULL; mod = mod->next)
+				;
+		} else if ((mod = find_module(name)) == NULL) {
+			put_mod_name(name);
+			goto out;
+		}
+		put_mod_name(name);
+	}
+
+	switch (which)
+	{
+	case 0:
+		err = 0;
+		break;
+	case QM_MODULES:
+		err = qm_modules(buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_DEPS:
+		err = qm_deps(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_REFS:
+		err = qm_refs(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_SYMBOLS:
+		err = qm_symbols(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	case QM_INFO:
+		err = qm_info(mod, buf, bufsize, (__kernel_size_t32 *)AA(ret));
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+out:
+	unlock_kernel();
+	return err;
+}
+
+struct kernel_sym32 {
+	u32 value;
+	char name[60];
+};
+		 
 extern asmlinkage int sys_get_kernel_syms(struct kernel_sym *table);
 
 asmlinkage int sys32_get_kernel_syms(struct kernel_sym32 *table)
 {
-        int len, i;
-        struct kernel_sym *tbl;
-        mm_segment_t old_fs;
-
-        len = sys_get_kernel_syms(NULL);
-        if (!table) return len;
-        tbl = kmalloc (len * sizeof (struct kernel_sym), GFP_KERNEL);
-        if (!tbl) return -ENOMEM;
-        old_fs = get_fs();
-        set_fs (KERNEL_DS);
-        sys_get_kernel_syms(tbl);
-        set_fs (old_fs);
-        for (i = 0; i < len; i++, table++) {
-                if (put_user (tbl[i].value, &table->value) ||
-                    copy_to_user (table->name, tbl[i].name, 60))
-                        break;
-        }
-        kfree (tbl);
-        return i;
+	int len, i;
+	struct kernel_sym *tbl;
+	mm_segment_t old_fs;
+	
+	len = sys_get_kernel_syms(NULL);
+	if (!table) return len;
+	tbl = kmalloc (len * sizeof (struct kernel_sym), GFP_KERNEL);
+	if (!tbl) return -ENOMEM;
+	old_fs = get_fs();
+	set_fs (KERNEL_DS);
+	sys_get_kernel_syms(tbl);
+	set_fs (old_fs);
+	for (i = 0; i < len; i++, table++) {
+		if (put_user (tbl[i].value, &table->value) ||
+		    copy_to_user (table->name, tbl[i].name, 60))
+			break;
+	}
+	kfree (tbl);
+	return i;
 }
 
 #else /* CONFIG_MODULES */
@@ -3161,10 +3504,10 @@ sys32_query_module(const char *name_user
 	return -ENOSYS;
 }
 
-asmlinkage long
+asmlinkage int
 sys32_get_kernel_syms(struct kernel_sym *table)
 {
 	return -ENOSYS;
 }
 
-#endif /* CONFIG_MODULES */
+#endif  /* CONFIG_MODULES */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/mips64_ksyms.c linux-mips-cvs-20040815/arch/mips64/kernel/mips64_ksyms.c
--- linux-2.4.27/arch/mips64/kernel/mips64_ksyms.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/mips64_ksyms.c	2004-05-02 00:47:32.000000000 +0200
@@ -53,10 +53,15 @@ EXPORT_SYMBOL_NOVERS(memcmp);
 EXPORT_SYMBOL_NOVERS(memset);
 EXPORT_SYMBOL_NOVERS(memcpy);
 EXPORT_SYMBOL_NOVERS(memmove);
+EXPORT_SYMBOL_NOVERS(memscan);
+EXPORT_SYMBOL_NOVERS(strcpy);
+EXPORT_SYMBOL_NOVERS(strncpy);
 EXPORT_SYMBOL_NOVERS(strcat);
 EXPORT_SYMBOL_NOVERS(strchr);
+EXPORT_SYMBOL_NOVERS(strncmp);
 EXPORT_SYMBOL_NOVERS(strlen);
 EXPORT_SYMBOL_NOVERS(strncat);
+EXPORT_SYMBOL_NOVERS(strcmp);
 EXPORT_SYMBOL_NOVERS(strnlen);
 EXPORT_SYMBOL_NOVERS(strrchr);
 EXPORT_SYMBOL_NOVERS(strtok);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/proc.c linux-mips-cvs-20040815/arch/mips64/kernel/proc.c
--- linux-2.4.27/arch/mips64/kernel/proc.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/proc.c	2004-08-15 08:05:52.000000000 +0200
@@ -48,7 +48,6 @@ static const char *cpu_name[] = {
 	[CPU_R4640]	"R4640",
 	[CPU_NEVADA]	"Nevada",
 	[CPU_RM7000]	"RM7000",
-	[CPU_RM9000]	"RM9000",
 	[CPU_R5432]	"R5432",
 	[CPU_4KC]	"MIPS 4Kc",
         [CPU_5KC]	"MIPS 5Kc",
@@ -58,23 +57,27 @@ static const char *cpu_name[] = {
 	[CPU_TX3922]	"TX3922",
 	[CPU_TX3927]	"TX3927",
 	[CPU_AU1000]	"Au1000",
-	[CPU_AU1500]	"Au1500",
 	[CPU_4KEC]	"MIPS 4KEc",
 	[CPU_4KSC]	"MIPS 4KSc",
 	[CPU_VR41XX]	"NEC Vr41xx",
 	[CPU_R5500]	"R5500",
 	[CPU_TX49XX]	"TX49xx",
+	[CPU_AU1500]	"Au1500",
 	[CPU_20KC]	"MIPS 20Kc",
-	[CPU_24K]	"MIPS 24K",
-	[CPU_25KF]	"MIPS 25Kf",
 	[CPU_VR4111]	"NEC VR4111",
 	[CPU_VR4121]	"NEC VR4121",
 	[CPU_VR4122]	"NEC VR4122",
 	[CPU_VR4131]	"NEC VR4131",
-	[CPU_VR4133]	"NEC VR4133",
 	[CPU_VR4181]	"NEC VR4181",
 	[CPU_VR4181A]	"NEC VR4181A",
-	[CPU_SR71000]	"Sandcraft SR71000"
+	[CPU_AU1100]	"Au1100",
+	[CPU_SR71000]	"Sandcraft SR71000",
+	[CPU_RM9000]	"RM9000",
+	[CPU_25KF]	"MIPS 25Kf",
+	[CPU_VR4133]	"NEC VR4133",
+	[CPU_AU1550]	"Au1550",
+	[CPU_24K]	"MIPS 24K",
+	[CPU_AU1200]	"Au1200",
 };
 
 
@@ -116,7 +119,7 @@ static int show_cpuinfo(struct seq_file 
 	              cpu_has_watch ? "yes" : "no");
 
 	sprintf(fmt, "VCE%%c exceptions\t\t: %s\n",
-	        cpu_has_vce ? "%d" : "not available");
+	        cpu_has_vce ? "%u" : "not available");
 	seq_printf(m, fmt, 'D', vced_count);
 	seq_printf(m, fmt, 'I', vcei_count);
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/scall_64.S linux-mips-cvs-20040815/arch/mips64/kernel/scall_64.S
--- linux-2.4.27/arch/mips64/kernel/scall_64.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/scall_64.S	2004-05-05 14:38:40.000000000 +0200
@@ -31,13 +31,15 @@ NESTED(handle_sys64, PT_SIZE, sp)
 	STI
 	.set	at
 #endif
-	ld	t1, PT_EPC(sp)		# skip syscall on return
 
 	subu	t0, v0, __NR_64_Linux	# check syscall number
 	sltiu	t0, t0,	__NR_64_Linux_syscalls + 1
+#if !defined(CONFIG_MIPS32_O32) && !defined(CONFIG_MIPS32_N32)
+	ld	t1, PT_EPC(sp)		# skip syscall on return
 	daddiu	t1, 4			# skip to next instruction
-	beqz	t0, illegal_syscall
 	sd	t1, PT_EPC(sp)
+#endif
+	beqz	t0, illegal_syscall
 
 	dsll	t0, v0, 3		# offset into table
 	ld	t2, (sys_call_table - (__NR_64_Linux * 8))(t0) # syscall routine
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/scall_n32.S linux-mips-cvs-20040815/arch/mips64/kernel/scall_n32.S
--- linux-2.4.27/arch/mips64/kernel/scall_n32.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/scall_n32.S	2004-05-05 14:38:40.000000000 +0200
@@ -35,13 +35,16 @@ NESTED(handle_sysn32, PT_SIZE, sp)
 	STI
 	.set	at
 #endif
-	ld	t1, PT_EPC(sp)		# skip syscall on return
 
 	subu	t0, v0, __NR_N32_Linux	# check syscall number
 	sltiu	t0, t0,	__NR_N32_Linux_syscalls + 1
+
+#ifndef CONFIG_MIPS32_O32
+	ld	t1, PT_EPC(sp)		# skip syscall on return
 	daddiu	t1, 4			# skip to next instruction
-	beqz	t0, not_n32_scall
 	sd	t1, PT_EPC(sp)
+#endif
+	beqz	t0, not_n32_scall
 
 	dsll	t0, v0, 3		# offset into table
 	ld	t2, (sysn32_call_table - (__NR_N32_Linux * 8))(t0)
@@ -300,11 +303,11 @@ EXPORT(sysn32_call_table)
 	PTR	sys_reboot
 	PTR	sys_sethostname			/* 6165 */
 	PTR	sys_setdomainname
-	PTR	sys_create_module
-	PTR	sys_init_module
-	PTR	sys_delete_module
-	PTR	sys_get_kernel_syms		/* 6170 */
-	PTR	sys_query_module
+	PTR	sys32_create_module
+	PTR	sys32_init_module
+	PTR	sys32_delete_module
+	PTR	sys32_get_kernel_syms		/* 6170 */
+	PTR	sys32_query_module
 	PTR	sys_quotactl
 	PTR	sys_nfsservctl
 	PTR	sys_ni_syscall			/* res. for getpmsg */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/scall_o32.S linux-mips-cvs-20040815/arch/mips64/kernel/scall_o32.S
--- linux-2.4.27/arch/mips64/kernel/scall_o32.S	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/scall_o32.S	2004-05-05 14:38:40.000000000 +0200
@@ -33,8 +33,8 @@ NESTED(handle_sys, PT_SIZE, sp)
 	subu	t0, v0, __NR_O32_Linux	# check syscall number
 	sltiu	t0, t0, __NR_O32_Linux_syscalls + 1
 	daddiu	t1, 4			# skip to next instruction
-	beqz	t0, not_o32_scall
 	sd	t1, PT_EPC(sp)
+	beqz	t0, not_o32_scall
 #if 0
  SAVE_ALL
  move a1, v0
@@ -451,9 +451,9 @@ out:	jr	ra
 	sys	sys32_adjtimex	1
 	sys	sys_mprotect	3			/* 4125 */
 	sys	sys32_sigprocmask	3
-	sys	sys_create_module 2
-	sys	sys_init_module	5
-	sys	sys_delete_module 1
+	sys	sys32_create_module 2
+	sys	sys32_init_module	5
+	sys	sys32_delete_module 1
 	sys	sys32_get_kernel_syms 1			/* 4130 */
 	sys	sys_quotactl	0
 	sys	sys_getpgid	1
@@ -511,7 +511,7 @@ out:	jr	ra
 	sys	sys_socketpair	4
 	sys	sys_setresuid	3			/* 4185 */
 	sys	sys_getresuid	3
-	sys	sys_query_module 5
+	sys	sys32_query_module 5
 	sys	sys_poll	3
 	sys	sys_nfsservctl	3
 	sys	sys_setresgid	3			/* 4190 */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/setup.c linux-mips-cvs-20040815/arch/mips64/kernel/setup.c
--- linux-2.4.27/arch/mips64/kernel/setup.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/setup.c	2004-05-02 00:47:32.000000000 +0200
@@ -41,6 +41,7 @@
 #include <asm/pgalloc.h>
 
 struct cpuinfo_mips cpu_data[NR_CPUS];
+EXPORT_SYMBOL(cpu_data);
 
 #ifdef CONFIG_VT
 struct screen_info screen_info;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/signal.c linux-mips-cvs-20040815/arch/mips64/kernel/signal.c
--- linux-2.4.27/arch/mips64/kernel/signal.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/signal.c	2004-03-03 04:42:00.000000000 +0100
@@ -265,7 +265,7 @@ static inline void *get_sigframe(struct 
  	sp -= 32;
 
 	/* This is the X/Open sanctioned signal stack switching.  */
-	if ((ka->sa.sa_flags & SA_ONSTACK) && ! on_sig_stack(sp))
+	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
 		sp = current->sas_ss_sp + current->sas_ss_size;
 
 	return (void *)((sp - frame_size) & ALMASK);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/signal32.c linux-mips-cvs-20040815/arch/mips64/kernel/signal32.c
--- linux-2.4.27/arch/mips64/kernel/signal32.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/signal32.c	2004-03-03 13:53:06.000000000 +0100
@@ -510,7 +510,7 @@ static inline void *get_sigframe(struct 
  	sp -= 32;
 
 	/* This is the X/Open sanctioned signal stack switching.  */
-	if ((ka->sa.sa_flags & SA_ONSTACK) && ! on_sig_stack(sp))
+	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
 		sp = current->sas_ss_sp + current->sas_ss_size;
 
 	return (void *)((sp - frame_size) & ALMASK);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/signal_n32.c linux-mips-cvs-20040815/arch/mips64/kernel/signal_n32.c
--- linux-2.4.27/arch/mips64/kernel/signal_n32.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/signal_n32.c	2004-03-03 13:53:06.000000000 +0100
@@ -138,7 +138,7 @@ static inline void *get_sigframe(struct 
  	sp -= 32;
 
 	/* This is the X/Open sanctioned signal stack switching.  */
-	if ((ka->sa.sa_flags & SA_ONSTACK) && ! on_sig_stack(sp))
+	if ((ka->sa.sa_flags & SA_ONSTACK) && (sas_ss_flags (sp) == 0))
 		sp = current->sas_ss_sp + current->sas_ss_size;
 
 	return (void *)((sp - frame_size) & ALMASK);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/smp.c linux-mips-cvs-20040815/arch/mips64/kernel/smp.c
--- linux-2.4.27/arch/mips64/kernel/smp.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/smp.c	2004-05-02 00:47:32.000000000 +0200
@@ -52,6 +52,9 @@ int __cpu_number_map[NR_CPUS];
 int __cpu_logical_map[NR_CPUS];
 cycles_t cacheflush_time;
 
+EXPORT_SYMBOL(__cpu_number_map);
+EXPORT_SYMBOL(__cpu_logical_map);
+
 void __init smp_callin(void)
 {
 #if 0
@@ -110,6 +113,7 @@ int smp_call_function (void (*func) (voi
 
 	spin_lock(&smp_call_lock);
 	call_data = &data;
+	wmb();
 
 	/* Send a message to all other CPUs and wait for them to respond */
 	for (i = 0; i < smp_num_cpus; i++)
@@ -283,7 +287,6 @@ void flush_tlb_page(struct vm_area_struc
 
 EXPORT_SYMBOL(smp_num_cpus);
 EXPORT_SYMBOL(flush_tlb_page);
-EXPORT_SYMBOL(cpu_data);
 EXPORT_SYMBOL(synchronize_irq);
 EXPORT_SYMBOL(kernel_flag);
 EXPORT_SYMBOL(__global_sti);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/syscall.c linux-mips-cvs-20040815/arch/mips64/kernel/syscall.c
--- linux-2.4.27/arch/mips64/kernel/syscall.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/syscall.c	2004-08-15 08:05:52.000000000 +0200
@@ -34,7 +34,7 @@
 
 extern asmlinkage void syscall_trace(void);
 
-asmlinkage int sys_pipe(abi64_no_regargs, struct pt_regs regs)
+asmlinkage int sys_pipe(abi64_no_regargs, volatile struct pt_regs regs)
 {
 	int fd[2];
 	int error, res;
@@ -61,6 +61,9 @@ unsigned long arch_get_unmapped_area(str
 {
 	struct vm_area_struct * vmm;
 	int do_color_align;
+	unsigned long task_size;
+	
+	task_size = (current->thread.mflags & MF_32BIT_ADDR) ? TASK_SIZE32 : TASK_SIZE;
 
 	if (flags & MAP_FIXED) {
 		/*
@@ -72,7 +75,7 @@ unsigned long arch_get_unmapped_area(str
 		return addr;
 	}
 
-	if (len > TASK_SIZE)
+	if (len > task_size)
 		return -ENOMEM;
 	do_color_align = 0;
 	if (filp || (flags & MAP_SHARED))
@@ -83,7 +86,7 @@ unsigned long arch_get_unmapped_area(str
 		else
 			addr = PAGE_ALIGN(addr);
 		vmm = find_vma(current->mm, addr);
-		if (TASK_SIZE - len >= addr &&
+		if (task_size - len >= addr &&
 		    (!vmm || addr + len <= vmm->vm_start))
 			return addr;
 	}
@@ -95,7 +98,7 @@ unsigned long arch_get_unmapped_area(str
 
 	for (vmm = find_vma(current->mm, addr); ; vmm = vmm->vm_next) {
 		/* At this point:  (!vmm || addr < vmm->vm_end). */
-		if (TASK_SIZE - len < addr)
+		if (task_size - len < addr)
 			return -ENOMEM;
 		if (!vmm || addr + len <= vmm->vm_start)
 			return addr;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/kernel/traps.c linux-mips-cvs-20040815/arch/mips64/kernel/traps.c
--- linux-2.4.27/arch/mips64/kernel/traps.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/kernel/traps.c	2004-08-15 08:05:52.000000000 +0200
@@ -9,7 +9,7 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Kevin D. Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2000, 01 MIPS Technologies, Inc.
- * Copyright (C) 2002, 2003  Maciej W. Rozycki
+ * Copyright (C) 2002, 2003, 2004  Maciej W. Rozycki
  */
 #include <linux/config.h>
 #include <linux/init.h>
@@ -22,6 +22,7 @@
 
 #include <asm/bootinfo.h>
 #include <asm/branch.h>
+#include <asm/break.h>
 #include <asm/cpu.h>
 #include <asm/fpu.h>
 #include <asm/module.h>
@@ -362,7 +363,7 @@ asmlinkage void do_be(struct pt_regs *re
 	int action = MIPS_BE_FATAL;
 
 	if (data && !user_mode(regs))
-		fixup = search_dbe_table(regs->cp0_epc);
+		fixup = search_dbe_table(exception_epc(regs));
 
 	if (fixup)
 		action = MIPS_BE_FIXUP;
@@ -606,9 +607,12 @@ asmlinkage void do_bp(struct pt_regs *re
 	/*
 	 * There is the ancient bug in the MIPS assemblers that the break
 	 * code starts left to bit 16 instead to bit 6 in the opcode.
-	 * Gas is bug-compatible ...
+	 * Gas is bug-compatible, but not always, grrr...
+	 * We handle both cases with a simple heuristics.  --macro
 	 */
-	bcode = ((opcode >> 16) & ((1 << 20) - 1));
+	bcode = ((opcode >> 6) & ((1 << 20) - 1));
+	if (bcode < (1 << 10))
+		bcode <<= 10;
 
 	/*
 	 * (A short test says that IRIX 5.3 sends SIGTRAP for all break
@@ -617,9 +621,9 @@ asmlinkage void do_bp(struct pt_regs *re
 	 * But should we continue the brokenness???  --macro
 	 */
 	switch (bcode) {
-	case 6:
-	case 7:
-		if (bcode == 7)
+	case BRK_OVERFLOW << 10:
+	case BRK_DIVZERO << 10:
+		if (bcode == (BRK_DIVZERO << 10))
 			info.si_code = FPE_INTDIV;
 		else
 			info.si_code = FPE_INTOVF;
@@ -643,7 +647,7 @@ asmlinkage void do_tr(struct pt_regs *re
 
 	/* Immediate versions don't provide a code.  */
 	if (!(opcode & OPCODE))
-		tcode = ((opcode >> 6) & ((1 << 20) - 1));
+		tcode = ((opcode >> 6) & ((1 << 10) - 1));
 
 	/*
 	 * (A short test says that IRIX 5.3 sends SIGTRAP for all trap
@@ -652,9 +656,9 @@ asmlinkage void do_tr(struct pt_regs *re
 	 * But should we continue the brokenness???  --macro
 	 */
 	switch (tcode) {
-	case 6:
-	case 7:
-		if (tcode == 7)
+	case BRK_OVERFLOW:
+	case BRK_DIVZERO:
+		if (tcode == BRK_DIVZERO)
 			info.si_code = FPE_INTDIV;
 		else
 			info.si_code = FPE_INTOVF;
@@ -851,8 +855,7 @@ void __init trap_init(void)
 		set_except_vector(i, handle_reserved);
 
 	/*
-	 * Only some CPUs have the watch exceptions or a dedicated
-	 * interrupt vector.
+	 * Only some CPUs have the watch exceptions.
 	 */
 	if (cpu_has_watch)
 		set_except_vector(23, handle_watch);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/lib/dump_tlb.c linux-mips-cvs-20040815/arch/mips64/lib/dump_tlb.c
--- linux-2.4.27/arch/mips64/lib/dump_tlb.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips64/lib/dump_tlb.c	2004-02-11 16:05:17.000000000 +0100
@@ -201,12 +201,10 @@ void dump16(unsigned long *p)
 {
 	int i;
 
-	for(i = 0; i < 8; i++) {
-		printk("*%08lx == %08lx, ",
-		       (unsigned long)p, (unsigned long)*p);
+	for (i = 0; i < 8; i++) {
+		printk("*%08lx == %08lx, ", (unsigned long)p, *p);
 		p++;
-		printk("*%08lx == %08lx\n",
-		       (unsigned long)p, (unsigned long)*p);
+		printk("*%08lx == %08lx\n", (unsigned long)p, *p);
 		p++;
 	}
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/c-r4k.c linux-mips-cvs-20040815/arch/mips64/mm/c-r4k.c
--- linux-2.4.27/arch/mips64/mm/c-r4k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/mm/c-r4k.c	2004-08-15 08:05:52.000000000 +0200
@@ -42,12 +42,13 @@ static struct bcache_ops no_sc_ops = {
 
 struct bcache_ops *bcops = &no_sc_ops;
 
+#define cpu_is_r4600_v1_x()	((read_c0_prid() & 0xfffffff0) == 0x2010)
+#define cpu_is_r4600_v2_x()	((read_c0_prid() & 0xfffffff0) == 0x2020)
+
 #define R4600_HIT_CACHEOP_WAR_IMPL					\
 do {									\
-	if (R4600_V2_HIT_CACHEOP_WAR &&					\
-	    (read_c0_prid() & 0xfff0) == 0x2020) {	/* R4600 V2.0 */\
+	if (R4600_V2_HIT_CACHEOP_WAR && cpu_is_r4600_v2_x())		\
 		*(volatile unsigned long *)KSEG1;			\
-	}								\
 	if (R4600_V1_HIT_CACHEOP_WAR)					\
 		__asm__ __volatile__("nop;nop;nop;nop");		\
 } while (0)
@@ -104,6 +105,15 @@ static inline void r4k_blast_dcache_setu
 #define CACHE32_UNROLL32_ALIGN	JUMP_TO_ALIGN(10) /* 32 * 32 = 1024 */
 #define CACHE32_UNROLL32_ALIGN2	JUMP_TO_ALIGN(11)
 
+static inline void blast_r4600_v1_icache32(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	blast_icache32();
+	local_irq_restore(flags);
+}
+
 static inline void tx49_blast_icache32(void)
 {
 	unsigned long start = KSEG0;
@@ -125,6 +135,15 @@ static inline void tx49_blast_icache32(v
 			cache32_unroll32(addr|ws,Index_Invalidate_I);
 }
 
+static inline void blast_icache32_r4600_v1_page_indexed(unsigned long page)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	blast_icache32_page_indexed(page);
+	local_irq_restore(flags);
+}
+
 static inline void tx49_blast_icache32_page_indexed(unsigned long page)
 {
 	unsigned long start = page;
@@ -168,11 +187,17 @@ static inline void r4k_blast_icache_page
 
 	if (ic_lsize == 16)
 		r4k_blast_icache_page_indexed = blast_icache16_page_indexed;
-	else if (ic_lsize == 32 && TX49XX_ICACHE_INDEX_INV_WAR)
-		r4k_blast_icache_page_indexed = tx49_blast_icache32_page_indexed;
-	else if (ic_lsize == 32)
-		r4k_blast_icache_page_indexed = blast_icache32_page_indexed;
-	else if (ic_lsize == 64)
+	else if (ic_lsize == 32) {
+		if (TX49XX_ICACHE_INDEX_INV_WAR)
+			r4k_blast_icache_page_indexed =
+				tx49_blast_icache32_page_indexed;
+		else if (R4600_V1_INDEX_ICACHEOP_WAR && cpu_is_r4600_v1_x())
+			r4k_blast_icache_page_indexed =
+				blast_icache32_r4600_v1_page_indexed;
+		else
+			r4k_blast_icache_page_indexed =
+				blast_icache32_page_indexed;
+	} else if (ic_lsize == 64)
 		r4k_blast_icache_page_indexed = blast_icache64_page_indexed;
 }
 
@@ -184,11 +209,14 @@ static inline void r4k_blast_icache_setu
 
 	if (ic_lsize == 16)
 		r4k_blast_icache = blast_icache16;
-	else if (ic_lsize == 32 && TX49XX_ICACHE_INDEX_INV_WAR)
-		r4k_blast_icache = tx49_blast_icache32;
-	else if (ic_lsize == 32)
-		r4k_blast_icache = blast_icache32;
-	else if (ic_lsize == 64)
+	else if (ic_lsize == 32) {
+		if (R4600_V1_INDEX_ICACHEOP_WAR && cpu_is_r4600_v1_x())
+			r4k_blast_icache = blast_r4600_v1_icache32;
+		else if (TX49XX_ICACHE_INDEX_INV_WAR)
+			r4k_blast_icache = tx49_blast_icache32;
+		else if (ic_lsize == 32)
+			r4k_blast_icache = blast_icache32;
+	} else if (ic_lsize == 64)
 		r4k_blast_icache = blast_icache64;
 }
 
@@ -352,6 +380,7 @@ static void r4k_flush_data_cache_page(un
 static void r4k_flush_icache_range(unsigned long start, unsigned long end)
 {
 	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
+	unsigned long ic_lsize = current_cpu_data.icache.linesz;
 	unsigned long addr, aend;
 
 	if (!cpu_has_ic_fills_f_dc) {
@@ -374,14 +403,14 @@ static void r4k_flush_icache_range(unsig
 	if (end - start > icache_size)
 		r4k_blast_icache();
 	else {
-		addr = start & ~(dc_lsize - 1);
-		aend = (end - 1) & ~(dc_lsize - 1);
+		addr = start & ~(ic_lsize - 1);
+		aend = (end - 1) & ~(ic_lsize - 1);
 		while (1) {
 			/* Hit_Invalidate_I */
 			protected_flush_icache_line(addr);
 			if (addr == aend)
 				break;
-			addr += dc_lsize;
+			addr += ic_lsize;
 		}
 	}
 }
@@ -445,6 +474,9 @@ static void r4k_dma_cache_wback_inv(unsi
 {
 	unsigned long end, a;
 
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	if (cpu_has_subset_pcaches) {
 		unsigned long sc_lsize = current_cpu_data.scache.linesz;
 
@@ -492,6 +524,9 @@ static void r4k_dma_cache_inv(unsigned l
 {
 	unsigned long end, a;
 
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	if (cpu_has_subset_pcaches) {
 		unsigned long sc_lsize = current_cpu_data.scache.linesz;
 
@@ -754,7 +789,10 @@ static void __init probe_pcache(void)
 		c->dcache.ways = 4;
 		c->dcache.waybit = ffs(dcache_size / c->dcache.ways) - 1;
 
-		c->options |= MIPS_CPU_CACHE_CDEX_P | MIPS_CPU_PREFETCH;
+#if !defined(CONFIG_SMP) || !defined(RM9000_CDEX_SMP_WAR)
+		c->options |= MIPS_CPU_CACHE_CDEX_P;
+#endif
+		c->options |= MIPS_CPU_PREFETCH;
 		break;
 
 	default:
@@ -937,10 +975,8 @@ static void __init setup_scache(void)
 	 * Linux memory managment.
 	 */
 	switch (c->cputype) {
-	case CPU_R4000PC:
 	case CPU_R4000SC:
 	case CPU_R4000MC:
-	case CPU_R4400PC:
 	case CPU_R4400SC:
 	case CPU_R4400MC:
 		probe_scache_kseg1 = (probe_func_t) (KSEG1ADDR(&probe_scache));
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/c-sb1.c linux-mips-cvs-20040815/arch/mips64/mm/c-sb1.c
--- linux-2.4.27/arch/mips64/mm/c-sb1.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/mm/c-sb1.c	2004-05-02 00:47:32.000000000 +0200
@@ -2,6 +2,7 @@
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
  * Copyright (C) 2000, 2001, 2002, 2003 Broadcom Corporation
+ * Copyright (C) 2004  Maciej W. Rozycki
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -231,8 +232,8 @@ static void sb1_flush_cache_page(struct 
 	local_sb1_flush_cache_page(vma, addr);
 }
 #else
-void sb1_flush_cache_page(struct vm_area_struct *vma, unsigned long addr);
-asm("sb1_flush_cache_page = local_sb1_flush_cache_page");
+void sb1_flush_cache_page(struct vm_area_struct *vma, unsigned long addr)
+	__attribute__((alias("local_sb1_flush_cache_page")));
 #endif
 
 /*
@@ -280,8 +281,8 @@ static void local_sb1___flush_cache_all(
 }
 
 #ifdef CONFIG_SMP
-extern void sb1___flush_cache_all_ipi(void *ignored);
-asm("sb1___flush_cache_all_ipi = local_sb1___flush_cache_all");
+void sb1___flush_cache_all_ipi(void *ignored)
+	__attribute__((alias("local_sb1___flush_cache_all")));
 
 static void sb1___flush_cache_all(void)
 {
@@ -289,8 +290,8 @@ static void sb1___flush_cache_all(void)
 	local_sb1___flush_cache_all();
 }
 #else
-extern void sb1___flush_cache_all(void);
-asm("sb1___flush_cache_all = local_sb1___flush_cache_all");
+void sb1___flush_cache_all(void)
+	__attribute__((alias("local_sb1___flush_cache_all")));
 #endif
 
 /*
@@ -340,8 +341,8 @@ void sb1_flush_icache_range(unsigned lon
 	local_sb1_flush_icache_range(start, end);
 }
 #else
-void sb1_flush_icache_range(unsigned long start, unsigned long end);
-asm("sb1_flush_icache_range = local_sb1_flush_icache_range");
+void sb1_flush_icache_range(unsigned long start, unsigned long end)
+	__attribute__((alias("local_sb1_flush_icache_range")));
 #endif
 
 /*
@@ -398,8 +399,8 @@ static void sb1_flush_icache_page(struct
 	local_sb1_flush_icache_page(vma, page);
 }
 #else
-void sb1_flush_icache_page(struct vm_area_struct *vma, struct page *page);
-asm("sb1_flush_icache_page = local_sb1_flush_icache_page");
+void sb1_flush_icache_page(struct vm_area_struct *vma, struct page *page)
+	__attribute__((alias("local_sb1_flush_icache_page")));
 #endif
 
 /*
@@ -447,8 +448,8 @@ static void sb1_flush_cache_sigtramp(uns
 	smp_call_function(sb1_flush_cache_sigtramp_ipi, (void *) addr, 1, 1);
 }
 #else
-void sb1_flush_cache_sigtramp(unsigned long addr);
-asm("sb1_flush_cache_sigtramp = local_sb1_flush_cache_sigtramp");
+void sb1_flush_cache_sigtramp(unsigned long addr)
+	__attribute__((alias("local_sb1_flush_cache_sigtramp")));
 #endif
 
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/pg-r4k.c linux-mips-cvs-20040815/arch/mips64/mm/pg-r4k.c
--- linux-2.4.27/arch/mips64/mm/pg-r4k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/mm/pg-r4k.c	2004-03-05 03:18:15.000000000 +0100
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
  */
 #include <linux/config.h>
 #include <linux/init.h>
@@ -11,6 +11,7 @@
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/module.h>
+#include <linux/proc_fs.h>
 
 #include <asm/cacheops.h>
 #include <asm/inst.h>
@@ -25,28 +26,30 @@
 #include <asm/cpu.h>
 #include <asm/war.h>
 
+#define half_scache_line_size()		(cpu_scache_line_size() >> 1)
+
 /*
  * Maximum sizes:
  *
- * R4000 16 bytes D-cache, 128 bytes S-cache:		0x78 bytes
- * R4600 v1.7:						0x5c bytes
- * R4600 v2.0:						0x60 bytes
- * With prefetching, 16 byte strides			0xa0 bytes
+ * R4000 128 bytes S-cache:		0x58 bytes
+ * R4600 v1.7:				0x5c bytes
+ * R4600 v2.0:				0x60 bytes
+ * With prefetching, 16 byte strides	0xa0 bytes
  */
 
-static unsigned int clear_page_array[0xa0 / 4];
+static unsigned int clear_page_array[0x130 / 4];
 
 void clear_page(void * page) __attribute__((alias("clear_page_array")));
 
 /*
  * Maximum sizes:
  *
- * R4000 16 bytes D-cache, 128 bytes S-cache:		0xbc bytes
- * R4600 v1.7:						0x80 bytes
- * R4600 v2.0:						0x84 bytes
- * With prefetching, 16 byte strides			0xb8 bytes
+ * R4000 128 bytes S-cache:		0x11c bytes
+ * R4600 v1.7:				0x080 bytes
+ * R4600 v2.0:				0x07c bytes
+ * With prefetching, 16 byte strides	0x0b8 bytes
  */
-static unsigned int copy_page_array[0xb8 / 4];
+static unsigned int copy_page_array[0x148 / 4];
 
 void copy_page(void *to, void *from) __attribute__((alias("copy_page_array")));
 
@@ -67,12 +70,58 @@ static int pref_offset_copy  __initdata 
 static unsigned int pref_src_mode __initdata;
 static unsigned int pref_dst_mode __initdata;
 
-static int has_scache __initdata = 0;
-static int load_offset __initdata = 0;
-static int store_offset __initdata = 0;
+static int load_offset __initdata;
+static int store_offset __initdata;
 
 static unsigned int __initdata *dest, *epc;
 
+static unsigned int instruction_pending;
+static union mips_instruction delayed_mi;
+
+static void __init emit_instruction(union mips_instruction mi)
+{
+	if (instruction_pending)
+		*epc++ = delayed_mi.word;
+
+	instruction_pending = 1;
+	delayed_mi = mi;
+}
+
+static inline void flush_delay_slot_or_nop(void)
+{
+	if (instruction_pending) {
+		*epc++ = delayed_mi.word;
+		instruction_pending = 0;
+		return;
+	}
+
+	*epc++ = 0;
+}
+
+static inline unsigned int *label(void)
+{
+	if (instruction_pending) {
+		*epc++ = delayed_mi.word;
+		instruction_pending = 0;
+	}
+
+	return epc;
+}
+
+static inline void build_insn_word(unsigned int word)
+{
+	union mips_instruction mi;
+
+	mi.word		 = word;
+
+	emit_instruction(mi);
+}
+
+static inline void build_nop(void)
+{
+	build_insn_word(0);			/* nop */
+}
+
 static inline void build_src_pref(int advance)
 {
 	if (!(load_offset & (cpu_dcache_line_size() - 1))) {
@@ -83,25 +132,28 @@ static inline void build_src_pref(int ad
 		mi.i_format.rt         = pref_src_mode;
 		mi.i_format.simmediate = load_offset + advance;
 
-		*epc++ = mi.word;
+		emit_instruction(mi);
 	}
 }
 
 static inline void __build_load_reg(int reg)
 {
 	union mips_instruction mi;
+	unsigned int width;
 
-	if (cpu_has_64bit_registers)
+	if (cpu_has_64bit_registers) {
 		mi.i_format.opcode     = ld_op;
-	else
+		width = 8;
+	} else {
 		mi.i_format.opcode     = lw_op;
+		width = 4;
+	}
 	mi.i_format.rs         = 5;		/* $a1 */
-	mi.i_format.rt         = reg;		/* $zero */
+	mi.i_format.rt         = reg;		/* $reg */
 	mi.i_format.simmediate = load_offset;
 
-	load_offset += (cpu_has_64bit_registers ? 8 : 4);
-
-	*epc++ = mi.word;
+	load_offset += width;
+	emit_instruction(mi);
 }
 
 static inline void build_load_reg(int reg)
@@ -122,87 +174,71 @@ static inline void build_dst_pref(int ad
 		mi.i_format.rt         = pref_dst_mode;
 		mi.i_format.simmediate = store_offset + advance;
 
-		*epc++ = mi.word;
+		emit_instruction(mi);
 	}
 }
 
-static inline void build_cdex(void)
+static inline void build_cdex_s(void)
 {
 	union mips_instruction mi;
 
-	if (cpu_has_cache_cdex_s &&
-	    !(store_offset & (cpu_scache_line_size() - 1))) {
+	if ((store_offset & (cpu_scache_line_size() - 1)))
+		return;
 
-		mi.c_format.opcode     = cache_op;
-		mi.c_format.rs         = 4;	/* $a0 */
-		mi.c_format.c_op       = 3;	/* Create Dirty Exclusive */
-		mi.c_format.cache      = 3;	/* Secondary Data Cache */
-		mi.c_format.simmediate = store_offset;
+	mi.c_format.opcode     = cache_op;
+	mi.c_format.rs         = 4;		/* $a0 */
+	mi.c_format.c_op       = 3;		/* Create Dirty Exclusive */
+	mi.c_format.cache      = 3;		/* Secondary Data Cache */
+	mi.c_format.simmediate = store_offset;
 
-		*epc++ = mi.word;
-	}
+	emit_instruction(mi);
+}
+
+static inline void build_cdex_p(void)
+{
+	union mips_instruction mi;
 
 	if (store_offset & (cpu_dcache_line_size() - 1))
 		return;
 
 	if (R4600_V1_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2010)) {
-		*epc++ = 0;			/* nop */
-		*epc++ = 0;			/* nop */
-		*epc++ = 0;			/* nop */
-		*epc++ = 0;			/* nop */
+		build_nop();
+		build_nop();
+		build_nop();
+		build_nop();
 	}
 
+	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+		build_insn_word(0x8c200000);	/* lw      $zero, ($at) */
+
 	mi.c_format.opcode     = cache_op;
 	mi.c_format.rs         = 4;		/* $a0 */
 	mi.c_format.c_op       = 3;		/* Create Dirty Exclusive */
 	mi.c_format.cache      = 1;		/* Data Cache */
 	mi.c_format.simmediate = store_offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
-static inline void __build_store_zero_reg(void)
+static void __build_store_reg(int reg)
 {
 	union mips_instruction mi;
+	unsigned int width;
 
-	if (cpu_has_64bits)
+	if (cpu_has_64bit_gp_regs ||
+	    (cpu_has_64bit_zero_reg && reg == 0)) {
 		mi.i_format.opcode     = sd_op;
-	else
-		mi.i_format.opcode     = sw_op;
-	mi.i_format.rs         = 4;		/* $a0 */
-	mi.i_format.rt         = 0;		/* $zero */
-	mi.i_format.simmediate = store_offset;
-
-	store_offset += (cpu_has_64bits ? 8 : 4);
-
-	*epc++ = mi.word;
-}
-
-static inline void __build_store_reg(int reg)
-{
-	union mips_instruction mi;
-	int reg_size;
-
-#ifdef CONFIG_MIPS32
-	if (cpu_has_64bit_registers && reg == 0) {
-		mi.i_format.opcode     = sd_op;
-		reg_size               = 8;
+		width = 8;
 	} else {
 		mi.i_format.opcode     = sw_op;
-		reg_size               = 4;
+		width = 4;
 	}
-#endif
-#ifdef CONFIG_MIPS64
-	mi.i_format.opcode     = sd_op;
-	reg_size               = 8;
-#endif
 	mi.i_format.rs         = 4;		/* $a0 */
-	mi.i_format.rt         = reg;		/* $zero */
+	mi.i_format.rt         = reg;		/* $reg */
 	mi.i_format.simmediate = store_offset;
 
-	store_offset += reg_size;
-
-	*epc++ = mi.word;
+	store_offset += width;
+	emit_instruction(mi);
 }
 
 static inline void build_store_reg(int reg)
@@ -212,13 +248,15 @@ static inline void build_store_reg(int r
 			build_dst_pref(pref_offset_copy);
 		else
 			build_dst_pref(pref_offset_clear);
+	else if (cpu_has_cache_cdex_s)
+		build_cdex_s();
 	else if (cpu_has_cache_cdex_p)
-		build_cdex();
+		build_cdex_p();
 
 	__build_store_reg(reg);
 }
 
-static inline void build_addiu_at_a0(unsigned long offset)
+static inline void build_addiu_a2_a0(unsigned long offset)
 {
 	union mips_instruction mi;
 
@@ -226,10 +264,10 @@ static inline void build_addiu_at_a0(uns
 
 	mi.i_format.opcode     = cpu_has_64bit_addresses ? daddiu_op : addiu_op;
 	mi.i_format.rs         = 4;		/* $a0 */
-	mi.i_format.rt         = 1;		/* $at */
+	mi.i_format.rt         = 6;		/* $a2 */
 	mi.i_format.simmediate = offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
 static inline void build_addiu_a1(unsigned long offset)
@@ -245,7 +283,7 @@ static inline void build_addiu_a1(unsign
 
 	load_offset -= offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
 static inline void build_addiu_a0(unsigned long offset)
@@ -261,7 +299,7 @@ static inline void build_addiu_a0(unsign
 
 	store_offset -= offset;
 
-	*epc++ = mi.word;
+	emit_instruction(mi);
 }
 
 static inline void build_bne(unsigned int *dest)
@@ -269,16 +307,12 @@ static inline void build_bne(unsigned in
 	union mips_instruction mi;
 
 	mi.i_format.opcode = bne_op;
-	mi.i_format.rs     = 1;			/* $at */
+	mi.i_format.rs     = 6;			/* $a2 */
 	mi.i_format.rt     = 4;			/* $a0 */
 	mi.i_format.simmediate = dest - epc - 1;
 
 	*epc++ = mi.word;
-}
-
-static inline void build_nop(void)
-{
-	*epc++ = 0;
+	flush_delay_slot_or_nop();
 }
 
 static inline void build_jr_ra(void)
@@ -293,19 +327,34 @@ static inline void build_jr_ra(void)
 	mi.r_format.func   = jr_op;
 
 	*epc++ = mi.word;
+	flush_delay_slot_or_nop();
 }
 
 void __init build_clear_page(void)
 {
+	unsigned int loop_start;
+
 	epc = (unsigned int *) &clear_page_array;
+	instruction_pending = 0;
+	store_offset = 0;
 
 	if (cpu_has_prefetch) {
 		switch (current_cpu_data.cputype) {
+		case CPU_RM9000:
+			/*
+			 * As a workaround for erratum G105 which make the
+			 * PrepareForStore hint unusable we fall back to
+			 * StoreRetained on the RM9000.  Once it is known which
+			 * versions of the RM9000 we'll be able to condition-
+			 * alize this.
+			 */
+
 		case CPU_R10000:
 		case CPU_R12000:
 			pref_src_mode = Pref_LoadStreamed;
 			pref_dst_mode = Pref_StoreRetained;
 			break;
+
 		default:
 			pref_src_mode = Pref_LoadStreamed;
 			pref_dst_mode = Pref_PrepareForStore;
@@ -313,64 +362,50 @@ void __init build_clear_page(void)
 		}
 	}
 
-	build_addiu_at_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_clear : 0));
+	build_addiu_a2_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_clear : 0));
 
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020)) {
-		*epc++ = 0x40026000;		/* mfc0    $v0, $12	*/
-		*epc++ = 0x34410001;		/* ori     $at, v0, 0x1	*/
-		*epc++ = 0x38210001;		/* xori    $at, at, 0x1	*/
-		*epc++ = 0x40816000;		/* mtc0    $at, $12	*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x3c01a000;		/* lui     $at, 0xa000  */
-		*epc++ = 0x8c200000;		/* lw      $zero, ($at) */
-	}
+	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+		build_insn_word(0x3c01a000);	/* lui     $at, 0xa000  */
 
-dest = epc;
-	build_store_reg(0);
-	build_store_reg(0);
-	build_store_reg(0);
-	build_store_reg(0);
-	if (has_scache && cpu_scache_line_size() == 128) {
+dest = label();
+	do {
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
-	}
+	} while (store_offset < half_scache_line_size());
 	build_addiu_a0(2 * store_offset);
-	build_store_reg(0);
-	build_store_reg(0);
-	if (has_scache && cpu_scache_line_size() == 128) {
+	loop_start = store_offset;
+	do {
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
 		build_store_reg(0);
-	}
-	build_store_reg(0);
+	} while ((store_offset - loop_start) < half_scache_line_size());
 	build_bne(dest);
-	 build_store_reg(0);
 
 	if (cpu_has_prefetch && pref_offset_clear) {
-		build_addiu_at_a0(pref_offset_clear);
-	dest = epc;
-		__build_store_reg(0);
-		__build_store_reg(0);
-		__build_store_reg(0);
-		__build_store_reg(0);
+		build_addiu_a2_a0(pref_offset_clear);
+	dest = label();
+		loop_start = store_offset;
+		do {
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_addiu_a0(2 * store_offset);
-		__build_store_reg(0);
-		__build_store_reg(0);
-		__build_store_reg(0);
+		loop_start = store_offset;
+		do {
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+			__build_store_reg(0);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_bne(dest);
-		 __build_store_reg(0);
 	}
 
 	build_jr_ra();
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
-		*epc++ = 0x40826000;		/* mtc0    $v0, $12	*/
-	else
-		build_nop();
 
 	flush_icache_range((unsigned long)&clear_page_array,
 	                   (unsigned long) epc);
@@ -380,32 +415,20 @@ dest = epc;
 
 void __init build_copy_page(void)
 {
+	unsigned int loop_start;
+
 	epc = (unsigned int *) &copy_page_array;
+	store_offset = load_offset = 0;
+	instruction_pending = 0;
 
-	build_addiu_at_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_copy : 0));
+	build_addiu_a2_a0(PAGE_SIZE - (cpu_has_prefetch ? pref_offset_copy : 0));
 
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020)) {
-		*epc++ = 0x40026000;		/* mfc0    $v0, $12	*/
-		*epc++ = 0x34410001;		/* ori     $at, v0, 0x1	*/
-		*epc++ = 0x38210001;		/* xori    $at, at, 0x1	*/
-		*epc++ = 0x40816000;		/* mtc0    $at, $12	*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x00000000;		/* nop			*/
-		*epc++ = 0x3c01a000;		/* lui     $at, 0xa000  */
-		*epc++ = 0x8c200000;		/* lw      $zero, ($at) */
-	}
+	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
+		build_insn_word(0x3c01a000);	/* lui     $at, 0xa000  */
 
-dest = epc;
-	build_load_reg( 8);
-	build_load_reg( 9);
-	build_load_reg(10);
-	build_load_reg(11);
-	build_store_reg( 8);
-	build_store_reg( 9);
-	build_store_reg(10);
-	build_store_reg(11);
-	if (has_scache && cpu_scache_line_size() == 128) {
+dest = label();
+	loop_start = store_offset;
+	do {
 		build_load_reg( 8);
 		build_load_reg( 9);
 		build_load_reg(10);
@@ -414,18 +437,11 @@ dest = epc;
 		build_store_reg( 9);
 		build_store_reg(10);
 		build_store_reg(11);
-	}
+	} while ((store_offset - loop_start) < half_scache_line_size());
 	build_addiu_a0(2 * store_offset);
 	build_addiu_a1(2 * load_offset);
-	build_load_reg( 8);
-	build_load_reg( 9);
-	build_load_reg(10);
-	build_load_reg(11);
-	build_store_reg( 8);
-	build_store_reg( 9);
-	build_store_reg(10);
-	if (has_scache && cpu_scache_line_size() == 128) {
-		build_store_reg(11);
+	loop_start = store_offset;
+	do {
 		build_load_reg( 8);
 		build_load_reg( 9);
 		build_load_reg(10);
@@ -433,39 +449,44 @@ dest = epc;
 		build_store_reg( 8);
 		build_store_reg( 9);
 		build_store_reg(10);
-	}
+		build_store_reg(11);
+	} while ((store_offset - loop_start) < half_scache_line_size());
 	build_bne(dest);
-	 build_store_reg(11);
 
 	if (cpu_has_prefetch && pref_offset_copy) {
-		build_addiu_at_a0(pref_offset_copy);
-	dest = epc;
-		__build_load_reg( 8);
-		__build_load_reg( 9);
-		__build_load_reg(10);
-		__build_load_reg(11);
-		__build_store_reg( 8);
-		__build_store_reg( 9);
-		__build_store_reg(10);
-		__build_store_reg(11);
+		build_addiu_a2_a0(pref_offset_copy);
+	dest = label();
+		loop_start = store_offset;
+		do {
+			__build_load_reg( 8);
+			__build_load_reg( 9);
+			__build_load_reg(10);
+			__build_load_reg(11);
+			__build_store_reg( 8);
+			__build_store_reg( 9);
+			__build_store_reg(10);
+			__build_store_reg(11);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_addiu_a0(2 * store_offset);
 		build_addiu_a1(2 * load_offset);
-		__build_load_reg( 8);
-		__build_load_reg( 9);
-		__build_load_reg(10);
-		__build_load_reg(11);
-		__build_store_reg( 8);
-		__build_store_reg( 9);
-		__build_store_reg(10);
+		loop_start = store_offset;
+		do {
+			__build_load_reg( 8);
+			__build_load_reg( 9);
+			__build_load_reg(10);
+			__build_load_reg(11);
+			__build_store_reg( 8);
+			__build_store_reg( 9);
+			__build_store_reg(10);
+			__build_store_reg(11);
+		} while ((store_offset - loop_start) < half_scache_line_size());
 		build_bne(dest);
-		 __build_store_reg(11);
 	}
 
 	build_jr_ra();
-	if (R4600_V2_HIT_CACHEOP_WAR && ((read_c0_prid() & 0xfff0) == 0x2020))
-		*epc++ = 0x40826000;		/* mtc0    $v0, $12	*/
-	else
-		build_nop();
+
+	flush_icache_range((unsigned long)&copy_page_array,
+	                   (unsigned long) epc);
 
 	BUG_ON(epc > copy_page_array + ARRAY_SIZE(copy_page_array));
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/sc-ip22.c linux-mips-cvs-20040815/arch/mips64/mm/sc-ip22.c
--- linux-2.4.27/arch/mips64/mm/sc-ip22.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips64/mm/sc-ip22.c	2004-03-17 01:47:37.000000000 +0100
@@ -65,8 +65,8 @@ static void indy_sc_wback_invalidate(uns
 	printk("indy_sc_wback_invalidate[%08lx,%08lx]", addr, size);
 #endif
 
-	if (!size)
-		return;
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
 
 	/* Which lines to flush?  */
 	first_line = SC_INDEX(addr);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/sc-r5k.c linux-mips-cvs-20040815/arch/mips64/mm/sc-r5k.c
--- linux-2.4.27/arch/mips64/mm/sc-r5k.c	2003-08-25 13:44:40.000000000 +0200
+++ linux-mips-cvs-20040815/arch/mips64/mm/sc-r5k.c	2004-03-17 01:47:37.000000000 +0100
@@ -47,6 +47,9 @@ static void r5k_dma_cache_inv_sc(unsigne
 {
 	unsigned long end, a;
 
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
+
 	if (size >= scache_size) {
 		blast_r5000_scache();
 		return;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/sc-rm7k.c linux-mips-cvs-20040815/arch/mips64/mm/sc-rm7k.c
--- linux-2.4.27/arch/mips64/mm/sc-rm7k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/mm/sc-rm7k.c	2004-03-17 16:30:19.000000000 +0100
@@ -1,8 +1,11 @@
 /*
  * sc-rm7k.c: RM7000 cache management functions.
  *
- * Copyright (C) 1997, 2001, 2003 Ralf Baechle (ralf@gnu.org),
+ * Copyright (C) 1997, 2001, 2003, 2004 Ralf Baechle (ralf@linux-mips.org)
  */
+
+#undef DEBUG
+
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
@@ -34,9 +37,10 @@ static void rm7k_sc_wback_inv(unsigned l
 {
 	unsigned long end, a;
 
-#ifdef DEBUG_CACHE
-	printk("rm7k_sc_wback_inv[%08lx,%08lx]", addr, size);
-#endif
+	pr_debug("rm7k_sc_wback_inv[%08lx,%08lx]", addr, size);
+
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
 
 	a = addr & ~(sc_lsize - 1);
 	end = (addr + size - 1) & ~(sc_lsize - 1);
@@ -64,9 +68,10 @@ static void rm7k_sc_inv(unsigned long ad
 {
 	unsigned long end, a;
 
-#ifdef DEBUG_CACHE
-	printk("rm7k_sc_inv[%08lx,%08lx]", addr, size);
-#endif
+	pr_debug("rm7k_sc_inv[%08lx,%08lx]", addr, size);
+
+	/* Catch bad driver code */
+	BUG_ON(size == 0);
 
 	a = addr & ~(sc_lsize - 1);
 	end = (addr + size - 1) & ~(sc_lsize - 1);
@@ -105,16 +110,16 @@ static void rm7k_sc_inv(unsigned long ad
  *
  * It seems we get our kicks from relying on unguaranteed behaviour in GCC
  */
-static __init void rm7k_sc_enable(void)
+static __init void __rm7k_sc_enable(void)
 {
 	int i;
 
-	set_c0_config(1<<3);				/* CONF_SE */
+	set_c0_config(1 << 3);				/* CONF_SE */
 
 	write_c0_taglo(0);
 	write_c0_taghi(0);
 
-	for (i=0; i<scache_size; i+=sc_lsize) {
+	for (i = 0; i < scache_size; i += sc_lsize) {
 		__asm__ __volatile__ (
 		      ".set noreorder\n\t"
 		      ".set mips3\n\t"
@@ -122,11 +127,21 @@ static __init void rm7k_sc_enable(void)
 		      ".set mips0\n\t"
 		      ".set reorder"
 		      :
-		      : "r" (KSEG0ADDR(i)),
-		        "i" (Index_Store_Tag_SD));
+		      : "r" (KSEG0ADDR(i)), "i" (Index_Store_Tag_SD));
 	}
 }
 
+static __init void rm7k_sc_enable(void)
+{
+	void (*func)(void) = (void *) KSEG1ADDR(&__rm7k_sc_enable);
+
+	if (read_c0_config() & 0x08)			/* CONF_SE */
+		return;
+
+	printk(KERN_INFO "Enabling secondary cache...");
+	func();
+}
+
 static void rm7k_sc_disable(void)
 {
 	clear_c0_config(1<<3);				/* CONF_SE */
@@ -134,22 +149,17 @@ static void rm7k_sc_disable(void)
 
 static inline int __init rm7k_sc_probe(void)
 {
-	void (*func)(void) = KSEG1ADDR(&rm7k_sc_enable);
 	unsigned int config = read_c0_config();
 
 	if ((config >> 31) & 1)
 		return 0;
 
-	printk(KERN_INFO "Secondary cache size %ldK, linesize %ld bytes.\n",
+	printk(KERN_INFO "Secondary cache size %dK, linesize %d bytes.\n",
 	       (scache_size >> 10), sc_lsize);
 
 	if ((config >> 3) & 1)                          /* CONF_SE */
 		return 1;
 
-	printk(KERN_INFO "Enabling secondary cache...");
-	func();
-	printk("  done\n");
-
 	/*
 	 * While we're at it let's deal with the tertiary cache.
 	 */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/tlb-r4k.c linux-mips-cvs-20040815/arch/mips64/mm/tlb-r4k.c
--- linux-2.4.27/arch/mips64/mm/tlb-r4k.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/mm/tlb-r4k.c	2004-02-26 00:24:21.000000000 +0100
@@ -52,7 +52,7 @@ void local_flush_tlb_all(void)
 
 	local_irq_save(flags);
 	/* Save old context and create impossible VPN2 value */
-	old_ctx = (read_c0_entryhi() & ASID_MASK);
+	old_ctx = read_c0_entryhi();
 	write_c0_entryhi(XKPHYS);
 	write_c0_entrylo0(0);
 	write_c0_entrylo1(0);
@@ -103,8 +103,8 @@ void local_flush_tlb_range(struct mm_str
 		local_irq_save(flags);
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
-		if(size <= current_cpu_data.tlbsize/2) {
-			int oldpid = read_c0_entryhi() & ASID_MASK;
+		if (size <= current_cpu_data.tlbsize/2) {
+			int oldpid = read_c0_entryhi();
 			int newpid = cpu_asid(cpu, mm);
 
 			start &= (PAGE_MASK << 1);
@@ -151,7 +151,7 @@ void local_flush_tlb_page(struct vm_area
 		newpid = cpu_asid(cpu, vma->vm_mm);
 		page &= (PAGE_MASK << 1);
 		local_irq_save(flags);
-		oldpid = (read_c0_entryhi() & ASID_MASK);
+		oldpid = read_c0_entryhi();
 		write_c0_entryhi(page | newpid);
 		BARRIER;
 		tlb_probe();
@@ -182,7 +182,7 @@ void local_flush_tlb_one(unsigned long p
 	int oldpid, idx;
 
 	page &= (PAGE_MASK << 1);
-	oldpid = read_c0_entryhi() & ASID_MASK;
+	oldpid = read_c0_entryhi();
 
 	local_irq_save(flags);
 	write_c0_entryhi(page);
@@ -208,6 +208,7 @@ void local_flush_tlb_one(unsigned long p
 void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 {
 	unsigned long flags;
+	unsigned int asid;
 	pgd_t *pgdp;
 	pmd_t *pmdp;
 	pte_t *ptep;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/arch/mips64/mm/tlb-sb1.c linux-mips-cvs-20040815/arch/mips64/mm/tlb-sb1.c
--- linux-2.4.27/arch/mips64/mm/tlb-sb1.c	2004-02-18 14:36:30.000000000 +0100
+++ linux-mips-cvs-20040815/arch/mips64/mm/tlb-sb1.c	2004-08-15 08:05:52.000000000 +0200
@@ -118,7 +118,7 @@ void local_flush_tlb_all(void)
  * with the firmware, go back and give all the entries invalid addresses with
  * the normal flush routine.  Wired entries will be killed as well!
  */
-void sb1_sanitize_tlb(void)
+static void __init sb1_sanitize_tlb(void)
 {
 	int entry;
 	long addr = 0;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/Config.in linux-mips-cvs-20040815/drivers/char/Config.in
--- linux-2.4.27/drivers/char/Config.in	2004-08-08 01:26:04.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/Config.in	2004-08-15 08:06:08.000000000 +0200
@@ -165,6 +165,7 @@ if [ "$CONFIG_MIPS_IVR" = "y" ]; then
    fi
    bool 'Enable Smart Card Reader 0 Support ' CONFIG_IT8172_SCR0
 fi
+dep_tristate 'Hydrogen 3 Au1100 buttons support' CONFIG_MIPS_HYDROGEN3_BUTTONS $CONFIG_MIPS_HYDROGEN3
 if [ "$CONFIG_CPU_VR41XX" = "y" ]; then
    bool 'NEC VR4100 series Keyboard Interface Unit Support ' CONFIG_VR41XX_KIU
 fi
@@ -313,14 +314,11 @@ fi
 if [ "$CONFIG_OBSOLETE" = "y" -a "$CONFIG_ALPHA_BOOK1" = "y" ]; then
    bool 'Tadpole ANA H8 Support (OBSOLETE)'  CONFIG_H8
 fi
-if [ "$CONFIG_MIPS" = "y" -a "$CONFIG_NEW_TIME_C" = "y" ]; then
-   tristate 'Generic MIPS RTC Support' CONFIG_MIPS_RTC
-fi
 if [ "$CONFIG_SGI_IP22" = "y" ]; then
-   bool 'SGI DS1286 RTC support' CONFIG_SGI_DS1286
+   tristate 'Dallas DS1286 RTC support' CONFIG_DS1286
 fi
 if [ "$CONFIG_SGI_IP27" = "y" ]; then
-   bool 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
+   tristate 'SGI M48T35 RTC support' CONFIG_SGI_IP27_RTC
 fi
 if [ "$CONFIG_TOSHIBA_RBTX4927" = "y" -o "$CONFIG_TOSHIBA_JMR3927" = "y" ]; then
    tristate 'Dallas DS1742 RTC support' CONFIG_DS1742
@@ -383,6 +381,11 @@ if [ "$CONFIG_DRM" = "y" ]; then
       source drivers/char/drm/Config.in
    fi
 fi
+
+if [ "$CONFIG_X86" = "y" ]; then
+   tristate 'ACP Modem (Mwave) support' CONFIG_MWAVE
+fi
+
 endmenu
 
 if [ "$CONFIG_HOTPLUG" = "y" -a "$CONFIG_PCMCIA" != "n" ]; then
@@ -391,6 +394,7 @@ fi
 if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
    tristate ' Alchemy Au1x00 GPIO device support' CONFIG_AU1X00_GPIO
    tristate ' Au1000/ADS7846 touchscreen support' CONFIG_TS_AU1X00_ADS7846
+   #tristate ' Alchemy Au1550 PSC SPI support' CONFIG_AU1550_PSC_SPI
 fi
 if [ "$CONFIG_MIPS_ITE8172" = "y" ]; then
   tristate ' ITE GPIO' CONFIG_ITE_GPIO
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/Makefile linux-mips-cvs-20040815/drivers/char/Makefile
--- linux-2.4.27/drivers/char/Makefile	2004-08-08 01:26:04.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/Makefile	2004-08-15 08:06:08.000000000 +0200
@@ -25,7 +25,7 @@ export-objs     :=	busmouse.o console.o 
 			misc.o pty.o random.o selection.o serial.o \
 			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
 			au1000_gpio.o vac-serial.o hp_psaux.o nvram.o \
-			scx200.o fetchop.o
+			scx200.o fetchop.o hydrogen3_buttons.o
 
 mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
 
@@ -48,7 +48,12 @@ ifeq ($(ARCH),mips)
     KEYBD    =
   endif
   ifeq ($(CONFIG_VR41XX_KIU),y)
-    KEYMAP   =
+    ifeq ($(CONFIG_IBM_WORKPAD),y)
+      KEYMAP = ibm_workpad_keymap.o
+    endif
+    ifeq ($(CONFIG_VICTOR_MPC30X),y)
+      KEYMAP = victor_mpc30x_keymap.o
+    endif
     KEYBD    = vr41xx_keyb.o
   endif
 endif
@@ -251,7 +256,6 @@ obj-$(CONFIG_MK712_MOUSE) += mk712.o
 obj-$(CONFIG_RTC) += rtc.o
 obj-$(CONFIG_GEN_RTC) += genrtc.o
 obj-$(CONFIG_EFI_RTC) += efirtc.o
-obj-$(CONFIG_SGI_DS1286) += ds1286.o
 obj-$(CONFIG_MIPS_RTC) += mips_rtc.o
 obj-$(CONFIG_SGI_IP27_RTC) += ip27-rtc.o
 ifeq ($(CONFIG_PPC),)
@@ -259,6 +263,7 @@ ifeq ($(CONFIG_PPC),)
 endif
 obj-$(CONFIG_TOSHIBA) += toshiba.o
 obj-$(CONFIG_I8K) += i8k.o
+obj-$(CONFIG_DS1286) += ds1286.o
 obj-$(CONFIG_DS1620) += ds1620.o
 obj-$(CONFIG_DS1742) += ds1742.o
 obj-$(CONFIG_INTEL_RNG) += i810_rng.o
@@ -269,9 +274,11 @@ obj-$(CONFIG_BRIQ_PANEL) += briq_panel.o
 
 obj-$(CONFIG_ITE_GPIO) += ite_gpio.o
 obj-$(CONFIG_AU1X00_GPIO) += au1000_gpio.o
+obj-$(CONFIG_AU1550_PSC_SPI) += au1550_psc_spi.o
 obj-$(CONFIG_AU1X00_USB_TTY) += au1000_usbtty.o
 obj-$(CONFIG_AU1X00_USB_RAW) += au1000_usbraw.o
 obj-$(CONFIG_COBALT_LCD) += lcd.o
+obj-$(CONFIG_MIPS_HYDROGEN3_BUTTONS) += hydrogen3_buttons.o
 
 obj-$(CONFIG_QIC02_TAPE) += tpqic02.o
 
@@ -353,3 +360,9 @@ defkeymap.c: defkeymap.map
 
 qtronixmap.c: qtronixmap.map
 	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+ibm_workpad_keymap.c: ibm_workpad_keymap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
+
+victor_mpc30x_keymap.c: victor_mpc30x_keymap.map
+	set -e ; loadkeys --mktable $< | sed -e 's/^static *//' > $@
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/au1000_gpio.c linux-mips-cvs-20040815/drivers/char/au1000_gpio.c
--- linux-2.4.27/drivers/char/au1000_gpio.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/au1000_gpio.c	2003-12-20 14:18:51.000000000 +0100
@@ -246,7 +246,7 @@ static struct file_operations au1000gpio
 
 static struct miscdevice au1000gpio_miscdev =
 {
-	GPIO_MINOR,
+	MISC_DYNAMIC_MINOR,
 	"au1000_gpio",
 	&au1000gpio_fops
 };
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/au1550_psc_spi.c linux-mips-cvs-20040815/drivers/char/au1550_psc_spi.c
--- linux-2.4.27/drivers/char/au1550_psc_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/au1550_psc_spi.c	2004-07-14 08:30:30.000000000 +0200
@@ -0,0 +1,440 @@
+/*
+ *  Driver for Alchemy Au1550 SPI on the PSC.
+ *
+ * Copyright 2004 Embedded Edge, LLC.
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE	LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/au1550_spi.h>
+#include <asm/au1xxx_psc.h>
+
+#ifdef CONFIG_MIPS_PB1550
+#include <asm/pb1550.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+#include <asm/db1x00.h>
+#endif
+
+/* This is just a simple programmed I/O SPI interface on the PSC of the 1550.
+ * We support open, close, write, and ioctl.  The SPI is a full duplex
+ * interface, you can't read without writing.  So, the write system call
+ * copies the bytes out to the SPI, and whatever is returned is placed
+ * in the same buffer.  Kinda weird, maybe we'll change it, but for now
+ * it works OK.
+ * I didn't implement any DMA yet, and it's a debate about the necessity.
+ * The SPI clocks are usually quite fast, so data is sent/received as
+ * quickly as you can stuff the FIFO.  The overhead of DMA and interrupts
+ * are usually far greater than the data transfer itself.  If, however,
+ * we find applications that move large amounts of data, we may choose
+ * use the overhead of buffering and DMA to do the work.
+ */
+
+/* The maximum clock rate specified in the manual is 2mHz.
+*/
+#define MAX_BAUD_RATE	(2 * 1000000)
+#define PSC_INTCLK_RATE (32 * 1000000)
+
+static	int	inuse;
+
+/* We have to know what the user requested for the data length
+ * so we know how to stuff the fifo.  The FIFO is 32 bits wide,
+ * and we have to load it with the bits to go in a single transfer.
+ */
+static	uint	spi_datalen;
+
+static int
+au1550spi_open(struct inode *inode, struct file *file)
+{
+	if (inuse)
+		return -EBUSY;
+
+	inuse = 1;
+
+	MOD_INC_USE_COUNT;
+
+	return 0;
+}
+
+static ssize_t
+au1550spi_write(struct file *fp, const char *bp, size_t count, loff_t *ppos)
+{
+	int	bytelen, i;
+	size_t	rcount, retval;
+	unsigned char	sb, *rp, *wp;
+	uint	fifoword, pcr, stat;
+	volatile psc_spi_t *sp;
+
+	/* Get the number of bytes per transfer.
+	*/
+	bytelen = ((spi_datalen - 1) / 8) + 1;
+
+	/* User needs to send us multiple of this count.
+	*/
+	if ((count % bytelen) != 0)
+		return -EINVAL;
+
+	rp = wp = (unsigned char *)bp;
+	retval = rcount = count;
+
+	/* Reset the FIFO.
+	*/
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	sp->psc_spipcr = (PSC_SPIPCR_RC | PSC_SPIPCR_TC);
+	au_sync();
+	do {
+		pcr = sp->psc_spipcr;
+		au_sync();
+	} while (pcr != 0);
+
+	/* Prime the transmit FIFO.
+	*/
+	while (count > 0) {
+		fifoword = 0;
+		for (i=0; i<bytelen; i++) {
+			fifoword <<= 8;
+			if (get_user(sb, wp) < 0)
+				return -EFAULT;
+			fifoword |= sb;
+			wp++;
+		}
+		count -= bytelen;
+		if (count <= 0)
+			fifoword |= PSC_SPITXRX_LC;
+		sp->psc_spitxrx = fifoword;
+		au_sync();
+		stat = sp->psc_spistat;
+		au_sync();
+		if (stat & PSC_SPISTAT_TF)
+			break;
+	}
+
+	/* Start the transfer.
+	*/
+	sp->psc_spipcr = PSC_SPIPCR_MS;
+	au_sync();
+
+	/* Now, just keep the transmit fifo full and empty the receive.
+	*/
+	while (count > 0) {
+		stat = sp->psc_spistat;
+		au_sync();
+		while ((stat & PSC_SPISTAT_RE) == 0) {
+			fifoword = sp->psc_spitxrx;
+			au_sync();
+			for (i=0; i<bytelen; i++) {
+				sb = fifoword & 0xff;
+				if (put_user(sb, rp) < 0)
+					return -EFAULT;
+				fifoword >>= 8;
+				rp++;
+			}
+			rcount -= bytelen;
+			stat = sp->psc_spistat;
+			au_sync();
+		}
+		if ((stat & PSC_SPISTAT_TF) == 0) {
+			fifoword = 0;
+			for (i=0; i<bytelen; i++) {
+				fifoword <<= 8;
+				if (get_user(sb, wp) < 0)
+					return -EFAULT;
+				fifoword |= sb;
+				wp++;
+			}
+			count -= bytelen;
+			if (count <= 0)
+				fifoword |= PSC_SPITXRX_LC;
+			sp->psc_spitxrx = fifoword;
+			au_sync();
+		}
+	}
+
+	/* All of the bytes for transmit have been written.  Hang
+	 * out waiting for any residual bytes that are yet to be
+	 * read from the fifo.
+	 */
+	while (rcount > 0) {
+		stat = sp->psc_spistat;
+		au_sync();
+		if ((stat & PSC_SPISTAT_RE) == 0) {
+			fifoword = sp->psc_spitxrx;
+			au_sync();
+			for (i=0; i<bytelen; i++) {
+				sb = fifoword & 0xff;
+				if (put_user(sb, rp) < 0)
+					return -EFAULT;
+				fifoword >>= 8;
+				rp++;
+			}
+			rcount -= bytelen;
+		}
+	}
+	return retval;
+}
+
+static int
+au1550spi_release(struct inode *inode, struct file *file)
+{
+	MOD_DEC_USE_COUNT;
+
+	inuse = 0;
+
+	return 0;
+}
+
+/* Set the baud rate closest to the request, then return the actual
+ * value we are using.
+ */
+static uint
+set_baud_rate(uint baud)
+{
+	uint	rate, tmpclk, brg, ctl, stat;
+	volatile psc_spi_t *sp;
+
+	/* For starters, the input clock is divided by two.
+	*/
+	tmpclk = PSC_INTCLK_RATE/2;
+
+	rate = tmpclk / baud;
+
+	/* The dividers work as follows:
+	 *	baud = tmpclk / (2 * (brg + 1))
+	 */
+	 brg = (rate/2) - 1;
+
+	 /* Test BRG to ensure it will fit into the 6 bits allocated.
+	 */
+
+	 /* Make sure the device is disabled while we make the change.
+	 */
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	ctl = sp->psc_spicfg;
+	au_sync();
+	sp->psc_spicfg = ctl & ~PSC_SPICFG_DE_ENABLE;
+	au_sync();
+	ctl = PSC_SPICFG_CLR_BAUD(ctl);
+	ctl |= PSC_SPICFG_SET_BAUD(brg);
+	sp->psc_spicfg = ctl;
+	au_sync();
+
+	/* If the device was running prior to getting here, wait for
+	 * it to restart.
+	 */
+	if (ctl & PSC_SPICFG_DE_ENABLE) {
+		do {
+			stat = sp->psc_spistat;
+			au_sync();
+		} while ((stat & PSC_SPISTAT_DR) == 0);
+	}
+
+	/* Return the actual value.
+	*/
+	rate = tmpclk / (2 * (brg + 1));
+
+	return(rate);
+}
+
+static uint
+set_word_len(uint len)
+{
+	uint	ctl, stat;
+	volatile psc_spi_t *sp;
+
+	if ((len < 4) || (len > 24))
+		return -EINVAL;
+
+	 /* Make sure the device is disabled while we make the change.
+	 */
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	ctl = sp->psc_spicfg;
+	au_sync();
+	sp->psc_spicfg = ctl & ~PSC_SPICFG_DE_ENABLE;
+	au_sync();
+	ctl = PSC_SPICFG_CLR_LEN(ctl);
+	ctl |= PSC_SPICFG_SET_LEN(len);
+	sp->psc_spicfg = ctl;
+	au_sync();
+
+	/* If the device was running prior to getting here, wait for
+	 * it to restart.
+	 */
+	if (ctl & PSC_SPICFG_DE_ENABLE) {
+		do {
+			stat = sp->psc_spistat;
+			au_sync();
+		} while ((stat & PSC_SPISTAT_DR) == 0);
+	}
+
+	return 0;
+}
+
+static int
+au1550spi_ioctl(struct inode *inode, struct file *file,
+			    unsigned int cmd, unsigned long arg)
+{
+	int status;
+	u32 val;
+
+	status = 0;
+
+	switch(cmd) {
+	case AU1550SPI_WORD_LEN:
+		status = set_word_len(arg);
+		break;
+
+	case AU1550SPI_SET_BAUD:
+		if (get_user(val, (u32 *)arg)) 
+			return -EFAULT;
+
+		val = set_baud_rate(val);
+		if (put_user(val, (u32 *)arg)) 
+			return -EFAULT;
+		break;
+
+	default:
+		status = -ENOIOCTLCMD;
+
+	}
+
+	return status;
+}
+
+
+static struct file_operations au1550spi_fops =
+{
+	owner:		THIS_MODULE,
+	write:		au1550spi_write,
+	ioctl:		au1550spi_ioctl,
+	open:		au1550spi_open,
+	release:	au1550spi_release,
+};
+
+
+static struct miscdevice au1550spi_miscdev =
+{
+	MISC_DYNAMIC_MINOR,
+	"au1550_spi",
+	&au1550spi_fops
+};
+
+
+int __init
+au1550spi_init(void)
+{
+	uint	clk, rate, stat;
+	volatile psc_spi_t *sp;
+
+	/* Wire up Freq3 as a clock for the SPI.  The PSC does
+	 * factor of 2 divisor, so run a higher rate so we can
+	 * get some granularity to the clock speeds.
+	 * We can't do this in board set up because the frequency
+	 * is computed too late.
+	 */
+	rate = get_au1x00_speed();
+	rate /= PSC_INTCLK_RATE;
+
+	/* The FRDIV in the frequency control is (FRDIV + 1) * 2
+	*/
+	rate /=2;
+	rate--;
+	clk = au_readl(SYS_FREQCTRL1);
+	au_sync();
+	clk &= ~SYS_FC_FRDIV3_MASK;
+	clk |= (rate << SYS_FC_FRDIV3_BIT);
+	clk |= SYS_FC_FE3;
+	au_writel(clk, SYS_FREQCTRL1);
+	au_sync();
+
+	/* Set up the clock source routing to get Freq3 to PSC0_intclk.
+	*/
+	clk = au_readl(SYS_CLKSRC);
+	au_sync();
+	clk &= ~0x03e0;
+	clk |= (5 << 7);
+	au_writel(clk, SYS_CLKSRC);
+	au_sync();
+
+	/* Set up GPIO pin function to drive PSC0_SYNC1, which is
+	 * the SPI Select.
+	 */
+	clk = au_readl(SYS_PINFUNC);
+	au_sync();
+	clk |= 1;
+	au_writel(clk, SYS_PINFUNC);
+	au_sync();
+
+	/* Now, set up the PSC for SPI PIO mode.
+	*/
+	sp = (volatile psc_spi_t *)SPI_PSC_BASE;
+	sp->psc_ctrl = PSC_CTRL_DISABLE;
+	au_sync();
+	sp->psc_sel = PSC_SEL_PS_SPIMODE;
+	sp->psc_spicfg = 0;
+	au_sync();
+	sp->psc_ctrl = PSC_CTRL_ENABLE;
+	au_sync();
+	do {
+		stat = sp->psc_spistat;
+		au_sync();
+	} while ((stat & PSC_SPISTAT_SR) == 0);
+
+	sp->psc_spicfg = (PSC_SPICFG_RT_FIFO8 | PSC_SPICFG_TT_FIFO8 |
+				PSC_SPICFG_DD_DISABLE | PSC_SPICFG_MO);
+	sp->psc_spicfg |= PSC_SPICFG_SET_LEN(8);
+	spi_datalen = 8;
+	sp->psc_spimsk = PSC_SPIMSK_ALLMASK;
+	au_sync();
+
+	set_baud_rate(1000000);
+
+	sp->psc_spicfg |= PSC_SPICFG_DE_ENABLE;
+	do {
+		stat = sp->psc_spistat;
+		au_sync();
+	} while ((stat & PSC_SPISTAT_DR) == 0);
+
+	misc_register(&au1550spi_miscdev);
+	printk("Au1550 SPI driver\n");
+	return 0;
+}	
+
+
+void __exit
+au1550spi_exit(void)
+{
+	misc_deregister(&au1550spi_miscdev);
+}
+
+
+module_init(au1550spi_init);
+module_exit(au1550spi_exit);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/decserial.c linux-mips-cvs-20040815/drivers/char/decserial.c
--- linux-2.4.27/drivers/char/decserial.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/decserial.c	2004-08-15 08:06:08.000000000 +0200
@@ -14,84 +14,82 @@
  *      device. Added support for PROM console in drivers/char/tty_io.c
  *      instead. Although it may work to enable more than one 
  *      console device I strongly recommend to use only one.
+ *
+ *	Copyright (C) 2004  Maciej W. Rozycki
  */
 
 #include <linux/config.h>
+#include <linux/errno.h>
 #include <linux/init.h>
-#include <asm/dec/machtype.h>
-
-#ifdef CONFIG_ZS
-extern int zs_init(void);
-#endif
 
-#ifdef CONFIG_DZ
-extern int dz_init(void);
-#endif
+#include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
 
-#ifdef CONFIG_SERIAL_DEC_CONSOLE
+extern int register_zs_hook(unsigned int channel,
+			    struct dec_serial_hook *hook);
+extern int unregister_zs_hook(unsigned int channel);
 
+int register_dec_serial_hook(unsigned int channel,
+			     struct dec_serial_hook *hook)
+{
 #ifdef CONFIG_ZS
-extern void zs_serial_console_init(void);
-#endif
-
-#ifdef CONFIG_DZ
-extern void dz_serial_console_init(void);
+	if (IOASIC)
+		return register_zs_hook(channel, hook);
 #endif
+	return 0;
+}
 
+int unregister_dec_serial_hook(unsigned int channel)
+{
+#ifdef CONFIG_ZS
+	if (IOASIC)
+		return unregister_zs_hook(channel);
 #endif
+	return 0;
+}
 
-/* rs_init - starts up the serial interface -
-   handle normal case of starting up the serial interface */
 
-#ifdef CONFIG_SERIAL_DEC
+extern int zs_init(void);
+extern int dz_init(void);
 
+/*
+ * rs_init - starts up the serial interface -
+ * handle normal case of starting up the serial interface
+ */
 int __init rs_init(void)
 {
-
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	return zs_init();
-    else
-	return dz_init();
-#else
-
 #ifdef CONFIG_ZS
-    return zs_init();
+	if (IOASIC)
+		return zs_init();
 #endif
-
 #ifdef CONFIG_DZ
-    return dz_init();
-#endif
-
+	if (!IOASIC)
+		return dz_init();
 #endif
+	return -ENXIO;
 }
 
 __initcall(rs_init);
 
-#endif
 
 #ifdef CONFIG_SERIAL_DEC_CONSOLE
 
-/* dec_serial_console_init handles the special case of starting
- *   up the console on the serial port
+extern void zs_serial_console_init(void);
+extern void dz_serial_console_init(void);
+
+/*
+ * dec_serial_console_init handles the special case of starting
+ * up the console on the serial port
  */
 void __init dec_serial_console_init(void)
 {
-#if defined(CONFIG_ZS) && defined(CONFIG_DZ)
-    if (IOASIC)
-	zs_serial_console_init();
-    else
-	dz_serial_console_init();
-#else
-
 #ifdef CONFIG_ZS
-    zs_serial_console_init();
+	if (IOASIC)
+		zs_serial_console_init();
 #endif
-
 #ifdef CONFIG_DZ
-    dz_serial_console_init();
-#endif
-
+	if (!IOASIC)
+		dz_serial_console_init();
 #endif
 }
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/ds1286.c linux-mips-cvs-20040815/drivers/char/ds1286.c
--- linux-2.4.27/drivers/char/ds1286.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/ds1286.c	2004-01-10 06:21:39.000000000 +0100
@@ -1,6 +1,10 @@
 /*
  * DS1286 Real Time Clock interface for Linux
  *
+ * Copyright (C) 2003 TimeSys Corp.
+ *                    S. James Hill (James.Hill@timesys.com)
+ *                                  (sjhill@realitydiluted.com)
+ *
  * Copyright (C) 1998, 1999, 2000 Ralf Baechle
  *
  * Based on code written by Paul Gortmaker.
@@ -29,6 +33,7 @@
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/miscdevice.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
 #include <linux/fcntl.h>
@@ -95,6 +100,12 @@ static ssize_t ds1286_read(struct file *
 	return -EIO;
 }
 
+void rtc_ds1286_wait(void)
+{
+	unsigned char sec = CMOS_READ(RTC_SECONDS);
+	while (sec == CMOS_READ(RTC_SECONDS));
+}
+
 static int ds1286_ioctl(struct inode *inode, struct file *file,
                         unsigned int cmd, unsigned long arg)
 {
@@ -249,23 +260,22 @@ static int ds1286_open(struct inode *ino
 {
 	spin_lock_irq(&ds1286_lock);
 
-	if (ds1286_status & RTC_IS_OPEN)
-		goto out_busy;
+	if (ds1286_status & RTC_IS_OPEN) {
+		spin_unlock_irq(&ds1286_lock);
+		return -EBUSY;
+	}
 
 	ds1286_status |= RTC_IS_OPEN;
 
-	spin_lock_irq(&ds1286_lock);
+	spin_unlock_irq(&ds1286_lock);
 	return 0;
-
-out_busy:
-	spin_lock_irq(&ds1286_lock);
-	return -EBUSY;
 }
 
 static int ds1286_release(struct inode *inode, struct file *file)
 {
+	spin_lock_irq(&ds1286_lock);
 	ds1286_status &= ~RTC_IS_OPEN;
-
+	spin_unlock_irq(&ds1286_lock);
 	return 0;
 }
 
@@ -276,32 +286,6 @@ static unsigned int ds1286_poll(struct f
 	return 0;
 }
 
-/*
- *	The various file operations we support.
- */
-
-static struct file_operations ds1286_fops = {
-	.llseek		= no_llseek,
-	.read		= ds1286_read,
-	.poll		= ds1286_poll,
-	.ioctl		= ds1286_ioctl,
-	.open		= ds1286_open,
-	.release	= ds1286_release,
-};
-
-static struct miscdevice ds1286_dev=
-{
-	.minor	= RTC_MINOR,
-	.name	= "rtc",
-	.fops	= &ds1286_fops,
-};
-
-int __init ds1286_init(void)
-{
-	printk(KERN_INFO "DS1286 Real Time Clock Driver v%s\n", DS1286_VERSION);
-	return misc_register(&ds1286_dev);
-}
-
 static char *days[] = {
 	"***", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
 };
@@ -528,3 +512,38 @@ void ds1286_get_alm_time(struct rtc_time
 	BCD_TO_BIN(alm_tm->tm_hour);
 	alm_tm->tm_sec = 0;
 }
+
+static struct file_operations ds1286_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= ds1286_read,
+	.poll		= ds1286_poll,
+	.ioctl		= ds1286_ioctl,
+	.open		= ds1286_open,
+	.release	= ds1286_release,
+};
+
+static struct miscdevice ds1286_dev =
+{
+	.minor	= RTC_MINOR,
+	.name	= "rtc",
+	.fops	= &ds1286_fops,
+};
+
+static int __init ds1286_init(void)
+{
+	printk(KERN_INFO "DS1286 Real Time Clock Driver v%s\n", DS1286_VERSION);
+	return misc_register(&ds1286_dev);
+}
+
+static void __exit ds1286_exit(void)
+{
+	misc_deregister(&ds1286_dev);
+}
+
+module_init(ds1286_init);
+module_exit(ds1286_exit);
+EXPORT_NO_SYMBOLS;
+
+MODULE_AUTHOR("Ralf Baechle");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/ds1742.c linux-mips-cvs-20040815/drivers/char/ds1742.c
--- linux-2.4.27/drivers/char/ds1742.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/ds1742.c	2004-01-09 20:27:16.000000000 +0100
@@ -142,6 +142,7 @@ static int rtc_ds1742_set_time(unsigned 
 	CMOS_WRITE(RTC_WRITE, RTC_CONTROL);
 
 	/* convert */
+	memset(&tm, 0, sizeof(struct rtc_time));
 	to_tm(t, &tm);
 
 	/* check each field one by one */
@@ -216,6 +217,7 @@ static int get_ds1742_status(char *buf)
 	unsigned long curr_time;
 
 	curr_time = rtc_ds1742_get_time();
+	memset(&tm, 0, sizeof(struct rtc_time));
 	to_tm(curr_time, &tm);
 
 	p = buf;
@@ -251,8 +253,8 @@ static int ds1742_read_proc(char *page, 
 
 void rtc_ds1742_wait(void)
 {
-	while (CMOS_READ(RTC_SECONDS) & 1);
-	while (!(CMOS_READ(RTC_SECONDS) & 1));
+	unsigned char sec = CMOS_READ(RTC_SECONDS);
+	while (sec == CMOS_READ(RTC_SECONDS));
 }
 
 static int ds1742_ioctl(struct inode *inode, struct file *file,
@@ -264,6 +266,7 @@ static int ds1742_ioctl(struct inode *in
 	switch (cmd) {
 	case RTC_RD_TIME:	/* Read the time/date from RTC  */
 		curr_time = rtc_ds1742_get_time();
+		memset(&rtc_tm, 0, sizeof(struct rtc_time));
 		to_tm(curr_time, &rtc_tm);
 		rtc_tm.tm_year -= 1900;
 		return copy_to_user((void *) arg, &rtc_tm, sizeof(rtc_tm)) ? 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/dummy_keyb.c linux-mips-cvs-20040815/drivers/char/dummy_keyb.c
--- linux-2.4.27/drivers/char/dummy_keyb.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/dummy_keyb.c	2004-01-09 09:53:08.000000000 +0100
@@ -140,3 +140,7 @@ void __init kbd_init_hw(void)
 {
 	printk("Dummy keyboard driver installed.\n");
 }
+#ifdef CONFIG_MAGIC_SYSRQ
+unsigned char kbd_sysrq_key;
+unsigned char kbd_sysrq_xlate[128];
+#endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/hydrogen3_buttons.c linux-mips-cvs-20040815/drivers/char/hydrogen3_buttons.c
--- linux-2.4.27/drivers/char/hydrogen3_buttons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/hydrogen3_buttons.c	2003-12-22 05:08:24.000000000 +0100
@@ -0,0 +1,308 @@
+/*
+ *  Copyright (C) 2003 Metrowerks, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/miscdevice.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <asm/au1000.h>
+#include <asm/uaccess.h>
+
+#define BUTTON_SELECT	(1<<1)
+#define BUTTON_1	(1<<2)
+#define BUTTON_2	(1<<3)
+#define BUTTON_ONOFF	(1<<6)
+#define BUTTON_3	(1<<7)
+#define BUTTON_4	(1<<8)
+#define BUTTON_LEFT	(1<<9)
+#define BUTTON_DOWN	(1<<10)
+#define BUTTON_RIGHT	(1<<11)
+#define BUTTON_UP	(1<<12)
+
+#define BUTTON_MASK (\
+    BUTTON_SELECT	\
+    | BUTTON_1   	\
+    | BUTTON_2		\
+    | BUTTON_ONOFF	\
+    | BUTTON_3		\
+    | BUTTON_4		\
+    | BUTTON_LEFT	\
+    | BUTTON_DOWN	\
+    | BUTTON_RIGHT	\
+    | BUTTON_UP		\
+    )
+
+#define BUTTON_INVERT (\
+    BUTTON_SELECT	\
+    | BUTTON_1   	\
+    | BUTTON_2		\
+    | BUTTON_3		\
+    | BUTTON_4		\
+    | BUTTON_LEFT	\
+    | BUTTON_DOWN	\
+    | BUTTON_RIGHT	\
+    | BUTTON_UP		\
+    )
+
+
+
+#define MAKE_FLAG 0x20
+
+#undef DEBUG
+
+#define DEBUG 0
+//#define DEBUG 1
+
+#if DEBUG
+#define DPRINTK(format, args...) printk(__FUNCTION__ ": "  format, ## args)
+#else
+#define DPRINTK(format, args...) do { } while (0)
+#endif
+
+/* Please note that this driver is based on a timer and is not interrupt
+ * driven.  If you are going to make use of this driver, you will need to have
+ * your application open the buttons listing from the /dev directory first.
+ */
+
+struct hydrogen3_buttons {
+	struct fasync_struct *fasync;
+	wait_queue_head_t     read_wait;
+	int open_count;
+	unsigned int debounce;
+	unsigned int current;
+	unsigned int last;
+};
+
+static struct hydrogen3_buttons buttons_info;
+
+
+static void button_timer_periodic(void *data);
+
+static struct tq_struct button_task = {
+	routine:	button_timer_periodic,
+	data:		NULL
+};
+
+static int cleanup_flag = 0;
+static DECLARE_WAIT_QUEUE_HEAD(cleanup_wait_queue);
+
+
+static unsigned int read_button_state(void)
+{
+	unsigned long state;
+
+	state = inl(SYS_PINSTATERD) & BUTTON_MASK;
+	state ^= BUTTON_INVERT;
+	
+	DPRINTK( "Current Button State: %d\n", state );
+
+	return state;
+}
+
+
+static void button_timer_periodic(void *data)
+{
+	struct hydrogen3_buttons *buttons = (struct hydrogen3_buttons *)data;
+	unsigned long button_state;
+	
+	// If cleanup wants us to die
+	if (cleanup_flag) {
+		wake_up(&cleanup_wait_queue);		// now cleanup_module can return
+	} else {
+		queue_task(&button_task, &tq_timer);	// put ourselves back in the task queue
+	}
+
+	// read current buttons
+	button_state = read_button_state();
+
+	// if no buttons are down and nothing to do then
+	// save time and be done.
+	if ((button_state == 0) && (buttons->current == 0)) {
+		return;
+	}
+	
+	if (button_state == buttons->debounce) {
+		buttons->current = button_state;
+	} else {
+		buttons->debounce = button_state;
+	}
+//	printk("0x%04x\n", button_state);
+	if (buttons->current != buttons->last) {
+		if (waitqueue_active(&buttons->read_wait)) {
+		    wake_up_interruptible(&buttons->read_wait);
+		}
+	}
+}
+
+
+static ssize_t hydrogen3_buttons_read(struct file *filp, char *buffer, size_t count, loff_t *ppos)
+{
+	struct hydrogen3_buttons *buttons = filp->private_data;
+	char events[16];
+	int index;
+	int last;
+	int cur;
+	int bit;
+	int bit_mask;
+	int err;
+	
+	DPRINTK("start\n");
+
+try_again:
+
+	while (buttons->current == buttons->last) {
+		if (filp->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		interruptible_sleep_on(&buttons->read_wait);
+		if (signal_pending(current)) {
+			return -ERESTARTSYS;
+		}
+	}
+	
+	cur  = buttons->current;
+	last = buttons->last;
+	
+	index    = 0;
+	bit_mask = 1;
+	for (bit = 0; (bit < 16) && count; bit++) {
+		if ((cur ^ last) & bit_mask) {
+			if (cur & bit_mask) {
+				events[index] = (bit | MAKE_FLAG) + 'A';
+				last |= bit_mask;
+			} else {
+				events[index] = bit + 'A';
+				last &= ~bit_mask;
+			}
+			index++;
+			count--;
+		}
+		bit_mask <<= 1;
+	}
+	buttons->last = last;
+	
+	if (index == 0) {
+		goto try_again;
+	}
+	
+	err = copy_to_user(buffer, events, index);
+	if (err) {
+		return err;
+	}
+	
+	return index;
+}
+
+
+static int hydrogen3_buttons_open(struct inode *inode, struct file *filp)
+{
+	struct hydrogen3_buttons *buttons = &buttons_info;
+
+	DPRINTK("start\n");
+	MOD_INC_USE_COUNT;
+
+	filp->private_data = buttons;
+
+	if (buttons->open_count++ == 0) {
+		button_task.data = buttons;
+		cleanup_flag = 0;
+		queue_task(&button_task, &tq_timer);
+	}
+
+	return 0;
+}
+
+
+static unsigned int hydrogen3_buttons_poll(struct file *filp, poll_table *wait)
+{
+	struct hydrogen3_buttons *buttons = filp->private_data;
+	int ret = 0;
+
+	DPRINTK("start\n");
+	poll_wait(filp, &buttons->read_wait, wait);
+	if (buttons->current != buttons->last) {
+		ret = POLLIN | POLLRDNORM;
+	}
+	return ret;
+}
+
+
+static int hydrogen3_buttons_release(struct inode *inode, struct file *filp)
+{
+	struct hydrogen3_buttons *buttons = filp->private_data;
+
+	DPRINTK("start\n");
+
+	if (--buttons->open_count == 0) {
+		cleanup_flag = 1;
+		sleep_on(&cleanup_wait_queue);
+	}
+	MOD_DEC_USE_COUNT;
+	
+	return 0;
+}
+
+
+
+static struct file_operations hydrogen3_buttons_fops = {
+	owner:		THIS_MODULE,
+	read:		hydrogen3_buttons_read,
+	poll:		hydrogen3_buttons_poll,
+	open:		hydrogen3_buttons_open,
+	release:	hydrogen3_buttons_release,
+};
+
+/*
+ * The hydrogen3 buttons is a misc device:
+ * Major 10 char
+ * Minor 22        /dev/buttons
+ * 
+ * This is /dev/misc/buttons if devfs is used.
+ */
+
+static struct miscdevice hydrogen3_buttons_dev = {
+	minor:	22,
+	name:	"buttons",
+	fops:	&hydrogen3_buttons_fops,
+};
+
+static int __init hydrogen3_buttons_init(void)
+{
+	struct hydrogen3_buttons *buttons = &buttons_info;
+	int ret;
+
+	DPRINTK("Initializing buttons driver\n");
+	buttons->open_count = 0;
+	cleanup_flag        = 0;
+	init_waitqueue_head(&buttons->read_wait);
+
+
+	// yamon configures GPIO pins for the buttons
+	// no initialization needed
+
+	ret = misc_register(&hydrogen3_buttons_dev);
+
+	DPRINTK("Buttons driver fully initialized.\n");
+
+	return ret;
+}
+
+
+static void __exit hydrogen3_buttons_exit(void)
+{
+	DPRINTK("unloading buttons driver\n");
+	misc_deregister(&hydrogen3_buttons_dev);
+}
+
+
+module_init(hydrogen3_buttons_init);
+module_exit(hydrogen3_buttons_exit);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/ibm_workpad_keymap.map linux-mips-cvs-20040815/drivers/char/ibm_workpad_keymap.map
--- linux-2.4.27/drivers/char/ibm_workpad_keymap.map	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/ibm_workpad_keymap.map	2003-12-20 15:20:44.000000000 +0100
@@ -0,0 +1,343 @@
+# Keymap for IBM Workpad z50
+# US Mapping
+#
+# by Michael Klar <wyldfier@iname.com>
+#
+# This is a great big mess on account of how the Caps Lock key is handled as
+# LeftShift-RightShift.  Right shift key had to be broken out, so don't use
+# use this map file as a basis for other keyboards that don't do the same
+# thing with Caps Lock.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+
+keymaps 0-2,4-5,8,12,32-33,36-37
+strings as usual
+
+keycode 0 = F1 F11 Console_13
+	shiftr keycode 0 = F11
+	shift shiftr keycode 0 = F11
+	control keycode 0 = F1
+	alt keycode 0 = Console_1
+	control alt keycode 0 = Console_1
+keycode 1 = F3 F13 Console_15
+	shiftr keycode 1 = F13
+	shift shiftr keycode 1 = F13
+	control keycode 1 = F3
+	alt keycode 1 = Console_3
+	control alt keycode 1 = Console_3
+keycode 2 = F5 F15 Console_17
+	shiftr keycode 2 = F15
+	shift shiftr keycode 2 = F15
+	control keycode 2 = F5
+	alt keycode 2 = Console_5
+	control alt keycode 2 = Console_5
+keycode 3 = F7 F17 Console_19
+	shiftr keycode 3 = F17
+	shift shiftr keycode 3 = F17
+	control keycode 3 = F7
+	alt keycode 3 = Console_7
+	control alt keycode 3 = Console_7
+keycode 4 = F9 F19 Console_21
+	shiftr keycode 4 = F19
+	shift shiftr keycode 4 = F19
+	control keycode 4 = F9
+	alt keycode 4 = Console_9
+	control alt keycode 4 = Console_9
+#keycode 5 is contrast down
+#keycode 6 is contrast up
+keycode 7 = F11 F11 Console_23
+	shiftr keycode 7 = F11
+	shift shiftr keycode 7 = F11
+	control keycode 7 = F11
+	alt keycode 7 = Console_11
+	control alt keycode 7 = Console_11
+keycode 8 = F2 F12 Console_14
+	shiftr keycode 8 = F12
+	shift shiftr keycode 8 = F12
+	control keycode 8 = F2
+	alt keycode 8 = Console_2
+	control alt keycode 8 = Console_2
+keycode 9 = F4 F14 Console_16
+	shiftr keycode 9 = F14
+	shift shiftr keycode 9 = F14
+	control keycode 9 = F4
+	alt keycode 9 = Console_4
+	control alt keycode 9 = Console_4
+keycode 10 = F6 F16 Console_18
+	shiftr keycode 10 = F16
+	shift shiftr keycode 10 = F16
+	control keycode 10 = F6
+	alt keycode 10 = Console_6
+	control alt keycode 10 = Console_6
+keycode 11 = F8 F18 Console_20
+	shiftr keycode 11 = F18
+	shift shiftr keycode 11 = F18
+	control keycode 11 = F8
+	alt keycode 11 = Console_8
+	control alt keycode 11 = Console_8
+keycode 12 = F10 F20 Console_22
+	shiftr keycode 12 = F20
+	shift shiftr keycode 12 = F20
+	control keycode 12 = F10
+	alt keycode 12 = Console_10
+	control alt keycode 12 = Console_10
+#keycode 13 is brightness down
+#keycode 14 is brightness up
+keycode 15 = F12 F12 Console_24
+	shiftr keycode 15 = F12
+	shift shiftr keycode 15 = F12
+	control keycode 15 = F12
+	alt keycode 15 = Console_12
+	control alt keycode 15 = Console_12
+keycode 16 = apostrophe quotedbl
+	shiftr keycode 16 = quotedbl
+	shift shiftr keycode 16 = quotedbl
+	control keycode 16 = Control_g
+	alt keycode 16 = Meta_apostrophe
+keycode 17 = bracketleft braceleft
+	shiftr keycode 17 = braceleft
+	shift shiftr keycode 17 = braceleft
+	control keycode 17 = Escape
+	alt keycode 17 = Meta_bracketleft
+keycode 18 = minus underscore backslash       
+	shiftr keycode 18 = underscore
+	shift shiftr keycode 18 = underscore
+	control keycode 18 = Control_underscore
+	shift control keycode 18 = Control_underscore
+	shiftr control keycode 18 = Control_underscore
+	shift shiftr control keycode 18 = Control_underscore
+	alt keycode 18 = Meta_minus
+keycode 19 = zero parenright braceright
+	shiftr keycode 19 = parenright
+	shift shiftr keycode 19 = parenright
+	alt keycode 19 = Meta_zero
+keycode 20 = p
+	shiftr keycode 20 = +P
+	shift shiftr keycode 20 = +p
+keycode 21 = semicolon colon
+	shiftr keycode 21 = colon
+	shift shiftr keycode 21 = colon
+	alt keycode 21 = Meta_semicolon
+keycode 22 = Up Scroll_Backward
+	shiftr keycode 22 = Scroll_Backward
+	shift shiftr keycode 22 = Scroll_Backward
+	alt keycode 22 = Prior
+keycode 23 = slash question
+	shiftr keycode 23 = question
+	shift shiftr keycode 23 = question
+	control keycode 23 = Delete
+	alt keycode 23 = Meta_slash
+
+keycode 27 = nine parenleft bracketright
+	shiftr keycode 27 = parenleft
+	shift shiftr keycode 27 = parenleft
+	alt keycode 27 = Meta_nine
+keycode 28 = o
+	shiftr keycode 28 = +O
+	shift shiftr keycode 28 = +o
+keycode 29 = l
+	shiftr keycode 29 = +L
+	shift shiftr keycode 29 = +l
+keycode 30 = period greater
+	shiftr keycode 30 = greater
+	shift shiftr keycode 30 = greater
+	control keycode 30 = Compose
+	alt keycode 30 = Meta_period
+
+keycode 32 = Left Decr_Console
+	shiftr keycode 32 = Decr_Console
+	shift shiftr keycode 32 = Decr_Console
+	alt keycode 32 = Home
+keycode 33 = bracketright braceright asciitilde      
+	shiftr keycode 33 = braceright
+	shift shiftr keycode 33 = braceright
+	control keycode 33 = Control_bracketright
+	alt keycode 33 = Meta_bracketright
+keycode 34 = equal plus
+	shiftr keycode 34 = plus
+	shift shiftr keycode 34 = plus
+	alt keycode 34 = Meta_equal
+keycode 35 = eight asterisk bracketleft
+	shiftr keycode 35 = asterisk
+	shift shiftr keycode 35 = asterisk
+	control keycode 35 = Delete
+	alt keycode 35 = Meta_eight
+keycode 36 = i
+	shiftr keycode 36 = +I
+	shift shiftr keycode 36 = +i
+keycode 37 = k
+	shiftr keycode 37 = +K
+	shift shiftr keycode 37 = +k
+keycode 38 = comma less
+	shiftr keycode 38 = less
+	shift shiftr keycode 38 = less
+	alt keycode 38 = Meta_comma
+
+keycode 40 = h
+	shiftr keycode 40 = +H
+	shift shiftr keycode 40 = +h
+keycode 41 = y
+	shiftr keycode 41 = +Y
+	shift shiftr keycode 41 = +y
+keycode 42 = six asciicircum
+	shiftr keycode 42 = asciicircum
+	shift shiftr keycode 42 = asciicircum
+	control keycode 42 = Control_asciicircum
+	alt keycode 42 = Meta_six
+keycode 43 = seven ampersand braceleft
+	shiftr keycode 43 = ampersand
+	shift shiftr keycode 43 = ampersand
+	control keycode 43 = Control_underscore
+	alt keycode 43 = Meta_seven
+keycode 44 = u
+	shiftr keycode 44 = +U
+	shift shiftr keycode 44 = +u
+keycode 45 = j
+	shiftr keycode 45 = +J
+	shift shiftr keycode 45 = +j
+keycode 46 = m
+	shiftr keycode 46 = +M
+	shift shiftr keycode 46 = +m
+keycode 47 = n
+	shiftr keycode 47 = +N
+	shift shiftr keycode 47 = +n
+
+# This is the "Backspace" key:
+keycode 49 = Delete Delete
+	shiftr keycode 49 = Delete
+	shift shiftr keycode 49 = Delete
+	control keycode 49 = BackSpace
+	alt keycode 49 = Meta_Delete
+keycode 50 = Num_Lock
+	shift keycode 50 = Bare_Num_Lock
+	shiftr keycode 50 = Bare_Num_Lock
+	shift shiftr keycode 50 = Bare_Num_Lock
+# This is the "Delete" key:
+keycode 51 = Remove
+	control alt keycode 51 = Boot
+
+keycode 53 = backslash bar
+	shiftr keycode 53 = bar
+	shift shiftr keycode 53 = bar
+	control keycode 53 = Control_backslash
+	alt keycode 53 = Meta_backslash
+keycode 54 = Return
+	alt keycode 54 = Meta_Control_m
+keycode 55 = space space           
+	shiftr keycode 55 = space
+	shift shiftr keycode 55 = space
+	control keycode 55 = nul
+	alt keycode 55 = Meta_space
+keycode 56 = g
+	shiftr keycode 56 = +G
+	shift shiftr keycode 56 = +g
+keycode 57 = t
+	shiftr keycode 57 = +T
+	shift shiftr keycode 57 = +t
+keycode 58 = five percent
+	shiftr keycode 58 = percent
+	shift shiftr keycode 58 = percent
+	control keycode 58 = Control_bracketright
+	alt keycode 58 = Meta_five
+keycode 59 = four dollar dollar
+	shiftr keycode 59 = dollar
+	shift shiftr keycode 59 = dollar
+	control keycode 59 = Control_backslash
+	alt keycode 59 = Meta_four
+keycode 60 = r
+	shiftr keycode 60 = +R
+	shift shiftr keycode 60 = +r
+keycode 61 = f
+	shiftr keycode 61 = +F
+	shift shiftr keycode 61 = +f
+	altgr keycode 61 = Hex_F
+keycode 62 = v
+	shiftr keycode 62 = +V
+	shift shiftr keycode 62 = +v
+keycode 63 = b
+	shiftr keycode 63 = +B
+	shift shiftr keycode 63 = +b
+	altgr keycode 63 = Hex_B
+
+keycode 67 = three numbersign
+	shiftr keycode 67 = numbersign
+	shift shiftr keycode 67 = numbersign
+	control keycode 67 = Escape
+	alt keycode 67 = Meta_three
+keycode 68 = e
+	shiftr keycode 68 = +E
+	shift shiftr keycode 68 = +e
+	altgr keycode 68 = Hex_E
+keycode 69 = d
+	shiftr keycode 69 = +D
+	shift shiftr keycode 69 = +d
+	altgr keycode 69 = Hex_D
+keycode 70 = c
+	shiftr keycode 70 = +C
+	shift shiftr keycode 70 = +c
+	altgr keycode 70 = Hex_C
+keycode 71 = Right Incr_Console
+	shiftr keycode 71 = Incr_Console
+	shift shiftr keycode 71 = Incr_Console
+	alt keycode 71 = End
+
+keycode 75 = two at at
+	shiftr keycode 75 = at
+	shift shiftr keycode 75 = at
+	control keycode 75 = nul
+	shift control keycode 75 = nul
+	shiftr control keycode 75 = nul
+	shift shiftr control keycode 75 = nul
+	alt keycode 75 = Meta_two
+keycode 76 = w
+	shiftr keycode 76 = +W
+	shift shiftr keycode 76 = +w
+keycode 77 = s
+	shiftr keycode 77 = +S
+	shift shiftr keycode 77 = +s
+keycode 78 = x
+	shiftr keycode 78 = +X
+	shift shiftr keycode 78 = +x
+keycode 79 = Down Scroll_Forward
+	shiftr keycode 79 = Scroll_Forward
+	shift shiftr keycode 79 = Scroll_Forward
+	alt keycode 79 = Next
+keycode 80 = Escape Escape
+	shiftr keycode 80 = Escape
+	shift shiftr keycode 80 = Escape
+	alt keycode 80 = Meta_Escape
+keycode 81 = Tab Tab             
+	shiftr keycode 81 = Tab
+	shift shiftr keycode 81 = Tab
+	alt keycode 81 = Meta_Tab
+keycode 82 = grave asciitilde
+	shiftr keycode 82 = asciitilde
+	shift shiftr keycode 82 = asciitilde
+	control keycode 82 = nul
+	alt keycode 82 = Meta_grave
+keycode 83 = one exclam
+	shiftr keycode 83 = exclam
+	shift shiftr keycode 83 = exclam
+	alt keycode 83 = Meta_one
+keycode 84 = q
+	shiftr keycode 84 = +Q
+	shift shiftr keycode 84 = +q
+keycode 85 = a
+	shiftr keycode 85 = +A
+	shift shiftr keycode 85 = +a
+	altgr keycode 85 = Hex_A
+keycode 86 = z
+	shiftr keycode 86 = +Z
+	shift shiftr keycode 86 = +z
+
+# This is the windows key:
+keycode 88 = Decr_Console
+keycode 89 = Shift
+keycode 90 = Control
+keycode 91 = Control
+keycode 92 = Alt
+keycode 93 = AltGr
+keycode 94 = ShiftR
+	shift keycode 94 = Caps_Lock
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/indydog.c linux-mips-cvs-20040815/drivers/char/indydog.c
--- linux-2.4.27/drivers/char/indydog.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/indydog.c	2004-08-15 08:06:08.000000000 +0200
@@ -1,5 +1,5 @@
 /*
- *	IndyDog	0.2	A Hardware Watchdog Device for SGI IP22
+ *	IndyDog	0.3	A Hardware Watchdog Device for SGI IP22
  *
  *	(c) Copyright 2002 Guido Guenther <agx@sigxcpu.org>, All Rights Reserved.
  *
@@ -7,10 +7,10 @@
  *	modify it under the terms of the GNU General Public License
  *	as published by the Free Software Foundation; either version
  *	2 of the License, or (at your option) any later version.
- *	
+ *
  *	based on softdog.c by Alan Cox <alan@redhat.com>
  */
- 
+
 #include <linux/module.h>
 #include <linux/config.h>
 #include <linux/types.h>
@@ -19,13 +19,12 @@
 #include <linux/mm.h>
 #include <linux/miscdevice.h>
 #include <linux/watchdog.h>
-#include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <asm/uaccess.h>
 #include <asm/sgi/mc.h>
 
-static unsigned long indydog_alive;
-static int expect_close = 0;
+#define PFX "indydog: "
+static int indydog_alive;
 
 #ifdef CONFIG_WATCHDOG_NOWAYOUT
 static int nowayout = 1;
@@ -33,10 +32,30 @@ static int nowayout = 1;
 static int nowayout = 0;
 #endif
 
+#define WATCHDOG_TIMEOUT 30		/* 30 sec default timeout */
+
 MODULE_PARM(nowayout,"i");
 MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=CONFIG_WATCHDOG_NOWAYOUT)");
 
-static inline void indydog_ping(void)
+static void indydog_start(void)
+{
+	u32 mc_ctrl0 = sgimc->cpuctrl0;
+
+	mc_ctrl0 = sgimc->cpuctrl0 | SGIMC_CCTRL0_WDOG;
+	sgimc->cpuctrl0 = mc_ctrl0;
+}
+
+static void indydog_stop(void)
+{
+	u32 mc_ctrl0 = sgimc->cpuctrl0;
+
+	mc_ctrl0 &= ~SGIMC_CCTRL0_WDOG;
+	sgimc->cpuctrl0 = mc_ctrl0;
+
+	printk(KERN_INFO PFX "Stopped watchdog timer.\n");
+}
+
+static void indydog_ping(void)
 {
 	sgimc->watchdogt = 0;
 }
@@ -46,18 +65,14 @@ static inline void indydog_ping(void)
  */
 static int indydog_open(struct inode *inode, struct file *file)
 {
-	u32 mc_ctrl0;
-	
-	if (test_and_set_bit(0,&indydog_alive))
+	if (indydog_alive)
 		return -EBUSY;
 
-	if (nowayout) {
+	if (nowayout)
 		MOD_INC_USE_COUNT;
-	}
 
 	/* Activate timer */
-	mc_ctrl0 = sgimc->cpuctrl0 | SGIMC_CCTRL0_WDOG;
-	sgimc->cpuctrl0 = mc_ctrl0;
+	indydog_start();
 	indydog_ping();
 			
 	indydog_alive = 1;
@@ -69,63 +84,48 @@ static int indydog_open(struct inode *in
 static int indydog_release(struct inode *inode, struct file *file)
 {
 	/* Shut off the timer.
-	 * Lock it in if it's a module and we set nowayout. */
-	lock_kernel();
-	if (expect_close) {
-		u32 mc_ctrl0 = sgimc->cpuctrl0;
+	 * Lock it in if it's a module and we defined ...NOWAYOUT */
+	if (!nowayout) {
+		u32 mc_ctrl0 = sgimc->cpuctrl0; 
 		mc_ctrl0 &= ~SGIMC_CCTRL0_WDOG;
 		sgimc->cpuctrl0 = mc_ctrl0;
 		printk(KERN_INFO "Stopped watchdog timer.\n");
-	} else
-		printk(KERN_CRIT "WDT device closed unexpectedly.  WDT will not stop!\n");
-	clear_bit(0, &indydog_alive);
-	unlock_kernel();
+	}
+	indydog_alive = 0;
 
 	return 0;
 }
 
 static ssize_t indydog_write(struct file *file, const char *data, size_t len, loff_t *ppos)
 {
-	/*  Can't seek (pwrite) on this device  */
+	/* Can't seek (pwrite) on this device */
 	if (ppos != &file->f_pos)
 		return -ESPIPE;
 
-	/*
-	 *	Refresh the timer.
-	 */
+	/* Refresh the timer. */
 	if (len) {
-		if (!nowayout) {
-			size_t i;
-
-			/* In case it was set long ago */
-			expect_close = 0;
- 
-			for (i = 0; i != len; i++) {
-				char c;
-				if (get_user(c, data + i))
-					return -EFAULT;
-				if (c == 'V')
-					expect_close = 1;
-			}
-		}
 		indydog_ping();
-		return 1;
 	}
-	return 0;
+	return len;
 }
 
 static int indydog_ioctl(struct inode *inode, struct file *file,
 	unsigned int cmd, unsigned long arg)
 {
+	int options, retval = -EINVAL;
 	static struct watchdog_info ident = {
-		options: WDIOF_MAGICCLOSE,
-		identity: "Hardware Watchdog for SGI IP22",
+		.options		= WDIOF_KEEPALIVEPING |
+					  WDIOF_MAGICCLOSE,
+		.firmware_version	= 0,
+		.identity		= "Hardware Watchdog for SGI IP22",
 	};
+
 	switch (cmd) {
 		default:
 			return -ENOIOCTLCMD;
 		case WDIOC_GETSUPPORT:
-			if(copy_to_user((struct watchdog_info *)arg, &ident, sizeof(ident)))
+			if (copy_to_user((struct watchdog_info *)arg,
+					 &ident, sizeof(ident)))
 				return -EFAULT;
 			return 0;
 		case WDIOC_GETSTATUS:
@@ -134,31 +134,53 @@ static int indydog_ioctl(struct inode *i
 		case WDIOC_KEEPALIVE:
 			indydog_ping();
 			return 0;
+		case WDIOC_GETTIMEOUT:
+			return put_user(WATCHDOG_TIMEOUT,(int *)arg);
+		case WDIOC_SETOPTIONS:
+		{
+			if (get_user(options, (int *)arg))
+				return -EFAULT;
+
+			if (options & WDIOS_DISABLECARD) {
+				indydog_stop();
+				retval = 0;
+			}
+
+			if (options & WDIOS_ENABLECARD) {
+				indydog_start();
+				retval = 0;
+			}
+
+			return retval;
+		}
 	}
 }
 
 static struct file_operations indydog_fops = {
-	owner:		THIS_MODULE,
-	write:		indydog_write,
-	ioctl:		indydog_ioctl,
-	open:		indydog_open,
-	release:	indydog_release,
+	.owner		= THIS_MODULE,
+	.write		= indydog_write,
+	.ioctl		= indydog_ioctl,
+	.open		= indydog_open,
+	.release	= indydog_release,
 };
 
 static struct miscdevice indydog_miscdev = {
-	minor:		WATCHDOG_MINOR,
-	name:		"watchdog",
-	fops:		&indydog_fops,
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &indydog_fops,
 };
 
-static const char banner[] __initdata = KERN_INFO "Hardware Watchdog Timer for SGI IP22: 0.2\n";
+static char banner[] __initdata =
+	KERN_INFO PFX "Hardware Watchdog Timer for SGI IP22: 0.3\n";
 
 static int __init watchdog_init(void)
 {
 	int ret = misc_register(&indydog_miscdev);
-
-	if (ret)
+	if (ret) {
+		printk(KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, ret);
 		return ret;
+	}
 
 	printk(banner);
 
@@ -172,4 +194,7 @@ static void __exit watchdog_exit(void)
 
 module_init(watchdog_init);
 module_exit(watchdog_exit);
+
+MODULE_AUTHOR("Guido Guenther <agx@sigxcpu.org>");
+MODULE_DESCRIPTION("Hardware Watchdog Device for SGI IP22");
 MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/ip27-rtc.c linux-mips-cvs-20040815/drivers/char/ip27-rtc.c
--- linux-2.4.27/drivers/char/ip27-rtc.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/ip27-rtc.c	2004-05-02 00:47:57.000000000 +0200
@@ -44,6 +44,7 @@
 #include <asm/sn/klconfig.h>
 #include <asm/sn/sn0/ip27.h>
 #include <asm/sn/sn0/hub.h>
+#include <asm/sn/sn_private.h>
 
 static int rtc_ioctl(struct inode *inode, struct file *file,
 		     unsigned int cmd, unsigned long arg);
@@ -209,11 +210,8 @@ static struct miscdevice rtc_dev=
 
 static int __init rtc_init(void)
 {
-	nasid_t nid;
-
-	nid = get_nasid();
 	rtc = (struct m48t35_rtc *)
-	    (KL_CONFIG_CH_CONS_INFO(nid)->memory_base + IOC3_BYTEBUS_DEV0);
+	(KL_CONFIG_CH_CONS_INFO(master_nasid)->memory_base + IOC3_BYTEBUS_DEV0);
 
 	printk(KERN_INFO "Real Time Clock Driver v%s\n", RTC_VERSION);
 	if (misc_register(&rtc_dev)) {
@@ -325,3 +323,7 @@ static void get_rtc_time(struct rtc_time
 
 	rtc_tm->tm_mon--;
 }
+
+MODULE_AUTHOR("Ralf Baechle <ralf@linux-mips.org>");
+MODULE_DESCRIPTION("SGI IP27 M48T35 RTC driver");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/ite_gpio.c linux-mips-cvs-20040815/drivers/char/ite_gpio.c
--- linux-2.4.27/drivers/char/ite_gpio.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/ite_gpio.c	2003-12-20 14:18:51.000000000 +0100
@@ -236,10 +236,6 @@ EXPORT_SYMBOL(ite_gpio_int_wait);
 
 static int ite_gpio_open(struct inode *inode, struct file *file)
 {
-	unsigned int minor = MINOR(inode->i_rdev); 
-	if (minor != GPIO_MINOR)
-		return -ENODEV;
-
 #ifdef MODULE
 	MOD_INC_USE_COUNT;
 #endif
@@ -250,7 +246,6 @@ static int ite_gpio_open(struct inode *i
 
 static int ite_gpio_release(struct inode *inode, struct file *file)
 {
-
 #ifdef MODULE
 	MOD_DEC_USE_COUNT;
 #endif
@@ -262,7 +257,6 @@ static int ite_gpio_release(struct inode
 static int ite_gpio_ioctl(struct inode *inode, struct file *file,
 	unsigned int cmd, unsigned long arg)
 {
-
 	static struct ite_gpio_ioctl_data ioctl_data;
 
 	if (copy_from_user(&ioctl_data, (struct ite_gpio_ioctl_data *)arg,
@@ -324,7 +318,8 @@ static int ite_gpio_ioctl(struct inode *
 	return 0;
 }
 
-static void ite_gpio_irq_handler(int this_irq, void *dev_id, struct pt_regs *regs)
+static void ite_gpio_irq_handler(int this_irq, void *dev_id,
+	struct pt_regs *regs)
 {
 	int i,line;
 
@@ -369,23 +364,20 @@ DEB(printk("interrupt 0x%x %d\n",ITE_GPA
 	}
 }
 
-static struct file_operations ite_gpio_fops =
-{
+static struct file_operations ite_gpio_fops = {
 	owner:		THIS_MODULE,
 	ioctl:		ite_gpio_ioctl,
 	open:		ite_gpio_open,
 	release:	ite_gpio_release,
 };
 
-/* GPIO_MINOR in include/linux/miscdevice.h */
-static struct miscdevice ite_gpio_miscdev =
-{
-	GPIO_MINOR,
+static struct miscdevice ite_gpio_miscdev = {
+	MISC_DYNAMIC_MINOR,
 	"ite_gpio",
 	&ite_gpio_fops
 };
 
-int __init ite_gpio_init(void)
+static int __init ite_gpio_init(void)
 {
 	int i;
 
@@ -417,7 +409,7 @@ int __init ite_gpio_init(void)
 	return 0;
 }	
 
-void __exit ite_gpio_exit(void)
+static void __exit ite_gpio_exit(void)
 {
 	misc_deregister(&ite_gpio_miscdev);
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/lcd.c linux-mips-cvs-20040815/drivers/char/lcd.c
--- linux-2.4.27/drivers/char/lcd.c	2003-08-25 13:44:41.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/char/lcd.c	2003-12-20 14:18:51.000000000 +0100
@@ -556,9 +556,8 @@ static struct file_operations lcd_fops =
 	open:		lcd_open,
 };
 
-static struct miscdevice lcd_dev=
-{
-	LCD_MINOR,
+static struct miscdevice lcd_dev = {
+	MISC_DYNAMIC_MINOR,
 	"lcd",
 	&lcd_fops
 };
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/mips_rtc.c linux-mips-cvs-20040815/drivers/char/mips_rtc.c
--- linux-2.4.27/drivers/char/mips_rtc.c	2004-01-05 14:53:56.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/mips_rtc.c	2004-08-15 08:06:08.000000000 +0200
@@ -53,14 +53,6 @@
 #include <asm/io.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
-
-/*
- * Check machine
- */
-#if !defined(CONFIG_MIPS) || !defined(CONFIG_NEW_TIME_C)
-#error "This driver is for MIPS machines with CONFIG_NEW_TIME_C defined"
-#endif
-
 #include <asm/time.h>
 
 static unsigned long rtc_status = 0;	/* bitmapped status byte.       */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/sb1250_duart.c linux-mips-cvs-20040815/drivers/char/sb1250_duart.c
--- linux-2.4.27/drivers/char/sb1250_duart.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/sb1250_duart.c	2004-08-15 08:06:08.000000000 +0200
@@ -498,9 +498,31 @@ static void duart_set_termios(struct tty
 	duart_set_cflag(us->line, tty->termios->c_cflag);
 }
 
+static int get_serial_info(uart_state_t *us, struct serial_struct * retinfo) {
+
+	struct serial_struct tmp;
+
+	memset(&tmp, 0, sizeof(tmp));
+
+	tmp.type=PORT_SB1250;
+	tmp.line=us->line;
+	tmp.port=A_DUART_CHANREG(tmp.line,0);
+	tmp.irq=K_INT_UART_0 + tmp.line;
+	tmp.xmit_fifo_size=16; /* fixed by hw */
+	tmp.baud_base=5000000;
+	tmp.io_type=SERIAL_IO_MEM;
+
+	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+		return -EFAULT;
+
+	return 0;
+}
+
 static int duart_ioctl(struct tty_struct *tty, struct file * file,
 		       unsigned int cmd, unsigned long arg)
 {
+	uart_state_t *us = (uart_state_t *) tty->driver_data;
+
 /*	if (serial_paranoia_check(info, tty->device, "rs_ioctl"))
 	return -ENODEV;*/
 	switch (cmd) {
@@ -517,7 +539,7 @@ static int duart_ioctl(struct tty_struct
 		printk("Ignoring TIOCMSET\n");
 		break;
 	case TIOCGSERIAL:
-		printk("Ignoring TIOCGSERIAL\n");
+		return get_serial_info(us,(struct serial_struct *) arg);
 		break;
 	case TIOCSSERIAL:
 		printk("Ignoring TIOCSSERIAL\n");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/serial.c linux-mips-cvs-20040815/drivers/char/serial.c
--- linux-2.4.27/drivers/char/serial.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/serial.c	2003-12-15 19:19:50.000000000 +0100
@@ -62,6 +62,12 @@
  *        Robert Schwebel <robert@schwebel.de>,
  *        Juergen Beisert <jbeisert@eurodsn.de>,
  *        Theodore Ts'o <tytso@mit.edu>
+ *
+ * 10/00: Added suport for MIPS Atlas board.
+ * 11/00: Hooks for serial kernel debug port support added.
+ *        Kevin D. Kissell, kevink@mips.com and Carsten Langgaard,
+ *        carstenl@mips.com
+ *        Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
  */
 
 static char *serial_version = "5.05c";
@@ -413,6 +419,22 @@ static inline int serial_paranoia_check(
 	return 0;
 }
 
+#if defined(CONFIG_MIPS_ATLAS) || defined(CONFIG_MIPS_SEAD)
+
+#include <asm/mips-boards/atlas.h>
+
+static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
+{
+        return (*(volatile unsigned int *)(mips_io_port_base + ATLAS_UART_REGS_BASE + offset*8) & 0xff);
+}
+
+static _INLINE_ void serial_out(struct async_struct *info, int offset, int value)
+{
+        *(volatile unsigned int *)(mips_io_port_base + ATLAS_UART_REGS_BASE + offset*8) = value;
+}
+
+#else
+
 static _INLINE_ unsigned int serial_in(struct async_struct *info, int offset)
 {
 	switch (info->io_type) {
@@ -447,6 +469,8 @@ static _INLINE_ void serial_out(struct a
 		outb(value, info->port+offset);
 	}
 }
+#endif
+
 
 /*
  * We used to support using pause I/O for certain machines.  We
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/victor_mpc30x_keymap.map linux-mips-cvs-20040815/drivers/char/victor_mpc30x_keymap.map
--- linux-2.4.27/drivers/char/victor_mpc30x_keymap.map	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/victor_mpc30x_keymap.map	2004-02-05 18:04:42.000000000 +0100
@@ -0,0 +1,102 @@
+# Victor Interlink MP-C303/304 keyboard keymap
+#
+# Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+keymaps 0-1,4-5,8-9,12
+alt_is_meta
+strings as usual
+compose as usual for "iso-8859-1"
+
+# First line
+keycode 89 = Escape
+keycode  9 = Delete
+
+# 2nd line
+keycode 73 = one              exclam
+keycode 18 = two              quotedbl
+keycode 92 = three            numbersign
+	control	keycode 92 = Escape
+keycode 53 = four             dollar
+	control	keycode 53 = Control_backslash
+keycode 21 = five             percent
+	control	keycode 21 = Control_bracketright
+keycode 50 = six              ampersand
+	control	keycode 50 = Control_underscore
+keycode 48 = seven            apostrophe
+keycode 51 = eight            parenleft
+keycode 16 = nine             parenright
+keycode 80 = zero             asciitilde
+	control	keycode 80 = nul
+keycode 49 = minus            equal
+keycode 30 = asciicircum      asciitilde
+	control	keycode 30 = Control_asciicircum
+keycode  5 = backslash        bar
+	control	keycode  5 = Control_backslash
+keycode 13 = BackSpace
+# 3rd line
+keycode 57 = Tab
+keycode 74 = q
+keycode 26 = w
+keycode 81 = e
+keycode 29 = r
+keycode 37 = t
+keycode 45 = y
+keycode 72 = u
+keycode 24 = i
+keycode 32 = o
+keycode 41 = p
+keycode  1 = at               grave
+	control	keycode  1 = nul
+keycode 54 = bracketleft      braceleft
+keycode 63 = Return
+	alt	keycode 63 = Meta_Control_m
+# 4th line
+keycode 23 = Caps_Lock
+keycode 34 = a
+keycode 66 = s
+keycode 52 = d
+keycode 20 = f
+keycode 84 = g
+keycode 67 = h
+keycode 64 = j
+keycode 17 = k
+keycode 83 = l
+keycode 22 = semicolon        plus
+keycode 61 = colon            asterisk
+	control keycode 61 = Control_g
+keycode 65 = bracketright     braceright
+	control	keycode 65 = Control_bracketright
+# 5th line
+keycode 91 = Shift
+keycode 76 = z
+keycode 68 = x
+keycode 28 = c
+keycode 36 = v
+keycode 44 = b
+keycode 19 = n
+keycode 27 = m
+keycode 35 = comma            less
+keycode  3 = period           greater
+	control	keycode  3 = Compose
+keycode 38 = slash            question
+	control	keycode 38 = Delete
+	shift	control	keycode 38 = Delete
+keycode  6 = backslash        underscore
+	control	keycode  6 = Control_backslash
+keycode 55 = Up
+	alt keycode 55 = PageUp
+keycode 14 = Shift
+# 6th line
+keycode 56 = Control
+keycode 42 = Alt
+keycode 33 = space
+	control	keycode 33 = nul
+keycode  7 = Left
+	alt keycode  7 = Home
+keycode 31 = Down
+	alt keycode 31 = PageDown
+keycode 47 = Right
+	alt keycode 47 = End
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/char/vr41xx_keyb.c linux-mips-cvs-20040815/drivers/char/vr41xx_keyb.c
--- linux-2.4.27/drivers/char/vr41xx_keyb.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/char/vr41xx_keyb.c	2004-02-17 13:08:55.000000000 +0100
@@ -308,7 +308,7 @@ void __devinit kbd_init_hw(void)
 			if (found != 0) {
 				kiu_base = VRC4173_KIU_OFFSET;
 				mkiuintreg = VRC4173_MKIUINTREG_OFFSET;
-				vrc4173_clock_supply(VRC4173_KIU_CLOCK);
+				vrc4173_supply_clock(VRC4173_KIU_CLOCK);
 			}
 		}
 #endif
@@ -325,7 +325,7 @@ void __devinit kbd_init_hw(void)
 
 	if (current_cpu_data.cputype == CPU_VR4111 ||
 	    current_cpu_data.cputype == CPU_VR4121)
-		vr41xx_clock_supply(KIU_CLOCK);
+		vr41xx_supply_clock(KIU_CLOCK);
 
 	kiu_writew(KIURST_KIURST, KIURST);
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/i2c/Config.in linux-mips-cvs-20040815/drivers/i2c/Config.in
--- linux-2.4.27/drivers/i2c/Config.in	2004-04-14 15:05:29.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/i2c/Config.in	2004-08-15 08:06:11.000000000 +0200
@@ -57,6 +57,10 @@ if [ "$CONFIG_I2C" != "n" ]; then
    if [ "$CONFIG_SGI_IP22" = "y" ]; then
       dep_tristate 'I2C SGI interfaces' CONFIG_I2C_ALGO_SGI $CONFIG_I2C
    fi
+
+   if [ "$CONFIG_SOC_AU1550" = "y" ]; then
+      dep_tristate 'Au1550 SMBus interface' CONFIG_I2C_ALGO_AU1550 $CONFIG_I2C
+   fi
  
 # This is needed for automatic patch generation: sensors code starts here
 # This is needed for automatic patch generation: sensors code ends here
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/i2c/Makefile linux-mips-cvs-20040815/drivers/i2c/Makefile
--- linux-2.4.27/drivers/i2c/Makefile	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/i2c/Makefile	2004-08-15 08:06:11.000000000 +0200
@@ -6,7 +6,7 @@ O_TARGET := i2c.o
 
 export-objs	:= i2c-core.o i2c-algo-bit.o i2c-algo-pcf.o \
 		   i2c-algo-ite.o i2c-algo-sibyte.o i2c-algo-sgi.o \
-		   i2c-proc.o
+		   i2c-algo-au1550.o i2c-proc.o
 
 obj-$(CONFIG_I2C)		+= i2c-core.o
 obj-$(CONFIG_I2C_CHARDEV)	+= i2c-dev.o
@@ -25,6 +25,7 @@ obj-$(CONFIG_I2C_KEYWEST)	+= i2c-keywest
 obj-$(CONFIG_I2C_ALGO_SIBYTE)	+= i2c-algo-sibyte.o i2c-sibyte.o
 obj-$(CONFIG_I2C_MAX1617)	+= i2c-max1617.o
 obj-$(CONFIG_I2C_ALGO_SGI)	+= i2c-algo-sgi.o
+obj-$(CONFIG_I2C_ALGO_AU1550)	+= i2c-algo-au1550.o i2c-au1550.o
 
 # This is needed for automatic patch generation: sensors code starts here
 # This is needed for automatic patch generation: sensors code ends here
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/i2c/i2c-algo-au1550.c linux-mips-cvs-20040815/drivers/i2c/i2c-algo-au1550.c
--- linux-2.4.27/drivers/i2c/i2c-algo-au1550.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/i2c/i2c-algo-au1550.c	2004-07-07 02:38:02.000000000 +0200
@@ -0,0 +1,340 @@
+/*
+ * i2c-algo-au1550.c: SMBus (i2c) driver algorithms for Alchemy PSC interface
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ * The documentation describes this as an SMBus controller, but it doesn't
+ * understand any of the SMBus protocol in hardware.  It's really an I2C
+ * controller that could emulate most of the SMBus in software.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <asm/au1000.h>
+#include <asm/au1xxx_psc.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-au1550.h>
+
+static int
+wait_xfer_done(struct i2c_algo_au1550_data *adap)
+{
+	u32	stat;
+	int	i;
+	volatile psc_smb_t	*sp;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Wait for Tx FIFO Underflow.
+	*/
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		stat = sp->psc_smbevnt;
+		au_sync();
+		if ((stat & PSC_SMBEVNT_TU) != 0) {
+			/* Clear it.  */
+			sp->psc_smbevnt = PSC_SMBEVNT_TU;
+			au_sync();
+			return 0;
+		}
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int
+wait_ack(struct i2c_algo_au1550_data *adap)
+{
+	u32	stat;
+	volatile psc_smb_t	*sp;
+
+	if (wait_xfer_done(adap))
+		return -ETIMEDOUT;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	stat = sp->psc_smbevnt;
+	au_sync();
+
+	if ((stat & (PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | PSC_SMBEVNT_AL)) != 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int
+wait_master_done(struct i2c_algo_au1550_data *adap)
+{
+	u32	stat;
+	int	i;
+	volatile psc_smb_t	*sp;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Wait for Master Done.
+	*/
+	for (i = 0; i < adap->xfer_timeout; i++) {
+		stat = sp->psc_smbevnt;
+		au_sync();
+		if ((stat & PSC_SMBEVNT_MD) != 0)
+			return 0;
+		udelay(1);
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int
+do_address(struct i2c_algo_au1550_data *adap, unsigned int addr, int rd)
+{
+	volatile psc_smb_t	*sp;
+	u32			stat;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	/* Reset the FIFOs, clear events.
+	*/
+	sp->psc_smbpcr = PSC_SMBPCR_DC;
+	sp->psc_smbevnt = PSC_SMBEVNT_ALLCLR;
+	au_sync();
+	do {
+		stat = sp->psc_smbpcr;
+		au_sync();
+	} while ((stat & PSC_SMBPCR_DC) != 0);
+
+	/* Write out the i2c chip address and specify operation
+	*/
+	addr <<= 1;
+	if (rd)
+		addr |= 1;
+
+	/* Put byte into fifo, start up master.
+	*/
+	sp->psc_smbtxrx = addr;
+	au_sync();
+	sp->psc_smbpcr = PSC_SMBPCR_MS;
+	au_sync();
+	if (wait_ack(adap))
+		return -EIO;
+	return 0;
+}
+
+static u32
+wait_for_rx_byte(struct i2c_algo_au1550_data *adap, u32 *ret_data)
+{
+	int	j;
+	u32	data, stat;
+	volatile psc_smb_t	*sp;
+
+	if (wait_xfer_done(adap))
+		return -EIO;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	j =  adap->xfer_timeout * 100;
+	do {
+		j--;
+		if (j <= 0)
+			return -EIO;
+
+		stat = sp->psc_smbstat;
+		au_sync();
+		if ((stat & PSC_SMBSTAT_RE) == 0)
+			j = 0;
+		else
+			udelay(1);
+	} while (j > 0);
+	data = sp->psc_smbtxrx;
+	au_sync();
+	*ret_data = data;
+
+	return 0;
+}
+
+static int
+i2c_read(struct i2c_algo_au1550_data *adap, unsigned char *buf,
+		    unsigned int len)
+{
+	int	i;
+	u32	data;
+	volatile psc_smb_t	*sp;
+
+	if (len == 0)
+		return 0;
+
+	/* A read is performed by stuffing the transmit fifo with
+	 * zero bytes for timing, waiting for bytes to appear in the
+	 * receive fifo, then reading the bytes.
+	 */
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	i = 0;
+	while (i < (len-1)) {
+		sp->psc_smbtxrx = 0;
+		au_sync();
+		if (wait_for_rx_byte(adap, &data))
+			return -EIO;
+
+		buf[i] = data;
+		i++;
+	}
+
+	/* The last byte has to indicate transfer done.
+	*/
+	sp->psc_smbtxrx = PSC_SMBTXRX_STP;
+	au_sync();
+	if (wait_master_done(adap))
+		return -EIO;
+
+	data = sp->psc_smbtxrx;
+	au_sync();
+	buf[i] = data;
+	return 0;
+}
+
+static int
+i2c_write(struct i2c_algo_au1550_data *adap, unsigned char *buf,
+		     unsigned int len)
+{
+	int	i;
+	u32	data;
+	volatile psc_smb_t	*sp;
+
+	if (len == 0)
+		return 0;
+
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+
+	i = 0;
+	while (i < (len-1)) {
+		data = buf[i];
+		sp->psc_smbtxrx = data;
+		au_sync();
+		if (wait_ack(adap))
+			return -EIO;
+		i++;
+	}
+
+	/* The last byte has to indicate transfer done.
+	*/
+	data = buf[i];
+	data |= PSC_SMBTXRX_STP;
+	sp->psc_smbtxrx = data;
+	au_sync();
+	if (wait_master_done(adap))
+		return -EIO;
+	return 0;
+}
+
+static int
+au1550_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_algo_au1550_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *p;
+	int i, err = 0;
+
+	for (i = 0; !err && i < num; i++) {
+		p = &msgs[i];
+		err = do_address(adap, p->addr, p->flags & I2C_M_RD);
+		if (err || !p->len)
+			continue;
+		if (p->flags & I2C_M_RD)
+			err = i2c_read(adap, p->buf, p->len);
+		else
+			err = i2c_write(adap, p->buf, p->len);
+	}
+
+	/* Return the number of messages processed, or the error code.
+	*/
+	if (err == 0)
+		err = num;
+	return err;
+}
+
+static u32
+au1550_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm au1550_algo = {
+	.name		= "Au1550 algorithm",
+	.id		= I2C_ALGO_AU1550,
+	.master_xfer	= au1550_xfer,
+	.functionality	= au1550_func,
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ * Prior to calling us, the 50MHz clock frequency and routing
+ * must have been set up for the PSC indicated by the adapter.
+ */
+int
+i2c_au1550_add_bus(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_au1550_data *adap = i2c_adap->algo_data;
+	volatile psc_smb_t	*sp;
+	u32	stat;
+
+	i2c_adap->algo = &au1550_algo;
+
+	/* Now, set up the PSC for SMBus PIO mode.
+	*/
+	sp = (volatile psc_smb_t *)(adap->psc_base);
+	sp->psc_ctrl = PSC_CTRL_DISABLE;
+	au_sync();
+	sp->psc_sel = PSC_SEL_PS_SMBUSMODE;
+	sp->psc_smbcfg = 0;
+	au_sync();
+	sp->psc_ctrl = PSC_CTRL_ENABLE;
+	au_sync();
+	do {
+		stat = sp->psc_smbstat;
+		au_sync();
+	} while ((stat & PSC_SMBSTAT_SR) == 0);
+
+	sp->psc_smbcfg = (PSC_SMBCFG_RT_FIFO8 | PSC_SMBCFG_TT_FIFO8 |
+				PSC_SMBCFG_DD_DISABLE);
+
+	/* Divide by 8 to get a 6.25 MHz clock.  The later protocol
+	 * timings are based on this clock.
+	 */
+	sp->psc_smbcfg |= PSC_SMBCFG_SET_DIV(PSC_SMBCFG_DIV8);
+	sp->psc_smbmsk = PSC_SMBMSK_ALLMASK;
+	au_sync();
+
+	/* Set the protocol timer values.  See Table 71 in the
+	 * Au1550 Data Book for standard timing values.
+	 */
+	sp->psc_smbtmr = PSC_SMBTMR_SET_TH(0) | PSC_SMBTMR_SET_PS(15) | \
+		PSC_SMBTMR_SET_PU(15) | PSC_SMBTMR_SET_SH(15) | \
+		PSC_SMBTMR_SET_SU(15) | PSC_SMBTMR_SET_CL(15) | \
+		PSC_SMBTMR_SET_CH(15);
+	au_sync();
+
+	sp->psc_smbcfg |= PSC_SMBCFG_DE_ENABLE;
+	do {
+		stat = sp->psc_smbstat;
+		au_sync();
+	} while ((stat & PSC_SMBSTAT_DR) == 0);
+
+	return i2c_add_adapter(i2c_adap);
+}
+
+
+int
+i2c_au1550_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+EXPORT_SYMBOL(i2c_au1550_add_bus);
+EXPORT_SYMBOL(i2c_au1550_del_bus);
+
+MODULE_AUTHOR("Dan Malek <dan@embeddededge.com>");
+MODULE_DESCRIPTION("SMBus Au1550 algorithm");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/i2c/i2c-au1550.c linux-mips-cvs-20040815/drivers/i2c/i2c-au1550.c
--- linux-2.4.27/drivers/i2c/i2c-au1550.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/i2c/i2c-au1550.c	2004-07-07 02:38:02.000000000 +0200
@@ -0,0 +1,111 @@
+/*
+ * i2c-au1550.c: SMBus (i2c) adapter for Alchemy PSC interface
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ * This is just a skeleton adapter to use with the Au1550 PSC
+ * algorithm.  It was developed for the Pb1550, but will work with
+ * any Au1550 board that has a similar PSC configuration.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+
+#include <asm/au1000.h>
+#include <asm/au1xxx_psc.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-au1550.h>
+
+static int
+pb1550_reg(struct i2c_client *client)
+{
+	return 0;
+}
+
+static int
+pb1550_unreg(struct i2c_client *client)
+{
+	return 0;
+}
+
+static void
+pb1550_inc_use(struct i2c_adapter *adap)
+{
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+}
+
+static void
+pb1550_dec_use(struct i2c_adapter *adap)
+{
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+}
+
+static struct i2c_algo_au1550_data pb1550_i2c_info = {
+	SMBUS_PSC_BASE, 200, 200
+};
+
+static struct i2c_adapter pb1550_board_adapter = {
+	name:              "pb1550 adapter",
+	id:                I2C_HW_AU1550_PSC,
+	algo:              NULL,
+	algo_data:         &pb1550_i2c_info,
+	inc_use:           pb1550_inc_use,
+	dec_use:           pb1550_dec_use,
+	client_register:   pb1550_reg,
+	client_unregister: pb1550_unreg,
+	client_count:      0,
+};
+
+int __init
+i2c_pb1550_init(void)
+{
+
+	/* This is where we would set up a 50MHz clock source
+	 * and routing.  On the Pb1550, the SMBus is PSC2, which
+	 * uses a shared clock with USB.  This has been already
+	 * configured by Yamon as a 48MHz clock, close enough
+	 * for our work.
+	 */
+        if (i2c_au1550_add_bus(&pb1550_board_adapter) < 0)
+                return -ENODEV;
+
+	return 0;
+}
+
+
+MODULE_AUTHOR("Dan Malek, Embedded Edge, LLC.");
+MODULE_DESCRIPTION("SMBus adapter Alchemy pb1550");
+MODULE_LICENSE("GPL");
+
+int
+init_module(void)
+{
+	return i2c_pb1550_init();
+}
+
+void
+cleanup_module(void)
+{
+	i2c_au1550_del_bus(&pb1550_board_adapter);
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/i2c/i2c-core.c linux-mips-cvs-20040815/drivers/i2c/i2c-core.c
--- linux-2.4.27/drivers/i2c/i2c-core.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/i2c/i2c-core.c	2004-08-15 08:06:11.000000000 +0200
@@ -1280,6 +1280,9 @@ static int __init i2c_init(void)
 #ifdef CONFIG_I2C_MAX1617
 	extern int i2c_max1617_init(void);
 #endif
+#ifdef CONFIG_I2C_ALGO_AU1550
+	extern int i2c_pb1550_init(void);
+#endif
 
 #ifdef CONFIG_I2C_PROC
 	extern int sensors_init(void);
@@ -1335,6 +1338,10 @@ int __init i2c_init_all(void)
 	i2c_max1617_init();
 #endif
 
+#ifdef CONFIG_I2C_ALGO_AU1550
+	i2c_pb1550_init();
+#endif
+
 	/* -------------- proc interface ---- */
 #ifdef CONFIG_I2C_PROC
 	sensors_init();
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/devices/docprobe.c linux-mips-cvs-20040815/drivers/mtd/devices/docprobe.c
--- linux-2.4.27/drivers/mtd/devices/docprobe.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/mtd/devices/docprobe.c	2003-06-16 01:42:21.000000000 +0200
@@ -89,10 +89,10 @@ static unsigned long __initdata doc_loca
 	0xe4000000,
 #elif defined(CONFIG_MOMENCO_OCELOT)
 	0x2f000000,
-        0xff000000,
+	0xff000000,
 #elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
-        0xff000000,
-##else
+	0xff000000,
+#else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
 	0 };
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/devices/ms02-nv.c linux-mips-cvs-20040815/drivers/mtd/devices/ms02-nv.c
--- linux-2.4.27/drivers/mtd/devices/ms02-nv.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/mtd/devices/ms02-nv.c	2004-08-15 08:06:17.000000000 +0200
@@ -1,10 +1,10 @@
 /*
- *      Copyright (c) 2001 Maciej W. Rozycki
+ *	Copyright (c) 2001 Maciej W. Rozycki
  *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
  *
  *	$Id: ms02-nv.c,v 1.2 2003/01/24 14:05:17 dwmw2 Exp $
  */
@@ -29,18 +29,18 @@
 
 
 static char version[] __initdata =
-        "ms02-nv.c: v.1.0.0  13 Aug 2001  Maciej W. Rozycki.\n";
+	"ms02-nv.c: v.1.0.0  13 Aug 2001  Maciej W. Rozycki.\n";
 
-MODULE_AUTHOR("Maciej W. Rozycki <macro@ds2.pg.gda.pl>");
+MODULE_AUTHOR("Maciej W. Rozycki <macro@linux-mips.org>");
 MODULE_DESCRIPTION("DEC MS02-NV NVRAM module driver");
 MODULE_LICENSE("GPL");
 
 
 /*
  * Addresses we probe for an MS02-NV at.  Modules may be located
- * at any 8MB boundary within a 0MB up to 112MB range or at any 32MB
- * boundary within a 0MB up to 448MB range.  We don't support a module
- * at 0MB, though.
+ * at any 8MiB boundary within a 0MiB up to 112MiB range or at any 32MiB
+ * boundary within a 0MiB up to 448MiB range.  We don't support a module
+ * at 0MiB, though.
  */
 static ulong ms02nv_addrs[] __initdata = {
 	0x07000000, 0x06800000, 0x06000000, 0x05800000, 0x05000000,
@@ -130,7 +130,7 @@ static int __init ms02nv_init_one(ulong 
 
 	int ret = -ENODEV;
 
-	/* The module decodes 8MB of address space. */
+	/* The module decodes 8MiB of address space. */
 	mod_res = kmalloc(sizeof(*mod_res), GFP_KERNEL);
 	if (!mod_res)
 		return -ENOMEM;
@@ -233,7 +233,7 @@ static int __init ms02nv_init_one(ulong 
 		goto err_out_csr_res;
 	}
 
-	printk(KERN_INFO "mtd%d: %s at 0x%08lx, size %uMB.\n",
+	printk(KERN_INFO "mtd%d: %s at 0x%08lx, size %uMiB.\n",
 		mtd->index, ms02nv_name, addr, size >> 20);
 
 	mp->next = root_ms02nv_mtd;
@@ -293,12 +293,12 @@ static int __init ms02nv_init(void)
 
 	switch (mips_machtype) {
 	case MACH_DS5000_200:
-		csr = (volatile u32 *)KN02_CSR_ADDR;
+		csr = (volatile u32 *)KN02_CSR_BASE;
 		if (*csr & KN02_CSR_BNK32M)
 			stride = 2;
 		break;
 	case MACH_DS5000_2X0:
-	case MACH_DS5000:
+	case MACH_DS5900:
 		csr = (volatile u32 *)KN03_MCR_BASE;
 		if (*csr & KN03_MCR_BNK32M)
 			stride = 2;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/devices/ms02-nv.h linux-mips-cvs-20040815/drivers/mtd/devices/ms02-nv.h
--- linux-2.4.27/drivers/mtd/devices/ms02-nv.h	2002-11-29 00:53:13.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/mtd/devices/ms02-nv.h	2004-08-15 08:06:17.000000000 +0200
@@ -1,32 +1,96 @@
 /*
- *      Copyright (c) 2001 Maciej W. Rozycki
+ *	Copyright (c) 2001, 2003  Maciej W. Rozycki
  *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of the GNU General Public License
- *      as published by the Free Software Foundation; either version
- *      2 of the License, or (at your option) any later version.
+ *	DEC MS02-NV (54-20948-01) battery backed-up NVRAM module for
+ *	DECstation/DECsystem 5000/2x0 and DECsystem 5900 and 5900/260
+ *	systems.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ *	$Id: ms02-nv.h,v 1.3 2003/08/19 09:25:36 dwmw2 Exp $
  */
 
 #include <linux/ioport.h>
 #include <linux/mtd/mtd.h>
 
+/*
+ * Addresses are decoded as follows:
+ *
+ * 0x000000 - 0x3fffff	SRAM
+ * 0x400000 - 0x7fffff	CSR
+ *
+ * Within the SRAM area the following ranges are forced by the system
+ * firmware:
+ *
+ * 0x000000 - 0x0003ff	diagnostic area, destroyed upon a reboot
+ * 0x000400 - ENDofRAM	storage area, available to operating systems
+ *
+ * but we can't really use the available area right from 0x000400 as
+ * the first word is used by the firmware as a status flag passed
+ * from an operating system.  If anything but the valid data magic
+ * ID value is found, the firmware considers the SRAM clean, i.e.
+ * containing no valid data, and disables the battery resulting in
+ * data being erased as soon as power is switched off.  So the choice
+ * for the start address of the user-available is 0x001000 which is
+ * nicely page aligned.  The area between 0x000404 and 0x000fff may
+ * be used by the driver for own needs.
+ *
+ * The diagnostic area defines two status words to be read by an
+ * operating system, a magic ID to distinguish a MS02-NV board from
+ * anything else and a status information providing results of tests
+ * as well as the size of SRAM available, which can be 1MiB or 2MiB
+ * (that's what the firmware handles; no idea if 2MiB modules ever
+ * existed).
+ *
+ * The firmware only handles the MS02-NV board if installed in the
+ * last (15th) slot, so for any other location the status information
+ * stored in the SRAM cannot be relied upon.  But from the hardware
+ * point of view there is no problem using up to 14 such boards in a
+ * system -- only the 1st slot needs to be filled with a DRAM module.
+ * The MS02-NV board is ECC-protected, like other MS02 memory boards.
+ *
+ * The state of the battery as provided by the CSR is reflected on
+ * the two onboard LEDs.  When facing the battery side of the board,
+ * with the LEDs at the top left and the battery at the bottom right
+ * (i.e. looking from the back side of the system box), their meaning
+ * is as follows (the system has to be powered on):
+ *
+ * left LED		battery disable status: lit = enabled
+ * right LED		battery condition status: lit = OK
+ */
+
 /* MS02-NV iomem register offsets. */
 #define MS02NV_CSR		0x400000	/* control & status register */
 
+/* MS02-NV CSR status bits. */
+#define MS02NV_CSR_BATT_OK	0x01		/* battery OK */
+#define MS02NV_CSR_BATT_OFF	0x02		/* battery disabled */
+
+
 /* MS02-NV memory offsets. */
 #define MS02NV_DIAG		0x0003f8	/* diagnostic status */
 #define MS02NV_MAGIC		0x0003fc	/* MS02-NV magic ID */
-#define MS02NV_RAM		0x000400	/* general-purpose RAM start */
+#define MS02NV_VALID		0x000400	/* valid data magic ID */
+#define MS02NV_RAM		0x001000	/* user-exposed RAM start */
 
-/* MS02-NV diagnostic status constants. */
-#define MS02NV_DIAG_SIZE_MASK	0xf0		/* RAM size mask */
-#define MS02NV_DIAG_SIZE_SHIFT	0x10		/* RAM size shift (left) */
+/* MS02-NV diagnostic status bits. */
+#define MS02NV_DIAG_TEST	0x01		/* SRAM test done (?) */
+#define MS02NV_DIAG_RO		0x02		/* SRAM r/o test done */
+#define MS02NV_DIAG_RW		0x04		/* SRAM r/w test done */
+#define MS02NV_DIAG_FAIL	0x08		/* SRAM test failed */
+#define MS02NV_DIAG_SIZE_MASK	0xf0		/* SRAM size mask */
+#define MS02NV_DIAG_SIZE_SHIFT	0x10		/* SRAM size shift (left) */
 
 /* MS02-NV general constants. */
 #define MS02NV_ID		0x03021966	/* MS02-NV magic ID value */
+#define MS02NV_VALID_ID		0xbd100248	/* valid data magic ID value */
 #define MS02NV_SLOT_SIZE	0x800000	/* size of the address space
 						   decoded by the module */
 
+
 typedef volatile u32 ms02nv_uint;
 
 struct ms02nv_private {
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/Config.in linux-mips-cvs-20040815/drivers/mtd/maps/Config.in
--- linux-2.4.27/drivers/mtd/maps/Config.in	2003-06-13 16:51:34.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/mtd/maps/Config.in	2004-02-26 01:46:35.000000000 +0100
@@ -51,11 +51,26 @@ if [ "$CONFIG_MIPS" = "y" ]; then
    dep_tristate '  Pb1000 MTD support' CONFIG_MTD_PB1000 $CONFIG_MIPS_PB1000
    dep_tristate '  Pb1500 MTD support' CONFIG_MTD_PB1500 $CONFIG_MIPS_PB1500
    dep_tristate '  Pb1100 MTD support' CONFIG_MTD_PB1100 $CONFIG_MIPS_PB1100
+   dep_tristate '  Bosporus MTD support' CONFIG_MTD_BOSPORUS $CONFIG_MIPS_BOSPORUS
+   dep_tristate '  XXS1500 boot flash device' CONFIG_MTD_XXS1500 $CONFIG_MIPS_XXS1500
+   dep_tristate '  MTX-1 flash device' CONFIG_MTD_MTX1 $CONFIG_MIPS_MTX1
    if [ "$CONFIG_MTD_PB1500" = "y" -o "$CONFIG_MTD_PB1500" = "m" \
 	-o "$CONFIG_MTD_PB1100" = "y" -o "$CONFIG_MTD_PB1100" = "m" ]; then
       bool '  Pb[15]00 boot flash device' CONFIG_MTD_PB1500_BOOT 
       bool '  Pb[15]00 user flash device (2nd 32MiB bank)' CONFIG_MTD_PB1500_USER
    fi
+   tristate '  Db1x00 MTD support' CONFIG_MTD_DB1X00
+   if [ "$CONFIG_MTD_DB1X00" = "y" -o "$CONFIG_MTD_DB1X00" = "m" ]; then
+      bool '  Db1x00 boot flash device' CONFIG_MTD_DB1X00_BOOT 
+      bool '  Db1x00 user flash device (2nd bank)' CONFIG_MTD_DB1X00_USER
+   fi
+   tristate '  Pb1550 MTD support' CONFIG_MTD_PB1550
+   if [ "$CONFIG_MTD_PB1550" = "y" -o "$CONFIG_MTD_PB1550" = "m" ]; then
+      bool '  Pb1550 Boot Flash' CONFIG_MTD_PB1550_BOOT
+      bool '  Pb1550 User Parameter Flash' CONFIG_MTD_PB1550_USER
+   fi
+   dep_tristate '  Hydrogen 3 MTD support' CONFIG_MTD_HYDROGEN3 $CONFIG_MIPS_HYDROGEN3
+   dep_tristate '  Mirage MTD support' CONFIG_MTD_MIRAGE $CONFIG_MIPS_MIRAGE
    dep_tristate '  Flash chip mapping on ITE QED-4N-S01B, Globespan IVR or custom board' CONFIG_MTD_CSTM_MIPS_IXX $CONFIG_MTD_CFI $CONFIG_MTD_JEDEC $CONFIG_MTD_PARTITIONS 
    if [ "$CONFIG_MTD_CSTM_MIPS_IXX" = "y" -o "$CONFIG_MTD_CSTM_MIPS_IXX" = "m" ]; then
       hex '    Physical start address of flash mapping' CONFIG_MTD_CSTM_MIPS_IXX_START 0x8000000
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/Makefile linux-mips-cvs-20040815/drivers/mtd/maps/Makefile
--- linux-2.4.27/drivers/mtd/maps/Makefile	2003-06-13 16:51:34.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/mtd/maps/Makefile	2004-02-26 01:46:35.000000000 +0100
@@ -52,7 +52,13 @@ obj-$(CONFIG_MTD_PCI)		+= pci.o
 obj-$(CONFIG_MTD_PB1000)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1100)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_PB1500)	+= pb1xxx-flash.o
+obj-$(CONFIG_MTD_XXS1500)       += xxs1500.o
+obj-$(CONFIG_MTD_MTX1)		+= mtx-1.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
+obj-$(CONFIG_MTD_DB1X00)        += db1x00-flash.o
+obj-$(CONFIG_MTD_PB1550)        += pb1550-flash.o
+obj-$(CONFIG_MTD_HYDROGEN3)     += hydrogen3-flash.o
+obj-$(CONFIG_MTD_BOSPORUS)	+= pb1xxx-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
@@ -61,5 +67,6 @@ obj-$(CONFIG_MTD_REDWOOD)	+= redwood.o
 obj-$(CONFIG_MTD_UCLINUX)	+= uclinux.o
 obj-$(CONFIG_MTD_NETtel)	+= nettel.o
 obj-$(CONFIG_MTD_SCB2_FLASH)	+= scb2_flash.o
+obj-$(CONFIG_MTD_MIRAGE)        += mirage-flash.o
 
 include $(TOPDIR)/Rules.make
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/db1x00-flash.c linux-mips-cvs-20040815/drivers/mtd/maps/db1x00-flash.c
--- linux-2.4.27/drivers/mtd/maps/db1x00-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/mtd/maps/db1x00-flash.c	2003-02-16 07:25:24.000000000 +0100
@@ -0,0 +1,285 @@
+/*
+ * Flash memory access on Alchemy Db1xxx boards
+ * 
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/db1x00.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+static unsigned long window_addr;
+static unsigned long window_size;
+static unsigned long flash_size;
+
+static BCSR * const bcsr = (BCSR *)0xAE000000;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info db1x00_map = {
+	name:		"Db1x00 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+/* 
+ * The Db1x boards support different flash densities. We setup
+ * the mtd_partition structures below for default of 64Mbit 
+ * flash densities, and override the partitions sizes, if
+ * necessary, after we check the board status register.
+ */
+
+#ifdef DB1X00_BOTH_BANKS
+/* both banks will be used. Combine the first bank and the first 
+ * part of the second bank together into a single jffs/jffs2
+ * partition.
+ */
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x1c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(DB1X00_BOOT_ONLY)
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x00c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(DB1X00_USER_ONLY)
+static struct mtd_partition db1x00_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x0e00000,
+                offset: 0x0000000
+        },{
+                name: "raw kernel",
+		size: MTDPART_SIZ_FULL,
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#else
+#error MTD_DB1X00 define combo error /* should never happen */
+#endif
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+/*
+ * Probe the flash density and setup window address and size
+ * based on user CONFIG options. There are times when we don't
+ * want the MTD driver to be probing the boot or user flash,
+ * so having the option to enable only one bank is important.
+ */
+int setup_flash_params()
+{
+	switch ((bcsr->status >> 14) & 0x3) {
+		case 0: /* 64Mbit devices */
+			flash_size = 0x800000; /* 8MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			window_addr = 0x1E000000;
+			window_size = 0x2000000; 
+#elif defined(DB1X00_BOOT_ONLY)
+			window_addr = 0x1F000000;
+			window_size = 0x1000000; 
+#else /* USER ONLY */
+			window_addr = 0x1E000000;
+			window_size = 0x1000000; 
+#endif
+			break;
+		case 1:
+			/* 128 Mbit devices */
+			flash_size = 0x1000000; /* 16MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			window_addr = 0x1C000000;
+			window_size = 0x4000000;
+			/* USERFS from 0x1C00 0000 to 0x1FC0 0000 */
+			db1x00_partitions[0].size = 0x3C00000;
+#elif defined(DB1X00_BOOT_ONLY)
+			window_addr = 0x1E000000;
+			window_size = 0x2000000;
+			/* USERFS from 0x1E00 0000 to 0x1FC0 0000 */
+			db1x00_partitions[0].size = 0x1C00000;
+#else /* USER ONLY */
+			window_addr = 0x1C000000;
+			window_size = 0x2000000;
+			/* USERFS from 0x1C00 0000 to 0x1DE00000 */
+			db1x00_partitions[0].size = 0x1DE0000;
+#endif
+			break;
+		case 2:
+			/* 256 Mbit devices */
+			flash_size = 0x4000000; /* 64MB per part */
+#if defined(DB1X00_BOTH_BANKS)
+			return 1;
+#elif defined(DB1X00_BOOT_ONLY)
+			/* Boot ROM flash bank only; no user bank */
+			window_addr = 0x1C000000;
+			window_size = 0x4000000;
+			/* USERFS from 0x1C00 0000 to 0x1FC00000 */
+			db1x00_partitions[0].size = 0x3C00000;
+#else /* USER ONLY */
+			return 1;
+#endif
+			break;
+		default:
+			return 1;
+	}
+	return 0;
+}
+
+int __init db1x00_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	db1x00_map.buswidth = flash_buswidth;
+
+	if (setup_flash_params()) 
+		return -ENXIO;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = db1x00_partitions;
+	nb_parts = NB_OF(db1x00_partitions);
+	db1x00_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Db1xxx flash: probing %d-bit flash bus\n", 
+			db1x00_map.buswidth*8);
+	db1x00_map.map_priv_1 = 
+		(unsigned long)ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &db1x00_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit db1x00_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(db1x00_mtd_init);
+module_exit(db1x00_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("Db1x00 mtd map driver");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/hydrogen3-flash.c linux-mips-cvs-20040815/drivers/mtd/maps/hydrogen3-flash.c
--- linux-2.4.27/drivers/mtd/maps/hydrogen3-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/mtd/maps/hydrogen3-flash.c	2004-01-10 23:40:18.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+ * Flash memory access on Alchemy HydrogenIII boards
+ * 
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#define WINDOW_ADDR 0x1E000000
+#define WINDOW_SIZE 0x02000000
+
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info hydrogen3_map = {
+	name:		"HydrogenIII flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+/* MTDPART_OFS_APPEND is vastly preferred to any attempt at statically lining
+ * up the offsets. */
+static struct mtd_partition hydrogen3_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x1c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+                size: 0x02c0000,
+                offset: MTDPART_OFS_APPEND
+        }
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init hydrogen3_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	hydrogen3_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = hydrogen3_partitions;
+	nb_parts = NB_OF(hydrogen3_partitions);
+	hydrogen3_map.size = WINDOW_SIZE;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "HydrogenIII flash: probing %d-bit flash bus\n", 
+			hydrogen3_map.buswidth*8);
+	hydrogen3_map.map_priv_1 = 
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &hydrogen3_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit hydrogen3_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+/*#ifndef MODULE
+
+static int __init _bootflashonly(char *str)
+{
+  bootflashonly = simple_strtol(str, NULL, 0);
+  return 1;
+}
+
+
+__setup("bootflashonly=", _bootflashonly);
+
+#endif*/
+
+
+module_init(hydrogen3_mtd_init);
+module_exit(hydrogen3_mtd_cleanup);
+
+MODULE_PARM(bootflashonly, "i");
+MODULE_PARM_DESC(bootflashonly, "1=use \"boot flash only\"");
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("HydrogenIII mtd map driver");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/lasat.c linux-mips-cvs-20040815/drivers/mtd/maps/lasat.c
--- linux-2.4.27/drivers/mtd/maps/lasat.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/mtd/maps/lasat.c	2003-08-18 04:59:02.000000000 +0200
@@ -1,15 +1,6 @@
 /*
  * Flash device on lasat 100 and 200 boards
  *
- * Presumably (C) 2002 Brian Murphy <brian@murphy.dk> or whoever he
- * works for.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * $Id: lasat.c,v 1.1 2003/01/24 14:26:38 dwmw2 Exp $
- *
  */
 
 #include <linux/module.h>
@@ -21,7 +12,6 @@
 #include <linux/mtd/partitions.h>
 #include <linux/config.h>
 #include <asm/lasat/lasat.h>
-#include <asm/lasat/lasat_mtd.h>
 
 static struct mtd_info *mymtd;
 
@@ -69,30 +59,33 @@ static void sp_copy_to(struct map_info *
 }
 
 static struct map_info sp_map = {
-	.name = "SP flash",
-	.buswidth = 4,
-	.read8 = sp_read8,
-	.read16 = sp_read16,
-	.read32 = sp_read32,
-	.copy_from = sp_copy_from,
-	.write8 = sp_write8,
-	.write16 = sp_write16,
-	.write32 = sp_write32,
-	.copy_to = sp_copy_to
+	name: "SP flash",
+	buswidth: 4,
+	read8: sp_read8,
+	read16: sp_read16,
+	read32: sp_read32,
+	copy_from: sp_copy_from,
+	write8: sp_write8,
+	write16: sp_write16,
+	write32: sp_write32,
+	copy_to: sp_copy_to
 };
 
 static struct mtd_partition partition_info[LASAT_MTD_LAST];
-static char *lasat_mtd_partnames[] = {"Bootloader", "Service", "Normal", "Filesystem", "Config"};
+static char *lasat_mtd_partnames[] = {"Bootloader", "Service", "Normal", "Config", "Filesystem"};
 
 static int __init init_sp(void)
 {
 	int i;
+	int nparts = 0;
 	/* this does not play well with the old flash code which 
 	 * protects and uprotects the flash when necessary */
        	printk(KERN_NOTICE "Unprotecting flash\n");
 	*lasat_misc->flash_wp_reg |= 1 << lasat_misc->flash_wp_bit;
 
-	sp_map.map_priv_1 = lasat_flash_partition_start(LASAT_MTD_BOOTLOADER);
+	sp_map.map_priv_1 = ioremap_nocache(
+		lasat_flash_partition_start(LASAT_MTD_BOOTLOADER),
+		lasat_board_info.li_flash_size);
 	sp_map.size = lasat_board_info.li_flash_size;
 
        	printk(KERN_NOTICE "sp flash device: %lx at %lx\n", 
@@ -109,12 +102,15 @@ static int __init init_sp(void)
 
 		for (i=0; i < LASAT_MTD_LAST; i++) {
 			size = lasat_flash_partition_size(i);
-			partition_info[i].size = size;
-			partition_info[i].offset = offset;
-			offset += size;
+			if (size != 0) {
+				nparts++;
+				partition_info[i].size = size;
+				partition_info[i].offset = offset;
+				offset += size;
+			}
 		}
 
-		add_mtd_partitions( mymtd, partition_info, LASAT_MTD_LAST );
+		add_mtd_partitions( mymtd, partition_info, nparts );
 		return 0;
 	}
 
@@ -124,11 +120,11 @@ static int __init init_sp(void)
 static void __exit cleanup_sp(void)
 {
 	if (mymtd) {
-		del_mtd_partitions(mymtd);
-		map_destroy(mymtd);
+	  del_mtd_partitions(mymtd);
+	  map_destroy(mymtd);
 	}
 	if (sp_map.map_priv_1) {
-		sp_map.map_priv_1 = 0;
+	  sp_map.map_priv_1 = 0;
 	}
 }
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/mirage-flash.c linux-mips-cvs-20040815/drivers/mtd/maps/mirage-flash.c
--- linux-2.4.27/drivers/mtd/maps/mirage-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/mtd/maps/mirage-flash.c	2003-12-22 04:37:22.000000000 +0100
@@ -0,0 +1,194 @@
+/*
+ * Flash memory access on AMD Mirage board.
+ * 
+ * (C) 2003 Embedded Edge
+ * based on mirage-flash.c:
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+//#include <asm/mirage.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+static unsigned long window_addr;
+static unsigned long window_size;
+static unsigned long flash_size;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info mirage_map = {
+	name:		"Mirage flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+static struct mtd_partition mirage_partitions[] = {
+        {
+                name: "User FS",
+                size:   0x1c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+/*
+ * Probe the flash density and setup window address and size
+ * based on user CONFIG options. There are times when we don't
+ * want the MTD driver to be probing the boot or user flash,
+ * so having the option to enable only one bank is important.
+ */
+int setup_flash_params()
+{
+	flash_size = 0x4000000; /* 64MB per part */
+	/* Boot ROM flash bank only; no user bank */
+	window_addr = 0x1C000000;
+	window_size = 0x4000000;
+	/* USERFS from 0x1C00 0000 to 0x1FC00000 */
+	mirage_partitions[0].size = 0x3C00000;
+	return 0;
+}
+
+int __init mirage_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	mirage_map.buswidth = flash_buswidth;
+
+	if (setup_flash_params()) 
+		return -ENXIO;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = mirage_partitions;
+	nb_parts = NB_OF(mirage_partitions);
+	mirage_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Mirage flash: probing %d-bit flash bus\n", 
+			mirage_map.buswidth*8);
+	mirage_map.map_priv_1 = 
+		(unsigned long)ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &mirage_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit mirage_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(mirage_mtd_init);
+module_exit(mirage_mtd_cleanup);
+
+MODULE_AUTHOR("Embedded Edge");
+MODULE_DESCRIPTION("Mirage mtd map driver");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/mtx-1.c linux-mips-cvs-20040815/drivers/mtd/maps/mtx-1.c
--- linux-2.4.27/drivers/mtd/maps/mtx-1.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/mtd/maps/mtx-1.c	2003-06-27 02:04:35.000000000 +0200
@@ -0,0 +1,181 @@
+/*
+ * Flash memory access on 4G Systems MTX-1 board
+ * 
+ * (C) 2003 Pete Popov <ppopov@mvista.com>
+ *	    Bruno Randolf <bruno.randolf@4g-systems.de>
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_MTX1
+#define WINDOW_ADDR 0x1E000000
+#define WINDOW_SIZE 0x2000000
+#endif
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+
+
+static struct map_info mtx1_map = {
+	name:		"MTX-1 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+
+static unsigned long flash_size = 0x01000000;
+static unsigned char flash_buswidth = 4;
+static struct mtd_partition mtx1_partitions[] = {
+        {
+                name: "user fs",
+                size: 0x1c00000,
+                offset: 0,
+        },{
+                name: "yamon",
+                size: 0x0100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+                size: 0x02c0000,
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon env vars",
+                size: 0x0040000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        }
+};
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init mtx1_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	mtx1_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = mtx1_partitions;
+	nb_parts = NB_OF(mtx1_partitions);
+	mtx1_map.size = flash_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "MTX-1 flash: probing %d-bit flash bus\n",
+			mtx1_map.buswidth*8);
+	mtx1_map.map_priv_1 =
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &mtx1_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit mtx1_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(mtx1_mtd_init);
+module_exit(mtx1_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("MTX-1 CFI map driver");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/pb1550-flash.c linux-mips-cvs-20040815/drivers/mtd/maps/pb1550-flash.c
--- linux-2.4.27/drivers/mtd/maps/pb1550-flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/mtd/maps/pb1550-flash.c	2004-08-15 08:06:17.000000000 +0200
@@ -0,0 +1,270 @@
+/*
+ * Flash memory access on Alchemy Pb1550 board
+ * 
+ * (C) 2004 Embedded Edge, LLC, based on pb1550-flash.c:
+ * (C) 2003 Pete Popov <ppopov@pacbell.net>
+ * 
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+#include <asm/pb1550.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+static unsigned long window_addr;
+static unsigned long window_size;
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+static struct map_info pb1550_map = {
+	name:		"Pb1550 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+static unsigned char flash_buswidth = 4;
+
+/* 
+ * Support only 64MB NOR Flash parts
+ */
+
+#ifdef PB1550_BOTH_BANKS
+/* both banks will be used. Combine the first bank and the first 
+ * part of the second bank together into a single jffs/jffs2
+ * partition.
+ */
+static struct mtd_partition pb1550_partitions[] = {
+	/* assume boot[2:0]:swap is '0000' or '1000', which translates to:
+	 * 1C00 0000 1FFF FFFF CE0 64MB Boot NOR Flash
+	 * 1800 0000 1BFF FFFF CE0 64MB Param NOR Flash
+	 */
+        {
+                name: "User FS",
+                size:   (0x1FC00000 - 0x18000000),
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000 - 0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(PB1550_BOOT_ONLY)
+static struct mtd_partition pb1550_partitions[] = {
+	/* assume boot[2:0]:swap is '0000' or '1000', which translates to:
+	 * 1C00 0000 1FFF FFFF CE0 64MB Boot NOR Flash
+	 */
+        {
+                name: "User FS",
+                size:   0x03c00000,
+                offset: 0x0000000
+        },{
+                name: "yamon",
+                size: 0x0100000,
+		offset:	MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "raw kernel",
+		size: (0x300000-0x40000), /* last 256KB is yamon env */
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#elif defined(PB1550_USER_ONLY)
+static struct mtd_partition pb1550_partitions[] = {
+	/* assume boot[2:0]:swap is '0000' or '1000', which translates to:
+	 * 1800 0000 1BFF FFFF CE0 64MB Param NOR Flash
+	 */
+        {
+                name: "User FS",
+                size:  (0x4000000 - 0x200000), /* reserve 2MB for raw kernel */
+                offset: 0x0000000
+        },{
+                name: "raw kernel",
+		size: MTDPART_SIZ_FULL,
+		offset:	MTDPART_OFS_APPEND,
+        }
+};
+#else
+#error MTD_PB1550 define combo error /* should never happen */
+#endif
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+/*
+ * Probe the flash density and setup window address and size
+ * based on user CONFIG options. There are times when we don't
+ * want the MTD driver to be probing the boot or user flash,
+ * so having the option to enable only one bank is important.
+ */
+int setup_flash_params()
+{
+	u16 boot_swapboot;
+	boot_swapboot = (au_readl(MEM_STSTAT) & (0x7<<1)) | 
+		((bcsr->status >> 6)  & 0x1);
+	printk("Pb1550 MTD: boot:swap %d\n", boot_swapboot);
+
+	switch (boot_swapboot) {
+		case 0: /* 512Mbit devices, both enabled */
+		case 1: 
+		case 8:
+		case 9: 
+#if defined(PB1550_BOTH_BANKS)
+			window_addr = 0x18000000;
+			window_size = 0x8000000; 
+#elif defined(PB1550_BOOT_ONLY)
+			window_addr = 0x1C000000;
+			window_size = 0x4000000; 
+#else /* USER ONLY */
+			window_addr = 0x1E000000;
+			window_size = 0x1000000; 
+#endif
+			break;
+		case 0xC:
+		case 0xD:
+		case 0xE:
+		case 0xF: 
+			/* 64 MB Boot NOR Flash is disabled */
+			/* and the start address is moved to 0x0C00000 */
+			window_addr = 0x0C000000;
+			window_size = 0x4000000; 
+		default:
+			printk("Pb1550 MTD: unsupported boot:swap setting\n");
+			return 1;
+	}
+	return 0;
+}
+
+int __init pb1550_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	pb1550_map.buswidth = flash_buswidth;
+
+	if (setup_flash_params()) 
+		return -ENXIO;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = pb1550_partitions;
+	nb_parts = NB_OF(pb1550_partitions);
+	pb1550_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "Pb1550 flash: probing %d-bit flash bus\n", 
+			pb1550_map.buswidth*8);
+	pb1550_map.map_priv_1 = 
+		(unsigned long)ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &pb1550_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit pb1550_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(pb1550_mtd_init);
+module_exit(pb1550_mtd_cleanup);
+
+MODULE_AUTHOR("Embedded Edge, LLC");
+MODULE_DESCRIPTION("Pb1550 mtd map driver");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/pb1xxx-flash.c linux-mips-cvs-20040815/drivers/mtd/maps/pb1xxx-flash.c
--- linux-2.4.27/drivers/mtd/maps/pb1xxx-flash.c	2003-06-13 16:51:34.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/mtd/maps/pb1xxx-flash.c	2003-05-19 08:27:22.000000000 +0200
@@ -192,6 +192,34 @@ static struct mtd_partition pb1xxx_parti
 #else
 #error MTD_PB1500 define combo error /* should never happen */
 #endif
+#elif defined(CONFIG_MTD_BOSPORUS)
+static unsigned char flash_buswidth = 2;
+static unsigned long flash_size 	= 0x02000000;
+#define WINDOW_ADDR 0x1F000000
+#define WINDOW_SIZE 0x2000000
+static struct mtd_partition pb1xxx_partitions[] = {
+        {
+                name:   "User FS",
+                size:   0x00400000,
+                offset: 0x00000000,
+        },{
+                name:   "Yamon-2",
+                size:   0x00100000,
+                offset: 0x00400000,
+        },{
+                name:   "Root FS",
+                size:   0x00700000,
+                offset: 0x00500000,
+        },{
+                name:   "Yamon-1",
+                size:   0x00100000,
+                offset: 0x00C00000,
+        },{
+                name:   "Kernel",
+                size:   0x00300000,
+                offset: 0x00D00000,
+        }
+};
 #else
 #error Unsupported board
 #endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/mtd/maps/xxs1500.c linux-mips-cvs-20040815/drivers/mtd/maps/xxs1500.c
--- linux-2.4.27/drivers/mtd/maps/xxs1500.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/mtd/maps/xxs1500.c	2003-08-02 04:06:01.000000000 +0200
@@ -0,0 +1,186 @@
+/*
+ * Flash memory access on MyCable XXS1500 board
+ * 
+ * (C) 2003 Pete Popov <ppopov@mvista.com>
+ * 
+ * $Id: xxs1500.c,v 1.1.2.2 2003/08/02 02:06:01 ppopov Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/au1000.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)	
+#endif
+
+#ifdef CONFIG_MIPS_XXS1500
+#define WINDOW_ADDR 0x1F000000
+#define WINDOW_SIZE 0x1000000
+#endif
+
+__u8 physmap_read8(struct map_info *map, unsigned long ofs)
+{
+	__u8 ret;
+	ret = __raw_readb(map->map_priv_1 + ofs);
+	DBG("read8 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u16 physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	__u16 ret;
+	ret = __raw_readw(map->map_priv_1 + ofs);
+	DBG("read16 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+__u32 physmap_read32(struct map_info *map, unsigned long ofs)
+{
+	__u32 ret;
+	ret = __raw_readl(map->map_priv_1 + ofs);
+	DBG("read32 from %x, %x\n", (unsigned)(map->map_priv_1 + ofs), ret);
+	return ret;
+}
+
+void physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	DBG("physmap_copy from %x to %x\n", (unsigned)from, (unsigned)to);
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+void physmap_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	DBG("write8 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writeb(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	DBG("write16 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	DBG("write32 at %x, %x\n", (unsigned)(map->map_priv_1 + adr), d);
+	__raw_writel(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	DBG("physmap_copy_to %x from %x\n", (unsigned)to, (unsigned)from);
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+
+
+static struct map_info xxs1500_map = {
+	name:		"XXS1500 flash",
+	read8: physmap_read8,
+	read16: physmap_read16,
+	read32: physmap_read32,
+	copy_from: physmap_copy_from,
+	write8: physmap_write8,
+	write16: physmap_write16,
+	write32: physmap_write32,
+	copy_to: physmap_copy_to,
+};
+
+
+static unsigned long flash_size = 0x00800000;
+static unsigned char flash_buswidth = 4;
+static struct mtd_partition xxs1500_partitions[] = {
+        {
+                name: "kernel image",
+                size: 0x00200000,
+                offset: 0,
+        },{
+                name: "user fs 0",
+                size: (0x00C00000-0x200000),
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon",
+                size: 0x00100000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        },{
+                name: "user fs 1",
+                size: 0x2c0000,
+                offset: MTDPART_OFS_APPEND,
+        },{
+                name: "yamon env vars",
+                size: 0x040000,
+                offset: MTDPART_OFS_APPEND,
+                mask_flags: MTD_WRITEABLE
+        }
+};
+
+
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init xxs1500_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	char *part_type;
+	
+	/* Default flash buswidth */
+	xxs1500_map.buswidth = flash_buswidth;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+	parts = xxs1500_partitions;
+	nb_parts = NB_OF(xxs1500_partitions);
+	xxs1500_map.size = flash_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "XXS1500 flash: probing %d-bit flash bus\n", 
+			xxs1500_map.buswidth*8);
+	xxs1500_map.map_priv_1 = 
+		(unsigned long)ioremap(WINDOW_ADDR, WINDOW_SIZE);
+	mymtd = do_map_probe("cfi_probe", &xxs1500_map);
+	if (!mymtd) return -ENXIO;
+	mymtd->module = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit xxs1500_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+}
+
+module_init(xxs1500_mtd_init);
+module_exit(xxs1500_mtd_cleanup);
+
+MODULE_AUTHOR("Pete Popov");
+MODULE_DESCRIPTION("XXS1500 CFI map driver");
+MODULE_LICENSE("GPL");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/Config.in linux-mips-cvs-20040815/drivers/net/Config.in
--- linux-2.4.27/drivers/net/Config.in	2004-08-08 01:26:04.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/net/Config.in	2004-08-15 08:06:18.000000000 +0200
@@ -281,6 +281,13 @@ if [ "$CONFIG_MOMENCO_OCELOT_C" = "y" -o
    dep_bool '    MV-64340 Port 1' CONFIG_MV64340_ETH_1 $CONFIG_MV64340_ETH
    dep_bool '    MV-64340 Port 2' CONFIG_MV64340_ETH_2 $CONFIG_MV64340_ETH
 fi
+
+if [ "$CONFIG_PMC_BIG_SUR" = "y" ]; then
+   tristate 'PMC-Sierra Big Sur Fast Ethernet Adapter' CONFIG_BIG_SUR_FE
+fi
+if [ "$CONFIG_PMC_YOSEMITE" = "y" ]; then
+   tristate 'PMC-Sierra TITAN Gigabit Ethernet Support' CONFIG_TITAN_GE
+fi
 endmenu
 
 if [ "$CONFIG_PPC_ISERIES" = "y" ]; then
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/Makefile linux-mips-cvs-20040815/drivers/net/Makefile
--- linux-2.4.27/drivers/net/Makefile	2004-08-08 01:26:04.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/net/Makefile	2004-08-15 08:06:18.000000000 +0200
@@ -117,6 +117,8 @@ obj-$(CONFIG_ADAPTEC_STARFIRE) += starfi
 
 obj-$(CONFIG_GALILEO_64240_ETH) += gt64240eth.o
 obj-$(CONFIG_MV64340_ETH)	+= mv64340_eth.o
+obj-$(CONFIG_BIG_SUR_FE)	+= big_sur_ge.o
+obj-$(CONFIG_TITAN_GE)		+= titan_mdio.o titan_ge.o
 obj-$(CONFIG_AIRONET4500) 	+= aironet4500_core.o
 obj-$(CONFIG_AIRONET4500_CS) 	+= aironet4500_core.o
 obj-$(CONFIG_AIRONET4500_NONCS)  += aironet4500_card.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/au1000_eth.c linux-mips-cvs-20040815/drivers/net/au1000_eth.c
--- linux-2.4.27/drivers/net/au1000_eth.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/au1000_eth.c	2004-08-15 08:06:18.000000000 +0200
@@ -241,7 +241,11 @@ int lsi_80227_init(struct net_device *de
 	mdelay(1);
 
 	/* set up LEDs to correct display */
+#ifdef CONFIG_MIPS_MTX1
+	mdio_write(dev, phy_addr, 17, 0xff80);
+#else
 	mdio_write(dev, phy_addr, 17, 0xffc0);
+#endif
 
 	if (au1000_debug > 4)
 		dump_mii(dev, phy_addr);
@@ -1077,6 +1081,7 @@ setup_hw_rings(struct au1000_private *au
 static struct {
 	int port;
 	u32 base_addr;
+	u32 macen_addr;
 	int irq;
 	struct net_device *dev;
 } iflist[2];
@@ -1095,23 +1100,48 @@ static int __init au1000_init_module(voi
 	struct net_device *dev;
 	int i, found_one = 0;
 
-	iflist[0].irq = AU1000_ETH0_IRQ;
-	iflist[1].irq = AU1000_ETH1_IRQ;
 	switch (c->cputype) {
+#ifdef CONFIG_SOC_AU1000
 	case CPU_AU1000:
 		num_ifs = 2 - ni;
 		iflist[0].base_addr = AU1000_ETH0_BASE;
 		iflist[1].base_addr = AU1000_ETH1_BASE;
+		iflist[0].macen_addr = AU1000_MAC0_ENABLE;
+		iflist[1].macen_addr = AU1000_MAC1_ENABLE;
+		iflist[0].irq = AU1000_MAC0_DMA_INT;
+		iflist[1].irq = AU1000_MAC1_DMA_INT;
 		break;
+#endif
+#ifdef CONFIG_SOC_AU1100
 	case CPU_AU1100:
 		num_ifs = 1 - ni;
-		iflist[0].base_addr = AU1000_ETH0_BASE;
+		iflist[0].base_addr = AU1100_ETH0_BASE;
+		iflist[0].macen_addr = AU1100_MAC0_ENABLE;
+		iflist[0].irq = AU1100_MAC0_DMA_INT;
 		break;
+#endif
+#ifdef CONFIG_SOC_AU1500
 	case CPU_AU1500:
 		num_ifs = 2 - ni;
 		iflist[0].base_addr = AU1500_ETH0_BASE;
 		iflist[1].base_addr = AU1500_ETH1_BASE;
+		iflist[0].macen_addr = AU1500_MAC0_ENABLE;
+		iflist[1].macen_addr = AU1500_MAC1_ENABLE;
+		iflist[0].irq = AU1500_MAC0_DMA_INT;
+		iflist[1].irq = AU1500_MAC1_DMA_INT;
+		break;
+#endif
+#ifdef CONFIG_SOC_AU1550
+	case CPU_AU1550:
+		num_ifs = 2 - ni;
+		iflist[0].base_addr = AU1550_ETH0_BASE;
+		iflist[1].base_addr = AU1550_ETH1_BASE;
+		iflist[0].macen_addr = AU1550_MAC0_ENABLE;
+		iflist[1].macen_addr = AU1550_MAC1_ENABLE;
+		iflist[0].irq = AU1550_MAC0_DMA_INT;
+		iflist[1].irq = AU1550_MAC1_DMA_INT;
 		break;
+#endif
 	default:
 		num_ifs = 0;
 	}
@@ -1173,9 +1203,8 @@ au1000_probe(u32 ioaddr, int irq, int po
 	/* aup->mac is the base address of the MAC's registers */
 	aup->mac = (volatile mac_reg_t *)((unsigned long)ioaddr);
 	/* Setup some variables for quick register address access */
-	switch (ioaddr) {
-	case AU1000_ETH0_BASE:
-	case AU1500_ETH0_BASE:
+	if (ioaddr == iflist[0].base_addr)
+	{
 		/* check env variables first */
 		if (!get_ethernet_addr(ethaddr)) { 
 			memcpy(au1000_mac_addr, ethaddr, sizeof(dev->dev_addr));
@@ -1192,37 +1221,27 @@ au1000_probe(u32 ioaddr, int irq, int po
 						sizeof(dev->dev_addr));
 			}
 		}
-		if (ioaddr == AU1000_ETH0_BASE)
 			aup->enable = (volatile u32 *) 
-				((unsigned long)AU1000_MAC0_ENABLE);
-		else
-			aup->enable = (volatile u32 *) 
-				((unsigned long)AU1500_MAC0_ENABLE);
+				((unsigned long)iflist[0].macen_addr);
 		memcpy(dev->dev_addr, au1000_mac_addr, sizeof(dev->dev_addr));
 		setup_hw_rings(aup, MAC0_RX_DMA_ADDR, MAC0_TX_DMA_ADDR);
 		aup->mac_id = 0;
 		au_macs[0] = aup;
-			break;
-
-	case AU1000_ETH1_BASE:
-	case AU1500_ETH1_BASE:
-		if (ioaddr == AU1000_ETH1_BASE)
-			aup->enable = (volatile u32 *) 
-				((unsigned long)AU1000_MAC1_ENABLE);
+	}
 		else
+	if (ioaddr == iflist[1].base_addr)
+	{
 			aup->enable = (volatile u32 *) 
-				((unsigned long)AU1500_MAC1_ENABLE);
+				((unsigned long)iflist[1].macen_addr);
 		memcpy(dev->dev_addr, au1000_mac_addr, sizeof(dev->dev_addr));
 		dev->dev_addr[4] += 0x10;
 		setup_hw_rings(aup, MAC1_RX_DMA_ADDR, MAC1_TX_DMA_ADDR);
 		aup->mac_id = 1;
 		au_macs[1] = aup;
-			break;
-
-	default:
+	}
+	else
+	{
 		printk(KERN_ERR "%s: bad ioaddr\n", dev->name);
-		break;
-
 	}
 
 	/* bring the device out of reset, otherwise probing the mii
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/big_sur_ge.c linux-mips-cvs-20040815/drivers/net/big_sur_ge.c
--- linux-2.4.27/drivers/net/big_sur_ge.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/big_sur_ge.c	2004-08-15 08:06:18.000000000 +0200
@@ -0,0 +1,1613 @@
+/*
+ * drivers/net/big_sur_ge.c - Driver for PMC-Sierra Big Sur
+ * ethernet ports
+ *
+ * Copyright (C) 2003, 2004 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+/*
+ * This driver also includes the PHY related stuff. The device
+ * is a fast ethernet device. But, there is a Gigabit unit
+ * in the works. When that is ready, this driver will support
+ * it. 
+ *
+ * Basic Operation
+ * ================
+ * The device operates in following modes:
+ * -> Polled mode, no DMA (FIFO)
+ * -> Polled mode, Simple DMA
+ * -> Interrupt mode, Simple DMA
+ * -> Interrupt mode, Scatter Gather DMA
+ *
+ * Scatter Gather DMA does not work. So, we make use of Simple DMA
+ * mode here. There is no implementation of ring descriptors here
+ * since it is not working as yet. Note that there could be an enhancement
+ * whereby the driver can support FIFO mode or Simple DMA. However,
+ * this version only supports Simple DMA.
+ *
+ * Receive Operation
+ * ==================
+ * The device DMA's sends an interrupt to the processor. The driver 
+ * is invoked and it determines if the packet is to be received. If 
+ * yes, it allocates a new skb and has the DMA controller transfer the 
+ * data into the newly allocated skb. The receive side handles one 
+ * packet at a time. The Rx FIFO on the device is 2000 bytes.
+ *
+ * Send Operation
+ * ===============
+ * The device Transmit FIFO is 2000 bytes long, i.e. one packet. When
+ * sending, the driver makes sure that the packet is aligned. Once
+ * done, it asks the device to do a DMA transfer from memory to the 
+ * onboard FIFO. The device is stopped till the transfer completes since
+ * it can DMA only one packet at a time.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "big_sur_ge.h"
+
+MODULE_AUTHOR("Manish Lachwani <lachwani@pmc-sierra.com>");
+MODULE_DESCRIPTION("PMC-Sierra Big Sur Ethernet MAC Driver");
+MODULE_LICENSE("GPL");
+
+#define TX_TIMEOUT (60 * HZ)      /* Transmit timeout */
+
+typedef enum DUPLEX { UNKNOWN, HALF_DUPLEX, FULL_DUPLEX } DUPLEX;
+
+/* Big Sur Ethernet MAC structure */
+struct big_sur_ge_enet {
+        struct net_device_stats *stats;	/* Statistics for this device */
+        struct timer_list phy_timer;    /* PHY monitoring timer */
+        u32 index;             		/* Which interface is this */
+        u32 save_base_address; 		/* Saved physical base address */
+        struct sk_buff *saved_skb;      /* skb being transmitted */
+        spinlock_t lock;            	/* For atomic access to saved_skb */
+        u8 mii_addr;        		/* The MII address of the PHY */
+        big_sur_ge *emac;               /* GE driver structure */
+	struct tasklet_struct big_sur_tasklet;	/* Tasklet structure */
+};
+
+extern unsigned char big_sur_mac_addr_base[6];
+
+/*
+ * Function Prototypes 
+ */
+unsigned long big_sur_ge_dma_control(xdma_channel *);
+void big_sur_ge_dma_reset(xdma_channel *);
+static void handle_intr(struct net_device *, big_sur_ge *);
+void big_sur_ge_check_fifo_recv_error(struct net_device *, big_sur_ge *);
+void big_sur_ge_check_fifo_send_error(struct net_device *, big_sur_ge *);
+static int big_sur_ge_config_fifo(big_sur_ge *);
+static int big_sur_ge_config_dma(big_sur_ge *);
+void big_sur_ge_enet_reset(big_sur_ge *);
+void big_sur_ge_check_mac_error(big_sur_ge *, unsigned long);
+static void big_sur_receive(struct net_device *);
+static void big_sur_tx_free_skb(struct net_device *);
+big_sur_ge_config *big_sur_ge_get_config(int);
+static void big_sur_ge_reset(struct net_device *,DUPLEX);
+
+/*
+ * DMA Channel Initialization. In case of Simple DMA,
+ * not much to do here. However, in case of SG DMA, we
+ * need to intialize the descriptor pointers 
+ */
+int big_sur_ge_dma_init(xdma_channel *dma, unsigned long base_address) 
+{
+	dma->reg_base_address = base_address;
+	dma->ready = 1; 
+
+	big_sur_ge_dma_reset(dma);
+	return 0;
+}
+
+/*
+ * Perform the self test on the DMA channel 
+ */
+#define BIG_SUR_GE_CONTROL_REG_RESET_MASK	0x98000000
+
+int big_sur_ge_dma_self_test(xdma_channel *dma)
+{
+	unsigned long	reg_data;
+
+	big_sur_ge_dma_reset(dma);
+	
+	reg_data = big_sur_ge_dma_control(dma);
+	if (reg_data != BIG_SUR_GE_CONTROL_REG_RESET_MASK) {
+		printk(KERN_ERR "DMA Channel Self Test Failed \n");
+		return -1;
+	}
+	
+	return 0;
+}
+
+/*
+ * Reset the DMA channel
+ */
+void big_sur_ge_dma_reset(xdma_channel *dma)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_RST_REG_OFFSET,
+						BIG_SUR_GE_RESET_MASK);
+}
+
+/*
+ * Get control register from the DMA channel
+ */
+unsigned long big_sur_ge_dma_control(xdma_channel *dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address + BIG_SUR_GE_DMAC_REG_OFFSET);
+}
+
+/*
+ * Set control register of the DMA channel
+ */
+void big_sur_ge_set_dma_control(xdma_channel *dma, unsigned long control)
+{
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_DMAC_REG_OFFSET, control);
+}
+
+/*
+ * Get the status of the DMA channel 
+ */
+unsigned long big_sur_ge_dma_status(xdma_channel *dma)
+{
+	return BIG_SUR_GE_READ(dma->reg_base_address + BIG_SUR_GE_DMAS_REG_OFFSET);
+}
+
+/*
+ * Transfer the data over the DMA channel
+ */
+void big_sur_ge_dma_transfer(xdma_channel *dma, unsigned long *source,
+				unsigned long *dest, unsigned long length)
+{
+	/* Source Address */
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_SA_REG_OFFSET, 
+				(unsigned long)source);
+
+	/* Destination Address */
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_DA_REG_OFFSET,
+				(unsigned long)dest);
+
+	/* Length of the data */
+	BIG_SUR_GE_WRITE(dma->reg_base_address + BIG_SUR_GE_LEN_REG_OFFSET,
+				length);
+}
+
+/*
+ * Init the packet fifo only in the FIFO mode
+ */
+int packet_fifo_init(packet_fifo *fifo, u32 reg, u32 data)
+{
+	fifo->reg_base_addr = reg;
+	fifo->data_base_address = data;
+	fifo->ready_status = 1;
+
+	BIG_SUR_GE_FIFO_RESET(fifo);
+
+	return 0;
+}
+
+/*
+ * Write to the packet FIFO, 32-bit at a time. 
+ */
+static int packet_fifo_write(packet_fifo * fifo, int *buffer, int len)
+{
+	unsigned long fifo_count, word_count, extra_byte;
+	unsigned long *buffer_data = (unsigned long *) buffer;
+
+	fifo_count =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT);
+	fifo_count &= BIG_SUR_GE_COUNT_MASK;
+
+	word_count = len / BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+	extra_byte = len % BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+
+	if (extra_byte > 0)
+		if (fifo_count > (word_count + 1)) {
+			printk(KERN_ERR
+			       "No room in the packet send fifo \n");
+			return -1;
+		}
+
+	for (fifo_count = 0; fifo_count < word_count; fifo_count++)
+		BIG_SUR_GE_WRITE(fifo->data_base_address,
+				 buffer_data[fifo_count]);
+
+	if (extra_byte > 0) {
+		unsigned long last_word = 0;
+		int *extra_buffer_data =
+		    (int *) (buffer_data + word_count);
+
+		if (extra_byte == 1)
+			last_word = extra_buffer_data[0] << 24;
+		else if (extra_byte == 2)
+			last_word = (extra_buffer_data[0] << 24 |
+				     extra_buffer_data[1] << 16);
+
+		else if (extra_byte == 3)
+			last_word = (extra_buffer_data[0] << 24 |
+				     extra_buffer_data[1] << 16 |
+				     extra_buffer_data[2] << 8);
+
+
+		BIG_SUR_GE_WRITE(fifo->data_base_address, last_word);
+	}
+
+	return 0;
+}
+
+/*
+ * Start transmitting the packet 
+ */
+int big_sur_tx(big_sur_ge *emac, u8 *buffer, unsigned long byte_cnt)
+{
+	unsigned long int_status, reg_data, status_reg;
+
+	if ( (!emac->started) && (emac->polled) &&
+		(emac->dma_sg) ) 
+		return -1;
+
+	/* There is space in the FIFO */
+	int_status = BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+	if (int_status & BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK) {
+		printk(KERN_ERR "Tx FIFO error: Queue is Full \n");
+		return -1;
+	}
+
+	/*
+	 * Check if there is enough space for this packet
+	 */
+	if ((BIG_SUR_GE_GET_COUNT(&emac->send_fifo) * sizeof(unsigned long)) < byte_cnt) {
+		printk(KERN_ERR "Send FIFO on chip is full \n");
+		return -1;
+	}
+
+	if (emac->has_dma == 0) {
+		/* Write to the Send FIFO */
+		if (packet_fifo_write(&emac->send_fifo, buffer, byte_cnt) == -1) {
+			printk(KERN_ERR "Error : Could not write to FIFO \n");
+			return -1;
+		}
+
+		/* Write the MSB of the length */
+		BIG_SUR_GE_WRITE(emac->base_address + 0x1FF4, (byte_cnt & 0xff00));
+
+		/* Write the LSB of the length */
+		BIG_SUR_GE_WRITE(emac->base_address + 0x1FF8, (byte_cnt & 0x00ff));
+
+		/* Write the Status bit */
+		BIG_SUR_GE_WRITE(emac->base_address + 0x1FFC, 0x80000000);
+	
+		/* Make sure MAC has done transmitting */	
+		status_reg = BIG_SUR_GE_READ(emac->base_address + 0x1FFC);
+		while (!(status_reg & 0x80000000)) {
+			status_reg = BIG_SUR_GE_READ(emac->base_address + 0x1FFC);
+			if (!(status_reg & 0x80000000))
+				break;
+		}
+
+	}
+	else {
+		/* DMA Engine is not buzy */
+		if (big_sur_ge_dma_status(&emac->send_channel) & BIG_SUR_GE_DMASR_BUSY_MASK) {
+			printk(KERN_ERR "Send channel FIFO engine busy \n");
+			return -1;
+		}
+
+		/* Get ready to transfer the data */
+		big_sur_ge_set_dma_control(&emac->send_channel, 
+					BIG_SUR_GE_DMACR_SOURCE_INCR_MASK |
+					BIG_SUR_GE_DMACR_DEST_LOCAL_MASK  |
+					BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+		big_sur_ge_dma_transfer(&emac->send_channel, (unsigned long *)buffer, 
+					(unsigned long *)(emac->base_address + 
+					BIG_SUR_GE_PFIFO_TXDATA_OFFSET), byte_cnt);
+
+		/* Check the DMA Engine status */	
+		reg_data = big_sur_ge_dma_status(&emac->send_channel);
+		while (reg_data & BIG_SUR_GE_DMASR_BUSY_MASK) {
+                	reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+	                if (!(reg_data & BIG_SUR_GE_DMASR_BUSY_MASK))
+        	                break;
+        	}
+
+		/* Check for any DMA errors */
+		if ( (reg_data & BIG_SUR_GE_DMASR_BUS_ERROR_MASK) || 
+			(reg_data & BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK)) {
+				printk(KERN_ERR "Send side DMA error \n");
+				return -1;
+		}
+
+		/* Write the packet length */
+		BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_TPLR_OFFSET, byte_cnt);
+	}
+
+	/* Good Send */
+	return 0;
+}
+
+/*
+ * Read the packet FIFO
+ */
+static int packet_fifo_read(packet_fifo * fifo, u8 * buffer, unsigned int len)
+{
+	unsigned long fifo_count, word_count, extra_byte;
+	unsigned long *buffer_data = (unsigned long *) buffer;
+
+	fifo_count =
+	    BIG_SUR_GE_READ(fifo->reg_base_addr +
+			    BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT);
+	fifo_count &= BIG_SUR_GE_COUNT_MASK;
+
+	if ((fifo_count * BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT) < len)
+		return -1;
+
+	word_count = len / BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+	extra_byte = len % BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT;
+
+	for (fifo_count = 0; fifo_count < word_count; fifo_count++)
+		buffer_data[fifo_count] =
+		    BIG_SUR_GE_READ(fifo->reg_base_addr);
+
+	if (extra_byte > 0) {
+		unsigned long last_word;
+		int *extra_buffer_data =
+		    (int *) (buffer_data + word_count);
+
+		last_word = BIG_SUR_GE_READ(fifo->data_base_address);
+		if (extra_byte == 1)
+			extra_buffer_data[0] = (int) (last_word << 24);
+		else if (extra_byte == 2) {
+			extra_buffer_data[0] = (int) (last_word << 24);
+			extra_buffer_data[1] = (int) (last_word << 16);
+		} else if (extra_byte == 3) {
+			extra_buffer_data[0] = (int) (last_word << 24);
+			extra_buffer_data[1] = (int) (last_word << 16);
+			extra_buffer_data[2] = (int) (last_word << 8);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * FIFO receive for Simple DMA case
+ */
+int big_sur_rx(big_sur_ge *emac, u8 *buffer, unsigned long *byte_cnt)
+{
+	unsigned long int_status, reg_data, packet_length;
+
+        if ( (!emac->started) && (emac->polled) &&
+		(emac->dma_sg) ) {
+                return -1;
+	}
+
+	/* Not enough space in the current buffer */	
+	if (*byte_cnt < BIG_SUR_GE_MAX_FRAME_SIZE)
+		return -1;
+
+	int_status = BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_IISR_OFFSET);
+
+	/* FIFO is empty */
+	if (int_status & BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK) {
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IISR_OFFSET, 
+					BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK);
+		return -1;
+	}
+
+	packet_length = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_RPLR_OFFSET);
+
+	if (emac->has_dma == 0) {
+		reg_data = BIG_SUR_GE_READ(emac->base_address + 0x3FFC);
+		if (reg_data & 0x80000000) {
+			if (packet_fifo_read(&emac->recv_fifo, buffer, packet_length) == -1) {
+				printk(KERN_ERR "Could not read the packet fifo \n");
+				return -1;
+			}
+
+			BIG_SUR_GE_WRITE(emac->base_address + 0x3FFC, 0x0);
+		}
+	}
+	else {	
+		/* Rx side DMA engine */
+		if (big_sur_ge_dma_status(&emac->recv_channel) & BIG_SUR_GE_DMASR_BUSY_MASK) {
+			printk(KERN_ERR "Rx side DMA Engine busy \n");
+			return -1;
+		}
+
+		if (packet_length == 0) {
+			printk(KERN_ERR "MAC has the FIFO packet length 0 \n");
+			return -1;
+		}
+
+		/* For the simple DMA case only */
+		big_sur_ge_set_dma_control(&emac->recv_channel, 
+							BIG_SUR_GE_DMACR_DEST_INCR_MASK |
+							BIG_SUR_GE_DMACR_SOURCE_LOCAL_MASK |
+							BIG_SUR_GE_DMACR_SG_DISABLE_MASK);
+
+		big_sur_ge_dma_transfer(&emac->recv_channel, (unsigned long *)
+					(emac->base_address + 
+					BIG_SUR_GE_PFIFO_RXDATA_OFFSET), (unsigned long *)
+					buffer, packet_length);
+
+		reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+		while (reg_data & BIG_SUR_GE_DMASR_BUSY_MASK) {
+			reg_data = big_sur_ge_dma_status(&emac->recv_channel);
+			if (!(reg_data & BIG_SUR_GE_DMASR_BUSY_MASK))
+					break;
+		}	
+
+		if ( (reg_data & BIG_SUR_GE_DMASR_BUS_ERROR_MASK) || 
+			(reg_data & BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK)) {
+				printk(KERN_ERR "DMA Bus Error \n");
+				return -1;
+		}
+	}
+
+	*byte_cnt = packet_length;
+	
+	return 0;
+}
+
+/*
+ * Main FIFO Interrupt Handler
+ */
+void big_sur_ge_fifo_intr(unsigned long data)
+{
+	struct net_device *netdev = (struct net_device *)data;
+	struct big_sur_ge_enet *lp = (struct big_sur_ge_enet *)netdev->priv;
+	big_sur_ge *emac = (big_sur_ge *)lp->emac;
+
+	/* Read the interrupt status */
+	unsigned long int_status = BIG_SUR_GE_READ(emac->base_address +
+							XIIF_V123B_DIPR_OFFSET);
+
+	/* Handle Rx and Tx */
+	if (int_status & BIG_SUR_GE_IPIF_EMAC_MASK)
+		handle_intr(netdev, emac);
+
+	/* Handle Receive Error */
+	if (int_status & BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+		big_sur_ge_check_fifo_recv_error(netdev, emac);
+
+	/* Handle Transmit Error */
+	if (int_status & BIG_SUR_GE_IPIF_SEND_FIFO_MASK)
+		big_sur_ge_check_fifo_send_error(netdev, emac);
+
+	/* Clear the errors */
+	if (int_status & XIIF_V123B_ERROR_MASK)
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DISR_OFFSET, 
+							XIIF_V123B_ERROR_MASK);
+}
+
+/*
+ * Tasklet function to invoke interrupt
+ */
+void big_sur_tasklet_schedule(void *data)
+{
+	struct net_device *netdev = (struct net_device *)data;
+	struct big_sur_ge_enet *lp = (struct big_sur_ge_enet *)netdev->priv;
+
+	tasklet_schedule(&lp->big_sur_tasklet);
+	
+	return;
+}
+
+/*
+ * Main intr handler 
+ */
+static void handle_intr(struct net_device *netdev, big_sur_ge *emac)
+{
+	unsigned long int_status = BIG_SUR_GE_READ(emac->base_address + 
+						XIIF_V123B_IISR_OFFSET);
+
+	/* Process the Rx side */
+	if (int_status & BIG_SUR_GE_EIR_RECV_DONE_MASK) {
+		big_sur_receive(netdev);
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IISR_OFFSET, 
+						BIG_SUR_GE_EIR_RECV_DONE_MASK);
+	}
+
+	/* Process the Tx side */
+	if (int_status & BIG_SUR_GE_EIR_XMIT_DONE_MASK) {
+		big_sur_tx_free_skb(netdev);
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IISR_OFFSET,
+                                                BIG_SUR_GE_EIR_XMIT_DONE_MASK);
+	}
+
+	big_sur_ge_check_mac_error(emac, int_status);
+}
+/*
+ * For now, the MAC address errors dont trigger a update of the 
+ * stats. There is no stats framework in place. Hence, we just
+ * check for the errors below and do a reset if needed. 
+ */
+void big_sur_ge_check_mac_error(big_sur_ge *emac, unsigned long int_status)
+{
+	if (int_status & (BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK | 
+				BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK |
+				BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK |
+				BIG_SUR_GE_EIR_RECV_ERROR_MASK |
+				BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK |
+				BIG_SUR_GE_EIR_RECV_COLLISION_MASK |
+				BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK |
+				BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK |
+				BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK |
+				BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK |
+				BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK |
+				BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK |
+				BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK |
+				BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK |
+				BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK) ) {
+
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IIER_OFFSET, 0);
+		big_sur_ge_enet_reset(emac);
+	}
+}
+
+/*
+ * Check for FIFO Recv errors
+ */
+void big_sur_ge_check_fifo_recv_error(struct net_device *netdev, big_sur_ge *emac)
+{
+	if (BIG_SUR_GE_IS_DEADLOCKED(&emac->recv_fifo)) {
+		unsigned long intr_enable;
+
+		/*
+		 * The only way to ack this interrupt is to reset the 
+		 * device. However, before we reset, we make sure this
+		 * interrupt is disabled
+		 */
+		intr_enable = BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_DIER_OFFSET);
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DIER_OFFSET,
+					(intr_enable & ~(BIG_SUR_GE_IPIF_RECV_FIFO_MASK)));
+
+		/* Reset the device */
+		big_sur_ge_reset(netdev, UNKNOWN);
+
+		/* Turn the interrupts back on */
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DIER_OFFSET,
+					(intr_enable | BIG_SUR_GE_IPIF_RECV_FIFO_MASK));
+
+	}
+}
+
+/*
+ * Check for FIFO Send errors
+ */
+void big_sur_ge_check_fifo_send_error(struct net_device *netdev, big_sur_ge *emac)
+{
+        if (BIG_SUR_GE_IS_DEADLOCKED(&emac->send_fifo)) {
+		unsigned long intr_enable;
+
+		/* Disable the interrupt first */
+		intr_enable = BIG_SUR_GE_READ(emac->base_address + XIIF_V123B_DIER_OFFSET);
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DIER_OFFSET,
+                                        (intr_enable & ~(BIG_SUR_GE_IPIF_SEND_FIFO_MASK)));
+
+		/* Reset the device */
+		big_sur_ge_reset(netdev, UNKNOWN);
+
+		/* Turn the interrupts back on */
+		BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DIER_OFFSET,
+					(intr_enable | BIG_SUR_GE_IPIF_SEND_FIFO_MASK));
+	}
+}
+
+/*
+ * GE unit init
+ */
+int big_sur_ge_enet_init(big_sur_ge *emac, unsigned int device_id)
+{
+	big_sur_ge_config *config;
+	int err;
+	
+	/* Assume that the device has been stopped */
+	config = big_sur_ge_get_config(device_id);
+	if (config == NULL)
+		return -1;
+
+	emac->ready = 0;
+	emac->started = 0;
+	emac->dma_sg = 0; 
+	emac->has_mii = config->has_mii;
+	emac->has_mcast_hash_table = 0;
+	emac->dma_config = config->dma_config;
+	emac->base_address = config->base_address;
+
+	if (big_sur_ge_config_dma(emac) == -1)
+		return -1;
+
+	if (emac->has_dma == 0) {
+		err = big_sur_ge_config_fifo(emac);
+		if (err == -1)
+			return err;
+	}
+
+	/* Now, we know that the FIFO initialized successfully. So, set the ready flag */
+	emac->ready = 1;
+
+	/* Do we need a PHY reset here also. It did cause problems on some boards */	
+	big_sur_ge_enet_reset(emac);
+
+	/* PHY reset code. Remove if causes a problem on the board */
+	big_sur_ge_reset_phy(emac->base_address);
+
+	return 0;
+}
+
+/*
+ * Start the GE unit for Tx, Rx and Interrupts
+ */
+int big_sur_ge_start(big_sur_ge *emac)
+{
+	unsigned long		reg_data;
+	
+	/*
+	 * Basic mode of operation is polled and interrupt mode. 
+	 * We disable the polled mode for good. We may use the 
+	 * polled mode for Rx NAPI but that does not require all 
+	 * the interrupts to be disabled
+	 */
+	emac->polled = 0;
+
+	/*
+ 	 * DMA: Three modes of operation - simple, FIFO, SG. 
+	 * SG is surely not working and so is kept off using the 
+	 * dma_sg flag. Simple and FIFO work. But, we may not use FIFO 
+	 * at all. So, we enable the interrupts below
+	 */
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DIER_OFFSET, 
+				BIG_SUR_GE_IPIF_FIFO_DFT_MASK | XIIF_V123B_ERROR_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_IIER_OFFSET,
+				BIG_SUR_GE_EIR_DFT_FIFO_MASK);
+
+	/* Toggle the started flag */
+	emac->started = 1;
+
+	/* Start the Tx and Rx units respectively */
+	reg_data = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &= ~(BIG_SUR_GE_ECR_XMIT_RESET_MASK | BIG_SUR_GE_ECR_RECV_RESET_MASK);
+	reg_data |= (BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | BIG_SUR_GE_ECR_RECV_ENABLE_MASK);
+	
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET, reg_data);
+
+	return 0;
+}
+
+/*
+ * Stop the GE unit
+ */
+int big_sur_ge_stop(big_sur_ge *emac)
+{
+	unsigned long	reg_data;
+
+	/* We assume that the device is not already stopped */
+	if (!emac->started)
+		return 0;
+
+	/* Disable the Tx and Rx unit respectively */
+	reg_data = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &= ~(BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | BIG_SUR_GE_ECR_RECV_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET, reg_data);
+
+	/* Disable the interrupts */
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_DGIER_OFFSET, 0);
+
+	/* Toggle the started flag */
+	emac->started = 0;
+
+	return 0;
+}
+
+/*
+ * Reset the GE MAC unit 
+ */
+void big_sur_ge_enet_reset(big_sur_ge *emac)
+{
+	unsigned long reg_data;
+
+	(void) big_sur_ge_stop(emac);
+
+	BIG_SUR_GE_WRITE(emac->base_address + XIIF_V123B_RESETR_OFFSET, 
+			XIIF_V123B_RESET_MASK);
+	
+	/*
+         * For now, configure the receiver to not strip off 
+	 * FCS and padding since this is not currently supported. 
+	 * In the future, just take the default and provide the option 
+	 * for the user to change this behavior.
+         */
+	reg_data = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+	reg_data &= ~(BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK | BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK);
+	reg_data &= ~(BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET, reg_data);
+}
+
+/*
+ * Set the MAC address of the GE mac unit 
+ */
+int big_sur_ge_set_mac_address(big_sur_ge *emac, unsigned char *addr)
+{
+	unsigned long	mac_addr = 0;
+
+	/* Device is started and so mac address must be set */
+	if (emac->started == 1)
+		return 0;
+
+	/* Address High */
+	mac_addr = ( (addr[0] << 8) | addr[1]);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_SAH_OFFSET, mac_addr);
+
+	/* Address Low */
+	mac_addr |= ( (addr[2] << 24) | (addr[3] << 16) | 
+			(addr[4] << 8) | addr[5]);
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_SAL_OFFSET, mac_addr);
+	
+	return 0;
+}
+
+/*
+ * Get the MAC address of the GE MAC unit
+ */
+void big_sur_ge_get_mac_unit(big_sur_ge *emac, unsigned int *addr)
+{
+	unsigned long	mac_addr_hi, mac_addr_lo;
+
+	mac_addr_hi = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_SAH_OFFSET);
+	mac_addr_lo = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_SAL_OFFSET);
+
+	addr[0] = (mac_addr_hi >> 8);
+	addr[1] = mac_addr_hi;
+
+	addr[2] = (mac_addr_lo >> 24);
+	addr[3] = (mac_addr_lo >> 16);
+	addr[4] = (mac_addr_lo >> 8);
+	addr[5] = mac_addr_lo;
+}
+
+/*
+ * Configure the GE MAC for DMA capabilities, only Simple
+ */
+static int big_sur_ge_config_dma(big_sur_ge *emac)
+{
+	/* Supports Simple DMA */
+	emac->has_dma = 1;
+
+	if (big_sur_ge_dma_init(&emac->recv_channel, emac->base_address +
+				BIG_SUR_GE_DMA_RECV_OFFSET) == -1) {
+		printk(KERN_ERR "Could not initialize the DMA unit  \n");
+		return -1;
+	}
+
+	if (big_sur_ge_dma_init(&emac->send_channel, emac->base_address +
+                                BIG_SUR_GE_DMA_SEND_OFFSET) == -1) {
+		printk(KERN_ERR "Could not initialize the DMA unit  \n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Configure the FIFO for simple DMA
+ */
+static int big_sur_ge_config_fifo(big_sur_ge *emac)
+{
+	int err = 0;
+
+	/* Receive side packet FIFO */
+	err = packet_fifo_init(&emac->recv_fifo, emac->base_address + 
+				BIG_SUR_GE_PFIFO_RXREG_OFFSET, emac->base_address +
+				BIG_SUR_GE_PFIFO_RXDATA_OFFSET);
+
+	if (err == -1) {
+		printk(KERN_ERR "Could not initialize Rx packet FIFO for Simple DMA \n");
+		return err;
+	}
+
+	/* Send side Packet FIFO */
+	err = packet_fifo_init(&emac->send_fifo, emac->base_address +
+				BIG_SUR_GE_PFIFO_TXREG_OFFSET, emac->base_address +
+				BIG_SUR_GE_PFIFO_TXDATA_OFFSET);
+
+	if (err == -1) {
+		printk(KERN_ERR "Could not initialize Tx packet FIFO for Simple DMA \n");
+	}
+
+	return err;
+}
+
+typedef struct {
+        unsigned long   option;
+        unsigned long   mask;
+} option_map;
+
+static option_map option_table[] = {
+        {BIG_SUR_GE_UNICAST_OPTION, BIG_SUR_GE_ECR_UNICAST_ENABLE_MASK},
+        {BIG_SUR_GE_BROADCAST_OPTION, BIG_SUR_GE_ECR_BROAD_ENABLE_MASK},
+        {BIG_SUR_GE_PROMISC_OPTION, BIG_SUR_GE_ECR_PROMISC_ENABLE_MASK},
+        {BIG_SUR_GE_FDUPLEX_OPTION, BIG_SUR_GE_ECR_FULL_DUPLEX_MASK},
+        {BIG_SUR_GE_LOOPBACK_OPTION, BIG_SUR_GE_ECR_LOOPBACK_MASK},
+        {BIG_SUR_GE_MULTICAST_OPTION, BIG_SUR_GE_ECR_MULTI_ENABLE_MASK},
+        {BIG_SUR_GE_FLOW_CONTROL_OPTION, BIG_SUR_GE_ECR_PAUSE_FRAME_MASK},
+        {BIG_SUR_GE_INSERT_PAD_OPTION, BIG_SUR_GE_ECR_XMIT_PAD_ENABLE_MASK},
+        {BIG_SUR_GE_INSERT_FCS_OPTION, BIG_SUR_GE_ECR_XMIT_FCS_ENABLE_MASK},
+        {BIG_SUR_GE_INSERT_ADDR_OPTION, BIG_SUR_GE_ECR_XMIT_ADDR_INSERT_MASK},
+        {BIG_SUR_GE_OVWRT_ADDR_OPTION, BIG_SUR_GE_ECR_XMIT_ADDR_OVWRT_MASK},
+        {BIG_SUR_GE_STRIP_PAD_OPTION, BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK},
+        {BIG_SUR_GE_STRIP_FCS_OPTION, BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK},
+        {BIG_SUR_GE_STRIP_PAD_FCS_OPTION, BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK}
+};
+
+#define BIG_SUR_GE_NUM_OPTIONS          (sizeof(option_table) / sizeof(option_map))
+
+/*
+ * Set the options for the GE
+ */
+int big_sur_ge_set_options(big_sur_ge *emac, unsigned long option_flag)
+{
+        unsigned long reg_data;
+        unsigned int index;
+
+        /* Assume that the device is stopped before calling this function */
+
+        reg_data = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+        for (index = 0; index < BIG_SUR_GE_NUM_OPTIONS; index++) {
+                if (option_flag & option_table[index].option)
+                        reg_data |= option_table[index].mask;
+                else
+                        reg_data &= ~(option_table[index].mask);
+
+        }
+
+        BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_ECR_OFFSET, reg_data);
+
+        /* No polled option */
+        emac->polled = 0;
+        return 0;
+}
+
+/*
+ * Get the options from the GE
+ */
+unsigned long big_sur_ge_get_options(big_sur_ge *emac)
+{
+        unsigned long option_flag = 0, reg_data;
+        unsigned int index;
+
+        reg_data = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_ECR_OFFSET);
+
+        for (index = 0; index < BIG_SUR_GE_NUM_OPTIONS; index++) {
+                if (option_flag & option_table[index].option)
+                        reg_data |= option_table[index].mask;
+        }
+
+        return option_flag;
+}
+
+/*
+ * Set the Inter frame gap
+ */
+int big_sur_ge_set_frame_gap(big_sur_ge *emac, int part1, int part2)
+{
+        unsigned long config;
+
+        /* Assume that the device is stopped before calling this */
+
+        config = ( (part1 << BIG_SUR_GE_IFGP_PART1_SHIFT) |
+                        (part2 << BIG_SUR_GE_IFGP_PART2_SHIFT) );
+
+        BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_IFGP_OFFSET, config);
+
+        return 0;
+}
+
+/*
+ * Get the Inter frame gap
+ */
+void big_sur_ge_get_frame_gap(big_sur_ge *emac, int *part1, int *part2)
+{
+        unsigned long config;
+
+        config = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_IFGP_OFFSET);
+        *part1 = ((config & BIG_SUR_GE_IFGP_PART1_SHIFT) >> BIG_SUR_GE_IFGP_PART1_SHIFT);
+        *part2 = ((config & BIG_SUR_GE_IFGP_PART2_SHIFT) >> BIG_SUR_GE_IFGP_PART2_SHIFT);
+}
+
+/*
+ * PHY specific functions for the MAC
+ */
+#define	BIG_SUR_GE_MAX_PHY_ADDR		32
+#define	BIG_SUR_GE_MAX_PHY_REG		32
+
+/*
+ * Read the PHY reg
+ */
+int big_sur_ge_phy_read(big_sur_ge *emac, unsigned long addr, 
+				unsigned long reg_num, unsigned int *data)
+{
+	unsigned long mii_control, mii_data;
+
+	if (!emac->has_mii)
+		return -1;
+
+	mii_control = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET);
+	if (mii_control & BIG_SUR_GE_MGTCR_START_MASK) {
+		printk(KERN_ERR "PHY busy \n");
+		return -1;
+	}
+
+	mii_control = (addr << BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT);
+	mii_control |= (reg_num << BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT);
+	mii_control |= (BIG_SUR_GE_MGTCR_RW_NOT_MASK | BIG_SUR_GE_MGTCR_START_MASK |
+				BIG_SUR_GE_MGTCR_MII_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET, mii_control);
+
+	while (mii_control & BIG_SUR_GE_MGTCR_START_MASK) 
+		if (!(mii_control & BIG_SUR_GE_MGTCR_START_MASK))
+			break;
+
+	mii_data = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTDR_OFFSET);
+	*data = (unsigned int) mii_data;
+
+	return 0;
+}
+
+/*
+ * Write to the PHY register
+ */
+int big_sur_ge_phy_write(big_sur_ge *emac, unsigned long addr,
+				unsigned long reg_num, unsigned int data)
+{
+	unsigned long		mii_control;
+
+	if (!emac->has_mii)
+                return -1;
+
+	mii_control = BIG_SUR_GE_READ(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET);
+	if (mii_control & BIG_SUR_GE_MGTCR_START_MASK) {
+                printk(KERN_ERR "PHY busy \n");
+                return -1;
+        }
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTDR_OFFSET, (unsigned long)data);
+	
+	mii_control = (addr << BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT);
+        mii_control |= (reg_num << BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT);
+        mii_control |= (BIG_SUR_GE_MGTCR_START_MASK | BIG_SUR_GE_MGTCR_MII_ENABLE_MASK);
+
+	BIG_SUR_GE_WRITE(emac->base_address + BIG_SUR_GE_MGTCR_OFFSET, mii_control);
+
+	while (mii_control & BIG_SUR_GE_MGTCR_START_MASK)
+                if (!(mii_control & BIG_SUR_GE_MGTCR_START_MASK))
+                        break;
+
+	return 0;
+}
+
+/*
+ * Reset the GE system
+ */
+static void big_sur_ge_reset(struct net_device *netdev, DUPLEX duplex)
+{
+	struct big_sur_ge_enet *lp = (struct big_sur_ge_enet *)netdev->priv;
+	struct sk_buff *skb;
+	unsigned long options;
+	int ifcfg1, ifcfg2;
+
+	/* Stop the queue */
+	netif_stop_queue(netdev);
+
+	big_sur_ge_get_frame_gap(lp->emac, &ifcfg1, &ifcfg2);
+	options = big_sur_ge_get_options(lp->emac);
+	switch (duplex) {
+		case HALF_DUPLEX:
+			options &= ~(BIG_SUR_GE_FDUPLEX_OPTION);
+			break;
+
+		case FULL_DUPLEX:
+			options |= BIG_SUR_GE_FDUPLEX_OPTION;
+			break;
+
+		case UNKNOWN:
+			break;
+	}
+
+	big_sur_ge_enet_reset(lp->emac);
+
+	/* Set the necessary options for the MAC unit */
+	big_sur_ge_set_mac_address(lp->emac, netdev->dev_addr);
+	big_sur_ge_set_frame_gap(lp->emac, ifcfg1, ifcfg2);
+	big_sur_ge_set_options(lp->emac, options);
+
+	(void) big_sur_ge_start(lp->emac);
+
+	spin_lock_irq(lp->lock);
+	skb = lp->saved_skb;
+	lp->saved_skb = NULL;
+	spin_unlock_irq(lp->lock);
+
+	if (skb) 
+		dev_kfree_skb(skb);
+
+	/* Start the queue, in case it was stopped */
+	netif_wake_queue(netdev);
+}
+
+/*
+ * Get the PHY status and then configure the 
+ * speed, duplex, link status etc.
+ */
+static int big_sur_ge_get_phy_status(struct net_device *netdev, 
+					DUPLEX *duplex, int *linkup)
+{
+	struct big_sur_ge_enet  *lp = netdev->priv;
+	unsigned int		reg_data;
+	int			err = 0;
+
+	err = big_sur_ge_phy_read(lp->emac, lp->mii_addr, MII_BMCR, &reg_data);
+	if (err == -1) {
+		printk(KERN_ERR "%s: Could not read PHY control register", netdev->name);
+		return err;
+	}
+
+	if (!(reg_data & BMCR_ANENABLE)) {
+		if (reg_data & BMCR_FULLDPLX) 
+			*duplex = FULL_DUPLEX;
+		else
+			*duplex = HALF_DUPLEX;
+	}
+	else {
+		unsigned int advertise, partner, neg;
+	
+		err = big_sur_ge_phy_read(lp->emac, lp->mii_addr, MII_ADVERTISE, &advertise);
+		if (err == -1) {
+	                printk(KERN_ERR "%s: Could not read PHY control register", netdev->name);
+        	        return err;
+		}
+
+		err = big_sur_ge_phy_read(lp->emac, lp->mii_addr, MII_LPA, &partner);
+		if (err == -1) {
+                        printk(KERN_ERR "%s: Could not read PHY control register", netdev->name);
+                        return err;
+                }
+
+		neg = advertise & partner & ADVERTISE_ALL;
+		if (neg & ADVERTISE_100FULL)
+                        *duplex = FULL_DUPLEX;
+                else if (neg & ADVERTISE_100HALF)
+                        *duplex = HALF_DUPLEX;
+                else if (neg & ADVERTISE_10FULL)
+                        *duplex = FULL_DUPLEX;
+                else
+                        *duplex = HALF_DUPLEX;
+
+		err = big_sur_ge_phy_read(lp->emac, lp->mii_addr, MII_BMSR, &reg_data);
+		if (err == -1) {
+                        printk(KERN_ERR "%s: Could not read PHY control register", netdev->name);
+                        return err;
+                }
+
+		*linkup = (reg_data & BMSR_LSTATUS) != 0;
+
+	}
+	return 0;
+}
+
+/*
+ * Poll the MII for duplex and link status 
+ */
+static void big_sur_ge_poll_mii(unsigned long data)
+{
+	struct net_device *netdev = (struct net_device *) data;	
+	struct big_sur_ge_enet* lp = netdev->priv;
+	unsigned long options;
+	DUPLEX mac_duplex, phy_duplex;
+	int phy_carrier, netif_carrier;
+
+	if (big_sur_ge_get_phy_status(netdev, &phy_duplex, &phy_carrier) == -1) {
+		printk(KERN_ERR "%s: Terminating link monitoring.\n", netdev->name);
+		return;
+	}
+
+	options = big_sur_ge_get_options(lp->emac);
+	if (options & BIG_SUR_GE_FDUPLEX_OPTION)
+		mac_duplex = FULL_DUPLEX;
+	else
+		mac_duplex = HALF_DUPLEX;
+
+	if (mac_duplex != phy_duplex) {
+		tasklet_disable(&lp->big_sur_tasklet);
+		big_sur_ge_reset(netdev, phy_duplex);
+		tasklet_enable(&lp->big_sur_tasklet);
+	}
+
+	netif_carrier = netif_carrier_ok(netdev) != 0;
+
+        if (phy_carrier != netif_carrier) {
+                if (phy_carrier) {
+                        printk(KERN_INFO "%s: Link carrier restored.\n",
+                               netdev->name);
+                        netif_carrier_on(netdev);
+                } else {
+                        printk(KERN_INFO "%s: Link carrier lost.\n", netdev->name);
+                        netif_carrier_off(netdev);
+                }
+        }
+
+        /* Set up the timer so we'll get called again in 2 seconds. */
+        lp->phy_timer.expires = jiffies + 2 * HZ;
+        add_timer(&lp->phy_timer);
+}
+
+/*
+ * Open the network interface
+ */
+static int big_sur_ge_open(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	unsigned long options;
+	DUPLEX phy_duplex, mac_duplex;
+	int phy_carrier;
+
+	(void) big_sur_ge_stop(lp->emac);
+
+	if (big_sur_ge_set_mac_address(lp->emac, netdev->dev_addr) == -1) {
+		printk(KERN_ERR "%s: Could not set MAC address.\n", netdev->name);
+		return -EIO;
+	}
+
+	options = big_sur_ge_get_options(lp->emac);
+
+	/*
+	 * This MAC unit has no support for Interrupts. So, we initialize
+	 * a tasklet here that will be scheduled from the timer
+	 * interrupt handler. Note that we cannot run the receive
+	 * and the transmit functions as part of an interrupt handler. Since,
+	 * this will be disastrous for the timer under load. Hence, tasklet
+	 * is the best way to go
+	 */
+	tasklet_init(&lp->big_sur_tasklet, big_sur_ge_fifo_intr, (unsigned long)netdev);
+
+	if (!(big_sur_ge_get_phy_status(netdev, &phy_duplex, &phy_carrier))) {
+		if (options & BIG_SUR_GE_FDUPLEX_OPTION)
+			mac_duplex = FULL_DUPLEX;
+		else
+			mac_duplex = HALF_DUPLEX;
+
+		if (mac_duplex != phy_duplex) {
+			switch (phy_duplex) {
+				case HALF_DUPLEX: 
+					options &= ~(BIG_SUR_GE_FDUPLEX_OPTION); 
+					break;
+				case FULL_DUPLEX:
+					options |= BIG_SUR_GE_FDUPLEX_OPTION;
+					break;
+				case UNKNOWN:
+					break;
+			}
+
+			big_sur_ge_set_options(lp->emac, options);
+		}
+	}
+
+	if (big_sur_ge_start(lp->emac) == -1) {
+		printk(KERN_ERR "%s: Could not start device.\n", netdev->name);
+		tasklet_kill(&lp->big_sur_tasklet);
+		return -EBUSY;
+	}
+
+	MOD_INC_USE_COUNT;
+	netif_start_queue(netdev);
+
+	lp->phy_timer.expires = jiffies + 2*HZ;
+        lp->phy_timer.data = (unsigned long)netdev;
+        lp->phy_timer.function = &big_sur_ge_poll_mii;
+	add_timer(&lp->phy_timer);
+
+	return 0;
+}
+
+/*
+ * Close the network device interface
+ */
+static int big_sur_ge_close(struct net_device *netdev)
+{
+	struct big_sur_ge_enet  *lp = netdev->priv;
+	
+	del_timer_sync(&lp->phy_timer);
+	netif_stop_queue(netdev);
+
+	if (big_sur_ge_stop(lp->emac) == -1) {
+		printk(KERN_ERR "%s: Could not stop device.\n", netdev->name);
+		return -EBUSY;
+        }
+
+	tasklet_kill(&lp->big_sur_tasklet);
+
+        MOD_DEC_USE_COUNT;
+        return 0;
+}
+
+/*	
+ * Get the network device stats. 
+ */
+static struct net_device_stats *big_sur_ge_get_stats(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	
+	return lp->stats;
+}
+
+/*
+ * FIFO send for a packet that needs to be transmitted
+ */
+static int big_sur_start_xmit(struct sk_buff *orig_skb, struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *new_skb;
+	unsigned int len, align;
+	struct net_device_stats *stats = lp->stats;
+
+	/* 
+	 * The FIFO takes a single request at a time. Stop the queue to
+	 * accomplish this.  We'll wake the queue in the transmit
+	 * routine below or in the timeout routine
+	 */
+	netif_stop_queue(netdev);
+        len = orig_skb->len;
+
+	/*
+	 * Align the packet for the FIFO
+	 */
+	if (!(new_skb = dev_alloc_skb(len + 4))) {
+                dev_kfree_skb(orig_skb);
+                printk(KERN_ERR "%s: Could not allocate transmit buffer.\n",
+                       netdev->name);
+                netif_wake_queue(netdev);
+                return -EBUSY;
+        }
+
+	align = 4 - ((unsigned long) new_skb->data & 3);
+        if (align != 4)
+                skb_reserve(new_skb, align);
+
+	skb_put(new_skb, len);
+        memcpy(new_skb->data, orig_skb->data, len);
+
+	dev_kfree_skb(orig_skb);
+	lp->saved_skb = new_skb;
+
+	/* Do the actual transmit */
+	if (big_sur_tx(lp->emac, (u8 *) new_skb->data, len) == -1) {
+		spin_lock_irq(&lp->lock);
+                new_skb = lp->saved_skb;
+                lp->saved_skb = NULL;
+                spin_unlock_irq(&lp->lock);
+
+                dev_kfree_skb(new_skb);
+                printk(KERN_ERR "%s: Could not transmit buffer.\n", netdev->name);
+                netif_wake_queue(netdev);
+                return -EIO;
+        }
+
+	stats->tx_bytes += len;
+	stats->tx_packets++;
+
+        return 0;
+}
+
+/*
+ * Free the skb
+ */
+static void big_sur_tx_free_skb(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct sk_buff *skb;
+
+	spin_lock_irq(&lp->lock);
+	skb = lp->saved_skb;
+        lp->saved_skb = NULL;
+        spin_unlock_irq(&lp->lock);
+	
+	if (skb)
+		dev_kfree_skb(skb);
+
+	/* Start the queue since we know that packet has been transmitted */
+        netif_wake_queue(netdev);
+}
+
+/*
+ * Handle the timeout of the ethernet device 
+ */
+static void big_sur_ge_tx_timeout(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = (struct big_sur_ge_enet *)netdev;
+
+	printk("%s: Exceeded transmit timeout of %lu ms.  Resetting mac.\n",
+			netdev->name, TX_TIMEOUT * 1000UL / HZ);
+
+	tasklet_disable(&lp->big_sur_tasklet);
+	big_sur_ge_reset(netdev, UNKNOWN);
+	tasklet_enable(&lp->big_sur_tasklet);
+}
+
+/*
+ * Receive the packets
+ */
+static void big_sur_receive(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = (struct big_sur_ge_enet *)netdev->priv;
+	struct sk_buff *skb;
+	unsigned long len = BIG_SUR_GE_MAX_FRAME_SIZE;
+	unsigned int align;
+	struct net_device_stats *stats = lp->stats;
+	
+	if (!(skb = dev_alloc_skb(len + 4))) {
+		printk(KERN_ERR "%s: Could not allocate receive buffer.\n",
+			netdev->name);
+		return;
+	}
+
+	align = 4 - ((unsigned long) skb->data & 3);
+        if (align != 4)
+                skb_reserve(skb, align);
+
+	if (big_sur_rx(lp->emac, (u8 *)skb->data, &len) == -1) {
+		dev_kfree_skb(skb);
+		
+		printk(KERN_ERR "%s: Could not receive buffer \n", netdev->name);
+		netdev->tx_timeout = NULL;
+		big_sur_ge_reset(netdev, UNKNOWN);
+		netdev->tx_timeout = big_sur_ge_tx_timeout;
+	}
+
+	skb_put(skb, len);
+        skb->dev = netdev;
+        skb->protocol = eth_type_trans(skb, netdev);
+
+	stats->rx_packets++;
+	stats->rx_bytes += len;
+
+	/* Good Rx, send the packet upstream. */
+	netif_rx(skb);
+}
+
+/*
+ * Set the Multicast Hash list
+ */
+static void big_sur_ge_set_multi(struct net_device *netdev)
+{
+	struct big_sur_ge_enet *lp = (struct big_sur_ge_enet *)netdev->priv;
+	unsigned long options;
+
+	tasklet_disable(&lp->big_sur_tasklet);
+
+	(void) big_sur_ge_stop(lp->emac);
+	options = big_sur_ge_get_options(lp->emac);
+	options &= ~(BIG_SUR_GE_PROMISC_OPTION | BIG_SUR_GE_MULTICAST_OPTION);
+
+	if (netdev->flags & IFF_PROMISC) 
+		options |= BIG_SUR_GE_PROMISC_OPTION;
+	
+	(void) big_sur_ge_start(lp->emac);
+
+	tasklet_enable(&lp->big_sur_tasklet);
+}	
+
+/*
+ * IOCTL support
+ */
+static int big_sur_ge_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
+{
+	struct big_sur_ge_enet *lp = netdev->priv;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *) &rq->ifr_data;
+
+	switch(cmd) {
+		case SIOCGMIIPHY:       	/* Get address of MII PHY in use. */
+	        case SIOCDEVPRIVATE:    	/* for binary compat, remove in 2.5 */
+                	data->phy_id = lp->mii_addr;
+
+        	case SIOCGMIIREG:   	    	/* Read MII PHY register. */
+	        case SIOCDEVPRIVATE + 1: 	/* for binary compat, remove in 2.5 */
+                	if (data->phy_id > 31 || data->reg_num > 31)
+                        	return -ENXIO;
+
+                	del_timer_sync(&lp->phy_timer);
+
+			if (big_sur_ge_phy_read(lp->emac, data->phy_id, 
+						data->reg_num, &data->val_out) == -1) {
+				printk(KERN_ERR "%s: Could not read from PHY", netdev->name);
+				return -EBUSY;
+			}
+
+			lp->phy_timer.expires = jiffies + 2*HZ;
+	                add_timer(&lp->phy_timer);
+				
+			return 0;
+
+		case SIOCSMIIREG:       	/* Write MII PHY register. */
+	        case SIOCDEVPRIVATE + 2:        /* for binary compat, remove in 2.5 */
+			if (data->phy_id > 31 || data->reg_num > 31)
+				return -ENXIO;
+	
+			del_timer_sync(&lp->phy_timer);
+
+			if (big_sur_ge_phy_write(lp->emac, data->phy_id, data->reg_num,
+							data->val_in) == -1) {
+				printk(KERN_ERR "%s: Could not write to PHY", netdev->name);
+				return -EBUSY;
+			}
+
+			lp->phy_timer.expires = jiffies + 2*HZ;
+			add_timer(&lp->phy_timer);
+
+			return 0;
+
+		default:
+			return -EOPNOTSUPP;
+	}
+}
+
+/*
+ * Get the config from the config table 
+ */
+big_sur_ge_config *big_sur_ge_get_config(int index)
+{	
+	/* For port 0 only */
+	big_sur_ge_config *config;
+
+	config->device_id = 0;
+	config->base_address = BIG_SUR_GE_BASE; /* Base Address of the MAC */
+	config->has_counters = 0;
+	config->has_sg_dma = 0;
+	config->dma_config = 0;
+	config->has_mii = 1;
+
+	return (big_sur_ge_config *)config;
+}
+
+/*
+ * Release the network device structure
+ */
+static void big_sur_ge_remove_dev(struct net_device *netdev)
+{
+	struct big_sur_ge_enet  *lp = (struct big_sur_ge_enet *)netdev;
+	big_sur_ge_config	*config;
+
+	config = big_sur_ge_get_config(lp->index);
+	config->base_address = lp->save_base_address;
+	
+	if (lp->saved_skb)
+                dev_kfree_skb(lp->saved_skb);
+        kfree(lp);
+
+        unregister_netdev(netdev);
+        kfree(netdev);
+}
+
+/*
+ * Initial Function to probe the network interface 
+ */
+static int __init big_sur_ge_probe(int index)
+{
+	struct net_device *netdev;
+	struct big_sur_ge_enet *lp;
+	big_sur_ge_config *config;
+	unsigned long maddr;
+
+	config = big_sur_ge_get_config(index);
+	if (!config)
+		return -ENODEV;
+
+	netdev = alloc_etherdev(sizeof(struct big_sur_ge_enet));
+
+	if (!netdev) {
+		printk(KERN_ERR "Could not allocate Big Sur Ethernet device %d.\n",index);
+		return -ENOMEM;
+	}
+
+	SET_MODULE_OWNER(netdev);
+
+	lp = (struct big_sur_ge_enet *)netdev->priv;
+	memset(lp, 0, sizeof(struct big_sur_ge_enet));
+	spin_lock_init(&lp->lock);
+	
+	/* Use KSEG1 address */
+	lp->save_base_address = config->base_address;
+	
+	if (big_sur_ge_enet_init(lp->emac, config->device_id) == -1) {
+		printk(KERN_ERR "%s: Could not initialize device.\n", netdev->name);
+		big_sur_ge_remove_dev(netdev);
+		return -ENODEV;
+	}
+
+	memcpy(netdev->dev_addr, big_sur_mac_addr_base, 6);
+	if (big_sur_ge_set_mac_address(lp->emac, netdev->dev_addr) == -1) {
+		printk(KERN_ERR "%s: Could not set MAC address.\n", netdev->name);
+		big_sur_ge_remove_dev(netdev);
+                return -EIO;
+        }
+
+	/* Check the PHY */	
+	lp->mii_addr = 0xff;
+	for (maddr = 0; maddr < 31; maddr++) {
+		unsigned int	reg_data;
+
+		if (big_sur_ge_phy_read(lp->emac, maddr, MII_BMCR, &reg_data) == 0) {
+			lp->mii_addr = maddr;
+                        break;
+                }
+	}
+
+	if (lp->mii_addr == 0xff) {
+                lp->mii_addr = 0;
+                printk(KERN_WARNING
+                       "%s: No PHY detected.  Assuming a PHY at address %d.\n",
+					netdev->name, lp->mii_addr);
+	}
+
+	netdev->open = big_sur_ge_open;
+	netdev->stop = big_sur_ge_close;
+	netdev->get_stats = big_sur_ge_get_stats; 
+	netdev->do_ioctl = big_sur_ge_ioctl;
+	netdev->tx_timeout = big_sur_ge_tx_timeout;
+	netdev->watchdog_timeo = TX_TIMEOUT;
+	netdev->hard_start_xmit = big_sur_start_xmit;
+	netdev->set_multicast_list = big_sur_ge_set_multi;
+
+	printk(KERN_INFO
+               "%s: PMC-Sierra Big Sur Ethernet Device %d  at 0x%08X mapped to 0x%08X\n",
+		netdev->name, index,
+               lp->save_base_address, config->base_address);
+
+        return 0;
+}
+	
+static int __init big_sur_ge_init(void)
+{
+	int	index = 0;
+
+	while (big_sur_ge_probe(index++) == 0);
+
+	return (index > 1) ? 0 : -ENODEV;
+}
+
+static void __init big_sur_ge_cleanup_module(void)
+{
+	/* Nothing to do here */
+}
+
+module_init(big_sur_ge_init);
+module_exit(big_sur_ge_cleanup_module);
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/big_sur_ge.h linux-mips-cvs-20040815/drivers/net/big_sur_ge.h
--- linux-2.4.27/drivers/net/big_sur_ge.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/big_sur_ge.h	2004-08-15 08:06:18.000000000 +0200
@@ -0,0 +1,449 @@
+/*
+ * drivers/net/big_sur_ge.h - Driver for PMC-Sierra Big Sur
+ * ethernet ports
+ *
+ * Copyright (C) 2003, 2004 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#ifndef	__BIG_SUR_GE_H__
+#define	__BIG_SUR_GE_H__
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#define	BIG_SUR_DEVICE_NAME	"big sur"
+#define	BIG_SUR_DEVICE_DESC	"Big Sur Ethernet 10/100 MAC"
+
+#define BIG_SUR_GE_BASE		(0x1b000000 | KSEG1)
+
+#define	BIG_SUR_GE_WRITE(ofs,data)			\
+	*(volatile u32 *)(BIG_SUR_GE_BASE+(ofs)) = data
+
+#define	BIG_SUR_GE_READ(ofs)				\
+	*(volatile u32 *)(BIG_SUR_GE_BASE+(ofs))
+
+#define	BIG_SUR_GE_READ_REG(base_addr, reg_offset)	\
+	BIG_SUR_GE_READ(base_addr + reg_offset)
+
+#define	BIG_SUR_GE_WRITE_REG(base_addr, reg_offset, data)	\
+	BIG_SUR_GE_WRITE(base_addr + reg_offset, data)
+
+#define	BIG_SUR_GE_CONTROL_REG(base_addr, mask)		\
+	BIG_SUR_GE_WRITE(base_addr + BIG_SUR_GE_ECR_OFFSET, mask)
+
+#define	BIG_SUR_GE_FIFO_WIDTH_BYTE_COUNT	4UL
+
+/* IPIF specific defines */
+#define XIIF_V123B_DISR_OFFSET     0UL  /* device interrupt status register */
+#define XIIF_V123B_DIPR_OFFSET     4UL  /* device interrupt pending register */
+#define XIIF_V123B_DIER_OFFSET     8UL  /* device interrupt enable register */
+#define XIIF_V123B_DIIR_OFFSET     24UL /* device interrupt ID register */
+#define XIIF_V123B_DGIER_OFFSET    28UL /* device global interrupt enable reg */
+#define XIIF_V123B_IISR_OFFSET     32UL /* IP interrupt status register */
+#define XIIF_V123B_IIER_OFFSET     40UL /* IP interrupt enable register */
+#define XIIF_V123B_RESETR_OFFSET   64UL /* reset register */
+#define XIIF_V123B_RESET_MASK	   0xAUL
+#define	XIIF_V123B_ERROR_MASK	   0x1UL
+
+/* Options for the MAC */
+#define BIG_SUR_GE_UNICAST_OPTION        	0x00000001
+#define BIG_SUR_GE_BROADCAST_OPTION      	0x00000002
+#define BIG_SUR_GE_PROMISC_OPTION        	0x00000004
+#define BIG_SUR_GE_FDUPLEX_OPTION        	0x00000008
+#define BIG_SUR_GE_POLLED_OPTION         	0x00000010
+#define BIG_SUR_GE_LOOPBACK_OPTION       	0x00000020
+#define BIG_SUR_GE_FLOW_CONTROL_OPTION   	0x00000080
+#define BIG_SUR_GE_INSERT_PAD_OPTION     	0x00000100
+#define BIG_SUR_GE_INSERT_FCS_OPTION     	0x00000200
+#define BIG_SUR_GE_INSERT_ADDR_OPTION    	0x00000400
+#define BIG_SUR_GE_OVWRT_ADDR_OPTION     	0x00000800
+#define BIG_SUR_GE_STRIP_PAD_FCS_OPTION  	0x00002000
+#define BIG_SUR_GE_MULTICAST_OPTION      	0x00000040
+#define BIG_SUR_GE_FLOW_CONTROL_OPTION   	0x00000080
+#define BIG_SUR_GE_INSERT_PAD_OPTION     	0x00000100
+#define BIG_SUR_GE_INSERT_FCS_OPTION     	0x00000200
+#define BIG_SUR_GE_INSERT_ADDR_OPTION    	0x00000400
+#define BIG_SUR_GE_OVWRT_ADDR_OPTION     	0x00000800
+#define BIG_SUR_GE_STRIP_PAD_OPTION      	0x00001000
+#define BIG_SUR_GE_STRIP_FCS_OPTION     	0x00002000
+
+#define BIG_SUR_GE_MTU             1500	/* max size of Ethernet frame */
+#define BIG_SUR_GE_HDR_SIZE        14	/* size of Ethernet header */
+#define BIG_SUR_GE_HDR_VLAN_SIZE   18	/* size of Ethernet header with VLAN */
+#define BIG_SUR_GE_TRL_SIZE        4 	/* size of Ethernet trailer (FCS) */
+#define BIG_SUR_GE_MAX_FRAME_SIZE  \
+		(BIG_SUR_GE_MTU + BIG_SUR_GE_HDR_SIZE + BIG_SUR_GE_TRL_SIZE)
+
+#define BIG_SUR_GE_MAX_VLAN_FRAME_SIZE  \
+		(BIG_SUR_GE_MTU + BIG_SUR_GE_HDR_VLAN_SIZE + BIG_SUR_GE_TRL_SIZE)
+
+/* FIFO Specific Defines */
+#define BIG_SUR_GE_RESET_REG_OFFSET            0UL
+#define BIG_SUR_GE_MODULE_INFO_REG_OFFSET      0UL
+#define BIG_SUR_GE_COUNT_STATUS_REG_OFFSET     4UL
+#define BIG_SUR_GE_RESET_FIFO_MASK             0x0000000A
+#define BIG_SUR_GE_COUNT_MASK                  0x0000FFFF
+#define BIG_SUR_GE_DEADLOCK_MASK               0x20000000
+#define BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK      0x40000000
+#define BIG_SUR_GE_EMPTY_FULL_MASK             0x80000000
+
+#define BIG_SUR_GE_FIFO_RESET(fifo)				\
+		BIG_SUR_GE_WRITE((fifo)->reg_base_addr + 	\
+		BIG_SUR_GE_RESET_REG_OFFSET, BIG_SUR_GE_RESET_FIFO_MASK)
+
+#define	BIG_SUR_GE_GET_COUNT(fifo)			\
+	(BIG_SUR_GE_READ((fifo)->reg_base_addr + 	\
+	BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) & BIG_SUR_GE_COUNT_MASK)
+
+#define	BIG_SUR_GE_IS_ALMOST_EMPTY(fifo)		\
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + 	\
+		BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &	\
+		BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK)
+
+#define	BIG_SUR_GE_IS_ALMOST_FULL(fifo)  		\
+		(BIG_SUR_GE_READ(fifo->reg_base_addr + 	\
+		BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+		BIG_SUR_GE_ALMOST_EMPTY_FULL_MASK)
+
+#define BIG_SUR_GE_IS_EMPTY(fifo)  			\
+		(BIG_SUR_GE_READ(fifo->reg_base_addr +	\
+		BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   \
+		BIG_SUR_GE_EMPTY_FULL_MASK)
+
+#define BIG_SUR_GE_IS_FULL(fifo)  			\
+	(BIG_SUR_GE_READ(fifo->reg_base_addr + 		\
+	BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   	\
+	BIG_SUR_GE_EMPTY_FULL_MASK)
+
+#define	BIG_SUR_GE_IS_DEADLOCKED(fifo)			\
+	(BIG_SUR_GE_READ((fifo)->reg_base_addr + 	\
+	BIG_SUR_GE_COUNT_STATUS_REG_OFFSET) &   	\
+	BIG_SUR_GE_DEADLOCK_MASK)
+
+/* Device Config */
+typedef struct _big_sur_ge_config {
+	u16 device_id;
+	u32 base_address;
+	u32 has_counters;
+	u32 has_sg_dma;
+	u8 dma_config;
+	u32 has_mii;
+} big_sur_ge_config;
+
+/* Send and Receive DMA channel */
+typedef struct _xdma_channel_tag {
+	u32 reg_base_address;
+        u32 base_address;
+        u32 ready;
+} xdma_channel;
+
+/* Send and Receive Packet FIFO */
+typedef struct _packet_fifo {
+        u32 reg_base_addr;
+        u32 ready_status;
+        u32 data_base_address;
+} packet_fifo;
+
+/* Big Sur GE driver structure */
+typedef struct _big_sur_ge {
+	u32 base_address;
+	u32 started;
+	u32 ready;
+	u32 polled;
+	u32 dma_sg;
+	u8 dma_config;
+	u32 has_mii;
+	u32 has_mcast_hash_table;
+	/* For the FIFO and simple DMA case only */
+	packet_fifo recv_fifo;
+	packet_fifo send_fifo;
+	xdma_channel	recv_channel;
+	xdma_channel	send_channel;
+
+	u8 has_dma;
+} big_sur_ge;
+
+/* Offset of the MAC registers from the IPIF base address */
+#define BIG_SUR_GE_REG_OFFSET     0x1100UL
+
+/*
+ * Register offsets for the Ethernet MAC. Each register is 32 bits.
+ */
+#define BIG_SUR_GE_EMIR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x0) /* EMAC Module ID */
+#define BIG_SUR_GE_ECR_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x4) /* MAC Control */
+#define BIG_SUR_GE_IFGP_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x8) /* Interframe Gap */
+#define BIG_SUR_GE_SAH_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0xC) /* Station addr, high */
+#define BIG_SUR_GE_SAL_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x10)/* Station addr, low */
+#define BIG_SUR_GE_MGTCR_OFFSET  (BIG_SUR_GE_REG_OFFSET + 0x14)/* MII mgmt control */
+#define BIG_SUR_GE_MGTDR_OFFSET  (BIG_SUR_GE_REG_OFFSET + 0x18)/* MII mgmt data */
+#define BIG_SUR_GE_RPLR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x1C)/* Rx packet length */
+#define BIG_SUR_GE_TPLR_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x20)/* Tx packet length */
+#define BIG_SUR_GE_TSR_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x24)/* Tx status */
+#define BIG_SUR_GE_RMFC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x28)/* Rx missed frames */
+#define BIG_SUR_GE_RCC_OFFSET    (BIG_SUR_GE_REG_OFFSET + 0x2C)/* Rx collisions */
+#define BIG_SUR_GE_RFCSEC_OFFSET (BIG_SUR_GE_REG_OFFSET + 0x30)/* Rx FCS errors */
+#define BIG_SUR_GE_RAEC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x34)/* Rx alignment errors */
+
+/* Transmit excess deferral cnt */
+#define BIG_SUR_GE_TEDC_OFFSET   (BIG_SUR_GE_REG_OFFSET + 0x38)
+
+/* Interrupt Status Register */
+#define BIG_SUR_GE_ISR_OFFSET           0x20UL 
+
+/* Send and Receive DMA Channel */
+#define BIG_SUR_GE_DMA_OFFSET           0x2300UL
+#define BIG_SUR_GE_DMA_SEND_OFFSET      (BIG_SUR_GE_DMA_OFFSET + 0x0) 
+#define BIG_SUR_GE_DMA_RECV_OFFSET      (BIG_SUR_GE_DMA_OFFSET + 0x40)
+
+/* Packet FIFO */
+#define BIG_SUR_GE_PFIFO_OFFSET         0x2000UL
+#define BIG_SUR_GE_PFIFO_TXREG_OFFSET   (BIG_SUR_GE_PFIFO_OFFSET + 0x0) 
+#define BIG_SUR_GE_PFIFO_RXREG_OFFSET   (BIG_SUR_GE_PFIFO_OFFSET + 0x10)
+#define BIG_SUR_GE_PFIFO_TXDATA_OFFSET  (BIG_SUR_GE_PFIFO_OFFSET + 0x100) 
+#define BIG_SUR_GE_PFIFO_RXDATA_OFFSET  (BIG_SUR_GE_PFIFO_OFFSET + 0x200)
+
+/*
+ * EMAC Module Identification Register (EMIR)
+ */
+#define BIG_SUR_GE_EMIR_VERSION_MASK    0xFFFF0000UL   /* Device version */
+#define BIG_SUR_GE_EMIR_TYPE_MASK       0x0000FF00UL   /* Device type */
+
+/*
+ * EMAC Control Register (ECR)
+ */
+#define BIG_SUR_GE_ECR_FULL_DUPLEX_MASK         0x80000000   /* Full duplex mode */
+#define BIG_SUR_GE_ECR_XMIT_RESET_MASK          0x40000000   /* Reset transmitter */
+#define BIG_SUR_GE_ECR_XMIT_ENABLE_MASK         0x20000000   /* Enable transmitter */
+#define BIG_SUR_GE_ECR_RECV_RESET_MASK          0x10000000   /* Reset receiver */
+#define BIG_SUR_GE_ECR_RECV_ENABLE_MASK         0x08000000   /* Enable receiver */
+#define BIG_SUR_GE_ECR_PHY_ENABLE_MASK          0x04000000   /* Enable PHY */
+#define BIG_SUR_GE_ECR_XMIT_PAD_ENABLE_MASK     0x02000000   /* Enable xmit pad insert */
+#define BIG_SUR_GE_ECR_XMIT_FCS_ENABLE_MASK     0x01000000   /* Enable xmit FCS insert */
+#define BIG_SUR_GE_ECR_XMIT_ADDR_INSERT_MASK    0x00800000   /* Enable xmit source addr insertion */
+#define BIG_SUR_GE_ECR_XMIT_ERROR_INSERT_MASK   0x00400000   /* Insert xmit error */
+#define BIG_SUR_GE_ECR_XMIT_ADDR_OVWRT_MASK     0x00200000   /* Enable xmit source addr overwrite */
+#define BIG_SUR_GE_ECR_LOOPBACK_MASK            0x00100000   /* Enable internal loopback */
+#define BIG_SUR_GE_ECR_RECV_PAD_ENABLE_MASK     0x00080000   /* Enable recv pad strip */
+#define BIG_SUR_GE_ECR_RECV_FCS_ENABLE_MASK     0x00040000   /* Enable recv FCS strip */
+#define BIG_SUR_GE_ECR_RECV_STRIP_ENABLE_MASK   0x00080000   /* Enable recv pad/fcs strip */
+#define BIG_SUR_GE_ECR_UNICAST_ENABLE_MASK      0x00020000   /* Enable unicast addr */
+#define BIG_SUR_GE_ECR_MULTI_ENABLE_MASK        0x00010000   /* Enable multicast addr */
+#define BIG_SUR_GE_ECR_BROAD_ENABLE_MASK        0x00008000   /* Enable broadcast addr */
+#define BIG_SUR_GE_ECR_PROMISC_ENABLE_MASK      0x00004000   /* Enable promiscuous mode */
+#define BIG_SUR_GE_ECR_RECV_ALL_MASK            0x00002000   /* Receive all frames */
+#define BIG_SUR_GE_ECR_RESERVED2_MASK           0x00001000   /* Reserved */
+#define BIG_SUR_GE_ECR_MULTI_HASH_ENABLE_MASK   0x00000800   /* Enable multicast hash */
+#define BIG_SUR_GE_ECR_PAUSE_FRAME_MASK         0x00000400   /* Interpret pause frames */
+#define BIG_SUR_GE_ECR_CLEAR_HASH_MASK          0x00000200   /* Clear hash table */
+#define BIG_SUR_GE_ECR_ADD_HASH_ADDR_MASK       0x00000100  /* Add hash table address */
+
+/*
+ * Interframe Gap Register (IFGR)
+ */
+#define BIG_SUR_GE_IFGP_PART1_MASK         0xF8000000        /* Interframe Gap Part1 */
+#define BIG_SUR_GE_IFGP_PART1_SHIFT        27
+#define BIG_SUR_GE_IFGP_PART2_MASK         0x07C00000        /* Interframe Gap Part2 */
+#define BIG_SUR_GE_IFGP_PART2_SHIFT        22
+
+/*
+ * Station Address High Register (SAH)
+ */
+#define BIG_SUR_GE_SAH_ADDR_MASK           0x0000FFFF        /* Station address high bytes */
+
+/*
+ * Station Address Low Register (SAL)
+ */
+#define BIG_SUR_GE_SAL_ADDR_MASK           0xFFFFFFFF        /* Station address low bytes */
+
+/*
+ * MII Management Control Register (MGTCR)
+ */
+#define BIG_SUR_GE_MGTCR_START_MASK        0x80000000        /* Start/Busy */
+#define BIG_SUR_GE_MGTCR_RW_NOT_MASK       0x40000000        /* Read/Write Not (direction) */
+#define BIG_SUR_GE_MGTCR_PHY_ADDR_MASK     0x3E000000        /* PHY address */
+#define BIG_SUR_GE_MGTCR_PHY_ADDR_SHIFT    25  /* PHY address shift */
+#define BIG_SUR_GE_MGTCR_REG_ADDR_MASK     0x01F00000        /* Register address */
+#define BIG_SUR_GE_MGTCR_REG_ADDR_SHIFT    20  /* Register addr shift */
+#define BIG_SUR_GE_MGTCR_MII_ENABLE_MASK   0x00080000        /* Enable MII from EMAC */
+#define BIG_SUR_GE_MGTCR_RD_ERROR_MASK     0x00040000        /* MII mgmt read error */
+
+/*
+ * MII Management Data Register (MGTDR)
+ */
+#define BIG_SUR_GE_MGTDR_DATA_MASK         0x0000FFFF        /* MII data */
+
+/*
+ * Receive Packet Length Register (RPLR)
+ */
+#define BIG_SUR_GE_RPLR_LENGTH_MASK        0x0000FFFF        /* Receive packet length */
+
+/*
+ * Transmit Packet Length Register (TPLR)
+ */
+#define BIG_SUR_GE_TPLR_LENGTH_MASK        0x0000FFFF       /* Transmit packet length */
+
+/*
+ * Transmit Status Register (TSR)
+ */
+#define BIG_SUR_GE_TSR_EXCESS_DEFERRAL_MASK 0x80000000       /* Transmit excess deferral */
+#define BIG_SUR_GE_TSR_FIFO_UNDERRUN_MASK   0x40000000       /* Packet FIFO underrun */
+#define BIG_SUR_GE_TSR_ATTEMPTS_MASK        0x3E000000      /* Transmission attempts */
+#define BIG_SUR_GE_TSR_LATE_COLLISION_MASK  0x01000000      /* Transmit late collision */
+
+/* Receive Missed Frame Count (RMFC) */
+#define BIG_SUR_GE_RMFC_DATA_MASK          0x0000FFFF
+
+/* Receive Collision Count (RCC) */
+#define BIG_SUR_GE_RCC_DATA_MASK           0x0000FFFF
+
+/* Receive FCS Error Count (RFCSEC) */
+#define BIG_SUR_GE_RFCSEC_DATA_MASK        0x0000FFFF
+
+/* Receive Alignment Error Count (RALN) */
+#define BIG_SUR_GE_RAEC_DATA_MASK          0x0000FFFF
+
+/* Transmit Excess Deferral Count (TEDC) */
+#define BIG_SUR_GE_TEDC_DATA_MASK          0x0000FFFF
+
+/*
+ * EMAC Interrupt Registers (Status and Enable) masks. These registers are
+ * part of the IPIF IP Interrupt registers
+ */
+#define BIG_SUR_GE_EIR_XMIT_DONE_MASK         0x00000001     /* Xmit complete */
+#define BIG_SUR_GE_EIR_RECV_DONE_MASK         0x00000002     /* Recv complete */
+#define BIG_SUR_GE_EIR_XMIT_ERROR_MASK        0x00000004     /* Xmit error */
+#define BIG_SUR_GE_EIR_RECV_ERROR_MASK        0x00000008     /* Recv error */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_EMPTY_MASK  0x00000010     /* Xmit status fifo empty */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_EMPTY_MASK  0x00000020     /* Recv length fifo empty */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_FULL_MASK   0x00000040     /* Xmit length fifo full */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_OVER_MASK   0x00000080     /* Recv length fifo overrun */
+#define BIG_SUR_GE_EIR_RECV_LFIFO_UNDER_MASK  0x00000100     /* Recv length fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_OVER_MASK   0x00000200     /* Xmit status fifo overrun */
+#define BIG_SUR_GE_EIR_XMIT_SFIFO_UNDER_MASK  0x00000400     /* Transmit status fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_OVER_MASK   0x00000800     /* Transmit length fifo overrun */
+#define BIG_SUR_GE_EIR_XMIT_LFIFO_UNDER_MASK  0x00001000     /* Transmit length fifo underrun */
+#define BIG_SUR_GE_EIR_XMIT_PAUSE_MASK        0x00002000     /* Transmit pause pkt received */
+#define BIG_SUR_GE_EIR_RECV_DFIFO_OVER_MASK   0x00004000     /* Receive data fifo overrun */
+#define BIG_SUR_GE_EIR_RECV_MISSED_FRAME_MASK 0x00008000     /* Receive missed frame error */
+#define BIG_SUR_GE_EIR_RECV_COLLISION_MASK    0x00010000     /* Receive collision error */
+#define BIG_SUR_GE_EIR_RECV_FCS_ERROR_MASK    0x00020000     /* Receive FCS error */
+#define BIG_SUR_GE_EIR_RECV_LEN_ERROR_MASK    0x00040000     /* Receive length field error */
+#define BIG_SUR_GE_EIR_RECV_SHORT_ERROR_MASK  0x00080000     /* Receive short frame error */
+#define BIG_SUR_GE_EIR_RECV_LONG_ERROR_MASK   0x00100000     /* Receive long frame error */
+#define BIG_SUR_GE_EIR_RECV_ALIGN_ERROR_MASK  0x00200000     /* Receive alignment error */
+
+/* Enable the MAC unit */
+#define	big_sur_ge_mac_enable(base_address)			\
+{								\
+	u32	control;					\
+	control = BIG_SUR_GE_READ(base_address + 		\
+				BIG_SUR_GE_ECR_OFFSET);		\
+	control &= ~(BIG_SUR_GE_ECR_XMIT_RESET_MASK | 		\
+			BIG_SUR_GE_ECR_RECV_RESET_MASK);	\
+	control |= (BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | 		\
+			BIG_SUR_GE_ECR_RECV_ENABLE_MASK);	\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);	\
+}
+
+/* Disable the MAC unit */
+#define	big_sur_ge_mac_disable(base_address)			\
+{								\
+	u32	control;					\
+	control = BIG_SUR_GE_READ(base_address + 		\
+				BIG_SUR_GE_ECR_OFFSET);		\
+	control &= ~(BIG_SUR_GE_ECR_XMIT_ENABLE_MASK | 		\
+			BIG_SUR_GE_ECR_RECV_ENABLE_MASK);	\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);	\
+}
+
+/* Check if the Tx is done */
+#define	big_sur_ge_tx_done(base_address)			\
+	(BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ISR_OFFSET)	\
+			& BIG_SUR_GE_EIR_XMIT_DONE_MASK)
+
+
+/* Check if Rx FIFO is empty */
+#define	big_sur_ge_rx_empty(base_address)			\
+	(!(BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ISR_OFFSET) \
+			& BIG_SUR_GE_EIR_RECV_DONE_MASK))
+
+/* Reset the MAC PHY */
+#define	big_sur_ge_reset_phy(base_address)				\
+{									\
+	u32 control;							\
+	control = BIG_SUR_GE_READ(base_address + BIG_SUR_GE_ECR_OFFSET);	\
+	control &= ~(BIG_SUR_GE_ECR_PHY_ENABLE_MASK);				\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);	\
+	control |= BIG_SUR_GE_ECR_PHY_ENABLE_MASK;				\
+	BIG_SUR_GE_WRITE(base_address + BIG_SUR_GE_ECR_OFFSET, control);	\
+}
+
+#define BIG_SUR_GE_RST_REG_OFFSET	0  /* reset register */
+#define BIG_SUR_GE_MI_REG_OFFSET	0  /* module information register */
+#define BIG_SUR_GE_DMAC_REG_OFFSET	4  /* DMA control register */
+#define BIG_SUR_GE_SA_REG_OFFSET	8  /* source address register */
+#define BIG_SUR_GE_DA_REG_OFFSET	12 /* destination address register */
+#define BIG_SUR_GE_LEN_REG_OFFSET	16 /* length register */
+#define BIG_SUR_GE_DMAS_REG_OFFSET	20 /* DMA status register */
+#define BIG_SUR_GE_BDA_REG_OFFSET	24 /* buffer descriptor address register */
+#define BIG_SUR_GE_SWCR_REG_OFFSET	28 /* software control register */
+#define BIG_SUR_GE_UPC_REG_OFFSET	32 /* unserviced packet count register */
+#define BIG_SUR_GE_PCT_REG_OFFSET	36 /* packet count threshold register */
+#define BIG_SUR_GE_PWB_REG_OFFSET	40 /* packet wait bound register */
+#define BIG_SUR_GE_IS_REG_OFFSET	44 /* interrupt status register */
+#define BIG_SUR_GE_IE_REG_OFFSET	48 /* interrupt enable register */
+
+#define BIG_SUR_GE_RESET_MASK		0x0000000A
+
+/* Simple DMA register support */
+#define BIG_SUR_GE_DMACR_SOURCE_INCR_MASK	0x80000000UL  /* increment source address */
+#define BIG_SUR_GE_DMACR_DEST_INCR_MASK		0x40000000UL  /* increment dest address */
+#define BIG_SUR_GE_DMACR_SOURCE_LOCAL_MASK	0x20000000UL  /* local source address */
+#define BIG_SUR_GE_DMACR_DEST_LOCAL_MASK	0x10000000UL  /* local dest address */
+#define BIG_SUR_GE_DMACR_SG_DISABLE_MASK	0x08000000UL   /* scatter gather disable */
+#define BIG_SUR_GE_DMASR_BUSY_MASK		0x80000000UL  /* channel is busy */
+#define BIG_SUR_GE_DMASR_BUS_ERROR_MASK		0x40000000UL   /* bus error occurred */
+#define BIG_SUR_GE_DMASR_BUS_TIMEOUT_MASK	0x20000000UL   /* bus timeout occurred */
+
+/* Interrupts */
+#define BIG_SUR_GE_IPIF_EMAC_MASK      0x00000004UL    /* MAC interrupt */
+#define BIG_SUR_GE_IPIF_SEND_DMA_MASK  0x00000008UL    /* Send DMA interrupt */
+#define BIG_SUR_GE_IPIF_RECV_DMA_MASK  0x00000010UL    /* Receive DMA interrupt */
+#define BIG_SUR_GE_IPIF_RECV_FIFO_MASK 0x00000020UL    /* Receive FIFO interrupt */
+#define BIG_SUR_GE_IPIF_SEND_FIFO_MASK 0x00000040UL    /* Send FIFO interrupt */
+
+#define BIG_SUR_GE_IPIF_FIFO_DFT_MASK  (BIG_SUR_GE_IPIF_EMAC_MASK |	\
+                                 BIG_SUR_GE_IPIF_SEND_FIFO_MASK |	\
+                                 BIG_SUR_GE_IPIF_RECV_FIFO_MASK)
+
+#define BIG_SUR_GE_IPIF_DMA_DEV_INTR_COUNT   7 /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_FIFO_DEV_INTR_COUNT  5 /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_DEVICE_INTR_COUNT  7   /* Number of interrupt sources */
+#define BIG_SUR_GE_IPIF_IP_INTR_COUNT      22  /* Number of MAC interrupts */
+
+/* A default interrupt mask for non-DMA operation (direct FIFOs) */
+#define BIG_SUR_GE_EIR_DFT_FIFO_MASK  (BIG_SUR_GE_EIR_XMIT_DONE_MASK |	\
+                                BIG_SUR_GE_EIR_RECV_DONE_MASK)
+
+#endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/gt64240eth.c linux-mips-cvs-20040815/drivers/net/gt64240eth.c
--- linux-2.4.27/drivers/net/gt64240eth.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/gt64240eth.c	2004-08-15 08:06:19.000000000 +0200
@@ -29,6 +29,9 @@
  *
  * Support for Rx NAPI, Rx checksum offload, IOCTL and ETHTOOL added
  * Manish Lachwani (lachwani@pmc-sierra.com) - 09/16/2003
+ *
+ * Modified for later version of Linux 2.4 kernel
+ * Manish Lachwani (lachwani@pmc-sierra.com) - 04/29/2004
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -77,12 +80,20 @@
  *  > 3	lots of change-of-state messages.
  *  > 4	EXTENSIVE data/descriptor dumps.
  */
+
 #ifdef GT64240_DEBUG
 static int gt64240_debug = GT64240_DEBUG;
 #else
 static int gt64240_debug = 0;
 #endif
 
+static int debug = -1;
+
+#define GT64240_MSG_ENABLE	(NETIF_MSG_DRV          | \
+				NETIF_MSG_PROBE        | \
+				NETIF_MSG_LINK)
+
+
 /********************************************************/
 
 // prototypes
@@ -254,119 +265,84 @@ static int read_MII(struct net_device *d
 	return (int) (smir & smirDataMask);
 }
 
-/* Ethtool support */
-static int netdev_ethtool_ioctl(struct net_device *dev, void *useraddr)
+static void gp_get_drvinfo (struct net_device *dev, 
+				struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, "gt64260");
+	strcpy(info->version, version);
+}
+
+static int gp_get_settings(struct net_device *dev, 
+				struct ethtool_cmd *cmd)
 {
 	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
-	u32 ethcmd;
+	int rc;
 
-	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
-		return -EFAULT;
+	spin_lock_irq(&gp->lock);
+	rc = mii_ethtool_gset(&gp->mii_if, cmd);
+	spin_unlock_irq(&gp->lock);
+	return rc;
+}
 
-	switch (ethcmd) {
-
-		/* Get driver info */
-	case ETHTOOL_GDRVINFO:{
-			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
-			strncpy(info.driver, "gt64260",
-				sizeof(info.driver) - 1);
-			strncpy(info.version, version,
-				sizeof(info.version) - 1);
-			if (copy_to_user(useraddr, &info, sizeof(info)))
-				return -EFAULT;
-			return 0;
-		}
-		/* get settings */
-	case ETHTOOL_GSET:{
-			struct ethtool_cmd ecmd = { ETHTOOL_GSET };
-			spin_lock_irq(&gp->lock);
-			mii_ethtool_gset(&gp->mii_if, &ecmd);
-			spin_unlock_irq(&gp->lock);
-			if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
-				return -EFAULT;
-			return 0;
-		}
-		/* set settings */
-	case ETHTOOL_SSET:{
-			int r;
-			struct ethtool_cmd ecmd;
-			if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
-				return -EFAULT;
-			spin_lock_irq(&gp->lock);
-			r = mii_ethtool_sset(&gp->mii_if, &ecmd);
-			spin_unlock_irq(&gp->lock);
-			return r;
-		}
-		/* restart autonegotiation */
-	case ETHTOOL_NWAY_RST:{
-			return mii_nway_restart(&gp->mii_if);
-		}
-		/* get link status */
-	case ETHTOOL_GLINK:{
-			struct ethtool_value edata = { ETHTOOL_GLINK };
-			edata.data = mii_link_ok(&gp->mii_if);
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-		/* get message-level */
-	case ETHTOOL_GMSGLVL:{
-			struct ethtool_value edata = { ETHTOOL_GMSGLVL };
-			edata.data = 0;	/* XXX */
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-		/* set message-level */
-	case ETHTOOL_SMSGLVL:{
-			struct ethtool_value edata;
-			if (copy_from_user
-			    (&edata, useraddr, sizeof(edata)))
-				return -EFAULT;
-			/* debug = edata.data; *//* XXX */
-			return 0;
-		}
-	}
-	return -EOPNOTSUPP;
+static int gp_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
+	int rc;
+
+	spin_lock_irq(&gp->lock);
+	rc = mii_ethtool_sset(&gp->mii_if, cmd);
+	spin_unlock_irq(&gp->lock);
+	return rc;
 }
 
+static int gp_nway_reset(struct net_device *dev)
+{
+	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
+	return mii_nway_restart(&gp->mii_if);
+}
+
+static u32 gp_get_link(struct net_device *dev)
+{
+	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
+	return mii_link_ok(&gp->mii_if);
+}
+
+static u32 gp_get_msglevel(struct net_device *dev)
+{
+	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
+	return gp->msg_enable;
+}
+
+static void gp_set_msglevel(struct net_device *dev, u32 value)
+{
+	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
+	gp->msg_enable = value;
+}
+
+static struct ethtool_ops gp_ethtool_ops = {
+	.get_drvinfo		= gp_get_drvinfo,
+	.get_settings		= gp_get_settings,
+	.set_settings		= gp_set_settings,
+	.nway_reset		= gp_nway_reset,
+	.get_link		= gp_get_link,
+	.get_msglevel		= gp_get_msglevel,
+	.set_msglevel		= gp_set_msglevel,
+};
+
 static int gt64240_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
+	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
 	struct mii_ioctl_data *data =
 	    (struct mii_ioctl_data *) &rq->ifr_data;
-	int phy = dev->base_addr & 0x1f;
 	int retval;
 
-	switch (cmd) {
-	case SIOCETHTOOL:
-		retval = netdev_ethtool_ioctl(dev, (void *) rq->ifr_data);
-		break;
-
-	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
-	case SIOCDEVPRIVATE:	/* for binary compat, remove in 2.5 */
-		data->phy_id = phy;
-		/* Fall through */
-
-	case SIOCGMIIREG:	/* Read MII PHY register. */
-	case SIOCDEVPRIVATE + 1:	/* for binary compat, remove in 2.5 */
-		data->val_out = read_MII(dev, data->reg_num & 0x1f);
-		retval = 0;
-		break;
-
-	case SIOCSMIIREG:	/* Write MII PHY register. */
-	case SIOCDEVPRIVATE + 2:	/* for binary compat, remove in 2.5 */
-		if (!capable(CAP_NET_ADMIN)) {
-			retval = -EPERM;
-		} else {
-			write_MII(dev, data->reg_num & 0x1f, data->val_in);
-			retval = 0;
-		}
-		break;
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	spin_lock_irq(&gp->lock);
+	retval = generic_mii_ioctl(&gp->mii_if, data, cmd, NULL);
+	spin_unlock_irq(&gp->lock);
 
-	default:
-		retval = -EOPNOTSUPP;
-		break;
-	}
 	return retval;
 }
 
@@ -714,17 +690,6 @@ static void disable_ether_irq(struct net
 	GT64240ETH_WRITE(gp, GT64240_ETH_INT_MASK, 0);
 }
 
-#ifdef GT64240_NAPI
-static inline void __netif_rx_complete(struct net_device *dev)
-{
-	if (!test_bit(__LINK_STATE_RX_SCHED, &dev->state))
-		BUG();
-	list_del(&dev->poll_list);
-	clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
-}
-#endif
-
-
 /*
  * Probe for a GT64240 ethernet controller.
  */
@@ -770,21 +735,12 @@ static int __init gt64240_probe1(uint32_
 	static unsigned version_printed = 0;
 	struct gt64240_private *gp = NULL;
 	int retval;
-	u16 vendor_id, device_id;
 	u32 cpuConfig;
 	unsigned char chip_rev;
 
-	// probe for GT64240 by reading PCI0 vendor/device ID register
-	pcibios_read_config_word(0, 0, PCI_VENDOR_ID, &vendor_id);
-	pcibios_read_config_word(0, 0, PCI_DEVICE_ID, &device_id);
-
-	dev = init_etherdev(NULL, sizeof(struct gt64240_private));
-
-	if (gt64240_debug > 2)
-		printk
-		    ("%s: gt64240_probe1 vendId=0x%08x, devId=0x%08x, addr=0x%08lx, irq=%d.,port=%d.\n",
-		     dev->name, vendor_id, device_id, ioaddr, irq,
-		     port_num);
+	dev = alloc_etherdev(sizeof(struct gt64240_private));
+	if (!dev)
+		return -ENOMEM;
 
 	if (irq < 0) {
 		printk
@@ -801,12 +757,8 @@ static int __init gt64240_probe1(uint32_
 	       (cpuConfig & (1 << 12)) ? "little" : "big");
 
 	printk
-	    ("%s: GT64240 found at ioaddr 0x%lx, irq %d., PCI devID=%x\n",
-	     dev->name, ioaddr, irq, device_id);
-
-	/* Allocate a new 'dev' if needed. */
-	if (dev == NULL)
-		dev = init_etherdev(0, sizeof(struct gt64240_private));
+	    ("%s: GT64240 found at ioaddr 0x%lx, irq %d.\n",
+	     dev->name, ioaddr, irq);
 
 	if (gt64240_debug && version_printed++ == 0)
 		printk("%s: %s", dev->name, version);
@@ -821,23 +773,9 @@ static int __init gt64240_probe1(uint32_
 	printk("%s: HW Address ", dev->name);
 	dump_hw_addr(dev->dev_addr);
 
-	/* Initialize our private structure. */
-	if (dev->priv == NULL) {
-
-		gp = (struct gt64240_private *) kmalloc(sizeof(*gp),
-							GFP_KERNEL);
-		if (gp == NULL) {
-			retval = -ENOMEM;
-			goto free_region;
-		}
-
-		dev->priv = gp;
-	}
-
 	gp = dev->priv;
 
-	memset(gp, 0, sizeof(*gp));	// clear it
-
+	gp->msg_enable = (debug < 0 ? GT64240_MSG_ENABLE : debug);
 	gp->port_num = port_num;
 	gp->io_size = GT64240_ETH_IO_SIZE;
 	gp->port_offset = port_num * GT64240_ETH_IO_SIZE;
@@ -927,12 +865,12 @@ static int __init gt64240_probe1(uint32_
 	dev->poll = gt64240_poll;
 	dev->weight = 64;
 #endif
+	dev->ethtool_ops = &gp_ethtool_ops;
 
 	/* Fill in the fields of the device structure with ethernet values. */
-	ether_setup(dev);
 	return 0;
 
-      free_region:
+free_region:
 	release_region(ioaddr, gp->io_size);
 	unregister_netdev(dev);
 	if (dev->priv != NULL)
@@ -1036,7 +974,6 @@ static void reset_rx(struct net_device *
 static int gt64240_init(struct net_device *dev)
 {
 	struct gt64240_private *gp = (struct gt64240_private *) dev->priv;
-	u32 ciu;
 
 	if (gt64240_debug > 3) {
 		printk("%s: gt64240_init: dev=%p\n", dev->name, dev);
@@ -1292,7 +1229,7 @@ static int gt64240_poll(struct net_devic
 	    (struct gt64240_private *) netdev->priv;
 	unsigned long flags;
 	int done = 1, orig_budget, work_done;
-	u32 intMask, status = GT64240ETH_READ(gp, GT64240_ETH_INT_CAUSE);
+	u32 status = GT64240ETH_READ(gp, GT64240_ETH_INT_CAUSE);
 
 	spin_lock_irqsave(&gp->lock, flags);
 	gt64240_tx_fill(netdev, status);
@@ -1315,6 +1252,8 @@ static int gt64240_poll(struct net_devic
 	}
 
 	spin_unlock_irqrestore(&gp->lock, flags);
+
+	return (done ? 0 : 1);
 }
 #endif
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/gt64240eth.h linux-mips-cvs-20040815/drivers/net/gt64240eth.h
--- linux-2.4.27/drivers/net/gt64240eth.h	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/gt64240eth.h	2004-08-15 08:06:19.000000000 +0200
@@ -401,6 +401,8 @@ struct gt64240_private {
     int drv_flags;
     spinlock_t lock;	   /* Serialise access to device */
     struct mii_if_info mii_if;
+
+    u32	msg_enable;
 };
 
 #endif /* _GT64240ETH_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/hamradio/hdlcdrv.c linux-mips-cvs-20040815/drivers/net/hamradio/hdlcdrv.c
--- linux-2.4.27/drivers/net/hamradio/hdlcdrv.c	2002-02-25 20:37:59.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/hamradio/hdlcdrv.c	2004-05-05 14:38:49.000000000 +0200
@@ -587,6 +587,8 @@ static int hdlcdrv_close(struct net_devi
 		return -EINVAL;
 	s = (struct hdlcdrv_state *)dev->priv;
 
+	netif_stop_queue(dev);
+
 	if (s->ops && s->ops->close)
 		i = s->ops->close(dev);
 	if (s->skb)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/mv64340_eth.c linux-mips-cvs-20040815/drivers/net/mv64340_eth.c
--- linux-2.4.27/drivers/net/mv64340_eth.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/mv64340_eth.c	2004-02-06 15:37:44.000000000 +0100
@@ -94,13 +94,6 @@ unsigned long mv64340_sram_base;
  * Helper functions - used inside the driver only *
  **************************************************/
 
-static inline void __netif_rx_complete(struct net_device *dev)
-{
-        if (!test_bit(__LINK_STATE_RX_SCHED, &dev->state)) BUG();
-        list_del(&dev->poll_list);
-        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
-}
-
 static void *mv64340_eth_malloc_ring(unsigned int size)
 {
 	dma_addr_t dma_handle;
@@ -707,11 +700,11 @@ static int mv64340_eth_open(struct net_d
 	if (mv64340_eth_real_open(dev)) {
 		printk("%s: Error opening interface\n", dev->name);
 		free_irq(dev->irq, dev);
-		spin_unlock_irq(&ethernet_priv->lock);
+               spin_unlock_irq(&port_private->lock);
 		return -EBUSY;
 	}
 	MOD_INC_USE_COUNT;
-	spin_unlock_irq(&ethernet_priv->lock);
+       spin_unlock_irq(&port_private->lock);
 	return 0;
 }
 
@@ -723,7 +716,6 @@ static int mv64340_eth_real_open(struct 
 	unsigned int port_num;
 	u32 phy_reg_data;
 	unsigned int size;
-	int i;
 
 	ethernet_private = dev->priv;
 	port_private =
@@ -952,7 +944,7 @@ static int mv64340_eth_stop(struct net_d
 
 	free_irq(dev->irq, dev);
 	MOD_DEC_USE_COUNT;
-	spin_unlock_irq(&ethernet_priv->lock);
+       spin_unlock_irq(&port_private->lock);
 	return 0;
 };
 
@@ -1232,7 +1224,7 @@ static int mv64340_eth_start_xmit(struct
 	stats->tx_packets++;
 	dev->trans_start = jiffies;
 
-	spin_unlock_irqrestore(&ethernet_priv->lock, flags);
+       spin_unlock_irqrestore(&port_private->lock, flags);
 	return 0;		/* success */
 }
 
@@ -2874,6 +2866,8 @@ static ETH_FUNC_RET_STATUS eth_rx_return
 	return ETH_OK;
 }
 
+#ifdef MV64340_COAL
+
 /*******************************************************************************
  * eth_port_set_rx_coal - Sets coalescing interrupt mechanism on RX path
  *
@@ -2910,6 +2904,7 @@ static unsigned int eth_port_set_rx_coal
 		  & 0xffc000ff));
 	return coal;
 }
+#endif
 
 /*******************************************************************************
  * eth_port_set_tx_coal - Sets coalescing interrupt mechanism on TX path
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/ne.c linux-mips-cvs-20040815/drivers/net/ne.c
--- linux-2.4.27/drivers/net/ne.c	2002-08-03 02:39:44.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/net/ne.c	2003-11-28 23:06:50.000000000 +0100
@@ -105,6 +105,9 @@ bad_clone_list[] __initdata = {
     {"PCM-4823", "PCM-4823", {0x00, 0xc0, 0x6c}}, /* Broken Advantech MoBo */
     {"REALTEK", "RTL8019", {0x00, 0x00, 0xe8}}, /* no-name with Realtek chip */
     {"LCS-8834", "LCS-8836", {0x04, 0x04, 0x37}}, /* ShinyNet (SET) */
+#ifdef CONFIG_TOSHIBA_RBTX4927
+    {"TX4927", "TX4927", {0x00, 0x60, 0x0a}}, /* Toshiba w/EEPROM, no probing */
+#endif
     {0,}
 };
 #endif
@@ -239,6 +242,13 @@ static int __init ne_probe1(struct net_d
 	int reg0, ret;
 	static unsigned version_printed;
 
+#ifdef CONFIG_TOSHIBA_RBTX4927
+#include <asm/tx4927/toshiba_rbtx4927.h>
+	ioaddr = RBTX4927_RTL_8019_BASE;
+	dev->irq = RBTX4927_RTL_8019_IRQ;
+	wordlength = 1;
+#endif
+
 	if (!request_region(ioaddr, NE_IO_EXTENT, dev->name))
 		return -EBUSY;
 
@@ -342,8 +352,15 @@ static int __init ne_probe1(struct net_d
 		start_page = NESM_START_PG;
 		stop_page = NESM_STOP_PG;
 	} else {
+#ifdef CONFIG_TOSHIBA_RBTX4927
+		start_page = NESM_START_PG;
+		stop_page = NESM_STOP_PG;
+		for (i = 0; i < 16; i++)
+			SA_prom[i] = SA_prom[i+i];
+#else
 		start_page = NE1SM_START_PG;
 		stop_page = NE1SM_STOP_PG;
+#endif
 	}
 
 	neX000 = (SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/pcnet32.c linux-mips-cvs-20040815/drivers/net/pcnet32.c
--- linux-2.4.27/drivers/net/pcnet32.c	2004-08-08 01:26:05.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/net/pcnet32.c	2004-08-15 08:06:19.000000000 +0200
@@ -1273,7 +1273,11 @@ pcnet32_probe1(unsigned long ioaddr, uns
 	dev->irq = irq_line;
     }
 
+#ifdef CONFIG_LASAT
+    if (dev->irq >= 0) {
+#else
     if (dev->irq >= 2) {
+#endif
 	if (pcnet32_debug & NETIF_MSG_PROBE)
 	    printk(" assigned IRQ %d.\n", dev->irq);
     } else {
@@ -1361,7 +1365,10 @@ pcnet32_open(struct net_device *dev)
     int rc;
     unsigned long flags;
 
-    if (dev->irq == 0 ||
+    if (
+#ifndef CONFIG_LASAT
+	dev->irq == 0 ||
+#endif
 	request_irq(dev->irq, &pcnet32_interrupt,
 		    lp->shared_irq ? SA_SHIRQ : 0, dev->name, (void *)dev)) {
 	return -EAGAIN;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/sb1250-mac.c linux-mips-cvs-20040815/drivers/net/sb1250-mac.c
--- linux-2.4.27/drivers/net/sb1250-mac.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/sb1250-mac.c	2004-01-07 20:24:33.000000000 +0100
@@ -468,14 +468,17 @@ static void sbmac_mii_sync(struct sbmac_
 {
 	int cnt;
 	uint64_t bits;
+	int mac_mdio_genc;
+
+	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
 	
 	bits = M_MAC_MDIO_DIR_OUTPUT | M_MAC_MDIO_OUT;
 	
-	SBMAC_WRITECSR(s->sbm_mdio,bits);
+	SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
 	
 	for (cnt = 0; cnt < 32; cnt++) {
-		SBMAC_WRITECSR(s->sbm_mdio,bits | M_MAC_MDC);
-		SBMAC_WRITECSR(s->sbm_mdio,bits);
+		SBMAC_WRITECSR(s->sbm_mdio,bits | M_MAC_MDC | mac_mdio_genc);
+		SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
 	}
 }
 
@@ -496,9 +499,12 @@ static void sbmac_mii_senddata(struct sb
 	int i;
 	uint64_t bits;
 	unsigned int curmask;
+	int mac_mdio_genc;
+
+	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
 	
 	bits = M_MAC_MDIO_DIR_OUTPUT;
-	SBMAC_WRITECSR(s->sbm_mdio,bits);
+	SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
 	
 	curmask = 1 << (bitcnt - 1);
 	
@@ -506,9 +512,9 @@ static void sbmac_mii_senddata(struct sb
 		if (data & curmask)
 			bits |= M_MAC_MDIO_OUT;
 		else bits &= ~M_MAC_MDIO_OUT;
-		SBMAC_WRITECSR(s->sbm_mdio,bits);
-		SBMAC_WRITECSR(s->sbm_mdio,bits | M_MAC_MDC);
-		SBMAC_WRITECSR(s->sbm_mdio,bits);
+		SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
+		SBMAC_WRITECSR(s->sbm_mdio,bits | M_MAC_MDC | mac_mdio_genc);
+		SBMAC_WRITECSR(s->sbm_mdio,bits | mac_mdio_genc);
 		curmask >>= 1;
 	}
 }
@@ -534,7 +540,8 @@ static unsigned int sbmac_mii_read(struc
 	int idx;
 	int error;
 	int regval;
-	
+	int mac_mdio_genc;
+
 	/*
 	 * Synchronize ourselves so that the PHY knows the next
 	 * thing coming down is a command
@@ -555,17 +562,20 @@ static unsigned int sbmac_mii_read(struc
 	sbmac_mii_senddata(s,phyaddr, 5);
 	sbmac_mii_senddata(s,regidx, 5);
 	
+	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
+	
 	/* 
 	 * Switch the port around without a clock transition.
 	 */
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT);
+	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
 	
 	/*
 	 * Send out a clock pulse to signal we want the status
 	 */
 	
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | M_MAC_MDC);
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT);
+	SBMAC_WRITECSR(s->sbm_mdio,
+		       M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc);
+	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
 	
 	/* 
 	 * If an error occurred, the PHY will signal '1' back
@@ -576,8 +586,9 @@ static unsigned int sbmac_mii_read(struc
 	 * Issue an 'idle' clock pulse, but keep the direction
 	 * the same.
 	 */
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | M_MAC_MDC);
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT);
+	SBMAC_WRITECSR(s->sbm_mdio,
+		       M_MAC_MDIO_DIR_INPUT | M_MAC_MDC | mac_mdio_genc);
+	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
 	
 	regval = 0;
 	
@@ -589,12 +600,14 @@ static unsigned int sbmac_mii_read(struc
 				regval |= 1;
 		}
 		
-		SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT | M_MAC_MDC);
-		SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_INPUT);
+		SBMAC_WRITECSR(s->sbm_mdio,
+			       M_MAC_MDIO_DIR_INPUT|M_MAC_MDC | mac_mdio_genc);
+		SBMAC_WRITECSR(s->sbm_mdio,
+			       M_MAC_MDIO_DIR_INPUT | mac_mdio_genc);
 	}
 	
 	/* Switch back to output */
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_OUTPUT);
+	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc);
 	
 	if (error == 0)
 		return regval;
@@ -620,7 +633,8 @@ static unsigned int sbmac_mii_read(struc
 static void sbmac_mii_write(struct sbmac_softc *s,int phyaddr,int regidx,
 			    unsigned int regval)
 {
-	
+	int mac_mdio_genc;
+
 	sbmac_mii_sync(s);
 	
 	sbmac_mii_senddata(s,MII_COMMAND_START,2);
@@ -629,8 +643,10 @@ static void sbmac_mii_write(struct sbmac
 	sbmac_mii_senddata(s,regidx, 5);
 	sbmac_mii_senddata(s,MII_COMMAND_ACK,2);
 	sbmac_mii_senddata(s,regval,16);
-	
-	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_OUTPUT);
+
+	mac_mdio_genc = SBMAC_READCSR(s->sbm_mdio) & M_MAC_GENC;
+
+	SBMAC_WRITECSR(s->sbm_mdio,M_MAC_MDIO_DIR_OUTPUT | mac_mdio_genc);
 }
 
 
@@ -2788,7 +2804,7 @@ sbmac_init_module(void)
 	struct net_device *dev;
 	sbmac_port_t port;
 	int chip_max_units;
-	
+
 	/*
 	 * For bringup when not using the firmware, we can pre-fill
 	 * the MAC addresses using the environment variables
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/sgiseeq.c linux-mips-cvs-20040815/drivers/net/sgiseeq.c
--- linux-2.4.27/drivers/net/sgiseeq.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/sgiseeq.c	2004-08-15 08:06:19.000000000 +0200
@@ -162,12 +162,6 @@ static int seeq_init_ring(struct net_dev
 
 	seeq_load_eaddr(dev, sp->sregs);
 
-	/* XXX for now just accept packets directly to us
-	 * XXX and ether-broadcast.  Will do multicast and
-	 * XXX promiscuous mode later. -davem
-	 */
-	sp->mode = SEEQ_RCMD_RBCAST;
-
 	/* Setup tx ring. */
 	for(i = 0; i < SEEQ_TX_BUFFERS; i++) {
 		if (!ib->tx_desc[i].tdma.pbuf) {
@@ -332,10 +326,17 @@ static inline void sgiseeq_rx(struct net
 				/* Copy out of kseg1 to avoid silly cache flush. */
 				eth_copy_and_sum(skb, pkt_pointer + 2, len, 0);
 				skb->protocol = eth_type_trans(skb, dev);
-				netif_rx(skb);
-				dev->last_rx = jiffies;
-				sp->stats.rx_packets++;
-				sp->stats.rx_bytes += len;
+
+				/* We don't want to receive our own packets */
+				if (memcmp(skb->mac.ethernet->h_source, dev->dev_addr, 6)) {
+					netif_rx(skb);
+					dev->last_rx = jiffies;
+					sp->stats.rx_packets++;
+					sp->stats.rx_bytes += len;
+				} else {
+					/* Silently drop my own packets */
+					dev_kfree_skb_irq(skb);
+				}
 			} else {
 				printk (KERN_NOTICE "%s: Memory squeeze, deferring packet.\n",
 					dev->name);
@@ -570,6 +571,22 @@ static struct net_device_stats *sgiseeq_
 
 static void sgiseeq_set_multicast(struct net_device *dev)
 {
+	struct sgiseeq_private *sp = (struct sgiseeq_private *) dev->priv;
+	unsigned char oldmode = sp->mode;
+
+	if(dev->flags & IFF_PROMISC)
+		sp->mode = SEEQ_RCMD_RANY;
+	else if ((dev->flags & IFF_ALLMULTI) || dev->mc_count)
+		sp->mode = SEEQ_RCMD_RBMCAST;
+	else
+		sp->mode = SEEQ_RCMD_RBCAST;
+
+	/* XXX I know this sucks, but is there a better way to reprogram
+	 * XXX the receiver? At least, this shouldn't happen too often.
+	 */
+
+	if (oldmode != sp->mode)
+		sgiseeq_reset(dev);
 }
 
 static inline void setup_tx_ring(struct sgiseeq_tx_desc *buf, int nbufs)
@@ -640,6 +657,7 @@ int sgiseeq_init(struct hpc3_regs* regs,
 	sp->sregs = (struct sgiseeq_regs *) &hpc3c0->eth_ext[0];
 	sp->hregs = &hpc3c0->ethregs;
 	sp->name = sgiseeqstr;
+	sp->mode = SEEQ_RCMD_RBCAST;
 
 	sp->srings.rx_desc = (struct sgiseeq_rx_desc *)
 	                     KSEG1ADDR(ALIGNED(&sp->srings.rxvector[0]));
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/titan_ge.c linux-mips-cvs-20040815/drivers/net/titan_ge.c
--- linux-2.4.27/drivers/net/titan_ge.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/titan_ge.c	2004-08-15 08:06:19.000000000 +0200
@@ -0,0 +1,2266 @@
+/*
+ * drivers/net/titan_ge.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * The MAC unit of the Titan consists of the following:
+ *
+ * -> XDMA Engine to move data to from the memory to the MAC packet FIFO
+ * -> FIFO is where the incoming and outgoing data is placed
+ * -> TRTG is the unit that pulls the data from the FIFO for Tx and pushes
+ *    the data into the FIFO for Rx
+ * -> TMAC is the outgoing MAC interface and RMAC is the incoming. 
+ * -> AFX is the address filtering block
+ * -> GMII block to communicate with the PHY
+ *
+ * Rx will look like the following:
+ * GMII --> RMAC --> AFX --> TRTG --> Rx FIFO --> XDMA --> CPU memory
+ *
+ * Tx will look like the following:
+ * CPU memory --> XDMA --> Tx FIFO --> TRTG --> TMAC --> GMII
+ *
+ * The Titan driver has support for the following performance features:
+ * -> Rx side checksumming 
+ * -> Jumbo Frames
+ * -> Interrupt Coalscing
+ * -> Rx NAPI 
+ * -> SKB Recycling
+ * -> Transmit/Receive descriptors in SRAM
+ * -> Fast routing for IP forwarding
+ */
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/fcntl.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/ip.h>
+#include <linux/init.h>
+#include <linux/in.h>
+#include <linux/pci.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/prefetch.h>
+
+/* For MII specifc registers, titan_mdio.h should be included */
+#include <net/ip.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+
+#include "titan_ge.h"
+#include "titan_mdio.h"
+
+/* Static Function Declarations	 */
+static int titan_ge_eth_open(struct net_device *);
+static int titan_ge_eth_stop(struct net_device *);
+static int titan_ge_change_mtu(struct net_device *, int);
+static struct net_device_stats *titan_ge_get_stats(struct net_device *);
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info *, int, int,
+				      unsigned long, unsigned long,
+				      unsigned long);
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info *, int,
+				      unsigned long, unsigned long);
+
+static int titan_ge_open(struct net_device *);
+static int titan_ge_start_xmit(struct sk_buff *, struct net_device *);
+static int titan_ge_stop(struct net_device *);
+static int titan_ge_set_mac_address(struct net_device *, void *);
+
+static unsigned long titan_ge_tx_coal(unsigned long, int);
+static unsigned long titan_ge_rx_coal(unsigned long, int);
+
+static void titan_ge_port_reset(unsigned int);
+static int titan_ge_free_tx_queue(titan_ge_port_info *);
+static int titan_ge_rx_task(struct net_device *, titan_ge_port_info *);
+static int titan_ge_port_start(struct net_device *, titan_ge_port_info *);
+
+static int titan_ge_init(int);
+static int titan_ge_return_tx_desc(titan_ge_port_info *, int);
+
+/*
+ * Some configuration for the FIFO and the XDMA channel needs
+ * to be done only once for all the ports. This flag controls
+ * that
+ */
+unsigned long config_done = 0;
+
+/*
+ * One time out of memory flag
+ */
+unsigned int oom_flag = 0;
+
+#ifdef TITAN_RX_NAPI
+static int titan_ge_poll(struct net_device *netdev, int *budget);
+#endif
+
+int titan_ge_receive_queue(struct net_device *, unsigned int);
+
+/* MAC Address */
+extern unsigned char titan_ge_mac_addr_base[6];
+
+/* Support for Rx NAPI */
+#ifdef TITAN_RX_NAPI
+static inline void __netif_rx_complete(struct net_device *dev)
+{
+        if (!test_bit(__LINK_STATE_RX_SCHED, &dev->state)) 
+		BUG();
+        list_del(&dev->poll_list);
+	mb();
+        clear_bit(__LINK_STATE_RX_SCHED, &dev->state);
+}
+#endif
+
+/* 
+ * The Titan GE has two alignment requirements:
+ * -> skb->data to be cacheline aligned (32 byte)
+ * -> IP header alignment to 16 bytes
+ *
+ * The latter is not implemented. So, that results in an extra copy on
+ * the Rx. This is a big performance hog. For the former case, the 
+ * dev_alloc_skb() has been replaced with titan_ge_alloc_skb(). The size
+ * requested is calculated:
+ * 
+ * Ethernet Frame Size : 1518
+ * Ethernet Header     : 14
+ * Future Titan change for IP header alignment : 2
+ *
+ * Hence, we allocate (1518 + 14 + 2+ 64) = 1580 bytes. For the future 
+ * revisions of the chip that do support IP header alignment, we will use
+ * skb_reserve().
+ */
+
+#define ALIGNED_RX_SKB_ADDR(addr) \
+        ((((unsigned long)(addr) + (64UL - 1UL)) \
+	& ~(64UL - 1UL)) - (unsigned long)(addr))
+
+#define titan_ge_alloc_skb(__length, __gfp_flags) \
+({      struct sk_buff *__skb; \
+        __skb = alloc_skb((__length) + 64, (__gfp_flags)); \
+        if(__skb) { \
+                int __offset = (int) ALIGNED_RX_SKB_ADDR(__skb->data); \
+                if(__offset) \
+                        skb_reserve(__skb, __offset); \
+        } \
+        __skb; \
+})
+
+/*
+ * Configure the GMII block of the Titan based 
+ * on what the PHY tells us
+ */
+static void titan_ge_gmii_config(int port_num)
+{
+	volatile unsigned int reg_data = 0, phy_reg;
+	int err;
+
+	err = titan_ge_mdio_read(port_num,
+                               TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+
+	if (err == TITAN_GE_MDIO_ERROR) {
+                printk(KERN_ERR
+                       "Could not read PHY control register 0x11 \n");
+		printk(KERN_ERR
+			"Setting speed to 1000 Mbps and Duplex to Full \n");
+
+		return TITAN_ERROR;
+        }
+
+	err = titan_ge_mdio_write(port_num,
+			TITAN_GE_MDIO_PHY_IE, 0);
+
+	if (phy_reg & 0x8000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE + 
+					(port_num << 12)), 0x201);
+		}  else {
+			/* Half Duplex and 1000 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2201);
+			}
+	}
+	if (phy_reg & 0x4000) {
+		if (phy_reg & 0x2000) {
+			/* Full Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x100);
+		} else {
+			/* Half Duplex and 100 Mbps */
+			TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_MODE +
+					(port_num << 12)), 0x2100);
+		}
+	}
+	reg_data = TITAN_GE_READ(TITAN_GE_GMII_CONFIG_GENERAL +
+				(port_num << 12));
+	reg_data |= 0x3;
+	TITAN_GE_WRITE((TITAN_GE_GMII_CONFIG_GENERAL +
+			(port_num << 12)), reg_data);
+}
+
+/*
+ * Enable the TMAC if it is not
+ */
+static void titan_ge_enable_tx(unsigned int port_num)
+{
+	unsigned long reg_data;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	if (!(reg_data & 0x8000)) {
+		printk("TMAC disabled for port %d!! \n", port_num);
+
+		reg_data |= 0x0001;	/* Enable TMAC */
+		reg_data |= 0x4000;	/* CRC Check Enable */
+		reg_data |= 0x2000;	/* Padding enable */
+		reg_data |= 0x0800;	/* CRC Add enable */
+		reg_data |= 0x0080;	/* PAUSE frame */
+
+		TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12)), reg_data);
+	}
+}
+
+/*
+ * Tx Timeout function
+ */
+static void titan_ge_tx_timeout(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev->priv;
+
+	printk(KERN_INFO "%s: TX timeout  ", netdev->name);
+	printk(KERN_INFO "Resetting card \n");
+
+	/* Do the reset outside of interrupt context */
+	schedule_task(&titan_ge_eth->tx_timeout_task);
+}
+
+/*
+ * Update the AFX tables for UC and MC for slice 0 only
+ */
+static void titan_ge_update_afx(titan_ge_port_info * titan_ge_eth)
+{
+	unsigned int i;
+	volatile unsigned long reg_data = 0;
+	u8 p_addr[6];
+	int port = titan_ge_eth->port_num;
+
+	memcpy(p_addr, titan_ge_eth->port_mac_addr, 6);
+
+	/* Set the MAC address here for TMAC and RMAC */
+        TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port << 12)),
+                       ((p_addr[5] << 8) | p_addr[4]));
+        TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port << 12)),
+                       ((p_addr[3] << 8) | p_addr[2]));
+        TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port << 12)), 
+                       ((p_addr[1] << 8) | p_addr[0]));
+
+        TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port << 12)),
+                       ((p_addr[5] << 8) | p_addr[4]));
+        TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port << 12)),
+                       ((p_addr[3] << 8) | p_addr[2]));
+        TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port << 12)),
+                       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((0x112c | (port << 12)), 0x1);
+	/* Configure the eight address filters */
+	for (i = 0; i < 8; i++) {
+		/* Select each of the eight filters */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_2 +
+				(port << 12)), i);
+
+		/* Configure the match */
+		reg_data = 0x9;	/* Forward Enable Bit */
+		TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_0 +
+				(port << 12)), reg_data);
+
+		/* Finally, AFX Exact Match Address Registers */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_LOW + (port << 12)),
+			       ((p_addr[1] << 8) | p_addr[0]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_MID + (port << 12)),
+			       ((p_addr[3] << 8) | p_addr[2]));
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_HIGH + (port << 12)),
+			       ((p_addr[5] << 8) | p_addr[4]));
+
+		/* VLAN id set to 0 */
+		TITAN_GE_WRITE((TITAN_GE_AFX_EXACT_MATCH_VID + 
+				(port << 12)), 0);
+	}
+}
+
+/*
+ * Actual Routine to reset the adapter when the timeout occurred
+ */
+static void titan_ge_tx_timeout_task(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev->priv;
+	int port = titan_ge_eth->port_num;
+
+	printk("Titan GE: Transmit timed out. Resetting ... \n");
+
+	/* Dump debug info */
+	printk(KERN_ERR "TRTG cause : %x \n",
+			(unsigned long)TITAN_GE_READ(0x100c + (port << 12)));
+
+	/* Fix this for the other ports */
+	printk(KERN_ERR "FIFO cause : %x \n",
+			(unsigned long)TITAN_GE_READ(0x482c));
+	printk(KERN_ERR "IE cause : %x \n",
+			(unsigned long)TITAN_GE_READ(0x0040));
+	printk(KERN_ERR "XDMA GDI ERROR : %x \n",
+			(unsigned long)TITAN_GE_READ(0x5008 + (port << 8)));
+	printk(KERN_ERR "CHANNEL ERROR: %x \n",
+			(unsigned long)TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT
+						+ (port << 8)));	
+
+	netif_device_detach(netdev);
+	titan_ge_port_reset(titan_ge_eth->port_num);
+	titan_ge_port_start(netdev, titan_ge_eth);
+	netif_device_attach(netdev);
+}
+
+/*
+ * Change the MTU of the Ethernet Device
+ */
+static int titan_ge_change_mtu(struct net_device *netdev, int new_mtu)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num;
+	unsigned long flags;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+
+	if ((new_mtu > 9500) || (new_mtu < 64)) {
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+		return -EINVAL;
+	}
+
+	netdev->mtu = new_mtu;
+
+	/* Now we have to reopen the interface so that SKBs with the new
+	 * size will be allocated */
+
+	if (netif_running(netdev)) {
+		if (titan_ge_eth_stop(netdev) != TITAN_OK) {
+			printk(KERN_ERR
+			       "%s: Fatal error on stopping device\n",
+			       netdev->name);
+			spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+			return -1;
+		}
+
+		if (titan_ge_eth_open(netdev) != TITAN_OK) {
+			printk(KERN_ERR
+			       "%s: Fatal error on opening device\n",
+			       netdev->name);
+			spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+			return -1;
+		}
+	}
+
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+	return 0;
+}
+
+/*
+ * Reset the XDMA unit due to errors
+ */
+static void titan_ge_xdma_reset(void)
+{
+       unsigned long   reg_data;
+
+       reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
+       reg_data |= 0x80000000;
+       TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
+
+       mdelay(2);
+
+       reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
+       reg_data &= ~(0x80000000);
+       TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
+}
+
+/*
+ * Titan Gbe Interrupt Handler. All the three ports send interrupt to one line
+ * only. Once an interrupt is triggered, figure out the port and then check
+ * the channel.
+ */
+static irqreturn_t titan_ge_int_handler(int irq, void *dev_id,
+	struct pt_regs *regs)
+{
+	struct net_device *netdev = (struct net_device *) dev_id;
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num, reg_data;
+	unsigned long eth_int_cause_error = 0, is;
+	unsigned long eth_int_cause1;
+	int err = 0;
+#ifdef CONFIG_SMP
+	unsigned long eth_int_cause2;
+#endif
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	/* Ack the CPU interrupt */
+	if (port_num == 1) {
+#ifdef CONFIG_MIPS64
+		is = *(volatile u_int32_t *)(0xfffffffffb001b00);
+		*(volatile u_int32_t *)(0xfffffffffb001b0c) = is;
+#else
+                is = *(volatile u_int32_t *)(0xfb001b00);
+                *(volatile u_int32_t *)(0xfb001b0c) = is;
+#endif
+
+#ifdef CONFIG_SMP
+#ifdef CONFIG_MIPS64
+		is = *(volatile u_int32_t *)(0xfffffffffb002b00);
+		*(volatile u_int32_t *)(0xfffffffffb002b0c) = is;
+#else
+		is = *(volatile u_int32_t *)(0xfb002b00);
+		*(volatile u_int32_t *)(0xfb002b0c) = is;
+#endif
+#endif
+        }
+
+        if (port_num == 0) {
+#ifdef CONFIG_MIPS64
+		is = *(volatile u_int32_t *)(0xfffffffffb001b10);
+		*(volatile u_int32_t *)(0xfffffffffb001b1c) = is;
+#else
+                is = *(volatile u_int32_t *)(0xfb001b10);
+                *(volatile u_int32_t *)(0xfb001b1c) = is;
+#endif
+
+#ifdef CONFIG_SMP
+#ifdef CONFIG_MIPS64
+		is = *(volatile u_int32_t *)(0xfffffffffb002b10);
+		*(volatile u_int32_t *)(0xfffffffffb002b1c) = is;
+#else
+		is = *(volatile u_int32_t *)(0xfb002b10);
+		*(volatile u_int32_t *)(0xfb002b1c) = is;
+#endif
+#endif
+        }
+
+	eth_int_cause1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+#ifdef CONFIG_SMP
+	eth_int_cause2 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_B);
+#endif
+
+	/* Spurious interrupt */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 == 0) && (eth_int_cause2 == 0)) {
+#else
+	if (eth_int_cause1 == 0) {
+#endif
+		eth_int_cause_error = TITAN_GE_READ(TITAN_GE_CHANNEL0_INTERRUPT +
+					(port_num << 8));
+
+		if (eth_int_cause_error == 0)
+			return IRQ_NONE;
+	}
+
+	/* Handle Tx first. No need to ack interrupts */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x20202) || 
+		(eth_int_cause2 & 0x20202) )
+#else
+	if (eth_int_cause1 & 0x20202) 
+#endif
+		titan_ge_free_tx_queue(titan_ge_eth);
+		
+#ifdef TITAN_RX_NAPI
+	/* Handle the Rx next */
+#ifdef CONFIG_SMP
+	if ( (eth_int_cause1 & 0x10101) ||
+		(eth_int_cause2 & 0x10101)) {
+#else
+	if (eth_int_cause1 & 0x10101) {
+#endif
+		if (netif_rx_schedule_prep(netdev)) {
+			unsigned int ack;
+	
+			ack = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+			/* Disable Tx and Rx both */
+			if (port_num == 0) 
+				ack &= ~(0x3);
+			if (port_num == 1) 
+				ack &= ~(0x300);
+
+			/* Interrupts have been disabled */
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, ack);
+
+			__netif_rx_schedule(netdev);
+		}
+	}
+#else
+	titan_ge_free_tx_queue(titan_ge_eth);
+	count = titan_ge_receive_queue(netdev, 0);
+
+#endif
+	/* Handle error interrupts */
+        if (eth_int_cause_error && 
+		(eth_int_cause_error != 0x2)) {
+		printk(KERN_ERR
+			"XDMA Channel Error : %x  on port %d\n",
+			eth_int_cause_error, port_num);
+
+		printk(KERN_ERR
+			"XDMA GDI Hardware error : %x  on port %d\n",
+			TITAN_GE_READ(0x5008 + (port_num << 8)), port_num);
+
+		printk(KERN_ERR
+			"XDMA currently has %d Rx descriptors \n",
+			TITAN_GE_READ(0x5048 + (port_num << 8)));
+
+		printk(KERN_ERR
+			"XDMA currently has prefetcted %d Rx descriptors \n",
+			TITAN_GE_READ(0x505c + (port_num << 8)));
+	
+                TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT +
+                               (port_num << 8)), eth_int_cause_error);
+        }
+
+	/*
+	 * PHY interrupt to inform abt the changes. Reading the 
+	 * PHY Status register will clear the interrupt
+	 */
+	if ((!(eth_int_cause1 & 0x30303)) && 
+		(eth_int_cause_error == 0)) {
+		err =
+		    titan_ge_mdio_read(port_num,
+			       TITAN_GE_MDIO_PHY_IS, &reg_data);
+
+		if (reg_data & 0x0400) {
+			/* Link status change */
+			titan_ge_mdio_read(port_num,
+				   TITAN_GE_MDIO_PHY_STATUS, &reg_data);
+			if (!(reg_data & 0x0400)) {
+				/* Link is down */
+				netif_carrier_off(netdev);
+				netif_stop_queue(netdev);
+			} else {
+				/* Link is up */
+				netif_carrier_on(netdev);
+				netif_wake_queue(netdev);
+
+				/* Enable the queue */
+				titan_ge_enable_tx(port_num);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Multicast and Promiscuous mode set. The 
+ * set_multi entry point is called whenever the 
+ * multicast address list or the network interface 
+ * flags are updated.
+ */
+static void titan_ge_set_multi(struct net_device *netdev)
+{
+	unsigned long reg_data;
+	unsigned int port_num;
+	titan_ge_port_info *titan_ge_eth;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	reg_data = TITAN_GE_READ(TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 + 
+				(port_num << 12));
+
+	if (netdev->flags & IFF_PROMISC) {
+		reg_data |= 0x2;
+	}
+	else if (netdev->flags & IFF_ALLMULTI) {
+		reg_data |= 0x01;
+		reg_data |= 0x400; /* Use the 64-bit Multicast Hash bin */
+	}
+	else {
+		reg_data = 0x2;
+	}
+
+	TITAN_GE_WRITE((TITAN_GE_AFX_ADDRS_FILTER_CTRL_1 + 
+			(port_num << 12)), reg_data);
+	if (reg_data & 0x01) {
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_LOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDLOW +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_MIDHI +
+				(port_num << 12)), 0xffff);
+		TITAN_GE_WRITE((TITAN_GE_AFX_MULTICAST_HASH_HI +
+				(port_num << 12)), 0xffff);
+	}
+}
+
+/*
+ * Open the network device
+ */
+static int titan_ge_open(struct net_device *netdev)
+{
+	int retval;
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	retval = request_irq(TITAN_ETH_PORT_IRQ - port_num, titan_ge_int_handler,
+		     SA_INTERRUPT | SA_SAMPLE_RANDOM , netdev->name, netdev);
+
+	if (retval != 0) {
+		printk(KERN_ERR "Cannot assign IRQ number to TITAN GE \n");
+		return -1;
+	} else {
+		netdev->irq = TITAN_ETH_PORT_IRQ - port_num;
+		printk(KERN_INFO "Assigned IRQ %d to port %d\n", 
+				netdev->irq, port_num);
+	}
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+
+	if (titan_ge_eth_open(netdev) != TITAN_OK) {
+		printk("%s: Error opening interface \n", netdev->name);
+		spin_unlock_irq(&(titan_ge_eth->lock));
+		free_irq(netdev->irq, netdev);
+		return -EBUSY;
+	}
+
+	SET_MODULE_OWNER(netdev);
+	spin_unlock_irq(&(titan_ge_eth->lock));
+	return 0;
+}
+
+/*
+ * Return the Rx buffer back to the Rx ring
+ */
+static int titan_ge_rx_return_buff(titan_ge_port_info * titan_ge_port,
+					struct sk_buff *skb)
+{
+	int rx_used_desc;
+	volatile titan_ge_rx_desc *rx_desc;
+
+	rx_used_desc = titan_ge_port->rx_used_desc_q;
+	rx_desc = &(titan_ge_port->rx_desc_area[rx_used_desc]);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	rx_desc->buffer_addr =
+               pci_map_single(0, skb->data, TITAN_GE_JUMBO_BUFSIZE - 2,
+                                            PCI_DMA_FROMDEVICE);
+#else
+	rx_desc->buffer_addr = 
+                pci_map_single(0, skb->data, TITAN_GE_STD_BUFSIZE - 2,
+                                            PCI_DMA_FROMDEVICE);
+#endif
+
+	titan_ge_port->rx_skb[rx_used_desc] = skb;
+	rx_desc->cmd_sts = TITAN_GE_RX_BUFFER_OWNED;
+
+	titan_ge_port->rx_used_desc_q =
+    	(rx_used_desc + 1) % TITAN_GE_RX_QUEUE;
+
+	return TITAN_OK;
+}
+
+/*
+ * Allocate the SKBs for the Rx ring. Also used 
+ * for refilling the queue
+ */
+static int titan_ge_rx_task(struct net_device *netdev, 
+				titan_ge_port_info *titan_ge_eth)
+{
+	struct sk_buff *skb;
+	int count = 0;
+
+	while (titan_ge_eth->rx_ring_skbs < titan_ge_eth->rx_ring_size) {
+
+	/* First try to get the skb from the recycler */
+#ifdef TITAN_GE_JUMBO_FRAMES
+		skb = titan_ge_alloc_skb(TITAN_GE_JUMBO_BUFSIZE, GFP_ATOMIC);
+#else	
+		skb = titan_ge_alloc_skb(TITAN_GE_STD_BUFSIZE, GFP_ATOMIC);
+#endif
+		if (!skb) {	
+			/* OOM, set the flag */
+			printk("OOM \n");
+			oom_flag = 1;
+			break;
+		}
+		count++;
+		skb->dev = netdev;
+
+		titan_ge_eth->rx_ring_skbs++;
+
+		if (titan_ge_rx_return_buff(titan_ge_eth, skb) !=
+		    TITAN_OK) {
+			printk(KERN_ERR "%s: Error allocating RX Ring\n",
+		       		netdev->name);
+			break;
+		}
+	}
+
+	return count;
+}
+
+/*
+ * Actual init of the Tital GE port. There is one register for 
+ * the channel configuration
+ */
+static void titan_port_init(struct net_device *netdev,
+			    titan_ge_port_info * titan_ge_eth)
+{
+	unsigned long reg_data;
+	
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	/* First reset the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x80000000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0xc0000000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	/* Now reset the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data |= 0x00080000;
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+
+	udelay(30);
+
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG);
+	reg_data &= ~(0x000c0000);
+	TITAN_GE_WRITE(TITAN_GE_CHANNEL0_CONFIG, reg_data);
+}
+
+/*
+ * Start the port. All the hardware specific configuration
+ * for the XDMA, Tx FIFO, Rx FIFO, TMAC, RMAC, TRTG and AFX
+ * go here
+ */
+static int titan_ge_port_start(struct net_device *netdev,
+				titan_ge_port_info * titan_port)
+{
+	volatile unsigned long reg_data, reg_data1;
+	int count = 0;
+	int port_num = titan_port->port_num;
+
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(0x0004);
+		reg_data |= 0x100;
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		reg_data &= ~(0x100);
+		TITAN_GE_WRITE(0x0004, reg_data);
+
+		/* Turn on GMII/MII mode and turn off TBI mode */
+		reg_data = TITAN_GE_READ(TITAN_GE_TSB_CTRL_1);
+        	reg_data |= 0x00000700;
+		reg_data &= ~(0x00800000); /* Fencing */
+#ifdef TITAN_RX_NAPI
+		TITAN_GE_WRITE(0x000c, 0x00001100);
+#else
+		TITAN_GE_WRITE(0x000c, 0x00000100); /* No WCIMODE */
+#endif
+	        TITAN_GE_WRITE(TITAN_GE_TSB_CTRL_1, reg_data);
+
+		/* Set the CPU Resource Limit register */
+		TITAN_GE_WRITE(0x00f8, 0x8); 
+
+		/* Be conservative when using the BIU buffers */
+		TITAN_GE_WRITE(0x0068, 0x4);
+	}
+
+#ifdef TITAN_RX_NAPI
+	titan_port->tx_threshold = 0;
+	titan_port->rx_threshold = 0;
+#endif
+
+	/* We need to write the descriptors for Tx and Rx */
+        TITAN_GE_WRITE((TITAN_GE_CHANNEL0_TX_DESC + (port_num << 8)),
+                       (unsigned long) titan_port->tx_dma);
+        TITAN_GE_WRITE((TITAN_GE_CHANNEL0_RX_DESC + (port_num << 8)),
+                       (unsigned long) titan_port->rx_dma);
+
+	if (config_done == 0) {
+		/* Step 1:  XDMA config	*/
+	        reg_data = TITAN_GE_READ(TITAN_GE_XDMA_CONFIG);
+		reg_data &= ~(0x80000000);      /* clear reset */
+       		reg_data |= 0x1 << 29;	/* sparse tx descriptor spacing */
+		reg_data |= 0x1 << 28;	/* sparse rx descriptor spacing */
+		reg_data |= (0x1 << 23) | (0x1 << 24);  /* Descriptor Coherency */ 
+		reg_data |= (0x1 << 21) | (0x1 << 22);  /* Data Coherency */
+		TITAN_GE_WRITE(TITAN_GE_XDMA_CONFIG, reg_data);
+	}
+
+	/* IR register for the XDMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8));
+       	reg_data |= 0x80068000; /* No Rx_OOD */
+       	TITAN_GE_WRITE((TITAN_GE_GDI_INTERRUPT_ENABLE + (port_num << 8)), reg_data);
+
+	/* Start the Tx and Rx XDMA controller */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG + (port_num << 8));
+	reg_data &= 0x4fffffff;     /* Clear tx reset */
+	reg_data &= 0xfff4ffff;     /* Clear rx reset */
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	reg_data |= 0xa0 | 0x30030000;
+#else
+	reg_data |= 0x40 | 0x20030000;
+#endif
+
+#ifndef CONFIG_SMP
+	reg_data &= ~(0x10);
+	reg_data |= 0x0f; /* All of the packet */
+#endif
+
+        TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG + (port_num << 8)), reg_data);
+
+	/* Rx desc count */
+	count = titan_ge_rx_task(netdev, titan_port);
+	TITAN_GE_WRITE((0x5048 + (port_num << 8)), count);
+	count = TITAN_GE_READ(0x5048 + (port_num << 8));
+
+	udelay(30);
+
+	/* 
+	 * Step 2:  Configure the SDQPF, i.e. FIFO 
+	 */
+	if (config_done == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_CTL);
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_CTL, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+		reg_data = 0x1;
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data &= ~(0x1);
+        	TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_CTL);
+        	TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_CTL, reg_data);
+	}
+	/* 
+	 * Enable RX FIFO 0, 4 and 8 
+	 */
+	if (port_num == 0) {
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_RXFIFO_0);
+	
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+		/* 
+		 * BAV2,BAV and DAV settings for the Rx FIFO 
+		 */
+        	reg_data1 = TITAN_GE_READ(0x4844);
+	       	reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+        	TITAN_GE_WRITE(0x4844, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_RXFIFO_0, reg_data);
+
+		reg_data = TITAN_GE_READ(TITAN_GE_SDQPF_TXFIFO_0);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+		reg_data |= (0xff << 10);
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+	
+		/* 
+		 * BAV2, BAV and DAV settings for the Tx FIFO 
+		 */
+	        reg_data1 = TITAN_GE_READ(0x4944);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+	        TITAN_GE_WRITE(0x4944, reg_data1);
+	
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(TITAN_GE_SDQPF_TXFIFO_0, reg_data);
+
+	}
+
+	if (port_num == 1) {
+		reg_data = TITAN_GE_READ(0x4870);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (0xff + 1);
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4874);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x4874, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4870, reg_data);
+
+		reg_data = TITAN_GE_READ(0x494c);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+		reg_data |= (0xff << 10) | (0xff + 1);
+		TITAN_GE_WRITE(0x494c, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x4950);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x4950, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x494c, reg_data);
+	}
+
+	if (port_num == 2) {
+		reg_data = TITAN_GE_READ(0x48a0);
+
+		reg_data |= 0x100000;
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+		/*
+		 * BAV2,BAV and DAV settings for the Rx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x48a4);
+		reg_data1 |= ( (0x10 << 20) | (0x10 << 10) | 0x1);
+		TITAN_GE_WRITE(0x48a4, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x48a0, reg_data);
+
+		reg_data = TITAN_GE_READ(0x4958);
+		reg_data |= 0x100000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+		reg_data |= (0xff << 10) | (2*(0xff + 1));
+		TITAN_GE_WRITE(0x4958, reg_data);
+
+		/*
+		 * BAV2, BAV and DAV settings for the Tx FIFO
+		 */
+		reg_data1 = TITAN_GE_READ(0x495c);
+		reg_data1 = ( (0x1 << 20) | (0x1 << 10) | 0x10);
+
+		TITAN_GE_WRITE(0x495c, reg_data1);
+
+		reg_data &= ~(0x00100000);
+		reg_data |= 0x200000;
+
+		TITAN_GE_WRITE(0x4958, reg_data);
+	}
+
+	/* 
+	 * Step 3:  TRTG block enable 
+	 */
+	reg_data = TITAN_GE_READ(TITAN_GE_TRTG_CONFIG + (port_num << 12));
+	reg_data |= 0x0001; 
+	TITAN_GE_WRITE((TITAN_GE_TRTG_CONFIG + (port_num << 12)), reg_data);
+
+	/* 
+	 * Step 4:  Start the Tx activity 
+	 */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_2 + (port_num << 12)), 0xe197);
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1258 + (port_num << 12)), 0x4000);
+#endif
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* Enable TMAC */
+	reg_data |= 0x6c70;	/* PAUSE also set */
+
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/* Destination Address drop bit */
+        reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_2 + (port_num << 12));
+        reg_data |= 0x218;        /* DA_DROP bit and pause */
+        TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_2 + (port_num << 12)), reg_data);
+
+	TITAN_GE_WRITE((0x1218 + (port_num << 12)), 0x3);
+
+#ifdef TITAN_GE_JUMBO_FRAMES
+	TITAN_GE_WRITE((0x1208 + (port_num << 12)), 0x4000);
+#endif
+	/* Start the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + (port_num << 12));
+	reg_data |= 0x0001;	/* RMAC Enable */
+	reg_data |= 0x0010;	/* CRC Check enable */
+	reg_data |= 0x0040;	/* Min Frame check enable */
+	reg_data |= 0x4400;	/* Max Frame check enable */
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + (port_num << 12)), reg_data);
+
+	udelay(30);
+
+	/* 
+	 * Enable the Interrupts for Tx and Rx 
+	 */
+	reg_data1 = TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0) {
+		reg_data1 |= 0x3;
+#ifdef CONFIG_SMP
+		TITAN_GE_WRITE(0x0038, 0x003);
+#else
+		TITAN_GE_WRITE(0x0038, 0x303);
+#endif
+	}
+
+	if (port_num == 1) {
+		reg_data1 |= 0x300;
+	}
+
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data1);
+	TITAN_GE_WRITE(0x003c, 0x300);
+	
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x0024, 0x04000024);	/* IRQ vector */
+		TITAN_GE_WRITE(0x0020, 0x000fb000);	/* INTMSG base */
+	}
+
+	/* Priority */
+	reg_data = TITAN_GE_READ(0x1038 + (port_num << 12));
+	reg_data &= ~(0x00f00000);
+	TITAN_GE_WRITE((0x1038 + (port_num << 12)), reg_data);
+
+	/* Step 5:  GMII config */
+	titan_ge_gmii_config(port_num);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(0x1a80, 0);
+		config_done = 1;
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Function to queue the packet for the Ethernet device
+ */
+static void titan_ge_tx_queue(titan_ge_port_info * titan_ge_eth,
+				struct sk_buff * skb)
+{
+	volatile titan_ge_tx_desc *tx_curr;
+	int port_num = titan_ge_eth->port_num;
+	unsigned int curr_desc =
+			titan_ge_eth->tx_curr_desc_q;
+
+	tx_curr = &(titan_ge_eth->tx_desc_area[curr_desc]);
+	tx_curr->buffer_addr = 
+		pci_map_single(0, skb->data, skb->len - skb->data_len,
+					PCI_DMA_TODEVICE);
+
+	titan_ge_eth->tx_skb[curr_desc] = (struct sk_buff *) skb;
+	tx_curr->buffer_len = skb->len - skb->data_len;
+
+	/* Last descriptor enables interrupt and changes ownership */
+	tx_curr->cmd_sts = 0x1 | (1 << 15) | (1 << 5);
+
+	/* Kick the XDMA to start the transfer from memory to the FIFO */
+        TITAN_GE_WRITE((0x5044 + (port_num << 8)), 0x1);
+
+	/* Current descriptor updated */
+	titan_ge_eth->tx_curr_desc_q = (curr_desc + 1) % TITAN_GE_TX_QUEUE;
+
+	/* Prefetch the next descriptor */
+#ifdef CONFIG_CPU_HAS_PREFETCH
+	rm9000_prefetch(&(titan_ge_eth->tx_desc_area[
+				titan_ge_eth->tx_curr_desc_q]));
+#endif
+}
+
+/*
+ * Actually does the open of the Ethernet device
+ */
+static int titan_ge_eth_open(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num, size, phy_reg;
+	unsigned long reg_data;
+	int err = 0;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	/* Stop the Rx activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	/* Clear the port interrupts */
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_INTERRUPT +
+			(port_num << 8)), 0x0);
+
+	if (config_done == 0) {
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0);
+		TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_B, 0);
+	}
+
+	/* Set the MAC Address */
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+	
+	if (config_done == 0)
+		titan_port_init(netdev, titan_ge_eth);
+
+	titan_ge_update_afx(titan_ge_eth);
+
+	/* Allocate the Tx ring now */
+	titan_ge_eth->tx_ring_skbs = 0;
+	titan_ge_eth->tx_ring_size = TITAN_GE_TX_QUEUE;
+	size = titan_ge_eth->tx_ring_size * sizeof(titan_ge_tx_desc);
+
+	/* Allocate space in the SRAM for the descriptors */
+        if (port_num == 0) {
+                titan_ge_eth->tx_desc_area =
+                    (titan_ge_tx_desc *) (TITAN_GE_SRAM_BASE_VIRTUAL);
+
+                titan_ge_eth->tx_dma = (TITAN_GE_SRAM_BASE_PHYSICAL);
+        }
+
+	if (port_num == 1) {
+		titan_ge_eth->tx_desc_area =
+		    (titan_ge_tx_desc *) (TITAN_GE_SRAM_BASE_VIRTUAL + 0x100);
+		
+		titan_ge_eth->tx_dma = (TITAN_GE_SRAM_BASE_PHYSICAL + 0x100);
+	}
+
+	if (!titan_ge_eth->tx_desc_area) {
+		printk(KERN_ERR
+		       "%s: Cannot allocate Tx Ring (size %d bytes) for port %d\n",
+		       netdev->name, size, port_num);
+		return -ENOMEM;
+	}
+
+	memset((void *) titan_ge_eth->tx_desc_area, 0,
+	       titan_ge_eth->tx_desc_area_size);
+
+	/* Now initialize the Tx descriptor ring */
+	titan_ge_init_tx_desc_ring(titan_ge_eth,
+				   titan_ge_eth->tx_ring_size,
+				   (unsigned long) titan_ge_eth->
+				   tx_desc_area,
+				   (unsigned long) titan_ge_eth->tx_dma);
+
+	/* Allocate the Rx ring now */
+	titan_ge_eth->rx_ring_size = TITAN_GE_RX_QUEUE;
+	titan_ge_eth->rx_ring_skbs = 0;
+	size = titan_ge_eth->rx_ring_size * sizeof(titan_ge_rx_desc);
+
+	if (port_num == 0) {
+		titan_ge_eth->rx_desc_area =
+			(titan_ge_rx_desc *)(TITAN_GE_SRAM_BASE_VIRTUAL + 0x1000);
+
+		titan_ge_eth->rx_dma = (TITAN_GE_SRAM_BASE_PHYSICAL + 0x1000);
+	}
+
+	if (port_num == 1) {
+		titan_ge_eth->rx_desc_area =
+			(titan_ge_rx_desc *)(TITAN_GE_SRAM_BASE_VIRTUAL + 0x1100);
+		titan_ge_eth->rx_dma = (TITAN_GE_SRAM_BASE_PHYSICAL + 0x1100);
+	}
+
+	if (!titan_ge_eth->rx_desc_area) {
+		printk(KERN_ERR
+		       "%s: Cannot allocate Rx Ring (size %d bytes)\n",
+		       netdev->name, size);
+
+		printk(KERN_ERR
+		       "%s: Freeing previously allocated TX queues...",
+		       netdev->name);
+
+		pci_free_consistent(0, titan_ge_eth->tx_desc_area_size,
+				    (void *) titan_ge_eth->tx_desc_area,
+				    titan_ge_eth->tx_dma);
+
+		return -ENOMEM;
+	}
+
+	memset((void *) titan_ge_eth->rx_desc_area, 0,
+	       titan_ge_eth->tx_desc_area_size);
+
+	/* Now initialize the Rx ring */
+#ifdef TITAN_GE_JUMBO_FRAMES
+	if ((titan_ge_init_rx_desc_ring
+	    (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_JUMBO_BUFSIZE,
+	     (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#else
+	if ((titan_ge_init_rx_desc_ring
+	     (titan_ge_eth, titan_ge_eth->rx_ring_size, TITAN_GE_STD_BUFSIZE,
+	      (unsigned long) titan_ge_eth->rx_desc_area, 0,
+	      (unsigned long) titan_ge_eth->rx_dma)) == 0)
+#endif
+		panic("%s: Error initializing RX Ring\n", netdev->name);
+
+	/* Fill the Rx ring with the SKBs */
+	titan_ge_port_start(netdev, titan_ge_eth);
+
+	/* 
+	 * Check if Interrupt Coalscing needs to be turned on. The
+	 * values specified in the register is multiplied by 
+	 * (8 x 64 nanoseconds) to determine when an interrupt should
+	 * be sent to the CPU. 
+	 */
+#ifndef TITAN_RX_NAPI
+	/* 
+	 * If NAPI is turned on, we disable Rx interrupts
+	 * completely. So, we dont need coalescing then. Tx side
+	 * coalescing set to very high value. Maybe, disable
+	 * Tx side interrupts completely
+	 */
+	if (TITAN_GE_RX_COAL) {
+		titan_ge_eth->rx_int_coal =
+		    titan_ge_rx_coal(TITAN_GE_RX_COAL, port_num);
+	} 
+
+#endif
+	if (TITAN_GE_TX_COAL) {
+		titan_ge_eth->tx_int_coal =
+		    titan_ge_tx_coal(TITAN_GE_TX_COAL, port_num);
+	}
+
+	err =
+	    titan_ge_mdio_read(port_num,
+			       TITAN_GE_MDIO_PHY_STATUS, &phy_reg);
+	if (err == TITAN_GE_MDIO_ERROR) {
+		printk(KERN_ERR
+		       "Could not read PHY control register 0x11 \n");
+		return TITAN_ERROR;
+	}
+	if (!(phy_reg & 0x0400)) {
+		netif_carrier_off(netdev);
+		netif_stop_queue(netdev);
+		return TITAN_ERROR;
+	} else {
+		netif_carrier_on(netdev);
+		netif_start_queue(netdev);
+	}
+
+	return TITAN_OK;
+}
+
+/*
+ * Queue the packet for Tx. Currently no support for zero copy, 
+ * checksum offload and Scatter Gather. The chip does support 
+ * Scatter Gather only. But, that wont help here since zero copy 
+ * requires support for Tx checksumming also. 
+ */
+int titan_ge_start_xmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned long flags;
+	struct net_device_stats *stats;
+	titan_ge_eth = netdev->priv;
+
+	stats = &titan_ge_eth->stats;
+#ifdef CONFIG_SMP
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+#else
+	local_irq_save(flags);
+#endif
+
+	if ((TITAN_GE_TX_QUEUE - titan_ge_eth->tx_ring_skbs) <=
+	    (skb_shinfo(skb)->nr_frags + 1)) {
+		netif_stop_queue(netdev);
+#ifdef CONFIG_SMP
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+#else
+		local_irq_restore(flags);
+#endif
+		printk(KERN_ERR "Tx OOD \n");
+		return 1;
+	}
+
+	titan_ge_tx_queue(titan_ge_eth, skb);
+	titan_ge_eth->tx_ring_skbs++;
+
+	if (TITAN_GE_TX_QUEUE <= (titan_ge_eth->tx_ring_skbs + 4)) {
+#ifdef CONFIG_SMP
+		spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+#else
+		local_irq_restore(flags);
+#endif
+		titan_ge_free_tx_queue(titan_ge_eth);
+#ifdef CONFIG_SMP
+		spin_lock_irqsave(&titan_ge_eth->lock, flags);
+#else
+		local_irq_save(flags);
+#endif
+	}
+
+	stats->tx_bytes += skb->len;
+	stats->tx_packets++;
+
+#ifdef CONFIG_SMP
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	netdev->trans_start = jiffies;
+
+	return 0;
+}
+
+#ifdef CONFIG_NET_FASTROUTE
+/*
+ * Fast forward function for the fast routing. Helps
+ * in IP forwarding. No semi fast forward since we
+ * have to do that extra copy on the Rx for the IP
+ * header alignment
+ */
+static int titan_ge_fast_forward(struct net_device *dev, 
+			struct sk_buff *skb, int len)
+{
+	titan_ge_port_info *titan_ge_eth = 
+			(titan_ge_port_info *)dev->priv;
+	struct ethhdr *eth = (void*)skb->data;
+
+	if (eth->h_proto == __constant_htons(ETH_P_IP)) {
+		struct rtable *rt;
+		struct iphdr *iph;
+		unsigned h;
+
+		iph = (struct iphdr*)(skb->data + ETH_HLEN);
+		h=(*(u8*)&iph->daddr^*(u8*)&iph->saddr)&NETDEV_FASTROUTE_HMASK;
+		rt = (struct rtable*)(dev->fastpath[h]);
+		if (rt &&
+			((u16*)&iph->daddr)[0] == ((u16*)&rt->key.dst)[0] &&
+			((u16*)&iph->daddr)[1] == ((u16*)&rt->key.dst)[1] &&
+			((u16*)&iph->saddr)[0] == ((u16*)&rt->key.src)[0] &&
+			((u16*)&iph->saddr)[1] == ((u16*)&rt->key.src)[1] &&
+			rt->u.dst.obsolete == 0) {
+				struct net_device *odev = rt->u.dst.dev;
+
+				if (*(u8*)iph != 0x45 ||
+					(eth->h_dest[0]&1) ||
+					!neigh_is_valid(rt->u.dst.neighbour) ||
+					iph->ttl <= 1) {
+						return 1;		
+				}
+				ip_decrease_ttl(iph);
+				skb_put(skb, len);
+
+				memcpy(eth->h_source, odev->dev_addr, 6);
+				memcpy(eth->h_dest, rt->u.dst.neighbour->ha, 6);
+				skb->dev = odev;
+				skb->pkt_type = PACKET_FASTROUTE;
+
+				if (netif_running(odev) &&
+				   (spin_trylock(&odev->xmit_lock))) {
+					if(odev->xmit_lock_owner != 0) {
+						odev->xmit_lock_owner=0;
+					}
+					if (odev->hard_start_xmit(skb,odev) == 0) {
+						odev->xmit_lock_owner=-1;
+						spin_unlock(&odev->xmit_lock);
+						return 0;
+					} 
+				}
+				skb->nh.raw = skb->data + ETH_HLEN;
+				skb->protocol = __constant_htons(ETH_P_IP);
+				return 1;
+			}
+	}
+	return 1;
+}
+
+#endif
+
+/*
+ * Actually does the Rx. Rx side checksumming supported.
+ */
+static int titan_ge_rx(struct net_device *netdev, int port_num,
+			titan_ge_port_info * titan_ge_port,
+		       titan_ge_packet * packet)
+{
+	int rx_curr_desc, rx_used_desc;
+	volatile titan_ge_rx_desc *rx_desc;
+
+	rx_curr_desc = titan_ge_port->rx_curr_desc_q;
+	rx_used_desc = titan_ge_port->rx_used_desc_q;
+
+	if (((rx_curr_desc + 1) % TITAN_GE_RX_QUEUE) == rx_used_desc) 
+		return TITAN_ERROR;
+
+	rx_desc = &(titan_ge_port->rx_desc_area[rx_curr_desc]);
+
+	if (rx_desc->cmd_sts & TITAN_GE_RX_BUFFER_OWNED) 
+		return TITAN_ERROR;
+
+	packet->skb = titan_ge_port->rx_skb[rx_curr_desc];
+	packet->len = (rx_desc->cmd_sts & 0x7fff);
+
+	/* 
+	 * At this point, we dont know if the checksumming 
+	 * actually helps relieve CPU. So, keep it for 
+	 * port 0 only
+	 */
+	packet->checksum = ntohs((rx_desc->buffer & 0xffff0000) >> 16);
+
+	titan_ge_port->rx_curr_desc_q =
+	    (rx_curr_desc + 1) % TITAN_GE_RX_QUEUE;
+	
+	/* Prefetch the next descriptor */
+#ifdef CONFIG_CPU_HAS_PREFETCH
+	rm9000_prefetch(&(titan_ge_port->rx_desc_area[
+			titan_ge_port->rx_curr_desc_q + 1]));
+#endif
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx queue of the used SKBs
+ */
+static int titan_ge_free_tx_queue(titan_ge_port_info *titan_ge_eth)
+{
+	unsigned long flags;
+
+	/* Take the lock */
+#ifdef CONFIG_SMP
+	spin_lock_irqsave(&(titan_ge_eth->lock), flags);
+#else
+	local_irq_save(flags);
+#endif
+
+	while (titan_ge_return_tx_desc(titan_ge_eth, titan_ge_eth->port_num) == 0) 
+		if (titan_ge_eth->tx_ring_skbs != 1)
+			titan_ge_eth->tx_ring_skbs--;
+
+#ifdef CONFIG_SMP
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	return TITAN_OK;
+}
+
+/*
+ * Do the slowpath route. This route is kicked off
+ * when the IP header is misaligned. Grrr ..
+ */
+static int titan_ge_slowpath(struct sk_buff *skb,
+				titan_ge_packet *packet,
+				struct net_device *netdev)
+{
+	struct sk_buff *copy_skb;
+
+	copy_skb = dev_alloc_skb(packet->len + 2);
+
+	if (!copy_skb) {
+		dev_kfree_skb_any(packet->skb);
+		return -1;
+	}
+
+	copy_skb->dev = netdev;
+	skb_reserve(copy_skb, 2);
+	skb_put(copy_skb, packet->len);
+
+	memcpy(copy_skb->data, skb->data, packet->len);
+
+	/* Titan supports Rx checksum offload */
+	copy_skb->ip_summed = CHECKSUM_HW;
+	copy_skb->csum = packet->checksum;
+
+	copy_skb->protocol = eth_type_trans(copy_skb, netdev);
+
+	dev_kfree_skb_any(packet->skb);
+#ifdef TITAN_RX_NAPI
+	netif_receive_skb(copy_skb);
+#else
+	netif_rx(copy_skb);
+#endif
+
+	return 0;
+}
+
+/*
+ * Threshold beyond which we do the cleaning of
+ * Tx queue and new allocation for the Rx 
+ * queue
+ */
+#define	TX_THRESHOLD	4
+#define	RX_THRESHOLD	10
+
+/*
+ * Receive the packets and send it to the kernel. 
+ */
+int titan_ge_receive_queue(struct net_device *netdev, unsigned int max)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num;
+	titan_ge_packet packet;
+	struct net_device_stats *stats;
+	struct sk_buff *skb;
+	unsigned long received_packets = 0;
+	unsigned int ack;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+	stats = &titan_ge_eth->stats;
+
+	while ((--max)
+	       && (titan_ge_rx(netdev, port_num, titan_ge_eth, &packet) == TITAN_OK)) {
+
+		titan_ge_eth->rx_ring_skbs--;
+
+#ifdef TITAN_RX_NAPI
+		if (--titan_ge_eth->rx_work_limit < 0)
+			break;
+		received_packets++;
+#endif
+		stats->rx_packets++;
+		stats->rx_bytes += packet.len;
+
+		if ((packet.cmd_sts & TITAN_GE_RX_PERR) ||
+			(packet.cmd_sts & TITAN_GE_RX_OVERFLOW_ERROR) ||
+			(packet.cmd_sts & TITAN_GE_RX_TRUNC) ||
+			(packet.cmd_sts & TITAN_GE_RX_CRC_ERROR)) {
+				stats->rx_dropped++;
+				dev_kfree_skb_any(skb);
+	
+				continue;
+		}
+		/* 
+		 * Either support fast path or slow path. Decision
+		 * making can really slow down the performance. The
+		 * idea is to cut down the number of checks and improve
+		 * the fastpath.
+		 */
+#ifdef CONFIG_NET_FASTROUTE
+		switch (titan_ge_fast_forward(netdev, 
+				packet.skb, packet.len)) {
+			case 0:
+				goto gone;
+			case 1:
+				break;
+		}
+#endif
+		skb = (struct sk_buff *) packet.skb;
+		/*
+		 * This chip is wierd. Does not have a byte level offset
+		 * to fix the IP header alignment issue. Now, do an extra
+		 * copy only if the custom pattern is not present
+		 */
+		skb_put(skb, packet.len);
+
+		/* Check to make sure this is the custom packet */
+		if (*(skb->data) == 0x0) {
+			skb_reserve(skb, 2);
+			skb->protocol = eth_type_trans(skb, netdev);
+			netif_receive_skb(skb);
+		}
+		else 	
+			if (titan_ge_slowpath(skb, &packet, netdev) < 0) 
+				goto out_next;
+#ifdef CONFIG_NET_FASTROUTE
+gone:
+#endif
+
+#ifdef TITAN_RX_NAPI
+		if (titan_ge_eth->rx_threshold > RX_THRESHOLD) {
+			ack = titan_ge_rx_task(netdev, titan_ge_eth);
+        	        TITAN_GE_WRITE((0x5048 + (port_num << 8)), ack);
+			titan_ge_eth->rx_threshold = 0;
+		} else
+			titan_ge_eth->rx_threshold++;
+#else
+		ack = titan_ge_rx_task(netdev, titan_ge_eth);
+		TITAN_GE_WRITE((0x5048 + (port_num << 8)), ack);
+#endif
+
+out_next:
+
+#ifdef TITAN_RX_NAPI
+		if (titan_ge_eth->tx_threshold > TX_THRESHOLD) {
+			titan_ge_eth->tx_threshold = 0;
+			titan_ge_free_tx_queue(titan_ge_eth);
+		}
+		else
+			titan_ge_eth->tx_threshold++;
+#endif
+
+	}
+	return received_packets;
+}
+
+
+#ifdef TITAN_RX_NAPI
+
+/*
+ * Enable the Rx side interrupts 
+ */
+static void titan_ge_enable_int(unsigned int port_num,
+			titan_ge_port_info *titan_ge_eth,
+			struct net_device *netdev)
+{
+	unsigned long reg_data = 
+		TITAN_GE_READ(TITAN_GE_INTR_XDMA_IE);
+
+	if (port_num == 0)
+		reg_data |= 0x3;
+	if (port_num == 1)
+		reg_data |= 0x300;
+	if (port_num == 2)
+		reg_data |= 0x30000;
+
+	/* Re-enable interrupts */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, reg_data);
+}
+
+/*
+ * Main function to handle the polling for Rx side NAPI.
+ * Receive interrupts have been disabled at this point. 
+ * The poll schedules the transmit followed by receive.
+ */	
+static int titan_ge_poll(struct net_device *netdev, int *budget)
+{
+        titan_ge_port_info *titan_ge_eth = netdev->priv;
+        int port_num = titan_ge_eth->port_num; 
+	int work_done = 0; 
+	unsigned long flags, status;
+
+	titan_ge_eth->rx_work_limit = *budget;
+        if (titan_ge_eth->rx_work_limit > netdev->quota)
+                titan_ge_eth->rx_work_limit = netdev->quota;
+
+	do {
+		/* Do the transmit cleaning work here */
+		titan_ge_free_tx_queue(titan_ge_eth);
+
+		/* Ack the Rx interrupts */
+		if (port_num == 0) 
+			TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x3);
+                if (port_num == 1)
+                        TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x300);
+                if (port_num == 2)
+                        TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_CORE_A, 0x30000);
+
+	        work_done += titan_ge_receive_queue(netdev, 0);
+
+		/* Out of quota and there is work to be done */	
+		if (titan_ge_eth->rx_work_limit < 0)
+			goto not_done;			
+
+		/* Receive alloc_skb could lead to OOM */	
+		if (oom_flag == 1) {
+			oom_flag = 0;
+			goto oom;
+		}
+
+		status = TITAN_GE_READ(TITAN_GE_INTR_XDMA_CORE_A);
+	} while (status & 0x30300);
+
+	/* If we are here, then no more interrupts to process */
+	goto done;
+
+not_done:
+	*budget -= work_done;
+	netdev->quota -= work_done;
+	return 1;
+
+oom:
+	printk(KERN_ERR "OOM \n");
+	netif_rx_complete(netdev);
+	return 0;
+
+done:
+	/*
+	 * No more packets on the poll list. Turn the interrupts 
+	 * back on and we should be able to catch the new
+	 * packets in the interrupt handler
+	 */
+	if (!work_done)
+		work_done = 1;
+
+	*budget -= work_done;
+        netdev->quota -= work_done;
+
+#ifdef CONFIG_SMP
+	spin_lock_irqsave(&titan_ge_eth->lock, flags);
+#else
+	local_irq_save(flags);
+#endif
+
+	/* Remove us from the poll list */
+	netif_rx_complete(netdev);
+
+	/* Re-enable interrupts */
+	titan_ge_enable_int(port_num, titan_ge_eth, netdev);
+
+#ifdef CONFIG_SMP
+	spin_unlock_irqrestore(&titan_ge_eth->lock, flags);
+#else
+	local_irq_restore(flags);
+#endif
+
+	return 0;
+}
+#endif
+
+/*
+ * Close the network device
+ */
+int titan_ge_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	spin_lock_irq(&(titan_ge_eth->lock));
+	titan_ge_eth_stop(netdev);
+	free_irq(netdev->irq, netdev);
+	MOD_DEC_USE_COUNT;
+	spin_unlock_irq(&titan_ge_eth->lock);
+
+	return TITAN_OK;
+}
+
+/*
+ * Free the Tx ring
+ */
+static void titan_ge_free_tx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num, curr;
+	unsigned long reg_data;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	/* Stop the Tx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG +
+				(port_num << 8));
+	reg_data |= 0xc0000000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the TMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     (titan_ge_eth->tx_ring_skbs) && (curr < TITAN_GE_TX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->tx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->tx_skb[curr]);
+			titan_ge_eth->tx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->tx_ring_skbs != 0)
+		printk
+		    ("%s: Error on Tx descriptor free - could not free %d"
+		     " descriptors\n", netdev->name,
+		     titan_ge_eth->tx_ring_skbs);
+
+	pci_free_consistent(0, titan_ge_eth->tx_desc_area_size,
+			    (void *) titan_ge_eth->tx_desc_area,
+			    titan_ge_eth->tx_dma);
+}
+
+/*
+ * Free the Rx ring
+ */
+static void titan_ge_free_rx_rings(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num, curr;
+	unsigned long reg_data;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	/* Stop the Rx DMA */
+	reg_data = TITAN_GE_READ(TITAN_GE_CHANNEL0_CONFIG + 
+				(port_num << 8));
+	reg_data |= 0x000c0000;
+	TITAN_GE_WRITE((TITAN_GE_CHANNEL0_CONFIG +
+			(port_num << 8)), reg_data);
+
+	/* Disable the RMAC */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 +
+				(port_num << 12));
+	reg_data &= ~(0x00000001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 +
+			(port_num << 12)), reg_data);
+
+	for (curr = 0;
+	     titan_ge_eth->rx_ring_skbs && (curr < TITAN_GE_RX_QUEUE);
+	     curr++) {
+		if (titan_ge_eth->rx_skb[curr]) {
+			dev_kfree_skb(titan_ge_eth->rx_skb[curr]);
+			titan_ge_eth->rx_ring_skbs--;
+		}
+	}
+
+	if (titan_ge_eth->rx_ring_skbs != 0)
+		printk(KERN_ERR
+		       "%s: Error in freeing Rx Ring. %d skb's still"
+		       " stuck in RX Ring - ignoring them\n", netdev->name,
+		       titan_ge_eth->rx_ring_skbs);
+
+	pci_free_consistent(0, titan_ge_eth->rx_desc_area_size,
+			    (void *) titan_ge_eth->rx_desc_area,
+			    titan_ge_eth->rx_dma);
+}
+
+/*
+ * Actually does the stop of the Ethernet device
+ */
+static int titan_ge_eth_stop(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	netif_stop_queue(netdev);
+
+	titan_ge_port_reset(titan_ge_eth->port_num);
+
+	titan_ge_free_tx_rings(netdev);
+	titan_ge_free_rx_rings(netdev);
+
+	/* Disable the Tx and Rx Interrupts for all channels */
+	TITAN_GE_WRITE(TITAN_GE_INTR_XDMA_IE, 0x0);
+
+	return TITAN_OK;
+}
+
+/*
+ * Update the MAC address. Note that we have to write the 
+ * address in three station registers, 16 bits each. And this 
+ * has to be done for TMAC and RMAC
+ */
+static void titan_ge_update_mac_address(struct net_device *netdev)
+{
+	titan_ge_port_info *titan_ge_eth = netdev->priv;
+	unsigned int port_num = titan_ge_eth->port_num;
+	u8 p_addr[6];
+
+	memcpy(titan_ge_eth->port_mac_addr, netdev->dev_addr, 6);
+	memcpy(p_addr, netdev->dev_addr, 6);
+
+	/* Update the Address Filtering Match tables */
+	titan_ge_update_afx(titan_ge_eth);
+
+	printk("Station MAC : %d %d %d %d %d %d  \n", 
+		p_addr[5], p_addr[4], p_addr[3], 
+		p_addr[2], p_addr[1], p_addr[0]);
+
+	/* Set the MAC address here for TMAC and RMAC */
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_TMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_HI + (port_num << 12)),
+		       ((p_addr[5] << 8) | p_addr[4]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_MID + (port_num << 12)),
+		       ((p_addr[3] << 8) | p_addr[2]));
+	TITAN_GE_WRITE((TITAN_GE_RMAC_STATION_LOW + (port_num << 12)),
+		       ((p_addr[1] << 8) | p_addr[0]));
+
+	return;
+}
+
+/*
+ * Set the MAC address of the Ethernet device
+ */
+int titan_ge_set_mac_address(struct net_device *netdev, void *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++)
+		netdev->dev_addr[i] = ((unsigned char *) addr)[i + 2];
+
+	titan_ge_update_mac_address(netdev);
+	return 0;
+}
+
+/*
+ * Get the Ethernet device stats
+ */
+static struct net_device_stats *titan_ge_get_stats(struct net_device
+						   *netdev)
+{
+	titan_ge_port_info *titan_ge_eth;
+	unsigned int port_num;
+
+	titan_ge_eth = netdev->priv;
+	port_num = titan_ge_eth->port_num;
+
+	return &titan_ge_eth->stats;
+}
+
+/*
+ * Register the Titan GE with the kernel
+ */
+static int __init titan_ge_init_module(void)
+{
+	unsigned long version, device;
+
+	printk(KERN_NOTICE
+	       "PMC-Sierra TITAN 10/100/1000 Ethernet Driver \n");
+	device = TITAN_GE_READ(TITAN_GE_DEVICE_ID);
+	version = (device & 0x000f0000) >> 16;
+	device &= 0x0000ffff;
+
+	printk(KERN_NOTICE "Device Id : %x,  Version : %x \n", device,
+	       version);
+
+	/* Register only one port */ 
+	if (titan_ge_init(0)) 
+		printk(KERN_ERR
+		       "Error registering the TITAN Ethernet driver"
+			"for port 0 \n");
+	
+	if (titan_ge_init(1)) 
+		printk(KERN_ERR "Error registering the TITAN Ethernet" 
+				"driver for port 1\n");
+
+	return 0;
+}
+
+/*
+ * Unregister the Titan GE from the kernel
+ */
+static void __init titan_ge_cleanup_module(void)
+{
+	/* Nothing to do here */
+}
+
+module_init(titan_ge_init_module);
+module_exit(titan_ge_cleanup_module);
+
+/*
+ * Initialize the Rx descriptor ring for the Titan Ge
+ */
+static int titan_ge_init_rx_desc_ring(titan_ge_port_info * titan_eth_port,
+				      int rx_desc_num,
+				      int rx_buff_size,
+				      unsigned long rx_desc_base_addr,
+				      unsigned long rx_buff_base_addr,
+				      unsigned long rx_dma)
+{
+	volatile titan_ge_rx_desc *rx_desc;
+	unsigned long buffer_addr;
+	int index;
+	unsigned long titan_ge_rx_desc_bus = rx_dma;
+
+	buffer_addr = rx_buff_base_addr;
+	rx_desc = (titan_ge_rx_desc *) rx_desc_base_addr;
+
+	/* Check alignment */
+	if (rx_buff_base_addr & 0xF)
+		return 0;
+
+	/* Check Rx buffer size */
+	if ((rx_buff_size < 8) || (rx_buff_size > TITAN_GE_MAX_RX_BUFFER))
+		return 0;
+
+	/* 64-bit alignment 
+	if ((rx_buff_base_addr + rx_buff_size) & 0x7)
+		return 0; */
+
+	/* Initialize the Rx desc ring */
+	for (index = 0; index < rx_desc_num; index++) {
+		titan_ge_rx_desc_bus += sizeof(titan_ge_rx_desc);
+		rx_desc[index].cmd_sts = 0;
+		rx_desc[index].buffer_addr = buffer_addr;
+		titan_eth_port->rx_skb[index] = NULL;
+		buffer_addr += rx_buff_size;
+	}
+
+	titan_eth_port->rx_curr_desc_q = 0;
+	titan_eth_port->rx_used_desc_q = 0;
+
+	titan_eth_port->rx_desc_area =
+	    (titan_ge_rx_desc *) rx_desc_base_addr;
+	titan_eth_port->rx_desc_area_size =
+	    rx_desc_num * sizeof(titan_ge_rx_desc);
+	
+	titan_eth_port->rx_dma = rx_dma;
+
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the Tx descriptor ring. Descriptors in the SRAM
+ */
+static int titan_ge_init_tx_desc_ring(titan_ge_port_info * titan_ge_port,
+				      int tx_desc_num,
+				      unsigned long tx_desc_base_addr,
+				      unsigned long tx_dma)
+{
+	titan_ge_tx_desc *tx_desc;
+	int index;
+	unsigned long titan_ge_tx_desc_bus = tx_dma;
+
+	if (tx_desc_base_addr & 0xF)
+		return 0;
+
+	tx_desc = (titan_ge_tx_desc *) tx_desc_base_addr;
+
+	for (index = 0; index < tx_desc_num; index++) {
+		titan_ge_port->tx_dma_array[index] =
+		    (dma_addr_t) titan_ge_tx_desc_bus;
+		titan_ge_tx_desc_bus += sizeof(titan_ge_tx_desc);
+		tx_desc[index].cmd_sts = 0x0000;
+		tx_desc[index].buffer_len = 0;
+		tx_desc[index].buffer_addr = 0x00000000;
+		titan_ge_port->tx_skb[index] = NULL;
+	}
+
+	titan_ge_port->tx_curr_desc_q = 0;
+	titan_ge_port->tx_used_desc_q = 0;
+
+	titan_ge_port->tx_desc_area =
+	    (titan_ge_tx_desc *) tx_desc_base_addr;
+	titan_ge_port->tx_desc_area_size =
+	    tx_desc_num * sizeof(titan_ge_tx_desc);
+
+	titan_ge_port->tx_dma = tx_dma;
+	return TITAN_OK;
+}
+
+/*
+ * Initialize the device as an Ethernet device
+ */
+static int titan_ge_init(int port)
+{
+	titan_ge_port_info *titan_ge_eth;
+	struct net_device *netdev;
+	int err;
+
+	netdev = alloc_etherdev(sizeof(titan_ge_port_info));
+	if (!netdev) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	netdev->open = titan_ge_open;
+	netdev->stop = titan_ge_stop;
+	netdev->hard_start_xmit = titan_ge_start_xmit;
+	netdev->get_stats = titan_ge_get_stats;
+	netdev->set_multicast_list = titan_ge_set_multi;
+	netdev->set_mac_address = titan_ge_set_mac_address;
+
+	/* Tx timeout */
+	netdev->tx_timeout = titan_ge_tx_timeout;
+	netdev->watchdog_timeo = 2 * HZ;
+
+#ifdef TITAN_RX_NAPI
+	/* Set these to very high values */
+	netdev->poll = titan_ge_poll;
+	netdev->weight = 64;
+#endif
+	netdev->tx_queue_len = TITAN_GE_TX_QUEUE;
+	netif_carrier_off(netdev);
+	netdev->base_addr = 0;
+
+#ifdef CONFIG_NET_FASTROUTE
+	netdev->accept_fastpath = titan_accept_fastpath;
+#endif
+
+	netdev->change_mtu = titan_ge_change_mtu;
+
+	titan_ge_eth = netdev->priv;
+	/* Allocation of memory for the driver structures */
+
+	titan_ge_eth->port_num = port;
+
+	memset(&titan_ge_eth->stats, 0, sizeof(struct net_device_stats));
+
+	/* Configure the Tx timeout handler */
+	INIT_TQUEUE(&titan_ge_eth->tx_timeout_task,
+		    (void (*)(void *)) titan_ge_tx_timeout_task, netdev);
+
+	spin_lock_init(&titan_ge_eth->lock);
+
+	/* set MAC addresses */
+	memcpy(netdev->dev_addr, titan_ge_mac_addr_base, 6);
+	netdev->dev_addr[5] += port;
+
+	err = register_netdev(netdev);
+
+        if (err)
+                goto out_free_private;
+
+	printk(KERN_NOTICE
+	       "%s: port %d with MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       netdev->name, port, netdev->dev_addr[0],
+	       netdev->dev_addr[1], netdev->dev_addr[2],
+	       netdev->dev_addr[3], netdev->dev_addr[4],
+	       netdev->dev_addr[5]);
+
+#ifdef TITAN_RX_NAPI
+	printk(KERN_NOTICE "Rx NAPI supported, Tx Coalescing ON \n");
+#else
+	printk(KERN_NOTICE "Rx and Tx Coalescing ON \n");
+#endif
+
+	return 0;
+
+out_free_private:
+
+out_free_netdev:
+	kfree(netdev);
+
+out:
+	return err;
+}
+
+/*
+ * Reset the Ethernet port
+ */
+static void titan_ge_port_reset(unsigned int port_num)
+{
+	unsigned int reg_data;
+
+	/* Stop the Tx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_TMAC_CONFIG_1 + 
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_TMAC_CONFIG_1 + 
+			(port_num << 12)), reg_data);
+
+	/* Stop the Rx port activity */
+	reg_data = TITAN_GE_READ(TITAN_GE_RMAC_CONFIG_1 + 
+				(port_num << 12));
+	reg_data &= ~(0x0001);
+	TITAN_GE_WRITE((TITAN_GE_RMAC_CONFIG_1 + 
+			(port_num << 12)), reg_data);
+
+	return;
+}
+
+/*
+ * Return the Tx desc after use by the XDMA
+ */
+static int titan_ge_return_tx_desc(titan_ge_port_info * titan_ge_eth, int port)
+{
+	int tx_desc_used;
+	struct sk_buff *skb;
+
+	tx_desc_used = titan_ge_eth->tx_used_desc_q;
+
+	/* return right away */
+	if (tx_desc_used == titan_ge_eth->tx_curr_desc_q)
+		return TITAN_ERROR;
+
+	/* Now the critical stuff */
+	skb = titan_ge_eth->tx_skb[tx_desc_used];
+
+	dev_kfree_skb_any(skb);
+
+	titan_ge_eth->tx_skb[tx_desc_used] = NULL;
+	titan_ge_eth->tx_used_desc_q =
+	    (tx_desc_used + 1) % TITAN_GE_TX_QUEUE;
+
+	return 0;
+}
+
+#ifndef TITAN_RX_NAPI
+/*
+ * Coalescing for the Rx path
+ */
+static unsigned long titan_ge_rx_coal(unsigned long delay, int port)
+{
+	TITAN_GE_WRITE(TITAN_GE_INT_COALESCING, delay);
+	TITAN_GE_WRITE(0x5038, delay);
+
+	return delay;
+}
+#endif
+
+/*
+ * Coalescing for the Tx path
+ */
+static unsigned long titan_ge_tx_coal(unsigned long delay, int port)
+{
+	unsigned long rx_delay;
+
+	rx_delay = TITAN_GE_READ(TITAN_GE_INT_COALESCING);
+	delay = (delay << 16) | rx_delay;
+
+	TITAN_GE_WRITE(TITAN_GE_INT_COALESCING, delay);
+	TITAN_GE_WRITE(0x5038, delay);
+
+	return delay;
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/titan_ge.h linux-mips-cvs-20040815/drivers/net/titan_ge.h
--- linux-2.4.27/drivers/net/titan_ge.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/titan_ge.h	2004-08-15 08:06:19.000000000 +0200
@@ -0,0 +1,436 @@
+#ifndef _TITAN_GE_H_
+#define _TITAN_GE_H_
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/spinlock.h>
+#include <asm/addrspace.h> /* For KSEG1ADDR() */
+
+/*
+ * These functions should be later moved to a more generic location since there
+ * will be others accessing it also
+ */
+
+/* 
+ * This is the way it works: LKB5 Base is at 0x0128. TITAN_BASE is defined in
+ * include/asm/titan_dep.h. TITAN_GE_BASE is the value in the TITAN_GE_LKB5 
+ * register.
+ */
+
+#ifdef CONFIG_MIPS64
+#define	TITAN_GE_BASE	0xfffffffffe000000
+#else
+#define	TITAN_GE_BASE	0xfe000000
+#endif
+
+#define	TITAN_GE_WRITE(offset, data) \
+		*(volatile u32 *)(TITAN_GE_BASE + offset) = data	
+
+#define TITAN_GE_READ(offset) *(volatile u32 *)(TITAN_GE_BASE + offset)
+
+#ifndef msec_delay
+#define msec_delay(x)   do { if(in_interrupt()) { \
+                                /* Don't mdelay in interrupt context! */ \
+                                BUG(); \
+                        } else { \
+                                set_current_state(TASK_UNINTERRUPTIBLE); \
+                                schedule_timeout((x * HZ)/1000); \
+                        } } while(0)
+#endif
+
+#define TITAN_GE_PORT_0
+
+#define	TITAN_GE_SRAM_BASE_VIRTUAL	0xf4000000
+#define	TITAN_GE_SRAM_BASE_PHYSICAL	0xf4000000
+
+#ifdef CONFIG_NET_FASTROUTE
+
+#include <linux/if_arp.h>
+#include <net/ip.h>
+
+static int titan_accept_fastpath(struct net_device *dev, struct dst_entry *dst)
+{
+	struct net_device *odev = dst->dev;
+
+	if (dst->ops->protocol != __constant_htons(ETH_P_IP))
+		return -1;
+	if (odev->type != ARPHRD_ETHER || odev->accept_fastpath == NULL)
+		return -1;
+
+	return 0;
+}
+#endif
+
+
+/*
+ * We may need these constants
+ */
+#define TITAN_BIT0    0x00000001
+#define TITAN_BIT1    0x00000002
+#define TITAN_BIT2    0x00000004
+#define TITAN_BIT3    0x00000008
+#define TITAN_BIT4    0x00000010
+#define TITAN_BIT5    0x00000020
+#define TITAN_BIT6    0x00000040
+#define TITAN_BIT7    0x00000080
+#define TITAN_BIT8    0x00000100
+#define TITAN_BIT9    0x00000200
+#define TITAN_BIT10   0x00000400
+#define TITAN_BIT11   0x00000800
+#define TITAN_BIT12   0x00001000
+#define TITAN_BIT13   0x00002000
+#define TITAN_BIT14   0x00004000
+#define TITAN_BIT15   0x00008000
+#define TITAN_BIT16   0x00010000
+#define TITAN_BIT17   0x00020000
+#define TITAN_BIT18   0x00040000
+#define TITAN_BIT19   0x00080000
+#define TITAN_BIT20   0x00100000
+#define TITAN_BIT21   0x00200000
+#define TITAN_BIT22   0x00400000
+#define TITAN_BIT23   0x00800000
+#define TITAN_BIT24   0x01000000
+#define TITAN_BIT25   0x02000000
+#define TITAN_BIT26   0x04000000
+#define TITAN_BIT27   0x08000000
+#define TITAN_BIT28   0x10000000
+#define TITAN_BIT29   0x20000000
+#define TITAN_BIT30   0x40000000
+#define TITAN_BIT31   0x80000000
+
+/* Flow Control */
+#define	TITAN_GE_FC_NONE	0x0
+#define	TITAN_GE_FC_FULL	0x1
+#define	TITAN_GE_FC_TX_PAUSE	0x2
+#define	TITAN_GE_FC_RX_PAUSE	0x3
+
+/* Duplex Settings */
+#define	TITAN_GE_FULL_DUPLEX	0x1
+#define	TITAN_GE_HALF_DUPLEX	0x2
+
+/* Speed settings */
+#define	TITAN_GE_SPEED_1000	0x1
+#define	TITAN_GE_SPEED_100	0x2
+#define	TITAN_GE_SPEED_10	0x3
+
+/* Debugging info only */
+#undef TITAN_DEBUG
+
+/* Support for Rx side NAPI */
+#define TITAN_RX_NAPI
+
+#ifdef CONFIG_MIPS64
+#define	TITAN_GE_IE_MASK	0xfffffffffb001b64
+#define	TITAN_GE_IE_STATUS	0xfffffffffb001b60
+#else
+#define	TITAN_GE_IE_MASK	0xfb001b64
+#define	TITAN_GE_IE_STATUS	0xfb001b60
+#endif
+
+/* Support for Jumbo Frames */
+#undef TITAN_GE_JUMBO_FRAMES
+
+/* Rx buffer size */
+#ifdef TITAN_GE_JUMBO_FRAMES
+#define	TITAN_GE_JUMBO_BUFSIZE	9080
+#else
+#define	TITAN_GE_STD_BUFSIZE	1580
+#endif
+
+/* Default Tx Queue Size */
+#define	TITAN_GE_TX_QUEUE	128
+
+/* Default Rx Queue Size */
+#define	TITAN_GE_RX_QUEUE	64
+
+/* 
+ * Tx and Rx Interrupt Coalescing parameter. These values are 
+ * for 1 Ghz processor. Rx coalescing can be taken care of
+ * by NAPI. NAPI is adaptive and hence useful. Tx coalescing
+ * is not adaptive. Hence, these values need to be adjusted
+ * based on load, CPU speed etc.
+ */
+#define	TITAN_GE_RX_COAL	150
+#define	TITAN_GE_TX_COAL	300
+
+#if defined(__BIG_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct _eth_rx_desc {
+        u32     reserved;	/* Unused 		*/
+        u32     buffer_addr;	/* CPU buffer address 	*/
+	u32	cmd_sts;	/* Command and Status	*/
+	u32	buffer;		/* XDMA buffer address	*/
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct _eth_tx_desc {
+        u16     cmd_sts;	/* Command, Status and Buffer count */
+	u16	buffer_len;	/* Length of the buffer	*/
+        u32     buffer_addr;	/* Physical address of the buffer */
+} titan_ge_tx_desc;
+
+#elif defined(__LITTLE_ENDIAN)
+
+/* Define the Rx descriptor */
+typedef struct _eth_rx_desc {
+	u32	buffer_addr;	/* Buffer address inclusive of checksum */
+        u32     cmd_sts;	/* Command and Status info */
+} titan_ge_rx_desc;
+
+/* Define the Tx descriptor */
+typedef struct _eth_tx_desc {
+	u32     buffer_addr;	/* Physical address of the buffer */
+	u16     buffer_len;     /* Length of the buffer */
+	u16     cmd_sts;        /* Command, Status and Buffer count */
+} titan_ge_tx_desc;
+#else
+#error One of __BIG_ENDIAN or __LITTLE_ENDIAN must be defined
+#endif
+
+/* Packet Structure */
+typedef struct _pkt_info {
+        unsigned int           len;
+        unsigned int            cmd_sts;
+        unsigned int            buffer;
+        struct sk_buff          *skb;
+	unsigned int		checksum;
+} titan_ge_packet;
+
+
+#define	PHYS_CNT	2
+
+/* Titan Port specific data structure */
+typedef struct _eth_port_ctrl {
+	unsigned int		port_num;
+	u8			port_mac_addr[6];
+
+	/* Rx descriptor pointers */
+	int 			rx_curr_desc_q, rx_used_desc_q;
+
+	/* Tx descriptor pointers */
+	int 			tx_curr_desc_q, tx_used_desc_q;
+
+	/* Rx descriptor area */
+	volatile titan_ge_rx_desc	*rx_desc_area;
+	unsigned int			rx_desc_area_size;
+	struct sk_buff*			rx_skb[TITAN_GE_RX_QUEUE];
+
+	/* Tx Descriptor area */
+	volatile titan_ge_tx_desc	*tx_desc_area;
+	unsigned int                    tx_desc_area_size;
+	struct sk_buff*                 tx_skb[TITAN_GE_TX_QUEUE];
+
+	/* Timeout task */
+	struct tq_struct		tx_timeout_task;
+
+	/* DMA structures and handles */
+	dma_addr_t			tx_dma;
+	dma_addr_t			rx_dma;
+	dma_addr_t			tx_dma_array[TITAN_GE_TX_QUEUE];
+
+	/* Device lock */
+	spinlock_t			lock;
+
+	unsigned int			tx_ring_skbs;
+	unsigned int			rx_ring_size;
+	unsigned int			tx_ring_size;
+	unsigned int			rx_ring_skbs;
+
+	struct net_device_stats		stats;
+
+	/* Tx and Rx coalescing */
+	unsigned long			rx_int_coal;
+	unsigned long			tx_int_coal;
+
+	/* Threshold for replenishing the Rx and Tx rings */
+	unsigned int			tx_threshold;
+	unsigned int			rx_threshold;
+
+	/* NAPI work limit */
+	unsigned int			rx_work_limit;
+} titan_ge_port_info;
+
+/* Titan specific constants */
+#define	TITAN_ETH_PORT_IRQ		4
+
+/* Max Rx buffer */
+#define	TITAN_GE_MAX_RX_BUFFER		65536
+
+/* Tx and Rx Error */
+#define	TITAN_GE_ERROR
+
+/* Rx Descriptor Command and Status */
+
+#define	TITAN_GE_RX_CRC_ERROR		TITAN_BIT27	/* crc error */
+#define	TITAN_GE_RX_OVERFLOW_ERROR	TITAN_BIT15	/* overflow */
+#define TITAN_GE_RX_BUFFER_OWNED	TITAN_BIT21	/* buffer ownership */
+#define	TITAN_GE_RX_STP			TITAN_BIT31	/* start of packet */
+#define	TITAN_GE_RX_BAM			TITAN_BIT30	/* broadcast address match */
+#define TITAN_GE_RX_PAM			TITAN_BIT28	/* physical address match */
+#define TITAN_GE_RX_LAFM		TITAN_BIT29	/* logical address filter match */
+#define TITAN_GE_RX_VLAN		TITAN_BIT26	/* virtual lans */
+#define TITAN_GE_RX_PERR		TITAN_BIT19	/* packet error */
+#define TITAN_GE_RX_TRUNC		TITAN_BIT20	/* packet size greater than 32 buffers */
+
+/* Tx Descriptor Command */
+#define	TITAN_GE_TX_BUFFER_OWNED	TITAN_BIT5	/* buffer ownership */	
+#define	TITAN_GE_TX_ENABLE_INTERRUPT	TITAN_BIT15	/* Interrupt Enable */
+
+/* Return Status */
+#define	TITAN_OK	0x1	/* Good Status */
+#define	TITAN_ERROR	0x2	/* Error Status */
+
+/* MIB specific register offset */
+#define TITAN_GE_MSTATX_STATS_BASE_LOW       0x0800  /* MSTATX COUNTL[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_MID       0x0804  /* MSTATX COUNTM[15:0] */
+#define TITAN_GE_MSTATX_STATS_BASE_HI        0x0808  /* MSTATX COUNTH[7:0] */
+#define TITAN_GE_MSTATX_CONTROL              0x0828  /* MSTATX Control */
+#define TITAN_GE_MSTATX_VARIABLE_SELECT      0x082C  /* MSTATX Variable Select */
+
+/* MIB counter offsets, add to the TITAN_GE_MSTATX_STATS_BASE_XXX */
+#define TITAN_GE_MSTATX_RXFRAMESOK                   0x0040
+#define TITAN_GE_MSTATX_RXOCTETSOK                   0x0050
+#define TITAN_GE_MSTATX_RXFRAMES                     0x0060
+#define TITAN_GE_MSTATX_RXOCTETS                     0x0070
+#define TITAN_GE_MSTATX_RXUNICASTFRAMESOK            0x0080
+#define TITAN_GE_MSTATX_RXBROADCASTFRAMESOK          0x0090
+#define TITAN_GE_MSTATX_RXMULTICASTFRAMESOK          0x00A0
+#define TITAN_GE_MSTATX_RXTAGGEDFRAMESOK             0x00B0
+#define TITAN_GE_MSTATX_RXMACPAUSECONTROLFRAMESOK    0x00C0
+#define TITAN_GE_MSTATX_RXMACCONTROLFRAMESOK         0x00D0
+#define TITAN_GE_MSTATX_RXFCSERROR                   0x00E0
+#define TITAN_GE_MSTATX_RXALIGNMENTERROR             0x00F0
+#define TITAN_GE_MSTATX_RXSYMBOLERROR                0x0100
+#define TITAN_GE_MSTATX_RXLAYER1ERROR                0x0110
+#define TITAN_GE_MSTATX_RXINRANGELENGTHERROR         0x0120
+#define TITAN_GE_MSTATX_RXLONGLENGTHERROR            0x0130
+#define TITAN_GE_MSTATX_RXLONGLENGTHCRCERROR         0x0140
+#define TITAN_GE_MSTATX_RXSHORTLENGTHERROR           0x0150
+#define TITAN_GE_MSTATX_RXSHORTLLENGTHCRCERROR       0x0160
+#define TITAN_GE_MSTATX_RXFRAMES64OCTETS             0x0170
+#define TITAN_GE_MSTATX_RXFRAMES65TO127OCTETS        0x0180
+#define TITAN_GE_MSTATX_RXFRAMES128TO255OCTETS       0x0190
+#define TITAN_GE_MSTATX_RXFRAMES256TO511OCTETS       0x01A0
+#define TITAN_GE_MSTATX_RXFRAMES512TO1023OCTETS      0x01B0
+#define TITAN_GE_MSTATX_RXFRAMES1024TO1518OCTETS     0x01C0
+#define TITAN_GE_MSTATX_RXFRAMES1519TOMAXSIZE        0x01D0
+#define TITAN_GE_MSTATX_RXSTATIONADDRESSFILTERED     0x01E0
+#define TITAN_GE_MSTATX_RXVARIABLE                   0x01F0
+#define TITAN_GE_MSTATX_GENERICADDRESSFILTERED       0x0200
+#define TITAN_GE_MSTATX_UNICASTFILTERED              0x0210
+#define TITAN_GE_MSTATX_MULTICASTFILTERED            0x0220
+#define TITAN_GE_MSTATX_BROADCASTFILTERED            0x0230
+#define TITAN_GE_MSTATX_HASHFILTERED                 0x0240
+#define TITAN_GE_MSTATX_TXFRAMESOK                   0x0250
+#define TITAN_GE_MSTATX_TXOCTETSOK                   0x0260
+#define TITAN_GE_MSTATX_TXOCTETS                     0x0270
+#define TITAN_GE_MSTATX_TXTAGGEDFRAMESOK             0x0280
+#define TITAN_GE_MSTATX_TXMACPAUSECONTROLFRAMESOK    0x0290
+#define TITAN_GE_MSTATX_TXFCSERROR                   0x02A0
+#define TITAN_GE_MSTATX_TXSHORTLENGTHERROR           0x02B0
+#define TITAN_GE_MSTATX_TXLONGLENGTHERROR            0x02C0
+#define TITAN_GE_MSTATX_TXSYSTEMERROR                0x02D0
+#define TITAN_GE_MSTATX_TXMACERROR                   0x02E0
+#define TITAN_GE_MSTATX_TXCARRIERSENSEERROR          0x02F0
+#define TITAN_GE_MSTATX_TXSQETESTERROR               0x0300
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESOK            0x0310
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESOK          0x0320
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESOK          0x0330
+#define TITAN_GE_MSTATX_TXUNICASTFRAMESATTEMPTED     0x0340
+#define TITAN_GE_MSTATX_TXBROADCASTFRAMESATTEMPTED   0x0350
+#define TITAN_GE_MSTATX_TXMULTICASTFRAMESATTEMPTED   0x0360
+#define TITAN_GE_MSTATX_TXFRAMES64OCTETS             0x0370
+#define TITAN_GE_MSTATX_TXFRAMES65TO127OCTETS        0x0380
+#define TITAN_GE_MSTATX_TXFRAMES128TO255OCTETS       0x0390
+#define TITAN_GE_MSTATX_TXFRAMES256TO511OCTETS       0x03A0
+#define TITAN_GE_MSTATX_TXFRAMES512TO1023OCTETS      0x03B0
+#define TITAN_GE_MSTATX_TXFRAMES1024TO1518OCTETS     0x03C0
+#define TITAN_GE_MSTATX_TXFRAMES1519TOMAXSIZE        0x03D0
+#define TITAN_GE_MSTATX_TXVARIABLE                   0x03E0
+#define TITAN_GE_MSTATX_RXSYSTEMERROR                0x03F0
+#define TITAN_GE_MSTATX_SINGLECOLLISION              0x0400
+#define TITAN_GE_MSTATX_MULTIPLECOLLISION            0x0410
+#define TITAN_GE_MSTATX_DEFERREDXMISSIONS            0x0420
+#define TITAN_GE_MSTATX_LATECOLLISIONS               0x0430
+#define TITAN_GE_MSTATX_ABORTEDDUETOXSCOLLS          0x0440
+
+/* Interrupt specific defines */
+#define TITAN_GE_DEVICE_ID         0x0000  /* Device ID */
+#define TITAN_GE_RESET             0x0004  /* Reset reg */
+#define TITAN_GE_TSB_CTRL_0        0x000C  /* TSB Control reg 0 */
+#define TITAN_GE_TSB_CTRL_1        0x0010  /* TSB Control reg 1 */
+#define TITAN_GE_INTR_GRP0_STATUS  0x0040  /* General Interrupt Group 0 Status */
+#define TITAN_GE_INTR_XDMA_CORE_A  0x0048  /* XDMA Channel Interrupt Status, Core A*/
+#define TITAN_GE_INTR_XDMA_CORE_B  0x004C  /* XDMA Channel Interrupt Status, Core B*/
+#define	TITAN_GE_INTR_XDMA_IE	   0x0058  /* XDMA Channel Interrupt Enable */
+#define TITAN_GE_SDQPF_ECC_INTR    0x480C  /* SDQPF ECC Interrupt Status */
+#define TITAN_GE_SDQPF_RXFIFO_CTL  0x4828  /* SDQPF RxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_RXFIFO_INTR 0x482C  /* SDQPF RxFifo Interrupt Status */
+#define TITAN_GE_SDQPF_TXFIFO_CTL  0x4928  /* SDQPF TxFifo Control and Interrupt Enb*/
+#define TITAN_GE_SDQPF_TXFIFO_INTR 0x492C  /* SDQPF TxFifo Interrupt Status */
+#define	TITAN_GE_SDQPF_RXFIFO_0	   0x4840  /* SDQPF RxFIFO Enable */
+#define	TITAN_GE_SDQPF_TXFIFO_0	   0x4940  /* SDQPF TxFIFO Enable */
+#define TITAN_GE_XDMA_CONFIG       0x5000  /* XDMA Global Configuration */
+#define TITAN_GE_XDMA_INTR_SUMMARY 0x5010  /* XDMA Interrupt Summary */
+#define TITAN_GE_XDMA_BUFADDRPRE   0x5018  /* XDMA Buffer Address Prefix */
+#define TITAN_GE_XDMA_DESCADDRPRE  0x501C  /* XDMA Descriptor Address Prefix */
+#define TITAN_GE_XDMA_PORTWEIGHT   0x502C  /* XDMA Port Weight Configuration */
+
+/* Rx MAC defines */
+#define TITAN_GE_RMAC_CONFIG_1               0x1200  /* RMAC Configuration 1 */
+#define TITAN_GE_RMAC_CONFIG_2               0x1204  /* RMAC Configuration 2 */
+#define TITAN_GE_RMAC_MAX_FRAME_LEN          0x1208  /* RMAC Max Frame Length */
+#define TITAN_GE_RMAC_STATION_HI             0x120C  /* Rx Station Address High */
+#define TITAN_GE_RMAC_STATION_MID            0x1210  /* Rx Station Address Middle */
+#define TITAN_GE_RMAC_STATION_LOW            0x1214  /* Rx Station Address Low */
+#define TITAN_GE_RMAC_LINK_CONFIG            0x1218  /* RMAC Link Configuration */
+
+/* Tx MAC defines */
+#define TITAN_GE_TMAC_CONFIG_1               0x1240  /* TMAC Configuration 1 */
+#define TITAN_GE_TMAC_CONFIG_2               0x1244  /* TMAC Configuration 2 */
+#define TITAN_GE_TMAC_IPG                    0x1248  /* TMAC Inter-Packet Gap */
+#define TITAN_GE_TMAC_STATION_HI             0x124C  /* Tx Station Address High */
+#define TITAN_GE_TMAC_STATION_MID            0x1250  /* Tx Station Address Middle */
+#define TITAN_GE_TMAC_STATION_LOW            0x1254  /* Tx Station Address Low */
+#define TITAN_GE_TMAC_MAX_FRAME_LEN          0x1258  /* TMAC Max Frame Length */
+#define TITAN_GE_TMAC_MIN_FRAME_LEN          0x125C  /* TMAC Min Frame Length */
+#define TITAN_GE_TMAC_PAUSE_FRAME_TIME       0x1260  /* TMAC Pause Frame Time */
+#define TITAN_GE_TMAC_PAUSE_FRAME_INTERVAL   0x1264  /* TMAC Pause Frame Interval */
+
+/* GMII register */
+#define TITAN_GE_GMII_INTERRUPT_STATUS       0x1348  /* GMII Interrupt Status */
+#define TITAN_GE_GMII_CONFIG_GENERAL         0x134C  /* GMII Configuration General */
+#define TITAN_GE_GMII_CONFIG_MODE            0x1350  /* GMII Configuration Mode */
+
+/* Tx and Rx XDMA defines */
+#define	TITAN_GE_INT_COALESCING		     0x5030 /* Interrupt Coalescing */
+#define	TITAN_GE_CHANNEL0_CONFIG	     0x5040 /* Channel 0 XDMA config */
+#define	TITAN_GE_CHANNEL0_INTERRUPT	     0x504c /* Channel 0 Interrupt Status */
+#define	TITAN_GE_GDI_INTERRUPT_ENABLE        0x5050 /* IE for the GDI Errors */
+#define	TITAN_GE_CHANNEL0_PACKET	     0x5060 /* Channel 0 Packet count */
+#define	TITAN_GE_CHANNEL0_BYTE		     0x5064 /* Channel 0 Byte count */
+#define	TITAN_GE_CHANNEL0_TX_DESC	     0x5054 /* Channel 0 Tx first desc */
+#define	TITAN_GE_CHANNEL0_RX_DESC	     0x5058 /* Channel 0 Rx first desc */
+
+/* AFX (Address Filter Exact) register offsets for Slice 0 */
+#define TITAN_GE_AFX_EXACT_MATCH_LOW         0x1100  /* AFX Exact Match Address Low*/
+#define TITAN_GE_AFX_EXACT_MATCH_MID         0x1104  /* AFX Exact Match Address Mid*/
+#define TITAN_GE_AFX_EXACT_MATCH_HIGH        0x1108  /* AFX Exact Match Address Hi */
+#define TITAN_GE_AFX_EXACT_MATCH_VID         0x110C  /* AFX Exact Match VID */
+#define TITAN_GE_AFX_MULTICAST_HASH_LOW      0x1110  /* AFX Multicast HASH Low */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDLOW   0x1114  /* AFX Multicast HASH MidLow */
+#define TITAN_GE_AFX_MULTICAST_HASH_MIDHI    0x1118  /* AFX Multicast HASH MidHi */
+#define TITAN_GE_AFX_MULTICAST_HASH_HI       0x111C  /* AFX Multicast HASH Hi */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_0     0x1120  /* AFX Address Filter Ctrl 0 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_1     0x1124  /* AFX Address Filter Ctrl 1 */
+#define TITAN_GE_AFX_ADDRS_FILTER_CTRL_2     0x1128  /* AFX Address Filter Ctrl 2 */
+
+/* Traffic Groomer block */
+#define        TITAN_GE_TRTG_CONFIG	     0x1000  /* TRTG Config */
+
+#endif 				/* _TITAN_GE_H_ */
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/titan_mdio.c linux-mips-cvs-20040815/drivers/net/titan_mdio.c
--- linux-2.4.27/drivers/net/titan_mdio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/titan_mdio.c	2004-08-15 08:06:19.000000000 +0200
@@ -0,0 +1,217 @@
+/*
+ * drivers/net/titan_mdio.c - Driver for Titan ethernet ports
+ *
+ * Copyright (C) 2003 PMC-Sierra Inc.
+ * Author : Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * Management Data IO (MDIO) driver for the Titan GMII. Interacts with the Marvel PHY
+ * on the Titan. No support for the TBI as yet. 
+ *
+ */
+
+#include	"titan_mdio.h"
+
+#define MDIO_DEBUG
+
+/*
+ * Local constants
+ */
+#define MAX_CLKA            1023
+#define MAX_PHY_DEV         31
+#define MAX_PHY_REG         31
+#define WRITEADDRS_OPCODE   0x0
+#define	READ_OPCODE	    0x2
+#define WRITE_OPCODE        0x1
+#define MAX_MDIO_POLL       100
+
+/* 
+ * Titan MDIO and SCMB registers
+ */
+#define TITAN_GE_SCMB_CONTROL                0x01c0  /* SCMB Control */
+#define TITAN_GE_SCMB_CLKA	             0x01c4  /* SCMB Clock A */
+#define TITAN_GE_MDIO_COMMAND                0x01d0  /* MDIO Command */
+#define TITAN_GE_MDIO_DEVICE_PORT_ADDRESS    0x01d4  /* MDIO Device and Port addrs */
+#define TITAN_GE_MDIO_DATA                   0x01d8  /* MDIO Data */
+#define TITAN_GE_MDIO_INTERRUPTS             0x01dC  /* MDIO Interrupts */
+
+/*
+ * Function to poll the MDIO 
+ */
+static int titan_ge_mdio_poll()
+{
+	int	i, val;
+
+	for (i = 0; i < MAX_MDIO_POLL; i++) {
+		val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+
+		if (!(val & 0x8000))
+			return TITAN_GE_MDIO_GOOD;
+	}
+
+	return TITAN_GE_MDIO_ERROR;
+}
+
+
+/*
+ * Initialize and configure the MDIO 
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *titan_mdio)
+{
+	unsigned long	val;
+
+	/* Reset the SCMB and program into MDIO mode*/
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x9000);
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CONTROL, 0x1000);
+
+	/* CLK A */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_SCMB_CLKA);
+	val = ( (val & ~(0x03ff)) | (titan_mdio->clka & 0x03ff));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_SCMB_CLKA, val);
+
+	/* Preamble Suppresion */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0001)) | (titan_mdio->mdio_spre & 0x0001));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	/* MDIO mode */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x4000)) | (titan_mdio->mdio_mode & 0x4000));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Set the PHY address in indirect mode
+ */
+int titan_ge_mdio_inaddrs(int dev_addr, int reg_addr)
+{
+	volatile unsigned long	val;
+
+	/* Setup the PHY device */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	/* Write the new address */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITEADDRS_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Read the MDIO register. This is what the individual parametes mean:
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register offset
+ *
+ * See the spec for the Titan MAC. We operate in the Direct Mode. 
+ */
+
+#define MAX_RETRIES	2
+
+int titan_ge_mdio_read(int dev_addr, int reg_addr, unsigned int *pdata)
+{
+	volatile unsigned long	val;
+	int retries = 0;
+
+	/* Setup the PHY device */
+
+again:
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+	val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+	val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+	
+	udelay(30);
+
+	/* Issue the read command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (READ_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	*pdata = (unsigned int)TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DATA);
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);
+
+	udelay(30);
+
+	if (val & 0x2) {
+		if (retries == MAX_RETRIES)
+			return TITAN_GE_MDIO_ERROR;
+		else {
+			retries++;
+			goto again;
+		}
+	}
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
+/*
+ * Write to the MDIO register 
+ *
+ * dev_addr : PHY ID
+ * reg_addr : register that needs to be written to
+ *
+ */
+int titan_ge_mdio_write(int dev_addr, int reg_addr, unsigned int data)
+{
+	volatile unsigned long	val;
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD)
+		return TITAN_GE_MDIO_ERROR;
+
+	/* Setup the PHY device */
+        val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS);
+        val = ( (val & ~(0x1f00)) | ( (dev_addr << 8) & 0x1f00));
+        val = ( (val & ~(0x001f)) | ( reg_addr & 0x001f));
+	val |= 0x4000;
+        TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DEVICE_PORT_ADDRESS, val);
+
+	udelay(30);
+
+	/* Setup the data to write */
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_DATA, data);
+
+	udelay(30);
+
+	/* Issue the write command */
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_COMMAND);
+	val = ( (val & ~(0x0300)) | ( (WRITE_OPCODE << 8) & 0x0300));
+	TITAN_GE_MDIO_WRITE(TITAN_GE_MDIO_COMMAND, val);
+
+	udelay(30);
+
+	if (titan_ge_mdio_poll() != TITAN_GE_MDIO_GOOD) 
+                return TITAN_GE_MDIO_ERROR;
+
+	val = TITAN_GE_MDIO_READ(TITAN_GE_MDIO_INTERRUPTS);	
+	if (val & 0x2)
+		return TITAN_GE_MDIO_ERROR;
+
+	return TITAN_GE_MDIO_GOOD;
+}
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/net/titan_mdio.h linux-mips-cvs-20040815/drivers/net/titan_mdio.h
--- linux-2.4.27/drivers/net/titan_mdio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/net/titan_mdio.h	2004-08-15 08:06:19.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * MDIO used to interact with the PHY when using GMII/MII
+ */
+#ifndef _TITAN_MDIO_H
+#define _TITAN_MDIO_H
+
+#include <linux/netdevice.h>
+#include <linux/tqueue.h>
+#include <linux/delay.h>
+#include "titan_ge.h"
+
+
+#define	TITAN_GE_MDIO_ERROR	(-9000)
+#define	TITAN_GE_MDIO_GOOD	0
+
+#define	TITAN_GE_MDIO_BASE		TITAN_GE_BASE
+
+#define	TITAN_GE_MDIO_READ(offset)	*(volatile u32 *)(TITAN_GE_MDIO_BASE + offset)
+
+#define	TITAN_GE_MDIO_WRITE(offset, data)	\
+					*(volatile u32 *)(TITAN_GE_MDIO_BASE + offset) = data
+
+
+/* GMII specific registers */
+#define	TITAN_GE_MARVEL_PHY_ID		0x00
+#define	TITAN_PHY_AUTONEG_ADV		0x04
+#define	TITAN_PHY_LP_ABILITY		0x05
+#define	TITAN_GE_MDIO_MII_CTRL		0x09
+#define	TITAN_GE_MDIO_MII_EXTENDED	0x0f
+#define	TITAN_GE_MDIO_PHY_CTRL		0x10
+#define	TITAN_GE_MDIO_PHY_STATUS	0x11
+#define	TITAN_GE_MDIO_PHY_IE		0x12
+#define	TITAN_GE_MDIO_PHY_IS		0x13
+#define	TITAN_GE_MDIO_PHY_LED		0x18
+#define	TITAN_GE_MDIO_PHY_LED_OVER	0x19
+#define	PHY_ANEG_TIME_WAIT		45	/* 45 seconds wait time */
+
+/*
+ * MDIO Config Structure 
+ */
+typedef struct 
+{
+	unsigned int		clka;
+	int			mdio_spre;
+	int			mdio_mode;
+} titan_ge_mdio_config;
+
+/*
+ * Function Prototypes 
+ */
+int titan_ge_mdio_setup(titan_ge_mdio_config *);
+int titan_ge_mdio_inaddrs(int, int);
+int titan_ge_mdio_read(int, int, unsigned int *);
+int titan_ge_mdio_write(int, int, unsigned int);
+
+#endif /* _TITAN_MDIO_H */
+		
+
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pci/pci.c linux-mips-cvs-20040815/drivers/pci/pci.c
--- linux-2.4.27/drivers/pci/pci.c	2004-08-08 01:26:05.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/pci/pci.c	2004-08-15 08:06:23.000000000 +0200
@@ -1279,11 +1279,17 @@ static int __devinit pci_scan_bridge(str
 {
 	unsigned int buses;
 	unsigned short cr;
+	unsigned short bctl;
 	struct pci_bus *child;
 	int is_cardbus = (dev->hdr_type == PCI_HEADER_TYPE_CARDBUS);
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 	DBG("Scanning behind PCI bridge %s, config %06x, pass %d\n", dev->slot_name, buses & 0xffffff, pass);
+	/* Disable MasterAbortMode during probing to avoid reporting
+           of bus errors (in some architectures) */
+	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &bctl);
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, 
+			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 	if ((buses & 0xffff00) && !pcibios_assign_all_busses()) {
 		/*
 		 * Bus already configured by firmware, process it in the first
@@ -1342,6 +1348,7 @@ static int __devinit pci_scan_bridge(str
 		pci_write_config_byte(dev, PCI_SUBORDINATE_BUS, max);
 		pci_write_config_word(dev, PCI_COMMAND, cr);
 	}
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, bctl);
 	sprintf(child->name, (is_cardbus ? "PCI CardBus #%02x" : "PCI Bus #%02x"), child->number);
 	return max;
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/Config.in linux-mips-cvs-20040815/drivers/pcmcia/Config.in
--- linux-2.4.27/drivers/pcmcia/Config.in	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/pcmcia/Config.in	2004-02-22 06:21:34.000000000 +0100
@@ -30,16 +30,14 @@ if [ "$CONFIG_PCMCIA" != "n" ]; then
       dep_tristate '  M8xx support' CONFIG_PCMCIA_M8XX $CONFIG_PCMCIA
    fi
    if [ "$CONFIG_SOC_AU1X00" = "y" ]; then
-      dep_tristate '  Au1x00 PCMCIA support' CONFIG_PCMCIA_AU1X00 $CONFIG_PCMCIA 
-      if [ "$CONFIG_PCMCIA_AU1X00" != "n" ]; then
-        bool '  Pb1x00 board support' CONFIG_PCMCIA_PB1X00
-        bool '  Db1x00 board support' CONFIG_PCMCIA_DB1X00
-        bool '  XXS1500 board support' CONFIG_PCMCIA_XXS1500
-      fi
+      dep_tristate '  Au1x00 PCMCIA support' CONFIG_PCMCIA_AU1X00 $CONFIG_PCMCIA
    fi
    if [ "$CONFIG_SIBYTE_SB1xxx_SOC" = "y" ]; then
       dep_bool '  SiByte PCMCIA support' CONFIG_PCMCIA_SIBYTE $CONFIG_PCMCIA $CONFIG_BLK_DEV_IDE_SIBYTE
    fi
+   if [ "$CONFIG_VRC4171" = "y" -o "$CONFIG_VRC4171" = "m" ]; then
+      dep_tristate '  NEC VRC4171 Card Controllers support' CONFIG_PCMCIA_VRC4171 $CONFIG_PCMCIA
+   fi
    if [ "$CONFIG_VRC4173" = "y" -o "$CONFIG_VRC4173" = "m" ]; then
       dep_tristate '  NEC VRC4173 CARDU support' CONFIG_PCMCIA_VRC4173 $CONFIG_PCMCIA
    fi
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/Makefile linux-mips-cvs-20040815/drivers/pcmcia/Makefile
--- linux-2.4.27/drivers/pcmcia/Makefile	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/pcmcia/Makefile	2004-05-05 14:38:50.000000000 +0200
@@ -61,9 +61,16 @@ endif
 
 obj-$(CONFIG_PCMCIA_AU1X00)			+= au1x00_ss.o
 au1000_ss-objs-y				:= au1000_generic.o
-au1000_ss-objs-$(CONFIG_PCMCIA_PB1X00)		+= au1000_pb1x00.o
-au1000_ss-objs-$(CONFIG_PCMCIA_DB1X00)		+= au1000_db1x00.o
-au1000_ss-objs-$(CONFIG_PCMCIA_XXS1500) 	+= au1000_xxs1500.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1000)		+= au1000_pb1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1100)		+= au1000_pb1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1500)		+= au1000_pb1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1000)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1100)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1500)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_DB1550)		+= au1000_db1x00.o
+au1000_ss-objs-$(CONFIG_MIPS_PB1550)		+= au1000_pb1550.o
+au1000_ss-objs-$(CONFIG_MIPS_HYDROGEN3)		+= au1000_hydrogen3.o
+au1000_ss-objs-$(CONFIG_MIPS_XXS1500) 		+= au1000_xxs1500.o
 
 obj-$(CONFIG_PCMCIA_SA1100)	+= sa1100_cs.o
 obj-$(CONFIG_PCMCIA_M8XX)	+= m8xx_pcmcia.o
@@ -89,6 +96,7 @@ sa1100_cs-objs-$(CONFIG_SA1100_STORK)		+
 sa1100_cs-objs-$(CONFIG_SA1100_XP860)		+= sa1100_xp860.o sa1111_generic.o
 sa1100_cs-objs-$(CONFIG_SA1100_YOPY)		+= sa1100_yopy.o
 
+obj-$(CONFIG_PCMCIA_VRC4171)	+= vrc4171_card.o
 obj-$(CONFIG_PCMCIA_VRC4173)	+= vrc4173_cardu.o
 
 include $(TOPDIR)/Rules.make
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/au1000_db1x00.c linux-mips-cvs-20040815/drivers/pcmcia/au1000_db1x00.c
--- linux-2.4.27/drivers/pcmcia/au1000_db1x00.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/pcmcia/au1000_db1x00.c	2004-05-02 00:48:18.000000000 +0200
@@ -56,7 +56,7 @@
 
 #include <asm/db1x00.h>
 
-static BCSR * const bcsr = (BCSR *)0xAE000000;
+static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 
 static int db1x00_pcmcia_init(struct pcmcia_init *init)
 {
@@ -143,11 +143,16 @@ static int db1x00_pcmcia_get_irq_info(st
 {
 	if(info->sock > PCMCIA_MAX_SOCK) return -1;
 
-	if(info->sock == 0) {
+	if(info->sock == 0)
+#ifdef CONFIG_MIPS_DB1550
+		info->irq = AU1000_GPIO_3;
+	else 
+		info->irq = AU1000_GPIO_5;
+#else
 		info->irq = AU1000_GPIO_2;
-	}
 	else 
 		info->irq = AU1000_GPIO_5;
+#endif
 
 	return 0;
 }
@@ -260,7 +265,7 @@ db1x00_pcmcia_configure_socket(const str
 	return 0;
 }
 
-struct pcmcia_low_level db1x00_pcmcia_ops = { 
+struct pcmcia_low_level au1x00_pcmcia_ops = { 
 	db1x00_pcmcia_init,
 	db1x00_pcmcia_shutdown,
 	db1x00_pcmcia_socket_state,
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/au1000_generic.c linux-mips-cvs-20040815/drivers/pcmcia/au1000_generic.c
--- linux-2.4.27/drivers/pcmcia/au1000_generic.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/pcmcia/au1000_generic.c	2004-02-22 06:21:34.000000000 +0100
@@ -70,7 +70,12 @@ MODULE_DESCRIPTION("Linux PCMCIA Card Se
  * callback value associated with the socket:
  */
 static struct au1000_pcmcia_socket *pcmcia_socket;
-static int socket_count;
+
+/* Some boards like to support CF cards as IDE root devices, so they
+ * grab pcmcia sockets directly.
+ */
+int socket_count;
+u32 *pcmcia_base_vaddrs[2];
 
 
 /* Returned by the low-level PCMCIA interface: */
@@ -157,16 +162,7 @@ static int __init au1000_pcmcia_driver_i
 		return -1;
 	}
 
-#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500)
-	pcmcia_low_level=&pb1x00_pcmcia_ops;
-#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500)
-	pcmcia_low_level=&db1x00_pcmcia_ops;
-#elif defined(CONFIG_MIPS_XXS1500)
-	pcmcia_low_level=&xxs1500_pcmcia_ops;
-#else
-#error Unsupported AU1000 board.
-#endif
-
+	pcmcia_low_level=&au1x00_pcmcia_ops;
 	pcmcia_init.handler=au1000_pcmcia_interrupt;
 	if((socket_count=pcmcia_low_level->init(&pcmcia_init))<0) {
 		printk(KERN_ERR "Unable to initialize PCMCIA service.\n");
@@ -205,7 +201,7 @@ static int __init au1000_pcmcia_driver_i
 		 * access address, we need to subtract it here.
 		 */
 		if (i == 0) {
-			pcmcia_socket[i].virt_io = 
+			pcmcia_socket[i].virt_io =
 				(u32)ioremap((ioaddr_t)AU1X_SOCK0_IO, 0x1000) -
 				mips_io_port_base;
 			pcmcia_socket[i].phys_attr = 
@@ -213,7 +209,7 @@ static int __init au1000_pcmcia_driver_i
 			pcmcia_socket[i].phys_mem = 
 				(ioaddr_t)AU1X_SOCK0_PHYS_MEM;
 		}
-#ifndef CONFIG_MIPS_XXS1500
+#ifdef AU1X_SOCK1_IO /* revisit */
 		else  {
 			pcmcia_socket[i].virt_io = 
 				(u32)ioremap((ioaddr_t)AU1X_SOCK1_IO, 0x1000) -
@@ -224,6 +220,7 @@ static int __init au1000_pcmcia_driver_i
 				(ioaddr_t)AU1X_SOCK1_PHYS_MEM;
 		}
 #endif
+		pcmcia_base_vaddrs[i] = (u32 *)pcmcia_socket[i].virt_io;
 	}
 
 	/* Only advertise as many sockets as we can detect: */
@@ -607,7 +604,6 @@ au1000_pcmcia_set_mem_map(unsigned int s
 	}
 
 	spin_lock_irqsave(&pcmcia_lock, flags);
-	start=map->sys_start;
 
 	if(map->sys_stop==0)
 		map->sys_stop=MAP_SIZE-1;
@@ -621,7 +617,7 @@ au1000_pcmcia_set_mem_map(unsigned int s
 			map->card_start;
 	}
 
-	map->sys_stop=map->sys_start+(map->sys_stop-start);
+	map->sys_stop=map->sys_start+MAP_SIZE;
 	pcmcia_socket[sock].mem_map[map->map]=*map;
 	spin_unlock_irqrestore(&pcmcia_lock, flags);
 	DEBUG(3, "set_mem_map %d start %x stop %x card_start %x\n", 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/au1000_hydrogen3.c linux-mips-cvs-20040815/drivers/pcmcia/au1000_hydrogen3.c
--- linux-2.4.27/drivers/pcmcia/au1000_hydrogen3.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/pcmcia/au1000_hydrogen3.c	2004-02-22 06:21:34.000000000 +0100
@@ -0,0 +1,152 @@
+/*
+ *
+ * Alchemy Semi Hydrogen III board specific pcmcia routines.
+ *
+ * based on:
+ *
+ * Alchemy Semi Hyd1100 board specific pcmcia routines.
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * 
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/tqueue.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <linux/types.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/bulkmem.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/bus_ops.h>
+#include "cs_internal.h"
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <asm/au1000.h>
+#include <asm/au1000_pcmcia.h>
+
+#include <asm/db1x00.h>
+
+#define PCMCIA_MAX_SOCK 0
+//#include <asm/hyd1100.h>
+
+
+static int hydrogen3_pcmcia_init(struct pcmcia_init *init)
+{
+	// power up
+	writel(0x00020002, GPIO2_OUTPUT); // GPIO_201 CF_PWR
+	return 1; // one slot
+}
+
+static int hydrogen3_pcmcia_shutdown(void)
+{
+	// power down
+	writel(0x00020000, GPIO2_OUTPUT); // GPIO_201 CF_PWR
+	return 0; 
+}
+
+static int 
+hydrogen3_pcmcia_socket_state(unsigned sock, struct pcmcia_state *state)
+{
+	u32 inserted;
+	inserted = (readl(SYS_PINSTATERD) & (1<<22)) ? 0 : 1; // GPIO_22 is CF_DETECT
+
+	state->ready = 0;
+	state->vs_Xv = 0;
+	state->vs_3v = 0;
+	state->detect = 0;
+
+	if (inserted)
+	{
+		state->vs_3v=1;
+		state->detect = 1;
+		state->ready = 1;
+	}
+
+	state->bvd1=1;
+	state->bvd2=1;
+	state->wrprot=0; 
+	return 1;
+}
+
+
+static int hydrogen3_pcmcia_get_irq_info(struct pcmcia_irq_info *info)
+{
+
+	if(info->sock > PCMCIA_MAX_SOCK) return -1;
+
+	if(info->sock == 0)
+		info->irq = AU1000_GPIO_21;
+	else 
+		info->irq = -1;
+
+	return 0;
+}
+
+
+static int 
+hydrogen3_pcmcia_configure_socket(const struct pcmcia_configure *configure)
+{
+	if(configure->sock > PCMCIA_MAX_SOCK) return -1;
+
+	au_sync_delay(300);
+
+	if (!configure->reset) {
+		// de-assert reset
+		writel(0x00010000, GPIO2_OUTPUT); // GPIO_200 CF_RESET
+		au_sync_delay(100);
+	}
+	else {
+		// assert reset
+		writel(0x00010001, GPIO2_OUTPUT); // GPIO_200 CF_RESET
+		au_sync_delay(300);
+	}
+	return 0;
+}
+
+struct pcmcia_low_level au1x00_pcmcia_ops = { 
+	hydrogen3_pcmcia_init,
+	hydrogen3_pcmcia_shutdown,
+	hydrogen3_pcmcia_socket_state,
+	hydrogen3_pcmcia_get_irq_info,
+	hydrogen3_pcmcia_configure_socket
+};
+
+struct pcmcia_low_level *
+hydrogen3_get_pcmcia_ops(void)
+{
+	return &au1x00_pcmcia_ops;
+};
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/au1000_pb1550.c linux-mips-cvs-20040815/drivers/pcmcia/au1000_pb1550.c
--- linux-2.4.27/drivers/pcmcia/au1000_pb1550.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/pcmcia/au1000_pb1550.c	2004-02-24 21:42:51.000000000 +0100
@@ -0,0 +1,270 @@
+/*
+ *
+ * AMD Alchemy Pb1550 boards specific pcmcia routines.
+ *
+ * Copyright 2004 Embedded Edge LLC
+ *
+ * Based on au1000_pb1550.c:
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         	ppopov@mvista.com or source@mvista.com
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * 
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/tqueue.h>
+#include <linux/timer.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h>
+#include <linux/types.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/bulkmem.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/bus_ops.h>
+#include "cs_internal.h"
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <asm/au1000.h>
+#include <asm/au1000_pcmcia.h>
+
+#include <asm/pb1550.h>
+
+
+static int pb1550_pcmcia_init(struct pcmcia_init *init)
+{
+	bcsr->pcmcia = 0; /* turn off power */
+	au_sync_delay(2);
+	return PCMCIA_NUM_SOCKS;
+}
+
+static int pb1550_pcmcia_shutdown(void)
+{
+	bcsr->pcmcia = 0; /* turn off power */
+	au_sync_delay(2);
+	return 0;
+}
+
+static int 
+pb1550_pcmcia_socket_state(unsigned sock, struct pcmcia_state *state)
+{
+	u32 inserted;
+	u16 vs;
+
+	if(sock > PCMCIA_MAX_SOCK) return -1;
+
+	state->ready = 0;
+	state->vs_Xv = 0;
+	state->vs_3v = 0;
+	state->detect = 0;
+
+	if (sock == 0) {
+		vs = bcsr->status & BCSR_STATUS_PCMCIA0VS;
+		inserted = !(bcsr->status & (1<<4));
+	}
+	else {
+		vs = (bcsr->status & BCSR_STATUS_PCMCIA1VS)>>2;
+		inserted = !(bcsr->status & (1<<5));
+	}
+
+	DEBUG(KERN_DEBUG "pb1550 socket %d: inserted %d, vs %d\n", 
+			sock, inserted, vs, bcsr->status);
+
+	if (inserted) {
+		switch (vs) {
+			case 0:
+			case 2:
+				state->vs_3v=1;
+				break;
+			case 3: /* 5V */
+				break;
+			default:
+				/* return without setting 'detect' */
+				printk(KERN_ERR "pb1550 bad VS (%d)\n", vs);
+				return -1;
+		}
+		state->detect = 1;
+		state->ready = 1;
+	}
+	else {
+		/* if the card was previously inserted and then ejected,
+		 * we should turn off power to it
+		 */
+		if ((sock == 0) && (bcsr->pcmcia & BCSR_PCMCIA_PC0RST)) {
+			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC0RST | 
+					BCSR_PCMCIA_PC0DRVEN |
+					BCSR_PCMCIA_PC0VPP |
+					BCSR_PCMCIA_PC0VCC);
+		}
+		else if ((sock == 1) && (bcsr->pcmcia & BCSR_PCMCIA_PC1RST)) {
+			bcsr->pcmcia &= ~(BCSR_PCMCIA_PC1RST | 
+					BCSR_PCMCIA_PC1DRVEN |
+					BCSR_PCMCIA_PC1VPP |
+					BCSR_PCMCIA_PC1VCC);
+		}
+	}
+
+	state->bvd1=1;
+	state->bvd2=1;
+	state->wrprot=0; 
+	return 1;
+}
+
+
+static int pb1550_pcmcia_get_irq_info(struct pcmcia_irq_info *info)
+{
+	if(info->sock > PCMCIA_MAX_SOCK) return -1;
+
+	if(info->sock == 0) {
+		info->irq = AU1000_GPIO_0;
+	}
+	else 
+		info->irq = AU1000_GPIO_1;
+
+	return 0;
+}
+
+
+static int 
+pb1550_pcmcia_configure_socket(const struct pcmcia_configure *configure)
+{
+	u16 pwr;
+	int sock = configure->sock;
+
+	if(sock > PCMCIA_MAX_SOCK) return -1;
+
+	DEBUG(KERN_DEBUG "socket %d Vcc %dV Vpp %dV, reset %d\n", 
+			sock, configure->vcc, configure->vpp, configure->reset);
+
+	/* pcmcia reg was set to zero at init time. Be careful when
+	 * initializing a socket not to wipe out the settings of the 
+	 * other socket.
+	 */
+	pwr = bcsr->pcmcia;
+	pwr &= ~(0xf << sock*8); /* clear voltage settings */
+
+	switch(configure->vcc){
+		case 0:  /* Vcc 0 */
+			pwr |= SET_VCC_VPP(0,0,sock);
+			break;
+		case 50: /* Vcc 5V */
+			switch(configure->vpp) {
+				case 0:
+					pwr |= SET_VCC_VPP(2,0,sock);
+					break;
+				case 50:
+					pwr |= SET_VCC_VPP(2,1,sock);
+					break;
+				case 12:
+					pwr |= SET_VCC_VPP(2,2,sock);
+					break;
+				case 33:
+				default:
+					pwr |= SET_VCC_VPP(0,0,sock);
+					printk("%s: bad Vcc/Vpp (%d:%d)\n", 
+							__FUNCTION__, 
+							configure->vcc, 
+							configure->vpp);
+					break;
+			}
+			break;
+		case 33: /* Vcc 3.3V */
+			switch(configure->vpp) {
+				case 0:
+					pwr |= SET_VCC_VPP(1,0,sock);
+					break;
+				case 12:
+					pwr |= SET_VCC_VPP(1,2,sock);
+					break;
+				case 33:
+					pwr |= SET_VCC_VPP(1,1,sock);
+					break;
+				case 50:
+				default:
+					pwr |= SET_VCC_VPP(0,0,sock);
+					printk("%s: bad Vcc/Vpp (%d:%d)\n", 
+							__FUNCTION__, 
+							configure->vcc, 
+							configure->vpp);
+					break;
+			}
+			break;
+		default: /* what's this ? */
+			pwr |= SET_VCC_VPP(0,0,sock);
+			printk(KERN_ERR "%s: bad Vcc %d\n", 
+					__FUNCTION__, configure->vcc);
+			break;
+	}
+
+	bcsr->pcmcia = pwr;
+	au_sync_delay(500);
+
+	if (sock == 0) {
+		if (!configure->reset) {
+			pwr |= BCSR_PCMCIA_PC0DRVEN;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(300);
+			pwr |= BCSR_PCMCIA_PC0RST;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+		else {
+			pwr &= ~(BCSR_PCMCIA_PC0RST | BCSR_PCMCIA_PC0DRVEN);
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+	}
+	else {
+		if (!configure->reset) {
+			pwr |= BCSR_PCMCIA_PC1DRVEN;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(300);
+			pwr |= BCSR_PCMCIA_PC1RST;
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+		else {
+			pwr &= ~(BCSR_PCMCIA_PC1RST | BCSR_PCMCIA_PC1DRVEN);
+			bcsr->pcmcia = pwr;
+			au_sync_delay(100);
+		}
+	}
+	return 0;
+}
+
+struct pcmcia_low_level au1x00_pcmcia_ops = { 
+	pb1550_pcmcia_init,
+	pb1550_pcmcia_shutdown,
+	pb1550_pcmcia_socket_state,
+	pb1550_pcmcia_get_irq_info,
+	pb1550_pcmcia_configure_socket
+};
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/au1000_pb1x00.c linux-mips-cvs-20040815/drivers/pcmcia/au1000_pb1x00.c
--- linux-2.4.27/drivers/pcmcia/au1000_pb1x00.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/pcmcia/au1000_pb1x00.c	2004-02-22 06:21:34.000000000 +0100
@@ -408,7 +408,7 @@ pb1x00_pcmcia_configure_socket(const str
 }
 
 
-struct pcmcia_low_level pb1x00_pcmcia_ops = { 
+struct pcmcia_low_level au1x00_pcmcia_ops = { 
 	pb1x00_pcmcia_init,
 	pb1x00_pcmcia_shutdown,
 	pb1x00_pcmcia_socket_state,
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/au1000_xxs1500.c linux-mips-cvs-20040815/drivers/pcmcia/au1000_xxs1500.c
--- linux-2.4.27/drivers/pcmcia/au1000_xxs1500.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/pcmcia/au1000_xxs1500.c	2004-03-05 23:58:33.000000000 +0100
@@ -92,7 +92,7 @@ xxs1500_pcmcia_socket_state(unsigned soc
 	gpio = au_readl(SYS_PINSTATERD);
 	gpio2 = au_readl(GPIO2_PINSTATE);
 
-	vs = gpio2 & ((1<<8) | (1<<9));
+	vs = (gpio2 >> 8) & 0x3;
 	inserted = (!(gpio & 0x1) && !(gpio & 0x2));
 
 	state->ready = 0;
@@ -110,8 +110,7 @@ xxs1500_pcmcia_socket_state(unsigned soc
 			case 3: /* 5V */
 			default:
 				/* return without setting 'detect' */
-				printk(KERN_ERR "au1x00_cs: unsupported VS\n",
-						vs);
+				printk(KERN_ERR "au1x00_cs: bad VS %d\n", vs);
 				return;
 		}
 		state->detect = 1;
@@ -156,7 +155,8 @@ xxs1500_pcmcia_configure_socket(const st
 			break;
 		case 50: /* Vcc 5V */
 		default: /* what's this ? */
-			printk(KERN_ERR "au1x00_cs: unsupported VCC\n");
+			printk(KERN_ERR "au1x00_cs: bad VCC %d\n", 
+					configure->vcc);
 		case 0:  /* Vcc 0 */
 			/* turn off power */
 			au_sync_delay(100);
@@ -182,7 +182,7 @@ xxs1500_pcmcia_configure_socket(const st
 	return 0;
 }
 
-struct pcmcia_low_level xxs1500_pcmcia_ops = { 
+struct pcmcia_low_level au1x00_pcmcia_ops = { 
 	xxs1500_pcmcia_init,
 	xxs1500_pcmcia_shutdown,
 	xxs1500_pcmcia_socket_state,
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/pcmcia/vrc4171_card.c linux-mips-cvs-20040815/drivers/pcmcia/vrc4171_card.c
--- linux-2.4.27/drivers/pcmcia/vrc4171_card.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/pcmcia/vrc4171_card.c	2004-01-19 16:54:58.000000000 +0100
@@ -0,0 +1,886 @@
+/*
+ * vrc4171_card.c, NEC VRC4171 Card Controller driver for Socket Services.
+ *
+ * Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+#include <asm/vr41xx/vrc4171.h>
+
+#include <pcmcia/ss.h>
+
+#include "i82365.h"
+
+MODULE_DESCRIPTION("NEC VRC4171 Card Controllers driver for Socket Services");
+MODULE_AUTHOR("Yoichi Yuasa <yuasa@hh.iij4u.or.jp>");
+MODULE_LICENSE("GPL");
+
+#define CARD_MAX_SLOTS		2
+#define CARD_SLOTA		0
+#define CARD_SLOTB		1
+#define CARD_SLOTB_OFFSET	0x40
+
+#define CARD_MEM_START		0x10000000
+#define CARD_MEM_END		0x13ffffff
+#define CARD_MAX_MEM_OFFSET	0x3ffffff
+#define CARD_MAX_MEM_SPEED	1000
+
+#define CARD_CONTROLLER_INDEX	0x03e0
+#define CARD_CONTROLLER_DATA	0x03e1
+#define CARD_CONTROLLER_SIZE	2
+ /* Power register */
+  #define VPP_GET_VCC		0x01
+  #define POWER_ENABLE		0x10
+ #define CARD_VOLTAGE_SENSE	0x1f
+  #define VCC_3VORXV_CAPABLE	0x00
+  #define VCC_XV_ONLY		0x01
+  #define VCC_3V_CAPABLE	0x02
+  #define VCC_5V_ONLY		0x03
+ #define CARD_VOLTAGE_SELECT	0x2f
+  #define VCC_3V		0x01
+  #define VCC_5V		0x00
+  #define VCC_XV		0x02
+  #define VCC_STATUS_3V		0x02
+  #define VCC_STATUS_5V		0x01
+  #define VCC_STATUS_XV		0x03
+ #define GLOBAL_CONTROL		0x1e
+  #define EXWRBK		0x04
+  #define IRQPM_EN		0x08
+  #define CLRPMIRQ		0x10
+
+#define IO_MAX_MAPS	2
+#define MEM_MAX_MAPS	5
+
+enum {
+	SLOTB_PROBE = 0,
+	SLOTB_NOPROBE_IO,
+	SLOTB_NOPROBE_MEM,
+	SLOTB_NOPROBE_ALL
+};
+
+typedef struct vrc4171_socket {
+	int noprobe;
+	void (*handler)(void *, unsigned int);
+	void *info;
+	socket_cap_t cap;
+	spinlock_t event_lock;
+	uint16_t events;
+	struct socket_info_t *pcmcia_socket;
+	struct tq_struct tq_task;
+	char name[24];
+	int csc_irq;
+	int io_irq;
+} vrc4171_socket_t;
+
+static vrc4171_socket_t vrc4171_sockets[CARD_MAX_SLOTS];
+static int vrc4171_slotb = SLOTB_IS_NONE;
+static unsigned int vrc4171_irq;
+static uint16_t vrc4171_irq_mask = 0xdeb8;
+
+extern struct socket_info_t *pcmcia_register_socket(int slot,
+                                                    struct pccard_operations *vtable,
+                                                    int use_bus_pm);
+extern void pcmcia_unregister_socket(struct socket_info_t *s);
+
+static inline uint8_t exca_read_byte(int slot, uint8_t index)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	return inb(CARD_CONTROLLER_DATA);
+}
+
+static inline uint16_t exca_read_word(int slot, uint8_t index)
+{
+	uint16_t data;
+
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index++, CARD_CONTROLLER_INDEX);
+	data = inb(CARD_CONTROLLER_DATA);
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	data |= ((uint16_t)inb(CARD_CONTROLLER_DATA)) << 8;
+
+	return data;
+}
+
+static inline uint8_t exca_write_byte(int slot, uint8_t index, uint8_t data)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	outb(data, CARD_CONTROLLER_DATA);
+
+	return data;
+}
+
+static inline uint16_t exca_write_word(int slot, uint8_t index, uint16_t data)
+{
+	if (slot == CARD_SLOTB)
+		index += CARD_SLOTB_OFFSET;
+
+	outb(index++, CARD_CONTROLLER_INDEX);
+	outb(data, CARD_CONTROLLER_DATA);
+
+	outb(index, CARD_CONTROLLER_INDEX);
+	outb((uint8_t)(data >> 8), CARD_CONTROLLER_DATA);
+
+	return data;
+}
+
+static inline int search_nonuse_irq(void)
+{
+	int i;
+
+	for (i = 0; i < 16; i++) {
+		if (vrc4171_irq_mask & (1 << i)) {
+			vrc4171_irq_mask &= ~(1 << i);
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static int pccard_init(unsigned int slot)
+{
+	vrc4171_socket_t *socket = &vrc4171_sockets[slot];
+
+	socket->cap.features |= SS_CAP_PCCARD | SS_CAP_PAGE_REGS;
+	socket->cap.irq_mask = 0;
+	socket->cap.pci_irq = vrc4171_irq;
+	socket->cap.map_size = 0x1000;
+	socket->events = 0;
+	spin_lock_init(socket->event_lock);
+	socket->csc_irq = search_nonuse_irq();
+	socket->io_irq = search_nonuse_irq();
+
+	return 0;
+}
+
+static int pccard_suspend(unsigned int slot)
+{
+	return -EINVAL;
+}
+
+static int pccard_register_callback(unsigned int slot,
+                                    void (*handler)(void *, unsigned int),
+                                    void *info)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	socket->handler = handler;
+	socket->info = info;
+
+	if (handler)
+		MOD_INC_USE_COUNT;
+	else
+		MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static int pccard_inquire_socket(unsigned int slot, socket_cap_t *cap)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS || cap == NULL)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	*cap = socket->cap;
+
+	return 0;
+}
+
+static int pccard_get_status(unsigned int slot, u_int *value)
+{
+	uint8_t status, sense;
+	u_int val = 0;
+
+	if (slot >= CARD_MAX_SLOTS || value == NULL)
+		return -EINVAL;
+
+	status = exca_read_byte(slot, I365_STATUS);
+	if (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {
+		if (status & I365_CS_STSCHG)
+			val |= SS_STSCHG;
+	} else {
+		if (!(status & I365_CS_BVD1))
+			val |= SS_BATDEAD;
+		else if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)
+			val |= SS_BATWARN;
+	}
+	if ((status & I365_CS_DETECT) == I365_CS_DETECT)
+		val |= SS_DETECT;
+	if (status & I365_CS_WRPROT)
+		val |= SS_WRPROT;
+	if (status & I365_CS_READY)
+		val |= SS_READY;
+	if (status & I365_CS_POWERON)
+		val |= SS_POWERON;
+
+	sense = exca_read_byte(slot, CARD_VOLTAGE_SENSE);
+	switch (sense) {
+	case VCC_3VORXV_CAPABLE:
+		val |= SS_3VCARD | SS_XVCARD;
+		break;
+	case VCC_XV_ONLY:
+		val |= SS_XVCARD;
+		break;
+	case VCC_3V_CAPABLE:
+		val |= SS_3VCARD;
+		break;
+	default:
+		/* 5V only */
+		break;
+	}
+
+	*value = val;
+
+	return 0;
+}
+
+static inline u_char get_Vcc_value(uint8_t voltage)
+{
+	switch (voltage) {
+	case VCC_STATUS_3V:
+		return 33;
+	case VCC_STATUS_5V:
+		return 50;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static inline u_char get_Vpp_value(uint8_t power, u_char Vcc)
+{
+	if ((power & 0x03) == 0x01 || (power & 0x03) == 0x02)
+		return Vcc;
+
+	return 0;
+}
+
+static int pccard_get_socket(unsigned int slot, socket_state_t *state)
+{
+	vrc4171_socket_t *socket;
+	uint8_t power, voltage, control, cscint;
+
+	if (slot >= CARD_MAX_SLOTS || state == NULL)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	power = exca_read_byte(slot, I365_POWER);
+	voltage = exca_read_byte(slot, CARD_VOLTAGE_SELECT);
+
+	state->Vcc = get_Vcc_value(voltage);
+	state->Vpp = get_Vpp_value(power, state->Vcc);
+
+	state->flags = 0;
+	if (power & POWER_ENABLE)
+		state->flags |= SS_PWR_AUTO;
+	if (power & I365_PWR_OUT)
+		state->flags |= SS_OUTPUT_ENA;
+
+	control = exca_read_byte(slot, I365_INTCTL);
+	if (control & I365_PC_IOCARD)
+		state->flags |= SS_IOCARD;
+	if (!(control & I365_PC_RESET))
+		state->flags |= SS_RESET;
+
+        cscint = exca_read_byte(slot, I365_CSCINT);
+	state->csc_mask = 0;
+	if (state->flags & SS_IOCARD) {
+		if (cscint & I365_CSC_STSCHG)
+			state->flags |= SS_STSCHG;
+	} else {
+		if (cscint & I365_CSC_BVD1)  
+			state->csc_mask |= SS_BATDEAD;
+		if (cscint & I365_CSC_BVD2)  
+			state->csc_mask |= SS_BATWARN;
+	}
+	if (cscint & I365_CSC_READY)
+		state->csc_mask |= SS_READY;
+	if (cscint & I365_CSC_DETECT)
+		state->csc_mask |= SS_DETECT;
+
+	return 0;
+}
+
+static inline uint8_t set_Vcc_value(u_char Vcc)
+{
+	switch (Vcc) {
+	case 33:
+		return VCC_3V;
+	case 50:
+		return VCC_5V;
+	}
+
+	/* Small voltage is chosen for safety. */
+	return VCC_3V;
+}
+
+static int pccard_set_socket(unsigned int slot, socket_state_t *state)
+{
+	vrc4171_socket_t *socket;
+	uint8_t voltage, power, control, cscint;
+
+	if (slot >= CARD_MAX_SLOTS ||
+	    (state->Vpp != state->Vcc && state->Vpp != 0) ||
+	    (state->Vcc != 50 && state->Vcc != 33 && state->Vcc != 0))
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+
+	spin_lock_irq(&socket->event_lock);
+
+	voltage = set_Vcc_value(state->Vcc);
+	exca_write_byte(slot, CARD_VOLTAGE_SELECT, voltage);
+
+	power = POWER_ENABLE;
+	if (state->Vpp == state->Vcc)
+		power |= VPP_GET_VCC;
+	if (state->flags & SS_OUTPUT_ENA)
+		power |= I365_PWR_OUT;
+	exca_write_byte(slot, I365_POWER, power);
+
+	control = 0;
+	if (state->io_irq != 0)
+		control |= socket->io_irq;
+	if (state->flags & SS_IOCARD)
+		control |= I365_PC_IOCARD;
+	if (state->flags & SS_RESET)
+		control	&= ~I365_PC_RESET;
+	else
+		control |= I365_PC_RESET;
+	exca_write_byte(slot, I365_INTCTL, control);
+
+        cscint = 0;
+        exca_write_byte(slot, I365_CSCINT, cscint);
+	exca_read_byte(slot, I365_CSC);	/* clear CardStatus change */
+	if (state->csc_mask != 0)
+		cscint |= socket->csc_irq << 8;
+	if (state->flags & SS_IOCARD) {
+		if (state->csc_mask & SS_STSCHG)
+			cscint |= I365_CSC_STSCHG;
+	} else {
+		if (state->csc_mask & SS_BATDEAD)
+			cscint |= I365_CSC_BVD1;
+		if (state->csc_mask & SS_BATWARN)
+			cscint |= I365_CSC_BVD2;
+	}
+	if (state->csc_mask & SS_READY)
+		cscint |= I365_CSC_READY;
+	if (state->csc_mask & SS_DETECT)
+		cscint |= I365_CSC_DETECT;
+        exca_write_byte(slot, I365_CSCINT, cscint);
+
+	spin_unlock_irq(&socket->event_lock);
+
+	return 0;
+}
+
+static int pccard_get_io_map(unsigned int slot, struct pccard_io_map *io)
+{
+	vrc4171_socket_t *socket;
+	uint8_t ioctl, addrwin;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS || io == NULL ||
+	    io->map >= IO_MAX_MAPS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = io->map;
+
+	io->start = exca_read_word(slot, I365_IO(map)+I365_W_START);
+	io->stop = exca_read_word(slot, I365_IO(map)+I365_W_STOP);
+
+	ioctl = exca_read_byte(slot, I365_IOCTL);
+	if (io->flags & I365_IOCTL_WAIT(map))
+		io->speed = 1;
+	else
+		io->speed = 0;
+
+	io->flags = 0;
+	if (ioctl & I365_IOCTL_16BIT(map))
+		io->flags |= MAP_16BIT;
+	if (ioctl & I365_IOCTL_IOCS16(map))
+		io->flags |= MAP_AUTOSZ;
+	if (ioctl & I365_IOCTL_0WS(map))
+		io->flags |= MAP_0WS;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_IO(map))
+		io->flags |= MAP_ACTIVE;
+
+	return 0;
+}
+
+static int pccard_set_io_map(unsigned int slot, struct pccard_io_map *io)
+{
+	vrc4171_socket_t *socket;
+	uint8_t ioctl, addrwin;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS ||
+	    io == NULL || io->map >= IO_MAX_MAPS ||
+	    io->start > 0xffff || io->stop > 0xffff || io->start > io->stop)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = io->map;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_IO(map)) {
+		addrwin &= ~I365_ENA_IO(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	exca_write_word(slot, I365_IO(map)+I365_W_START, io->start);
+	exca_write_word(slot, I365_IO(map)+I365_W_STOP, io->stop);
+
+	ioctl = 0;
+	if (io->speed > 0)
+		ioctl |= I365_IOCTL_WAIT(map);
+	if (io->flags & MAP_16BIT)
+		ioctl |= I365_IOCTL_16BIT(map);
+	if (io->flags & MAP_AUTOSZ)
+		ioctl |= I365_IOCTL_IOCS16(map);
+	if (io->flags & MAP_0WS)
+		ioctl |= I365_IOCTL_0WS(map);
+	exca_write_byte(slot, I365_IOCTL, ioctl);
+
+	if (io->flags & MAP_ACTIVE) {
+		addrwin |= I365_ENA_IO(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	return 0;
+}
+
+static int pccard_get_mem_map(unsigned int slot, struct pccard_mem_map *mem)
+{
+	vrc4171_socket_t *socket;
+	uint8_t addrwin;
+	u_long start, stop;
+	u_int offset;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS || mem == NULL || mem->map >= MEM_MAX_MAPS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = mem->map;
+
+	mem->flags = 0;
+	mem->speed = 0;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_MEM(map))
+		mem->flags |= MAP_ACTIVE;
+
+	start = exca_read_word(slot, I365_MEM(map)+I365_W_START);
+	if (start & I365_MEM_16BIT)
+		mem->flags |= MAP_16BIT;
+	mem->sys_start = (start & 0x3fffUL) << 12;
+
+	stop = exca_read_word(slot, I365_MEM(map)+I365_W_STOP);
+	if (start & I365_MEM_WS0)
+		mem->speed += 1;
+	if (start & I365_MEM_WS1)
+		mem->speed += 2;
+	mem->sys_stop = ((stop & 0x3fffUL) << 12) + 0xfffUL;
+
+	offset = exca_read_word(slot, I365_MEM(map)+I365_W_OFF);
+	if (offset & I365_MEM_REG)
+		mem->flags |= MAP_ATTRIB;
+	if (offset & I365_MEM_WRPROT)
+		mem->flags |= MAP_WRPROT;
+	mem->card_start = (offset & 0x3fffUL) << 12;
+
+	mem->sys_start += CARD_MEM_START;
+	mem->sys_stop += CARD_MEM_START;
+
+	return 0;
+}
+
+static int pccard_set_mem_map(unsigned int slot, struct pccard_mem_map *mem)
+{
+	vrc4171_socket_t *socket;
+	uint16_t start, stop, offset;
+	uint8_t addrwin;
+	u_char map;
+
+	if (slot >= CARD_MAX_SLOTS ||
+	    mem == NULL || mem->map >= MEM_MAX_MAPS ||
+	    mem->sys_start < CARD_MEM_START || mem->sys_start > CARD_MEM_END ||
+	    mem->sys_stop < CARD_MEM_START || mem->sys_stop > CARD_MEM_END ||
+	    mem->sys_start > mem->sys_stop ||
+	    mem->card_start > CARD_MAX_MEM_OFFSET ||
+	    mem->speed > CARD_MAX_MEM_SPEED)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	map = mem->map;
+
+	addrwin = exca_read_byte(slot, I365_ADDRWIN);
+	if (addrwin & I365_ENA_MEM(map)) {
+		addrwin &= ~I365_ENA_MEM(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	start = (mem->sys_start >> 12) & 0x3fff;
+	if (mem->flags & MAP_16BIT)
+		start |= I365_MEM_16BIT;
+	exca_write_word(slot, I365_MEM(map)+I365_W_START, start);
+
+	stop = (mem->sys_stop >> 12) & 0x3fff;
+	switch (mem->speed) {
+	case 0:
+		break;
+	case 1:
+		stop |= I365_MEM_WS0;
+		break;
+	case 2:
+		stop |= I365_MEM_WS1;
+		break;
+	default:
+		stop |= I365_MEM_WS0 | I365_MEM_WS1;
+		break;
+	}
+	exca_write_word(slot, I365_MEM(map)+I365_W_STOP, stop);
+
+	offset = (mem->card_start >> 12) & 0x3fff;
+	if (mem->flags & MAP_ATTRIB)
+		offset |= I365_MEM_REG;
+	if (mem->flags & MAP_WRPROT)
+		offset |= I365_MEM_WRPROT;
+	exca_write_word(slot, I365_MEM(map)+I365_W_OFF, offset);
+
+	if (mem->flags & MAP_ACTIVE) {
+		addrwin |= I365_ENA_MEM(map);
+		exca_write_byte(slot, I365_ADDRWIN, addrwin);
+	}
+
+	return 0;
+}
+
+static void pccard_proc_setup(unsigned int slot, struct proc_dir_entry *base)
+{          
+}
+
+static struct pccard_operations vrc4171_pccard_operations = {
+	.init			= pccard_init,
+	.suspend		= pccard_suspend,
+	.register_callback	= pccard_register_callback,
+	.inquire_socket		= pccard_inquire_socket,
+	.get_status		= pccard_get_status,
+	.get_socket		= pccard_get_socket,
+	.set_socket		= pccard_set_socket,
+	.get_io_map		= pccard_get_io_map,
+	.set_io_map		= pccard_set_io_map,
+	.get_mem_map		= pccard_get_mem_map,
+	.set_mem_map		= pccard_set_mem_map,
+	.proc_setup		= pccard_proc_setup,
+};
+
+static void pccard_bh(void *data)
+{
+	vrc4171_socket_t *socket = (vrc4171_socket_t *)data;
+	uint16_t events;
+
+	spin_lock_irq(&socket->event_lock);
+	events = socket->events;
+	socket->events = 0;
+	spin_unlock_irq(&socket->event_lock);
+ 
+	if (socket->handler)
+		socket->handler(socket->info, events);
+}
+
+static inline uint16_t get_events(int slot)
+{
+	uint16_t events = 0;
+	uint8_t status, csc;
+
+	status = exca_read_byte(slot, I365_STATUS);
+	csc = exca_read_byte(slot, I365_CSC);
+
+	if (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {
+		if ((csc & I365_CSC_STSCHG) && (status & I365_CS_STSCHG))
+			events |= SS_STSCHG;
+	} else {
+		if (csc & (I365_CSC_BVD1 | I365_CSC_BVD2)) {
+			if (!(status & I365_CS_BVD1))
+				events |= SS_BATDEAD;
+			else if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)
+				events |= SS_BATWARN;
+		}
+	}
+	if ((csc & I365_CSC_READY) && (status & I365_CS_READY))
+		events |= SS_READY;
+	if ((csc & I365_CSC_DETECT) && ((status & I365_CS_DETECT) == I365_CS_DETECT))
+		events |= SS_DETECT;
+
+	return events;
+}
+
+static void pccard_status_change(int slot, vrc4171_socket_t *socket)
+{
+	uint16_t events;
+
+	socket->tq_task.routine = pccard_bh;
+	socket->tq_task.data = socket;
+
+	events = get_events(slot);
+	if (events) {
+		spin_lock(&socket->event_lock);
+		socket->events |= events;
+		spin_unlock(&socket->event_lock);
+		schedule_task(&socket->tq_task);
+	}
+}
+
+static void pccard_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	vrc4171_socket_t *socket;
+	uint16_t status;
+
+	status = vrc4171_get_irq_status();
+	if (status & IRQ_A) {
+		socket = &vrc4171_sockets[CARD_SLOTA];
+		if (socket->noprobe == SLOTB_PROBE) {
+			if (status & (1 << socket->csc_irq))
+				pccard_status_change(CARD_SLOTA, socket);
+		}
+	}
+
+	if (status & IRQ_B) {
+		socket = &vrc4171_sockets[CARD_SLOTB];
+		if (socket->noprobe == SLOTB_PROBE) {
+			if (status & (1 << socket->csc_irq))
+				pccard_status_change(CARD_SLOTB, socket);
+		}
+	}
+}
+
+static inline void reserve_using_irq(int slot)
+{
+	unsigned int irq;
+
+	irq = exca_read_byte(slot, I365_INTCTL);
+	irq &= 0x0f;
+	vrc4171_irq_mask &= ~(1 << irq);
+
+	irq = exca_read_byte(slot, I365_CSCINT);
+	irq = (irq & 0xf0) >> 4;
+	vrc4171_irq_mask &= ~(1 << irq);
+}
+
+static int __devinit vrc4171_add_socket(int slot)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return -EINVAL;
+
+	socket = &vrc4171_sockets[slot];
+	if (socket->noprobe != SLOTB_PROBE) {
+		uint8_t addrwin;
+
+		switch (socket->noprobe) {
+		case SLOTB_NOPROBE_MEM:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0x1f;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		case SLOTB_NOPROBE_IO:
+			addrwin = exca_read_byte(slot, I365_ADDRWIN);
+			addrwin &= 0xc0;
+			exca_write_byte(slot, I365_ADDRWIN, addrwin);
+			break;
+		default:
+			break;
+		}
+
+		reserve_using_irq(slot);
+
+		return 0;
+	}
+
+	sprintf(socket->name, "NEC VRC4171 Card Slot %1c", 'A' + slot);
+
+	socket->pcmcia_socket = pcmcia_register_socket(slot, &vrc4171_pccard_operations, 1);
+	if (socket->pcmcia_socket == NULL)
+		return -ENOMEM;
+
+	exca_write_byte(slot, I365_ADDRWIN, 0);
+
+	exca_write_byte(slot, GLOBAL_CONTROL, 0);
+
+	return 0;
+}
+
+static void vrc4171_remove_socket(int slot)
+{
+	vrc4171_socket_t *socket;
+
+	if (slot >= CARD_MAX_SLOTS)
+		return;
+
+	socket = &vrc4171_sockets[slot];
+
+	if (socket->pcmcia_socket != NULL) {
+		pcmcia_unregister_socket(socket->pcmcia_socket);
+		socket->pcmcia_socket = NULL;
+	}
+}
+
+static int __devinit vrc4171_card_setup(char *options)
+{
+	if (options == NULL || *options == '\0')
+		return 0;
+
+	if (strncmp(options, "irq:", 4) == 0) {
+		int irq;
+		options += 4;
+		irq = simple_strtoul(options, &options, 0);
+		if (irq >= 0 && irq < NR_IRQS)
+			vrc4171_irq = irq;
+
+		if (*options != ',')
+			return 0;
+		options++;
+	}
+
+	if (strncmp(options, "slota:", 6) == 0) {
+		options += 6;
+		if (*options != '\0') {
+			if (strncmp(options, "noprobe", 7) == 0) {
+				vrc4171_sockets[CARD_SLOTA].noprobe = 1;
+				options += 7;
+			}
+
+			if (*options != ',')
+				return 0;
+			options++;
+		} else
+			return 0;
+
+	}
+
+	if (strncmp(options, "slotb:", 6) == 0) {
+		options += 6;
+		if (*options != '\0') {
+			if (strncmp(options, "pccard", 6) == 0) {
+				vrc4171_slotb = SLOTB_IS_PCCARD;
+				options += 6;
+			} else if (strncmp(options, "cf", 2) == 0) {
+				vrc4171_slotb = SLOTB_IS_CF;
+				options += 2;
+			} else if (strncmp(options, "flashrom", 8) == 0) {
+				vrc4171_slotb = SLOTB_IS_FLASHROM;
+				options += 8;
+			} else if (strncmp(options, "none", 4) == 0) {
+				vrc4171_slotb = SLOTB_IS_NONE;
+				options += 4;
+			}
+
+			if (*options != ',')
+				return 0;
+			options++;
+
+			if ( strncmp(options, "memnoprobe", 10) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOTB_NOPROBE_MEM;
+			if ( strncmp(options, "ionoprobe", 9) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOTB_NOPROBE_IO;
+			if ( strncmp(options, "noprobe", 7) == 0)
+				vrc4171_sockets[CARD_SLOTB].noprobe = SLOTB_NOPROBE_ALL;
+		}
+	}
+
+	return 0;
+}
+
+__setup("vrc4171_card=", vrc4171_card_setup);
+
+static int __devinit vrc4171_card_init(void)
+{
+	int retval, slot;
+
+	vrc4171_set_multifunction_pin(vrc4171_slotb);
+
+	if (request_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE,
+	                       "NEC VRC4171 Card Controller") == NULL)
+		return -EBUSY;
+
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++) {
+		if (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)
+			break;
+
+		retval = vrc4171_add_socket(slot);
+		if (retval != 0)
+			return retval;
+	}
+
+	retval = request_irq(vrc4171_irq, pccard_interrupt, SA_SHIRQ,
+	                     "NEC VRC4171 Card Controller", vrc4171_sockets);
+	if (retval < 0) {
+		for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+			vrc4171_remove_socket(slot);
+
+		return retval;
+	}
+
+	printk(KERN_INFO "NEC VRC4171 Card Controller, connected to IRQ %d\n", vrc4171_irq);
+
+	return 0;
+}
+
+static void __devexit vrc4171_card_exit(void)
+{
+	int slot;
+
+	for (slot = 0; slot < CARD_MAX_SLOTS; slot++)
+		vrc4171_remove_socket(slot);
+
+	release_region(CARD_CONTROLLER_INDEX, CARD_CONTROLLER_SIZE);
+}
+
+module_init(vrc4171_card_init);
+module_exit(vrc4171_card_exit);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/scsi/NCR53C9x.h linux-mips-cvs-20040815/drivers/scsi/NCR53C9x.h
--- linux-2.4.27/drivers/scsi/NCR53C9x.h	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/scsi/NCR53C9x.h	2003-12-15 19:19:51.000000000 +0100
@@ -144,12 +144,7 @@
 
 #ifndef MULTIPLE_PAD_SIZES
 
-#ifdef CONFIG_CPU_HAS_WB
-#include <asm/wbflush.h>
-#define esp_write(__reg, __val) do{(__reg) = (__val); wbflush();} while(0)
-#else
-#define esp_write(__reg, __val) ((__reg) = (__val))
-#endif
+#define esp_write(__reg, __val) do{(__reg) = (__val); iob();} while(0)
 #define esp_read(__reg) (__reg)
 
 struct ESP_regs {
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/sound/Config.in linux-mips-cvs-20040815/drivers/sound/Config.in
--- linux-2.4.27/drivers/sound/Config.in	2003-11-28 19:26:20.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/sound/Config.in	2004-03-02 06:13:34.000000000 +0100
@@ -74,6 +74,7 @@ if [ "$CONFIG_DDB5477" = "y" ]; then
 fi
 if [ "$CONFIG_SOC_AU1X00" = "y" -o  "$CONFIG_SOC_AU1500" = "y" ]; then
     dep_tristate '  Au1x00 Sound' CONFIG_SOUND_AU1X00 $CONFIG_SOUND
+    dep_tristate '  Au1550 PSC Sound' CONFIG_SOUND_AU1550_PSC $CONFIG_SOUND
 fi
 
 dep_tristate '  Trident 4DWave DX/NX, SiS 7018 or ALi 5451 PCI Audio Core' CONFIG_SOUND_TRIDENT $CONFIG_SOUND $CONFIG_PCI
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/sound/Makefile linux-mips-cvs-20040815/drivers/sound/Makefile
--- linux-2.4.27/drivers/sound/Makefile	2003-11-28 19:26:20.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/sound/Makefile	2004-03-02 06:13:39.000000000 +0100
@@ -69,6 +69,7 @@ obj-$(CONFIG_SOUND_ES1370)	+= es1370.o
 obj-$(CONFIG_SOUND_ES1371)	+= es1371.o ac97_codec.o
 obj-$(CONFIG_SOUND_VRC5477)	+= nec_vrc5477.o ac97_codec.o
 obj-$(CONFIG_SOUND_AU1X00)      += au1000.o ac97_codec.o  
+obj-$(CONFIG_SOUND_AU1550_PSC)  += au1550_psc.o ac97_codec.o  
 obj-$(CONFIG_SOUND_ESSSOLO1)	+= esssolo1.o
 obj-$(CONFIG_SOUND_FUSION)	+= cs46xx.o ac97_codec.o
 obj-$(CONFIG_SOUND_MAESTRO)	+= maestro.o
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/sound/au1550_psc.c linux-mips-cvs-20040815/drivers/sound/au1550_psc.c
--- linux-2.4.27/drivers/sound/au1550_psc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/sound/au1550_psc.c	2004-08-15 08:06:28.000000000 +0200
@@ -0,0 +1,2168 @@
+/*
+ *      au1550.c  --  Sound driver for Alchemy Au1550 MIPS Internet Edge
+ *                    Processor.
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ *
+ * Mostly copied from the au1000.c driver and some from the
+ * PowerMac dbdma driver.
+ * We assume the processor can do memory coherent DMA.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/sound.h>
+#include <linux/slab.h>
+#include <linux/soundcard.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/ac97_codec.h>
+#include <linux/wrapper.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/hardirq.h>
+#include <asm/au1000.h>
+#include <asm/au1xxx_psc.h>
+#include <asm/au1xxx_dbdma.h>
+
+#ifdef CONFIG_MIPS_PB1550
+#include <asm/pb1550.h>
+#endif
+
+#ifdef CONFIG_MIPS_DB1550
+#include <asm/db1x00.h>
+#endif
+
+#undef OSS_DOCUMENTED_MIXER_SEMANTICS
+
+#define AU1550_MODULE_NAME "Au1550 psc audio"
+#define PFX AU1550_MODULE_NAME
+
+/* misc stuff */
+/* #define POLL_COUNT   0x5000 */
+#define POLL_COUNT   0x50000
+#define AC97_EXT_DACS (AC97_EXTID_SDAC | AC97_EXTID_CDAC | AC97_EXTID_LDAC)
+
+/* The number of DBDMA ring descriptors to allocate.  No sense making
+ * this too large....if you can't keep up with a few you aren't likely
+ * to be able to with lots of them, either.
+ */
+#define NUM_DBDMA_DESCRIPTORS 4
+
+#define err(format, arg...) printk(KERN_ERR PFX ": " format "\n" , ## arg)
+#define info(format, arg...) printk(KERN_INFO PFX ": " format "\n" , ## arg)
+
+/* Boot options
+ * 0 = no VRA, 1 = use VRA if codec supports it
+ */
+static int      vra = 1;
+MODULE_PARM(vra, "i");
+MODULE_PARM_DESC(vra, "if 1 use VRA if codec supports it");
+
+struct au1550_state {
+	/* soundcore stuff */
+	int             dev_audio;
+
+#ifdef AU1000_DEBUG
+	/* debug /proc entry */
+	struct proc_dir_entry *ps;
+	struct proc_dir_entry *ac97_ps;
+#endif				/* AU1000_DEBUG */
+
+	struct ac97_codec *codec;
+	unsigned        codec_base_caps; /* AC'97 reg 00h, "Reset Register" */
+	unsigned        codec_ext_caps;  /* AC'97 reg 28h, "Extended Audio ID" */
+	int             no_vra;		/* do not use VRA */
+
+	spinlock_t      lock;
+	struct semaphore open_sem;
+	struct semaphore sem;
+	mode_t          open_mode;
+	wait_queue_head_t open_wait;
+
+	struct dmabuf {
+		u32		dmanr;
+		unsigned        sample_rate;
+		unsigned	src_factor;
+		unsigned        sample_size;
+		int             num_channels;
+		int		dma_bytes_per_sample;
+		int		user_bytes_per_sample;
+		int		cnt_factor;
+
+		void		*rawbuf;
+		unsigned        buforder;
+		unsigned	numfrag;
+		unsigned        fragshift;
+		void		*nextIn;
+		void		*nextOut;
+		int		count;
+		unsigned        total_bytes;
+		unsigned        error;
+		wait_queue_head_t wait;
+
+		/* redundant, but makes calculations easier */
+		unsigned	fragsize;
+		unsigned	dma_fragsize;
+		unsigned	dmasize;
+		unsigned	dma_qcount;
+
+		/* OSS stuff */
+		unsigned        mapped:1;
+		unsigned        ready:1;
+		unsigned        stopped:1;
+		unsigned        ossfragshift;
+		int             ossmaxfrags;
+		unsigned        subdivision;
+	} dma_dac, dma_adc;
+} au1550_state;
+
+static unsigned
+ld2(unsigned int x)
+{
+	unsigned        r = 0;
+
+	if (x >= 0x10000) {
+		x >>= 16;
+		r += 16;
+	}
+	if (x >= 0x100) {
+		x >>= 8;
+		r += 8;
+	}
+	if (x >= 0x10) {
+		x >>= 4;
+		r += 4;
+	}
+	if (x >= 4) {
+		x >>= 2;
+		r += 2;
+	}
+	if (x >= 2)
+		r++;
+	return r;
+}
+
+static void
+au1550_delay(int msec)
+{
+	unsigned long   tmo;
+	signed long     tmo2;
+
+	if (in_interrupt())
+		return;
+
+	tmo = jiffies + (msec * HZ) / 1000;
+	for (;;) {
+		tmo2 = tmo - jiffies;
+		if (tmo2 <= 0)
+			break;
+		schedule_timeout(tmo2);
+	}
+}
+
+static u16
+rdcodec(struct ac97_codec *codec, u8 addr)
+{
+	struct au1550_state *s = (struct au1550_state *)codec->private_data;
+	unsigned long   flags;
+	u32             cmd, val;
+	u16             data;
+	int             i;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("rdcodec: codec cmd pending expired!");
+
+	cmd = (u32)PSC_AC97CDC_INDX(addr);
+	cmd |= PSC_AC97CDC_RD;	/* read command */
+	au_writel(cmd, PSC_AC97CDC);
+	au_sync();
+
+	/* now wait for the data
+	*/
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT) {
+		err("rdcodec: read poll expired!");
+		return 0;
+	}
+
+	/* wait for command done?
+	*/
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97EVNT);
+		au_sync();
+		if (val & PSC_AC97EVNT_CD)
+			break;
+	}
+	if (i == POLL_COUNT) {
+		err("rdcodec: read cmdwait expired!");
+		return 0;
+	}
+
+	data = au_readl(PSC_AC97CDC) & 0xffff;
+	au_sync();
+
+	/* Clear command done event.
+	*/
+	au_writel(PSC_AC97EVNT_CD, PSC_AC97EVNT);
+	au_sync();
+
+	spin_unlock_irqrestore(&s->lock, flags);
+
+	return data;
+}
+
+
+static void
+wrcodec(struct ac97_codec *codec, u8 addr, u16 data)
+{
+	struct au1550_state *s = (struct au1550_state *)codec->private_data;
+	unsigned long   flags;
+	u32             cmd, val;
+	int             i;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("wrcodec: codec cmd pending expired!");
+
+	cmd = (u32)PSC_AC97CDC_INDX(addr);
+	cmd |= (u32)data;
+	au_writel(cmd, PSC_AC97CDC);
+	au_sync();
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (!(val & PSC_AC97STAT_CP))
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("wrcodec: codec cmd pending expired!");
+
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97EVNT);
+		au_sync();
+		if (val & PSC_AC97EVNT_CD)
+			break;
+	}
+	if (i == POLL_COUNT)
+		err("wrcodec: read cmdwait expired!");
+
+	/* Clear command done event.
+	*/
+	au_writel(PSC_AC97EVNT_CD, PSC_AC97EVNT);
+	au_sync();
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+waitcodec(struct ac97_codec *codec)
+{
+	u16	temp;
+	u32	val;
+	int	i;
+
+	/* codec_wait is used to wait for a ready state after
+	 * an AC97C_RESET.
+	 */
+	au1550_delay(10);
+
+	/* first poll the CODEC_READY tag bit
+	*/
+	for (i = 0; i < POLL_COUNT; i++) {
+		val = au_readl(PSC_AC97STAT);
+		au_sync();
+		if (val & PSC_AC97STAT_CR)
+			break;
+	}
+	if (i == POLL_COUNT) {
+		err("waitcodec: CODEC_READY poll expired!");
+		return;
+	}
+
+	/* get AC'97 powerdown control/status register
+	*/
+	temp = rdcodec(codec, AC97_POWER_CONTROL);
+
+	/* If anything is powered down, power'em up
+	*/
+	if (temp & 0x7f00) {
+		/* Power on
+		*/
+		wrcodec(codec, AC97_POWER_CONTROL, 0);
+		au1550_delay(100);
+
+		/* Reread
+		*/
+		temp = rdcodec(codec, AC97_POWER_CONTROL);
+	}
+    
+	/* Check if Codec REF,ANL,DAC,ADC ready
+	*/
+	if ((temp & 0x7f0f) != 0x000f)
+		err("codec reg 26 status (0x%x) not ready!!", temp);
+}
+
+/* stop the ADC before calling */
+static void
+set_adc_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *adc = &s->dma_adc;
+	struct dmabuf  *dac = &s->dma_dac;
+	unsigned        adc_rate, dac_rate;
+	u16             ac97_extstat;
+
+	if (s->no_vra) {
+		/* calc SRC factor
+		*/
+		adc->src_factor = ((96000 / rate) + 1) >> 1;
+		adc->sample_rate = 48000 / adc->src_factor;
+		return;
+	}
+
+	adc->src_factor = 1;
+
+	ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+
+	rate = rate > 48000 ? 48000 : rate;
+
+	/* enable VRA
+	*/
+	wrcodec(s->codec, AC97_EXTENDED_STATUS,
+		ac97_extstat | AC97_EXTSTAT_VRA);
+
+	/* now write the sample rate
+	*/
+	wrcodec(s->codec, AC97_PCM_LR_ADC_RATE, (u16) rate);
+
+	/* read it back for actual supported rate
+	*/
+	adc_rate = rdcodec(s->codec, AC97_PCM_LR_ADC_RATE);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg(__FUNCTION__ ": set to %d Hz", adc_rate);
+#endif
+
+	/* some codec's don't allow unequal DAC and ADC rates, in which case
+	 * writing one rate reg actually changes both.
+	 */
+	dac_rate = rdcodec(s->codec, AC97_PCM_FRONT_DAC_RATE);
+	if (dac->num_channels > 2)
+		wrcodec(s->codec, AC97_PCM_SURR_DAC_RATE, dac_rate);
+	if (dac->num_channels > 4)
+		wrcodec(s->codec, AC97_PCM_LFE_DAC_RATE, dac_rate);
+
+	adc->sample_rate = adc_rate;
+	dac->sample_rate = dac_rate;
+}
+
+/* stop the DAC before calling */
+static void
+set_dac_rate(struct au1550_state *s, unsigned rate)
+{
+	struct dmabuf  *dac = &s->dma_dac;
+	struct dmabuf  *adc = &s->dma_adc;
+	unsigned        adc_rate, dac_rate;
+	u16             ac97_extstat;
+
+	if (s->no_vra) {
+		/* calc SRC factor
+		*/
+		dac->src_factor = ((96000 / rate) + 1) >> 1;
+		dac->sample_rate = 48000 / dac->src_factor;
+		return;
+	}
+
+	dac->src_factor = 1;
+
+	ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+
+	rate = rate > 48000 ? 48000 : rate;
+
+	/* enable VRA
+	*/
+	wrcodec(s->codec, AC97_EXTENDED_STATUS,
+		ac97_extstat | AC97_EXTSTAT_VRA);
+
+	/* now write the sample rate
+	*/
+	wrcodec(s->codec, AC97_PCM_FRONT_DAC_RATE, (u16) rate);
+
+	/* I don't support different sample rates for multichannel,
+	 * so make these channels the same.
+	 */
+	if (dac->num_channels > 2)
+		wrcodec(s->codec, AC97_PCM_SURR_DAC_RATE, (u16) rate);
+	if (dac->num_channels > 4)
+		wrcodec(s->codec, AC97_PCM_LFE_DAC_RATE, (u16) rate);
+	/* read it back for actual supported rate
+	*/
+	dac_rate = rdcodec(s->codec, AC97_PCM_FRONT_DAC_RATE);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg(__FUNCTION__ ": set to %d Hz", dac_rate);
+#endif
+
+	/* some codec's don't allow unequal DAC and ADC rates, in which case
+	 * writing one rate reg actually changes both.
+	 */
+	adc_rate = rdcodec(s->codec, AC97_PCM_LR_ADC_RATE);
+
+	dac->sample_rate = dac_rate;
+	adc->sample_rate = adc_rate;
+}
+
+static void
+stop_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	u32		stat;
+	unsigned long   flags;
+
+	if (db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	au_writel(PSC_AC97PCR_TP, PSC_AC97PCR);
+	au_sync();
+
+	/* Wait for Transmit Busy to show disabled.
+	*/
+	do {
+		stat = readl(PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_TB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+stop_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	unsigned long   flags;
+	u32		stat;
+
+	if (db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	au_writel(PSC_AC97PCR_RP, PSC_AC97PCR);
+	au_sync();
+
+	/* Wait for Receive Busy to show disabled.
+	*/
+	do {
+		stat = readl(PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_RB) != 0);
+
+	au1xxx_dbdma_reset(db->dmanr);
+
+	db->stopped = 1;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+
+static void
+set_xmit_slots(int num_channels)
+{
+	u32	ac97_config, stat;
+
+	ac97_config = au_readl(PSC_AC97CFG);
+	au_sync();
+	ac97_config &= ~(PSC_AC97CFG_TXSLOT_MASK | PSC_AC97CFG_DE_ENABLE);
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	switch (num_channels) {
+	case 6:		/* stereo with surround and center/LFE,
+			 * slots 3,4,6,7,8,9
+			 */
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(6);
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(9);
+
+	case 4:		/* stereo with surround, slots 3,4,7,8 */
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(7);
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(8);
+
+	case 2:		/* stereo, slots 3,4 */
+	case 1:		/* mono */
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(3);
+		ac97_config |= PSC_AC97CFG_TXSLOT_ENA(4);
+	}
+
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	ac97_config |= PSC_AC97CFG_DE_ENABLE;
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		stat = readl(PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_DR) == 0);
+}
+
+static void
+set_recv_slots(int num_channels)
+{
+	u32	ac97_config, stat;
+
+	ac97_config = au_readl(PSC_AC97CFG);
+	au_sync();
+	ac97_config &= ~(PSC_AC97CFG_RXSLOT_MASK | PSC_AC97CFG_DE_ENABLE);
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	/* Always enable slots 3 and 4 (stereo). Slot 6 is
+	 * optional Mic ADC, which we don't support yet.
+	 */
+	ac97_config |= PSC_AC97CFG_RXSLOT_ENA(3);
+	ac97_config |= PSC_AC97CFG_RXSLOT_ENA(4);
+
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	ac97_config |= PSC_AC97CFG_DE_ENABLE;
+	au_writel(ac97_config, PSC_AC97CFG);
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		stat = readl(PSC_AC97STAT);
+		au_sync();
+	} while ((stat & PSC_AC97STAT_DR) == 0);
+}
+
+static void
+start_dac(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_dac;
+	unsigned long   flags;
+
+	if (!db->stopped)
+		return;
+
+	spin_lock_irqsave(&s->lock, flags);
+
+	set_xmit_slots(db->num_channels);
+	au_writel(PSC_AC97PCR_TC, PSC_AC97PCR);
+	au_sync();
+	au_writel(PSC_AC97PCR_TS, PSC_AC97PCR);
+	au_sync();
+
+	au1xxx_dbdma_start(db->dmanr);
+
+	db->stopped = 0;
+
+	spin_unlock_irqrestore(&s->lock, flags);
+}
+
+static void
+start_adc(struct au1550_state *s)
+{
+	struct dmabuf  *db = &s->dma_adc;
+	int	i;
+
+	if (!db->stopped)
+		return;
+
+	/* Put two buffers on the ring to get things started.
+	*/
+	for (i=0; i<2; i++) {
+		au1xxx_dbdma_put_dest(db->dmanr, db->nextIn, db->dma_fragsize);
+
+		db->nextIn += db->dma_fragsize;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+	}
+
+	set_recv_slots(db->num_channels);
+	au1xxx_dbdma_start(db->dmanr);
+	au_writel(PSC_AC97PCR_RC, PSC_AC97PCR);
+	au_sync();
+	au_writel(PSC_AC97PCR_RS, PSC_AC97PCR);
+	au_sync();
+
+	db->stopped = 0;
+}
+
+static int
+prog_dmabuf(struct au1550_state *s, struct dmabuf *db)
+{
+	unsigned user_bytes_per_sec;
+	unsigned        bufs;
+	unsigned        rate = db->sample_rate;
+
+	if (!db->rawbuf) {
+		db->ready = db->mapped = 0;
+		db->buforder = 5;	/* 32 * PAGE_SIZE */
+		db->rawbuf = kmalloc((PAGE_SIZE << db->buforder), GFP_KERNEL);
+		if (!db->rawbuf)
+			return -ENOMEM;
+	}
+
+	db->cnt_factor = 1;
+	if (db->sample_size == 8)
+		db->cnt_factor *= 2;
+	if (db->num_channels == 1)
+		db->cnt_factor *= 2;
+	db->cnt_factor *= db->src_factor;
+
+	db->count = 0;
+	db->dma_qcount = 0;
+	db->nextIn = db->nextOut = db->rawbuf;
+
+	db->user_bytes_per_sample = (db->sample_size>>3) * db->num_channels;
+	db->dma_bytes_per_sample = 2 * ((db->num_channels == 1) ?
+					2 : db->num_channels);
+
+	user_bytes_per_sec = rate * db->user_bytes_per_sample;
+	bufs = PAGE_SIZE << db->buforder;
+	if (db->ossfragshift) {
+		if ((1000 << db->ossfragshift) < user_bytes_per_sec)
+			db->fragshift = ld2(user_bytes_per_sec/1000);
+		else
+			db->fragshift = db->ossfragshift;
+	} else {
+		db->fragshift = ld2(user_bytes_per_sec / 100 /
+				    (db->subdivision ? db->subdivision : 1));
+		if (db->fragshift < 3)
+			db->fragshift = 3;
+	}
+
+	db->fragsize = 1 << db->fragshift;
+	db->dma_fragsize = db->fragsize * db->cnt_factor;
+	db->numfrag = bufs / db->dma_fragsize;
+
+	while (db->numfrag < 4 && db->fragshift > 3) {
+		db->fragshift--;
+		db->fragsize = 1 << db->fragshift;
+		db->dma_fragsize = db->fragsize * db->cnt_factor;
+		db->numfrag = bufs / db->dma_fragsize;
+	}
+
+	if (db->ossmaxfrags >= 4 && db->ossmaxfrags < db->numfrag)
+		db->numfrag = db->ossmaxfrags;
+
+	db->dmasize = db->dma_fragsize * db->numfrag;
+	memset(db->rawbuf, 0, bufs);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg("rate=%d, samplesize=%d, channels=%d",
+	    rate, db->sample_size, db->num_channels);
+	dbg("fragsize=%d, cnt_factor=%d, dma_fragsize=%d",
+	    db->fragsize, db->cnt_factor, db->dma_fragsize);
+	dbg("numfrag=%d, dmasize=%d", db->numfrag, db->dmasize);
+#endif
+
+	db->ready = 1;
+	return 0;
+}
+
+static int
+prog_dmabuf_adc(struct au1550_state *s)
+{
+	stop_adc(s);
+	return prog_dmabuf(s, &s->dma_adc);
+
+}
+
+static int
+prog_dmabuf_dac(struct au1550_state *s)
+{
+	stop_dac(s);
+	return prog_dmabuf(s, &s->dma_dac);
+}
+
+
+/* hold spinlock for the following */
+static void
+dac_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct au1550_state *s = (struct au1550_state *) dev_id;
+	struct dmabuf  *db = &s->dma_dac;
+	u32	ac97c_stat;
+
+	ac97c_stat = au_readl(PSC_AC97STAT);
+#ifdef AU1000_VERBOSE_DEBUG
+	if (ac97c_stat & (AC97C_XU | AC97C_XO | AC97C_TE))
+		dbg("AC97C status = 0x%08x", ac97c_stat);
+#endif
+	db->dma_qcount--;
+
+	if (db->count >= db->fragsize) {
+		if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+			err("qcount < 2 and no ring room!");
+		}
+		db->nextOut += db->fragsize;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		db->count -= db->fragsize;
+		db->total_bytes += db->dma_fragsize;
+		db->dma_qcount++;
+	}
+
+	/* wake up anybody listening */
+	if (waitqueue_active(&db->wait))
+		wake_up(&db->wait);
+}
+
+
+static void
+adc_dma_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct	au1550_state *s = (struct au1550_state *)dev_id;
+	struct	dmabuf  *dp = &s->dma_adc;
+	u32	obytes;
+	char	*obuf;
+
+	/* Pull the buffer from the dma queue.
+	*/
+	au1xxx_dbdma_get_dest(dp->dmanr, (void *)(&obuf), &obytes);
+
+	if ((dp->count + obytes) > dp->dmasize) {
+		/* Overrun. Stop ADC and log the error
+		*/
+		stop_adc(s);
+		dp->error++;
+		err("adc overrun");
+		return;
+	}
+
+	/* Put a new empty buffer on the destination DMA.
+	*/
+	au1xxx_dbdma_put_dest(dp->dmanr, dp->nextIn, dp->dma_fragsize);
+
+	dp->nextIn += dp->dma_fragsize;
+	if (dp->nextIn >= dp->rawbuf + dp->dmasize)
+		dp->nextIn -= dp->dmasize;
+
+	dp->count += obytes;
+	dp->total_bytes += obytes;
+
+	/* wake up anybody listening
+	*/
+	if (waitqueue_active(&dp->wait))
+		wake_up(&dp->wait);
+
+}
+
+static loff_t
+au1550_llseek(struct file *file, loff_t offset, int origin)
+{
+	return -ESPIPE;
+}
+
+
+static int
+au1550_open_mixdev(struct inode *inode, struct file *file)
+{
+	file->private_data = &au1550_state;
+	return 0;
+}
+
+static int
+au1550_release_mixdev(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int
+mixdev_ioctl(struct ac97_codec *codec, unsigned int cmd,
+                        unsigned long arg)
+{
+	return codec->mixer_ioctl(codec, cmd, arg);
+}
+
+static int
+au1550_ioctl_mixdev(struct inode *inode, struct file *file,
+			       unsigned int cmd, unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct ac97_codec *codec = s->codec;
+
+	return mixdev_ioctl(codec, cmd, arg);
+}
+
+static /*const */ struct file_operations au1550_mixer_fops = {
+	owner:THIS_MODULE,
+	llseek:au1550_llseek,
+	ioctl:au1550_ioctl_mixdev,
+	open:au1550_open_mixdev,
+	release:au1550_release_mixdev,
+};
+
+static int
+drain_dac(struct au1550_state *s, int nonblock)
+{
+	unsigned long   flags;
+	int             count, tmo;
+
+	if (s->dma_dac.mapped || !s->dma_dac.ready || s->dma_dac.stopped)
+		return 0;
+
+	for (;;) {
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count <= s->dma_dac.fragsize)
+			break;
+		if (signal_pending(current))
+			break;
+		if (nonblock)
+			return -EBUSY;
+		tmo = 1000 * count / (s->no_vra ?
+				      48000 : s->dma_dac.sample_rate);
+		tmo /= s->dma_dac.dma_bytes_per_sample;
+		au1550_delay(tmo);
+	}
+	if (signal_pending(current))
+		return -ERESTARTSYS;
+	return 0;
+}
+
+static inline u8 S16_TO_U8(s16 ch)
+{
+	return (u8) (ch >> 8) + 0x80;
+}
+static inline s16 U8_TO_S16(u8 ch)
+{
+	return (s16) (ch - 0x80) << 8;
+}
+
+/*
+ * Translates user samples to dma buffer suitable for AC'97 DAC data:
+ *     If mono, copy left channel to right channel in dma buffer.
+ *     If 8 bit samples, cvt to 16-bit before writing to dma buffer.
+ *     If interpolating (no VRA), duplicate every audio frame src_factor times.
+ */
+static int
+translate_from_user(struct dmabuf *db, char* dmabuf, char* userbuf,
+							       int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+	s16             ch, dmasample[6];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_from_user(dmabuf, userbuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		if (copy_from_user(usersample, userbuf,
+				   db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				ch = U8_TO_S16(usersample[i]);
+			else
+				ch = *((s16 *) (&usersample[i * 2]));
+			dmasample[i] = ch;
+			if (mono)
+				dmasample[i + 1] = ch;	/* right channel */
+		}
+
+		/* duplicate every audio frame src_factor times
+		*/
+		for (i = 0; i < db->src_factor; i++)
+			memcpy(dmabuf, dmasample, db->dma_bytes_per_sample);
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Translates AC'97 ADC samples to user buffer:
+ *     If mono, send only left channel to user buffer.
+ *     If 8 bit samples, cvt from 16 to 8 bit before writing to user buffer.
+ *     If decimating (no VRA), skip over src_factor audio frames.
+ */
+static int
+translate_to_user(struct dmabuf *db, char* userbuf, char* dmabuf,
+							     int dmacount)
+{
+	int             sample, i;
+	int             interp_bytes_per_sample;
+	int             num_samples;
+	int             mono = (db->num_channels == 1);
+	char            usersample[12];
+
+	if (db->sample_size == 16 && !mono && db->src_factor == 1) {
+		/* no translation necessary, just copy
+		*/
+		if (copy_to_user(userbuf, dmabuf, dmacount))
+			return -EFAULT;
+		return dmacount;
+	}
+
+	interp_bytes_per_sample = db->dma_bytes_per_sample * db->src_factor;
+	num_samples = dmacount / interp_bytes_per_sample;
+
+	for (sample = 0; sample < num_samples; sample++) {
+		for (i = 0; i < db->num_channels; i++) {
+			if (db->sample_size == 8)
+				usersample[i] =
+					S16_TO_U8(*((s16 *) (&dmabuf[i * 2])));
+			else
+				*((s16 *) (&usersample[i * 2])) =
+					*((s16 *) (&dmabuf[i * 2]));
+		}
+
+		if (copy_to_user(userbuf, usersample,
+				 db->user_bytes_per_sample)) {
+			return -EFAULT;
+		}
+
+		userbuf += db->user_bytes_per_sample;
+		dmabuf += interp_bytes_per_sample;
+	}
+
+	return num_samples * interp_bytes_per_sample;
+}
+
+/*
+ * Copy audio data to/from user buffer from/to dma buffer, taking care
+ * that we wrap when reading/writing the dma buffer. Returns actual byte
+ * count written to or read from the dma buffer.
+ */
+static int
+copy_dmabuf_user(struct dmabuf *db, char* userbuf, int count, int to_user)
+{
+	char           *bufptr = to_user ? db->nextOut : db->nextIn;
+	char           *bufend = db->rawbuf + db->dmasize;
+	int             cnt, ret;
+
+	if (bufptr + count > bufend) {
+		int             partial = (int) (bufend - bufptr);
+		if (to_user) {
+			if ((cnt = translate_to_user(db, userbuf,
+						     bufptr, partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_to_user(db, userbuf + partial,
+						     db->rawbuf,
+						     count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		} else {
+			if ((cnt = translate_from_user(db, bufptr, userbuf,
+						       partial)) < 0)
+				return cnt;
+			ret = cnt;
+			if ((cnt = translate_from_user(db, db->rawbuf,
+						       userbuf + partial,
+						       count - partial)) < 0)
+				return cnt;
+			ret += cnt;
+		}
+	} else {
+		if (to_user)
+			ret = translate_to_user(db, userbuf, bufptr, count);
+		else
+			ret = translate_from_user(db, bufptr, userbuf, count);
+	}
+
+	return ret;
+}
+
+
+static ssize_t
+au1550_read(struct file *file, char *buffer, size_t count, loff_t *ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_adc;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_WRITE, buffer, count))
+		return -EFAULT;
+	ret = 0;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for samples in ADC dma buffer
+		*/
+		do {
+			if (db->stopped)
+				start_adc(s);
+			spin_lock_irqsave(&s->lock, flags);
+			avail = db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from nextOut to user
+		*/
+		if ((cnt = copy_dmabuf_user(db, buffer,
+					    count > avail ?
+					    avail : count, 1)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count -= cnt;
+		db->nextOut += cnt;
+		if (db->nextOut >= db->rawbuf + db->dmasize)
+			db->nextOut -= db->dmasize;
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+static ssize_t
+au1550_write(struct file *file, const char *buffer, size_t count, loff_t * ppos)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db = &s->dma_dac;
+	DECLARE_WAITQUEUE(wait, current);
+	ssize_t         ret = 0;
+	unsigned long   flags;
+	int             cnt, usercnt, avail;
+
+#ifdef AU1000_VERBOSE_DEBUG
+	dbg("write: count=%d", count);
+#endif
+
+	if (ppos != &file->f_pos)
+		return -ESPIPE;
+	if (db->mapped)
+		return -ENXIO;
+	if (!access_ok(VERIFY_READ, buffer, count))
+		return -EFAULT;
+
+	count *= db->cnt_factor;
+
+	down(&s->sem);	
+	add_wait_queue(&db->wait, &wait);
+
+	while (count > 0) {
+		/* wait for space in playback buffer
+		*/
+		do {
+			spin_lock_irqsave(&s->lock, flags);
+			avail = (int) db->dmasize - db->count;
+			if (avail <= 0)
+				__set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&s->lock, flags);
+			if (avail <= 0) {
+				if (file->f_flags & O_NONBLOCK) {
+					if (!ret)
+						ret = -EAGAIN;
+					goto out;
+				}
+				up(&s->sem);
+				schedule();
+				if (signal_pending(current)) {
+					if (!ret)
+						ret = -ERESTARTSYS;
+					goto out2;
+				}
+				down(&s->sem);
+			}
+		} while (avail <= 0);
+
+		/* copy from user to nextIn
+		*/
+		if ((cnt = copy_dmabuf_user(db, (char *) buffer,
+					    count > avail ?
+					    avail : count, 0)) < 0) {
+			if (!ret)
+				ret = -EFAULT;
+			goto out;
+		}
+
+		spin_lock_irqsave(&s->lock, flags);
+		db->count += cnt;
+		db->nextIn += cnt;
+		if (db->nextIn >= db->rawbuf + db->dmasize)
+			db->nextIn -= db->dmasize;
+
+		/* If the data is available, we want to keep two buffers
+		 * on the dma queue.  If the queue count reaches zero,
+		 * we know the dma has stopped.
+		 */
+		while ((db->dma_qcount < 2) && (db->count >= db->fragsize)) {
+			if (au1xxx_dbdma_put_source(db->dmanr, db->nextOut,
+							db->fragsize) == 0) {
+				err("qcount < 2 and no ring room!");
+			}
+			db->nextOut += db->fragsize;
+			if (db->nextOut >= db->rawbuf + db->dmasize)
+				db->nextOut -= db->dmasize;
+			db->total_bytes += db->dma_fragsize;
+			if (db->dma_qcount == 0)
+				start_dac(s);
+			db->dma_qcount++;
+		}
+		spin_unlock_irqrestore(&s->lock, flags);
+
+		count -= cnt;
+		usercnt = cnt / db->cnt_factor;
+		buffer += usercnt;
+		ret += usercnt;
+	}			/* while (count > 0) */
+
+out:
+	up(&s->sem);
+out2:
+	remove_wait_queue(&db->wait, &wait);
+	set_current_state(TASK_RUNNING);
+	return ret;
+}
+
+
+/* No kernel lock - we have our own spinlock */
+static unsigned int
+au1550_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	unsigned int    mask = 0;
+
+	if (file->f_mode & FMODE_WRITE) {
+		if (!s->dma_dac.ready)
+			return 0;
+		poll_wait(file, &s->dma_dac.wait, wait);
+	}
+	if (file->f_mode & FMODE_READ) {
+		if (!s->dma_adc.ready)
+			return 0;
+		poll_wait(file, &s->dma_adc.wait, wait);
+	}
+
+	spin_lock_irqsave(&s->lock, flags);
+	
+	if (file->f_mode & FMODE_READ) {
+		if (s->dma_adc.count >= (signed)s->dma_adc.dma_fragsize)
+			mask |= POLLIN | POLLRDNORM;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if (s->dma_dac.mapped) {
+			if (s->dma_dac.count >=
+			    (signed)s->dma_dac.dma_fragsize) 
+				mask |= POLLOUT | POLLWRNORM;
+		} else {
+			if ((signed) s->dma_dac.dmasize >=
+			    s->dma_dac.count + (signed)s->dma_dac.dma_fragsize)
+				mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+	spin_unlock_irqrestore(&s->lock, flags);
+	return mask;
+}
+
+static int
+au1550_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	struct dmabuf  *db;
+	unsigned long   size;
+	int ret = 0;
+
+	lock_kernel();
+	down(&s->sem);
+	if (vma->vm_flags & VM_WRITE)
+		db = &s->dma_dac;
+	else if (vma->vm_flags & VM_READ)
+		db = &s->dma_adc;
+	else {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (vma->vm_pgoff != 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+	size = vma->vm_end - vma->vm_start;
+	if (size > (PAGE_SIZE << db->buforder)) {
+		ret = -EINVAL;
+		goto out;
+	}
+	if (remap_page_range(vma->vm_start, virt_to_phys(db->rawbuf),
+			     size, vma->vm_page_prot)) {
+		ret = -EAGAIN;
+		goto out;
+	}
+	vma->vm_flags &= ~VM_IO;
+	db->mapped = 1;
+out:
+	up(&s->sem);
+	unlock_kernel();
+	return ret;
+}
+
+
+#ifdef AU1000_VERBOSE_DEBUG
+static struct ioctl_str_t {
+	unsigned int    cmd;
+	const char     *str;
+} ioctl_str[] = {
+	{SNDCTL_DSP_RESET, "SNDCTL_DSP_RESET"},
+	{SNDCTL_DSP_SYNC, "SNDCTL_DSP_SYNC"},
+	{SNDCTL_DSP_SPEED, "SNDCTL_DSP_SPEED"},
+	{SNDCTL_DSP_STEREO, "SNDCTL_DSP_STEREO"},
+	{SNDCTL_DSP_GETBLKSIZE, "SNDCTL_DSP_GETBLKSIZE"},
+	{SNDCTL_DSP_SAMPLESIZE, "SNDCTL_DSP_SAMPLESIZE"},
+	{SNDCTL_DSP_CHANNELS, "SNDCTL_DSP_CHANNELS"},
+	{SOUND_PCM_WRITE_CHANNELS, "SOUND_PCM_WRITE_CHANNELS"},
+	{SOUND_PCM_WRITE_FILTER, "SOUND_PCM_WRITE_FILTER"},
+	{SNDCTL_DSP_POST, "SNDCTL_DSP_POST"},
+	{SNDCTL_DSP_SUBDIVIDE, "SNDCTL_DSP_SUBDIVIDE"},
+	{SNDCTL_DSP_SETFRAGMENT, "SNDCTL_DSP_SETFRAGMENT"},
+	{SNDCTL_DSP_GETFMTS, "SNDCTL_DSP_GETFMTS"},
+	{SNDCTL_DSP_SETFMT, "SNDCTL_DSP_SETFMT"},
+	{SNDCTL_DSP_GETOSPACE, "SNDCTL_DSP_GETOSPACE"},
+	{SNDCTL_DSP_GETISPACE, "SNDCTL_DSP_GETISPACE"},
+	{SNDCTL_DSP_NONBLOCK, "SNDCTL_DSP_NONBLOCK"},
+	{SNDCTL_DSP_GETCAPS, "SNDCTL_DSP_GETCAPS"},
+	{SNDCTL_DSP_GETTRIGGER, "SNDCTL_DSP_GETTRIGGER"},
+	{SNDCTL_DSP_SETTRIGGER, "SNDCTL_DSP_SETTRIGGER"},
+	{SNDCTL_DSP_GETIPTR, "SNDCTL_DSP_GETIPTR"},
+	{SNDCTL_DSP_GETOPTR, "SNDCTL_DSP_GETOPTR"},
+	{SNDCTL_DSP_MAPINBUF, "SNDCTL_DSP_MAPINBUF"},
+	{SNDCTL_DSP_MAPOUTBUF, "SNDCTL_DSP_MAPOUTBUF"},
+	{SNDCTL_DSP_SETSYNCRO, "SNDCTL_DSP_SETSYNCRO"},
+	{SNDCTL_DSP_SETDUPLEX, "SNDCTL_DSP_SETDUPLEX"},
+	{SNDCTL_DSP_GETODELAY, "SNDCTL_DSP_GETODELAY"},
+	{SNDCTL_DSP_GETCHANNELMASK, "SNDCTL_DSP_GETCHANNELMASK"},
+	{SNDCTL_DSP_BIND_CHANNEL, "SNDCTL_DSP_BIND_CHANNEL"},
+	{OSS_GETVERSION, "OSS_GETVERSION"},
+	{SOUND_PCM_READ_RATE, "SOUND_PCM_READ_RATE"},
+	{SOUND_PCM_READ_CHANNELS, "SOUND_PCM_READ_CHANNELS"},
+	{SOUND_PCM_READ_BITS, "SOUND_PCM_READ_BITS"},
+	{SOUND_PCM_READ_FILTER, "SOUND_PCM_READ_FILTER"}
+};
+#endif
+
+static int
+dma_count_done(struct dmabuf *db)
+{
+	if (db->stopped)
+		return 0;
+
+	return db->dma_fragsize - au1xxx_get_dma_residue(db->dmanr);
+}
+
+
+static int
+au1550_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+	unsigned long   flags;
+	audio_buf_info  abinfo;
+	count_info      cinfo;
+	int             count;
+	int             val, mapped, ret, diff;
+
+	mapped = ((file->f_mode & FMODE_WRITE) && s->dma_dac.mapped) ||
+		((file->f_mode & FMODE_READ) && s->dma_adc.mapped);
+
+#ifdef AU1000_VERBOSE_DEBUG
+	for (count=0; count<sizeof(ioctl_str)/sizeof(ioctl_str[0]); count++) {
+		if (ioctl_str[count].cmd == cmd)
+			break;
+	}
+	if (count < sizeof(ioctl_str) / sizeof(ioctl_str[0]))
+		dbg("ioctl %s, arg=0x%lx", ioctl_str[count].str, arg);
+	else
+		dbg("ioctl 0x%x unknown, arg=0x%lx", cmd, arg);
+#endif
+
+	switch (cmd) {
+	case OSS_GETVERSION:
+		return put_user(SOUND_VERSION, (int *) arg);
+
+	case SNDCTL_DSP_SYNC:
+		if (file->f_mode & FMODE_WRITE)
+			return drain_dac(s, file->f_flags & O_NONBLOCK);
+		return 0;
+
+	case SNDCTL_DSP_SETDUPLEX:
+		return 0;
+
+	case SNDCTL_DSP_GETCAPS:
+		return put_user(DSP_CAP_DUPLEX | DSP_CAP_REALTIME |
+				DSP_CAP_TRIGGER | DSP_CAP_MMAP, (int *)arg);
+
+	case SNDCTL_DSP_RESET:
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			synchronize_irq();
+			s->dma_dac.count = s->dma_dac.total_bytes = 0;
+			s->dma_dac.nextIn = s->dma_dac.nextOut =
+				s->dma_dac.rawbuf;
+		}
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			synchronize_irq();
+			s->dma_adc.count = s->dma_adc.total_bytes = 0;
+			s->dma_adc.nextIn = s->dma_adc.nextOut =
+				s->dma_adc.rawbuf;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SPEED:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val >= 0) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				set_adc_rate(s, val);
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				set_dac_rate(s, val);
+			}
+			if (s->open_mode & FMODE_READ)
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			if (s->open_mode & FMODE_WRITE)
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+		}
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SNDCTL_DSP_STEREO:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.num_channels = val ? 2 : 1;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.num_channels = val ? 2 : 1;
+			if (s->codec_ext_caps & AC97_EXT_DACS) {
+				/* disable surround and center/lfe in AC'97
+				*/
+				u16 ext_stat = rdcodec(s->codec,
+						       AC97_EXTENDED_STATUS);
+				wrcodec(s->codec, AC97_EXTENDED_STATUS,
+					ext_stat | (AC97_EXTSTAT_PRI |
+						    AC97_EXTSTAT_PRJ |
+						    AC97_EXTSTAT_PRK));
+			}
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_CHANNELS:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 0) {
+			if (file->f_mode & FMODE_READ) {
+				if (val < 0 || val > 2)
+					return -EINVAL;
+				stop_adc(s);
+				s->dma_adc.num_channels = val;
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				switch (val) {
+				case 1:
+				case 2:
+					break;
+				case 3:
+				case 5:
+					return -EINVAL;
+				case 4:
+					if (!(s->codec_ext_caps &
+					      AC97_EXTID_SDAC))
+						return -EINVAL;
+					break;
+				case 6:
+					if ((s->codec_ext_caps &
+					     AC97_EXT_DACS) != AC97_EXT_DACS)
+						return -EINVAL;
+					break;
+				default:
+					return -EINVAL;
+				}
+
+				stop_dac(s);
+				if (val <= 2 &&
+				    (s->codec_ext_caps & AC97_EXT_DACS)) {
+					/* disable surround and center/lfe
+					 * channels in AC'97
+					 */
+					u16             ext_stat =
+						rdcodec(s->codec,
+							AC97_EXTENDED_STATUS);
+					wrcodec(s->codec,
+						AC97_EXTENDED_STATUS,
+						ext_stat | (AC97_EXTSTAT_PRI |
+							    AC97_EXTSTAT_PRJ |
+							    AC97_EXTSTAT_PRK));
+				} else if (val >= 4) {
+					/* enable surround, center/lfe
+					 * channels in AC'97
+					 */
+					u16             ext_stat =
+						rdcodec(s->codec,
+							AC97_EXTENDED_STATUS);
+					ext_stat &= ~AC97_EXTSTAT_PRJ;
+					if (val == 6)
+						ext_stat &=
+							~(AC97_EXTSTAT_PRI |
+							  AC97_EXTSTAT_PRK);
+					wrcodec(s->codec,
+						AC97_EXTENDED_STATUS,
+						ext_stat);
+				}
+
+				s->dma_dac.num_channels = val;
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_GETFMTS:	/* Returns a mask */
+		return put_user(AFMT_S16_LE | AFMT_U8, (int *) arg);
+
+	case SNDCTL_DSP_SETFMT:	/* Selects ONE fmt */
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != AFMT_QUERY) {
+			if (file->f_mode & FMODE_READ) {
+				stop_adc(s);
+				if (val == AFMT_S16_LE)
+					s->dma_adc.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_adc.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_adc(s)))
+					return ret;
+			}
+			if (file->f_mode & FMODE_WRITE) {
+				stop_dac(s);
+				if (val == AFMT_S16_LE)
+					s->dma_dac.sample_size = 16;
+				else {
+					val = AFMT_U8;
+					s->dma_dac.sample_size = 8;
+				}
+				if ((ret = prog_dmabuf_dac(s)))
+					return ret;
+			}
+		} else {
+			if (file->f_mode & FMODE_READ)
+				val = (s->dma_adc.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+			else
+				val = (s->dma_dac.sample_size == 16) ?
+					AFMT_S16_LE : AFMT_U8;
+		}
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_POST:
+		return 0;
+
+	case SNDCTL_DSP_GETTRIGGER:
+		val = 0;
+		spin_lock_irqsave(&s->lock, flags);
+		if (file->f_mode & FMODE_READ && !s->dma_adc.stopped)
+			val |= PCM_ENABLE_INPUT;
+		if (file->f_mode & FMODE_WRITE && !s->dma_dac.stopped)
+			val |= PCM_ENABLE_OUTPUT;
+		spin_unlock_irqrestore(&s->lock, flags);
+		return put_user(val, (int *) arg);
+
+	case SNDCTL_DSP_SETTRIGGER:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			if (val & PCM_ENABLE_INPUT)
+				start_adc(s);
+			else
+				stop_adc(s);
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			if (val & PCM_ENABLE_OUTPUT)
+				start_dac(s);
+			else
+				stop_dac(s);
+		}
+		return 0;
+
+	case SNDCTL_DSP_GETOSPACE:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_dac.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = (s->dma_dac.dmasize - count) /
+			s->dma_dac.cnt_factor;
+		abinfo.fragstotal = s->dma_dac.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_dac.fragshift;
+#ifdef AU1000_VERBOSE_DEBUG
+		dbg("bytes=%d, fragments=%d", abinfo.bytes, abinfo.fragments);
+#endif
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_GETISPACE:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		abinfo.fragsize = s->dma_adc.fragsize;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_adc.count;
+		count += dma_count_done(&s->dma_adc);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		abinfo.bytes = count / s->dma_adc.cnt_factor;
+		abinfo.fragstotal = s->dma_adc.numfrag;
+		abinfo.fragments = abinfo.bytes >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &abinfo,
+				    sizeof(abinfo)) ? -EFAULT : 0;
+
+	case SNDCTL_DSP_NONBLOCK:
+		file->f_flags |= O_NONBLOCK;
+		return 0;
+
+	case SNDCTL_DSP_GETODELAY:
+		if (!(file->f_mode & FMODE_WRITE))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		count = s->dma_dac.count;
+		count -= dma_count_done(&s->dma_dac);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		count /= s->dma_dac.cnt_factor;
+		return put_user(count, (int *) arg);
+
+	case SNDCTL_DSP_GETIPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_adc.total_bytes;
+		count = s->dma_adc.count;
+		if (!s->dma_adc.stopped) {
+			diff = dma_count_done(&s->dma_adc);
+			count += diff;
+			cinfo.bytes += diff;
+			cinfo.ptr =  virt_to_phys(s->dma_adc.nextIn) + diff -
+				virt_to_phys(s->dma_adc.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_adc.nextIn) -
+				virt_to_phys(s->dma_adc.rawbuf);
+		if (s->dma_adc.mapped)
+			s->dma_adc.count &= (s->dma_adc.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_adc.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETOPTR:
+		if (!(file->f_mode & FMODE_READ))
+			return -EINVAL;
+		spin_lock_irqsave(&s->lock, flags);
+		cinfo.bytes = s->dma_dac.total_bytes;
+		count = s->dma_dac.count;
+		if (!s->dma_dac.stopped) {
+			diff = dma_count_done(&s->dma_dac);
+			count -= diff;
+			cinfo.bytes += diff;
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) + diff -
+				virt_to_phys(s->dma_dac.rawbuf);
+		} else
+			cinfo.ptr = virt_to_phys(s->dma_dac.nextOut) -
+				virt_to_phys(s->dma_dac.rawbuf);
+		if (s->dma_dac.mapped)
+			s->dma_dac.count &= (s->dma_dac.dma_fragsize-1);
+		spin_unlock_irqrestore(&s->lock, flags);
+		if (count < 0)
+			count = 0;
+		cinfo.blocks = count >> s->dma_dac.fragshift;
+		return copy_to_user((void *) arg, &cinfo, sizeof(cinfo));
+
+	case SNDCTL_DSP_GETBLKSIZE:
+		if (file->f_mode & FMODE_WRITE)
+			return put_user(s->dma_dac.fragsize, (int *) arg);
+		else
+			return put_user(s->dma_adc.fragsize, (int *) arg);
+
+	case SNDCTL_DSP_SETFRAGMENT:
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.ossfragshift = val & 0xffff;
+			s->dma_adc.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_adc.ossfragshift < 4)
+				s->dma_adc.ossfragshift = 4;
+			if (s->dma_adc.ossfragshift > 15)
+				s->dma_adc.ossfragshift = 15;
+			if (s->dma_adc.ossmaxfrags < 4)
+				s->dma_adc.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.ossfragshift = val & 0xffff;
+			s->dma_dac.ossmaxfrags = (val >> 16) & 0xffff;
+			if (s->dma_dac.ossfragshift < 4)
+				s->dma_dac.ossfragshift = 4;
+			if (s->dma_dac.ossfragshift > 15)
+				s->dma_dac.ossfragshift = 15;
+			if (s->dma_dac.ossmaxfrags < 4)
+				s->dma_dac.ossmaxfrags = 4;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SNDCTL_DSP_SUBDIVIDE:
+		if ((file->f_mode & FMODE_READ && s->dma_adc.subdivision) ||
+		    (file->f_mode & FMODE_WRITE && s->dma_dac.subdivision))
+			return -EINVAL;
+		if (get_user(val, (int *) arg))
+			return -EFAULT;
+		if (val != 1 && val != 2 && val != 4)
+			return -EINVAL;
+		if (file->f_mode & FMODE_READ) {
+			stop_adc(s);
+			s->dma_adc.subdivision = val;
+			if ((ret = prog_dmabuf_adc(s)))
+				return ret;
+		}
+		if (file->f_mode & FMODE_WRITE) {
+			stop_dac(s);
+			s->dma_dac.subdivision = val;
+			if ((ret = prog_dmabuf_dac(s)))
+				return ret;
+		}
+		return 0;
+
+	case SOUND_PCM_READ_RATE:
+		return put_user((file->f_mode & FMODE_READ) ?
+				s->dma_adc.sample_rate :
+				s->dma_dac.sample_rate,
+				(int *)arg);
+
+	case SOUND_PCM_READ_CHANNELS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.num_channels, (int *)arg);
+		else
+			return put_user(s->dma_dac.num_channels, (int *)arg);
+
+	case SOUND_PCM_READ_BITS:
+		if (file->f_mode & FMODE_READ)
+			return put_user(s->dma_adc.sample_size, (int *)arg);
+		else
+			return put_user(s->dma_dac.sample_size, (int *)arg);
+
+	case SOUND_PCM_WRITE_FILTER:
+	case SNDCTL_DSP_SETSYNCRO:
+	case SOUND_PCM_READ_FILTER:
+		return -EINVAL;
+	}
+
+	return mixdev_ioctl(s->codec, cmd, arg);
+}
+
+
+static int
+au1550_open(struct inode *inode, struct file *file)
+{
+	int             minor = MINOR(inode->i_rdev);
+	DECLARE_WAITQUEUE(wait, current);
+	struct au1550_state *s = &au1550_state;
+	int             ret;
+
+#ifdef AU1000_VERBOSE_DEBUG
+	if (file->f_flags & O_NONBLOCK)
+		dbg(__FUNCTION__ ": non-blocking");
+	else
+		dbg(__FUNCTION__ ": blocking");
+#endif
+	
+	file->private_data = s;
+	/* wait for device to become free */
+	down(&s->open_sem);
+	while (s->open_mode & file->f_mode) {
+		if (file->f_flags & O_NONBLOCK) {
+			up(&s->open_sem);
+			return -EBUSY;
+		}
+		add_wait_queue(&s->open_wait, &wait);
+		__set_current_state(TASK_INTERRUPTIBLE);
+		up(&s->open_sem);
+		schedule();
+		remove_wait_queue(&s->open_wait, &wait);
+		set_current_state(TASK_RUNNING);
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+		down(&s->open_sem);
+	}
+
+	stop_dac(s);
+	stop_adc(s);
+
+	if (file->f_mode & FMODE_READ) {
+		s->dma_adc.ossfragshift = s->dma_adc.ossmaxfrags =
+			s->dma_adc.subdivision = s->dma_adc.total_bytes = 0;
+		s->dma_adc.num_channels = 1;
+		s->dma_adc.sample_size = 8;
+		set_adc_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_adc.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_WRITE) {
+		s->dma_dac.ossfragshift = s->dma_dac.ossmaxfrags =
+			s->dma_dac.subdivision = s->dma_dac.total_bytes = 0;
+		s->dma_dac.num_channels = 1;
+		s->dma_dac.sample_size = 8;
+		set_dac_rate(s, 8000);
+		if ((minor & 0xf) == SND_DEV_DSP16)
+			s->dma_dac.sample_size = 16;
+	}
+
+	if (file->f_mode & FMODE_READ) {
+		if ((ret = prog_dmabuf_adc(s)))
+			return ret;
+	}
+	if (file->f_mode & FMODE_WRITE) {
+		if ((ret = prog_dmabuf_dac(s)))
+			return ret;
+	}
+
+	s->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);
+	up(&s->open_sem);
+	init_MUTEX(&s->sem);
+	return 0;
+}
+
+static int
+au1550_release(struct inode *inode, struct file *file)
+{
+	struct au1550_state *s = (struct au1550_state *)file->private_data;
+
+	lock_kernel();
+	
+	if (file->f_mode & FMODE_WRITE) {
+		unlock_kernel();
+		drain_dac(s, file->f_flags & O_NONBLOCK);
+		lock_kernel();
+	}
+
+	down(&s->open_sem);
+	if (file->f_mode & FMODE_WRITE) {
+		stop_dac(s);
+		kfree(s->dma_dac.rawbuf);
+		s->dma_dac.rawbuf = NULL;
+	}
+	if (file->f_mode & FMODE_READ) {
+		stop_adc(s);
+		kfree(s->dma_adc.rawbuf);
+		s->dma_adc.rawbuf = NULL;
+	}
+	s->open_mode &= ((~file->f_mode) & (FMODE_READ|FMODE_WRITE));
+	up(&s->open_sem);
+	wake_up(&s->open_wait);
+	unlock_kernel();
+	return 0;
+}
+
+static /*const */ struct file_operations au1550_audio_fops = {
+	owner:		THIS_MODULE,
+	llseek:		au1550_llseek,
+	read:		au1550_read,
+	write:		au1550_write,
+	poll:		au1550_poll,
+	ioctl:		au1550_ioctl,
+	mmap:		au1550_mmap,
+	open:		au1550_open,
+	release:	au1550_release,
+};
+
+MODULE_AUTHOR("Advanced Micro Devices (AMD), dan@embeddededge.com");
+MODULE_DESCRIPTION("Au1550 Audio Driver");
+
+static int __devinit
+au1550_probe(void)
+{
+	struct au1550_state *s = &au1550_state;
+	int             val;
+#ifdef AU1550_DEBUG
+	char            proc_str[80];
+#endif
+
+	memset(s, 0, sizeof(struct au1550_state));
+
+	init_waitqueue_head(&s->dma_adc.wait);
+	init_waitqueue_head(&s->dma_dac.wait);
+	init_waitqueue_head(&s->open_wait);
+	init_MUTEX(&s->open_sem);
+	spin_lock_init(&s->lock);
+
+	s->codec = ac97_alloc_codec();
+	if(s->codec == NULL) {
+		err("Out of memory");
+		return -1;
+	}
+	s->codec->private_data = s;
+	s->codec->id = 0;
+	s->codec->codec_read = rdcodec;
+	s->codec->codec_write = wrcodec;
+	s->codec->codec_wait = waitcodec;
+
+	if (!request_region(PHYSADDR(AC97_PSC_SEL),
+			    0x30, AU1550_MODULE_NAME)) {
+		err("AC'97 ports in use");
+	}
+
+	/* Allocate the DMA Channels
+	*/
+	if ((s->dma_dac.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_MEM_CHAN,
+	    DBDMA_AC97_TX_CHAN, dac_dma_interrupt, (void *)s)) == 0) {
+		err("Can't get DAC DMA");
+		goto err_dma1;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_dac.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_dac.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		err("Can't get DAC DMA descriptors");
+		goto err_dma1;
+	}
+
+	if ((s->dma_adc.dmanr = au1xxx_dbdma_chan_alloc(DBDMA_AC97_RX_CHAN,
+	    DBDMA_MEM_CHAN, adc_dma_interrupt, (void *)s)) == 0) {
+		err("Can't get ADC DMA");
+		goto err_dma2;
+	}
+	au1xxx_dbdma_set_devwidth(s->dma_adc.dmanr, 16);
+	if (au1xxx_dbdma_ring_alloc(s->dma_adc.dmanr,
+					NUM_DBDMA_DESCRIPTORS) == 0) {
+		err("Can't get ADC DMA descriptors");
+		goto err_dma2;
+	}
+
+	info("DAC: DMA%d, ADC: DMA%d", DBDMA_AC97_TX_CHAN, DBDMA_AC97_RX_CHAN);
+
+	/* register devices */
+
+	if ((s->dev_audio = register_sound_dsp(&au1550_audio_fops, -1)) < 0)
+		goto err_dev1;
+	if ((s->codec->dev_mixer =
+	     register_sound_mixer(&au1550_mixer_fops, -1)) < 0)
+		goto err_dev2;
+
+#ifdef AU1550_DEBUG
+	/* intialize the debug proc device */
+	s->ps = create_proc_read_entry(AU1000_MODULE_NAME, 0, NULL,
+				       proc_au1550_dump, NULL);
+#endif /* AU1550_DEBUG */
+
+	/* The GPIO for the appropriate PSC was configured by the
+	 * board specific start up.
+	 *
+	 * configure PSC for AC'97
+	 */
+	au_writel(0, AC97_PSC_CTRL);	/* Disable PSC */
+	au_sync();
+	au_writel((PSC_SEL_CLK_SERCLK | PSC_SEL_PS_AC97MODE), AC97_PSC_SEL);
+	au_sync();
+
+	/* cold reset the AC'97
+	*/
+	au_writel(PSC_AC97RST_RST, PSC_AC97RST);
+	au_sync();
+	au1550_delay(10);
+	au_writel(0, PSC_AC97RST);
+	au_sync();
+
+	/* need to delay around 500msec(bleech) to give
+	   some CODECs enough time to wakeup */
+	au1550_delay(500);
+
+	/* warm reset the AC'97 to start the bitclk
+	*/
+	au_writel(PSC_AC97RST_SNC, PSC_AC97RST);
+	au_sync();
+	udelay(100);
+	au_writel(0, PSC_AC97RST);
+	au_sync();
+
+	/* Enable PSC
+	*/
+	au_writel(PSC_CTRL_ENABLE, AC97_PSC_CTRL);
+	au_sync();
+
+	/* Wait for PSC ready.
+	*/
+	do {
+		val = readl(PSC_AC97STAT);
+		au_sync();
+	} while ((val & PSC_AC97STAT_SR) == 0);
+
+	/* Configure AC97 controller.
+	 * Deep FIFO, 16-bit sample, DMA, make sure DMA matches fifo size.
+	 */
+	val = PSC_AC97CFG_SET_LEN(16);
+	val |= PSC_AC97CFG_RT_FIFO8 | PSC_AC97CFG_TT_FIFO8;
+
+	/* Enable device so we can at least
+	 * talk over the AC-link.
+	 */
+	au_writel(val, PSC_AC97CFG);
+	au_writel(PSC_AC97MSK_ALLMASK, PSC_AC97MSK);
+	au_sync();
+	val |= PSC_AC97CFG_DE_ENABLE;
+	au_writel(val, PSC_AC97CFG);
+	au_sync();
+
+	/* Wait for Device ready.
+	*/
+	do {
+		val = readl(PSC_AC97STAT);
+		au_sync();
+	} while ((val & PSC_AC97STAT_DR) == 0);
+
+	/* codec init */
+	if (!ac97_probe_codec(s->codec))
+		goto err_dev3;
+
+	s->codec_base_caps = rdcodec(s->codec, AC97_RESET);
+	s->codec_ext_caps = rdcodec(s->codec, AC97_EXTENDED_ID);
+	info("AC'97 Base/Extended ID = %04x/%04x",
+	     s->codec_base_caps, s->codec_ext_caps);
+
+	if (!(s->codec_ext_caps & AC97_EXTID_VRA)) {
+		/* codec does not support VRA
+		*/
+		s->no_vra = 1;
+	} else if (!vra) {
+		/* Boot option says disable VRA
+		*/
+		u16 ac97_extstat = rdcodec(s->codec, AC97_EXTENDED_STATUS);
+		wrcodec(s->codec, AC97_EXTENDED_STATUS,
+			ac97_extstat & ~AC97_EXTSTAT_VRA);
+		s->no_vra = 1;
+	}
+	if (s->no_vra)
+		info("no VRA, interpolating and decimating");
+
+	/* set mic to be the recording source */
+	val = SOUND_MASK_MIC;
+	mixdev_ioctl(s->codec, SOUND_MIXER_WRITE_RECSRC,
+		     (unsigned long) &val);
+#ifdef AU1550_DEBUG
+	sprintf(proc_str, "driver/%s/%d/ac97", AU1550_MODULE_NAME,
+		s->codec->id);
+	s->ac97_ps = create_proc_read_entry (proc_str, 0, NULL,
+					     ac97_read_proc, &s->codec);
+#endif
+
+	return 0;
+
+ err_dev3:
+	unregister_sound_mixer(s->codec->dev_mixer);
+ err_dev2:
+	unregister_sound_dsp(s->dev_audio);
+ err_dev1:
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+ err_dma2:
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+ err_dma1:
+	release_region(PHYSADDR(AC97_PSC_SEL), 0x30);
+
+	ac97_release_codec(s->codec);
+	return -1;
+}
+
+static void __devinit
+au1550_remove(void)
+{
+	struct au1550_state *s = &au1550_state;
+
+	if (!s)
+		return;
+#ifdef AU1550_DEBUG
+	if (s->ps)
+		remove_proc_entry(AU1000_MODULE_NAME, NULL);
+#endif /* AU1000_DEBUG */
+	synchronize_irq();
+	au1xxx_dbdma_chan_free(s->dma_adc.dmanr);
+	au1xxx_dbdma_chan_free(s->dma_dac.dmanr);
+	release_region(PHYSADDR(AC97_PSC_SEL), 0x30);
+	unregister_sound_dsp(s->dev_audio);
+	unregister_sound_mixer(s->codec->dev_mixer);
+	ac97_release_codec(s->codec);
+}
+
+static int __init
+init_au1550(void)
+{
+	return au1550_probe();
+}
+
+static void __exit
+cleanup_au1550(void)
+{
+	au1550_remove();
+}
+
+module_init(init_au1550);
+module_exit(cleanup_au1550);
+
+#ifndef MODULE
+
+static int __init
+au1550_setup(char *options)
+{
+	char           *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	for(this_opt=strtok(options, ",");
+	    this_opt; this_opt=strtok(NULL, ",")) {
+		if (!strncmp(this_opt, "vra", 3)) {
+			vra = 1;
+		}
+	}
+
+	return 1;
+}
+
+__setup("au1550_audio=", au1550_setup);
+
+#endif /* MODULE */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/sound/swarm_cs4297a.c linux-mips-cvs-20040815/drivers/sound/swarm_cs4297a.c
--- linux-2.4.27/drivers/sound/swarm_cs4297a.c	2003-08-25 13:44:42.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/sound/swarm_cs4297a.c	2004-05-02 00:48:24.000000000 +0200
@@ -11,6 +11,7 @@
 *            -- adapted from cs4281 PCI driver for cs4297a on
 *               BCM1250 Synchronous Serial interface
 *               (Kip Walker, Broadcom Corp.)
+*      Copyright (C) 2004  Maciej W. Rozycki
 *
 *      This program is free software; you can redistribute it and/or modify
 *      it under the terms of the GNU General Public License as published by
@@ -71,14 +72,16 @@
 #include <linux/ac97_codec.h>
 #include <linux/pci.h>
 #include <linux/bitops.h>
-#include <asm/io.h>
-#include <asm/dma.h>
 #include <linux/init.h>
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/wrapper.h>
-#include <asm/uaccess.h>
+
+#include <asm/byteorder.h>
+#include <asm/dma.h>
 #include <asm/hardirq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
 
 #include <asm/sibyte/sb1250_regs.h>
 #include <asm/sibyte/sb1250_int.h>
@@ -758,7 +761,7 @@ static int serdma_reg_access(struct cs42
 
                 descr = &d->descrtab[swptr];
                 data_p = &d->dma_buf[swptr * 4];
-                *data_p = data;
+		*data_p = cpu_to_be64(data);
                 out64(1, SS_CSR(R_SER_DMA_DSCR_COUNT_TX));
                 CS_DBGOUT(CS_DESCR, 4,
                           printk(KERN_INFO "cs4297a: add_tx  %p (%x -> %x)\n",
@@ -950,7 +953,7 @@ static void cs4297a_update_ptr(struct cs
                         s_ptr = (u32 *)&(d->dma_buf[d->swptr*4]);
                         descr = &d->descrtab[d->swptr];
                         while (diff2--) {
-                                u64 data = *(u64 *)s_ptr;
+				u64 data = be64_to_cpu(*(u64 *)s_ptr);
                                 u64 descr_a;
                                 u16 left, right;
                                 descr_a = descr->descr_a;
@@ -977,10 +980,11 @@ static void cs4297a_update_ptr(struct cs
                                         continue;
                                 }
                                 good_diff++;
-                                left = ((s_ptr[1] & 0xff) << 8) | ((s_ptr[2] >> 24) & 0xff);
-                                right = (s_ptr[2] >> 4) & 0xffff;
-                                *d->sb_hwptr++ = left;
-                                *d->sb_hwptr++ = right;
+				left = ((be32_to_cpu(s_ptr[1]) & 0xff) << 8) |
+				       ((be32_to_cpu(s_ptr[2]) >> 24) & 0xff);
+				right = (be32_to_cpu(s_ptr[2]) >> 4) & 0xffff;
+				*d->sb_hwptr++ = cpu_to_be16(left);
+				*d->sb_hwptr++ = cpu_to_be16(right);
                                 if (d->sb_hwptr == d->sb_end)
                                         d->sb_hwptr = d->sample_buf;
                                 descr++;
@@ -1025,7 +1029,7 @@ static void cs4297a_update_ptr(struct cs
                            here because of an interrupt, so there must
                            be a buffer to process. */
                         do {
-                                data = *data_p;
+				data = be64_to_cpu(*data_p);
                                 if ((descr->descr_a & M_DMA_DSCRA_A_ADDR) != PHYSADDR((long)data_p)) {
                                         printk(KERN_ERR "cs4297a: RX Bad address %d (%llx %lx)\n", d->swptr,
                                                (long long)(descr->descr_a & M_DMA_DSCRA_A_ADDR),
@@ -1804,7 +1808,6 @@ static ssize_t cs4297a_write(struct file
                 u32 *s_tmpl;
                 u32 *t_tmpl;
                 u32 left, right;
-                /* XXXKW check system endian here ... */
                 int swap = (s->prop_dac.fmt == AFMT_S16_LE) || (s->prop_dac.fmt == AFMT_U16_LE);
                 
                 /* XXXXXX this is broken for BLOAT_FACTOR */
@@ -1845,21 +1848,21 @@ static ssize_t cs4297a_write(struct file
 
                 /* XXXKW assuming 16-bit stereo! */
                 do {
-                        t_tmpl[0] = 0x98000000;
-                        left = s_tmpl[0] >> 16;
-                        if (left & 0x8000)
-                                left |= 0xf0000;
-                        right = s_tmpl[0] & 0xffff;
-                        if (right & 0x8000)
-                                right |= 0xf0000;
-                        if (swap) {
-                          t_tmpl[1] = left & 0xff;
-                          t_tmpl[2] = ((left & 0xff00) << 16) | ((right & 0xff) << 12) |
-                              ((right & 0xff00) >> 4);
-                        } else {
-                          t_tmpl[1] = left >> 8;
-                          t_tmpl[2] = ((left & 0xff) << 24) | (right << 4);
-                        }
+			u32 tmp;
+
+			t_tmpl[0] = cpu_to_be32(0x98000000);
+
+			tmp = be32_to_cpu(s_tmpl[0]);
+			left = tmp & 0xffff;
+			right = tmp >> 16;
+			if (swap) {
+				left = swab16(left);
+				right = swab16(right);
+			}
+			t_tmpl[1] = cpu_to_be32(left >> 8);
+			t_tmpl[2] = cpu_to_be32(((left & 0xff) << 24) |
+						(right << 4));
+
                         s_tmpl++;
                         t_tmpl += 8;
                         copy_cnt -= 4;
@@ -1867,7 +1870,8 @@ static ssize_t cs4297a_write(struct file
 
                 /* Mux in any pending read/write accesses */
                 if (s->reg_request) {
-                        *(u64 *)(d->dma_buf + (swptr * 4)) |= s->reg_request;
+			*(u64 *)(d->dma_buf + (swptr * 4)) |=
+				cpu_to_be64(s->reg_request);
                         s->reg_request = 0;
                         wake_up(&s->dma_dac.reg_wait);
                 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/tc/lk201-map.c linux-mips-cvs-20040815/drivers/tc/lk201-map.c
--- linux-2.4.27/drivers/tc/lk201-map.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/tc/lk201-map.c	2004-04-14 21:34:05.000000000 +0200
@@ -0,0 +1,265 @@
+
+/* Do not edit this file! It was automatically generated by   */
+/*    loadkeys --mktable defkeymap.map > defkeymap.c          */
+
+#include <linux/types.h>
+#include <linux/keyboard.h>
+#include <linux/kd.h>
+
+u_short plain_map[NR_KEYS] = {
+	0xf200,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,	0xf105,	0xf106,
+	0xf107,	0xf108,	0xf109,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf11b,
+	0xf11c,	0xf110,	0xf111,	0xf112,	0xf113,	0xf060,	0xf031,	0xf032,
+	0xf033,	0xf034,	0xf035,	0xf036,	0xf037,	0xf038,	0xf039,	0xf030,
+	0xf02d,	0xf03d,	0xf07f,	0xf114,	0xf115,	0xf116,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf009,	0xfb71,	0xfb77,	0xfb65,	0xfb72,	0xfb74,
+	0xfb79,	0xfb75,	0xfb69,	0xfb6f,	0xfb70,	0xf05b,	0xf05d,	0xf201,
+	0xf117,	0xf118,	0xf119,	0xf307,	0xf308,	0xf309,	0xf30b,	0xf702,
+	0xf207,	0xfb61,	0xfb73,	0xfb64,	0xfb66,	0xfb67,	0xfb68,	0xfb6a,
+	0xfb6b,	0xfb6c,	0xf03b,	0xf027,	0xf05c,	0xf603,	0xf304,	0xf305,
+	0xf306,	0xf200,	0xf700,	0xf03e,	0xfb7a,	0xfb78,	0xfb63,	0xfb76,
+	0xfb62,	0xfb6e,	0xfb6d,	0xf02c,	0xf02e,	0xf02f,	0xf200,	0xf601,
+	0xf600,	0xf602,	0xf301,	0xf302,	0xf303,	0xf30e,	0xf200,	0xf703,
+	0xf020,	0xf200,	0xf200,	0xf300,	0xf310,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static u_short shift_map[NR_KEYS] = {
+	0xf200,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,	0xf105,	0xf106,
+	0xf107,	0xf108,	0xf109,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf203,
+	0xf11c,	0xf110,	0xf111,	0xf112,	0xf113,	0xf07e,	0xf021,	0xf040,
+	0xf023,	0xf024,	0xf025,	0xf05e,	0xf026,	0xf02a,	0xf028,	0xf029,
+	0xf05f,	0xf02b,	0xf07f,	0xf114,	0xf115,	0xf116,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf009,	0xfb51,	0xfb57,	0xfb45,	0xfb52,	0xfb54,
+	0xfb59,	0xfb55,	0xfb49,	0xfb4f,	0xfb50,	0xf07b,	0xf07d,	0xf201,
+	0xf117,	0xf20b,	0xf20a,	0xf307,	0xf308,	0xf309,	0xf30b,	0xf702,
+	0xf207,	0xfb41,	0xfb53,	0xfb44,	0xfb46,	0xfb47,	0xfb48,	0xfb4a,
+	0xfb4b,	0xfb4c,	0xf03a,	0xf022,	0xf07c,	0xf603,	0xf304,	0xf305,
+	0xf306,	0xf200,	0xf700,	0xf03c,	0xfb5a,	0xfb58,	0xfb43,	0xfb56,
+	0xfb42,	0xfb4e,	0xfb4d,	0xf03c,	0xf03e,	0xf03f,	0xf200,	0xf601,
+	0xf600,	0xf602,	0xf301,	0xf302,	0xf303,	0xf30e,	0xf200,	0xf703,
+	0xf020,	0xf200,	0xf200,	0xf300,	0xf310,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static u_short altgr_map[NR_KEYS] = {
+	0xf200,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,	0xf105,	0xf106,
+	0xf107,	0xf108,	0xf109,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf202,
+	0xf11c,	0xf110,	0xf111,	0xf112,	0xf113,	0xf200,	0xf200,	0xf040,
+	0xf200,	0xf024,	0xf200,	0xf200,	0xf07b,	0xf05b,	0xf05d,	0xf07d,
+	0xf05c,	0xf200,	0xf200,	0xf114,	0xf115,	0xf116,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xfb71,	0xfb77,	0xf918,	0xfb72,	0xfb74,
+	0xfb79,	0xfb75,	0xfb69,	0xfb6f,	0xfb70,	0xf200,	0xf07e,	0xf201,
+	0xf117,	0xf118,	0xf119,	0xf911,	0xf912,	0xf913,	0xf30b,	0xf702,
+	0xf207,	0xf914,	0xfb73,	0xf917,	0xf919,	0xfb67,	0xfb68,	0xfb6a,
+	0xfb6b,	0xfb6c,	0xf200,	0xf200,	0xf200,	0xf603,	0xf90e,	0xf90f,
+	0xf910,	0xf200,	0xf700,	0xf200,	0xfb7a,	0xfb78,	0xf916,	0xfb76,
+	0xf915,	0xfb6e,	0xfb6d,	0xf200,	0xf200,	0xf200,	0xf200,	0xf601,
+	0xf600,	0xf602,	0xf90b,	0xf90c,	0xf90d,	0xf30e,	0xf200,	0xf703,
+	0xf200,	0xf200,	0xf200,	0xf90a,	0xf310,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static u_short ctrl_map[NR_KEYS] = {
+	0xf200,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,	0xf105,	0xf106,
+	0xf107,	0xf108,	0xf109,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf204,
+	0xf11c,	0xf110,	0xf111,	0xf112,	0xf113,	0xf81b,	0xf200,	0xf000,
+	0xf01b,	0xf01c,	0xf01d,	0xf01e,	0xf01f,	0xf07f,	0xf200,	0xf200,
+	0xf01f,	0xf200,	0xf008,	0xf114,	0xf115,	0xf116,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,
+	0xf019,	0xf015,	0xf009,	0xf00f,	0xf010,	0xf01b,	0xf01d,	0xf201,
+	0xf117,	0xf118,	0xf119,	0xf307,	0xf308,	0xf309,	0xf30b,	0xf702,
+	0xf207,	0xf001,	0xf013,	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,
+	0xf00b,	0xf00c,	0xf200,	0xf007,	0xf01c,	0xf603,	0xf304,	0xf305,
+	0xf306,	0xf200,	0xf700,	0xf200,	0xf01a,	0xf018,	0xf003,	0xf016,
+	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf20e,	0xf07f,	0xf200,	0xf601,
+	0xf600,	0xf602,	0xf301,	0xf302,	0xf303,	0xf30e,	0xf200,	0xf703,
+	0xf000,	0xf200,	0xf200,	0xf300,	0xf310,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static u_short shift_ctrl_map[NR_KEYS] = {
+	0xf200,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,	0xf105,	0xf106,
+	0xf107,	0xf108,	0xf109,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf200,
+	0xf11c,	0xf110,	0xf111,	0xf112,	0xf113,	0xf200,	0xf200,	0xf000,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf01f,	0xf200,	0xf200,	0xf114,	0xf115,	0xf116,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,
+	0xf019,	0xf015,	0xf009,	0xf00f,	0xf010,	0xf200,	0xf200,	0xf201,
+	0xf117,	0xf118,	0xf119,	0xf307,	0xf308,	0xf309,	0xf30b,	0xf702,
+	0xf207,	0xf001,	0xf013,	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,
+	0xf00b,	0xf00c,	0xf200,	0xf200,	0xf200,	0xf603,	0xf304,	0xf305,
+	0xf306,	0xf200,	0xf700,	0xf200,	0xf01a,	0xf018,	0xf003,	0xf016,
+	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf200,	0xf200,	0xf200,	0xf601,
+	0xf600,	0xf602,	0xf301,	0xf302,	0xf303,	0xf30e,	0xf200,	0xf703,
+	0xf200,	0xf200,	0xf200,	0xf300,	0xf310,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static u_short alt_map[NR_KEYS] = {
+	0xf200,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,	0xf505,	0xf506,
+	0xf507,	0xf508,	0xf509,	0xf50a,	0xf50b,	0xf50c,	0xf50d,	0xf200,
+	0xf11c,	0xf510,	0xf511,	0xf512,	0xf513,	0xf01b,	0xf831,	0xf832,
+	0xf833,	0xf834,	0xf835,	0xf836,	0xf837,	0xf838,	0xf839,	0xf830,
+	0xf82d,	0xf83d,	0xf87f,	0xf114,	0xf115,	0xf116,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf809,	0xf871,	0xf877,	0xf865,	0xf872,	0xf874,
+	0xf879,	0xf875,	0xf869,	0xf86f,	0xf870,	0xf85b,	0xf85d,	0xf80d,
+	0xf117,	0xf118,	0xf119,	0xf907,	0xf908,	0xf909,	0xf30b,	0xf702,
+	0xf207,	0xf861,	0xf873,	0xf864,	0xf866,	0xf867,	0xf868,	0xf86a,
+	0xf86b,	0xf86c,	0xf83b,	0xf827,	0xf85c,	0xf603,	0xf904,	0xf905,
+	0xf906,	0xf200,	0xf700,	0xf200,	0xf87a,	0xf878,	0xf863,	0xf876,
+	0xf862,	0xf86e,	0xf86d,	0xf82c,	0xf82e,	0xf82f,	0xf200,	0xf210,
+	0xf600,	0xf211,	0xf901,	0xf902,	0xf903,	0xf30e,	0xf200,	0xf703,
+	0xf820,	0xf200,	0xf200,	0xf900,	0xf310,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+static u_short ctrl_alt_map[NR_KEYS] = {
+	0xf200,	0xf500,	0xf501,	0xf502,	0xf503,	0xf504,	0xf505,	0xf506,
+	0xf507,	0xf508,	0xf509,	0xf50a,	0xf50b,	0xf50c,	0xf50d,	0xf200,
+	0xf11c,	0xf510,	0xf511,	0xf512,	0xf513,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf114,	0xf115,	0xf20c,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf811,	0xf817,	0xf805,	0xf812,	0xf814,
+	0xf819,	0xf815,	0xf809,	0xf80f,	0xf810,	0xf200,	0xf200,	0xf201,
+	0xf117,	0xf118,	0xf119,	0xf307,	0xf308,	0xf309,	0xf30b,	0xf702,
+	0xf207,	0xf801,	0xf813,	0xf804,	0xf806,	0xf807,	0xf808,	0xf80a,
+	0xf80b,	0xf80c,	0xf200,	0xf200,	0xf200,	0xf603,	0xf304,	0xf305,
+	0xf306,	0xf200,	0xf700,	0xf200,	0xf81a,	0xf818,	0xf803,	0xf816,
+	0xf802,	0xf80e,	0xf80d,	0xf200,	0xf200,	0xf200,	0xf200,	0xf601,
+	0xf600,	0xf602,	0xf301,	0xf302,	0xf303,	0xf30e,	0xf200,	0xf703,
+	0xf200,	0xf200,	0xf200,	0xf300,	0xf20c,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
+};
+
+ushort *key_maps[MAX_NR_KEYMAPS] = {
+	plain_map, shift_map, altgr_map, 0,
+	ctrl_map, shift_ctrl_map, 0, 0,
+	alt_map, 0, 0, 0,
+	ctrl_alt_map,	0
+};
+
+unsigned int keymap_count = 7;
+
+
+/*
+ * Philosophy: most people do not define more strings, but they who do
+ * often want quite a lot of string space. So, we statically allocate
+ * the default and allocate dynamically in chunks of 512 bytes.
+ */
+
+char func_buf[] = {
+	'\033', '[', '[', 'A', 0, 
+	'\033', '[', '[', 'B', 0, 
+	'\033', '[', '[', 'C', 0, 
+	'\033', '[', '[', 'D', 0, 
+	'\033', '[', '[', 'E', 0, 
+	'\033', '[', '1', '7', '~', 0, 
+	'\033', '[', '1', '8', '~', 0, 
+	'\033', '[', '1', '9', '~', 0, 
+	'\033', '[', '2', '0', '~', 0, 
+	'\033', '[', '2', '1', '~', 0, 
+	'\033', '[', '2', '3', '~', 0, 
+	'\033', '[', '2', '4', '~', 0, 
+	'\033', '[', '2', '5', '~', 0, 
+	'\033', '[', '2', '6', '~', 0, 
+	'\033', '[', '2', '8', '~', 0, 
+	'\033', '[', '2', '9', '~', 0, 
+	'\033', '[', '3', '1', '~', 0, 
+	'\033', '[', '3', '2', '~', 0, 
+	'\033', '[', '3', '3', '~', 0, 
+	'\033', '[', '3', '4', '~', 0, 
+	'\033', '[', '1', '~', 0, 
+	'\033', '[', '2', '~', 0, 
+	'\033', '[', '3', '~', 0, 
+	'\033', '[', '4', '~', 0, 
+	'\033', '[', '5', '~', 0, 
+	'\033', '[', '6', '~', 0, 
+	'\033', '[', 'M', 0, 
+	'\033', '[', 'P', 0, 
+};
+
+
+char *funcbufptr = func_buf;
+int funcbufsize = sizeof(func_buf);
+int funcbufleft = 0;          /* space left */
+
+char *func_table[MAX_NR_FUNC] = {
+	func_buf + 0,
+	func_buf + 5,
+	func_buf + 10,
+	func_buf + 15,
+	func_buf + 20,
+	func_buf + 25,
+	func_buf + 31,
+	func_buf + 37,
+	func_buf + 43,
+	func_buf + 49,
+	func_buf + 55,
+	func_buf + 61,
+	func_buf + 67,
+	func_buf + 73,
+	func_buf + 79,
+	func_buf + 85,
+	func_buf + 91,
+	func_buf + 97,
+	func_buf + 103,
+	func_buf + 109,
+	func_buf + 115,
+	func_buf + 120,
+	func_buf + 125,
+	func_buf + 130,
+	func_buf + 135,
+	func_buf + 140,
+	func_buf + 145,
+	0,
+	0,
+	func_buf + 149,
+	0,
+};
+
+struct kbdiacr accent_table[MAX_DIACR] = {
+	{'`', 'A', '\300'},	{'`', 'a', '\340'},
+	{'\'', 'A', '\301'},	{'\'', 'a', '\341'},
+	{'^', 'A', '\302'},	{'^', 'a', '\342'},
+	{'~', 'A', '\303'},	{'~', 'a', '\343'},
+	{'"', 'A', '\304'},	{'"', 'a', '\344'},
+	{'O', 'A', '\305'},	{'o', 'a', '\345'},
+	{'0', 'A', '\305'},	{'0', 'a', '\345'},
+	{'A', 'A', '\305'},	{'a', 'a', '\345'},
+	{'A', 'E', '\306'},	{'a', 'e', '\346'},
+	{',', 'C', '\307'},	{',', 'c', '\347'},
+	{'`', 'E', '\310'},	{'`', 'e', '\350'},
+	{'\'', 'E', '\311'},	{'\'', 'e', '\351'},
+	{'^', 'E', '\312'},	{'^', 'e', '\352'},
+	{'"', 'E', '\313'},	{'"', 'e', '\353'},
+	{'`', 'I', '\314'},	{'`', 'i', '\354'},
+	{'\'', 'I', '\315'},	{'\'', 'i', '\355'},
+	{'^', 'I', '\316'},	{'^', 'i', '\356'},
+	{'"', 'I', '\317'},	{'"', 'i', '\357'},
+	{'-', 'D', '\320'},	{'-', 'd', '\360'},
+	{'~', 'N', '\321'},	{'~', 'n', '\361'},
+	{'`', 'O', '\322'},	{'`', 'o', '\362'},
+	{'\'', 'O', '\323'},	{'\'', 'o', '\363'},
+	{'^', 'O', '\324'},	{'^', 'o', '\364'},
+	{'~', 'O', '\325'},	{'~', 'o', '\365'},
+	{'"', 'O', '\326'},	{'"', 'o', '\366'},
+	{'/', 'O', '\330'},	{'/', 'o', '\370'},
+	{'`', 'U', '\331'},	{'`', 'u', '\371'},
+	{'\'', 'U', '\332'},	{'\'', 'u', '\372'},
+	{'^', 'U', '\333'},	{'^', 'u', '\373'},
+	{'"', 'U', '\334'},	{'"', 'u', '\374'},
+	{'\'', 'Y', '\335'},	{'\'', 'y', '\375'},
+	{'T', 'H', '\336'},	{'t', 'h', '\376'},
+	{'s', 's', '\337'},	{'"', 'y', '\377'},
+	{'s', 'z', '\337'},	{'i', 'j', '\377'},
+};
+
+unsigned int accent_table_size = 68;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/tc/lk201.c linux-mips-cvs-20040815/drivers/tc/lk201.c
--- linux-2.4.27/drivers/tc/lk201.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/tc/lk201.c	2004-08-15 08:06:28.000000000 +0200
@@ -5,7 +5,7 @@
  * for more details.
  *
  * Copyright (C) 1999-2002 Harald Koerfgen <hkoerfg@web.de>
- * Copyright (C) 2001, 2002, 2003  Maciej W. Rozycki <macro@ds2.pg.gda.pl>
+ * Copyright (C) 2001, 2002, 2003, 2004  Maciej W. Rozycki
  */
 
 #include <linux/config.h>
@@ -23,8 +23,8 @@
 #include <asm/keyboard.h>
 #include <asm/dec/tc.h>
 #include <asm/dec/machtype.h>
+#include <asm/dec/serial.h>
 
-#include "zs.h"
 #include "lk201.h"
 
 /*
@@ -57,17 +57,17 @@ unsigned char kbd_sysrq_key = -1;
 
 #define KEYB_LINE	3
 
-static int __init lk201_init(struct dec_serial *);
-static void __init lk201_info(struct dec_serial *);
-static void lk201_kbd_rx_char(unsigned char, unsigned char);
+static int __init lk201_init(void *);
+static void __init lk201_info(void *);
+static void lk201_rx_char(unsigned char, unsigned char);
 
-struct zs_hook lk201_kbdhook = {
+static struct dec_serial_hook lk201_hook = {
 	.init_channel	= lk201_init,
 	.init_info	= lk201_info,
 	.rx_char	= NULL,
 	.poll_rx_char	= NULL,
 	.poll_tx_char	= NULL,
-	.cflags		= B4800 | CS8 | CSTOPB | CLOCAL
+	.cflags		= B4800 | CS8 | CSTOPB | CLOCAL,
 };
 
 /*
@@ -93,28 +93,28 @@ static unsigned char lk201_reset_string[
 	LK_CMD_ENB_BELL, LK_PARAM_VOLUME(4),
 };
 
-static struct dec_serial* lk201kbd_info;
+static void *lk201_handle;
 
-static int lk201_send(struct dec_serial *info, unsigned char ch)
+static int lk201_send(unsigned char ch)
 {
-	if (info->hook->poll_tx_char(info, ch)) {
+	if (lk201_hook.poll_tx_char(lk201_handle, ch)) {
 		printk(KERN_ERR "lk201: transmit timeout\n");
 		return -EIO;
 	}
 	return 0;
 }
 
-static inline int lk201_get_id(struct dec_serial *info)
+static inline int lk201_get_id(void)
 {
-	return lk201_send(info, LK_CMD_REQ_ID);
+	return lk201_send(LK_CMD_REQ_ID);
 }
 
-static int lk201_reset(struct dec_serial *info)
+static int lk201_reset(void)
 {
 	int i, r;
 
 	for (i = 0; i < sizeof(lk201_reset_string); i++) {
-		r = lk201_send(info, lk201_reset_string[i]);
+		r = lk201_send(lk201_reset_string[i]);
 		if (r < 0)
 			return r;
 	}
@@ -203,24 +203,26 @@ static void parse_kbd_rate(struct kbd_re
 
 static int write_kbd_rate(struct kbd_repeat *rep)
 {
-	struct dec_serial* info = lk201kbd_info;
 	int delay, rate;
 	int i;
 
 	delay = rep->delay / 5;
 	rate = rep->rate;
 	for (i = 0; i < 4; i++) {
-		if (info->hook->poll_tx_char(info, LK_CMD_RPT_RATE(i)))
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_CMD_RPT_RATE(i)))
 			return 1;
-		if (info->hook->poll_tx_char(info, LK_PARAM_DELAY(delay)))
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_PARAM_DELAY(delay)))
 			return 1;
-		if (info->hook->poll_tx_char(info, LK_PARAM_RATE(rate)))
+		if (lk201_hook.poll_tx_char(lk201_handle,
+					    LK_PARAM_RATE(rate)))
 			return 1;
 	}
 	return 0;
 }
 
-static int lk201kbd_rate(struct kbd_repeat *rep)
+static int lk201_kbd_rate(struct kbd_repeat *rep)
 {
 	if (rep == NULL)
 		return -EINVAL;
@@ -237,10 +239,8 @@ static int lk201kbd_rate(struct kbd_repe
 	return 0;
 }
 
-static void lk201kd_mksound(unsigned int hz, unsigned int ticks)
+static void lk201_kd_mksound(unsigned int hz, unsigned int ticks)
 {
-	struct dec_serial* info = lk201kbd_info;
-
 	if (!ticks)
 		return;
 
@@ -253,20 +253,19 @@ static void lk201kd_mksound(unsigned int
 		ticks = 7;
 	ticks = 7 - ticks;
 
-	if (info->hook->poll_tx_char(info, LK_CMD_ENB_BELL))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_ENB_BELL))
 		return;
-	if (info->hook->poll_tx_char(info, LK_PARAM_VOLUME(ticks)))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_VOLUME(ticks)))
 		return;
-	if (info->hook->poll_tx_char(info, LK_CMD_BELL))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_BELL))
 		return;
 }
 
 void kbd_leds(unsigned char leds)
 {
-	struct dec_serial* info = lk201kbd_info;
 	unsigned char l = 0;
 
-	if (!info)		/* FIXME */
+	if (!lk201_handle)		/* FIXME */
 		return;
 
 	/* FIXME -- Only Hold and Lock LEDs for now. --macro */
@@ -275,13 +274,13 @@ void kbd_leds(unsigned char leds)
 	if (leds & LED_CAP)
 		l |= LK_LED_LOCK;
 
-	if (info->hook->poll_tx_char(info, LK_CMD_LEDS_ON))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_LEDS_ON))
 		return;
-	if (info->hook->poll_tx_char(info, LK_PARAM_LED_MASK(l)))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_LED_MASK(l)))
 		return;
-	if (info->hook->poll_tx_char(info, LK_CMD_LEDS_OFF))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_CMD_LEDS_OFF))
 		return;
-	if (info->hook->poll_tx_char(info, LK_PARAM_LED_MASK(~l)))
+	if (lk201_hook.poll_tx_char(lk201_handle, LK_PARAM_LED_MASK(~l)))
 		return;
 }
 
@@ -307,7 +306,7 @@ char kbd_unexpected_up(unsigned char key
 	return 0x80;
 }
 
-static void lk201_kbd_rx_char(unsigned char ch, unsigned char stat)
+static void lk201_rx_char(unsigned char ch, unsigned char fl)
 {
 	static unsigned char id[6];
 	static int id_i;
@@ -316,9 +315,8 @@ static void lk201_kbd_rx_char(unsigned c
 	static int prev_scancode;
 	unsigned char c = scancodeRemap[ch];
 
-	if (stat && stat != TTY_OVERRUN) {
-		printk(KERN_ERR "lk201: keyboard receive error: 0x%02x\n",
-		       stat);
+	if (fl != TTY_NORMAL && fl != TTY_OVERRUN) {
+		printk(KERN_ERR "lk201: keyboard receive error: 0x%02x\n", fl);
 		return;
 	}
 
@@ -335,7 +333,7 @@ static void lk201_kbd_rx_char(unsigned c
 			/* OK, the power-up concluded. */
 			lk201_report(id);
 			if (id[2] == LK_STAT_PWRUP_OK)
-				lk201_get_id(lk201kbd_info);
+				lk201_get_id();
 			else {
 				id_i = 0;
 				printk(KERN_ERR "lk201: keyboard power-up "
@@ -345,7 +343,7 @@ static void lk201_kbd_rx_char(unsigned c
 			/* We got the ID; report it and start operation. */
 			id_i = 0;
 			lk201_id(id);
-			lk201_reset(lk201kbd_info);
+			lk201_reset();
 		}
 		return;
 	}
@@ -398,30 +396,27 @@ static void lk201_kbd_rx_char(unsigned c
 	tasklet_schedule(&keyboard_tasklet);
 }
 
-static void __init lk201_info(struct dec_serial *info)
+static void __init lk201_info(void *handle)
 {
 }
 
-static int __init lk201_init(struct dec_serial *info)
+static int __init lk201_init(void *handle)
 {
 	/* First install handlers. */
-	lk201kbd_info = info;
-	kbd_rate = lk201kbd_rate;
-	kd_mksound = lk201kd_mksound;
+	lk201_handle = handle;
+	kbd_rate = lk201_kbd_rate;
+	kd_mksound = lk201_kd_mksound;
 
-	info->hook->rx_char = lk201_kbd_rx_char;
+	lk201_hook.rx_char = lk201_rx_char;
 
 	/* Then just issue a reset -- the handlers will do the rest. */
-	lk201_send(info, LK_CMD_POWER_UP);
+	lk201_send(LK_CMD_POWER_UP);
 
 	return 0;
 }
 
 void __init kbd_init_hw(void)
 {
-	extern int register_zs_hook(unsigned int, struct zs_hook *);
-	extern int unregister_zs_hook(unsigned int);
-
 	/* Maxine uses LK501 at the Access.Bus. */
 	if (!LK_IFACE)
 		return;
@@ -434,8 +429,8 @@ void __init kbd_init_hw(void)
 		 * rs_init() so just register the kbd hook
 		 * and let zs_init do the rest :-)
 		 */
-		if(!register_zs_hook(KEYB_LINE, &lk201_kbdhook))
-			unregister_zs_hook(KEYB_LINE);
+		if (!register_dec_serial_hook(KEYB_LINE, &lk201_hook))
+			unregister_dec_serial_hook(KEYB_LINE);
 	} else {
 		/*
 		 * TODO: modify dz.c to allow similar hooks
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/tc/zs.c linux-mips-cvs-20040815/drivers/tc/zs.c
--- linux-2.4.27/drivers/tc/zs.c	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/tc/zs.c	2004-08-15 08:06:28.000000000 +0200
@@ -68,6 +68,8 @@
 #include <asm/bitops.h>
 #include <asm/uaccess.h>
 #include <asm/bootinfo.h>
+#include <asm/dec/serial.h>
+
 #ifdef CONFIG_DECSTATION
 #include <asm/dec/interrupts.h>
 #include <asm/dec/machtype.h>
@@ -160,8 +162,8 @@ struct tty_struct zs_ttys[NUM_CHANNELS];
 #ifdef CONFIG_SERIAL_DEC_CONSOLE
 static struct console sercons;
 #endif
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) \
-    && !defined(MODULE)
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
 static unsigned long break_pressed; /* break, really ... */
 #endif
 
@@ -196,7 +198,6 @@ static int serial_refcount;
 /*
  * Debugging.
  */
-#undef SERIAL_DEBUG_INTR
 #undef SERIAL_DEBUG_OPEN
 #undef SERIAL_DEBUG_FLOW
 #undef SERIAL_DEBUG_THROTTLE
@@ -221,10 +222,6 @@ static struct tty_struct *serial_table[N
 static struct termios *serial_termios[NUM_CHANNELS];
 static struct termios *serial_termios_locked[NUM_CHANNELS];
 
-#ifndef MIN
-#define MIN(a,b)	((a) < (b) ? (a) : (b))
-#endif
-
 /*
  * tmp_buf is used as a temporary buffer by serial_write.  We need to
  * lock it in case the copy_from_user blocks while swapping in a page,
@@ -386,8 +383,6 @@ static inline void rs_recv_clear(struct 
  * -----------------------------------------------------------------------
  */
 
-static int tty_break;	/* Set whenever BREAK condition is detected.  */
-
 /*
  * This routine is used by the interrupt handler to schedule
  * processing in the software interrupt portion of the driver.
@@ -414,20 +409,15 @@ static _INLINE_ void receive_chars(struc
 		if (!tty && (!info->hook || !info->hook->rx_char))
 			continue;
 
-		if (tty_break) {
-			tty_break = 0;
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
-			if (info->line == sercons.index) {
-				if (!break_pressed) {
-					break_pressed = jiffies;
-					goto ignore_char;
-				}
-				break_pressed = 0;
-			}
-#endif
+		flag = TTY_NORMAL;
+		if (info->tty_break) {
+			info->tty_break = 0;
 			flag = TTY_BREAK;
 			if (info->flags & ZILOG_SAK)
 				do_SAK(tty);
+			/* Ignore the null char got when BREAK is removed.  */
+			if (ch == 0)
+				continue;
 		} else {
 			if (stat & Rx_OVR) {
 				flag = TTY_OVERRUN;
@@ -435,20 +425,22 @@ static _INLINE_ void receive_chars(struc
 				flag = TTY_FRAME;
 			} else if (stat & PAR_ERR) {
 				flag = TTY_PARITY;
-			} else
-				flag = 0;
-			if (flag)
+			}
+			if (flag != TTY_NORMAL)
 				/* reset the error indication */
 				write_zsreg(info->zs_channel, R0, ERR_RES);
 		}
 
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
 		if (break_pressed && info->line == sercons.index) {
-			if (ch != 0 &&
-			    time_before(jiffies, break_pressed + HZ*5)) {
+			/* Ignore the null char got when BREAK is removed.  */
+			if (ch == 0)
+				continue;
+			if (time_before(jiffies, break_pressed + HZ * 5)) {
 				handle_sysrq(ch, regs, NULL, NULL);
 				break_pressed = 0;
-				goto ignore_char;
+				continue;
 			}
 			break_pressed = 0;
 		}
@@ -459,23 +451,7 @@ static _INLINE_ void receive_chars(struc
 			return;
   		}
 
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
-			static int flip_buf_ovf;
-			++flip_buf_ovf;
-			continue;
-		}
-		tty->flip.count++;
-		{
-			static int flip_max_cnt;
-			if (flip_max_cnt < tty->flip.count)
-				flip_max_cnt = tty->flip.count;
-		}
-
-		*tty->flip.flag_buf_ptr++ = flag;
-		*tty->flip.char_buf_ptr++ = ch;
-#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && !defined(MODULE)
-	ignore_char:
-#endif
+		tty_insert_flip_char(tty, ch, flag);
 	}
 	if (tty)
 		tty_flip_buffer_push(tty);
@@ -517,11 +493,15 @@ static _INLINE_ void status_handle(struc
 	/* Get status from Read Register 0 */
 	stat = read_zsreg(info->zs_channel, R0);
 
-	if (stat & BRK_ABRT) {
-#ifdef SERIAL_DEBUG_INTR
-		printk("handling break....");
+	if ((stat & BRK_ABRT) && !(info->read_reg_zero & BRK_ABRT)) {
+#if defined(CONFIG_SERIAL_DEC_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ) && \
+   !defined(MODULE)
+		if (info->line == sercons.index) {
+			if (!break_pressed)
+				break_pressed = jiffies;
+		} else
 #endif
-		tty_break = 1;
+			info->tty_break = 1;
 	}
 
 	if (info->zs_channel != info->zs_chan_a) {
@@ -960,7 +940,7 @@ static int rs_write(struct tty_struct * 
 	save_flags(flags);
 	while (1) {
 		cli();
-		c = MIN(count, MIN(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+		c = min(count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
 				   SERIAL_XMIT_SIZE - info->xmit_head));
 		if (c <= 0)
 			break;
@@ -968,7 +948,7 @@ static int rs_write(struct tty_struct * 
 		if (from_user) {
 			down(&tmp_buf_sem);
 			copy_from_user(tmp_buf, buf, c);
-			c = MIN(c, MIN(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+			c = min(c, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
 				       SERIAL_XMIT_SIZE - info->xmit_head));
 			memcpy(info->xmit_buf + info->xmit_head, tmp_buf, c);
 			up(&tmp_buf_sem);
@@ -1288,46 +1268,48 @@ static int rs_ioctl(struct tty_struct *t
 	}
 
 	switch (cmd) {
-		case TIOCMGET:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-				sizeof(unsigned int));
-			if (error)
-				return error;
-			return get_modem_info(info, (unsigned int *) arg);
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			return set_modem_info(info, cmd, (unsigned int *) arg);
-		case TIOCGSERIAL:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-						sizeof(struct serial_struct));
-			if (error)
-				return error;
-			return get_serial_info(info,
-					       (struct serial_struct *) arg);
-		case TIOCSSERIAL:
-			return set_serial_info(info,
-					       (struct serial_struct *) arg);
-		case TIOCSERGETLSR: /* Get line status register */
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-				sizeof(unsigned int));
-			if (error)
-				return error;
-			else
-			    return get_lsr_info(info, (unsigned int *) arg);
+	case TIOCMGET:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(unsigned int));
+		if (error)
+			return error;
+		return get_modem_info(info, (unsigned int *)arg);
 
-		case TIOCSERGSTRUCT:
-			error = verify_area(VERIFY_WRITE, (void *) arg,
-						sizeof(struct dec_serial));
-			if (error)
-				return error;
-			copy_from_user((struct dec_serial *) arg,
-				       info, sizeof(struct dec_serial));
-			return 0;
+	case TIOCMBIS:
+	case TIOCMBIC:
+	case TIOCMSET:
+		return set_modem_info(info, cmd, (unsigned int *)arg);
 
-		default:
-			return -ENOIOCTLCMD;
-		}
+	case TIOCGSERIAL:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(struct serial_struct));
+		if (error)
+			return error;
+		return get_serial_info(info, (struct serial_struct *)arg);
+
+	case TIOCSSERIAL:
+		return set_serial_info(info, (struct serial_struct *)arg);
+
+	case TIOCSERGETLSR:			/* Get line status register */
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(unsigned int));
+		if (error)
+			return error;
+		else
+			return get_lsr_info(info, (unsigned int *)arg);
+
+	case TIOCSERGSTRUCT:
+		error = verify_area(VERIFY_WRITE, (void *)arg,
+				    sizeof(struct dec_serial));
+		if (error)
+			return error;
+		copy_from_user((struct dec_serial *)arg, info,
+			       sizeof(struct dec_serial));
+		return 0;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
 	return 0;
 }
 
@@ -1453,7 +1435,8 @@ static void rs_close(struct tty_struct *
 static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
 {
 	struct dec_serial *info = (struct dec_serial *) tty->driver_data;
-	unsigned long orig_jiffies, char_time;
+	unsigned long orig_jiffies;
+	int char_time;
 
 	if (serial_paranoia_check(info, tty->device, "rs_wait_until_sent"))
 		return;
@@ -1469,7 +1452,7 @@ static void rs_wait_until_sent(struct tt
 	if (char_time == 0)
 		char_time = 1;
 	if (timeout)
-		char_time = MIN(char_time, timeout);
+		char_time = min(char_time, timeout);
 	while ((read_zsreg(info->zs_channel, 1) & Tx_BUF_EMP) == 0) {
 		current->state = TASK_INTERRUPTIBLE;
 		schedule_timeout(char_time);
@@ -1721,7 +1704,7 @@ int rs_open(struct tty_struct *tty, stru
 
 static void __init show_serial_version(void)
 {
-	printk("DECstation Z8530 serial driver version 0.08\n");
+	printk("DECstation Z8530 serial driver version 0.09\n");
 }
 
 /*  Initialize Z8530s zs_channels
@@ -2001,8 +1984,9 @@ int __init zs_init(void)
  * polling I/O routines
  */
 static int
-zs_poll_tx_char(struct dec_serial *info, unsigned char ch)
+zs_poll_tx_char(void *handle, unsigned char ch)
 {
+	struct dec_serial *info = handle;
 	struct dec_zschannel *chan = info->zs_channel;
 	int    ret;
 
@@ -2024,8 +2008,9 @@ zs_poll_tx_char(struct dec_serial *info,
 }
 
 static int
-zs_poll_rx_char(struct dec_serial *info)
+zs_poll_rx_char(void *handle)
 {
+	struct dec_serial *info = handle;
         struct dec_zschannel *chan = info->zs_channel;
         int    ret;
 
@@ -2045,12 +2030,13 @@ zs_poll_rx_char(struct dec_serial *info)
 		return -ENODEV;
 }
 
-unsigned int register_zs_hook(unsigned int channel, struct zs_hook *hook)
+int register_zs_hook(unsigned int channel, struct dec_serial_hook *hook)
 {
 	struct dec_serial *info = &zs_soft[channel];
 
 	if (info->hook) {
-		printk(__FUNCTION__": line %d has already a hook registered\n", channel);
+		printk("%s: line %d has already a hook registered\n",
+		       __FUNCTION__, channel);
 
 		return 0;
 	} else {
@@ -2062,7 +2048,7 @@ unsigned int register_zs_hook(unsigned i
 	}
 }
 
-unsigned int unregister_zs_hook(unsigned int channel)
+int unregister_zs_hook(unsigned int channel)
 {
 	struct dec_serial *info = &zs_soft[channel];
 
@@ -2070,8 +2056,8 @@ unsigned int unregister_zs_hook(unsigned
                 info->hook = NULL;
                 return 1;
         } else {
-                printk(__FUNCTION__": trying to unregister hook on line %d,"
-                       " but none is registered\n", channel);
+                printk("%s: trying to unregister hook on line %d,"
+                       " but none is registered\n", __FUNCTION__, channel);
                 return 0;
         }
 }
@@ -2326,22 +2312,23 @@ void kgdb_interruptible(int yes)
 	write_zsreg(chan, 9, nine);
 }
 
-static int kgdbhook_init_channel(struct dec_serial* info)
+static int kgdbhook_init_channel(void *handle)
 {
 	return 0;
 }
 
-static void kgdbhook_init_info(struct dec_serial* info)
+static void kgdbhook_init_info(void *handle)
 {
 }
 
-static void kgdbhook_rx_char(struct dec_serial* info,
-			     unsigned char ch, unsigned char stat)
+static void kgdbhook_rx_char(void *handle, unsigned char ch, unsigned char fl)
 {
+	struct dec_serial *info = handle;
+
+	if (fl != TTY_NORMAL)
+		return;
 	if (ch == 0x03 || ch == '$')
 		breakpoint();
-	if (stat & (Rx_OVR|FRM_ERR|PAR_ERR))
-		write_zsreg(info->zs_channel, 0, ERR_RES);
 }
 
 /* This sets up the serial port we're using, and turns on
@@ -2367,11 +2354,11 @@ static inline void kgdb_chaninit(struct 
  * for /dev/ttyb which is determined in setup_arch() from the
  * boot command line flags.
  */
-struct zs_hook zs_kgdbhook = {
-	init_channel : kgdbhook_init_channel,
-	init_info    : kgdbhook_init_info,
-	cflags       : B38400|CS8|CLOCAL,
-	rx_char      : kgdbhook_rx_char,
+struct dec_serial_hook zs_kgdbhook = {
+	.init_channel	= kgdbhook_init_channel,
+	.init_info	= kgdbhook_init_info,
+	.rx_char	= kgdbhook_rx_char,
+	.cflags		= B38400 | CS8 | CLOCAL,
 }
 
 void __init zs_kgdb_hook(int tty_num)
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/tc/zs.h linux-mips-cvs-20040815/drivers/tc/zs.h
--- linux-2.4.27/drivers/tc/zs.h	2004-02-18 14:36:31.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/tc/zs.h	2004-08-15 08:06:28.000000000 +0200
@@ -1,14 +1,18 @@
 /*
- * macserial.h: Definitions for the Macintosh Z8530 serial driver.
+ * drivers/tc/zs.h: Definitions for the DECstation Z85C30 serial driver.
  *
  * Adapted from drivers/sbus/char/sunserial.h by Paul Mackerras.
+ * Adapted from drivers/macintosh/macserial.h by Harald Koerfgen.
  *
  * Copyright (C) 1996 Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
  * Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)
+ * Copyright (C) 2004  Maciej W. Rozycki
  */
 #ifndef _DECSERIAL_H
 #define _DECSERIAL_H
 
+#include <asm/dec/serial.h>
+
 #define NUM_ZSREGS    16
 
 struct serial_struct {
@@ -89,63 +93,50 @@ struct dec_zschannel {
 	unsigned char curregs[NUM_ZSREGS];
 };
 
-struct dec_serial;
-
-struct zs_hook {
-	int (*init_channel)(struct dec_serial* info);
-	void (*init_info)(struct dec_serial* info);
-	void (*rx_char)(unsigned char ch, unsigned char stat);
-	int  (*poll_rx_char)(struct dec_serial* info);
-	int  (*poll_tx_char)(struct dec_serial* info,
-			     unsigned char ch);
-	unsigned cflags;
-};
-
 struct dec_serial {
-	struct dec_serial *zs_next;	/* For IRQ servicing chain */
-	struct dec_zschannel *zs_channel; /* Channel registers */
-	struct dec_zschannel *zs_chan_a;	/* A side registers */
-	unsigned char read_reg_zero;
-
-	char soft_carrier;  /* Use soft carrier on this channel */
-	char break_abort;   /* Is serial console in, so process brk/abrt */
-	struct zs_hook *hook;  /* Hook on this channel */
-	char is_cons;       /* Is this our console. */
-	unsigned char tx_active; /* character is being xmitted */
-	unsigned char tx_stopped; /* output is suspended */
-
-	/* We need to know the current clock divisor
-	 * to read the bps rate the chip has currently
-	 * loaded.
+	struct dec_serial	*zs_next;	/* For IRQ servicing chain.  */
+	struct dec_zschannel	*zs_channel;	/* Channel registers.  */
+	struct dec_zschannel	*zs_chan_a;	/* A side registers.  */
+	unsigned char		read_reg_zero;
+
+	struct dec_serial_hook	*hook;		/* Hook on this channel.  */
+	int			tty_break;	/* Set on BREAK condition.  */
+	int			is_cons;	/* Is this our console.  */
+	int			tx_active;	/* Char is being xmitted.  */
+	int			tx_stopped;	/* Output is suspended.  */
+
+	/*
+	 * We need to know the current clock divisor
+	 * to read the bps rate the chip has currently loaded.
 	 */
-	unsigned char clk_divisor;  /* May be 1, 16, 32, or 64 */
-	int zs_baud;
+	int			clk_divisor;	/* May be 1, 16, 32, or 64.  */
+	int			zs_baud;
 
-	char change_needed;
+	char			change_needed;
 
 	int			magic;
 	int			baud_base;
 	int			port;
 	int			irq;
-	int			flags; 		/* defined in tty.h */
-	int			type; 		/* UART type */
+	int			flags; 		/* Defined in tty.h.  */
+	int			type; 		/* UART type.  */
 	struct tty_struct 	*tty;
 	int			read_status_mask;
 	int			ignore_status_mask;
 	int			timeout;
 	int			xmit_fifo_size;
 	int			custom_divisor;
-	int			x_char;	/* xon/xoff character */
+	int			x_char;		/* XON/XOFF character.  */
 	int			close_delay;
 	unsigned short		closing_wait;
 	unsigned short		closing_wait2;
 	unsigned long		event;
 	unsigned long		last_active;
 	int			line;
-	int			count;	    /* # of fd on device */
-	int			blocked_open; /* # of blocked opens */
-	long			session; /* Session of opening process */
-	long			pgrp; /* pgrp of opening process */
+	int			count;		/* # of fds on device.  */
+	int			blocked_open;	/* # of blocked opens.  */
+	long			session;	/* Sess of opening process.  */
+	long			pgrp;		/* Pgrp of opening process.  */
 	unsigned char 		*xmit_buf;
 	int			xmit_head;
 	int			xmit_tail;
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/video/ims332.h linux-mips-cvs-20040815/drivers/video/ims332.h
--- linux-2.4.27/drivers/video/ims332.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/drivers/video/ims332.h	2003-12-22 17:02:20.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ *	linux/drivers/video/ims332.h
+ *
+ *	Copyright 2003  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+ *
+ *	This file is subject to the terms and conditions of the GNU General
+ *	Public License. See the file COPYING in the main directory of this
+ *	archive for more details.
+ */
+#include <linux/types.h>
+
+/*
+ * IMS332 16-bit wide, 128-bit aligned registers.
+ */
+struct _ims332_reg {
+	volatile u16 r;
+	u16 pad[7];
+};
+
+struct _ims332_regs {
+#define IMS332_BOOT_PLL_MUTLIPLIER	0x00001f
+#define IMS332_BOOT_CLOCK_SOURCE_SEL	0x000020
+#define IMS332_BOOT_ADDRESS_ALIGNMENT	0x000040
+#define IMS332_BOOT_WRITE_ZERO		0xffff80
+	struct _ims332_reg boot;
+	struct _ims332_reg pad0[0x020 - 0x000];
+	struct _ims332_reg half_sync;
+	struct _ims332_reg back_porch;
+	struct _ims332_reg display;
+	struct _ims332_reg short_display;
+	struct _ims332_reg broad_pulse;
+	struct _ims332_reg vsync;
+	struct _ims332_reg vpre_equalise;
+	struct _ims332_reg vpost_equalise;
+	struct _ims332_reg vblank;
+	struct _ims332_reg vdisplay;
+	struct _ims332_reg line_time;
+	struct _ims332_reg line_start;
+	struct _ims332_reg mem_init;
+	struct _ims332_reg transfer_delay;
+	struct _ims332_reg pad1[0x03f - 0x02e];
+	struct _ims332_reg pixel_address_mask;
+	struct _ims332_reg pad2[0x05f - 0x040];
+
+#define IMS332_CTRL_A_BOOT_ENABLE_VTG		0x000001
+#define IMS332_CTRL_A_SCREEN_FORMAT		0x000002
+#define IMS332_CTRL_A_INTERLACED_STANDARD	0x000004
+#define IMS332_CTRL_A_OPERATING_MODE		0x000008
+#define IMS332_CTRL_A_FRAME_FLYBACK_PATTERN	0x000010
+#define IMS332_CTRL_A_DIGITAL_SYNC_FORMAT	0x000020
+#define IMS332_CTRL_A_ANALOGUE_VIDEO_FORMAT	0x000040
+#define IMS332_CTRL_A_BLANK_LEVEL		0x000080
+#define IMS332_CTRL_A_BLANK_IO			0x000100
+#define IMS332_CTRL_A_BLANK_FUNCTION_SWITCH	0x000200
+#define IMS332_CTRL_A_FORCE_BLANKING		0x000400
+#define IMS332_CTRL_A_TURN_OFF_BLANKING		0x000800
+#define IMS332_CTRL_A_VRAM_ADDRESS_INCREMENT	0x003000
+#define IMS332_CTRL_A_TURN_OFF_DMA		0x004000
+#define IMS332_CTRL_A_SYNC_DELAY		0x038000
+#define IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING	0x040000
+#define IMS332_CTRL_A_DELAYED_SAMPLING		0x080000
+#define IMS332_CTRL_A_BITS_PER_PIXEL		0x700000
+#define IMS332_CTRL_A_CURSOR_DISABLE		0x800000
+	struct _ims332_reg config_control_a;
+	struct _ims332_reg pad3[0x06f - 0x060];
+
+#define IMS332_CTRL_B_WRITE_ZERO	0xffffff
+	struct _ims332_reg config_control_b;
+	struct _ims332_reg pad4[0x07f - 0x070];
+	struct _ims332_reg screen_top;
+	struct _ims332_reg pad5[0x0a0 - 0x080];
+	/* cursor color palette, 3 entries, reg no. 0xa1 - 0xa3 */
+	struct _ims332_reg cursor_color_palette0;
+	struct _ims332_reg cursor_color_palette1;
+	struct _ims332_reg cursor_color_palette2;
+	struct _ims332_reg pad6[0x0bf - 0x0a3];
+	struct _ims332_reg rgb_frame_checksum0;
+	struct _ims332_reg rgb_frame_checksum1;
+	struct _ims332_reg rgb_frame_checksum2;
+	struct _ims332_reg pad7[0x0c6 - 0x0c2];
+	struct _ims332_reg cursor_start;
+	struct _ims332_reg pad8[0x0ff - 0x0c7];
+	/* color palette, 256 entries of form 0x00BBGGRR, reg no. 0x100 - 0x1ff */
+	struct _ims332_reg color_palette[0x1ff - 0x0ff];
+	/* hardware cursor bitmap, reg no. 0x200 - 0x3ff */
+	struct _ims332_reg cursor_ram[0x3ff - 0x1ff];
+};
+
+/*
+ * In the functions below we use some weird looking helper variables to
+ * access most members of this struct, otherwise the compiler splits
+ * the read/write in two byte accesses.
+ */
+struct ims332_regs {
+	struct _ims332_regs rw;
+	char pad0[0x80000 - sizeof (struct _ims332_regs)];
+	struct _ims332_regs r;
+	char pad1[0xa0000 - (sizeof (struct _ims332_regs) + 0x80000)];
+	struct _ims332_regs w;
+} __attribute__((packed));
+
+static inline void ims332_control_reg_bits(struct ims332_regs *regs, u32 mask,
+					   u32 val)
+{
+	volatile u16 *ctr = &(regs->r.config_control_a.r);
+	volatile u16 *ctw = &(regs->w.config_control_a.r);
+	u32 ctrl;
+
+	mb();
+	ctrl = *ctr;
+	rmb();
+	ctrl |= ((regs->rw.boot.r << 8) & 0x00ff0000);
+	ctrl |= val & mask;
+	ctrl &= ~(~val & mask);
+	wmb();
+	regs->rw.boot.r = (ctrl >> 8) & 0xff00;
+	wmb();
+	*ctw = ctrl & 0xffff;
+}
+
+/* FIXME: This is maxinefb specific. */
+static inline void ims332_bootstrap(struct ims332_regs *regs)
+{
+	volatile u16 *ctw = &(regs->w.config_control_a.r);
+	u32 ctrl = IMS332_CTRL_A_BOOT_ENABLE_VTG | IMS332_CTRL_A_TURN_OFF_DMA;
+
+	/* bootstrap sequence */
+	mb();
+	regs->rw.boot.r = 0;
+	wmb();
+	*ctw = 0;
+
+	/* init control A register */
+	wmb();
+	regs->rw.boot.r = (ctrl >> 8) & 0xff00;
+	wmb();
+	*ctw = ctrl & 0xffff;
+}
+
+static inline void ims332_blank_screen(struct ims332_regs *regs, int blank)
+{
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_FORCE_BLANKING,
+				blank ? IMS332_CTRL_A_FORCE_BLANKING : 0);
+}
+
+static inline void ims332_set_color_depth(struct ims332_regs *regs, u32 depth)
+{
+	u32 dp;
+	u32 mask = (IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING
+		    | IMS332_CTRL_A_DELAYED_SAMPLING
+		    | IMS332_CTRL_A_BITS_PER_PIXEL);
+
+	switch (depth) {
+	case 1: dp = 0 << 20; break;
+	case 2: dp = 1 << 20; break;
+	case 4: dp = 2 << 20; break;
+	case 8: dp = 3 << 20; break;
+	case 15: dp = (4 << 20) | IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING; break;
+	case 16: dp = (5 << 20) | IMS332_CTRL_A_PIXEL_PORT_INTERLEAVING; break;
+	default: return;
+	}
+	ims332_control_reg_bits(regs, mask, dp);
+
+	if (depth <= 8) {
+		volatile u16 *pmask = &(regs->w.pixel_address_mask.r);
+		u32 dm = (1 << depth) - 1;
+
+		wmb();
+		regs->rw.boot.r = dm << 8;
+		wmb();
+		*pmask = dm << 8 | dm;
+	}
+}
+
+static inline void ims332_set_screen_top(struct ims332_regs *regs, u16 top)
+{
+	volatile u16 *st = &(regs->w.screen_top.r);
+
+	mb();
+	*st = top & 0xffff;
+}
+
+static inline void ims332_enable_cursor(struct ims332_regs *regs, int on)
+{
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_CURSOR_DISABLE,
+				on ? 0 : IMS332_CTRL_A_CURSOR_DISABLE);
+}
+
+static inline void ims332_position_cursor(struct ims332_regs *regs,
+					  u16 x, u16 y)
+{
+	volatile u16 *cp = &(regs->w.cursor_start.r);
+	u32 val = ((x & 0xfff) << 12) | (y & 0xfff);
+
+	if (x > 2303 || y > 2303)
+		return;
+
+	mb();
+	regs->rw.boot.r = (val >> 8) & 0xff00;
+	wmb();
+	*cp = val & 0xffff;
+}
+
+static inline void ims332_set_font(struct ims332_regs *regs, u8 fgc,
+				   u16 width, u16 height)
+{
+	volatile u16 *cp0 = &(regs->w.cursor_color_palette0.r);
+	int i;
+
+	mb();
+	for (i = 0; i < 0x200; i++) {
+		volatile u16 *cram = &(regs->w.cursor_ram[i].r);
+
+		if (height << 6 <= i << 3)
+			*cram = 0x0000;
+		else if (width <= i % 8 << 3)
+			*cram = 0x0000;
+		else if (((width >> 3) & 0xffff) > i % 8)
+			*cram = 0x5555;
+		else
+			*cram = 0x5555 & ~(0xffff << (width % 8 << 1));
+		wmb();
+	}
+	regs->rw.boot.r = fgc << 8;
+	wmb();
+	*cp0 = fgc << 8 | fgc;
+}
+
+static inline void ims332_read_cmap(struct ims332_regs *regs, u8 reg,
+				    u8* red, u8* green, u8* blue)
+{
+	volatile u16 *rptr = &(regs->r.color_palette[reg].r);
+	u16 val;
+
+	mb();
+	val = *rptr;
+	*red = val & 0xff;
+	*green = (val >> 8) & 0xff;
+	rmb();
+	*blue = (regs->rw.boot.r >> 8) & 0xff;
+}
+
+static inline void ims332_write_cmap(struct ims332_regs *regs, u8 reg,
+				     u8 red, u8 green, u8 blue)
+{
+	volatile u16 *wptr = &(regs->w.color_palette[reg].r);
+
+	mb();
+	regs->rw.boot.r = blue << 8;
+	wmb();
+	*wptr = (green << 8) + red;
+}
+
+static inline void ims332_dump_regs(struct ims332_regs *regs)
+{
+	int i;
+
+	printk(__FUNCTION__);
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_BOOT_ENABLE_VTG, 0);
+	for (i = 0; i < 0x100; i++) {
+		volatile u16 *cpad = (u16 *)((char *)(&regs->r) + sizeof(struct _ims332_reg) * i);
+		u32 val;
+
+		val = *cpad;
+		rmb();
+		val |= regs->rw.boot.r << 8;
+		rmb();
+		if (! (i % 8))
+			printk("\n%02x:", i);
+		printk(" %06x", val);
+	}
+	ims332_control_reg_bits(regs, IMS332_CTRL_A_BOOT_ENABLE_VTG,
+				IMS332_CTRL_A_BOOT_ENABLE_VTG);
+	printk("\n");
+}
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/drivers/video/maxinefb.h linux-mips-cvs-20040815/drivers/video/maxinefb.h
--- linux-2.4.27/drivers/video/maxinefb.h	2003-08-25 13:44:42.000000000 +0200
+++ linux-mips-cvs-20040815/drivers/video/maxinefb.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/*
- *      linux/drivers/video/maxinefb.h
- *
- *      DECstation 5000/xx onboard framebuffer support, Copyright (C) 1999 by
- *      Michael Engel <engel@unix-ag.org> and Karsten Merker <merker@guug.de>
- *      This file is subject to the terms and conditions of the GNU General
- *      Public License.  See the file COPYING in the main directory of this
- *      archive for more details.
- */
-
-#include <asm/addrspace.h>
-
-/*
- * IMS332 video controller register base address
- */
-#define MAXINEFB_IMS332_ADDRESS		KSEG1ADDR(0x1c140000)
-
-/*
- * Begin of DECstation 5000/xx onboard framebuffer memory, default resolution
- * is 1024x768x8
- */
-#define DS5000_xx_ONBOARD_FBMEM_START	KSEG1ADDR(0x0a000000)
-
-/*
- *      The IMS 332 video controller used in the DECstation 5000/xx series
- *      uses 32 bits wide registers; the following defines declare the
- *      register numbers, to get the real offset, these have to be multiplied
- *      by four.
- */
-
-#define IMS332_REG_CURSOR_RAM           0x200	/* hardware cursor bitmap */
-
-/*
- * The color palette entries have the form 0x00BBGGRR
- */
-#define IMS332_REG_COLOR_PALETTE        0x100	/* color palette, 256 entries */
-#define IMS332_REG_CURSOR_COLOR_PALETTE	0x0a1	/* cursor color palette, */
-						/* 3 entries             */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/fs/binfmt_elf.c linux-mips-cvs-20040815/fs/binfmt_elf.c
--- linux-2.4.27/fs/binfmt_elf.c	2004-04-14 15:05:40.000000000 +0200
+++ linux-mips-cvs-20040815/fs/binfmt_elf.c	2004-05-05 14:38:53.000000000 +0200
@@ -604,6 +604,9 @@ static int load_elf_binary(struct linux_
 		    bprm->argc++;
 		  }
 		}
+	} else {
+		/* Executables without an interpreter also need a personality  */
+		SET_PERSONALITY(elf_ex, ibcs2_interpreter);
 	}
 
 	/* Flush all traces of the currently running executable */
@@ -1123,7 +1126,11 @@ static int elf_core_dump(long signr, str
 	elf.e_entry = 0;
 	elf.e_phoff = sizeof(elf);
 	elf.e_shoff = 0;
+#ifdef ELF_CORE_EFLAGS
+	elf.e_flags = ELF_CORE_EFLAGS;
+#else
 	elf.e_flags = 0;
+#endif
 	elf.e_ehsize = sizeof(elf);
 	elf.e_phentsize = sizeof(struct elf_phdr);
 	elf.e_phnum = segs+1;		/* Include notes */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/fs/partitions/sgi.c linux-mips-cvs-20040815/fs/partitions/sgi.c
--- linux-2.4.27/fs/partitions/sgi.c	2001-10-02 05:03:26.000000000 +0200
+++ linux-mips-cvs-20040815/fs/partitions/sgi.c	2004-08-15 08:06:39.000000000 +0200
@@ -17,6 +17,11 @@
 #include "check.h"
 #include "sgi.h"
 
+#if CONFIG_BLK_DEV_MD
+extern void md_autodetect_dev(kdev_t dev);
+#endif
+
+
 int sgi_partition(struct gendisk *hd, struct block_device *bdev, unsigned long first_sector, int current_minor)
 {
 	int i, csum, magic;
@@ -77,6 +82,10 @@ int sgi_partition(struct gendisk *hd, st
 		if(!blocks)
 			continue;
 		add_gd_partition(hd, current_minor, start, blocks);
+#ifdef CONFIG_BLK_DEV_MD
+		if (be32_to_cpu(p->type) == LINUX_RAID_PARTITION)
+			md_autodetect_dev(MKDEV(hd->major, current_minor));
+#endif
 		current_minor++;
 	}
 	printk("\n");
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/fs/proc/array.c linux-mips-cvs-20040815/fs/proc/array.c
--- linux-2.4.27/fs/proc/array.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-mips-cvs-20040815/fs/proc/array.c	2003-11-17 02:07:44.000000000 +0100
@@ -362,15 +362,15 @@ int proc_pid_stat(struct task_struct *ta
 		task->cmin_flt,
 		task->maj_flt,
 		task->cmaj_flt,
-		task->times.tms_utime,
-		task->times.tms_stime,
-		task->times.tms_cutime,
-		task->times.tms_cstime,
+		hz_to_std(task->times.tms_utime),
+		hz_to_std(task->times.tms_stime),
+		hz_to_std(task->times.tms_cutime),
+		hz_to_std(task->times.tms_cstime),
 		priority,
 		nice,
 		0UL /* removed */,
 		task->it_real_value,
-		task->start_time,
+		hz_to_std(task->start_time),
 		vsize,
 		mm ? mm->rss : 0, /* you might want to shift this left 3 */
 		task->rlim[RLIMIT_RSS].rlim_cur,
@@ -609,14 +609,14 @@ int proc_pid_cpu(struct task_struct *tas
 
 	len = sprintf(buffer,
 		"cpu  %lu %lu\n",
-		task->times.tms_utime,
-		task->times.tms_stime);
+		hz_to_std(task->times.tms_utime),
+		hz_to_std(task->times.tms_stime));
 		
 	for (i = 0 ; i < smp_num_cpus; i++)
 		len += sprintf(buffer + len, "cpu%d %lu %lu\n",
 			i,
-			task->per_cpu_utime[cpu_logical_map(i)],
-			task->per_cpu_stime[cpu_logical_map(i)]);
+			hz_to_std(task->per_cpu_utime[cpu_logical_map(i)]),
+			hz_to_std(task->per_cpu_stime[cpu_logical_map(i)]));
 
 	return len;
 }
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/fs/proc/proc_misc.c linux-mips-cvs-20040815/fs/proc/proc_misc.c
--- linux-2.4.27/fs/proc/proc_misc.c	2004-08-08 01:26:06.000000000 +0200
+++ linux-mips-cvs-20040815/fs/proc/proc_misc.c	2004-08-15 08:06:39.000000000 +0200
@@ -308,16 +308,16 @@ static int kstat_read_proc(char *page, c
 {
 	int i, len = 0;
 	extern unsigned long total_forks;
-	unsigned long jif = jiffies;
+	unsigned long jif = hz_to_std(jiffies);
 	unsigned int sum = 0, user = 0, nice = 0, system = 0;
 	int major, disk;
 
 	for (i = 0 ; i < smp_num_cpus; i++) {
 		int cpu = cpu_logical_map(i), j;
 
-		user += kstat.per_cpu_user[cpu];
-		nice += kstat.per_cpu_nice[cpu];
-		system += kstat.per_cpu_system[cpu];
+		user += hz_to_std(kstat.per_cpu_user[cpu]);
+		nice += hz_to_std(kstat.per_cpu_nice[cpu]);
+		system += hz_to_std(kstat.per_cpu_system[cpu]);
 #if !defined(CONFIG_ARCH_S390)
 		for (j = 0 ; j < NR_IRQS ; j++)
 			sum += kstat.irqs[cpu][j];
@@ -331,10 +331,10 @@ static int kstat_read_proc(char *page, c
 		proc_sprintf(page, &off, &len,
 			"cpu%d %u %u %u %lu\n",
 			i,
-			kstat.per_cpu_user[cpu_logical_map(i)],
-			kstat.per_cpu_nice[cpu_logical_map(i)],
-			kstat.per_cpu_system[cpu_logical_map(i)],
-			jif - (  kstat.per_cpu_user[cpu_logical_map(i)] \
+			hz_to_std(kstat.per_cpu_user[cpu_logical_map(i)]),
+			hz_to_std(kstat.per_cpu_nice[cpu_logical_map(i)]),
+			hz_to_std(kstat.per_cpu_system[cpu_logical_map(i)]),
+			jif - hz_to_std(  kstat.per_cpu_user[cpu_logical_map(i)] \
 				   + kstat.per_cpu_nice[cpu_logical_map(i)] \
 				   + kstat.per_cpu_system[cpu_logical_map(i)]));
 	proc_sprintf(page, &off, &len,
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-alpha/param.h linux-mips-cvs-20040815/include/asm-alpha/param.h
--- linux-2.4.27/include/asm-alpha/param.h	2000-11-08 08:37:31.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-alpha/param.h	2000-11-28 04:59:03.000000000 +0100
@@ -13,6 +13,9 @@
 # else
 #  define HZ	1200
 # endif
+#ifdef __KERNEL__
+# define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-i386/param.h linux-mips-cvs-20040815/include/asm-i386/param.h
--- linux-2.4.27/include/asm-i386/param.h	2000-10-27 20:04:43.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-i386/param.h	2000-11-23 03:00:55.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-ia64/param.h linux-mips-cvs-20040815/include/asm-ia64/param.h
--- linux-2.4.27/include/asm-ia64/param.h	2004-04-14 15:05:40.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-ia64/param.h	2004-05-05 14:39:08.000000000 +0200
@@ -7,9 +7,15 @@
  * Based on <asm-i386/param.h>.
  *
  * Modified 1998, 1999, 2002-2003
- *	David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
+ *    David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co
  */
 
+#include <linux/config.h>
+
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
+
 #define EXEC_PAGESIZE	65536
 
 #ifndef NGROUPS
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-m68k/param.h linux-mips-cvs-20040815/include/asm-m68k/param.h
--- linux-2.4.27/include/asm-m68k/param.h	2001-01-04 22:00:55.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-m68k/param.h	2001-01-11 05:02:45.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/au1000.h linux-mips-cvs-20040815/include/asm-mips/au1000.h
--- linux-2.4.27/include/asm-mips/au1000.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/au1000.h	2004-08-15 08:06:47.000000000 +0200
@@ -161,6 +161,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #endif
 
 /* SDRAM Controller */
+#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
 #define MEM_SDMODE0                0xB4000000
 #define MEM_SDMODE1                0xB4000004
 #define MEM_SDMODE2                0xB4000008
@@ -179,6 +180,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 
 #define MEM_SDSLEEP                0xB4000030
 #define MEM_SDSMCKE                0xB4000034
+#endif
 
 /* Static Bus Controller */
 #define MEM_STCFG0                 0xB4001000
@@ -197,6 +199,15 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define MEM_STTIME3                0xB4001034
 #define MEM_STADDR3                0xB4001038
 
+#if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
+#define MEM_STNDCTL                0xB4001100
+#define MEM_STSTAT                 0xB4001104
+
+#define MEM_STNAND_CMD                  (0x0)
+#define MEM_STNAND_ADDR                 (0x4)
+#define MEM_STNAND_DATA                (0x20)
+#endif
+
 /* Interrupt Controller 0 */
 #define IC0_CFG0RD                 0xB0400040
 #define IC0_CFG0SET                0xB0400040
@@ -283,21 +294,14 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define INTC_INT_HIGH_AND_LOW_LEVEL    0x7
 
 /* Interrupt Numbers */
+/* Au1000 */
+#ifdef CONFIG_SOC_AU1000
 #define AU1000_UART0_INT          0
 #define AU1000_UART1_INT          1 /* au1000 */
 #define AU1000_UART2_INT          2 /* au1000 */
-
-#define AU1000_PCI_INTA           1 /* au1500 */
-#define AU1000_PCI_INTB           2 /* au1500 */
-
 #define AU1000_UART3_INT          3
-
 #define AU1000_SSI0_INT           4 /* au1000 */
 #define AU1000_SSI1_INT           5 /* au1000 */
-
-#define AU1000_PCI_INTC           4 /* au1500 */
-#define AU1000_PCI_INTD           5 /* au1500 */
-
 #define AU1000_DMA_INT_BASE       6
 #define AU1000_TOY_INT            14
 #define AU1000_TOY_MATCH0_INT     15
@@ -315,11 +319,8 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1000_ACSYNC_INT         27
 #define AU1000_MAC0_DMA_INT       28
 #define AU1000_MAC1_DMA_INT       29
-#define AU1000_ETH0_IRQ           AU1000_MAC0_DMA_INT
-#define AU1000_ETH1_IRQ           AU1000_MAC1_DMA_INT
 #define AU1000_I2S_UO_INT         30 /* au1000 */
 #define AU1000_AC97C_INT          31
-#define AU1000_LAST_INTC0_INT     AU1000_AC97C_INT
 #define AU1000_GPIO_0             32
 #define AU1000_GPIO_1             33
 #define AU1000_GPIO_2             34
@@ -336,8 +337,6 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1000_GPIO_13            45
 #define AU1000_GPIO_14            46
 #define AU1000_GPIO_15            47
-
-/* Au1000 only */
 #define AU1000_GPIO_16            48
 #define AU1000_GPIO_17            49
 #define AU1000_GPIO_18            50
@@ -355,7 +354,62 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1000_GPIO_30            62
 #define AU1000_GPIO_31            63
 
-/* Au1500 only */
+#define UART0_ADDR                0xB1100000
+#define UART1_ADDR                0xB1200000
+#define UART2_ADDR                0xB1300000
+#define UART3_ADDR                0xB1400000
+
+#define USB_OHCI_BASE             0x10100000 // phys addr for ioremap
+#define USB_HOST_CONFIG           0xB017fffc
+
+#define AU1000_ETH0_BASE      0xB0500000
+#define AU1000_ETH1_BASE      0xB0510000
+#define AU1000_MAC0_ENABLE       0xB0520000
+#define AU1000_MAC1_ENABLE       0xB0520004
+#define NUM_ETH_INTERFACES 2
+#endif // CONFIG_SOC_AU1000
+
+/* Au1500 */
+#ifdef CONFIG_SOC_AU1500
+#define AU1500_UART0_INT          0
+#define AU1000_PCI_INTA           1 /* au1500 */
+#define AU1000_PCI_INTB           2 /* au1500 */
+#define AU1500_UART3_INT          3
+#define AU1000_PCI_INTC           4 /* au1500 */
+#define AU1000_PCI_INTD           5 /* au1500 */
+#define AU1000_DMA_INT_BASE       6
+#define AU1000_TOY_INT            14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
+#define AU1500_PCI_ERR_INT        22
+#define AU1000_USB_DEV_REQ_INT    24
+#define AU1000_USB_DEV_SUS_INT    25
+#define AU1000_USB_HOST_INT       26
+#define AU1000_ACSYNC_INT         27
+#define AU1500_MAC0_DMA_INT       28
+#define AU1500_MAC1_DMA_INT       29
+#define AU1000_AC97C_INT          31
+#define AU1000_GPIO_0             32
+#define AU1000_GPIO_1             33
+#define AU1000_GPIO_2             34
+#define AU1000_GPIO_3             35
+#define AU1000_GPIO_4             36
+#define AU1000_GPIO_5             37
+#define AU1000_GPIO_6             38
+#define AU1000_GPIO_7             39
+#define AU1000_GPIO_8             40
+#define AU1000_GPIO_9             41
+#define AU1000_GPIO_10            42
+#define AU1000_GPIO_11            43
+#define AU1000_GPIO_12            44
+#define AU1000_GPIO_13            45
+#define AU1000_GPIO_14            46
+#define AU1000_GPIO_15            47
 #define AU1500_GPIO_200           48
 #define AU1500_GPIO_201           49
 #define AU1500_GPIO_202           50
@@ -373,14 +427,79 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1500_GPIO_207           62
 #define AU1500_GPIO_208_215       63
 
-#define AU1000_MAX_INTR           63
+#define UART0_ADDR                0xB1100000
+#define UART3_ADDR                0xB1400000
+
+#define USB_OHCI_BASE             0x10100000 // phys addr for ioremap
+#define USB_HOST_CONFIG           0xB017fffc
+
+#define AU1500_ETH0_BASE	  0xB1500000
+#define AU1500_ETH1_BASE	  0xB1510000
+#define AU1500_MAC0_ENABLE       0xB1520000
+#define AU1500_MAC1_ENABLE       0xB1520004
+#define NUM_ETH_INTERFACES 2
+#endif // CONFIG_SOC_AU1500
 
-#define AU1100_SD		2
+/* Au1100 */
+#ifdef CONFIG_SOC_AU1100
+#define AU1100_UART0_INT          0
+#define AU1100_UART1_INT          1
+#define AU1100_SD_INT             2
+#define AU1100_UART3_INT          3
+#define AU1000_SSI0_INT           4
+#define AU1000_SSI1_INT           5
+#define AU1000_DMA_INT_BASE       6
+#define AU1000_TOY_INT            14
+#define AU1000_TOY_MATCH0_INT     15
+#define AU1000_TOY_MATCH1_INT     16
+#define AU1000_TOY_MATCH2_INT     17
+#define AU1000_RTC_INT            18
+#define AU1000_RTC_MATCH0_INT     19
+#define AU1000_RTC_MATCH1_INT     20
+#define AU1000_RTC_MATCH2_INT     21
+#define AU1000_IRDA_TX_INT        22
+#define AU1000_IRDA_RX_INT        23
+#define AU1000_USB_DEV_REQ_INT    24
+#define AU1000_USB_DEV_SUS_INT    25
+#define AU1000_USB_HOST_INT       26
+#define AU1000_ACSYNC_INT         27
+#define AU1100_MAC0_DMA_INT       28
 #define	AU1100_GPIO_208_215	29
-// Seperate defines for AU1550 SOC
-#define AU1550_UART0_INT          AU1000_UART0_INT
-#define AU1550_PCI_INTA           AU1000_PCI_INTA
-#define AU1550_PCI_INTB           AU1000_PCI_INTB
+#define	AU1100_LCD_INT            30
+#define AU1000_AC97C_INT          31
+#define AU1000_GPIO_0             32
+#define AU1000_GPIO_1             33
+#define AU1000_GPIO_2             34
+#define AU1000_GPIO_3             35
+#define AU1000_GPIO_4             36
+#define AU1000_GPIO_5             37
+#define AU1000_GPIO_6             38
+#define AU1000_GPIO_7             39
+#define AU1000_GPIO_8             40
+#define AU1000_GPIO_9             41
+#define AU1000_GPIO_10            42
+#define AU1000_GPIO_11            43
+#define AU1000_GPIO_12            44
+#define AU1000_GPIO_13            45
+#define AU1000_GPIO_14            46
+#define AU1000_GPIO_15            47
+
+#define UART0_ADDR                0xB1100000
+#define UART1_ADDR                0xB1200000
+#define UART3_ADDR                0xB1400000
+
+#define USB_OHCI_BASE             0x10100000 // phys addr for ioremap
+#define USB_HOST_CONFIG           0xB017fffc
+
+#define AU1100_ETH0_BASE	  0xB0500000
+#define AU1100_MAC0_ENABLE       0xB0520000
+#define NUM_ETH_INTERFACES 1
+#endif // CONFIG_SOC_AU1100
+
+#ifdef CONFIG_SOC_AU1550
+#define AU1550_UART0_INT          0
+#define AU1550_PCI_INTA           1
+#define AU1550_PCI_INTB           2
 #define AU1550_DDMA_INT           3
 #define AU1550_CRYPTO_INT         4
 #define AU1550_PCI_INTC           5
@@ -404,11 +523,27 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1550_USB_DEV_REQ_INT    24
 #define AU1550_USB_DEV_SUS_INT    25
 #define AU1550_USB_HOST_INT       26
+#define AU1000_USB_DEV_REQ_INT    AU1550_USB_DEV_REQ_INT
+#define AU1000_USB_DEV_SUS_INT    AU1550_USB_DEV_SUS_INT
+#define AU1000_USB_HOST_INT       AU1550_USB_HOST_INT
 #define AU1550_MAC0_DMA_INT       27
 #define AU1550_MAC1_DMA_INT       28
-#define AU1550_ETH0_IRQ           AU1550_MAC0_DMA_INT
-#define AU1550_ETH1_IRQ           AU1550_MAC1_DMA_INT
-
+#define AU1000_GPIO_0             32
+#define AU1000_GPIO_1             33
+#define AU1000_GPIO_2             34
+#define AU1000_GPIO_3             35
+#define AU1000_GPIO_4             36
+#define AU1000_GPIO_5             37
+#define AU1000_GPIO_6             38
+#define AU1000_GPIO_7             39
+#define AU1000_GPIO_8             40
+#define AU1000_GPIO_9             41
+#define AU1000_GPIO_10            42
+#define AU1000_GPIO_11            43
+#define AU1000_GPIO_12            44
+#define AU1000_GPIO_13            45
+#define AU1000_GPIO_14            46
+#define AU1000_GPIO_15            47
 #define AU1550_GPIO_200           48
 #define AU1500_GPIO_201_205       49	// Logical or of GPIO201:205
 #define AU1500_GPIO_16            50
@@ -426,7 +561,101 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define AU1500_GPIO_207           62
 #define AU1500_GPIO_208_218       63	// Logical or of GPIO208:218
 
-// REDEFINE SECONDARY GPIO BLOCK INTO IC1 CONTROLLER HERE
+#define UART0_ADDR                0xB1100000
+#define UART1_ADDR                0xB1200000
+#define UART3_ADDR                0xB1400000
+
+#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
+#define USB_HOST_CONFIG           0xB4027ffc
+
+#define AU1550_ETH0_BASE      0xB0500000
+#define AU1550_ETH1_BASE      0xB0510000
+#define AU1550_MAC0_ENABLE       0xB0520000
+#define AU1550_MAC1_ENABLE       0xB0520004
+#define NUM_ETH_INTERFACES 2
+#endif // CONFIG_SOC_AU1550
+
+#ifdef CONFIG_SOC_AU1200
+#define AU1200_UART0_INT          0
+#define AU1200_SWT_INT            1
+#define AU1200_SD_INT             2
+#define AU1200_DDMA_INT           3
+#define AU1200_MAE_BE_INT         4
+#define AU1200_GPIO_200           5
+#define AU1200_GPIO_201           6
+#define AU1200_GPIO_202           7
+#define AU1200_UART1_INT          8
+#define AU1200_MAE_FE_INT         9
+#define AU1200_PSC0_INT           10
+#define AU1200_PSC1_INT           11
+#define AU1200_AES_INT            12
+#define AU1200_CAMERA_INT         13
+#define AU1200_TOY_INT			  14
+#define AU1200_TOY_MATCH0_INT     15
+#define AU1200_TOY_MATCH1_INT     16
+#define AU1200_TOY_MATCH2_INT     17
+#define AU1200_RTC_INT            18
+#define AU1200_RTC_MATCH0_INT     19
+#define AU1200_RTC_MATCH1_INT     20
+#define AU1200_RTC_MATCH2_INT     21
+#define AU1200_NAND_INT           23
+#define AU1200_GPIO_204           24
+#define AU1200_GPIO_205           25
+#define AU1200_GPIO_206           26
+#define AU1200_GPIO_207           27
+#define AU1200_GPIO_208_215       28 // Logical OR of 208:215
+#define AU1200_USB_INT            29
+#define AU1200_LCD_INT            30
+#define AU1200_MAE_BOTH_INT       31
+#define AU1000_GPIO_0             32
+#define AU1000_GPIO_1             33
+#define AU1000_GPIO_2             34
+#define AU1000_GPIO_3             35
+#define AU1000_GPIO_4             36
+#define AU1000_GPIO_5             37
+#define AU1000_GPIO_6             38
+#define AU1000_GPIO_7             39
+#define AU1000_GPIO_8             40
+#define AU1000_GPIO_9             41
+#define AU1000_GPIO_10            42
+#define AU1000_GPIO_11            43
+#define AU1000_GPIO_12            44
+#define AU1000_GPIO_13            45
+#define AU1000_GPIO_14            46
+#define AU1000_GPIO_15            47
+#define AU1000_GPIO_16            48
+#define AU1000_GPIO_17            49
+#define AU1000_GPIO_18            50
+#define AU1000_GPIO_19            51
+#define AU1000_GPIO_20            52
+#define AU1000_GPIO_21            53
+#define AU1000_GPIO_22            54
+#define AU1000_GPIO_23            55
+#define AU1000_GPIO_24            56
+#define AU1000_GPIO_25            57
+#define AU1000_GPIO_26            58
+#define AU1000_GPIO_27            59
+#define AU1000_GPIO_28            60
+#define AU1000_GPIO_29            61
+#define AU1000_GPIO_30            62
+#define AU1000_GPIO_31            63
+
+#define UART0_ADDR                0xB1100000
+#define UART1_ADDR                0xB1200000
+
+#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
+#define USB_HOST_CONFIG           0xB4027ffc
+
+// these are here for prototyping on au1550 (do not exist on au1200)
+#define AU1200_ETH0_BASE      0xB0500000
+#define AU1200_ETH1_BASE      0xB0510000
+#define AU1200_MAC0_ENABLE       0xB0520000
+#define AU1200_MAC1_ENABLE       0xB0520004
+#define NUM_ETH_INTERFACES 2
+#endif // CONFIG_SOC_AU1200
+
+#define AU1000_LAST_INTC0_INT     31
+#define AU1000_MAX_INTR           63
 
 
 /* Programmable Counters 0 and 1 */
@@ -500,16 +729,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define I2S_CONTROL_CE        (1<<0)
 
 /* USB Host Controller */
-// We pass USB_OHCI_BASE to ioremap, so it needs to be a physical address
-#if defined( CONFIG_SOC_AU1550 )
-#define USB_OHCI_BASE             0x14020000
-#define USB_OHCI_LEN              0x00100000
-#define USB_HOST_CONFIG           0xB4027ffc
-#else
-#define USB_OHCI_BASE             0x10100000
 #define USB_OHCI_LEN              0x00100000
-#define USB_HOST_CONFIG           0xB017fffc
-#endif
 
 /* USB Device Controller */
 #define USBD_EP0RD                0xB0200000
@@ -554,13 +774,6 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define USBDEV_CE     (1<<0)
 
 /* Ethernet Controllers  */
-#define AU1000_ETH0_BASE          0xB0500000
-#define AU1000_ETH1_BASE          0xB0510000
-#define AU1500_ETH0_BASE	  0xB1500000
-#define AU1500_ETH1_BASE	  0xB1510000
-#define AU1100_ETH0_BASE	  0xB0500000
-#define AU1550_ETH0_BASE      0xB0500000
-#define AU1550_ETH1_BASE      0xB0510000
 
 /* 4 byte offsets from AU1000_ETH_BASE */
 #define MAC_CONTROL                     0x0
@@ -605,11 +818,6 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define MAC_VLAN2_TAG                  0x24
 
 /* Ethernet Controller Enable */
-#define AU1000_MAC0_ENABLE       0xB0520000
-#define AU1000_MAC1_ENABLE       0xB0520004
-#define AU1500_MAC0_ENABLE       0xB1520000
-#define AU1500_MAC1_ENABLE       0xB1520004
-#define AU1100_MAC0_ENABLE       0xB0520000
 
   #define MAC_EN_CLOCK_ENABLE         (1<<0)
   #define MAC_EN_RESET0               (1<<1)
@@ -693,10 +901,6 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 
 
 /* UARTS 0-3 */
-#define UART0_ADDR                0xB1100000
-#define UART1_ADDR                0xB1200000
-#define UART2_ADDR                0xB1300000
-#define UART3_ADDR                0xB1400000
 #define UART_BASE                 UART0_ADDR
 #define UART_DEBUG_BASE           UART3_ADDR
 
@@ -951,6 +1155,22 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define SYS_PF_CS			(1<<16)	/* EXTCLK0/32khz to gpio2 */
   #define SYS_PF_EX0			(1<<9)	/* gpio2/clock */
 
+/* Au1550 Only.  Redefines lots of pins */
+  #define SYS_PF_PSC2_MASK		(7 << 17)
+  #define SYS_PF_PSC2_AC97		(0)
+  #define SYS_PF_PSC2_SPI		(0)
+  #define SYS_PF_PSC2_I2S		(1 << 17)
+  #define SYS_PF_PSC2_SMBUS		(3 << 17)
+  #define SYS_PF_PSC2_GPIO		(7 << 17)
+  #define SYS_PF_PSC3_MASK		(7 << 20)
+  #define SYS_PF_PSC3_AC97		(0)
+  #define SYS_PF_PSC3_SPI		(0)
+  #define SYS_PF_PSC3_I2S		(1 << 20)
+  #define SYS_PF_PSC3_SMBUS		(3 << 20)
+  #define SYS_PF_PSC3_GPIO		(7 << 20)
+  #define SYS_PF_PSC1_S1		(1 << 1)
+  #define SYS_PF_MUST_BE_SET		((1 << 5) | (1 << 2))
+
 #define SYS_TRIOUTRD              0xB1900100
 #define SYS_TRIOUTCLR             0xB1900100
 #define SYS_OUTPUTRD              0xB1900108
@@ -959,7 +1179,7 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define SYS_PINSTATERD            0xB1900110
 #define SYS_PININPUTEN            0xB1900110
 
-/* GPIO2, Au1500 only */
+/* GPIO2, Au1500, Au1550 only */
 #define GPIO2_BASE                0xB1700000
 #define GPIO2_DIR                 (GPIO2_BASE + 0)
 #define GPIO2_OUTPUT              (GPIO2_BASE + 8)
@@ -1071,6 +1291,14 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
   #define AC97C_RS              (1<<1)
   #define AC97C_CE              (1<<0)
 
+ 
+/* Secure Digital (SD) Controller */
+#define SD0_XMIT_FIFO	0xB0600000
+#define SD0_RECV_FIFO	0xB0600004
+#define SD1_XMIT_FIFO	0xB0680000
+#define SD1_RECV_FIFO	0xB0680004
+
+
 #if defined (CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 /* Au1500 PCI Controller */
 #define Au1500_CFG_BASE           0xB4005000 // virtual, kseg0 addr
@@ -1119,6 +1347,20 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 #define IOMEM_RESOURCE_START  0x10000000
 #define IOMEM_RESOURCE_END    0xffffffff
 
+  /*
+   * Borrowed from the PPC arch:
+   * The following macro is used to lookup irqs in a standard table
+   * format for those PPC systems that do not already have PCI
+   * interrupts properly routed.
+   */
+  /* FIXME - double check this from asm-ppc/pci-bridge.h */
+#define PCI_IRQ_TABLE_LOOKUP                            \
+  ({ long _ctl_ = -1;                                 \
+      if (idsel >= min_idsel && idsel <= max_idsel && pin <= irqs_per_slot)    \
+	       _ctl_ = pci_irq_table[idsel - min_idsel][pin-1];               \
+		      _ctl_; })
+
+
 #else /* Au1000 and Au1100 */
 
 /* don't allow any legacy ports probing */
@@ -1146,10 +1388,19 @@ extern au1xxx_irq_map_t au1xxx_irq_map[]
 
 #endif
 
-#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
-#define NUM_ETH_INTERFACES 2
-#elif defined(CONFIG_SOC_AU1100)
-#define NUM_ETH_INTERFACES 1
-#endif
+/* Processor information base on prid.
+ * Copied from PowerPC.
+ */
+struct cpu_spec {
+	/* CPU is matched via (PRID & prid_mask) == prid_value */
+	unsigned int	prid_mask;
+	unsigned int	prid_value;
+
+	char		*cpu_name;
+	unsigned char	cpu_od;		/* Set Config[OD] */
+	unsigned char	cpu_bclk;	/* Enable BCLK switching */
+};
 
+extern struct cpu_spec		cpu_specs[];
+extern struct cpu_spec		*cur_cpu_spec[];
 #endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/au1000_dma.h linux-mips-cvs-20040815/include/asm-mips/au1000_dma.h
--- linux-2.4.27/include/asm-mips/au1000_dma.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/au1000_dma.h	2004-05-02 00:48:41.000000000 +0200
@@ -51,6 +51,7 @@
 #define DMA_DAH_MASK		(0x0f << 20)
 #define DMA_DID_BIT		16
 #define DMA_DID_MASK		(0x0f << DMA_DID_BIT)
+#define DMA_DS			(1<<15)
 #define DMA_BE			(1<<13)
 #define DMA_DR			(1<<12)
 #define DMA_TS8			(1<<11)
@@ -100,6 +101,15 @@ enum {
 	DMA_NUM_DEV
 };
 
+/* DMA Device ID's for 2nd bank (AU1100) follow */
+enum {
+	DMA_ID_SD0_TX = 0,
+	DMA_ID_SD0_RX,
+	DMA_ID_SD1_TX,
+	DMA_ID_SD1_RX,
+	DMA_NUM_DEV_BANK2
+};
+
 struct dma_chan {
 	int dev_id;		// this channel is allocated if >=0, free otherwise
 	unsigned int io;
@@ -127,7 +137,7 @@ extern spinlock_t au1000_dma_spin_lock;
 
 static __inline__ struct dma_chan *get_dma_chan(unsigned int dmanr)
 {
-	if (dmanr > NUM_AU1000_DMA_CHANNELS
+	if (dmanr >= NUM_AU1000_DMA_CHANNELS
 	    || au1000_dma_table[dmanr].dev_id < 0)
 		return NULL;
 	return &au1000_dma_table[dmanr];
@@ -206,8 +216,8 @@ static __inline__ void disable_dma(unsig
 
 	halt_dma(dmanr);
 
-		// now we can disable the buffers
-		au_writel(~DMA_GO, chan->io + DMA_MODE_CLEAR);
+	// now we can disable the buffers
+	au_writel(~DMA_GO, chan->io + DMA_MODE_CLEAR);
 }
 
 static __inline__ int dma_halted(unsigned int dmanr)
@@ -287,6 +297,9 @@ static __inline__ void set_dma_fifo_addr
 	if (!chan)
 		return;
 
+	if (chan->mode & DMA_DS)	/* second bank of device ids */
+		return;
+
 	if (chan->dev_id != DMA_ID_GP04 && chan->dev_id != DMA_ID_GP05)
 		return;
 
@@ -431,3 +444,4 @@ static __inline__ int get_dma_residue(un
 }
 
 #endif /* __ASM_AU1000_DMA_H */
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/au1000_pcmcia.h linux-mips-cvs-20040815/include/asm-mips/au1000_pcmcia.h
--- linux-2.4.27/include/asm-mips/au1000_pcmcia.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/au1000_pcmcia.h	2004-05-02 00:48:41.000000000 +0200
@@ -44,7 +44,7 @@
 #define AU1X_SOCK1_IO        0xF08000000
 #define AU1X_SOCK1_PHYS_ATTR 0xF48000000
 #define AU1X_SOCK1_PHYS_MEM  0xF88000000
-#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500)
+#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_PB1550) || defined(CONFIG_MIPS_DB1550)
 #define AU1X_SOCK1_IO        0xF04000000
 #define AU1X_SOCK1_PHYS_ATTR 0xF44000000
 #define AU1X_SOCK1_PHYS_MEM  0xF84000000
@@ -100,14 +100,5 @@ struct pcmcia_low_level {
 	int (*configure_socket)(const struct pcmcia_configure *);
 };
 
-#if defined(CONFIG_MIPS_PB1000) || defined(CONFIG_MIPS_PB1100) || defined(CONFIG_MIPS_PB1500)
-extern struct pcmcia_low_level pb1x00_pcmcia_ops;
-#elif defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500)
-extern struct pcmcia_low_level db1x00_pcmcia_ops;
-#elif defined(CONFIG_MIPS_XXS1500)
-extern struct pcmcia_low_level xxs1500_pcmcia_ops;
-#else
-error unknown Au1000 board
-#endif
-
+extern struct pcmcia_low_level au1x00_pcmcia_ops;
 #endif /* __ASM_AU1000_PCMCIA_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/au1100_mmc.h linux-mips-cvs-20040815/include/asm-mips/au1100_mmc.h
--- linux-2.4.27/include/asm-mips/au1100_mmc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/au1100_mmc.h	2004-03-31 10:24:24.000000000 +0200
@@ -0,0 +1,205 @@
+/*
+ * BRIEF MODULE DESCRIPTION
+ *	Defines for using the MMC/SD controllers on the
+ *      Alchemy Au1100 mips processor.
+ *
+ * Copyright (c) 2003 Embedded Edge, LLC.
+ * Author: Embedded Edge, LLC.
+ *         	dan@embeddededge.com or tim@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+/*
+ * AU1100 MMC/SD definitions.
+ *
+ * From "AMD Alchemy Solutions Au1100 Processor Data Book - Preliminary"
+ *    June, 2003
+ */
+
+#ifndef __ASM_AU1100_MMC_H
+#define __ASM_AU1100_MMC_H
+
+
+#define NUM_AU1100_MMC_CONTROLLERS	2
+
+
+#define AU1100_SD_IRQ	2
+
+
+#define SD0_BASE	0xB0600000
+#define SD1_BASE	0xB0680000
+
+
+/*
+ *  Register offsets.
+ */
+#define SD_TXPORT	(0x0000)
+#define SD_RXPORT	(0x0004)
+#define SD_CONFIG	(0x0008)
+#define SD_ENABLE	(0x000C)
+#define SD_CONFIG2	(0x0010)
+#define SD_BLKSIZE	(0x0014)
+#define SD_STATUS	(0x0018)
+#define SD_DEBUG	(0x001C)
+#define SD_CMD		(0x0020)
+#define SD_CMDARG	(0x0024)
+#define SD_RESP3	(0x0028)
+#define SD_RESP2	(0x002C)
+#define SD_RESP1	(0x0030)
+#define SD_RESP0	(0x0034)
+#define SD_TIMEOUT	(0x0038)
+
+
+/*
+ *  SD_TXPORT bit definitions.
+ */
+#define SD_TXPORT_TXD	(0x000000ff)
+
+
+/*
+ *  SD_RXPORT bit definitions.
+ */
+#define SD_RXPORT_RXD	(0x000000ff)
+
+
+/*
+ *  SD_CONFIG bit definitions.
+ */
+#define SD_CONFIG_DIV	(0x000001ff)
+#define SD_CONFIG_DE	(0x00000200)
+#define SD_CONFIG_NE	(0x00000400)
+#define SD_CONFIG_TU	(0x00000800)
+#define SD_CONFIG_TO	(0x00001000)
+#define SD_CONFIG_RU	(0x00002000)
+#define SD_CONFIG_RO	(0x00004000)
+#define SD_CONFIG_I	(0x00008000)
+#define SD_CONFIG_CR	(0x00010000)
+#define SD_CONFIG_RAT	(0x00020000)
+#define SD_CONFIG_DD	(0x00040000)
+#define SD_CONFIG_DT	(0x00080000)
+#define SD_CONFIG_SC	(0x00100000)
+#define SD_CONFIG_RC	(0x00200000)
+#define SD_CONFIG_WC	(0x00400000)
+#define SD_CONFIG_xxx	(0x00800000)
+#define SD_CONFIG_TH	(0x01000000)
+#define SD_CONFIG_TE	(0x02000000)
+#define SD_CONFIG_TA	(0x04000000)
+#define SD_CONFIG_RH	(0x08000000)
+#define SD_CONFIG_RA	(0x10000000)
+#define SD_CONFIG_RF	(0x20000000)
+#define SD_CONFIG_CD	(0x40000000)
+#define SD_CONFIG_SI	(0x80000000)
+
+
+/*
+ *  SD_ENABLE bit definitions.
+ */
+#define SD_ENABLE_CE	(0x00000001)
+#define SD_ENABLE_R	(0x00000002)
+
+
+/*
+ *  SD_CONFIG2 bit definitions.
+ */
+#define SD_CONFIG2_EN	(0x00000001)
+#define SD_CONFIG2_FF	(0x00000002)
+#define SD_CONFIG2_xx1	(0x00000004)
+#define SD_CONFIG2_DF	(0x00000008)
+#define SD_CONFIG2_DC	(0x00000010)
+#define SD_CONFIG2_xx2	(0x000000e0)
+#define SD_CONFIG2_WB	(0x00000100)
+#define SD_CONFIG2_RW	(0x00000200)
+
+
+/*
+ *  SD_BLKSIZE bit definitions.
+ */
+#define SD_BLKSIZE_BS	(0x000007ff)
+#define SD_BLKSIZE_BS_SHIFT	 (0)
+#define SD_BLKSIZE_BC	(0x01ff0000)
+#define SD_BLKSIZE_BC_SHIFT	(16)
+
+
+/*
+ *  SD_STATUS bit definitions.
+ */
+#define SD_STATUS_DCRCW	(0x00000007)
+#define SD_STATUS_xx1	(0x00000008)
+#define SD_STATUS_CB	(0x00000010)
+#define SD_STATUS_DB	(0x00000020)
+#define SD_STATUS_CF	(0x00000040)
+#define SD_STATUS_D3	(0x00000080)
+#define SD_STATUS_xx2	(0x00000300)
+#define SD_STATUS_NE	(0x00000400)
+#define SD_STATUS_TU	(0x00000800)
+#define SD_STATUS_TO	(0x00001000)
+#define SD_STATUS_RU	(0x00002000)
+#define SD_STATUS_RO	(0x00004000)
+#define SD_STATUS_I	(0x00008000)
+#define SD_STATUS_CR	(0x00010000)
+#define SD_STATUS_RAT	(0x00020000)
+#define SD_STATUS_DD	(0x00040000)
+#define SD_STATUS_DT	(0x00080000)
+#define SD_STATUS_SC	(0x00100000)
+#define SD_STATUS_RC	(0x00200000)
+#define SD_STATUS_WC	(0x00400000)
+#define SD_STATUS_xx3	(0x00800000)
+#define SD_STATUS_TH	(0x01000000)
+#define SD_STATUS_TE	(0x02000000)
+#define SD_STATUS_TA	(0x04000000)
+#define SD_STATUS_RH	(0x08000000)
+#define SD_STATUS_RA	(0x10000000)
+#define SD_STATUS_RF	(0x20000000)
+#define SD_STATUS_CD	(0x40000000)
+#define SD_STATUS_SI	(0x80000000)
+
+
+/*
+ *  SD_CMD bit definitions.
+ */
+#define SD_CMD_GO	(0x00000001)
+#define SD_CMD_RY	(0x00000002)
+#define SD_CMD_xx1	(0x0000000c)
+#define SD_CMD_CT_MASK	(0x000000f0)
+#define SD_CMD_CT_0	(0x00000000)
+#define SD_CMD_CT_1	(0x00000010)
+#define SD_CMD_CT_2	(0x00000020)
+#define SD_CMD_CT_3	(0x00000030)
+#define SD_CMD_CT_4	(0x00000040)
+#define SD_CMD_CT_5	(0x00000050)
+#define SD_CMD_CT_6	(0x00000060)
+#define SD_CMD_CT_7	(0x00000070)
+#define SD_CMD_CI	(0x0000ff00)
+#define SD_CMD_CI_SHIFT		(8)
+#define SD_CMD_RT_MASK	(0x00ff0000)
+#define SD_CMD_RT_0	(0x00000000)
+#define SD_CMD_RT_1	(0x00010000)
+#define SD_CMD_RT_2	(0x00020000)
+#define SD_CMD_RT_3	(0x00030000)
+#define SD_CMD_RT_4	(0x00040000)
+#define SD_CMD_RT_5	(0x00050000)
+#define SD_CMD_RT_6	(0x00060000)
+#define SD_CMD_RT_1B	(0x00810000)
+
+
+#endif /* __ASM_AU1100_MMC_H */
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/au1550_spi.h linux-mips-cvs-20040815/include/asm-mips/au1550_spi.h
--- linux-2.4.27/include/asm-mips/au1550_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/au1550_spi.h	2004-05-12 09:31:10.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ *	API to Alchemy Au1550 SPI device.
+ *
+ * Copyright 2004 Embedded Edge, LLC.
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __AU1550_SPI_H
+#define __AU1550_SPI_H
+
+#include <linux/ioctl.h>
+
+#define AU1550SPI_IOC_MAGIC 'S'
+
+#define AU1550SPI_SET_BAUD	_IOW(AU1550SPI_IOC_MAGIC, 0, int *)
+#define AU1550SPI_WORD_LEN	_IOW(AU1550SPI_IOC_MAGIC, 1, int)
+
+#endif /* __AU1000_SPI_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/au1xxx_dbdma.h linux-mips-cvs-20040815/include/asm-mips/au1xxx_dbdma.h
--- linux-2.4.27/include/asm-mips/au1xxx_dbdma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/au1xxx_dbdma.h	2004-08-15 08:06:47.000000000 +0200
@@ -0,0 +1,318 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Include file for Alchemy Semiconductor's Au1550 Descriptor
+ *	Based DMA Controller.
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Specifics for the Au1xxx Descriptor-Based DMA Controllers, first
+ * seen in the AU1550 part.
+ */
+#ifndef _AU1000_DBDMA_H_
+#define _AU1000_DBDMA_H_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* The DMA base addresses.
+ * The Channels are every 256 bytes (0x0100) from the channel 0 base.
+ * Interrupt status/enable is bits 15:0 for channels 15 to zero.
+ */
+#define DDMA_GLOBAL_BASE	0xb4003000
+#define DDMA_CHANNEL_BASE	0xb4002000
+
+typedef struct dbdma_global {
+	u32	ddma_config;
+	u32	ddma_intstat;
+	u32	ddma_throttle;
+	u32	ddma_inten;
+} dbdma_global_t;
+
+/* General Configuration.
+*/
+#define DDMA_CONFIG_AF		(1 << 2)
+#define DDMA_CONFIG_AH		(1 << 1)
+#define DDMA_CONFIG_AL		(1 << 0)
+
+#define DDMA_THROTTLE_EN	(1 << 31)
+
+/* The structure of a DMA Channel.
+*/
+typedef struct au1xxx_dma_channel {
+	u32	ddma_cfg;	/* See below */
+	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
+	u32	ddma_statptr;	/* word aligned pointer to status word */
+	u32	ddma_dbell;	/* A write activates channel operation */
+	u32	ddma_irq;	/* If bit 0 set, interrupt pending */
+	u32	ddma_stat;	/* See below */
+	u32	ddma_bytecnt;	/* Byte count, valid only when chan idle */
+	/* Remainder, up to the 256 byte boundary, is reserved.
+	*/
+} au1x_dma_chan_t;
+
+#define DDMA_CFG_SED	(1 << 9)	/* source DMA level/edge detect */
+#define DDMA_CFG_SP	(1 << 8)	/* source DMA polarity */
+#define DDMA_CFG_DED	(1 << 7)	/* destination DMA level/edge detect */
+#define DDMA_CFG_DP	(1 << 6)	/* destination DMA polarity */
+#define DDMA_CFG_SYNC	(1 << 5)	/* Sync static bus controller */
+#define DDMA_CFG_PPR	(1 << 4)	/* PCI posted read/write control */
+#define DDMA_CFG_DFN	(1 << 3)	/* Descriptor fetch non-coherent */
+#define DDMA_CFG_SBE	(1 << 2)	/* Source big endian */
+#define DDMA_CFG_DBE	(1 << 1)	/* Destination big endian */
+#define DDMA_CFG_EN	(1 << 0)	/* Channel enable */
+
+/* Always set when descriptor processing done, regardless of
+ * interrupt enable state.  Reflected in global intstat, don't
+ * clear this until global intstat is read/used.
+ */
+#define DDMA_IRQ_IN	(1 << 0)
+
+#define DDMA_STAT_DB	(1 << 2)	/* Doorbell pushed */
+#define DDMA_STAT_V	(1 << 1)	/* Descriptor valid */
+#define DDMA_STAT_H	(1 << 0)	/* Channel Halted */
+
+/* "Standard" DDMA Descriptor.
+ * Must be 32-byte aligned.
+ */
+typedef struct au1xxx_ddma_desc {
+	u32	dscr_cmd0;		/* See below */
+	u32	dscr_cmd1;		/* See below */
+	u32	dscr_source0;		/* source phys address */
+	u32	dscr_source1;		/* See below */
+	u32	dscr_dest0;		/* Destination address */
+	u32	dscr_dest1;		/* See below */
+	u32	dscr_stat;		/* completion status */
+	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
+} au1x_ddma_desc_t;
+
+#define DSCR_CMD0_V		(1 << 31)	/* Descriptor valid */
+#define DSCR_CMD0_MEM		(1 << 30)	/* mem-mem transfer */
+#define DSCR_CMD0_SID_MASK	(0x1f << 25)	/* Source ID */
+#define DSCR_CMD0_DID_MASK	(0x1f << 20)	/* Destination ID */
+#define DSCR_CMD0_SW_MASK	(0x3 << 18)	/* Source Width */
+#define DSCR_CMD0_DW_MASK	(0x3 << 16)	/* Destination Width */
+#define DSCR_CMD0_ARB		(0x1 << 15)	/* Set for Hi Pri */
+#define DSCR_CMD0_DT_MASK	(0x3 << 13)	/* Descriptor Type */
+#define DSCR_CMD0_SN		(0x1 << 12)	/* Source non-coherent */
+#define DSCR_CMD0_DN		(0x1 << 11)	/* Destination non-coherent */
+#define DSCR_CMD0_SM		(0x1 << 10)	/* Stride mode */
+#define DSCR_CMD0_IE		(0x1 << 8)	/* Interrupt Enable */
+#define DSCR_CMD0_SP		(0x1 << 4)	/* Status pointer select */
+#define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
+#define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
+
+/* Command 0 device IDs.
+*/
+#ifdef CONFIG_SOC_AU1550
+#define DSCR_CMD0_UART0_TX	0
+#define DSCR_CMD0_UART0_RX	1
+#define DSCR_CMD0_UART3_TX	2
+#define DSCR_CMD0_UART3_RX	3
+#define DSCR_CMD0_DMA_REQ0	4
+#define DSCR_CMD0_DMA_REQ1	5
+#define DSCR_CMD0_DMA_REQ2	6
+#define DSCR_CMD0_DMA_REQ3	7
+#define DSCR_CMD0_USBDEV_RX0	8
+#define DSCR_CMD0_USBDEV_TX0	9
+#define DSCR_CMD0_USBDEV_TX1	10
+#define DSCR_CMD0_USBDEV_TX2	11
+#define DSCR_CMD0_USBDEV_RX3	12
+#define DSCR_CMD0_USBDEV_RX4	13
+#define DSCR_CMD0_PSC0_TX	14
+#define DSCR_CMD0_PSC0_RX	15
+#define DSCR_CMD0_PSC1_TX	16
+#define DSCR_CMD0_PSC1_RX	17
+#define DSCR_CMD0_PSC2_TX	18
+#define DSCR_CMD0_PSC2_RX	19
+#define DSCR_CMD0_PSC3_TX	20
+#define DSCR_CMD0_PSC3_RX	21
+#define DSCR_CMD0_PCI_WRITE	22
+#define DSCR_CMD0_NAND_FLASH	23
+#define DSCR_CMD0_MAC0_RX	24
+#define DSCR_CMD0_MAC0_TX	25
+#define DSCR_CMD0_MAC1_RX	26
+#define DSCR_CMD0_MAC1_TX	27
+#endif /* CONFIG_SOC_AU1550 */
+
+#ifdef CONFIG_SOC_AU1200
+#define DSCR_CMD0_UART0_TX	0
+#define DSCR_CMD0_UART0_RX	1
+#define DSCR_CMD0_UART1_TX	2
+#define DSCR_CMD0_UART1_RX	3
+#define DSCR_CMD0_DMA_REQ0	4
+#define DSCR_CMD0_DMA_REQ1	5
+#define DSCR_CMD0_MAE_BE	6
+#define DSCR_CMD0_MAE_FE	7
+#define DSCR_CMD0_SDMS_TX0	8
+#define DSCR_CMD0_SDMS_RX0	9
+#define DSCR_CMD0_SDMS_TX1	10
+#define DSCR_CMD0_SDMS_RX1	11
+#define DSCR_CMD0_AES_TX	12
+#define DSCR_CMD0_AES_RX	13
+#define DSCR_CMD0_PSC0_TX	14
+#define DSCR_CMD0_PSC0_RX	15
+#define DSCR_CMD0_PSC1_TX	16
+#define DSCR_CMD0_PSC1_RX	17
+#define DSCR_CMD0_CIM_RXA	18
+#define DSCR_CMD0_CIM_RXB	19
+#define DSCR_CMD0_CIM_RXC	20
+#define DSCR_CMD0_MAE_BOTH	21
+#define DSCR_CMD0_LCD		22
+#define DSCR_CMD0_NAND_FLASH	23
+#define DSCR_CMD0_PSC0_SYNC	24
+#define DSCR_CMD0_PSC1_SYNC	25
+#define DSCR_CMD0_CIM_SYNC	26
+#endif /* CONFIG_SOC_AU1200 */
+
+#define DSCR_CMD0_THROTTLE	30
+#define DSCR_CMD0_ALWAYS	31
+#define DSCR_NDEV_IDS		32
+
+#define DSCR_CMD0_SID(x)	(((x) & 0x1f) << 25)
+#define DSCR_CMD0_DID(x)	(((x) & 0x1f) << 20)
+
+/* Source/Destination transfer width.
+*/
+#define DSCR_CMD0_BYTE		0
+#define DSCR_CMD0_HALFWORD	1
+#define DSCR_CMD0_WORD		2
+
+#define DSCR_CMD0_SW(x)		(((x) & 0x3) << 18)
+#define DSCR_CMD0_DW(x)		(((x) & 0x3) << 16)
+
+/* DDMA Descriptor Type.
+*/
+#define DSCR_CMD0_STANDARD	0
+#define DSCR_CMD0_LITERAL	1
+#define DSCR_CMD0_CMP_BRANCH	2
+
+#define DSCR_CMD0_DT(x)		(((x) & 0x3) << 13)
+
+/* Status Instruction.
+*/
+#define DSCR_CMD0_ST_NOCHANGE	0	/* Don't change */
+#define DSCR_CMD0_ST_CURRENT	1	/* Write current status */
+#define DSCR_CMD0_ST_CMD0	2	/* Write cmd0 with V cleared */
+#define DSCR_CMD0_ST_BYTECNT	3	/* Write remaining byte count */
+
+#define DSCR_CMD0_ST(x)		(((x) & 0x3) << 0)
+
+/* Descriptor Command 1
+*/
+#define DSCR_CMD1_SUPTR_MASK	(0xf << 28)	/* upper 4 bits of src addr */
+#define DSCR_CMD1_DUPTR_MASK	(0xf << 24)	/* upper 4 bits of dest addr */
+#define DSCR_CMD1_FL_MASK	(0x3 << 22)	/* Flag bits */
+#define DSCR_CMD1_BC_MASK	(0x3fffff)	/* Byte count */
+
+/* Flag description.
+*/
+#define DSCR_CMD1_FL_MEM_STRIDE0	0
+#define DSCR_CMD1_FL_MEM_STRIDE1	1
+#define DSCR_CMD1_FL_MEM_STRIDE2	2
+
+#define DSCR_CMD1_FL(x)		(((x) & 0x3) << 22)
+
+/* Source1, 1-dimensional stride.
+*/
+#define DSCR_SRC1_STS_MASK	(3 << 30)	/* Src xfer size */
+#define DSCR_SRC1_SAM_MASK	(3 << 28)	/* Src xfer movement */
+#define DSCR_SRC1_SB_MASK	(0x3fff << 14)	/* Block size */
+#define DSCR_SRC1_SB(x)		(((x) & 0x3fff) << 14)
+#define DSCR_SRC1_SS_MASK	(0x3fff << 0)	/* Stride */
+#define DSCR_SRC1_SS(x)		(((x) & 0x3fff) << 0)
+
+/* Dest1, 1-dimensional stride.
+*/
+#define DSCR_DEST1_DTS_MASK	(3 << 30)	/* Dest xfer size */
+#define DSCR_DEST1_DAM_MASK	(3 << 28)	/* Dest xfer movement */
+#define DSCR_DEST1_DB_MASK	(0x3fff << 14)	/* Block size */
+#define DSCR_DEST1_DB(x)	(((x) & 0x3fff) << 14)
+#define DSCR_DEST1_DS_MASK	(0x3fff << 0)	/* Stride */
+#define DSCR_DEST1_DS(x)	(((x) & 0x3fff) << 0)
+
+#define DSCR_xTS_SIZE1		0
+#define DSCR_xTS_SIZE2		1
+#define DSCR_xTS_SIZE4		2
+#define DSCR_xTS_SIZE8		3
+#define DSCR_SRC1_STS(x)	(((x) & 3) << 30)
+#define DSCR_DEST1_DTS(x)	(((x) & 3) << 30)
+
+#define DSCR_xAM_INCREMENT	0
+#define DSCR_xAM_DECREMENT	1
+#define DSCR_xAM_STATIC		2
+#define DSCR_xAM_BURST		3
+#define DSCR_SRC1_SAM(x)	(((x) & 3) << 28)
+#define DSCR_DEST1_DAM(x)	(((x) & 3) << 28)
+
+/* The next descriptor pointer.
+*/
+#define DSCR_NXTPTR_MASK	(0x07ffffff)
+#define DSCR_NXTPTR(x)		((x) >> 5)
+#define DSCR_GET_NXTPTR(x)	((x) << 5)
+#define DSCR_NXTPTR_MS		(1 << 27)
+
+/* The number of DBDMA channels.
+*/
+#define NUM_DBDMA_CHANS	16
+
+/* External functions for drivers to use.
+*/
+/* Use this to allocate a dbdma channel.  The device ids are one of the
+ * DSCR_CMD0 devices IDs, which is usually redefined to a more
+ * meaningful name.  The 'callback' is called during dma completion
+ * interrupt.
+ */
+u32 au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
+       void (*callback)(int, void *, struct pt_regs *), void *callparam);
+
+#define DBDMA_MEM_CHAN	DSCR_CMD0_ALWAYS
+
+/* Set the device width of a in/out fifo.
+*/
+u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits);
+
+/* Allocate a ring of descriptors for dbdma.
+*/
+u32 au1xxx_dbdma_ring_alloc(u32 chanid, int entries);
+
+/* Put buffers on source/destination descriptors.
+*/
+u32 au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes);
+u32 au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes);
+
+/* Get a buffer from the destination descriptor.
+*/
+u32 au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes);
+
+void au1xxx_dbdma_stop(u32 chanid);
+void au1xxx_dbdma_start(u32 chanid);
+void au1xxx_dbdma_reset(u32 chanid);
+u32 au1xxx_get_dma_residue(u32 chanid);
+
+void au1xxx_dbdma_chan_free(u32 chanid);
+void au1xxx_dbdma_dump(u32 chanid);
+
+#endif /* _LANGUAGE_ASSEMBLY */
+#endif /* _AU1000_DBDMA_H_ */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/au1xxx_psc.h linux-mips-cvs-20040815/include/asm-mips/au1xxx_psc.h
--- linux-2.4.27/include/asm-mips/au1xxx_psc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/au1xxx_psc.h	2004-08-15 08:06:47.000000000 +0200
@@ -0,0 +1,522 @@
+/*
+ *
+ * BRIEF MODULE DESCRIPTION
+ *	Include file for Alchemy Semiconductor's Au1k CPU.
+ *
+ * Copyright 2004 Embedded Edge, LLC
+ *	dan@embeddededge.com
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* Specifics for the Au1xxx Programmable Serial Controllers, first
+ * seen in the AU1550 part.
+ */
+#ifndef _AU1000_PSC_H_
+#define _AU1000_PSC_H_
+
+/* The PSC base addresses.  */
+#ifdef CONFIG_SOC_AU1550
+#define PSC0_BASE_ADDR		0xb1a00000
+#define PSC1_BASE_ADDR		0xb1b00000
+#define PSC2_BASE_ADDR		0xb0a00000
+#define PSC3_BASE_ADDR		0xb0d00000
+#endif
+
+/* The PSC select and control registers are common to
+ * all protocols.
+ */
+#define PSC_SEL_OFFSET		0x00000000
+#define PSC_CTRL_OFFSET		0x00000004
+
+#define PSC_SEL_CLK_MASK	(3 << 4)
+#define PSC_SEL_CLK_INTCLK	(0 << 4)
+#define PSC_SEL_CLK_EXTCLK	(1 << 4)
+#define PSC_SEL_CLK_SERCLK	(2 << 4)
+
+#define PSC_SEL_PS_MASK		0x00000007
+#define PSC_SEL_PS_DISABLED	(0)
+#define PSC_SEL_PS_SPIMODE	(2)
+#define PSC_SEL_PS_I2SMODE	(3)
+#define PSC_SEL_PS_AC97MODE	(4)
+#define PSC_SEL_PS_SMBUSMODE	(5)
+
+#define PSC_CTRL_DISABLE	(0)
+#define PSC_CTRL_SUSPEND	(2)
+#define PSC_CTRL_ENABLE		(3)
+
+/* AC97 Registers.
+*/
+#define PSC_AC97CFG_OFFSET	0x00000008
+#define PSC_AC97MSK_OFFSET	0x0000000c
+#define PSC_AC97PCR_OFFSET	0x00000010
+#define PSC_AC97STAT_OFFSET	0x00000014
+#define PSC_AC97EVNT_OFFSET	0x00000018
+#define PSC_AC97TXRX_OFFSET	0x0000001c
+#define PSC_AC97CDC_OFFSET	0x00000020
+#define PSC_AC97RST_OFFSET	0x00000024
+#define PSC_AC97GPO_OFFSET	0x00000028
+#define PSC_AC97GPI_OFFSET	0x0000002c
+
+#define AC97_PSC_SEL		(AC97_PSC_BASE + PSC_SEL_OFFSET)
+#define AC97_PSC_CTRL		(AC97_PSC_BASE + PSC_CTRL_OFFSET)
+#define PSC_AC97CFG		(AC97_PSC_BASE + PSC_AC97CFG_OFFSET)
+#define PSC_AC97MSK		(AC97_PSC_BASE + PSC_AC97MSK_OFFSET)
+#define PSC_AC97PCR		(AC97_PSC_BASE + PSC_AC97PCR_OFFSET)
+#define PSC_AC97STAT		(AC97_PSC_BASE + PSC_AC97STAT_OFFSET)
+#define PSC_AC97EVNT		(AC97_PSC_BASE + PSC_AC97EVNT_OFFSET)
+#define PSC_AC97TXRX		(AC97_PSC_BASE + PSC_AC97TXRX_OFFSET)
+#define PSC_AC97CDC		(AC97_PSC_BASE + PSC_AC97CDC_OFFSET)
+#define PSC_AC97RST		(AC97_PSC_BASE + PSC_AC97RST_OFFSET)
+#define PSC_AC97GPO		(AC97_PSC_BASE + PSC_AC97GPO_OFFSET)
+#define PSC_AC97GPI		(AC97_PSC_BASE + PSC_AC97GPI_OFFSET)
+
+/* AC97 Config Register.
+*/
+#define PSC_AC97CFG_RT_MASK	(3 << 30)
+#define PSC_AC97CFG_RT_FIFO1	(0 << 30)
+#define PSC_AC97CFG_RT_FIFO2	(1 << 30)
+#define PSC_AC97CFG_RT_FIFO4	(2 << 30)
+#define PSC_AC97CFG_RT_FIFO8	(3 << 30)
+
+#define PSC_AC97CFG_TT_MASK	(3 << 28)
+#define PSC_AC97CFG_TT_FIFO1	(0 << 28)
+#define PSC_AC97CFG_TT_FIFO2	(1 << 28)
+#define PSC_AC97CFG_TT_FIFO4	(2 << 28)
+#define PSC_AC97CFG_TT_FIFO8	(3 << 28)
+
+#define PSC_AC97CFG_DD_DISABLE	(1 << 27)
+#define PSC_AC97CFG_DE_ENABLE	(1 << 26)
+#define PSC_AC97CFG_SE_ENABLE	(1 << 25)
+
+#define PSC_AC97CFG_LEN_MASK	(0xf << 21)
+#define PSC_AC97CFG_TXSLOT_MASK	(0x3ff << 11)
+#define PSC_AC97CFG_RXSLOT_MASK	(0x3ff << 1)
+#define PSC_AC97CFG_GE_ENABLE	(1)
+
+/* Enable slots 3-12.
+*/
+#define PSC_AC97CFG_TXSLOT_ENA(x)	(1 << (((x) - 3) + 11))
+#define PSC_AC97CFG_RXSLOT_ENA(x)	(1 << (((x) - 3) + 1))
+
+/* The word length equation is ((x) * 2) + 2, so choose 'x' appropriately.
+ * The only sensible numbers are 7, 9, or possibly 11.  Nah, just do the
+ * arithmetic in the macro.
+ */
+#define PSC_AC97CFG_SET_LEN(x)	(((((x)-2)/2) & 0xf) << 21)
+#define PSC_AC97CFG_GET_LEN(x)	(((((x) >> 21) & 0xf) * 2) + 2)
+
+/* AC97 Mask Register.
+*/
+#define PSC_AC97MSK_GR		(1 << 25)
+#define PSC_AC97MSK_CD		(1 << 24)
+#define PSC_AC97MSK_RR		(1 << 13)
+#define PSC_AC97MSK_RO		(1 << 12)
+#define PSC_AC97MSK_RU		(1 << 11)
+#define PSC_AC97MSK_TR		(1 << 10)
+#define PSC_AC97MSK_TO		(1 << 9)
+#define PSC_AC97MSK_TU		(1 << 8)
+#define PSC_AC97MSK_RD		(1 << 5)
+#define PSC_AC97MSK_TD		(1 << 4)
+#define PSC_AC97MSK_ALLMASK	(PSC_AC97MSK_GR | PSC_AC97MSK_CD | \
+				 PSC_AC97MSK_RR | PSC_AC97MSK_RO | \
+				 PSC_AC97MSK_RU | PSC_AC97MSK_TR | \
+				 PSC_AC97MSK_TO | PSC_AC97MSK_TU | \
+				 PSC_AC97MSK_RD | PSC_AC97MSK_TD)
+
+/* AC97 Protocol Control Register.
+*/
+#define PSC_AC97PCR_RC		(1 << 6)
+#define PSC_AC97PCR_RP		(1 << 5)
+#define PSC_AC97PCR_RS		(1 << 4)
+#define PSC_AC97PCR_TC		(1 << 2)
+#define PSC_AC97PCR_TP		(1 << 1)
+#define PSC_AC97PCR_TS		(1 << 0)
+
+/* AC97 Status register (read only).
+*/
+#define PSC_AC97STAT_CB		(1 << 26)
+#define PSC_AC97STAT_CP		(1 << 25)
+#define PSC_AC97STAT_CR		(1 << 24)
+#define PSC_AC97STAT_RF		(1 << 13)
+#define PSC_AC97STAT_RE		(1 << 12)
+#define PSC_AC97STAT_RR		(1 << 11)
+#define PSC_AC97STAT_TF		(1 << 10)
+#define PSC_AC97STAT_TE		(1 << 9)
+#define PSC_AC97STAT_TR		(1 << 8)
+#define PSC_AC97STAT_RB		(1 << 5)
+#define PSC_AC97STAT_TB		(1 << 4)
+#define PSC_AC97STAT_DI		(1 << 2)
+#define PSC_AC97STAT_DR		(1 << 1)
+#define PSC_AC97STAT_SR		(1 << 0)
+
+/* AC97 Event Register.
+*/
+#define PSC_AC97EVNT_GR		(1 << 25)
+#define PSC_AC97EVNT_CD		(1 << 24)
+#define PSC_AC97EVNT_RR		(1 << 13)
+#define PSC_AC97EVNT_RO		(1 << 12)
+#define PSC_AC97EVNT_RU		(1 << 11)
+#define PSC_AC97EVNT_TR		(1 << 10)
+#define PSC_AC97EVNT_TO		(1 << 9)
+#define PSC_AC97EVNT_TU		(1 << 8)
+#define PSC_AC97EVNT_RD		(1 << 5)
+#define PSC_AC97EVNT_TD		(1 << 4)
+
+/* CODEC Command Register.
+*/
+#define PSC_AC97CDC_RD		(1 << 25)
+#define PSC_AC97CDC_ID_MASK	(3 << 23)
+#define PSC_AC97CDC_INDX_MASK	(0x7f << 16)
+#define PSC_AC97CDC_ID(x)	(((x) & 0x3) << 23)
+#define PSC_AC97CDC_INDX(x)	(((x) & 0x7f) << 16)
+
+/* AC97 Reset Control Register.
+*/
+#define PSC_AC97RST_RST		(1 << 1)
+#define PSC_AC97RST_SNC		(1 << 0)
+
+
+/* PSC in I2S Mode.
+*/
+typedef struct	psc_i2s {
+	u32	psc_sel;
+	u32	psc_ctrl;
+	u32	psc_i2scfg;
+	u32	psc_i2smsk;
+	u32	psc_i2spcr;
+	u32	psc_i2sstat;
+	u32	psc_i2sevent;
+	u32	psc_i2stxrx;
+	u32	psc_i2sudf;
+} psc_i2s_t;
+
+/* I2S Config Register.
+*/
+#define PSC_I2SCFG_RT_MASK	(3 << 30)
+#define PSC_I2SCFG_RT_FIFO1	(0 << 30)
+#define PSC_I2SCFG_RT_FIFO2	(1 << 30)
+#define PSC_I2SCFG_RT_FIFO4	(2 << 30)
+#define PSC_I2SCFG_RT_FIFO8	(3 << 30)
+
+#define PSC_I2SCFG_TT_MASK	(3 << 28)
+#define PSC_I2SCFG_TT_FIFO1	(0 << 28)
+#define PSC_I2SCFG_TT_FIFO2	(1 << 28)
+#define PSC_I2SCFG_TT_FIFO4	(2 << 28)
+#define PSC_I2SCFG_TT_FIFO8	(3 << 28)
+
+#define PSC_I2SCFG_DD_DISABLE	(1 << 27)
+#define PSC_I2SCFG_DE_ENABLE	(1 << 26)
+#define PSC_I2SCDC_SET_WS(x)	(((x) & 0xff) << 16)
+#define PSC_I2SCFG_WI		(1 << 15)
+
+#define PSC_I2SCFG_DIV_MASK	(3 << 13)
+#define PSC_I2SCFG_DIV2		(0 << 13)
+#define PSC_I2SCFG_DIV4		(1 << 13)
+#define PSC_I2SCFG_DIV8		(2 << 13)
+#define PSC_I2SCFG_DIV16	(3 << 13)
+
+#define PSC_I2SCFG_BI		(1 << 12)
+#define PSC_I2SCFG_BUF		(1 << 11)
+#define PSC_I2SCFG_MLJ		(1 << 10)
+#define PSC_I2SCFG_XM		(1 << 9)
+
+/* The word length equation is simply LEN+1.
+ */
+#define PSC_I2SCFG_SET_LEN(x)	((((x) - 1) & 0x1f) << 4)
+#define PSC_I2SCFG_GET_LEN(x)	((((x) >> 4) & 0x1f) + 1)
+
+#define PSC_I2SCFG_LB		(1 << 2)
+#define PSC_I2SCFG_MLF		(1 << 1)
+#define PSC_I2SCFG_MS		(1 << 0)
+
+/* I2S Mask Register.
+*/
+#define PSC_I2SMSK_RR		(1 << 13)
+#define PSC_I2SMSK_RO		(1 << 12)
+#define PSC_I2SMSK_RU		(1 << 11)
+#define PSC_I2SMSK_TR		(1 << 10)
+#define PSC_I2SMSK_TO		(1 << 9)
+#define PSC_I2SMSK_TU		(1 << 8)
+#define PSC_I2SMSK_RD		(1 << 5)
+#define PSC_I2SMSK_TD		(1 << 4)
+#define PSC_I2SMSK_ALLMASK	(PSC_I2SMSK_RR | PSC_I2SMSK_RO | \
+				 PSC_I2SMSK_RU | PSC_I2SMSK_TR | \
+				 PSC_I2SMSK_TO | PSC_I2SMSK_TU | \
+				 PSC_I2SMSK_RD | PSC_I2SMSK_TD)
+
+/* I2S Protocol Control Register.
+*/
+#define PSC_I2SPCR_RC		(1 << 6)
+#define PSC_I2SPCR_RP		(1 << 5)
+#define PSC_I2SPCR_RS		(1 << 4)
+#define PSC_I2SPCR_TC		(1 << 2)
+#define PSC_I2SPCR_TP		(1 << 1)
+#define PSC_I2SPCR_TS		(1 << 0)
+
+/* I2S Status register (read only).
+*/
+#define PSC_I2SSTAT_RF		(1 << 13)
+#define PSC_I2SSTAT_RE		(1 << 12)
+#define PSC_I2SSTAT_RR		(1 << 11)
+#define PSC_I2SSTAT_TF		(1 << 10)
+#define PSC_I2SSTAT_TE		(1 << 9)
+#define PSC_I2SSTAT_TR		(1 << 8)
+#define PSC_I2SSTAT_RB		(1 << 5)
+#define PSC_I2SSTAT_TB		(1 << 4)
+#define PSC_I2SSTAT_DI		(1 << 2)
+#define PSC_I2SSTAT_DR		(1 << 1)
+#define PSC_I2SSTAT_SR		(1 << 0)
+
+/* I2S Event Register.
+*/
+#define PSC_I2SEVNT_RR		(1 << 13)
+#define PSC_I2SEVNT_RO		(1 << 12)
+#define PSC_I2SEVNT_RU		(1 << 11)
+#define PSC_I2SEVNT_TR		(1 << 10)
+#define PSC_I2SEVNT_TO		(1 << 9)
+#define PSC_I2SEVNT_TU		(1 << 8)
+#define PSC_I2SEVNT_RD		(1 << 5)
+#define PSC_I2SEVNT_TD		(1 << 4)
+
+/* PSC in SPI Mode.
+*/
+typedef struct	psc_spi {
+	u32	psc_sel;
+	u32	psc_ctrl;
+	u32	psc_spicfg;
+	u32	psc_spimsk;
+	u32	psc_spipcr;
+	u32	psc_spistat;
+	u32	psc_spievent;
+	u32	psc_spitxrx;
+} psc_spi_t;
+
+/* SPI Config Register.
+*/
+#define PSC_SPICFG_RT_MASK	(3 << 30)
+#define PSC_SPICFG_RT_FIFO1	(0 << 30)
+#define PSC_SPICFG_RT_FIFO2	(1 << 30)
+#define PSC_SPICFG_RT_FIFO4	(2 << 30)
+#define PSC_SPICFG_RT_FIFO8	(3 << 30)
+
+#define PSC_SPICFG_TT_MASK	(3 << 28)
+#define PSC_SPICFG_TT_FIFO1	(0 << 28)
+#define PSC_SPICFG_TT_FIFO2	(1 << 28)
+#define PSC_SPICFG_TT_FIFO4	(2 << 28)
+#define PSC_SPICFG_TT_FIFO8	(3 << 28)
+
+#define PSC_SPICFG_DD_DISABLE	(1 << 27)
+#define PSC_SPICFG_DE_ENABLE	(1 << 26)
+#define PSC_SPICFG_CLR_BAUD(x)	((x) & ~((0x3f) << 15))
+#define PSC_SPICFG_SET_BAUD(x)	(((x) & 0x3f) << 15)
+
+#define PSC_SPICFG_SET_DIV(x)	(((x) & 0x03) << 13)
+#define PSC_SPICFG_DIV2		0
+#define PSC_SPICFG_DIV4		1
+#define PSC_SPICFG_DIV8		2
+#define PSC_SPICFG_DIV16	3
+
+#define PSC_SPICFG_BI		(1 << 12)
+#define PSC_SPICFG_PSE		(1 << 11)
+#define PSC_SPICFG_CGE		(1 << 10)
+#define PSC_SPICFG_CDE		(1 << 9)
+
+#define PSC_SPICFG_CLR_LEN(x)	((x) & ~((0x1f) << 4))
+#define PSC_SPICFG_SET_LEN(x)	(((x-1) & 0x1f) << 4)
+
+#define PSC_SPICFG_LB		(1 << 3)
+#define PSC_SPICFG_MLF		(1 << 1)
+#define PSC_SPICFG_MO		(1 << 0)
+
+/* SPI Mask Register.
+*/
+#define PSC_SPIMSK_MM		(1 << 16)
+#define PSC_SPIMSK_RR		(1 << 13)
+#define PSC_SPIMSK_RO		(1 << 12)
+#define PSC_SPIMSK_RU		(1 << 11)
+#define PSC_SPIMSK_TR		(1 << 10)
+#define PSC_SPIMSK_TO		(1 << 9)
+#define PSC_SPIMSK_TU		(1 << 8)
+#define PSC_SPIMSK_SD		(1 << 5)
+#define PSC_SPIMSK_MD		(1 << 4)
+#define PSC_SPIMSK_ALLMASK	(PSC_SPIMSK_MM | PSC_SPIMSK_RR | \
+				 PSC_SPIMSK_RO | PSC_SPIMSK_TO | \
+				 PSC_SPIMSK_TU | PSC_SPIMSK_SD | \
+				 PSC_SPIMSK_MD)
+
+/* SPI Protocol Control Register.
+*/
+#define PSC_SPIPCR_RC		(1 << 6)
+#define PSC_SPIPCR_SP		(1 << 5)
+#define PSC_SPIPCR_SS		(1 << 4)
+#define PSC_SPIPCR_TC		(1 << 2)
+#define PSC_SPIPCR_MS		(1 << 0)
+
+/* SPI Status register (read only).
+*/
+#define PSC_SPISTAT_RF		(1 << 13)
+#define PSC_SPISTAT_RE		(1 << 12)
+#define PSC_SPISTAT_RR		(1 << 11)
+#define PSC_SPISTAT_TF		(1 << 10)
+#define PSC_SPISTAT_TE		(1 << 9)
+#define PSC_SPISTAT_TR		(1 << 8)
+#define PSC_SPISTAT_SB		(1 << 5)
+#define PSC_SPISTAT_MB		(1 << 4)
+#define PSC_SPISTAT_DI		(1 << 2)
+#define PSC_SPISTAT_DR		(1 << 1)
+#define PSC_SPISTAT_SR		(1 << 0)
+
+/* SPI Event Register.
+*/
+#define PSC_SPIEVNT_MM		(1 << 16)
+#define PSC_SPIEVNT_RR		(1 << 13)
+#define PSC_SPIEVNT_RO		(1 << 12)
+#define PSC_SPIEVNT_RU		(1 << 11)
+#define PSC_SPIEVNT_TR		(1 << 10)
+#define PSC_SPIEVNT_TO		(1 << 9)
+#define PSC_SPIEVNT_TU		(1 << 8)
+#define PSC_SPIEVNT_SD		(1 << 5)
+#define PSC_SPIEVNT_MD		(1 << 4)
+
+/* Transmit register control.
+*/
+#define PSC_SPITXRX_LC		(1 << 29)
+#define PSC_SPITXRX_SR		(1 << 28)
+
+/* PSC in SMBus (I2C) Mode.
+*/
+typedef struct	psc_smb {
+	u32	psc_sel;
+	u32	psc_ctrl;
+	u32	psc_smbcfg;
+	u32	psc_smbmsk;
+	u32	psc_smbpcr;
+	u32	psc_smbstat;
+	u32	psc_smbevnt;
+	u32	psc_smbtxrx;
+	u32	psc_smbtmr;
+} psc_smb_t;
+
+/* SMBus Config Register.
+*/
+#define PSC_SMBCFG_RT_MASK	(3 << 30)
+#define PSC_SMBCFG_RT_FIFO1	(0 << 30)
+#define PSC_SMBCFG_RT_FIFO2	(1 << 30)
+#define PSC_SMBCFG_RT_FIFO4	(2 << 30)
+#define PSC_SMBCFG_RT_FIFO8	(3 << 30)
+
+#define PSC_SMBCFG_TT_MASK	(3 << 28)
+#define PSC_SMBCFG_TT_FIFO1	(0 << 28)
+#define PSC_SMBCFG_TT_FIFO2	(1 << 28)
+#define PSC_SMBCFG_TT_FIFO4	(2 << 28)
+#define PSC_SMBCFG_TT_FIFO8	(3 << 28)
+
+#define PSC_SMBCFG_DD_DISABLE	(1 << 27)
+#define PSC_SMBCFG_DE_ENABLE	(1 << 26)
+
+#define PSC_SMBCFG_SET_DIV(x)	(((x) & 0x03) << 13)
+#define PSC_SMBCFG_DIV2		0
+#define PSC_SMBCFG_DIV4		1
+#define PSC_SMBCFG_DIV8		2
+#define PSC_SMBCFG_DIV16	3
+
+#define PSC_SMBCFG_GCE		(1 << 9)
+#define PSC_SMBCFG_SFM		(1 << 8)
+
+#define PSC_SMBCFG_SET_SLV(x)	(((x) & 0x7f) << 1)
+
+/* SMBus Mask Register.
+*/
+#define PSC_SMBMSK_DN		(1 << 30)
+#define PSC_SMBMSK_AN		(1 << 29)
+#define PSC_SMBMSK_AL		(1 << 28)
+#define PSC_SMBMSK_RR		(1 << 13)
+#define PSC_SMBMSK_RO		(1 << 12)
+#define PSC_SMBMSK_RU		(1 << 11)
+#define PSC_SMBMSK_TR		(1 << 10)
+#define PSC_SMBMSK_TO		(1 << 9)
+#define PSC_SMBMSK_TU		(1 << 8)
+#define PSC_SMBMSK_SD		(1 << 5)
+#define PSC_SMBMSK_MD		(1 << 4)
+#define PSC_SMBMSK_ALLMASK	(PSC_SMBMSK_DN | PSC_SMBMSK_AN | \
+				 PSC_SMBMSK_AL | PSC_SMBMSK_RR | \
+				 PSC_SMBMSK_RO | PSC_SMBMSK_TO | \
+				 PSC_SMBMSK_TU | PSC_SMBMSK_SD | \
+				 PSC_SMBMSK_MD)
+
+/* SMBus Protocol Control Register.
+*/
+#define PSC_SMBPCR_DC		(1 << 2)
+#define PSC_SMBPCR_MS		(1 << 0)
+
+/* SMBus Status register (read only).
+*/
+#define PSC_SMBSTAT_BB		(1 << 28)
+#define PSC_SMBSTAT_RF		(1 << 13)
+#define PSC_SMBSTAT_RE		(1 << 12)
+#define PSC_SMBSTAT_RR		(1 << 11)
+#define PSC_SMBSTAT_TF		(1 << 10)
+#define PSC_SMBSTAT_TE		(1 << 9)
+#define PSC_SMBSTAT_TR		(1 << 8)
+#define PSC_SMBSTAT_SB		(1 << 5)
+#define PSC_SMBSTAT_MB		(1 << 4)
+#define PSC_SMBSTAT_DI		(1 << 2)
+#define PSC_SMBSTAT_DR		(1 << 1)
+#define PSC_SMBSTAT_SR		(1 << 0)
+
+/* SMBus Event Register.
+*/
+#define PSC_SMBEVNT_DN		(1 << 30)
+#define PSC_SMBEVNT_AN		(1 << 29)
+#define PSC_SMBEVNT_AL		(1 << 28)
+#define PSC_SMBEVNT_RR		(1 << 13)
+#define PSC_SMBEVNT_RO		(1 << 12)
+#define PSC_SMBEVNT_RU		(1 << 11)
+#define PSC_SMBEVNT_TR		(1 << 10)
+#define PSC_SMBEVNT_TO		(1 << 9)
+#define PSC_SMBEVNT_TU		(1 << 8)
+#define PSC_SMBEVNT_SD		(1 << 5)
+#define PSC_SMBEVNT_MD		(1 << 4)
+#define PSC_SMBEVNT_ALLCLR	(PSC_SMBEVNT_DN | PSC_SMBEVNT_AN | \
+				 PSC_SMBEVNT_AL | PSC_SMBEVNT_RR | \
+				 PSC_SMBEVNT_RO | PSC_SMBEVNT_TO | \
+				 PSC_SMBEVNT_TU | PSC_SMBEVNT_SD | \
+				 PSC_SMBEVNT_MD)
+
+/* Transmit register control.
+*/
+#define PSC_SMBTXRX_RSR		(1 << 30)
+#define PSC_SMBTXRX_STP		(1 << 29)
+#define PSC_SMBTXRX_DATAMASK	(0xff)
+
+/* SMBus protocol timers register.
+*/
+#define PSC_SMBTMR_SET_TH(x)	(((x) & 0x3) << 30)
+#define PSC_SMBTMR_SET_PS(x)	(((x) & 0x1f) << 25)
+#define PSC_SMBTMR_SET_PU(x)	(((x) & 0x1f) << 20)
+#define PSC_SMBTMR_SET_SH(x)	(((x) & 0x1f) << 15)
+#define PSC_SMBTMR_SET_SU(x)	(((x) & 0x1f) << 10)
+#define PSC_SMBTMR_SET_CL(x)	(((x) & 0x1f) << 5)
+#define PSC_SMBTMR_SET_CH(x)	(((x) & 0x1f) << 0)
+
+
+#endif /* _AU1000_PSC_H_ */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/checksum.h linux-mips-cvs-20040815/include/asm-mips/checksum.h
--- linux-2.4.27/include/asm-mips/checksum.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/checksum.h	2004-05-05 14:39:08.000000000 +0200
@@ -123,10 +123,6 @@ static inline unsigned short ip_fast_csu
 	return csum_fold(csum);
 }
 
-/*
- * computes the checksum of the TCP/UDP pseudo-header
- * returns a 16-bit checksum, already complemented
- */
 static inline unsigned long csum_tcpudp_nofold(unsigned long saddr,
                                                unsigned long daddr,
                                                unsigned short len,
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/cpu.h linux-mips-cvs-20040815/include/asm-mips/cpu.h
--- linux-2.4.27/include/asm-mips/cpu.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/cpu.h	2004-08-15 08:06:47.000000000 +0200
@@ -173,7 +173,8 @@
 #define CPU_VR4133		56
 #define CPU_AU1550		57
 #define CPU_24K			58
-#define CPU_LAST		58
+#define CPU_AU1200		59
+#define CPU_LAST		59
 
 /*
  * ISA Level encodings
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/db1x00.h linux-mips-cvs-20040815/include/asm-mips/db1x00.h
--- linux-2.4.27/include/asm-mips/db1x00.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/db1x00.h	2004-08-15 08:06:47.000000000 +0200
@@ -27,21 +27,42 @@
 #ifndef __ASM_DB1X00_H
 #define __ASM_DB1X00_H
 
+#ifdef CONFIG_MIPS_DB1550
+#define BCSR_KSEG1_ADDR 0xAF000000
+#define NAND_PHYS_ADDR   0x20000000
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC2_BASE_ADDR
+#define I2S_PSC_BASE        PSC3_BASE_ADDR
+
+#else
+#define BCSR_KSEG1_ADDR 0xAE000000
+#endif
 
 /*
  * Overlay data structure of the Db1x00 board registers.
- * Registers located at physical 1E0000xx, KSEG1 0xAE0000xx
+ * Registers located at physical 0E0000xx, KSEG1 0xAE0000xx
  */
 typedef volatile struct
 {
-	/*00*/	unsigned long whoami;
-	/*04*/	unsigned long status;
-	/*08*/	unsigned long switches;
-	/*0C*/	unsigned long resets;
-	/*10*/	unsigned long pcmcia;
-	/*14*/	unsigned long specific;
-	/*18*/	unsigned long leds;
-	/*1C*/	unsigned long swreset;
+	/*00*/	unsigned short whoami;
+			unsigned short reserved0;
+	/*04*/	unsigned short status;
+			unsigned short reserved1;
+	/*08*/	unsigned short switches;
+			unsigned short reserved2;
+	/*0C*/	unsigned short resets;
+			unsigned short reserved3;
+	/*10*/	unsigned short pcmcia;
+			unsigned short reserved4;
+	/*14*/	unsigned short specific;
+			unsigned short reserved5;
+	/*18*/	unsigned short leds;
+			unsigned short reserved6;
+	/*1C*/	unsigned short swreset;
+			unsigned short reserved7;
 
 } BCSR;
 
@@ -93,9 +114,13 @@ typedef volatile struct
 #define BCSR_PCMCIA_PC1RST		0x8000
 
 #define BCSR_BOARD_PCIM66EN		0x0001
+#define BCSR_BOARD_SD0_PWR		0x0040
+#define BCSR_BOARD_SD1_PWR		0x0080
 #define BCSR_BOARD_PCIM33		0x0100
 #define BCSR_BOARD_GPIO200RST		0x0400
 #define BCSR_BOARD_PCICFG		0x1000
+#define BCSR_BOARD_SD0_WP		0x4000
+#define BCSR_BOARD_SD1_WP		0x8000
 
 #define BCSR_LEDS_DECIMALS		0x0003
 #define BCSR_LEDS_LED0			0x0100
@@ -122,4 +147,48 @@ typedef volatile struct
 #define DB1X00_USER_ONLY
 #endif
 
+/* SD controller macros */
+/*
+ * Detect card.
+ */
+#define mmc_card_inserted(_n_, _res_) \
+	do { \
+		BCSR * const bcsr = (BCSR *)0xAE000000; \
+		unsigned long mmc_wp, board_specific; \
+		if ((_n_)) { \
+			mmc_wp = BCSR_BOARD_SD1_WP; \
+		} else { \
+			mmc_wp = BCSR_BOARD_SD0_WP; \
+		} \
+		board_specific = au_readl((unsigned long)(&bcsr->specific)); \
+		if (!(board_specific & mmc_wp)) {/* low means card present */ \
+			*(int *)(_res_) = 1; \
+		} else { \
+			*(int *)(_res_) = 0; \
+		} \
+	} while (0)
+
+/*
+ * Apply power to card slot(s).
+ */
+#define mmc_power_on(_n_) \
+	do { \
+		BCSR * const bcsr = (BCSR *)0xAE000000; \
+		unsigned long mmc_pwr, mmc_wp, board_specific; \
+		if ((_n_)) { \
+			mmc_pwr = BCSR_BOARD_SD1_PWR; \
+			mmc_wp = BCSR_BOARD_SD1_WP; \
+		} else { \
+			mmc_pwr = BCSR_BOARD_SD0_PWR; \
+			mmc_wp = BCSR_BOARD_SD0_WP; \
+		} \
+		board_specific = au_readl((unsigned long)(&bcsr->specific)); \
+		if (!(board_specific & mmc_wp)) {/* low means card present */ \
+			board_specific |= mmc_pwr; \
+			au_writel(board_specific, (int)(&bcsr->specific)); \
+			au_sync(); \
+		} \
+	} while (0)
+
 #endif /* __ASM_DB1X00_H */
+
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/dec/prom.h linux-mips-cvs-20040815/include/asm-mips/dec/prom.h
--- linux-2.4.27/include/asm-mips/dec/prom.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/dec/prom.h	2004-02-11 16:17:09.000000000 +0100
@@ -164,4 +164,7 @@ extern void prom_meminit(u32);
 extern void prom_identify_arch(u32);
 extern void prom_init_cmdline(s32, s32 *, u32);
 
+extern void register_prom_console(void);
+extern void unregister_prom_console(void);
+
 #endif /* __ASM_DEC_PROM_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/dec/serial.h linux-mips-cvs-20040815/include/asm-mips/dec/serial.h
--- linux-2.4.27/include/asm-mips/dec/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/dec/serial.h	2004-07-01 15:28:56.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *	include/asm-mips/dec/serial.h
+ *
+ *	Definitions common to all DECstation serial devices.
+ *
+ *	Copyright (C) 2004  Maciej W. Rozycki
+ *
+ *	Based on bits extracted from drivers/tc/zs.h for which
+ *	the following copyrights apply:
+ *
+ *	Copyright (C) 1995  David S. Miller (davem@caip.rutgers.edu)
+ *	Copyright (C) 1996  Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
+ *	Copyright (C)       Harald Koerfgen
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_MIPS_DEC_SERIAL_H
+#define __ASM_MIPS_DEC_SERIAL_H
+
+struct dec_serial_hook {
+	int (*init_channel)(void *handle);
+	void (*init_info)(void *handle);
+	void (*rx_char)(unsigned char ch, unsigned char fl);
+	int (*poll_rx_char)(void *handle);
+	int (*poll_tx_char)(void *handle, unsigned char ch);
+	unsigned int cflags;
+};
+
+extern int register_dec_serial_hook(unsigned int channel,
+				    struct dec_serial_hook *hook);
+extern int unregister_dec_serial_hook(unsigned int channel);
+
+#endif /* __ASM_MIPS_DEC_SERIAL_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/mipsregs.h linux-mips-cvs-20040815/include/asm-mips/mipsregs.h
--- linux-2.4.27/include/asm-mips/mipsregs.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/mipsregs.h	2004-08-15 08:06:47.000000000 +0200
@@ -632,6 +632,24 @@ do {									\
 } while (0)
 
 /*
+ * On RM7000/RM9000 these are uses to access cop0 set 1 registers
+ */
+#define __read_32bit_c0_ctrl_register(source)				\
+({ int __res;								\
+	__asm__ __volatile__(						\
+		"cfc0\t%0, " #source "\n\t"				\
+		: "=r" (__res));					\
+	__res;								\
+})
+
+#define __write_32bit_c0_ctrl_register(register, value)			\
+do {									\
+	__asm__ __volatile__(						\
+		"ctc0\t%z0, " #register "\n\t"				\
+		: : "Jr" ((unsigned int)value));			\
+} while (0)
+
+/*
  * These versions are only needed for systems with more than 38 bits of
  * physical address space running the 32-bit kernel.  That's none atm :-)
  */
@@ -788,12 +806,30 @@ do {									\
 #define read_c0_xcontext()	__read_ulong_c0_register($20, 0)
 #define write_c0_xcontext(val)	__write_ulong_c0_register($20, 0, val)
 
-#define read_c0_intcontrol()	__read_32bit_c0_register($20, 1)
-#define write_c0_intcontrol(val) __write_32bit_c0_register($20, 1, val)
+#define read_c0_intcontrol()	__read_32bit_c0_ctrl_register($20)
+#define write_c0_intcontrol(val) __write_32bit_c0_ctrl_register($20, val)
 
 #define read_c0_framemask()	__read_32bit_c0_register($21, 0)
 #define write_c0_framemask(val)	__write_32bit_c0_register($21, 0, val)
 
+#define read_c0_diag()		__read_32bit_c0_register($22, 0)
+#define write_c0_diag(val)	__write_32bit_c0_register($22, 0, val)
+
+#define read_c0_diag1()		__read_32bit_c0_register($22, 1)
+#define write_c0_diag1(val)	__write_32bit_c0_register($22, 1, val)
+
+#define read_c0_diag2()		__read_32bit_c0_register($22, 2)
+#define write_c0_diag2(val)	__write_32bit_c0_register($22, 2, val)
+
+#define read_c0_diag3()		__read_32bit_c0_register($22, 3)
+#define write_c0_diag3(val)	__write_32bit_c0_register($22, 3, val)
+
+#define read_c0_diag4()		__read_32bit_c0_register($22, 4)
+#define write_c0_diag4(val)	__write_32bit_c0_register($22, 4, val)
+
+#define read_c0_diag5()		__read_32bit_c0_register($22, 5)
+#define write_c0_diag5(val)	__write_32bit_c0_register($22, 5, val)
+
 #define read_c0_debug()		__read_32bit_c0_register($23, 0)
 #define write_c0_debug(val)	__write_32bit_c0_register($23, 0, val)
 
@@ -879,7 +915,7 @@ static inline void tlb_write_random(void
 /*
  * Manipulate bits in a c0 register.
  */
-#define __BUILD_SET_C0(name,register)				\
+#define __BUILD_SET_C0(name)					\
 static inline unsigned int					\
 set_c0_##name(unsigned int set)					\
 {								\
@@ -917,9 +953,10 @@ change_c0_##name(unsigned int change, un
 	return res;						\
 }
 
-__BUILD_SET_C0(status,CP0_STATUS)
-__BUILD_SET_C0(cause,CP0_CAUSE)
-__BUILD_SET_C0(config,CP0_CONFIG)
+__BUILD_SET_C0(status)
+__BUILD_SET_C0(cause)
+__BUILD_SET_C0(config)
+__BUILD_SET_C0(intcontrol)
 
 #endif /* !__ASSEMBLY__ */
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/mmu_context.h linux-mips-cvs-20040815/include/asm-mips/mmu_context.h
--- linux-2.4.27/include/asm-mips/mmu_context.h	2003-08-25 13:44:43.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/mmu_context.h	2004-02-25 14:05:49.000000000 +0100
@@ -33,13 +33,18 @@ extern unsigned long pgd_current[];
 
 #define cpu_context(cpu, mm)	((mm)->context[cpu])
 #define cpu_asid(cpu, mm)	(cpu_context((cpu), (mm)) & ASID_MASK)
-#define asid_cache(cpu)		cpu_data[cpu].asid_cache
+#define asid_cache(cpu)		(cpu_data[cpu].asid_cache)
 
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 
 #define ASID_INC	0x40
 #define ASID_MASK	0xfc0
 
+#elif defined(CONFIG_CPU_RM9000)
+
+#define ASID_INC	0x1
+#define ASID_MASK	0xfff
+
 #else /* FIXME: not correct for R6000, R8000 */
 
 #define ASID_INC	0x1
@@ -136,7 +141,7 @@ activate_mm(struct mm_struct *prev, stru
 	write_c0_entryhi(cpu_context(cpu, next));
 	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
 
-	/* mark mmu ownership change */	
+	/* mark mmu ownership change */
 	clear_bit(cpu, &prev->cpu_vm_mask);
 	set_bit(cpu, &next->cpu_vm_mask);
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/pb1550.h linux-mips-cvs-20040815/include/asm-mips/pb1550.h
--- linux-2.4.27/include/asm-mips/pb1550.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/pb1550.h	2004-08-15 08:06:47.000000000 +0200
@@ -0,0 +1,165 @@
+/*
+ * AMD Alchemy Semi PB1550 Referrence Board
+ * Board Registers defines.
+ *
+ * Copyright 2004 Embedded Edge LLC.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ *
+ */
+#ifndef __ASM_PB1550_H
+#define __ASM_PB1550_H
+
+#include <linux/types.h>
+
+#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
+#define SPI_PSC_BASE        PSC0_BASE_ADDR
+#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define SMBUS_PSC_BASE      PSC2_BASE_ADDR
+#define I2S_PSC_BASE        PSC3_BASE_ADDR
+
+#define BCSR_PHYS_ADDR 0xAF000000
+
+typedef volatile struct
+{
+	/*00*/	u16 whoami;
+		u16 reserved0;
+	/*04*/	u16 status;
+		u16 reserved1;
+	/*08*/	u16 switches;
+		u16 reserved2;
+	/*0C*/	u16 resets;
+		u16 reserved3;
+	/*10*/	u16 pcmcia;
+		u16 reserved4;
+	/*14*/	u16 pci;
+		u16 reserved5;
+	/*18*/	u16 leds;
+		u16 reserved6;
+	/*1C*/	u16 system;
+		u16 reserved7;
+
+} BCSR;
+
+static BCSR * const bcsr = (BCSR *)BCSR_PHYS_ADDR;
+
+/*
+ * Register bit definitions for the BCSRs
+ */
+#define BCSR_WHOAMI_DCID	0x000F
+#define BCSR_WHOAMI_CPLD	0x00F0
+#define BCSR_WHOAMI_BOARD	0x0F00
+
+#define BCSR_STATUS_PCMCIA0VS	0x0003
+#define BCSR_STATUS_PCMCIA1VS	0x000C
+#define BCSR_STATUS_PCMCIA0FI	0x0010
+#define BCSR_STATUS_PCMCIA1FI	0x0020
+#define BCSR_STATUS_SWAPBOOT	0x0040
+#define BCSR_STATUS_SRAMWIDTH	0x0080
+#define BCSR_STATUS_FLASHBUSY	0x0100
+#define BCSR_STATUS_ROMBUSY	0x0200
+#define BCSR_STATUS_USBOTGID	0x0800
+#define BCSR_STATUS_U0RXD	0x1000
+#define BCSR_STATUS_U1RXD	0x2000
+#define BCSR_STATUS_U3RXD	0x8000
+
+#define BCSR_SWITCHES_OCTAL	0x00FF
+#define BCSR_SWITCHES_DIP_1	0x0080
+#define BCSR_SWITCHES_DIP_2	0x0040
+#define BCSR_SWITCHES_DIP_3	0x0020
+#define BCSR_SWITCHES_DIP_4	0x0010
+#define BCSR_SWITCHES_DIP_5	0x0008
+#define BCSR_SWITCHES_DIP_6	0x0004
+#define BCSR_SWITCHES_DIP_7	0x0002
+#define BCSR_SWITCHES_DIP_8	0x0001
+#define BCSR_SWITCHES_ROTARY	0x0F00
+
+#define BCSR_RESETS_PHY0	0x0001
+#define BCSR_RESETS_PHY1	0x0002
+#define BCSR_RESETS_DC		0x0004
+#define BCSR_RESETS_WSC		0x2000
+#define BCSR_RESETS_SPISEL	0x4000
+#define BCSR_RESETS_DMAREQ	0x8000
+
+#define BCSR_PCMCIA_PC0VPP	0x0003
+#define BCSR_PCMCIA_PC0VCC	0x000C
+#define BCSR_PCMCIA_PC0DRVEN	0x0010
+#define BCSR_PCMCIA_PC0RST	0x0080
+#define BCSR_PCMCIA_PC1VPP	0x0300
+#define BCSR_PCMCIA_PC1VCC	0x0C00
+#define BCSR_PCMCIA_PC1DRVEN	0x1000
+#define BCSR_PCMCIA_PC1RST	0x8000
+
+#define BCSR_PCI_M66EN		0x0001
+#define BCSR_PCI_M33		0x0100
+#define BCSR_PCI_EXTERNARB	0x0200
+#define BCSR_PCI_GPIO200RST	0x0400
+#define BCSR_PCI_CLKOUT		0x0800
+#define BCSR_PCI_CFGHOST	0x1000
+
+#define BCSR_LEDS_DECIMALS	0x00FF
+#define BCSR_LEDS_LED0		0x0100
+#define BCSR_LEDS_LED1		0x0200
+#define BCSR_LEDS_LED2		0x0400
+#define BCSR_LEDS_LED3		0x0800
+
+#define BCSR_SYSTEM_VDDI	0x001F
+#define BCSR_SYSTEM_POWEROFF	0x4000
+#define BCSR_SYSTEM_RESET	0x8000
+
+#define PCMCIA_MAX_SOCK 1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT)\
+	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+
+#if defined(CONFIG_MTD_PB1550_BOOT) && defined(CONFIG_MTD_PB1550_USER)
+#define PB1550_BOTH_BANKS
+#elif defined(CONFIG_MTD_PB1550_BOOT) && !defined(CONFIG_MTD_PB1550_USER)
+#define PB1550_BOOT_ONLY
+#elif !defined(CONFIG_MTD_PB1550_BOOT) && defined(CONFIG_MTD_PB1550_USER)
+#define PB1550_USER_ONLY
+#endif
+
+#define NAND_PHYS_ADDR   0x20000000
+/* Timing values as described in databook, * ns value stripped of 
+ * lower 2 bits.
+ * These defines are here rather than an SOC1550 generic file because 
+ * the parts chosen on another board may be different and may require 
+ * different timings.
+ */
+#define NAND_T_H			(18 >> 2)
+#define NAND_T_PUL			(30 >> 2)
+#define NAND_T_SU			(30 >> 2)
+#define NAND_T_WH			(30 >> 2)
+
+/* Bitfield shift amounts */
+#define NAND_T_H_SHIFT		0
+#define NAND_T_PUL_SHIFT	4
+#define NAND_T_SU_SHIFT		8
+#define NAND_T_WH_SHIFT		12
+
+#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
+			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
+			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
+			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+
+#endif /* __ASM_PB1550_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/pgtable-bits.h linux-mips-cvs-20040815/include/asm-mips/pgtable-bits.h
--- linux-2.4.27/include/asm-mips/pgtable-bits.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/pgtable-bits.h	2004-03-03 06:27:47.000000000 +0100
@@ -49,6 +49,10 @@
 #define _PAGE_SILENT_WRITE          (1<<2)
 #define _CACHE_MASK                 (7<<3)
 
+#ifdef CONFIG_SOC_AU1X00
+#define _CACHE_CACHABLE_COW         (3<<3)
+#endif
+
 /* MIPS32 defines only values 2 and 3. The rest are implementation
  * dependent.
  */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/prefetch.h linux-mips-cvs-20040815/include/asm-mips/prefetch.h
--- linux-2.4.27/include/asm-mips/prefetch.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/prefetch.h	2004-03-05 03:18:15.000000000 +0100
@@ -21,8 +21,9 @@
  * RM7000 version 1.0 interprets all hints as Pref_Load; version 2.0 implements
  * Pref_PrepareForStore also.
  *
- * RM9000 is MIPS IV but implements prefetching like MIPS32/MIPS64;
- * it's Pref_WriteBackInvalidate is a nop.
+ * RM9000 is MIPS IV but implements prefetching like MIPS32/MIPS64; it's
+ * Pref_WriteBackInvalidate is a nop and Pref_PrepareForStore is broken in
+ * current versions due to erratum G105.
  *
  * VR7701 only implements the Load prefetch.
  *
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/processor.h linux-mips-cvs-20040815/include/asm-mips/processor.h
--- linux-2.4.27/include/asm-mips/processor.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/processor.h	2004-01-31 03:52:42.000000000 +0100
@@ -96,6 +96,8 @@ struct cpuinfo_mips {
 #define cpu_has_dc_aliases	(cpu_data[0].dcache.flags & MIPS_CACHE_ALIASES)
 #define cpu_has_ic_fills_f_dc	(cpu_data[0].dcache.flags & MIPS_CACHE_IC_F_DC)
 #define cpu_has_64bits		(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
+#define cpu_has_64bit_zero_reg	(cpu_data[0].isa_level & MIPS_CPU_ISA_64BIT)
+#define cpu_has_64bit_gp_regs	0
 #define cpu_has_64bit_addresses	0
 #define cpu_has_subset_pcaches	(cpu_data[0].options & MIPS_CPU_SUBSET_CACHES)
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/serial.h linux-mips-cvs-20040815/include/asm-mips/serial.h
--- linux-2.4.27/include/asm-mips/serial.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/serial.h	2004-08-15 08:06:47.000000000 +0200
@@ -160,6 +160,7 @@
 
 #ifdef CONFIG_AU1X00_UART
 #include <asm/au1000.h>
+#ifdef CONFIG_SOC_AU1000
 #define AU1000_SERIAL_PORT_DEFNS                              \
     { .baud_base = 0, .port = UART0_ADDR, .irq = AU1000_UART0_INT,  \
       .flags = STD_COM_FLAGS, .type = 1 },                        \
@@ -169,6 +170,44 @@
       .flags = STD_COM_FLAGS, .type = 1 },    \
     { .baud_base = 0, .port = UART3_ADDR, .irq = AU1000_UART3_INT,  \
       .flags = STD_COM_FLAGS, .type = 1 },
+#endif
+
+#ifdef CONFIG_SOC_AU1500
+#define AU1000_SERIAL_PORT_DEFNS                              \
+    { .baud_base = 0, .port = UART0_ADDR, .irq = AU1500_UART0_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },                        \
+    { .baud_base = 0, .port = UART3_ADDR, .irq = AU1500_UART3_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },
+#endif
+
+#ifdef CONFIG_SOC_AU1100
+#define AU1000_SERIAL_PORT_DEFNS                              \
+    { .baud_base = 0, .port = UART0_ADDR, .irq = AU1100_UART0_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },                        \
+    { .baud_base = 0, .port = UART1_ADDR, .irq = AU1100_UART1_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },     \
+    { .baud_base = 0, .port = UART3_ADDR, .irq = AU1100_UART3_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },
+#endif
+
+#ifdef CONFIG_SOC_AU1550
+#define AU1000_SERIAL_PORT_DEFNS                              \
+    { .baud_base = 0, .port = UART0_ADDR, .irq = AU1550_UART0_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },                        \
+    { .baud_base = 0, .port = UART1_ADDR, .irq = AU1550_UART1_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },     \
+    { .baud_base = 0, .port = UART3_ADDR, .irq = AU1550_UART3_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },
+#endif
+
+#ifdef CONFIG_SOC_AU1200
+#define AU1000_SERIAL_PORT_DEFNS                              \
+    { .baud_base = 0, .port = UART0_ADDR, .irq = AU1200_UART0_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },                        \
+    { .baud_base = 0, .port = UART1_ADDR, .irq = AU1200_UART1_INT,  \
+      .flags = STD_COM_FLAGS, .type = 1 },
+#endif
+
 #else
 #define AU1000_SERIAL_PORT_DEFNS
 #endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/smp.h linux-mips-cvs-20040815/include/asm-mips/smp.h
--- linux-2.4.27/include/asm-mips/smp.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/smp.h	2004-05-02 00:48:41.000000000 +0200
@@ -106,7 +106,7 @@ void core_send_ipi(int cpu, unsigned int
  * Clear all undefined state in the cpu, set up sp and gp to the passed
  * values, and kick the cpu into smp_bootstrap();
  */
-void prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp);
+int prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp);
 
 /*
  *  After we've done initial boot, this function is called to allow the
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/unaligned.h linux-mips-cvs-20040815/include/asm-mips/unaligned.h
--- linux-2.4.27/include/asm-mips/unaligned.h	2002-11-29 00:53:15.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/unaligned.h	2004-08-15 08:06:47.000000000 +0200
@@ -3,157 +3,142 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 1999, 2000 by Ralf Baechle
- * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 1996, 1999, 2000, 2001, 2003 by Ralf Baechle
+ * Copyright (C) 1999, 2000, 2001 Silicon Graphics, Inc.
  */
 #ifndef _ASM_UNALIGNED_H
 #define _ASM_UNALIGNED_H
 
-extern void __get_unaligned_bad_length(void);
-extern void __put_unaligned_bad_length(void);
+#include <linux/types.h>
 
 /*
- * Load double unaligned.
+ * get_unaligned - get value from possibly mis-aligned location
+ * @ptr: pointer to value
+ *
+ * This macro should be used for accessing values larger in size than
+ * single bytes at locations that are expected to be improperly aligned,
+ * e.g. retrieving a u16 value from a location not u16-aligned.
  *
- * This could have been implemented in plain C like IA64 but egcs 1.0.3a
- * inflates this to 23 instructions ...
+ * Note that unaligned accesses can be very expensive on some architectures.
  */
-static inline unsigned long long __ldq_u(const unsigned long long * __addr)
-{
-	unsigned long long __res;
+#define get_unaligned(ptr) \
+	((__typeof__(*(ptr)))__get_unaligned((ptr), sizeof(*(ptr))))
 
-	__asm__("ulw\t%0, %1\n\t"
-		"ulw\t%D0, 4+%1"
-		: "=&r" (__res)
-		: "m" (*__addr));
-
-	return __res;
-}
+/*
+ * put_unaligned - put value to a possibly mis-aligned location
+ * @val: value to place
+ * @ptr: pointer to location
+ *
+ * This macro should be used for placing values larger in size than
+ * single bytes at locations that are expected to be improperly aligned,
+ * e.g. writing a u16 value to a location not u16-aligned.
+ *
+ * Note that unaligned accesses can be very expensive on some architectures.
+ */
+#define put_unaligned(x,ptr) \
+	__put_unaligned((__u64)(x), (ptr), sizeof(*(ptr)))
 
 /*
- * Load word unaligned.
+ * This is a silly but good way to make sure that
+ * the get/put functions are indeed always optimized,
+ * and that we use the correct sizes.
  */
-static inline unsigned long __ldl_u(const unsigned int * __addr)
-{
-	unsigned long __res;
+extern void bad_unaligned_access_length(void);
 
-	__asm__("ulw\t%0,%1"
-		: "=&r" (__res)
-		: "m" (*__addr));
+/*
+ * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
+ * packed structures to talk about such things with.
+ */
 
-	return __res;
-}
+struct __una_u64 { __u64 x __attribute__((packed)); };
+struct __una_u32 { __u32 x __attribute__((packed)); };
+struct __una_u16 { __u16 x __attribute__((packed)); };
 
 /*
- * Load halfword unaligned.
+ * Elemental unaligned loads
  */
-static inline unsigned long __ldw_u(const unsigned short * __addr)
+
+static inline __u64 __uldq(const __u64 * r11)
 {
-	unsigned long __res;
+	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
+	return ptr->x;
+}
 
-	__asm__("ulh\t%0,%1"
-		: "=&r" (__res)
-		: "m" (*__addr));
+static inline __u32 __uldl(const __u32 * r11)
+{
+	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
+	return ptr->x;
+}
 
-	return __res;
+static inline __u16 __uldw(const __u16 * r11)
+{
+	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
+	return ptr->x;
 }
 
 /*
- * Store doubleword ununaligned.
+ * Elemental unaligned stores
  */
-static inline void __stq_u(unsigned long __val, unsigned long long * __addr)
+
+static inline void __ustq(__u64 r5, __u64 * r11)
 {
-	__asm__("usw\t%1, %0\n\t"
-		"usw\t%D1, 4+%0"
-		: "=m" (*__addr)
-		: "r" (__val));
+	struct __una_u64 *ptr = (struct __una_u64 *) r11;
+	ptr->x = r5;
 }
 
-/*
- * Store long ununaligned.
- */
-static inline void __stl_u(unsigned long __val, unsigned int * __addr)
+static inline void __ustl(__u32 r5, __u32 * r11)
 {
-	__asm__("usw\t%1, %0"
-		: "=m" (*__addr)
-		: "r" (__val));
+	struct __una_u32 *ptr = (struct __una_u32 *) r11;
+	ptr->x = r5;
 }
 
-/*
- * Store word ununaligned.
- */
-static inline void __stw_u(unsigned long __val, unsigned short * __addr)
+static inline void __ustw(__u16 r5, __u16 * r11)
 {
-	__asm__("ush\t%1, %0"
-		: "=m" (*__addr)
-		: "r" (__val));
+	struct __una_u16 *ptr = (struct __una_u16 *) r11;
+	ptr->x = r5;
 }
 
-/*
- * get_unaligned - get value from possibly mis-aligned location
- * @ptr: pointer to value
- *
- * This macro should be used for accessing values larger in size than
- * single bytes at locations that are expected to be improperly aligned,
- * e.g. retrieving a u16 value from a location not u16-aligned.
- *
- * Note that unaligned accesses can be very expensive on some architectures.
- */
-#define get_unaligned(ptr)						\
-({									\
-	__typeof__(*(ptr)) __val;					\
-									\
-	switch (sizeof(*(ptr))) {					\
-	case 1:								\
-		__val = *(const unsigned char *)ptr;			\
-		break;							\
-	case 2:								\
-		__val = __ldw_u((const unsigned short *)ptr);		\
-		break;							\
-	case 4:								\
-		__val = __ldl_u((const unsigned int *)ptr);		\
-		break;							\
-	case 8:								\
-		__val = __ldq_u((const unsigned long long *)ptr);	\
-		break;							\
-	default:							\
-		__get_unaligned_bad_length();				\
-		break;							\
-	}								\
-									\
-	__val;								\
-})
+static inline __u64 __get_unaligned(const void *ptr, size_t size)
+{
+	__u64 val;
 
-/*
- * put_unaligned - put value to a possibly mis-aligned location
- * @val: value to place
- * @ptr: pointer to location
- *
- * This macro should be used for placing values larger in size than
- * single bytes at locations that are expected to be improperly aligned,
- * e.g. writing a u16 value to a location not u16-aligned.
- *
- * Note that unaligned accesses can be very expensive on some architectures.
- */
-#define put_unaligned(val,ptr)						\
-do {									\
-	switch (sizeof(*(ptr))) {					\
-	case 1:								\
-		*(unsigned char *)(ptr) = (val);			\
-		break;							\
-	case 2:								\
-		__stw_u(val, (unsigned short *)(ptr));			\
-		break;							\
-	case 4:								\
-		__stl_u(val, (unsigned int *)(ptr));			\
-		break;							\
-	case 8:								\
-		__stq_u(val, (unsigned long long *)(ptr));		\
-		break;							\
-	default:							\
-		__put_unaligned_bad_length();				\
-		break;							\
-	}								\
-} while(0)
+	switch (size) {
+	case 1:
+		val = *(const __u8 *)ptr;
+		break;
+	case 2:
+		val = __uldw((const __u16 *)ptr);
+		break;
+	case 4:
+		val = __uldl((const __u32 *)ptr);
+		break;
+	case 8:
+		val = __uldq((const __u64 *)ptr);
+		break;
+	default:
+		bad_unaligned_access_length();
+	}
+	return val;
+}
+
+static inline void __put_unaligned(__u64 val, void *ptr, size_t size)
+{
+	switch (size) {
+	      case 1:
+		*(__u8 *)ptr = (val);
+	        break;
+	      case 2:
+		__ustw(val, (__u16 *)ptr);
+		break;
+	      case 4:
+		__ustl(val, (__u32 *)ptr);
+		break;
+	      case 8:
+		__ustq(val, (__u64 *)ptr);
+		break;
+	      default:
+	    	bad_unaligned_access_length();
+	}
+}
 
 #endif /* _ASM_UNALIGNED_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/unistd.h linux-mips-cvs-20040815/include/asm-mips/unistd.h
--- linux-2.4.27/include/asm-mips/unistd.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/unistd.h	2004-05-02 00:48:41.000000000 +0200
@@ -863,7 +863,7 @@ type name(atype a, btype b, ctype c, dty
 	return -1; \
 }
 
-#if (_MIPS_SIM == _MIPS_SIM_ABIN32)
+#if (_MIPS_SIM == _MIPS_SIM_ABI32)
 
 /*
  * Using those means your brain needs more than an oil change ;-)
@@ -931,9 +931,9 @@ type name(atype a, btype b, ctype c, dty
 	return -1; \
 }
 
-#endif /* (_MIPS_SIM == _MIPS_SIM_ABIN32) */
+#endif /* (_MIPS_SIM == _MIPS_SIM_ABI32) */
 
-#if (_MIPS_SIM == _MIPS_SIM_NABIN32) || (_MIPS_SIM == _MIPS_SIM_ABI64)
+#if (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64)
 
 #define _syscall5(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e) \
 type name (atype a,btype b,ctype c,dtype d,etype e) \
@@ -989,7 +989,7 @@ type name (atype a,btype b,ctype c,dtype
 	return -1; \
 }
 
-#endif /* (_MIPS_SIM == _MIPS_SIM_NABIN32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
+#endif /* (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
 
 #ifdef __KERNEL_SYSCALLS__
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/vr41xx/tb0229.h linux-mips-cvs-20040815/include/asm-mips/vr41xx/tb0229.h
--- linux-2.4.27/include/asm-mips/vr41xx/tb0229.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/vr41xx/tb0229.h	2004-02-13 18:22:22.000000000 +0100
@@ -68,6 +68,6 @@
 
 #define TB0219_RESET_REGS		KSEG1ADDR(0x0a00000e)
 
-extern void tanbac_tb0229_restart(char *command);
+extern void tanbac_tb0219_restart(char *command);
 
 #endif /* __TANBAC_TB0229_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/vr41xx/vr41xx.h linux-mips-cvs-20040815/include/asm-mips/vr41xx/vr41xx.h
--- linux-2.4.27/include/asm-mips/vr41xx/vr41xx.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/vr41xx/vr41xx.h	2004-02-17 13:08:55.000000000 +0100
@@ -53,8 +53,6 @@ extern unsigned long vr41xx_get_tclock_f
  * Clock Mask Unit
  */
 extern void vr41xx_cmu_init(void);
-extern void vr41xx_clock_supply(unsigned int clock);
-extern void vr41xx_clock_mask(unsigned int clock);
 
 enum {
 	PIU_CLOCK,
@@ -72,6 +70,9 @@ enum {
 	ETHER1_CLOCK
 };
 
+extern void vr41xx_supply_clock(unsigned int clock);
+extern void vr41xx_mask_clock(unsigned int clock);
+
 /*
  * Interrupt Control Unit
  */
@@ -134,6 +135,11 @@ extern int vr41xx_set_intassign(unsigned
 extern int vr41xx_cascade_irq(unsigned int irq, int (*get_irq_number)(int irq));
 
 /*
+ * Power Management Unit
+ */
+extern void vr41xx_pmu_init(void);
+
+/*
  * RTC
  */
 extern void vr41xx_set_rtclong1_cycle(uint32_t cycles);
@@ -208,9 +214,9 @@ extern void vr41xx_dsiu_init(void);
  * PCI Control Unit
  */
 struct vr41xx_pci_address_space {
-	u32 internal_base;
-	u32 address_mask;
-	u32 pci_base;
+	uint32_t internal_base;
+	uint32_t address_mask;
+	uint32_t pci_base;
 };
 
 struct vr41xx_pci_address_map {
@@ -221,16 +227,14 @@ struct vr41xx_pci_address_map {
 
 extern void vr41xx_pciu_init(struct vr41xx_pci_address_map *map);
 
+extern struct pci_ops vr41xx_pci_ops;
+
 /*
  * MISC
  */
 extern void vr41xx_time_init(void);
 extern void vr41xx_timer_setup(struct irqaction *irq);
 
-extern void vr41xx_restart(char *command);
-extern void vr41xx_halt(void);
-extern void vr41xx_power_off(void);
-
 #if defined(CONFIG_IDE) || defined(CONFIG_IDE_MODULE)
 extern struct ide_ops vr41xx_ide_ops;
 #endif
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/vr41xx/vrc4173.h linux-mips-cvs-20040815/include/asm-mips/vr41xx/vrc4173.h
--- linux-2.4.27/include/asm-mips/vr41xx/vrc4173.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips/vr41xx/vrc4173.h	2004-02-09 21:53:23.000000000 +0100
@@ -72,21 +72,23 @@ extern unsigned long vrc4173_io_offset;
 /*
  * Clock Mask Unit
  */
-#define VRC4173_PIU_CLOCK		0x0001
-#define VRC4173_KIU_CLOCK		0x0002
-#define VRC4173_AIU_CLOCK		0x0004
-#define VRC4173_PS2CH1_CLOCK		0x0008
-#define VRC4173_PS2CH2_CLOCK		0x0010
-#define VRC4173_USBU_PCI_CLOCK		0x0020
-#define VRC4173_CARDU1_PCI_CLOCK	0x0040
-#define VRC4173_CARDU2_PCI_CLOCK	0x0080
-#define VRC4173_AC97U_PCI_CLOCK		0x0100
-#define VRC4173_USBU_48MHz_CLOCK	0x0400
-#define VRC4173_EXT_48MHz_CLOCK		0x0800
-#define VRC4173_48MHz_CLOCK		0x1000
+enum {
+	VRC4173_PIU_CLOCK,
+	VRC4173_KIU_CLOCK,
+	VRC4173_AIU_CLOCK,
+	VRC4173_PS2_CH1_CLOCK,
+	VRC4173_PS2_CH2_CLOCK,
+	VRC4173_USBU_PCI_CLOCK,
+	VRC4173_CARDU1_PCI_CLOCK,
+	VRC4173_CARDU2_PCI_CLOCK,
+	VRC4173_AC97U_PCI_CLOCK,
+	VRC4173_USBU_48MHz_CLOCK,
+	VRC4173_EXT_48MHz_CLOCK,
+	VRC4173_48MHz_CLOCK,
+};
 
-extern void vrc4173_clock_supply(u16 mask);
-extern void vrc4173_clock_mask(u16 mask);
+extern void vrc4173_supply_clock(unsigned int clock);
+extern void vrc4173_mask_clock(unsigned int clock);
 
 /*
  * General-Purpose I/O Unit
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips/war.h linux-mips-cvs-20040815/include/asm-mips/war.h
--- linux-2.4.27/include/asm-mips/war.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips/war.h	2004-03-05 03:45:59.000000000 +0100
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2002 by Ralf Baechle
+ * Copyright (C) 2002, 2004 by Ralf Baechle
  */
 #ifndef _ASM_WAR_H
 #define _ASM_WAR_H
@@ -11,6 +11,15 @@
 #include <linux/config.h>
 
 /*
+ * Another R4600 erratum.  Due to the lack of errata information the exact
+ * technical details aren't known.  I've experimentally found that disabling
+ * interrupts during indexed I-cache flushes seems to be sufficient to deal
+ * with the issue.
+ *
+ * #define R4600_V1_INDEX_ICACHEOP_WAR 1
+ */
+
+/*
  * Pleasures of the R4600 V1.x.  Cite from the IDT R4600 V1.7 errata:
  *
  *  18. The CACHE instructions Hit_Writeback_Invalidate_D, Hit_Writeback_D,
@@ -59,6 +68,7 @@
  */
 #ifdef CONFIG_SGI_IP22
 
+#define R4600_V1_INDEX_ICACHEOP_WAR	1
 #define R4600_V1_HIT_CACHEOP_WAR	1
 #define R4600_V2_HIT_CACHEOP_WAR	1
 
@@ -159,8 +169,19 @@
 #endif
 
 /*
+ * On the RM9000 there is a problem which makes the CreateDirtyExclusive
+ * cache operation unusable on SMP systems.
+ */
+#if defined(CONFIG_MOMENCO_JAGUAR_ATX) || defined(CONFIG_PMC_YOSEMITE)
+#define  RM9000_CDEX_SMP_WAR		1
+#endif
+
+/*
  * Workarounds default to off
  */
+#ifndef R4600_V1_INDEX_ICACHEOP_WAR
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#endif
 #ifndef R4600_V1_HIT_CACHEOP_WAR
 #define R4600_V1_HIT_CACHEOP_WAR	0
 #endif
@@ -185,5 +206,8 @@
 #ifndef TX49XX_ICACHE_INDEX_INV_WAR
 #define TX49XX_ICACHE_INDEX_INV_WAR	0
 #endif
+#ifndef RM9000_CDEX_SMP_WAR
+#define RM9000_CDEX_SMP_WAR		0
+#endif
 
 #endif /* _ASM_WAR_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/checksum.h linux-mips-cvs-20040815/include/asm-mips64/checksum.h
--- linux-2.4.27/include/asm-mips64/checksum.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips64/checksum.h	2004-05-05 14:39:08.000000000 +0200
@@ -127,9 +127,6 @@ static inline unsigned short ip_fast_csu
 }
 
 /*
- * computes the checksum of the TCP/UDP pseudo-header
- * returns a 16-bit checksum, already complemented
- *
  * Cast unsigned short expressions to unsigned long explicitly
  * to avoid surprises resulting from implicit promotions to
  * signed int.  --macro
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/cpu.h linux-mips-cvs-20040815/include/asm-mips64/cpu.h
--- linux-2.4.27/include/asm-mips64/cpu.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips64/cpu.h	2004-08-15 08:06:49.000000000 +0200
@@ -173,7 +173,8 @@
 #define CPU_VR4133		56
 #define CPU_AU1550		57
 #define CPU_24K			58
-#define CPU_LAST		58
+#define CPU_AU1200		59
+#define CPU_LAST		59
 
 /*
  * ISA Level encodings
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/dec/prom.h linux-mips-cvs-20040815/include/asm-mips64/dec/prom.h
--- linux-2.4.27/include/asm-mips64/dec/prom.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips64/dec/prom.h	2004-02-11 16:17:09.000000000 +0100
@@ -164,4 +164,7 @@ extern void prom_meminit(u32);
 extern void prom_identify_arch(u32);
 extern void prom_init_cmdline(s32, s32 *, u32);
 
+extern void register_prom_console(void);
+extern void unregister_prom_console(void);
+
 #endif /* __ASM_DEC_PROM_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/dec/serial.h linux-mips-cvs-20040815/include/asm-mips64/dec/serial.h
--- linux-2.4.27/include/asm-mips64/dec/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips64/dec/serial.h	2004-07-01 15:28:57.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ *	include/asm-mips/dec/serial.h
+ *
+ *	Definitions common to all DECstation serial devices.
+ *
+ *	Copyright (C) 2004  Maciej W. Rozycki
+ *
+ *	Based on bits extracted from drivers/tc/zs.h for which
+ *	the following copyrights apply:
+ *
+ *	Copyright (C) 1995  David S. Miller (davem@caip.rutgers.edu)
+ *	Copyright (C) 1996  Paul Mackerras (Paul.Mackerras@cs.anu.edu.au)
+ *	Copyright (C)       Harald Koerfgen
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_MIPS_DEC_SERIAL_H
+#define __ASM_MIPS_DEC_SERIAL_H
+
+struct dec_serial_hook {
+	int (*init_channel)(void *handle);
+	void (*init_info)(void *handle);
+	void (*rx_char)(unsigned char ch, unsigned char fl);
+	int (*poll_rx_char)(void *handle);
+	int (*poll_tx_char)(void *handle, unsigned char ch);
+	unsigned int cflags;
+};
+
+extern int register_dec_serial_hook(unsigned int channel,
+				    struct dec_serial_hook *hook);
+extern int unregister_dec_serial_hook(unsigned int channel);
+
+#endif /* __ASM_MIPS_DEC_SERIAL_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/mipsregs.h linux-mips-cvs-20040815/include/asm-mips64/mipsregs.h
--- linux-2.4.27/include/asm-mips64/mipsregs.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips64/mipsregs.h	2004-08-15 08:06:49.000000000 +0200
@@ -632,6 +632,24 @@ do {									\
 } while (0)
 
 /*
+ * On RM7000/RM9000 these are uses to access cop0 set 1 registers
+ */
+#define __read_32bit_c0_ctrl_register(source)				\
+({ int __res;								\
+	__asm__ __volatile__(						\
+		"cfc0\t%0, " #source "\n\t"				\
+		: "=r" (__res));					\
+	__res;								\
+})
+
+#define __write_32bit_c0_ctrl_register(register, value)			\
+do {									\
+	__asm__ __volatile__(						\
+		"ctc0\t%z0, " #register "\n\t"				\
+		: : "Jr" ((unsigned int)value));			\
+} while (0)
+
+/*
  * These versions are only needed for systems with more than 38 bits of
  * physical address space running the 32-bit kernel.  That's none atm :-)
  */
@@ -788,8 +806,8 @@ do {									\
 #define read_c0_xcontext()	__read_ulong_c0_register($20, 0)
 #define write_c0_xcontext(val)	__write_ulong_c0_register($20, 0, val)
 
-#define read_c0_intcontrol()	__read_32bit_c0_register($20, 1)
-#define write_c0_intcontrol(val) __write_32bit_c0_register($20, 1, val)
+#define read_c0_intcontrol()	__read_32bit_c0_ctrl_register($20)
+#define write_c0_intcontrol(val) __write_32bit_c0_ctrl_register($20, val)
 
 #define read_c0_framemask()	__read_32bit_c0_register($21, 0)
 #define write_c0_framemask(val)	__write_32bit_c0_register($21, 0, val)
@@ -879,7 +897,7 @@ static inline void tlb_write_random(void
 /*
  * Manipulate bits in a c0 register.
  */
-#define __BUILD_SET_C0(name,register)				\
+#define __BUILD_SET_C0(name)					\
 static inline unsigned int					\
 set_c0_##name(unsigned int set)					\
 {								\
@@ -917,9 +935,10 @@ change_c0_##name(unsigned int change, un
 	return res;						\
 }
 
-__BUILD_SET_C0(status,CP0_STATUS)
-__BUILD_SET_C0(cause,CP0_CAUSE)
-__BUILD_SET_C0(config,CP0_CONFIG)
+__BUILD_SET_C0(status)
+__BUILD_SET_C0(cause)
+__BUILD_SET_C0(config)
+__BUILD_SET_C0(intcontrol)
 
 #endif /* !__ASSEMBLY__ */
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/mmu_context.h linux-mips-cvs-20040815/include/asm-mips64/mmu_context.h
--- linux-2.4.27/include/asm-mips64/mmu_context.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips64/mmu_context.h	2004-02-25 14:05:49.000000000 +0100
@@ -35,9 +35,23 @@ extern unsigned long pgd_current[];
 #define cpu_asid(cpu, mm)	(cpu_context((cpu), (mm)) & ASID_MASK)
 #define asid_cache(cpu)		(cpu_data[cpu].asid_cache)
 
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+
+#define ASID_INC	0x40
+#define ASID_MASK	0xfc0
+
+#elif defined(CONFIG_CPU_RM9000)
+
+#define ASID_INC	0x1
+#define ASID_MASK	0xfff
+
+#else /* FIXME: not correct for R6000, R8000 */
+
 #define ASID_INC	0x1
 #define ASID_MASK	0xff
 
+#endif
+
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk, unsigned cpu)
 {
 }
@@ -127,7 +141,7 @@ activate_mm(struct mm_struct *prev, stru
 	write_c0_entryhi(cpu_context(cpu, next));
 	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
 
-	/* mark mmu ownership change */ 
+	/* mark mmu ownership change */
 	clear_bit(cpu, &prev->cpu_vm_mask);
 	set_bit(cpu, &next->cpu_vm_mask);
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/prefetch.h linux-mips-cvs-20040815/include/asm-mips64/prefetch.h
--- linux-2.4.27/include/asm-mips64/prefetch.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips64/prefetch.h	2004-03-05 03:18:15.000000000 +0100
@@ -21,8 +21,9 @@
  * RM7000 version 1.0 interprets all hints as Pref_Load; version 2.0 implements
  * Pref_PrepareForStore also.
  *
- * RM9000 is MIPS IV but implements prefetching like MIPS32/MIPS64;
- * it's Pref_WriteBackInvalidate is a nop.
+ * RM9000 is MIPS IV but implements prefetching like MIPS32/MIPS64; it's
+ * Pref_WriteBackInvalidate is a nop and Pref_PrepareForStore is broken in
+ * current versions due to erratum G105.
  *
  * VR7701 only implements the Load prefetch.
  *
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/processor.h linux-mips-cvs-20040815/include/asm-mips64/processor.h
--- linux-2.4.27/include/asm-mips64/processor.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips64/processor.h	2004-01-31 03:52:42.000000000 +0100
@@ -128,6 +128,8 @@ struct cpuinfo_mips {
 #define cpu_has_dc_aliases	(cpu_data[0].dcache.flags & MIPS_CACHE_ALIASES)
 #define cpu_has_ic_fills_f_dc	(cpu_data[0].dcache.flags & MIPS_CACHE_IC_F_DC)
 #define cpu_has_64bits		1
+#define cpu_has_64bit_zero_reg	1
+#define cpu_has_64bit_gp_regs	1
 #define cpu_has_64bit_addresses	1
 #define cpu_has_subset_pcaches	(cpu_data[0].options & MIPS_CPU_SUBSET_CACHES)
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/smp.h linux-mips-cvs-20040815/include/asm-mips64/smp.h
--- linux-2.4.27/include/asm-mips64/smp.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips64/smp.h	2004-05-02 00:48:42.000000000 +0200
@@ -106,7 +106,7 @@ void core_send_ipi(int cpu, unsigned int
  * Clear all undefined state in the cpu, set up sp and gp to the passed
  * values, and kick the cpu into smp_bootstrap();
  */
-void prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp);
+int prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp);
 
 /*
  *  After we've done initial boot, this function is called to allow the
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/unaligned.h linux-mips-cvs-20040815/include/asm-mips64/unaligned.h
--- linux-2.4.27/include/asm-mips64/unaligned.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips64/unaligned.h	2004-08-15 08:06:49.000000000 +0200
@@ -3,152 +3,142 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 1999, 2000, 2001 by Ralf Baechle
+ * Copyright (C) 1996, 1999, 2000, 2001, 2003 by Ralf Baechle
  * Copyright (C) 1999, 2000, 2001 Silicon Graphics, Inc.
  */
 #ifndef _ASM_UNALIGNED_H
 #define _ASM_UNALIGNED_H
 
-extern void __get_unaligned_bad_length(void);
-extern void __put_unaligned_bad_length(void);
+#include <linux/types.h>
 
 /*
- * Load quad unaligned.
+ * get_unaligned - get value from possibly mis-aligned location
+ * @ptr: pointer to value
+ *
+ * This macro should be used for accessing values larger in size than
+ * single bytes at locations that are expected to be improperly aligned,
+ * e.g. retrieving a u16 value from a location not u16-aligned.
+ *
+ * Note that unaligned accesses can be very expensive on some architectures.
  */
-static inline unsigned long __ldq_u(const unsigned long * __addr)
-{
-	unsigned long __res;
-
-	__asm__("uld\t%0,%1"
-		: "=&r" (__res)
-		: "m" (*__addr));
+#define get_unaligned(ptr) \
+	((__typeof__(*(ptr)))__get_unaligned((ptr), sizeof(*(ptr))))
 
-	return __res;
-}
+/*
+ * put_unaligned - put value to a possibly mis-aligned location
+ * @val: value to place
+ * @ptr: pointer to location
+ *
+ * This macro should be used for placing values larger in size than
+ * single bytes at locations that are expected to be improperly aligned,
+ * e.g. writing a u16 value to a location not u16-aligned.
+ *
+ * Note that unaligned accesses can be very expensive on some architectures.
+ */
+#define put_unaligned(x,ptr) \
+	__put_unaligned((__u64)(x), (ptr), sizeof(*(ptr)))
 
 /*
- * Load long unaligned.
+ * This is a silly but good way to make sure that
+ * the get/put functions are indeed always optimized,
+ * and that we use the correct sizes.
  */
-static inline unsigned long __ldl_u(const unsigned int * __addr)
-{
-	unsigned long __res;
+extern void bad_unaligned_access_length(void);
 
-	__asm__("ulw\t%0,%1"
-		: "=&r" (__res)
-		: "m" (*__addr));
+/*
+ * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
+ * packed structures to talk about such things with.
+ */
 
-	return __res;
-}
+struct __una_u64 { __u64 x __attribute__((packed)); };
+struct __una_u32 { __u32 x __attribute__((packed)); };
+struct __una_u16 { __u16 x __attribute__((packed)); };
 
 /*
- * Load word unaligned.
+ * Elemental unaligned loads
  */
-static inline unsigned long __ldw_u(const unsigned short * __addr)
+
+static inline __u64 __uldq(const __u64 * r11)
 {
-	unsigned long __res;
+	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
+	return ptr->x;
+}
 
-	__asm__("ulh\t%0,%1"
-		: "=&r" (__res)
-		: "m" (*__addr));
+static inline __u32 __uldl(const __u32 * r11)
+{
+	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
+	return ptr->x;
+}
 
-	return __res;
+static inline __u16 __uldw(const __u16 * r11)
+{
+	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
+	return ptr->x;
 }
 
 /*
- * Store quad unaligned.
+ * Elemental unaligned stores
  */
-static inline void __stq_u(unsigned long __val, unsigned long * __addr)
+
+static inline void __ustq(__u64 r5, __u64 * r11)
 {
-	__asm__("usd\t%1, %0"
-		: "=m" (*__addr)
-		: "r" (__val));
+	struct __una_u64 *ptr = (struct __una_u64 *) r11;
+	ptr->x = r5;
 }
 
-/*
- * Store long unaligned.
- */
-static inline void __stl_u(unsigned long __val, unsigned int * __addr)
+static inline void __ustl(__u32 r5, __u32 * r11)
 {
-	__asm__("usw\t%1, %0"
-		: "=m" (*__addr)
-		: "r" (__val));
+	struct __una_u32 *ptr = (struct __una_u32 *) r11;
+	ptr->x = r5;
 }
 
-/*
- * Store word unaligned.
- */
-static inline void __stw_u(unsigned long __val, unsigned short * __addr)
+static inline void __ustw(__u16 r5, __u16 * r11)
 {
-	__asm__("ush\t%1, %0"
-		: "=m" (*__addr)
-		: "r" (__val));
+	struct __una_u16 *ptr = (struct __una_u16 *) r11;
+	ptr->x = r5;
 }
 
-/*
- * get_unaligned - get value from possibly mis-aligned location
- * @ptr: pointer to value
- *
- * This macro should be used for accessing values larger in size than
- * single bytes at locations that are expected to be improperly aligned,
- * e.g. retrieving a u16 value from a location not u16-aligned.
- *
- * Note that unaligned accesses can be very expensive on some architectures.
- */
-#define get_unaligned(ptr)						\
-({									\
-	__typeof__(*(ptr)) __val;					\
-									\
-	switch (sizeof(*(ptr))) {					\
-	case 1:								\
-		__val = *(const unsigned char *)(ptr);			\
-		break;							\
-	case 2:								\
-		__val = __ldw_u((const unsigned short *)(ptr));		\
-		break;							\
-	case 4:								\
-		__val = __ldl_u((const unsigned int *)(ptr));		\
-		break;							\
-	case 8:								\
-		__val = __ldq_u((const unsigned long *)(ptr));		\
-		break;							\
-	default:							\
-		__get_unaligned_bad_length();				\
-		break;							\
-	}								\
-									\
-	__val;								\
-})
+static inline __u64 __get_unaligned(const void *ptr, size_t size)
+{
+	__u64 val;
 
-/*
- * put_unaligned - put value to a possibly mis-aligned location
- * @val: value to place
- * @ptr: pointer to location
- *
- * This macro should be used for placing values larger in size than
- * single bytes at locations that are expected to be improperly aligned,
- * e.g. writing a u16 value to a location not u16-aligned.
- *
- * Note that unaligned accesses can be very expensive on some architectures.
- */
-#define put_unaligned(val,ptr)						\
-do {									\
-	switch (sizeof(*(ptr))) {					\
-	case 1:								\
-		*(unsigned char *)(ptr) = (val);			\
-		break;							\
-	case 2:								\
-		__stw_u((val), (unsigned short *)(ptr));		\
-		break;							\
-	case 4:								\
-		__stl_u((val), (unsigned int *)(ptr));			\
-		break;							\
-	case 8:								\
-		__stq_u((val), (unsigned long long *)(ptr));		\
-		break;							\
-	default:							\
-		__put_unaligned_bad_length();				\
-		break;							\
-	}								\
-} while(0)
+	switch (size) {
+	case 1:
+		val = *(const __u8 *)ptr;
+		break;
+	case 2:
+		val = __uldw((const __u16 *)ptr);
+		break;
+	case 4:
+		val = __uldl((const __u32 *)ptr);
+		break;
+	case 8:
+		val = __uldq((const __u64 *)ptr);
+		break;
+	default:
+		bad_unaligned_access_length();
+	}
+	return val;
+}
+
+static inline void __put_unaligned(__u64 val, void *ptr, size_t size)
+{
+	switch (size) {
+	      case 1:
+		*(__u8 *)ptr = (val);
+	        break;
+	      case 2:
+		__ustw(val, (__u16 *)ptr);
+		break;
+	      case 4:
+		__ustl(val, (__u32 *)ptr);
+		break;
+	      case 8:
+		__ustq(val, (__u64 *)ptr);
+		break;
+	      default:
+	    	bad_unaligned_access_length();
+	}
+}
 
 #endif /* _ASM_UNALIGNED_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/unistd.h linux-mips-cvs-20040815/include/asm-mips64/unistd.h
--- linux-2.4.27/include/asm-mips64/unistd.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-mips64/unistd.h	2004-05-02 00:48:42.000000000 +0200
@@ -865,7 +865,7 @@ type name(atype a, btype b, ctype c, dty
 	return -1; \
 }
 
-#if (_MIPS_SIM == _MIPS_SIM_ABIN32)
+#if (_MIPS_SIM == _MIPS_SIM_ABI32)
 
 /*
  * Using those means your brain needs more than an oil change ;-)
@@ -933,9 +933,9 @@ type name(atype a, btype b, ctype c, dty
 	return -1; \
 }
 
-#endif /* (_MIPS_SIM == _MIPS_SIM_ABIN32) */
+#endif /* (_MIPS_SIM == _MIPS_SIM_ABI32) */
 
-#if (_MIPS_SIM == _MIPS_SIM_NABIN32) || (_MIPS_SIM == _MIPS_SIM_ABI64)
+#if (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64)
 
 #define _syscall5(type,name,atype,a,btype,b,ctype,c,dtype,d,etype,e) \
 type name (atype a,btype b,ctype c,dtype d,etype e) \
@@ -991,7 +991,7 @@ type name (atype a,btype b,ctype c,dtype
 	return -1; \
 }
 
-#endif /* (_MIPS_SIM == _MIPS_SIM_NABIN32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
+#endif /* (_MIPS_SIM == _MIPS_SIM_NABI32) || (_MIPS_SIM == _MIPS_SIM_ABI64) */
 
 #ifdef __KERNEL_SYSCALLS__
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-mips64/war.h linux-mips-cvs-20040815/include/asm-mips64/war.h
--- linux-2.4.27/include/asm-mips64/war.h	2003-08-25 13:44:44.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-mips64/war.h	2004-03-05 03:45:59.000000000 +0100
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2002 by Ralf Baechle
+ * Copyright (C) 2002, 2004 by Ralf Baechle
  */
 #ifndef _ASM_WAR_H
 #define _ASM_WAR_H
@@ -11,6 +11,15 @@
 #include <linux/config.h>
 
 /*
+ * Another R4600 erratum.  Due to the lack of errata information the exact
+ * technical details aren't known.  I've experimentally found that disabling
+ * interrupts during indexed I-cache flushes seems to be sufficient to deal
+ * with the issue.
+ *
+ * #define R4600_V1_INDEX_ICACHEOP_WAR 1
+ */
+
+/*
  * Pleasures of the R4600 V1.x.  Cite from the IDT R4600 V1.7 errata:
  *
  *  18. The CACHE instructions Hit_Writeback_Invalidate_D, Hit_Writeback_D,
@@ -59,6 +68,7 @@
  */
 #ifdef CONFIG_SGI_IP22
 
+#define R4600_V1_INDEX_ICACHEOP_WAR	1
 #define R4600_V1_HIT_CACHEOP_WAR	1
 #define R4600_V2_HIT_CACHEOP_WAR	1
 
@@ -159,8 +169,19 @@
 #endif
 
 /*
+ * On the RM9000 there is a problem which makes the CreateDirtyExclusive
+ * cache operation unusable on SMP systems.
+ */
+#if defined(CONFIG_MOMENCO_JAGUAR_ATX) || defined(CONFIG_PMC_YOSEMITE)
+#define  RM9000_CDEX_SMP_WAR		1
+#endif
+
+/*
  * Workarounds default to off
  */
+#ifndef R4600_V1_INDEX_ICACHEOP_WAR
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#endif
 #ifndef R4600_V1_HIT_CACHEOP_WAR
 #define R4600_V1_HIT_CACHEOP_WAR	0
 #endif
@@ -185,5 +206,8 @@
 #ifndef TX49XX_ICACHE_INDEX_INV_WAR
 #define TX49XX_ICACHE_INDEX_INV_WAR	0
 #endif
+#ifndef RM9000_CDEX_SMP_WAR
+#define RM9000_CDEX_SMP_WAR		0
+#endif
 
 #endif /* _ASM_WAR_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-ppc/param.h linux-mips-cvs-20040815/include/asm-ppc/param.h
--- linux-2.4.27/include/asm-ppc/param.h	2003-06-13 16:51:38.000000000 +0200
+++ linux-mips-cvs-20040815/include/asm-ppc/param.h	2003-07-05 05:23:46.000000000 +0200
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-s390/param.h linux-mips-cvs-20040815/include/asm-s390/param.h
--- linux-2.4.27/include/asm-s390/param.h	2001-02-13 23:13:44.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-s390/param.h	2001-03-09 21:34:48.000000000 +0100
@@ -11,6 +11,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-sh/param.h linux-mips-cvs-20040815/include/asm-sh/param.h
--- linux-2.4.27/include/asm-sh/param.h	2001-01-04 22:19:13.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-sh/param.h	2001-01-11 05:02:45.000000000 +0100
@@ -3,6 +3,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	4096
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-sparc/param.h linux-mips-cvs-20040815/include/asm-sparc/param.h
--- linux-2.4.27/include/asm-sparc/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-sparc/param.h	2000-11-23 03:00:56.000000000 +0100
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/asm-sparc64/param.h linux-mips-cvs-20040815/include/asm-sparc64/param.h
--- linux-2.4.27/include/asm-sparc64/param.h	2000-10-30 23:34:12.000000000 +0100
+++ linux-mips-cvs-20040815/include/asm-sparc64/param.h	2000-11-23 03:00:56.000000000 +0100
@@ -4,6 +4,9 @@
 
 #ifndef HZ
 #define HZ 100
+#ifdef __KERNEL__
+#define hz_to_std(a) (a)
+#endif
 #endif
 
 #define EXEC_PAGESIZE	8192    /* Thanks for sun4's we carry baggage... */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/linux/i2c-algo-au1550.h linux-mips-cvs-20040815/include/linux/i2c-algo-au1550.h
--- linux-2.4.27/include/linux/i2c-algo-au1550.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-mips-cvs-20040815/include/linux/i2c-algo-au1550.h	2004-07-07 02:38:02.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2004 Embedded Edge, LLC <dan@embeddededge.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef I2C_ALGO_AU1550_H
+#define I2C_ALGO_AU1550_H 1
+
+struct i2c_algo_au1550_data {
+	u32	psc_base;
+	int	xfer_timeout;
+	int	ack_timeout;
+};
+
+int i2c_au1550_add_bus(struct i2c_adapter *);
+int i2c_au1550_del_bus(struct i2c_adapter *);
+
+#endif /* I2C_ALGO_AU1550_H */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/linux/i2c-id.h linux-mips-cvs-20040815/include/linux/i2c-id.h
--- linux-2.4.27/include/linux/i2c-id.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/linux/i2c-id.h	2004-08-15 08:06:54.000000000 +0200
@@ -156,6 +156,8 @@
 
 #define I2C_ALGO_SGI	0x130000	/* SGI algorithm		*/
 
+#define I2C_ALGO_AU1550	0x140000	/* Alchemy Au1550 PSC		*/
+
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
 #define I2C_ALGO_MASK	0xff0000	/* Mask for algorithms		*/
@@ -204,6 +206,9 @@
 #define I2C_HW_SGI_VINO	0x00
 #define I2C_HW_SGI_MACE	0x01
 
+/* --- Au1550 PSC adapters						*/
+#define I2C_HW_AU1550_PSC	0x00
+
 /* --- SMBus only adapters						*/
 #define I2C_HW_SMBUS_PIIX4	0x00
 #define I2C_HW_SMBUS_ALI15X3	0x01
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/linux/sched.h linux-mips-cvs-20040815/include/linux/sched.h
--- linux-2.4.27/include/linux/sched.h	2004-08-08 01:26:06.000000000 +0200
+++ linux-mips-cvs-20040815/include/linux/sched.h	2004-08-15 08:06:55.000000000 +0200
@@ -617,6 +617,10 @@ asmlinkage long sys_wait4(pid_t pid,unsi
 extern int in_group_p(gid_t);
 extern int in_egroup_p(gid_t);
 
+extern ATTRIB_NORET void cpu_idle(void);
+
+extern void release_task(struct task_struct * p);
+
 extern void proc_caches_init(void);
 extern void flush_signals(struct task_struct *);
 extern void flush_signal_handlers(struct task_struct *);
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/linux/serial.h linux-mips-cvs-20040815/include/linux/serial.h
--- linux-2.4.27/include/linux/serial.h	2002-08-03 02:39:45.000000000 +0200
+++ linux-mips-cvs-20040815/include/linux/serial.h	2004-08-15 08:06:56.000000000 +0200
@@ -75,7 +75,8 @@ struct serial_struct {
 #define PORT_16654	11
 #define PORT_16850	12
 #define PORT_RSA	13	/* RSA-DV II/S card */
-#define PORT_MAX	13
+#define PORT_SB1250	14
+#define PORT_MAX	14
 
 #define SERIAL_IO_PORT	0
 #define SERIAL_IO_HUB6	1
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/include/linux/swap.h linux-mips-cvs-20040815/include/linux/swap.h
--- linux-2.4.27/include/linux/swap.h	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/include/linux/swap.h	2004-03-01 15:17:39.000000000 +0100
@@ -1,6 +1,12 @@
 #ifndef _LINUX_SWAP_H
 #define _LINUX_SWAP_H
 
+#include <linux/config.h>
+
+#define MAX_SWAPFILES 32
+
+#ifdef __KERNEL__
+
 #include <linux/spinlock.h>
 #include <asm/page.h>
 
@@ -8,8 +14,6 @@
 #define SWAP_FLAG_PRIO_MASK	0x7fff
 #define SWAP_FLAG_PRIO_SHIFT	0
 
-#define MAX_SWAPFILES 32
-
 /*
  * Magic header for a swap area. The first part of the union is
  * what the swap magic looks like for the old (limited to 128MB)
@@ -39,8 +43,6 @@ union swap_header {
 	} info;
 };
 
-#ifdef __KERNEL__
-
 /*
  * Max bad pages in the new format..
  */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/init/main.c linux-mips-cvs-20040815/init/main.c
--- linux-2.4.27/init/main.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-mips-cvs-20040815/init/main.c	2003-11-17 02:07:46.000000000 +0100
@@ -291,7 +291,6 @@ static void __init parse_options(char *l
 
 
 extern void setup_arch(char **);
-extern void cpu_idle(void);
 
 unsigned long wait_init_idle;
 
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/kernel/exit.c linux-mips-cvs-20040815/kernel/exit.c
--- linux-2.4.27/kernel/exit.c	2002-11-29 00:53:15.000000000 +0100
+++ linux-mips-cvs-20040815/kernel/exit.c	2003-01-11 18:53:18.000000000 +0100
@@ -26,7 +26,7 @@ extern struct task_struct *child_reaper;
 
 int getrusage(struct task_struct *, int, struct rusage *);
 
-static void release_task(struct task_struct * p)
+void release_task(struct task_struct * p)
 {
 	if (p != current) {
 #ifdef CONFIG_SMP
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/kernel/signal.c linux-mips-cvs-20040815/kernel/signal.c
--- linux-2.4.27/kernel/signal.c	2004-02-18 14:36:32.000000000 +0100
+++ linux-mips-cvs-20040815/kernel/signal.c	2004-01-20 16:10:34.000000000 +0100
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 
+#include <asm/param.h>
 #include <asm/uaccess.h>
 
 /*
@@ -28,6 +29,14 @@
 #define SIG_SLAB_DEBUG	0
 #endif
 
+#define DEBUG_SIG 0
+
+#if DEBUG_SIG
+#define SIG_SLAB_DEBUG	(SLAB_DEBUG_FREE | SLAB_RED_ZONE /* | SLAB_POISON */)
+#else
+#define SIG_SLAB_DEBUG	0
+#endif
+
 static kmem_cache_t *sigqueue_cachep;
 
 atomic_t nr_queued_signals;
@@ -270,6 +279,11 @@ printk("SIG dequeue (%s:%d): %d ", curre
 	signal_pending(current));
 #endif
 
+#if DEBUG_SIG
+printk("SIG dequeue (%s:%d): %d ", current->comm, current->pid,
+	signal_pending(current));
+#endif
+
 	sig = next_signal(current, mask);
 	if (sig) {
 		if (current->notifier) {
@@ -293,6 +307,10 @@ printk("SIG dequeue (%s:%d): %d ", curre
 printk(" %d -> %d\n", signal_pending(current), sig);
 #endif
 
+#if DEBUG_SIG
+printk(" %d -> %d\n", signal_pending(current), sig);
+#endif
+
 	return sig;
 }
 
@@ -540,6 +558,11 @@ send_sig_info(int sig, struct siginfo *i
 printk("SIG queue (%s:%d): %d ", t->comm, t->pid, sig);
 #endif
 
+
+#if DEBUG_SIG
+printk("SIG queue (%s:%d): %d ", t->comm, t->pid, sig);
+#endif
+
 	ret = -EINVAL;
 	if (sig < 0 || sig > _NSIG)
 		goto out_nolock;
@@ -778,8 +801,8 @@ void do_notify_parent(struct task_struct
 	info.si_uid = tsk->uid;
 
 	/* FIXME: find out whether or not this is supposed to be c*time. */
-	info.si_utime = tsk->times.tms_utime;
-	info.si_stime = tsk->times.tms_stime;
+	info.si_utime = hz_to_std(tsk->times.tms_utime);
+	info.si_stime = hz_to_std(tsk->times.tms_stime);
 
 	status = tsk->exit_code & 0x7f;
 	why = SI_KERNEL;	/* shouldn't happen */
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/kernel/sys.c linux-mips-cvs-20040815/kernel/sys.c
--- linux-2.4.27/kernel/sys.c	2003-11-28 19:26:21.000000000 +0100
+++ linux-mips-cvs-20040815/kernel/sys.c	2003-11-17 02:07:47.000000000 +0100
@@ -801,16 +801,23 @@ asmlinkage long sys_setfsgid(gid_t gid)
 
 asmlinkage long sys_times(struct tms * tbuf)
 {
+	struct tms temp;
+
 	/*
 	 *	In the SMP world we might just be unlucky and have one of
 	 *	the times increment as we use it. Since the value is an
 	 *	atomically safe type this is just fine. Conceptually its
 	 *	as if the syscall took an instant longer to occur.
 	 */
-	if (tbuf)
-		if (copy_to_user(tbuf, &current->times, sizeof(struct tms)))
+	if (tbuf) {
+		temp.tms_utime = hz_to_std(current->times.tms_utime);
+		temp.tms_stime = hz_to_std(current->times.tms_stime);
+		temp.tms_cutime = hz_to_std(current->times.tms_cutime);
+		temp.tms_cstime = hz_to_std(current->times.tms_cstime);
+		if (copy_to_user(tbuf, &temp, sizeof(struct tms)))
 			return -EFAULT;
-	return jiffies;
+	}
+	return hz_to_std(jiffies);
 }
 
 /*
diff -urpNX ../2.4.26/dontdiff linux-2.4.27/lib/Makefile linux-mips-cvs-20040815/lib/Makefile
--- linux-2.4.27/lib/Makefile	2004-04-14 15:05:40.000000000 +0200
+++ linux-mips-cvs-20040815/lib/Makefile	2004-05-05 14:39:12.000000000 +0200
@@ -27,6 +27,7 @@ obj-$(CONFIG_CRC32)     += crc32.o
 subdir-$(CONFIG_ZLIB_INFLATE) += zlib_inflate
 subdir-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate
 
+-include $(TOPDIR)/arch/$(ARCH)/Makefile.lib
 include $(TOPDIR)/drivers/net/Makefile.lib
 include $(TOPDIR)/drivers/usb/Makefile.lib
 include $(TOPDIR)/drivers/bluetooth/Makefile.lib
