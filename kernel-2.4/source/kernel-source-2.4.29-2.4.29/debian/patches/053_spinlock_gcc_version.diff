# origin: Debian (herbert)
# cset: n/a
# inclusion: not submitted (not suitable?)
# description: tighten GCC conditional for empty initializer workaround
# revision date: 2004-09-03

diff -urN kernel-source-2.4.26/include/linux/spinlock.h kernel-source-2.4.26-1/include/linux/spinlock.h
--- kernel-source-2.4.26/include/linux/spinlock.h	2004-02-19 00:36:32.000000000 +1100
+++ kernel-source-2.4.26-1/include/linux/spinlock.h	2004-02-22 20:28:34.000000000 +1100
@@ -70,10 +70,9 @@
 /*
  * Your basic spinlocks, allowing only a single CPU anywhere
  *
- * Some older gcc versions had a nasty bug with empty initializers.
- * (XXX: could someone please confirm whether egcs 1.1 still has this bug?)
+ * Most gcc versions have a nasty bug with empty initializers.
  */
-#if (__GNUC__ > 2 || __GNUC_MINOR__ > 95)
+#if (__GNUC__ > 2)
   typedef struct { } spinlock_t;
   #define SPIN_LOCK_UNLOCKED (spinlock_t) { }
 #else
@@ -134,10 +133,9 @@
  * irq-safe write-lock, but readers can get non-irqsafe
  * read-locks.
  *
- * Some older gcc versions had a nasty bug with empty initializers.
- * (XXX: could someone please confirm whether egcs 1.1 still has this bug?)
+ * Most gcc versions have a nasty bug with empty initializers.
  */
-#if (__GNUC__ > 2 || __GNUC_MINOR__ > 91)
+#if (__GNUC__ > 2)
   typedef struct { } rwlock_t;
   #define RW_LOCK_UNLOCKED (rwlock_t) { }
 #else

