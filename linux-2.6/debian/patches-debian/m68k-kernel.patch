diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/kernel/exit.c linux-2.6.13/kernel/exit.c
--- linux-2.6.13-i386/kernel/exit.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/kernel/exit.c	2005-08-30 16:36:41.000000000 +0200
@@ -846,7 +846,7 @@
 	if (group_dead && tsk->signal->leader)
 		disassociate_ctty(1);
 
-	module_put(tsk->thread_info->exec_domain->module);
+	module_put(task_thread_info(tsk)->exec_domain->module);
 	if (tsk->binfmt)
 		module_put(tsk->binfmt->module);
 
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/kernel/fork.c linux-2.6.13/kernel/fork.c
--- linux-2.6.13-i386/kernel/fork.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/kernel/fork.c	2005-08-30 16:36:41.000000000 +0200
@@ -100,7 +100,7 @@
 
 void free_task(struct task_struct *tsk)
 {
-	free_thread_info(tsk->thread_info);
+	free_thread_stack(tsk->stack);
 	free_task_struct(tsk);
 }
 EXPORT_SYMBOL(free_task);
@@ -155,7 +155,7 @@
 static struct task_struct *dup_task_struct(struct task_struct *orig)
 {
 	struct task_struct *tsk;
-	struct thread_info *ti;
+	void *stack;
 
 	prepare_to_copy(orig);
 
@@ -163,16 +163,16 @@
 	if (!tsk)
 		return NULL;
 
-	ti = alloc_thread_info(tsk);
-	if (!ti) {
+	stack = alloc_thread_stack(tsk);
+	if (!stack) {
 		free_task_struct(tsk);
 		return NULL;
 	}
 
-	*ti = *orig->thread_info;
 	*tsk = *orig;
-	tsk->thread_info = ti;
-	ti->task = tsk;
+	tsk->stack = stack;
+	*(struct task_struct **)tsk->stack = tsk;
+	setup_thread_stack(tsk, orig);
 
 	/* One for us, one for whoever does the "release_task()" (usually parent) */
 	atomic_set(&tsk->usage,2);
@@ -898,7 +898,7 @@
 	if (nr_threads >= max_threads)
 		goto bad_fork_cleanup_count;
 
-	if (!try_module_get(p->thread_info->exec_domain->module))
+	if (!try_module_get(task_thread_info(p)->exec_domain->module))
 		goto bad_fork_cleanup_count;
 
 	if (p->binfmt && !try_module_get(p->binfmt->module))
@@ -1151,7 +1151,7 @@
 	if (p->binfmt)
 		module_put(p->binfmt->module);
 bad_fork_cleanup_put_domain:
-	module_put(p->thread_info->exec_domain->module);
+	module_put(task_thread_info(p)->exec_domain->module);
 bad_fork_cleanup_count:
 	put_group_info(p->group_info);
 	atomic_dec(&p->user->processes);
diff -urN --exclude-from=/usr/src/exclude-file linux-2.6.13-i386/kernel/sched.c linux-2.6.13/kernel/sched.c
--- linux-2.6.13-i386/kernel/sched.c	2005-08-29 01:41:01.000000000 +0200
+++ linux-2.6.13/kernel/sched.c	2005-08-30 16:36:43.000000000 +0200
@@ -4121,10 +4121,10 @@
 #endif
 #ifdef CONFIG_DEBUG_STACK_USAGE
 	{
-		unsigned long * n = (unsigned long *) (p->thread_info+1);
+		unsigned long * n = end_of_stack(p);
 		while (!*n)
 			n++;
-		free = (unsigned long) n - (unsigned long)(p->thread_info+1);
+		free = (unsigned long) n - (unsigned long) end_of_stack(p);
 	}
 #endif
 	printk("%5lu %5d %6d ", free, p->pid, p->parent->pid);
@@ -4204,9 +4204,9 @@
 
 	/* Set the preempt count _outside_ the spinlocks! */
 #if defined(CONFIG_PREEMPT) && !defined(CONFIG_PREEMPT_BKL)
-	idle->thread_info->preempt_count = (idle->lock_depth >= 0);
+	task_thread_info(idle)->preempt_count = (idle->lock_depth >= 0);
 #else
-	idle->thread_info->preempt_count = 0;
+	task_thread_info(idle)->preempt_count = 0;
 #endif
 }
 
