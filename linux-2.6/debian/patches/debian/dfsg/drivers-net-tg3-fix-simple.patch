--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2229,7 +2229,6 @@
 
 config TIGON3
 	tristate "Broadcom Tigon3 support"
-	depends on BROKEN
 	depends on PCI
 	help
 	  This driver supports Broadcom Tigon3 based gigabit Ethernet cards.
--- a/drivers/net/tg3.c
+++ b/drivers/net/tg3.c
@@ -5124,11 +5124,6 @@
 }
 
 
-#define RX_CPU_SCRATCH_BASE	0x30000
-#define RX_CPU_SCRATCH_SIZE	0x04000
-#define TX_CPU_SCRATCH_BASE	0x34000
-#define TX_CPU_SCRATCH_SIZE	0x04000
-
 /* tp->lock is held. */
 static int tg3_halt_cpu(struct tg3 *tp, u32 offset)
 {
@@ -5177,205 +5172,6 @@
 	return 0;
 }
 
-struct fw_info {
-	unsigned int text_base;
-	unsigned int text_len;
-	const u32 *text_data;
-	unsigned int rodata_base;
-	unsigned int rodata_len;
-	const u32 *rodata_data;
-	unsigned int data_base;
-	unsigned int data_len;
-	const u32 *data_data;
-};
-
-/* tp->lock is held. */
-static int tg3_load_firmware_cpu(struct tg3 *tp, u32 cpu_base, u32 cpu_scratch_base,
-				 int cpu_scratch_size, struct fw_info *info)
-{
-	int err, lock_err, i;
-	void (*write_op)(struct tg3 *, u32, u32);
-
-	if (cpu_base == TX_CPU_BASE &&
-	    (tp->tg3_flags2 & TG3_FLG2_5705_PLUS)) {
-		printk(KERN_ERR PFX "tg3_load_firmware_cpu: Trying to load "
-		       "TX cpu firmware on %s which is 5705.\n",
-		       tp->dev->name);
-		return -EINVAL;
-	}
-
-	if (tp->tg3_flags2 & TG3_FLG2_5705_PLUS)
-		write_op = tg3_write_mem;
-	else
-		write_op = tg3_write_indirect_reg32;
-
-	/* It is possible that bootcode is still loading at this point.
-	 * Get the nvram lock first before halting the cpu.
-	 */
-	lock_err = tg3_nvram_lock(tp);
-	err = tg3_halt_cpu(tp, cpu_base);
-	if (!lock_err)
-		tg3_nvram_unlock(tp);
-	if (err)
-		goto out;
-
-	for (i = 0; i < cpu_scratch_size; i += sizeof(u32))
-		write_op(tp, cpu_scratch_base + i, 0);
-	tw32(cpu_base + CPU_STATE, 0xffffffff);
-	tw32(cpu_base + CPU_MODE, tr32(cpu_base+CPU_MODE)|CPU_MODE_HALT);
-	for (i = 0; i < (info->text_len / sizeof(u32)); i++)
-		write_op(tp, (cpu_scratch_base +
-			      (info->text_base & 0xffff) +
-			      (i * sizeof(u32))),
-			 (info->text_data ?
-			  info->text_data[i] : 0));
-	for (i = 0; i < (info->rodata_len / sizeof(u32)); i++)
-		write_op(tp, (cpu_scratch_base +
-			      (info->rodata_base & 0xffff) +
-			      (i * sizeof(u32))),
-			 (info->rodata_data ?
-			  info->rodata_data[i] : 0));
-	for (i = 0; i < (info->data_len / sizeof(u32)); i++)
-		write_op(tp, (cpu_scratch_base +
-			      (info->data_base & 0xffff) +
-			      (i * sizeof(u32))),
-			 (info->data_data ?
-			  info->data_data[i] : 0));
-
-	err = 0;
-
-out:
-	return err;
-}
-
-/* tp->lock is held. */
-static int tg3_load_5701_a0_firmware_fix(struct tg3 *tp)
-{
-	struct fw_info info;
-	int err, i;
-
-	info.text_base = TG3_FW_TEXT_ADDR;
-	info.text_len = TG3_FW_TEXT_LEN;
-	info.text_data = &tg3FwText[0];
-	info.rodata_base = TG3_FW_RODATA_ADDR;
-	info.rodata_len = TG3_FW_RODATA_LEN;
-	info.rodata_data = &tg3FwRodata[0];
-	info.data_base = TG3_FW_DATA_ADDR;
-	info.data_len = TG3_FW_DATA_LEN;
-	info.data_data = NULL;
-
-	err = tg3_load_firmware_cpu(tp, RX_CPU_BASE,
-				    RX_CPU_SCRATCH_BASE, RX_CPU_SCRATCH_SIZE,
-				    &info);
-	if (err)
-		return err;
-
-	err = tg3_load_firmware_cpu(tp, TX_CPU_BASE,
-				    TX_CPU_SCRATCH_BASE, TX_CPU_SCRATCH_SIZE,
-				    &info);
-	if (err)
-		return err;
-
-	/* Now startup only the RX cpu. */
-	tw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);
-	tw32_f(RX_CPU_BASE + CPU_PC,    TG3_FW_TEXT_ADDR);
-
-	for (i = 0; i < 5; i++) {
-		if (tr32(RX_CPU_BASE + CPU_PC) == TG3_FW_TEXT_ADDR)
-			break;
-		tw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);
-		tw32(RX_CPU_BASE + CPU_MODE,  CPU_MODE_HALT);
-		tw32_f(RX_CPU_BASE + CPU_PC,    TG3_FW_TEXT_ADDR);
-		udelay(1000);
-	}
-	if (i >= 5) {
-		printk(KERN_ERR PFX "tg3_load_firmware fails for %s "
-		       "to set RX CPU PC, is %08x should be %08x\n",
-		       tp->dev->name, tr32(RX_CPU_BASE + CPU_PC),
-		       TG3_FW_TEXT_ADDR);
-		return -ENODEV;
-	}
-	tw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);
-	tw32_f(RX_CPU_BASE + CPU_MODE,  0x00000000);
-
-	return 0;
-}
-
-
-
-/* tp->lock is held. */
-static int tg3_load_tso_firmware(struct tg3 *tp)
-{
-	struct fw_info info;
-	unsigned long cpu_base, cpu_scratch_base, cpu_scratch_size;
-	int err, i;
-
-	if (tp->tg3_flags2 & TG3_FLG2_HW_TSO)
-		return 0;
-
-	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5705) {
-		info.text_base = TG3_TSO5_FW_TEXT_ADDR;
-		info.text_len = TG3_TSO5_FW_TEXT_LEN;
-		info.text_data = &tg3Tso5FwText[0];
-		info.rodata_base = TG3_TSO5_FW_RODATA_ADDR;
-		info.rodata_len = TG3_TSO5_FW_RODATA_LEN;
-		info.rodata_data = &tg3Tso5FwRodata[0];
-		info.data_base = TG3_TSO5_FW_DATA_ADDR;
-		info.data_len = TG3_TSO5_FW_DATA_LEN;
-		info.data_data = &tg3Tso5FwData[0];
-		cpu_base = RX_CPU_BASE;
-		cpu_scratch_base = NIC_SRAM_MBUF_POOL_BASE5705;
-		cpu_scratch_size = (info.text_len +
-				    info.rodata_len +
-				    info.data_len +
-				    TG3_TSO5_FW_SBSS_LEN +
-				    TG3_TSO5_FW_BSS_LEN);
-	} else {
-		info.text_base = TG3_TSO_FW_TEXT_ADDR;
-		info.text_len = TG3_TSO_FW_TEXT_LEN;
-		info.text_data = &tg3TsoFwText[0];
-		info.rodata_base = TG3_TSO_FW_RODATA_ADDR;
-		info.rodata_len = TG3_TSO_FW_RODATA_LEN;
-		info.rodata_data = &tg3TsoFwRodata[0];
-		info.data_base = TG3_TSO_FW_DATA_ADDR;
-		info.data_len = TG3_TSO_FW_DATA_LEN;
-		info.data_data = &tg3TsoFwData[0];
-		cpu_base = TX_CPU_BASE;
-		cpu_scratch_base = TX_CPU_SCRATCH_BASE;
-		cpu_scratch_size = TX_CPU_SCRATCH_SIZE;
-	}
-
-	err = tg3_load_firmware_cpu(tp, cpu_base,
-				    cpu_scratch_base, cpu_scratch_size,
-				    &info);
-	if (err)
-		return err;
-
-	/* Now startup the cpu. */
-	tw32(cpu_base + CPU_STATE, 0xffffffff);
-	tw32_f(cpu_base + CPU_PC,    info.text_base);
-
-	for (i = 0; i < 5; i++) {
-		if (tr32(cpu_base + CPU_PC) == info.text_base)
-			break;
-		tw32(cpu_base + CPU_STATE, 0xffffffff);
-		tw32(cpu_base + CPU_MODE,  CPU_MODE_HALT);
-		tw32_f(cpu_base + CPU_PC,    info.text_base);
-		udelay(1000);
-	}
-	if (i >= 5) {
-		printk(KERN_ERR PFX "tg3_load_tso_firmware fails for %s "
-		       "to set CPU PC, is %08x should be %08x\n",
-		       tp->dev->name, tr32(cpu_base + CPU_PC),
-		       info.text_base);
-		return -ENODEV;
-	}
-	tw32(cpu_base + CPU_STATE, 0xffffffff);
-	tw32_f(cpu_base + CPU_MODE,  0x00000000);
-	return 0;
-}
-
-
 /* tp->lock is held. */
 static void __tg3_set_mac_addr(struct tg3 *tp, int skip_mac_1)
 {
@@ -5590,18 +5386,8 @@
 		tw32(BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE);
 	}
 	else if (tp->tg3_flags2 & TG3_FLG2_TSO_CAPABLE) {
-		int fw_len;
-
-		fw_len = (TG3_TSO5_FW_TEXT_LEN +
-			  TG3_TSO5_FW_RODATA_LEN +
-			  TG3_TSO5_FW_DATA_LEN +
-			  TG3_TSO5_FW_SBSS_LEN +
-			  TG3_TSO5_FW_BSS_LEN);
-		fw_len = (fw_len + (0x80 - 1)) & ~(0x80 - 1);
-		tw32(BUFMGR_MB_POOL_ADDR,
-		     NIC_SRAM_MBUF_POOL_BASE5705 + fw_len);
-		tw32(BUFMGR_MB_POOL_SIZE,
-		     NIC_SRAM_MBUF_POOL_SIZE5705 - fw_len - 0xa00);
+		tw32(BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE5705);
+		tw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE5705 - 0xa00);
 	}
 
 	if (tp->dev->mtu <= ETH_DATA_LEN) {
@@ -5980,18 +5766,6 @@
 	tw32(SNDBDI_MODE, SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE);
 	tw32(SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE);
 
-	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0) {
-		err = tg3_load_5701_a0_firmware_fix(tp);
-		if (err)
-			return err;
-	}
-
-	if (tp->tg3_flags2 & TG3_FLG2_TSO_CAPABLE) {
-		err = tg3_load_tso_firmware(tp);
-		if (err)
-			return err;
-	}
-
 	tp->tx_mode = TX_MODE_ENABLE;
 	tw32_f(MAC_TX_MODE, tp->tx_mode);
 	udelay(100);
@@ -11284,6 +11058,12 @@
 		goto err_out_iounmap;
 	}
 
+	if (tp->pci_chip_rev_id == CHIPREV_ID_5701_A0) {                                                                        
+		printk(KERN_ERR PFX "5701 A0 firmware fix not available, aborting.\n");
+		err = -ENODEV;
+		goto err_out_iounmap;
+        }     
+
 	/* The EPB bridge inside 5714, 5715, and 5780 and any
 	 * device behind the EPB cannot support DMA addresses > 40-bit.
 	 * On 64-bit systems with IOMMU, use 40-bit dma_mask.
