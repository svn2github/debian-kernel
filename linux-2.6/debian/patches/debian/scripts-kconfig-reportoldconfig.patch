diff --git a/scripts/kconfig/Makefile b/scripts/kconfig/Makefile
index 32e8c5a..7e14c56 100644
--- a/scripts/kconfig/Makefile
+++ b/scripts/kconfig/Makefile
@@ -2,7 +2,7 @@
 # Kernel configuration targets
 # These targets are used from top-level makefile
 
-PHONY += oldconfig xconfig gconfig menuconfig config silentoldconfig update-po-config
+PHONY += oldconfig xconfig gconfig menuconfig config reportoldconfig silentoldconfig updateoldconfig update-po-config
 
 Kconfig := arch/$(SRCARCH)/Kconfig
 
@@ -21,9 +21,15 @@ config: $(obj)/conf
 oldconfig: $(obj)/conf
 	$< -o $(Kconfig)
 
+reportoldconfig: $(obj)/conf
+	$< -R $(Kconfig)
+
 silentoldconfig: $(obj)/conf
 	$< -s $(Kconfig)
 
+updateoldconfig: $(obj)/conf
+	$< -U $(Kconfig)
+
 # Create new linux.pot file
 # Adjust charset to UTF-8 in .po file to accept UTF-8 in Kconfig files
 # The symlink is used to repair a deficiency in arch/um
diff --git a/scripts/kconfig/conf.c b/scripts/kconfig/conf.c
index fda6313..c9f3f3a 100644
--- a/scripts/kconfig/conf.c
+++ b/scripts/kconfig/conf.c
@@ -5,6 +5,7 @@
 
 #include <locale.h>
 #include <ctype.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -464,17 +465,106 @@ static void check_conf(struct menu *menu)
 	return 0;
 }
 
+void report_changes(void)
+{
+	struct symbol *sym;
+	struct menu *menu;
+	int type, l;
+	const char *str;
+
+	fprintf(stdout, "\n#\n"
+			"# Changes:\n"
+			"#\n");
+	menu = rootmenu.list;
+	while (menu) {
+		sym = menu->sym;
+		if (!sym) {
+			if (!menu_is_visible(menu))
+				goto next;
+		} else if (!(sym->flags & SYMBOL_CHOICE)) {
+			sym_calc_value(sym);
+			if ((sym->flags & (SYMBOL_WRITE | SYMBOL_CHANGED_REAL | SYMBOL_DEF_USER)) !=
+			    (SYMBOL_WRITE | SYMBOL_CHANGED_REAL | SYMBOL_DEF_USER))
+				goto next;
+                        if (sym->visible == no)
+                                goto next;
+			type = sym->type;
+			if (type == S_TRISTATE) {
+				sym_calc_value(modules_sym);
+				if (modules_sym->curr.tri == no)
+					type = S_BOOLEAN;
+			}
+			switch (type) {
+			case S_BOOLEAN:
+			case S_TRISTATE:
+				switch (sym_get_tristate_value(sym)) {
+				case no:
+					fprintf(stdout, "# CONFIG_%s is not set\n", sym->name);
+					break;
+				case mod:
+					fprintf(stdout, "CONFIG_%s=m\n", sym->name);
+					break;
+				case yes:
+					fprintf(stdout, "CONFIG_%s=y\n", sym->name);
+					break;
+				}
+				break;
+			case S_STRING:
+				str = sym_get_string_value(sym);
+				fprintf(stdout, "CONFIG_%s=\"", sym->name);
+				while (1) {
+					l = strcspn(str, "\"\\");
+					if (l) {
+						fwrite(str, l, 1, stdout);
+						str += l;
+					}
+					if (!*str)
+						break;
+					fprintf(stdout, "\\%c", *str++);
+				}
+				fputs("\"\n", stdout);
+				break;
+			case S_HEX:
+				str = sym_get_string_value(sym);
+				if (str[0] != '0' || (str[1] != 'x' && str[1] != 'X')) {
+					fprintf(stdout, "CONFIG_%s=%s\n", sym->name, str);
+					break;
+				}
+			case S_INT:
+				str = sym_get_string_value(sym);
+				fprintf(stdout, "CONFIG_%s=%s\n", sym->name, str);
+				break;
+			}
+		}
+
+	next:
+		if (menu->list) {
+			menu = menu->list;
+			continue;
+		}
+		if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
 int main(int ac, char **av)
 {
 	int opt;
 	const char *name;
 	struct stat tmpstat;
+	bool report = false, update = false;
 
 	setlocale(LC_ALL, "");
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	textdomain(PACKAGE);
 
-	while ((opt = getopt(ac, av, "osdD:nmyrh")) != -1) {
+	while ((opt = getopt(ac, av, "osdD:nmyrRUh")) != -1) {
 		switch (opt) {
 		case 'o':
 			input_mode = ask_new;
@@ -533,6 +623,14 @@ int main(int ac, char **av)
 			input_mode = set_random;
 			srand(time(NULL));
 			break;
+		case 'R':
+			input_mode = set_default;
+			report = update = true;
+			break;
+		case 'U':
+			input_mode = set_default;
+			update = true;
+			break;
 		case 'h':
 			printf(_("See README for usage info\n"));
 			exit(0);
@@ -551,13 +649,17 @@ int main(int ac, char **av)
 	//zconfdump(stdout);
 	switch (input_mode) {
 	case set_default:
-		if (!defconfig_file)
-			defconfig_file = conf_get_default_confname();
-		if (conf_read(defconfig_file)) {
-			printf(_("***\n"
-				"*** Can't find default configuration \"%s\"!\n"
-				"***\n"), defconfig_file);
-			exit(1);
+		if (update)
+			conf_read(NULL);
+		else {
+			if (!defconfig_file)
+				defconfig_file = conf_get_default_confname();
+			if (conf_read(defconfig_file)) {
+				printf("***\n"
+					"*** Can't find default configuration \"%s\"!\n"
+					"***\n", defconfig_file);
+				exit(1);
+			}
 		}
 		break;
 	case ask_silent:
@@ -596,6 +698,10 @@ int main(int ac, char **av)
 		break;
 	}
 
+
+	if (report)
+		report_changes();
+
 	if (conf_get_changed() && conf_write(NULL)) {
 		fprintf(stderr, _("\n*** Error during writing of the kernel configuration.\n\n"));
 		exit(1);
diff --git a/scripts/kconfig/confdata.c b/scripts/kconfig/confdata.c
index ee5fe94..3efce9f 100644
--- a/scripts/kconfig/confdata.c
+++ b/scripts/kconfig/confdata.c
@@ -366,8 +366,6 @@ int conf_read(const char *name)
 			 * doesn't quite work if the Kconfig and the saved
 			 * configuration disagree.
 			 */
-			if (sym->visible == no && !conf_unsaved)
-				sym->flags &= ~SYMBOL_DEF_USER;
 			switch (sym->type) {
 			case S_STRING:
 			case S_INT:
diff --git a/scripts/kconfig/expr.h b/scripts/kconfig/expr.h
index 9d4cba1..439608b 100644
--- a/scripts/kconfig/expr.h
+++ b/scripts/kconfig/expr.h
@@ -100,6 +100,7 @@ struct symbol {
 #define SYMBOL_DEF_AUTO		0x20000
 #define SYMBOL_DEF3		0x40000
 #define SYMBOL_DEF4		0x80000
+#define SYMBOL_CHANGED_REAL	0x100000
 
 #define SYMBOL_MAXLENGTH	256
 #define SYMBOL_HASHSIZE		257
diff --git a/scripts/kconfig/lkc.h b/scripts/kconfig/lkc.h
index 4bc68f2..4590130 100644
--- a/scripts/kconfig/lkc.h
+++ b/scripts/kconfig/lkc.h
@@ -110,7 +110,7 @@ extern struct expr *sym_env_list;
 void sym_init(void);
 void sym_clear_all_valid(void);
 void sym_set_all_changed(void);
-void sym_set_changed(struct symbol *sym);
+void sym_set_changed(struct symbol *sym, bool real);
 struct symbol *sym_check_deps(struct symbol *sym);
 struct property *prop_alloc(enum prop_type type, struct symbol *sym);
 struct symbol *prop_get_symbol(struct property *prop);
diff --git a/scripts/kconfig/symbol.c b/scripts/kconfig/symbol.c
index 3929e5b..b035410 100644
--- a/scripts/kconfig/symbol.c
+++ b/scripts/kconfig/symbol.c
@@ -4,6 +4,7 @@
  */
 
 #include <ctype.h>
+#include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
 #include <regex.h>
@@ -201,7 +202,7 @@ static void sym_calc_visibility(struct symbol *sym)
 		tri = yes;
 	if (sym->visible != tri) {
 		sym->visible = tri;
-		sym_set_changed(sym);
+		sym_set_changed(sym, false);
 	}
 	if (sym_is_choice_value(sym))
 		return;
@@ -212,7 +213,7 @@ static void sym_calc_visibility(struct symbol *sym)
 		tri = yes;
 	if (sym->rev_dep.tri != tri) {
 		sym->rev_dep.tri = tri;
-		sym_set_changed(sym);
+		sym_set_changed(sym, false);
 	}
 }
 
@@ -351,7 +352,7 @@ void sym_calc_value(struct symbol *sym)
 	sym_validate_range(sym);
 
 	if (memcmp(&oldval, &sym->curr, sizeof(oldval))) {
-		sym_set_changed(sym);
+		sym_set_changed(sym, false);
 		if (modules_sym == sym) {
 			sym_set_all_changed();
 			modules_val = modules_sym->curr.tri;
@@ -366,7 +367,7 @@ void sym_calc_value(struct symbol *sym)
 		expr_list_for_each_sym(prop->expr, e, choice_sym) {
 			choice_sym->flags |= flags;
 			if (flags & SYMBOL_CHANGED)
-				sym_set_changed(choice_sym);
+				sym_set_changed(choice_sym, false);
 		}
 	}
 
@@ -383,11 +384,13 @@ void sym_clear_all_valid(void)
 		sym_calc_value(modules_sym);
 }
 
-void sym_set_changed(struct symbol *sym)
+void sym_set_changed(struct symbol *sym, bool real)
 {
 	struct property *prop;
 
 	sym->flags |= SYMBOL_CHANGED;
+	if (real)
+		sym->flags |= SYMBOL_CHANGED_REAL;
 	for (prop = sym->prop; prop; prop = prop->next) {
 		if (prop->menu)
 			prop->menu->flags |= MENU_CHANGED;
@@ -400,7 +403,7 @@ void sym_set_all_changed(void)
 	int i;
 
 	for_all_symbols(i, sym)
-		sym_set_changed(sym);
+		sym_set_changed(sym, false);
 }
 
 bool sym_tristate_within_range(struct symbol *sym, tristate val)
@@ -431,7 +434,7 @@ bool sym_set_tristate_value(struct symbol *sym, tristate val)
 
 	if (!(sym->flags & SYMBOL_DEF_USER)) {
 		sym->flags |= SYMBOL_DEF_USER;
-		sym_set_changed(sym);
+		sym_set_changed(sym, true);
 	}
 	/*
 	 * setting a choice value also resets the new flag of the choice
@@ -593,7 +596,7 @@ bool sym_set_string_value(struct symbol *sym, const char *newval)
 
 	if (!(sym->flags & SYMBOL_DEF_USER)) {
 		sym->flags |= SYMBOL_DEF_USER;
-		sym_set_changed(sym);
+		sym_set_changed(sym, true);
 	}
 
 	oldval = sym->def[S_DEF_USER].val;
