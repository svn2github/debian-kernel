# Add an MTD maps for IOP3xx boards
# Upstream status: can be solved in a better way as of 2.6.18

diff -urN a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
--- a/drivers/mtd/maps/Kconfig	2006-08-03 11:39:05.885006500 +0000
+++ b/drivers/mtd/maps/Kconfig	2006-08-07 17:19:06.190596000 +0000
@@ -447,6 +447,14 @@
 	  21285 bridge used with Intel's StrongARM processors. More info at
 	  <http://www.intel.com/design/bridge/docs/21285_documentation.htm>.
 
+config MTD_IOP3XX
+	tristate "CFI Flash device mapped on the XScale IOP3XX board"
+	depends on ARM && MTD_CFI && ARCH_IOP3XX
+	help
+	  This enables access routines for the flash chips on the Intel XScale
+	  IOP3XX based evaluation board. If you have one of these boards and
+	  would like to use the flash chips on it, say 'Y'.
+
 config MTD_IQ80310
 	tristate "CFI Flash device mapped on the XScale IQ80310 board"
 	depends on MTD_CFI && ARCH_IQ80310
diff -urN a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
--- a/drivers/mtd/maps/Makefile	2006-08-03 11:39:05.885006500 +0000
+++ b/drivers/mtd/maps/Makefile	2006-08-07 17:18:53.981833000 +0000
@@ -15,7 +15,7 @@
 obj-$(CONFIG_MTD_CSTM_MIPS_IXX)	+= cstm_mips_ixx.o
 obj-$(CONFIG_MTD_DC21285)	+= dc21285.o
 obj-$(CONFIG_MTD_DILNETPC)	+= dilnetpc.o
-obj-$(CONFIG_MTD_IQ80310)	+= iq80310.o
+obj-$(CONFIG_MTD_IOP3XX)	+= iop3xx.o
 obj-$(CONFIG_MTD_L440GX)	+= l440gx.o
 obj-$(CONFIG_MTD_AMD76XROM)	+= amd76xrom.o
 obj-$(CONFIG_MTD_ICHXROM)	+= ichxrom.o
diff -urN a/drivers/mtd/maps/iop3xx.c b/drivers/mtd/maps/iop3xx.c
--- a/drivers/mtd/maps/iop3xx.c	1970-01-01 00:00:00.000000000 +0000
+++ b/drivers/mtd/maps/iop3xx.c	2006-08-07 17:18:53.981833000 +0000
@@ -0,0 +1,150 @@
+/*
+ * $Id: iop3xx.c,v 1.17 2003/06/23 11:48:18 dwmw2 Exp $
+ *
+ * Mapping for Intel XScale IOP3xx based platforms
+ *
+ * Author:	Nicolas Pitre
+ * Copyright:	(C) 2001-2003 MontaVista Software Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * 09/03: Cleaned up to be generic to all IOP3xx systems - ds
+ *
+ * If you add a new machine type with a different WINDOW_SIZE or 
+ * physmap addr, just wrap the init in if(machine_is_X()) { }
+ * and make sure your board header gets included in 
+ * include/asm-arm/arch-iop3xx/hardware.h to pick up the definitions.
+ *
+ * DO NOT fill this file with #ifdef CONFIG_ARCH_XXXX crap.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+static struct mtd_info *mymtd;
+
+static struct map_info iop3xx_map = {
+	.name = "IOP3xx Flash",
+};
+
+static struct mtd_partition iop3xx_partitions[6] = {
+	{
+		.name =		"RedBoot",
+		.size =		0x00040000,
+		.offset =	0,
+	},{
+		.name =		"ramdisk",
+		.size =		0x00d00000,
+		.offset =	0x00040000,
+	},{
+		.name =		"kernel",
+		.size =		0x00160000,
+		.offset =	0x00d40000
+	},{
+		.name =		"user",
+		.size =		0x00120000,
+		.offset =	0x00ea0000
+	},{
+		.name =		"RedBoot config",
+		.size =		0x00020000,
+		.offset =	0x00fc0000,
+	//	.mask_flags =	MTD_WRITEABLE
+	},{ 
+                .name =         "FIS directory",
+                .size =         0x00020000,
+                .offset =       0x00fe0000
+        }
+};
+
+static struct mtd_info *mymtd;
+static struct mtd_partition *parsed_parts;
+static const char *probes[] = { "RedBoot", "cmdlinepart", NULL };
+
+static int __init init_iop3xx(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	int parsed_nr_parts = 0;
+	int ret;
+
+	if(machine_is_iq80321()) {
+		iop3xx_map.phys = IQ80321_FLASHBASE;
+		iop3xx_map.size = IQ80321_FLASHSIZE;
+		iop3xx_map.bankwidth = IQ80321_FLASHWIDTH;
+	} else if(machine_is_iq31244()) {
+		iop3xx_map.phys = IQ31244_FLASHBASE;
+		iop3xx_map.size = IQ31244_FLASHSIZE;
+		iop3xx_map.bankwidth = IQ31244_FLASHWIDTH;
+	} else if(machine_is_iq80331()) {
+		iop3xx_map.phys = IQ80331_FLASHBASE;
+		iop3xx_map.size = IQ80331_FLASHSIZE;
+		iop3xx_map.bankwidth = IQ80331_FLASHWIDTH;
+	} else if(machine_is_n2100()) {
+		iop3xx_map.phys = N2100_FLASHBASE;
+		iop3xx_map.size = N2100_FLASHSIZE;
+		iop3xx_map.bankwidth = N2100_FLASHWIDTH;
+	} else {
+		printk("Unknown IOP3xx platform - flash access disabled\n");
+		return -ENODEV;
+	}
+
+	iop3xx_map.virt = 
+		(unsigned long)ioremap(iop3xx_map.phys, iop3xx_map.size );
+	if (!iop3xx_map.virt) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	simple_map_init(&iop3xx_map);
+
+	mymtd = do_map_probe("cfi_probe", &iop3xx_map);
+	if (!mymtd) {
+		iounmap((void *)iop3xx_map.virt);
+		return -ENXIO;
+	}
+	mymtd->owner = THIS_MODULE;
+
+	ret = parse_mtd_partitions(mymtd, probes, &parsed_parts, 0);
+	ret=-1;
+	if (ret > 0)
+		parsed_nr_parts = ret;
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nb_parts = parsed_nr_parts;
+	} else {
+		parts = iop3xx_partitions;
+		nb_parts = ARRAY_SIZE(iop3xx_partitions);
+	}
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit cleanup_iop3xx(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (iop3xx_map.virt)
+		iounmap((void *)iop3xx_map.virt);
+}
+
+module_init(init_iop3xx);
+module_exit(cleanup_iop3xx);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nicolas Pitre <nico@cam.org>");
+MODULE_DESCRIPTION("MTD map driver for Intel XScale IOP3xx Platforms");

