Upstream status: will go into 2.6.17


Fix VINO drivers when using a 64-bit kernel

This patch should fix problems with VINO drivers when using a 64-bit
kernel.

There are also other bugs which prevent V4L drivers from functioning
correctly when using 32-bit userland with a 64-bit kernel as the ioctl
compatibility layer (in drivers/media/video/compat_ioctl32.c) doesn't seem
to handle VIDIOC_CROPCAP. I'm not sure if any other ioctls are missing.


diff -urN a/drivers/media/video/indycam.c b/drivers/media/video/indycam.c
--- a/drivers/media/video/indycam.c	2006-03-17 14:04:42.000000000 +0200
+++ b/drivers/media/video/indycam.c	2006-03-17 14:04:55.000000000 +0200
@@ -2,7 +2,7 @@
  *  indycam.c - Silicon Graphics IndyCam digital camera driver
  *
  *  Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
- *  Copyright (C) 2004,2005 Mikael Nousiainen <tmnousia@cc.hut.fi>
+ *  Copyright (C) 2004,2005,2006 Mikael Nousiainen <tmnousia@cc.hut.fi>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
@@ -27,7 +27,7 @@
 
 #include "indycam.h"
 
-#define INDYCAM_MODULE_VERSION "0.0.5"
+#define INDYCAM_MODULE_VERSION "0.0.6"
 
 MODULE_DESCRIPTION("SGI IndyCam driver");
 MODULE_VERSION(INDYCAM_MODULE_VERSION);
diff -urN a/drivers/media/video/saa7191.c b/drivers/media/video/saa7191.c
--- a/drivers/media/video/saa7191.c	2006-03-17 14:04:42.000000000 +0200
+++ b/drivers/media/video/saa7191.c	2006-03-17 14:04:55.000000000 +0200
@@ -2,7 +2,7 @@
  *  saa7191.c - Philips SAA7191 video decoder driver
  *
  *  Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
- *  Copyright (C) 2004,2005 Mikael Nousiainen <tmnousia@cc.hut.fi>
+ *  Copyright (C) 2004,2005,2006 Mikael Nousiainen <tmnousia@cc.hut.fi>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
@@ -26,7 +26,7 @@
 
 #include "saa7191.h"
 
-#define SAA7191_MODULE_VERSION	"0.0.5"
+#define SAA7191_MODULE_VERSION	"0.0.6"
 
 MODULE_DESCRIPTION("Philips SAA7191 video decoder driver");
 MODULE_VERSION(SAA7191_MODULE_VERSION);
diff -urN a/drivers/media/video/vino.c b/drivers/media/video/vino.c
--- a/drivers/media/video/vino.c	2006-03-17 14:04:42.000000000 +0200
+++ b/drivers/media/video/vino.c	2006-03-17 14:04:55.000000000 +0200
@@ -4,7 +4,7 @@
  * This file is subject to the terms and conditions of the GNU General Public
  * License version 2 as published by the Free Software Foundation.
  *
- * Copyright (C) 2004,2005 Mikael Nousiainen <tmnousia@cc.hut.fi>
+ * Copyright (C) 2004,2005,2006 Mikael Nousiainen <tmnousia@cc.hut.fi>
  *
  * Based on the previous version of the driver for 2.4 kernels by:
  * Copyright (C) 2003 Ladislav Michl <ladis@linux-mips.org>
@@ -58,8 +58,8 @@
 // #define VINO_DEBUG
 // #define VINO_DEBUG_INT
 
-#define VINO_MODULE_VERSION "0.0.5"
-#define VINO_VERSION_CODE KERNEL_VERSION(0, 0, 5)
+#define VINO_MODULE_VERSION "0.0.6"
+#define VINO_VERSION_CODE KERNEL_VERSION(0, 0, 6)
 
 MODULE_DESCRIPTION("SGI VINO Video4Linux2 driver");
 MODULE_VERSION(VINO_MODULE_VERSION);
@@ -150,6 +150,9 @@
 
 /* Internal data structure definitions */
 
+/* DMA addresses in VINO descriptor table are always 32-bit */
+typedef u32 vino_dma_addr_t;
+
 struct vino_input {
 	char *name;
 	v4l2_std_id std;
@@ -190,7 +193,7 @@
 
 	/* cpu address for the VINO descriptor table
 	 * (contains DMA addresses, VINO_PAGE_SIZE chunks) */
-	unsigned long *dma_cpu;
+	vino_dma_addr_t *dma_cpu;
 	/* dma address for the VINO descriptor table
 	 * (contains DMA addresses, VINO_PAGE_SIZE chunks) */
 	dma_addr_t dma;
@@ -817,7 +820,7 @@
 
 	dma_free_coherent(NULL,
 			  VINO_PAGE_RATIO * (fb->desc_table.page_count + 4) *
-			  sizeof(dma_addr_t), (void *)fb->desc_table.dma_cpu,
+			  sizeof(vino_dma_addr_t), (void *)fb->desc_table.dma_cpu,
 			  fb->desc_table.dma);
 	kfree(fb->desc_table.virtual);
 
@@ -857,7 +860,7 @@
 	 * (has space for four extra descriptors) */
 	fb->desc_table.dma_cpu =
 		dma_alloc_coherent(NULL, VINO_PAGE_RATIO * (count + 4) *
-				   sizeof(dma_addr_t), &fb->desc_table.dma,
+				   sizeof(vino_dma_addr_t), &fb->desc_table.dma,
 				   GFP_KERNEL | GFP_DMA);
 	if (!fb->desc_table.dma_cpu) {
 		ret = -ENOMEM;
@@ -913,93 +916,6 @@
 	return ret;
 }
 
-#if 0
-/* user buffers not fully implemented yet */
-static int vino_prepare_user_buffer(struct vino_framebuffer *fb,
-				     void *user,
-				     unsigned int size)
-{
-	unsigned int count, i, j;
-	int ret = 0;
-
-	dprintk("vino_prepare_user_buffer():\n");
-
-	if (size < 1)
-		return -EINVAL;
-
-	memset(fb, 0, sizeof(struct vino_framebuffer));
-
-	count = ((size / PAGE_SIZE)) & ~3;
-
-	dprintk("vino_prepare_user_buffer(): size = %d, count = %d\n",
-		size, count);
-
-	/* allocate memory for table with virtual (page) addresses */
-	fb->desc_table.virtual = (unsigned long *)
-		kmalloc(count * sizeof(unsigned long), GFP_KERNEL);
-	if (!fb->desc_table.virtual)
-		return -ENOMEM;
-
-	/* allocate memory for table with dma addresses
-	 * (has space for four extra descriptors) */
-	fb->desc_table.dma_cpu =
-		dma_alloc_coherent(NULL, VINO_PAGE_RATIO * (count + 4) *
-				   sizeof(dma_addr_t), &fb->desc_table.dma,
-				   GFP_KERNEL | GFP_DMA);
-	if (!fb->desc_table.dma_cpu) {
-		ret = -ENOMEM;
-		goto out_free_virtual;
-	}
-
-	/* allocate pages for the buffer and acquire the according
-	 * dma addresses */
-	for (i = 0; i < count; i++) {
-		dma_addr_t dma_data_addr;
-
-		fb->desc_table.virtual[i] =
-			get_zeroed_page(GFP_KERNEL | GFP_DMA);
-		if (!fb->desc_table.virtual[i]) {
-			ret = -ENOBUFS;
-			break;
-		}
-
-		dma_data_addr =
-			dma_map_single(NULL,
-				       (void *)fb->desc_table.virtual[i],
-				       PAGE_SIZE, DMA_FROM_DEVICE);
-
-		for (j = 0; j < VINO_PAGE_RATIO; j++) {
-			fb->desc_table.dma_cpu[VINO_PAGE_RATIO * i + j] =
-				dma_data_addr + VINO_PAGE_SIZE * j;
-		}
-
-		SetPageReserved(virt_to_page(fb->desc_table.virtual[i]));
-	}
-
-	/* page_count needs to be set anyway, because the descriptor table has
-	 * been allocated according to this number */
-	fb->desc_table.page_count = count;
-
-	if (ret) {
-		/* the descriptor with index i doesn't contain
-		 * a valid address yet */
-		vino_free_buffer_with_count(fb, i);
-		return ret;
-	}
-
-	//fb->size = size;
-	fb->size = count * PAGE_SIZE;
-
-	/* set the dma stop-bit for the last (count+1)th descriptor */
-	fb->desc_table.dma_cpu[VINO_PAGE_RATIO * count] = VINO_DESC_STOP;
-	return 0;
-
- out_free_virtual:
-	kfree(fb->desc_table.virtual);
-	return ret;
-}
-#endif
-
 static void vino_sync_buffer(struct vino_framebuffer *fb)
 {
 	int i;
@@ -4394,6 +4310,7 @@
 	.open		= vino_open,
 	.release	= vino_close,
 	.ioctl		= vino_ioctl,
+	.compat_ioctl	= v4l_compat_ioctl32,
 	.mmap		= vino_mmap,
 	.poll		= vino_poll,
 	.llseek		= no_llseek,
@@ -4436,8 +4353,8 @@
 		dma_unmap_single(NULL,
 				 vino_drvdata->dummy_desc_table.dma_cpu[0],
 				 PAGE_SIZE, DMA_FROM_DEVICE);
-		dma_free_coherent(NULL, VINO_DUMMY_DESC_COUNT
-				  * sizeof(dma_addr_t),
+		dma_free_coherent(NULL, vino_drvdata->dummy_desc_table.page_count
+				  * sizeof(vino_dma_addr_t),
 				  (void *)vino_drvdata->
 				  dummy_desc_table.dma_cpu,
 				  vino_drvdata->dummy_desc_table.dma);
@@ -4514,11 +4431,13 @@
 	}
 	vino_init_stage++;
 
-	// TODO: use page_count in dummy_desc_table
+	vino_drvdata->dummy_desc_table.page_count =
+		VINO_DUMMY_DESC_COUNT;
 
 	vino_drvdata->dummy_desc_table.dma_cpu =
 		dma_alloc_coherent(NULL,
-		VINO_DUMMY_DESC_COUNT * sizeof(dma_addr_t),
+		vino_drvdata->dummy_desc_table.page_count *
+				   sizeof(vino_dma_addr_t),
 		&vino_drvdata->dummy_desc_table.dma,
 		GFP_KERNEL | GFP_DMA);
 	if (!vino_drvdata->dummy_desc_table.dma_cpu) {
@@ -4529,8 +4448,8 @@
 
 	dma_dummy_address = dma_map_single(NULL,
 					   (void *)vino_drvdata->dummy_page,
-					PAGE_SIZE, DMA_FROM_DEVICE);
-	for (i = 0; i < VINO_DUMMY_DESC_COUNT; i++) {
+					   PAGE_SIZE, DMA_FROM_DEVICE);
+	for (i = 0; i < vino_drvdata->dummy_desc_table.page_count; i++) {
 		vino_drvdata->dummy_desc_table.dma_cpu[i] = dma_dummy_address;
 	}
 
