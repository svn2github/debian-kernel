From: Karl-Johan Karlsson <creideiki+linux-mips@ferretporn.se>
Date: Sat, 7 Oct 2006 23:15:02 +0000 (+0200)
Subject: [MIPS] Show actual CPU information in /proc/cpuinfo
X-Git-Tag: linux-1.1.68
X-Git-Url: http://www.linux-mips.org/git?p=linux.git;a=commitdiff;h=fc3dee0744865746ad02824e241442edc6ce7a07

[MIPS] Show actual CPU information in /proc/cpuinfo

Currently, /proc/cpuinfo contains several copies of the information for
whatever processor we happen to be scheduled on. This patch makes it contain
the proper information for each CPU, which is particularly useful on mixed
R12k/R10k IP27 machines.

Signed-off-by: Karl-Johan Karlsson <creideiki@lysator.liu.se>
Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
(cherry picked from fa91b67b68a484c0cd69f29ef9acb3683bc82928 commit)
---

--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -89,9 +89,9 @@ static const char *cpu_name[] = {
 
 static int show_cpuinfo(struct seq_file *m, void *v)
 {
-	unsigned int version = current_cpu_data.processor_id;
-	unsigned int fp_vers = current_cpu_data.fpu_id;
 	unsigned long n = (unsigned long) v - 1;
+	unsigned int version = cpu_data[n].processor_id;
+	unsigned int fp_vers = cpu_data[n].fpu_id;
 	char fmt [64];
 
 #ifdef CONFIG_SMP
@@ -108,8 +108,8 @@ static int show_cpuinfo(struct seq_file 
 	seq_printf(m, "processor\t\t: %ld\n", n);
 	sprintf(fmt, "cpu model\t\t: %%s V%%d.%%d%s\n",
 	        cpu_has_fpu ? "  FPU V%d.%d" : "");
-	seq_printf(m, fmt, cpu_name[current_cpu_data.cputype <= CPU_LAST ?
-	                            current_cpu_data.cputype : CPU_UNKNOWN],
+	seq_printf(m, fmt, cpu_name[cpu_data[n].cputype <= CPU_LAST ?
+	                            cpu_data[n].cputype : CPU_UNKNOWN],
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
@@ -118,7 +118,7 @@ static int show_cpuinfo(struct seq_file 
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 	              cpu_has_counter ? "yes" : "no");
-	seq_printf(m, "tlb_entries\t\t: %d\n", current_cpu_data.tlbsize);
+	seq_printf(m, "tlb_entries\t\t: %d\n", cpu_data[n].tlbsize);
 	seq_printf(m, "extra interrupt vector\t: %s\n",
 	              cpu_has_divec ? "yes" : "no");
 	seq_printf(m, "hardware watchpoint\t: %s\n",
