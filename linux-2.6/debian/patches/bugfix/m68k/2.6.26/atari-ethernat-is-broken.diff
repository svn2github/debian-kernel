
FIXME marked it broken for now, until the remaining issues are fixed.

---
 drivers/net/Kconfig        |    2 
 drivers/net/atari_91C111.c |  208 ++++++++++++++++++++++-----------------------
 2 files changed, 105 insertions(+), 105 deletions(-)

--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -426,7 +426,7 @@ config ATARI_ETHERNAT
 	tristate "Atari EtherNAT Ethernet support"
 	select CRC32
 	select MII
-	depends on NET_ETHERNET && ATARI
+	depends on NET_ETHERNET && ATARI && BROKEN
 	help
 	  Say Y to include support for the EtherNAT network adapter for the
 	  CT/60 extension port. The driver works by polling instead of
--- a/drivers/net/atari_91C111.c
+++ b/drivers/net/atari_91C111.c
@@ -231,7 +231,7 @@ static void PRINT_PKT(u_char *buf, int l
 	spin_lock_irq(&lp->lock);					\
 	mask = SMC_GET_INT_MASK();					\
 	mask |= (x);							\
-	SMC_SET_INT_MASK(mask);						\
+	SMC_SET_INT_MASK(lp, mask);					\
 	spin_unlock_irq(&lp->lock);					\
 } while (0)
 
@@ -241,7 +241,7 @@ static void PRINT_PKT(u_char *buf, int l
 	spin_lock_irq(&lp->lock);					\
 	mask = SMC_GET_INT_MASK();					\
 	mask &= ~(x);							\
-	SMC_SET_INT_MASK(mask);						\
+	SMC_SET_INT_MASK(lp, mask);					\
 	spin_unlock_irq(&lp->lock);					\
 } while (0)
 
@@ -345,8 +345,8 @@ static void smc_reset(struct net_device 
 
 	/* Disable all interrupts, block TX tasklet */
 	spin_lock_irq(&lp->lock);
-	SMC_SELECT_BANK(2);
-	SMC_SET_INT_MASK(0);
+	SMC_SELECT_BANK(lp, 2);
+	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
 	spin_unlock_irq(&lp->lock);
@@ -362,15 +362,15 @@ static void smc_reset(struct net_device 
 	 * This resets the registers mostly to defaults, but doesn't
 	 * affect EEPROM.  That seems unnecessary
 	 */
-	SMC_SELECT_BANK(0);
-	SMC_SET_RCR(RCR_SOFTRST);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_RCR(lp, RCR_SOFTRST);
 
 	/*
 	 * Setup the Configuration Register
 	 * This is necessary because the CONFIG_REG is not affected
 	 * by a soft reset
 	 */
-	SMC_SELECT_BANK(1);
+	SMC_SELECT_BANK(lp, 1);
 
 	cfg = CONFIG_DEFAULT;
 
@@ -388,7 +388,7 @@ static void smc_reset(struct net_device 
 	 */
 	cfg |= CONFIG_EPH_POWER_EN;
 
-	SMC_SET_CONFIG(cfg);
+	SMC_SET_CONFIG(lp, cfg);
 
 	/* this should pause enough for the chip to be happy */
 	/*
@@ -401,11 +401,11 @@ static void smc_reset(struct net_device 
 	udelay(1);
 
 	/* Disable transmit and receive functionality */
-	SMC_SELECT_BANK(0);
-	SMC_SET_RCR(RCR_CLEAR);
-	SMC_SET_TCR(TCR_CLEAR);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_RCR(lp, RCR_CLEAR);
+	SMC_SET_TCR(lp, TCR_CLEAR);
 
-	SMC_SELECT_BANK(1);
+	SMC_SELECT_BANK(lp, 1);
 	ctl = SMC_GET_CTL() | CTL_LE_ENABLE;
 
 	/*
@@ -417,11 +417,11 @@ static void smc_reset(struct net_device 
 		ctl |= CTL_AUTO_RELEASE;
 	else
 		ctl &= ~CTL_AUTO_RELEASE;
-	SMC_SET_CTL(ctl);
+	SMC_SET_CTL(lp, ctl);
 
 	/* Reset the MMU */
-	SMC_SELECT_BANK(2);
-	SMC_SET_MMU_CMD(MC_RESET);
+	SMC_SELECT_BANK(lp, 2);
+	SMC_SET_MMU_CMD(lp, MC_RESET);
 	SMC_WAIT_MMU_BUSY();
 }
 
@@ -437,19 +437,19 @@ static void smc_enable(struct net_device
 	DBG(2, "%s: %s\n", dev->name, __FUNCTION__);
 
 	/* see the header file for options in TCR/RCR DEFAULT */
-	SMC_SELECT_BANK(0);
-	SMC_SET_TCR(lp->tcr_cur_mode);
-	SMC_SET_RCR(lp->rcr_cur_mode);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_TCR(lp, lp->tcr_cur_mode);
+	SMC_SET_RCR(lp, lp->rcr_cur_mode);
 
-	SMC_SELECT_BANK(1);
-	SMC_SET_MAC_ADDR(dev->dev_addr);
+	SMC_SELECT_BANK(lp, 1);
+	SMC_SET_MAC_ADDR(lp, dev->dev_addr);
 
 	/* now, enable interrupts */
 	mask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;
 	if (lp->version >= (CHIP_91100 << 4))
 		mask |= IM_MDINT;
-	SMC_SELECT_BANK(2);
-	SMC_SET_INT_MASK(mask);
+	SMC_SELECT_BANK(lp, 2);
+	SMC_SET_INT_MASK(lp, mask);
 
 	/*
 	 * From this point the register bank must _NOT_ be switched away
@@ -472,8 +472,8 @@ static void smc_shutdown(struct net_devi
 
 	/* no more interrupts for me */
 	spin_lock_irq(&lp->lock);
-	SMC_SELECT_BANK(2);
-	SMC_SET_INT_MASK(0);
+	SMC_SELECT_BANK(lp, 2);
+	SMC_SET_INT_MASK(lp, 0);
 	pending_skb = lp->pending_tx_skb;
 	lp->pending_tx_skb = NULL;
 	spin_unlock_irq(&lp->lock);
@@ -481,14 +481,14 @@ static void smc_shutdown(struct net_devi
 		dev_kfree_skb(pending_skb);
 
 	/* and tell the card to stay away from that nasty outside world */
-	SMC_SELECT_BANK(0);
-	SMC_SET_RCR(RCR_CLEAR);
-	SMC_SET_TCR(TCR_CLEAR);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_RCR(lp, RCR_CLEAR);
+	SMC_SET_TCR(lp, TCR_CLEAR);
 
 #ifdef POWER_DOWN
 	/* finally, shut the chip down */
-	SMC_SELECT_BANK(1);
-	SMC_SET_CONFIG(SMC_GET_CONFIG() & ~CONFIG_EPH_POWER_EN);
+	SMC_SELECT_BANK(lp, 1);
+	SMC_SET_CONFIG(lp, SMC_GET_CONFIG() & ~CONFIG_EPH_POWER_EN);
 #endif
 }
 
@@ -510,10 +510,10 @@ static inline void  smc_rcv(struct net_d
 	}
 
 	/* read from start of packet */
-	SMC_SET_PTR(PTR_READ | PTR_RCV | PTR_AUTOINC);
+	SMC_SET_PTR(lp, PTR_READ | PTR_RCV | PTR_AUTOINC);
 
 	/* First two words are status and packet length */
-	SMC_GET_PKT_HDR(status, packet_len);
+	SMC_GET_PKT_HDR(lp, status, packet_len);
 	packet_len &= 0x07ff;  /* mask off top bits */
 	DBG(2, "%s: RX PNR 0x%x STATUS 0x%04x LENGTH 0x%04x (%d)\n",
 		dev->name, packet_number, status,
@@ -533,7 +533,7 @@ static inline void  smc_rcv(struct net_d
 			status |= RS_TOOSHORT;
 		}
 		SMC_WAIT_MMU_BUSY();
-		SMC_SET_MMU_CMD(MC_RELEASE);
+		SMC_SET_MMU_CMD(lp, MC_RELEASE);
 		dev->stats.rx_errors++;
 		if (status & RS_ALGNERR)
 			dev->stats.rx_frame_errors++;
@@ -563,7 +563,7 @@ static inline void  smc_rcv(struct net_d
 			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
 				dev->name);
 			SMC_WAIT_MMU_BUSY();
-			SMC_SET_MMU_CMD(MC_RELEASE);
+			SMC_SET_MMU_CMD(lp, MC_RELEASE);
 			dev->stats.rx_dropped++;
 			return;
 		}
@@ -582,10 +582,10 @@ static inline void  smc_rcv(struct net_d
 		 */
 		data_len = packet_len - ((status & RS_ODDFRAME) ? 5 : 6);
 		data = skb_put(skb, data_len);
-		SMC_PULL_DATA(data, packet_len - 4);
+		SMC_PULL_DATA(lp, data, packet_len - 4);
 
 		SMC_WAIT_MMU_BUSY();
-		SMC_SET_MMU_CMD(MC_RELEASE);
+		SMC_SET_MMU_CMD(lp, MC_RELEASE);
 
 		PRINT_PKT(data, packet_len - 4);
 
@@ -673,8 +673,8 @@ static void smc_hardware_send_pkt(unsign
 	}
 
 	/* point to the beginning of the packet */
-	SMC_SET_PN(packet_no);
-	SMC_SET_PTR(PTR_AUTOINC);
+	SMC_SET_PN(lp, packet_no);
+	SMC_SET_PTR(lp, PTR_AUTOINC);
 
 	buf = skb->data;
 	len = skb->len;
@@ -686,10 +686,10 @@ static void smc_hardware_send_pkt(unsign
 	 * Send the packet length (+6 for status words, length, and ctl.
 	 * The card will pad to 64 bytes with zeroes if packet is too small.
 	 */
-	SMC_PUT_PKT_HDR(0, len + 6);
+	SMC_PUT_PKT_HDR(lp, 0, len + 6);
 
 	/* send the actual data */
-	SMC_PUSH_DATA(buf, len & ~1);
+	SMC_PUSH_DATA(lp, buf, len & ~1);
 
 	/* Send final ctl word with the last byte if there is one */
 	SMC_outw(((len & 1) ? (0x2000 | buf[len-1]) : 0), ioaddr, DATA_REG);
@@ -706,7 +706,7 @@ static void smc_hardware_send_pkt(unsign
 		netif_stop_queue(dev);
 
 	/* queue the packet for TX */
-	SMC_SET_MMU_CMD(MC_ENQUEUE);
+	SMC_SET_MMU_CMD(lp, MC_ENQUEUE);
 	smc_special_unlock(&lp->lock);
 
 	dev->trans_start = jiffies;
@@ -760,7 +760,7 @@ static int smc_hard_start_xmit(struct sk
 	smc_special_lock(&lp->lock);
 
 	/* now, try to allocate the memory */
-	SMC_SET_MMU_CMD(MC_ALLOC | numPages);
+	SMC_SET_MMU_CMD(lp, MC_ALLOC | numPages);
 
 	/*
 	 * Poll the chip for a short amount of time in case the
@@ -770,7 +770,7 @@ static int smc_hard_start_xmit(struct sk
 	do {
 		status = SMC_GET_INT();
 		if (status & IM_ALLOC_INT) {
-			SMC_ACK_INT(IM_ALLOC_INT);
+			SMC_ACK_INT(lp, IM_ALLOC_INT);
   			break;
 		}
    	} while (--poll_count);
@@ -816,11 +816,11 @@ static void smc_tx(struct net_device *de
 
 	/* select packet to read from */
 	saved_packet = SMC_GET_PN();
-	SMC_SET_PN(packet_no);
+	SMC_SET_PN(lp, packet_no);
 
 	/* read the first word (status word) from this packet */
-	SMC_SET_PTR(PTR_AUTOINC | PTR_READ);
-	SMC_GET_PKT_HDR(tx_status, pkt_len);
+	SMC_SET_PTR(lp, PTR_AUTOINC | PTR_READ);
+	SMC_GET_PKT_HDR(lp, tx_status, pkt_len);
 	DBG(2, "%s: TX STATUS 0x%04x PNR 0x%02x\n",
 		dev->name, tx_status, packet_no);
 
@@ -844,16 +844,16 @@ static void smc_tx(struct net_device *de
 
 	/* kill the packet */
 	SMC_WAIT_MMU_BUSY();
-	SMC_SET_MMU_CMD(MC_FREEPKT);
+	SMC_SET_MMU_CMD(lp, MC_FREEPKT);
 
 	/* Don't restore Packet Number Reg until busy bit is cleared */
 	SMC_WAIT_MMU_BUSY();
-	SMC_SET_PN(saved_packet);
+	SMC_SET_PN(lp, saved_packet);
 
 	/* re-enable transmit */
-	SMC_SELECT_BANK(0);
-	SMC_SET_TCR(lp->tcr_cur_mode);
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_TCR(lp, lp->tcr_cur_mode);
+	SMC_SELECT_BANK(lp, 2);
 }
 
 
@@ -874,9 +874,9 @@ static void smc_mii_out(struct net_devic
 		else
 			mii_reg &= ~MII_MDO;
 
-		SMC_SET_MII(mii_reg);
+		SMC_SET_MII(lp, mii_reg);
 		udelay(MII_DELAY);
-		SMC_SET_MII(mii_reg | MII_MCLK);
+		SMC_SET_MII(lp, mii_reg | MII_MCLK);
 		udelay(MII_DELAY);
 	}
 }
@@ -888,15 +888,15 @@ static unsigned int smc_mii_in(struct ne
 	unsigned int mii_reg, mask, val;
 
 	mii_reg = SMC_GET_MII() & ~(MII_MCLK | MII_MDOE | MII_MDO);
-	SMC_SET_MII(mii_reg);
+	SMC_SET_MII(lp, mii_reg);
 
 	for (mask = 1 << (bits - 1), val = 0; mask; mask >>= 1) {
 		if (SMC_GET_MII() & MII_MDI)
 			val |= mask;
 
-		SMC_SET_MII(mii_reg);
+		SMC_SET_MII(lp, mii_reg);
 		udelay(MII_DELAY);
-		SMC_SET_MII(mii_reg | MII_MCLK);
+		SMC_SET_MII(lp, mii_reg | MII_MCLK);
 		udelay(MII_DELAY);
 	}
 
@@ -912,7 +912,7 @@ static int smc_phy_read(struct net_devic
 	void __iomem *ioaddr = lp->base;
 	unsigned int phydata;
 
-	SMC_SELECT_BANK(3);
+	SMC_SELECT_BANK(lp, 3);
 
 	/* Idle - 32 ones */
 	smc_mii_out(dev, 0xffffffff, 32);
@@ -924,12 +924,12 @@ static int smc_phy_read(struct net_devic
 	phydata = smc_mii_in(dev, 18);
 
 	/* Return to idle state */
-	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
+	SMC_SET_MII(lp, SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
 
 	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
 		__FUNCTION__, phyaddr, phyreg, phydata);
 
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 2);
 	return phydata;
 }
 
@@ -942,7 +942,7 @@ static void smc_phy_write(struct net_dev
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
 
-	SMC_SELECT_BANK(3);
+	SMC_SELECT_BANK(lp, 3);
 
 	/* Idle - 32 ones */
 	smc_mii_out(dev, 0xffffffff, 32);
@@ -951,12 +951,12 @@ static void smc_phy_write(struct net_dev
 	smc_mii_out(dev, 5 << 28 | phyaddr << 23 | phyreg << 18 | 2 << 16 | phydata, 32);
 
 	/* Return to idle state */
-	SMC_SET_MII(SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
+	SMC_SET_MII(lp, SMC_GET_MII() & ~(MII_MCLK|MII_MDOE|MII_MDO));
 
 	DBG(3, "%s: phyaddr=0x%x, phyreg=0x%x, phydata=0x%x\n",
 		__FUNCTION__, phyaddr, phyreg, phydata);
 
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 2);
 }
 
 /*
@@ -1029,9 +1029,9 @@ static int smc_phy_fixed(struct net_devi
 	smc_phy_write(dev, phyaddr, MII_BMCR, bmcr);
 
 	/* Re-Configure the Receive/Phy Control register */
-	SMC_SELECT_BANK(0);
-	SMC_SET_RPC(lp->rpc_cur_mode);
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_RPC(lp, lp->rpc_cur_mode);
+	SMC_SELECT_BANK(lp, 2);
 
 	return 1;
 }
@@ -1122,8 +1122,8 @@ static void smc_phy_check_media(struct n
 			lp->tcr_cur_mode &= ~TCR_SWFDUP;
 		}
 
-		SMC_SELECT_BANK(0);
-		SMC_SET_TCR(lp->tcr_cur_mode);
+		SMC_SELECT_BANK(lp, 0);
+		SMC_SET_TCR(lp, lp->tcr_cur_mode);
 	}
 }
 
@@ -1172,8 +1172,8 @@ static void smc_phy_configure(struct wor
 		PHY_INT_SPDDET | PHY_INT_DPLXDET);
 
 	/* Configure the Receive/Phy Control register */
-	SMC_SELECT_BANK(0);
-	SMC_SET_RPC(lp->rpc_cur_mode);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_RPC(lp, lp->rpc_cur_mode);
 
 	/* If the user requested no auto neg, then go set his request */
 	if (lp->mii.force_media) {
@@ -1230,7 +1230,7 @@ static void smc_phy_configure(struct wor
 	smc_phy_check_media(dev, 1);
 
 smc_phy_configure_exit:
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 2);
 	spin_unlock_irq(&lp->lock);
 	lp->work_pending = 0;
 }
@@ -1272,9 +1272,9 @@ static void smc_10bt_check_media(struct 
 
 	old_carrier = netif_carrier_ok(dev) ? 1 : 0;
 
-	SMC_SELECT_BANK(0);
+	SMC_SELECT_BANK(lp, 0);
 	new_carrier = (SMC_GET_EPH_STATUS() & ES_LINK_OK) ? 1 : 0;
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 2);
 
 	if (init || (old_carrier != new_carrier)) {
 		if (!new_carrier) {
@@ -1296,11 +1296,11 @@ static void smc_eph_interrupt(struct net
 
 	smc_10bt_check_media(dev, 0);
 
-	SMC_SELECT_BANK(1);
+	SMC_SELECT_BANK(lp, 1);
 	ctl = SMC_GET_CTL();
-	SMC_SET_CTL(ctl & ~CTL_LE_ENABLE);
-	SMC_SET_CTL(ctl);
-	SMC_SELECT_BANK(2);
+	SMC_SET_CTL(lp, ctl & ~CTL_LE_ENABLE);
+	SMC_SET_CTL(lp, ctl);
+	SMC_SELECT_BANK(lp, 2);
 }
 
 /*
@@ -1326,7 +1326,7 @@ static irqreturn_t smc_interrupt(int irq
 
 	saved_pointer = SMC_GET_PTR();
 	mask = SMC_GET_INT_MASK();
-	SMC_SET_INT_MASK(0);
+	SMC_SET_INT_MASK(lp, 0);
 
 	/* set a timeout value, so I don't stay here forever */
 	timeout = MAX_IRQ_LOOPS;
@@ -1336,9 +1336,9 @@ static irqreturn_t smc_interrupt(int irq
 
 		DBG(2, "%s: INT 0x%02x MASK 0x%02x MEM 0x%04x FIFO 0x%04x\n",
 			dev->name, status, mask,
-			({ int meminfo; SMC_SELECT_BANK(0);
+			({ int meminfo; SMC_SELECT_BANK(lp, 0);
 			   meminfo = SMC_GET_MIR();
-			   SMC_SELECT_BANK(2); meminfo; }),
+			   SMC_SELECT_BANK(lp, 2); meminfo; }),
 			SMC_GET_FIFO());
 
 		status &= mask;
@@ -1349,7 +1349,7 @@ static irqreturn_t smc_interrupt(int irq
 			/* do this before RX as it will free memory quickly */
 			DBG(3, "%s: TX int\n", dev->name);
 			smc_tx(dev);
-			SMC_ACK_INT(IM_TX_INT);
+			SMC_ACK_INT(lp, IM_TX_INT);
 			if (THROTTLE_TX_PKTS)
 				netif_wake_queue(dev);
 		} else if (status & IM_RCV_INT) {
@@ -1364,9 +1364,9 @@ static irqreturn_t smc_interrupt(int irq
 			mask &= ~IM_TX_EMPTY_INT;
 
 			/* update stats */
-			SMC_SELECT_BANK(0);
+			SMC_SELECT_BANK(lp, 0);
 			card_stats = SMC_GET_COUNTER();
-			SMC_SELECT_BANK(2);
+			SMC_SELECT_BANK(lp, 2);
 
 			/* single collisions */
 			dev->stats.collisions += card_stats & 0xF;
@@ -1376,26 +1376,26 @@ static irqreturn_t smc_interrupt(int irq
 			dev->stats.collisions += card_stats & 0xF;
 		} else if (status & IM_RX_OVRN_INT) {
 			DBG(1, "%s: RX overrun (EPH_ST 0x%04x)\n", dev->name,
-			       ({ int eph_st; SMC_SELECT_BANK(0);
+			       ({ int eph_st; SMC_SELECT_BANK(lp, 0);
 				  eph_st = SMC_GET_EPH_STATUS();
-				  SMC_SELECT_BANK(2); eph_st; }) );
-			SMC_ACK_INT(IM_RX_OVRN_INT);
+				  SMC_SELECT_BANK(lp, 2); eph_st; }) );
+			SMC_ACK_INT(lp, IM_RX_OVRN_INT);
 			dev->stats.rx_errors++;
 			dev->stats.rx_fifo_errors++;
 		} else if (status & IM_EPH_INT) {
 			smc_eph_interrupt(dev);
 		} else if (status & IM_MDINT) {
-			SMC_ACK_INT(IM_MDINT);
+			SMC_ACK_INT(lp, IM_MDINT);
 			smc_phy_interrupt(dev);
 		} else if (status & IM_ERCV_INT) {
-			SMC_ACK_INT(IM_ERCV_INT);
+			SMC_ACK_INT(lp, IM_ERCV_INT);
 			PRINTK("%s: UNSUPPORTED: ERCV INTERRUPT \n", dev->name);
 		}
 	} while (--timeout);
 
 	/* restore register states */
-	SMC_SET_PTR(saved_pointer);
-	SMC_SET_INT_MASK(mask);
+	SMC_SET_PTR(lp, saved_pointer);
+	SMC_SET_INT_MASK(lp, mask);
 	spin_unlock(&lp->lock);
 
 	if (timeout == MAX_IRQ_LOOPS)
@@ -1441,10 +1441,10 @@ static void smc_timeout(struct net_devic
 	status = SMC_GET_INT();
 	mask = SMC_GET_INT_MASK();
 	fifo = SMC_GET_FIFO();
-	SMC_SELECT_BANK(0);
+	SMC_SELECT_BANK(lp, 0);
 	eph_st = SMC_GET_EPH_STATUS();
 	meminfo = SMC_GET_MIR();
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 2);
 	spin_unlock_irq(&lp->lock);
 	PRINTK( "%s: TX timeout (INT 0x%02x INTMASK 0x%02x "
 		"MEM 0x%04x FIFO 0x%04x EPH_ST 0x%04x)\n",
@@ -1564,13 +1564,13 @@ static void smc_set_multicast_list(struc
 	}
 
 	spin_lock_irq(&lp->lock);
-	SMC_SELECT_BANK(0);
-	SMC_SET_RCR(lp->rcr_cur_mode);
+	SMC_SELECT_BANK(lp, 0);
+	SMC_SET_RCR(lp, lp->rcr_cur_mode);
 	if (update_multicast) {
-		SMC_SELECT_BANK(3);
-		SMC_SET_MCAST(multicast_table);
+		SMC_SELECT_BANK(lp, 3);
+		SMC_SET_MCAST(lp, multicast_table);
 	}
-	SMC_SELECT_BANK(2);
+	SMC_SELECT_BANK(lp, 2);
 	spin_unlock_irq(&lp->lock);
 }
 
@@ -1789,14 +1789,14 @@ static int __init smc_findirq(void __iom
 	 * when done.
 	 */
 	/* enable ALLOCation interrupts ONLY */
-	SMC_SELECT_BANK(2);
-	SMC_SET_INT_MASK(IM_ALLOC_INT);
+	SMC_SELECT_BANK(lp, 2);
+	SMC_SET_INT_MASK(lp, IM_ALLOC_INT);
 
 	/*
  	 * Allocate 512 bytes of memory.  Note that the chip was just
 	 * reset so all the memory is available
 	 */
-	SMC_SET_MMU_CMD(MC_ALLOC | 1);
+	SMC_SET_MMU_CMD(lp, MC_ALLOC | 1);
 
 	/*
 	 * Wait until positive that the interrupt has been generated
@@ -1817,7 +1817,7 @@ static int __init smc_findirq(void __iom
 	 */
 
 	/* and disable all interrupts again */
-	SMC_SET_INT_MASK(0);
+	SMC_SET_INT_MASK(lp, 0);
 
 	/* and return what I found */
 	return probe_irq_off(cookie);
@@ -1880,7 +1880,7 @@ static int __init smc_probe(struct net_d
 	 * The above MIGHT indicate a device, but I need to write to
 	 * further test this.
 	 */
-	SMC_SELECT_BANK(0);
+	SMC_SELECT_BANK(lp, 0);
 	val = SMC_CURRENT_BANK();
 	if ((val & 0xFF00) != 0x3300) {
 		retval = -ENODEV;
@@ -1893,7 +1893,7 @@ static int __init smc_probe(struct net_d
 	 * register to bank 1, so I can access the base address
 	 * register
 	 */
-	SMC_SELECT_BANK(1);
+	SMC_SELECT_BANK(lp, 1);
 	val = SMC_GET_BASE();
 	val = ((val & 0x1F00) >> 3) << SMC_IO_SHIFT;
 	if (((unsigned int)ioaddr & (0x3e0 << SMC_IO_SHIFT)) != val) {
@@ -1906,7 +1906,7 @@ static int __init smc_probe(struct net_d
 	 * recognize.  These might need to be added to later,
 	 * as future revisions could be added.
 	 */
-	SMC_SELECT_BANK(3);
+	SMC_SELECT_BANK(lp, 3);
 	revision_register = SMC_GET_REV();
 	DBG(2, "%s: revision = 0x%04x\n", CARDNAME, revision_register);
 	version_string = chip_ids[ (revision_register >> 4) & 0xF];
@@ -1931,8 +1931,8 @@ static int __init smc_probe(struct net_d
 	spin_lock_init(&lp->lock);
 
 	/* Get the MAC address */
-	SMC_SELECT_BANK(1);
-	SMC_GET_MAC_ADDR(dev->dev_addr);
+	SMC_SELECT_BANK(lp, 1);
+	SMC_GET_MAC_ADDR(lp, dev->dev_addr);
 
 	/* now, reset the chip, and put it into a known state */
 	smc_reset(dev);
