Subject: [PATCH] m68k: Remove the broken Hades support

From: Adrian Bunk <bunk@kernel.org>

This patch removes the Hades support that was marked as BROKEN 5 years ago.

Signed-off-by: Adrian Bunk <bunk@kernel.org>
Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
---

 arch/m68k/Kconfig              |   13 -
 arch/m68k/atari/Makefile       |    3 
 arch/m68k/atari/ataints.c      |    6 
 arch/m68k/atari/config.c       |   37 +--
 arch/m68k/atari/hades-pci.c    |  440 --------------------------------------
 arch/m68k/kernel/bios32.c      |    6 
 arch/m68k/kernel/process.c     |    2 
 drivers/block/ataflop.c        |    4 
 drivers/scsi/Kconfig           |    8 
 drivers/scsi/atari_dma_emul.c  |  468 -----------------------------------------
 drivers/scsi/atari_scsi.c      |   27 --
 include/asm-m68k/atarihw.h     |    1 
 include/asm-m68k/entry.h       |    2 
 include/asm-m68k/virtconvert.h |    6 
 14 files changed, 23 insertions(+), 1000 deletions(-)

d9b251e93344e93aace1d7dadc235b4a4aa8c3b2 
--- a/arch/m68k/Kconfig
+++ b/arch/m68k/Kconfig
@@ -124,22 +124,9 @@ config ATARI
 	  this kernel on an Atari, say Y here and browse the material
 	  available in <file:Documentation/m68k>; otherwise say N.
 
-config HADES
-	bool "Hades support"
-	depends on ATARI && BROKEN
-	help
-	  This option enables support for the Hades Atari clone. If you plan
-	  to use this kernel on a Hades, say Y here; otherwise say N.
-
 config PCI
 	bool
-	depends on HADES
-	default y
 	help
-	  Find out whether you have a PCI motherboard. PCI is the name of a
-	  bus system, i.e. the way the CPU talks to the other stuff inside
-	  your box. Other bus systems are ISA, EISA, MicroChannel (MCA) or
-	  VESA. If you have PCI, say Y, otherwise N.
 
 config MAC
 	bool "Macintosh support"
--- a/arch/m68k/atari/Makefile
+++ b/arch/m68k/atari/Makefile
@@ -5,7 +5,4 @@
 obj-y		:= config.o time.o debug.o ataints.o stdma.o \
 			atasound.o stram.o
 
-ifeq ($(CONFIG_PCI),y)
-obj-$(CONFIG_HADES)	+= hades-pci.o
-endif
 obj-$(CONFIG_ATARI_KBD_CORE)	+= atakeyb.o
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -407,10 +407,8 @@ void __init atari_init_IRQ(void)
 		 * gets overruns)
 		 */
 
-		if (!MACH_IS_HADES) {
-			vectors[VEC_INT2] = falcon_hblhandler;
-			vectors[VEC_INT4] = falcon_hblhandler;
-		}
+		vectors[VEC_INT2] = falcon_hblhandler;
+		vectors[VEC_INT4] = falcon_hblhandler;
 	}
 
 	if (ATARIHW_PRESENT(PCM_8BIT) && ATARIHW_PRESENT(MICROWIRE)) {
--- a/arch/m68k/atari/config.c
+++ b/arch/m68k/atari/config.c
@@ -231,7 +231,7 @@ void __init config_atari(void)
 	 */
 
 	printk("Atari hardware found: ");
-	if (MACH_IS_MEDUSA || MACH_IS_HADES) {
+	if (MACH_IS_MEDUSA) {
 		/* There's no Atari video hardware on the Medusa, but all the
 		 * addresses below generate a DTACK so no bus error occurs! */
 	} else if (hwreg_present(f030_xreg)) {
@@ -269,10 +269,6 @@ void __init config_atari(void)
 		ATARIHW_SET(SCSI_DMA);
 		printk("TT_SCSI_DMA ");
 	}
-	if (!MACH_IS_HADES && hwreg_present(&st_dma.dma_hi)) {
-		ATARIHW_SET(STND_DMA);
-		printk("STND_DMA ");
-	}
 	/*
 	 * The ST-DMA address registers aren't readable
 	 * on all Medusas, so the test below may fail
@@ -294,12 +290,11 @@ void __init config_atari(void)
 		ATARIHW_SET(YM_2149);
 		printk("YM2149 ");
 	}
-	if (!MACH_IS_MEDUSA && !MACH_IS_HADES &&
-		hwreg_present(&tt_dmasnd.ctrl)) {
+	if (!MACH_IS_MEDUSA && hwreg_present(&tt_dmasnd.ctrl)) {
 		ATARIHW_SET(PCM_8BIT);
 		printk("PCM ");
 	}
-	if (!MACH_IS_HADES && hwreg_present(&falcon_codec.unused5)) {
+	if (hwreg_present(&falcon_codec.unused5)) {
 		ATARIHW_SET(CODEC);
 		printk("CODEC ");
 	}
@@ -313,7 +308,7 @@ void __init config_atari(void)
 	    (tt_scc_dma.dma_ctrl = 0x01, (tt_scc_dma.dma_ctrl & 1) == 1) &&
 	    (tt_scc_dma.dma_ctrl = 0x00, (tt_scc_dma.dma_ctrl & 1) == 0)
 #else
-	    !MACH_IS_MEDUSA && !MACH_IS_HADES
+	    !MACH_IS_MEDUSA
 #endif
 	    ) {
 		ATARIHW_SET(SCC_DMA);
@@ -327,10 +322,7 @@ void __init config_atari(void)
 		ATARIHW_SET(ST_ESCC);
 		printk("ST_ESCC ");
 	}
-	if (MACH_IS_HADES) {
-		ATARIHW_SET(VME);
-		printk("VME ");
-	} else if (hwreg_present(&tt_scu.sys_mask)) {
+	if (hwreg_present(&tt_scu.sys_mask)) {
 		ATARIHW_SET(SCU);
 		/* Assume a VME bus if there's a SCU */
 		ATARIHW_SET(VME);
@@ -340,7 +332,7 @@ void __init config_atari(void)
 		ATARIHW_SET(ANALOG_JOY);
 		printk("ANALOG_JOY ");
 	}
-	if (!MACH_IS_HADES && hwreg_present(blitter.halftone)) {
+	if (hwreg_present(blitter.halftone)) {
 		ATARIHW_SET(BLITTER);
 		printk("BLITTER ");
 	}
@@ -349,8 +341,7 @@ void __init config_atari(void)
 		printk("IDE ");
 	}
 #if 1 /* This maybe wrong */
-	if (!MACH_IS_MEDUSA && !MACH_IS_HADES &&
-	    hwreg_present(&tt_microwire.data) &&
+	if (!MACH_IS_MEDUSA && hwreg_present(&tt_microwire.data) &&
 	    hwreg_present(&tt_microwire.mask) &&
 	    (tt_microwire.mask = 0x7ff,
 	     udelay(1),
@@ -369,19 +360,18 @@ void __init config_atari(void)
 		mach_hwclk = atari_tt_hwclk;
 		mach_set_clock_mmss = atari_tt_set_clock_mmss;
 	}
-	if (!MACH_IS_HADES && hwreg_present(&mste_rtc.sec_ones)) {
+	if (hwreg_present(&mste_rtc.sec_ones)) {
 		ATARIHW_SET(MSTE_CLK);
 		printk("MSTE_CLK ");
 		mach_hwclk = atari_mste_hwclk;
 		mach_set_clock_mmss = atari_mste_set_clock_mmss;
 	}
-	if (!MACH_IS_MEDUSA && !MACH_IS_HADES &&
-	    hwreg_present(&dma_wd.fdc_speed) &&
+	if (!MACH_IS_MEDUSA && hwreg_present(&dma_wd.fdc_speed) &&
 	    hwreg_write(&dma_wd.fdc_speed, 0)) {
 		ATARIHW_SET(FDCSPEED);
 		printk("FDC_SPEED ");
 	}
-	if (!MACH_IS_HADES && !ATARIHW_PRESENT(ST_SCSI)) {
+	if (!ATARIHW_PRESENT(ST_SCSI)) {
 		ATARIHW_SET(ACSI);
 		printk("ACSI ");
 	}
@@ -449,7 +439,7 @@ void __init config_atari(void)
 	 * 0xFFxxxxxx -> 0x00xxxxxx, so that the first 16MB is accessible
 	 * in the last 16MB of the address space.
 	 */
-	tos_version = (MACH_IS_MEDUSA || MACH_IS_HADES) ?
+	tos_version = (MACH_IS_MEDUSA) ?
 			0xfff : *(unsigned short *)0xff000002;
 	atari_rtc_year_offset = (tos_version < 0x306) ? 70 : 68;
 }
@@ -511,8 +501,7 @@ static void atari_reset(void)
 	 * On the Medusa, phys. 0x4 may contain garbage because it's no
 	 * ROM.  See above for explanation why we cannot use PTOV(4).
 	 */
-	reset_addr = MACH_IS_HADES ? 0x7fe00030 :
-		     MACH_IS_MEDUSA || MACH_IS_AB40 ? 0xe00030 :
+	reset_addr = MACH_IS_MEDUSA || MACH_IS_AB40 ? 0xe00030 :
 		     *(unsigned long *) 0xff000004;
 
 	/* reset ACIA for switch off OverScan, if it's active */
@@ -606,8 +595,6 @@ static void atari_get_model(char *model)
 		if (MACH_IS_MEDUSA)
 			/* Medusa has TT _MCH cookie */
 			strcat(model, "Medusa");
-		else if (MACH_IS_HADES)
-			strcat(model, "Hades");
 		else
 			strcat(model, "TT");
 		break;
--- a/arch/m68k/atari/hades-pci.c
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
- * hades-pci.c - Hardware specific PCI BIOS functions the Hades Atari clone.
- *
- * Written by Wout Klaren.
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/io.h>
-
-#if 0
-# define DBG_DEVS(args)		printk args
-#else
-# define DBG_DEVS(args)
-#endif
-
-#if defined(CONFIG_PCI) && defined(CONFIG_HADES)
-
-#include <linux/slab.h>
-#include <linux/mm.h>
-#include <linux/pci.h>
-
-#include <asm/atarihw.h>
-#include <asm/atariints.h>
-#include <asm/byteorder.h>
-#include <asm/pci.h>
-
-#define HADES_MEM_BASE		0x80000000
-#define HADES_MEM_SIZE		0x20000000
-#define HADES_CONFIG_BASE	0xA0000000
-#define HADES_CONFIG_SIZE	0x10000000
-#define HADES_IO_BASE		0xB0000000
-#define HADES_IO_SIZE		0x10000000
-#define HADES_VIRT_IO_SIZE	0x00010000	/* Only 64k is remapped and actually used. */
-
-#define N_SLOTS				4			/* Number of PCI slots. */
-
-static const char pci_mem_name[] = "PCI memory space";
-static const char pci_io_name[] = "PCI I/O space";
-static const char pci_config_name[] = "PCI config space";
-
-static struct resource config_space = {
-    .name = pci_config_name,
-    .start = HADES_CONFIG_BASE,
-    .end = HADES_CONFIG_BASE + HADES_CONFIG_SIZE - 1
-};
-static struct resource io_space = {
-    .name = pci_io_name,
-    .start = HADES_IO_BASE,
-    .end = HADES_IO_BASE + HADES_IO_SIZE - 1
-};
-
-static const unsigned long pci_conf_base_phys[] = {
-    0xA0080000, 0xA0040000, 0xA0020000, 0xA0010000
-};
-static unsigned long pci_conf_base_virt[N_SLOTS];
-static unsigned long pci_io_base_virt;
-
-/*
- * static void *mk_conf_addr(unsigned char bus, unsigned char device_fn,
- *			     unsigned char where)
- *
- * Calculate the address of the PCI configuration area of the given
- * device.
- *
- * BUG: boards with multiple functions are probably not correctly
- * supported.
- */
-
-static void *mk_conf_addr(struct pci_dev *dev, int where)
-{
-	int device = dev->devfn >> 3, function = dev->devfn & 7;
-	void *result;
-
-	DBG_DEVS(("mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x, pci_addr=0x%p)\n",
-		  dev->bus->number, dev->devfn, where, pci_addr));
-
-	if (device > 3)
-	{
-		DBG_DEVS(("mk_conf_addr: device (%d) > 3, returning NULL\n", device));
-		return NULL;
-	}
-
-	if (dev->bus->number != 0)
-	{
-		DBG_DEVS(("mk_conf_addr: bus (%d) > 0, returning NULL\n", device));
-		return NULL;
-	}
-
-	result = (void *) (pci_conf_base_virt[device] | (function << 8) | (where));
-	DBG_DEVS(("mk_conf_addr: returning pci_addr 0x%lx\n", (unsigned long) result));
-	return result;
-}
-
-static int hades_read_config_byte(struct pci_dev *dev, int where, u8 *value)
-{
-	volatile unsigned char *pci_addr;
-
-	*value = 0xff;
-
-	if ((pci_addr = (unsigned char *) mk_conf_addr(dev, where)) == NULL)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	*value = *pci_addr;
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int hades_read_config_word(struct pci_dev *dev, int where, u16 *value)
-{
-	volatile unsigned short *pci_addr;
-
-	*value = 0xffff;
-
-	if (where & 0x1)
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
-	if ((pci_addr = (unsigned short *) mk_conf_addr(dev, where)) == NULL)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	*value = le16_to_cpu(*pci_addr);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int hades_read_config_dword(struct pci_dev *dev, int where, u32 *value)
-{
-	volatile unsigned int *pci_addr;
-	unsigned char header_type;
-	int result;
-
-	*value = 0xffffffff;
-
-	if (where & 0x3)
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
-	if ((pci_addr = (unsigned int *) mk_conf_addr(dev, where)) == NULL)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	*value = le32_to_cpu(*pci_addr);
-
-	/*
-	 * Check if the value is an address on the bus. If true, add the
-	 * base address of the PCI memory or PCI I/O area on the Hades.
-	 */
-
-	if ((result = hades_read_config_byte(dev, PCI_HEADER_TYPE,
-					     &header_type)) != PCIBIOS_SUCCESSFUL)
-		return result;
-
-	if (((where >= PCI_BASE_ADDRESS_0) && (where <= PCI_BASE_ADDRESS_1)) ||
-	    ((header_type != PCI_HEADER_TYPE_BRIDGE) && ((where >= PCI_BASE_ADDRESS_2) &&
-							 (where <= PCI_BASE_ADDRESS_5))))
-	{
-		if ((*value & PCI_BASE_ADDRESS_SPACE) == PCI_BASE_ADDRESS_SPACE_IO)
-		{
-			/*
-			 * Base address register that contains an I/O address. If the
-			 * address is valid on the Hades (0 <= *value < HADES_VIRT_IO_SIZE),
-			 * add 'pci_io_base_virt' to the value.
-			 */
-
-			if (*value < HADES_VIRT_IO_SIZE)
-				*value += pci_io_base_virt;
-		}
-		else
-		{
-			/*
-			 * Base address register that contains an memory address. If the
-			 * address is valid on the Hades (0 <= *value < HADES_MEM_SIZE),
-			 * add HADES_MEM_BASE to the value.
-			 */
-
-			if (*value == 0)
-			{
-				/*
-				 * Base address is 0. Test if this base
-				 * address register is used.
-				 */
-
-				*pci_addr = 0xffffffff;
-				if (*pci_addr != 0)
-				{
-					*pci_addr = *value;
-					if (*value < HADES_MEM_SIZE)
-						*value += HADES_MEM_BASE;
-				}
-			}
-			else
-			{
-				if (*value < HADES_MEM_SIZE)
-					*value += HADES_MEM_BASE;
-			}
-		}
-	}
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int hades_write_config_byte(struct pci_dev *dev, int where, u8 value)
-{
-	volatile unsigned char *pci_addr;
-
-	if ((pci_addr = (unsigned char *) mk_conf_addr(dev, where)) == NULL)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	*pci_addr = value;
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int hades_write_config_word(struct pci_dev *dev, int where, u16 value)
-{
-	volatile unsigned short *pci_addr;
-
-	if ((pci_addr = (unsigned short *) mk_conf_addr(dev, where)) == NULL)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	*pci_addr = cpu_to_le16(value);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int hades_write_config_dword(struct pci_dev *dev, int where, u32 value)
-{
-	volatile unsigned int *pci_addr;
-	unsigned char header_type;
-	int result;
-
-	if ((pci_addr = (unsigned int *) mk_conf_addr(dev, where)) == NULL)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/*
-	 * Check if the value is an address on the bus. If true, subtract the
-	 * base address of the PCI memory or PCI I/O area on the Hades.
-	 */
-
-	if ((result = hades_read_config_byte(dev, PCI_HEADER_TYPE,
-					     &header_type)) != PCIBIOS_SUCCESSFUL)
-		return result;
-
-	if (((where >= PCI_BASE_ADDRESS_0) && (where <= PCI_BASE_ADDRESS_1)) ||
-	    ((header_type != PCI_HEADER_TYPE_BRIDGE) && ((where >= PCI_BASE_ADDRESS_2) &&
-							 (where <= PCI_BASE_ADDRESS_5))))
-	{
-		if ((value & PCI_BASE_ADDRESS_SPACE) ==
-		    PCI_BASE_ADDRESS_SPACE_IO)
-		{
-			/*
-			 * I/O address. Check if the address is valid address on
-			 * the Hades (pci_io_base_virt <= value < pci_io_base_virt +
-			 * HADES_VIRT_IO_SIZE) or if the value is 0xffffffff. If not
-			 * true do not write the base address register. If it is a
-			 * valid base address subtract 'pci_io_base_virt' from the value.
-			 */
-
-			if ((value >= pci_io_base_virt) && (value < (pci_io_base_virt +
-														 HADES_VIRT_IO_SIZE)))
-				value -= pci_io_base_virt;
-			else
-			{
-				if (value != 0xffffffff)
-					return PCIBIOS_SET_FAILED;
-			}
-		}
-		else
-		{
-			/*
-			 * Memory address. Check if the address is valid address on
-			 * the Hades (HADES_MEM_BASE <= value < HADES_MEM_BASE + HADES_MEM_SIZE) or
-			 * if the value is 0xffffffff. If not true do not write
-			 * the base address register. If it is a valid base address
-			 * subtract HADES_MEM_BASE from the value.
-			 */
-
-			if ((value >= HADES_MEM_BASE) && (value < (HADES_MEM_BASE + HADES_MEM_SIZE)))
-				value -= HADES_MEM_BASE;
-			else
-			{
-				if (value != 0xffffffff)
-					return PCIBIOS_SET_FAILED;
-			}
-		}
-	}
-
-	*pci_addr = cpu_to_le32(value);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/*
- * static inline void hades_fixup(void)
- *
- * Assign IRQ numbers as used by Linux to the interrupt pins
- * of the PCI cards.
- */
-
-static void __init hades_fixup(int pci_modify)
-{
-	char irq_tab[4] = {
-		[0] = IRQ_TT_MFP_IO0,		/* Slot 0. */
-		[1] = IRQ_TT_MFP_IO1,		/* Slot 1. */
-		[2] = IRQ_TT_MFP_SCC,		/* Slot 2. */
-		[3] = IRQ_TT_MFP_SCSIDMA	/* Slot 3. */
-	};
-	struct pci_dev *dev = NULL;
-	unsigned char slot;
-
-	/*
-	 * Go through all devices, fixing up irqs as we see fit:
-	 */
-
-	while ((dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL)
-	{
-		if (dev->class >> 16 != PCI_BASE_CLASS_BRIDGE)
-		{
-			slot = PCI_SLOT(dev->devfn);	/* Determine slot number. */
-			dev->irq = irq_tab[slot];
-			if (pci_modify)
-				pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
-		}
-	}
-}
-
-/*
- * static void hades_conf_device(struct pci_dev *dev)
- *
- * Machine dependent Configure the given device.
- *
- * Parameters:
- *
- * dev		- the pci device.
- */
-
-static void __init hades_conf_device(struct pci_dev *dev)
-{
-	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 0);
-}
-
-static struct pci_ops hades_pci_ops = {
-	.read_byte =	hades_read_config_byte,
-	.read_word =	hades_read_config_word,
-	.read_dword =	hades_read_config_dword,
-	.write_byte =	hades_write_config_byte,
-	.write_word =	hades_write_config_word,
-	.write_dword =	hades_write_config_dword
-};
-
-/*
- * struct pci_bus_info *init_hades_pci(void)
- *
- * Machine specific initialisation:
- *
- * - Allocate and initialise a 'pci_bus_info' structure
- * - Initialise hardware
- *
- * Result: pointer to 'pci_bus_info' structure.
- */
-
-struct pci_bus_info * __init init_hades_pci(void)
-{
-	struct pci_bus_info *bus;
-	int i;
-
-	/*
-	 * Remap I/O and configuration space.
-	 */
-
-	pci_io_base_virt = (unsigned long) ioremap(HADES_IO_BASE, HADES_VIRT_IO_SIZE);
-
-	for (i = 0; i < N_SLOTS; i++)
-		pci_conf_base_virt[i] = (unsigned long) ioremap(pci_conf_base_phys[i], 0x10000);
-
-	/*
-	 * Allocate memory for bus info structure.
-	 */
-
-	bus = kzalloc(sizeof(struct pci_bus_info), GFP_KERNEL);
-	if (unlikely(!bus))
-		goto iounmap_base_virt;
-
-	/*
-	 * Claim resources. The m68k has no separate I/O space, both
-	 * PCI memory space and PCI I/O space are in memory space. Therefore
-	 * the I/O resources are requested in memory space as well.
-	 */
-
-	if (unlikely(request_resource(&iomem_resource, &config_space) != 0))
-		goto free_bus;
-
-	if (unlikely(request_resource(&iomem_resource, &io_space) != 0))
-		goto release_config_space;
-
-	bus->mem_space.start = HADES_MEM_BASE;
-	bus->mem_space.end = HADES_MEM_BASE + HADES_MEM_SIZE - 1;
-	bus->mem_space.name = pci_mem_name;
-#if 1
-	if (unlikely(request_resource(&iomem_resource, &bus->mem_space) != 0))
-		goto release_io_space;
-#endif
-	bus->io_space.start = pci_io_base_virt;
-	bus->io_space.end = pci_io_base_virt + HADES_VIRT_IO_SIZE - 1;
-	bus->io_space.name = pci_io_name;
-#if 1
-	if (unlikely(request_resource(&ioport_resource, &bus->io_space) != 0))
-		goto release_bus_mem_space;
-#endif
-	/*
-	 * Set hardware dependent functions.
-	 */
-
-	bus->m68k_pci_ops = &hades_pci_ops;
-	bus->fixup = hades_fixup;
-	bus->conf_device = hades_conf_device;
-
-	/*
-	 * Select high to low edge for PCI interrupts.
-	 */
-
-	tt_mfp.active_edge &= ~0x27;
-
-	return bus;
-
-release_bus_mem_space:
-	release_resource(&bus->mem_space);
-release_io_space:
-	release_resource(&io_space);
-release_config_space:
-	release_resource(&config_space);
-free_bus:
-	kfree(bus);
-iounmap_base_virt:
-	iounmap((void *)pci_io_base_virt);
-
-	for (i = 0; i < N_SLOTS; i++)
-		iounmap((void *)pci_conf_base_virt[i]);
-
-	return NULL;
-}
-#endif
--- a/arch/m68k/kernel/bios32.c
+++ b/arch/m68k/kernel/bios32.c
@@ -476,10 +476,12 @@ void __init pcibios_init(void)
 	printk("Linux/m68k PCI BIOS32 revision %x.%02x\n", MAJOR_REV, MINOR_REV);
 
 	bus_info = NULL;
-#ifdef CONFIG_HADES
+
+/* Hades code was:
 	if (MACH_IS_HADES)
 		bus_info = init_hades_pci();
-#endif
+*/
+
 	if (bus_info != NULL)
 	{
 		printk("PCI: Probing PCI hardware\n");
--- a/arch/m68k/kernel/process.c
+++ b/arch/m68k/kernel/process.c
@@ -78,7 +78,7 @@ unsigned long thread_saved_pc(struct tas
 static void default_idle(void)
 {
 	if (!need_resched())
-#if defined(MACH_ATARI_ONLY) && !defined(CONFIG_HADES)
+#if defined(MACH_ATARI_ONLY)
 		/* block out HSYNC on the atari (falcon) */
 		__asm__("stop #0x2200" : : : "cc");
 #else
--- a/drivers/block/ataflop.c
+++ b/drivers/block/ataflop.c
@@ -1882,10 +1882,6 @@ static int __init atari_floppy_init (voi
 		/* Amiga, Mac, ... don't have Atari-compatible floppy :-) */
 		return -ENODEV;
 
-	if (MACH_IS_HADES)
-		/* Hades doesn't have Atari-compatible floppy */
-		return -ENODEV;
-
 	if (register_blkdev(FLOPPY_MAJOR,"fd"))
 		return -EBUSY;
 
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -1678,14 +1678,6 @@ config ATARI_SCSI_RESET_BOOT
 	  boot process fractionally longer but may assist recovery from errors
 	  that leave the devices with SCSI operations partway completed.
 
-config TT_DMA_EMUL
-	bool "Hades SCSI DMA emulator"
-	depends on ATARI_SCSI && HADES
-	help
-	  This option enables code which emulates the TT SCSI DMA chip on the
-	  Hades. This increases the SCSI transfer rates at least ten times
-	  compared to PIO transfers.
-
 config MAC_SCSI
 	bool "Macintosh NCR5380 SCSI"
 	depends on MAC && SCSI=y
--- a/drivers/scsi/atari_dma_emul.c
+++ /dev/null
@@ -1,468 +0,0 @@
-/*
- * atari_dma_emul.c -- TT SCSI DMA emulator for the Hades.
- *
- * Copyright 1997 Wout Klaren <W.Klaren@inter.nl.net>
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file COPYING in the main directory of this archive
- * for more details.
- *
- * This code was written using the Hades TOS source code as a
- * reference. This source code can be found on the home page
- * of Medusa Computer Systems.
- *
- * Version 0.1, 1997-09-24.
- * 
- * This code should be considered experimental. It has only been
- * tested on a Hades with a 68060. It might not work on a Hades
- * with a 68040. Make backups of your hard drives before using
- * this code.
- */
-
-#include <linux/compiler.h>
-#include <asm/thread_info.h>
-#include <asm/uaccess.h>
-
-#define hades_dma_ctrl		(*(unsigned char *) 0xffff8717)
-#define hades_psdm_reg		(*(unsigned char *) 0xffff8741)
-
-#define TRANSFER_SIZE		16
-
-struct m68040_frame {
-	unsigned long  effaddr;  /* effective address */
-	unsigned short ssw;      /* special status word */
-	unsigned short wb3s;     /* write back 3 status */
-	unsigned short wb2s;     /* write back 2 status */
-	unsigned short wb1s;     /* write back 1 status */
-	unsigned long  faddr;    /* fault address */
-	unsigned long  wb3a;     /* write back 3 address */
-	unsigned long  wb3d;     /* write back 3 data */
-	unsigned long  wb2a;     /* write back 2 address */
-	unsigned long  wb2d;     /* write back 2 data */
-	unsigned long  wb1a;     /* write back 1 address */
-	unsigned long  wb1dpd0;  /* write back 1 data/push data 0*/
-	unsigned long  pd1;      /* push data 1*/
-	unsigned long  pd2;      /* push data 2*/
-	unsigned long  pd3;      /* push data 3*/
-};
-
-static void writeback (unsigned short wbs, unsigned long wba,
-		       unsigned long wbd, void *old_buserr)
-{
-	mm_segment_t fs = get_fs();
-	static void *save_buserr;
-
-	__asm__ __volatile__ ("movec.l	%%vbr,%%a0\n\t"
-			      "move.l	%0,8(%%a0)\n\t"
-			      :
-			      : "r" (&&bus_error)
-			      : "a0" );
-
-	save_buserr = old_buserr;
-
-	set_fs (MAKE_MM_SEG(wbs & WBTM_040));
-
-	switch (wbs & WBSIZ_040) {
-	    case BA_SIZE_BYTE:
-		put_user (wbd & 0xff, (char *)wba);
-		break;
-	    case BA_SIZE_WORD:
-		put_user (wbd & 0xffff, (short *)wba);
-		break;
-	    case BA_SIZE_LONG:
-		put_user (wbd, (int *)wba);
-		break;
-	}
-
-	set_fs (fs);
-	return;
-
-bus_error:
-	__asm__ __volatile__ ("cmp.l	%0,2(%%sp)\n\t"
-			      "bcs.s	.jump_old\n\t"
-			      "cmp.l	%1,2(%%sp)\n\t"
-			      "bls.s	.restore_old\n"
-			".jump_old:\n\t"
-			      "move.l	%2,-(%%sp)\n\t"
-			      "rts\n"
-			".restore_old:\n\t"
-			      "move.l	%%a0,-(%%sp)\n\t"
-			      "movec.l	%%vbr,%%a0\n\t"
-			      "move.l	%2,8(%%a0)\n\t"
-			      "move.l	(%%sp)+,%%a0\n\t"
-			      "rte\n\t"
-			      :
-			      : "i" (writeback), "i" (&&bus_error),
-			        "m" (save_buserr) );
-}
-
-/*
- * static inline void set_restdata_reg(unsigned char *cur_addr)
- *
- * Set the rest data register if necessary.
- */
-
-static inline void set_restdata_reg(unsigned char *cur_addr)
-{
-	if (((long) cur_addr & ~3) != 0)
-		tt_scsi_dma.dma_restdata =
-			*((unsigned long *) ((long) cur_addr & ~3));
-}
-
-/*
- * void hades_dma_emulator(int irq, void *dummy)
- * 
- * This code emulates TT SCSI DMA on the Hades.
- * 
- * Note the following:
- * 
- * 1. When there is no byte available to read from the SCSI bus, or
- *    when a byte cannot yet bet written to the SCSI bus, a bus
- *    error occurs when reading or writing the pseudo DMA data
- *    register (hades_psdm_reg). We have to catch this bus error
- *    and try again to read or write the byte. If after several tries
- *    we still get a bus error, the interrupt handler is left. When
- *    the byte can be read or written, the interrupt handler is
- *    called again.
- * 
- * 2. The SCSI interrupt must be disabled in this interrupt handler.
- * 
- * 3. If we set the EOP signal, the SCSI controller still expects one
- *    byte to be read or written. Therefore the last byte is transferred
- *    separately, after setting the EOP signal.
- * 
- * 4. When this function is left, the address pointer (start_addr) is
- *    converted to a physical address. Because it points one byte
- *    further than the last transferred byte, it can point outside the
- *    current page. If virt_to_phys() is called with this address we
- *    might get an access error. Therefore virt_to_phys() is called with
- *    start_addr - 1 if the count has reached zero. The result is
- *    increased with one.
- */
-
-static irqreturn_t hades_dma_emulator(int irq, void *dummy)
-{
-	unsigned long dma_base;
-	register unsigned long dma_cnt asm ("d3");
-	static long save_buserr;
-	register unsigned long save_sp asm ("d4");
-	register int tries asm ("d5");
-	register unsigned char *start_addr asm ("a3"), *end_addr asm ("a4");
-	register unsigned char *eff_addr;
-	register unsigned char *psdm_reg;
-	unsigned long rem;
-
-	atari_disable_irq(IRQ_TT_MFP_SCSI);
-
-	/*
-	 * Read the dma address and count registers.
-	 */
-
-	dma_base = SCSI_DMA_READ_P(dma_addr);
-	dma_cnt = SCSI_DMA_READ_P(dma_cnt);
-
-	/*
-	 * Check if DMA is still enabled.
-	 */
-
-	if ((tt_scsi_dma.dma_ctrl & 2) == 0)
-	{
-		atari_enable_irq(IRQ_TT_MFP_SCSI);
-		return IRQ_HANDLED;
-	}
-
-	if (dma_cnt == 0)
-	{
-		printk(KERN_NOTICE "DMA emulation: count is zero.\n");
-		tt_scsi_dma.dma_ctrl &= 0xfd;	/* DMA ready. */
-		atari_enable_irq(IRQ_TT_MFP_SCSI);
-		return IRQ_HANDLED;
-	}
-
-	/*
-	 * Install new bus error routine.
-	 */
-
-	__asm__ __volatile__ ("movec.l	%%vbr,%%a0\n\t"
-			      "move.l	8(%%a0),%0\n\t"
-			      "move.l	%1,8(%%a0)\n\t"
-			      : "=&r" (save_buserr)
-			      : "r" (&&scsi_bus_error)
-			      : "a0" );
-
-	hades_dma_ctrl &= 0xfc;		/* Bus error and EOP off. */
-
-	/*
-	 * Save the stack pointer.
-	 */
-
-	__asm__ __volatile__ ("move.l	%%sp,%0\n\t"
-			      : "=&r" (save_sp) );
-
-	tries = 100;			/* Maximum number of bus errors. */
-	start_addr = phys_to_virt(dma_base);
-	end_addr = start_addr + dma_cnt;
-
-scsi_loop:
-	dma_cnt--;
-	rem = dma_cnt & (TRANSFER_SIZE - 1);
-	dma_cnt &= ~(TRANSFER_SIZE - 1);
-	psdm_reg = &hades_psdm_reg;
-
-	if (tt_scsi_dma.dma_ctrl & 1)	/* Read or write? */
-	{
-		/*
-		 * SCSI write. Abort when count is zero.
-		 */
-
-		switch (rem)
-		{
-		case 0:
-			while (dma_cnt > 0)
-			{
-				dma_cnt -= TRANSFER_SIZE;
-
-				*psdm_reg = *start_addr++;
-		case 15:
-				*psdm_reg = *start_addr++;
-		case 14:
-				*psdm_reg = *start_addr++;
-		case 13:
-				*psdm_reg = *start_addr++;
-		case 12:
-				*psdm_reg = *start_addr++;
-		case 11:
-				*psdm_reg = *start_addr++;
-		case 10:
-				*psdm_reg = *start_addr++;
-		case 9:
-				*psdm_reg = *start_addr++;
-		case 8:
-				*psdm_reg = *start_addr++;
-		case 7:
-				*psdm_reg = *start_addr++;
-		case 6:
-				*psdm_reg = *start_addr++;
-		case 5:
-				*psdm_reg = *start_addr++;
-		case 4:
-				*psdm_reg = *start_addr++;
-		case 3:
-				*psdm_reg = *start_addr++;
-		case 2:
-				*psdm_reg = *start_addr++;
-		case 1:
-				*psdm_reg = *start_addr++;
-			}
-		}
-
-		hades_dma_ctrl |= 1;	/* Set EOP. */
-		udelay(10);
-		*psdm_reg = *start_addr++;	/* Dummy byte. */
-		tt_scsi_dma.dma_ctrl &= 0xfd;	/* DMA ready. */
-	}
-	else
-	{
-		/*
-		 * SCSI read. Abort when count is zero.
-		 */
-
-		switch (rem)
-		{
-		case 0:
-			while (dma_cnt > 0)
-			{
-				dma_cnt -= TRANSFER_SIZE;
-
-				*start_addr++ = *psdm_reg;
-		case 15:
-				*start_addr++ = *psdm_reg;
-		case 14:
-				*start_addr++ = *psdm_reg;
-		case 13:
-				*start_addr++ = *psdm_reg;
-		case 12:
-				*start_addr++ = *psdm_reg;
-		case 11:
-				*start_addr++ = *psdm_reg;
-		case 10:
-				*start_addr++ = *psdm_reg;
-		case 9:
-				*start_addr++ = *psdm_reg;
-		case 8:
-				*start_addr++ = *psdm_reg;
-		case 7:
-				*start_addr++ = *psdm_reg;
-		case 6:
-				*start_addr++ = *psdm_reg;
-		case 5:
-				*start_addr++ = *psdm_reg;
-		case 4:
-				*start_addr++ = *psdm_reg;
-		case 3:
-				*start_addr++ = *psdm_reg;
-		case 2:
-				*start_addr++ = *psdm_reg;
-		case 1:
-				*start_addr++ = *psdm_reg;
-			}
-		}
-
-		hades_dma_ctrl |= 1;	/* Set EOP. */
-		udelay(10);
-		*start_addr++ = *psdm_reg;
-		tt_scsi_dma.dma_ctrl &= 0xfd;	/* DMA ready. */
-
-		set_restdata_reg(start_addr);
-	}
-
-	if (start_addr != end_addr)
-		printk(KERN_CRIT "DMA emulation: FATAL: Count is not zero at end of transfer.\n");
-
-	dma_cnt = end_addr - start_addr;
-
-scsi_end:
-	dma_base = (dma_cnt == 0) ? virt_to_phys(start_addr - 1) + 1 :  
-				    virt_to_phys(start_addr);
-
-	SCSI_DMA_WRITE_P(dma_addr, dma_base);
-	SCSI_DMA_WRITE_P(dma_cnt, dma_cnt);
-
-	/*
-	 * Restore old bus error routine.
-	 */
-
-	__asm__ __volatile__ ("movec.l	%%vbr,%%a0\n\t"
-			      "move.l	%0,8(%%a0)\n\t"
-			      :
-			      : "r" (save_buserr)
-			      : "a0" );
-
-	atari_enable_irq(IRQ_TT_MFP_SCSI);
-
-	return IRQ_HANDLED;
-
-scsi_bus_error:
-	/*
-	 * First check if the bus error is caused by our code.
-	 * If not, call the original handler.
-	 */
-
-	__asm__ __volatile__ ("cmp.l	%0,2(%%sp)\n\t"
-			      "bcs.s	.old_vector\n\t"
-			      "cmp.l	%1,2(%%sp)\n\t"
-			      "bls.s	.scsi_buserr\n"
-			".old_vector:\n\t"
-			      "move.l	%2,-(%%sp)\n\t"
-			      "rts\n"
-			".scsi_buserr:\n\t"
-			      :
-			      : "i" (&&scsi_loop), "i" (&&scsi_end),
-			        "m" (save_buserr) );
-
-	if (CPU_IS_060)
-	{
-		/*
-		 * Get effective address and restore the stack.
-		 */
-
-		__asm__ __volatile__ ("move.l	8(%%sp),%0\n\t"
-				      "move.l	%1,%%sp\n\t"
-				      : "=a&" (eff_addr)
-				      : "r" (save_sp) );
-	}
-	else
-	{
-		register struct m68040_frame *frame;
-
-		__asm__ __volatile__ ("lea	8(%%sp),%0\n\t"
-				      : "=a&" (frame) );
-
-		if (tt_scsi_dma.dma_ctrl & 1)
-		{
-			/*
-			 * Bus error while writing.
-			 */
-
-			if (frame->wb3s & WBV_040)
-			{
-				if (frame->wb3a == (long) &hades_psdm_reg)
-					start_addr--;
-				else
-					writeback(frame->wb3s, frame->wb3a,
-						  frame->wb3d, &&scsi_bus_error);
-			}
-
-			if (frame->wb2s & WBV_040)
-			{
-				if (frame->wb2a == (long) &hades_psdm_reg)
-					start_addr--;
-				else
-					writeback(frame->wb2s, frame->wb2a,
-						  frame->wb2d, &&scsi_bus_error);
-			}
-
-			if (frame->wb1s & WBV_040)
-			{
-				if (frame->wb1a == (long) &hades_psdm_reg)
-					start_addr--;
-			}
-		}
-		else
-		{
-			/*
-			 * Bus error while reading.
-			 */
-
-			if (frame->wb3s & WBV_040)
-				writeback(frame->wb3s, frame->wb3a,
-					  frame->wb3d, &&scsi_bus_error);
-		}
-
-		eff_addr = (unsigned char *) frame->faddr;
-
-		__asm__ __volatile__ ("move.l	%0,%%sp\n\t"
-				      :
-				      : "r" (save_sp) );
-	}
-
-	dma_cnt = end_addr - start_addr;
-
-	if (eff_addr == &hades_psdm_reg)
-	{
-		/*
-		 * Bus error occurred while reading the pseudo
-		 * DMA register. Time out.
-		 */
-
-		tries--;
-
-		if (tries <= 0)
-		{
-			if ((tt_scsi_dma.dma_ctrl & 1) == 0)	/* Read or write? */
-				set_restdata_reg(start_addr);
-
-			if (dma_cnt <= 1)
-				printk(KERN_CRIT "DMA emulation: Fatal "
-				       "error while %s the last byte.\n",
-				       (tt_scsi_dma.dma_ctrl & 1)
-				       ? "writing" : "reading");
-
-			goto scsi_end;
-		}
-		else
-			goto scsi_loop;
-	}
-	else
-	{
-		/*
-		 * Bus error during pseudo DMA transfer.
-		 * Terminate the DMA transfer.
-		 */
-
-		hades_dma_ctrl |= 3;	/* Set EOP and bus error. */
-		if ((tt_scsi_dma.dma_ctrl & 1) == 0)	/* Read or write? */
-			set_restdata_reg(start_addr);
-		goto scsi_end;
-	}
-}
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -249,10 +249,6 @@ static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
 
 
-#if defined(CONFIG_TT_DMA_EMUL)
-#include "atari_dma_emul.c"
-#endif
-
 #if defined(REAL_DMA)
 
 static int scsi_dma_is_ignored_buserr(unsigned char dma_stat)
@@ -695,21 +691,8 @@ int atari_scsi_detect(struct scsi_host_t
 #ifdef REAL_DMA
 		tt_scsi_dma.dma_ctrl = 0;
 		atari_dma_residual = 0;
-#ifdef CONFIG_TT_DMA_EMUL
-		if (MACH_IS_HADES) {
-			if (request_irq(IRQ_AUTO_2, hades_dma_emulator,
-					 IRQ_TYPE_PRIO, "Hades DMA emulator",
-					 hades_dma_emulator)) {
-				printk(KERN_ERR "atari_scsi_detect: cannot allocate irq %d, aborting (MACH_IS_HADES)",IRQ_AUTO_2);
-				free_irq(IRQ_TT_MFP_SCSI, instance);
-				scsi_unregister(atari_scsi_host);
-				atari_stram_free(atari_dma_buffer);
-				atari_dma_buffer = 0;
-				return 0;
-			}
-		}
-#endif
-		if (MACH_IS_MEDUSA || MACH_IS_HADES) {
+
+		if (MACH_IS_MEDUSA) {
 			/* While the read overruns (described by Drew Eckhardt in
 			 * NCR5380.c) never happened on TTs, they do in fact on the Medusa
 			 * (This was the cause why SCSI didn't work right for so long
@@ -1007,11 +990,7 @@ static unsigned long atari_dma_xfer_len(
 					Scsi_Cmnd *cmd, int write_flag)
 {
 	unsigned long	possible_len, limit;
-#ifndef CONFIG_TT_DMA_EMUL
-	if (MACH_IS_HADES)
-		/* Hades has no SCSI DMA at all :-( Always force use of PIO */
-		return 0;
-#endif
+
 	if (IS_A_TT())
 		/* TT SCSI DMA can transfer arbitrary #bytes */
 		return wanted_len;
--- a/include/asm-m68k/atarihw.h
+++ b/include/asm-m68k/atarihw.h
@@ -39,7 +39,6 @@ extern int atari_dont_touch_floppy_selec
 #define MACH_IS_TT	((atari_mch_cookie >> 16) == ATARI_MCH_TT)
 #define MACH_IS_FALCON	((atari_mch_cookie >> 16) == ATARI_MCH_FALCON)
 #define MACH_IS_MEDUSA	(atari_mch_type == ATARI_MACH_MEDUSA)
-#define MACH_IS_HADES	(atari_mch_type == ATARI_MACH_HADES)
 #define MACH_IS_AB40	(atari_mch_type == ATARI_MACH_AB40)
 
 /* values for atari_switches */
--- a/include/asm-m68k/entry.h
+++ b/include/asm-m68k/entry.h
@@ -31,7 +31,7 @@
  */
 
 /* the following macro is used when enabling interrupts */
-#if defined(MACH_ATARI_ONLY) && !defined(CONFIG_HADES)
+#if defined(MACH_ATARI_ONLY)
 	/* block out HSYNC on the atari */
 #define ALLOWINT	(~0x400)
 #define	MAX_NOINT_IPL	3
--- a/include/asm-m68k/virtconvert.h
+++ b/include/asm-m68k/virtconvert.h
@@ -40,15 +40,9 @@ static inline void *phys_to_virt(unsigne
 
 /*
  * IO bus memory addresses are 1:1 with the physical address,
- * except on the PCI bus of the Hades.
  */
-#ifdef CONFIG_HADES
-#define virt_to_bus(a) (virt_to_phys(a) + (MACH_IS_HADES ? 0x80000000 : 0))
-#define bus_to_virt(a) (phys_to_virt((a) - (MACH_IS_HADES ? 0x80000000 : 0)))
-#else
 #define virt_to_bus virt_to_phys
 #define bus_to_virt phys_to_virt
-#endif
 
 #endif
 #endif
