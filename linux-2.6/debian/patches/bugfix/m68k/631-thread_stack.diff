To: linus, akpm
Cc: lkml
Subject: [PATCH] Thread stack abstractions

From: Roman Zippel <zippel@linux-m68k.org>

Thread stack abstractions:
  - Move thread_info into task_struct
  - Adapt thread_info initialization
  - Abstract thread_info access
  - Thread_info field becomes stack
  - Change get_task_struct/put_task_struct into inline functions
  - Move task_struct into <linux/task_struct.h>

Signed-off-by: Roman Zippel <zippel@linux-m68k.org>

---
 include/asm-m68k/thread_info.h |   12 ++++++------
 include/linux/init_task.h      |    2 +-
 include/linux/sched.h          |    3 ++-
 kernel/fork.c                  |   10 +++++-----
 4 files changed, 14 insertions(+), 13 deletions(-)

--- linux-m68k-2.6.21.orig/include/asm-m68k/thread_info.h
+++ linux-m68k-2.6.21/include/asm-m68k/thread_info.h
@@ -26,24 +26,24 @@ struct thread_info {
 
 /* THREAD_SIZE should be 8k, so handle differently for 4k and 8k machines */
 #if PAGE_SHIFT == 13 /* 8k machines */
-#define alloc_thread_info(tsk)   ((struct thread_info *)__get_free_pages(GFP_KERNEL,0))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),0)
+#define alloc_thread_stack(tsk) ((void *)__get_free_pages(GFP_KERNEL,0))
+#define free_thread_stack(ti)  free_pages((unsigned long)(ti),0)
 #else /* otherwise assume 4k pages */
-#define alloc_thread_info(tsk)   ((struct thread_info *)__get_free_pages(GFP_KERNEL,1))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),1)
+#define alloc_thread_stack(tsk) ((void *)__get_free_pages(GFP_KERNEL,1))
+#define free_thread_stack(ti)  free_pages((unsigned long)(ti),1)
 #endif /* PAGE_SHIFT == 13 */
 
 #define init_thread_info	(init_task.thread.info)
 #define init_stack		(init_thread_union.stack)
 
 #define task_thread_info(tsk)	(&(tsk)->thread.info)
-#define task_stack_page(tsk)	((void *)(tsk)->thread_info)
+#define task_stack_page(tsk)	((void *)(tsk)->stack)
 #define current_thread_info()	task_thread_info(current)
 
 #define __HAVE_THREAD_FUNCTIONS
 
 #define setup_thread_stack(p, org) ({			\
-	*(struct task_struct **)(p)->thread_info = (p);	\
+	*(struct task_struct **)(p)->stack = (p);	\
 	task_thread_info(p)->task = (p);		\
 })
 
--- linux-m68k-2.6.21.orig/include/linux/init_task.h
+++ linux-m68k-2.6.21/include/linux/init_task.h
@@ -95,7 +95,7 @@ extern struct group_info init_groups;
 #define INIT_TASK(tsk)	\
 {									\
 	.state		= 0,						\
-	.thread_info	= &init_thread_info,				\
+	.stack		= &init_stack,					\
 	.usage		= ATOMIC_INIT(2),				\
 	.flags		= 0,						\
 	.lock_depth	= -1,						\
--- linux-m68k-2.6.21.orig/include/linux/sched.h
+++ linux-m68k-2.6.21/include/linux/sched.h
@@ -799,7 +799,8 @@ struct prio_array;
 
 struct task_struct {
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
-	struct thread_info *thread_info;
+	//struct thread_info *thread_info;
+	void *stack;
 	atomic_t usage;
 	unsigned long flags;	/* per process flags, defined below */
 	unsigned long ptrace;
--- linux-m68k-2.6.21.orig/kernel/fork.c
+++ linux-m68k-2.6.21/kernel/fork.c
@@ -106,7 +106,7 @@ static struct kmem_cache *mm_cachep;
 
 void free_task(struct task_struct *tsk)
 {
-	free_thread_info(tsk->thread_info);
+	free_thread_stack(tsk->stack);
 	rt_mutex_debug_task_free(tsk);
 	free_task_struct(tsk);
 }
@@ -161,7 +161,7 @@ void __init fork_init(unsigned long memp
 static struct task_struct *dup_task_struct(struct task_struct *orig)
 {
 	struct task_struct *tsk;
-	struct thread_info *ti;
+	void *stack;
 
 	prepare_to_copy(orig);
 
@@ -169,14 +169,14 @@ static struct task_struct *dup_task_stru
 	if (!tsk)
 		return NULL;
 
-	ti = alloc_thread_info(tsk);
-	if (!ti) {
+	stack = alloc_thread_stack(tsk);
+	if (!stack) {
 		free_task_struct(tsk);
 		return NULL;
 	}
 
 	*tsk = *orig;
-	tsk->thread_info = ti;
+	tsk->stack = stack;
 	setup_thread_stack(tsk, orig);
 
 #ifdef CONFIG_CC_STACKPROTECTOR
