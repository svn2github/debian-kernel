diff --git a/arch/mips/au1000/common/Makefile b/arch/mips/au1000/common/Makefile
index 90e2d7a..dd0e19d 100644
--- a/arch/mips/au1000/common/Makefile
+++ b/arch/mips/au1000/common/Makefile
@@ -1,9 +1,8 @@
 #
-#  Copyright 2000 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Copyright 2000, 2008 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc. <source@mvista.com>
 #
-# Makefile for the Alchemy Au1000 CPU, generic files.
+# Makefile for the Alchemy Au1xx0 CPUs, generic files.
 #
 
 obj-y += prom.o irq.o puts.o time.o reset.o \
diff --git a/arch/mips/au1000/common/au1xxx_irqmap.c b/arch/mips/au1000/common/au1xxx_irqmap.c
index 37a10a0..c7ca159 100644
--- a/arch/mips/au1000/common/au1xxx_irqmap.c
+++ b/arch/mips/au1000/common/au1xxx_irqmap.c
@@ -40,20 +40,20 @@
 struct au1xxx_irqmap __initdata au1xxx_ic0_map[] = {
 
 #if defined(CONFIG_SOC_AU1000)
-	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART2_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_UART0_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_UART1_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_UART2_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_UART3_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
@@ -62,32 +62,32 @@ struct au1xxx_irqmap __initdata au1xxx_ic0_map[] = {
 	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
 
 #elif defined(CONFIG_SOC_AU1500)
 
-	{ AU1500_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1500_UART0_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1500_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1500_UART3_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
@@ -100,26 +100,26 @@ struct au1xxx_irqmap __initdata au1xxx_ic0_map[] = {
 	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1500_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1500_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1500_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1500_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
 
 #elif defined(CONFIG_SOC_AU1100)
 
-	{ AU1100_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1100_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1100_SD_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1100_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1100_UART0_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1100_UART1_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1100_SD_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1100_UART3_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_SSI0_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_SSI1_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+1, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+2, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+3, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+4, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+5, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+6, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_DMA_INT_BASE+7, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
@@ -128,33 +128,33 @@ struct au1xxx_irqmap __initdata au1xxx_ic0_map[] = {
 	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1000_IRDA_TX_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1000_IRDA_RX_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1000_ACSYNC_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1100_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	/*{ AU1000_GPIO215_208_INT, INTC_INT_HIGH_LEVEL, 0},*/
-	{ AU1100_LCD_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1100_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0 },
+	/* { AU1000_GPIO215_208_INT, INTC_INT_HIGH_LEVEL, 0 }, */
+	{ AU1100_LCD_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_AC97C_INT, INTC_INT_RISE_EDGE, 0 },
 
 #elif defined(CONFIG_SOC_AU1550)
 
-	{ AU1550_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_UART0_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1550_PCI_INTA, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1550_PCI_INTB, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_DDMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_CRYPTO_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_DDMA_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_CRYPTO_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1550_PCI_INTC, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1550_PCI_INTD, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1550_PCI_RST_INT, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_UART3_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC2_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_PSC3_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_UART1_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_UART3_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_PSC0_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_PSC1_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_PSC2_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_PSC3_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
@@ -163,26 +163,26 @@ struct au1xxx_irqmap __initdata au1xxx_ic0_map[] = {
 	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1550_NAND_INT, INTC_INT_RISE_EDGE, 0},
+	{ AU1550_NAND_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1550_USB_DEV_REQ_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1550_USB_DEV_SUS_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1550_USB_HOST_INT, INTC_INT_LOW_LEVEL, 0 },
-	{ AU1550_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1550_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1550_MAC0_DMA_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1550_MAC1_DMA_INT, INTC_INT_HIGH_LEVEL, 0 },
 
 #elif defined(CONFIG_SOC_AU1200)
 
-	{ AU1200_UART0_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_UART0_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1200_SWT_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_SD_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_DDMA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_SD_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_DDMA_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1200_MAE_BE_INT, INTC_INT_HIGH_LEVEL, 0 },
-	{ AU1200_UART1_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_UART1_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1200_MAE_FE_INT, INTC_INT_HIGH_LEVEL, 0 },
-	{ AU1200_PSC0_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_PSC1_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_AES_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_CAMERA_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_PSC0_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_PSC1_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_AES_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_CAMERA_INT, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1000_TOY_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_TOY_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
@@ -191,10 +191,10 @@ struct au1xxx_irqmap __initdata au1xxx_ic0_map[] = {
 	{ AU1000_RTC_MATCH0_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH1_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1000_RTC_MATCH2_INT, INTC_INT_RISE_EDGE, 0 },
-	{ AU1200_NAND_INT, INTC_INT_RISE_EDGE, 0},
+	{ AU1200_NAND_INT, INTC_INT_RISE_EDGE, 0 },
 	{ AU1200_USB_INT, INTC_INT_HIGH_LEVEL, 0 },
-	{ AU1200_LCD_INT, INTC_INT_HIGH_LEVEL, 0},
-	{ AU1200_MAE_BOTH_INT, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1200_LCD_INT, INTC_INT_HIGH_LEVEL, 0 },
+	{ AU1200_MAE_BOTH_INT, INTC_INT_HIGH_LEVEL, 0 },
 
 #else
 #error "Error: Unknown Alchemy SOC"
@@ -203,4 +203,3 @@ struct au1xxx_irqmap __initdata au1xxx_ic0_map[] = {
 };
 
 int __initdata au1xxx_ic0_nr_irqs = ARRAY_SIZE(au1xxx_ic0_map);
-
diff --git a/arch/mips/au1000/common/clocks.c b/arch/mips/au1000/common/clocks.c
index 3ce6cac..46f8ee0 100644
--- a/arch/mips/au1000/common/clocks.c
+++ b/arch/mips/au1000/common/clocks.c
@@ -1,10 +1,9 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	Simple Au1000 clocks routines.
+ *	Simple Au1xx0 clocks routines.
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *		ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute	 it and/or modify it
  *  under  the terms of	 the GNU General  Public License as published by the
@@ -30,8 +29,8 @@
 #include <linux/module.h>
 #include <asm/mach-au1x00/au1000.h>
 
-static unsigned int au1x00_clock; // Hz
-static unsigned int lcd_clock;    // KHz
+static unsigned int au1x00_clock; /*  Hz */
+static unsigned int lcd_clock;    /* KHz */
 static unsigned long uart_baud_base;
 
 /*
@@ -47,8 +46,6 @@ unsigned int get_au1x00_speed(void)
 	return au1x00_clock;
 }
 
-
-
 /*
  * The UART baud base is not known at compile time ... if
  * we want to be able to use the same code on different
@@ -73,24 +70,23 @@ void set_au1x00_uart_baud_base(unsigned long new_baud_base)
 void set_au1x00_lcd_clock(void)
 {
 	unsigned int static_cfg0;
-	unsigned int sys_busclk =
-		(get_au1x00_speed()/1000) /
-		((int)(au_readl(SYS_POWERCTRL)&0x03) + 2);
+	unsigned int sys_busclk = (get_au1x00_speed() / 1000) /
+				  ((int)(au_readl(SYS_POWERCTRL) & 0x03) + 2);
 
 	static_cfg0 = au_readl(MEM_STCFG0);
 
-	if (static_cfg0 & (1<<11))
+	if (static_cfg0 & (1 << 11))
 		lcd_clock = sys_busclk / 5; /* note: BCLK switching fails with D5 */
 	else
 		lcd_clock = sys_busclk / 4;
 
 	if (lcd_clock > 50000) /* Epson MAX */
-		printk("warning: LCD clock too high (%d KHz)\n", lcd_clock);
+		printk(KERN_WARNING "warning: LCD clock too high (%u KHz)\n",
+				    lcd_clock);
 }
 
 unsigned int get_au1x00_lcd_clock(void)
 {
 	return lcd_clock;
 }
-
 EXPORT_SYMBOL(get_au1x00_lcd_clock);
diff --git a/arch/mips/au1000/common/cputable.c b/arch/mips/au1000/common/cputable.c
index 8c93a05..ba6430b 100644
--- a/arch/mips/au1000/common/cputable.c
+++ b/arch/mips/au1000/common/cputable.c
@@ -14,7 +14,7 @@
 
 #include <asm/mach-au1x00/au1000.h>
 
-struct cpu_spec* cur_cpu_spec[NR_CPUS];
+struct cpu_spec *cur_cpu_spec[NR_CPUS];
 
 /* With some thought, we can probably use the mask to reduce the
  * size of the table.
@@ -39,8 +39,7 @@ struct cpu_spec cpu_specs[] = {
 	{ 0x00000000, 0x00000000, "Unknown Au1xxx", 1, 0, 0 }
 };
 
-void
-set_cpuspec(void)
+void set_cpuspec(void)
 {
 	struct	cpu_spec *sp;
 	u32	prid;
diff --git a/arch/mips/au1000/common/dbdma.c b/arch/mips/au1000/common/dbdma.c
index 53377df..42d5552 100644
--- a/arch/mips/au1000/common/dbdma.c
+++ b/arch/mips/au1000/common/dbdma.c
@@ -53,12 +53,11 @@
  */
 static DEFINE_SPINLOCK(au1xxx_dbdma_spin_lock);
 
-/* I couldn't find a macro that did this......
-*/
+/* I couldn't find a macro that did this... */
 #define ALIGN_ADDR(x, a)	((((u32)(x)) + (a-1)) & ~(a-1))
 
 static dbdma_global_t *dbdma_gptr = (dbdma_global_t *)DDMA_GLOBAL_BASE;
-static int dbdma_initialized=0;
+static int dbdma_initialized;
 static void au1xxx_dbdma_init(void);
 
 static dbdev_tab_t dbdev_tab[] = {
@@ -149,7 +148,7 @@ static dbdev_tab_t dbdev_tab[] = {
 
 	{ DSCR_CMD0_NAND_FLASH, DEV_FLAGS_IN, 0, 0, 0x00000000, 0, 0 },
 
-#endif // CONFIG_SOC_AU1200
+#endif /* CONFIG_SOC_AU1200 */
 
 	{ DSCR_CMD0_THROTTLE, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
 	{ DSCR_CMD0_ALWAYS, DEV_FLAGS_ANYUSE, 0, 0, 0x00000000, 0, 0 },
@@ -177,8 +176,7 @@ static dbdev_tab_t dbdev_tab[] = {
 
 static chan_tab_t *chan_tab_ptr[NUM_DBDMA_CHANS];
 
-static dbdev_tab_t *
-find_dbdev_id(u32 id)
+static dbdev_tab_t *find_dbdev_id(u32 id)
 {
 	int i;
 	dbdev_tab_t *p;
@@ -190,29 +188,27 @@ find_dbdev_id(u32 id)
 	return NULL;
 }
 
-void * au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp)
+void *au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp)
 {
-        return phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
+	return phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 }
 EXPORT_SYMBOL(au1xxx_ddma_get_nextptr_virt);
 
-u32
-au1xxx_ddma_add_device(dbdev_tab_t *dev)
+u32 au1xxx_ddma_add_device(dbdev_tab_t *dev)
 {
 	u32 ret = 0;
-	dbdev_tab_t *p=NULL;
-	static u16 new_id=0x1000;
+	dbdev_tab_t *p;
+	static u16 new_id = 0x1000;
 
 	p = find_dbdev_id(~0);
-	if ( NULL != p )
-	{
+	if (NULL != p) {
 		memcpy(p, dev, sizeof(dbdev_tab_t));
 		p->dev_id = DSCR_DEV2CUSTOM_ID(new_id, dev->dev_id);
 		ret = p->dev_id;
 		new_id++;
 #if 0
-		printk("add_device: id:%x flags:%x padd:%x\n",
-				p->dev_id, p->dev_flags, p->dev_physaddr );
+		printk(KERN_DEBUG "add_device: id:%x flags:%x padd:%x\n",
+				  p->dev_id, p->dev_flags, p->dev_physaddr);
 #endif
 	}
 
@@ -220,10 +216,8 @@ au1xxx_ddma_add_device(dbdev_tab_t *dev)
 }
 EXPORT_SYMBOL(au1xxx_ddma_add_device);
 
-/* Allocate a channel and return a non-zero descriptor if successful.
-*/
-u32
-au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
+/* Allocate a channel and return a non-zero descriptor if successful. */
+u32 au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
        void (*callback)(int, void *), void *callparam)
 {
 	unsigned long   flags;
@@ -234,7 +228,8 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
 	chan_tab_t	*ctp;
 	au1x_dma_chan_t *cp;
 
-	/* We do the intialization on the first channel allocation.
+	/*
+	 * We do the intialization on the first channel allocation.
 	 * We have to wait because of the interrupt handler initialization
 	 * which can't be done successfully during board set up.
 	 */
@@ -242,16 +237,17 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
 		au1xxx_dbdma_init();
 	dbdma_initialized = 1;
 
-	if ((stp = find_dbdev_id(srcid)) == NULL)
+	stp = find_dbdev_id(srcid);
+	if (stp == NULL)
 		return 0;
-	if ((dtp = find_dbdev_id(destid)) == NULL)
+	dtp = find_dbdev_id(destid);
+	if (dtp == NULL)
 		return 0;
 
 	used = 0;
 	rv = 0;
 
-	/* Check to see if we can get both channels.
-	*/
+	/* Check to see if we can get both channels. */
 	spin_lock_irqsave(&au1xxx_dbdma_spin_lock, flags);
 	if (!(stp->dev_flags & DEV_FLAGS_INUSE) ||
 	     (stp->dev_flags & DEV_FLAGS_ANYUSE)) {
@@ -261,35 +257,30 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
 		     (dtp->dev_flags & DEV_FLAGS_ANYUSE)) {
 			/* Got destination */
 			dtp->dev_flags |= DEV_FLAGS_INUSE;
-		}
-		else {
-			/* Can't get dest.  Release src.
-			*/
+		} else {
+			/* Can't get dest.  Release src. */
 			stp->dev_flags &= ~DEV_FLAGS_INUSE;
 			used++;
 		}
-	}
-	else {
+	} else
 		used++;
-	}
 	spin_unlock_irqrestore(&au1xxx_dbdma_spin_lock, flags);
 
 	if (!used) {
-		/* Let's see if we can allocate a channel for it.
-		*/
+		/* Let's see if we can allocate a channel for it. */
 		ctp = NULL;
 		chan = 0;
 		spin_lock_irqsave(&au1xxx_dbdma_spin_lock, flags);
-		for (i=0; i<NUM_DBDMA_CHANS; i++) {
+		for (i = 0; i < NUM_DBDMA_CHANS; i++)
 			if (chan_tab_ptr[i] == NULL) {
-				/* If kmalloc fails, it is caught below same
+				/*
+				 * If kmalloc fails, it is caught below same
 				 * as a channel not available.
 				 */
 				ctp = kmalloc(sizeof(chan_tab_t), GFP_ATOMIC);
 				chan_tab_ptr[i] = ctp;
 				break;
 			}
-		}
 		spin_unlock_irqrestore(&au1xxx_dbdma_spin_lock, flags);
 
 		if (ctp != NULL) {
@@ -304,8 +295,7 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
 			ctp->chan_callback = callback;
 			ctp->chan_callparam = callparam;
 
-			/* Initialize channel configuration.
-			*/
+			/* Initialize channel configuration. */
 			i = 0;
 			if (stp->dev_intlevel)
 				i |= DDMA_CFG_SED;
@@ -326,8 +316,7 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
 			 * operations.
 			 */
 			rv = (u32)(&chan_tab_ptr[chan]);
-		}
-		else {
+		} else {
 			/* Release devices */
 			stp->dev_flags &= ~DEV_FLAGS_INUSE;
 			dtp->dev_flags &= ~DEV_FLAGS_INUSE;
@@ -337,11 +326,11 @@ au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
 }
 EXPORT_SYMBOL(au1xxx_dbdma_chan_alloc);
 
-/* Set the device width if source or destination is a FIFO.
+/*
+ * Set the device width if source or destination is a FIFO.
  * Should be 8, 16, or 32 bits.
  */
-u32
-au1xxx_dbdma_set_devwidth(u32 chanid, int bits)
+u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits)
 {
 	u32		rv;
 	chan_tab_t	*ctp;
@@ -365,10 +354,8 @@ au1xxx_dbdma_set_devwidth(u32 chanid, int bits)
 }
 EXPORT_SYMBOL(au1xxx_dbdma_set_devwidth);
 
-/* Allocate a descriptor ring, initializing as much as possible.
-*/
-u32
-au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
+/* Allocate a descriptor ring, initializing as much as possible. */
+u32 au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
 {
 	int			i;
 	u32			desc_base, srcid, destid;
@@ -378,43 +365,45 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
 	dbdev_tab_t		*stp, *dtp;
 	au1x_ddma_desc_t	*dp;
 
-	/* I guess we could check this to be within the
+	/*
+	 * I guess we could check this to be within the
 	 * range of the table......
 	 */
 	ctp = *((chan_tab_t **)chanid);
 	stp = ctp->chan_src;
 	dtp = ctp->chan_dest;
 
-	/* The descriptors must be 32-byte aligned.  There is a
+	/*
+	 * The descriptors must be 32-byte aligned.  There is a
 	 * possibility the allocation will give us such an address,
 	 * and if we try that first we are likely to not waste larger
 	 * slabs of memory.
 	 */
 	desc_base = (u32)kmalloc(entries * sizeof(au1x_ddma_desc_t),
-			GFP_KERNEL|GFP_DMA);
+				 GFP_KERNEL|GFP_DMA);
 	if (desc_base == 0)
 		return 0;
 
 	if (desc_base & 0x1f) {
-		/* Lost....do it again, allocate extra, and round
+		/*
+		 * Lost....do it again, allocate extra, and round
 		 * the address base.
 		 */
 		kfree((const void *)desc_base);
 		i = entries * sizeof(au1x_ddma_desc_t);
 		i += (sizeof(au1x_ddma_desc_t) - 1);
-		if ((desc_base = (u32)kmalloc(i, GFP_KERNEL|GFP_DMA)) == 0)
+		desc_base = (u32)kmalloc(i, GFP_KERNEL|GFP_DMA);
+		if (desc_base == 0)
 			return 0;
 
 		desc_base = ALIGN_ADDR(desc_base, sizeof(au1x_ddma_desc_t));
 	}
 	dp = (au1x_ddma_desc_t *)desc_base;
 
-	/* Keep track of the base descriptor.
-	*/
+	/* Keep track of the base descriptor. */
 	ctp->chan_desc_base = dp;
 
-	/* Initialize the rings with as much information as we know.
-	 */
+	/* Initialize the rings with as much information as we know. */
 	srcid = stp->dev_id;
 	destid = dtp->dev_id;
 
@@ -426,11 +415,12 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
 	cmd0 |= DSCR_CMD0_IE | DSCR_CMD0_CV;
 	cmd0 |= DSCR_CMD0_ST(DSCR_CMD0_ST_NOCHANGE);
 
-        /* is it mem to mem transfer? */
-        if(((DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_THROTTLE) || (DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_ALWAYS)) &&
-           ((DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_THROTTLE) || (DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_ALWAYS))) {
-               cmd0 |= DSCR_CMD0_MEM;
-        }
+	/* Is it mem to mem transfer? */
+	if (((DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_THROTTLE) ||
+	     (DSCR_CUSTOM2DEV_ID(srcid) == DSCR_CMD0_ALWAYS)) &&
+	    ((DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_THROTTLE) ||
+	     (DSCR_CUSTOM2DEV_ID(destid) == DSCR_CMD0_ALWAYS)))
+		cmd0 |= DSCR_CMD0_MEM;
 
 	switch (stp->dev_devwidth) {
 	case 8:
@@ -458,15 +448,17 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
 		break;
 	}
 
-	/* If the device is marked as an in/out FIFO, ensure it is
+	/*
+	 * If the device is marked as an in/out FIFO, ensure it is
 	 * set non-coherent.
 	 */
 	if (stp->dev_flags & DEV_FLAGS_IN)
-		cmd0 |= DSCR_CMD0_SN;		/* Source in fifo */
+		cmd0 |= DSCR_CMD0_SN;		/* Source in FIFO */
 	if (dtp->dev_flags & DEV_FLAGS_OUT)
-		cmd0 |= DSCR_CMD0_DN;		/* Destination out fifo */
+		cmd0 |= DSCR_CMD0_DN;		/* Destination out FIFO */
 
-	/* Set up source1.  For now, assume no stride and increment.
+	/*
+	 * Set up source1.  For now, assume no stride and increment.
 	 * A channel attribute update can change this later.
 	 */
 	switch (stp->dev_tsize) {
@@ -485,19 +477,19 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
 		break;
 	}
 
-	/* If source input is fifo, set static address.
-	*/
+	/* If source input is FIFO, set static address.	*/
 	if (stp->dev_flags & DEV_FLAGS_IN) {
-		if ( stp->dev_flags & DEV_FLAGS_BURSTABLE )
+		if (stp->dev_flags & DEV_FLAGS_BURSTABLE)
 			src1 |= DSCR_SRC1_SAM(DSCR_xAM_BURST);
 		else
-		src1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);
-
+			src1 |= DSCR_SRC1_SAM(DSCR_xAM_STATIC);
 	}
+
 	if (stp->dev_physaddr)
 		src0 = stp->dev_physaddr;
 
-	/* Set up dest1.  For now, assume no stride and increment.
+	/*
+	 * Set up dest1.  For now, assume no stride and increment.
 	 * A channel attribute update can change this later.
 	 */
 	switch (dtp->dev_tsize) {
@@ -516,22 +508,24 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
 		break;
 	}
 
-	/* If destination output is fifo, set static address.
-	*/
+	/* If destination output is FIFO, set static address. */
 	if (dtp->dev_flags & DEV_FLAGS_OUT) {
-		if ( dtp->dev_flags & DEV_FLAGS_BURSTABLE )
-	                dest1 |= DSCR_DEST1_DAM(DSCR_xAM_BURST);
-				else
-		dest1 |= DSCR_DEST1_DAM(DSCR_xAM_STATIC);
+		if (dtp->dev_flags & DEV_FLAGS_BURSTABLE)
+			dest1 |= DSCR_DEST1_DAM(DSCR_xAM_BURST);
+		else
+			dest1 |= DSCR_DEST1_DAM(DSCR_xAM_STATIC);
 	}
+
 	if (dtp->dev_physaddr)
 		dest0 = dtp->dev_physaddr;
 
 #if 0
-		printk("did:%x sid:%x cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",
-			dtp->dev_id, stp->dev_id, cmd0, cmd1, src0, src1, dest0, dest1 );
+		printk(KERN_DEBUG "did:%x sid:%x cmd0:%x cmd1:%x source0:%x "
+				  "source1:%x dest0:%x dest1:%x\n",
+				  dtp->dev_id, stp->dev_id, cmd0, cmd1, src0,
+				  src1, dest0, dest1);
 #endif
-	for (i=0; i<entries; i++) {
+	for (i = 0; i < entries; i++) {
 		dp->dscr_cmd0 = cmd0;
 		dp->dscr_cmd1 = cmd1;
 		dp->dscr_source0 = src0;
@@ -545,49 +539,49 @@ au1xxx_dbdma_ring_alloc(u32 chanid, int entries)
 		dp++;
 	}
 
-	/* Make last descrptor point to the first.
-	*/
+	/* Make last descrptor point to the first. */
 	dp--;
 	dp->dscr_nxtptr = DSCR_NXTPTR(virt_to_phys(ctp->chan_desc_base));
 	ctp->get_ptr = ctp->put_ptr = ctp->cur_ptr = ctp->chan_desc_base;
 
-	return (u32)(ctp->chan_desc_base);
+	return (u32)ctp->chan_desc_base;
 }
 EXPORT_SYMBOL(au1xxx_dbdma_ring_alloc);
 
-/* Put a source buffer into the DMA ring.
+/*
+ * Put a source buffer into the DMA ring.
  * This updates the source pointer and byte count.  Normally used
  * for memory to fifo transfers.
  */
-u32
-_au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags)
+u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
 
-	/* I guess we could check this to be within the
+	/*
+	 * I guess we could check this to be within the
 	 * range of the table......
 	 */
-	ctp = *((chan_tab_t **)chanid);
+	ctp = *(chan_tab_t **)chanid;
 
-	/* We should have multiple callers for a particular channel,
+	/*
+	 * We should have multiple callers for a particular channel,
 	 * an interrupt doesn't affect this pointer nor the descriptor,
 	 * so no locking should be needed.
 	 */
 	dp = ctp->put_ptr;
 
-	/* If the descriptor is valid, we are way ahead of the DMA
+	/*
+	 * If the descriptor is valid, we are way ahead of the DMA
 	 * engine, so just return an error condition.
 	 */
-	if (dp->dscr_cmd0 & DSCR_CMD0_V) {
+	if (dp->dscr_cmd0 & DSCR_CMD0_V)
 		return 0;
-	}
 
-	/* Load up buffer address and byte count.
-	*/
+	/* Load up buffer address and byte count. */
 	dp->dscr_source0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
-	/* Check flags  */
+	/* Check flags */
 	if (flags & DDMA_FLAGS_IE)
 		dp->dscr_cmd0 |= DSCR_CMD0_IE;
 	if (flags & DDMA_FLAGS_NOIE)
@@ -595,23 +589,21 @@ _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags)
 
 	/*
 	 * There is an errata on the Au1200/Au1550 parts that could result
-	 * in "stale" data being DMA'd. It has to do with the snoop logic on
-	 * the dache eviction buffer.  NONCOHERENT_IO is on by default for
-	 * these parts. If it is fixedin the future, these dma_cache_inv will
+	 * in "stale" data being DMA'ed. It has to do with the snoop logic on
+	 * the cache eviction buffer.  DMA_NONCOHERENT is on by default for
+	 * these parts. If it is fixed in the future, these dma_cache_inv will
 	 * just be nothing more than empty macros. See io.h.
-	 * */
+	 */
 	dma_cache_wback_inv((unsigned long)buf, nbytes);
-        dp->dscr_cmd0 |= DSCR_CMD0_V;        /* Let it rip */
+	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
 	au_sync();
 	dma_cache_wback_inv((unsigned long)dp, sizeof(dp));
-        ctp->chan_ptr->ddma_dbell = 0;
+	ctp->chan_ptr->ddma_dbell = 0;
 
-	/* Get next descriptor pointer.
-	*/
+	/* Get next descriptor pointer.	*/
 	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 
-	/* return something not zero.
-	*/
+	/* Return something non-zero. */
 	return nbytes;
 }
 EXPORT_SYMBOL(_au1xxx_dbdma_put_source);
@@ -654,81 +646,77 @@ _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags)
 	dp->dscr_dest0 = virt_to_phys(buf);
 	dp->dscr_cmd1 = nbytes;
 #if 0
-	printk("cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",
-			dp->dscr_cmd0, dp->dscr_cmd1, dp->dscr_source0,
-			dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1 );
+	printk(KERN_DEBUG "cmd0:%x cmd1:%x source0:%x source1:%x dest0:%x dest1:%x\n",
+			  dp->dscr_cmd0, dp->dscr_cmd1, dp->dscr_source0,
+			  dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1);
 #endif
 	/*
 	 * There is an errata on the Au1200/Au1550 parts that could result in
-	 * "stale" data being DMA'd. It has to do with the snoop logic on the
-	 * dache eviction buffer. NONCOHERENT_IO is on by default for these
-	 * parts. If it is fixedin the future, these dma_cache_inv will just
+	 * "stale" data being DMA'ed. It has to do with the snoop logic on the
+	 * cache eviction buffer.  DMA_NONCOHERENT is on by default for these
+	 * parts. If it is fixed in the future, these dma_cache_inv will just
 	 * be nothing more than empty macros. See io.h.
-	 * */
+	 */
 	dma_cache_inv((unsigned long)buf, nbytes);
 	dp->dscr_cmd0 |= DSCR_CMD0_V;	/* Let it rip */
 	au_sync();
 	dma_cache_wback_inv((unsigned long)dp, sizeof(dp));
-        ctp->chan_ptr->ddma_dbell = 0;
+	ctp->chan_ptr->ddma_dbell = 0;
 
-	/* Get next descriptor pointer.
-	*/
+	/* Get next descriptor pointer.	*/
 	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 
-	/* return something not zero.
-	*/
+	/* Return something non-zero. */
 	return nbytes;
 }
 EXPORT_SYMBOL(_au1xxx_dbdma_put_dest);
 
-/* Get a destination buffer into the DMA ring.
+/*
+ * Get a destination buffer into the DMA ring.
  * Normally used to get a full buffer from the ring during fifo
  * to memory transfers.  This does not set the valid bit, you will
  * have to put another destination buffer to keep the DMA going.
  */
-u32
-au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes)
+u32 au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
 	u32			rv;
 
-	/* I guess we could check this to be within the
+	/*
+	 * I guess we could check this to be within the
 	 * range of the table......
 	 */
 	ctp = *((chan_tab_t **)chanid);
 
-	/* We should have multiple callers for a particular channel,
+	/*
+	 * We should have multiple callers for a particular channel,
 	 * an interrupt doesn't affect this pointer nor the descriptor,
 	 * so no locking should be needed.
 	 */
 	dp = ctp->get_ptr;
 
-	/* If the descriptor is valid, we are way ahead of the DMA
+	/*
+	 * If the descriptor is valid, we are way ahead of the DMA
 	 * engine, so just return an error condition.
 	 */
 	if (dp->dscr_cmd0 & DSCR_CMD0_V)
 		return 0;
 
-	/* Return buffer address and byte count.
-	*/
+	/* Return buffer address and byte count. */
 	*buf = (void *)(phys_to_virt(dp->dscr_dest0));
 	*nbytes = dp->dscr_cmd1;
 	rv = dp->dscr_stat;
 
-	/* Get next descriptor pointer.
-	*/
+	/* Get next descriptor pointer.	*/
 	ctp->get_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 
-	/* return something not zero.
-	*/
+	/* Return something non-zero. */
 	return rv;
 }
-
 EXPORT_SYMBOL_GPL(au1xxx_dbdma_get_dest);
 
-void
-au1xxx_dbdma_stop(u32 chanid)
+void au1xxx_dbdma_stop(u32 chanid)
 {
 	chan_tab_t	*ctp;
 	au1x_dma_chan_t *cp;
@@ -743,7 +731,7 @@ au1xxx_dbdma_stop(u32 chanid)
 		udelay(1);
 		halt_timeout++;
 		if (halt_timeout > 100) {
-			printk("warning: DMA channel won't halt\n");
+			printk(KERN_WARNING "warning: DMA channel won't halt\n");
 			break;
 		}
 	}
@@ -753,12 +741,12 @@ au1xxx_dbdma_stop(u32 chanid)
 }
 EXPORT_SYMBOL(au1xxx_dbdma_stop);
 
-/* Start using the current descriptor pointer.  If the dbdma encounters
- * a not valid descriptor, it will stop.  In this case, we can just
+/*
+ * Start using the current descriptor pointer.  If the DBDMA encounters
+ * a non-valid descriptor, it will stop.  In this case, we can just
  * continue by adding a buffer to the list and starting again.
  */
-void
-au1xxx_dbdma_start(u32 chanid)
+void au1xxx_dbdma_start(u32 chanid)
 {
 	chan_tab_t	*ctp;
 	au1x_dma_chan_t *cp;
@@ -773,8 +761,7 @@ au1xxx_dbdma_start(u32 chanid)
 }
 EXPORT_SYMBOL(au1xxx_dbdma_start);
 
-void
-au1xxx_dbdma_reset(u32 chanid)
+void au1xxx_dbdma_reset(u32 chanid)
 {
 	chan_tab_t		*ctp;
 	au1x_ddma_desc_t	*dp;
@@ -784,14 +771,14 @@ au1xxx_dbdma_reset(u32 chanid)
 	ctp = *((chan_tab_t **)chanid);
 	ctp->get_ptr = ctp->put_ptr = ctp->cur_ptr = ctp->chan_desc_base;
 
-	/* Run through the descriptors and reset the valid indicator.
-	*/
+	/* Run through the descriptors and reset the valid indicator. */
 	dp = ctp->chan_desc_base;
 
 	do {
 		dp->dscr_cmd0 &= ~DSCR_CMD0_V;
-		/* reset our SW status -- this is used to determine
-		 * if a descriptor is in use by upper level SW. Since
+		/*
+		 * Reset our software status -- this is used to determine
+		 * if a descriptor is in use by upper level software. Since
 		 * posting can reset 'V' bit.
 		 */
 		dp->sw_status = 0;
@@ -800,8 +787,7 @@ au1xxx_dbdma_reset(u32 chanid)
 }
 EXPORT_SYMBOL(au1xxx_dbdma_reset);
 
-u32
-au1xxx_get_dma_residue(u32 chanid)
+u32 au1xxx_get_dma_residue(u32 chanid)
 {
 	chan_tab_t	*ctp;
 	au1x_dma_chan_t *cp;
@@ -810,18 +796,15 @@ au1xxx_get_dma_residue(u32 chanid)
 	ctp = *((chan_tab_t **)chanid);
 	cp = ctp->chan_ptr;
 
-	/* This is only valid if the channel is stopped.
-	*/
+	/* This is only valid if the channel is stopped. */
 	rv = cp->ddma_bytecnt;
 	au_sync();
 
 	return rv;
 }
-
 EXPORT_SYMBOL_GPL(au1xxx_get_dma_residue);
 
-void
-au1xxx_dbdma_chan_free(u32 chanid)
+void au1xxx_dbdma_chan_free(u32 chanid)
 {
 	chan_tab_t	*ctp;
 	dbdev_tab_t	*stp, *dtp;
@@ -842,8 +825,7 @@ au1xxx_dbdma_chan_free(u32 chanid)
 }
 EXPORT_SYMBOL(au1xxx_dbdma_chan_free);
 
-static irqreturn_t
-dbdma_interrupt(int irq, void *dev_id)
+static irqreturn_t dbdma_interrupt(int irq, void *dev_id)
 {
 	u32 intstat;
 	u32 chan_index;
@@ -859,13 +841,12 @@ dbdma_interrupt(int irq, void *dev_id)
 	cp = ctp->chan_ptr;
 	dp = ctp->cur_ptr;
 
-	/* Reset interrupt.
-	*/
+	/* Reset interrupt. */
 	cp->ddma_irq = 0;
 	au_sync();
 
 	if (ctp->chan_callback)
-		(ctp->chan_callback)(irq, ctp->chan_callparam);
+		ctp->chan_callback(irq, ctp->chan_callparam);
 
 	ctp->cur_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	return IRQ_RETVAL(1);
@@ -890,47 +871,47 @@ static void au1xxx_dbdma_init(void)
 
 	if (request_irq(irq_nr, dbdma_interrupt, IRQF_DISABLED,
 			"Au1xxx dbdma", (void *)dbdma_gptr))
-		printk("Can't get 1550 dbdma irq");
+		printk(KERN_ERR "Can't get 1550 dbdma irq");
 }
 
-void
-au1xxx_dbdma_dump(u32 chanid)
+void au1xxx_dbdma_dump(u32 chanid)
 {
-	chan_tab_t		*ctp;
-	au1x_ddma_desc_t	*dp;
-	dbdev_tab_t		*stp, *dtp;
-	au1x_dma_chan_t *cp;
-		u32			i = 0;
+	chan_tab_t	 *ctp;
+	au1x_ddma_desc_t *dp;
+	dbdev_tab_t	 *stp, *dtp;
+	au1x_dma_chan_t  *cp;
+	u32 i		 = 0;
 
 	ctp = *((chan_tab_t **)chanid);
 	stp = ctp->chan_src;
 	dtp = ctp->chan_dest;
 	cp = ctp->chan_ptr;
 
-	printk("Chan %x, stp %x (dev %d)  dtp %x (dev %d) \n",
-		(u32)ctp, (u32)stp, stp - dbdev_tab, (u32)dtp, dtp - dbdev_tab);
-	printk("desc base %x, get %x, put %x, cur %x\n",
-		(u32)(ctp->chan_desc_base), (u32)(ctp->get_ptr),
-		(u32)(ctp->put_ptr), (u32)(ctp->cur_ptr));
-
-	printk("dbdma chan %x\n", (u32)cp);
-	printk("cfg %08x, desptr %08x, statptr %08x\n",
-		cp->ddma_cfg, cp->ddma_desptr, cp->ddma_statptr);
-	printk("dbell %08x, irq %08x, stat %08x, bytecnt %08x\n",
-		cp->ddma_dbell, cp->ddma_irq, cp->ddma_stat, cp->ddma_bytecnt);
-
-
-	/* Run through the descriptors
-	*/
+	printk(KERN_DEBUG "Chan %x, stp %x (dev %d)  dtp %x (dev %d) \n",
+			  (u32)ctp, (u32)stp, stp - dbdev_tab, (u32)dtp,
+			  dtp - dbdev_tab);
+	printk(KERN_DEBUG "desc base %x, get %x, put %x, cur %x\n",
+			  (u32)(ctp->chan_desc_base), (u32)(ctp->get_ptr),
+			  (u32)(ctp->put_ptr), (u32)(ctp->cur_ptr));
+
+	printk(KERN_DEBUG "dbdma chan %x\n", (u32)cp);
+	printk(KERN_DEBUG "cfg %08x, desptr %08x, statptr %08x\n",
+			  cp->ddma_cfg, cp->ddma_desptr, cp->ddma_statptr);
+	printk(KERN_DEBUG "dbell %08x, irq %08x, stat %08x, bytecnt %08x\n",
+			  cp->ddma_dbell, cp->ddma_irq, cp->ddma_stat,
+			  cp->ddma_bytecnt);
+
+	/* Run through the descriptors */
 	dp = ctp->chan_desc_base;
 
 	do {
-                printk("Dp[%d]= %08x, cmd0 %08x, cmd1 %08x\n",
-                        i++, (u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
-                printk("src0 %08x, src1 %08x, dest0 %08x, dest1 %08x\n",
-                        dp->dscr_source0, dp->dscr_source1, dp->dscr_dest0, dp->dscr_dest1);
-                printk("stat %08x, nxtptr %08x\n",
-                        dp->dscr_stat, dp->dscr_nxtptr);
+		printk(KERN_DEBUG "Dp[%d]= %08x, cmd0 %08x, cmd1 %08x\n",
+				  i++, (u32)dp, dp->dscr_cmd0, dp->dscr_cmd1);
+		printk(KERN_DEBUG "src0 %08x, src1 %08x, dest0 %08x, dest1 %08x\n",
+				  dp->dscr_source0, dp->dscr_source1,
+				  dp->dscr_dest0, dp->dscr_dest1);
+		printk(KERN_DEBUG "stat %08x, nxtptr %08x\n",
+				  dp->dscr_stat, dp->dscr_nxtptr);
 		dp = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 	} while (dp != ctp->chan_desc_base);
 }
@@ -938,32 +919,33 @@ au1xxx_dbdma_dump(u32 chanid)
 /* Put a descriptor into the DMA ring.
  * This updates the source/destination pointers and byte count.
  */
-u32
-au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr )
+u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr)
 {
 	chan_tab_t *ctp;
 	au1x_ddma_desc_t *dp;
-	u32 nbytes=0;
+	u32 nbytes = 0;
 
-	/* I guess we could check this to be within the
-	* range of the table......
-	*/
+	/*
+	 * I guess we could check this to be within the
+	 * range of the table......
+	 */
 	ctp = *((chan_tab_t **)chanid);
 
-	/* We should have multiple callers for a particular channel,
-	* an interrupt doesn't affect this pointer nor the descriptor,
-	* so no locking should be needed.
-	*/
+	/*
+	 * We should have multiple callers for a particular channel,
+	 * an interrupt doesn't affect this pointer nor the descriptor,
+	 * so no locking should be needed.
+	 */
 	dp = ctp->put_ptr;
 
-	/* If the descriptor is valid, we are way ahead of the DMA
-	* engine, so just return an error condition.
-	*/
+	/*
+	 * If the descriptor is valid, we are way ahead of the DMA
+	 * engine, so just return an error condition.
+	 */
 	if (dp->dscr_cmd0 & DSCR_CMD0_V)
 		return 0;
 
-	/* Load up buffer addresses and byte count.
-	*/
+	/* Load up buffer addresses and byte count. */
 	dp->dscr_dest0 = dscr->dscr_dest0;
 	dp->dscr_source0 = dscr->dscr_source0;
 	dp->dscr_dest1 = dscr->dscr_dest1;
@@ -975,14 +957,11 @@ au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr )
 	dp->dscr_cmd0 |= dscr->dscr_cmd0 | DSCR_CMD0_V;
 	ctp->chan_ptr->ddma_dbell = 0;
 
-	/* Get next descriptor pointer.
-	*/
+	/* Get next descriptor pointer.	*/
 	ctp->put_ptr = phys_to_virt(DSCR_GET_NXTPTR(dp->dscr_nxtptr));
 
-	/* return something not zero.
-	*/
+	/* Return something non-zero. */
 	return nbytes;
 }
 
 #endif /* defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200) */
-
diff --git a/arch/mips/au1000/common/dbg_io.c b/arch/mips/au1000/common/dbg_io.c
index eae1bb2..af5be7d 100644
--- a/arch/mips/au1000/common/dbg_io.c
+++ b/arch/mips/au1000/common/dbg_io.c
@@ -1,3 +1,4 @@
+#include <linux/types.h>
 
 #include <asm/mach-au1x00/au1000.h>
 
@@ -8,12 +9,6 @@
  * uart to be used for debugging.
  */
 #define DEBUG_BASE  UART_DEBUG_BASE
-/**/
-
-/* we need uint32 uint8 */
-/* #include "types.h" */
-typedef         unsigned char uint8;
-typedef         unsigned int  uint32;
 
 #define         UART16550_BAUD_2400             2400
 #define         UART16550_BAUD_4800             4800
@@ -51,17 +46,15 @@ typedef         unsigned int  uint32;
 #define UART_MOD_CNTRL	0x100	/* Module Control */
 
 /* memory-mapped read/write of the port */
-#define UART16550_READ(y)    (au_readl(DEBUG_BASE + y) & 0xff)
-#define UART16550_WRITE(y, z) (au_writel(z&0xff, DEBUG_BASE + y))
+#define UART16550_READ(y)     (au_readl(DEBUG_BASE + y) & 0xff)
+#define UART16550_WRITE(y, z) (au_writel(z & 0xff, DEBUG_BASE + y))
 
 extern unsigned long calc_clock(void);
 
-void debugInit(uint32 baud, uint8 data, uint8 parity, uint8 stop)
+void debugInit(u32 baud, u8 data, u8 parity, u8 stop)
 {
-
-	if (UART16550_READ(UART_MOD_CNTRL) != 0x3) {
+	if (UART16550_READ(UART_MOD_CNTRL) != 0x3)
 		UART16550_WRITE(UART_MOD_CNTRL, 3);
-	}
 	calc_clock();
 
 	/* disable interrupts */
@@ -69,7 +62,7 @@ void debugInit(uint32 baud, uint8 data, uint8 parity, uint8 stop)
 
 	/* set up baud rate */
 	{
-		uint32 divisor;
+		u32 divisor;
 
 		/* set divisor */
 		divisor = get_au1x00_uart_baud_base() / baud;
@@ -80,9 +73,9 @@ void debugInit(uint32 baud, uint8 data, uint8 parity, uint8 stop)
 	UART16550_WRITE(UART_LCR, (data | parity | stop));
 }
 
-static int remoteDebugInitialized = 0;
+static int remoteDebugInitialized;
 
-uint8 getDebugChar(void)
+u8 getDebugChar(void)
 {
 	if (!remoteDebugInitialized) {
 		remoteDebugInitialized = 1;
@@ -92,15 +85,13 @@ uint8 getDebugChar(void)
 			  UART16550_STOP_1BIT);
 	}
 
-	while((UART16550_READ(UART_LSR) & 0x1) == 0);
+	while ((UART16550_READ(UART_LSR) & 0x1) == 0);
 	return UART16550_READ(UART_RX);
 }
 
 
-int putDebugChar(uint8 byte)
+int putDebugChar(u8 byte)
 {
-//	int i;
-
 	if (!remoteDebugInitialized) {
 		remoteDebugInitialized = 1;
 		debugInit(UART16550_BAUD_115200,
@@ -109,9 +100,8 @@ int putDebugChar(uint8 byte)
 			  UART16550_STOP_1BIT);
 	}
 
-	while ((UART16550_READ(UART_LSR)&0x40) == 0);
+	while ((UART16550_READ(UART_LSR) & 0x40) == 0);
 	UART16550_WRITE(UART_TX, byte);
-	//for (i=0;i<0xfff;i++);
 
 	return 1;
 }
diff --git a/arch/mips/au1000/common/dma.c b/arch/mips/au1000/common/dma.c
index 95f69ea..d6fbda2 100644
--- a/arch/mips/au1000/common/dma.c
+++ b/arch/mips/au1000/common/dma.c
@@ -1,12 +1,11 @@
 /*
  *
  * BRIEF MODULE DESCRIPTION
- *      A DMA channel allocator for Au1000. API is modeled loosely off of
+ *      A DMA channel allocator for Au1x00. API is modeled loosely off of
  *      linux/kernel/dma.c.
  *
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	stevel@mvista.com or source@mvista.com
+ * Copyright 2000, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute  it and/or modify it
@@ -39,7 +38,8 @@
 #include <asm/mach-au1x00/au1000.h>
 #include <asm/mach-au1x00/au1000_dma.h>
 
-#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
+#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || \
+    defined(CONFIG_SOC_AU1100)
 /*
  * A note on resource allocation:
  *
@@ -56,7 +56,6 @@
  * returned from request_dma.
  */
 
-
 DEFINE_SPINLOCK(au1000_dma_spin_lock);
 
 struct dma_chan au1000_dma_table[NUM_AU1000_DMA_CHANNELS] = {
@@ -71,7 +70,7 @@ struct dma_chan au1000_dma_table[NUM_AU1000_DMA_CHANNELS] = {
 };
 EXPORT_SYMBOL(au1000_dma_table);
 
-// Device FIFO addresses and default DMA modes
+/* Device FIFO addresses and default DMA modes */
 static const struct dma_dev {
 	unsigned int fifo_addr;
 	unsigned int dma_mode;
@@ -80,8 +79,8 @@ static const struct dma_dev {
 	{UART0_ADDR + UART_RX, 0},
 	{0, 0},
 	{0, 0},
-	{AC97C_DATA, DMA_DW16 },          // coherent
-	{AC97C_DATA, DMA_DR | DMA_DW16 }, // coherent
+	{AC97C_DATA, DMA_DW16 },          /* coherent */
+	{AC97C_DATA, DMA_DR | DMA_DW16 }, /* coherent */
 	{UART3_ADDR + UART_TX, DMA_DW8 | DMA_NC},
 	{UART3_ADDR + UART_RX, DMA_DR | DMA_DW8 | DMA_NC},
 	{USBD_EP0RD, DMA_DR | DMA_DW8 | DMA_NC},
@@ -101,10 +100,10 @@ int au1000_dma_read_proc(char *buf, char **start, off_t fpos,
 	struct dma_chan *chan;
 
 	for (i = 0; i < NUM_AU1000_DMA_CHANNELS; i++) {
-		if ((chan = get_dma_chan(i)) != NULL) {
+		chan = get_dma_chan(i);
+		if (chan != NULL)
 			len += sprintf(buf + len, "%2d: %s\n",
 				       i, chan->dev_str);
-		}
 	}
 
 	if (fpos >= len) {
@@ -113,18 +112,19 @@ int au1000_dma_read_proc(char *buf, char **start, off_t fpos,
 		return 0;
 	}
 	*start = buf + fpos;
-	if ((len -= fpos) > length)
+	len -= fpos;
+	if (len > length)
 		return length;
 	*eof = 1;
 	return len;
 }
 
-// Device FIFO addresses and default DMA modes - 2nd bank
+/* Device FIFO addresses and default DMA modes - 2nd bank */
 static const struct dma_dev dma_dev_table_bank2[DMA_NUM_DEV_BANK2] = {
-	{SD0_XMIT_FIFO, DMA_DS | DMA_DW8},		// coherent
-	{SD0_RECV_FIFO, DMA_DS | DMA_DR | DMA_DW8},	// coherent
-	{SD1_XMIT_FIFO, DMA_DS | DMA_DW8},		// coherent
-	{SD1_RECV_FIFO, DMA_DS | DMA_DR | DMA_DW8}	// coherent
+	{ SD0_XMIT_FIFO, DMA_DS | DMA_DW8 },		/* coherent */
+	{ SD0_RECV_FIFO, DMA_DS | DMA_DR | DMA_DW8 },	/* coherent */
+	{ SD1_XMIT_FIFO, DMA_DS | DMA_DW8 },		/* coherent */
+	{ SD1_RECV_FIFO, DMA_DS | DMA_DR | DMA_DW8 }	/* coherent */
 };
 
 void dump_au1000_dma_channel(unsigned int dmanr)
@@ -150,7 +150,6 @@ void dump_au1000_dma_channel(unsigned int dmanr)
 	       au_readl(chan->io + DMA_BUFFER1_COUNT));
 }
 
-
 /*
  * Finds a free channel, and binds the requested device to it.
  * Returns the allocated channel number, or negative on error.
@@ -169,14 +168,14 @@ int request_au1000_dma(int dev_id, const char *dev_str,
 	if (dev_id < 0 || dev_id >= (DMA_NUM_DEV + DMA_NUM_DEV_BANK2))
 		return -EINVAL;
 #else
- 	if (dev_id < 0 || dev_id >= DMA_NUM_DEV)
+	if (dev_id < 0 || dev_id >= DMA_NUM_DEV)
 		return -EINVAL;
 #endif
 
-	for (i = 0; i < NUM_AU1000_DMA_CHANNELS; i++) {
+	for (i = 0; i < NUM_AU1000_DMA_CHANNELS; i++)
 		if (au1000_dma_table[i].dev_id < 0)
 			break;
-	}
+
 	if (i == NUM_AU1000_DMA_CHANNELS)
 		return -ENODEV;
 
@@ -185,15 +184,15 @@ int request_au1000_dma(int dev_id, const char *dev_str,
 	if (dev_id >= DMA_NUM_DEV) {
 		dev_id -= DMA_NUM_DEV;
 		dev = &dma_dev_table_bank2[dev_id];
-	} else {
+	} else
 		dev = &dma_dev_table[dev_id];
-	}
 
 	if (irqhandler) {
 		chan->irq = AU1000_DMA_INT_BASE + i;
 		chan->irq_dev = irq_dev_id;
-		if ((ret = request_irq(chan->irq, irqhandler, irqflags,
-				       dev_str, chan->irq_dev))) {
+		ret = request_irq(chan->irq, irqhandler, irqflags, dev_str,
+				  chan->irq_dev);
+		if (ret) {
 			chan->irq = 0;
 			chan->irq_dev = NULL;
 			return ret;
@@ -203,7 +202,7 @@ int request_au1000_dma(int dev_id, const char *dev_str,
 		chan->irq_dev = NULL;
 	}
 
-	// fill it in
+	/* fill it in */
 	chan->io = DMA_CHANNEL_BASE + i * DMA_CHANNEL_LEN;
 	chan->dev_id = dev_id;
 	chan->dev_str = dev_str;
@@ -220,8 +219,9 @@ EXPORT_SYMBOL(request_au1000_dma);
 void free_au1000_dma(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan) {
-		printk("Trying to free DMA%d\n", dmanr);
+		printk(KERN_ERR "Error trying to free DMA%d\n", dmanr);
 		return;
 	}
 
@@ -235,4 +235,4 @@ void free_au1000_dma(unsigned int dmanr)
 }
 EXPORT_SYMBOL(free_au1000_dma);
 
-#endif // AU1000 AU1500 AU1100
+#endif /* AU1000 AU1500 AU1100 */
diff --git a/arch/mips/au1000/common/gpio.c b/arch/mips/au1000/common/gpio.c
index 5254525..b485d94 100644
--- a/arch/mips/au1000/common/gpio.c
+++ b/arch/mips/au1000/common/gpio.c
@@ -69,7 +69,7 @@ static int au1xxx_gpio2_direction_output(unsigned gpio, int value)
 
 static int au1xxx_gpio1_read(unsigned gpio)
 {
-	return ((gpio1->pinstaterd >> gpio) & 0x01);
+	return (gpio1->pinstaterd >> gpio) & 0x01;
 }
 
 static void au1xxx_gpio1_write(unsigned gpio, int value)
@@ -104,7 +104,6 @@ int au1xxx_gpio_get_value(unsigned gpio)
 	else
 		return au1xxx_gpio1_read(gpio);
 }
-
 EXPORT_SYMBOL(au1xxx_gpio_get_value);
 
 void au1xxx_gpio_set_value(unsigned gpio, int value)
@@ -118,7 +117,6 @@ void au1xxx_gpio_set_value(unsigned gpio, int value)
 	else
 		au1xxx_gpio1_write(gpio, value);
 }
-
 EXPORT_SYMBOL(au1xxx_gpio_set_value);
 
 int au1xxx_gpio_direction_input(unsigned gpio)
@@ -132,7 +130,6 @@ int au1xxx_gpio_direction_input(unsigned gpio)
 
 	return au1xxx_gpio1_direction_input(gpio);
 }
-
 EXPORT_SYMBOL(au1xxx_gpio_direction_input);
 
 int au1xxx_gpio_direction_output(unsigned gpio, int value)
@@ -146,5 +143,4 @@ int au1xxx_gpio_direction_output(unsigned gpio, int value)
 
 	return au1xxx_gpio1_direction_output(gpio, value);
 }
-
 EXPORT_SYMBOL(au1xxx_gpio_direction_output);
diff --git a/arch/mips/au1000/common/irq.c b/arch/mips/au1000/common/irq.c
index f062699..40c6cec 100644
--- a/arch/mips/au1000/common/irq.c
+++ b/arch/mips/au1000/common/irq.c
@@ -210,10 +210,8 @@ static inline void mask_and_ack_either_edge_irq(unsigned int irq_nr)
 	au_sync();
 }
 
-
 static inline void mask_and_ack_level_irq(unsigned int irq_nr)
 {
-
 	local_disable_irq(irq_nr);
 	au_sync();
 #if defined(CONFIG_MIPS_PB1000)
@@ -263,14 +261,14 @@ void restore_local_and_enable(int controller, unsigned long mask)
 	unsigned long flags, new_mask;
 
 	spin_lock_irqsave(&irq_lock, flags);
-	for (i = 0; i < 32; i++) {
+	for (i = 0; i < 32; i++)
 		if (mask & (1 << i)) {
 			if (controller)
 				local_enable_irq(i + 32);
 			else
 				local_enable_irq(i);
 		}
-	}
+
 	if (controller)
 		new_mask = au_readl(IC1_MASKSET);
 	else
diff --git a/arch/mips/au1000/common/pci.c b/arch/mips/au1000/common/pci.c
index 7e966b3..7866cf5 100644
--- a/arch/mips/au1000/common/pci.c
+++ b/arch/mips/au1000/common/pci.c
@@ -2,9 +2,8 @@
  * BRIEF MODULE DESCRIPTION
  *	Alchemy/AMD Au1x00 PCI support.
  *
- * Copyright 2001-2003, 2007 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001-2003, 2007-2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
@@ -86,9 +85,9 @@ static int __init au1x_pci_setup(void)
 		u32 prid = read_c0_prid();
 
 		if ((prid & 0xFF000000) == 0x01000000 && prid < 0x01030202) {
-		       au_writel((1 << 16) | au_readl(Au1500_PCI_CFG),
-			         Au1500_PCI_CFG);
-		       printk("Non-coherent PCI accesses enabled\n");
+			au_writel((1 << 16) | au_readl(Au1500_PCI_CFG),
+				  Au1500_PCI_CFG);
+			printk(KERN_INFO "Non-coherent PCI accesses enabled\n");
 		}
 	}
 #endif
diff --git a/arch/mips/au1000/common/platform.c b/arch/mips/au1000/common/platform.c
index 31d2a22..8cae775 100644
--- a/arch/mips/au1000/common/platform.c
+++ b/arch/mips/au1000/common/platform.c
@@ -269,8 +269,8 @@ static struct platform_device au1x00_pcmcia_device = {
 #ifdef SMBUS_PSC_BASE
 static struct resource pbdb_smbus_resources[] = {
 	{
-		.start	= SMBUS_PSC_BASE,
-		.end	= SMBUS_PSC_BASE + 0x24 - 1,
+		.start	= CPHYSADDR(SMBUS_PSC_BASE),
+		.end	= CPHYSADDR(SMBUS_PSC_BASE + 0xfffff),
 		.flags	= IORESOURCE_MEM,
 	},
 };
@@ -302,16 +302,17 @@ static struct platform_device *au1xxx_platform_devices[] __initdata = {
 #endif
 };
 
-int __init au1xxx_platform_init(void)
+static int __init au1xxx_platform_init(void)
 {
 	unsigned int uartclk = get_au1x00_uart_baud_base() * 16;
 	int i;
 
 	/* Fill up uartclk. */
-	for (i = 0; au1x00_uart_data[i].flags ; i++)
+	for (i = 0; au1x00_uart_data[i].flags; i++)
 		au1x00_uart_data[i].uartclk = uartclk;
 
-	return platform_add_devices(au1xxx_platform_devices, ARRAY_SIZE(au1xxx_platform_devices));
+	return platform_add_devices(au1xxx_platform_devices,
+				    ARRAY_SIZE(au1xxx_platform_devices));
 }
 
 arch_initcall(au1xxx_platform_init);
diff --git a/arch/mips/au1000/common/power.c b/arch/mips/au1000/common/power.c
index a8cd2c1..2166b9e 100644
--- a/arch/mips/au1000/common/power.c
+++ b/arch/mips/au1000/common/power.c
@@ -1,10 +1,9 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	Au1000 Power Management routines.
+ *	Au1xx0 Power Management routines.
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *		ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  Some of the routines are right out of init/main.c, whose
  *  copyrights apply here.
@@ -43,10 +42,10 @@
 #ifdef CONFIG_PM
 
 #define DEBUG 1
-#ifdef DEBUG
-#  define DPRINTK(fmt, args...)	printk("%s: " fmt, __func__, ## args)
+#ifdef	DEBUG
+#define DPRINTK(fmt, args...)	printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
 #else
-#  define DPRINTK(fmt, args...)
+#define DPRINTK(fmt, args...)
 #endif
 
 static void au1000_calibrate_delay(void);
@@ -57,7 +56,8 @@ extern void local_enable_irq(unsigned int irq_nr);
 
 static DEFINE_SPINLOCK(pm_lock);
 
-/* We need to save/restore a bunch of core registers that are
+/*
+ * We need to save/restore a bunch of core registers that are
  * either volatile or reset to some state across a processor sleep.
  * If reading a register doesn't provide a proper result for a
  * later restore, we have to provide a function for loading that
@@ -78,24 +78,25 @@ static unsigned int	sleep_usbhost_enable;
 static unsigned int	sleep_usbdev_enable;
 static unsigned int	sleep_static_memctlr[4][3];
 
-/* Define this to cause the value you write to /proc/sys/pm/sleep to
+/*
+ * Define this to cause the value you write to /proc/sys/pm/sleep to
  * set the TOY timer for the amount of time you want to sleep.
  * This is done mainly for testing, but may be useful in other cases.
  * The value is number of 32KHz ticks to sleep.
  */
 #define SLEEP_TEST_TIMEOUT 1
-#ifdef SLEEP_TEST_TIMEOUT
-static	int	sleep_ticks;
+#ifdef	SLEEP_TEST_TIMEOUT
+static int sleep_ticks;
 void wakeup_counter0_set(int ticks);
 #endif
 
-static void
-save_core_regs(void)
+static void save_core_regs(void)
 {
 	extern void save_au1xxx_intctl(void);
 	extern void pm_eth0_shutdown(void);
 
-	/* Do the serial ports.....these really should be a pm_*
+	/*
+	 * Do the serial ports.....these really should be a pm_*
 	 * registered function by the driver......but of course the
 	 * standard serial driver doesn't understand our Au1xxx
 	 * unique registers.
@@ -106,27 +107,24 @@ save_core_regs(void)
 	sleep_uart0_clkdiv = au_readl(UART0_ADDR + UART_CLK);
 	sleep_uart0_enable = au_readl(UART0_ADDR + UART_MOD_CNTRL);
 
-	/* Shutdown USB host/device.
-	*/
+	/* Shutdown USB host/device. */
 	sleep_usbhost_enable = au_readl(USB_HOST_CONFIG);
 
-	/* There appears to be some undocumented reset register....
-	*/
+	/* There appears to be some undocumented reset register.... */
 	au_writel(0, 0xb0100004); au_sync();
 	au_writel(0, USB_HOST_CONFIG); au_sync();
 
 	sleep_usbdev_enable = au_readl(USBD_ENABLE);
 	au_writel(0, USBD_ENABLE); au_sync();
 
-	/* Save interrupt controller state.
-	*/
+	/* Save interrupt controller state. */
 	save_au1xxx_intctl();
 
-	/* Clocks and PLLs.
-	*/
+	/* Clocks and PLLs. */
 	sleep_aux_pll_cntrl = au_readl(SYS_AUXPLL);
 
-	/* We don't really need to do this one, but unless we
+	/*
+	 * We don't really need to do this one, but unless we
 	 * write it again it won't have a valid value if we
 	 * happen to read it.
 	 */
@@ -134,8 +132,7 @@ save_core_regs(void)
 
 	sleep_pin_function = au_readl(SYS_PINFUNC);
 
-	/* Save the static memory controller configuration.
-	*/
+	/* Save the static memory controller configuration. */
 	sleep_static_memctlr[0][0] = au_readl(MEM_STCFG0);
 	sleep_static_memctlr[0][1] = au_readl(MEM_STTIME0);
 	sleep_static_memctlr[0][2] = au_readl(MEM_STADDR0);
@@ -150,8 +147,7 @@ save_core_regs(void)
 	sleep_static_memctlr[3][2] = au_readl(MEM_STADDR3);
 }
 
-static void
-restore_core_regs(void)
+static void restore_core_regs(void)
 {
 	extern void restore_au1xxx_intctl(void);
 	extern void wakeup_counter0_adjust(void);
@@ -160,8 +156,7 @@ restore_core_regs(void)
 	au_writel(sleep_cpu_pll_cntrl, SYS_CPUPLL); au_sync();
 	au_writel(sleep_pin_function, SYS_PINFUNC); au_sync();
 
-	/* Restore the static memory controller configuration.
-	*/
+	/* Restore the static memory controller configuration. */
 	au_writel(sleep_static_memctlr[0][0], MEM_STCFG0);
 	au_writel(sleep_static_memctlr[0][1], MEM_STTIME0);
 	au_writel(sleep_static_memctlr[0][2], MEM_STADDR0);
@@ -175,7 +170,8 @@ restore_core_regs(void)
 	au_writel(sleep_static_memctlr[3][1], MEM_STTIME3);
 	au_writel(sleep_static_memctlr[3][2], MEM_STADDR3);
 
-	/* Enable the UART if it was enabled before sleep.
+	/*
+	 * Enable the UART if it was enabled before sleep.
 	 * I guess I should define module control bits........
 	 */
 	if (sleep_uart0_enable & 0x02) {
@@ -202,7 +198,7 @@ void wakeup_from_suspend(void)
 int au_sleep(void)
 {
 	unsigned long wakeup, flags;
-	extern	void	save_and_sleep(void);
+	extern void save_and_sleep(void);
 
 	spin_lock_irqsave(&pm_lock, flags);
 
@@ -210,23 +206,22 @@ int au_sleep(void)
 
 	flush_cache_all();
 
-	/** The code below is all system dependent and we should probably
+	/**
+	 ** The code below is all system dependent and we should probably
 	 ** have a function call out of here to set this up.  You need
 	 ** to configure the GPIO or timer interrupts that will bring
 	 ** you out of sleep.
 	 ** For testing, the TOY counter wakeup is useful.
 	 **/
-
 #if 0
 	au_writel(au_readl(SYS_PINSTATERD) & ~(1 << 11), SYS_PINSTATERD);
 
-	/* gpio 6 can cause a wake up event */
+	/* GPIO 6 can cause a wake up event */
 	wakeup = au_readl(SYS_WAKEMSK);
 	wakeup &= ~(1 << 8);	/* turn off match20 wakeup */
-	wakeup |= 1 << 6;	/* turn on gpio 6 wakeup   */
+	wakeup |= 1 << 6;	/* turn on  GPIO  6 wakeup */
 #else
-	/* For testing, allow match20 to wake us up.
-	*/
+	/* For testing, allow match20 to wake us up. */
 #ifdef SLEEP_TEST_TIMEOUT
 	wakeup_counter0_set(sleep_ticks);
 #endif
@@ -240,7 +235,8 @@ int au_sleep(void)
 
 	save_and_sleep();
 
-	/* after a wakeup, the cpu vectors back to 0x1fc00000 so
+	/*
+	 * After a wakeup, the cpu vectors back to 0x1fc00000, so
 	 * it's up to the boot code to get us back here.
 	 */
 	restore_core_regs();
@@ -248,24 +244,22 @@ int au_sleep(void)
 	return 0;
 }
 
-static int pm_do_sleep(ctl_table * ctl, int write, struct file *file,
-		       void __user *buffer, size_t * len, loff_t *ppos)
+static int pm_do_sleep(ctl_table *ctl, int write, struct file *file,
+		       void __user *buffer, size_t *len, loff_t *ppos)
 {
 #ifdef SLEEP_TEST_TIMEOUT
 #define TMPBUFLEN2 16
 	char buf[TMPBUFLEN2], *p;
 #endif
 
-	if (!write) {
+	if (!write)
 		*len = 0;
-	} else {
+	else {
 #ifdef SLEEP_TEST_TIMEOUT
-		if (*len > TMPBUFLEN2 - 1) {
+		if (*len > TMPBUFLEN2 - 1)
 			return -EFAULT;
-		}
-		if (copy_from_user(buf, buffer, *len)) {
+		if (copy_from_user(buf, buffer, *len))
 			return -EFAULT;
-		}
 		buf[*len] = 0;
 		p = buf;
 		sleep_ticks = simple_strtoul(p, &p, 0);
@@ -276,8 +270,8 @@ static int pm_do_sleep(ctl_table * ctl, int write, struct file *file,
 	return 0;
 }
 
-static int pm_do_freq(ctl_table * ctl, int write, struct file *file,
-		      void __user *buffer, size_t * len, loff_t *ppos)
+static int pm_do_freq(ctl_table *ctl, int write, struct file *file,
+		      void __user *buffer, size_t *len, loff_t *ppos)
 {
 	int retval = 0, i;
 	unsigned long val, pll;
@@ -285,14 +279,14 @@ static int pm_do_freq(ctl_table * ctl, int write, struct file *file,
 #define MAX_CPU_FREQ 396
 	char buf[TMPBUFLEN], *p;
 	unsigned long flags, intc0_mask, intc1_mask;
-	unsigned long old_baud_base, old_cpu_freq, baud_rate, old_clk,
-	    old_refresh;
+	unsigned long old_baud_base, old_cpu_freq, old_clk, old_refresh;
 	unsigned long new_baud_base, new_cpu_freq, new_clk, new_refresh;
+	unsigned long baud_rate;
 
 	spin_lock_irqsave(&pm_lock, flags);
-	if (!write) {
+	if (!write)
 		*len = 0;
-	} else {
+	else {
 		/* Parse the new frequency */
 		if (*len > TMPBUFLEN - 1) {
 			spin_unlock_irqrestore(&pm_lock, flags);
@@ -312,7 +306,7 @@ static int pm_do_freq(ctl_table * ctl, int write, struct file *file,
 
 		pll = val / 12;
 		if ((pll > 33) || (pll < 7)) {	/* 396 MHz max, 84 MHz min */
-			/* revisit this for higher speed cpus */
+			/* Revisit this for higher speed CPUs */
 			spin_unlock_irqrestore(&pm_lock, flags);
 			return -EFAULT;
 		}
@@ -321,30 +315,28 @@ static int pm_do_freq(ctl_table * ctl, int write, struct file *file,
 		old_cpu_freq = get_au1x00_speed();
 
 		new_cpu_freq = pll * 12 * 1000000;
-	        new_baud_base =  (new_cpu_freq / (2 * ((int)(au_readl(SYS_POWERCTRL)&0x03) + 2) * 16));
+	        new_baud_base = (new_cpu_freq / (2 * ((int)(au_readl(SYS_POWERCTRL)
+							    & 0x03) + 2) * 16));
 		set_au1x00_speed(new_cpu_freq);
 		set_au1x00_uart_baud_base(new_baud_base);
 
 		old_refresh = au_readl(MEM_SDREFCFG) & 0x1ffffff;
-		new_refresh =
-		    ((old_refresh * new_cpu_freq) /
-		     old_cpu_freq) | (au_readl(MEM_SDREFCFG) & ~0x1ffffff);
+		new_refresh = ((old_refresh * new_cpu_freq) / old_cpu_freq) |
+			      (au_readl(MEM_SDREFCFG) & ~0x1ffffff);
 
 		au_writel(pll, SYS_CPUPLL);
 		au_sync_delay(1);
 		au_writel(new_refresh, MEM_SDREFCFG);
 		au_sync_delay(1);
 
-		for (i = 0; i < 4; i++) {
-			if (au_readl
-			    (UART_BASE + UART_MOD_CNTRL +
-			     i * 0x00100000) == 3) {
-				old_clk =
-				    au_readl(UART_BASE + UART_CLK +
-					  i * 0x00100000);
-				// baud_rate = baud_base/clk
+		for (i = 0; i < 4; i++)
+			if (au_readl(UART_BASE + UART_MOD_CNTRL +
+				     i * 0x00100000) == 3) {
+				old_clk = au_readl(UART_BASE + UART_CLK +
+						   i * 0x00100000);
 				baud_rate = old_baud_base / old_clk;
-				/* we won't get an exact baud rate and the error
+				/*
+				 * We won't get an exact baud rate and the error
 				 * could be significant enough that our new
 				 * calculation will result in a clock that will
 				 * give us a baud rate that's too far off from
@@ -359,18 +351,14 @@ static int pm_do_freq(ctl_table * ctl, int write, struct file *file,
 				else if (baud_rate > 17000)
 					baud_rate = 19200;
 				else
-					(baud_rate = 9600);
-				// new_clk = new_baud_base/baud_rate
+					baud_rate = 9600;
 				new_clk = new_baud_base / baud_rate;
-				au_writel(new_clk,
-				       UART_BASE + UART_CLK +
-				       i * 0x00100000);
+				au_writel(new_clk, UART_BASE + UART_CLK +
+					  i * 0x00100000);
 				au_sync_delay(10);
 			}
-		}
 	}
 
-
 	/*
 	 * We don't want _any_ interrupts other than match20. Otherwise our
 	 * au1000_calibrate_delay() calculation will be off, potentially a lot.
@@ -428,14 +416,15 @@ static int __init pm_init(void)
 
 __initcall(pm_init);
 
-
 /*
  * This is right out of init/main.c
  */
 
-/* This is the number of bits of precision for the loops_per_jiffy.  Each
-   bit takes on average 1.5/HZ seconds.  This (like the original) is a little
-   better than 1% */
+/*
+ * This is the number of bits of precision for the loops_per_jiffy.
+ * Each bit takes on average 1.5/HZ seconds.  This (like the original)
+ * is a little better than 1%.
+ */
 #define LPS_PREC 8
 
 static void au1000_calibrate_delay(void)
@@ -443,14 +432,14 @@ static void au1000_calibrate_delay(void)
 	unsigned long ticks, loopbit;
 	int lps_precision = LPS_PREC;
 
-	loops_per_jiffy = (1 << 12);
+	loops_per_jiffy = 1 << 12;
 
 	while (loops_per_jiffy <<= 1) {
-		/* wait for "start of" clock tick */
+		/* Wait for "start of" clock tick */
 		ticks = jiffies;
 		while (ticks == jiffies)
 			/* nothing */ ;
-		/* Go .. */
+		/* Go ... */
 		ticks = jiffies;
 		__delay(loops_per_jiffy);
 		ticks = jiffies - ticks;
@@ -458,8 +447,10 @@ static void au1000_calibrate_delay(void)
 			break;
 	}
 
-/* Do a binary approximation to get loops_per_jiffy set to equal one clock
-   (up to lps_precision bits) */
+	/*
+	 * Do a binary approximation to get loops_per_jiffy set to be equal
+	 * one clock (up to lps_precision bits)
+	 */
 	loops_per_jiffy >>= 1;
 	loopbit = loops_per_jiffy;
 	while (lps_precision-- && (loopbit >>= 1)) {
@@ -472,4 +463,4 @@ static void au1000_calibrate_delay(void)
 			loops_per_jiffy &= ~loopbit;
 	}
 }
-#endif				/* CONFIG_PM */
+#endif	/* CONFIG_PM */
diff --git a/arch/mips/au1000/common/prom.c b/arch/mips/au1000/common/prom.c
index f10af82..18b310b 100644
--- a/arch/mips/au1000/common/prom.c
+++ b/arch/mips/au1000/common/prom.c
@@ -3,9 +3,8 @@
  * BRIEF MODULE DESCRIPTION
  *    PROM library initialisation code, supports YAMON and U-Boot.
  *
- * Copyright 2000, 2001, 2006 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2000-2001, 2006, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  * This file was derived from Carsten Langgaard's
  * arch/mips/mips-boards/xx files.
@@ -57,7 +56,7 @@ void prom_init_cmdline(void)
 	actr = 1; /* Always ignore argv[0] */
 
 	cp = &(arcs_cmdline[0]);
-	while(actr < prom_argc) {
+	while (actr < prom_argc) {
 		strcpy(cp, prom_argv[actr]);
 		cp += strlen(prom_argv[actr]);
 		*cp++ = ' ';
@@ -84,10 +83,8 @@ char *prom_getenv(char *envname)
 		if (yamon) {
 			if (strcmp(envname, *env++) == 0)
 				return *env;
-		} else {
-			if (strncmp(envname, *env, i) == 0 && (*env)[i] == '=')
-				return *env + i + 1;
-		}
+		} else if (strncmp(envname, *env, i) == 0 && (*env)[i] == '=')
+			return *env + i + 1;
 		env++;
 	}
 
@@ -110,13 +107,13 @@ static inline void str2eaddr(unsigned char *ea, unsigned char *str)
 {
 	int i;
 
-	for(i = 0; i < 6; i++) {
+	for (i = 0; i < 6; i++) {
 		unsigned char num;
 
-		if((*str == '.') || (*str == ':'))
+		if ((*str == '.') || (*str == ':'))
 			str++;
-		num = str2hexnum(*str++) << 4;
-		num |= (str2hexnum(*str++));
+		num  = str2hexnum(*str++) << 4;
+		num |= str2hexnum(*str++);
 		ea[i] = num;
 	}
 }
diff --git a/arch/mips/au1000/common/puts.c b/arch/mips/au1000/common/puts.c
index e34c67e..55bbe24 100644
--- a/arch/mips/au1000/common/puts.c
+++ b/arch/mips/au1000/common/puts.c
@@ -1,11 +1,10 @@
 /*
  *
  * BRIEF MODULE DESCRIPTION
- *	Low level uart routines to directly access a 16550 uart.
+ *	Low level UART routines to directly access Alchemy UART.
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -40,12 +39,12 @@
 
 static volatile unsigned long * const com1 = (unsigned long *)SERIAL_BASE;
 
-
 #ifdef SLOW_DOWN
 static inline void slow_down(void)
 {
-    int k;
-    for (k=0; k<10000; k++);
+	int k;
+
+	for (k = 0; k < 10000; k++);
 }
 #else
 #define slow_down()
@@ -54,16 +53,16 @@ static inline void slow_down(void)
 void
 prom_putchar(const unsigned char c)
 {
-    unsigned char ch;
-    int i = 0;
+	unsigned char ch;
+	int i = 0;
+
+	do {
+		ch = com1[SER_CMD];
+		slow_down();
+		i++;
+		if (i > TIMEOUT)
+			break;
+	} while (0 == (ch & TX_BUSY));
 
-    do {
-        ch = com1[SER_CMD];
-        slow_down();
-        i++;
-        if (i>TIMEOUT) {
-            break;
-        }
-    } while (0 == (ch & TX_BUSY));
-    com1[SER_DATA] = c;
+	com1[SER_DATA] = c;
 }
diff --git a/arch/mips/au1000/common/reset.c b/arch/mips/au1000/common/reset.c
index 60cec53..d555429 100644
--- a/arch/mips/au1000/common/reset.c
+++ b/arch/mips/au1000/common/reset.c
@@ -1,11 +1,10 @@
 /*
  *
  * BRIEF MODULE DESCRIPTION
- *	Au1000 reset routines.
+ *	Au1xx0 reset routines.
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2006, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -28,10 +27,11 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <asm/cacheflush.h>
+
 #include <asm/mach-au1x00/au1000.h>
 
 extern int au_sleep(void);
-extern void (*flush_cache_all)(void);
 
 void au1000_restart(char *command)
 {
@@ -40,8 +40,8 @@ void au1000_restart(char *command)
 	u32 prid = read_c0_prid();
 
 	printk(KERN_NOTICE "\n** Resetting Integrated Peripherals\n");
-	switch (prid & 0xFF000000)
-	{
+
+	switch (prid & 0xFF000000) {
 	case 0x00000000: /* Au1000 */
 		au_writel(0x02, 0xb0000010); /* ac97_enable */
 		au_writel(0x08, 0xb017fffc); /* usbh_enable - early errata */
@@ -138,9 +138,6 @@ void au1000_restart(char *command)
 		au_writel(0x00, 0xb1900064); /* sys_auxpll */
 		au_writel(0x00, 0xb1900100); /* sys_pininputen */
 		break;
-
-	default:
-		break;
 	}
 
 	set_c0_status(ST0_BEV | ST0_ERL);
@@ -158,25 +155,25 @@ void au1000_restart(char *command)
 void au1000_halt(void)
 {
 #if defined(CONFIG_MIPS_PB1550) || defined(CONFIG_MIPS_DB1550)
-	/* power off system */
-	printk("\n** Powering off...\n");
-	au_writew(au_readw(0xAF00001C) | (3<<14), 0xAF00001C);
+	/* Power off system */
+	printk(KERN_NOTICE "\n** Powering off...\n");
+	au_writew(au_readw(0xAF00001C) | (3 << 14), 0xAF00001C);
 	au_sync();
-	while(1); /* should not get here */
+	while (1); /* should not get here */
 #else
 	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
 #ifdef CONFIG_MIPS_MIRAGE
 	au_writel((1 << 26) | (1 << 10), GPIO2_OUTPUT);
 #endif
 #ifdef CONFIG_MIPS_DB1200
-	au_writew(au_readw(0xB980001C) | (1<<14), 0xB980001C);
+	au_writew(au_readw(0xB980001C) | (1 << 14), 0xB980001C);
 #endif
 #ifdef CONFIG_PM
 	au_sleep();
 
-	/* should not get here */
-	printk(KERN_ERR "Unable to put cpu in sleep mode\n");
-	while(1);
+	/* Should not get here */
+	printk(KERN_ERR "Unable to put CPU in sleep mode\n");
+	while (1);
 #else
 	while (1)
 		__asm__(".set\tmips3\n\t"
diff --git a/arch/mips/au1000/common/setup.c b/arch/mips/au1000/common/setup.c
index 0e86f7a..1ac6b06 100644
--- a/arch/mips/au1000/common/setup.c
+++ b/arch/mips/au1000/common/setup.c
@@ -1,7 +1,6 @@
 /*
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2000, 2007-2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com
  *
  * Updates to 2.6, Pete Popov, Embedded Alley Solutions, Inc.
  *
@@ -48,7 +47,7 @@ void __init plat_mem_setup(void)
 {
 	struct	cpu_spec *sp;
 	char *argptr;
-	unsigned long prid, cpufreq, bclk = 1;
+	unsigned long prid, cpufreq, bclk;
 
 	set_cpuspec();
 	sp = cur_cpu_spec[0];
@@ -66,42 +65,39 @@ void __init plat_mem_setup(void)
 		cpufreq = (au_readl(SYS_CPUPLL) & 0x3F) * 12;
 	printk(KERN_INFO "(PRID %08lx) @ %ld MHz\n", prid, cpufreq);
 
-	bclk = sp->cpu_bclk;
-	if (bclk)
-	{
+	if (sp->cpu_bclk) {
 		/* Enable BCLK switching */
-		bclk = au_readl(0xB190003C);
-		au_writel(bclk | 0x60, 0xB190003C);
-		printk("BCLK switching enabled!\n");
+		bclk = au_readl(SYS_POWERCTRL);
+		au_writel(bclk | 0x60, SYS_POWERCTRL);
+		printk(KERN_INFO "BCLK switching enabled!\n");
 	}
 
-	if (sp->cpu_od) {
-		/* Various early Au1000 Errata corrected by this */
-		set_c0_config(1<<19); /* Set Config[OD] */
-	}
-	else {
+	if (sp->cpu_od)
+		/* Various early Au1xx0 errata corrected by this */
+		set_c0_config(1 << 19); /* Set Config[OD] */
+	else
 		/* Clear to obtain best system bus performance */
-		clear_c0_config(1<<19); /* Clear Config[OD] */
-	}
+		clear_c0_config(1 << 19); /* Clear Config[OD] */
 
 	argptr = prom_getcmdline();
 
 #ifdef CONFIG_SERIAL_8250_CONSOLE
-	if ((argptr = strstr(argptr, "console=")) == NULL) {
+	argptr = strstr(argptr, "console=");
+	if (argptr == NULL) {
 		argptr = prom_getcmdline();
 		strcat(argptr, " console=ttyS0,115200");
 	}
 #endif
 
 #ifdef CONFIG_FB_AU1100
-    if ((argptr = strstr(argptr, "video=")) == NULL) {
-        argptr = prom_getcmdline();
-        /* default panel */
-        /*strcat(argptr, " video=au1100fb:panel:Sharp_320x240_16");*/
-    }
+	argptr = strstr(argptr, "video=");
+	if (argptr == NULL) {
+		argptr = prom_getcmdline();
+		/* default panel */
+		/*strcat(argptr, " video=au1100fb:panel:Sharp_320x240_16");*/
+	}
 #endif
 
-
 #if defined(CONFIG_SOUND_AU1X00) && !defined(CONFIG_SOC_AU1000)
 	/* au1000 does not support vra, au1500 and au1100 do */
 	strcat(argptr, " au1000_audio=vra");
@@ -129,7 +125,7 @@ void __init plat_mem_setup(void)
 /* This routine should be valid for all Au1x based boards */
 phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 {
-	/* Don't fixup 36 bit addresses */
+	/* Don't fixup 36-bit addresses */
 	if ((phys_addr >> 32) != 0)
 		return phys_addr;
 
@@ -145,17 +141,17 @@ phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 	}
 #endif
 
-	/* All Au1x SOCs have a pcmcia controller */
-	/* We setup our 32 bit pseudo addresses to be equal to the
-	 * 36 bit addr >> 4, to make it easier to check the address
+	/*
+	 * All Au1xx0 SOCs have a PCMCIA controller.
+	 * We setup our 32-bit pseudo addresses to be equal to the
+	 * 36-bit addr >> 4, to make it easier to check the address
 	 * and fix it.
-	 * The Au1x socket 0 phys attribute address is 0xF 4000 0000.
+	 * The PCMCIA socket 0 physical attribute address is 0xF 4000 0000.
 	 * The pseudo address we use is 0xF400 0000. Any address over
-	 * 0xF400 0000 is a pcmcia pseudo address.
+	 * 0xF400 0000 is a PCMCIA pseudo address.
 	 */
-	if ((phys_addr >= 0xF4000000) && (phys_addr < 0xFFFFFFFF)) {
+	if ((phys_addr >= 0xF4000000) && (phys_addr < 0xFFFFFFFF))
 		return (phys_t)(phys_addr << 4);
-	}
 
 	/* default nop */
 	return phys_addr;
diff --git a/arch/mips/au1000/common/time.c b/arch/mips/au1000/common/time.c
index bdb6d73..563d939 100644
--- a/arch/mips/au1000/common/time.c
+++ b/arch/mips/au1000/common/time.c
@@ -25,11 +25,9 @@
  *
  * Setting up the clock on the MIPS boards.
  *
- * Update.  Always configure the kernel with CONFIG_NEW_TIME_C.  This
- * will use the user interface gettimeofday() functions from the
- * arch/mips/kernel/time.c, and we provide the clock interrupt processing
- * and the timer offset compute functions.  If CONFIG_PM is selected,
- * we also ensure the 32KHz timer is available.   -- Dan
+ * We provide the clock interrupt processing and the timer offset compute
+ * functions.  If CONFIG_PM is selected, we also ensure the 32KHz timer is
+ * available.  -- Dan
  */
 
 #include <linux/types.h>
@@ -47,8 +45,7 @@ extern int allow_au1k_wait; /* default off for CP0 Counter */
 #if HZ < 100 || HZ > 1000
 #error "unsupported HZ value! Must be in [100,1000]"
 #endif
-#define MATCH20_INC (328*100/HZ) /* magic number 328 is for HZ=100... */
-extern void startup_match20_interrupt(irq_handler_t handler);
+#define MATCH20_INC (328 * 100 / HZ) /* magic number 328 is for HZ=100... */
 static unsigned long last_pc0, last_match20;
 #endif
 
@@ -61,7 +58,7 @@ static irqreturn_t counter0_irq(int irq, void *dev_id)
 {
 	unsigned long pc0;
 	int time_elapsed;
-	static int jiffie_drift = 0;
+	static int jiffie_drift;
 
 	if (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20) {
 		/* should never happen! */
@@ -70,13 +67,11 @@ static irqreturn_t counter0_irq(int irq, void *dev_id)
 	}
 
 	pc0 = au_readl(SYS_TOYREAD);
-	if (pc0 < last_match20) {
+	if (pc0 < last_match20)
 		/* counter overflowed */
 		time_elapsed = (0xffffffff - last_match20) + pc0;
-	}
-	else {
+	else
 		time_elapsed = pc0 - last_match20;
-	}
 
 	while (time_elapsed > 0) {
 		do_timer(1);
@@ -92,8 +87,9 @@ static irqreturn_t counter0_irq(int irq, void *dev_id)
 	au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
 	au_sync();
 
-	/* our counter ticks at 10.009765625 ms/tick, we we're running
-	 * almost 10uS too slow per tick.
+	/*
+	 * Our counter ticks at 10.009765625 ms/tick, we we're running
+	 * almost 10 uS too slow per tick.
 	 */
 
 	if (jiffie_drift >= 999) {
@@ -117,20 +113,17 @@ struct irqaction counter0_action = {
 /* When we wakeup from sleep, we have to "catch up" on all of the
  * timer ticks we have missed.
  */
-void
-wakeup_counter0_adjust(void)
+void wakeup_counter0_adjust(void)
 {
 	unsigned long pc0;
 	int time_elapsed;
 
 	pc0 = au_readl(SYS_TOYREAD);
-	if (pc0 < last_match20) {
+	if (pc0 < last_match20)
 		/* counter overflowed */
 		time_elapsed = (0xffffffff - last_match20) + pc0;
-	}
-	else {
+	else
 		time_elapsed = pc0 - last_match20;
-	}
 
 	while (time_elapsed > 0) {
 		time_elapsed -= MATCH20_INC;
@@ -143,10 +136,8 @@ wakeup_counter0_adjust(void)
 
 }
 
-/* This is just for debugging to set the timer for a sleep delay.
-*/
-void
-wakeup_counter0_set(int ticks)
+/* This is just for debugging to set the timer for a sleep delay. */
+void wakeup_counter0_set(int ticks)
 {
 	unsigned long pc0;
 
@@ -157,21 +148,22 @@ wakeup_counter0_set(int ticks)
 }
 #endif
 
-/* I haven't found anyone that doesn't use a 12 MHz source clock,
+/*
+ * I haven't found anyone that doesn't use a 12 MHz source clock,
  * but just in case.....
  */
 #define AU1000_SRC_CLK	12000000
 
 /*
  * We read the real processor speed from the PLL.  This is important
- * because it is more accurate than computing it from the 32KHz
+ * because it is more accurate than computing it from the 32 KHz
  * counter, if it exists.  If we don't have an accurate processor
  * speed, all of the peripherals that derive their clocks based on
  * this advertised speed will introduce error and sometimes not work
  * properly.  This function is futher convoluted to still allow configurations
  * to do that in case they have really, really old silicon with a
- * write-only PLL register, that we need the 32KHz when power management
- * "wait" is enabled, and we need to detect if the 32KHz isn't present
+ * write-only PLL register, that we need the 32 KHz when power management
+ * "wait" is enabled, and we need to detect if the 32 KHz isn't present
  * but requested......got it? :-)		-- Dan
  */
 unsigned long calc_clock(void)
@@ -182,8 +174,7 @@ unsigned long calc_clock(void)
 
 	spin_lock_irqsave(&time_lock, flags);
 
-	/* Power management cares if we don't have a 32KHz counter.
-	*/
+	/* Power management cares if we don't have a 32 KHz counter. */
 	no_au1xxx_32khz = 0;
 	counter = au_readl(SYS_COUNTER_CNTRL);
 	if (counter & SYS_CNTRL_E0) {
@@ -193,7 +184,7 @@ unsigned long calc_clock(void)
 
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T1S);
 		/* RTC now ticks at 32.768/16 kHz */
-		au_writel(trim_divide-1, SYS_RTCTRIM);
+		au_writel(trim_divide - 1, SYS_RTCTRIM);
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T1S);
 
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C1S);
@@ -215,9 +206,11 @@ unsigned long calc_clock(void)
 #endif
 	else
 		cpu_speed = (au_readl(SYS_CPUPLL) & 0x0000003f) * AU1000_SRC_CLK;
+	/* On Alchemy CPU:counter ratio is 1:1 */
 	mips_hpt_frequency = cpu_speed;
-	// Equation: Baudrate = CPU / (SD * 2 * CLKDIV * 16)
-	set_au1x00_uart_baud_base(cpu_speed / (2 * ((int)(au_readl(SYS_POWERCTRL)&0x03) + 2) * 16));
+	/* Equation: Baudrate = CPU / (SD * 2 * CLKDIV * 16) */
+	set_au1x00_uart_baud_base(cpu_speed / (2 * ((int)(au_readl(SYS_POWERCTRL)
+							  & 0x03) + 2) * 16));
 	spin_unlock_irqrestore(&time_lock, flags);
 	return cpu_speed;
 }
@@ -228,10 +221,10 @@ void __init plat_time_init(void)
 
 	est_freq += 5000;    /* round */
 	est_freq -= est_freq%10000;
-	printk("CPU frequency %d.%02d MHz\n", est_freq/1000000,
-	       (est_freq%1000000)*100/1000000);
- 	set_au1x00_speed(est_freq);
- 	set_au1x00_lcd_clock(); // program the LCD clock
+	printk(KERN_INFO "CPU frequency %u.%02u MHz\n",
+	       est_freq / 1000000, ((est_freq % 1000000) * 100) / 1000000);
+	set_au1x00_speed(est_freq);
+	set_au1x00_lcd_clock(); /* program the LCD clock */
 
 #ifdef CONFIG_PM
 	/*
@@ -243,30 +236,29 @@ void __init plat_time_init(void)
 	 * counter 0 interrupt as a special irq and it doesn't show
 	 * up under /proc/interrupts.
 	 *
-	 * Check to ensure we really have a 32KHz oscillator before
+	 * Check to ensure we really have a 32 KHz oscillator before
 	 * we do this.
 	 */
 	if (no_au1xxx_32khz)
-		printk("WARNING: no 32KHz clock found.\n");
+		printk(KERN_WARNING "WARNING: no 32KHz clock found.\n");
 	else {
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C0S);
 		au_writel(0, SYS_TOYWRITE);
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_C0S);
 
-		au_writel(au_readl(SYS_WAKEMSK) | (1<<8), SYS_WAKEMSK);
+		au_writel(au_readl(SYS_WAKEMSK) | (1 << 8), SYS_WAKEMSK);
 		au_writel(~0, SYS_WAKESRC);
 		au_sync();
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
 
-		/* setup match20 to interrupt once every HZ */
+		/* Setup match20 to interrupt once every HZ */
 		last_pc0 = last_match20 = au_readl(SYS_TOYREAD);
 		au_writel(last_match20 + MATCH20_INC, SYS_TOYMATCH2);
 		au_sync();
 		while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_M20);
 		setup_irq(AU1000_TOY_MATCH2_INT, &counter0_action);
 
-		/* We can use the real 'wait' instruction.
-		*/
+		/* We can use the real 'wait' instruction. */
 		allow_au1k_wait = 1;
 	}
 
diff --git a/arch/mips/au1000/db1x00/Makefile b/arch/mips/au1000/db1x00/Makefile
index 51d62bd..274db3b 100644
--- a/arch/mips/au1000/db1x00/Makefile
+++ b/arch/mips/au1000/db1x00/Makefile
@@ -1,8 +1,8 @@
 #
-#  Copyright 2000 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Copyright 2000, 2008 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc. <source@mvista.com>
+#
+# Makefile for the Alchemy Semiconductor DBAu1xx0 boards.
 #
-# Makefile for the Alchemy Semiconductor Db1x00 board.
 
 lib-y := init.o board_setup.o irqmap.o
diff --git a/arch/mips/au1000/db1x00/board_setup.c b/arch/mips/au1000/db1x00/board_setup.c
index b7dcbad..9e5ccbb 100644
--- a/arch/mips/au1000/db1x00/board_setup.c
+++ b/arch/mips/au1000/db1x00/board_setup.c
@@ -3,9 +3,8 @@
  * BRIEF MODULE DESCRIPTION
  *	Alchemy Db1x00 board setup.
  *
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2000, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -37,49 +36,49 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 
 void board_reset(void)
 {
-	/* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
+	/* Hit BCSR.SW_RESET[RESET] */
 	bcsr->swreset = 0x0000;
 }
 
 void __init board_setup(void)
 {
-	u32 pin_func;
+	u32 pin_func = 0;
 
-	pin_func = 0;
-	/* not valid for 1550 */
-
-#if defined(CONFIG_IRDA) && (defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1100))
-	/* set IRFIRSEL instead of GPIO15 */
-	pin_func = au_readl(SYS_PINFUNC) | (u32)((1<<8));
+	/* Not valid for Au1550 */
+#if defined(CONFIG_IRDA) && \
+   (defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1100))
+	/* Set IRFIRSEL instead of GPIO15 */
+	pin_func = au_readl(SYS_PINFUNC) | SYS_PF_IRF;
 	au_writel(pin_func, SYS_PINFUNC);
-	/* power off until the driver is in use */
+	/* Power off until the driver is in use */
 	bcsr->resets &= ~BCSR_RESETS_IRDA_MODE_MASK;
-	bcsr->resets |= BCSR_RESETS_IRDA_MODE_OFF;
+	bcsr->resets |=  BCSR_RESETS_IRDA_MODE_OFF;
 	au_sync();
 #endif
 	bcsr->pcmcia = 0x0000; /* turn off PCMCIA power */
 
 #ifdef CONFIG_MIPS_MIRAGE
-	/* enable GPIO[31:0] inputs */
+	/* Enable GPIO[31:0] inputs */
 	au_writel(0, SYS_PININPUTEN);
 
-	/* GPIO[20] is output, tristate the other input primary GPIO's */
-	au_writel((u32)(~(1<<20)), SYS_TRIOUTCLR);
+	/* GPIO[20] is output, tristate the other input primary GPIOs */
+	au_writel(~(1 << 20), SYS_TRIOUTCLR);
 
-	/* set GPIO[210:208] instead of SSI_0 */
-	pin_func = au_readl(SYS_PINFUNC) | (u32)(1);
+	/* Set GPIO[210:208] instead of SSI_0 */
+	pin_func = au_readl(SYS_PINFUNC) | SYS_PF_S0;
 
-	/* set GPIO[215:211] for LED's */
-	pin_func |= (u32)((5<<2));
+	/* Set GPIO[215:211] for LEDs */
+	pin_func |= 5 << 2;
 
-	/* set GPIO[214:213] for more LED's */
-	pin_func |= (u32)((5<<12));
+	/* Set GPIO[214:213] for more LEDs */
+	pin_func |= 5 << 12;
 
-	/* set GPIO[207:200] instead of PCMCIA/LCD */
-	pin_func |= (u32)((3<<17));
+	/* Set GPIO[207:200] instead of PCMCIA/LCD */
+	pin_func |= SYS_PF_LCD | SYS_PF_PC;
 	au_writel(pin_func, SYS_PINFUNC);
 
-	/* Enable speaker amplifier.  This should
+	/*
+	 * Enable speaker amplifier.  This should
 	 * be part of the audio driver.
 	 */
 	au_writel(au_readl(GPIO2_DIR) | 0x200, GPIO2_DIR);
@@ -89,21 +88,21 @@ void __init board_setup(void)
 	au_sync();
 
 #ifdef CONFIG_MIPS_DB1000
-    printk("AMD Alchemy Au1000/Db1000 Board\n");
+	printk(KERN_INFO "AMD Alchemy Au1000/Db1000 Board\n");
 #endif
 #ifdef CONFIG_MIPS_DB1500
-    printk("AMD Alchemy Au1500/Db1500 Board\n");
+	printk(KERN_INFO "AMD Alchemy Au1500/Db1500 Board\n");
 #endif
 #ifdef CONFIG_MIPS_DB1100
-    printk("AMD Alchemy Au1100/Db1100 Board\n");
+	printk(KERN_INFO "AMD Alchemy Au1100/Db1100 Board\n");
 #endif
 #ifdef CONFIG_MIPS_BOSPORUS
-    printk("AMD Alchemy Bosporus Board\n");
+	printk(KERN_INFO "AMD Alchemy Bosporus Board\n");
 #endif
 #ifdef CONFIG_MIPS_MIRAGE
-    printk("AMD Alchemy Mirage Board\n");
+	printk(KERN_INFO "AMD Alchemy Mirage Board\n");
 #endif
 #ifdef CONFIG_MIPS_DB1550
-    printk("AMD Alchemy Au1550/Db1550 Board\n");
+	printk(KERN_INFO "AMD Alchemy Au1550/Db1550 Board\n");
 #endif
 }
diff --git a/arch/mips/au1000/db1x00/init.c b/arch/mips/au1000/db1x00/init.c
index d3b967c..5ebe0de 100644
--- a/arch/mips/au1000/db1x00/init.c
+++ b/arch/mips/au1000/db1x00/init.c
@@ -2,9 +2,8 @@
  * BRIEF MODULE DESCRIPTION
  *	PB1000 board setup
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -49,8 +48,8 @@ void __init prom_init(void)
 	unsigned long memsize;
 
 	prom_argc = fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg2;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
 
 	prom_init_cmdline();
 
@@ -58,6 +57,6 @@ void __init prom_init(void)
 	if (!memsize_str)
 		memsize = 0x04000000;
 	else
-		memsize = simple_strtol(memsize_str, NULL, 0);
+		memsize = strict_strtol(memsize_str, 0, NULL);
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/db1x00/irqmap.c b/arch/mips/au1000/db1x00/irqmap.c
index eaa50c7..94c090e 100644
--- a/arch/mips/au1000/db1x00/irqmap.c
+++ b/arch/mips/au1000/db1x00/irqmap.c
@@ -32,32 +32,32 @@
 
 #ifdef CONFIG_MIPS_DB1500
 char irq_tab_alchemy[][5] __initdata = {
- [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT371   */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+	[12] = { -1, INTA, INTX, INTX, INTX }, /* IDSEL 12 - HPT371   */
+	[13] = { -1, INTA, INTB, INTC, INTD }, /* IDSEL 13 - PCI slot */
 };
 #endif
 
 #ifdef CONFIG_MIPS_BOSPORUS
 char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 11 - miniPCI  */
- [12] =	{ -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - SN1741   */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+	[11] = { -1, INTA, INTB, INTX, INTX }, /* IDSEL 11 - miniPCI  */
+	[12] = { -1, INTA, INTX, INTX, INTX }, /* IDSEL 12 - SN1741   */
+	[13] = { -1, INTA, INTB, INTC, INTD }, /* IDSEL 13 - PCI slot */
 };
 #endif
 
 #ifdef CONFIG_MIPS_MIRAGE
 char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTD, INTX, INTX, INTX},   /* IDSEL 11 - SMI VGX */
- [12] =	{ -1, INTX, INTX, INTC, INTX},   /* IDSEL 12 - PNX1300 */
- [13] =	{ -1, INTA, INTB, INTX, INTX},   /* IDSEL 13 - miniPCI */
+	[11] = { -1, INTD, INTX, INTX, INTX }, /* IDSEL 11 - SMI VGX */
+	[12] = { -1, INTX, INTX, INTC, INTX }, /* IDSEL 12 - PNX1300 */
+	[13] = { -1, INTA, INTB, INTX, INTX }, /* IDSEL 13 - miniPCI */
 };
 #endif
 
 #ifdef CONFIG_MIPS_DB1550
 char irq_tab_alchemy[][5] __initdata = {
- [11] =	{ -1, INTC, INTX, INTX, INTX},   /* IDSEL 11 - on-board HPT371    */
- [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+	[11] = { -1, INTC, INTX, INTX, INTX }, /* IDSEL 11 - on-board HPT371 */
+	[12] = { -1, INTB, INTC, INTD, INTA }, /* IDSEL 12 - PCI slot 2 (left) */
+	[13] = { -1, INTA, INTB, INTC, INTD }, /* IDSEL 13 - PCI slot 1 (right) */
 };
 #endif
 
diff --git a/arch/mips/au1000/mtx-1/Makefile b/arch/mips/au1000/mtx-1/Makefile
index 85a9094..7c67b3d 100644
--- a/arch/mips/au1000/mtx-1/Makefile
+++ b/arch/mips/au1000/mtx-1/Makefile
@@ -1,7 +1,6 @@
 #
 #  Copyright 2003 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Author: MontaVista Software, Inc. <source@mvista.com>
 #       Bruno Randolf <bruno.randolf@4g-systems.biz>
 #
 # Makefile for 4G Systems MTX-1 board.
diff --git a/arch/mips/au1000/mtx-1/board_setup.c b/arch/mips/au1000/mtx-1/board_setup.c
index 5736354..3f80791 100644
--- a/arch/mips/au1000/mtx-1/board_setup.c
+++ b/arch/mips/au1000/mtx-1/board_setup.c
@@ -3,9 +3,8 @@
  * BRIEF MODULE DESCRIPTION
  *	4G Systems MTX-1 board setup.
  *
- * Copyright 2003 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2003, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *         Bruno Randolf <bruno.randolf@4g-systems.biz>
  *
  *  This program is free software; you can redistribute  it and/or modify it
@@ -34,7 +33,7 @@
 #include <asm/mach-au1x00/au1000.h>
 
 extern int (*board_pci_idsel)(unsigned int devsel, int assert);
-int    mtx1_pci_idsel(unsigned int devsel, int assert);
+int mtx1_pci_idsel(unsigned int devsel, int assert);
 
 void board_reset(void)
 {
@@ -45,36 +44,36 @@ void board_reset(void)
 void __init board_setup(void)
 {
 #if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
-	// enable USB power switch
-	au_writel( au_readl(GPIO2_DIR) | 0x10, GPIO2_DIR );
-	au_writel( 0x100000, GPIO2_OUTPUT );
+	/* Enable USB power switch */
+	au_writel(au_readl(GPIO2_DIR) | 0x10, GPIO2_DIR);
+	au_writel(0x100000, GPIO2_OUTPUT);
 #endif /* defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE) */
 
 #ifdef CONFIG_PCI
 #if defined(__MIPSEB__)
-	au_writel(0xf | (2<<6) | (1<<4), Au1500_PCI_CFG);
+	au_writel(0xf | (2 << 6) | (1 << 4), Au1500_PCI_CFG);
 #else
 	au_writel(0xf, Au1500_PCI_CFG);
 #endif
 #endif
 
-	// initialize sys_pinfunc:
-	au_writel( SYS_PF_NI2, SYS_PINFUNC );
+	/* Initialize sys_pinfunc */
+	au_writel(SYS_PF_NI2, SYS_PINFUNC);
 
-	// initialize GPIO
-	au_writel( 0xFFFFFFFF, SYS_TRIOUTCLR );
-	au_writel( 0x00000001, SYS_OUTPUTCLR ); // set M66EN (PCI 66MHz) to OFF
-	au_writel( 0x00000008, SYS_OUTPUTSET ); // set PCI CLKRUN# to OFF
-	au_writel( 0x00000002, SYS_OUTPUTSET ); // set EXT_IO3 ON
-	au_writel( 0x00000020, SYS_OUTPUTCLR ); // set eth PHY TX_ER to OFF
+	/* Initialize GPIO */
+	au_writel(0xFFFFFFFF, SYS_TRIOUTCLR);
+	au_writel(0x00000001, SYS_OUTPUTCLR); /* set M66EN (PCI 66MHz) to OFF */
+	au_writel(0x00000008, SYS_OUTPUTSET); /* set PCI CLKRUN# to OFF */
+	au_writel(0x00000002, SYS_OUTPUTSET); /* set EXT_IO3 ON */
+	au_writel(0x00000020, SYS_OUTPUTCLR); /* set eth PHY TX_ER to OFF */
 
-	// enable LED and set it to green
-	au_writel( au_readl(GPIO2_DIR) | 0x1800, GPIO2_DIR );
-	au_writel( 0x18000800, GPIO2_OUTPUT );
+	/* Enable LED and set it to green */
+	au_writel(au_readl(GPIO2_DIR) | 0x1800, GPIO2_DIR);
+	au_writel(0x18000800, GPIO2_OUTPUT);
 
 	board_pci_idsel = mtx1_pci_idsel;
 
-	printk("4G Systems MTX-1 Board\n");
+	printk(KERN_INFO "4G Systems MTX-1 Board\n");
 }
 
 int
@@ -82,20 +81,18 @@ mtx1_pci_idsel(unsigned int devsel, int assert)
 {
 #define MTX_IDSEL_ONLY_0_AND_3 0
 #if MTX_IDSEL_ONLY_0_AND_3
-       if (devsel != 0 && devsel != 3) {
-               printk("*** not 0 or 3\n");
-               return 0;
-       }
+	if (devsel != 0 && devsel != 3) {
+		printk(KERN_ERR "*** not 0 or 3\n");
+		return 0;
+	}
 #endif
 
-       if (assert && devsel != 0) {
-               // suppress signal to cardbus
-               au_writel( 0x00000002, SYS_OUTPUTCLR ); // set EXT_IO3 OFF
-       }
-       else {
-               au_writel( 0x00000002, SYS_OUTPUTSET ); // set EXT_IO3 ON
-       }
-       au_sync_udelay(1);
-       return 1;
+	if (assert && devsel != 0)
+		/* Suppress signal to Cardbus */
+		au_writel(0x00000002, SYS_OUTPUTCLR); /* set EXT_IO3 OFF */
+	else
+		au_writel(0x00000002, SYS_OUTPUTSET); /* set EXT_IO3 ON */
+	au_sync_udelay(1);
+	return 1;
 }
 
diff --git a/arch/mips/au1000/mtx-1/init.c b/arch/mips/au1000/mtx-1/init.c
index c015cbc..33a4aeb 100644
--- a/arch/mips/au1000/mtx-1/init.c
+++ b/arch/mips/au1000/mtx-1/init.c
@@ -3,9 +3,8 @@
  * BRIEF MODULE DESCRIPTION
  *	4G Systems MTX-1 board setup
  *
- * Copyright 2003 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2003, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *         Bruno Randolf <bruno.randolf@4g-systems.biz>
  *
  *  This program is free software; you can redistribute  it and/or modify it
@@ -47,8 +46,8 @@ void __init prom_init(void)
 	unsigned long memsize;
 
 	prom_argc = fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg2;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
 
 	prom_init_cmdline();
 
@@ -56,6 +55,6 @@ void __init prom_init(void)
 	if (!memsize_str)
 		memsize = 0x04000000;
 	else
-		memsize = simple_strtol(memsize_str, NULL, 0);
+		memsize = strict_strtol(memsize_str, 0, NULL);
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/mtx-1/irqmap.c b/arch/mips/au1000/mtx-1/irqmap.c
index 78d70c4..f2bf029 100644
--- a/arch/mips/au1000/mtx-1/irqmap.c
+++ b/arch/mips/au1000/mtx-1/irqmap.c
@@ -31,18 +31,18 @@
 #include <asm/mach-au1x00/au1000.h>
 
 char irq_tab_alchemy[][5] __initdata = {
- [0] = { -1, INTA, INTA, INTX, INTX},   /* IDSEL 00 - AdapterA-Slot0 (top)    */
- [1] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 01 - AdapterA-Slot1 (bottom) */
- [2] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 02 - AdapterB-Slot0 (top)    */
- [3] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 03 - AdapterB-Slot1 (bottom) */
- [4] = { -1, INTA, INTB, INTX, INTX},   /* IDSEL 04 - AdapterC-Slot0 (top)    */
- [5] = { -1, INTB, INTA, INTX, INTX},   /* IDSEL 05 - AdapterC-Slot1 (bottom) */
- [6] = { -1, INTC, INTD, INTX, INTX},   /* IDSEL 06 - AdapterD-Slot0 (top)    */
- [7] = { -1, INTD, INTC, INTX, INTX},   /* IDSEL 07 - AdapterD-Slot1 (bottom) */
+	[0] = { -1, INTA, INTA, INTX, INTX }, /* IDSEL 00 - AdapterA-Slot0 (top) */
+	[1] = { -1, INTB, INTA, INTX, INTX }, /* IDSEL 01 - AdapterA-Slot1 (bottom) */
+	[2] = { -1, INTC, INTD, INTX, INTX }, /* IDSEL 02 - AdapterB-Slot0 (top) */
+	[3] = { -1, INTD, INTC, INTX, INTX }, /* IDSEL 03 - AdapterB-Slot1 (bottom) */
+	[4] = { -1, INTA, INTB, INTX, INTX }, /* IDSEL 04 - AdapterC-Slot0 (top) */
+	[5] = { -1, INTB, INTA, INTX, INTX }, /* IDSEL 05 - AdapterC-Slot1 (bottom) */
+	[6] = { -1, INTC, INTD, INTX, INTX }, /* IDSEL 06 - AdapterD-Slot0 (top) */
+	[7] = { -1, INTD, INTC, INTX, INTX }, /* IDSEL 07 - AdapterD-Slot1 (bottom) */
 };
 
 struct au1xxx_irqmap __initdata au1xxx_irq_map[] = {
-       { AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
+       { AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0 },
        { AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
        { AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
        { AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
diff --git a/arch/mips/au1000/mtx-1/platform.c b/arch/mips/au1000/mtx-1/platform.c
index a7edbf0..9807be3 100644
--- a/arch/mips/au1000/mtx-1/platform.c
+++ b/arch/mips/au1000/mtx-1/platform.c
@@ -21,11 +21,10 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/leds.h>
+#include <linux/gpio.h>
 #include <linux/gpio_keys.h>
 #include <linux/input.h>
 
-#include <asm/gpio.h>
-
 static struct gpio_keys_button mtx1_gpio_button[] = {
 	{
 		.gpio = 207,
diff --git a/arch/mips/au1000/pb1000/Makefile b/arch/mips/au1000/pb1000/Makefile
index daa1a50..99bbec0 100644
--- a/arch/mips/au1000/pb1000/Makefile
+++ b/arch/mips/au1000/pb1000/Makefile
@@ -1,8 +1,8 @@
 #
-#  Copyright 2000 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Copyright 2000, 2008 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc. <source@mvista.com>
+#
+# Makefile for the Alchemy Semiconductor Pb1000 board.
 #
-# Makefile for the Alchemy Semiconductor PB1000 board.
 
 lib-y := init.o board_setup.o irqmap.o
diff --git a/arch/mips/au1000/pb1000/board_setup.c b/arch/mips/au1000/pb1000/board_setup.c
index 33f15ac..25df167 100644
--- a/arch/mips/au1000/pb1000/board_setup.c
+++ b/arch/mips/au1000/pb1000/board_setup.c
@@ -1,7 +1,6 @@
 /*
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2000, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -40,128 +39,126 @@ void __init board_setup(void)
 	u32 sys_freqctrl, sys_clksrc;
 	u32 prid = read_c0_prid();
 
-	// set AUX clock to 12MHz * 8 = 96 MHz
+	/* Set AUX clock to 12 MHz * 8 = 96 MHz */
 	au_writel(8, SYS_AUXPLL);
 	au_writel(0, SYS_PINSTATERD);
 	udelay(100);
 
 #if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
-	/* zero and disable FREQ2 */
+	/* Zero and disable FREQ2 */
 	sys_freqctrl = au_readl(SYS_FREQCTRL0);
 	sys_freqctrl &= ~0xFFF00000;
 	au_writel(sys_freqctrl, SYS_FREQCTRL0);
 
-	/* zero and disable USBH/USBD clocks */
+	/* Zero and disable USBH/USBD clocks */
 	sys_clksrc = au_readl(SYS_CLKSRC);
-	sys_clksrc &= ~0x00007FE0;
+	sys_clksrc &= ~(SYS_CS_CUD | SYS_CS_DUD | SYS_CS_MUD_MASK |
+		        SYS_CS_CUH | SYS_CS_DUH | SYS_CS_MUH_MASK);
 	au_writel(sys_clksrc, SYS_CLKSRC);
 
 	sys_freqctrl = au_readl(SYS_FREQCTRL0);
 	sys_freqctrl &= ~0xFFF00000;
 
 	sys_clksrc = au_readl(SYS_CLKSRC);
-	sys_clksrc &= ~0x00007FE0;
+	sys_clksrc &= ~(SYS_CS_CUD | SYS_CS_DUD | SYS_CS_MUD_MASK |
+		        SYS_CS_CUH | SYS_CS_DUH | SYS_CS_MUH_MASK);
 
-	switch (prid & 0x000000FF)
-	{
+	switch (prid & 0x000000FF) {
 	case 0x00: /* DA */
 	case 0x01: /* HA */
 	case 0x02: /* HB */
-	/* CPU core freq to 48MHz to slow it way down... */
-	au_writel(4, SYS_CPUPLL);
+		/* CPU core freq to 48 MHz to slow it way down... */
+		au_writel(4, SYS_CPUPLL);
 
-	/*
-	 * Setup 48MHz FREQ2 from CPUPLL for USB Host
-	 */
-	/* FRDIV2=3 -> div by 8 of 384MHz -> 48MHz */
-	sys_freqctrl |= ((3<<22) | (1<<21) | (0<<20));
-	au_writel(sys_freqctrl, SYS_FREQCTRL0);
+		/*
+		 * Setup 48 MHz FREQ2 from CPUPLL for USB Host
+		 * FRDIV2 = 3 -> div by 8 of 384 MHz -> 48 MHz
+		 */
+		sys_freqctrl |= (3 << SYS_FC_FRDIV2_BIT) | SYS_FC_FE2;
+		au_writel(sys_freqctrl, SYS_FREQCTRL0);
 
-	/* CPU core freq to 384MHz */
-	au_writel(0x20, SYS_CPUPLL);
+		/* CPU core freq to 384 MHz */
+		au_writel(0x20, SYS_CPUPLL);
 
-	printk("Au1000: 48MHz OHCI workaround enabled\n");
+		printk(KERN_INFO "Au1000: 48 MHz OHCI workaround enabled\n");
 		break;
 
-	default:  /* HC and newer */
-	// FREQ2 = aux/2 = 48 MHz
-	sys_freqctrl |= ((0<<22) | (1<<21) | (1<<20));
-	au_writel(sys_freqctrl, SYS_FREQCTRL0);
+	default: /* HC and newer */
+		/* FREQ2 = aux / 2 = 48 MHz */
+		sys_freqctrl |= (0 << SYS_FC_FRDIV2_BIT) |
+				 SYS_FC_FE2 | SYS_FC_FS2;
+		au_writel(sys_freqctrl, SYS_FREQCTRL0);
 		break;
 	}
 
 	/*
-	 * Route 48MHz FREQ2 into USB Host and/or Device
+	 * Route 48 MHz FREQ2 into USB Host and/or Device
 	 */
-#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
-	sys_clksrc |= ((4<<12) | (0<<11) | (0<<10));
-#endif
+	sys_clksrc |= SYS_CS_MUX_FQ2 << SYS_CS_MUH_BIT;
 	au_writel(sys_clksrc, SYS_CLKSRC);
 
-	// configure pins GPIO[14:9] as GPIO
-	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8080);
+	/* Configure pins GPIO[14:9] as GPIO */
+	pin_func = au_readl(SYS_PINFUNC) & ~(SYS_PF_UR3 | SYS_PF_USB);
 
-	// 2nd USB port is USB host
-	pin_func |= 0x8000;
+	/* 2nd USB port is USB host */
+	pin_func |= SYS_PF_USB;
 
 	au_writel(pin_func, SYS_PINFUNC);
 	au_writel(0x2800, SYS_TRIOUTCLR);
 	au_writel(0x0030, SYS_OUTPUTCLR);
 #endif /* defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE) */
 
-	// make gpio 15 an input (for interrupt line)
-	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x100);
-	// we don't need I2S, so make it available for GPIO[31:29]
-	pin_func |= (1<<5);
+	/* Make GPIO 15 an input (for interrupt line) */
+	pin_func = au_readl(SYS_PINFUNC) & ~SYS_PF_IRF;
+	/* We don't need I2S, so make it available for GPIO[31:29] */
+	pin_func |= SYS_PF_I2S;
 	au_writel(pin_func, SYS_PINFUNC);
 
 	au_writel(0x8000, SYS_TRIOUTCLR);
 
-	static_cfg0 = au_readl(MEM_STCFG0) & (u32)(~0xc00);
+	static_cfg0 = au_readl(MEM_STCFG0) & ~0xc00;
 	au_writel(static_cfg0, MEM_STCFG0);
 
-	// configure RCE2* for LCD
+	/* configure RCE2* for LCD */
 	au_writel(0x00000004, MEM_STCFG2);
 
-	// MEM_STTIME2
+	/* MEM_STTIME2 */
 	au_writel(0x09000000, MEM_STTIME2);
 
-	// Set 32-bit base address decoding for RCE2*
+	/* Set 32-bit base address decoding for RCE2* */
 	au_writel(0x10003ff0, MEM_STADDR2);
 
-	// PCI CPLD setup
-	// expand CE0 to cover PCI
+	/*
+	 * PCI CPLD setup
+	 * Expand CE0 to cover PCI
+	 */
 	au_writel(0x11803e40, MEM_STADDR1);
 
-	// burst visibility on
+	/* Burst visibility on */
 	au_writel(au_readl(MEM_STCFG0) | 0x1000, MEM_STCFG0);
 
-	au_writel(0x83, MEM_STCFG1);         // ewait enabled, flash timing
-	au_writel(0x33030a10, MEM_STTIME1);   // slower timing for FPGA
+	au_writel(0x83, MEM_STCFG1);	     /* ewait enabled, flash timing */
+	au_writel(0x33030a10, MEM_STTIME1);  /* slower timing for FPGA */
 
-	/* setup the static bus controller */
+	/* Setup the static bus controller */
 	au_writel(0x00000002, MEM_STCFG3);  /* type = PCMCIA */
 	au_writel(0x280E3D07, MEM_STTIME3); /* 250ns cycle time */
 	au_writel(0x10000000, MEM_STADDR3); /* any PCMCIA select */
 
-#ifdef CONFIG_PCI
-	au_writel(0, PCI_BRIDGE_CONFIG); // set extend byte to 0
-	au_writel(0, SDRAM_MBAR);        // set mbar to 0
-	au_writel(0x2, SDRAM_CMD);       // enable memory accesses
-	au_sync_delay(1);
-#endif
-
-	/* Enable Au1000 BCLK switching - note: sed1356 must not use
-	 * its BCLK (Au1000 LCLK) for any timings */
-	switch (prid & 0x000000FF)
-	{
+	/*
+	 * Enable Au1000 BCLK switching - note: sed1356 must not use
+	 * its BCLK (Au1000 LCLK) for any timings
+	 */
+	switch (prid & 0x000000FF) {
 	case 0x00: /* DA */
 	case 0x01: /* HA */
 	case 0x02: /* HB */
 		break;
 	default:  /* HC and newer */
-		/* Enable sys bus clock divider when IDLE state or no bus
-		   activity. */
+		/*
+		 * Enable sys bus clock divider when IDLE state or no bus
+		 * activity.
+		 */
 		au_writel(au_readl(SYS_POWERCTRL) | (0x3 << 5), SYS_POWERCTRL);
 		break;
 	}
diff --git a/arch/mips/au1000/pb1000/init.c b/arch/mips/au1000/pb1000/init.c
index 549447d..3837365 100644
--- a/arch/mips/au1000/pb1000/init.c
+++ b/arch/mips/au1000/pb1000/init.c
@@ -1,10 +1,9 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	PB1000 board setup
+ *	Pb1000 board setup
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -44,16 +43,15 @@ void __init prom_init(void)
 	unsigned char *memsize_str;
 	unsigned long memsize;
 
-	prom_argc = (int) fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg2;
+	prom_argc = (int)fw_arg0;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
 
 	prom_init_cmdline();
 	memsize_str = prom_getenv("memsize");
-	if (!memsize_str) {
+	if (!memsize_str)
 		memsize = 0x04000000;
-	} else {
-		memsize = simple_strtol(memsize_str, NULL, 0);
-	}
+	else
+		memsize = strict_strtol(memsize_str, 0, NULL);
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/pb1100/Makefile b/arch/mips/au1000/pb1100/Makefile
index 996236d..793e97c 100644
--- a/arch/mips/au1000/pb1100/Makefile
+++ b/arch/mips/au1000/pb1100/Makefile
@@ -1,8 +1,8 @@
 #
-#  Copyright 2000,2001 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Copyright 2000, 2001, 2008 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc. <source@mvista.com>
 #
 # Makefile for the Alchemy Semiconductor Pb1100 board.
+#
 
 lib-y := init.o board_setup.o irqmap.o
diff --git a/arch/mips/au1000/pb1100/board_setup.c b/arch/mips/au1000/pb1100/board_setup.c
index 656164c..c0bfd59 100644
--- a/arch/mips/au1000/pb1100/board_setup.c
+++ b/arch/mips/au1000/pb1100/board_setup.c
@@ -1,7 +1,6 @@
 /*
- * Copyright 2002 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2002, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -32,15 +31,15 @@
 
 void board_reset(void)
 {
-    /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
-    au_writel(0x00000000, 0xAE00001C);
+	/* Hit BCSR.RST_VDDI[SOFT_RESET] */
+	au_writel(0x00000000, PB1100_RST_VDDI);
 }
 
 void __init board_setup(void)
 {
-	volatile void __iomem * base = (volatile void __iomem *) 0xac000000UL;
+	volatile void __iomem *base = (volatile void __iomem *)0xac000000UL;
 
-	// set AUX clock to 12MHz * 8 = 96 MHz
+	/* Set AUX clock to 12 MHz * 8 = 96 MHz */
 	au_writel(8, SYS_AUXPLL);
 	au_writel(0, SYS_PININPUTEN);
 	udelay(100);
@@ -49,44 +48,47 @@ void __init board_setup(void)
 	{
 		u32 pin_func, sys_freqctrl, sys_clksrc;
 
-		// configure pins GPIO[14:9] as GPIO
-		pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x80);
+		/* Configure pins GPIO[14:9] as GPIO */
+		pin_func = au_readl(SYS_PINFUNC) & ~SYS_PF_UR3;
 
-		/* zero and disable FREQ2 */
+		/* Zero and disable FREQ2 */
 		sys_freqctrl = au_readl(SYS_FREQCTRL0);
 		sys_freqctrl &= ~0xFFF00000;
 		au_writel(sys_freqctrl, SYS_FREQCTRL0);
 
-		/* zero and disable USBH/USBD/IrDA clock */
+		/* Zero and disable USBH/USBD/IrDA clock */
 		sys_clksrc = au_readl(SYS_CLKSRC);
-		sys_clksrc &= ~0x0000001F;
+		sys_clksrc &= ~(SYS_CS_CIR | SYS_CS_DIR | SYS_CS_MIR_MASK);
 		au_writel(sys_clksrc, SYS_CLKSRC);
 
 		sys_freqctrl = au_readl(SYS_FREQCTRL0);
 		sys_freqctrl &= ~0xFFF00000;
 
 		sys_clksrc = au_readl(SYS_CLKSRC);
-		sys_clksrc &= ~0x0000001F;
+		sys_clksrc &= ~(SYS_CS_CIR | SYS_CS_DIR | SYS_CS_MIR_MASK);
 
-		// FREQ2 = aux/2 = 48 MHz
-		sys_freqctrl |= ((0<<22) | (1<<21) | (1<<20));
+		/* FREQ2 = aux / 2 = 48 MHz */
+		sys_freqctrl |= (0 << SYS_FC_FRDIV2_BIT) |
+				SYS_FC_FE2 | SYS_FC_FS2;
 		au_writel(sys_freqctrl, SYS_FREQCTRL0);
 
 		/*
-		 * Route 48MHz FREQ2 into USBH/USBD/IrDA
+		 * Route 48 MHz FREQ2 into USBH/USBD/IrDA
 		 */
-		sys_clksrc |= ((4<<2) | (0<<1) | 0 );
+		sys_clksrc |= SYS_CS_MUX_FQ2 << SYS_CS_MIR_BIT;
 		au_writel(sys_clksrc, SYS_CLKSRC);
 
-		/* setup the static bus controller */
+		/* Setup the static bus controller */
 		au_writel(0x00000002, MEM_STCFG3);  /* type = PCMCIA */
 		au_writel(0x280E3D07, MEM_STTIME3); /* 250ns cycle time */
 		au_writel(0x10000000, MEM_STADDR3); /* any PCMCIA select */
 
-		// get USB Functionality pin state (device vs host drive pins)
-		pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8000);
-		// 2nd USB port is USB host
-		pin_func |= 0x8000;
+		/*
+		 * Get USB Functionality pin state (device vs host drive pins).
+		 */
+		pin_func = au_readl(SYS_PINFUNC) & ~SYS_PF_USB;
+		/* 2nd USB port is USB host. */
+		pin_func |= SYS_PF_USB;
 		au_writel(pin_func, SYS_PINFUNC);
 	}
 #endif /* defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE) */
@@ -94,12 +96,12 @@ void __init board_setup(void)
 	/* Enable sys bus clock divider when IDLE state or no bus activity. */
 	au_writel(au_readl(SYS_POWERCTRL) | (0x3 << 5), SYS_POWERCTRL);
 
-	// Enable the RTC if not already enabled
+	/* Enable the RTC if not already enabled. */
 	if (!(readb(base + 0x28) & 0x20)) {
 		writeb(readb(base + 0x28) | 0x20, base + 0x28);
 		au_sync();
 	}
-	// Put the clock in BCD mode
+	/* Put the clock in BCD mode. */
 	if (readb(base + 0x2C) & 0x4) { /* reg B */
 		writeb(readb(base + 0x2c) & ~0x4, base + 0x2c);
 		au_sync();
diff --git a/arch/mips/au1000/pb1100/init.c b/arch/mips/au1000/pb1100/init.c
index c913446..8355483 100644
--- a/arch/mips/au1000/pb1100/init.c
+++ b/arch/mips/au1000/pb1100/init.c
@@ -3,9 +3,8 @@
  * BRIEF MODULE DESCRIPTION
  *	Pb1100 board setup
  *
- * Copyright 2002 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2002, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -46,8 +45,8 @@ void __init prom_init(void)
 	unsigned long memsize;
 
 	prom_argc = fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg3;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg3;
 
 	prom_init_cmdline();
 
@@ -55,7 +54,7 @@ void __init prom_init(void)
 	if (!memsize_str)
 		memsize = 0x04000000;
 	else
-		memsize = simple_strtol(memsize_str, NULL, 0);
+		memsize = strict_strtol(memsize_str, 0, NULL);
 
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/pb1100/irqmap.c b/arch/mips/au1000/pb1100/irqmap.c
index b5021e3..9b7dd8b 100644
--- a/arch/mips/au1000/pb1100/irqmap.c
+++ b/arch/mips/au1000/pb1100/irqmap.c
@@ -1,6 +1,6 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	Au1xxx irq map table
+ *	Au1xx0 IRQ map table
  *
  * Copyright 2003 Embedded Edge, LLC
  *		dan@embeddededge.com
@@ -31,10 +31,10 @@
 #include <asm/mach-au1x00/au1000.h>
 
 struct au1xxx_irqmap __initdata au1xxx_irq_map[] = {
-	{ AU1000_GPIO_9, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card Fully_Interted#
-	{ AU1000_GPIO_10, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card STSCHG#
-	{ AU1000_GPIO_11, INTC_INT_LOW_LEVEL, 0 }, // PCMCIA Card IRQ#
-	{ AU1000_GPIO_13, INTC_INT_LOW_LEVEL, 0 }, // DC_IRQ#
+	{ AU1000_GPIO_9,  INTC_INT_LOW_LEVEL, 0 }, /* PCMCIA Card Fully_Inserted# */
+	{ AU1000_GPIO_10, INTC_INT_LOW_LEVEL, 0 }, /* PCMCIA Card STSCHG# */
+	{ AU1000_GPIO_11, INTC_INT_LOW_LEVEL, 0 }, /* PCMCIA Card IRQ# */
+	{ AU1000_GPIO_13, INTC_INT_LOW_LEVEL, 0 }, /* DC_IRQ# */
 };
 
 int __initdata au1xxx_nr_irqs = ARRAY_SIZE(au1xxx_irq_map);
diff --git a/arch/mips/au1000/pb1200/Makefile b/arch/mips/au1000/pb1200/Makefile
index 4fe02ea..d678adf 100644
--- a/arch/mips/au1000/pb1200/Makefile
+++ b/arch/mips/au1000/pb1200/Makefile
@@ -1,5 +1,5 @@
 #
-# Makefile for the Alchemy Semiconductor PB1200 board.
+# Makefile for the Alchemy Semiconductor Pb1200/DBAu1200 boards.
 #
 
 lib-y := init.o board_setup.o irqmap.o
diff --git a/arch/mips/au1000/pb1200/board_setup.c b/arch/mips/au1000/pb1200/board_setup.c
index 4493a79..6cb2115 100644
--- a/arch/mips/au1000/pb1200/board_setup.c
+++ b/arch/mips/au1000/pb1200/board_setup.c
@@ -27,16 +27,8 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 
-#include <au1000.h>
 #include <prom.h>
-
-#ifdef CONFIG_MIPS_PB1200
-#include <asm/mach-pb1x00/pb1200.h>
-#endif
-
-#ifdef CONFIG_MIPS_DB1200
-#include <asm/mach-db1x00/db1200.h>
-#endif
+#include <au1xxx.h>
 
 extern void _board_init_irq(void);
 extern void (*board_init_irq)(void);
@@ -53,56 +45,57 @@ void __init board_setup(void)
 
 #if 0
 	{
-	u32 pin_func;
-
-	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
-	 * but it is board specific code, so put it here.
-	 */
-	pin_func = au_readl(SYS_PINFUNC);
-	au_sync();
-	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
-	au_writel(pin_func, SYS_PINFUNC);
-
-	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
-	au_sync();
+		u32 pin_func;
+
+		/*
+		 * Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+		 * but it is board specific code, so put it here.
+		 */
+		pin_func = au_readl(SYS_PINFUNC);
+		au_sync();
+		pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
+		au_writel(pin_func, SYS_PINFUNC);
+
+		au_writel(0, (u32)bcsr | 0x10); /* turn off PCMCIA power */
+		au_sync();
 	}
 #endif
 
 #if defined(CONFIG_I2C_AU1550)
 	{
-	u32 freq0, clksrc;
-	u32 pin_func;
-
-	/* Select SMBUS in CPLD */
-	bcsr->resets &= ~(BCSR_RESETS_PCS0MUX);
-
-	pin_func = au_readl(SYS_PINFUNC);
-	au_sync();
-	pin_func &= ~(3<<17 | 1<<4);
-	/* Set GPIOs correctly */
-	pin_func |= 2<<17;
-	au_writel(pin_func, SYS_PINFUNC);
-	au_sync();
-
-	/* The i2c driver depends on 50Mhz clock */
-	freq0 = au_readl(SYS_FREQCTRL0);
-	au_sync();
-	freq0 &= ~(SYS_FC_FRDIV1_MASK | SYS_FC_FS1 | SYS_FC_FE1);
-	freq0 |= (3<<SYS_FC_FRDIV1_BIT);
-	/* 396Mhz / (3+1)*2 == 49.5Mhz */
-	au_writel(freq0, SYS_FREQCTRL0);
-	au_sync();
-	freq0 |= SYS_FC_FE1;
-	au_writel(freq0, SYS_FREQCTRL0);
-	au_sync();
-
-	clksrc = au_readl(SYS_CLKSRC);
-	au_sync();
-	clksrc &= ~0x01f00000;
-	/* bit 22 is EXTCLK0 for PSC0 */
-	clksrc |= (0x3 << 22);
-	au_writel(clksrc, SYS_CLKSRC);
-	au_sync();
+		u32 freq0, clksrc;
+		u32 pin_func;
+
+		/* Select SMBus in CPLD */
+		bcsr->resets &= ~BCSR_RESETS_PCS0MUX;
+
+		pin_func = au_readl(SYS_PINFUNC);
+		au_sync();
+		pin_func &= ~(SYS_PINFUNC_P0A | SYS_PINFUNC_P0B);
+		/* Set GPIOs correctly */
+		pin_func |= 2 << 17;
+		au_writel(pin_func, SYS_PINFUNC);
+		au_sync();
+
+		/* The I2C driver depends on 50 MHz clock */
+		freq0 = au_readl(SYS_FREQCTRL0);
+		au_sync();
+		freq0 &= ~(SYS_FC_FRDIV1_MASK | SYS_FC_FS1 | SYS_FC_FE1);
+		freq0 |= 3 << SYS_FC_FRDIV1_BIT;
+		/* 396 MHz / (3 + 1) * 2 == 49.5 MHz */
+		au_writel(freq0, SYS_FREQCTRL0);
+		au_sync();
+		freq0 |= SYS_FC_FE1;
+		au_writel(freq0, SYS_FREQCTRL0);
+		au_sync();
+
+		clksrc = au_readl(SYS_CLKSRC);
+		au_sync();
+		clksrc &= ~(SYS_CS_CE0 | SYS_CS_DE0 | SYS_CS_ME0_MASK);
+		/* Bit 22 is EXTCLK0 for PSC0 */
+		clksrc |= SYS_CS_MUX_FQ1 << SYS_CS_ME0_BIT;
+		au_writel(clksrc, SYS_CLKSRC);
+		au_sync();
 	}
 #endif
 
@@ -116,27 +109,27 @@ void __init board_setup(void)
 #endif
 #endif
 
-	/* The Pb1200 development board uses external MUX for PSC0 to
-	support SMB/SPI. bcsr->resets bit 12: 0=SMB 1=SPI
-	*/
+	/*
+	 * The Pb1200 development board uses external MUX for PSC0 to
+	 * support SMB/SPI. bcsr->resets bit 12: 0=SMB 1=SPI
+	 */
 #ifdef CONFIG_I2C_AU1550
-	bcsr->resets &= (~BCSR_RESETS_PCS0MUX);
+	bcsr->resets &= ~BCSR_RESETS_PCS0MUX;
 #endif
 	au_sync();
 
 #ifdef CONFIG_MIPS_PB1200
-	printk("AMD Alchemy Pb1200 Board\n");
+	printk(KERN_INFO "AMD Alchemy Pb1200 Board\n");
 #endif
 #ifdef CONFIG_MIPS_DB1200
-	printk("AMD Alchemy Db1200 Board\n");
+	printk(KERN_INFO "AMD Alchemy Db1200 Board\n");
 #endif
 
 	/* Setup Pb1200 External Interrupt Controller */
 	board_init_irq = _board_init_irq;
 }
 
-int
-board_au1200fb_panel(void)
+int board_au1200fb_panel(void)
 {
 	BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 	int p;
@@ -147,23 +140,23 @@ board_au1200fb_panel(void)
 	return p;
 }
 
-int
-board_au1200fb_panel_init(void)
+int board_au1200fb_panel_init(void)
 {
 	/* Apply power */
-    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
-	bcsr->board |= (BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
-	/*printk("board_au1200fb_panel_init()\n"); */
+	BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+	bcsr->board |= BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL;
+	/* printk(KERN_DEBUG "board_au1200fb_panel_init()\n"); */
 	return 0;
 }
 
-int
-board_au1200fb_panel_shutdown(void)
+int board_au1200fb_panel_shutdown(void)
 {
 	/* Remove power */
-    BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
-	bcsr->board &= ~(BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD | BCSR_BOARD_LCDBL);
-	/*printk("board_au1200fb_panel_shutdown()\n"); */
+	BCSR *bcsr = (BCSR *)BCSR_KSEG1_ADDR;
+
+	bcsr->board &= ~(BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD |
+			 BCSR_BOARD_LCDBL);
+	/* printk(KERN_DEBUG "board_au1200fb_panel_shutdown()\n"); */
 	return 0;
 }
-
diff --git a/arch/mips/au1000/pb1200/init.c b/arch/mips/au1000/pb1200/init.c
index 72af550..09fd63b 100644
--- a/arch/mips/au1000/pb1200/init.c
+++ b/arch/mips/au1000/pb1200/init.c
@@ -3,9 +3,8 @@
  * BRIEF MODULE DESCRIPTION
  *	PB1200 board setup
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -45,16 +44,15 @@ void __init prom_init(void)
 	unsigned char *memsize_str;
 	unsigned long memsize;
 
-	prom_argc = (int) fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg2;
+	prom_argc = (int)fw_arg0;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
 
 	prom_init_cmdline();
 	memsize_str = prom_getenv("memsize");
-	if (!memsize_str) {
+	if (!memsize_str)
 		memsize = 0x08000000;
-	} else {
-		memsize = simple_strtol(memsize_str, NULL, 0);
-	}
+	else
+		memsize = strict_strtol(memsize_str, 0, NULL);
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/pb1200/irqmap.c b/arch/mips/au1000/pb1200/irqmap.c
index e61eb8e..2a505ad 100644
--- a/arch/mips/au1000/pb1200/irqmap.c
+++ b/arch/mips/au1000/pb1200/irqmap.c
@@ -39,25 +39,25 @@
 #endif
 
 struct au1xxx_irqmap __initdata au1xxx_irq_map[] = {
-	{ AU1000_GPIO_7, INTC_INT_LOW_LEVEL, 0 }, // This is exteranl interrupt cascade
+	/* This is external interrupt cascade */
+	{ AU1000_GPIO_7, INTC_INT_LOW_LEVEL, 0 },
 };
 
 int __initdata au1xxx_nr_irqs = ARRAY_SIZE(au1xxx_irq_map);
 
 /*
- *	Support for External interrupts on the PbAu1200 Development platform.
+ * Support for External interrupts on the Pb1200 Development platform.
  */
-static volatile int pb1200_cascade_en=0;
+static volatile int pb1200_cascade_en;
 
-irqreturn_t pb1200_cascade_handler( int irq, void *dev_id)
+irqreturn_t pb1200_cascade_handler(int irq, void *dev_id)
 {
 	unsigned short bisr = bcsr->int_status;
 	int extirq_nr = 0;
 
-	/* Clear all the edge interrupts. This has no effect on level */
+	/* Clear all the edge interrupts. This has no effect on level. */
 	bcsr->int_status = bisr;
-	for( ; bisr; bisr &= (bisr-1) )
-	{
+	for ( ; bisr; bisr &= bisr - 1) {
 		extirq_nr = PB1200_INT_BEGIN + __ffs(bisr);
 		/* Ack and dispatch IRQ */
 		do_IRQ(extirq_nr);
@@ -68,26 +68,20 @@ irqreturn_t pb1200_cascade_handler( int irq, void *dev_id)
 
 inline void pb1200_enable_irq(unsigned int irq_nr)
 {
-	bcsr->intset_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
-	bcsr->intset = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intset_mask = 1 << (irq_nr - PB1200_INT_BEGIN);
+	bcsr->intset = 1 << (irq_nr - PB1200_INT_BEGIN);
 }
 
 inline void pb1200_disable_irq(unsigned int irq_nr)
 {
-	bcsr->intclr_mask = 1<<(irq_nr - PB1200_INT_BEGIN);
-	bcsr->intclr = 1<<(irq_nr - PB1200_INT_BEGIN);
+	bcsr->intclr_mask = 1 << (irq_nr - PB1200_INT_BEGIN);
+	bcsr->intclr = 1 << (irq_nr - PB1200_INT_BEGIN);
 }
 
 static unsigned int pb1200_setup_cascade(void)
 {
-	int err;
-
-	err = request_irq(AU1000_GPIO_7, &pb1200_cascade_handler,
-			  0, "Pb1200 Cascade", &pb1200_cascade_handler);
-	if (err)
-		return err;
-
-	return 0;
+	return request_irq(AU1000_GPIO_7, &pb1200_cascade_handler,
+			   0, "Pb1200 Cascade", &pb1200_cascade_handler);
 }
 
 static unsigned int pb1200_startup_irq(unsigned int irq)
@@ -132,23 +126,23 @@ void _board_init_irq(void)
 	unsigned int irq;
 
 #ifdef CONFIG_MIPS_PB1200
-	/* We have a problem with CPLD rev3. Enable a workaround */
+	/* We have a problem with CPLD rev 3. */
 	if (((bcsr->whoami & BCSR_WHOAMI_CPLD) >> 4) <= 3) {
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("Pb1200 must be at CPLD rev4. Please have Pb1200\n");
-		printk("updated to latest revision. This software will not\n");
-		printk("work on anything less than CPLD rev4\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
-		printk("\nWARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "Pb1200 must be at CPLD rev 4. Please have Pb1200\n");
+		printk(KERN_ERR "updated to latest revision. This software will\n");
+		printk(KERN_ERR "not work on anything less than CPLD rev 4.\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
+		printk(KERN_ERR "WARNING!!!\n");
 		panic("Game over.  Your score is 0.");
 	}
 #endif
@@ -161,6 +155,6 @@ void _board_init_irq(void)
 
 	/*
 	 * GPIO_7 can not be hooked here, so it is hooked upon first
-	 * request of any source attached to the cascade
+	 * request of any source attached to the cascade.
 	 */
 }
diff --git a/arch/mips/au1000/pb1500/Makefile b/arch/mips/au1000/pb1500/Makefile
index 97a7308..602f38d 100644
--- a/arch/mips/au1000/pb1500/Makefile
+++ b/arch/mips/au1000/pb1500/Makefile
@@ -1,8 +1,8 @@
 #
-#  Copyright 2000,2001 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Copyright 2000, 2001, 2008 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc. <source@mvista.com>
 #
 # Makefile for the Alchemy Semiconductor Pb1500 board.
+#
 
 lib-y := init.o board_setup.o irqmap.o
diff --git a/arch/mips/au1000/pb1500/board_setup.c b/arch/mips/au1000/pb1500/board_setup.c
index 24c652e..035771c 100644
--- a/arch/mips/au1000/pb1500/board_setup.c
+++ b/arch/mips/au1000/pb1500/board_setup.c
@@ -1,7 +1,6 @@
 /*
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2000, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -32,8 +31,8 @@
 
 void board_reset(void)
 {
-    /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
-    au_writel(0x00000000, 0xAE00001C);
+	/* Hit BCSR.RST_VDDI[SOFT_RESET] */
+	au_writel(0x00000000, PB1500_RST_VDDI);
 }
 
 void __init board_setup(void)
@@ -42,7 +41,7 @@ void __init board_setup(void)
 	u32 sys_freqctrl, sys_clksrc;
 
 	sys_clksrc = sys_freqctrl = pin_func = 0;
-	// set AUX clock to 12MHz * 8 = 96 MHz
+	/* Set AUX clock to 12 MHz * 8 = 96 MHz */
 	au_writel(8, SYS_AUXPLL);
 	au_writel(0, SYS_PINSTATERD);
 	udelay(100);
@@ -51,51 +50,48 @@ void __init board_setup(void)
 
 	/* GPIO201 is input for PCMCIA card detect */
 	/* GPIO203 is input for PCMCIA interrupt request */
-	au_writel(au_readl(GPIO2_DIR) & (u32)(~((1<<1)|(1<<3))), GPIO2_DIR);
+	au_writel(au_readl(GPIO2_DIR) & ~((1 << 1) | (1 << 3)), GPIO2_DIR);
 
-	/* zero and disable FREQ2 */
+	/* Zero and disable FREQ2 */
 	sys_freqctrl = au_readl(SYS_FREQCTRL0);
 	sys_freqctrl &= ~0xFFF00000;
 	au_writel(sys_freqctrl, SYS_FREQCTRL0);
 
 	/* zero and disable USBH/USBD clocks */
 	sys_clksrc = au_readl(SYS_CLKSRC);
-	sys_clksrc &= ~0x00007FE0;
+	sys_clksrc &= ~(SYS_CS_CUD | SYS_CS_DUD | SYS_CS_MUD_MASK |
+			SYS_CS_CUH | SYS_CS_DUH | SYS_CS_MUH_MASK);
 	au_writel(sys_clksrc, SYS_CLKSRC);
 
 	sys_freqctrl = au_readl(SYS_FREQCTRL0);
 	sys_freqctrl &= ~0xFFF00000;
 
 	sys_clksrc = au_readl(SYS_CLKSRC);
-	sys_clksrc &= ~0x00007FE0;
+	sys_clksrc &= ~(SYS_CS_CUD | SYS_CS_DUD | SYS_CS_MUD_MASK |
+			SYS_CS_CUH | SYS_CS_DUH | SYS_CS_MUH_MASK);
 
-	// FREQ2 = aux/2 = 48 MHz
-	sys_freqctrl |= ((0<<22) | (1<<21) | (1<<20));
+	/* FREQ2 = aux/2 = 48 MHz */
+	sys_freqctrl |= (0 << SYS_FC_FRDIV2_BIT) | SYS_FC_FE2 | SYS_FC_FS2;
 	au_writel(sys_freqctrl, SYS_FREQCTRL0);
 
 	/*
 	 * Route 48MHz FREQ2 into USB Host and/or Device
 	 */
-#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
-	sys_clksrc |= ((4<<12) | (0<<11) | (0<<10));
-#endif
+	sys_clksrc |= SYS_CS_MUX_FQ2 << SYS_CS_MUH_BIT;
 	au_writel(sys_clksrc, SYS_CLKSRC);
 
-
-	pin_func = au_readl(SYS_PINFUNC) & (u32)(~0x8000);
-	// 2nd USB port is USB host
-	pin_func |= 0x8000;
+	pin_func = au_readl(SYS_PINFUNC) & ~SYS_PF_USB;
+	/* 2nd USB port is USB host */
+	pin_func |= SYS_PF_USB;
 	au_writel(pin_func, SYS_PINFUNC);
 #endif /* defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE) */
 
-
-
 #ifdef CONFIG_PCI
-	// Setup PCI bus controller
+	/* Setup PCI bus controller */
 	au_writel(0, Au1500_PCI_CMEM);
 	au_writel(0x00003fff, Au1500_CFG_BASE);
 #if defined(__MIPSEB__)
-	au_writel(0xf | (2<<6) | (1<<4), Au1500_PCI_CFG);
+	au_writel(0xf | (2 << 6) | (1 << 4), Au1500_PCI_CFG);
 #else
 	au_writel(0xf, Au1500_PCI_CFG);
 #endif
@@ -112,11 +108,11 @@ void __init board_setup(void)
 
 	/* Enable the RTC if not already enabled */
 	if (!(au_readl(0xac000028) & 0x20)) {
-		printk("enabling clock ...\n");
+		printk(KERN_INFO "enabling clock ...\n");
 		au_writel((au_readl(0xac000028) | 0x20), 0xac000028);
 	}
 	/* Put the clock in BCD mode */
-	if (au_readl(0xac00002C) & 0x4) { /* reg B */
+	if (au_readl(0xac00002c) & 0x4) { /* reg B */
 		au_writel(au_readl(0xac00002c) & ~0x4, 0xac00002c);
 		au_sync();
 	}
diff --git a/arch/mips/au1000/pb1500/init.c b/arch/mips/au1000/pb1500/init.c
index 488507c..49f51e1 100644
--- a/arch/mips/au1000/pb1500/init.c
+++ b/arch/mips/au1000/pb1500/init.c
@@ -1,11 +1,10 @@
 /*
  *
  * BRIEF MODULE DESCRIPTION
- *	PB1500 board setup
+ *	Pb1500 board setup
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -45,16 +44,15 @@ void __init prom_init(void)
 	unsigned char *memsize_str;
 	unsigned long memsize;
 
-	prom_argc = (int) fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg2;
+	prom_argc = (int)fw_arg0;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
 
 	prom_init_cmdline();
 	memsize_str = prom_getenv("memsize");
-	if (!memsize_str) {
+	if (!memsize_str)
 		memsize = 0x04000000;
-	} else {
-		memsize = simple_strtol(memsize_str, NULL, 0);
-	}
+	else
+		memsize = strict_strtol(memsize_str, 0, NULL);
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/pb1500/irqmap.c b/arch/mips/au1000/pb1500/irqmap.c
index 4817ab4..39c4682 100644
--- a/arch/mips/au1000/pb1500/irqmap.c
+++ b/arch/mips/au1000/pb1500/irqmap.c
@@ -31,12 +31,12 @@
 #include <asm/mach-au1x00/au1000.h>
 
 char irq_tab_alchemy[][5] __initdata = {
- [12] = { -1, INTA, INTX, INTX, INTX},   /* IDSEL 12 - HPT370   */
- [13] = { -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot */
+	[12] = { -1, INTA, INTX, INTX, INTX },   /* IDSEL 12 - HPT370	*/
+	[13] = { -1, INTA, INTB, INTC, INTD },   /* IDSEL 13 - PCI slot */
 };
 
 struct au1xxx_irqmap __initdata au1xxx_irq_map[] = {
-	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
diff --git a/arch/mips/au1000/pb1550/Makefile b/arch/mips/au1000/pb1550/Makefile
index aa35bc6..7d8beca 100644
--- a/arch/mips/au1000/pb1550/Makefile
+++ b/arch/mips/au1000/pb1550/Makefile
@@ -1,9 +1,8 @@
 #
-#  Copyright 2000 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Copyright 2000, 2008 MontaVista Software Inc.
+#  Author: MontaVista Software, Inc. <source@mvista.com>
 #
-# Makefile for the Alchemy Semiconductor PB1000 board.
+# Makefile for the Alchemy Semiconductor Pb1550 board.
 #
 
 lib-y := init.o board_setup.o irqmap.o
diff --git a/arch/mips/au1000/pb1550/board_setup.c b/arch/mips/au1000/pb1550/board_setup.c
index 45d6087..0ed76b6 100644
--- a/arch/mips/au1000/pb1550/board_setup.c
+++ b/arch/mips/au1000/pb1550/board_setup.c
@@ -3,9 +3,8 @@
  * BRIEF MODULE DESCRIPTION
  *	Alchemy Pb1550 board setup.
  *
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2000, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -35,15 +34,16 @@
 
 void board_reset(void)
 {
-    /* Hit BCSR.SYSTEM_CONTROL[SW_RST] */
-	au_writew(au_readw(0xAF00001C) & ~(1<<15), 0xAF00001C);
+	/* Hit BCSR.SYSTEM[RESET] */
+	au_writew(au_readw(0xAF00001C) & ~BCSR_SYSTEM_RESET, 0xAF00001C);
 }
 
 void __init board_setup(void)
 {
 	u32 pin_func;
 
-	/* Enable PSC1 SYNC for AC97.  Normaly done in audio driver,
+	/*
+	 * Enable PSC1 SYNC for AC'97.  Normaly done in audio driver,
 	 * but it is board specific code, so put it here.
 	 */
 	pin_func = au_readl(SYS_PINFUNC);
@@ -51,8 +51,8 @@ void __init board_setup(void)
 	pin_func |= SYS_PF_MUST_BE_SET | SYS_PF_PSC1_S1;
 	au_writel(pin_func, SYS_PINFUNC);
 
-	au_writel(0, (u32)bcsr|0x10); /* turn off pcmcia power */
+	au_writel(0, (u32)bcsr | 0x10); /* turn off PCMCIA power */
 	au_sync();
 
-	printk("AMD Alchemy Pb1550 Board\n");
+	printk(KERN_INFO "AMD Alchemy Pb1550 Board\n");
 }
diff --git a/arch/mips/au1000/pb1550/init.c b/arch/mips/au1000/pb1550/init.c
index f6b2fc5..1b5f584 100644
--- a/arch/mips/au1000/pb1550/init.c
+++ b/arch/mips/au1000/pb1550/init.c
@@ -1,11 +1,10 @@
 /*
  *
  * BRIEF MODULE DESCRIPTION
- *	PB1550 board setup
+ *	Pb1550 board setup
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -45,16 +44,15 @@ void __init prom_init(void)
 	unsigned char *memsize_str;
 	unsigned long memsize;
 
-	prom_argc = (int) fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg2;
+	prom_argc = (int)fw_arg0;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
 
 	prom_init_cmdline();
 	memsize_str = prom_getenv("memsize");
-	if (!memsize_str) {
+	if (!memsize_str)
 		memsize = 0x08000000;
-	} else {
-		memsize = simple_strtol(memsize_str, NULL, 0);
-	}
+	else
+		memsize = strict_strtol(memsize_str, 0, NULL);
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/pb1550/irqmap.c b/arch/mips/au1000/pb1550/irqmap.c
index e1dac37..a02a4d1 100644
--- a/arch/mips/au1000/pb1550/irqmap.c
+++ b/arch/mips/au1000/pb1550/irqmap.c
@@ -1,6 +1,6 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	Au1xxx irq map table
+ *	Au1xx0 IRQ map table
  *
  * Copyright 2003 Embedded Edge, LLC
  *		dan@embeddededge.com
@@ -31,8 +31,8 @@
 #include <asm/mach-au1x00/au1000.h>
 
 char irq_tab_alchemy[][5] __initdata = {
- [12] =	{ -1, INTB, INTC, INTD, INTA},   /* IDSEL 12 - PCI slot 2 (left)  */
- [13] =	{ -1, INTA, INTB, INTC, INTD},   /* IDSEL 13 - PCI slot 1 (right) */
+	[12] = { -1, INTB, INTC, INTD, INTA }, /* IDSEL 12 - PCI slot 2 (left)  */
+	[13] = { -1, INTA, INTB, INTC, INTD }, /* IDSEL 13 - PCI slot 1 (right) */
 };
 
 struct au1xxx_irqmap __initdata au1xxx_irq_map[] = {
diff --git a/arch/mips/au1000/xxs1500/Makefile b/arch/mips/au1000/xxs1500/Makefile
index 44d7f70..db3c526 100644
--- a/arch/mips/au1000/xxs1500/Makefile
+++ b/arch/mips/au1000/xxs1500/Makefile
@@ -1,7 +1,6 @@
 #
 #  Copyright 2003 MontaVista Software Inc.
-#  Author: MontaVista Software, Inc.
-#     	ppopov@mvista.com or source@mvista.com
+#  Author: MontaVista Software, Inc. <source@mvista.com>
 #
 # Makefile for MyCable XXS1500 board.
 #
diff --git a/arch/mips/au1000/xxs1500/board_setup.c b/arch/mips/au1000/xxs1500/board_setup.c
index 79d1798..4c587ac 100644
--- a/arch/mips/au1000/xxs1500/board_setup.c
+++ b/arch/mips/au1000/xxs1500/board_setup.c
@@ -1,7 +1,6 @@
 /*
- * Copyright 2000-2003 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2000-2003, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -39,40 +38,40 @@ void __init board_setup(void)
 {
 	u32 pin_func;
 
-	// set multiple use pins (UART3/GPIO) to UART (it's used as UART too)
-	pin_func = au_readl(SYS_PINFUNC) & (u32)(~SYS_PF_UR3);
+	/* Set multiple use pins (UART3/GPIO) to UART (it's used as UART too) */
+	pin_func  = au_readl(SYS_PINFUNC) & ~SYS_PF_UR3;
 	pin_func |= SYS_PF_UR3;
 	au_writel(pin_func, SYS_PINFUNC);
 
-	// enable UART
-	au_writel(0x01, UART3_ADDR+UART_MOD_CNTRL); // clock enable (CE)
+	/* Enable UART */
+	au_writel(0x01, UART3_ADDR + UART_MOD_CNTRL); /* clock enable (CE) */
 	mdelay(10);
-	au_writel(0x03, UART3_ADDR+UART_MOD_CNTRL); // CE and "enable"
+	au_writel(0x03, UART3_ADDR + UART_MOD_CNTRL); /* CE and "enable" */
 	mdelay(10);
 
-	// enable DTR = USB power up
-	au_writel(0x01, UART3_ADDR+UART_MCR); //? UART_MCR_DTR is 0x01???
+	/* Enable DTR = USB power up */
+	au_writel(0x01, UART3_ADDR + UART_MCR); /* UART_MCR_DTR is 0x01??? */
 
 #ifdef CONFIG_PCMCIA_XXS1500
-	/* setup pcmcia signals */
+	/* Setup PCMCIA signals */
 	au_writel(0, SYS_PININPUTEN);
 
-	/* gpio 0, 1, and 4 are inputs */
-	au_writel(1 | (1<<1) | (1<<4), SYS_TRIOUTCLR);
+	/* GPIO 0, 1, and 4 are inputs */
+	au_writel(1 | (1 << 1) | (1 << 4), SYS_TRIOUTCLR);
 
-	/* enable GPIO2 if not already enabled */
+	/* Enable GPIO2 if not already enabled */
 	au_writel(1, GPIO2_ENABLE);
-	/* gpio2 208/9/10/11 are inputs */
-	au_writel((1<<8) | (1<<9) | (1<<10) | (1<<11), GPIO2_DIR);
+	/* GPIO2 208/9/10/11 are inputs */
+	au_writel((1 << 8) | (1 << 9) | (1 << 10) | (1 << 11), GPIO2_DIR);
 
-	/* turn off power */
-	au_writel((au_readl(GPIO2_PINSTATE) & ~(1<<14))|(1<<30), GPIO2_OUTPUT);
+	/* Turn off power */
+	au_writel((au_readl(GPIO2_PINSTATE) & ~(1 << 14)) | (1 << 30),
+		  GPIO2_OUTPUT);
 #endif
 
-
 #ifdef CONFIG_PCI
 #if defined(__MIPSEB__)
-	au_writel(0xf | (2<<6) | (1<<4), Au1500_PCI_CFG);
+	au_writel(0xf | (2 << 6) | (1 << 4), Au1500_PCI_CFG);
 #else
 	au_writel(0xf, Au1500_PCI_CFG);
 #endif
diff --git a/arch/mips/au1000/xxs1500/init.c b/arch/mips/au1000/xxs1500/init.c
index 24fc6e1..b849bf5 100644
--- a/arch/mips/au1000/xxs1500/init.c
+++ b/arch/mips/au1000/xxs1500/init.c
@@ -2,9 +2,8 @@
  * BRIEF MODULE DESCRIPTION
  *	XXS1500 board setup
  *
- * Copyright 2003 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2003, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -45,8 +44,8 @@ void __init prom_init(void)
 	unsigned long memsize;
 
 	prom_argc = fw_arg0;
-	prom_argv = (char **) fw_arg1;
-	prom_envp = (char **) fw_arg2;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
 
 	prom_init_cmdline();
 
@@ -54,6 +53,6 @@ void __init prom_init(void)
 	if (!memsize_str)
 		memsize = 0x04000000;
 	else
-		memsize = simple_strtol(memsize_str, NULL, 0);
+		memsize = strict_strtol(memsize_str, 0, NULL);
 	add_memory_region(0, memsize, BOOT_MEM_RAM);
 }
diff --git a/arch/mips/au1000/xxs1500/irqmap.c b/arch/mips/au1000/xxs1500/irqmap.c
index dd6e3d1..edf06ed 100644
--- a/arch/mips/au1000/xxs1500/irqmap.c
+++ b/arch/mips/au1000/xxs1500/irqmap.c
@@ -31,7 +31,7 @@
 #include <asm/mach-au1x00/au1000.h>
 
 struct au1xxx_irqmap __initdata au1xxx_irq_map[] = {
-	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0},
+	{ AU1500_GPIO_204, INTC_INT_HIGH_LEVEL, 0 },
 	{ AU1500_GPIO_201, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_202, INTC_INT_LOW_LEVEL, 0 },
 	{ AU1500_GPIO_203, INTC_INT_LOW_LEVEL, 0 },
diff --git a/arch/mips/emma2rh/markeins/setup.c b/arch/mips/emma2rh/markeins/setup.c
index 82f9e90..62bfb45 100644
--- a/arch/mips/emma2rh/markeins/setup.c
+++ b/arch/mips/emma2rh/markeins/setup.c
@@ -76,7 +76,9 @@ static void markeins_machine_power_off(void)
 	while (1) ;
 }
 
-static unsigned long clock[4] = { 166500000, 187312500, 199800000, 210600000 };
+static unsigned long __initdata emma2rh_clock[4] = {
+	166500000, 187312500, 199800000, 210600000
+};
 
 static unsigned int __init detect_bus_frequency(unsigned long rtc_base)
 {
@@ -85,7 +87,8 @@ static unsigned int __init detect_bus_frequency(unsigned long rtc_base)
 	/* detect from boot strap */
 	reg = emma2rh_in32(EMMA2RH_BHIF_STRAP_0);
 	reg = (reg >> 4) & 0x3;
-	return clock[reg];
+
+	return emma2rh_clock[reg];
 }
 
 void __init plat_time_init(void)
diff --git a/arch/mips/kernel/Makefile b/arch/mips/kernel/Makefile
index 45545be..cc02440 100644
--- a/arch/mips/kernel/Makefile
+++ b/arch/mips/kernel/Makefile
@@ -56,9 +56,9 @@ obj-$(CONFIG_MIPS_MT_SMP)	+= smp-mt.o
 obj-$(CONFIG_MIPS_CMP)		+= smp-cmp.o
 obj-$(CONFIG_CPU_MIPSR2)	+= spram.o
 
-obj-$(CONFIG_MIPS_APSP_KSPD)	+= kspd.o
 obj-$(CONFIG_MIPS_VPE_LOADER)	+= vpe.o
 obj-$(CONFIG_MIPS_VPE_APSP_API)	+= rtlx.o
+obj-$(CONFIG_MIPS_APSP_KSPD)	+= kspd.o
 
 obj-$(CONFIG_I8259)		+= i8259.o
 obj-$(CONFIG_IRQ_CPU)		+= irq_cpu.o
diff --git a/arch/mips/kernel/cpu-bugs64.c b/arch/mips/kernel/cpu-bugs64.c
index a1b48af..02b7713 100644
--- a/arch/mips/kernel/cpu-bugs64.c
+++ b/arch/mips/kernel/cpu-bugs64.c
@@ -38,7 +38,7 @@ static inline void align_mod(const int align, const int mod)
 		".endr\n\t"
 		".set	pop"
 		:
-		: GCC_IMM_ASM(align), GCC_IMM_ASM(mod));
+		: GCC_IMM_ASM() (align), GCC_IMM_ASM() (mod));
 }
 
 static inline void mult_sh_align_mod(long *v1, long *v2, long *w,
diff --git a/arch/mips/kernel/irixelf.c b/arch/mips/kernel/irixelf.c
index 290d8e3..469c723 100644
--- a/arch/mips/kernel/irixelf.c
+++ b/arch/mips/kernel/irixelf.c
@@ -578,7 +578,7 @@ static inline int map_interpreter(struct elf_phdr *epp, struct elfhdr *ihp,
  * process and the system, here we map the page and fill the
  * structure
  */
-static void irix_map_prda_page(void)
+static int irix_map_prda_page(void)
 {
 	unsigned long v;
 	struct prda *pp;
@@ -587,8 +587,8 @@ static void irix_map_prda_page(void)
 	v =  do_brk(PRDA_ADDRESS, PAGE_SIZE);
 	up_write(&current->mm->mmap_sem);
 
-	if (v < 0)
-		return;
+	if (v != PRDA_ADDRESS)
+		return v;		/* v must be an error code */
 
 	pp = (struct prda *) v;
 	pp->prda_sys.t_pid  = task_pid_vnr(current);
@@ -596,6 +596,8 @@ static void irix_map_prda_page(void)
 	pp->prda_sys.t_rpid = task_pid_vnr(current);
 
 	/* We leave the rest set to zero */
+
+	return 0;
 }
 
 
@@ -781,7 +783,8 @@ static int load_irix_binary(struct linux_binprm * bprm, struct pt_regs * regs)
 	 * IRIX maps a page at 0x200000 which holds some system
 	 * information.  Programs depend on this.
 	 */
-	irix_map_prda_page();
+	if (irix_map_prda_page())
+		goto out_free_dentry;
 
 	padzero(elf_bss);
 
diff --git a/arch/mips/kernel/kspd.c b/arch/mips/kernel/kspd.c
index ceb62dc..b0591ae 100644
--- a/arch/mips/kernel/kspd.c
+++ b/arch/mips/kernel/kspd.c
@@ -257,7 +257,7 @@ void sp_work_handle_request(void)
 
 		vcwd = vpe_getcwd(tclimit);
 
- 		/* change to the cwd of the process that loaded the SP program */
+		/* change to cwd of the process that loaded the SP program */
 		old_fs = get_fs();
 		set_fs(KERNEL_DS);
 		sys_chdir(vcwd);
@@ -323,6 +323,9 @@ static void sp_cleanup(void)
 			set >>= 1;
 		}
 	}
+
+	/* Put daemon cwd back to root to avoid umount problems */
+	sys_chdir("/");
 }
 
 static int channel_open = 0;
diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 0233798..b88f1c1 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -72,6 +72,15 @@ static void rtlx_dispatch(void)
 static irqreturn_t rtlx_interrupt(int irq, void *dev_id)
 {
 	int i;
+	unsigned int flags, vpeflags;
+
+	/* Ought not to be strictly necessary for SMTC builds */
+	local_irq_save(flags);
+	vpeflags = dvpe();
+	set_c0_status(0x100 << MIPS_CPU_RTLX_IRQ);
+	irq_enable_hazard();
+	evpe(vpeflags);
+	local_irq_restore(flags);
 
 	for (i = 0; i < RTLX_CHANNELS; i++) {
 			wake_up(&channel_wqs[i].lx_queue);
@@ -108,7 +117,8 @@ static void __used dump_rtlx(void)
 static int rtlx_init(struct rtlx_info *rtlxi)
 {
 	if (rtlxi->id != RTLX_ID) {
-		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%lx\n", rtlxi, rtlxi->id);
+		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%lx\n",
+			rtlxi, rtlxi->id);
 		return -ENOEXEC;
 	}
 
@@ -162,18 +172,17 @@ int rtlx_open(int index, int can_sleep)
 
 	if (rtlx == NULL) {
 		if( (p = vpe_get_shared(tclimit)) == NULL) {
-			if (can_sleep) {
-				__wait_event_interruptible(channel_wqs[index].lx_queue,
-				                           (p = vpe_get_shared(tclimit)),
-				                           ret);
-				if (ret)
-					goto out_fail;
-			} else {
-				printk(KERN_DEBUG "No SP program loaded, and device "
-					"opened with O_NONBLOCK\n");
-				ret = -ENOSYS;
+		    if (can_sleep) {
+			__wait_event_interruptible(channel_wqs[index].lx_queue,
+				(p = vpe_get_shared(tclimit)), ret);
+			if (ret)
 				goto out_fail;
-			}
+		    } else {
+			printk(KERN_DEBUG "No SP program loaded, and device "
+					"opened with O_NONBLOCK\n");
+			ret = -ENOSYS;
+			goto out_fail;
+		    }
 		}
 
 		smp_rmb();
@@ -182,7 +191,9 @@ int rtlx_open(int index, int can_sleep)
 				DEFINE_WAIT(wait);
 
 				for (;;) {
-					prepare_to_wait(&channel_wqs[index].lx_queue, &wait, TASK_INTERRUPTIBLE);
+					prepare_to_wait(
+						&channel_wqs[index].lx_queue,
+						&wait, TASK_INTERRUPTIBLE);
 					smp_rmb();
 					if (*p != NULL)
 						break;
@@ -195,7 +206,7 @@ int rtlx_open(int index, int can_sleep)
 				}
 				finish_wait(&channel_wqs[index].lx_queue, &wait);
 			} else {
-				printk(" *vpe_get_shared is NULL. "
+				pr_err(" *vpe_get_shared is NULL. "
 				       "Has an SP program been loaded?\n");
 				ret = -ENOSYS;
 				goto out_fail;
@@ -203,8 +214,9 @@ int rtlx_open(int index, int can_sleep)
 		}
 
 		if ((unsigned int)*p < KSEG0) {
-			printk(KERN_WARNING "vpe_get_shared returned an invalid pointer "
-			       "maybe an error code %d\n", (int)*p);
+			printk(KERN_WARNING "vpe_get_shared returned an "
+			       "invalid pointer maybe an error code %d\n",
+			       (int)*p);
 			ret = -ENOSYS;
 			goto out_fail;
 		}
@@ -232,6 +244,10 @@ out_ret:
 
 int rtlx_release(int index)
 {
+	if (rtlx == NULL) {
+		pr_err("rtlx_release() with null rtlx\n");
+		return 0;
+	}
 	rtlx->channel[index].lx_state = RTLX_STATE_UNUSED;
 	return 0;
 }
@@ -251,8 +267,8 @@ unsigned int rtlx_read_poll(int index, int can_sleep)
 			int ret = 0;
 
 			__wait_event_interruptible(channel_wqs[index].lx_queue,
-			                           chan->lx_read != chan->lx_write || sp_stopping,
-			                           ret);
+				(chan->lx_read != chan->lx_write) ||
+				sp_stopping, ret);
 			if (ret)
 				return ret;
 
@@ -282,7 +298,9 @@ static inline int write_spacefree(int read, int write, int size)
 unsigned int rtlx_write_poll(int index)
 {
 	struct rtlx_channel *chan = &rtlx->channel[index];
-	return write_spacefree(chan->rt_read, chan->rt_write, chan->buffer_size);
+
+	return write_spacefree(chan->rt_read, chan->rt_write,
+				chan->buffer_size);
 }
 
 ssize_t rtlx_read(int index, void __user *buff, size_t count)
@@ -344,8 +362,8 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 	rt_read = rt->rt_read;
 
 	/* total number of bytes to copy */
-	count = min(count,
-		    (size_t)write_spacefree(rt_read, rt->rt_write, rt->buffer_size));
+	count = min(count, (size_t)write_spacefree(rt_read, rt->rt_write,
+							rt->buffer_size));
 
 	/* first bit from write pointer to the end of the buffer, or count */
 	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
@@ -514,6 +532,11 @@ static int __init rtlx_module_init(void)
 
 	if (cpu_has_vint)
 		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
+	else {
+		pr_err("APRP RTLX init on non-vectored-interrupt processor\n");
+		err = -ENODEV;
+		goto out_chrdev;
+	}
 
 	rtlx_irq.dev_id = rtlx;
 	setup_irq(rtlx_irq_num, &rtlx_irq);
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 39f3dfe..c6a063b 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -331,6 +331,7 @@ static void __init bootmem_init(void)
 	/*
 	 * Determine low and high memory ranges
 	 */
+	max_pfn = max_low_pfn;
 	if (max_low_pfn > PFN_DOWN(HIGHMEM_START)) {
 #ifdef CONFIG_HIGHMEM
 		highstart_pfn = PFN_DOWN(HIGHMEM_START);
diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c
index 33780cc..63370cd 100644
--- a/arch/mips/kernel/smp.c
+++ b/arch/mips/kernel/smp.c
@@ -87,8 +87,8 @@ struct plat_smp_ops *mp_ops;
 
 __cpuinit void register_smp_ops(struct plat_smp_ops *ops)
 {
-	if (ops)
-		printk(KERN_WARNING "Overriding previous set SMP ops\n");
+	if (mp_ops)
+		printk(KERN_WARNING "Overriding previously set SMP ops\n");
 
 	mp_ops = ops;
 }
diff --git a/arch/mips/kernel/vpe.c b/arch/mips/kernel/vpe.c
index 39804c5..2794501 100644
--- a/arch/mips/kernel/vpe.c
+++ b/arch/mips/kernel/vpe.c
@@ -269,7 +269,7 @@ static void *alloc_progmem(unsigned long len)
 	 * This means you must tell Linux to use less memory than you
 	 * physically have, for example by passing a mem= boot argument.
 	 */
-	addr = pfn_to_kaddr(max_pfn);
+	addr = pfn_to_kaddr(max_low_pfn);
 	memset(addr, 0, len);
 #else
 	/* simple grab some mem for now */
@@ -781,10 +781,15 @@ static int vpe_run(struct vpe * v)
 	/* take system out of configuration state */
 	clear_c0_mvpcontrol(MVPCONTROL_VPC);
 
+	/*
+	 * SMTC/SMVP kernels manage VPE enable independently,
+	 * but uniprocessor kernels need to turn it on, even
+	 * if that wasn't the pre-dvpe() state.
+	 */
 #ifdef CONFIG_SMP
-	evpe(EVPE_ENABLE);
-#else
 	evpe(vpeflags);
+#else
+	evpe(EVPE_ENABLE);
 #endif
 	emt(dmt_flag);
 	local_irq_restore(flags);
@@ -840,7 +845,7 @@ static int vpe_elfload(struct vpe * v)
 
 	/* Sanity checks against insmoding binaries or wrong arch,
 	   weird elf version */
-	if (memcmp(hdr->e_ident, ELFMAG, 4) != 0
+	if (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0
 	    || (hdr->e_type != ET_REL && hdr->e_type != ET_EXEC)
 	    || !elf_check_arch(hdr)
 	    || hdr->e_shentsize != sizeof(*sechdrs)) {
@@ -947,12 +952,14 @@ static int vpe_elfload(struct vpe * v)
 		struct elf_phdr *phdr = (struct elf_phdr *) ((char *)hdr + hdr->e_phoff);
 
 		for (i = 0; i < hdr->e_phnum; i++) {
-			if (phdr->p_type != PT_LOAD)
-				continue;
-
-			memcpy((void *)phdr->p_paddr, (char *)hdr + phdr->p_offset, phdr->p_filesz);
-			memset((void *)phdr->p_paddr + phdr->p_filesz, 0, phdr->p_memsz - phdr->p_filesz);
-			phdr++;
+			if (phdr->p_type == PT_LOAD) {
+				memcpy((void *)phdr->p_paddr,
+				       (char *)hdr + phdr->p_offset,
+				       phdr->p_filesz);
+				memset((void *)phdr->p_paddr + phdr->p_filesz,
+				       0, phdr->p_memsz - phdr->p_filesz);
+		    }
+		    phdr++;
 		}
 
 		for (i = 0; i < hdr->e_shnum; i++) {
@@ -1107,7 +1114,7 @@ static int vpe_release(struct inode *inode, struct file *filp)
 		return -ENODEV;
 
 	hdr = (Elf_Ehdr *) v->pbuffer;
-	if (memcmp(hdr->e_ident, ELFMAG, 4) == 0) {
+	if (memcmp(hdr->e_ident, ELFMAG, SELFMAG) == 0) {
 		if (vpe_elfload(v) >= 0) {
 			vpe_run(v);
 		} else {
diff --git a/arch/mips/mm/highmem.c b/arch/mips/mm/highmem.c
index 10dd2af..8f2cd8e 100644
--- a/arch/mips/mm/highmem.c
+++ b/arch/mips/mm/highmem.c
@@ -116,4 +116,3 @@ EXPORT_SYMBOL(__kmap);
 EXPORT_SYMBOL(__kunmap);
 EXPORT_SYMBOL(__kmap_atomic);
 EXPORT_SYMBOL(__kunmap_atomic);
-EXPORT_SYMBOL(__kmap_atomic_to_page);
diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index da8cbb6..b40df7d 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -281,7 +281,7 @@ static inline int n_counters(void)
 
 static void reset_counters(void *arg)
 {
-	int counters = (int)arg;
+	int counters = (int)(long)arg;
 	switch (counters) {
 	case 4:
 		w_c0_perfctrl3(0);
@@ -313,7 +313,7 @@ static int __init mipsxx_init(void)
 	if (!cpu_has_mipsmt_pertccounters)
 		counters = counters_total_to_per_cpu(counters);
 #endif
-	on_each_cpu(reset_counters, (void *)counters, 0, 1);
+	on_each_cpu(reset_counters, (void *)(long)counters, 0, 1);
 
 	op_model_mipsxx_ops.num_counters = counters;
 	switch (current_cpu_type()) {
@@ -382,7 +382,7 @@ static void mipsxx_exit(void)
 	int counters = op_model_mipsxx_ops.num_counters;
 
 	counters = counters_per_cpu_to_total(counters);
-	on_each_cpu(reset_counters, (void *)counters, 0, 1);
+	on_each_cpu(reset_counters, (void *)(long)counters, 0, 1);
 
 	perf_irq = save_perf_irq;
 }
diff --git a/arch/mips/pci/fixup-au1000.c b/arch/mips/pci/fixup-au1000.c
index 00c36c9..e2ddfc4 100644
--- a/arch/mips/pci/fixup-au1000.c
+++ b/arch/mips/pci/fixup-au1000.c
@@ -1,10 +1,9 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	Board specific pci fixups.
+ *	Board specific PCI fixups.
  *
- * Copyright 2001-2003 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001-2003, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
diff --git a/arch/mips/pci/ops-au1000.c b/arch/mips/pci/ops-au1000.c
index 1314bd5..9a57c5a 100644
--- a/arch/mips/pci/ops-au1000.c
+++ b/arch/mips/pci/ops-au1000.c
@@ -1,10 +1,9 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	Alchemy/AMD Au1x00 PCI support.
+ *	Alchemy/AMD Au1xx0 PCI support.
  *
- * Copyright 2001-2003, 2007 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001-2003, 2007-2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  Support for all devices (greater than 16) added by David Gathright.
  *
@@ -28,6 +27,7 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
+
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
@@ -36,9 +36,9 @@
 
 #include <asm/mach-au1x00/au1000.h>
 
-#undef DEBUG
-#ifdef DEBUG
-#define DBG(x...) printk(x)
+#undef	DEBUG
+#ifdef	DEBUG
+#define DBG(x...) printk(KERN_DEBUG x)
 #else
 #define DBG(x...)
 #endif
@@ -46,7 +46,6 @@
 #define PCI_ACCESS_READ  0
 #define PCI_ACCESS_WRITE 1
 
-
 int (*board_pci_idsel)(unsigned int devsel, int assert);
 
 void mod_wired_entry(int entry, unsigned long entrylo0,
@@ -92,10 +91,9 @@ void __init au1x_pci_cfg_init(void)
 }
 
 static int config_access(unsigned char access_type, struct pci_bus *bus,
-			 unsigned int dev_fn, unsigned char where,
-			 u32 * data)
+			 unsigned int dev_fn, unsigned char where, u32 *data)
 {
-#if defined( CONFIG_SOC_AU1500 ) || defined( CONFIG_SOC_AU1550 )
+#if defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 	unsigned int device = PCI_SLOT(dev_fn);
 	unsigned int function = PCI_FUNC(dev_fn);
 	unsigned long offset, status;
@@ -114,38 +112,36 @@ static int config_access(unsigned char access_type, struct pci_bus *bus,
 			Au1500_PCI_STATCMD);
 	au_sync_udelay(1);
 
-	/* Allow board vendors to implement their own off-chip idsel.
+	/*
+	 * Allow board vendors to implement their own off-chip IDSEL.
 	 * If it doesn't succeed, may as well bail out at this point.
 	 */
-	if (board_pci_idsel) {
-		if (board_pci_idsel(device, 1) == 0) {
-			*data = 0xffffffff;
-			local_irq_restore(flags);
-			return -1;
-		}
+	if (board_pci_idsel && board_pci_idsel(device, 1) == 0) {
+		*data = 0xffffffff;
+		local_irq_restore(flags);
+		return -1;
 	}
 
-        /* setup the config window */
-        if (bus->number == 0) {
-                cfg_base = ((1<<device)<<11);
-        } else {
-                cfg_base = 0x80000000 | (bus->number<<16) | (device<<11);
-        }
+	/* Setup the config window */
+	if (bus->number == 0)
+		cfg_base = (1 << device) << 11;
+	else
+		cfg_base = 0x80000000 | (bus->number << 16) | (device << 11);
 
-        /* setup the lower bits of the 36 bit address */
-        offset = (function << 8) | (where & ~0x3);
-	/* pick up any address that falls below the page mask */
+	/* Setup the lower bits of the 36-bit address */
+	offset = (function << 8) | (where & ~0x3);
+	/* Pick up any address that falls below the page mask */
 	offset |= cfg_base & ~PAGE_MASK;
 
-	/* page boundary */
+	/* Page boundary */
 	cfg_base = cfg_base & PAGE_MASK;
 
 	/*
 	 * To improve performance, if the current device is the same as
 	 * the last device accessed, we don't touch the TLB.
 	 */
-	entryLo0 = (6 << 26)  | (cfg_base >> 6) | (2 << 3) | 7;
-	entryLo1 = (6 << 26)  | (cfg_base >> 6) | (0x1000 >> 6) | (2 << 3) | 7;
+	entryLo0 = (6 << 26) | (cfg_base >> 6) | (2 << 3) | 7;
+	entryLo1 = (6 << 26) | (cfg_base >> 6) | (0x1000 >> 6) | (2 << 3) | 7;
 	if ((entryLo0 != last_entryLo0) || (entryLo1 != last_entryLo1)) {
 		mod_wired_entry(pci_cfg_wired_entry, entryLo0, entryLo1,
 				(unsigned long)pci_cfg_vm->addr, PM_4K);
@@ -153,38 +149,37 @@ static int config_access(unsigned char access_type, struct pci_bus *bus,
 		last_entryLo1 = entryLo1;
 	}
 
-	if (access_type == PCI_ACCESS_WRITE) {
+	if (access_type == PCI_ACCESS_WRITE)
 		au_writel(*data, (int)(pci_cfg_vm->addr + offset));
-	} else {
+	else
 		*data = au_readl((int)(pci_cfg_vm->addr + offset));
-	}
+
 	au_sync_udelay(2);
 
-	DBG("cfg_access %d bus->number %d dev %d at %x *data %x conf %x\n",
-			access_type, bus->number, device, where, *data, offset);
+	DBG("cfg_access %d bus->number %u dev %u at %x *data %x conf %lx\n",
+	    access_type, bus->number, device, where, *data, offset);
 
-	/* check master abort */
+	/* Check master abort */
 	status = au_readl(Au1500_PCI_STATCMD);
 
-	if (status & (1<<29)) {
+	if (status & (1 << 29)) {
 		*data = 0xffffffff;
 		error = -1;
 		DBG("Au1x Master Abort\n");
 	} else if ((status >> 28) & 0xf) {
-		DBG("PCI ERR detected: device %d, status %x\n", device, ((status >> 28) & 0xf));
+		DBG("PCI ERR detected: device %u, status %lx\n",
+		    device, (status >> 28) & 0xf);
 
-		/* clear errors */
+		/* Clear errors */
 		au_writel(status & 0xf000ffff, Au1500_PCI_STATCMD);
 
 		*data = 0xffffffff;
 		error = -1;
 	}
 
-	/* Take away the idsel.
-	*/
-	if (board_pci_idsel) {
+	/* Take away the IDSEL. */
+	if (board_pci_idsel)
 		(void)board_pci_idsel(device, 0);
-	}
 
 	local_irq_restore(flags);
 	return error;
@@ -192,7 +187,7 @@ static int config_access(unsigned char access_type, struct pci_bus *bus,
 }
 
 static int read_config_byte(struct pci_bus *bus, unsigned int devfn,
-			    int where, u8 * val)
+			    int where,	u8 *val)
 {
 	u32 data;
 	int ret;
@@ -206,9 +201,8 @@ static int read_config_byte(struct pci_bus *bus, unsigned int devfn,
 	return ret;
 }
 
-
 static int read_config_word(struct pci_bus *bus, unsigned int devfn,
-			    int where, u16 * val)
+			    int where, u16 *val)
 {
 	u32 data;
 	int ret;
@@ -221,7 +215,7 @@ static int read_config_word(struct pci_bus *bus, unsigned int devfn,
 }
 
 static int read_config_dword(struct pci_bus *bus, unsigned int devfn,
-			     int where, u32 * val)
+			     int where, u32 *val)
 {
 	int ret;
 
@@ -229,9 +223,8 @@ static int read_config_dword(struct pci_bus *bus, unsigned int devfn,
 	return ret;
 }
 
-static int
-write_config_byte(struct pci_bus *bus, unsigned int devfn, int where,
-		  u8 val)
+static int write_config_byte(struct pci_bus *bus, unsigned int devfn,
+			     int where, u8 val)
 {
 	u32 data = 0;
 
@@ -239,7 +232,7 @@ write_config_byte(struct pci_bus *bus, unsigned int devfn, int where,
 		return -1;
 
 	data = (data & ~(0xff << ((where & 3) << 3))) |
-	    (val << ((where & 3) << 3));
+	       (val << ((where & 3) << 3));
 
 	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
 		return -1;
@@ -247,9 +240,8 @@ write_config_byte(struct pci_bus *bus, unsigned int devfn, int where,
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int
-write_config_word(struct pci_bus *bus, unsigned int devfn, int where,
-		  u16 val)
+static int write_config_word(struct pci_bus *bus, unsigned int devfn,
+			     int where, u16 val)
 {
 	u32 data = 0;
 
@@ -257,18 +249,16 @@ write_config_word(struct pci_bus *bus, unsigned int devfn, int where,
 		return -1;
 
 	data = (data & ~(0xffff << ((where & 3) << 3))) |
-	    (val << ((where & 3) << 3));
+	       (val << ((where & 3) << 3));
 
 	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &data))
 		return -1;
 
-
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int
-write_config_dword(struct pci_bus *bus, unsigned int devfn, int where,
-		   u32 val)
+static int write_config_dword(struct pci_bus *bus, unsigned int devfn,
+			      int where, u32 val)
 {
 	if (config_access(PCI_ACCESS_WRITE, bus, devfn, where, &val))
 		return -1;
@@ -277,18 +267,20 @@ write_config_dword(struct pci_bus *bus, unsigned int devfn, int where,
 }
 
 static int config_read(struct pci_bus *bus, unsigned int devfn,
-		       int where, int size, u32 * val)
+		       int where, int size, u32 *val)
 {
 	switch (size) {
 	case 1: {
 			u8 _val;
 			int rc = read_config_byte(bus, devfn, where, &_val);
+
 			*val = _val;
 			return rc;
 		}
-       case 2: {
+	case 2: {
 			u16 _val;
 			int rc = read_config_word(bus, devfn, where, &_val);
+
 			*val = _val;
 			return rc;
 		}
@@ -310,7 +302,6 @@ static int config_write(struct pci_bus *bus, unsigned int devfn,
 	}
 }
 
-
 struct pci_ops au1x_pci_ops = {
 	config_read,
 	config_write
diff --git a/arch/mips/pmc-sierra/msp71xx/msp_hwbutton.c b/arch/mips/pmc-sierra/msp71xx/msp_hwbutton.c
index ab96a2d..11769b5 100644
--- a/arch/mips/pmc-sierra/msp71xx/msp_hwbutton.c
+++ b/arch/mips/pmc-sierra/msp71xx/msp_hwbutton.c
@@ -126,9 +126,6 @@ static irqreturn_t hwbutton_handler(int irq, void *data)
 	struct hwbutton_interrupt *hirq = data;
 	unsigned long cic_ext = *CIC_EXT_CFG_REG;
 
-	if (irq != hirq->irq)
-		return IRQ_NONE;
-
 	if (CIC_EXT_IS_ACTIVE_HI(cic_ext, hirq->eirq)) {
 		/* Interrupt: pin is now HI */
 		CIC_EXT_SET_ACTIVE_LO(cic_ext, hirq->eirq);
@@ -164,7 +161,7 @@ static int msp_hwbutton_register(struct hwbutton_interrupt *hirq)
 	*CIC_EXT_CFG_REG = cic_ext;
 
 	return request_irq(hirq->irq, hwbutton_handler, IRQF_DISABLED,
-				hirq->name, (void *)hirq);
+			   hirq->name, hirq);
 }
 
 static int __init msp_hwbutton_setup(void)
diff --git a/arch/mips/sgi-ip27/ip27-timer.c b/arch/mips/sgi-ip27/ip27-timer.c
index 25d3baf..9cebc9e 100644
--- a/arch/mips/sgi-ip27/ip27-timer.c
+++ b/arch/mips/sgi-ip27/ip27-timer.c
@@ -158,7 +158,7 @@ static void rt_set_mode(enum clock_event_mode mode,
 	}
 }
 
-unsigned int rt_timer_irq;
+int rt_timer_irq;
 
 static irqreturn_t hub_rt_counter_handler(int irq, void *dev_id)
 {
@@ -219,7 +219,7 @@ static void __cpuinit hub_rt_clock_event_init(void)
 
 static void __init hub_rt_clock_event_global_init(void)
 {
-	unsigned int irq;
+	int irq;
 
 	do {
 		smp_wmb();
diff --git a/arch/powerpc/kernel/Makefile b/arch/powerpc/kernel/Makefile
index d14cebf..2346d27 100644
--- a/arch/powerpc/kernel/Makefile
+++ b/arch/powerpc/kernel/Makefile
@@ -105,6 +105,9 @@ PHONY += systbl_chk
 systbl_chk: $(src)/systbl_chk.sh $(obj)/systbl_chk.i
 	$(call cmd,systbl_chk)
 
+
+ifeq ($(CONFIG_PPC_MERGE),y)
+
 $(obj)/built-in.o:		prom_init_check
 
 quiet_cmd_prom_init_check = CALL    $<
@@ -114,4 +117,7 @@ PHONY += prom_init_check
 prom_init_check: $(src)/prom_init_check.sh $(obj)/prom_init.o
 	$(call cmd,prom_init_check)
 
+endif
+
+
 clean-files := vmlinux.lds
diff --git a/arch/powerpc/kernel/cputable.c b/arch/powerpc/kernel/cputable.c
index 81738a4..e44d553 100644
--- a/arch/powerpc/kernel/cputable.c
+++ b/arch/powerpc/kernel/cputable.c
@@ -1484,6 +1484,7 @@ static struct cpu_spec __initdata cpu_specs[] = {
 		.dcache_bsize		= 32,
 		.machine_check		= machine_check_e200,
 		.platform		= "ppc5554",
+	}
 #endif /* CONFIG_E200 */
 #ifdef CONFIG_E500
 	{	/* e500 */
@@ -1533,6 +1534,7 @@ static struct cpu_spec __initdata cpu_specs[] = {
 		.dcache_bsize		= 32,
 		.machine_check		= machine_check_e500,
 		.platform		= "powerpc",
+	}
 #endif /* CONFIG_E500 */
 #endif /* CONFIG_PPC32 */
 };
diff --git a/arch/powerpc/lib/Makefile b/arch/powerpc/lib/Makefile
index f1d2cdc..c71d37d 100644
--- a/arch/powerpc/lib/Makefile
+++ b/arch/powerpc/lib/Makefile
@@ -10,6 +10,7 @@ ifeq ($(CONFIG_PPC_MERGE),y)
 obj-y			:= string.o alloc.o \
 			   checksum_$(CONFIG_WORD_SIZE).o
 obj-$(CONFIG_PPC32)	+= div64.o copy_32.o
+obj-$(CONFIG_HAS_IOMEM)	+= devres.o
 endif
 
 obj-$(CONFIG_PPC64)	+= copypage_64.o copyuser_64.o \
@@ -23,4 +24,3 @@ obj-$(CONFIG_SMP)	+= locks.o
 endif
 
 obj-$(CONFIG_PPC_LIB_RHEAP) += rheap.o
-obj-$(CONFIG_HAS_IOMEM)	+= devres.o
diff --git a/arch/ppc/Makefile b/arch/ppc/Makefile
index 8df7f0e..2352d13 100644
--- a/arch/ppc/Makefile
+++ b/arch/ppc/Makefile
@@ -43,7 +43,7 @@ KBUILD_AFLAGS += $(cpu-as-y)
 KBUILD_CFLAGS += $(cpu-as-y)
 
 # Default to the common case.
-KBUILD_DEFCONFIG := common_defconfig
+KBUILD_DEFCONFIG := ebony_defconfig
 
 head-y				:= arch/ppc/kernel/head.o
 head-$(CONFIG_8xx)		:= arch/ppc/kernel/head_8xx.o
diff --git a/arch/ppc/kernel/ppc_ksyms.c b/arch/ppc/kernel/ppc_ksyms.c
index 16ac11c..602c268 100644
--- a/arch/ppc/kernel/ppc_ksyms.c
+++ b/arch/ppc/kernel/ppc_ksyms.c
@@ -24,6 +24,7 @@
 #include <asm/checksum.h>
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
 #include <linux/adb.h>
 #include <linux/cuda.h>
 #include <linux/pmu.h>
diff --git a/arch/ppc/kernel/setup.c b/arch/ppc/kernel/setup.c
index bfddfde..51e8094 100644
--- a/arch/ppc/kernel/setup.c
+++ b/arch/ppc/kernel/setup.c
@@ -36,6 +36,7 @@
 #include <asm/nvram.h>
 #include <asm/xmon.h>
 #include <asm/ocp.h>
+#include <asm/irq.h>
 
 #define USES_PPC_SYS (defined(CONFIG_MPC10X_BRIDGE) || defined(CONFIG_8260) || \
 		      defined(CONFIG_PPC_MPC52xx))
diff --git a/arch/ppc/platforms/residual.c b/arch/ppc/platforms/residual.c
index 18495e7..d687b0f 100644
--- a/arch/ppc/platforms/residual.c
+++ b/arch/ppc/platforms/residual.c
@@ -38,6 +38,7 @@
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>
+#include <linux/proc_fs.h>
 
 #include <asm/sections.h>
 #include <asm/mmu.h>
diff --git a/arch/sparc/kernel/rtrap.S b/arch/sparc/kernel/rtrap.S
index b27b5b5..ab818cd 100644
--- a/arch/sparc/kernel/rtrap.S
+++ b/arch/sparc/kernel/rtrap.S
@@ -139,7 +139,7 @@ ret_trap_userwins_ok:
 	LOAD_PT_PRIV(sp, t_psr, t_pc, t_npc)
 	or	%t_pc, %t_npc, %g2
 	andcc	%g2, 0x3, %g0
-	sethi	%hi(PSR_SYCALL), %g2
+	sethi	%hi(PSR_SYSCALL), %g2
 	be	1f
 	 andn	%t_psr, %g2, %t_psr
 
diff --git a/arch/sparc64/mm/init.c b/arch/sparc64/mm/init.c
index ec3e2c7..a9828d7 100644
--- a/arch/sparc64/mm/init.c
+++ b/arch/sparc64/mm/init.c
@@ -610,8 +610,6 @@ static void __init remap_kernel(void)
 
 static void __init inherit_prom_mappings(void)
 {
-	read_obp_translations();
-
 	/* Now fixup OBP's idea about where we really are mapped. */
 	printk("Remapping the kernel... ");
 	remap_kernel();
@@ -1747,7 +1745,17 @@ void __init paging_init(void)
 
 	lmb_init();
 
-	/* Find available physical memory... */
+	/* Find available physical memory...
+	 *
+	 * Read it twice in order to work around a bug in openfirmware.
+	 * The call to grab this table itself can cause openfirmware to
+	 * allocate memory, which in turn can take away some space from
+	 * the list of available memory.  Reading it twice makes sure
+	 * we really do get the final value.
+	 */
+	read_obp_translations();
+	read_obp_memory("reg", &pall[0], &pall_ents);
+	read_obp_memory("available", &pavail[0], &pavail_ents);
 	read_obp_memory("available", &pavail[0], &pavail_ents);
 
 	phys_base = 0xffffffffffffffffUL;
@@ -1788,8 +1796,6 @@ void __init paging_init(void)
 	
 	inherit_prom_mappings();
 	
-	read_obp_memory("reg", &pall[0], &pall_ents);
-
 	init_kpte_bitmap();
 
 	/* Ok, we can use our TLB miss and window trap handlers safely.  */
diff --git a/drivers/i2c/busses/i2c-au1550.c b/drivers/i2c/busses/i2c-au1550.c
index 491718f..cae9dc8 100644
--- a/drivers/i2c/busses/i2c-au1550.c
+++ b/drivers/i2c/busses/i2c-au1550.c
@@ -335,7 +335,7 @@ i2c_au1550_probe(struct platform_device *pdev)
 		goto out_mem;
 	}
 
-	priv->psc_base = r->start;
+	priv->psc_base = CKSEG1ADDR(r->start);
 	priv->xfer_timeout = 200;
 	priv->ack_timeout = 200;
 
diff --git a/drivers/net/wireless/strip.c b/drivers/net/wireless/strip.c
index 5dd23c9..883af89 100644
--- a/drivers/net/wireless/strip.c
+++ b/drivers/net/wireless/strip.c
@@ -2611,7 +2611,7 @@ static int strip_open(struct tty_struct *tty)
 	 * We need a write method.
 	 */
 
-	if (tty->ops->write == NULL)
+	if (tty->ops->write == NULL || tty->ops->set_termios == NULL)
 		return -EOPNOTSUPP;
 
 	/*
diff --git a/drivers/serial/crisv10.c b/drivers/serial/crisv10.c
index f9fa237..3e0366e 100644
--- a/drivers/serial/crisv10.c
+++ b/drivers/serial/crisv10.c
@@ -3808,7 +3808,7 @@ rs_close(struct tty_struct *tty, struct file * filp)
 
 	shutdown(info);
 	rs_flush_buffer(tty);
-	tty_ldisc_flush_buffer(tty);
+	tty_ldisc_flush(tty);
 	tty->closing = 0;
 	info->event = 0;
 	info->tty = 0;
diff --git a/drivers/usb/c67x00/c67x00-ll-hpi.c b/drivers/usb/c67x00/c67x00-ll-hpi.c
index f3430b3..5100fbb 100644
--- a/drivers/usb/c67x00/c67x00-ll-hpi.c
+++ b/drivers/usb/c67x00/c67x00-ll-hpi.c
@@ -23,6 +23,7 @@
 
 #include <asm/byteorder.h>
 #include <linux/io.h>
+#include <linux/jiffies.h>
 #include <linux/usb/c67x00.h>
 #include "c67x00.h"
 
diff --git a/fs/cifs/cifspdu.h b/fs/cifs/cifspdu.h
index a0d26b5..c43bf4b 100644
--- a/fs/cifs/cifspdu.h
+++ b/fs/cifs/cifspdu.h
@@ -340,6 +340,7 @@
 #define OPEN_NO_RECALL          0x00400000
 #define OPEN_FREE_SPACE_QUERY   0x00800000	/* should be zero */
 #define CREATE_OPTIONS_MASK     0x007FFFFF
+#define CREATE_OPTION_READONLY	0x10000000
 #define CREATE_OPTION_SPECIAL   0x20000000   /* system. NB not sent over wire */
 
 /* ImpersonationLevel flags */
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index cfd9750..95fbba4 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -1224,11 +1224,8 @@ OldOpenRetry:
 	else /* BB FIXME BB */
 		pSMB->FileAttributes = cpu_to_le16(0/*ATTR_NORMAL*/);
 
-	/* if ((omode & S_IWUGO) == 0)
-		pSMB->FileAttributes |= cpu_to_le32(ATTR_READONLY);*/
-	/*  Above line causes problems due to vfs splitting create into two
-	    pieces - need to set mode after file created not while it is
-	    being created */
+	if (create_options & CREATE_OPTION_READONLY)
+		pSMB->FileAttributes |= cpu_to_le16(ATTR_READONLY);
 
 	/* BB FIXME BB */
 /*	pSMB->CreateOptions = cpu_to_le32(create_options &
@@ -1331,17 +1328,16 @@ openRetry:
 		pSMB->FileAttributes = cpu_to_le32(ATTR_SYSTEM);
 	else
 		pSMB->FileAttributes = cpu_to_le32(ATTR_NORMAL);
+
 	/* XP does not handle ATTR_POSIX_SEMANTICS */
 	/* but it helps speed up case sensitive checks for other
 	servers such as Samba */
 	if (tcon->ses->capabilities & CAP_UNIX)
 		pSMB->FileAttributes |= cpu_to_le32(ATTR_POSIX_SEMANTICS);
 
-	/* if ((omode & S_IWUGO) == 0)
-		pSMB->FileAttributes |= cpu_to_le32(ATTR_READONLY);*/
-	/*  Above line causes problems due to vfs splitting create into two
-		pieces - need to set mode after file created not while it is
-		being created */
+	if (create_options & CREATE_OPTION_READONLY)
+		pSMB->FileAttributes |= cpu_to_le32(ATTR_READONLY);
+
 	pSMB->ShareAccess = cpu_to_le32(FILE_SHARE_ALL);
 	pSMB->CreateDisposition = cpu_to_le32(openDisposition);
 	pSMB->CreateOptions = cpu_to_le32(create_options & CREATE_OPTIONS_MASK);
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index 791ca5c..f428bf3 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -348,7 +348,6 @@ cifs_demultiplex_thread(struct TCP_Server_Info *server)
 	int reconnect;
 
 	current->flags |= PF_MEMALLOC;
-	server->tsk = current;	/* save process info to wake at shutdown */
 	cFYI(1, ("Demultiplex PID: %d", task_pid_nr(current)));
 	write_lock(&GlobalSMBSeslock);
 	atomic_inc(&tcpSesAllocCount);
@@ -651,10 +650,20 @@ multi_t2_fnd:
 
 	spin_lock(&GlobalMid_Lock);
 	server->tcpStatus = CifsExiting;
-	server->tsk = NULL;
+	spin_unlock(&GlobalMid_Lock);
+
+	/* don't exit until kthread_stop is called */
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	while (!kthread_should_stop()) {
+		schedule();
+		set_current_state(TASK_UNINTERRUPTIBLE);
+	}
+	set_current_state(TASK_RUNNING);
+
 	/* check if we have blocked requests that need to free */
 	/* Note that cifs_max_pending is normally 50, but
 	can be set at module install time to as little as two */
+	spin_lock(&GlobalMid_Lock);
 	if (atomic_read(&server->inFlight) >= cifs_max_pending)
 		atomic_set(&server->inFlight, cifs_max_pending - 1);
 	/* We do not want to set the max_pending too low or we
@@ -1318,42 +1327,43 @@ cifs_parse_mount_options(char *options, const char *devname,
 
 static struct cifsSesInfo *
 cifs_find_tcp_session(struct in_addr *target_ip_addr,
-		struct in6_addr *target_ip6_addr,
-		 char *userName, struct TCP_Server_Info **psrvTcp)
+		      struct in6_addr *target_ip6_addr,
+		      char *userName, struct TCP_Server_Info **psrvTcp)
 {
 	struct list_head *tmp;
 	struct cifsSesInfo *ses;
+
 	*psrvTcp = NULL;
-	read_lock(&GlobalSMBSeslock);
 
+	read_lock(&GlobalSMBSeslock);
 	list_for_each(tmp, &GlobalSMBSessionList) {
 		ses = list_entry(tmp, struct cifsSesInfo, cifsSessionList);
-		if (ses->server) {
-			if ((target_ip_addr &&
-				(ses->server->addr.sockAddr.sin_addr.s_addr
-				  == target_ip_addr->s_addr)) || (target_ip6_addr
-				&& memcmp(&ses->server->addr.sockAddr6.sin6_addr,
-					target_ip6_addr, sizeof(*target_ip6_addr)))) {
-				/* BB lock server and tcp session and increment
-				      use count here?? */
-
-				/* found a match on the TCP session */
-				*psrvTcp = ses->server;
-
-				/* BB check if reconnection needed */
-				if (strncmp
-				    (ses->userName, userName,
-				     MAX_USERNAME_SIZE) == 0){
-					read_unlock(&GlobalSMBSeslock);
-					/* Found exact match on both TCP and
-					   SMB sessions */
-					return ses;
-				}
-			}
+		if (!ses->server)
+			continue;
+
+		if (target_ip_addr &&
+		    ses->server->addr.sockAddr.sin_addr.s_addr != target_ip_addr->s_addr)
+				continue;
+		else if (target_ip6_addr &&
+			 memcmp(&ses->server->addr.sockAddr6.sin6_addr,
+				target_ip6_addr, sizeof(*target_ip6_addr)))
+				continue;
+		/* BB lock server and tcp session; increment use count here?? */
+
+		/* found a match on the TCP session */
+		*psrvTcp = ses->server;
+
+		/* BB check if reconnection needed */
+		if (strncmp(ses->userName, userName, MAX_USERNAME_SIZE) == 0) {
+			read_unlock(&GlobalSMBSeslock);
+			/* Found exact match on both TCP and
+			   SMB sessions */
+			return ses;
 		}
 		/* else tcp and smb sessions need reconnection */
 	}
 	read_unlock(&GlobalSMBSeslock);
+
 	return NULL;
 }
 
@@ -2186,15 +2196,12 @@ cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
 			srvTcp->tcpStatus = CifsExiting;
 			spin_unlock(&GlobalMid_Lock);
 			if (srvTcp->tsk) {
-				struct task_struct *tsk;
 				/* If we could verify that kthread_stop would
 				   always wake up processes blocked in
 				   tcp in recv_mesg then we could remove the
 				   send_sig call */
 				force_sig(SIGKILL, srvTcp->tsk);
-				tsk = srvTcp->tsk;
-				if (tsk)
-					kthread_stop(tsk);
+				kthread_stop(srvTcp->tsk);
 			}
 		}
 		 /* If find_unc succeeded then rc == 0 so we can not end */
@@ -2210,23 +2217,17 @@ cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,
 					if ((temp_rc == -ESHUTDOWN) &&
 					    (pSesInfo->server) &&
 					    (pSesInfo->server->tsk)) {
-						struct task_struct *tsk;
 						force_sig(SIGKILL,
 							pSesInfo->server->tsk);
-						tsk = pSesInfo->server->tsk;
-						if (tsk)
-							kthread_stop(tsk);
+						kthread_stop(pSesInfo->server->tsk);
 					}
 				} else {
 					cFYI(1, ("No session or bad tcon"));
 					if ((pSesInfo->server) &&
 					    (pSesInfo->server->tsk)) {
-						struct task_struct *tsk;
 						force_sig(SIGKILL,
 							pSesInfo->server->tsk);
-						tsk = pSesInfo->server->tsk;
-						if (tsk)
-							kthread_stop(tsk);
+						kthread_stop(pSesInfo->server->tsk);
 					}
 				}
 				sesInfoFree(pSesInfo);
diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c
index 6ed7759..e4e0078 100644
--- a/fs/cifs/dir.c
+++ b/fs/cifs/dir.c
@@ -119,6 +119,7 @@ cifs_create(struct inode *inode, struct dentry *direntry, int mode,
 {
 	int rc = -ENOENT;
 	int xid;
+	int create_options = CREATE_NOT_DIR;
 	int oplock = 0;
 	int desiredAccess = GENERIC_READ | GENERIC_WRITE;
 	__u16 fileHandle;
@@ -176,9 +177,19 @@ cifs_create(struct inode *inode, struct dentry *direntry, int mode,
 		FreeXid(xid);
 		return -ENOMEM;
 	}
+
+	mode &= ~current->fs->umask;
+
+	/*
+	 * if we're not using unix extensions, see if we need to set
+	 * ATTR_READONLY on the create call
+	 */
+	if (!pTcon->unix_ext && (mode & S_IWUGO) == 0)
+		create_options |= CREATE_OPTION_READONLY;
+
 	if (cifs_sb->tcon->ses->capabilities & CAP_NT_SMBS)
 		rc = CIFSSMBOpen(xid, pTcon, full_path, disposition,
-			 desiredAccess, CREATE_NOT_DIR,
+			 desiredAccess, create_options,
 			 &fileHandle, &oplock, buf, cifs_sb->local_nls,
 			 cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
 	else
@@ -187,7 +198,7 @@ cifs_create(struct inode *inode, struct dentry *direntry, int mode,
 	if (rc == -EIO) {
 		/* old server, retry the open legacy style */
 		rc = SMBLegacyOpen(xid, pTcon, full_path, disposition,
-			desiredAccess, CREATE_NOT_DIR,
+			desiredAccess, create_options,
 			&fileHandle, &oplock, buf, cifs_sb->local_nls,
 			cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);
 	}
@@ -197,7 +208,6 @@ cifs_create(struct inode *inode, struct dentry *direntry, int mode,
 		/* If Open reported that we actually created a file
 		then we now have to set the mode if possible */
 		if ((pTcon->unix_ext) && (oplock & CIFS_CREATE_ACTION)) {
-			mode &= ~current->fs->umask;
 			if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {
 				CIFSSMBUnixSetPerms(xid, pTcon, full_path, mode,
 					(__u64)current->fsuid,
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index 0d9d2e6..fcbdbb6 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -974,8 +974,8 @@ mkdir_get_info:
 		  * failed to get it from the server or was set bogus */
 		if ((direntry->d_inode) && (direntry->d_inode->i_nlink < 2))
 				direntry->d_inode->i_nlink = 2;
+		mode &= ~current->fs->umask;
 		if (pTcon->unix_ext) {
-			mode &= ~current->fs->umask;
 			if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {
 				CIFSSMBUnixSetPerms(xid, pTcon, full_path,
 						    mode,
@@ -994,9 +994,16 @@ mkdir_get_info:
 						    CIFS_MOUNT_MAP_SPECIAL_CHR);
 			}
 		} else {
-			/* BB to be implemented via Windows secrty descriptors
-			   eg CIFSSMBWinSetPerms(xid, pTcon, full_path, mode,
-						 -1, -1, local_nls); */
+			if (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL) &&
+			    (mode & S_IWUGO) == 0) {
+				FILE_BASIC_INFO pInfo;
+				memset(&pInfo, 0, sizeof(pInfo));
+				pInfo.Attributes = cpu_to_le32(ATTR_READONLY);
+				CIFSSMBSetTimes(xid, pTcon, full_path,
+						&pInfo, cifs_sb->local_nls,
+						cifs_sb->mnt_cifs_flags &
+						CIFS_MOUNT_MAP_SPECIAL_CHR);
+			}
 			if (direntry->d_inode) {
 				direntry->d_inode->i_mode = mode;
 				direntry->d_inode->i_mode |= S_IFDIR;
@@ -1408,18 +1415,19 @@ int cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 	__u64 uid = 0xFFFFFFFFFFFFFFFFULL;
 	__u64 gid = 0xFFFFFFFFFFFFFFFFULL;
 	struct cifsInodeInfo *cifsInode;
+	struct inode *inode = direntry->d_inode;
 
 	xid = GetXid();
 
 	cFYI(1, ("setattr on file %s attrs->iavalid 0x%x",
 		 direntry->d_name.name, attrs->ia_valid));
 
-	cifs_sb = CIFS_SB(direntry->d_inode->i_sb);
+	cifs_sb = CIFS_SB(inode->i_sb);
 	pTcon = cifs_sb->tcon;
 
 	if ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) == 0) {
 		/* check if we have permission to change attrs */
-		rc = inode_change_ok(direntry->d_inode, attrs);
+		rc = inode_change_ok(inode, attrs);
 		if (rc < 0) {
 			FreeXid(xid);
 			return rc;
@@ -1432,7 +1440,7 @@ int cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 		FreeXid(xid);
 		return -ENOMEM;
 	}
-	cifsInode = CIFS_I(direntry->d_inode);
+	cifsInode = CIFS_I(inode);
 
 	if ((attrs->ia_valid & ATTR_MTIME) || (attrs->ia_valid & ATTR_SIZE)) {
 		/*
@@ -1443,9 +1451,9 @@ int cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 		   will be truncated anyway? Also, should we error out here if
 		   the flush returns error?
 		 */
-		rc = filemap_write_and_wait(direntry->d_inode->i_mapping);
+		rc = filemap_write_and_wait(inode->i_mapping);
 		if (rc != 0) {
-			CIFS_I(direntry->d_inode)->write_behind_rc = rc;
+			cifsInode->write_behind_rc = rc;
 			rc = 0;
 		}
 	}
@@ -1521,9 +1529,8 @@ int cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 		   */
 
 		if (rc == 0) {
-			rc = cifs_vmtruncate(direntry->d_inode, attrs->ia_size);
-			cifs_truncate_page(direntry->d_inode->i_mapping,
-					   direntry->d_inode->i_size);
+			rc = cifs_vmtruncate(inode, attrs->ia_size);
+			cifs_truncate_page(inode->i_mapping, inode->i_size);
 		} else
 			goto cifs_setattr_exit;
 	}
@@ -1557,7 +1564,7 @@ int cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 		rc = 0;
 #ifdef CONFIG_CIFS_EXPERIMENTAL
 		if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)
-			rc = mode_to_acl(direntry->d_inode, full_path, mode);
+			rc = mode_to_acl(inode, full_path, mode);
 		else if ((mode & S_IWUGO) == 0) {
 #else
 		if ((mode & S_IWUGO) == 0) {
@@ -1665,7 +1672,7 @@ int cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 	/* do not need local check to inode_check_ok since the server does
 	   that */
 	if (!rc)
-		rc = inode_setattr(direntry->d_inode, attrs);
+		rc = inode_setattr(inode, attrs);
 cifs_setattr_exit:
 	kfree(full_path);
 	FreeXid(xid);
diff --git a/include/asm-mips/bitops.h b/include/asm-mips/bitops.h
index c2bd126..6427247 100644
--- a/include/asm-mips/bitops.h
+++ b/include/asm-mips/bitops.h
@@ -558,11 +558,13 @@ static inline void __clear_bit_unlock(unsigned long nr, volatile unsigned long *
 	__clear_bit(nr, addr);
 }
 
+#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
+
 /*
  * Return the bit position (0..63) of the most significant 1 bit in a word
  * Returns -1 if no 1 bit exists
  */
-static inline int __ilog2(unsigned long x)
+static inline unsigned long __fls(unsigned long x)
 {
 	int lz;
 
@@ -591,13 +593,6 @@ static inline int __ilog2(unsigned long x)
 	return 63 - lz;
 }
 
-static inline unsigned long __fls(unsigned long x)
-{
-	return __ilog2(x);
-}
-
-#if defined(CONFIG_CPU_MIPS32) || defined(CONFIG_CPU_MIPS64)
-
 /*
  * __ffs - find first bit in word.
  * @word: The word to search
@@ -607,7 +602,7 @@ static inline unsigned long __fls(unsigned long x)
  */
 static inline unsigned long __ffs(unsigned long word)
 {
-	return __ilog2(word & -word);
+	return __fls(word & -word);
 }
 
 /*
@@ -654,6 +649,7 @@ static inline int ffs(int word)
 #else
 
 #include <asm-generic/bitops/__ffs.h>
+#include <asm-generic/bitops/__fls.h>
 #include <asm-generic/bitops/ffs.h>
 #include <asm-generic/bitops/fls.h>
 #include <asm-generic/bitops/fls64.h>
diff --git a/include/asm-mips/compiler.h b/include/asm-mips/compiler.h
index aa6b876..71f5c5c 100644
--- a/include/asm-mips/compiler.h
+++ b/include/asm-mips/compiler.h
@@ -9,10 +9,10 @@
 #define _ASM_COMPILER_H
 
 #if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
-#define GCC_IMM_ASM "n"
+#define GCC_IMM_ASM() "n"
 #define GCC_REG_ACCUM "$0"
 #else
-#define GCC_IMM_ASM "rn"
+#define GCC_IMM_ASM() "rn"
 #define GCC_REG_ACCUM "accum"
 #endif
 
diff --git a/include/asm-mips/mach-au1x00/au1000.h b/include/asm-mips/mach-au1x00/au1000.h
index a055551..363a14e 100644
--- a/include/asm-mips/mach-au1x00/au1000.h
+++ b/include/asm-mips/mach-au1x00/au1000.h
@@ -40,8 +40,8 @@
 #include <linux/delay.h>
 #include <linux/types.h>
 
-#include <asm/io.h>
-#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/irq.h>
 
 /* cpu pipeline flush */
 void static inline au_sync(void)
@@ -63,32 +63,32 @@ void static inline au_sync_delay(int ms)
 
 void static inline au_writeb(u8 val, unsigned long reg)
 {
-	*(volatile u8 *)(reg) = val;
+	*(volatile u8 *)reg = val;
 }
 
 void static inline au_writew(u16 val, unsigned long reg)
 {
-	*(volatile u16 *)(reg) = val;
+	*(volatile u16 *)reg = val;
 }
 
 void static inline au_writel(u32 val, unsigned long reg)
 {
-	*(volatile u32 *)(reg) = val;
+	*(volatile u32 *)reg = val;
 }
 
 static inline u8 au_readb(unsigned long reg)
 {
-	return (*(volatile u8 *)reg);
+	return *(volatile u8 *)reg;
 }
 
 static inline u16 au_readw(unsigned long reg)
 {
-	return (*(volatile u16 *)reg);
+	return *(volatile u16 *)reg;
 }
 
 static inline u32 au_readl(unsigned long reg)
 {
-	return (*(volatile u32 *)reg);
+	return *(volatile u32 *)reg;
 }
 
 
@@ -117,76 +117,77 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 #endif /* !defined (_LANGUAGE_ASSEMBLY) */
 
 /*
- * SDRAM Register Offsets
+ * SDRAM register offsets
  */
-#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1100)
-#define MEM_SDMODE0		(0x0000)
-#define MEM_SDMODE1		(0x0004)
-#define MEM_SDMODE2		(0x0008)
-#define MEM_SDADDR0		(0x000C)
-#define MEM_SDADDR1		(0x0010)
-#define MEM_SDADDR2		(0x0014)
-#define MEM_SDREFCFG	(0x0018)
-#define MEM_SDPRECMD	(0x001C)
-#define MEM_SDAUTOREF	(0x0020)
-#define MEM_SDWRMD0		(0x0024)
-#define MEM_SDWRMD1		(0x0028)
-#define MEM_SDWRMD2		(0x002C)
-#define MEM_SDSLEEP		(0x0030)
-#define MEM_SDSMCKE		(0x0034)
+#if defined(CONFIG_SOC_AU1000) || defined(CONFIG_SOC_AU1500) || \
+    defined(CONFIG_SOC_AU1100)
+#define MEM_SDMODE0		0x0000
+#define MEM_SDMODE1		0x0004
+#define MEM_SDMODE2		0x0008
+#define MEM_SDADDR0		0x000C
+#define MEM_SDADDR1		0x0010
+#define MEM_SDADDR2		0x0014
+#define MEM_SDREFCFG		0x0018
+#define MEM_SDPRECMD		0x001C
+#define MEM_SDAUTOREF		0x0020
+#define MEM_SDWRMD0		0x0024
+#define MEM_SDWRMD1		0x0028
+#define MEM_SDWRMD2		0x002C
+#define MEM_SDSLEEP		0x0030
+#define MEM_SDSMCKE		0x0034
 
 /*
  * MEM_SDMODE register content definitions
  */
-#define MEM_SDMODE_F		(1<<22)
-#define MEM_SDMODE_SR		(1<<21)
-#define MEM_SDMODE_BS		(1<<20)
-#define MEM_SDMODE_RS		(3<<18)
-#define MEM_SDMODE_CS		(7<<15)
-#define MEM_SDMODE_TRAS		(15<<11)
-#define MEM_SDMODE_TMRD		(3<<9)
-#define MEM_SDMODE_TWR		(3<<7)
-#define MEM_SDMODE_TRP		(3<<5)
-#define MEM_SDMODE_TRCD		(3<<3)
-#define MEM_SDMODE_TCL		(7<<0)
-
-#define MEM_SDMODE_BS_2Bank	(0<<20)
-#define MEM_SDMODE_BS_4Bank	(1<<20)
-#define MEM_SDMODE_RS_11Row	(0<<18)
-#define MEM_SDMODE_RS_12Row	(1<<18)
-#define MEM_SDMODE_RS_13Row	(2<<18)
-#define MEM_SDMODE_RS_N(N)	((N)<<18)
-#define MEM_SDMODE_CS_7Col	(0<<15)
-#define MEM_SDMODE_CS_8Col	(1<<15)
-#define MEM_SDMODE_CS_9Col	(2<<15)
-#define MEM_SDMODE_CS_10Col	(3<<15)
-#define MEM_SDMODE_CS_11Col	(4<<15)
-#define MEM_SDMODE_CS_N(N)		((N)<<15)
-#define MEM_SDMODE_TRAS_N(N)	((N)<<11)
-#define MEM_SDMODE_TMRD_N(N)	((N)<<9)
-#define MEM_SDMODE_TWR_N(N)		((N)<<7)
-#define MEM_SDMODE_TRP_N(N)		((N)<<5)
-#define MEM_SDMODE_TRCD_N(N)	((N)<<3)
-#define MEM_SDMODE_TCL_N(N)		((N)<<0)
+#define MEM_SDMODE_F		(1 << 22)
+#define MEM_SDMODE_SR		(1 << 21)
+#define MEM_SDMODE_BS		(1 << 20)
+#define MEM_SDMODE_RS		(3 << 18)
+#define MEM_SDMODE_CS		(7 << 15)
+#define MEM_SDMODE_TRAS 	(15 << 11)
+#define MEM_SDMODE_TMRD 	(3 << 9)
+#define MEM_SDMODE_TWR		(3 << 7)
+#define MEM_SDMODE_TRP		(3 << 5)
+#define MEM_SDMODE_TRCD 	(3 << 3)
+#define MEM_SDMODE_TCL		(7 << 0)
+
+#define MEM_SDMODE_BS_2Bank	(0 << 20)
+#define MEM_SDMODE_BS_4Bank	(1 << 20)
+#define MEM_SDMODE_RS_11Row	(0 << 18)
+#define MEM_SDMODE_RS_12Row	(1 << 18)
+#define MEM_SDMODE_RS_13Row	(2 << 18)
+#define MEM_SDMODE_RS_N(N)	((N) << 18)
+#define MEM_SDMODE_CS_7Col	(0 << 15)
+#define MEM_SDMODE_CS_8Col	(1 << 15)
+#define MEM_SDMODE_CS_9Col	(2 << 15)
+#define MEM_SDMODE_CS_10Col	(3 << 15)
+#define MEM_SDMODE_CS_11Col	(4 << 15)
+#define MEM_SDMODE_CS_N(N)	((N) << 15)
+#define MEM_SDMODE_TRAS_N(N)	((N) << 11)
+#define MEM_SDMODE_TMRD_N(N)	((N) << 9)
+#define MEM_SDMODE_TWR_N(N)	((N) << 7)
+#define MEM_SDMODE_TRP_N(N)	((N) << 5)
+#define MEM_SDMODE_TRCD_N(N)	((N) << 3)
+#define MEM_SDMODE_TCL_N(N)	((N) << 0)
 
 /*
  * MEM_SDADDR register contents definitions
  */
-#define MEM_SDADDR_E			(1<<20)
-#define MEM_SDADDR_CSBA			(0x03FF<<10)
-#define MEM_SDADDR_CSMASK		(0x03FF<<0)
-#define MEM_SDADDR_CSBA_N(N)	((N)&(0x03FF<<22)>>12)
-#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF<<22)>>22)
+#define MEM_SDADDR_E		(1 << 20)
+#define MEM_SDADDR_CSBA 	(0x03FF << 10)
+#define MEM_SDADDR_CSMASK	(0x03FF << 0)
+#define MEM_SDADDR_CSBA_N(N)	((N) & (0x03FF << 22) >> 12)
+#define MEM_SDADDR_CSMASK_N(N)	((N)&(0x03FF << 22) >> 22)
 
 /*
  * MEM_SDREFCFG register content definitions
  */
-#define MEM_SDREFCFG_TRC		(15<<28)
-#define MEM_SDREFCFG_TRPM		(3<<26)
-#define MEM_SDREFCFG_E			(1<<25)
-#define MEM_SDREFCFG_RE			(0x1ffffff<<0)
-#define MEM_SDREFCFG_TRC_N(N)	((N)<<MEM_SDREFCFG_TRC)
-#define MEM_SDREFCFG_TRPM_N(N)	((N)<<MEM_SDREFCFG_TRPM)
+#define MEM_SDREFCFG_TRC	(15 << 28)
+#define MEM_SDREFCFG_TRPM	(3 << 26)
+#define MEM_SDREFCFG_E		(1 << 25)
+#define MEM_SDREFCFG_RE 	(0x1ffffff << 0)
+#define MEM_SDREFCFG_TRC_N(N)	((N) << MEM_SDREFCFG_TRC)
+#define MEM_SDREFCFG_TRPM_N(N)	((N) << MEM_SDREFCFG_TRPM)
 #define MEM_SDREFCFG_REF_N(N)	(N)
 #endif
 
@@ -199,25 +200,25 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 /***********************************************************************/
 
 #if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
-#define MEM_SDMODE0		(0x0800)
-#define MEM_SDMODE1		(0x0808)
-#define MEM_SDMODE2		(0x0810)
-#define MEM_SDADDR0		(0x0820)
-#define MEM_SDADDR1		(0x0828)
-#define MEM_SDADDR2		(0x0830)
-#define MEM_SDCONFIGA	(0x0840)
-#define MEM_SDCONFIGB	(0x0848)
-#define MEM_SDSTAT		(0x0850)
-#define MEM_SDERRADDR	(0x0858)
-#define MEM_SDSTRIDE0	(0x0860)
-#define MEM_SDSTRIDE1	(0x0868)
-#define MEM_SDSTRIDE2	(0x0870)
-#define MEM_SDWRMD0		(0x0880)
-#define MEM_SDWRMD1		(0x0888)
-#define MEM_SDWRMD2		(0x0890)
-#define MEM_SDPRECMD	(0x08C0)
-#define MEM_SDAUTOREF	(0x08C8)
-#define MEM_SDSREF		(0x08D0)
+#define MEM_SDMODE0		0x0800
+#define MEM_SDMODE1		0x0808
+#define MEM_SDMODE2		0x0810
+#define MEM_SDADDR0		0x0820
+#define MEM_SDADDR1		0x0828
+#define MEM_SDADDR2		0x0830
+#define MEM_SDCONFIGA		0x0840
+#define MEM_SDCONFIGB		0x0848
+#define MEM_SDSTAT		0x0850
+#define MEM_SDERRADDR		0x0858
+#define MEM_SDSTRIDE0		0x0860
+#define MEM_SDSTRIDE1		0x0868
+#define MEM_SDSTRIDE2		0x0870
+#define MEM_SDWRMD0		0x0880
+#define MEM_SDWRMD1		0x0888
+#define MEM_SDWRMD2		0x0890
+#define MEM_SDPRECMD		0x08C0
+#define MEM_SDAUTOREF		0x08C8
+#define MEM_SDSREF		0x08D0
 #define MEM_SDSLEEP		MEM_SDSREF
 
 #endif
@@ -256,9 +257,9 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 #define	SSI0_PHYS_ADDR		0x11600000
 #define	SSI1_PHYS_ADDR		0x11680000
 #define	SYS_PHYS_ADDR		0x11900000
-#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
 #endif
 
 /********************************************************************/
@@ -290,13 +291,13 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 #define	UART3_PHYS_ADDR		0x11400000
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
-#define PCI_MEM_PHYS_ADDR     0x400000000ULL
-#define PCI_IO_PHYS_ADDR      0x500000000ULL
-#define PCI_CONFIG0_PHYS_ADDR 0x600000000ULL
-#define PCI_CONFIG1_PHYS_ADDR 0x680000000ULL
-#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#define PCI_MEM_PHYS_ADDR	0x400000000ULL
+#define PCI_IO_PHYS_ADDR	0x500000000ULL
+#define PCI_CONFIG0_PHYS_ADDR	0x600000000ULL
+#define PCI_CONFIG1_PHYS_ADDR	0x680000000ULL
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
 #endif
 
 /********************************************************************/
@@ -333,9 +334,9 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 #define GPIO2_PHYS_ADDR		0x11700000
 #define	SYS_PHYS_ADDR		0x11900000
 #define LCD_PHYS_ADDR		0x15000000
-#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
 #endif
 
 /***********************************************************************/
@@ -360,17 +361,17 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 #define	SYS_PHYS_ADDR		0x11900000
 #define	DDMA_PHYS_ADDR		0x14002000
 #define PE_PHYS_ADDR		0x14008000
-#define PSC0_PHYS_ADDR	 	0x11A00000
-#define PSC1_PHYS_ADDR	 	0x11B00000
-#define PSC2_PHYS_ADDR	 	0x10A00000
-#define PSC3_PHYS_ADDR	 	0x10B00000
-#define PCI_MEM_PHYS_ADDR     0x400000000ULL
-#define PCI_IO_PHYS_ADDR      0x500000000ULL
-#define PCI_CONFIG0_PHYS_ADDR 0x600000000ULL
-#define PCI_CONFIG1_PHYS_ADDR 0x680000000ULL
-#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#define PSC0_PHYS_ADDR		0x11A00000
+#define PSC1_PHYS_ADDR		0x11B00000
+#define PSC2_PHYS_ADDR		0x10A00000
+#define PSC3_PHYS_ADDR		0x10B00000
+#define PCI_MEM_PHYS_ADDR	0x400000000ULL
+#define PCI_IO_PHYS_ADDR	0x500000000ULL
+#define PCI_CONFIG0_PHYS_ADDR	0x600000000ULL
+#define PCI_CONFIG1_PHYS_ADDR	0x680000000ULL
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
 #endif
 
 /***********************************************************************/
@@ -397,122 +398,121 @@ extern struct au1xxx_irqmap au1xxx_irq_map[];
 #define SWCNT_PHYS_ADDR		0x1110010C
 #define MAEFE_PHYS_ADDR		0x14012000
 #define MAEBE_PHYS_ADDR		0x14010000
-#define PCMCIA_IO_PHYS_ADDR   0xF00000000ULL
-#define PCMCIA_ATTR_PHYS_ADDR 0xF40000000ULL
-#define PCMCIA_MEM_PHYS_ADDR  0xF80000000ULL
+#define PCMCIA_IO_PHYS_ADDR	0xF00000000ULL
+#define PCMCIA_ATTR_PHYS_ADDR	0xF40000000ULL
+#define PCMCIA_MEM_PHYS_ADDR	0xF80000000ULL
 #endif
 
-
 /* Static Bus Controller */
-#define MEM_STCFG0                 0xB4001000
-#define MEM_STTIME0                0xB4001004
-#define MEM_STADDR0                0xB4001008
+#define MEM_STCFG0		0xB4001000
+#define MEM_STTIME0		0xB4001004
+#define MEM_STADDR0		0xB4001008
 
-#define MEM_STCFG1                 0xB4001010
-#define MEM_STTIME1                0xB4001014
-#define MEM_STADDR1                0xB4001018
+#define MEM_STCFG1		0xB4001010
+#define MEM_STTIME1		0xB4001014
+#define MEM_STADDR1		0xB4001018
 
-#define MEM_STCFG2                 0xB4001020
-#define MEM_STTIME2                0xB4001024
-#define MEM_STADDR2                0xB4001028
+#define MEM_STCFG2		0xB4001020
+#define MEM_STTIME2		0xB4001024
+#define MEM_STADDR2		0xB4001028
 
-#define MEM_STCFG3                 0xB4001030
-#define MEM_STTIME3                0xB4001034
-#define MEM_STADDR3                0xB4001038
+#define MEM_STCFG3		0xB4001030
+#define MEM_STTIME3		0xB4001034
+#define MEM_STADDR3		0xB4001038
 
 #if defined(CONFIG_SOC_AU1550) || defined(CONFIG_SOC_AU1200)
-#define MEM_STNDCTL                0xB4001100
-#define MEM_STSTAT                 0xB4001104
+#define MEM_STNDCTL		0xB4001100
+#define MEM_STSTAT		0xB4001104
 
-#define MEM_STNAND_CMD                  (0x0)
-#define MEM_STNAND_ADDR                 (0x4)
-#define MEM_STNAND_DATA                (0x20)
+#define MEM_STNAND_CMD		0x0
+#define MEM_STNAND_ADDR 	0x4
+#define MEM_STNAND_DATA 	0x20
 #endif
 
 /* Interrupt Controller 0 */
-#define IC0_CFG0RD                 0xB0400040
-#define IC0_CFG0SET                0xB0400040
-#define IC0_CFG0CLR                0xB0400044
+#define IC0_CFG0RD		0xB0400040
+#define IC0_CFG0SET		0xB0400040
+#define IC0_CFG0CLR		0xB0400044
 
-#define IC0_CFG1RD                 0xB0400048
-#define IC0_CFG1SET                0xB0400048
-#define IC0_CFG1CLR                0xB040004C
+#define IC0_CFG1RD		0xB0400048
+#define IC0_CFG1SET		0xB0400048
+#define IC0_CFG1CLR		0xB040004C
 
-#define IC0_CFG2RD                 0xB0400050
-#define IC0_CFG2SET                0xB0400050
-#define IC0_CFG2CLR                0xB0400054
+#define IC0_CFG2RD		0xB0400050
+#define IC0_CFG2SET		0xB0400050
+#define IC0_CFG2CLR		0xB0400054
 
-#define IC0_REQ0INT                0xB0400054
-#define IC0_SRCRD                  0xB0400058
-#define IC0_SRCSET                 0xB0400058
-#define IC0_SRCCLR                 0xB040005C
-#define IC0_REQ1INT                0xB040005C
+#define IC0_REQ0INT		0xB0400054
+#define IC0_SRCRD		0xB0400058
+#define IC0_SRCSET		0xB0400058
+#define IC0_SRCCLR		0xB040005C
+#define IC0_REQ1INT		0xB040005C
 
-#define IC0_ASSIGNRD               0xB0400060
-#define IC0_ASSIGNSET              0xB0400060
-#define IC0_ASSIGNCLR              0xB0400064
+#define IC0_ASSIGNRD		0xB0400060
+#define IC0_ASSIGNSET		0xB0400060
+#define IC0_ASSIGNCLR		0xB0400064
 
-#define IC0_WAKERD                 0xB0400068
-#define IC0_WAKESET                0xB0400068
-#define IC0_WAKECLR                0xB040006C
+#define IC0_WAKERD		0xB0400068
+#define IC0_WAKESET		0xB0400068
+#define IC0_WAKECLR		0xB040006C
 
-#define IC0_MASKRD                 0xB0400070
-#define IC0_MASKSET                0xB0400070
-#define IC0_MASKCLR                0xB0400074
+#define IC0_MASKRD		0xB0400070
+#define IC0_MASKSET		0xB0400070
+#define IC0_MASKCLR		0xB0400074
 
-#define IC0_RISINGRD               0xB0400078
-#define IC0_RISINGCLR              0xB0400078
-#define IC0_FALLINGRD              0xB040007C
-#define IC0_FALLINGCLR             0xB040007C
+#define IC0_RISINGRD		0xB0400078
+#define IC0_RISINGCLR		0xB0400078
+#define IC0_FALLINGRD		0xB040007C
+#define IC0_FALLINGCLR		0xB040007C
 
-#define IC0_TESTBIT                0xB0400080
+#define IC0_TESTBIT		0xB0400080
 
 /* Interrupt Controller 1 */
-#define IC1_CFG0RD                 0xB1800040
-#define IC1_CFG0SET                0xB1800040
-#define IC1_CFG0CLR                0xB1800044
+#define IC1_CFG0RD		0xB1800040
+#define IC1_CFG0SET		0xB1800040
+#define IC1_CFG0CLR		0xB1800044
 
-#define IC1_CFG1RD                 0xB1800048
-#define IC1_CFG1SET                0xB1800048
-#define IC1_CFG1CLR                0xB180004C
+#define IC1_CFG1RD		0xB1800048
+#define IC1_CFG1SET		0xB1800048
+#define IC1_CFG1CLR		0xB180004C
 
-#define IC1_CFG2RD                 0xB1800050
-#define IC1_CFG2SET                0xB1800050
-#define IC1_CFG2CLR                0xB1800054
+#define IC1_CFG2RD		0xB1800050
+#define IC1_CFG2SET		0xB1800050
+#define IC1_CFG2CLR		0xB1800054
 
-#define IC1_REQ0INT                0xB1800054
-#define IC1_SRCRD                  0xB1800058
-#define IC1_SRCSET                 0xB1800058
-#define IC1_SRCCLR                 0xB180005C
-#define IC1_REQ1INT                0xB180005C
+#define IC1_REQ0INT		0xB1800054
+#define IC1_SRCRD		0xB1800058
+#define IC1_SRCSET		0xB1800058
+#define IC1_SRCCLR		0xB180005C
+#define IC1_REQ1INT		0xB180005C
 
-#define IC1_ASSIGNRD               0xB1800060
-#define IC1_ASSIGNSET              0xB1800060
-#define IC1_ASSIGNCLR              0xB1800064
+#define IC1_ASSIGNRD            0xB1800060
+#define IC1_ASSIGNSET           0xB1800060
+#define IC1_ASSIGNCLR           0xB1800064
 
-#define IC1_WAKERD                 0xB1800068
-#define IC1_WAKESET                0xB1800068
-#define IC1_WAKECLR                0xB180006C
+#define IC1_WAKERD		0xB1800068
+#define IC1_WAKESET		0xB1800068
+#define IC1_WAKECLR		0xB180006C
 
-#define IC1_MASKRD                 0xB1800070
-#define IC1_MASKSET                0xB1800070
-#define IC1_MASKCLR                0xB1800074
+#define IC1_MASKRD		0xB1800070
+#define IC1_MASKSET		0xB1800070
+#define IC1_MASKCLR		0xB1800074
 
-#define IC1_RISINGRD               0xB1800078
-#define IC1_RISINGCLR              0xB1800078
-#define IC1_FALLINGRD              0xB180007C
-#define IC1_FALLINGCLR             0xB180007C
+#define IC1_RISINGRD		0xB1800078
+#define IC1_RISINGCLR		0xB1800078
+#define IC1_FALLINGRD		0xB180007C
+#define IC1_FALLINGCLR		0xB180007C
 
-#define IC1_TESTBIT                0xB1800080
+#define IC1_TESTBIT		0xB1800080
 
 /* Interrupt Configuration Modes */
-#define INTC_INT_DISABLED                0
-#define INTC_INT_RISE_EDGE             0x1
-#define INTC_INT_FALL_EDGE             0x2
-#define INTC_INT_RISE_AND_FALL_EDGE    0x3
-#define INTC_INT_HIGH_LEVEL            0x5
-#define INTC_INT_LOW_LEVEL             0x6
-#define INTC_INT_HIGH_AND_LOW_LEVEL    0x7
+#define INTC_INT_DISABLED		0x0
+#define INTC_INT_RISE_EDGE		0x1
+#define INTC_INT_FALL_EDGE		0x2
+#define INTC_INT_RISE_AND_FALL_EDGE	0x3
+#define INTC_INT_HIGH_LEVEL		0x5
+#define INTC_INT_LOW_LEVEL		0x6
+#define INTC_INT_HIGH_AND_LOW_LEVEL	0x7
 
 /* Interrupt Numbers */
 /* Au1000 */
@@ -579,18 +579,18 @@ enum soc_au1000_ints {
 	AU1000_GPIO_31,
 };
 
-#define UART0_ADDR                0xB1100000
-#define UART1_ADDR                0xB1200000
-#define UART2_ADDR                0xB1300000
-#define UART3_ADDR                0xB1400000
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+#define UART2_ADDR		0xB1300000
+#define UART3_ADDR		0xB1400000
 
-#define USB_OHCI_BASE             0x10100000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB017fffc
+#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
+#define USB_HOST_CONFIG 	0xB017FFFC
 
-#define AU1000_ETH0_BASE      0xB0500000
-#define AU1000_ETH1_BASE      0xB0510000
-#define AU1000_MAC0_ENABLE       0xB0520000
-#define AU1000_MAC1_ENABLE       0xB0520004
+#define AU1000_ETH0_BASE	0xB0500000
+#define AU1000_ETH1_BASE	0xB0510000
+#define AU1000_MAC0_ENABLE	0xB0520000
+#define AU1000_MAC1_ENABLE	0xB0520004
 #define NUM_ETH_INTERFACES 2
 #endif /* CONFIG_SOC_AU1000 */
 
@@ -662,16 +662,16 @@ enum soc_au1500_ints {
 #define INTC AU1000_PCI_INTC
 #define INTD AU1000_PCI_INTD
 
-#define UART0_ADDR                0xB1100000
-#define UART3_ADDR                0xB1400000
+#define UART0_ADDR		0xB1100000
+#define UART3_ADDR		0xB1400000
 
-#define USB_OHCI_BASE             0x10100000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB017fffc
+#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
+#define USB_HOST_CONFIG 	0xB017fffc
 
-#define AU1500_ETH0_BASE	  0xB1500000
-#define AU1500_ETH1_BASE	  0xB1510000
-#define AU1500_MAC0_ENABLE       0xB1520000
-#define AU1500_MAC1_ENABLE       0xB1520004
+#define AU1500_ETH0_BASE	0xB1500000
+#define AU1500_ETH1_BASE	0xB1510000
+#define AU1500_MAC0_ENABLE	0xB1520000
+#define AU1500_MAC1_ENABLE	0xB1520004
 #define NUM_ETH_INTERFACES 2
 #endif /* CONFIG_SOC_AU1500 */
 
@@ -739,15 +739,15 @@ enum soc_au1100_ints {
 	AU1000_GPIO_31,
 };
 
-#define UART0_ADDR                0xB1100000
-#define UART1_ADDR                0xB1200000
-#define UART3_ADDR                0xB1400000
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+#define UART3_ADDR		0xB1400000
 
-#define USB_OHCI_BASE             0x10100000 // phys addr for ioremap
-#define USB_HOST_CONFIG           0xB017fffc
+#define USB_OHCI_BASE		0x10100000	/* phys addr for ioremap */
+#define USB_HOST_CONFIG 	0xB017FFFC
 
-#define AU1100_ETH0_BASE	  0xB0500000
-#define AU1100_MAC0_ENABLE       0xB0520000
+#define AU1100_ETH0_BASE	0xB0500000
+#define AU1100_MAC0_ENABLE	0xB0520000
 #define NUM_ETH_INTERFACES 1
 #endif /* CONFIG_SOC_AU1100 */
 
@@ -826,18 +826,18 @@ enum soc_au1550_ints {
 #define INTC AU1550_PCI_INTC
 #define INTD AU1550_PCI_INTD
 
-#define UART0_ADDR                0xB1100000
-#define UART1_ADDR                0xB1200000
-#define UART3_ADDR                0xB1400000
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+#define UART3_ADDR		0xB1400000
 
-#define USB_OHCI_BASE             0x14020000 // phys addr for ioremap
-#define USB_OHCI_LEN              0x00060000
-#define USB_HOST_CONFIG           0xB4027ffc
+#define USB_OHCI_BASE		0x14020000	/* phys addr for ioremap */
+#define USB_OHCI_LEN		0x00060000
+#define USB_HOST_CONFIG 	0xB4027ffc
 
-#define AU1550_ETH0_BASE      0xB0500000
-#define AU1550_ETH1_BASE      0xB0510000
-#define AU1550_MAC0_ENABLE       0xB0520000
-#define AU1550_MAC1_ENABLE       0xB0520004
+#define AU1550_ETH0_BASE	0xB0500000
+#define AU1550_ETH1_BASE	0xB0510000
+#define AU1550_MAC0_ENABLE	0xB0520000
+#define AU1550_MAC1_ENABLE	0xB0520004
 #define NUM_ETH_INTERFACES 2
 #endif /* CONFIG_SOC_AU1550 */
 
@@ -911,32 +911,32 @@ enum soc_au1200_ints {
 	AU1000_GPIO_31,
 };
 
-#define UART0_ADDR                0xB1100000
-#define UART1_ADDR                0xB1200000
-
-#define USB_UOC_BASE              0x14020020
-#define USB_UOC_LEN               0x20
-#define USB_OHCI_BASE             0x14020100
-#define USB_OHCI_LEN              0x100
-#define USB_EHCI_BASE             0x14020200
-#define USB_EHCI_LEN              0x100
-#define USB_UDC_BASE              0x14022000
-#define USB_UDC_LEN               0x2000
-#define USB_MSR_BASE			  0xB4020000
-#define USB_MSR_MCFG              4
-#define USBMSRMCFG_OMEMEN         0
-#define USBMSRMCFG_OBMEN          1
-#define USBMSRMCFG_EMEMEN         2
-#define USBMSRMCFG_EBMEN          3
-#define USBMSRMCFG_DMEMEN         4
-#define USBMSRMCFG_DBMEN          5
-#define USBMSRMCFG_GMEMEN         6
-#define USBMSRMCFG_OHCCLKEN       16
-#define USBMSRMCFG_EHCCLKEN       17
-#define USBMSRMCFG_UDCCLKEN       18
-#define USBMSRMCFG_PHYPLLEN       19
-#define USBMSRMCFG_RDCOMB         30
-#define USBMSRMCFG_PFEN           31
+#define UART0_ADDR		0xB1100000
+#define UART1_ADDR		0xB1200000
+
+#define USB_UOC_BASE		0x14020020
+#define USB_UOC_LEN		0x20
+#define USB_OHCI_BASE		0x14020100
+#define USB_OHCI_LEN		0x100
+#define USB_EHCI_BASE		0x14020200
+#define USB_EHCI_LEN		0x100
+#define USB_UDC_BASE		0x14022000
+#define USB_UDC_LEN		0x2000
+#define USB_MSR_BASE		0xB4020000
+#define USB_MSR_MCFG		4
+#define USBMSRMCFG_OMEMEN	0
+#define USBMSRMCFG_OBMEN	1
+#define USBMSRMCFG_EMEMEN	2
+#define USBMSRMCFG_EBMEN	3
+#define USBMSRMCFG_DMEMEN	4
+#define USBMSRMCFG_DBMEN	5
+#define USBMSRMCFG_GMEMEN	6
+#define USBMSRMCFG_OHCCLKEN	16
+#define USBMSRMCFG_EHCCLKEN	17
+#define USBMSRMCFG_UDCCLKEN	18
+#define USBMSRMCFG_PHYPLLEN	19
+#define USBMSRMCFG_RDCOMB	30
+#define USBMSRMCFG_PFEN 	31
 
 #endif /* CONFIG_SOC_AU1200 */
 
@@ -949,259 +949,258 @@ enum soc_au1200_ints {
 #define INTX			0xFF			/* not valid */
 
 /* Programmable Counters 0 and 1 */
-#define SYS_BASE                   0xB1900000
-#define SYS_COUNTER_CNTRL          (SYS_BASE + 0x14)
-#  define SYS_CNTRL_E1S            (1<<23)
-#  define SYS_CNTRL_T1S            (1<<20)
-#  define SYS_CNTRL_M21            (1<<19)
-#  define SYS_CNTRL_M11            (1<<18)
-#  define SYS_CNTRL_M01            (1<<17)
-#  define SYS_CNTRL_C1S            (1<<16)
-#  define SYS_CNTRL_BP             (1<<14)
-#  define SYS_CNTRL_EN1            (1<<13)
-#  define SYS_CNTRL_BT1            (1<<12)
-#  define SYS_CNTRL_EN0            (1<<11)
-#  define SYS_CNTRL_BT0            (1<<10)
-#  define SYS_CNTRL_E0             (1<<8)
-#  define SYS_CNTRL_E0S            (1<<7)
-#  define SYS_CNTRL_32S            (1<<5)
-#  define SYS_CNTRL_T0S            (1<<4)
-#  define SYS_CNTRL_M20            (1<<3)
-#  define SYS_CNTRL_M10            (1<<2)
-#  define SYS_CNTRL_M00            (1<<1)
-#  define SYS_CNTRL_C0S            (1<<0)
+#define SYS_BASE		0xB1900000
+#define SYS_COUNTER_CNTRL	(SYS_BASE + 0x14)
+#  define SYS_CNTRL_E1S 	(1 << 23)
+#  define SYS_CNTRL_T1S 	(1 << 20)
+#  define SYS_CNTRL_M21 	(1 << 19)
+#  define SYS_CNTRL_M11 	(1 << 18)
+#  define SYS_CNTRL_M01 	(1 << 17)
+#  define SYS_CNTRL_C1S 	(1 << 16)
+#  define SYS_CNTRL_BP		(1 << 14)
+#  define SYS_CNTRL_EN1 	(1 << 13)
+#  define SYS_CNTRL_BT1 	(1 << 12)
+#  define SYS_CNTRL_EN0 	(1 << 11)
+#  define SYS_CNTRL_BT0 	(1 << 10)
+#  define SYS_CNTRL_E0		(1 << 8)
+#  define SYS_CNTRL_E0S 	(1 << 7)
+#  define SYS_CNTRL_32S 	(1 << 5)
+#  define SYS_CNTRL_T0S 	(1 << 4)
+#  define SYS_CNTRL_M20 	(1 << 3)
+#  define SYS_CNTRL_M10 	(1 << 2)
+#  define SYS_CNTRL_M00 	(1 << 1)
+#  define SYS_CNTRL_C0S 	(1 << 0)
 
 /* Programmable Counter 0 Registers */
-#define SYS_TOYTRIM                 (SYS_BASE + 0)
-#define SYS_TOYWRITE                (SYS_BASE + 4)
-#define SYS_TOYMATCH0               (SYS_BASE + 8)
-#define SYS_TOYMATCH1               (SYS_BASE + 0xC)
-#define SYS_TOYMATCH2               (SYS_BASE + 0x10)
-#define SYS_TOYREAD                 (SYS_BASE + 0x40)
+#define SYS_TOYTRIM		(SYS_BASE + 0)
+#define SYS_TOYWRITE		(SYS_BASE + 4)
+#define SYS_TOYMATCH0		(SYS_BASE + 8)
+#define SYS_TOYMATCH1		(SYS_BASE + 0xC)
+#define SYS_TOYMATCH2		(SYS_BASE + 0x10)
+#define SYS_TOYREAD		(SYS_BASE + 0x40)
 
 /* Programmable Counter 1 Registers */
-#define SYS_RTCTRIM                 (SYS_BASE + 0x44)
-#define SYS_RTCWRITE                (SYS_BASE + 0x48)
-#define SYS_RTCMATCH0               (SYS_BASE + 0x4C)
-#define SYS_RTCMATCH1               (SYS_BASE + 0x50)
-#define SYS_RTCMATCH2               (SYS_BASE + 0x54)
-#define SYS_RTCREAD                 (SYS_BASE + 0x58)
+#define SYS_RTCTRIM		(SYS_BASE + 0x44)
+#define SYS_RTCWRITE		(SYS_BASE + 0x48)
+#define SYS_RTCMATCH0		(SYS_BASE + 0x4C)
+#define SYS_RTCMATCH1		(SYS_BASE + 0x50)
+#define SYS_RTCMATCH2		(SYS_BASE + 0x54)
+#define SYS_RTCREAD		(SYS_BASE + 0x58)
 
 /* I2S Controller */
-#define I2S_DATA                    0xB1000000
-#  define I2S_DATA_MASK        (0xffffff)
-#define I2S_CONFIG                0xB1000004
-#  define I2S_CONFIG_XU        (1<<25)
-#  define I2S_CONFIG_XO        (1<<24)
-#  define I2S_CONFIG_RU        (1<<23)
-#  define I2S_CONFIG_RO        (1<<22)
-#  define I2S_CONFIG_TR        (1<<21)
-#  define I2S_CONFIG_TE        (1<<20)
-#  define I2S_CONFIG_TF        (1<<19)
-#  define I2S_CONFIG_RR        (1<<18)
-#  define I2S_CONFIG_RE        (1<<17)
-#  define I2S_CONFIG_RF        (1<<16)
-#  define I2S_CONFIG_PD        (1<<11)
-#  define I2S_CONFIG_LB        (1<<10)
-#  define I2S_CONFIG_IC        (1<<9)
-#  define I2S_CONFIG_FM_BIT    7
-#  define I2S_CONFIG_FM_MASK     (0x3 << I2S_CONFIG_FM_BIT)
-#    define I2S_CONFIG_FM_I2S    (0x0 << I2S_CONFIG_FM_BIT)
-#    define I2S_CONFIG_FM_LJ     (0x1 << I2S_CONFIG_FM_BIT)
-#    define I2S_CONFIG_FM_RJ     (0x2 << I2S_CONFIG_FM_BIT)
-#  define I2S_CONFIG_TN        (1<<6)
-#  define I2S_CONFIG_RN        (1<<5)
-#  define I2S_CONFIG_SZ_BIT    0
-#  define I2S_CONFIG_SZ_MASK     (0x1F << I2S_CONFIG_SZ_BIT)
-
-#define I2S_CONTROL                0xB1000008
-#  define I2S_CONTROL_D         (1<<1)
-#  define I2S_CONTROL_CE        (1<<0)
+#define I2S_DATA		0xB1000000
+#  define I2S_DATA_MASK 	0xffffff
+#define I2S_CONFIG		0xB1000004
+#  define I2S_CONFIG_XU 	(1 << 25)
+#  define I2S_CONFIG_XO 	(1 << 24)
+#  define I2S_CONFIG_RU 	(1 << 23)
+#  define I2S_CONFIG_RO 	(1 << 22)
+#  define I2S_CONFIG_TR 	(1 << 21)
+#  define I2S_CONFIG_TE 	(1 << 20)
+#  define I2S_CONFIG_TF 	(1 << 19)
+#  define I2S_CONFIG_RR 	(1 << 18)
+#  define I2S_CONFIG_RE 	(1 << 17)
+#  define I2S_CONFIG_RF 	(1 << 16)
+#  define I2S_CONFIG_PD 	(1 << 11)
+#  define I2S_CONFIG_LB 	(1 << 10)
+#  define I2S_CONFIG_IC 	(1 << 9)
+#  define I2S_CONFIG_FM_BIT	7
+#  define I2S_CONFIG_FM_MASK	(0x3 << I2S_CONFIG_FM_BIT)
+#    define I2S_CONFIG_FM_I2S	(0x0 << I2S_CONFIG_FM_BIT)
+#    define I2S_CONFIG_FM_LJ	(0x1 << I2S_CONFIG_FM_BIT)
+#    define I2S_CONFIG_FM_RJ	(0x2 << I2S_CONFIG_FM_BIT)
+#  define I2S_CONFIG_TN 	(1 << 6)
+#  define I2S_CONFIG_RN 	(1 << 5)
+#  define I2S_CONFIG_SZ_BIT	0
+#  define I2S_CONFIG_SZ_MASK	(0x1F << I2S_CONFIG_SZ_BIT)
+
+#define I2S_CONTROL		0xB1000008
+#  define I2S_CONTROL_D 	(1 << 1)
+#  define I2S_CONTROL_CE	(1 << 0)
 
 /* USB Host Controller */
 #ifndef USB_OHCI_LEN
-#define USB_OHCI_LEN              0x00100000
+#define USB_OHCI_LEN		0x00100000
 #endif
 
 #ifndef CONFIG_SOC_AU1200
 
 /* USB Device Controller */
-#define USBD_EP0RD                0xB0200000
-#define USBD_EP0WR                0xB0200004
-#define USBD_EP2WR                0xB0200008
-#define USBD_EP3WR                0xB020000C
-#define USBD_EP4RD                0xB0200010
-#define USBD_EP5RD                0xB0200014
-#define USBD_INTEN                0xB0200018
-#define USBD_INTSTAT              0xB020001C
-#  define USBDEV_INT_SOF       (1<<12)
-#  define USBDEV_INT_HF_BIT    6
-#  define USBDEV_INT_HF_MASK   (0x3f << USBDEV_INT_HF_BIT)
-#  define USBDEV_INT_CMPLT_BIT  0
+#define USBD_EP0RD		0xB0200000
+#define USBD_EP0WR		0xB0200004
+#define USBD_EP2WR		0xB0200008
+#define USBD_EP3WR		0xB020000C
+#define USBD_EP4RD		0xB0200010
+#define USBD_EP5RD		0xB0200014
+#define USBD_INTEN		0xB0200018
+#define USBD_INTSTAT		0xB020001C
+#  define USBDEV_INT_SOF	(1 << 12)
+#  define USBDEV_INT_HF_BIT	6
+#  define USBDEV_INT_HF_MASK	0x3f << USBDEV_INT_HF_BIT)
+#  define USBDEV_INT_CMPLT_BIT	0
 #  define USBDEV_INT_CMPLT_MASK (0x3f << USBDEV_INT_CMPLT_BIT)
-#define USBD_CONFIG               0xB0200020
-#define USBD_EP0CS                0xB0200024
-#define USBD_EP2CS                0xB0200028
-#define USBD_EP3CS                0xB020002C
-#define USBD_EP4CS                0xB0200030
-#define USBD_EP5CS                0xB0200034
-#  define USBDEV_CS_SU         (1<<14)
-#  define USBDEV_CS_NAK        (1<<13)
-#  define USBDEV_CS_ACK        (1<<12)
-#  define USBDEV_CS_BUSY       (1<<11)
-#  define USBDEV_CS_TSIZE_BIT  1
-#  define USBDEV_CS_TSIZE_MASK (0x3ff << USBDEV_CS_TSIZE_BIT)
-#  define USBDEV_CS_STALL      (1<<0)
-#define USBD_EP0RDSTAT            0xB0200040
-#define USBD_EP0WRSTAT            0xB0200044
-#define USBD_EP2WRSTAT            0xB0200048
-#define USBD_EP3WRSTAT            0xB020004C
-#define USBD_EP4RDSTAT            0xB0200050
-#define USBD_EP5RDSTAT            0xB0200054
-#  define USBDEV_FSTAT_FLUSH     (1<<6)
-#  define USBDEV_FSTAT_UF        (1<<5)
-#  define USBDEV_FSTAT_OF        (1<<4)
-#  define USBDEV_FSTAT_FCNT_BIT  0
+#define USBD_CONFIG		0xB0200020
+#define USBD_EP0CS		0xB0200024
+#define USBD_EP2CS		0xB0200028
+#define USBD_EP3CS		0xB020002C
+#define USBD_EP4CS		0xB0200030
+#define USBD_EP5CS		0xB0200034
+#  define USBDEV_CS_SU		(1 << 14)
+#  define USBDEV_CS_NAK 	(1 << 13)
+#  define USBDEV_CS_ACK 	(1 << 12)
+#  define USBDEV_CS_BUSY	(1 << 11)
+#  define USBDEV_CS_TSIZE_BIT	1
+#  define USBDEV_CS_TSIZE_MASK	(0x3ff << USBDEV_CS_TSIZE_BIT)
+#  define USBDEV_CS_STALL	(1 << 0)
+#define USBD_EP0RDSTAT		0xB0200040
+#define USBD_EP0WRSTAT		0xB0200044
+#define USBD_EP2WRSTAT		0xB0200048
+#define USBD_EP3WRSTAT		0xB020004C
+#define USBD_EP4RDSTAT		0xB0200050
+#define USBD_EP5RDSTAT		0xB0200054
+#  define USBDEV_FSTAT_FLUSH	(1 << 6)
+#  define USBDEV_FSTAT_UF	(1 << 5)
+#  define USBDEV_FSTAT_OF	(1 << 4)
+#  define USBDEV_FSTAT_FCNT_BIT 0
 #  define USBDEV_FSTAT_FCNT_MASK (0x0f << USBDEV_FSTAT_FCNT_BIT)
-#define USBD_ENABLE               0xB0200058
-#  define USBDEV_ENABLE (1<<1)
-#  define USBDEV_CE     (1<<0)
+#define USBD_ENABLE		0xB0200058
+#  define USBDEV_ENABLE 	(1 << 1)
+#  define USBDEV_CE		(1 << 0)
 
 #endif /* !CONFIG_SOC_AU1200 */
 
 /* Ethernet Controllers  */
 
 /* 4 byte offsets from AU1000_ETH_BASE */
-#define MAC_CONTROL                     0x0
-#  define MAC_RX_ENABLE               (1<<2)
-#  define MAC_TX_ENABLE               (1<<3)
-#  define MAC_DEF_CHECK               (1<<5)
-#  define MAC_SET_BL(X)       (((X)&0x3)<<6)
-#  define MAC_AUTO_PAD                (1<<8)
-#  define MAC_DISABLE_RETRY          (1<<10)
-#  define MAC_DISABLE_BCAST          (1<<11)
-#  define MAC_LATE_COL               (1<<12)
-#  define MAC_HASH_MODE              (1<<13)
-#  define MAC_HASH_ONLY              (1<<15)
-#  define MAC_PASS_ALL               (1<<16)
-#  define MAC_INVERSE_FILTER         (1<<17)
-#  define MAC_PROMISCUOUS            (1<<18)
-#  define MAC_PASS_ALL_MULTI         (1<<19)
-#  define MAC_FULL_DUPLEX            (1<<20)
-#  define MAC_NORMAL_MODE                 0
-#  define MAC_INT_LOOPBACK           (1<<21)
-#  define MAC_EXT_LOOPBACK           (1<<22)
-#  define MAC_DISABLE_RX_OWN         (1<<23)
-#  define MAC_BIG_ENDIAN             (1<<30)
-#  define MAC_RX_ALL                 (1<<31)
-#define MAC_ADDRESS_HIGH                0x4
-#define MAC_ADDRESS_LOW                 0x8
-#define MAC_MCAST_HIGH                  0xC
-#define MAC_MCAST_LOW                  0x10
-#define MAC_MII_CNTRL                  0x14
-#  define MAC_MII_BUSY                (1<<0)
-#  define MAC_MII_READ                     0
-#  define MAC_MII_WRITE               (1<<1)
-#  define MAC_SET_MII_SELECT_REG(X)   (((X)&0x1f)<<6)
-#  define MAC_SET_MII_SELECT_PHY(X)   (((X)&0x1f)<<11)
-#define MAC_MII_DATA                   0x18
-#define MAC_FLOW_CNTRL                 0x1C
-#  define MAC_FLOW_CNTRL_BUSY         (1<<0)
-#  define MAC_FLOW_CNTRL_ENABLE       (1<<1)
-#  define MAC_PASS_CONTROL            (1<<2)
-#  define MAC_SET_PAUSE(X)        (((X)&0xffff)<<16)
-#define MAC_VLAN1_TAG                  0x20
-#define MAC_VLAN2_TAG                  0x24
+#define MAC_CONTROL		0x0
+#  define MAC_RX_ENABLE 	(1 << 2)
+#  define MAC_TX_ENABLE 	(1 << 3)
+#  define MAC_DEF_CHECK 	(1 << 5)
+#  define MAC_SET_BL(X) 	(((X) & 0x3) << 6)
+#  define MAC_AUTO_PAD		(1 << 8)
+#  define MAC_DISABLE_RETRY	(1 << 10)
+#  define MAC_DISABLE_BCAST	(1 << 11)
+#  define MAC_LATE_COL		(1 << 12)
+#  define MAC_HASH_MODE 	(1 << 13)
+#  define MAC_HASH_ONLY 	(1 << 15)
+#  define MAC_PASS_ALL		(1 << 16)
+#  define MAC_INVERSE_FILTER	(1 << 17)
+#  define MAC_PROMISCUOUS	(1 << 18)
+#  define MAC_PASS_ALL_MULTI	(1 << 19)
+#  define MAC_FULL_DUPLEX	(1 << 20)
+#  define MAC_NORMAL_MODE	0
+#  define MAC_INT_LOOPBACK	(1 << 21)
+#  define MAC_EXT_LOOPBACK	(1 << 22)
+#  define MAC_DISABLE_RX_OWN	(1 << 23)
+#  define MAC_BIG_ENDIAN	(1 << 30)
+#  define MAC_RX_ALL		(1 << 31)
+#define MAC_ADDRESS_HIGH	0x4
+#define MAC_ADDRESS_LOW		0x8
+#define MAC_MCAST_HIGH		0xC
+#define MAC_MCAST_LOW		0x10
+#define MAC_MII_CNTRL		0x14
+#  define MAC_MII_BUSY		(1 << 0)
+#  define MAC_MII_READ		0
+#  define MAC_MII_WRITE		(1 << 1)
+#  define MAC_SET_MII_SELECT_REG(X) (((X) & 0x1f) << 6)
+#  define MAC_SET_MII_SELECT_PHY(X) (((X) & 0x1f) << 11)
+#define MAC_MII_DATA		0x18
+#define MAC_FLOW_CNTRL		0x1C
+#  define MAC_FLOW_CNTRL_BUSY	(1 << 0)
+#  define MAC_FLOW_CNTRL_ENABLE (1 << 1)
+#  define MAC_PASS_CONTROL	(1 << 2)
+#  define MAC_SET_PAUSE(X)	(((X) & 0xffff) << 16)
+#define MAC_VLAN1_TAG		0x20
+#define MAC_VLAN2_TAG		0x24
 
 /* Ethernet Controller Enable */
 
-#  define MAC_EN_CLOCK_ENABLE         (1<<0)
-#  define MAC_EN_RESET0               (1<<1)
-#  define MAC_EN_TOSS                 (0<<2)
-#  define MAC_EN_CACHEABLE            (1<<3)
-#  define MAC_EN_RESET1               (1<<4)
-#  define MAC_EN_RESET2               (1<<5)
-#  define MAC_DMA_RESET               (1<<6)
+#  define MAC_EN_CLOCK_ENABLE	(1 << 0)
+#  define MAC_EN_RESET0		(1 << 1)
+#  define MAC_EN_TOSS		(0 << 2)
+#  define MAC_EN_CACHEABLE	(1 << 3)
+#  define MAC_EN_RESET1 	(1 << 4)
+#  define MAC_EN_RESET2 	(1 << 5)
+#  define MAC_DMA_RESET 	(1 << 6)
 
 /* Ethernet Controller DMA Channels */
 
-#define MAC0_TX_DMA_ADDR         0xB4004000
-#define MAC1_TX_DMA_ADDR         0xB4004200
+#define MAC0_TX_DMA_ADDR	0xB4004000
+#define MAC1_TX_DMA_ADDR	0xB4004200
 /* offsets from MAC_TX_RING_ADDR address */
-#define MAC_TX_BUFF0_STATUS             0x0
-#  define TX_FRAME_ABORTED            (1<<0)
-#  define TX_JAB_TIMEOUT              (1<<1)
-#  define TX_NO_CARRIER               (1<<2)
-#  define TX_LOSS_CARRIER             (1<<3)
-#  define TX_EXC_DEF                  (1<<4)
-#  define TX_LATE_COLL_ABORT          (1<<5)
-#  define TX_EXC_COLL                 (1<<6)
-#  define TX_UNDERRUN                 (1<<7)
-#  define TX_DEFERRED                 (1<<8)
-#  define TX_LATE_COLL                (1<<9)
-#  define TX_COLL_CNT_MASK         (0xF<<10)
-#  define TX_PKT_RETRY               (1<<31)
-#define MAC_TX_BUFF0_ADDR                0x4
-#  define TX_DMA_ENABLE               (1<<0)
-#  define TX_T_DONE                   (1<<1)
-#  define TX_GET_DMA_BUFFER(X)    (((X)>>2)&0x3)
-#define MAC_TX_BUFF0_LEN                 0x8
-#define MAC_TX_BUFF1_STATUS             0x10
-#define MAC_TX_BUFF1_ADDR               0x14
-#define MAC_TX_BUFF1_LEN                0x18
-#define MAC_TX_BUFF2_STATUS             0x20
-#define MAC_TX_BUFF2_ADDR               0x24
-#define MAC_TX_BUFF2_LEN                0x28
-#define MAC_TX_BUFF3_STATUS             0x30
-#define MAC_TX_BUFF3_ADDR               0x34
-#define MAC_TX_BUFF3_LEN                0x38
-
-#define MAC0_RX_DMA_ADDR         0xB4004100
-#define MAC1_RX_DMA_ADDR         0xB4004300
+#define MAC_TX_BUFF0_STATUS	0x0
+#  define TX_FRAME_ABORTED	(1 << 0)
+#  define TX_JAB_TIMEOUT	(1 << 1)
+#  define TX_NO_CARRIER 	(1 << 2)
+#  define TX_LOSS_CARRIER	(1 << 3)
+#  define TX_EXC_DEF		(1 << 4)
+#  define TX_LATE_COLL_ABORT	(1 << 5)
+#  define TX_EXC_COLL		(1 << 6)
+#  define TX_UNDERRUN		(1 << 7)
+#  define TX_DEFERRED		(1 << 8)
+#  define TX_LATE_COLL		(1 << 9)
+#  define TX_COLL_CNT_MASK	(0xF << 10)
+#  define TX_PKT_RETRY		(1 << 31)
+#define MAC_TX_BUFF0_ADDR	0x4
+#  define TX_DMA_ENABLE 	(1 << 0)
+#  define TX_T_DONE		(1 << 1)
+#  define TX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
+#define MAC_TX_BUFF0_LEN	0x8
+#define MAC_TX_BUFF1_STATUS	0x10
+#define MAC_TX_BUFF1_ADDR	0x14
+#define MAC_TX_BUFF1_LEN	0x18
+#define MAC_TX_BUFF2_STATUS	0x20
+#define MAC_TX_BUFF2_ADDR	0x24
+#define MAC_TX_BUFF2_LEN	0x28
+#define MAC_TX_BUFF3_STATUS	0x30
+#define MAC_TX_BUFF3_ADDR	0x34
+#define MAC_TX_BUFF3_LEN	0x38
+
+#define MAC0_RX_DMA_ADDR	0xB4004100
+#define MAC1_RX_DMA_ADDR	0xB4004300
 /* offsets from MAC_RX_RING_ADDR */
-#define MAC_RX_BUFF0_STATUS              0x0
-#  define RX_FRAME_LEN_MASK           0x3fff
-#  define RX_WDOG_TIMER              (1<<14)
-#  define RX_RUNT                    (1<<15)
-#  define RX_OVERLEN                 (1<<16)
-#  define RX_COLL                    (1<<17)
-#  define RX_ETHER                   (1<<18)
-#  define RX_MII_ERROR               (1<<19)
-#  define RX_DRIBBLING               (1<<20)
-#  define RX_CRC_ERROR               (1<<21)
-#  define RX_VLAN1                   (1<<22)
-#  define RX_VLAN2                   (1<<23)
-#  define RX_LEN_ERROR               (1<<24)
-#  define RX_CNTRL_FRAME             (1<<25)
-#  define RX_U_CNTRL_FRAME           (1<<26)
-#  define RX_MCAST_FRAME             (1<<27)
-#  define RX_BCAST_FRAME             (1<<28)
-#  define RX_FILTER_FAIL             (1<<29)
-#  define RX_PACKET_FILTER           (1<<30)
-#  define RX_MISSED_FRAME            (1<<31)
+#define MAC_RX_BUFF0_STATUS	0x0
+#  define RX_FRAME_LEN_MASK	0x3fff
+#  define RX_WDOG_TIMER 	(1 << 14)
+#  define RX_RUNT		(1 << 15)
+#  define RX_OVERLEN		(1 << 16)
+#  define RX_COLL		(1 << 17)
+#  define RX_ETHER		(1 << 18)
+#  define RX_MII_ERROR		(1 << 19)
+#  define RX_DRIBBLING		(1 << 20)
+#  define RX_CRC_ERROR		(1 << 21)
+#  define RX_VLAN1		(1 << 22)
+#  define RX_VLAN2		(1 << 23)
+#  define RX_LEN_ERROR		(1 << 24)
+#  define RX_CNTRL_FRAME	(1 << 25)
+#  define RX_U_CNTRL_FRAME	(1 << 26)
+#  define RX_MCAST_FRAME	(1 << 27)
+#  define RX_BCAST_FRAME	(1 << 28)
+#  define RX_FILTER_FAIL	(1 << 29)
+#  define RX_PACKET_FILTER	(1 << 30)
+#  define RX_MISSED_FRAME	(1 << 31)
 
 #  define RX_ERROR (RX_WDOG_TIMER | RX_RUNT | RX_OVERLEN |  \
-                    RX_COLL | RX_MII_ERROR | RX_CRC_ERROR | \
-                    RX_LEN_ERROR | RX_U_CNTRL_FRAME | RX_MISSED_FRAME)
-#define MAC_RX_BUFF0_ADDR                0x4
-#  define RX_DMA_ENABLE               (1<<0)
-#  define RX_T_DONE                   (1<<1)
-#  define RX_GET_DMA_BUFFER(X)    (((X)>>2)&0x3)
-#  define RX_SET_BUFF_ADDR(X)     ((X)&0xffffffc0)
-#define MAC_RX_BUFF1_STATUS              0x10
-#define MAC_RX_BUFF1_ADDR                0x14
-#define MAC_RX_BUFF2_STATUS              0x20
-#define MAC_RX_BUFF2_ADDR                0x24
-#define MAC_RX_BUFF3_STATUS              0x30
-#define MAC_RX_BUFF3_ADDR                0x34
-
+		    RX_COLL | RX_MII_ERROR | RX_CRC_ERROR | \
+		    RX_LEN_ERROR | RX_U_CNTRL_FRAME | RX_MISSED_FRAME)
+#define MAC_RX_BUFF0_ADDR	0x4
+#  define RX_DMA_ENABLE 	(1 << 0)
+#  define RX_T_DONE		(1 << 1)
+#  define RX_GET_DMA_BUFFER(X)	(((X) >> 2) & 0x3)
+#  define RX_SET_BUFF_ADDR(X)	((X) & 0xffffffc0)
+#define MAC_RX_BUFF1_STATUS	0x10
+#define MAC_RX_BUFF1_ADDR	0x14
+#define MAC_RX_BUFF2_STATUS	0x20
+#define MAC_RX_BUFF2_ADDR	0x24
+#define MAC_RX_BUFF3_STATUS	0x30
+#define MAC_RX_BUFF3_ADDR	0x34
 
 /* UARTS 0-3 */
-#define UART_BASE                 UART0_ADDR
+#define UART_BASE		UART0_ADDR
 #ifdef	CONFIG_SOC_AU1200
-#define UART_DEBUG_BASE           UART1_ADDR
+#define UART_DEBUG_BASE 	UART1_ADDR
 #else
-#define UART_DEBUG_BASE           UART3_ADDR
+#define UART_DEBUG_BASE 	UART3_ADDR
 #endif
 
 #define UART_RX		0	/* Receive buffer */
@@ -1294,341 +1293,337 @@ enum soc_au1200_ints {
 #define UART_MSR_DCTS	0x01	/* Delta CTS */
 #define UART_MSR_ANY_DELTA 0x0F	/* Any of the delta bits! */
 
-
-
 /* SSIO */
-#define SSI0_STATUS                0xB1600000
-#  define SSI_STATUS_BF              (1<<4)
-#  define SSI_STATUS_OF              (1<<3)
-#  define SSI_STATUS_UF              (1<<2)
-#  define SSI_STATUS_D               (1<<1)
-#  define SSI_STATUS_B               (1<<0)
-#define SSI0_INT                   0xB1600004
-#  define SSI_INT_OI                 (1<<3)
-#  define SSI_INT_UI                 (1<<2)
-#  define SSI_INT_DI                 (1<<1)
-#define SSI0_INT_ENABLE            0xB1600008
-#  define SSI_INTE_OIE               (1<<3)
-#  define SSI_INTE_UIE               (1<<2)
-#  define SSI_INTE_DIE               (1<<1)
-#define SSI0_CONFIG                0xB1600020
-#  define SSI_CONFIG_AO              (1<<24)
-#  define SSI_CONFIG_DO              (1<<23)
-#  define SSI_CONFIG_ALEN_BIT        20
-#    define SSI_CONFIG_ALEN_MASK       (0x7<<20)
-#  define SSI_CONFIG_DLEN_BIT        16
-#    define SSI_CONFIG_DLEN_MASK       (0x7<<16)
-#  define SSI_CONFIG_DD              (1<<11)
-#  define SSI_CONFIG_AD              (1<<10)
-#  define SSI_CONFIG_BM_BIT          8
-#    define SSI_CONFIG_BM_MASK         (0x3<<8)
-#  define SSI_CONFIG_CE              (1<<7)
-#  define SSI_CONFIG_DP              (1<<6)
-#  define SSI_CONFIG_DL              (1<<5)
-#  define SSI_CONFIG_EP              (1<<4)
-#define SSI0_ADATA                 0xB1600024
-#  define SSI_AD_D                   (1<<24)
-#  define SSI_AD_ADDR_BIT            16
-#    define SSI_AD_ADDR_MASK           (0xff<<16)
-#  define SSI_AD_DATA_BIT            0
-#    define SSI_AD_DATA_MASK           (0xfff<<0)
-#define SSI0_CLKDIV                0xB1600028
-#define SSI0_CONTROL               0xB1600100
-#  define SSI_CONTROL_CD             (1<<1)
-#  define SSI_CONTROL_E              (1<<0)
+#define SSI0_STATUS		0xB1600000
+#  define SSI_STATUS_BF 	(1 << 4)
+#  define SSI_STATUS_OF 	(1 << 3)
+#  define SSI_STATUS_UF 	(1 << 2)
+#  define SSI_STATUS_D		(1 << 1)
+#  define SSI_STATUS_B		(1 << 0)
+#define SSI0_INT		0xB1600004
+#  define SSI_INT_OI		(1 << 3)
+#  define SSI_INT_UI		(1 << 2)
+#  define SSI_INT_DI		(1 << 1)
+#define SSI0_INT_ENABLE 	0xB1600008
+#  define SSI_INTE_OIE		(1 << 3)
+#  define SSI_INTE_UIE		(1 << 2)
+#  define SSI_INTE_DIE		(1 << 1)
+#define SSI0_CONFIG		0xB1600020
+#  define SSI_CONFIG_AO 	(1 << 24)
+#  define SSI_CONFIG_DO 	(1 << 23)
+#  define SSI_CONFIG_ALEN_BIT	20
+#  define SSI_CONFIG_ALEN_MASK	(0x7 << 20)
+#  define SSI_CONFIG_DLEN_BIT	16
+#  define SSI_CONFIG_DLEN_MASK	(0x7 << 16)
+#  define SSI_CONFIG_DD 	(1 << 11)
+#  define SSI_CONFIG_AD 	(1 << 10)
+#  define SSI_CONFIG_BM_BIT	8
+#  define SSI_CONFIG_BM_MASK	(0x3 << 8)
+#  define SSI_CONFIG_CE 	(1 << 7)
+#  define SSI_CONFIG_DP 	(1 << 6)
+#  define SSI_CONFIG_DL 	(1 << 5)
+#  define SSI_CONFIG_EP 	(1 << 4)
+#define SSI0_ADATA		0xB1600024
+#  define SSI_AD_D		(1 << 24)
+#  define SSI_AD_ADDR_BIT	16
+#  define SSI_AD_ADDR_MASK	(0xff << 16)
+#  define SSI_AD_DATA_BIT	0
+#  define SSI_AD_DATA_MASK	(0xfff << 0)
+#define SSI0_CLKDIV		0xB1600028
+#define SSI0_CONTROL		0xB1600100
+#  define SSI_CONTROL_CD	(1 << 1)
+#  define SSI_CONTROL_E 	(1 << 0)
 
 /* SSI1 */
-#define SSI1_STATUS                0xB1680000
-#define SSI1_INT                   0xB1680004
-#define SSI1_INT_ENABLE            0xB1680008
-#define SSI1_CONFIG                0xB1680020
-#define SSI1_ADATA                 0xB1680024
-#define SSI1_CLKDIV                0xB1680028
-#define SSI1_ENABLE                0xB1680100
+#define SSI1_STATUS		0xB1680000
+#define SSI1_INT		0xB1680004
+#define SSI1_INT_ENABLE 	0xB1680008
+#define SSI1_CONFIG		0xB1680020
+#define SSI1_ADATA		0xB1680024
+#define SSI1_CLKDIV		0xB1680028
+#define SSI1_ENABLE		0xB1680100
 
 /*
  * Register content definitions
  */
-#define SSI_STATUS_BF				(1<<4)
-#define SSI_STATUS_OF				(1<<3)
-#define SSI_STATUS_UF				(1<<2)
-#define SSI_STATUS_D				(1<<1)
-#define SSI_STATUS_B				(1<<0)
+#define SSI_STATUS_BF		(1 << 4)
+#define SSI_STATUS_OF		(1 << 3)
+#define SSI_STATUS_UF		(1 << 2)
+#define SSI_STATUS_D		(1 << 1)
+#define SSI_STATUS_B		(1 << 0)
 
 /* SSI_INT */
-#define SSI_INT_OI					(1<<3)
-#define SSI_INT_UI					(1<<2)
-#define SSI_INT_DI					(1<<1)
+#define SSI_INT_OI		(1 << 3)
+#define SSI_INT_UI		(1 << 2)
+#define SSI_INT_DI		(1 << 1)
 
 /* SSI_INTEN */
-#define SSI_INTEN_OIE				(1<<3)
-#define SSI_INTEN_UIE				(1<<2)
-#define SSI_INTEN_DIE				(1<<1)
-
-#define SSI_CONFIG_AO				(1<<24)
-#define SSI_CONFIG_DO				(1<<23)
-#define SSI_CONFIG_ALEN				(7<<20)
-#define SSI_CONFIG_DLEN				(15<<16)
-#define SSI_CONFIG_DD				(1<<11)
-#define SSI_CONFIG_AD				(1<<10)
-#define SSI_CONFIG_BM				(3<<8)
-#define SSI_CONFIG_CE				(1<<7)
-#define SSI_CONFIG_DP				(1<<6)
-#define SSI_CONFIG_DL				(1<<5)
-#define SSI_CONFIG_EP				(1<<4)
-#define SSI_CONFIG_ALEN_N(N)		((N-1)<<20)
-#define SSI_CONFIG_DLEN_N(N)		((N-1)<<16)
-#define SSI_CONFIG_BM_HI			(0<<8)
-#define SSI_CONFIG_BM_LO			(1<<8)
-#define SSI_CONFIG_BM_CY			(2<<8)
-
-#define SSI_ADATA_D					(1<<24)
-#define SSI_ADATA_ADDR				(0xFF<<16)
-#define SSI_ADATA_DATA				(0x0FFF)
-#define SSI_ADATA_ADDR_N(N)			(N<<16)
-
-#define SSI_ENABLE_CD				(1<<1)
-#define SSI_ENABLE_E				(1<<0)
-
+#define SSI_INTEN_OIE		(1 << 3)
+#define SSI_INTEN_UIE		(1 << 2)
+#define SSI_INTEN_DIE		(1 << 1)
+
+#define SSI_CONFIG_AO		(1 << 24)
+#define SSI_CONFIG_DO		(1 << 23)
+#define SSI_CONFIG_ALEN 	(7 << 20)
+#define SSI_CONFIG_DLEN 	(15 << 16)
+#define SSI_CONFIG_DD		(1 << 11)
+#define SSI_CONFIG_AD		(1 << 10)
+#define SSI_CONFIG_BM		(3 << 8)
+#define SSI_CONFIG_CE		(1 << 7)
+#define SSI_CONFIG_DP		(1 << 6)
+#define SSI_CONFIG_DL		(1 << 5)
+#define SSI_CONFIG_EP		(1 << 4)
+#define SSI_CONFIG_ALEN_N(N)	((N-1) << 20)
+#define SSI_CONFIG_DLEN_N(N)	((N-1) << 16)
+#define SSI_CONFIG_BM_HI	(0 << 8)
+#define SSI_CONFIG_BM_LO	(1 << 8)
+#define SSI_CONFIG_BM_CY	(2 << 8)
+
+#define SSI_ADATA_D		(1 << 24)
+#define SSI_ADATA_ADDR		(0xFF << 16)
+#define SSI_ADATA_DATA		0x0FFF
+#define SSI_ADATA_ADDR_N(N)	(N << 16)
+
+#define SSI_ENABLE_CD		(1 << 1)
+#define SSI_ENABLE_E		(1 << 0)
 
 /* IrDA Controller */
-#define IRDA_BASE                 0xB0300000
-#define IR_RING_PTR_STATUS        (IRDA_BASE+0x00)
-#define IR_RING_BASE_ADDR_H       (IRDA_BASE+0x04)
-#define IR_RING_BASE_ADDR_L       (IRDA_BASE+0x08)
-#define IR_RING_SIZE              (IRDA_BASE+0x0C)
-#define IR_RING_PROMPT            (IRDA_BASE+0x10)
-#define IR_RING_ADDR_CMPR         (IRDA_BASE+0x14)
-#define IR_INT_CLEAR              (IRDA_BASE+0x18)
-#define IR_CONFIG_1               (IRDA_BASE+0x20)
-#  define IR_RX_INVERT_LED        (1<<0)
-#  define IR_TX_INVERT_LED        (1<<1)
-#  define IR_ST                   (1<<2)
-#  define IR_SF                   (1<<3)
-#  define IR_SIR                  (1<<4)
-#  define IR_MIR                  (1<<5)
-#  define IR_FIR                  (1<<6)
-#  define IR_16CRC                (1<<7)
-#  define IR_TD                   (1<<8)
-#  define IR_RX_ALL               (1<<9)
-#  define IR_DMA_ENABLE           (1<<10)
-#  define IR_RX_ENABLE            (1<<11)
-#  define IR_TX_ENABLE            (1<<12)
-#  define IR_LOOPBACK             (1<<14)
-#  define IR_SIR_MODE	          (IR_SIR | IR_DMA_ENABLE | \
-		                   IR_RX_ALL | IR_RX_ENABLE | IR_SF | IR_16CRC)
-#define IR_SIR_FLAGS              (IRDA_BASE+0x24)
-#define IR_ENABLE                 (IRDA_BASE+0x28)
-#  define IR_RX_STATUS            (1<<9)
-#  define IR_TX_STATUS            (1<<10)
-#define IR_READ_PHY_CONFIG        (IRDA_BASE+0x2C)
-#define IR_WRITE_PHY_CONFIG       (IRDA_BASE+0x30)
-#define IR_MAX_PKT_LEN            (IRDA_BASE+0x34)
-#define IR_RX_BYTE_CNT            (IRDA_BASE+0x38)
-#define IR_CONFIG_2               (IRDA_BASE+0x3C)
-#  define IR_MODE_INV             (1<<0)
-#  define IR_ONE_PIN              (1<<1)
-#define IR_INTERFACE_CONFIG       (IRDA_BASE+0x40)
+#define IRDA_BASE		0xB0300000
+#define IR_RING_PTR_STATUS	(IRDA_BASE + 0x00)
+#define IR_RING_BASE_ADDR_H	(IRDA_BASE + 0x04)
+#define IR_RING_BASE_ADDR_L	(IRDA_BASE + 0x08)
+#define IR_RING_SIZE		(IRDA_BASE + 0x0C)
+#define IR_RING_PROMPT		(IRDA_BASE + 0x10)
+#define IR_RING_ADDR_CMPR	(IRDA_BASE + 0x14)
+#define IR_INT_CLEAR		(IRDA_BASE + 0x18)
+#define IR_CONFIG_1		(IRDA_BASE + 0x20)
+#  define IR_RX_INVERT_LED	(1 << 0)
+#  define IR_TX_INVERT_LED	(1 << 1)
+#  define IR_ST 		(1 << 2)
+#  define IR_SF 		(1 << 3)
+#  define IR_SIR		(1 << 4)
+#  define IR_MIR		(1 << 5)
+#  define IR_FIR		(1 << 6)
+#  define IR_16CRC		(1 << 7)
+#  define IR_TD 		(1 << 8)
+#  define IR_RX_ALL		(1 << 9)
+#  define IR_DMA_ENABLE 	(1 << 10)
+#  define IR_RX_ENABLE		(1 << 11)
+#  define IR_TX_ENABLE		(1 << 12)
+#  define IR_LOOPBACK		(1 << 14)
+#  define IR_SIR_MODE		(IR_SIR | IR_DMA_ENABLE | \
+				 IR_RX_ALL | IR_RX_ENABLE | IR_SF | IR_16CRC)
+#define IR_SIR_FLAGS		(IRDA_BASE + 0x24)
+#define IR_ENABLE		(IRDA_BASE + 0x28)
+#  define IR_RX_STATUS		(1 << 9)
+#  define IR_TX_STATUS		(1 << 10)
+#define IR_READ_PHY_CONFIG	(IRDA_BASE + 0x2C)
+#define IR_WRITE_PHY_CONFIG	(IRDA_BASE + 0x30)
+#define IR_MAX_PKT_LEN		(IRDA_BASE + 0x34)
+#define IR_RX_BYTE_CNT		(IRDA_BASE + 0x38)
+#define IR_CONFIG_2		(IRDA_BASE + 0x3C)
+#  define IR_MODE_INV		(1 << 0)
+#  define IR_ONE_PIN		(1 << 1)
+#define IR_INTERFACE_CONFIG	(IRDA_BASE + 0x40)
 
 /* GPIO */
-#define SYS_PINFUNC               0xB190002C
-#  define SYS_PF_USB			(1<<15)	/* 2nd USB device/host */
-#  define SYS_PF_U3			(1<<14)	/* GPIO23/U3TXD */
-#  define SYS_PF_U2			(1<<13) /* GPIO22/U2TXD */
-#  define SYS_PF_U1			(1<<12) /* GPIO21/U1TXD */
-#  define SYS_PF_SRC			(1<<11)	/* GPIO6/SROMCKE */
-#  define SYS_PF_CK5			(1<<10)	/* GPIO3/CLK5 */
-#  define SYS_PF_CK4			(1<<9)	/* GPIO2/CLK4 */
-#  define SYS_PF_IRF			(1<<8)	/* GPIO15/IRFIRSEL */
-#  define SYS_PF_UR3			(1<<7)	/* GPIO[14:9]/UART3 */
-#  define SYS_PF_I2D			(1<<6)	/* GPIO8/I2SDI */
-#  define SYS_PF_I2S			(1<<5)	/* I2S/GPIO[29:31] */
-#  define SYS_PF_NI2			(1<<4)	/* NI2/GPIO[24:28] */
-#  define SYS_PF_U0			(1<<3)	/* U0TXD/GPIO20 */
-#  define SYS_PF_RD			(1<<2)	/* IRTXD/GPIO19 */
-#  define SYS_PF_A97			(1<<1)	/* AC97/SSL1 */
-#  define SYS_PF_S0			(1<<0)	/* SSI_0/GPIO[16:18] */
-
-/* Au1100 Only */
-#  define SYS_PF_PC			(1<<18)	/* PCMCIA/GPIO[207:204] */
-#  define SYS_PF_LCD			(1<<17)	/* extern lcd/GPIO[203:200] */
-#  define SYS_PF_CS			(1<<16)	/* EXTCLK0/32khz to gpio2 */
-#  define SYS_PF_EX0			(1<<9)	/* gpio2/clock */
-
-/* Au1550 Only.  Redefines lots of pins */
-#  define SYS_PF_PSC2_MASK		(7 << 17)
-#  define SYS_PF_PSC2_AC97		(0)
-#  define SYS_PF_PSC2_SPI		(0)
-#  define SYS_PF_PSC2_I2S		(1 << 17)
-#  define SYS_PF_PSC2_SMBUS		(3 << 17)
-#  define SYS_PF_PSC2_GPIO		(7 << 17)
-#  define SYS_PF_PSC3_MASK		(7 << 20)
-#  define SYS_PF_PSC3_AC97		(0)
-#  define SYS_PF_PSC3_SPI		(0)
-#  define SYS_PF_PSC3_I2S		(1 << 20)
-#  define SYS_PF_PSC3_SMBUS		(3 << 20)
-#  define SYS_PF_PSC3_GPIO		(7 << 20)
-#  define SYS_PF_PSC1_S1		(1 << 1)
-#  define SYS_PF_MUST_BE_SET		((1 << 5) | (1 << 2))
-
-/* Au1200 Only */
+#define SYS_PINFUNC		0xB190002C
+#  define SYS_PF_USB		(1 << 15)	/* 2nd USB device/host */
+#  define SYS_PF_U3		(1 << 14)	/* GPIO23/U3TXD */
+#  define SYS_PF_U2		(1 << 13)	/* GPIO22/U2TXD */
+#  define SYS_PF_U1		(1 << 12)	/* GPIO21/U1TXD */
+#  define SYS_PF_SRC		(1 << 11)	/* GPIO6/SROMCKE */
+#  define SYS_PF_CK5		(1 << 10)	/* GPIO3/CLK5 */
+#  define SYS_PF_CK4		(1 << 9)	/* GPIO2/CLK4 */
+#  define SYS_PF_IRF		(1 << 8)	/* GPIO15/IRFIRSEL */
+#  define SYS_PF_UR3		(1 << 7)	/* GPIO[14:9]/UART3 */
+#  define SYS_PF_I2D		(1 << 6)	/* GPIO8/I2SDI */
+#  define SYS_PF_I2S		(1 << 5)	/* I2S/GPIO[29:31] */
+#  define SYS_PF_NI2		(1 << 4)	/* NI2/GPIO[24:28] */
+#  define SYS_PF_U0		(1 << 3)	/* U0TXD/GPIO20 */
+#  define SYS_PF_RD		(1 << 2)	/* IRTXD/GPIO19 */
+#  define SYS_PF_A97		(1 << 1)	/* AC97/SSL1 */
+#  define SYS_PF_S0		(1 << 0)	/* SSI_0/GPIO[16:18] */
+
+/* Au1100 only */
+#  define SYS_PF_PC		(1 << 18)	/* PCMCIA/GPIO[207:204] */
+#  define SYS_PF_LCD		(1 << 17)	/* extern lcd/GPIO[203:200] */
+#  define SYS_PF_CS		(1 << 16)	/* EXTCLK0/32KHz to gpio2 */
+#  define SYS_PF_EX0		(1 << 9)	/* GPIO2/clock */
+
+/* Au1550 only.  Redefines lots of pins */
+#  define SYS_PF_PSC2_MASK	(7 << 17)
+#  define SYS_PF_PSC2_AC97	0
+#  define SYS_PF_PSC2_SPI	0
+#  define SYS_PF_PSC2_I2S	(1 << 17)
+#  define SYS_PF_PSC2_SMBUS	(3 << 17)
+#  define SYS_PF_PSC2_GPIO	(7 << 17)
+#  define SYS_PF_PSC3_MASK	(7 << 20)
+#  define SYS_PF_PSC3_AC97	0
+#  define SYS_PF_PSC3_SPI	0
+#  define SYS_PF_PSC3_I2S	(1 << 20)
+#  define SYS_PF_PSC3_SMBUS	(3 << 20)
+#  define SYS_PF_PSC3_GPIO	(7 << 20)
+#  define SYS_PF_PSC1_S1	(1 << 1)
+#  define SYS_PF_MUST_BE_SET	((1 << 5) | (1 << 2))
+
+/* Au1200 only */
 #ifdef CONFIG_SOC_AU1200
-#define SYS_PINFUNC_DMA		(1<<31)
-#define SYS_PINFUNC_S0A		(1<<30)
-#define SYS_PINFUNC_S1A		(1<<29)
-#define SYS_PINFUNC_LP0		(1<<28)
-#define SYS_PINFUNC_LP1		(1<<27)
-#define SYS_PINFUNC_LD16	(1<<26)
-#define SYS_PINFUNC_LD8		(1<<25)
-#define SYS_PINFUNC_LD1		(1<<24)
-#define SYS_PINFUNC_LD0		(1<<23)
-#define SYS_PINFUNC_P1A		(3<<21)
-#define SYS_PINFUNC_P1B		(1<<20)
-#define SYS_PINFUNC_FS3		(1<<19)
-#define SYS_PINFUNC_P0A		(3<<17)
-#define SYS_PINFUNC_CS		(1<<16)
-#define SYS_PINFUNC_CIM		(1<<15)
-#define SYS_PINFUNC_P1C		(1<<14)
-#define SYS_PINFUNC_U1T		(1<<12)
-#define SYS_PINFUNC_U1R		(1<<11)
-#define SYS_PINFUNC_EX1		(1<<10)
-#define SYS_PINFUNC_EX0		(1<<9)
-#define SYS_PINFUNC_U0R		(1<<8)
-#define SYS_PINFUNC_MC		(1<<7)
-#define SYS_PINFUNC_S0B		(1<<6)
-#define SYS_PINFUNC_S0C		(1<<5)
-#define SYS_PINFUNC_P0B		(1<<4)
-#define SYS_PINFUNC_U0T		(1<<3)
-#define SYS_PINFUNC_S1B		(1<<2)
+#define SYS_PINFUNC_DMA 	(1 << 31)
+#define SYS_PINFUNC_S0A 	(1 << 30)
+#define SYS_PINFUNC_S1A 	(1 << 29)
+#define SYS_PINFUNC_LP0 	(1 << 28)
+#define SYS_PINFUNC_LP1 	(1 << 27)
+#define SYS_PINFUNC_LD16 	(1 << 26)
+#define SYS_PINFUNC_LD8 	(1 << 25)
+#define SYS_PINFUNC_LD1 	(1 << 24)
+#define SYS_PINFUNC_LD0 	(1 << 23)
+#define SYS_PINFUNC_P1A 	(3 << 21)
+#define SYS_PINFUNC_P1B 	(1 << 20)
+#define SYS_PINFUNC_FS3 	(1 << 19)
+#define SYS_PINFUNC_P0A 	(3 << 17)
+#define SYS_PINFUNC_CS		(1 << 16)
+#define SYS_PINFUNC_CIM 	(1 << 15)
+#define SYS_PINFUNC_P1C 	(1 << 14)
+#define SYS_PINFUNC_U1T 	(1 << 12)
+#define SYS_PINFUNC_U1R 	(1 << 11)
+#define SYS_PINFUNC_EX1 	(1 << 10)
+#define SYS_PINFUNC_EX0 	(1 << 9)
+#define SYS_PINFUNC_U0R 	(1 << 8)
+#define SYS_PINFUNC_MC		(1 << 7)
+#define SYS_PINFUNC_S0B 	(1 << 6)
+#define SYS_PINFUNC_S0C 	(1 << 5)
+#define SYS_PINFUNC_P0B 	(1 << 4)
+#define SYS_PINFUNC_U0T 	(1 << 3)
+#define SYS_PINFUNC_S1B 	(1 << 2)
 #endif
 
-#define SYS_TRIOUTRD              0xB1900100
-#define SYS_TRIOUTCLR             0xB1900100
-#define SYS_OUTPUTRD              0xB1900108
-#define SYS_OUTPUTSET             0xB1900108
-#define SYS_OUTPUTCLR             0xB190010C
-#define SYS_PINSTATERD            0xB1900110
-#define SYS_PININPUTEN            0xB1900110
+#define SYS_TRIOUTRD		0xB1900100
+#define SYS_TRIOUTCLR		0xB1900100
+#define SYS_OUTPUTRD		0xB1900108
+#define SYS_OUTPUTSET		0xB1900108
+#define SYS_OUTPUTCLR		0xB190010C
+#define SYS_PINSTATERD		0xB1900110
+#define SYS_PININPUTEN		0xB1900110
 
 /* GPIO2, Au1500, Au1550 only */
-#define GPIO2_BASE                0xB1700000
-#define GPIO2_DIR                 (GPIO2_BASE + 0)
-#define GPIO2_OUTPUT              (GPIO2_BASE + 8)
-#define GPIO2_PINSTATE            (GPIO2_BASE + 0xC)
-#define GPIO2_INTENABLE           (GPIO2_BASE + 0x10)
-#define GPIO2_ENABLE              (GPIO2_BASE + 0x14)
+#define GPIO2_BASE		0xB1700000
+#define GPIO2_DIR		(GPIO2_BASE + 0)
+#define GPIO2_OUTPUT		(GPIO2_BASE + 8)
+#define GPIO2_PINSTATE		(GPIO2_BASE + 0xC)
+#define GPIO2_INTENABLE 	(GPIO2_BASE + 0x10)
+#define GPIO2_ENABLE		(GPIO2_BASE + 0x14)
 
 /* Power Management */
-#define SYS_SCRATCH0              0xB1900018
-#define SYS_SCRATCH1              0xB190001C
-#define SYS_WAKEMSK               0xB1900034
-#define SYS_ENDIAN                0xB1900038
-#define SYS_POWERCTRL             0xB190003C
-#define SYS_WAKESRC               0xB190005C
-#define SYS_SLPPWR                0xB1900078
-#define SYS_SLEEP                 0xB190007C
+#define SYS_SCRATCH0		0xB1900018
+#define SYS_SCRATCH1		0xB190001C
+#define SYS_WAKEMSK		0xB1900034
+#define SYS_ENDIAN		0xB1900038
+#define SYS_POWERCTRL		0xB190003C
+#define SYS_WAKESRC		0xB190005C
+#define SYS_SLPPWR		0xB1900078
+#define SYS_SLEEP		0xB190007C
 
 /* Clock Controller */
-#define SYS_FREQCTRL0             0xB1900020
-#  define SYS_FC_FRDIV2_BIT         22
-#  define SYS_FC_FRDIV2_MASK        (0xff << SYS_FC_FRDIV2_BIT)
-#  define SYS_FC_FE2                (1<<21)
-#  define SYS_FC_FS2                (1<<20)
-#  define SYS_FC_FRDIV1_BIT         12
-#  define SYS_FC_FRDIV1_MASK        (0xff << SYS_FC_FRDIV1_BIT)
-#  define SYS_FC_FE1                (1<<11)
-#  define SYS_FC_FS1                (1<<10)
-#  define SYS_FC_FRDIV0_BIT         2
-#  define SYS_FC_FRDIV0_MASK        (0xff << SYS_FC_FRDIV0_BIT)
-#  define SYS_FC_FE0                (1<<1)
-#  define SYS_FC_FS0                (1<<0)
-#define SYS_FREQCTRL1             0xB1900024
-#  define SYS_FC_FRDIV5_BIT         22
-#  define SYS_FC_FRDIV5_MASK        (0xff << SYS_FC_FRDIV5_BIT)
-#  define SYS_FC_FE5                (1<<21)
-#  define SYS_FC_FS5                (1<<20)
-#  define SYS_FC_FRDIV4_BIT         12
-#  define SYS_FC_FRDIV4_MASK        (0xff << SYS_FC_FRDIV4_BIT)
-#  define SYS_FC_FE4                (1<<11)
-#  define SYS_FC_FS4                (1<<10)
-#  define SYS_FC_FRDIV3_BIT         2
-#  define SYS_FC_FRDIV3_MASK        (0xff << SYS_FC_FRDIV3_BIT)
-#  define SYS_FC_FE3                (1<<1)
-#  define SYS_FC_FS3                (1<<0)
-#define SYS_CLKSRC                0xB1900028
-#  define SYS_CS_ME1_BIT            27
-#  define SYS_CS_ME1_MASK           (0x7<<SYS_CS_ME1_BIT)
-#  define SYS_CS_DE1                (1<<26)
-#  define SYS_CS_CE1                (1<<25)
-#  define SYS_CS_ME0_BIT            22
-#  define SYS_CS_ME0_MASK           (0x7<<SYS_CS_ME0_BIT)
-#  define SYS_CS_DE0                (1<<21)
-#  define SYS_CS_CE0                (1<<20)
-#  define SYS_CS_MI2_BIT            17
-#  define SYS_CS_MI2_MASK           (0x7<<SYS_CS_MI2_BIT)
-#  define SYS_CS_DI2                (1<<16)
-#  define SYS_CS_CI2                (1<<15)
+#define SYS_FREQCTRL0		0xB1900020
+#  define SYS_FC_FRDIV2_BIT	22
+#  define SYS_FC_FRDIV2_MASK	(0xff << SYS_FC_FRDIV2_BIT)
+#  define SYS_FC_FE2		(1 << 21)
+#  define SYS_FC_FS2		(1 << 20)
+#  define SYS_FC_FRDIV1_BIT	12
+#  define SYS_FC_FRDIV1_MASK	(0xff << SYS_FC_FRDIV1_BIT)
+#  define SYS_FC_FE1		(1 << 11)
+#  define SYS_FC_FS1		(1 << 10)
+#  define SYS_FC_FRDIV0_BIT	2
+#  define SYS_FC_FRDIV0_MASK	(0xff << SYS_FC_FRDIV0_BIT)
+#  define SYS_FC_FE0		(1 << 1)
+#  define SYS_FC_FS0		(1 << 0)
+#define SYS_FREQCTRL1		0xB1900024
+#  define SYS_FC_FRDIV5_BIT	22
+#  define SYS_FC_FRDIV5_MASK	(0xff << SYS_FC_FRDIV5_BIT)
+#  define SYS_FC_FE5		(1 << 21)
+#  define SYS_FC_FS5		(1 << 20)
+#  define SYS_FC_FRDIV4_BIT	12
+#  define SYS_FC_FRDIV4_MASK	(0xff << SYS_FC_FRDIV4_BIT)
+#  define SYS_FC_FE4		(1 << 11)
+#  define SYS_FC_FS4		(1 << 10)
+#  define SYS_FC_FRDIV3_BIT	2
+#  define SYS_FC_FRDIV3_MASK	(0xff << SYS_FC_FRDIV3_BIT)
+#  define SYS_FC_FE3		(1 << 1)
+#  define SYS_FC_FS3		(1 << 0)
+#define SYS_CLKSRC		0xB1900028
+#  define SYS_CS_ME1_BIT	27
+#  define SYS_CS_ME1_MASK	(0x7 << SYS_CS_ME1_BIT)
+#  define SYS_CS_DE1		(1 << 26)
+#  define SYS_CS_CE1		(1 << 25)
+#  define SYS_CS_ME0_BIT	22
+#  define SYS_CS_ME0_MASK	(0x7 << SYS_CS_ME0_BIT)
+#  define SYS_CS_DE0		(1 << 21)
+#  define SYS_CS_CE0		(1 << 20)
+#  define SYS_CS_MI2_BIT	17
+#  define SYS_CS_MI2_MASK	(0x7 << SYS_CS_MI2_BIT)
+#  define SYS_CS_DI2		(1 << 16)
+#  define SYS_CS_CI2		(1 << 15)
 #ifdef CONFIG_SOC_AU1100
-#  define SYS_CS_ML_BIT             7
-#  define SYS_CS_ML_MASK            (0x7<<SYS_CS_ML_BIT)
-#  define SYS_CS_DL                 (1<<6)
-#  define SYS_CS_CL                 (1<<5)
+#  define SYS_CS_ML_BIT 	7
+#  define SYS_CS_ML_MASK	(0x7 << SYS_CS_ML_BIT)
+#  define SYS_CS_DL		(1 << 6)
+#  define SYS_CS_CL		(1 << 5)
 #else
-#  define SYS_CS_MUH_BIT            12
-#  define SYS_CS_MUH_MASK           (0x7<<SYS_CS_MUH_BIT)
-#  define SYS_CS_DUH                (1<<11)
-#  define SYS_CS_CUH                (1<<10)
-#  define SYS_CS_MUD_BIT            7
-#  define SYS_CS_MUD_MASK           (0x7<<SYS_CS_MUD_BIT)
-#  define SYS_CS_DUD                (1<<6)
-#  define SYS_CS_CUD                (1<<5)
+#  define SYS_CS_MUH_BIT	12
+#  define SYS_CS_MUH_MASK	(0x7 << SYS_CS_MUH_BIT)
+#  define SYS_CS_DUH		(1 << 11)
+#  define SYS_CS_CUH		(1 << 10)
+#  define SYS_CS_MUD_BIT	7
+#  define SYS_CS_MUD_MASK	(0x7 << SYS_CS_MUD_BIT)
+#  define SYS_CS_DUD		(1 << 6)
+#  define SYS_CS_CUD		(1 << 5)
 #endif
-#  define SYS_CS_MIR_BIT            2
-#  define SYS_CS_MIR_MASK           (0x7<<SYS_CS_MIR_BIT)
-#  define SYS_CS_DIR                (1<<1)
-#  define SYS_CS_CIR                (1<<0)
-
-#  define SYS_CS_MUX_AUX            0x1
-#  define SYS_CS_MUX_FQ0            0x2
-#  define SYS_CS_MUX_FQ1            0x3
-#  define SYS_CS_MUX_FQ2            0x4
-#  define SYS_CS_MUX_FQ3            0x5
-#  define SYS_CS_MUX_FQ4            0x6
-#  define SYS_CS_MUX_FQ5            0x7
-#define SYS_CPUPLL                0xB1900060
-#define SYS_AUXPLL                0xB1900064
+#  define SYS_CS_MIR_BIT	2
+#  define SYS_CS_MIR_MASK	(0x7 << SYS_CS_MIR_BIT)
+#  define SYS_CS_DIR		(1 << 1)
+#  define SYS_CS_CIR		(1 << 0)
+
+#  define SYS_CS_MUX_AUX	0x1
+#  define SYS_CS_MUX_FQ0	0x2
+#  define SYS_CS_MUX_FQ1	0x3
+#  define SYS_CS_MUX_FQ2	0x4
+#  define SYS_CS_MUX_FQ3	0x5
+#  define SYS_CS_MUX_FQ4	0x6
+#  define SYS_CS_MUX_FQ5	0x7
+#define SYS_CPUPLL		0xB1900060
+#define SYS_AUXPLL		0xB1900064
 
 /* AC97 Controller */
-#define AC97C_CONFIG              0xB0000000
-#  define AC97C_RECV_SLOTS_BIT  13
+#define AC97C_CONFIG		0xB0000000
+#  define AC97C_RECV_SLOTS_BIT	13
 #  define AC97C_RECV_SLOTS_MASK (0x3ff << AC97C_RECV_SLOTS_BIT)
-#  define AC97C_XMIT_SLOTS_BIT  3
+#  define AC97C_XMIT_SLOTS_BIT	3
 #  define AC97C_XMIT_SLOTS_MASK (0x3ff << AC97C_XMIT_SLOTS_BIT)
-#  define AC97C_SG              (1<<2)
-#  define AC97C_SYNC            (1<<1)
-#  define AC97C_RESET           (1<<0)
-#define AC97C_STATUS              0xB0000004
-#  define AC97C_XU              (1<<11)
-#  define AC97C_XO              (1<<10)
-#  define AC97C_RU              (1<<9)
-#  define AC97C_RO              (1<<8)
-#  define AC97C_READY           (1<<7)
-#  define AC97C_CP              (1<<6)
-#  define AC97C_TR              (1<<5)
-#  define AC97C_TE              (1<<4)
-#  define AC97C_TF              (1<<3)
-#  define AC97C_RR              (1<<2)
-#  define AC97C_RE              (1<<1)
-#  define AC97C_RF              (1<<0)
-#define AC97C_DATA                0xB0000008
-#define AC97C_CMD                 0xB000000C
-#  define AC97C_WD_BIT          16
-#  define AC97C_READ            (1<<7)
-#  define AC97C_INDEX_MASK      0x7f
-#define AC97C_CNTRL               0xB0000010
-#  define AC97C_RS              (1<<1)
-#  define AC97C_CE              (1<<0)
-
+#  define AC97C_SG		(1 << 2)
+#  define AC97C_SYNC		(1 << 1)
+#  define AC97C_RESET		(1 << 0)
+#define AC97C_STATUS		0xB0000004
+#  define AC97C_XU		(1 << 11)
+#  define AC97C_XO		(1 << 10)
+#  define AC97C_RU		(1 << 9)
+#  define AC97C_RO		(1 << 8)
+#  define AC97C_READY		(1 << 7)
+#  define AC97C_CP		(1 << 6)
+#  define AC97C_TR		(1 << 5)
+#  define AC97C_TE		(1 << 4)
+#  define AC97C_TF		(1 << 3)
+#  define AC97C_RR		(1 << 2)
+#  define AC97C_RE		(1 << 1)
+#  define AC97C_RF		(1 << 0)
+#define AC97C_DATA		0xB0000008
+#define AC97C_CMD		0xB000000C
+#  define AC97C_WD_BIT		16
+#  define AC97C_READ		(1 << 7)
+#  define AC97C_INDEX_MASK	0x7f
+#define AC97C_CNTRL		0xB0000010
+#  define AC97C_RS		(1 << 1)
+#  define AC97C_CE		(1 << 0)
 
 /* Secure Digital (SD) Controller */
 #define SD0_XMIT_FIFO	0xB0600000
@@ -1638,73 +1633,74 @@ enum soc_au1200_ints {
 
 #if defined(CONFIG_SOC_AU1500) || defined(CONFIG_SOC_AU1550)
 /* Au1500 PCI Controller */
-#define Au1500_CFG_BASE           0xB4005000 // virtual, kseg0 addr
-#define Au1500_PCI_CMEM           (Au1500_CFG_BASE + 0)
-#define Au1500_PCI_CFG            (Au1500_CFG_BASE + 4)
-#  define PCI_ERROR ((1<<22) | (1<<23) | (1<<24) | (1<<25) | (1<<26) | (1<<27))
-#define Au1500_PCI_B2BMASK_CCH    (Au1500_CFG_BASE + 8)
-#define Au1500_PCI_B2B0_VID       (Au1500_CFG_BASE + 0xC)
-#define Au1500_PCI_B2B1_ID        (Au1500_CFG_BASE + 0x10)
-#define Au1500_PCI_MWMASK_DEV     (Au1500_CFG_BASE + 0x14)
+#define Au1500_CFG_BASE 	0xB4005000	/* virtual, KSEG1 addr */
+#define Au1500_PCI_CMEM 	(Au1500_CFG_BASE + 0)
+#define Au1500_PCI_CFG		(Au1500_CFG_BASE + 4)
+#  define PCI_ERROR		((1 << 22) | (1 << 23) | (1 << 24) | \
+				 (1 << 25) | (1 << 26) | (1 << 27))
+#define Au1500_PCI_B2BMASK_CCH	(Au1500_CFG_BASE + 8)
+#define Au1500_PCI_B2B0_VID	(Au1500_CFG_BASE + 0xC)
+#define Au1500_PCI_B2B1_ID	(Au1500_CFG_BASE + 0x10)
+#define Au1500_PCI_MWMASK_DEV	(Au1500_CFG_BASE + 0x14)
 #define Au1500_PCI_MWBASE_REV_CCL (Au1500_CFG_BASE + 0x18)
-#define Au1500_PCI_ERR_ADDR       (Au1500_CFG_BASE + 0x1C)
-#define Au1500_PCI_SPEC_INTACK    (Au1500_CFG_BASE + 0x20)
-#define Au1500_PCI_ID             (Au1500_CFG_BASE + 0x100)
-#define Au1500_PCI_STATCMD        (Au1500_CFG_BASE + 0x104)
-#define Au1500_PCI_CLASSREV       (Au1500_CFG_BASE + 0x108)
-#define Au1500_PCI_HDRTYPE        (Au1500_CFG_BASE + 0x10C)
-#define Au1500_PCI_MBAR           (Au1500_CFG_BASE + 0x110)
+#define Au1500_PCI_ERR_ADDR	(Au1500_CFG_BASE + 0x1C)
+#define Au1500_PCI_SPEC_INTACK	(Au1500_CFG_BASE + 0x20)
+#define Au1500_PCI_ID		(Au1500_CFG_BASE + 0x100)
+#define Au1500_PCI_STATCMD	(Au1500_CFG_BASE + 0x104)
+#define Au1500_PCI_CLASSREV	(Au1500_CFG_BASE + 0x108)
+#define Au1500_PCI_HDRTYPE	(Au1500_CFG_BASE + 0x10C)
+#define Au1500_PCI_MBAR 	(Au1500_CFG_BASE + 0x110)
 
-#define Au1500_PCI_HDR            0xB4005100 // virtual, kseg0 addr
+#define Au1500_PCI_HDR		0xB4005100	/* virtual, KSEG1 addr */
 
-/* All of our structures, like pci resource, have 32 bit members.
+/*
+ * All of our structures, like PCI resource, have 32-bit members.
  * Drivers are expected to do an ioremap on the PCI MEM resource, but it's
- * hard to store 0x4 0000 0000 in a 32 bit type.  We require a small patch
+ * hard to store 0x4 0000 0000 in a 32-bit type.  We require a small patch
  * to __ioremap to check for addresses between (u32)Au1500_PCI_MEM_START and
- * (u32)Au1500_PCI_MEM_END and change those to the full 36 bit PCI MEM
- * addresses.  For PCI IO, it's simpler because we get to do the ioremap
+ * (u32)Au1500_PCI_MEM_END and change those to the full 36-bit PCI MEM
+ * addresses.  For PCI I/O, it's simpler because we get to do the ioremap
  * ourselves and then adjust the device's resources.
  */
-#define Au1500_EXT_CFG            0x600000000ULL
-#define Au1500_EXT_CFG_TYPE1      0x680000000ULL
-#define Au1500_PCI_IO_START       0x500000000ULL
-#define Au1500_PCI_IO_END         0x5000FFFFFULL
-#define Au1500_PCI_MEM_START      0x440000000ULL
-#define Au1500_PCI_MEM_END        0x44FFFFFFFULL
+#define Au1500_EXT_CFG		0x600000000ULL
+#define Au1500_EXT_CFG_TYPE1	0x680000000ULL
+#define Au1500_PCI_IO_START	0x500000000ULL
+#define Au1500_PCI_IO_END	0x5000FFFFFULL
+#define Au1500_PCI_MEM_START	0x440000000ULL
+#define Au1500_PCI_MEM_END	0x44FFFFFFFULL
 
 #define PCI_IO_START	0x00001000
 #define PCI_IO_END	0x000FFFFF
 #define PCI_MEM_START	0x40000000
 #define PCI_MEM_END	0x4FFFFFFF
 
-#define PCI_FIRST_DEVFN (0<<3)
-#define PCI_LAST_DEVFN  (19<<3)
+#define PCI_FIRST_DEVFN (0 << 3)
+#define PCI_LAST_DEVFN	(19 << 3)
 
-#define IOPORT_RESOURCE_START 0x00001000 /* skip legacy probing */
-#define IOPORT_RESOURCE_END   0xffffffff
-#define IOMEM_RESOURCE_START  0x10000000
-#define IOMEM_RESOURCE_END    0xffffffff
+#define IOPORT_RESOURCE_START	0x00001000	/* skip legacy probing */
+#define IOPORT_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_START	0x10000000
+#define IOMEM_RESOURCE_END	0xffffffff
 
 #else /* Au1000 and Au1100 and Au1200 */
 
-/* don't allow any legacy ports probing */
-#define IOPORT_RESOURCE_START 0x10000000
-#define IOPORT_RESOURCE_END   0xffffffff
-#define IOMEM_RESOURCE_START  0x10000000
-#define IOMEM_RESOURCE_END    0xffffffff
+/* Don't allow any legacy ports probing */
+#define IOPORT_RESOURCE_START	0x10000000
+#define IOPORT_RESOURCE_END	0xffffffff
+#define IOMEM_RESOURCE_START	0x10000000
+#define IOMEM_RESOURCE_END	0xffffffff
 
-#define PCI_IO_START    0
-#define PCI_IO_END      0
-#define PCI_MEM_START   0
-#define PCI_MEM_END     0
+#define PCI_IO_START	0
+#define PCI_IO_END	0
+#define PCI_MEM_START	0
+#define PCI_MEM_END	0
 #define PCI_FIRST_DEVFN 0
-#define PCI_LAST_DEVFN  0
+#define PCI_LAST_DEVFN	0
 
 #endif
 
 #ifndef _LANGUAGE_ASSEMBLY
-typedef volatile struct
-{
+typedef volatile struct {
 	/* 0x0000 */ u32 toytrim;
 	/* 0x0004 */ u32 toywrite;
 	/* 0x0008 */ u32 toymatch0;
@@ -1746,13 +1742,14 @@ typedef volatile struct
 	/* 0x010C */ u32 outputclr;
 	/* 0x0110 */ u32 pinstaterd;
 #define pininputen pinstaterd
-
 } AU1X00_SYS;
 
-static AU1X00_SYS* const sys  = (AU1X00_SYS *)SYS_BASE;
+static AU1X00_SYS * const sys = (AU1X00_SYS *)SYS_BASE;
 
 #endif
-/* Processor information base on prid.
+
+/*
+ * Processor information based on PRID.
  * Copied from PowerPC.
  */
 #ifndef _LANGUAGE_ASSEMBLY
@@ -1767,9 +1764,8 @@ struct cpu_spec {
 	unsigned char	cpu_pll_wo;	/* sys_cpupll reg. write-only */
 };
 
-extern struct cpu_spec		cpu_specs[];
-extern struct cpu_spec		*cur_cpu_spec[];
+extern struct cpu_spec	cpu_specs[];
+extern struct cpu_spec	*cur_cpu_spec[];
 #endif
 
 #endif
-
diff --git a/include/asm-mips/mach-au1x00/au1000_dma.h b/include/asm-mips/mach-au1x00/au1000_dma.h
index 9f29520..c333b4e 100644
--- a/include/asm-mips/mach-au1x00/au1000_dma.h
+++ b/include/asm-mips/mach-au1x00/au1000_dma.h
@@ -1,11 +1,10 @@
 /*
  * BRIEF MODULE DESCRIPTION
- *	Defines for using and allocating dma channels on the Alchemy
- *      Au1000 mips processor.
+ *	Defines for using and allocating DMA channels on the Alchemy
+ *      Au1x00 MIPS processors.
  *
- * Copyright 2000 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	stevel@mvista.com or source@mvista.com
+ * Copyright 2000, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -31,7 +30,7 @@
 #ifndef __ASM_AU1000_DMA_H
 #define __ASM_AU1000_DMA_H
 
-#include <asm/io.h>		/* need byte IO */
+#include <linux/io.h>		/* need byte IO */
 #include <linux/spinlock.h>	/* And spinlocks */
 #include <linux/delay.h>
 #include <asm/system.h>
@@ -50,36 +49,36 @@
 #define DMA_DAH_MASK		(0x0f << 20)
 #define DMA_DID_BIT		16
 #define DMA_DID_MASK		(0x0f << DMA_DID_BIT)
-#define DMA_DS			(1<<15)
-#define DMA_BE			(1<<13)
-#define DMA_DR			(1<<12)
-#define DMA_TS8			(1<<11)
+#define DMA_DS			(1 << 15)
+#define DMA_BE			(1 << 13)
+#define DMA_DR			(1 << 12)
+#define DMA_TS8 		(1 << 11)
 #define DMA_DW_BIT		9
 #define DMA_DW_MASK		(0x03 << DMA_DW_BIT)
 #define DMA_DW8			(0 << DMA_DW_BIT)
 #define DMA_DW16		(1 << DMA_DW_BIT)
 #define DMA_DW32		(2 << DMA_DW_BIT)
-#define DMA_NC			(1<<8)
-#define DMA_IE			(1<<7)
-#define DMA_HALT		(1<<6)
-#define DMA_GO			(1<<5)
-#define DMA_AB			(1<<4)
-#define DMA_D1			(1<<3)
-#define DMA_BE1			(1<<2)
-#define DMA_D0			(1<<1)
-#define DMA_BE0			(1<<0)
-
-#define DMA_PERIPHERAL_ADDR       0x00000008
-#define DMA_BUFFER0_START         0x0000000C
-#define DMA_BUFFER1_START         0x00000014
-#define DMA_BUFFER0_COUNT         0x00000010
-#define DMA_BUFFER1_COUNT         0x00000018
-#define DMA_BAH_BIT 16
-#define DMA_BAH_MASK (0x0f << DMA_BAH_BIT)
-#define DMA_COUNT_BIT 0
-#define DMA_COUNT_MASK (0xffff << DMA_COUNT_BIT)
-
-/* DMA Device ID's follow */
+#define DMA_NC			(1 << 8)
+#define DMA_IE			(1 << 7)
+#define DMA_HALT		(1 << 6)
+#define DMA_GO			(1 << 5)
+#define DMA_AB			(1 << 4)
+#define DMA_D1			(1 << 3)
+#define DMA_BE1 		(1 << 2)
+#define DMA_D0			(1 << 1)
+#define DMA_BE0 		(1 << 0)
+
+#define DMA_PERIPHERAL_ADDR	0x00000008
+#define DMA_BUFFER0_START	0x0000000C
+#define DMA_BUFFER1_START	0x00000014
+#define DMA_BUFFER0_COUNT	0x00000010
+#define DMA_BUFFER1_COUNT	0x00000018
+#define DMA_BAH_BIT	16
+#define DMA_BAH_MASK	(0x0f << DMA_BAH_BIT)
+#define DMA_COUNT_BIT	0
+#define DMA_COUNT_MASK	(0xffff << DMA_COUNT_BIT)
+
+/* DMA Device IDs follow */
 enum {
 	DMA_ID_UART0_TX = 0,
 	DMA_ID_UART0_RX,
@@ -110,7 +109,8 @@ enum {
 };
 
 struct dma_chan {
-	int dev_id;		// this channel is allocated if >=0, free otherwise
+	int dev_id;		/* this channel is allocated if >= 0, */
+				/* free otherwise */
 	unsigned int io;
 	const char *dev_str;
 	int irq;
@@ -132,23 +132,23 @@ extern int au1000_dma_read_proc(char *buf, char **start, off_t fpos,
 extern void dump_au1000_dma_channel(unsigned int dmanr);
 extern spinlock_t au1000_dma_spin_lock;
 
-
-static __inline__ struct dma_chan *get_dma_chan(unsigned int dmanr)
+static inline struct dma_chan *get_dma_chan(unsigned int dmanr)
 {
-	if (dmanr >= NUM_AU1000_DMA_CHANNELS
-	    || au1000_dma_table[dmanr].dev_id < 0)
+	if (dmanr >= NUM_AU1000_DMA_CHANNELS ||
+	    au1000_dma_table[dmanr].dev_id < 0)
 		return NULL;
 	return &au1000_dma_table[dmanr];
 }
 
-static __inline__ unsigned long claim_dma_lock(void)
+static inline unsigned long claim_dma_lock(void)
 {
 	unsigned long flags;
+
 	spin_lock_irqsave(&au1000_dma_spin_lock, flags);
 	return flags;
 }
 
-static __inline__ void release_dma_lock(unsigned long flags)
+static inline void release_dma_lock(unsigned long flags)
 {
 	spin_unlock_irqrestore(&au1000_dma_spin_lock, flags);
 }
@@ -156,48 +156,53 @@ static __inline__ void release_dma_lock(unsigned long flags)
 /*
  * Set the DMA buffer enable bits in the mode register.
  */
-static __inline__ void enable_dma_buffer0(unsigned int dmanr)
+static inline void enable_dma_buffer0(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	au_writel(DMA_BE0, chan->io + DMA_MODE_SET);
 }
-static __inline__ void enable_dma_buffer1(unsigned int dmanr)
+
+static inline void enable_dma_buffer1(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	au_writel(DMA_BE1, chan->io + DMA_MODE_SET);
 }
-static __inline__ void enable_dma_buffers(unsigned int dmanr)
+static inline void enable_dma_buffers(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	au_writel(DMA_BE0 | DMA_BE1, chan->io + DMA_MODE_SET);
 }
 
-static __inline__ void start_dma(unsigned int dmanr)
+static inline void start_dma(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
-
 	au_writel(DMA_GO, chan->io + DMA_MODE_SET);
 }
 
 #define DMA_HALT_POLL 0x5000
 
-static __inline__ void halt_dma(unsigned int dmanr)
+static inline void halt_dma(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
 	int i;
+
 	if (!chan)
 		return;
-
 	au_writel(DMA_GO, chan->io + DMA_MODE_CLEAR);
-	// poll the halt bit
+
+	/* Poll the halt bit */
 	for (i = 0; i < DMA_HALT_POLL; i++)
 		if (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT)
 			break;
@@ -205,55 +210,57 @@ static __inline__ void halt_dma(unsigned int dmanr)
 		printk(KERN_INFO "halt_dma: HALT poll expired!\n");
 }
 
-
-static __inline__ void disable_dma(unsigned int dmanr)
+static inline void disable_dma(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 
 	halt_dma(dmanr);
 
-	// now we can disable the buffers
+	/* Now we can disable the buffers */
 	au_writel(~DMA_GO, chan->io + DMA_MODE_CLEAR);
 }
 
-static __inline__ int dma_halted(unsigned int dmanr)
+static inline int dma_halted(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return 1;
 	return (au_readl(chan->io + DMA_MODE_READ) & DMA_HALT) ? 1 : 0;
 }
 
-/* initialize a DMA channel */
-static __inline__ void init_dma(unsigned int dmanr)
+/* Initialize a DMA channel. */
+static inline void init_dma(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
 	u32 mode;
+
 	if (!chan)
 		return;
 
 	disable_dma(dmanr);
 
-	// set device FIFO address
-	au_writel(CPHYSADDR(chan->fifo_addr),
-		  chan->io + DMA_PERIPHERAL_ADDR);
+	/* Set device FIFO address */
+	au_writel(CPHYSADDR(chan->fifo_addr), chan->io + DMA_PERIPHERAL_ADDR);
 
 	mode = chan->mode | (chan->dev_id << DMA_DID_BIT);
 	if (chan->irq)
 		mode |= DMA_IE;
 
 	au_writel(~mode, chan->io + DMA_MODE_CLEAR);
-	au_writel(mode, chan->io + DMA_MODE_SET);
+	au_writel(mode,  chan->io + DMA_MODE_SET);
 }
 
 /*
- * set mode for a specific DMA channel
+ * Set mode for a specific DMA channel
  */
-static __inline__ void set_dma_mode(unsigned int dmanr, unsigned int mode)
+static inline void set_dma_mode(unsigned int dmanr, unsigned int mode)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	/*
@@ -266,36 +273,37 @@ static __inline__ void set_dma_mode(unsigned int dmanr, unsigned int mode)
 	chan->mode |= mode;
 }
 
-static __inline__ unsigned int get_dma_mode(unsigned int dmanr)
+static inline unsigned int get_dma_mode(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return 0;
 	return chan->mode;
 }
 
-static __inline__ int get_dma_active_buffer(unsigned int dmanr)
+static inline int get_dma_active_buffer(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return -1;
 	return (au_readl(chan->io + DMA_MODE_READ) & DMA_AB) ? 1 : 0;
 }
 
-
 /*
- * set the device FIFO address for a specific DMA channel - only
+ * Set the device FIFO address for a specific DMA channel - only
  * applicable to GPO4 and GPO5. All the other devices have fixed
  * FIFO addresses.
  */
-static __inline__ void set_dma_fifo_addr(unsigned int dmanr,
-					 unsigned int a)
+static inline void set_dma_fifo_addr(unsigned int dmanr, unsigned int a)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 
-	if (chan->mode & DMA_DS)	/* second bank of device ids */
+	if (chan->mode & DMA_DS)	/* second bank of device IDs */
 		return;
 
 	if (chan->dev_id != DMA_ID_GP04 && chan->dev_id != DMA_ID_GP05)
@@ -307,16 +315,19 @@ static __inline__ void set_dma_fifo_addr(unsigned int dmanr,
 /*
  * Clear the DMA buffer done bits in the mode register.
  */
-static __inline__ void clear_dma_done0(unsigned int dmanr)
+static inline void clear_dma_done0(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	au_writel(DMA_D0, chan->io + DMA_MODE_CLEAR);
 }
-static __inline__ void clear_dma_done1(unsigned int dmanr)
+
+static inline void clear_dma_done1(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	au_writel(DMA_D1, chan->io + DMA_MODE_CLEAR);
@@ -325,16 +336,17 @@ static __inline__ void clear_dma_done1(unsigned int dmanr)
 /*
  * This does nothing - not applicable to Au1000 DMA.
  */
-static __inline__ void set_dma_page(unsigned int dmanr, char pagenr)
+static inline void set_dma_page(unsigned int dmanr, char pagenr)
 {
 }
 
 /*
  * Set Buffer 0 transfer address for specific DMA channel.
  */
-static __inline__ void set_dma_addr0(unsigned int dmanr, unsigned int a)
+static inline void set_dma_addr0(unsigned int dmanr, unsigned int a)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	au_writel(a, chan->io + DMA_BUFFER0_START);
@@ -343,9 +355,10 @@ static __inline__ void set_dma_addr0(unsigned int dmanr, unsigned int a)
 /*
  * Set Buffer 1 transfer address for specific DMA channel.
  */
-static __inline__ void set_dma_addr1(unsigned int dmanr, unsigned int a)
+static inline void set_dma_addr1(unsigned int dmanr, unsigned int a)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	au_writel(a, chan->io + DMA_BUFFER1_START);
@@ -355,10 +368,10 @@ static __inline__ void set_dma_addr1(unsigned int dmanr, unsigned int a)
 /*
  * Set Buffer 0 transfer size (max 64k) for a specific DMA channel.
  */
-static __inline__ void set_dma_count0(unsigned int dmanr,
-				      unsigned int count)
+static inline void set_dma_count0(unsigned int dmanr, unsigned int count)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	count &= DMA_COUNT_MASK;
@@ -368,10 +381,10 @@ static __inline__ void set_dma_count0(unsigned int dmanr,
 /*
  * Set Buffer 1 transfer size (max 64k) for a specific DMA channel.
  */
-static __inline__ void set_dma_count1(unsigned int dmanr,
-				      unsigned int count)
+static inline void set_dma_count1(unsigned int dmanr, unsigned int count)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	count &= DMA_COUNT_MASK;
@@ -381,10 +394,10 @@ static __inline__ void set_dma_count1(unsigned int dmanr,
 /*
  * Set both buffer transfer sizes (max 64k) for a specific DMA channel.
  */
-static __inline__ void set_dma_count(unsigned int dmanr,
-				     unsigned int count)
+static inline void set_dma_count(unsigned int dmanr, unsigned int count)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return;
 	count &= DMA_COUNT_MASK;
@@ -396,35 +409,36 @@ static __inline__ void set_dma_count(unsigned int dmanr,
  * Returns which buffer has its done bit set in the mode register.
  * Returns -1 if neither or both done bits set.
  */
-static __inline__ unsigned int get_dma_buffer_done(unsigned int dmanr)
+static inline unsigned int get_dma_buffer_done(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return 0;
-
-    return au_readl(chan->io + DMA_MODE_READ) & (DMA_D0 | DMA_D1);
+	return au_readl(chan->io + DMA_MODE_READ) & (DMA_D0 | DMA_D1);
 }
 
 
 /*
  * Returns the DMA channel's Buffer Done IRQ number.
  */
-static __inline__ int get_dma_done_irq(unsigned int dmanr)
+static inline int get_dma_done_irq(unsigned int dmanr)
 {
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return -1;
-
 	return chan->irq;
 }
 
 /*
  * Get DMA residue count. Returns the number of _bytes_ left to transfer.
  */
-static __inline__ int get_dma_residue(unsigned int dmanr)
+static inline int get_dma_residue(unsigned int dmanr)
 {
 	int curBufCntReg, count;
 	struct dma_chan *chan = get_dma_chan(dmanr);
+
 	if (!chan)
 		return 0;
 
@@ -442,4 +456,3 @@ static __inline__ int get_dma_residue(unsigned int dmanr)
 }
 
 #endif /* __ASM_AU1000_DMA_H */
-
diff --git a/include/asm-mips/mach-au1x00/au1000_gpio.h b/include/asm-mips/mach-au1x00/au1000_gpio.h
index 298f920..d8c96fd 100644
--- a/include/asm-mips/mach-au1x00/au1000_gpio.h
+++ b/include/asm-mips/mach-au1x00/au1000_gpio.h
@@ -2,12 +2,12 @@
  * FILE NAME au1000_gpio.h
  *
  * BRIEF MODULE DESCRIPTION
- *	API to Alchemy Au1000 GPIO device.
+ *	API to Alchemy Au1xx0 GPIO device.
  *
  *  Author: MontaVista Software, Inc.  <source@mvista.com>
- *          Steve Longerbeam <stevel@mvista.com>
+ *          Steve Longerbeam
  *
- * Copyright 2001 MontaVista Software Inc.
+ * Copyright 2001, 2008 MontaVista Software Inc.
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -37,12 +37,12 @@
 
 #define AU1000GPIO_IOC_MAGIC 'A'
 
-#define AU1000GPIO_IN		_IOR (AU1000GPIO_IOC_MAGIC, 0, int)
-#define AU1000GPIO_SET		_IOW (AU1000GPIO_IOC_MAGIC, 1, int)
-#define AU1000GPIO_CLEAR	_IOW (AU1000GPIO_IOC_MAGIC, 2, int)
-#define AU1000GPIO_OUT		_IOW (AU1000GPIO_IOC_MAGIC, 3, int)
-#define AU1000GPIO_TRISTATE	_IOW (AU1000GPIO_IOC_MAGIC, 4, int)
-#define AU1000GPIO_AVAIL_MASK	_IOR (AU1000GPIO_IOC_MAGIC, 5, int)
+#define AU1000GPIO_IN		_IOR(AU1000GPIO_IOC_MAGIC, 0, int)
+#define AU1000GPIO_SET		_IOW(AU1000GPIO_IOC_MAGIC, 1, int)
+#define AU1000GPIO_CLEAR	_IOW(AU1000GPIO_IOC_MAGIC, 2, int)
+#define AU1000GPIO_OUT		_IOW(AU1000GPIO_IOC_MAGIC, 3, int)
+#define AU1000GPIO_TRISTATE	_IOW(AU1000GPIO_IOC_MAGIC, 4, int)
+#define AU1000GPIO_AVAIL_MASK	_IOR(AU1000GPIO_IOC_MAGIC, 5, int)
 
 #ifdef __KERNEL__
 extern u32 get_au1000_avail_gpio_mask(void);
diff --git a/include/asm-mips/mach-au1x00/au1550_spi.h b/include/asm-mips/mach-au1x00/au1550_spi.h
index c2f0466..40e6c48 100644
--- a/include/asm-mips/mach-au1x00/au1550_spi.h
+++ b/include/asm-mips/mach-au1x00/au1550_spi.h
@@ -1,5 +1,5 @@
 /*
- * au1550_spi.h - au1550 psc spi controller driver - platform data struct
+ * au1550_spi.h - Au1550 PSC SPI controller driver - platform data structure
  */
 
 #ifndef _AU1550_SPI_H_
diff --git a/include/asm-mips/mach-au1x00/au1xxx.h b/include/asm-mips/mach-au1x00/au1xxx.h
index 9471359..1b36550 100644
--- a/include/asm-mips/mach-au1x00/au1xxx.h
+++ b/include/asm-mips/mach-au1x00/au1xxx.h
@@ -23,10 +23,10 @@
 #ifndef _AU1XXX_H_
 #define _AU1XXX_H_
 
-
 #include <asm/mach-au1x00/au1000.h>
 
-#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_DB1550)
+#if defined(CONFIG_MIPS_DB1000) || defined(CONFIG_MIPS_DB1100) || \
+    defined(CONFIG_MIPS_DB1500) || defined(CONFIG_MIPS_DB1550)
 #include <asm/mach-db1x00/db1x00.h>
 
 #elif defined(CONFIG_MIPS_PB1550)
diff --git a/include/asm-mips/mach-au1x00/au1xxx_dbdma.h b/include/asm-mips/mach-au1x00/au1xxx_dbdma.h
index 93d507c..ad17d7c 100644
--- a/include/asm-mips/mach-au1x00/au1xxx_dbdma.h
+++ b/include/asm-mips/mach-au1x00/au1xxx_dbdma.h
@@ -28,17 +28,18 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-/* Specifics for the Au1xxx Descriptor-Based DMA Controllers, first
- * seen in the AU1550 part.
+/*
+ * Specifics for the Au1xxx Descriptor-Based DMA Controller,
+ * first seen in the AU1550 part.
  */
 #ifndef _AU1000_DBDMA_H_
 #define _AU1000_DBDMA_H_
 
-
 #ifndef _LANGUAGE_ASSEMBLY
 
-/* The DMA base addresses.
- * The Channels are every 256 bytes (0x0100) from the channel 0 base.
+/*
+ * The DMA base addresses.
+ * The channels are every 256 bytes (0x0100) from the channel 0 base.
  * Interrupt status/enable is bits 15:0 for channels 15 to zero.
  */
 #define DDMA_GLOBAL_BASE	0xb4003000
@@ -51,16 +52,14 @@ typedef volatile struct dbdma_global {
 	u32	ddma_inten;
 } dbdma_global_t;
 
-/* General Configuration.
-*/
+/* General Configuration. */
 #define DDMA_CONFIG_AF		(1 << 2)
 #define DDMA_CONFIG_AH		(1 << 1)
 #define DDMA_CONFIG_AL		(1 << 0)
 
 #define DDMA_THROTTLE_EN	(1 << 31)
 
-/* The structure of a DMA Channel.
-*/
+/* The structure of a DMA Channel. */
 typedef volatile struct au1xxx_dma_channel {
 	u32	ddma_cfg;	/* See below */
 	u32	ddma_desptr;	/* 32-byte aligned pointer to descriptor */
@@ -69,8 +68,7 @@ typedef volatile struct au1xxx_dma_channel {
 	u32	ddma_irq;	/* If bit 0 set, interrupt pending */
 	u32	ddma_stat;	/* See below */
 	u32	ddma_bytecnt;	/* Byte count, valid only when chan idle */
-	/* Remainder, up to the 256 byte boundary, is reserved.
-	*/
+	/* Remainder, up to the 256 byte boundary, is reserved. */
 } au1x_dma_chan_t;
 
 #define DDMA_CFG_SED	(1 << 9)	/* source DMA level/edge detect */
@@ -84,7 +82,8 @@ typedef volatile struct au1xxx_dma_channel {
 #define DDMA_CFG_DBE	(1 << 1)	/* Destination big endian */
 #define DDMA_CFG_EN	(1 << 0)	/* Channel enable */
 
-/* Always set when descriptor processing done, regardless of
+/*
+ * Always set when descriptor processing done, regardless of
  * interrupt enable state.  Reflected in global intstat, don't
  * clear this until global intstat is read/used.
  */
@@ -94,7 +93,8 @@ typedef volatile struct au1xxx_dma_channel {
 #define DDMA_STAT_V	(1 << 1)	/* Descriptor valid */
 #define DDMA_STAT_H	(1 << 0)	/* Channel Halted */
 
-/* "Standard" DDMA Descriptor.
+/*
+ * "Standard" DDMA Descriptor.
  * Must be 32-byte aligned.
  */
 typedef volatile struct au1xxx_ddma_desc {
@@ -106,8 +106,9 @@ typedef volatile struct au1xxx_ddma_desc {
 	u32	dscr_dest1;		/* See below */
 	u32	dscr_stat;		/* completion status */
 	u32	dscr_nxtptr;		/* Next descriptor pointer (mostly) */
-	/* First 32bytes are HW specific!!!
-	   Lets have some SW data following.. make sure its 32bytes
+	/*
+	 * First 32 bytes are HW specific!!!
+	 * Lets have some SW data following -- make sure it's 32 bytes.
 	 */
 	u32	sw_status;
 	u32 	sw_context;
@@ -130,10 +131,9 @@ typedef volatile struct au1xxx_ddma_desc {
 #define DSCR_CMD0_CV		(0x1 << 2)	/* Clear Valid when done */
 #define DSCR_CMD0_ST_MASK	(0x3 << 0)	/* Status instruction */
 
-#define SW_STATUS_INUSE		(1<<0)
+#define SW_STATUS_INUSE 	(1 << 0)
 
-/* Command 0 device IDs.
-*/
+/* Command 0 device IDs. */
 #ifdef CONFIG_SOC_AU1550
 #define DSCR_CMD0_UART0_TX	0
 #define DSCR_CMD0_UART0_RX	1
@@ -198,16 +198,15 @@ typedef volatile struct au1xxx_ddma_desc {
 #define DSCR_CMD0_THROTTLE	30
 #define DSCR_CMD0_ALWAYS	31
 #define DSCR_NDEV_IDS		32
-/* THis macro is used to find/create custom device types */
-#define DSCR_DEV2CUSTOM_ID(x, d)	(((((x)&0xFFFF)<<8)|0x32000000)|((d)&0xFF))
-#define DSCR_CUSTOM2DEV_ID(x)	((x)&0xFF)
-
+/* This macro is used to find/create custom device types */
+#define DSCR_DEV2CUSTOM_ID(x, d) (((((x) & 0xFFFF) << 8) | 0x32000000) | \
+				  ((d) & 0xFF))
+#define DSCR_CUSTOM2DEV_ID(x)	((x) & 0xFF)
 
 #define DSCR_CMD0_SID(x)	(((x) & 0x1f) << 25)
 #define DSCR_CMD0_DID(x)	(((x) & 0x1f) << 20)
 
-/* Source/Destination transfer width.
-*/
+/* Source/Destination transfer width. */
 #define DSCR_CMD0_BYTE		0
 #define DSCR_CMD0_HALFWORD	1
 #define DSCR_CMD0_WORD		2
@@ -215,16 +214,14 @@ typedef volatile struct au1xxx_ddma_desc {
 #define DSCR_CMD0_SW(x)		(((x) & 0x3) << 18)
 #define DSCR_CMD0_DW(x)		(((x) & 0x3) << 16)
 
-/* DDMA Descriptor Type.
-*/
+/* DDMA Descriptor Type. */
 #define DSCR_CMD0_STANDARD	0
 #define DSCR_CMD0_LITERAL	1
 #define DSCR_CMD0_CMP_BRANCH	2
 
 #define DSCR_CMD0_DT(x)		(((x) & 0x3) << 13)
 
-/* Status Instruction.
-*/
+/* Status Instruction. */
 #define DSCR_CMD0_ST_NOCHANGE	0	/* Don't change */
 #define DSCR_CMD0_ST_CURRENT	1	/* Write current status */
 #define DSCR_CMD0_ST_CMD0	2	/* Write cmd0 with V cleared */
@@ -232,23 +229,20 @@ typedef volatile struct au1xxx_ddma_desc {
 
 #define DSCR_CMD0_ST(x)		(((x) & 0x3) << 0)
 
-/* Descriptor Command 1
-*/
+/* Descriptor Command 1. */
 #define DSCR_CMD1_SUPTR_MASK	(0xf << 28)	/* upper 4 bits of src addr */
 #define DSCR_CMD1_DUPTR_MASK	(0xf << 24)	/* upper 4 bits of dest addr */
 #define DSCR_CMD1_FL_MASK	(0x3 << 22)	/* Flag bits */
 #define DSCR_CMD1_BC_MASK	(0x3fffff)	/* Byte count */
 
-/* Flag description.
-*/
+/* Flag description. */
 #define DSCR_CMD1_FL_MEM_STRIDE0	0
 #define DSCR_CMD1_FL_MEM_STRIDE1	1
 #define DSCR_CMD1_FL_MEM_STRIDE2	2
 
 #define DSCR_CMD1_FL(x)		(((x) & 0x3) << 22)
 
-/* Source1, 1-dimensional stride.
-*/
+/* Source1, 1-dimensional stride. */
 #define DSCR_SRC1_STS_MASK	(3 << 30)	/* Src xfer size */
 #define DSCR_SRC1_SAM_MASK	(3 << 28)	/* Src xfer movement */
 #define DSCR_SRC1_SB_MASK	(0x3fff << 14)	/* Block size */
@@ -256,8 +250,7 @@ typedef volatile struct au1xxx_ddma_desc {
 #define DSCR_SRC1_SS_MASK	(0x3fff << 0)	/* Stride */
 #define DSCR_SRC1_SS(x)		(((x) & 0x3fff) << 0)
 
-/* Dest1, 1-dimensional stride.
-*/
+/* Dest1, 1-dimensional stride. */
 #define DSCR_DEST1_DTS_MASK	(3 << 30)	/* Dest xfer size */
 #define DSCR_DEST1_DAM_MASK	(3 << 28)	/* Dest xfer movement */
 #define DSCR_DEST1_DB_MASK	(0x3fff << 14)	/* Block size */
@@ -279,29 +272,27 @@ typedef volatile struct au1xxx_ddma_desc {
 #define DSCR_SRC1_SAM(x)	(((x) & 3) << 28)
 #define DSCR_DEST1_DAM(x)	(((x) & 3) << 28)
 
-/* The next descriptor pointer.
-*/
+/* The next descriptor pointer. */
 #define DSCR_NXTPTR_MASK	(0x07ffffff)
 #define DSCR_NXTPTR(x)		((x) >> 5)
 #define DSCR_GET_NXTPTR(x)	((x) << 5)
 #define DSCR_NXTPTR_MS		(1 << 27)
 
-/* The number of DBDMA channels.
-*/
+/* The number of DBDMA channels. */
 #define NUM_DBDMA_CHANS	16
 
 /*
- * Ddma API definitions
+ * DDMA API definitions
  * FIXME: may not fit to this header file
  */
 typedef struct dbdma_device_table {
-	u32		dev_id;
-	u32		dev_flags;
-	u32		dev_tsize;
-	u32		dev_devwidth;
-	u32		dev_physaddr;		/* If FIFO */
-	u32		dev_intlevel;
-	u32		dev_intpolarity;
+	u32	dev_id;
+	u32	dev_flags;
+	u32	dev_tsize;
+	u32	dev_devwidth;
+	u32	dev_physaddr;		/* If FIFO */
+	u32	dev_intlevel;
+	u32	dev_intpolarity;
 } dbdev_tab_t;
 
 
@@ -316,44 +307,41 @@ typedef struct dbdma_chan_config {
 	au1x_ddma_desc_t	*chan_desc_base;
 	au1x_ddma_desc_t	*get_ptr, *put_ptr, *cur_ptr;
 	void			*chan_callparam;
-	void (*chan_callback)(int, void *);
+	void			(*chan_callback)(int, void *);
 } chan_tab_t;
 
 #define DEV_FLAGS_INUSE		(1 << 0)
 #define DEV_FLAGS_ANYUSE	(1 << 1)
 #define DEV_FLAGS_OUT		(1 << 2)
 #define DEV_FLAGS_IN		(1 << 3)
-#define DEV_FLAGS_BURSTABLE (1 << 4)
+#define DEV_FLAGS_BURSTABLE	(1 << 4)
 #define DEV_FLAGS_SYNC		(1 << 5)
-/* end Ddma API definitions */
+/* end DDMA API definitions */
 
-/* External functions for drivers to use.
-*/
-/* Use this to allocate a dbdma channel.  The device ids are one of the
- * DSCR_CMD0 devices IDs, which is usually redefined to a more
- * meaningful name.  The 'callback' is called during dma completion
+/*
+ * External functions for drivers to use.
+ * Use this to allocate a DBDMA channel.  The device IDs are one of
+ * the DSCR_CMD0 devices IDs, which is usually redefined to a more
+ * meaningful name.  The 'callback' is called during DMA completion
  * interrupt.
  */
 extern u32 au1xxx_dbdma_chan_alloc(u32 srcid, u32 destid,
-	void (*callback)(int, void *), void *callparam);
+				   void (*callback)(int, void *),
+				   void *callparam);
 
 #define DBDMA_MEM_CHAN	DSCR_CMD0_ALWAYS
 
-/* Set the device width of a in/out fifo.
-*/
+/* Set the device width of an in/out FIFO. */
 u32 au1xxx_dbdma_set_devwidth(u32 chanid, int bits);
 
-/* Allocate a ring of descriptors for dbdma.
-*/
+/* Allocate a ring of descriptors for DBDMA. */
 u32 au1xxx_dbdma_ring_alloc(u32 chanid, int entries);
 
-/* Put buffers on source/destination descriptors.
-*/
+/* Put buffers on source/destination descriptors. */
 u32 _au1xxx_dbdma_put_source(u32 chanid, void *buf, int nbytes, u32 flags);
 u32 _au1xxx_dbdma_put_dest(u32 chanid, void *buf, int nbytes, u32 flags);
 
-/* Get a buffer from the destination descriptor.
-*/
+/* Get a buffer from the destination descriptor. */
 u32 au1xxx_dbdma_get_dest(u32 chanid, void **buf, int *nbytes);
 
 void au1xxx_dbdma_stop(u32 chanid);
@@ -364,29 +352,34 @@ u32 au1xxx_get_dma_residue(u32 chanid);
 void au1xxx_dbdma_chan_free(u32 chanid);
 void au1xxx_dbdma_dump(u32 chanid);
 
-u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr );
+u32 au1xxx_dbdma_put_dscr(u32 chanid, au1x_ddma_desc_t *dscr);
 
-u32 au1xxx_ddma_add_device( dbdev_tab_t *dev );
-void * au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp);
+u32 au1xxx_ddma_add_device(dbdev_tab_t *dev);
+void *au1xxx_ddma_get_nextptr_virt(au1x_ddma_desc_t *dp);
 
 /*
- 	Some compatibilty macros --
-		Needed to make changes to API without breaking existing drivers
-*/
-#define	au1xxx_dbdma_put_source(chanid, buf, nbytes)_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
-#define	au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags) _au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
-#define	put_source_flags(chanid, buf, nbytes, flags) au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags)
-
-
-#define au1xxx_dbdma_put_dest(chanid, buf, nbytes) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
-#define	au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags) _au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
-#define	put_dest_flags(chanid, buf, nbytes, flags) au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags)
+ * Some compatibilty macros -- needed to make changes to API
+ * without breaking existing drivers.
+ */
+#define au1xxx_dbdma_put_source(chanid, buf, nbytes)			\
+	_au1xxx_dbdma_put_source(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags)	\
+	_au1xxx_dbdma_put_source(chanid, buf, nbytes, flags)
+#define put_source_flags(chanid, buf, nbytes, flags)			\
+	au1xxx_dbdma_put_source_flags(chanid, buf, nbytes, flags)
+
+#define au1xxx_dbdma_put_dest(chanid, buf, nbytes)			\
+	_au1xxx_dbdma_put_dest(chanid, buf, nbytes, DDMA_FLAGS_IE)
+#define au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags) 	\
+	_au1xxx_dbdma_put_dest(chanid, buf, nbytes, flags)
+#define put_dest_flags(chanid, buf, nbytes, flags)			\
+	au1xxx_dbdma_put_dest_flags(chanid, buf, nbytes, flags)
 
 /*
  *	Flags for the put_source/put_dest functions.
  */
-#define DDMA_FLAGS_IE	(1<<0)
-#define DDMA_FLAGS_NOIE (1<<1)
+#define DDMA_FLAGS_IE	(1 << 0)
+#define DDMA_FLAGS_NOIE (1 << 1)
 
 #endif /* _LANGUAGE_ASSEMBLY */
 #endif /* _AU1000_DBDMA_H_ */
diff --git a/include/asm-mips/mach-au1x00/au1xxx_ide.h b/include/asm-mips/mach-au1x00/au1xxx_ide.h
index b493a5e..60638b8 100644
--- a/include/asm-mips/mach-au1x00/au1xxx_ide.h
+++ b/include/asm-mips/mach-au1x00/au1xxx_ide.h
@@ -31,167 +31,164 @@
  */
 
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        #define DMA_WAIT_TIMEOUT        100
-        #define NUM_DESCRIPTORS         PRD_ENTRIES
+#define DMA_WAIT_TIMEOUT	100
+#define NUM_DESCRIPTORS 	PRD_ENTRIES
 #else /* CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA */
-        #define NUM_DESCRIPTORS         2
+#define NUM_DESCRIPTORS 	2
 #endif
 
 #ifndef AU1XXX_ATA_RQSIZE
-        #define AU1XXX_ATA_RQSIZE       128
+#define AU1XXX_ATA_RQSIZE	128
 #endif
 
 /* Disable Burstable-Support for DBDMA */
 #ifndef CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON
-        #define CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON  0
+#define CONFIG_BLK_DEV_IDE_AU1XXX_BURSTABLE_ON	0
 #endif
 
 #ifdef CONFIG_PM
 /*
-* This will enable the device to be powered up when write() or read()
-* is called. If this is not defined, the driver will return -EBUSY.
-*/
+ * This will enable the device to be powered up when write() or read()
+ * is called. If this is not defined, the driver will return -EBUSY.
+ */
 #define WAKE_ON_ACCESS 1
 
-typedef struct
-{
-        spinlock_t         lock;       /* Used to block on state transitions */
-        au1xxx_power_dev_t *dev;       /* Power Managers device structure */
-        unsigned	   stopped;    /* USed to signaling device is stopped */
+typedef struct {
+	spinlock_t		lock;	/* Used to block on state transitions */
+	au1xxx_power_dev_t	*dev;	/* Power Managers device structure */
+	unsigned		stopped; /* Used to signal device is stopped */
 } pm_state;
 #endif
 
-
-typedef struct
-{
-        u32                     tx_dev_id, rx_dev_id, target_dev_id;
-        u32                     tx_chan, rx_chan;
-        void                    *tx_desc_head, *rx_desc_head;
-        ide_hwif_t              *hwif;
+typedef struct {
+	u32			tx_dev_id, rx_dev_id, target_dev_id;
+	u32			tx_chan, rx_chan;
+	void			*tx_desc_head, *rx_desc_head;
+	ide_hwif_t		*hwif;
 #ifdef CONFIG_BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
-        ide_drive_t             *drive;
-        struct dbdma_cmd        *dma_table_cpu;
-        dma_addr_t              dma_table_dma;
+	ide_drive_t		*drive;
+	struct dbdma_cmd	*dma_table_cpu;
+	dma_addr_t		dma_table_dma;
 #endif
 	int			irq;
 	u32			regbase;
 #ifdef CONFIG_PM
-        pm_state                pm;
+	pm_state		pm;
 #endif
 } _auide_hwif;
 
-/*******************************************************************************
-* PIO Mode timing calculation :                                                *
-*                                                                              *
-* Static Bus Spec   ATA Spec                                                   *
-*      Tcsoe      =   t1                                                       *
-*      Toecs      =   t9                                                       *
-*      Twcs       =   t9                                                       *
-*      Tcsh       =   t2i | t2                                                 *
-*      Tcsoff     =   t2i | t2                                                 *
-*      Twp        =   t2                                                       *
-*      Tcsw       =   t1                                                       *
-*      Tpm        =   0                                                        *
-*      Ta         =   t1+t2                                                    *
-*******************************************************************************/
+/******************************************************************************/
+/* PIO Mode timing calculation :					      */
+/*									      */
+/* Static Bus Spec   ATA Spec						      */
+/*	Tcsoe	   =	t1						      */
+/*	Toecs	   =	t9						      */
+/*	Twcs	   =	t9						      */
+/*	Tcsh	   =	t2i | t2					      */
+/*	Tcsoff	   =	t2i | t2					      */
+/*	Twp	   =	t2						      */
+/*	Tcsw	   =	t1						      */
+/*	Tpm	   =	0						      */
+/*	Ta	   =	t1+t2						      */
+/******************************************************************************/
 
-#define TCSOE_MASK            (0x07<<29)
-#define TOECS_MASK            (0x07<<26)
-#define TWCS_MASK             (0x07<<28)
-#define TCSH_MASK             (0x0F<<24)
-#define TCSOFF_MASK           (0x07<<20)
-#define TWP_MASK              (0x3F<<14)
-#define TCSW_MASK             (0x0F<<10)
-#define TPM_MASK              (0x0F<<6)
-#define TA_MASK               (0x3F<<0)
-#define TS_MASK               (1<<8)
+#define TCSOE_MASK		(0x07 << 29)
+#define TOECS_MASK		(0x07 << 26)
+#define TWCS_MASK		(0x07 << 28)
+#define TCSH_MASK		(0x0F << 24)
+#define TCSOFF_MASK		(0x07 << 20)
+#define TWP_MASK		(0x3F << 14)
+#define TCSW_MASK		(0x0F << 10)
+#define TPM_MASK		(0x0F << 6)
+#define TA_MASK 		(0x3F << 0)
+#define TS_MASK 		(1 << 8)
 
 /* Timing parameters PIO mode 0 */
-#define SBC_IDE_PIO0_TCSOE    (0x04<<29)
-#define SBC_IDE_PIO0_TOECS    (0x01<<26)
-#define SBC_IDE_PIO0_TWCS     (0x02<<28)
-#define SBC_IDE_PIO0_TCSH     (0x08<<24)
-#define SBC_IDE_PIO0_TCSOFF   (0x07<<20)
-#define SBC_IDE_PIO0_TWP      (0x10<<14)
-#define SBC_IDE_PIO0_TCSW     (0x04<<10)
-#define SBC_IDE_PIO0_TPM      (0x0<<6)
-#define SBC_IDE_PIO0_TA       (0x15<<0)
+#define SBC_IDE_PIO0_TCSOE	(0x04 << 29)
+#define SBC_IDE_PIO0_TOECS	(0x01 << 26)
+#define SBC_IDE_PIO0_TWCS	(0x02 << 28)
+#define SBC_IDE_PIO0_TCSH	(0x08 << 24)
+#define SBC_IDE_PIO0_TCSOFF	(0x07 << 20)
+#define SBC_IDE_PIO0_TWP	(0x10 << 14)
+#define SBC_IDE_PIO0_TCSW	(0x04 << 10)
+#define SBC_IDE_PIO0_TPM	(0x00 << 6)
+#define SBC_IDE_PIO0_TA 	(0x15 << 0)
 /* Timing parameters PIO mode 1 */
-#define SBC_IDE_PIO1_TCSOE    (0x03<<29)
-#define SBC_IDE_PIO1_TOECS    (0x01<<26)
-#define SBC_IDE_PIO1_TWCS     (0x01<<28)
-#define SBC_IDE_PIO1_TCSH     (0x06<<24)
-#define SBC_IDE_PIO1_TCSOFF   (0x06<<20)
-#define SBC_IDE_PIO1_TWP      (0x08<<14)
-#define SBC_IDE_PIO1_TCSW     (0x03<<10)
-#define SBC_IDE_PIO1_TPM      (0x00<<6)
-#define SBC_IDE_PIO1_TA       (0x0B<<0)
+#define SBC_IDE_PIO1_TCSOE	(0x03 << 29)
+#define SBC_IDE_PIO1_TOECS	(0x01 << 26)
+#define SBC_IDE_PIO1_TWCS	(0x01 << 28)
+#define SBC_IDE_PIO1_TCSH	(0x06 << 24)
+#define SBC_IDE_PIO1_TCSOFF	(0x06 << 20)
+#define SBC_IDE_PIO1_TWP	(0x08 << 14)
+#define SBC_IDE_PIO1_TCSW	(0x03 << 10)
+#define SBC_IDE_PIO1_TPM	(0x00 << 6)
+#define SBC_IDE_PIO1_TA 	(0x0B << 0)
 /* Timing parameters PIO mode 2 */
-#define SBC_IDE_PIO2_TCSOE    (0x05<<29)
-#define SBC_IDE_PIO2_TOECS    (0x01<<26)
-#define SBC_IDE_PIO2_TWCS     (0x01<<28)
-#define SBC_IDE_PIO2_TCSH     (0x07<<24)
-#define SBC_IDE_PIO2_TCSOFF   (0x07<<20)
-#define SBC_IDE_PIO2_TWP      (0x1F<<14)
-#define SBC_IDE_PIO2_TCSW     (0x05<<10)
-#define SBC_IDE_PIO2_TPM      (0x00<<6)
-#define SBC_IDE_PIO2_TA       (0x22<<0)
+#define SBC_IDE_PIO2_TCSOE	(0x05 << 29)
+#define SBC_IDE_PIO2_TOECS	(0x01 << 26)
+#define SBC_IDE_PIO2_TWCS	(0x01 << 28)
+#define SBC_IDE_PIO2_TCSH	(0x07 << 24)
+#define SBC_IDE_PIO2_TCSOFF	(0x07 << 20)
+#define SBC_IDE_PIO2_TWP	(0x1F << 14)
+#define SBC_IDE_PIO2_TCSW	(0x05 << 10)
+#define SBC_IDE_PIO2_TPM	(0x00 << 6)
+#define SBC_IDE_PIO2_TA 	(0x22 << 0)
 /* Timing parameters PIO mode 3 */
-#define SBC_IDE_PIO3_TCSOE    (0x05<<29)
-#define SBC_IDE_PIO3_TOECS    (0x01<<26)
-#define SBC_IDE_PIO3_TWCS     (0x01<<28)
-#define SBC_IDE_PIO3_TCSH     (0x0D<<24)
-#define SBC_IDE_PIO3_TCSOFF   (0x0D<<20)
-#define SBC_IDE_PIO3_TWP      (0x15<<14)
-#define SBC_IDE_PIO3_TCSW     (0x05<<10)
-#define SBC_IDE_PIO3_TPM      (0x00<<6)
-#define SBC_IDE_PIO3_TA       (0x1A<<0)
+#define SBC_IDE_PIO3_TCSOE	(0x05 << 29)
+#define SBC_IDE_PIO3_TOECS	(0x01 << 26)
+#define SBC_IDE_PIO3_TWCS	(0x01 << 28)
+#define SBC_IDE_PIO3_TCSH	(0x0D << 24)
+#define SBC_IDE_PIO3_TCSOFF	(0x0D << 20)
+#define SBC_IDE_PIO3_TWP	(0x15 << 14)
+#define SBC_IDE_PIO3_TCSW	(0x05 << 10)
+#define SBC_IDE_PIO3_TPM	(0x00 << 6)
+#define SBC_IDE_PIO3_TA 	(0x1A << 0)
 /* Timing parameters PIO mode 4 */
-#define SBC_IDE_PIO4_TCSOE    (0x04<<29)
-#define SBC_IDE_PIO4_TOECS    (0x01<<26)
-#define SBC_IDE_PIO4_TWCS     (0x01<<28)
-#define SBC_IDE_PIO4_TCSH     (0x04<<24)
-#define SBC_IDE_PIO4_TCSOFF   (0x04<<20)
-#define SBC_IDE_PIO4_TWP      (0x0D<<14)
-#define SBC_IDE_PIO4_TCSW     (0x03<<10)
-#define SBC_IDE_PIO4_TPM      (0x00<<6)
-#define SBC_IDE_PIO4_TA       (0x12<<0)
+#define SBC_IDE_PIO4_TCSOE	(0x04 << 29)
+#define SBC_IDE_PIO4_TOECS	(0x01 << 26)
+#define SBC_IDE_PIO4_TWCS	(0x01 << 28)
+#define SBC_IDE_PIO4_TCSH	(0x04 << 24)
+#define SBC_IDE_PIO4_TCSOFF	(0x04 << 20)
+#define SBC_IDE_PIO4_TWP	(0x0D << 14)
+#define SBC_IDE_PIO4_TCSW	(0x03 << 10)
+#define SBC_IDE_PIO4_TPM	(0x00 << 6)
+#define SBC_IDE_PIO4_TA 	(0x12 << 0)
 /* Timing parameters MDMA mode 0 */
-#define SBC_IDE_MDMA0_TCSOE   (0x03<<29)
-#define SBC_IDE_MDMA0_TOECS   (0x01<<26)
-#define SBC_IDE_MDMA0_TWCS    (0x01<<28)
-#define SBC_IDE_MDMA0_TCSH    (0x07<<24)
-#define SBC_IDE_MDMA0_TCSOFF  (0x07<<20)
-#define SBC_IDE_MDMA0_TWP     (0x0C<<14)
-#define SBC_IDE_MDMA0_TCSW    (0x03<<10)
-#define SBC_IDE_MDMA0_TPM     (0x00<<6)
-#define SBC_IDE_MDMA0_TA      (0x0F<<0)
+#define SBC_IDE_MDMA0_TCSOE	(0x03 << 29)
+#define SBC_IDE_MDMA0_TOECS	(0x01 << 26)
+#define SBC_IDE_MDMA0_TWCS	(0x01 << 28)
+#define SBC_IDE_MDMA0_TCSH	(0x07 << 24)
+#define SBC_IDE_MDMA0_TCSOFF	(0x07 << 20)
+#define SBC_IDE_MDMA0_TWP	(0x0C << 14)
+#define SBC_IDE_MDMA0_TCSW	(0x03 << 10)
+#define SBC_IDE_MDMA0_TPM	(0x00 << 6)
+#define SBC_IDE_MDMA0_TA	(0x0F << 0)
 /* Timing parameters MDMA mode 1 */
-#define SBC_IDE_MDMA1_TCSOE   (0x05<<29)
-#define SBC_IDE_MDMA1_TOECS   (0x01<<26)
-#define SBC_IDE_MDMA1_TWCS    (0x01<<28)
-#define SBC_IDE_MDMA1_TCSH    (0x05<<24)
-#define SBC_IDE_MDMA1_TCSOFF  (0x05<<20)
-#define SBC_IDE_MDMA1_TWP     (0x0F<<14)
-#define SBC_IDE_MDMA1_TCSW    (0x05<<10)
-#define SBC_IDE_MDMA1_TPM     (0x00<<6)
-#define SBC_IDE_MDMA1_TA      (0x15<<0)
+#define SBC_IDE_MDMA1_TCSOE	(0x05 << 29)
+#define SBC_IDE_MDMA1_TOECS	(0x01 << 26)
+#define SBC_IDE_MDMA1_TWCS	(0x01 << 28)
+#define SBC_IDE_MDMA1_TCSH	(0x05 << 24)
+#define SBC_IDE_MDMA1_TCSOFF	(0x05 << 20)
+#define SBC_IDE_MDMA1_TWP	(0x0F << 14)
+#define SBC_IDE_MDMA1_TCSW	(0x05 << 10)
+#define SBC_IDE_MDMA1_TPM	(0x00 << 6)
+#define SBC_IDE_MDMA1_TA	(0x15 << 0)
 /* Timing parameters MDMA mode 2 */
-#define SBC_IDE_MDMA2_TCSOE   (0x04<<29)
-#define SBC_IDE_MDMA2_TOECS   (0x01<<26)
-#define SBC_IDE_MDMA2_TWCS    (0x01<<28)
-#define SBC_IDE_MDMA2_TCSH    (0x04<<24)
-#define SBC_IDE_MDMA2_TCSOFF  (0x04<<20)
-#define SBC_IDE_MDMA2_TWP     (0x0D<<14)
-#define SBC_IDE_MDMA2_TCSW    (0x04<<10)
-#define SBC_IDE_MDMA2_TPM     (0x00<<6)
-#define SBC_IDE_MDMA2_TA      (0x12<<0)
+#define SBC_IDE_MDMA2_TCSOE	(0x04 << 29)
+#define SBC_IDE_MDMA2_TOECS	(0x01 << 26)
+#define SBC_IDE_MDMA2_TWCS	(0x01 << 28)
+#define SBC_IDE_MDMA2_TCSH	(0x04 << 24)
+#define SBC_IDE_MDMA2_TCSOFF	(0x04 << 20)
+#define SBC_IDE_MDMA2_TWP	(0x0D << 14)
+#define SBC_IDE_MDMA2_TCSW	(0x04 << 10)
+#define SBC_IDE_MDMA2_TPM	(0x00 << 6)
+#define SBC_IDE_MDMA2_TA	(0x12 << 0)
 
 #define SBC_IDE_TIMING(mode) \
-         SBC_IDE_##mode##_TWCS | \
-         SBC_IDE_##mode##_TCSH | \
-         SBC_IDE_##mode##_TCSOFF | \
-         SBC_IDE_##mode##_TWP | \
-         SBC_IDE_##mode##_TCSW | \
-         SBC_IDE_##mode##_TPM | \
-         SBC_IDE_##mode##_TA
+	(SBC_IDE_##mode##_TWCS | \
+	 SBC_IDE_##mode##_TCSH | \
+	 SBC_IDE_##mode##_TCSOFF | \
+	 SBC_IDE_##mode##_TWP | \
+	 SBC_IDE_##mode##_TCSW | \
+	 SBC_IDE_##mode##_TPM | \
+	 SBC_IDE_##mode##_TA)
diff --git a/include/asm-mips/mach-au1x00/au1xxx_psc.h b/include/asm-mips/mach-au1x00/au1xxx_psc.h
index 1bd4e27..dae4eca 100644
--- a/include/asm-mips/mach-au1x00/au1xxx_psc.h
+++ b/include/asm-mips/mach-au1x00/au1xxx_psc.h
@@ -33,7 +33,6 @@
 #ifndef _AU1000_PSC_H_
 #define _AU1000_PSC_H_
 
-
 /* The PSC base addresses.  */
 #ifdef CONFIG_SOC_AU1550
 #define PSC0_BASE_ADDR		0xb1a00000
@@ -47,8 +46,8 @@
 #define PSC1_BASE_ADDR		0xb1b00000
 #endif
 
-/* The PSC select and control registers are common to
- * all protocols.
+/*
+ * The PSC select and control registers are common to all protocols.
  */
 #define PSC_SEL_OFFSET		0x00000000
 #define PSC_CTRL_OFFSET		0x00000004
@@ -59,18 +58,17 @@
 #define PSC_SEL_CLK_SERCLK	(2 << 4)
 
 #define PSC_SEL_PS_MASK		0x00000007
-#define PSC_SEL_PS_DISABLED	(0)
-#define PSC_SEL_PS_SPIMODE	(2)
-#define PSC_SEL_PS_I2SMODE	(3)
-#define PSC_SEL_PS_AC97MODE	(4)
-#define PSC_SEL_PS_SMBUSMODE	(5)
-
-#define PSC_CTRL_DISABLE	(0)
-#define PSC_CTRL_SUSPEND	(2)
-#define PSC_CTRL_ENABLE		(3)
-
-/* AC97 Registers.
-*/
+#define PSC_SEL_PS_DISABLED	0
+#define PSC_SEL_PS_SPIMODE	2
+#define PSC_SEL_PS_I2SMODE	3
+#define PSC_SEL_PS_AC97MODE	4
+#define PSC_SEL_PS_SMBUSMODE	5
+
+#define PSC_CTRL_DISABLE	0
+#define PSC_CTRL_SUSPEND	2
+#define PSC_CTRL_ENABLE 	3
+
+/* AC97 Registers. */
 #define PSC_AC97CFG_OFFSET	0x00000008
 #define PSC_AC97MSK_OFFSET	0x0000000c
 #define PSC_AC97PCR_OFFSET	0x00000010
@@ -95,8 +93,7 @@
 #define PSC_AC97GPO		(AC97_PSC_BASE + PSC_AC97GPO_OFFSET)
 #define PSC_AC97GPI		(AC97_PSC_BASE + PSC_AC97GPI_OFFSET)
 
-/* AC97 Config Register.
-*/
+/* AC97 Config Register. */
 #define PSC_AC97CFG_RT_MASK	(3 << 30)
 #define PSC_AC97CFG_RT_FIFO1	(0 << 30)
 #define PSC_AC97CFG_RT_FIFO2	(1 << 30)
@@ -118,20 +115,19 @@
 #define PSC_AC97CFG_RXSLOT_MASK	(0x3ff << 1)
 #define PSC_AC97CFG_GE_ENABLE	(1)
 
-/* Enable slots 3-12.
-*/
+/* Enable slots 3-12. */
 #define PSC_AC97CFG_TXSLOT_ENA(x)	(1 << (((x) - 3) + 11))
 #define PSC_AC97CFG_RXSLOT_ENA(x)	(1 << (((x) - 3) + 1))
 
-/* The word length equation is ((x) * 2) + 2, so choose 'x' appropriately.
+/*
+ * The word length equation is ((x) * 2) + 2, so choose 'x' appropriately.
  * The only sensible numbers are 7, 9, or possibly 11.  Nah, just do the
  * arithmetic in the macro.
  */
-#define PSC_AC97CFG_SET_LEN(x)	(((((x)-2)/2) & 0xf) << 21)
+#define PSC_AC97CFG_SET_LEN(x)	(((((x) - 2) / 2) & 0xf) << 21)
 #define PSC_AC97CFG_GET_LEN(x)	(((((x) >> 21) & 0xf) * 2) + 2)
 
-/* AC97 Mask Register.
-*/
+/* AC97 Mask Register. */
 #define PSC_AC97MSK_GR		(1 << 25)
 #define PSC_AC97MSK_CD		(1 << 24)
 #define PSC_AC97MSK_RR		(1 << 13)
@@ -148,8 +144,7 @@
 				 PSC_AC97MSK_TO | PSC_AC97MSK_TU | \
 				 PSC_AC97MSK_RD | PSC_AC97MSK_TD)
 
-/* AC97 Protocol Control Register.
-*/
+/* AC97 Protocol Control Register. */
 #define PSC_AC97PCR_RC		(1 << 6)
 #define PSC_AC97PCR_RP		(1 << 5)
 #define PSC_AC97PCR_RS		(1 << 4)
@@ -157,8 +152,7 @@
 #define PSC_AC97PCR_TP		(1 << 1)
 #define PSC_AC97PCR_TS		(1 << 0)
 
-/* AC97 Status register (read only).
-*/
+/* AC97 Status register (read only). */
 #define PSC_AC97STAT_CB		(1 << 26)
 #define PSC_AC97STAT_CP		(1 << 25)
 #define PSC_AC97STAT_CR		(1 << 24)
@@ -174,8 +168,7 @@
 #define PSC_AC97STAT_DR		(1 << 1)
 #define PSC_AC97STAT_SR		(1 << 0)
 
-/* AC97 Event Register.
-*/
+/* AC97 Event Register. */
 #define PSC_AC97EVNT_GR		(1 << 25)
 #define PSC_AC97EVNT_CD		(1 << 24)
 #define PSC_AC97EVNT_RR		(1 << 13)
@@ -187,22 +180,18 @@
 #define PSC_AC97EVNT_RD		(1 << 5)
 #define PSC_AC97EVNT_TD		(1 << 4)
 
-/* CODEC Command Register.
-*/
+/* CODEC Command Register. */
 #define PSC_AC97CDC_RD		(1 << 25)
 #define PSC_AC97CDC_ID_MASK	(3 << 23)
 #define PSC_AC97CDC_INDX_MASK	(0x7f << 16)
-#define PSC_AC97CDC_ID(x)	(((x) & 0x3) << 23)
+#define PSC_AC97CDC_ID(x)	(((x) & 0x03) << 23)
 #define PSC_AC97CDC_INDX(x)	(((x) & 0x7f) << 16)
 
-/* AC97 Reset Control Register.
-*/
+/* AC97 Reset Control Register. */
 #define PSC_AC97RST_RST		(1 << 1)
 #define PSC_AC97RST_SNC		(1 << 0)
 
-
-/* PSC in I2S Mode.
-*/
+/* PSC in I2S Mode. */
 typedef struct	psc_i2s {
 	u32	psc_sel;
 	u32	psc_ctrl;
@@ -215,8 +204,7 @@ typedef struct	psc_i2s {
 	u32	psc_i2sudf;
 } psc_i2s_t;
 
-/* I2S Config Register.
-*/
+/* I2S Config Register. */
 #define PSC_I2SCFG_RT_MASK	(3 << 30)
 #define PSC_I2SCFG_RT_FIFO1	(0 << 30)
 #define PSC_I2SCFG_RT_FIFO2	(1 << 30)
@@ -247,8 +235,7 @@ typedef struct	psc_i2s {
 #define PSC_I2SCFG_MLJ		(1 << 10)
 #define PSC_I2SCFG_XM		(1 << 9)
 
-/* The word length equation is simply LEN+1.
- */
+/* The word length equation is simply LEN+1. */
 #define PSC_I2SCFG_SET_LEN(x)	((((x) - 1) & 0x1f) << 4)
 #define PSC_I2SCFG_GET_LEN(x)	((((x) >> 4) & 0x1f) + 1)
 
@@ -256,8 +243,7 @@ typedef struct	psc_i2s {
 #define PSC_I2SCFG_MLF		(1 << 1)
 #define PSC_I2SCFG_MS		(1 << 0)
 
-/* I2S Mask Register.
-*/
+/* I2S Mask Register. */
 #define PSC_I2SMSK_RR		(1 << 13)
 #define PSC_I2SMSK_RO		(1 << 12)
 #define PSC_I2SMSK_RU		(1 << 11)
@@ -271,8 +257,7 @@ typedef struct	psc_i2s {
 				 PSC_I2SMSK_TO | PSC_I2SMSK_TU | \
 				 PSC_I2SMSK_RD | PSC_I2SMSK_TD)
 
-/* I2S Protocol Control Register.
-*/
+/* I2S Protocol Control Register. */
 #define PSC_I2SPCR_RC		(1 << 6)
 #define PSC_I2SPCR_RP		(1 << 5)
 #define PSC_I2SPCR_RS		(1 << 4)
@@ -280,8 +265,7 @@ typedef struct	psc_i2s {
 #define PSC_I2SPCR_TP		(1 << 1)
 #define PSC_I2SPCR_TS		(1 << 0)
 
-/* I2S Status register (read only).
-*/
+/* I2S Status register (read only). */
 #define PSC_I2SSTAT_RF		(1 << 13)
 #define PSC_I2SSTAT_RE		(1 << 12)
 #define PSC_I2SSTAT_RR		(1 << 11)
@@ -294,8 +278,7 @@ typedef struct	psc_i2s {
 #define PSC_I2SSTAT_DR		(1 << 1)
 #define PSC_I2SSTAT_SR		(1 << 0)
 
-/* I2S Event Register.
-*/
+/* I2S Event Register. */
 #define PSC_I2SEVNT_RR		(1 << 13)
 #define PSC_I2SEVNT_RO		(1 << 12)
 #define PSC_I2SEVNT_RU		(1 << 11)
@@ -305,8 +288,7 @@ typedef struct	psc_i2s {
 #define PSC_I2SEVNT_RD		(1 << 5)
 #define PSC_I2SEVNT_TD		(1 << 4)
 
-/* PSC in SPI Mode.
-*/
+/* PSC in SPI Mode. */
 typedef struct	psc_spi {
 	u32	psc_sel;
 	u32	psc_ctrl;
@@ -318,8 +300,7 @@ typedef struct	psc_spi {
 	u32	psc_spitxrx;
 } psc_spi_t;
 
-/* SPI Config Register.
-*/
+/* SPI Config Register. */
 #define PSC_SPICFG_RT_MASK	(3 << 30)
 #define PSC_SPICFG_RT_FIFO1	(0 << 30)
 #define PSC_SPICFG_RT_FIFO2	(1 << 30)
@@ -355,8 +336,7 @@ typedef struct	psc_spi {
 #define PSC_SPICFG_MLF		(1 << 1)
 #define PSC_SPICFG_MO		(1 << 0)
 
-/* SPI Mask Register.
-*/
+/* SPI Mask Register. */
 #define PSC_SPIMSK_MM		(1 << 16)
 #define PSC_SPIMSK_RR		(1 << 13)
 #define PSC_SPIMSK_RO		(1 << 12)
@@ -371,16 +351,14 @@ typedef struct	psc_spi {
 				 PSC_SPIMSK_TU | PSC_SPIMSK_SD | \
 				 PSC_SPIMSK_MD)
 
-/* SPI Protocol Control Register.
-*/
+/* SPI Protocol Control Register. */
 #define PSC_SPIPCR_RC		(1 << 6)
 #define PSC_SPIPCR_SP		(1 << 5)
 #define PSC_SPIPCR_SS		(1 << 4)
 #define PSC_SPIPCR_TC		(1 << 2)
 #define PSC_SPIPCR_MS		(1 << 0)
 
-/* SPI Status register (read only).
-*/
+/* SPI Status register (read only). */
 #define PSC_SPISTAT_RF		(1 << 13)
 #define PSC_SPISTAT_RE		(1 << 12)
 #define PSC_SPISTAT_RR		(1 << 11)
@@ -393,8 +371,7 @@ typedef struct	psc_spi {
 #define PSC_SPISTAT_DR		(1 << 1)
 #define PSC_SPISTAT_SR		(1 << 0)
 
-/* SPI Event Register.
-*/
+/* SPI Event Register. */
 #define PSC_SPIEVNT_MM		(1 << 16)
 #define PSC_SPIEVNT_RR		(1 << 13)
 #define PSC_SPIEVNT_RO		(1 << 12)
@@ -405,13 +382,11 @@ typedef struct	psc_spi {
 #define PSC_SPIEVNT_SD		(1 << 5)
 #define PSC_SPIEVNT_MD		(1 << 4)
 
-/* Transmit register control.
-*/
+/* Transmit register control. */
 #define PSC_SPITXRX_LC		(1 << 29)
 #define PSC_SPITXRX_SR		(1 << 28)
 
-/* PSC in SMBus (I2C) Mode.
-*/
+/* PSC in SMBus (I2C) Mode. */
 typedef struct	psc_smb {
 	u32	psc_sel;
 	u32	psc_ctrl;
@@ -424,8 +399,7 @@ typedef struct	psc_smb {
 	u32	psc_smbtmr;
 } psc_smb_t;
 
-/* SMBus Config Register.
-*/
+/* SMBus Config Register. */
 #define PSC_SMBCFG_RT_MASK	(3 << 30)
 #define PSC_SMBCFG_RT_FIFO1	(0 << 30)
 #define PSC_SMBCFG_RT_FIFO2	(1 << 30)
@@ -452,8 +426,7 @@ typedef struct	psc_smb {
 
 #define PSC_SMBCFG_SET_SLV(x)	(((x) & 0x7f) << 1)
 
-/* SMBus Mask Register.
-*/
+/* SMBus Mask Register. */
 #define PSC_SMBMSK_DN		(1 << 30)
 #define PSC_SMBMSK_AN		(1 << 29)
 #define PSC_SMBMSK_AL		(1 << 28)
@@ -471,13 +444,11 @@ typedef struct	psc_smb {
 				 PSC_SMBMSK_TU | PSC_SMBMSK_SD | \
 				 PSC_SMBMSK_MD)
 
-/* SMBus Protocol Control Register.
-*/
+/* SMBus Protocol Control Register. */
 #define PSC_SMBPCR_DC		(1 << 2)
 #define PSC_SMBPCR_MS		(1 << 0)
 
-/* SMBus Status register (read only).
-*/
+/* SMBus Status register (read only). */
 #define PSC_SMBSTAT_BB		(1 << 28)
 #define PSC_SMBSTAT_RF		(1 << 13)
 #define PSC_SMBSTAT_RE		(1 << 12)
@@ -491,8 +462,7 @@ typedef struct	psc_smb {
 #define PSC_SMBSTAT_DR		(1 << 1)
 #define PSC_SMBSTAT_SR		(1 << 0)
 
-/* SMBus Event Register.
-*/
+/* SMBus Event Register. */
 #define PSC_SMBEVNT_DN		(1 << 30)
 #define PSC_SMBEVNT_AN		(1 << 29)
 #define PSC_SMBEVNT_AL		(1 << 28)
@@ -510,15 +480,13 @@ typedef struct	psc_smb {
 				 PSC_SMBEVNT_TU | PSC_SMBEVNT_SD | \
 				 PSC_SMBEVNT_MD)
 
-/* Transmit register control.
-*/
+/* Transmit register control. */
 #define PSC_SMBTXRX_RSR		(1 << 28)
 #define PSC_SMBTXRX_STP		(1 << 29)
-#define PSC_SMBTXRX_DATAMASK	(0xff)
+#define PSC_SMBTXRX_DATAMASK	0xff
 
-/* SMBus protocol timers register.
-*/
-#define PSC_SMBTMR_SET_TH(x)	(((x) & 0x3) << 30)
+/* SMBus protocol timers register. */
+#define PSC_SMBTMR_SET_TH(x)	(((x) & 0x03) << 30)
 #define PSC_SMBTMR_SET_PS(x)	(((x) & 0x1f) << 25)
 #define PSC_SMBTMR_SET_PU(x)	(((x) & 0x1f) << 20)
 #define PSC_SMBTMR_SET_SH(x)	(((x) & 0x1f) << 15)
@@ -526,5 +494,4 @@ typedef struct	psc_smb {
 #define PSC_SMBTMR_SET_CL(x)	(((x) & 0x1f) << 5)
 #define PSC_SMBTMR_SET_CH(x)	(((x) & 0x1f) << 0)
 
-
 #endif /* _AU1000_PSC_H_ */
diff --git a/include/asm-mips/mach-db1x00/db1200.h b/include/asm-mips/mach-db1x00/db1200.h
index eedd048..27f2610 100644
--- a/include/asm-mips/mach-db1x00/db1200.h
+++ b/include/asm-mips/mach-db1x00/db1200.h
@@ -1,6 +1,6 @@
 /*
- * AMD Alchemy DB1200 Referrence Board
- * Board Registers defines.
+ * AMD Alchemy DBAu1200 Reference Board
+ * Board register defines.
  *
  * ########################################################################
  *
@@ -27,26 +27,25 @@
 #include <linux/types.h>
 #include <asm/mach-au1x00/au1xxx_psc.h>
 
-// This is defined in au1000.h with bogus value
-#undef AU1X00_EXTERNAL_INT
+#define DBDMA_AC97_TX_CHAN	DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN	DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN	DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN	DSCR_CMD0_PSC1_RX
 
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
-
-/* SPI and SMB are muxed on the Pb1200 board.
-   Refer to board documentation.
+/*
+ * SPI and SMB are muxed on the DBAu1200 board.
+ * Refer to board documentation.
  */
-#define SPI_PSC_BASE        PSC0_BASE_ADDR
-#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
-/* AC97 and I2S are muxed on the Pb1200 board.
-   Refer to board documentation.
+#define SPI_PSC_BASE		PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE		PSC0_BASE_ADDR
+/*
+ * AC'97 and I2S are muxed on the DBAu1200 board.
+ * Refer to board documentation.
  */
-#define AC97_PSC_BASE       PSC1_BASE_ADDR
+#define AC97_PSC_BASE		PSC1_BASE_ADDR
 #define I2S_PSC_BASE		PSC1_BASE_ADDR
 
-#define BCSR_KSEG1_ADDR 0xB9800000
+#define BCSR_KSEG1_ADDR 	0xB9800000
 
 typedef volatile struct
 {
@@ -102,9 +101,9 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define BCSR_STATUS_SWAPBOOT	0x0040
 #define BCSR_STATUS_FLASHBUSY	0x0100
 #define BCSR_STATUS_IDECBLID	0x0200
-#define BCSR_STATUS_SD0WP		0x0400
-#define BCSR_STATUS_U0RXD		0x1000
-#define BCSR_STATUS_U1RXD		0x2000
+#define BCSR_STATUS_SD0WP	0x0400
+#define BCSR_STATUS_U0RXD	0x1000
+#define BCSR_STATUS_U1RXD	0x2000
 
 #define BCSR_SWITCHES_OCTAL	0x00FF
 #define BCSR_SWITCHES_DIP_1	0x0080
@@ -122,8 +121,8 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define BCSR_RESETS_DC		0x0004
 #define BCSR_RESETS_IDE		0x0008
 #define BCSR_RESETS_TV		0x0010
-/* not resets but in the same register */
-#define BCSR_RESETS_PWMR1mUX 0x0800
+/* Not resets but in the same register */
+#define BCSR_RESETS_PWMR1MUX	0x0800
 #define BCSR_RESETS_PCS0MUX	0x1000
 #define BCSR_RESETS_PCS1MUX	0x2000
 #define BCSR_RESETS_SPISEL	0x4000
@@ -160,7 +159,7 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define BCSR_INT_PC0STSCHG	0x0008
 #define BCSR_INT_PC1		0x0010
 #define BCSR_INT_PC1STSCHG	0x0020
-#define BCSR_INT_DC			0x0040
+#define BCSR_INT_DC		0x0040
 #define BCSR_INT_FLASHBUSY	0x0080
 #define BCSR_INT_PC0INSERT	0x0100
 #define BCSR_INT_PC0EJECT	0x0200
@@ -179,10 +178,10 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define IDE_DDMA_REQ		DSCR_CMD0_DMA_REQ1
 #define IDE_RQSIZE		128
 
-#define NAND_PHYS_ADDR   0x20000000
+#define NAND_PHYS_ADDR		0x20000000
 
 /*
- * External Interrupts for Pb1200 as of 8/6/2004.
+ * External Interrupts for DBAu1200 as of 8/6/2004.
  * Bit positions in the CPLD registers can be calculated by taking
  * the interrupt define and subtracting the DB1200_INT_BEGIN value.
  *
@@ -211,23 +210,21 @@ enum external_pb1200_ints {
 };
 
 
-/* For drivers/pcmcia/au1000_db1x00.c */
-
-/* PCMCIA Db1x00 specific defines */
-
-#define PCMCIA_MAX_SOCK 1
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+/*
+ * DBAu1200 specific PCMCIA defines for drivers/pcmcia/au1000_db1x00.c
+ */
+#define PCMCIA_MAX_SOCK  1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK + 1)
 
 /* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP, SLOT)\
-	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+#define SET_VCC_VPP(VCC, VPP, SLOT) \
+	((((VCC) << 2) | ((VPP) << 0)) << ((SLOT) * 8))
 
-#define BOARD_PC0_INT DB1200_PC0_INT
-#define BOARD_PC1_INT DB1200_PC1_INT
-#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+#define BOARD_PC0_INT	DB1200_PC0_INT
+#define BOARD_PC1_INT	DB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1 << (8 + (2 * SOCKET)))
 
-/* Nand chip select */
+/* NAND chip select */
 #define NAND_CS 1
 
 #endif /* __ASM_DB1200_H */
-
diff --git a/include/asm-mips/mach-db1x00/db1x00.h b/include/asm-mips/mach-db1x00/db1x00.h
index e7a88ba..612ae90 100644
--- a/include/asm-mips/mach-db1x00/db1x00.h
+++ b/include/asm-mips/mach-db1x00/db1x00.h
@@ -1,9 +1,8 @@
 /*
- * AMD Alchemy DB1x00 Reference Boards
+ * AMD Alchemy DBAu1x00 Reference Boards
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  * Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
  *
  * ########################################################################
@@ -32,26 +31,26 @@
 
 #ifdef CONFIG_MIPS_DB1550
 
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#define DBDMA_I2S_TX_CHAN  DSCR_CMD0_PSC3_TX
-#define DBDMA_I2S_RX_CHAN  DSCR_CMD0_PSC3_RX
+#define DBDMA_AC97_TX_CHAN	DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN	DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN	DSCR_CMD0_PSC3_TX
+#define DBDMA_I2S_RX_CHAN	DSCR_CMD0_PSC3_RX
 
-#define SPI_PSC_BASE       PSC0_BASE_ADDR
-#define AC97_PSC_BASE      PSC1_BASE_ADDR
-#define SMBUS_PSC_BASE     PSC2_BASE_ADDR
-#define I2S_PSC_BASE       PSC3_BASE_ADDR
+#define SPI_PSC_BASE		PSC0_BASE_ADDR
+#define AC97_PSC_BASE		PSC1_BASE_ADDR
+#define SMBUS_PSC_BASE		PSC2_BASE_ADDR
+#define I2S_PSC_BASE		PSC3_BASE_ADDR
 
-#define BCSR_KSEG1_ADDR 0xAF000000
-#define NAND_PHYS_ADDR  0x20000000
+#define BCSR_KSEG1_ADDR 	0xAF000000
+#define NAND_PHYS_ADDR		0x20000000
 
 #else
 #define BCSR_KSEG1_ADDR 0xAE000000
 #endif
 
 /*
- * Overlay data structure of the Db1x00 board registers.
- * Registers located at physical 0E0000xx, KSEG1 0xAE0000xx
+ * Overlay data structure of the DBAu1x00 board registers.
+ * Registers are located at physical 0E0000xx, KSEG1 0xAE0000xx.
  */
 typedef volatile struct
 {
@@ -138,18 +137,19 @@ typedef volatile struct
 
 #define BCSR_SWRESET_RESET		0x0080
 
-/* PCMCIA Db1x00 specific defines */
-#define PCMCIA_MAX_SOCK 1
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+/* PCMCIA DBAu1x00 specific defines */
+#define PCMCIA_MAX_SOCK  1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK + 1)
 
 /* VPP/VCC */
 #define SET_VCC_VPP(VCC, VPP, SLOT)\
-	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+	((((VCC) << 2) | ((VPP) << 0)) << ((SLOT) * 8))
 
-/* SD controller macros */
 /*
- * Detect card.
+ * SD controller macros
  */
+
+/* Detect card. */
 #define mmc_card_inserted(_n_, _res_) \
 	do { \
 		BCSR * const bcsr = (BCSR *)0xAE000000; \
@@ -176,10 +176,10 @@ typedef volatile struct
 		unsigned long mmc_pwr, mmc_wp, board_specific; \
 		if ((_n_)) { \
 			mmc_pwr = BCSR_BOARD_SD1_PWR; \
-			mmc_wp = BCSR_BOARD_SD1_WP; \
+			mmc_wp	= BCSR_BOARD_SD1_WP; \
 		} else { \
 			mmc_pwr = BCSR_BOARD_SD0_PWR; \
-			mmc_wp = BCSR_BOARD_SD0_WP; \
+			mmc_wp	= BCSR_BOARD_SD0_WP; \
 		} \
 		board_specific = au_readl((unsigned long)(&bcsr->specific)); \
 		if (!(board_specific & mmc_wp)) {/* low means card present */ \
@@ -190,17 +190,19 @@ typedef volatile struct
 	} while (0)
 
 
-/* NAND defines */
-/* Timing values as described in databook, * ns value stripped of
+/*
+ * NAND defines
+ *
+ * Timing values as described in databook, * ns value stripped of the
  * lower 2 bits.
- * These defines are here rather than an SOC1550 generic file because
+ * These defines are here rather than an Au1550 generic file because
  * the parts chosen on another board may be different and may require
  * different timings.
  */
-#define NAND_T_H			(18 >> 2)
-#define NAND_T_PUL			(30 >> 2)
-#define NAND_T_SU			(30 >> 2)
-#define NAND_T_WH			(30 >> 2)
+#define NAND_T_H		(18 >> 2)
+#define NAND_T_PUL		(30 >> 2)
+#define NAND_T_SU		(30 >> 2)
+#define NAND_T_WH		(30 >> 2)
 
 /* Bitfield shift amounts */
 #define NAND_T_H_SHIFT		0
@@ -208,16 +210,15 @@ typedef volatile struct
 #define NAND_T_SU_SHIFT		8
 #define NAND_T_WH_SHIFT		12
 
-#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
-			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
-			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
-			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
-#define NAND_CS 1
+#define NAND_TIMING	(((NAND_T_H   & 0xF) << NAND_T_H_SHIFT)   | \
+			 ((NAND_T_PUL & 0xF) << NAND_T_PUL_SHIFT) | \
+			 ((NAND_T_SU  & 0xF) << NAND_T_SU_SHIFT)  | \
+			 ((NAND_T_WH  & 0xF) << NAND_T_WH_SHIFT))
+#define NAND_CS 	1
 
-/* should be done by yamon */
-#define NAND_STCFG  0x00400005 /* 8-bit NAND */
-#define NAND_STTIME 0x00007774 /* valid for 396MHz SD=2 only */
-#define NAND_STADDR 0x12000FFF /* physical address 0x20000000 */
+/* Should be done by YAMON */
+#define NAND_STCFG	0x00400005 /* 8-bit NAND */
+#define NAND_STTIME	0x00007774 /* valid for 396 MHz SD=2 only */
+#define NAND_STADDR	0x12000FFF /* physical address 0x20000000 */
 
 #endif /* __ASM_DB1X00_H */
-
diff --git a/include/asm-mips/mach-pb1x00/pb1000.h b/include/asm-mips/mach-pb1x00/pb1000.h
index b52e0e7..6d1ff90 100644
--- a/include/asm-mips/mach-pb1x00/pb1000.h
+++ b/include/asm-mips/mach-pb1x00/pb1000.h
@@ -1,9 +1,8 @@
 /*
- * Alchemy Semi PB1000 Referrence Board
+ * Alchemy Semi Pb1000 Referrence Board
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  * ########################################################################
  *
@@ -28,145 +27,61 @@
 #define __ASM_PB1000_H
 
 /* PCMCIA PB1000 specific defines */
-#define PCMCIA_MAX_SOCK 1
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
-
-#define PB1000_PCR     0xBE000000
-#  define PCR_SLOT_0_VPP0  (1<<0)
-#  define PCR_SLOT_0_VPP1  (1<<1)
-#  define PCR_SLOT_0_VCC0  (1<<2)
-#  define PCR_SLOT_0_VCC1  (1<<3)
-#  define PCR_SLOT_0_RST   (1<<4)
-
-#  define PCR_SLOT_1_VPP0  (1<<8)
-#  define PCR_SLOT_1_VPP1  (1<<9)
-#  define PCR_SLOT_1_VCC0  (1<<10)
-#  define PCR_SLOT_1_VCC1  (1<<11)
-#  define PCR_SLOT_1_RST   (1<<12)
-
-#define PB1000_MDR     0xBE000004
-#  define MDR_PI        (1<<5)  /* pcmcia int latch  */
-#  define MDR_EPI      (1<<14)  /* enable pcmcia int */
-#  define MDR_CPI      (1<<15)  /* clear pcmcia int  */
-
-#define PB1000_ACR1    0xBE000008
-#  define ACR1_SLOT_0_CD1    (1<<0)  /* card detect 1     */
-#  define ACR1_SLOT_0_CD2    (1<<1)  /* card detect 2     */
-#  define ACR1_SLOT_0_READY  (1<<2)  /* ready             */
-#  define ACR1_SLOT_0_STATUS (1<<3)  /* status change     */
-#  define ACR1_SLOT_0_VS1    (1<<4)  /* voltage sense 1   */
-#  define ACR1_SLOT_0_VS2    (1<<5)  /* voltage sense 2   */
-#  define ACR1_SLOT_0_INPACK (1<<6)  /* inpack pin status */
-#  define ACR1_SLOT_1_CD1    (1<<8)  /* card detect 1     */
-#  define ACR1_SLOT_1_CD2    (1<<9)  /* card detect 2     */
-#  define ACR1_SLOT_1_READY  (1<<10) /* ready             */
-#  define ACR1_SLOT_1_STATUS (1<<11) /* status change     */
-#  define ACR1_SLOT_1_VS1    (1<<12) /* voltage sense 1   */
-#  define ACR1_SLOT_1_VS2    (1<<13) /* voltage sense 2   */
-#  define ACR1_SLOT_1_INPACK (1<<14) /* inpack pin status */
-
-#define CPLD_AUX0      0xBE00000C
-#define CPLD_AUX1      0xBE000010
-#define CPLD_AUX2      0xBE000014
+#define PCMCIA_MAX_SOCK  1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK + 1)
+
+#define PB1000_PCR		0xBE000000
+#  define PCR_SLOT_0_VPP0	(1 << 0)
+#  define PCR_SLOT_0_VPP1	(1 << 1)
+#  define PCR_SLOT_0_VCC0	(1 << 2)
+#  define PCR_SLOT_0_VCC1	(1 << 3)
+#  define PCR_SLOT_0_RST	(1 << 4)
+#  define PCR_SLOT_1_VPP0	(1 << 8)
+#  define PCR_SLOT_1_VPP1	(1 << 9)
+#  define PCR_SLOT_1_VCC0	(1 << 10)
+#  define PCR_SLOT_1_VCC1	(1 << 11)
+#  define PCR_SLOT_1_RST	(1 << 12)
+
+#define PB1000_MDR		0xBE000004
+#  define MDR_PI		(1 << 5)	/* PCMCIA int latch  */
+#  define MDR_EPI		(1 << 14)	/* enable PCMCIA int */
+#  define MDR_CPI		(1 << 15)	/* clear  PCMCIA int  */
+
+#define PB1000_ACR1		0xBE000008
+#  define ACR1_SLOT_0_CD1	(1 << 0)	/* card detect 1	*/
+#  define ACR1_SLOT_0_CD2	(1 << 1)	/* card detect 2	*/
+#  define ACR1_SLOT_0_READY	(1 << 2)	/* ready		*/
+#  define ACR1_SLOT_0_STATUS	(1 << 3)	/* status change	*/
+#  define ACR1_SLOT_0_VS1	(1 << 4)	/* voltage sense 1	*/
+#  define ACR1_SLOT_0_VS2	(1 << 5)	/* voltage sense 2	*/
+#  define ACR1_SLOT_0_INPACK	(1 << 6)	/* inpack pin status	*/
+#  define ACR1_SLOT_1_CD1	(1 << 8)	/* card detect 1	*/
+#  define ACR1_SLOT_1_CD2	(1 << 9)	/* card detect 2	*/
+#  define ACR1_SLOT_1_READY	(1 << 10)	/* ready		*/
+#  define ACR1_SLOT_1_STATUS	(1 << 11)	/* status change	*/
+#  define ACR1_SLOT_1_VS1	(1 << 12)	/* voltage sense 1	*/
+#  define ACR1_SLOT_1_VS2	(1 << 13)	/* voltage sense 2	*/
+#  define ACR1_SLOT_1_INPACK	(1 << 14)	/* inpack pin status	*/
+
+#define CPLD_AUX0		0xBE00000C
+#define CPLD_AUX1		0xBE000010
+#define CPLD_AUX2		0xBE000014
 
 /* Voltage levels */
 
 /* VPPEN1 - VPPEN0 */
-#define VPP_GND ((0<<1) | (0<<0))
-#define VPP_5V  ((1<<1) | (0<<0))
-#define VPP_3V  ((0<<1) | (1<<0))
-#define VPP_12V ((0<<1) | (1<<0))
-#define VPP_HIZ ((1<<1) | (1<<0))
+#define VPP_GND ((0 << 1) | (0 << 0))
+#define VPP_5V	((1 << 1) | (0 << 0))
+#define VPP_3V	((0 << 1) | (1 << 0))
+#define VPP_12V ((0 << 1) | (1 << 0))
+#define VPP_HIZ ((1 << 1) | (1 << 0))
 
 /* VCCEN1 - VCCEN0 */
-#define VCC_3V  ((0<<1) | (1<<0))
-#define VCC_5V  ((1<<1) | (0<<0))
-#define VCC_HIZ ((0<<1) | (0<<0))
+#define VCC_3V	((0 << 1) | (1 << 0))
+#define VCC_5V	((1 << 1) | (0 << 0))
+#define VCC_HIZ ((0 << 1) | (0 << 0))
 
 /* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP, SLOT)\
-	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
-
-
-/* PCI PB1000 specific defines */
-/* The reason these defines are here instead of au1000.h is because
- * the Au1000 does not have a PCI bus controller so the PCI implementation
- * on the some of the older Pb1000 boards was very board specific.
- */
-#define PCI_CONFIG_BASE   0xBA020000 /* the only external slot */
-
-#define SDRAM_DEVID       0xBA010000
-#define SDRAM_CMD         0xBA010004
-#define SDRAM_CLASS       0xBA010008
-#define SDRAM_MISC        0xBA01000C
-#define SDRAM_MBAR        0xBA010010
-
-#define PCI_IO_DATA_PORT  0xBA800000
-
-#define PCI_IO_ADDR       0xBE00001C
-#define PCI_INT_ACK       0xBBC00000
-#define PCI_IO_READ       0xBBC00020
-#define PCI_IO_WRITE      0xBBC00030
-
-#define PCI_BRIDGE_CONFIG 0xBE000018
-
-#define PCI_IO_START      0x10000000
-#define PCI_IO_END        0x1000ffff
-#define PCI_MEM_START     0x18000000
-#define PCI_MEM_END       0x18ffffff
-
-#define PCI_FIRST_DEVFN   0
-#define PCI_LAST_DEVFN    1
-
-static inline u8 au_pci_io_readb(u32 addr)
-{
-	writel(addr, PCI_IO_ADDR);
-	writel((readl(PCI_BRIDGE_CONFIG) & 0xffffcfff) | (1<<12), PCI_BRIDGE_CONFIG);
-	return (readl(PCI_IO_DATA_PORT) & 0xff);
-}
-
-static inline u16 au_pci_io_readw(u32 addr)
-{
-	writel(addr, PCI_IO_ADDR);
-	writel((readl(PCI_BRIDGE_CONFIG) & 0xffffcfff) | (1<<13), PCI_BRIDGE_CONFIG);
-	return (readl(PCI_IO_DATA_PORT) & 0xffff);
-}
-
-static inline u32 au_pci_io_readl(u32 addr)
-{
-	writel(addr, PCI_IO_ADDR);
-	writel((readl(PCI_BRIDGE_CONFIG) & 0xffffcfff), PCI_BRIDGE_CONFIG);
-	return readl(PCI_IO_DATA_PORT);
-}
-
-static inline void au_pci_io_writeb(u8 val, u32 addr)
-{
-	writel(addr, PCI_IO_ADDR);
-	writel((readl(PCI_BRIDGE_CONFIG) & 0xffffcfff) | (1<<12), PCI_BRIDGE_CONFIG);
-	writel(val, PCI_IO_DATA_PORT);
-}
-
-static inline void au_pci_io_writew(u16 val, u32 addr)
-{
-	writel(addr, PCI_IO_ADDR);
-	writel((readl(PCI_BRIDGE_CONFIG) & 0xffffcfff) | (1<<13), PCI_BRIDGE_CONFIG);
-	writel(val, PCI_IO_DATA_PORT);
-}
-
-static inline void au_pci_io_writel(u32 val, u32 addr)
-{
-	writel(addr, PCI_IO_ADDR);
-	writel(readl(PCI_BRIDGE_CONFIG) & 0xffffcfff, PCI_BRIDGE_CONFIG);
-	writel(val, PCI_IO_DATA_PORT);
-}
-
-static inline void set_sdram_extbyte(void)
-{
-	writel(readl(PCI_BRIDGE_CONFIG) & 0xffffff00, PCI_BRIDGE_CONFIG);
-}
-
-static inline void set_slot_extbyte(void)
-{
-	writel((readl(PCI_BRIDGE_CONFIG) & 0xffffbf00) | 0x18, PCI_BRIDGE_CONFIG);
-}
+#define SET_VCC_VPP(VCC, VPP, SLOT) \
+	((((VCC) << 2) | ((VPP) << 0)) << ((SLOT) * 8))
 #endif /* __ASM_PB1000_H */
diff --git a/include/asm-mips/mach-pb1x00/pb1100.h b/include/asm-mips/mach-pb1x00/pb1100.h
index 63aa392..b1a60f1 100644
--- a/include/asm-mips/mach-pb1x00/pb1100.h
+++ b/include/asm-mips/mach-pb1x00/pb1100.h
@@ -1,9 +1,8 @@
 /*
- * Alchemy Semi PB1100 Referrence Board
+ * Alchemy Semi Pb1100 Referrence Board
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  * ########################################################################
  *
@@ -27,59 +26,60 @@
 #ifndef __ASM_PB1100_H
 #define __ASM_PB1100_H
 
-#define PB1100_IDENT          0xAE000000
-#define BOARD_STATUS_REG      0xAE000004
-#  define PB1100_ROM_SEL         (1<<15)
-#  define PB1100_ROM_SIZ         (1<<14)
-#  define PB1100_SWAP_BOOT       (1<<13)
-#  define PB1100_FLASH_WP        (1<<12)
-#  define PB1100_ROM_H_STS       (1<<11)
-#  define PB1100_ROM_L_STS       (1<<10)
-#  define PB1100_FLASH_H_STS      (1<<9)
-#  define PB1100_FLASH_L_STS      (1<<8)
-#  define PB1100_SRAM_SIZ         (1<<7)
-#  define PB1100_TSC_BUSY         (1<<6)
-#  define PB1100_PCMCIA_VS_MASK   (3<<4)
-#  define PB1100_RS232_CD         (1<<3)
-#  define PB1100_RS232_CTS        (1<<2)
-#  define PB1100_RS232_DSR        (1<<1)
-#  define PB1100_RS232_RI         (1<<0)
+#define PB1100_IDENT		0xAE000000
+#define BOARD_STATUS_REG	0xAE000004
+#  define PB1100_ROM_SEL	(1 << 15)
+#  define PB1100_ROM_SIZ	(1 << 14)
+#  define PB1100_SWAP_BOOT	(1 << 13)
+#  define PB1100_FLASH_WP	(1 << 12)
+#  define PB1100_ROM_H_STS	(1 << 11)
+#  define PB1100_ROM_L_STS	(1 << 10)
+#  define PB1100_FLASH_H_STS	(1 << 9)
+#  define PB1100_FLASH_L_STS	(1 << 8)
+#  define PB1100_SRAM_SIZ	(1 << 7)
+#  define PB1100_TSC_BUSY	(1 << 6)
+#  define PB1100_PCMCIA_VS_MASK (3 << 4)
+#  define PB1100_RS232_CD	(1 << 3)
+#  define PB1100_RS232_CTS	(1 << 2)
+#  define PB1100_RS232_DSR	(1 << 1)
+#  define PB1100_RS232_RI	(1 << 0)
 
-#define PB1100_IRDA_RS232     0xAE00000C
-#  define PB1100_IRDA_FULL       (0<<14) /* full power */
-#  define PB1100_IRDA_SHUTDOWN   (1<<14)
-#  define PB1100_IRDA_TT         (2<<14) /* 2/3 power */
-#  define PB1100_IRDA_OT         (3<<14) /* 1/3 power */
-#  define PB1100_IRDA_FIR        (1<<13)
+#define PB1100_IRDA_RS232	0xAE00000C
+#  define PB1100_IRDA_FULL	(0 << 14)	/* full power		*/
+#  define PB1100_IRDA_SHUTDOWN	(1 << 14)
+#  define PB1100_IRDA_TT	(2 << 14)	/* 2/3 power		*/
+#  define PB1100_IRDA_OT	(3 << 14)	/* 1/3 power		*/
+#  define PB1100_IRDA_FIR	(1 << 13)
 
-#define PCMCIA_BOARD_REG     0xAE000010
-#  define PB1100_SD_WP1_RO       (1<<15) /* read only */
-#  define PB1100_SD_WP0_RO       (1<<14) /* read only */
-#  define PB1100_SD_PWR1         (1<<11) /* applies power to SD1 */
-#  define PB1100_SD_PWR0         (1<<10) /* applies power to SD0 */
-#  define PB1100_SEL_SD_CONN1     (1<<9)
-#  define PB1100_SEL_SD_CONN0     (1<<8)
-#  define PC_DEASSERT_RST         (1<<7)
-#  define PC_DRV_EN               (1<<4)
+#define PCMCIA_BOARD_REG	0xAE000010
+#  define PB1100_SD_WP1_RO	(1 << 15)	/* read only		*/
+#  define PB1100_SD_WP0_RO	(1 << 14)	/* read only		*/
+#  define PB1100_SD_PWR1	(1 << 11)	/* applies power to SD1 */
+#  define PB1100_SD_PWR0	(1 << 10)	/* applies power to SD0 */
+#  define PB1100_SEL_SD_CONN1	(1 << 9)
+#  define PB1100_SEL_SD_CONN0	(1 << 8)
+#  define PC_DEASSERT_RST	(1 << 7)
+#  define PC_DRV_EN		(1 << 4)
 
-#define PB1100_G_CONTROL      0xAE000014 /* graphics control */
+#define PB1100_G_CONTROL	0xAE000014	/* graphics control	*/
 
-#define PB1100_RST_VDDI       0xAE00001C
-#  define PB1100_SOFT_RESET      (1<<15) /* clear to reset the board */
-#  define PB1100_VDDI_MASK        (0x1F)
+#define PB1100_RST_VDDI 	0xAE00001C
+#  define PB1100_SOFT_RESET	(1 << 15)	/* clear to reset the board */
+#  define PB1100_VDDI_MASK	0x1F
 
-#define PB1100_LEDS           0xAE000018
+#define PB1100_LEDS		0xAE000018
 
-/* 11:8 is 4 discreet LEDs. Clearing a bit illuminates the LED.
- * 7:0 is the LED Display's decimal points.
+/*
+ * 11:8 is 4 discreet LEDs. Clearing a bit illuminates the LED.
+ * 7:0  is the LED Display's decimal points.
  */
-#define PB1100_HEX_LED        0xAE000018
+#define PB1100_HEX_LED		0xAE000018
 
-/* PCMCIA PB1100 specific defines */
-#define PCMCIA_MAX_SOCK 0
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+/* PCMCIA Pb1100 specific defines */
+#define PCMCIA_MAX_SOCK  0
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK + 1)
 
 /* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP) (((VCC)<<2) | ((VPP)<<0))
+#define SET_VCC_VPP(VCC, VPP) (((VCC) << 2) | ((VPP) << 0))
 
 #endif /* __ASM_PB1100_H */
diff --git a/include/asm-mips/mach-pb1x00/pb1200.h b/include/asm-mips/mach-pb1x00/pb1200.h
index e2c6bca..c8618df 100644
--- a/include/asm-mips/mach-pb1x00/pb1200.h
+++ b/include/asm-mips/mach-pb1x00/pb1200.h
@@ -1,5 +1,5 @@
 /*
- * AMD Alchemy PB1200 Referrence Board
+ * AMD Alchemy Pb1200 Referrence Board
  * Board Registers defines.
  *
  * ########################################################################
@@ -27,21 +27,20 @@
 #include <linux/types.h>
 #include <asm/mach-au1x00/au1xxx_psc.h>
 
-// This is defined in au1000.h with bogus value
-#undef AU1X00_EXTERNAL_INT
+#define DBDMA_AC97_TX_CHAN	DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN	DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN	DSCR_CMD0_PSC1_TX
+#define DBDMA_I2S_RX_CHAN	DSCR_CMD0_PSC1_RX
 
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC1_RX
-
-/* SPI and SMB are muxed on the Pb1200 board.
-   Refer to board documentation.
+/*
+ * SPI and SMB are muxed on the Pb1200 board.
+ * Refer to board documentation.
  */
-#define SPI_PSC_BASE        PSC0_BASE_ADDR
-#define SMBUS_PSC_BASE      PSC0_BASE_ADDR
-/* AC97 and I2S are muxed on the Pb1200 board.
-   Refer to board documentation.
+#define SPI_PSC_BASE		PSC0_BASE_ADDR
+#define SMBUS_PSC_BASE		PSC0_BASE_ADDR
+/*
+ * AC97 and I2S are muxed on the Pb1200 board.
+ * Refer to board documentation.
  */
 #define AC97_PSC_BASE       PSC1_BASE_ADDR
 #define I2S_PSC_BASE		PSC1_BASE_ADDR
@@ -102,10 +101,10 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define BCSR_STATUS_SWAPBOOT	0x0040
 #define BCSR_STATUS_FLASHBUSY	0x0100
 #define BCSR_STATUS_IDECBLID	0x0200
-#define BCSR_STATUS_SD0WP		0x0400
-#define BCSR_STATUS_SD1WP		0x0800
-#define BCSR_STATUS_U0RXD		0x1000
-#define BCSR_STATUS_U1RXD		0x2000
+#define BCSR_STATUS_SD0WP	0x0400
+#define BCSR_STATUS_SD1WP	0x0800
+#define BCSR_STATUS_U0RXD	0x1000
+#define BCSR_STATUS_U1RXD	0x2000
 
 #define BCSR_SWITCHES_OCTAL	0x00FF
 #define BCSR_SWITCHES_DIP_1	0x0080
@@ -123,11 +122,11 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define BCSR_RESETS_DC		0x0004
 #define BCSR_RESETS_IDE		0x0008
 /* not resets but in the same register */
-#define BCSR_RESETS_WSCFSM  0x0800
+#define BCSR_RESETS_WSCFSM	0x0800
 #define BCSR_RESETS_PCS0MUX	0x1000
 #define BCSR_RESETS_PCS1MUX	0x2000
 #define BCSR_RESETS_SPISEL	0x4000
-#define BCSR_RESETS_SD1MUX  0x8000
+#define BCSR_RESETS_SD1MUX	0x8000
 
 #define BCSR_PCMCIA_PC0VPP	0x0003
 #define BCSR_PCMCIA_PC0VCC	0x000C
@@ -163,7 +162,7 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define BCSR_INT_PC0STSCHG	0x0008
 #define BCSR_INT_PC1		0x0010
 #define BCSR_INT_PC1STSCHG	0x0020
-#define BCSR_INT_DC			0x0040
+#define BCSR_INT_DC		0x0040
 #define BCSR_INT_FLASHBUSY	0x0080
 #define BCSR_INT_PC0INSERT	0x0100
 #define BCSR_INT_PC0EJECT	0x0200
@@ -174,14 +173,6 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define BCSR_INT_SD1INSERT	0x4000
 #define BCSR_INT_SD1EJECT	0x8000
 
-/* PCMCIA Db1x00 specific defines */
-#define PCMCIA_MAX_SOCK 1
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
-
-/* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP, SLOT)\
-	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
-
 #define SMC91C111_PHYS_ADDR	0x0D000300
 #define SMC91C111_INT		PB1200_ETH_INT
 
@@ -192,18 +183,19 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define IDE_DDMA_REQ		DSCR_CMD0_DMA_REQ1
 #define IDE_RQSIZE		128
 
-#define NAND_PHYS_ADDR   0x1C000000
+#define NAND_PHYS_ADDR 	0x1C000000
 
-/* Timing values as described in databook, * ns value stripped of
+/*
+ * Timing values as described in databook, * ns value stripped of
  * lower 2 bits.
- * These defines are here rather than an SOC1200 generic file because
+ * These defines are here rather than an Au1200 generic file because
  * the parts chosen on another board may be different and may require
  * different timings.
  */
-#define NAND_T_H			(18 >> 2)
-#define NAND_T_PUL			(30 >> 2)
-#define NAND_T_SU			(30 >> 2)
-#define NAND_T_WH			(30 >> 2)
+#define NAND_T_H		(18 >> 2)
+#define NAND_T_PUL		(30 >> 2)
+#define NAND_T_SU		(30 >> 2)
+#define NAND_T_WH		(30 >> 2)
 
 /* Bitfield shift amounts */
 #define NAND_T_H_SHIFT		0
@@ -211,11 +203,10 @@ static BCSR * const bcsr = (BCSR *)BCSR_KSEG1_ADDR;
 #define NAND_T_SU_SHIFT		8
 #define NAND_T_WH_SHIFT		12
 
-#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
-			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
-			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
-			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
-
+#define NAND_TIMING	(((NAND_T_H   & 0xF) << NAND_T_H_SHIFT)   | \
+			 ((NAND_T_PUL & 0xF) << NAND_T_PUL_SHIFT) | \
+			 ((NAND_T_SU  & 0xF) << NAND_T_SU_SHIFT)  | \
+			 ((NAND_T_WH  & 0xF) << NAND_T_WH_SHIFT))
 
 /*
  * External Interrupts for Pb1200 as of 8/6/2004.
@@ -248,13 +239,21 @@ enum external_pb1200_ints {
 	PB1200_INT_END		= PB1200_INT_BEGIN + 15
 };
 
-/* For drivers/pcmcia/au1000_db1x00.c */
-#define BOARD_PC0_INT PB1200_PC0_INT
-#define BOARD_PC1_INT PB1200_PC1_INT
-#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1<<(8+(2*SOCKET)))
+/*
+ * Pb1200 specific PCMCIA defines for drivers/pcmcia/au1000_db1x00.c
+ */
+#define PCMCIA_MAX_SOCK  1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK + 1)
 
-/* Nand chip select */
+/* VPP/VCC */
+#define SET_VCC_VPP(VCC, VPP, SLOT) \
+	((((VCC) << 2) | ((VPP) << 0)) << ((SLOT) * 8))
+
+#define BOARD_PC0_INT	PB1200_PC0_INT
+#define BOARD_PC1_INT	PB1200_PC1_INT
+#define BOARD_CARD_INSERTED(SOCKET) bcsr->sig_status & (1 << (8 + (2 * SOCKET)))
+
+/* NAND chip select */
 #define NAND_CS 1
 
 #endif /* __ASM_PB1200_H */
-
diff --git a/include/asm-mips/mach-pb1x00/pb1500.h b/include/asm-mips/mach-pb1x00/pb1500.h
index ff6d40c..da51a2e 100644
--- a/include/asm-mips/mach-pb1x00/pb1500.h
+++ b/include/asm-mips/mach-pb1x00/pb1500.h
@@ -1,9 +1,8 @@
 /*
- * Alchemy Semi PB1500 Referrence Board
+ * Alchemy Semi Pb1500 Referrence Board
  *
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *         	ppopov@mvista.com or source@mvista.com
+ * Copyright 2001, 2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com>
  *
  * ########################################################################
  *
@@ -27,25 +26,24 @@
 #ifndef __ASM_PB1500_H
 #define __ASM_PB1500_H
 
+#define IDENT_BOARD_REG 	0xAE000000
+#define BOARD_STATUS_REG	0xAE000004
+#define PCI_BOARD_REG		0xAE000010
+#define PCMCIA_BOARD_REG	0xAE000010
+#  define PC_DEASSERT_RST	      0x80
+#  define PC_DRV_EN		      0x10
+#define PB1500_G_CONTROL	0xAE000014
+#define PB1500_RST_VDDI 	0xAE00001C
+#define PB1500_LEDS		0xAE000018
 
-#define IDENT_BOARD_REG           0xAE000000
-#define BOARD_STATUS_REG          0xAE000004
-#define PCI_BOARD_REG             0xAE000010
-#define PCMCIA_BOARD_REG          0xAE000010
-  #define PC_DEASSERT_RST               0x80
-  #define PC_DRV_EN                     0x10
-#define PB1500_G_CONTROL          0xAE000014
-#define PB1500_RST_VDDI           0xAE00001C
-#define PB1500_LEDS               0xAE000018
+#define PB1500_HEX_LED		0xAF000004
+#define PB1500_HEX_LED_BLANK	0xAF000008
 
-#define PB1500_HEX_LED            0xAF000004
-#define PB1500_HEX_LED_BLANK      0xAF000008
-
-/* PCMCIA PB1500 specific defines */
-#define PCMCIA_MAX_SOCK 0
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+/* PCMCIA Pb1500 specific defines */
+#define PCMCIA_MAX_SOCK  0
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK + 1)
 
 /* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP) (((VCC)<<2) | ((VPP)<<0))
+#define SET_VCC_VPP(VCC, VPP) (((VCC) << 2) | ((VPP) << 0))
 
 #endif /* __ASM_PB1500_H */
diff --git a/include/asm-mips/mach-pb1x00/pb1550.h b/include/asm-mips/mach-pb1x00/pb1550.h
index c2ab0e2..6704a11 100644
--- a/include/asm-mips/mach-pb1x00/pb1550.h
+++ b/include/asm-mips/mach-pb1x00/pb1550.h
@@ -30,15 +30,15 @@
 #include <linux/types.h>
 #include <asm/mach-au1x00/au1xxx_psc.h>
 
-#define DBDMA_AC97_TX_CHAN DSCR_CMD0_PSC1_TX
-#define DBDMA_AC97_RX_CHAN DSCR_CMD0_PSC1_RX
-#define DBDMA_I2S_TX_CHAN DSCR_CMD0_PSC3_TX
-#define DBDMA_I2S_RX_CHAN DSCR_CMD0_PSC3_RX
+#define DBDMA_AC97_TX_CHAN	DSCR_CMD0_PSC1_TX
+#define DBDMA_AC97_RX_CHAN	DSCR_CMD0_PSC1_RX
+#define DBDMA_I2S_TX_CHAN	DSCR_CMD0_PSC3_TX
+#define DBDMA_I2S_RX_CHAN	DSCR_CMD0_PSC3_RX
 
-#define SPI_PSC_BASE        PSC0_BASE_ADDR
-#define AC97_PSC_BASE       PSC1_BASE_ADDR
-#define SMBUS_PSC_BASE      PSC2_BASE_ADDR
-#define I2S_PSC_BASE        PSC3_BASE_ADDR
+#define SPI_PSC_BASE		PSC0_BASE_ADDR
+#define AC97_PSC_BASE		PSC1_BASE_ADDR
+#define SMBUS_PSC_BASE		PSC2_BASE_ADDR
+#define I2S_PSC_BASE		PSC3_BASE_ADDR
 
 #define BCSR_PHYS_ADDR 0xAF000000
 
@@ -129,12 +129,12 @@ static BCSR * const bcsr = (BCSR *)BCSR_PHYS_ADDR;
 #define BCSR_SYSTEM_POWEROFF	0x4000
 #define BCSR_SYSTEM_RESET	0x8000
 
-#define PCMCIA_MAX_SOCK 1
-#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK+1)
+#define PCMCIA_MAX_SOCK  1
+#define PCMCIA_NUM_SOCKS (PCMCIA_MAX_SOCK + 1)
 
 /* VPP/VCC */
-#define SET_VCC_VPP(VCC, VPP, SLOT)\
-	((((VCC)<<2) | ((VPP)<<0)) << ((SLOT)*8))
+#define SET_VCC_VPP(VCC, VPP, SLOT) \
+	((((VCC) << 2) | ((VPP) << 0)) << ((SLOT) * 8))
 
 #if defined(CONFIG_MTD_PB1550_BOOT) && defined(CONFIG_MTD_PB1550_USER)
 #define PB1550_BOTH_BANKS
@@ -144,16 +144,17 @@ static BCSR * const bcsr = (BCSR *)BCSR_PHYS_ADDR;
 #define PB1550_USER_ONLY
 #endif
 
-/* Timing values as described in databook, * ns value stripped of
+/*
+ * Timing values as described in databook, * ns value stripped of
  * lower 2 bits.
  * These defines are here rather than an SOC1550 generic file because
  * the parts chosen on another board may be different and may require
  * different timings.
  */
-#define NAND_T_H			(18 >> 2)
-#define NAND_T_PUL			(30 >> 2)
-#define NAND_T_SU			(30 >> 2)
-#define NAND_T_WH			(30 >> 2)
+#define NAND_T_H		(18 >> 2)
+#define NAND_T_PUL		(30 >> 2)
+#define NAND_T_SU		(30 >> 2)
+#define NAND_T_WH		(30 >> 2)
 
 /* Bitfield shift amounts */
 #define NAND_T_H_SHIFT		0
@@ -161,16 +162,16 @@ static BCSR * const bcsr = (BCSR *)BCSR_PHYS_ADDR;
 #define NAND_T_SU_SHIFT		8
 #define NAND_T_WH_SHIFT		12
 
-#define NAND_TIMING	((NAND_T_H   & 0xF)	<< NAND_T_H_SHIFT)   | \
-			((NAND_T_PUL & 0xF)	<< NAND_T_PUL_SHIFT) | \
-			((NAND_T_SU  & 0xF)	<< NAND_T_SU_SHIFT)  | \
-			((NAND_T_WH  & 0xF)	<< NAND_T_WH_SHIFT)
+#define NAND_TIMING	(((NAND_T_H   & 0xF) << NAND_T_H_SHIFT)   | \
+			 ((NAND_T_PUL & 0xF) << NAND_T_PUL_SHIFT) | \
+			 ((NAND_T_SU  & 0xF) << NAND_T_SU_SHIFT)  | \
+			 ((NAND_T_WH  & 0xF) << NAND_T_WH_SHIFT))
 
 #define NAND_CS 1
 
-/* should be done by yamon */
-#define NAND_STCFG  0x00400005 /* 8-bit NAND */
-#define NAND_STTIME 0x00007774 /* valid for 396MHz SD=2 only */
-#define NAND_STADDR 0x12000FFF /* physical address 0x20000000 */
+/* Should be done by YAMON */
+#define NAND_STCFG	0x00400005 /* 8-bit NAND */
+#define NAND_STTIME	0x00007774 /* valid for 396 MHz SD=2 only */
+#define NAND_STADDR	0x12000FFF /* physical address 0x20000000 */
 
 #endif /* __ASM_PB1550_H */
diff --git a/include/asm-mips/rtlx.h b/include/asm-mips/rtlx.h
index 65778c8..20b6660 100644
--- a/include/asm-mips/rtlx.h
+++ b/include/asm-mips/rtlx.h
@@ -29,13 +29,13 @@ extern unsigned int rtlx_read_poll(int index, int can_sleep);
 extern unsigned int rtlx_write_poll(int index);
 
 enum rtlx_state {
-	RTLX_STATE_UNUSED,
+	RTLX_STATE_UNUSED = 0,
 	RTLX_STATE_INITIALISED,
 	RTLX_STATE_REMOTE_READY,
 	RTLX_STATE_OPENED
 };
 
-#define RTLX_BUFFER_SIZE 1024
+#define RTLX_BUFFER_SIZE 2048
 
 /* each channel supports read and write.
    linux (vpe0) reads lx_buffer  and writes rt_buffer
diff --git a/include/asm-ppc/system.h b/include/asm-ppc/system.h
index 0593cb8..70ebd33 100644
--- a/include/asm-ppc/system.h
+++ b/include/asm-ppc/system.h
@@ -178,7 +178,7 @@ static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size
 
 }
 
-extern inline void * xchg_ptr(void * m, void * val)
+static inline void * xchg_ptr(void * m, void * val)
 {
 	return (void *) xchg_u32(m, (unsigned long) val);
 }
diff --git a/include/asm-s390/types.h b/include/asm-s390/types.h
index 78dda03..0e959e2 100644
--- a/include/asm-s390/types.h
+++ b/include/asm-s390/types.h
@@ -10,9 +10,9 @@
 #define _S390_TYPES_H
 
 #ifndef __s390x__
-# include <asm-generic/int-l64.h>
-#else
 # include <asm-generic/int-ll64.h>
+#else
+# include <asm-generic/int-l64.h>
 #endif
 
 #ifndef __ASSEMBLY__
diff --git a/include/asm-sparc/ptrace.h b/include/asm-sparc/ptrace.h
index 6b5e6ce..0afb867 100644
--- a/include/asm-sparc/ptrace.h
+++ b/include/asm-sparc/ptrace.h
@@ -10,6 +10,8 @@
 
 #ifndef __ASSEMBLY__
 
+#include <linux/types.h>
+
 struct pt_regs {
 	unsigned long psr;
 	unsigned long pc;
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 4ab9f32..5395a61 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -2027,7 +2027,7 @@ static inline int fatal_signal_pending(struct task_struct *p)
 
 static inline int need_resched(void)
 {
-	return unlikely(test_tsk_need_resched(current));
+	return unlikely(test_thread_flag(TIF_NEED_RESCHED));
 }
 
 /*
@@ -2038,7 +2038,7 @@ static inline int need_resched(void)
  * cond_resched_softirq() will enable bhs before scheduling.
  */
 extern int _cond_resched(void);
-#ifdef CONFIG_PREEMPT
+#ifdef CONFIG_PREEMPT_BKL
 static inline int cond_resched(void)
 {
 	return 0;
