Return-Path: <linux-wireless-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on dual
X-Spam-Level: 
X-Spam-Status: No, score=0.9 required=5.0 tests=BAYES_00,FREEMAIL_FROM,
	KB_DATE_CONTAINS_TAB autolearn=no version=3.3.1
X-Original-To: maks@dual
Delivered-To: maks@dual
Received: from dual (localhost.localdomain [127.0.0.1])
	by dual (Postfix) with ESMTP id 9C5E5240B2
	for <maks@dual>; Sat, 10 Apr 2010 05:40:32 +0200 (CEST)
X-Original-To: max@stro.at
Delivered-To: max@stro.at
Received: from baikonur.stro.at [213.239.196.228]
	by dual with POP3 (fetchmail-6.3.13)
	for <maks@dual> (single-drop); Sat, 10 Apr 2010 05:40:32 +0200 (CEST)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by baikonur.stro.at (Postfix) with ESMTP id 57CCD5C001
	for <max@stro.at>; Fri,  9 Apr 2010 21:30:10 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755774Ab0DIThv (ORCPT <rfc822;max@stro.at>);
	Fri, 9 Apr 2010 15:37:51 -0400
Received: from mail-fx0-f223.google.com ([209.85.220.223]:53451 "EHLO
	mail-fx0-f223.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755660Ab0DIThu (ORCPT
	<rfc822;linux-wireless@vger.kernel.org>);
	Fri, 9 Apr 2010 15:37:50 -0400
Received: by fxm23 with SMTP id 23so3059091fxm.21
        for <linux-wireless@vger.kernel.org>; Fri, 09 Apr 2010 12:37:48 -0700 (PDT)
DKIM-Signature:	v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=googlemail.com; s=gamma;
        h=domainkey-signature:received:received:received:to:subject:cc:from
         :date:mime-version:content-type:content-transfer-encoding:message-id;
        bh=/1/MkPwABrV9B+UeF6gm0FPvrdPa07zITP+BiYkzzvw=;
        b=auJ2WlRwYLTrqH7PVkjv2hQzjgsBbBZysz1x9gVsGRQoOOZ+wTxIkXHmADOz2Clurf
         qKYgHxxCHnjDu6Xb3kQiYRHAmKFE9O/sRDNyWmVXKU9eLSt47cF16hKkyVPAOs/+g2P7
         usGYv5VXGKFrTCJwhqjvUCrVeW/6sy2mne5qo=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=googlemail.com; s=gamma;
        h=to:subject:cc:from:date:mime-version:content-type
         :content-transfer-encoding:message-id;
        b=jVz41M1Z71WIF8rYp/LErkkyGct/5qylglZrBSMErJB5AC3su/UaeNmI6c+tEXGrmE
         RYWQDDFlrvqDy7qgL+QmxvU0RgOizjnueLLPZlD3X4dR1O7YN+CuIpK1JJ+6Roa+p2QF
         e60ozvjRK1DjNk1aahW0hpaZxRDPGrFVxtxwM=
Received: by 10.223.6.153 with SMTP id 25mr453117faz.81.1270841868071;
        Fri, 09 Apr 2010 12:37:48 -0700 (PDT)
Received: from debian64.daheim (p5B16D5D6.dip.t-dialin.net [91.22.213.214])
        by mx.google.com with ESMTPS id e17sm3562248fke.27.2010.04.09.12.37.42
        (version=TLSv1/SSLv3 cipher=RC4-MD5);
        Fri, 09 Apr 2010 12:37:42 -0700 (PDT)
Received: from debian64.daheim
	([192.168.0.4] helo=debian64.localnet ident=chuck)
	by debian64.daheim with esmtpsa (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
	(Exim 4.71)
	(envelope-from <chunkeey@googlemail.com>)
	id 1O0K1N-0002Xr-Ua; Fri, 09 Apr 2010 21:37:41 +0200
To: linux-wireless@vger.kernel.org
Subject: [PATCH] p54pci: prevent stuck rx-ring on slow system
Cc: linville@tuxdriver.com
From: Christian Lamparter <chunkeey@googlemail.com>
Date:	Fri, 9 Apr 2010 21:37:38 +0200
MIME-Version: 1.0
Content-Type: Text/Plain;
  charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Message-Id: <201004092137.39285.chunkeey@googlemail.com>
Sender: linux-wireless-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-wireless.vger.kernel.org>
X-Mailing-List:	linux-wireless@vger.kernel.org
X-Virus-Scanned: by Amavis (ClamAV) at stro.at
Content-Length: 4420

From: Quintin Pitts <geek4linux@gmail.com>

This patch fixes an old problem, which - under certain
circumstances - could cause the device to become
unresponsive. 

most of p54pci's rx-ring management is implemented in just
two distinct standalone functions. p54p_check_rx_ring takes
care of processing incoming data, while p54p_refill_rx_ring
tries to replenish all depleted communication buffers.

This has always worked fine on my fast machine, but
now I know there is a hidden race...

The most likely candidate here is ring_control->device_idx.
Quintin Pitts had already analyzed the culprit and posted
a patch back in Oct 2009. But sadly, no one's picked up on this.
( https://patchwork.kernel.org/patch/53079/ [2 & 3] ).
This patch does the same way, except that it also prioritize
rx data processing, simply because tx routines *can* wait.

Reported-by: Sean Young <sean@mess.org>
Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=11386
Reported-by: Quintin Pitts <geek4linux@gmail.com>
Signed-off-by: Quintin Pitts <geek4linux@gmail.com>
Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
---
John,

It's been nearly a week and no complains or regressions
have been reported. Therefore I think it is now save to
finally merge this patch... Preferably into -next, so
bug #11386 can be closed for 2.6.34 release.

Regards,
	Chr
---
diff --git a/drivers/net/wireless/p54/p54pci.c b/drivers/net/wireless/p54/p54pci.c
index ed4bdff..aa29663 100644
--- a/drivers/net/wireless/p54/p54pci.c
+++ b/drivers/net/wireless/p54/p54pci.c
@@ -131,7 +131,7 @@ static int p54p_upload_firmware(struct ieee80211_hw *dev)
 
 static void p54p_refill_rx_ring(struct ieee80211_hw *dev,
 	int ring_index, struct p54p_desc *ring, u32 ring_limit,
-	struct sk_buff **rx_buf)
+	struct sk_buff **rx_buf, u32 index)
 {
 	struct p54p_priv *priv = dev->priv;
 	struct p54p_ring_control *ring_control = priv->ring_control;
@@ -139,7 +139,7 @@ static void p54p_refill_rx_ring(struct ieee80211_hw *dev,
 
 	idx = le32_to_cpu(ring_control->host_idx[ring_index]);
 	limit = idx;
-	limit -= le32_to_cpu(ring_control->device_idx[ring_index]);
+	limit -= le32_to_cpu(index);
 	limit = ring_limit - limit;
 
 	i = idx % ring_limit;
@@ -231,7 +231,7 @@ static void p54p_check_rx_ring(struct ieee80211_hw *dev, u32 *index,
 		i %= ring_limit;
 	}
 
-	p54p_refill_rx_ring(dev, ring_index, ring, ring_limit, rx_buf);
+	p54p_refill_rx_ring(dev, ring_index, ring, ring_limit, rx_buf, *index);
 }
 
 static void p54p_check_tx_ring(struct ieee80211_hw *dev, u32 *index,
@@ -276,14 +276,6 @@ static void p54p_tasklet(unsigned long dev_id)
 	struct p54p_priv *priv = dev->priv;
 	struct p54p_ring_control *ring_control = priv->ring_control;
 
-	p54p_check_tx_ring(dev, &priv->tx_idx_mgmt, 3, ring_control->tx_mgmt,
-			   ARRAY_SIZE(ring_control->tx_mgmt),
-			   priv->tx_buf_mgmt);
-
-	p54p_check_tx_ring(dev, &priv->tx_idx_data, 1, ring_control->tx_data,
-			   ARRAY_SIZE(ring_control->tx_data),
-			   priv->tx_buf_data);
-
 	p54p_check_rx_ring(dev, &priv->rx_idx_mgmt, 2, ring_control->rx_mgmt,
 		ARRAY_SIZE(ring_control->rx_mgmt), priv->rx_buf_mgmt);
 
@@ -292,6 +284,14 @@ static void p54p_tasklet(unsigned long dev_id)
 
 	wmb();
 	P54P_WRITE(dev_int, cpu_to_le32(ISL38XX_DEV_INT_UPDATE));
+
+	p54p_check_tx_ring(dev, &priv->tx_idx_mgmt, 3, ring_control->tx_mgmt,
+			   ARRAY_SIZE(ring_control->tx_mgmt),
+			   priv->tx_buf_mgmt);
+
+	p54p_check_tx_ring(dev, &priv->tx_idx_data, 1, ring_control->tx_data,
+			   ARRAY_SIZE(ring_control->tx_data),
+			   priv->tx_buf_data);
 }
 
 static irqreturn_t p54p_interrupt(int irq, void *dev_id)
@@ -444,10 +444,10 @@ static int p54p_open(struct ieee80211_hw *dev)
 	priv->rx_idx_mgmt = priv->tx_idx_mgmt = 0;
 
 	p54p_refill_rx_ring(dev, 0, priv->ring_control->rx_data,
-		ARRAY_SIZE(priv->ring_control->rx_data), priv->rx_buf_data);
+		ARRAY_SIZE(priv->ring_control->rx_data), priv->rx_buf_data, 0);
 
 	p54p_refill_rx_ring(dev, 2, priv->ring_control->rx_mgmt,
-		ARRAY_SIZE(priv->ring_control->rx_mgmt), priv->rx_buf_mgmt);
+		ARRAY_SIZE(priv->ring_control->rx_mgmt), priv->rx_buf_mgmt, 0);
 
 	P54P_WRITE(ring_control_base, cpu_to_le32(priv->ring_control_dma));
 	P54P_READ(ring_control_base);
--
To unsubscribe from this list: send the line "unsubscribe linux-wireless" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

