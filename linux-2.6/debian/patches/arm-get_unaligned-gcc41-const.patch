# Make get_unaligned() work with const pointers and GCC 4.1

# See
# http://lists.arm.linux.org.uk/pipermail/linux-arm-kernel/2006-September/035862.html


From: Lennert Buytenhek <buytenh@wantstofly.org>

On Wed, Sep 06, 2006 at 09:32:58AM +0100, Russell King - ARM Linux wrote:
> >   CC [M]  drivers/net/wireless/zd1211rw/zd_usb.o
> > drivers/net/wireless/zd1211rw/zd_usb.c: In function 'handle_rx_packet':
> > drivers/net/wireless/zd1211rw/zd_usb.c:547: error: assignment of read-only variable '__v'
> > This comes from
> >        if (get_unaligned(&length_info->tag) == cpu_to_le16(RX_LENGTH_INFO_TAG))
> > which gets expanded to arm's __get_unaligned_le().  The code ends up
> > being something like:

The attached patch makes get_unaligned() work with const pointers,
and doesn't seem to noticably affect code generation.

Original code (2.6.18-rc5), format is instructions/registers:

		2.95.3	3.2.3	3.3.3	3.4.2	4.0.2	4.1.0
original, u8	1/1	1/1	1/1	1/1	1/1	1/1
original, u16	3/2	3/3	3/3	3/2	3/2	3/2
original, u32	7/4	8/5	9/5	7/5	7/4	8/5
original, u64	19/8	19/8	21/8	19/7	20/9	22/11


After patch (* denotes change):

		2.95.3	3.2.3	3.3.3	3.4.2	4.0.2	4.1.0
fixed, u8	1/1	1/1	1/1	1/1	1/1	1/1
fixed, u16	3/2	3/3	3/3	3/2	3/2	3/2
fixed, u32	7/4	9/6 *	9/6 *	7/5	7/4	8/5
fixed, u64	19/8	19/8	20/8 *	19/7	20/9	22/11


So, for gcc 3.2.3 in the u32 case we need 1 insn and 1 register more,
on gcc 3.3.3 we need 1 reg more in the u32 case and save one insn in
the u64 case, and all the other compiler versions don't seem to care
at all.


--- a/include/asm-arm/unaligned.h.orig	2006-09-07 00:36:56.937552584 +0200
+++ b/include/asm-arm/unaligned.h	2006-09-07 02:03:40.522487432 +0200
@@ -3,7 +3,7 @@
 
 #include <asm/types.h>
 
-extern int __bug_unaligned_x(void *ptr);
+extern int __bug_unaligned_x(const void *ptr);
 
 /*
  * What is the most efficient way of loading/storing an unaligned value?
@@ -51,47 +51,34 @@
 #define __get_unaligned_4_be(__p)					\
 	(__p[0] << 24 | __p[1] << 16 | __p[2] << 8 | __p[3])
 
-#define __get_unaligned_le(ptr)					\
-	({							\
-		__typeof__(*(ptr)) __v;				\
-		__u8 *__p = (__u8 *)(ptr);			\
-		switch (sizeof(*(ptr))) {			\
-		case 1:	__v = *(ptr);			break;	\
-		case 2: __v = __get_unaligned_2_le(__p);	break;	\
-		case 4: __v = __get_unaligned_4_le(__p);	break;	\
-		case 8: {					\
-				unsigned int __v1, __v2;	\
-				__v2 = __get_unaligned_4_le((__p+4)); \
-				__v1 = __get_unaligned_4_le(__p);	\
-				__v = ((unsigned long long)__v2 << 32 | __v1);	\
-			}					\
-			break;					\
-		default: __v = __bug_unaligned_x(__p);	break;	\
-		}						\
-		__v;						\
+#define __get_unaligned_8_le(__p)					\
+	((unsigned long long)__get_unaligned_4_le((__p+4)) << 32 |	\
+		__get_unaligned_4_le(__p))
+
+#define __get_unaligned_8_be(__p)					\
+	((unsigned long long)__get_unaligned_4_le(__p) << 32 |		\
+		__get_unaligned_4_le((__p+4)))
+
+#define __get_unaligned_le(ptr)						\
+	({								\
+		const __u8 *__p = (const __u8 *)(ptr);			\
+		sizeof(*(ptr)) == 1 ? *__p :				\
+		  sizeof(*(ptr)) == 2 ? __get_unaligned_2_le(__p) :	\
+		  sizeof(*(ptr)) == 4 ? __get_unaligned_4_le(__p) :	\
+		  sizeof(*(ptr)) == 8 ? __get_unaligned_8_le(__p) :	\
+		    __bug_unaligned_x(__p);				\
 	})
 
-#define __get_unaligned_be(ptr)					\
-	({							\
-		__typeof__(*(ptr)) __v;				\
-		__u8 *__p = (__u8 *)(ptr);			\
-		switch (sizeof(*(ptr))) {			\
-		case 1:	__v = *(ptr);			break;	\
-		case 2: __v = __get_unaligned_2_be(__p);	break;	\
-		case 4: __v = __get_unaligned_4_be(__p);	break;	\
-		case 8: {					\
-				unsigned int __v1, __v2;	\
-				__v2 = __get_unaligned_4_be(__p); \
-				__v1 = __get_unaligned_4_be((__p+4));	\
-				__v = ((unsigned long long)__v2 << 32 | __v1);	\
-			}					\
-			break;					\
-		default: __v = __bug_unaligned_x(__p);	break;	\
-		}						\
-		__v;						\
+#define __get_unaligned_be(ptr)						\
+	({								\
+		const __u8 *__p = (const __u8 *)(ptr);			\
+		sizeof(*(ptr)) == 1 ? *__p :				\
+		  sizeof(*(ptr)) == 2 ? __get_unaligned_2_be(__p) :	\
+		  sizeof(*(ptr)) == 4 ? __get_unaligned_4_be(__p) :	\
+		  sizeof(*(ptr)) == 8 ? __get_unaligned_8_be(__p) :	\
+		    __bug_unaligned_x(__p);				\
 	})
 
-
 static inline void __put_unaligned_2_le(__u32 __v, register __u8 *__p)
 {
 	*__p++ = __v;

