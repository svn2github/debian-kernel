From 6f004b2fa4f9b6e5692084f7301271503788c05c Mon Sep 17 00:00:00 2001
From: Sylvain Munaut <tnt@246tNt.com>
Date: Sat, 9 Dec 2006 02:06:55 +0100
Subject: [PATCH] powerpc: Add support for uevent to of_platform

This adds a proper uevent handler to the of_platform bus. This
allows autoloading of modules (or at least should ;).
It's _heavily_ based on the macio counterpart.

Signed-off-by: Sylvain Munaut <tnt@246tNt.com>
---
 arch/powerpc/kernel/of_platform.c |   70 +++++++++++++++++++++++++++++++++++++
 1 files changed, 70 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/of_platform.c b/arch/powerpc/kernel/of_platform.c
index b3189d0..f000023 100644
--- a/arch/powerpc/kernel/of_platform.c
+++ b/arch/powerpc/kernel/of_platform.c
@@ -73,6 +73,75 @@ static int of_platform_bus_match(struct 
 	return of_match_device(matches, of_dev) != NULL;
 }
 
+static int of_platform_uevent(struct device *dev, char **envp, int num_envp,
+                              char *buffer, int buffer_size)
+{
+	struct of_device *of;
+	const char *compat;
+	char *compat2;
+	char compat_buf[128];	/* need to be size of 'compatible' */
+
+	int i = 0;
+	int length = 0, cplen, sl, seen = 0;
+
+	if (!dev)
+		return -ENODEV;
+
+	of = to_of_device(dev);
+	if (!of)
+		return -ENODEV;
+
+	/* stuff we want to pass to /sbin/hotplug */
+	if (add_uevent_var(envp, num_envp, &i,
+			   buffer, buffer_size, &length,
+			   "OF_NAME=%s", of->node->name))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &i,
+			   buffer, buffer_size, &length,
+			   "OF_TYPE=%s", of->node->type))
+		return -ENOMEM;
+
+        /* Since the compatible field can contain pretty much anything
+         * it's not really legal to split it out with commas. We split it
+         * up using a number of environment variables instead. */
+
+	compat = get_property(of->node, "compatible", &cplen);
+	compat2 = compat_buf;
+	if (compat)
+		memcpy(compat2, compat, cplen);
+	while (compat && *compat && cplen > 0) {
+		if (add_uevent_var(envp, num_envp, &i,
+				   buffer, buffer_size, &length,
+				   "OF_COMPATIBLE_%d=%s", seen, compat))
+			return -ENOMEM;
+
+		sl = strlen (compat) + 1;
+		compat += sl;
+		compat2 += sl;
+		cplen -= sl;
+		seen++;
+		compat2[-1] = 'C'; 
+	}
+	compat2[seen?-1:0] = 0;
+
+	if (add_uevent_var(envp, num_envp, &i,
+			   buffer, buffer_size, &length,
+			   "OF_COMPATIBLE_N=%d", seen))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &i,
+			   buffer, buffer_size, &length,
+			   "MODALIAS=of:N%sT%sC%s",
+			   of->node->name, of->node->type,
+			   compat_buf))
+		return -ENOMEM;
+
+	envp[i] = NULL;
+
+	return 0;
+}
+
 static int of_platform_device_probe(struct device *dev)
 {
 	int error = -ENODEV;
@@ -132,6 +201,7 @@ static int of_platform_device_resume(str
 struct bus_type of_platform_bus_type = {
        .name	= "of_platform",
        .match	= of_platform_bus_match,
+       .uevent	= of_platform_uevent,
        .probe	= of_platform_device_probe,
        .remove	= of_platform_device_remove,
        .suspend	= of_platform_device_suspend,
-- 
1.4.2

