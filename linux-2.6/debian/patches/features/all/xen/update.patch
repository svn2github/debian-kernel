diff -r 563a16543a96 arch/i386/Kconfig
--- a/arch/i386/Kconfig	Mon Mar 12 14:07:24 2007 +0100
+++ b/arch/i386/Kconfig	Fri Mar 16 20:29:31 2007 +0100
@@ -200,7 +200,7 @@ config PARAVIRT
 config PARAVIRT
 	bool "Paravirtualization support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
-	depends on !(X86_VISWS || X86_VOYAGER)
+	depends on !(X86_VISWS || X86_VOYAGER || X86_XEN)
 	help
 	  Paravirtualization is a way of running multiple instances of
 	  Linux on the same machine, under a hypervisor.  This option
diff -r 563a16543a96 arch/i386/kernel/microcode-xen.c
--- a/arch/i386/kernel/microcode-xen.c	Mon Mar 12 14:07:24 2007 +0100
+++ b/arch/i386/kernel/microcode-xen.c	Fri Mar 16 20:15:51 2007 +0100
@@ -52,30 +52,32 @@ MODULE_LICENSE("GPL");
 /* no concurrent ->write()s are allowed on /dev/cpu/microcode */
 static DEFINE_MUTEX(microcode_mutex);
 
-static void __user *user_buffer;	/* user area microcode data buffer */
-static unsigned int user_buffer_size;	/* it's size */
-				
 static int microcode_open (struct inode *unused1, struct file *unused2)
 {
 	return capable(CAP_SYS_RAWIO) ? 0 : -EPERM;
 }
 
 
-static int do_microcode_update (void)
+static int do_microcode_update (const void __user *ubuf, size_t len)
 {
 	int err;
-	dom0_op_t op;
+	void *kbuf;
 
-	err = sys_mlock((unsigned long)user_buffer, user_buffer_size);
-	if (err != 0)
-		return err;
+	kbuf = vmalloc(len);
+	if (!kbuf)
+		return -ENOMEM;
 
-	op.cmd = DOM0_MICROCODE;
-	set_xen_guest_handle(op.u.microcode.data, user_buffer);
-	op.u.microcode.length = user_buffer_size;
-	err = HYPERVISOR_dom0_op(&op);
+	if (copy_from_user(kbuf, ubuf, len) == 0) {
+		dom0_op_t op;
 
-	(void)sys_munlock((unsigned long)user_buffer, user_buffer_size);
+		op.cmd = DOM0_MICROCODE;
+		set_xen_guest_handle(op.u.microcode.data, kbuf);
+		op.u.microcode.length = len;
+		err = HYPERVISOR_dom0_op(&op);
+	} else
+		err = -EFAULT;
+
+	vfree(kbuf);
 
 	return err;
 }
@@ -89,17 +91,9 @@ static ssize_t microcode_write (struct f
 		return -EINVAL;
 	}
 
-	if ((len >> PAGE_SHIFT) > num_physpages) {
-		printk(KERN_ERR "microcode: too much data (max %ld pages)\n", num_physpages);
-		return -EINVAL;
-	}
-
 	mutex_lock(&microcode_mutex);
 
-	user_buffer = (void __user *) buf;
-	user_buffer_size = (int) len;
-
-	ret = do_microcode_update();
+	ret = do_microcode_update(buf, len);
 	if (!ret)
 		ret = (ssize_t)len;
 
