From: Henry Ptasinski <henryp@broadcom.com>
Date: Wed, 8 Sep 2010 21:04:42 -0700
Subject: [PATCH] Staging: Add initial release of brcm80211 - Broadcom 802.11n wireless LAN driver.

commit a9533e7ea3c410fed2f4cd8b3e1e213e48529b75 upstream.

Signed-off-by: Henry Ptasinski <henryp@broadcom.com>
Cc: Brett Rudley <brudley@broadcom.com>
Cc: Nohee Ko <noheek@broadcom.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 MAINTAINERS                                        |    8 +
 drivers/staging/Kconfig                            |    2 +
 drivers/staging/Makefile                           |    1 +
 drivers/staging/brcm80211/Kconfig                  |   14 +
 drivers/staging/brcm80211/Makefile                 |   65 +
 drivers/staging/brcm80211/README                   |   94 +
 drivers/staging/brcm80211/TODO                     |   42 +
 drivers/staging/brcm80211/include/aidmp.h          |  374 +
 drivers/staging/brcm80211/include/bcm_rpc.h        |   80 +
 drivers/staging/brcm80211/include/bcm_rpc_tp.h     |  137 +
 drivers/staging/brcm80211/include/bcm_xdr.h        |   60 +
 drivers/staging/brcm80211/include/bcmdefs.h        |  224 +
 drivers/staging/brcm80211/include/bcmdevs.h        |  187 +
 drivers/staging/brcm80211/include/bcmendian.h      |  305 +
 drivers/staging/brcm80211/include/bcmnvram.h       |  173 +
 drivers/staging/brcm80211/include/bcmotp.h         |   44 +
 drivers/staging/brcm80211/include/bcmsdbus.h       |  113 +
 drivers/staging/brcm80211/include/bcmsdh.h         |  198 +
 drivers/staging/brcm80211/include/bcmsdh_sdmmc.h   |  108 +
 drivers/staging/brcm80211/include/bcmsdpcm.h       |  255 +
 drivers/staging/brcm80211/include/bcmsrom.h        |   34 +
 drivers/staging/brcm80211/include/bcmsrom_fmt.h    |  367 +
 drivers/staging/brcm80211/include/bcmsrom_tbl.h    |  583 +
 drivers/staging/brcm80211/include/bcmutils.h       |  606 +
 drivers/staging/brcm80211/include/bcmwifi.h        |  207 +
 drivers/staging/brcm80211/include/bcmwpa.h         |   86 +
 drivers/staging/brcm80211/include/bitfuncs.h       |   86 +
 drivers/staging/brcm80211/include/d11.h            | 1775 ++
 drivers/staging/brcm80211/include/dbus.h           |  355 +
 drivers/staging/brcm80211/include/epivers.h        |   44 +
 drivers/staging/brcm80211/include/hnddma.h         |  243 +
 drivers/staging/brcm80211/include/hndpmu.h         |   71 +
 drivers/staging/brcm80211/include/hndsoc.h         |  199 +
 drivers/staging/brcm80211/include/hndtcam.h        |   48 +
 drivers/staging/brcm80211/include/linux_osl.h      |  370 +
 drivers/staging/brcm80211/include/linuxver.h       |  108 +
 drivers/staging/brcm80211/include/nicpci.h         |   79 +
 drivers/staging/brcm80211/include/osl.h            |   59 +
 .../staging/brcm80211/include/packed_section_end.h |   32 +
 .../brcm80211/include/packed_section_start.h       |   36 +
 drivers/staging/brcm80211/include/pci_core.h       |  122 +
 drivers/staging/brcm80211/include/pcicfg.h         |  524 +
 drivers/staging/brcm80211/include/pcie_core.h      |  299 +
 drivers/staging/brcm80211/include/proto/802.11.h   | 1436 +
 drivers/staging/brcm80211/include/proto/802.11e.h  |  110 +
 drivers/staging/brcm80211/include/proto/802.1d.h   |   37 +
 drivers/staging/brcm80211/include/proto/bcmevent.h |  214 +
 drivers/staging/brcm80211/include/proto/ethernet.h |  113 +
 drivers/staging/brcm80211/include/proto/wpa.h      |  128 +
 drivers/staging/brcm80211/include/qmath.h          |   80 +
 drivers/staging/brcm80211/include/rpc_osl.h        |   33 +
 drivers/staging/brcm80211/include/sbchipc.h        | 1588 ++
 drivers/staging/brcm80211/include/sbconfig.h       |  272 +
 drivers/staging/brcm80211/include/sbhnddma.h       |  315 +
 drivers/staging/brcm80211/include/sbhndpio.h       |   52 +
 drivers/staging/brcm80211/include/sbpcmcia.h       |  217 +
 drivers/staging/brcm80211/include/sbsdio.h         |  152 +
 drivers/staging/brcm80211/include/sbsdpcmdev.h     |  281 +
 drivers/staging/brcm80211/include/sbsocram.h       |  175 +
 drivers/staging/brcm80211/include/sdio.h           |  552 +
 drivers/staging/brcm80211/include/sdioh.h          |   63 +
 drivers/staging/brcm80211/include/sdiovar.h        |   46 +
 drivers/staging/brcm80211/include/siutils.h        |  455 +
 drivers/staging/brcm80211/include/spid.h           |  155 +
 drivers/staging/brcm80211/include/typedefs.h       |  214 +
 drivers/staging/brcm80211/include/wlioctl.h        | 2007 ++
 drivers/staging/brcm80211/phy/phy_version.h        |   36 +
 drivers/staging/brcm80211/phy/wlc_phy_cmn.c        | 3438 +++
 drivers/staging/brcm80211/phy/wlc_phy_hal.h        |  263 +
 drivers/staging/brcm80211/phy/wlc_phy_int.h        | 1229 +
 drivers/staging/brcm80211/phy/wlc_phy_lcn.c        | 5312 ++++
 drivers/staging/brcm80211/phy/wlc_phy_lcn.h        |  121 +
 drivers/staging/brcm80211/phy/wlc_phy_n.c          |29230 ++++++++++++++++++++
 drivers/staging/brcm80211/phy/wlc_phy_radio.h      | 1533 +
 drivers/staging/brcm80211/phy/wlc_phyreg_n.h       |  167 +
 drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c     | 3639 +++
 drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h     |   49 +
 drivers/staging/brcm80211/phy/wlc_phytbl_n.c       |10631 +++++++
 drivers/staging/brcm80211/phy/wlc_phytbl_n.h       |   39 +
 drivers/staging/brcm80211/sys/d11ucode_ext.h       |   35 +
 drivers/staging/brcm80211/sys/wl_dbg.h             |   82 +
 drivers/staging/brcm80211/sys/wl_export.h          |   63 +
 drivers/staging/brcm80211/sys/wl_mac80211.c        | 2547 ++
 drivers/staging/brcm80211/sys/wl_mac80211.h        |  171 +
 drivers/staging/brcm80211/sys/wl_ucode.h           |   38 +
 drivers/staging/brcm80211/sys/wl_ucode_loader.c    |   89 +
 drivers/staging/brcm80211/sys/wlc_alloc.c          |  383 +
 drivers/staging/brcm80211/sys/wlc_alloc.h          |   25 +
 drivers/staging/brcm80211/sys/wlc_ampdu.c          | 1417 +
 drivers/staging/brcm80211/sys/wlc_ampdu.h          |   40 +
 drivers/staging/brcm80211/sys/wlc_antsel.c         |  327 +
 drivers/staging/brcm80211/sys/wlc_antsel.h         |   28 +
 drivers/staging/brcm80211/sys/wlc_bmac.c           | 4178 +++
 drivers/staging/brcm80211/sys/wlc_bmac.h           |  277 +
 drivers/staging/brcm80211/sys/wlc_bsscfg.h         |  152 +
 drivers/staging/brcm80211/sys/wlc_cfg.h            |  310 +
 drivers/staging/brcm80211/sys/wlc_channel.c        | 1598 ++
 drivers/staging/brcm80211/sys/wlc_channel.h        |  159 +
 drivers/staging/brcm80211/sys/wlc_event.c          |  226 +
 drivers/staging/brcm80211/sys/wlc_event.h          |   51 +
 drivers/staging/brcm80211/sys/wlc_key.h            |  143 +
 drivers/staging/brcm80211/sys/wlc_mac80211.c       | 9111 ++++++
 drivers/staging/brcm80211/sys/wlc_mac80211.h       | 1039 +
 drivers/staging/brcm80211/sys/wlc_phy_shim.c       |  251 +
 drivers/staging/brcm80211/sys/wlc_phy_shim.h       |  115 +
 drivers/staging/brcm80211/sys/wlc_pub.h            |  714 +
 drivers/staging/brcm80211/sys/wlc_rate.c           |  498 +
 drivers/staging/brcm80211/sys/wlc_rate.h           |  170 +
 drivers/staging/brcm80211/sys/wlc_rpc.h            |  527 +
 drivers/staging/brcm80211/sys/wlc_rpctx.h          |   71 +
 drivers/staging/brcm80211/sys/wlc_scb.h            |  211 +
 drivers/staging/brcm80211/sys/wlc_stf.c            |  590 +
 drivers/staging/brcm80211/sys/wlc_stf.h            |   42 +
 drivers/staging/brcm80211/sys/wlc_types.h          |   52 +
 drivers/staging/brcm80211/util/aiutils.c           |  795 +
 drivers/staging/brcm80211/util/bcmotp.c            |  954 +
 drivers/staging/brcm80211/util/bcmsrom.c           | 2081 ++
 drivers/staging/brcm80211/util/bcmutils.c          | 1760 ++
 drivers/staging/brcm80211/util/bcmwifi.c           |  318 +
 drivers/staging/brcm80211/util/bcmwpa.c            |   51 +
 drivers/staging/brcm80211/util/hnddma.c            | 2689 ++
 drivers/staging/brcm80211/util/hndpmu.c            | 2681 ++
 drivers/staging/brcm80211/util/linux_osl.c         |  516 +
 drivers/staging/brcm80211/util/nicpci.c            |  880 +
 drivers/staging/brcm80211/util/nvram/nvram_ro.c    |  198 +
 drivers/staging/brcm80211/util/qmath.c             |  680 +
 drivers/staging/brcm80211/util/siutils.c           | 2914 ++
 drivers/staging/brcm80211/util/siutils_priv.h      |   32 +
 128 files changed, 115478 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/brcm80211/Kconfig
 create mode 100644 drivers/staging/brcm80211/Makefile
 create mode 100644 drivers/staging/brcm80211/Module.symvers
 create mode 100644 drivers/staging/brcm80211/README
 create mode 100644 drivers/staging/brcm80211/TODO
 create mode 100644 drivers/staging/brcm80211/include/aidmp.h
 create mode 100644 drivers/staging/brcm80211/include/bcm_rpc.h
 create mode 100644 drivers/staging/brcm80211/include/bcm_rpc_tp.h
 create mode 100644 drivers/staging/brcm80211/include/bcm_xdr.h
 create mode 100644 drivers/staging/brcm80211/include/bcmdefs.h
 create mode 100644 drivers/staging/brcm80211/include/bcmdevs.h
 create mode 100644 drivers/staging/brcm80211/include/bcmendian.h
 create mode 100644 drivers/staging/brcm80211/include/bcmnvram.h
 create mode 100644 drivers/staging/brcm80211/include/bcmotp.h
 create mode 100644 drivers/staging/brcm80211/include/bcmsdbus.h
 create mode 100644 drivers/staging/brcm80211/include/bcmsdh.h
 create mode 100644 drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
 create mode 100644 drivers/staging/brcm80211/include/bcmsdpcm.h
 create mode 100644 drivers/staging/brcm80211/include/bcmsrom.h
 create mode 100644 drivers/staging/brcm80211/include/bcmsrom_fmt.h
 create mode 100644 drivers/staging/brcm80211/include/bcmsrom_tbl.h
 create mode 100644 drivers/staging/brcm80211/include/bcmutils.h
 create mode 100644 drivers/staging/brcm80211/include/bcmwifi.h
 create mode 100644 drivers/staging/brcm80211/include/bcmwpa.h
 create mode 100644 drivers/staging/brcm80211/include/bitfuncs.h
 create mode 100644 drivers/staging/brcm80211/include/d11.h
 create mode 100644 drivers/staging/brcm80211/include/dbus.h
 create mode 100644 drivers/staging/brcm80211/include/epivers.h
 create mode 100644 drivers/staging/brcm80211/include/hnddma.h
 create mode 100644 drivers/staging/brcm80211/include/hndpmu.h
 create mode 100644 drivers/staging/brcm80211/include/hndsoc.h
 create mode 100644 drivers/staging/brcm80211/include/hndtcam.h
 create mode 100644 drivers/staging/brcm80211/include/linux_osl.h
 create mode 100644 drivers/staging/brcm80211/include/linuxver.h
 create mode 100644 drivers/staging/brcm80211/include/nicpci.h
 create mode 100644 drivers/staging/brcm80211/include/osl.h
 create mode 100644 drivers/staging/brcm80211/include/packed_section_end.h
 create mode 100644 drivers/staging/brcm80211/include/packed_section_start.h
 create mode 100644 drivers/staging/brcm80211/include/pci_core.h
 create mode 100644 drivers/staging/brcm80211/include/pcicfg.h
 create mode 100644 drivers/staging/brcm80211/include/pcie_core.h
 create mode 100644 drivers/staging/brcm80211/include/proto/802.11.h
 create mode 100644 drivers/staging/brcm80211/include/proto/802.11e.h
 create mode 100644 drivers/staging/brcm80211/include/proto/802.1d.h
 create mode 100644 drivers/staging/brcm80211/include/proto/bcmevent.h
 create mode 100644 drivers/staging/brcm80211/include/proto/ethernet.h
 create mode 100644 drivers/staging/brcm80211/include/proto/wpa.h
 create mode 100644 drivers/staging/brcm80211/include/qmath.h
 create mode 100644 drivers/staging/brcm80211/include/rpc_osl.h
 create mode 100644 drivers/staging/brcm80211/include/sbchipc.h
 create mode 100644 drivers/staging/brcm80211/include/sbconfig.h
 create mode 100644 drivers/staging/brcm80211/include/sbhnddma.h
 create mode 100644 drivers/staging/brcm80211/include/sbhndpio.h
 create mode 100644 drivers/staging/brcm80211/include/sbpcmcia.h
 create mode 100644 drivers/staging/brcm80211/include/sbsdio.h
 create mode 100644 drivers/staging/brcm80211/include/sbsdpcmdev.h
 create mode 100644 drivers/staging/brcm80211/include/sbsocram.h
 create mode 100644 drivers/staging/brcm80211/include/sdio.h
 create mode 100644 drivers/staging/brcm80211/include/sdioh.h
 create mode 100644 drivers/staging/brcm80211/include/sdiovar.h
 create mode 100644 drivers/staging/brcm80211/include/siutils.h
 create mode 100644 drivers/staging/brcm80211/include/spid.h
 create mode 100644 drivers/staging/brcm80211/include/typedefs.h
 create mode 100644 drivers/staging/brcm80211/include/wlioctl.h
 create mode 100644 drivers/staging/brcm80211/phy/phy_version.h
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phy_cmn.c
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phy_hal.h
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phy_int.h
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phy_lcn.c
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phy_lcn.h
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phy_n.c
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phy_radio.h
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phyreg_n.h
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phytbl_n.c
 create mode 100644 drivers/staging/brcm80211/phy/wlc_phytbl_n.h
 create mode 100644 drivers/staging/brcm80211/sys/d11ucode_ext.h
 create mode 100644 drivers/staging/brcm80211/sys/wl_dbg.h
 create mode 100644 drivers/staging/brcm80211/sys/wl_export.h
 create mode 100644 drivers/staging/brcm80211/sys/wl_mac80211.c
 create mode 100644 drivers/staging/brcm80211/sys/wl_mac80211.h
 create mode 100644 drivers/staging/brcm80211/sys/wl_ucode.h
 create mode 100644 drivers/staging/brcm80211/sys/wl_ucode_loader.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_alloc.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_alloc.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_ampdu.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_ampdu.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_antsel.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_antsel.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_bmac.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_bmac.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_bsscfg.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_cfg.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_channel.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_channel.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_event.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_event.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_key.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_mac80211.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_mac80211.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_phy_shim.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_phy_shim.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_pub.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_rate.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_rate.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_rpc.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_rpctx.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_scb.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_stf.c
 create mode 100644 drivers/staging/brcm80211/sys/wlc_stf.h
 create mode 100644 drivers/staging/brcm80211/sys/wlc_types.h
 create mode 100644 drivers/staging/brcm80211/util/aiutils.c
 create mode 100644 drivers/staging/brcm80211/util/bcmotp.c
 create mode 100644 drivers/staging/brcm80211/util/bcmsrom.c
 create mode 100644 drivers/staging/brcm80211/util/bcmutils.c
 create mode 100644 drivers/staging/brcm80211/util/bcmwifi.c
 create mode 100644 drivers/staging/brcm80211/util/bcmwpa.c
 create mode 100644 drivers/staging/brcm80211/util/hnddma.c
 create mode 100644 drivers/staging/brcm80211/util/hndpmu.c
 create mode 100644 drivers/staging/brcm80211/util/linux_osl.c
 create mode 100644 drivers/staging/brcm80211/util/nicpci.c
 create mode 100644 drivers/staging/brcm80211/util/nvram/nvram_ro.c
 create mode 100644 drivers/staging/brcm80211/util/qmath.c
 create mode 100644 drivers/staging/brcm80211/util/siutils.c
 create mode 100644 drivers/staging/brcm80211/util/siutils_priv.h

diff --git a/MAINTAINERS b/MAINTAINERS
index c36f5d7..a3f9786 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1392,6 +1392,14 @@ L:	netdev@vger.kernel.org
 S:	Supported
 F:	drivers/net/tg3.*
 
+BROADCOM BRCM80211 IEEE802.11n WIRELESS DRIVER
+M:	Brett Rudley <brudley@broadcom.com>
+M:	Henry Ptasinski <henryp@broadcom.com>
+M:	Nohee Ko <noheek@broadcom.com>
+L:	linux-wireless@vger.kernel.org
+S:	Supported
+F:	drivers/staging/brcm80211/
+
 BROCADE BFA FC SCSI DRIVER
 M:	Jing Huang <huangj@brocade.com>
 L:	linux-scsi@vger.kernel.org
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index af9b8e4..e6c3ee6 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -61,6 +61,8 @@ source "drivers/staging/echo/Kconfig"
 
 source "drivers/staging/otus/Kconfig"
 
+source "drivers/staging/brcm80211/Kconfig"
+
 source "drivers/staging/rt2860/Kconfig"
 
 source "drivers/staging/rt2870/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index cad2574..2e82589 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_W35UND)		+= winbond/
 obj-$(CONFIG_PRISM2_USB)	+= wlan-ng/
 obj-$(CONFIG_ECHO)		+= echo/
 obj-$(CONFIG_OTUS)		+= otus/
+obj-$(CONFIG_BRCM80211))	+= brcm80211/
 obj-$(CONFIG_RT2860)		+= rt2860/
 obj-$(CONFIG_RT2870)		+= rt2870/
 obj-$(CONFIG_COMEDI)		+= comedi/
diff --git a/drivers/staging/brcm80211/Kconfig b/drivers/staging/brcm80211/Kconfig
new file mode 100644
index 0000000..6b74685
--- /dev/null
+++ b/drivers/staging/brcm80211/Kconfig
@@ -0,0 +1,14 @@
+menuconfig BRCM80211
+	tristate "Broadcom 802.11 WLAN driver for bcm43xx chips"
+	depends on PCI && WLAN
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	default N
+	help
+	  If built as a module, it will be called brcm80211.ko.
+
+config BRCM80211_PCI
+	bool "Broadcom 802.11 WLAN NIC driver"
+	depends on BRCM80211
+	default y
+
diff --git a/drivers/staging/brcm80211/Makefile b/drivers/staging/brcm80211/Makefile
new file mode 100644
index 0000000..05a4103
--- /dev/null
+++ b/drivers/staging/brcm80211/Makefile
@@ -0,0 +1,65 @@
+#
+# Makefile fragment for Broadcom 802.11n Networking Device Driver
+#
+# Copyright (c) 2010 Broadcom Corporation
+#
+# Permission to use, copy, modify, and/or distribute this software for any
+# purpose with or without fee is hereby granted, provided that the above
+# copyright notice and this permission notice appear in all copies.
+#
+# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+EXTRA_CFLAGS := -DBCMDBG -DWLC_HIGH -DSTA -DWME -DWL11N -DDBAND -DBCMDMA32 -DBCMNVRAMR -Idrivers/staging/brcm80211/sys -Idrivers/staging/brcm80211/phy -Idrivers/staging/brcm80211/util -Idrivers/staging/brcm80211/include -Wall -Wstrict-prototypes -Werror -Wmissing-prototypes
+
+PCI_CFLAGS := -DWLC_LOW
+
+BRCM80211_OFILES := \
+	util/siutils.o \
+	util/aiutils.o \
+	util/bcmotp.o \
+	util/bcmsrom.o \
+	util/bcmutils.o \
+	util/bcmwifi.o \
+	util/bcmwpa.o \
+	util/hndpmu.o \
+	util/linux_osl.o \
+	sys/wlc_alloc.o \
+	sys/wlc_antsel.o \
+	sys/wlc_channel.o \
+	sys/wlc_event.o \
+	sys/wlc_mac80211.o \
+	sys/wlc_rate.o \
+	sys/wlc_stf.o \
+	sys/wl_mac80211.o \
+	sys/wlc_ampdu.o
+
+PCIFILES := \
+	phy/wlc_phy_cmn.o \
+	phy/wlc_phy_lcn.o \
+	phy/wlc_phy_n.o \
+	phy/wlc_phytbl_lcn.o \
+	phy/wlc_phytbl_n.o \
+	sys/wlc_bmac.o \
+	sys/wlc_phy_shim.o \
+	sys/wl_ucode_loader.o \
+	util/hnddma.o \
+	util/nicpci.o \
+	util/nvram/nvram_ro.o \
+	util/qmath.o
+
+MODULEPFX := brcm80211
+
+obj-m	+= $(MODULEPFX).o
+
+# PCI driver
+ifeq ($(CONFIG_BRCM80211_PCI),y)
+EXTRA_CFLAGS += $(PCI_CFLAGS)
+$(MODULEPFX)-objs	= $(BRCM80211_OFILES) $(PCIFILES)
+endif
+
diff --git a/drivers/staging/brcm80211/Module.symvers b/drivers/staging/brcm80211/Module.symvers
new file mode 100644
index 0000000..e69de29
diff --git a/drivers/staging/brcm80211/README b/drivers/staging/brcm80211/README
new file mode 100644
index 0000000..97fa01c
--- /dev/null
+++ b/drivers/staging/brcm80211/README
@@ -0,0 +1,94 @@
+Broadcom Mac80211 driver
+
+This is a driver in progress.  It has features still to be implemented well as
+bugs in current code.
+
+
+What's here and not here
+=======================
+- Completely open source host driver, no binary object files
+- Features Broadcom's OneDriver architecture (single source base for
+  supported chips and architectures)
+- On-chip firmware loaded using standard request_firmware()
+- Support for BCM43224, BCM43225, BCM4313 (PCIe NIC)
+- Framework for supporting new chips, including mac80211-aware embedded chips
+- Does not support older PCI/PCIe chips with SSB backplane
+- Driver includes BMAC interface for transparent dongle support
+- Uses minstrel_ht rate algorithm
+- HW based encryption not enabled yet
+
+
+What's done
+==========
+- Integration with mac80211 stack
+- A-MPDU single & dual stream rates
+- BCM43224:	Dualband, Dual stream, 20MHz channels
+	Throughput (in chamber): ~85-90 Mbits/sec (in both 2.4 & 5 GHz bands)
+- BCM43225:	2.4 GHz, Dual Stream, 20MHz channels
+	Throughput (in chamber): ~85-90 Mbits/sec
+- BCM4313:		2.4 GHz, Single Stream
+	Throughput (in chamber): ~40 Mbits/sec
+
+
+Things To Be Done
+=================
+See the TODO file
+
+
+Firmware installation
+======================
+Firmware is available from the Linux firmware repository at:
+
+	git://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
+	http://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
+	https://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
+
+For all chips, copy brcm/bcm43xx-0-610-809-0.fw and
+brcm/bcm43xx_hdr-0-610-809-0.fw to /lib/firmware/brcm (or wherever firmware is
+normally installed on the system).  In the /lib/firmware/brcm directory, then
+create the following symlinks:
+
+	ln -s bcm43xx-0-610-809-0.fw bcm43xx-0.fw
+	ln -s bcm43xx_hdr-0-610-809-0.fw bcm43xx_hdr-0.fw
+
+
+Currently supported chips
+==============
+PCI
+Name		Device ID
+BCM4313		0x4727
+BCM43224	0x4353
+BCM43225	0x4357
+
+
+Bugs/Problems
+==============
+- Driver can get confused while scanning during high throughput, can cause
+  burping, hanging, and possible crashing.
+- Occasional hangs & burps with BCM43224 on 2.4 GHz with dual stream rates.
+- Occasional crashes with BCM43224 on multicore machines.
+
+
+Note on Regulatory Implementation
+================================
+This generation of chips contain additional regulatory support independent of
+the driver. The devices use a single worldwide regulatory domain, with channels
+12-14 (2.4 GHz band) and channels 52-64 and 100-140 (5 GHz band) restricted to
+passive operation. Transmission on those channels is suppressed until
+appropriate other traffic is observed on those channels.
+
+Within the driver, we use the ficticious country code "X2" to represent this
+worldwide regulatory domain. There is currently no interface to configure a
+different domain.
+
+The driver reads the SROM country code from the chip and hands it up to
+mac80211 as the regulatory hint, however this information is otherwise unused
+with the driver.
+
+
+Contact Info:
+=============
+Brett Rudley	brudley@broadcom.com
+Henry Ptasinski henryp@broadcom.com
+Nohee Ko	noheek@broadcom.com
+
diff --git a/drivers/staging/brcm80211/TODO b/drivers/staging/brcm80211/TODO
new file mode 100644
index 0000000..aa38d49
--- /dev/null
+++ b/drivers/staging/brcm80211/TODO
@@ -0,0 +1,42 @@
+To Do List for Broadcom Mac80211 driver
+
+Features to be added
+=====================
+- 40 MHz channels
+- Power Save
+- AP
+- IBSS
+- HW-based encryption
+- LED support
+- RFKILL
+- Debugfs and debugability
+
+Code cleanup
+============
+- Use proper kernel coding standards
+- Remove overlap with system header files. (ie much of include/proto/*.h should
+  be removed)
+- Purge unused variables/data structs/functions BUT keep code related to
+  features that are being added (ie AP mode, 40 Mhz channels, IBSS etc).
+- Replace proprietary utility functions with public kernel versions.
+
+Bugs
+====
+- Various occasional asserts/hangs
+- Scanning during data transfer sometimes causes major slowdowns.  Sometimes
+  revcovers when scan is done, other times not.
+- Driver does not handle missing firmware gracefully.
+- Mac80211 API not completely implemented (ie ops_bss_info_changed,
+  ops_get_stats, etc)
+
+Other
+=====
+- wlc_mac80211.[ch], wl_mac80211.[ch] and linux_osl.c all need to be refactored
+    and combined.
+- Replace driver's proprietary ssb interface with generic kernel ssb module
+  (only used when compiling for SDIO).
+- PCI and SDIO support are currently #ifdef'ed exclusive of each other, which
+  leads to a separate wl.ko for each.  This should be changed to runtime
+  handling of different interfaces so that a single binary driver can be built.
+- Add support for new chips (obviously an ongoing item).
+
diff --git a/drivers/staging/brcm80211/include/aidmp.h b/drivers/staging/brcm80211/include/aidmp.h
new file mode 100644
index 0000000..e64dd03
--- /dev/null
+++ b/drivers/staging/brcm80211/include/aidmp.h
@@ -0,0 +1,374 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_AIDMP_H
+#define	_AIDMP_H
+
+/* Manufacturer Ids */
+#define	MFGID_ARM		0x43b
+#define	MFGID_BRCM		0x4bf
+#define	MFGID_MIPS		0x4a7
+
+/* Component Classes */
+#define	CC_SIM			0
+#define	CC_EROM			1
+#define	CC_CORESIGHT		9
+#define	CC_VERIF		0xb
+#define	CC_OPTIMO		0xd
+#define	CC_GEN			0xe
+#define	CC_PRIMECELL		0xf
+
+/* Enumeration ROM registers */
+#define	ER_EROMENTRY		0x000
+#define	ER_REMAPCONTROL		0xe00
+#define	ER_REMAPSELECT		0xe04
+#define	ER_MASTERSELECT		0xe10
+#define	ER_ITCR			0xf00
+#define	ER_ITIP			0xf04
+
+/* Erom entries */
+#define	ER_TAG			0xe
+#define	ER_TAG1			0x6
+#define	ER_VALID		1
+#define	ER_CI			0
+#define	ER_MP			2
+#define	ER_ADD			4
+#define	ER_END			0xe
+#define	ER_BAD			0xffffffff
+
+/* EROM CompIdentA */
+#define	CIA_MFG_MASK		0xfff00000
+#define	CIA_MFG_SHIFT		20
+#define	CIA_CID_MASK		0x000fff00
+#define	CIA_CID_SHIFT		8
+#define	CIA_CCL_MASK		0x000000f0
+#define	CIA_CCL_SHIFT		4
+
+/* EROM CompIdentB */
+#define	CIB_REV_MASK		0xff000000
+#define	CIB_REV_SHIFT		24
+#define	CIB_NSW_MASK		0x00f80000
+#define	CIB_NSW_SHIFT		19
+#define	CIB_NMW_MASK		0x0007c000
+#define	CIB_NMW_SHIFT		14
+#define	CIB_NSP_MASK		0x00003e00
+#define	CIB_NSP_SHIFT		9
+#define	CIB_NMP_MASK		0x000001f0
+#define	CIB_NMP_SHIFT		4
+
+/* EROM MasterPortDesc */
+#define	MPD_MUI_MASK		0x0000ff00
+#define	MPD_MUI_SHIFT		8
+#define	MPD_MP_MASK		0x000000f0
+#define	MPD_MP_SHIFT		4
+
+/* EROM AddrDesc */
+#define	AD_ADDR_MASK		0xfffff000
+#define	AD_SP_MASK		0x00000f00
+#define	AD_SP_SHIFT		8
+#define	AD_ST_MASK		0x000000c0
+#define	AD_ST_SHIFT		6
+#define	AD_ST_SLAVE		0x00000000
+#define	AD_ST_BRIDGE		0x00000040
+#define	AD_ST_SWRAP		0x00000080
+#define	AD_ST_MWRAP		0x000000c0
+#define	AD_SZ_MASK		0x00000030
+#define	AD_SZ_SHIFT		4
+#define	AD_SZ_4K		0x00000000
+#define	AD_SZ_8K		0x00000010
+#define	AD_SZ_16K		0x00000020
+#define	AD_SZ_SZD		0x00000030
+#define	AD_AG32			0x00000008
+#define	AD_ADDR_ALIGN		0x00000fff
+#define	AD_SZ_BASE		0x00001000	/* 4KB */
+
+/* EROM SizeDesc */
+#define	SD_SZ_MASK		0xfffff000
+#define	SD_SG32			0x00000008
+#define	SD_SZ_ALIGN		0x00000fff
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+typedef volatile struct _aidmp {
+	uint32 oobselina30;	/* 0x000 */
+	uint32 oobselina74;	/* 0x004 */
+	uint32 PAD[6];
+	uint32 oobselinb30;	/* 0x020 */
+	uint32 oobselinb74;	/* 0x024 */
+	uint32 PAD[6];
+	uint32 oobselinc30;	/* 0x040 */
+	uint32 oobselinc74;	/* 0x044 */
+	uint32 PAD[6];
+	uint32 oobselind30;	/* 0x060 */
+	uint32 oobselind74;	/* 0x064 */
+	uint32 PAD[38];
+	uint32 oobselouta30;	/* 0x100 */
+	uint32 oobselouta74;	/* 0x104 */
+	uint32 PAD[6];
+	uint32 oobseloutb30;	/* 0x120 */
+	uint32 oobseloutb74;	/* 0x124 */
+	uint32 PAD[6];
+	uint32 oobseloutc30;	/* 0x140 */
+	uint32 oobseloutc74;	/* 0x144 */
+	uint32 PAD[6];
+	uint32 oobseloutd30;	/* 0x160 */
+	uint32 oobseloutd74;	/* 0x164 */
+	uint32 PAD[38];
+	uint32 oobsynca;	/* 0x200 */
+	uint32 oobseloutaen;	/* 0x204 */
+	uint32 PAD[6];
+	uint32 oobsyncb;	/* 0x220 */
+	uint32 oobseloutben;	/* 0x224 */
+	uint32 PAD[6];
+	uint32 oobsyncc;	/* 0x240 */
+	uint32 oobseloutcen;	/* 0x244 */
+	uint32 PAD[6];
+	uint32 oobsyncd;	/* 0x260 */
+	uint32 oobseloutden;	/* 0x264 */
+	uint32 PAD[38];
+	uint32 oobaextwidth;	/* 0x300 */
+	uint32 oobainwidth;	/* 0x304 */
+	uint32 oobaoutwidth;	/* 0x308 */
+	uint32 PAD[5];
+	uint32 oobbextwidth;	/* 0x320 */
+	uint32 oobbinwidth;	/* 0x324 */
+	uint32 oobboutwidth;	/* 0x328 */
+	uint32 PAD[5];
+	uint32 oobcextwidth;	/* 0x340 */
+	uint32 oobcinwidth;	/* 0x344 */
+	uint32 oobcoutwidth;	/* 0x348 */
+	uint32 PAD[5];
+	uint32 oobdextwidth;	/* 0x360 */
+	uint32 oobdinwidth;	/* 0x364 */
+	uint32 oobdoutwidth;	/* 0x368 */
+	uint32 PAD[37];
+	uint32 ioctrlset;	/* 0x400 */
+	uint32 ioctrlclear;	/* 0x404 */
+	uint32 ioctrl;		/* 0x408 */
+	uint32 PAD[61];
+	uint32 iostatus;	/* 0x500 */
+	uint32 PAD[127];
+	uint32 ioctrlwidth;	/* 0x700 */
+	uint32 iostatuswidth;	/* 0x704 */
+	uint32 PAD[62];
+	uint32 resetctrl;	/* 0x800 */
+	uint32 resetstatus;	/* 0x804 */
+	uint32 resetreadid;	/* 0x808 */
+	uint32 resetwriteid;	/* 0x80c */
+	uint32 PAD[60];
+	uint32 errlogctrl;	/* 0x900 */
+	uint32 errlogdone;	/* 0x904 */
+	uint32 errlogstatus;	/* 0x908 */
+	uint32 errlogaddrlo;	/* 0x90c */
+	uint32 errlogaddrhi;	/* 0x910 */
+	uint32 errlogid;	/* 0x914 */
+	uint32 errloguser;	/* 0x918 */
+	uint32 errlogflags;	/* 0x91c */
+	uint32 PAD[56];
+	uint32 intstatus;	/* 0xa00 */
+	uint32 PAD[127];
+	uint32 config;		/* 0xe00 */
+	uint32 PAD[63];
+	uint32 itcr;		/* 0xf00 */
+	uint32 PAD[3];
+	uint32 itipooba;	/* 0xf10 */
+	uint32 itipoobb;	/* 0xf14 */
+	uint32 itipoobc;	/* 0xf18 */
+	uint32 itipoobd;	/* 0xf1c */
+	uint32 PAD[4];
+	uint32 itipoobaout;	/* 0xf30 */
+	uint32 itipoobbout;	/* 0xf34 */
+	uint32 itipoobcout;	/* 0xf38 */
+	uint32 itipoobdout;	/* 0xf3c */
+	uint32 PAD[4];
+	uint32 itopooba;	/* 0xf50 */
+	uint32 itopoobb;	/* 0xf54 */
+	uint32 itopoobc;	/* 0xf58 */
+	uint32 itopoobd;	/* 0xf5c */
+	uint32 PAD[4];
+	uint32 itopoobain;	/* 0xf70 */
+	uint32 itopoobbin;	/* 0xf74 */
+	uint32 itopoobcin;	/* 0xf78 */
+	uint32 itopoobdin;	/* 0xf7c */
+	uint32 PAD[4];
+	uint32 itopreset;	/* 0xf90 */
+	uint32 PAD[15];
+	uint32 peripherialid4;	/* 0xfd0 */
+	uint32 peripherialid5;	/* 0xfd4 */
+	uint32 peripherialid6;	/* 0xfd8 */
+	uint32 peripherialid7;	/* 0xfdc */
+	uint32 peripherialid0;	/* 0xfe0 */
+	uint32 peripherialid1;	/* 0xfe4 */
+	uint32 peripherialid2;	/* 0xfe8 */
+	uint32 peripherialid3;	/* 0xfec */
+	uint32 componentid0;	/* 0xff0 */
+	uint32 componentid1;	/* 0xff4 */
+	uint32 componentid2;	/* 0xff8 */
+	uint32 componentid3;	/* 0xffc */
+} aidmp_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* Out-of-band Router registers */
+#define	OOB_BUSCONFIG		0x020
+#define	OOB_STATUSA		0x100
+#define	OOB_STATUSB		0x104
+#define	OOB_STATUSC		0x108
+#define	OOB_STATUSD		0x10c
+#define	OOB_ENABLEA0		0x200
+#define	OOB_ENABLEA1		0x204
+#define	OOB_ENABLEA2		0x208
+#define	OOB_ENABLEA3		0x20c
+#define	OOB_ENABLEB0		0x280
+#define	OOB_ENABLEB1		0x284
+#define	OOB_ENABLEB2		0x288
+#define	OOB_ENABLEB3		0x28c
+#define	OOB_ENABLEC0		0x300
+#define	OOB_ENABLEC1		0x304
+#define	OOB_ENABLEC2		0x308
+#define	OOB_ENABLEC3		0x30c
+#define	OOB_ENABLED0		0x380
+#define	OOB_ENABLED1		0x384
+#define	OOB_ENABLED2		0x388
+#define	OOB_ENABLED3		0x38c
+#define	OOB_ITCR		0xf00
+#define	OOB_ITIPOOBA		0xf10
+#define	OOB_ITIPOOBB		0xf14
+#define	OOB_ITIPOOBC		0xf18
+#define	OOB_ITIPOOBD		0xf1c
+#define	OOB_ITOPOOBA		0xf30
+#define	OOB_ITOPOOBB		0xf34
+#define	OOB_ITOPOOBC		0xf38
+#define	OOB_ITOPOOBD		0xf3c
+
+/* DMP wrapper registers */
+#define	AI_OOBSELINA30		0x000
+#define	AI_OOBSELINA74		0x004
+#define	AI_OOBSELINB30		0x020
+#define	AI_OOBSELINB74		0x024
+#define	AI_OOBSELINC30		0x040
+#define	AI_OOBSELINC74		0x044
+#define	AI_OOBSELIND30		0x060
+#define	AI_OOBSELIND74		0x064
+#define	AI_OOBSELOUTA30		0x100
+#define	AI_OOBSELOUTA74		0x104
+#define	AI_OOBSELOUTB30		0x120
+#define	AI_OOBSELOUTB74		0x124
+#define	AI_OOBSELOUTC30		0x140
+#define	AI_OOBSELOUTC74		0x144
+#define	AI_OOBSELOUTD30		0x160
+#define	AI_OOBSELOUTD74		0x164
+#define	AI_OOBSYNCA		0x200
+#define	AI_OOBSELOUTAEN		0x204
+#define	AI_OOBSYNCB		0x220
+#define	AI_OOBSELOUTBEN		0x224
+#define	AI_OOBSYNCC		0x240
+#define	AI_OOBSELOUTCEN		0x244
+#define	AI_OOBSYNCD		0x260
+#define	AI_OOBSELOUTDEN		0x264
+#define	AI_OOBAEXTWIDTH		0x300
+#define	AI_OOBAINWIDTH		0x304
+#define	AI_OOBAOUTWIDTH		0x308
+#define	AI_OOBBEXTWIDTH		0x320
+#define	AI_OOBBINWIDTH		0x324
+#define	AI_OOBBOUTWIDTH		0x328
+#define	AI_OOBCEXTWIDTH		0x340
+#define	AI_OOBCINWIDTH		0x344
+#define	AI_OOBCOUTWIDTH		0x348
+#define	AI_OOBDEXTWIDTH		0x360
+#define	AI_OOBDINWIDTH		0x364
+#define	AI_OOBDOUTWIDTH		0x368
+
+#if	defined(IL_BIGENDIAN) && defined(BCMHND74K)
+/* Selective swapped defines for those registers we need in
+ * big-endian code.
+ */
+#define	AI_IOCTRLSET		0x404
+#define	AI_IOCTRLCLEAR		0x400
+#define	AI_IOCTRL		0x40c
+#define	AI_IOSTATUS		0x504
+#define	AI_RESETCTRL		0x804
+#define	AI_RESETSTATUS		0x800
+
+#else				/* !IL_BIGENDIAN || !BCMHND74K */
+
+#define	AI_IOCTRLSET		0x400
+#define	AI_IOCTRLCLEAR		0x404
+#define	AI_IOCTRL		0x408
+#define	AI_IOSTATUS		0x500
+#define	AI_RESETCTRL		0x800
+#define	AI_RESETSTATUS		0x804
+
+#endif				/* IL_BIGENDIAN && BCMHND74K */
+
+#define	AI_IOCTRLWIDTH		0x700
+#define	AI_IOSTATUSWIDTH	0x704
+
+#define	AI_RESETREADID		0x808
+#define	AI_RESETWRITEID		0x80c
+#define	AI_ERRLOGCTRL		0xa00
+#define	AI_ERRLOGDONE		0xa04
+#define	AI_ERRLOGSTATUS		0xa08
+#define	AI_ERRLOGADDRLO		0xa0c
+#define	AI_ERRLOGADDRHI		0xa10
+#define	AI_ERRLOGID		0xa14
+#define	AI_ERRLOGUSER		0xa18
+#define	AI_ERRLOGFLAGS		0xa1c
+#define	AI_INTSTATUS		0xa00
+#define	AI_CONFIG		0xe00
+#define	AI_ITCR			0xf00
+#define	AI_ITIPOOBA		0xf10
+#define	AI_ITIPOOBB		0xf14
+#define	AI_ITIPOOBC		0xf18
+#define	AI_ITIPOOBD		0xf1c
+#define	AI_ITIPOOBAOUT		0xf30
+#define	AI_ITIPOOBBOUT		0xf34
+#define	AI_ITIPOOBCOUT		0xf38
+#define	AI_ITIPOOBDOUT		0xf3c
+#define	AI_ITOPOOBA		0xf50
+#define	AI_ITOPOOBB		0xf54
+#define	AI_ITOPOOBC		0xf58
+#define	AI_ITOPOOBD		0xf5c
+#define	AI_ITOPOOBAIN		0xf70
+#define	AI_ITOPOOBBIN		0xf74
+#define	AI_ITOPOOBCIN		0xf78
+#define	AI_ITOPOOBDIN		0xf7c
+#define	AI_ITOPRESET		0xf90
+#define	AI_PERIPHERIALID4	0xfd0
+#define	AI_PERIPHERIALID5	0xfd4
+#define	AI_PERIPHERIALID6	0xfd8
+#define	AI_PERIPHERIALID7	0xfdc
+#define	AI_PERIPHERIALID0	0xfe0
+#define	AI_PERIPHERIALID1	0xfe4
+#define	AI_PERIPHERIALID2	0xfe8
+#define	AI_PERIPHERIALID3	0xfec
+#define	AI_COMPONENTID0		0xff0
+#define	AI_COMPONENTID1		0xff4
+#define	AI_COMPONENTID2		0xff8
+#define	AI_COMPONENTID3		0xffc
+
+/* resetctrl */
+#define	AIRC_RESET		1
+
+/* config */
+#define	AICFG_OOB		0x00000020
+#define	AICFG_IOS		0x00000010
+#define	AICFG_IOC		0x00000008
+#define	AICFG_TO		0x00000004
+#define	AICFG_ERRL		0x00000002
+#define	AICFG_RST		0x00000001
+
+#endif				/* _AIDMP_H */
diff --git a/drivers/staging/brcm80211/include/bcm_rpc.h b/drivers/staging/brcm80211/include/bcm_rpc.h
new file mode 100644
index 0000000..33408fd
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcm_rpc.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BCM_RPC_H_
+#define _BCM_RPC_H_
+
+#include <typedefs.h>
+#include <rpc_osl.h>
+
+typedef struct rpc_info rpc_info_t;
+typedef struct rpc_buf rpc_buf_t;
+struct rpc_transport_info;
+typedef void (*rpc_dispatch_cb_t) (void *ctx, struct rpc_buf * buf);
+typedef void (*rpc_resync_cb_t) (void *ctx);
+typedef void (*rpc_down_cb_t) (void *ctx);
+typedef void (*rpc_txdone_cb_t) (void *ctx, struct rpc_buf * buf);
+extern struct rpc_info *bcm_rpc_attach(void *pdev, osl_t * osh,
+				       struct rpc_transport_info *rpc_th);
+
+extern void bcm_rpc_detach(struct rpc_info *rpc);
+extern void bcm_rpc_down(struct rpc_info *rpc);
+extern void bcm_rpc_watchdog(struct rpc_info *rpc);
+
+extern struct rpc_buf *bcm_rpc_buf_alloc(struct rpc_info *rpc, int len);
+extern void bcm_rpc_buf_free(struct rpc_info *rpc, struct rpc_buf *b);
+/* get rpc transport handle */
+extern struct rpc_transport_info *bcm_rpc_tp_get(struct rpc_info *rpc);
+
+/* callback for: data_rx, down, resync */
+extern void bcm_rpc_rxcb_init(struct rpc_info *rpc, void *ctx,
+			      rpc_dispatch_cb_t cb, void *dnctx,
+			      rpc_down_cb_t dncb, rpc_resync_cb_t resync_cb,
+			      rpc_txdone_cb_t);
+extern void bcm_rpc_rxcb_deinit(struct rpc_info *rpci);
+
+/* HOST or CLIENT rpc call, requiring no return value */
+extern int bcm_rpc_call(struct rpc_info *rpc, struct rpc_buf *b);
+
+/* HOST rpc call, demanding return.
+ *   The thread may be suspended and control returns back to OS
+ *   The thread will resume(waked up) on either the return signal received or timeout
+ *     The implementation details depend on OS
+ */
+extern struct rpc_buf *bcm_rpc_call_with_return(struct rpc_info *rpc,
+						struct rpc_buf *b);
+
+/* CLIENT rpc call to respond to bcm_rpc_call_with_return, requiring no return value */
+extern int bcm_rpc_call_return(struct rpc_info *rpc, struct rpc_buf *retb);
+
+extern uint bcm_rpc_buf_header_len(struct rpc_info *rpci);
+
+#define RPC_PKTLOG_SIZE		50	/* Depth of the history */
+#define RPC_PKTLOG_RD_LEN	3
+#define RPC_PKTLOG_DUMP_SIZE	150	/* dump size should be more than the product of above two */
+extern int bcm_rpc_pktlog_get(struct rpc_info *rpci, uint32 * buf,
+			      uint buf_size, bool send);
+extern int bcm_rpc_dump(rpc_info_t * rpci, struct bcmstrbuf *b);
+
+/* HIGH/BMAC: bit 15-8: RPC module, bit 7-0: TP module */
+#define RPC_ERROR_VAL	0x0001
+#define RPC_TRACE_VAL	0x0002
+#define RPC_PKTTRACE_VAL 0x0004
+#define RPC_PKTLOG_VAL	0x0008
+extern void bcm_rpc_msglevel_set(struct rpc_info *rpci, uint16 msglevel,
+				 bool high_low);
+
+#endif				/* _BCM_RPC_H_ */
diff --git a/drivers/staging/brcm80211/include/bcm_rpc_tp.h b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
new file mode 100644
index 0000000..d52701c
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcm_rpc_tp.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _bcm_rpc_tp_h_
+#define _bcm_rpc_tp_h_
+#include <bcm_rpc.h>
+
+#define DBUS_RX_BUFFER_SIZE_RPC	(2100)	/* rxbufsize for dbus_attach, linux only for now */
+
+#define BCM_RPC_TP_ENCAP_LEN	4	/* TP header is 4 bytes */
+
+#define BCM_RPC_TP_HOST_AGG_MASK	0xffff0000
+#define BCM_RPC_TP_HOST_AGG_SHIFT	16
+#define BCM_RPC_TP_HOST_AGG_AMPDU	0x00010000	/* HOST->DNGL ampdu aggregation */
+#define BCM_RPC_TP_HOST_AGG_TEST	0x00100000	/* HOST->DNGL test aggregation */
+#define BCM_RPC_TP_DNGL_AGG_MASK	0x0000ffff
+#define BCM_RPC_TP_DNGL_AGG_DPC		0x00000001	/* DNGL->HOST data aggregation */
+#define BCM_RPC_TP_DNGL_AGG_FLOWCTL	0x00000002	/* DNGL->HOST tx flowcontrol agg */
+#define BCM_RPC_TP_DNGL_AGG_TEST	0x00000010	/* DNGL->HOST test agg */
+
+#define BCM_RPC_TP_DNGL_AGG_MAX_SFRAME	3	/* max agg subframes, must be <= USB_NTXD */
+#define BCM_RPC_TP_DNGL_AGG_MAX_BYTE	4000	/* max agg bytes */
+
+#define BCM_RPC_TP_HOST_AGG_MAX_SFRAME  3	/* max agg subframes, AMPDU only, 3 is enough */
+#define BCM_RPC_TP_HOST_AGG_MAX_BYTE    3400	/* max agg bytes; to fit 2+ tcp/udp pkts. Each one:
+						 * 802.3pkt + 802.11 hdr + rpc hdr + tp hdr < 1700B
+						 * Need to be in sync with dongle usb rx dma
+						 *  rxbufsize(USBBULK_RXBUF_GIANT in usbdev_sb.c)
+						 */
+/* TP-DBUS pkts flowcontrol */
+#define BCM_RPC_TP_DBUS_NTXQ	50	/* queue size for TX on bulk OUT, aggregation possible */
+#define BCM_RPC_TP_DBUS_NRXQ	50	/* queue size for RX on bulk IN, aggregation possible */
+#define BCM_RPC_TP_DBUS_NRXQ_CTRL	1	/* queue size for RX on ctl EP0 */
+
+#define BCM_RPC_TP_DBUS_NRXQ_PKT	(BCM_RPC_TP_DBUS_NRXQ * BCM_RPC_TP_DNGL_AGG_MAX_SFRAME)
+#define BCM_RPC_TP_DBUS_NTXQ_PKT	(BCM_RPC_TP_DBUS_NTXQ * BCM_RPC_TP_HOST_AGG_MAX_SFRAME)
+
+typedef struct rpc_transport_info rpc_tp_info_t;
+
+typedef void (*rpc_tx_complete_fn_t) (void *, rpc_buf_t *, int status);
+typedef void (*rpc_rx_fn_t) (void *, rpc_buf_t *);
+
+#ifdef WLC_LOW
+typedef void (*rpc_txflowctl_cb_t) (void *ctx, bool on);
+#endif
+
+extern rpc_tp_info_t *bcm_rpc_tp_attach(osl_t * osh, void *bus);
+extern void bcm_rpc_tp_detach(rpc_tp_info_t * rpcb);
+extern void bcm_rpc_tp_down(rpc_tp_info_t * rpcb);
+extern void bcm_rpc_tp_watchdog(rpc_tp_info_t * rpcb);
+
+extern int bcm_rpc_tp_buf_send(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
+
+/* callback for tx_complete, rx_pkt */
+extern void bcm_rpc_tp_register_cb(rpc_tp_info_t * rpcb,
+				   rpc_tx_complete_fn_t txcmplt,
+				   void *tx_context, rpc_rx_fn_t rxpkt,
+				   void *rx_context, rpc_osl_t * rpc_osh);
+extern void bcm_rpc_tp_deregister_cb(rpc_tp_info_t * rpcb);
+
+/* Buffer manipulation */
+extern uint bcm_rpc_buf_tp_header_len(rpc_tp_info_t * rpcb);
+extern rpc_buf_t *bcm_rpc_tp_buf_alloc(rpc_tp_info_t * rpcb, int len);
+extern void bcm_rpc_tp_buf_free(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
+extern int bcm_rpc_buf_len_get(rpc_tp_info_t * rpcb, rpc_buf_t * b);
+extern int bcm_rpc_buf_len_set(rpc_tp_info_t * rpcb, rpc_buf_t * b, uint len);
+extern rpc_buf_t *bcm_rpc_buf_next_get(rpc_tp_info_t * rpcb, rpc_buf_t * b);
+extern void bcm_rpc_buf_next_set(rpc_tp_info_t * rpcb, rpc_buf_t * b,
+				 rpc_buf_t * nextb);
+extern unsigned char *bcm_rpc_buf_data(rpc_tp_info_t * rpcb, rpc_buf_t * b);
+extern unsigned char *bcm_rpc_buf_push(rpc_tp_info_t * rpcb, rpc_buf_t * b,
+				       uint delta);
+extern unsigned char *bcm_rpc_buf_pull(rpc_tp_info_t * rpcb, rpc_buf_t * b,
+				       uint delta);
+extern void bcm_rpc_tp_buf_release(rpc_tp_info_t * rpcb, rpc_buf_t * buf);
+extern void bcm_rpc_tp_buf_cnt_adjust(rpc_tp_info_t * rpcb, int adjust);
+/* RPC call_with_return */
+extern int bcm_rpc_tp_recv_rtn(rpc_tp_info_t * rpcb);
+extern int bcm_rpc_tp_get_device_speed(rpc_tp_info_t * rpc_th);
+#ifdef BCMDBG
+extern int bcm_rpc_tp_dump(rpc_tp_info_t * rpcb, struct bcmstrbuf *b);
+#endif
+
+#ifdef WLC_LOW
+/* intercept USB pkt to parse RPC header: USB driver rx-> wl_send -> this -> wl driver */
+extern void bcm_rpc_tp_rx_from_dnglbus(rpc_tp_info_t * rpc_th, struct lbuf *lb);
+
+/* RPC callreturn pkt, go to USB driver tx */
+extern int bcm_rpc_tp_send_callreturn(rpc_tp_info_t * rpc_th, rpc_buf_t * b);
+
+extern void bcm_rpc_tp_dump(rpc_tp_info_t * rpcb);
+extern void bcm_rpc_tp_txflowctl(rpc_tp_info_t * rpcb, bool state, int prio);
+extern void bcm_rpc_tp_txflowctlcb_init(rpc_tp_info_t * rpc_th, void *ctx,
+					rpc_txflowctl_cb_t cb);
+extern void bcm_rpc_tp_txflowctlcb_deinit(rpc_tp_info_t * rpc_th);
+extern void bcm_rpc_tp_txq_wm_set(rpc_tp_info_t * rpc_th, uint8 hiwm,
+				  uint8 lowm);
+extern void bcm_rpc_tp_txq_wm_get(rpc_tp_info_t * rpc_th, uint8 * hiwm,
+				  uint8 * lowm);
+#endif				/* WLC_LOW */
+
+extern void bcm_rpc_tp_agg_set(rpc_tp_info_t * rpcb, uint32 reason, bool set);
+extern void bcm_rpc_tp_agg_limit_set(rpc_tp_info_t * rpc_th, uint8 sf,
+				     uint16 bytes);
+extern void bcm_rpc_tp_agg_limit_get(rpc_tp_info_t * rpc_th, uint8 * sf,
+				     uint16 * bytes);
+
+#define BCM_RPC_TP_MSG_LEVEL_MASK	0x00ff
+/* dongle msg level */
+#define RPC_TP_MSG_DNGL_ERR_VAL		0x0001	/* DNGL TP error msg */
+#define RPC_TP_MSG_DNGL_DBG_VAL		0x0002	/* DNGL TP dbg msg */
+#define RPC_TP_MSG_DNGL_AGG_VAL		0x0004	/* DNGL TP agg msg */
+#define RPC_TP_MSG_DNGL_DEA_VAL		0x0008	/* DNGL TP deag msg */
+
+/* host msg level */
+#define RPC_TP_MSG_HOST_ERR_VAL		0x0001	/* DNGL TP error msg */
+#define RPC_TP_MSG_HOST_DBG_VAL		0x0002	/* DNGL TP dbg msg */
+#define RPC_TP_MSG_HOST_AGG_VAL		0x0004	/* DNGL TP agg msg */
+#define RPC_TP_MSG_HOST_DEA_VAL		0x0008	/* DNGL TP deag msg */
+
+extern void bcm_rpc_tp_msglevel_set(rpc_tp_info_t * rpc_th, uint8 msglevel,
+				    bool high_low);
+
+#endif				/* _bcm_rpc_tp_h_ */
diff --git a/drivers/staging/brcm80211/include/bcm_xdr.h b/drivers/staging/brcm80211/include/bcm_xdr.h
new file mode 100644
index 0000000..18a677d
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcm_xdr.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BCM_XDR_H
+#define _BCM_XDR_H
+
+/*
+ * bcm_xdr_buf_t
+ * Structure used for bookkeeping of a buffer being packed or unpacked.
+ * Keeps a current read/write pointer and size as well as
+ * the original buffer pointer and size.
+ *
+ */
+typedef struct {
+	uint8 *buf;		/* pointer to current position in origbuf */
+	uint size;		/* current (residual) size in bytes */
+	uint8 *origbuf;		/* unmodified pointer to orignal buffer */
+	uint origsize;		/* unmodified orignal buffer size in bytes */
+} bcm_xdr_buf_t;
+
+void bcm_xdr_buf_init(bcm_xdr_buf_t * b, void *buf, size_t len);
+
+int bcm_xdr_pack_uint32(bcm_xdr_buf_t * b, uint32 val);
+int bcm_xdr_unpack_uint32(bcm_xdr_buf_t * b, uint32 * pval);
+int bcm_xdr_pack_int32(bcm_xdr_buf_t * b, int32 val);
+int bcm_xdr_unpack_int32(bcm_xdr_buf_t * b, int32 * pval);
+int bcm_xdr_pack_int8(bcm_xdr_buf_t * b, int8 val);
+int bcm_xdr_unpack_int8(bcm_xdr_buf_t * b, int8 * pval);
+int bcm_xdr_pack_opaque(bcm_xdr_buf_t * b, uint len, void *data);
+int bcm_xdr_unpack_opaque(bcm_xdr_buf_t * b, uint len, void **pdata);
+int bcm_xdr_unpack_opaque_cpy(bcm_xdr_buf_t * b, uint len, void *data);
+int bcm_xdr_pack_opaque_varlen(bcm_xdr_buf_t * b, uint len, void *data);
+int bcm_xdr_unpack_opaque_varlen(bcm_xdr_buf_t * b, uint * plen, void **pdata);
+int bcm_xdr_pack_string(bcm_xdr_buf_t * b, char *str);
+int bcm_xdr_unpack_string(bcm_xdr_buf_t * b, uint * plen, char **pstr);
+
+int bcm_xdr_pack_uint8_vec(bcm_xdr_buf_t *, uint8 * vec, uint32 elems);
+int bcm_xdr_unpack_uint8_vec(bcm_xdr_buf_t *, uint8 * vec, uint32 elems);
+int bcm_xdr_pack_uint16_vec(bcm_xdr_buf_t * b, uint len, void *vec);
+int bcm_xdr_unpack_uint16_vec(bcm_xdr_buf_t * b, uint len, void *vec);
+int bcm_xdr_pack_uint32_vec(bcm_xdr_buf_t * b, uint len, void *vec);
+int bcm_xdr_unpack_uint32_vec(bcm_xdr_buf_t * b, uint len, void *vec);
+
+int bcm_xdr_pack_opaque_raw(bcm_xdr_buf_t * b, uint len, void *data);
+int bcm_xdr_pack_opaque_pad(bcm_xdr_buf_t * b);
+
+#endif				/* _BCM_XDR_H */
diff --git a/drivers/staging/brcm80211/include/bcmdefs.h b/drivers/staging/brcm80211/include/bcmdefs.h
new file mode 100644
index 0000000..caa96b1
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmdefs.h
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmdefs_h_
+#define	_bcmdefs_h_
+
+/*
+ * One doesn't need to include this file explicitly, gets included automatically if
+ * typedefs.h is included.
+ */
+
+/* Use BCM_REFERENCE to suppress warnings about intentionally-unused function
+ * arguments or local variables.
+ */
+#define BCM_REFERENCE(data)	((void)data)
+
+/* Reclaiming text and data :
+ * The following macros specify special linker sections that can be reclaimed
+ * after a system is considered 'up'.
+ * BCMATTACHFN is also used for detach functions (it's not worth having a BCMDETACHFN,
+ * as in most cases, the attach function calls the detach function to clean up on error).
+ */
+
+#define bcmreclaimed 		0
+#define BCMATTACHDATA(_data)	_data
+#define BCMATTACHFN(_fn)	_fn
+#define BCMPREATTACHDATA(_data)	_data
+#define BCMPREATTACHFN(_fn)	_fn
+#define BCMINITDATA(_data)	_data
+#define BCMINITFN(_fn)		_fn
+#define BCMUNINITFN(_fn)	_fn
+#define	BCMNMIATTACHFN(_fn)	_fn
+#define	BCMNMIATTACHDATA(_data)	_data
+#define BCMOVERLAY0DATA(_sym)	_sym
+#define BCMOVERLAY0FN(_fn)	_fn
+#define BCMOVERLAY1DATA(_sym)	_sym
+#define BCMOVERLAY1FN(_fn)	_fn
+#define BCMOVERLAYERRFN(_fn)	_fn
+#define CONST	const
+#ifdef mips
+#define BCMFASTPATH		__attribute__ ((__section__(".text.fastpath")))
+#else
+#define BCMFASTPATH
+#endif
+
+/* Put some library data/code into ROM to reduce RAM requirements */
+#define BCMROMDATA(_data)	_data
+#define BCMROMDAT_NAME(_data)	_data
+#define BCMROMFN(_fn)		_fn
+#define BCMROMFN_NAME(_fn)	_fn
+#define STATIC	static
+#define BCMROMDAT_ARYSIZ(data)	ARRAYSIZE(data)
+#define BCMROMDAT_SIZEOF(data)	sizeof(data)
+#define BCMROMDAT_APATCH(data)
+#define BCMROMDAT_SPATCH(data)
+
+/* Bus types */
+#define	SI_BUS			0	/* SOC Interconnect */
+#define	PCI_BUS			1	/* PCI target */
+#define SDIO_BUS		3	/* SDIO target */
+#define JTAG_BUS		4	/* JTAG */
+#define USB_BUS			5	/* USB (does not support R/W REG) */
+#define SPI_BUS			6	/* gSPI target */
+#define RPC_BUS			7	/* RPC target */
+
+/* Allows size optimization for single-bus image */
+#ifdef BCMBUSTYPE
+#define BUSTYPE(bus) 	(BCMBUSTYPE)
+#else
+#define BUSTYPE(bus) 	(bus)
+#endif
+
+/* Allows size optimization for single-backplane image */
+#ifdef BCMCHIPTYPE
+#define CHIPTYPE(bus) 	(BCMCHIPTYPE)
+#else
+#define CHIPTYPE(bus) 	(bus)
+#endif
+
+/* Allows size optimization for SPROM support */
+#define SPROMBUS	(PCI_BUS)
+
+/* Allows size optimization for single-chip image */
+#ifdef BCMCHIPID
+#define CHIPID(chip)	(BCMCHIPID)
+#else
+#define CHIPID(chip)	(chip)
+#endif
+
+#ifdef BCMCHIPREV
+#define CHIPREV(rev)	(BCMCHIPREV)
+#else
+#define CHIPREV(rev)	(rev)
+#endif
+
+/* Defines for DMA Address Width - Shared between OSL and HNDDMA */
+#define DMADDR_MASK_32 0x0	/* Address mask for 32-bits */
+#define DMADDR_MASK_30 0xc0000000	/* Address mask for 30-bits */
+#define DMADDR_MASK_0  0xffffffff	/* Address mask for 0-bits (hi-part) */
+
+#define	DMADDRWIDTH_30  30	/* 30-bit addressing capability */
+#define	DMADDRWIDTH_32  32	/* 32-bit addressing capability */
+#define	DMADDRWIDTH_63  63	/* 64-bit addressing capability */
+#define	DMADDRWIDTH_64  64	/* 64-bit addressing capability */
+
+#ifdef BCMDMA64OSL
+typedef struct {
+	uint32 loaddr;
+	uint32 hiaddr;
+} dma64addr_t;
+
+typedef dma64addr_t dmaaddr_t;
+#define PHYSADDRHI(_pa) ((_pa).hiaddr)
+#define PHYSADDRHISET(_pa, _val) \
+	do { \
+		(_pa).hiaddr = (_val);		\
+	} while (0)
+#define PHYSADDRLO(_pa) ((_pa).loaddr)
+#define PHYSADDRLOSET(_pa, _val) \
+	do { \
+		(_pa).loaddr = (_val);		\
+	} while (0)
+
+#else
+typedef unsigned long dmaaddr_t;
+#define PHYSADDRHI(_pa) (0)
+#define PHYSADDRHISET(_pa, _val)
+#define PHYSADDRLO(_pa) ((_pa))
+#define PHYSADDRLOSET(_pa, _val) \
+	do { \
+		(_pa) = (_val);			\
+	} while (0)
+#endif				/* BCMDMA64OSL */
+
+/* One physical DMA segment */
+typedef struct {
+	dmaaddr_t addr;
+	uint32 length;
+} hnddma_seg_t;
+
+#define MAX_DMA_SEGS 4
+
+typedef struct {
+	void *oshdmah;		/* Opaque handle for OSL to store its information */
+	uint origsize;		/* Size of the virtual packet */
+	uint nsegs;
+	hnddma_seg_t segs[MAX_DMA_SEGS];
+} hnddma_seg_map_t;
+
+/* packet headroom necessary to accommodate the largest header in the system, (i.e TXOFF).
+ * By doing, we avoid the need  to allocate an extra buffer for the header when bridging to WL.
+ * There is a compile time check in wlc.c which ensure that this value is at least as big
+ * as TXOFF. This value is used in dma_rxfill (hnddma.c).
+ */
+
+#define BCMEXTRAHDROOM 172
+
+/* Headroom required for dongle-to-host communication.  Packets allocated
+ * locally in the dongle (e.g. for CDC ioctls or RNDIS messages) should
+ * leave this much room in front for low-level message headers which may
+ * be needed to get across the dongle bus to the host.  (These messages
+ * don't go over the network, so room for the full WL header above would
+ * be a waste.).
+*/
+#define BCMDONGLEHDRSZ 12
+#define BCMDONGLEPADSZ 16
+
+#define BCMDONGLEOVERHEAD	(BCMDONGLEHDRSZ + BCMDONGLEPADSZ)
+
+#ifdef BCMDBG
+
+#define BCMDBG_ERR
+
+#ifndef BCMDBG_ASSERT
+#define BCMDBG_ASSERT
+#endif				/* BCMDBG_ASSERT */
+
+#endif				/* BCMDBG */
+
+#if defined(BCMDBG_ASSERT)
+#define BCMASSERT_SUPPORT
+#endif
+
+/* Macros for doing definition and get/set of bitfields
+ * Usage example, e.g. a three-bit field (bits 4-6):
+ *    #define <NAME>_M	BITFIELD_MASK(3)
+ *    #define <NAME>_S	4
+ * ...
+ *    regval = R_REG(osh, &regs->regfoo);
+ *    field = GFIELD(regval, <NAME>);
+ *    regval = SFIELD(regval, <NAME>, 1);
+ *    W_REG(osh, &regs->regfoo, regval);
+ */
+#define BITFIELD_MASK(width) \
+		(((unsigned)1 << (width)) - 1)
+#define GFIELD(val, field) \
+		(((val) >> field ## _S) & field ## _M)
+#define SFIELD(val, field, bits) \
+		(((val) & (~(field ## _M << field ## _S))) | \
+		 ((unsigned)(bits) << field ## _S))
+
+/* define BCMSMALL to remove misc features for memory-constrained environments */
+#define	BCMSPACE
+#define bcmspace	TRUE	/* if (bcmspace) code is retained */
+
+/* Max. nvram variable table size */
+#define	MAXSZ_NVRAM_VARS	4096
+
+#define LOCATOR_EXTERN static
+
+#endif				/* _bcmdefs_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmdevs.h b/drivers/staging/brcm80211/include/bcmdevs.h
new file mode 100644
index 0000000..7d3a97a
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmdevs.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_BCMDEVS_H
+#define	_BCMDEVS_H
+
+/* PCI vendor IDs */
+#define	VENDOR_BROADCOM		0x14e4
+
+/* DONGLE VID/PIDs */
+#define BCM_DNGL_VID		0x0a5c
+#define BCM_DNGL_BDC_PID	0x0bdc
+
+#define BCM4329_D11N_ID		0x432e	/* 4329 802.11n dualband device */
+#define BCM4329_D11N2G_ID	0x432f	/* 4329 802.11n 2.4G device */
+#define BCM4329_D11N5G_ID	0x4330	/* 4329 802.11n 5G device */
+
+#define BCM4319_D11N_ID		0x4337	/* 4319 802.11n dualband device */
+#define BCM4319_D11N2G_ID	0x4338	/* 4319 802.11n 2.4G device */
+#define BCM4319_D11N5G_ID	0x4339	/* 4319 802.11n 5G device */
+
+#define BCM43224_D11N_ID	0x4353	/* 43224 802.11n dualband device */
+#define BCM43225_D11N2G_ID	0x4357	/* 43225 802.11n 2.4GHz device */
+
+#define BCM43236_D11N_ID	0x4346	/* 43236 802.11n dualband device */
+#define BCM43236_D11N2G_ID	0x4347	/* 43236 802.11n 2.4GHz device */
+#define BCM43236_D11N5G_ID	0x4348	/* 43236 802.11n 5GHz device */
+
+#define BCM43421_D11N_ID	0xA99D	/* 43421 802.11n dualband device */
+#define BCM4313_D11N2G_ID	0x4727	/* 4313 802.11n 2.4G device */
+#define BCM4330_D11N_ID         0x4360	/* 4330 802.11n dualband device */
+#define BCM4330_D11N2G_ID       0x4361	/* 4330 802.11n 2.4G device */
+#define BCM4330_D11N5G_ID       0x4362	/* 4330 802.11n 5G device */
+#define BCM4336_D11N_ID		0x4343	/* 4336 802.11n 2.4GHz device */
+#define BCM6362_D11N_ID		0x435f	/* 6362 802.11n dualband device */
+#define BCM4331_D11N_ID		0x4331	/* 4331 802.11n dualband id */
+#define BCM4331_D11N2G_ID	0x4332	/* 4331 802.11n 2.4Ghz band id */
+#define BCM4331_D11N5G_ID	0x4333	/* 4331 802.11n 5Ghz band id */
+
+/* Chip IDs */
+#define BCM4313_CHIP_ID		0x4313	/* 4313 chip id */
+#define	BCM4319_CHIP_ID		0x4319	/* 4319 chip id */
+
+#define	BCM43224_CHIP_ID	43224	/* 43224 chipcommon chipid */
+#define	BCM43225_CHIP_ID	43225	/* 43225 chipcommon chipid */
+#define	BCM43228_CHIP_ID	43228	/* 43228 chipcommon chipid */
+#define	BCM43421_CHIP_ID	43421	/* 43421 chipcommon chipid */
+#define	BCM43235_CHIP_ID	43235	/* 43235 chipcommon chipid */
+#define	BCM43236_CHIP_ID	43236	/* 43236 chipcommon chipid */
+#define	BCM43238_CHIP_ID	43238	/* 43238 chipcommon chipid */
+#define	BCM4329_CHIP_ID		0x4329	/* 4329 chipcommon chipid */
+#define	BCM4331_CHIP_ID		0x4331	/* 4331 chipcommon chipid */
+#define BCM4336_CHIP_ID		0x4336	/* 4336 chipcommon chipid */
+#define BCM4330_CHIP_ID		0x4330	/* 4330 chipcommon chipid */
+#define BCM6362_CHIP_ID		0x6362	/* 6362 chipcommon chipid */
+
+/* these are router chips */
+#define	BCM4716_CHIP_ID		0x4716	/* 4716 chipcommon chipid */
+#define	BCM47162_CHIP_ID	47162	/* 47162 chipcommon chipid */
+#define	BCM4748_CHIP_ID		0x4748	/* 4716 chipcommon chipid (OTP, RBBU) */
+#define	BCM5356_CHIP_ID		0x5356	/* 5356 chipcommon chipid */
+#define	BCM5357_CHIP_ID		0x5357	/* 5357 chipcommon chipid */
+
+/* Package IDs */
+#define BCM4329_289PIN_PKG_ID	0	/* 4329 289-pin package id */
+#define BCM4329_182PIN_PKG_ID	1	/* 4329N 182-pin package id */
+#define	BCM4716_PKG_ID		8	/* 4716 package id */
+#define	BCM4717_PKG_ID		9	/* 4717 package id */
+#define	BCM4718_PKG_ID		10	/* 4718 package id */
+#define BCM5356_PKG_NONMODE	1	/* 5356 package without nmode suppport */
+#define BCM5358U_PKG_ID		8	/* 5358U package id */
+#define BCM5358_PKG_ID		9	/* 5358 package id */
+#define BCM47186_PKG_ID		10	/* 47186 package id */
+#define BCM5357_PKG_ID		11	/* 5357 package id */
+#define BCM5356U_PKG_ID		12	/* 5356U package id */
+#define HDLSIM5350_PKG_ID	1	/* HDL simulator package id for a 5350 */
+#define HDLSIM_PKG_ID		14	/* HDL simulator package id */
+#define HWSIM_PKG_ID		15	/* Hardware simulator package id */
+#define BCM43224_FAB_CSM	0x8	/* the chip is manufactured by CSM */
+#define BCM43224_FAB_SMIC	0xa	/* the chip is manufactured by SMIC */
+#define BCM4336_WLBGA_PKG_ID 0x8
+
+/* boardflags */
+#define	BFL_RESERVED1		0x00000001
+#define	BFL_PACTRL		0x00000002	/* Board has gpio 9 controlling the PA */
+#define	BFL_AIRLINEMODE		0x00000004	/* Board implements gpio 13 radio disable indication */
+#define	BFL_ADCDIV		0x00000008	/* Board has the rssi ADC divider */
+#define	BFL_ENETROBO		0x00000010	/* Board has robo switch or core */
+#define	BFL_NOPLLDOWN		0x00000020	/* Not ok to power down the chip pll and oscillator */
+#define	BFL_CCKHIPWR		0x00000040	/* Can do high-power CCK transmission */
+#define	BFL_ENETADM		0x00000080	/* Board has ADMtek switch */
+#define	BFL_ENETVLAN		0x00000100	/* Board has VLAN capability */
+#define BFL_NOPCI		0x00000400	/* Board leaves PCI floating */
+#define BFL_FEM			0x00000800	/* Board supports the Front End Module */
+#define BFL_EXTLNA		0x00001000	/* Board has an external LNA in 2.4GHz band */
+#define BFL_HGPA		0x00002000	/* Board has a high gain PA */
+#define	BFL_RESERVED2		0x00004000
+#define	BFL_ALTIQ		0x00008000	/* Alternate I/Q settings */
+#define BFL_NOPA		0x00010000	/* Board has no PA */
+#define BFL_RSSIINV		0x00020000	/* Board's RSSI uses positive slope(not TSSI) */
+#define BFL_PAREF		0x00040000	/* Board uses the PARef LDO */
+#define BFL_3TSWITCH		0x00080000	/* Board uses a triple throw switch shared with BT */
+#define BFL_PHASESHIFT		0x00100000	/* Board can support phase shifter */
+#define BFL_BUCKBOOST		0x00200000	/* Power topology uses BUCKBOOST */
+#define BFL_FEM_BT		0x00400000	/* Board has FEM and switch to share antenna w/ BT */
+#define BFL_NOCBUCK		0x00800000	/* Power topology doesn't use CBUCK */
+#define BFL_CCKFAVOREVM		0x01000000	/* Favor CCK EVM over spectral mask */
+#define BFL_PALDO		0x02000000	/* Power topology uses PALDO */
+#define BFL_LNLDO2_2P5		0x04000000	/* Select 2.5V as LNLDO2 output voltage */
+#define BFL_FASTPWR		0x08000000
+#define BFL_UCPWRCTL_MININDX	0x08000000	/* Enforce min power index to avoid FEM damage */
+#define BFL_EXTLNA_5GHz		0x10000000	/* Board has an external LNA in 5GHz band */
+#define BFL_TRSW_1by2		0x20000000	/* Board has 2 TRSW's in 1by2 designs */
+#define BFL_LO_TRSW_R_5GHz	0x40000000	/* In 5G do not throw TRSW to T for clipLO gain */
+#define BFL_ELNA_GAINDEF	0x80000000	/* Backoff InitGain based on elna_2g/5g field
+						 * when this flag is set
+						 */
+
+/* boardflags2 */
+#define BFL2_RXBB_INT_REG_DIS	0x00000001	/* Board has an external rxbb regulator */
+#define BFL2_APLL_WAR		0x00000002	/* Flag to implement alternative A-band PLL settings */
+#define BFL2_TXPWRCTRL_EN	0x00000004	/* Board permits enabling TX Power Control */
+#define BFL2_2X4_DIV		0x00000008	/* Board supports the 2X4 diversity switch */
+#define BFL2_5G_PWRGAIN		0x00000010	/* Board supports 5G band power gain */
+#define BFL2_PCIEWAR_OVR	0x00000020	/* Board overrides ASPM and Clkreq settings */
+#define BFL2_CAESERS_BRD	0x00000040	/* Board is Caesers brd (unused by sw) */
+#define BFL2_LEGACY		0x00000080
+#define BFL2_SKWRKFEM_BRD	0x00000100	/* 4321mcm93 board uses Skyworks FEM */
+#define BFL2_SPUR_WAR		0x00000200	/* Board has a WAR for clock-harmonic spurs */
+#define BFL2_GPLL_WAR		0x00000400	/* Flag to narrow G-band PLL loop b/w */
+#define BFL2_TRISTATE_LED	0x00000800	/* Tri-state the LED */
+#define BFL2_SINGLEANT_CCK	0x00001000	/* Tx CCK pkts on Ant 0 only */
+#define BFL2_2G_SPUR_WAR	0x00002000	/* WAR to reduce and avoid clock-harmonic spurs in 2G */
+#define BFL2_BPHY_ALL_TXCORES	0x00004000	/* Transmit bphy frames using all tx cores */
+#define BFL2_FCC_BANDEDGE_WAR	0x00008000	/* using 40Mhz LPF for 20Mhz bandedge channels */
+#define BFL2_GPLL_WAR2	        0x00010000	/* Flag to widen G-band PLL loop b/w */
+#define BFL2_IPALVLSHIFT_3P3    0x00020000
+#define BFL2_INTERNDET_TXIQCAL  0x00040000	/* Use internal envelope detector for TX IQCAL */
+#define BFL2_XTALBUFOUTEN       0x00080000	/* Keep the buffered Xtal output from radio "ON"
+						 * Most drivers will turn it off without this flag
+						 * to save power.
+						 */
+
+/* board specific GPIO assignment, gpio 0-3 are also customer-configurable led */
+#define	BOARD_GPIO_RESERVED1	0x010
+#define	BOARD_GPIO_RESERVED2	0x020
+#define	BOARD_GPIO_RESERVED3	0x080
+#define	BOARD_GPIO_RESERVED4	0x100
+#define	BOARD_GPIO_PACTRL	0x200	/* bit 9 controls the PA on new 4306 boards */
+#define BOARD_GPIO_12		0x1000	/* gpio 12 */
+#define BOARD_GPIO_13		0x2000	/* gpio 13 */
+#define BOARD_GPIO_RESERVED5	0x0800
+#define BOARD_GPIO_RESERVED6	0x2000
+#define BOARD_GPIO_RESERVED7	0x4000
+#define BOARD_GPIO_RESERVED8	0x8000
+
+#define	PCI_CFG_GPIO_SCS	0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
+#define PCI_CFG_GPIO_HWRAD	0x20	/* PCI config space GPIO 13 for hw radio disable */
+#define PCI_CFG_GPIO_XTAL	0x40	/* PCI config space GPIO 14 for Xtal power-up */
+#define PCI_CFG_GPIO_PLL	0x80	/* PCI config space GPIO 15 for PLL power-down */
+
+/* power control defines */
+#define PLL_DELAY		150	/* us pll on delay */
+#define FREF_DELAY		200	/* us fref change delay */
+#define MIN_SLOW_CLK		32	/* us Slow clock period */
+#define	XTAL_ON_DELAY		1000	/* us crystal power-on delay */
+
+/* # of GPIO pins */
+#define GPIO_NUMPINS		16
+
+/* Reference board types */
+#define	SPI_BOARD		0x0402
+
+#endif				/* _BCMDEVS_H */
diff --git a/drivers/staging/brcm80211/include/bcmendian.h b/drivers/staging/brcm80211/include/bcmendian.h
new file mode 100644
index 0000000..12c1890
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmendian.h
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BCMENDIAN_H_
+#define _BCMENDIAN_H_
+
+#include <typedefs.h>
+
+/* Reverse the bytes in a 16-bit value */
+#define BCMSWAP16(val) \
+	((uint16)((((uint16)(val) & (uint16)0x00ffU) << 8) | \
+		  (((uint16)(val) & (uint16)0xff00U) >> 8)))
+
+/* Reverse the bytes in a 32-bit value */
+#define BCMSWAP32(val) \
+	((uint32)((((uint32)(val) & (uint32)0x000000ffU) << 24) | \
+		  (((uint32)(val) & (uint32)0x0000ff00U) <<  8) | \
+		  (((uint32)(val) & (uint32)0x00ff0000U) >>  8) | \
+		  (((uint32)(val) & (uint32)0xff000000U) >> 24)))
+
+/* Reverse the two 16-bit halves of a 32-bit value */
+#define BCMSWAP32BY16(val) \
+	((uint32)((((uint32)(val) & (uint32)0x0000ffffU) << 16) | \
+		  (((uint32)(val) & (uint32)0xffff0000U) >> 16)))
+
+/* Byte swapping macros
+ *    Host <=> Network (Big Endian) for 16- and 32-bit values
+ *    Host <=> Little-Endian for 16- and 32-bit values
+ */
+#ifndef hton16
+#ifndef IL_BIGENDIAN
+#define HTON16(i) BCMSWAP16(i)
+#define	hton16(i) bcmswap16(i)
+#define	HTON32(i) BCMSWAP32(i)
+#define	hton32(i) bcmswap32(i)
+#define	NTOH16(i) BCMSWAP16(i)
+#define	ntoh16(i) bcmswap16(i)
+#define	NTOH32(i) BCMSWAP32(i)
+#define	ntoh32(i) bcmswap32(i)
+#define LTOH16(i) (i)
+#define ltoh16(i) (i)
+#define LTOH32(i) (i)
+#define ltoh32(i) (i)
+#define HTOL16(i) (i)
+#define htol16(i) (i)
+#define HTOL32(i) (i)
+#define htol32(i) (i)
+#else				/* IL_BIGENDIAN */
+#define HTON16(i) (i)
+#define	hton16(i) (i)
+#define	HTON32(i) (i)
+#define	hton32(i) (i)
+#define	NTOH16(i) (i)
+#define	ntoh16(i) (i)
+#define	NTOH32(i) (i)
+#define	ntoh32(i) (i)
+#define	LTOH16(i) BCMSWAP16(i)
+#define	ltoh16(i) bcmswap16(i)
+#define	LTOH32(i) BCMSWAP32(i)
+#define	ltoh32(i) bcmswap32(i)
+#define HTOL16(i) BCMSWAP16(i)
+#define htol16(i) bcmswap16(i)
+#define HTOL32(i) BCMSWAP32(i)
+#define htol32(i) bcmswap32(i)
+#endif				/* IL_BIGENDIAN */
+#endif				/* hton16 */
+
+#ifndef IL_BIGENDIAN
+#define ltoh16_buf(buf, i)
+#define htol16_buf(buf, i)
+#else
+#define ltoh16_buf(buf, i) bcmswap16_buf((uint16 *)(buf), (i))
+#define htol16_buf(buf, i) bcmswap16_buf((uint16 *)(buf), (i))
+#endif				/* IL_BIGENDIAN */
+
+/* Unaligned loads and stores in host byte order */
+#ifndef IL_BIGENDIAN
+#define load32_ua(a)		ltoh32_ua(a)
+#define store32_ua(a, v)	htol32_ua_store(v, a)
+#define load16_ua(a)		ltoh16_ua(a)
+#define store16_ua(a, v)	htol16_ua_store(v, a)
+#else
+#define load32_ua(a)		ntoh32_ua(a)
+#define store32_ua(a, v)	hton32_ua_store(v, a)
+#define load16_ua(a)		ntoh16_ua(a)
+#define store16_ua(a, v)	hton16_ua_store(v, a)
+#endif				/* IL_BIGENDIAN */
+
+#define _LTOH16_UA(cp)	((cp)[0] | ((cp)[1] << 8))
+#define _LTOH32_UA(cp)	((cp)[0] | ((cp)[1] << 8) | ((cp)[2] << 16) | ((cp)[3] << 24))
+#define _NTOH16_UA(cp)	(((cp)[0] << 8) | (cp)[1])
+#define _NTOH32_UA(cp)	(((cp)[0] << 24) | ((cp)[1] << 16) | ((cp)[2] << 8) | (cp)[3])
+
+#define ltoh_ua(ptr) \
+	(sizeof(*(ptr)) == sizeof(uint8) ? *(const uint8 *)(ptr) : \
+	 sizeof(*(ptr)) == sizeof(uint16) ? _LTOH16_UA((const uint8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(uint32) ? _LTOH32_UA((const uint8 *)(ptr)) : \
+	 *(uint8 *)0)
+
+#define ntoh_ua(ptr) \
+	(sizeof(*(ptr)) == sizeof(uint8) ? *(const uint8 *)(ptr) : \
+	 sizeof(*(ptr)) == sizeof(uint16) ? _NTOH16_UA((const uint8 *)(ptr)) : \
+	 sizeof(*(ptr)) == sizeof(uint32) ? _NTOH32_UA((const uint8 *)(ptr)) : \
+	 *(uint8 *)0)
+
+#ifdef __GNUC__
+
+/* GNU macro versions avoid referencing the argument multiple times, while also
+ * avoiding the -fno-inline used in ROM builds.
+ */
+
+#define bcmswap16(val) ({ \
+	uint16 _val = (val); \
+	BCMSWAP16(_val); \
+})
+
+#define bcmswap32(val) ({ \
+	uint32 _val = (val); \
+	BCMSWAP32(_val); \
+})
+
+#define bcmswap32by16(val) ({ \
+	uint32 _val = (val); \
+	BCMSWAP32BY16(_val); \
+})
+
+#define bcmswap16_buf(buf, len) ({ \
+	uint16 *_buf = (uint16 *)(buf); \
+	uint _wds = (len) / 2; \
+	while (_wds--) { \
+		*_buf = bcmswap16(*_buf); \
+		_buf++; \
+	} \
+})
+
+#define htol16_ua_store(val, bytes) ({ \
+	uint16 _val = (val); \
+	uint8 *_bytes = (uint8 *)(bytes); \
+	_bytes[0] = _val & 0xff; \
+	_bytes[1] = _val >> 8; \
+})
+
+#define htol32_ua_store(val, bytes) ({ \
+	uint32 _val = (val); \
+	uint8 *_bytes = (uint8 *)(bytes); \
+	_bytes[0] = _val & 0xff; \
+	_bytes[1] = (_val >> 8) & 0xff; \
+	_bytes[2] = (_val >> 16) & 0xff; \
+	_bytes[3] = _val >> 24; \
+})
+
+#define hton16_ua_store(val, bytes) ({ \
+	uint16 _val = (val); \
+	uint8 *_bytes = (uint8 *)(bytes); \
+	_bytes[0] = _val >> 8; \
+	_bytes[1] = _val & 0xff; \
+})
+
+#define hton32_ua_store(val, bytes) ({ \
+	uint32 _val = (val); \
+	uint8 *_bytes = (uint8 *)(bytes); \
+	_bytes[0] = _val >> 24; \
+	_bytes[1] = (_val >> 16) & 0xff; \
+	_bytes[2] = (_val >> 8) & 0xff; \
+	_bytes[3] = _val & 0xff; \
+})
+
+#define ltoh16_ua(bytes) ({ \
+	const uint8 *_bytes = (const uint8 *)(bytes); \
+	_LTOH16_UA(_bytes); \
+})
+
+#define ltoh32_ua(bytes) ({ \
+	const uint8 *_bytes = (const uint8 *)(bytes); \
+	_LTOH32_UA(_bytes); \
+})
+
+#define ntoh16_ua(bytes) ({ \
+	const uint8 *_bytes = (const uint8 *)(bytes); \
+	_NTOH16_UA(_bytes); \
+})
+
+#define ntoh32_ua(bytes) ({ \
+	const uint8 *_bytes = (const uint8 *)(bytes); \
+	_NTOH32_UA(_bytes); \
+})
+
+#else				/* !__GNUC__ */
+
+/* Inline versions avoid referencing the argument multiple times */
+static INLINE uint16 bcmswap16(uint16 val)
+{
+	return BCMSWAP16(val);
+}
+
+static INLINE uint32 bcmswap32(uint32 val)
+{
+	return BCMSWAP32(val);
+}
+
+static INLINE uint32 bcmswap32by16(uint32 val)
+{
+	return BCMSWAP32BY16(val);
+}
+
+/* Reverse pairs of bytes in a buffer (not for high-performance use) */
+/* buf	- start of buffer of shorts to swap */
+/* len  - byte length of buffer */
+static INLINE void bcmswap16_buf(uint16 * buf, uint len)
+{
+	len = len / 2;
+
+	while (len--) {
+		*buf = bcmswap16(*buf);
+		buf++;
+	}
+}
+
+/*
+ * Store 16-bit value to unaligned little-endian byte array.
+ */
+static INLINE void htol16_ua_store(uint16 val, uint8 * bytes)
+{
+	bytes[0] = val & 0xff;
+	bytes[1] = val >> 8;
+}
+
+/*
+ * Store 32-bit value to unaligned little-endian byte array.
+ */
+static INLINE void htol32_ua_store(uint32 val, uint8 * bytes)
+{
+	bytes[0] = val & 0xff;
+	bytes[1] = (val >> 8) & 0xff;
+	bytes[2] = (val >> 16) & 0xff;
+	bytes[3] = val >> 24;
+}
+
+/*
+ * Store 16-bit value to unaligned network-(big-)endian byte array.
+ */
+static INLINE void hton16_ua_store(uint16 val, uint8 * bytes)
+{
+	bytes[0] = val >> 8;
+	bytes[1] = val & 0xff;
+}
+
+/*
+ * Store 32-bit value to unaligned network-(big-)endian byte array.
+ */
+static INLINE void hton32_ua_store(uint32 val, uint8 * bytes)
+{
+	bytes[0] = val >> 24;
+	bytes[1] = (val >> 16) & 0xff;
+	bytes[2] = (val >> 8) & 0xff;
+	bytes[3] = val & 0xff;
+}
+
+/*
+ * Load 16-bit value from unaligned little-endian byte array.
+ */
+static INLINE uint16 ltoh16_ua(const void *bytes)
+{
+	return _LTOH16_UA((const uint8 *)bytes);
+}
+
+/*
+ * Load 32-bit value from unaligned little-endian byte array.
+ */
+static INLINE uint32 ltoh32_ua(const void *bytes)
+{
+	return _LTOH32_UA((const uint8 *)bytes);
+}
+
+/*
+ * Load 16-bit value from unaligned big-(network-)endian byte array.
+ */
+static INLINE uint16 ntoh16_ua(const void *bytes)
+{
+	return _NTOH16_UA((const uint8 *)bytes);
+}
+
+/*
+ * Load 32-bit value from unaligned big-(network-)endian byte array.
+ */
+static INLINE uint32 ntoh32_ua(const void *bytes)
+{
+	return _NTOH32_UA((const uint8 *)bytes);
+}
+
+#endif				/* !__GNUC__ */
+#endif				/* !_BCMENDIAN_H_ */
diff --git a/drivers/staging/brcm80211/include/bcmnvram.h b/drivers/staging/brcm80211/include/bcmnvram.h
new file mode 100644
index 0000000..2fe940d
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmnvram.h
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _bcmnvram_h_
+#define _bcmnvram_h_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+
+struct nvram_header {
+	uint32 magic;
+	uint32 len;
+	uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
+	uint32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
+	uint32 config_ncdl;	/* ncdl values for memc */
+};
+
+struct nvram_tuple {
+	char *name;
+	char *value;
+	struct nvram_tuple *next;
+};
+
+/*
+ * Get default value for an NVRAM variable
+ */
+extern char *nvram_default_get(const char *name);
+
+/*
+ * Initialize NVRAM access. May be unnecessary or undefined on certain
+ * platforms.
+ */
+extern int nvram_init(void *sih);
+
+/*
+ * Append a chunk of nvram variables to the global list
+ */
+extern int nvram_append(void *si, char *vars, uint varsz);
+
+/*
+ * Check for reset button press for restoring factory defaults.
+ */
+extern int nvram_reset(void *sih);
+
+/*
+ * Disable NVRAM access. May be unnecessary or undefined on certain
+ * platforms.
+ */
+extern void nvram_exit(void *sih);
+
+/*
+ * Get the value of an NVRAM variable. The pointer returned may be
+ * invalid after a set.
+ * @param	name	name of variable to get
+ * @return	value of variable or NULL if undefined
+ */
+extern char *nvram_get(const char *name);
+
+/*
+ * Read the reset GPIO value from the nvram and set the GPIO
+ * as input
+ */
+extern int BCMINITFN(nvram_resetgpio_init) (void *sih);
+
+/*
+ * Get the value of an NVRAM variable.
+ * @param	name	name of variable to get
+ * @return	value of variable or NUL if undefined
+ */
+#define nvram_safe_get(name) (nvram_get(name) ? : "")
+
+/*
+ * Match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is string equal
+ *		to match or FALSE otherwise
+ */
+static INLINE int nvram_match(char *name, char *match)
+{
+	const char *value = nvram_get(name);
+	return (value && !strcmp(value, match));
+}
+
+/*
+ * Inversely match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is not string
+ *		equal to invmatch or FALSE otherwise
+ */
+static INLINE int nvram_invmatch(char *name, char *invmatch)
+{
+	const char *value = nvram_get(name);
+	return (value && strcmp(value, invmatch));
+}
+
+/*
+ * Set the value of an NVRAM variable. The name and value strings are
+ * copied into private storage. Pointers to previously set values
+ * may become invalid. The new value may be immediately
+ * retrieved but will not be permanently stored until a commit.
+ * @param	name	name of variable to set
+ * @param	value	value of variable
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_set(const char *name, const char *value);
+
+/*
+ * Unset an NVRAM variable. Pointers to previously set values
+ * remain valid until a set.
+ * @param	name	name of variable to unset
+ * @return	0 on success and errno on failure
+ * NOTE: use nvram_commit to commit this change to flash.
+ */
+extern int nvram_unset(const char *name);
+
+/*
+ * Commit NVRAM variables to permanent storage. All pointers to values
+ * may be invalid after a commit.
+ * NVRAM values are undefined after a commit.
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_commit(void);
+
+/*
+ * Get all NVRAM variables (format name=value\0 ... \0\0).
+ * @param	buf	buffer to store variables
+ * @param	count	size of buffer in bytes
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_getall(char *nvram_buf, int count);
+
+/*
+ * returns the crc value of the nvram
+ * @param	nvh	nvram header pointer
+ */
+uint8 nvram_calc_crc(struct nvram_header *nvh);
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* The NVRAM version number stored as an NVRAM variable */
+#define NVRAM_SOFTWARE_VERSION	"1"
+
+#define NVRAM_MAGIC		0x48534C46	/* 'FLSH' */
+#define NVRAM_CLEAR_MAGIC	0x0
+#define NVRAM_INVALID_MAGIC	0xFFFFFFFF
+#define NVRAM_VERSION		1
+#define NVRAM_HEADER_SIZE	20
+#define NVRAM_SPACE		0x8000
+
+#define NVRAM_MAX_VALUE_LEN 255
+#define NVRAM_MAX_PARAM_LEN 64
+
+#define NVRAM_CRC_START_POSITION	9	/* magic, len, crc8 to be skipped */
+#define NVRAM_CRC_VER_MASK	0xffffff00	/* for crc_ver_init */
+
+#endif				/* _bcmnvram_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmotp.h b/drivers/staging/brcm80211/include/bcmotp.h
new file mode 100644
index 0000000..9186878
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmotp.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmotp_h_
+#define	_bcmotp_h_
+
+/* OTP regions */
+#define OTP_HW_RGN	1
+#define OTP_SW_RGN	2
+#define OTP_CI_RGN	4
+#define OTP_FUSE_RGN	8
+#define OTP_ALL_RGN	0xf	/* From h/w region to end of OTP including checksum */
+
+/* OTP Size */
+#define OTP_SZ_MAX		(6144/8)	/* maximum bytes in one CIS */
+
+/* Fixed size subregions sizes in words */
+#define OTPGU_CI_SZ		2
+
+/* OTP usage */
+#define OTP4325_FM_DISABLED_OFFSET	188
+
+/* Exported functions */
+extern int otp_status(void *oh);
+extern int otp_size(void *oh);
+extern uint16 otp_read_bit(void *oh, uint offset);
+extern void *otp_init(si_t * sih);
+extern int otp_read_region(si_t * sih, int region, uint16 * data, uint * wlen);
+extern int otp_nvread(void *oh, char *data, uint * len);
+
+#endif				/* _bcmotp_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsdbus.h b/drivers/staging/brcm80211/include/bcmsdbus.h
new file mode 100644
index 0000000..36dd3cf
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmsdbus.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_sdio_api_h_
+#define	_sdio_api_h_
+
+#define SDIOH_API_RC_SUCCESS                          (0x00)
+#define SDIOH_API_RC_FAIL	                      (0x01)
+#define SDIOH_API_SUCCESS(status) (status == 0)
+
+#define SDIOH_READ              0	/* Read request */
+#define SDIOH_WRITE             1	/* Write request */
+
+#define SDIOH_DATA_FIX          0	/* Fixed addressing */
+#define SDIOH_DATA_INC          1	/* Incremental addressing */
+
+#define SDIOH_CMD_TYPE_NORMAL   0	/* Normal command */
+#define SDIOH_CMD_TYPE_APPEND   1	/* Append command */
+#define SDIOH_CMD_TYPE_CUTTHRU  2	/* Cut-through command */
+
+#define SDIOH_DATA_PIO          0	/* PIO mode */
+#define SDIOH_DATA_DMA          1	/* DMA mode */
+
+typedef int SDIOH_API_RC;
+
+/* SDio Host structure */
+typedef struct sdioh_info sdioh_info_t;
+
+/* callback function, taking one arg */
+typedef void (*sdioh_cb_fn_t) (void *);
+
+/* attach, return handler on success, NULL if failed.
+ *  The handler shall be provided by all subsequent calls. No local cache
+ *  cfghdl points to the starting address of pci device mapped memory
+ */
+extern sdioh_info_t *sdioh_attach(osl_t * osh, void *cfghdl, uint irq);
+extern SDIOH_API_RC sdioh_detach(osl_t * osh, sdioh_info_t * si);
+extern SDIOH_API_RC sdioh_interrupt_register(sdioh_info_t * si,
+					     sdioh_cb_fn_t fn, void *argh);
+extern SDIOH_API_RC sdioh_interrupt_deregister(sdioh_info_t * si);
+
+/* query whether SD interrupt is enabled or not */
+extern SDIOH_API_RC sdioh_interrupt_query(sdioh_info_t * si, bool * onoff);
+
+/* enable or disable SD interrupt */
+extern SDIOH_API_RC sdioh_interrupt_set(sdioh_info_t * si, bool enable_disable);
+
+#if defined(BCMDBG)
+extern bool sdioh_interrupt_pending(sdioh_info_t * si);
+#endif
+
+extern int sdioh_claim_host_and_lock(sdioh_info_t * si);
+extern int sdioh_release_host_and_unlock(sdioh_info_t * si);
+
+/* read or write one byte using cmd52 */
+extern SDIOH_API_RC sdioh_request_byte(sdioh_info_t * si, uint rw, uint fnc,
+				       uint addr, uint8 * byte);
+
+/* read or write 2/4 bytes using cmd53 */
+extern SDIOH_API_RC sdioh_request_word(sdioh_info_t * si, uint cmd_type,
+				       uint rw, uint fnc, uint addr,
+				       uint32 * word, uint nbyte);
+
+/* read or write any buffer using cmd53 */
+extern SDIOH_API_RC sdioh_request_buffer(sdioh_info_t * si, uint pio_dma,
+					 uint fix_inc, uint rw, uint fnc_num,
+					 uint32 addr, uint regwidth,
+					 uint32 buflen, uint8 * buffer,
+					 void *pkt);
+
+/* get cis data */
+extern SDIOH_API_RC sdioh_cis_read(sdioh_info_t * si, uint fuc, uint8 * cis,
+				   uint32 length);
+
+extern SDIOH_API_RC sdioh_cfg_read(sdioh_info_t * si, uint fuc, uint32 addr,
+				   uint8 * data);
+extern SDIOH_API_RC sdioh_cfg_write(sdioh_info_t * si, uint fuc, uint32 addr,
+				    uint8 * data);
+
+/* query number of io functions */
+extern uint sdioh_query_iofnum(sdioh_info_t * si);
+
+/* handle iovars */
+extern int sdioh_iovar_op(sdioh_info_t * si, const char *name,
+			  void *params, int plen, void *arg, int len, bool set);
+
+/* Issue abort to the specified function and clear controller as needed */
+extern int sdioh_abort(sdioh_info_t * si, uint fnc);
+
+/* Start and Stop SDIO without re-enumerating the SD card. */
+extern int sdioh_start(sdioh_info_t * si, int stage);
+extern int sdioh_stop(sdioh_info_t * si);
+
+/* Reset and re-initialize the device */
+extern int sdioh_sdio_reset(sdioh_info_t * si);
+
+/* Helper function */
+void *bcmsdh_get_sdioh(bcmsdh_info_t * sdh);
+
+#endif				/* _sdio_api_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsdh.h b/drivers/staging/brcm80211/include/bcmsdh.h
new file mode 100644
index 0000000..551ca57
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmsdh.h
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmsdh_h_
+#define	_bcmsdh_h_
+
+#define BCMSDH_ERROR_VAL	0x0001	/* Error */
+#define BCMSDH_INFO_VAL		0x0002	/* Info */
+extern const uint bcmsdh_msglevel;
+
+#ifdef BCMDBG
+#define BCMSDH_ERROR(x)	do { if ((bcmsdh_msglevel & BCMSDH_ERROR_VAL) && net_ratelimit()) printf x; } while (0)
+#define BCMSDH_INFO(x)	do { if ((bcmsdh_msglevel & BCMSDH_INFO_VAL) && net_ratelimit()) printf x; } while (0)
+#else				/* BCMDBG */
+#define BCMSDH_ERROR(x)
+#define BCMSDH_INFO(x)
+#endif				/* BCMDBG */
+
+/* forward declarations */
+typedef struct bcmsdh_info bcmsdh_info_t;
+typedef void (*bcmsdh_cb_fn_t) (void *);
+
+/* Attach and build an interface to the underlying SD host driver.
+ *  - Allocates resources (structs, arrays, mem, OS handles, etc) needed by bcmsdh.
+ *  - Returns the bcmsdh handle and virtual address base for register access.
+ *    The returned handle should be used in all subsequent calls, but the bcmsh
+ *    implementation may maintain a single "default" handle (e.g. the first or
+ *    most recent one) to enable single-instance implementations to pass NULL.
+ */
+extern bcmsdh_info_t *bcmsdh_attach(osl_t * osh, void *cfghdl, void **regsva,
+				    uint irq);
+
+/* Detach - freeup resources allocated in attach */
+extern int bcmsdh_detach(osl_t * osh, void *sdh);
+
+/* Query if SD device interrupts are enabled */
+extern bool bcmsdh_intr_query(void *sdh);
+
+/* Enable/disable SD interrupt */
+extern int bcmsdh_intr_enable(void *sdh);
+extern int bcmsdh_intr_disable(void *sdh);
+
+/* Register/deregister device interrupt handler. */
+extern int bcmsdh_intr_reg(void *sdh, bcmsdh_cb_fn_t fn, void *argh);
+extern int bcmsdh_intr_dereg(void *sdh);
+
+#if defined(BCMDBG)
+/* Query pending interrupt status from the host controller */
+extern bool bcmsdh_intr_pending(void *sdh);
+#endif
+extern int bcmsdh_claim_host_and_lock(void *sdh);
+extern int bcmsdh_release_host_and_unlock(void *sdh);
+
+/* Register a callback to be called if and when bcmsdh detects
+ * device removal. No-op in the case of non-removable/hardwired devices.
+ */
+extern int bcmsdh_devremove_reg(void *sdh, bcmsdh_cb_fn_t fn, void *argh);
+
+/* Access SDIO address space (e.g. CCCR) using CMD52 (single-byte interface).
+ *   fn:   function number
+ *   addr: unmodified SDIO-space address
+ *   data: data byte to write
+ *   err:  pointer to error code (or NULL)
+ */
+extern uint8 bcmsdh_cfg_read(void *sdh, uint func, uint32 addr, int *err);
+extern void bcmsdh_cfg_write(void *sdh, uint func, uint32 addr, uint8 data,
+			     int *err);
+
+/* Read/Write 4bytes from/to cfg space */
+extern uint32 bcmsdh_cfg_read_word(void *sdh, uint fnc_num, uint32 addr,
+				   int *err);
+extern void bcmsdh_cfg_write_word(void *sdh, uint fnc_num, uint32 addr,
+				  uint32 data, int *err);
+
+/* Read CIS content for specified function.
+ *   fn:     function whose CIS is being requested (0 is common CIS)
+ *   cis:    pointer to memory location to place results
+ *   length: number of bytes to read
+ * Internally, this routine uses the values from the cis base regs (0x9-0xB)
+ * to form an SDIO-space address to read the data from.
+ */
+extern int bcmsdh_cis_read(void *sdh, uint func, uint8 * cis, uint length);
+
+/* Synchronous access to device (client) core registers via CMD53 to F1.
+ *   addr: backplane address (i.e. >= regsva from attach)
+ *   size: register width in bytes (2 or 4)
+ *   data: data for register write
+ */
+extern uint32 bcmsdh_reg_read(void *sdh, uint32 addr, uint size);
+extern uint32 bcmsdh_reg_write(void *sdh, uint32 addr, uint size, uint32 data);
+
+/* Indicate if last reg read/write failed */
+extern bool bcmsdh_regfail(void *sdh);
+
+/* Buffer transfer to/from device (client) core via cmd53.
+ *   fn:       function number
+ *   addr:     backplane address (i.e. >= regsva from attach)
+ *   flags:    backplane width, address increment, sync/async
+ *   buf:      pointer to memory data buffer
+ *   nbytes:   number of bytes to transfer to/from buf
+ *   pkt:      pointer to packet associated with buf (if any)
+ *   complete: callback function for command completion (async only)
+ *   handle:   handle for completion callback (first arg in callback)
+ * Returns 0 or error code.
+ * NOTE: Async operation is not currently supported.
+ */
+typedef void (*bcmsdh_cmplt_fn_t) (void *handle, int status, bool sync_waiting);
+extern int bcmsdh_send_buf(void *sdh, uint32 addr, uint fn, uint flags,
+			   uint8 * buf, uint nbytes, void *pkt,
+			   bcmsdh_cmplt_fn_t complete, void *handle);
+extern int bcmsdh_recv_buf(void *sdh, uint32 addr, uint fn, uint flags,
+			   uint8 * buf, uint nbytes, void *pkt,
+			   bcmsdh_cmplt_fn_t complete, void *handle);
+
+/* Flags bits */
+#define SDIO_REQ_4BYTE	0x1	/* Four-byte target (backplane) width (vs. two-byte) */
+#define SDIO_REQ_FIXED	0x2	/* Fixed address (FIFO) (vs. incrementing address) */
+#define SDIO_REQ_ASYNC	0x4	/* Async request (vs. sync request) */
+
+/* Pending (non-error) return code */
+#define BCME_PENDING	1
+
+/* Read/write to memory block (F1, no FIFO) via CMD53 (sync only).
+ *   rw:       read or write (0/1)
+ *   addr:     direct SDIO address
+ *   buf:      pointer to memory data buffer
+ *   nbytes:   number of bytes to transfer to/from buf
+ * Returns 0 or error code.
+ */
+extern int bcmsdh_rwdata(void *sdh, uint rw, uint32 addr, uint8 * buf,
+			 uint nbytes);
+
+/* Issue an abort to the specified function */
+extern int bcmsdh_abort(void *sdh, uint fn);
+
+/* Start SDIO Host Controller communication */
+extern int bcmsdh_start(void *sdh, int stage);
+
+/* Stop SDIO Host Controller communication */
+extern int bcmsdh_stop(void *sdh);
+
+/* Returns the "Device ID" of target device on the SDIO bus. */
+extern int bcmsdh_query_device(void *sdh);
+
+/* Returns the number of IO functions reported by the device */
+extern uint bcmsdh_query_iofnum(void *sdh);
+
+/* Miscellaneous knob tweaker. */
+extern int bcmsdh_iovar_op(void *sdh, const char *name,
+			   void *params, int plen, void *arg, int len,
+			   bool set);
+
+/* Reset and reinitialize the device */
+extern int bcmsdh_reset(bcmsdh_info_t * sdh);
+
+/* helper functions */
+
+extern void *bcmsdh_get_sdioh(bcmsdh_info_t * sdh);
+
+/* callback functions */
+typedef struct {
+	/* attach to device */
+	void *(*attach) (uint16 vend_id, uint16 dev_id, uint16 bus, uint16 slot,
+			 uint16 func, uint bustype, void *regsva, osl_t * osh,
+			 void *param);
+	/* detach from device */
+	void (*detach) (void *ch);
+} bcmsdh_driver_t;
+
+/* platform specific/high level functions */
+extern int bcmsdh_register(bcmsdh_driver_t * driver);
+extern void bcmsdh_unregister(void);
+extern bool bcmsdh_chipmatch(uint16 vendor, uint16 device);
+extern void bcmsdh_device_remove(void *sdh);
+
+/* Function to pass device-status bits to DHD. */
+extern uint32 bcmsdh_get_dstatus(void *sdh);
+
+/* Function to return current window addr */
+extern uint32 bcmsdh_cur_sbwad(void *sdh);
+
+/* Function to pass chipid and rev to lower layers for controlling pr's */
+extern void bcmsdh_chipinfo(void *sdh, uint32 chip, uint32 chiprev);
+
+#endif				/* _bcmsdh_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
new file mode 100644
index 0000000..4f9efd4
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmsdh_sdmmc.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __BCMSDH_SDMMC_H__
+#define __BCMSDH_SDMMC_H__
+
+#ifdef BCMDBG
+#define sd_err(x)	do { if ((sd_msglevel & SDH_ERROR_VAL) && net_ratelimit()) printf x; } while (0)
+#define sd_trace(x)	do { if ((sd_msglevel & SDH_TRACE_VAL) && net_ratelimit()) printf x; } while (0)
+#define sd_info(x)	do { if ((sd_msglevel & SDH_INFO_VAL) && net_ratelimit()) printf x; } while (0)
+#define sd_debug(x)	do { if ((sd_msglevel & SDH_DEBUG_VAL) && net_ratelimit()) printf x; } while (0)
+#define sd_data(x)	do { if ((sd_msglevel & SDH_DATA_VAL) && net_ratelimit()) printf x; } while (0)
+#define sd_ctrl(x)	do { if ((sd_msglevel & SDH_CTRL_VAL) && net_ratelimit()) printf x; } while (0)
+#else
+#define sd_err(x)
+#define sd_trace(x)
+#define sd_info(x)
+#define sd_debug(x)
+#define sd_data(x)
+#define sd_ctrl(x)
+#endif
+
+/* Allocate/init/free per-OS private data */
+extern int sdioh_sdmmc_osinit(sdioh_info_t * sd);
+extern void sdioh_sdmmc_osfree(sdioh_info_t * sd);
+
+#define BLOCK_SIZE_64 64
+#define BLOCK_SIZE_512 512
+
+/* internal return code */
+#define SUCCESS	0
+#define ERROR	1
+
+/* private bus modes */
+#define SDIOH_MODE_SD4		2
+#define CLIENT_INTR 		0x100	/* Get rid of this! */
+
+struct sdioh_info {
+	osl_t *osh;		/* osh handler */
+	bool client_intr_enabled;	/* interrupt connnected flag */
+	bool intr_handler_valid;	/* client driver interrupt handler valid */
+	sdioh_cb_fn_t intr_handler;	/* registered interrupt handler */
+	void *intr_handler_arg;	/* argument to call interrupt handler */
+	uint16 intmask;		/* Current active interrupts */
+	void *sdos_info;	/* Pointer to per-OS private data */
+
+	uint irq;		/* Client irq */
+	int intrcount;		/* Client interrupts */
+	bool sd_use_dma;	/* DMA on CMD53 */
+	bool sd_blockmode;	/* sd_blockmode == FALSE => 64 Byte Cmd 53s. */
+	/*  Must be on for sd_multiblock to be effective */
+	bool use_client_ints;	/* If this is false, make sure to restore */
+	int sd_mode;		/* SD1/SD4/SPI */
+	int client_block_size[SDIOD_MAX_IOFUNCS];	/* Blocksize */
+	uint8 num_funcs;	/* Supported funcs on client */
+	uint32 com_cis_ptr;
+	uint32 func_cis_ptr[SDIOD_MAX_IOFUNCS];
+	uint max_dma_len;
+	uint max_dma_descriptors;	/* DMA Descriptors supported by this controller. */
+	/*	SDDMA_DESCRIPTOR	SGList[32]; *//* Scatter/Gather DMA List */
+};
+
+/************************************************************
+ * Internal interfaces: per-port references into bcmsdh_sdmmc.c
+ */
+
+/* Global message bits */
+extern uint sd_msglevel;
+
+/* OS-independent interrupt handler */
+extern bool check_client_intr(sdioh_info_t * sd);
+
+/* Core interrupt enable/disable of device interrupts */
+extern void sdioh_sdmmc_devintr_on(sdioh_info_t * sd);
+extern void sdioh_sdmmc_devintr_off(sdioh_info_t * sd);
+
+/**************************************************************
+ * Internal interfaces: bcmsdh_sdmmc.c references to per-port code
+ */
+
+/* Register mapping routines */
+extern uint32 *sdioh_sdmmc_reg_map(osl_t * osh, int32 addr, int size);
+extern void sdioh_sdmmc_reg_unmap(osl_t * osh, int32 addr, int size);
+
+/* Interrupt (de)registration routines */
+extern int sdioh_sdmmc_register_irq(sdioh_info_t * sd, uint irq);
+extern void sdioh_sdmmc_free_irq(uint irq, sdioh_info_t * sd);
+
+typedef struct _BCMSDH_SDMMC_INSTANCE {
+	sdioh_info_t *sd;
+	struct sdio_func *func[SDIOD_MAX_IOFUNCS];
+	uint32 host_claimed;
+} BCMSDH_SDMMC_INSTANCE, *PBCMSDH_SDMMC_INSTANCE;
+
+#endif				/* __BCMSDH_SDMMC_H__ */
diff --git a/drivers/staging/brcm80211/include/bcmsdpcm.h b/drivers/staging/brcm80211/include/bcmsdpcm.h
new file mode 100644
index 0000000..7937cda
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmsdpcm.h
@@ -0,0 +1,255 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmsdpcm_h_
+#define	_bcmsdpcm_h_
+
+/*
+ * Software allocation of To SB Mailbox resources
+ */
+
+/* intstatus bits */
+#define I_SMB_NAK	I_SMB_SW0	/* To SB Mailbox Frame NAK */
+#define I_SMB_INT_ACK	I_SMB_SW1	/* To SB Mailbox Host Interrupt ACK */
+#define I_SMB_USE_OOB	I_SMB_SW2	/* To SB Mailbox Use OOB Wakeup */
+#define I_SMB_DEV_INT	I_SMB_SW3	/* To SB Mailbox Miscellaneous Interrupt */
+
+#define I_TOSBMAIL      (I_SMB_NAK | I_SMB_INT_ACK | I_SMB_USE_OOB | I_SMB_DEV_INT)
+
+/* tosbmailbox bits corresponding to intstatus bits */
+#define SMB_NAK		(1 << 0)	/* To SB Mailbox Frame NAK */
+#define SMB_INT_ACK	(1 << 1)	/* To SB Mailbox Host Interrupt ACK */
+#define SMB_USE_OOB	(1 << 2)	/* To SB Mailbox Use OOB Wakeup */
+#define SMB_DEV_INT	(1 << 3)	/* To SB Mailbox Miscellaneous Interrupt */
+#define SMB_MASK	0x0000000f	/* To SB Mailbox Mask */
+
+/* tosbmailboxdata */
+#define SMB_DATA_VERSION_MASK	0x00ff0000	/* host protocol version (sent with F2 enable) */
+#define SMB_DATA_VERSION_SHIFT	16	/* host protocol version (sent with F2 enable) */
+
+/*
+ * Software allocation of To Host Mailbox resources
+ */
+
+/* intstatus bits */
+#define I_HMB_FC_STATE	I_HMB_SW0	/* To Host Mailbox Flow Control State */
+#define I_HMB_FC_CHANGE	I_HMB_SW1	/* To Host Mailbox Flow Control State Changed */
+#define I_HMB_FRAME_IND	I_HMB_SW2	/* To Host Mailbox Frame Indication */
+#define I_HMB_HOST_INT	I_HMB_SW3	/* To Host Mailbox Miscellaneous Interrupt */
+
+#define I_TOHOSTMAIL    (I_HMB_FC_CHANGE | I_HMB_FRAME_IND | I_HMB_HOST_INT)
+
+/* tohostmailbox bits corresponding to intstatus bits */
+#define HMB_FC_ON	(1 << 0)	/* To Host Mailbox Flow Control State */
+#define HMB_FC_CHANGE	(1 << 1)	/* To Host Mailbox Flow Control State Changed */
+#define HMB_FRAME_IND	(1 << 2)	/* To Host Mailbox Frame Indication */
+#define HMB_HOST_INT	(1 << 3)	/* To Host Mailbox Miscellaneous Interrupt */
+#define HMB_MASK	0x0000000f	/* To Host Mailbox Mask */
+
+/* tohostmailboxdata */
+#define HMB_DATA_NAKHANDLED	1	/* we're ready to retransmit NAK'd frame to host */
+#define HMB_DATA_DEVREADY	2	/* we're ready to to talk to host after enable */
+#define HMB_DATA_FC		4	/* per prio flowcontrol update flag to host */
+#define HMB_DATA_FWREADY	8	/* firmware is ready for protocol activity */
+
+#define HMB_DATA_FCDATA_MASK	0xff000000	/* per prio flowcontrol data */
+#define HMB_DATA_FCDATA_SHIFT	24	/* per prio flowcontrol data */
+
+#define HMB_DATA_VERSION_MASK	0x00ff0000	/* device protocol version (with devready) */
+#define HMB_DATA_VERSION_SHIFT	16	/* device protocol version (with devready) */
+
+/*
+ * Software-defined protocol header
+ */
+
+/* Current protocol version */
+#define SDPCM_PROT_VERSION	4
+
+/* SW frame header */
+#define SDPCM_SEQUENCE_MASK		0x000000ff	/* Sequence Number Mask */
+#define SDPCM_PACKET_SEQUENCE(p) (((uint8 *)p)[0] & 0xff)	/* p starts w/SW Header */
+
+#define SDPCM_CHANNEL_MASK		0x00000f00	/* Channel Number Mask */
+#define SDPCM_CHANNEL_SHIFT		8	/* Channel Number Shift */
+#define SDPCM_PACKET_CHANNEL(p) (((uint8 *)p)[1] & 0x0f)	/* p starts w/SW Header */
+
+#define SDPCM_FLAGS_MASK		0x0000f000	/* Mask of flag bits */
+#define SDPCM_FLAGS_SHIFT		12	/* Flag bits shift */
+#define SDPCM_PACKET_FLAGS(p) ((((uint8 *)p)[1] & 0xf0) >> 4)	/* p starts w/SW Header */
+
+/* Next Read Len: lookahead length of next frame, in 16-byte units (rounded up) */
+#define SDPCM_NEXTLEN_MASK		0x00ff0000	/* Next Read Len Mask */
+#define SDPCM_NEXTLEN_SHIFT		16	/* Next Read Len Shift */
+#define SDPCM_NEXTLEN_VALUE(p) ((((uint8 *)p)[2] & 0xff) << 4)	/* p starts w/SW Header */
+#define SDPCM_NEXTLEN_OFFSET		2
+
+/* Data Offset from SOF (HW Tag, SW Tag, Pad) */
+#define SDPCM_DOFFSET_OFFSET		3	/* Data Offset */
+#define SDPCM_DOFFSET_VALUE(p) 		(((uint8 *)p)[SDPCM_DOFFSET_OFFSET] & 0xff)
+#define SDPCM_DOFFSET_MASK		0xff000000
+#define SDPCM_DOFFSET_SHIFT		24
+
+#define SDPCM_FCMASK_OFFSET		4	/* Flow control */
+#define SDPCM_FCMASK_VALUE(p)		(((uint8 *)p)[SDPCM_FCMASK_OFFSET ] & 0xff)
+#define SDPCM_WINDOW_OFFSET		5	/* Credit based fc */
+#define SDPCM_WINDOW_VALUE(p)		(((uint8 *)p)[SDPCM_WINDOW_OFFSET] & 0xff)
+#define SDPCM_VERSION_OFFSET		6	/* Version # */
+#define SDPCM_VERSION_VALUE(p)		(((uint8 *)p)[SDPCM_VERSION_OFFSET] & 0xff)
+#define SDPCM_UNUSED_OFFSET		7	/* Spare */
+#define SDPCM_UNUSED_VALUE(p)		(((uint8 *)p)[SDPCM_UNUSED_OFFSET] & 0xff)
+
+#define SDPCM_SWHEADER_LEN	8	/* SW header is 64 bits */
+
+/* logical channel numbers */
+#define SDPCM_CONTROL_CHANNEL	0	/* Control Request/Response Channel Id */
+#define SDPCM_EVENT_CHANNEL	1	/* Asyc Event Indication Channel Id */
+#define SDPCM_DATA_CHANNEL	2	/* Data Xmit/Recv Channel Id */
+#define SDPCM_GLOM_CHANNEL	3	/* For coalesced packets (superframes) */
+#define SDPCM_TEST_CHANNEL	15	/* Reserved for test/debug packets */
+#define SDPCM_MAX_CHANNEL	15
+
+#define SDPCM_SEQUENCE_WRAP	256	/* wrap-around val for eight-bit frame seq number */
+
+#define SDPCM_FLAG_RESVD0	0x01
+#define SDPCM_FLAG_RESVD1	0x02
+#define SDPCM_FLAG_GSPI_TXENAB	0x04
+#define SDPCM_FLAG_GLOMDESC	0x08	/* Superframe descriptor mask */
+
+/* For GLOM_CHANNEL frames, use a flag to indicate descriptor frame */
+#define SDPCM_GLOMDESC_FLAG	(SDPCM_FLAG_GLOMDESC << SDPCM_FLAGS_SHIFT)
+
+#define SDPCM_GLOMDESC(p)	(((uint8 *)p)[1] & 0x80)
+
+/* For TEST_CHANNEL packets, define another 4-byte header */
+#define SDPCM_TEST_HDRLEN	4	/* Generally: Cmd(1), Ext(1), Len(2);
+					 * Semantics of Ext byte depend on command.
+					 * Len is current or requested frame length, not
+					 * including test header; sent little-endian.
+					 */
+#define SDPCM_TEST_DISCARD	0x01	/* Receiver discards. Ext is a pattern id. */
+#define SDPCM_TEST_ECHOREQ	0x02	/* Echo request. Ext is a pattern id. */
+#define SDPCM_TEST_ECHORSP	0x03	/* Echo response. Ext is a pattern id. */
+#define SDPCM_TEST_BURST	0x04	/* Receiver to send a burst. Ext is a frame count */
+#define SDPCM_TEST_SEND		0x05	/* Receiver sets send mode. Ext is boolean on/off */
+
+/* Handy macro for filling in datagen packets with a pattern */
+#define SDPCM_TEST_FILL(byteno, id)	((uint8)(id + byteno))
+
+/*
+ * Software counters (first part matches hardware counters)
+ */
+
+typedef volatile struct {
+	uint32 cmd52rd;		/* Cmd52RdCount, SDIO: cmd52 reads */
+	uint32 cmd52wr;		/* Cmd52WrCount, SDIO: cmd52 writes */
+	uint32 cmd53rd;		/* Cmd53RdCount, SDIO: cmd53 reads */
+	uint32 cmd53wr;		/* Cmd53WrCount, SDIO: cmd53 writes */
+	uint32 abort;		/* AbortCount, SDIO: aborts */
+	uint32 datacrcerror;	/* DataCrcErrorCount, SDIO: frames w/CRC error */
+	uint32 rdoutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Rd Frm out of sync */
+	uint32 wroutofsync;	/* RdOutOfSyncCount, SDIO/PCMCIA: Wr Frm out of sync */
+	uint32 writebusy;	/* WriteBusyCount, SDIO: device asserted "busy" */
+	uint32 readwait;	/* ReadWaitCount, SDIO: no data ready for a read cmd */
+	uint32 readterm;	/* ReadTermCount, SDIO: read frame termination cmds */
+	uint32 writeterm;	/* WriteTermCount, SDIO: write frames termination cmds */
+	uint32 rxdescuflo;	/* receive descriptor underflows */
+	uint32 rxfifooflo;	/* receive fifo overflows */
+	uint32 txfifouflo;	/* transmit fifo underflows */
+	uint32 runt;		/* runt (too short) frames recv'd from bus */
+	uint32 badlen;		/* frame's rxh len does not match its hw tag len */
+	uint32 badcksum;	/* frame's hw tag chksum doesn't agree with len value */
+	uint32 seqbreak;	/* break in sequence # space from one rx frame to the next */
+	uint32 rxfcrc;		/* frame rx header indicates crc error */
+	uint32 rxfwoos;		/* frame rx header indicates write out of sync */
+	uint32 rxfwft;		/* frame rx header indicates write frame termination */
+	uint32 rxfabort;	/* frame rx header indicates frame aborted */
+	uint32 woosint;		/* write out of sync interrupt */
+	uint32 roosint;		/* read out of sync interrupt */
+	uint32 rftermint;	/* read frame terminate interrupt */
+	uint32 wftermint;	/* write frame terminate interrupt */
+} sdpcmd_cnt_t;
+
+/*
+ * Register Access Macros
+ */
+
+#define SDIODREV_IS(var, val)	((var) == (val))
+#define SDIODREV_GE(var, val)	((var) >= (val))
+#define SDIODREV_GT(var, val)	((var) > (val))
+#define SDIODREV_LT(var, val)	((var) < (val))
+#define SDIODREV_LE(var, val)	((var) <= (val))
+
+#define SDIODDMAREG32(h, dir, chnl) \
+	((dir) == DMA_TX ? \
+	 (void *)(uintptr)&((h)->regs->dma.sdiod32.dma32regs[chnl].xmt) : \
+	 (void *)(uintptr)&((h)->regs->dma.sdiod32.dma32regs[chnl].rcv))
+
+#define SDIODDMAREG64(h, dir, chnl) \
+	((dir) == DMA_TX ? \
+	 (void *)(uintptr)&((h)->regs->dma.sdiod64.dma64regs[chnl].xmt) : \
+	 (void *)(uintptr)&((h)->regs->dma.sdiod64.dma64regs[chnl].rcv))
+
+#define SDIODDMAREG(h, dir, chnl) \
+	(SDIODREV_LT((h)->corerev, 1) ? \
+	 SDIODDMAREG32((h), (dir), (chnl)) : \
+	 SDIODDMAREG64((h), (dir), (chnl)))
+
+#define PCMDDMAREG(h, dir, chnl) \
+	((dir) == DMA_TX ? \
+	 (void *)(uintptr)&((h)->regs->dma.pcm32.dmaregs.xmt) : \
+	 (void *)(uintptr)&((h)->regs->dma.pcm32.dmaregs.rcv))
+
+#define SDPCMDMAREG(h, dir, chnl, coreid) \
+	((coreid) == SDIOD_CORE_ID ? \
+	 SDIODDMAREG(h, dir, chnl) : \
+	 PCMDDMAREG(h, dir, chnl))
+
+#define SDIODFIFOREG(h, corerev) \
+	(SDIODREV_LT((corerev), 1) ? \
+	 ((dma32diag_t *)(uintptr)&((h)->regs->dma.sdiod32.dmafifo)) : \
+	 ((dma32diag_t *)(uintptr)&((h)->regs->dma.sdiod64.dmafifo)))
+
+#define PCMDFIFOREG(h) \
+	((dma32diag_t *)(uintptr)&((h)->regs->dma.pcm32.dmafifo))
+
+#define SDPCMFIFOREG(h, coreid, corerev) \
+	((coreid) == SDIOD_CORE_ID ? \
+	 SDIODFIFOREG(h, corerev) : \
+	 PCMDFIFOREG(h))
+
+/*
+ * Shared structure between dongle and the host.
+ * The structure contains pointers to trap or assert information.
+ */
+#define SDPCM_SHARED_VERSION       0x0001
+#define SDPCM_SHARED_VERSION_MASK  0x00FF
+#define SDPCM_SHARED_ASSERT_BUILT  0x0100
+#define SDPCM_SHARED_ASSERT        0x0200
+#define SDPCM_SHARED_TRAP          0x0400
+
+typedef struct {
+	uint32 flags;
+	uint32 trap_addr;
+	uint32 assert_exp_addr;
+	uint32 assert_file_addr;
+	uint32 assert_line;
+	uint32 console_addr;	/* Address of hndrte_cons_t */
+	uint32 msgtrace_addr;
+} sdpcm_shared_t;
+
+extern sdpcm_shared_t sdpcm_shared;
+
+#endif				/* _bcmsdpcm_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsrom.h b/drivers/staging/brcm80211/include/bcmsrom.h
new file mode 100644
index 0000000..dfede70
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmsrom.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmsrom_h_
+#define	_bcmsrom_h_
+
+#include <bcmsrom_fmt.h>
+
+/* Prototypes */
+extern int srom_var_init(si_t * sih, uint bus, void *curmap, osl_t * osh,
+			 char **vars, uint * count);
+
+extern int srom_read(si_t * sih, uint bus, void *curmap, osl_t * osh,
+		     uint byteoff, uint nbytes, uint16 * buf, bool check_crc);
+
+/* parse standard PCMCIA cis, normally used by SB/PCMCIA/SDIO/SPI/OTP
+ *   and extract from it into name=value pairs
+ */
+extern int srom_parsecis(osl_t * osh, uint8 ** pcis, uint ciscnt,
+			 char **vars, uint * count);
+#endif				/* _bcmsrom_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsrom_fmt.h b/drivers/staging/brcm80211/include/bcmsrom_fmt.h
new file mode 100644
index 0000000..5ce6143
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmsrom_fmt.h
@@ -0,0 +1,367 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmsrom_fmt_h_
+#define	_bcmsrom_fmt_h_
+
+/* Maximum srom: 6 Kilobits == 768 bytes */
+#define	SROM_MAX		768
+#define SROM_MAXW		384
+#define VARS_MAX		4096
+
+/* PCI fields */
+#define PCI_F0DEVID		48
+
+#define	SROM_WORDS		64
+
+#define SROM3_SWRGN_OFF		28	/* s/w region offset in words */
+
+#define	SROM_SSID		2
+
+#define	SROM_WL1LHMAXP		29
+
+#define	SROM_WL1LPAB0		30
+#define	SROM_WL1LPAB1		31
+#define	SROM_WL1LPAB2		32
+
+#define	SROM_WL1HPAB0		33
+#define	SROM_WL1HPAB1		34
+#define	SROM_WL1HPAB2		35
+
+#define	SROM_MACHI_IL0		36
+#define	SROM_MACMID_IL0		37
+#define	SROM_MACLO_IL0		38
+#define	SROM_MACHI_ET0		39
+#define	SROM_MACMID_ET0		40
+#define	SROM_MACLO_ET0		41
+#define	SROM_MACHI_ET1		42
+#define	SROM_MACMID_ET1		43
+#define	SROM_MACLO_ET1		44
+#define	SROM3_MACHI		37
+#define	SROM3_MACMID		38
+#define	SROM3_MACLO		39
+
+#define	SROM_BXARSSI2G		40
+#define	SROM_BXARSSI5G		41
+
+#define	SROM_TRI52G		42
+#define	SROM_TRI5GHL		43
+
+#define	SROM_RXPO52G		45
+
+#define	SROM2_ENETPHY		45
+
+#define	SROM_AABREV		46
+/* Fields in AABREV */
+#define	SROM_BR_MASK		0x00ff
+#define	SROM_CC_MASK		0x0f00
+#define	SROM_CC_SHIFT		8
+#define	SROM_AA0_MASK		0x3000
+#define	SROM_AA0_SHIFT		12
+#define	SROM_AA1_MASK		0xc000
+#define	SROM_AA1_SHIFT		14
+
+#define	SROM_WL0PAB0		47
+#define	SROM_WL0PAB1		48
+#define	SROM_WL0PAB2		49
+
+#define	SROM_LEDBH10		50
+#define	SROM_LEDBH32		51
+
+#define	SROM_WL10MAXP		52
+
+#define	SROM_WL1PAB0		53
+#define	SROM_WL1PAB1		54
+#define	SROM_WL1PAB2		55
+
+#define	SROM_ITT		56
+
+#define	SROM_BFL		57
+#define	SROM_BFL2		28
+#define	SROM3_BFL2		61
+
+#define	SROM_AG10		58
+
+#define	SROM_CCODE		59
+
+#define	SROM_OPO		60
+
+#define	SROM3_LEDDC		62
+
+#define	SROM_CRCREV		63
+
+/* SROM Rev 4: Reallocate the software part of the srom to accomodate
+ * MIMO features. It assumes up to two PCIE functions and 440 bytes
+ * of useable srom i.e. the useable storage in chips with OTP that
+ * implements hardware redundancy.
+ */
+
+#define	SROM4_WORDS		220
+
+#define	SROM4_SIGN		32
+#define	SROM4_SIGNATURE		0x5372
+
+#define	SROM4_BREV		33
+
+#define	SROM4_BFL0		34
+#define	SROM4_BFL1		35
+#define	SROM4_BFL2		36
+#define	SROM4_BFL3		37
+#define	SROM5_BFL0		37
+#define	SROM5_BFL1		38
+#define	SROM5_BFL2		39
+#define	SROM5_BFL3		40
+
+#define	SROM4_MACHI		38
+#define	SROM4_MACMID		39
+#define	SROM4_MACLO		40
+#define	SROM5_MACHI		41
+#define	SROM5_MACMID		42
+#define	SROM5_MACLO		43
+
+#define	SROM4_CCODE		41
+#define	SROM4_REGREV		42
+#define	SROM5_CCODE		34
+#define	SROM5_REGREV		35
+
+#define	SROM4_LEDBH10		43
+#define	SROM4_LEDBH32		44
+#define	SROM5_LEDBH10		59
+#define	SROM5_LEDBH32		60
+
+#define	SROM4_LEDDC		45
+#define	SROM5_LEDDC		45
+
+#define	SROM4_AA		46
+#define	SROM4_AA2G_MASK		0x00ff
+#define	SROM4_AA2G_SHIFT	0
+#define	SROM4_AA5G_MASK		0xff00
+#define	SROM4_AA5G_SHIFT	8
+
+#define	SROM4_AG10		47
+#define	SROM4_AG32		48
+
+#define	SROM4_TXPID2G		49
+#define	SROM4_TXPID5G		51
+#define	SROM4_TXPID5GL		53
+#define	SROM4_TXPID5GH		55
+
+#define SROM4_TXRXC		61
+#define SROM4_TXCHAIN_MASK	0x000f
+#define SROM4_TXCHAIN_SHIFT	0
+#define SROM4_RXCHAIN_MASK	0x00f0
+#define SROM4_RXCHAIN_SHIFT	4
+#define SROM4_SWITCH_MASK	0xff00
+#define SROM4_SWITCH_SHIFT	8
+
+/* Per-path fields */
+#define	MAX_PATH_SROM		4
+#define	SROM4_PATH0		64
+#define	SROM4_PATH1		87
+#define	SROM4_PATH2		110
+#define	SROM4_PATH3		133
+
+#define	SROM4_2G_ITT_MAXP	0
+#define	SROM4_2G_PA		1
+#define	SROM4_5G_ITT_MAXP	5
+#define	SROM4_5GLH_MAXP		6
+#define	SROM4_5G_PA		7
+#define	SROM4_5GL_PA		11
+#define	SROM4_5GH_PA		15
+
+/* Fields in the ITT_MAXP and 5GLH_MAXP words */
+#define	B2G_MAXP_MASK		0xff
+#define	B2G_ITT_SHIFT		8
+#define	B5G_MAXP_MASK		0xff
+#define	B5G_ITT_SHIFT		8
+#define	B5GH_MAXP_MASK		0xff
+#define	B5GL_MAXP_SHIFT		8
+
+/* All the miriad power offsets */
+#define	SROM4_2G_CCKPO		156
+#define	SROM4_2G_OFDMPO		157
+#define	SROM4_5G_OFDMPO		159
+#define	SROM4_5GL_OFDMPO	161
+#define	SROM4_5GH_OFDMPO	163
+#define	SROM4_2G_MCSPO		165
+#define	SROM4_5G_MCSPO		173
+#define	SROM4_5GL_MCSPO		181
+#define	SROM4_5GH_MCSPO		189
+#define	SROM4_CDDPO		197
+#define	SROM4_STBCPO		198
+#define	SROM4_BW40PO		199
+#define	SROM4_BWDUPPO		200
+
+#define	SROM4_CRCREV		219
+
+/* SROM Rev 8: Make space for a 48word hardware header for PCIe rev >= 6.
+ * This is acombined srom for both MIMO and SISO boards, usable in
+ * the .130 4Kilobit OTP with hardware redundancy.
+ */
+
+#define	SROM8_SIGN		64
+
+#define	SROM8_BREV		65
+
+#define	SROM8_BFL0		66
+#define	SROM8_BFL1		67
+#define	SROM8_BFL2		68
+#define	SROM8_BFL3		69
+
+#define	SROM8_MACHI		70
+#define	SROM8_MACMID		71
+#define	SROM8_MACLO		72
+
+#define	SROM8_CCODE		73
+#define	SROM8_REGREV		74
+
+#define	SROM8_LEDBH10		75
+#define	SROM8_LEDBH32		76
+
+#define	SROM8_LEDDC		77
+
+#define	SROM8_AA		78
+
+#define	SROM8_AG10		79
+#define	SROM8_AG32		80
+
+#define	SROM8_TXRXC		81
+
+#define	SROM8_BXARSSI2G		82
+#define	SROM8_BXARSSI5G		83
+#define	SROM8_TRI52G		84
+#define	SROM8_TRI5GHL		85
+#define	SROM8_RXPO52G		86
+
+#define SROM8_FEM2G		87
+#define SROM8_FEM5G		88
+#define SROM8_FEM_ANTSWLUT_MASK		0xf800
+#define SROM8_FEM_ANTSWLUT_SHIFT	11
+#define SROM8_FEM_TR_ISO_MASK		0x0700
+#define SROM8_FEM_TR_ISO_SHIFT		8
+#define SROM8_FEM_PDET_RANGE_MASK	0x00f8
+#define SROM8_FEM_PDET_RANGE_SHIFT	3
+#define SROM8_FEM_EXTPA_GAIN_MASK	0x0006
+#define SROM8_FEM_EXTPA_GAIN_SHIFT	1
+#define SROM8_FEM_TSSIPOS_MASK		0x0001
+#define SROM8_FEM_TSSIPOS_SHIFT		0
+
+#define SROM8_THERMAL		89
+
+/* Temp sense related entries */
+#define SROM8_MPWR_RAWTS		90
+#define SROM8_TS_SLP_OPT_CORRX	91
+/* FOC: freiquency offset correction, HWIQ: H/W IOCAL enable, IQSWP: IQ CAL swap disable */
+#define SROM8_FOC_HWIQ_IQSWP	92
+
+/* Temperature delta for PHY calibration */
+#define SROM8_PHYCAL_TEMPDELTA	93
+
+/* Per-path offsets & fields */
+#define	SROM8_PATH0		96
+#define	SROM8_PATH1		112
+#define	SROM8_PATH2		128
+#define	SROM8_PATH3		144
+
+#define	SROM8_2G_ITT_MAXP	0
+#define	SROM8_2G_PA		1
+#define	SROM8_5G_ITT_MAXP	4
+#define	SROM8_5GLH_MAXP		5
+#define	SROM8_5G_PA		6
+#define	SROM8_5GL_PA		9
+#define	SROM8_5GH_PA		12
+
+/* All the miriad power offsets */
+#define	SROM8_2G_CCKPO		160
+
+#define	SROM8_2G_OFDMPO		161
+#define	SROM8_5G_OFDMPO		163
+#define	SROM8_5GL_OFDMPO	165
+#define	SROM8_5GH_OFDMPO	167
+
+#define	SROM8_2G_MCSPO		169
+#define	SROM8_5G_MCSPO		177
+#define	SROM8_5GL_MCSPO		185
+#define	SROM8_5GH_MCSPO		193
+
+#define	SROM8_CDDPO		201
+#define	SROM8_STBCPO		202
+#define	SROM8_BW40PO		203
+#define	SROM8_BWDUPPO		204
+
+/* SISO PA parameters are in the path0 spaces */
+#define	SROM8_SISO		96
+
+/* Legacy names for SISO PA paramters */
+#define	SROM8_W0_ITTMAXP	(SROM8_SISO + SROM8_2G_ITT_MAXP)
+#define	SROM8_W0_PAB0		(SROM8_SISO + SROM8_2G_PA)
+#define	SROM8_W0_PAB1		(SROM8_SISO + SROM8_2G_PA + 1)
+#define	SROM8_W0_PAB2		(SROM8_SISO + SROM8_2G_PA + 2)
+#define	SROM8_W1_ITTMAXP	(SROM8_SISO + SROM8_5G_ITT_MAXP)
+#define	SROM8_W1_MAXP_LCHC	(SROM8_SISO + SROM8_5GLH_MAXP)
+#define	SROM8_W1_PAB0		(SROM8_SISO + SROM8_5G_PA)
+#define	SROM8_W1_PAB1		(SROM8_SISO + SROM8_5G_PA + 1)
+#define	SROM8_W1_PAB2		(SROM8_SISO + SROM8_5G_PA + 2)
+#define	SROM8_W1_PAB0_LC	(SROM8_SISO + SROM8_5GL_PA)
+#define	SROM8_W1_PAB1_LC	(SROM8_SISO + SROM8_5GL_PA + 1)
+#define	SROM8_W1_PAB2_LC	(SROM8_SISO + SROM8_5GL_PA + 2)
+#define	SROM8_W1_PAB0_HC	(SROM8_SISO + SROM8_5GH_PA)
+#define	SROM8_W1_PAB1_HC	(SROM8_SISO + SROM8_5GH_PA + 1)
+#define	SROM8_W1_PAB2_HC	(SROM8_SISO + SROM8_5GH_PA + 2)
+
+#define	SROM8_CRCREV		219
+
+/* SROM REV 9 */
+#define SROM9_2GPO_CCKBW20	160
+#define SROM9_2GPO_CCKBW20UL	161
+#define SROM9_2GPO_LOFDMBW20	162
+#define SROM9_2GPO_LOFDMBW20UL	164
+
+#define SROM9_5GLPO_LOFDMBW20	166
+#define SROM9_5GLPO_LOFDMBW20UL	168
+#define SROM9_5GMPO_LOFDMBW20	170
+#define SROM9_5GMPO_LOFDMBW20UL	172
+#define SROM9_5GHPO_LOFDMBW20	174
+#define SROM9_5GHPO_LOFDMBW20UL	176
+
+#define SROM9_2GPO_MCSBW20	178
+#define SROM9_2GPO_MCSBW20UL	180
+#define SROM9_2GPO_MCSBW40	182
+
+#define SROM9_5GLPO_MCSBW20	184
+#define SROM9_5GLPO_MCSBW20UL	186
+#define SROM9_5GLPO_MCSBW40	188
+#define SROM9_5GMPO_MCSBW20	190
+#define SROM9_5GMPO_MCSBW20UL	192
+#define SROM9_5GMPO_MCSBW40	194
+#define SROM9_5GHPO_MCSBW20	196
+#define SROM9_5GHPO_MCSBW20UL	198
+#define SROM9_5GHPO_MCSBW40	200
+
+#define SROM9_PO_MCS32		202
+#define SROM9_PO_LOFDM40DUP	203
+
+#define SROM9_REV_CRC		219
+
+typedef struct {
+	uint8 tssipos;		/* TSSI positive slope, 1: positive, 0: negative */
+	uint8 extpagain;	/* Ext PA gain-type: full-gain: 0, pa-lite: 1, no_pa: 2 */
+	uint8 pdetrange;	/* support 32 combinations of different Pdet dynamic ranges */
+	uint8 triso;		/* TR switch isolation */
+	uint8 antswctrllut;	/* antswctrl lookup table configuration: 32 possible choices */
+} srom_fem_t;
+
+#endif				/* _bcmsrom_fmt_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmsrom_tbl.h b/drivers/staging/brcm80211/include/bcmsrom_tbl.h
new file mode 100644
index 0000000..646126f
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmsrom_tbl.h
@@ -0,0 +1,583 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmsrom_tbl_h_
+#define	_bcmsrom_tbl_h_
+
+#include "sbpcmcia.h"
+#include "wlioctl.h"
+
+typedef struct {
+	const char *name;
+	uint32 revmask;
+	uint32 flags;
+	uint16 off;
+	uint16 mask;
+} sromvar_t;
+
+#define SRFL_MORE	1	/* value continues as described by the next entry */
+#define	SRFL_NOFFS	2	/* value bits can't be all one's */
+#define	SRFL_PRHEX	4	/* value is in hexdecimal format */
+#define	SRFL_PRSIGN	8	/* value is in signed decimal format */
+#define	SRFL_CCODE	0x10	/* value is in country code format */
+#define	SRFL_ETHADDR	0x20	/* value is an Ethernet address */
+#define SRFL_LEDDC	0x40	/* value is an LED duty cycle */
+#define SRFL_NOVAR	0x80	/* do not generate a nvram param, entry is for mfgc */
+
+/* Assumptions:
+ * - Ethernet address spans across 3 consective words
+ *
+ * Table rules:
+ * - Add multiple entries next to each other if a value spans across multiple words
+ *   (even multiple fields in the same word) with each entry except the last having
+ *   it's SRFL_MORE bit set.
+ * - Ethernet address entry does not follow above rule and must not have SRFL_MORE
+ *   bit set. Its SRFL_ETHADDR bit implies it takes multiple words.
+ * - The last entry's name field must be NULL to indicate the end of the table. Other
+ *   entries must have non-NULL name.
+ */
+
+static const sromvar_t pci_sromvars[] = {
+	{"devid", 0xffffff00, SRFL_PRHEX | SRFL_NOVAR, PCI_F0DEVID, 0xffff},
+	{"boardrev", 0x0000000e, SRFL_PRHEX, SROM_AABREV, SROM_BR_MASK},
+	{"boardrev", 0x000000f0, SRFL_PRHEX, SROM4_BREV, 0xffff},
+	{"boardrev", 0xffffff00, SRFL_PRHEX, SROM8_BREV, 0xffff},
+	{"boardflags", 0x00000002, SRFL_PRHEX, SROM_BFL, 0xffff},
+	{"boardflags", 0x00000004, SRFL_PRHEX | SRFL_MORE, SROM_BFL, 0xffff},
+	{"", 0, 0, SROM_BFL2, 0xffff},
+	{"boardflags", 0x00000008, SRFL_PRHEX | SRFL_MORE, SROM_BFL, 0xffff},
+	{"", 0, 0, SROM3_BFL2, 0xffff},
+	{"boardflags", 0x00000010, SRFL_PRHEX | SRFL_MORE, SROM4_BFL0, 0xffff},
+	{"", 0, 0, SROM4_BFL1, 0xffff},
+	{"boardflags", 0x000000e0, SRFL_PRHEX | SRFL_MORE, SROM5_BFL0, 0xffff},
+	{"", 0, 0, SROM5_BFL1, 0xffff},
+	{"boardflags", 0xffffff00, SRFL_PRHEX | SRFL_MORE, SROM8_BFL0, 0xffff},
+	{"", 0, 0, SROM8_BFL1, 0xffff},
+	{"boardflags2", 0x00000010, SRFL_PRHEX | SRFL_MORE, SROM4_BFL2, 0xffff},
+	{"", 0, 0, SROM4_BFL3, 0xffff},
+	{"boardflags2", 0x000000e0, SRFL_PRHEX | SRFL_MORE, SROM5_BFL2, 0xffff},
+	{"", 0, 0, SROM5_BFL3, 0xffff},
+	{"boardflags2", 0xffffff00, SRFL_PRHEX | SRFL_MORE, SROM8_BFL2, 0xffff},
+	{"", 0, 0, SROM8_BFL3, 0xffff},
+	{"boardtype", 0xfffffffc, SRFL_PRHEX, SROM_SSID, 0xffff},
+	{"boardnum", 0x00000006, 0, SROM_MACLO_IL0, 0xffff},
+	{"boardnum", 0x00000008, 0, SROM3_MACLO, 0xffff},
+	{"boardnum", 0x00000010, 0, SROM4_MACLO, 0xffff},
+	{"boardnum", 0x000000e0, 0, SROM5_MACLO, 0xffff},
+	{"boardnum", 0xffffff00, 0, SROM8_MACLO, 0xffff},
+	{"cc", 0x00000002, 0, SROM_AABREV, SROM_CC_MASK},
+	{"regrev", 0x00000008, 0, SROM_OPO, 0xff00},
+	{"regrev", 0x00000010, 0, SROM4_REGREV, 0x00ff},
+	{"regrev", 0x000000e0, 0, SROM5_REGREV, 0x00ff},
+	{"regrev", 0xffffff00, 0, SROM8_REGREV, 0x00ff},
+	{"ledbh0", 0x0000000e, SRFL_NOFFS, SROM_LEDBH10, 0x00ff},
+	{"ledbh1", 0x0000000e, SRFL_NOFFS, SROM_LEDBH10, 0xff00},
+	{"ledbh2", 0x0000000e, SRFL_NOFFS, SROM_LEDBH32, 0x00ff},
+	{"ledbh3", 0x0000000e, SRFL_NOFFS, SROM_LEDBH32, 0xff00},
+	{"ledbh0", 0x00000010, SRFL_NOFFS, SROM4_LEDBH10, 0x00ff},
+	{"ledbh1", 0x00000010, SRFL_NOFFS, SROM4_LEDBH10, 0xff00},
+	{"ledbh2", 0x00000010, SRFL_NOFFS, SROM4_LEDBH32, 0x00ff},
+	{"ledbh3", 0x00000010, SRFL_NOFFS, SROM4_LEDBH32, 0xff00},
+	{"ledbh0", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH10, 0x00ff},
+	{"ledbh1", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH10, 0xff00},
+	{"ledbh2", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH32, 0x00ff},
+	{"ledbh3", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH32, 0xff00},
+	{"ledbh0", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH10, 0x00ff},
+	{"ledbh1", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH10, 0xff00},
+	{"ledbh2", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH32, 0x00ff},
+	{"ledbh3", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH32, 0xff00},
+	{"pa0b0", 0x0000000e, SRFL_PRHEX, SROM_WL0PAB0, 0xffff},
+	{"pa0b1", 0x0000000e, SRFL_PRHEX, SROM_WL0PAB1, 0xffff},
+	{"pa0b2", 0x0000000e, SRFL_PRHEX, SROM_WL0PAB2, 0xffff},
+	{"pa0itssit", 0x0000000e, 0, SROM_ITT, 0x00ff},
+	{"pa0maxpwr", 0x0000000e, 0, SROM_WL10MAXP, 0x00ff},
+	{"pa0b0", 0xffffff00, SRFL_PRHEX, SROM8_W0_PAB0, 0xffff},
+	{"pa0b1", 0xffffff00, SRFL_PRHEX, SROM8_W0_PAB1, 0xffff},
+	{"pa0b2", 0xffffff00, SRFL_PRHEX, SROM8_W0_PAB2, 0xffff},
+	{"pa0itssit", 0xffffff00, 0, SROM8_W0_ITTMAXP, 0xff00},
+	{"pa0maxpwr", 0xffffff00, 0, SROM8_W0_ITTMAXP, 0x00ff},
+	{"opo", 0x0000000c, 0, SROM_OPO, 0x00ff},
+	{"opo", 0xffffff00, 0, SROM8_2G_OFDMPO, 0x00ff},
+	{"aa2g", 0x0000000e, 0, SROM_AABREV, SROM_AA0_MASK},
+	{"aa2g", 0x000000f0, 0, SROM4_AA, 0x00ff},
+	{"aa2g", 0xffffff00, 0, SROM8_AA, 0x00ff},
+	{"aa5g", 0x0000000e, 0, SROM_AABREV, SROM_AA1_MASK},
+	{"aa5g", 0x000000f0, 0, SROM4_AA, 0xff00},
+	{"aa5g", 0xffffff00, 0, SROM8_AA, 0xff00},
+	{"ag0", 0x0000000e, 0, SROM_AG10, 0x00ff},
+	{"ag1", 0x0000000e, 0, SROM_AG10, 0xff00},
+	{"ag0", 0x000000f0, 0, SROM4_AG10, 0x00ff},
+	{"ag1", 0x000000f0, 0, SROM4_AG10, 0xff00},
+	{"ag2", 0x000000f0, 0, SROM4_AG32, 0x00ff},
+	{"ag3", 0x000000f0, 0, SROM4_AG32, 0xff00},
+	{"ag0", 0xffffff00, 0, SROM8_AG10, 0x00ff},
+	{"ag1", 0xffffff00, 0, SROM8_AG10, 0xff00},
+	{"ag2", 0xffffff00, 0, SROM8_AG32, 0x00ff},
+	{"ag3", 0xffffff00, 0, SROM8_AG32, 0xff00},
+	{"pa1b0", 0x0000000e, SRFL_PRHEX, SROM_WL1PAB0, 0xffff},
+	{"pa1b1", 0x0000000e, SRFL_PRHEX, SROM_WL1PAB1, 0xffff},
+	{"pa1b2", 0x0000000e, SRFL_PRHEX, SROM_WL1PAB2, 0xffff},
+	{"pa1lob0", 0x0000000c, SRFL_PRHEX, SROM_WL1LPAB0, 0xffff},
+	{"pa1lob1", 0x0000000c, SRFL_PRHEX, SROM_WL1LPAB1, 0xffff},
+	{"pa1lob2", 0x0000000c, SRFL_PRHEX, SROM_WL1LPAB2, 0xffff},
+	{"pa1hib0", 0x0000000c, SRFL_PRHEX, SROM_WL1HPAB0, 0xffff},
+	{"pa1hib1", 0x0000000c, SRFL_PRHEX, SROM_WL1HPAB1, 0xffff},
+	{"pa1hib2", 0x0000000c, SRFL_PRHEX, SROM_WL1HPAB2, 0xffff},
+	{"pa1itssit", 0x0000000e, 0, SROM_ITT, 0xff00},
+	{"pa1maxpwr", 0x0000000e, 0, SROM_WL10MAXP, 0xff00},
+	{"pa1lomaxpwr", 0x0000000c, 0, SROM_WL1LHMAXP, 0xff00},
+	{"pa1himaxpwr", 0x0000000c, 0, SROM_WL1LHMAXP, 0x00ff},
+	{"pa1b0", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB0, 0xffff},
+	{"pa1b1", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB1, 0xffff},
+	{"pa1b2", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB2, 0xffff},
+	{"pa1lob0", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB0_LC, 0xffff},
+	{"pa1lob1", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB1_LC, 0xffff},
+	{"pa1lob2", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB2_LC, 0xffff},
+	{"pa1hib0", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB0_HC, 0xffff},
+	{"pa1hib1", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB1_HC, 0xffff},
+	{"pa1hib2", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB2_HC, 0xffff},
+	{"pa1itssit", 0xffffff00, 0, SROM8_W1_ITTMAXP, 0xff00},
+	{"pa1maxpwr", 0xffffff00, 0, SROM8_W1_ITTMAXP, 0x00ff},
+	{"pa1lomaxpwr", 0xffffff00, 0, SROM8_W1_MAXP_LCHC, 0xff00},
+	{"pa1himaxpwr", 0xffffff00, 0, SROM8_W1_MAXP_LCHC, 0x00ff},
+	{"bxa2g", 0x00000008, 0, SROM_BXARSSI2G, 0x1800},
+	{"rssisav2g", 0x00000008, 0, SROM_BXARSSI2G, 0x0700},
+	{"rssismc2g", 0x00000008, 0, SROM_BXARSSI2G, 0x00f0},
+	{"rssismf2g", 0x00000008, 0, SROM_BXARSSI2G, 0x000f},
+	{"bxa2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x1800},
+	{"rssisav2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x0700},
+	{"rssismc2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x00f0},
+	{"rssismf2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x000f},
+	{"bxa5g", 0x00000008, 0, SROM_BXARSSI5G, 0x1800},
+	{"rssisav5g", 0x00000008, 0, SROM_BXARSSI5G, 0x0700},
+	{"rssismc5g", 0x00000008, 0, SROM_BXARSSI5G, 0x00f0},
+	{"rssismf5g", 0x00000008, 0, SROM_BXARSSI5G, 0x000f},
+	{"bxa5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x1800},
+	{"rssisav5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x0700},
+	{"rssismc5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x00f0},
+	{"rssismf5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x000f},
+	{"tri2g", 0x00000008, 0, SROM_TRI52G, 0x00ff},
+	{"tri5g", 0x00000008, 0, SROM_TRI52G, 0xff00},
+	{"tri5gl", 0x00000008, 0, SROM_TRI5GHL, 0x00ff},
+	{"tri5gh", 0x00000008, 0, SROM_TRI5GHL, 0xff00},
+	{"tri2g", 0xffffff00, 0, SROM8_TRI52G, 0x00ff},
+	{"tri5g", 0xffffff00, 0, SROM8_TRI52G, 0xff00},
+	{"tri5gl", 0xffffff00, 0, SROM8_TRI5GHL, 0x00ff},
+	{"tri5gh", 0xffffff00, 0, SROM8_TRI5GHL, 0xff00},
+	{"rxpo2g", 0x00000008, SRFL_PRSIGN, SROM_RXPO52G, 0x00ff},
+	{"rxpo5g", 0x00000008, SRFL_PRSIGN, SROM_RXPO52G, 0xff00},
+	{"rxpo2g", 0xffffff00, SRFL_PRSIGN, SROM8_RXPO52G, 0x00ff},
+	{"rxpo5g", 0xffffff00, SRFL_PRSIGN, SROM8_RXPO52G, 0xff00},
+	{"txchain", 0x000000f0, SRFL_NOFFS, SROM4_TXRXC, SROM4_TXCHAIN_MASK},
+	{"rxchain", 0x000000f0, SRFL_NOFFS, SROM4_TXRXC, SROM4_RXCHAIN_MASK},
+	{"antswitch", 0x000000f0, SRFL_NOFFS, SROM4_TXRXC, SROM4_SWITCH_MASK},
+	{"txchain", 0xffffff00, SRFL_NOFFS, SROM8_TXRXC, SROM4_TXCHAIN_MASK},
+	{"rxchain", 0xffffff00, SRFL_NOFFS, SROM8_TXRXC, SROM4_RXCHAIN_MASK},
+	{"antswitch", 0xffffff00, SRFL_NOFFS, SROM8_TXRXC, SROM4_SWITCH_MASK},
+	{"tssipos2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_TSSIPOS_MASK},
+	{"extpagain2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_EXTPA_GAIN_MASK},
+	{"pdetrange2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_PDET_RANGE_MASK},
+	{"triso2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_TR_ISO_MASK},
+	{"antswctl2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_ANTSWLUT_MASK},
+	{"tssipos5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_TSSIPOS_MASK},
+	{"extpagain5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_EXTPA_GAIN_MASK},
+	{"pdetrange5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_PDET_RANGE_MASK},
+	{"triso5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_TR_ISO_MASK},
+	{"antswctl5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_ANTSWLUT_MASK},
+	{"tempthresh", 0xffffff00, 0, SROM8_THERMAL, 0xff00},
+	{"tempoffset", 0xffffff00, 0, SROM8_THERMAL, 0x00ff},
+	{"txpid2ga0", 0x000000f0, 0, SROM4_TXPID2G, 0x00ff},
+	{"txpid2ga1", 0x000000f0, 0, SROM4_TXPID2G, 0xff00},
+	{"txpid2ga2", 0x000000f0, 0, SROM4_TXPID2G + 1, 0x00ff},
+	{"txpid2ga3", 0x000000f0, 0, SROM4_TXPID2G + 1, 0xff00},
+	{"txpid5ga0", 0x000000f0, 0, SROM4_TXPID5G, 0x00ff},
+	{"txpid5ga1", 0x000000f0, 0, SROM4_TXPID5G, 0xff00},
+	{"txpid5ga2", 0x000000f0, 0, SROM4_TXPID5G + 1, 0x00ff},
+	{"txpid5ga3", 0x000000f0, 0, SROM4_TXPID5G + 1, 0xff00},
+	{"txpid5gla0", 0x000000f0, 0, SROM4_TXPID5GL, 0x00ff},
+	{"txpid5gla1", 0x000000f0, 0, SROM4_TXPID5GL, 0xff00},
+	{"txpid5gla2", 0x000000f0, 0, SROM4_TXPID5GL + 1, 0x00ff},
+	{"txpid5gla3", 0x000000f0, 0, SROM4_TXPID5GL + 1, 0xff00},
+	{"txpid5gha0", 0x000000f0, 0, SROM4_TXPID5GH, 0x00ff},
+	{"txpid5gha1", 0x000000f0, 0, SROM4_TXPID5GH, 0xff00},
+	{"txpid5gha2", 0x000000f0, 0, SROM4_TXPID5GH + 1, 0x00ff},
+	{"txpid5gha3", 0x000000f0, 0, SROM4_TXPID5GH + 1, 0xff00},
+
+	{"ccode", 0x0000000f, SRFL_CCODE, SROM_CCODE, 0xffff},
+	{"ccode", 0x00000010, SRFL_CCODE, SROM4_CCODE, 0xffff},
+	{"ccode", 0x000000e0, SRFL_CCODE, SROM5_CCODE, 0xffff},
+	{"ccode", 0xffffff00, SRFL_CCODE, SROM8_CCODE, 0xffff},
+	{"macaddr", 0xffffff00, SRFL_ETHADDR, SROM8_MACHI, 0xffff},
+	{"macaddr", 0x000000e0, SRFL_ETHADDR, SROM5_MACHI, 0xffff},
+	{"macaddr", 0x00000010, SRFL_ETHADDR, SROM4_MACHI, 0xffff},
+	{"macaddr", 0x00000008, SRFL_ETHADDR, SROM3_MACHI, 0xffff},
+	{"il0macaddr", 0x00000007, SRFL_ETHADDR, SROM_MACHI_IL0, 0xffff},
+	{"et1macaddr", 0x00000007, SRFL_ETHADDR, SROM_MACHI_ET1, 0xffff},
+	{"leddc", 0xffffff00, SRFL_NOFFS | SRFL_LEDDC, SROM8_LEDDC, 0xffff},
+	{"leddc", 0x000000e0, SRFL_NOFFS | SRFL_LEDDC, SROM5_LEDDC, 0xffff},
+	{"leddc", 0x00000010, SRFL_NOFFS | SRFL_LEDDC, SROM4_LEDDC, 0xffff},
+	{"leddc", 0x00000008, SRFL_NOFFS | SRFL_LEDDC, SROM3_LEDDC, 0xffff},
+	{"rawtempsense", 0xffffff00, SRFL_PRHEX, SROM8_MPWR_RAWTS, 0x01ff},
+	{"measpower", 0xffffff00, SRFL_PRHEX, SROM8_MPWR_RAWTS, 0xfe00},
+	{"tempsense_slope", 0xffffff00, SRFL_PRHEX, SROM8_TS_SLP_OPT_CORRX,
+	 0x00ff},
+	{"tempcorrx", 0xffffff00, SRFL_PRHEX, SROM8_TS_SLP_OPT_CORRX, 0xfc00},
+	{"tempsense_option", 0xffffff00, SRFL_PRHEX, SROM8_TS_SLP_OPT_CORRX,
+	 0x0300},
+	{"freqoffset_corr", 0xffffff00, SRFL_PRHEX, SROM8_FOC_HWIQ_IQSWP,
+	 0x000f},
+	{"iqcal_swp_dis", 0xffffff00, SRFL_PRHEX, SROM8_FOC_HWIQ_IQSWP, 0x0010},
+	{"hw_iqcal_en", 0xffffff00, SRFL_PRHEX, SROM8_FOC_HWIQ_IQSWP, 0x0020},
+	{"phycal_tempdelta", 0xffffff00, 0, SROM8_PHYCAL_TEMPDELTA, 0x00ff},
+
+	{"cck2gpo", 0x000000f0, 0, SROM4_2G_CCKPO, 0xffff},
+	{"cck2gpo", 0x00000100, 0, SROM8_2G_CCKPO, 0xffff},
+	{"ofdm2gpo", 0x000000f0, SRFL_MORE, SROM4_2G_OFDMPO, 0xffff},
+	{"", 0, 0, SROM4_2G_OFDMPO + 1, 0xffff},
+	{"ofdm5gpo", 0x000000f0, SRFL_MORE, SROM4_5G_OFDMPO, 0xffff},
+	{"", 0, 0, SROM4_5G_OFDMPO + 1, 0xffff},
+	{"ofdm5glpo", 0x000000f0, SRFL_MORE, SROM4_5GL_OFDMPO, 0xffff},
+	{"", 0, 0, SROM4_5GL_OFDMPO + 1, 0xffff},
+	{"ofdm5ghpo", 0x000000f0, SRFL_MORE, SROM4_5GH_OFDMPO, 0xffff},
+	{"", 0, 0, SROM4_5GH_OFDMPO + 1, 0xffff},
+	{"ofdm2gpo", 0x00000100, SRFL_MORE, SROM8_2G_OFDMPO, 0xffff},
+	{"", 0, 0, SROM8_2G_OFDMPO + 1, 0xffff},
+	{"ofdm5gpo", 0x00000100, SRFL_MORE, SROM8_5G_OFDMPO, 0xffff},
+	{"", 0, 0, SROM8_5G_OFDMPO + 1, 0xffff},
+	{"ofdm5glpo", 0x00000100, SRFL_MORE, SROM8_5GL_OFDMPO, 0xffff},
+	{"", 0, 0, SROM8_5GL_OFDMPO + 1, 0xffff},
+	{"ofdm5ghpo", 0x00000100, SRFL_MORE, SROM8_5GH_OFDMPO, 0xffff},
+	{"", 0, 0, SROM8_5GH_OFDMPO + 1, 0xffff},
+	{"mcs2gpo0", 0x000000f0, 0, SROM4_2G_MCSPO, 0xffff},
+	{"mcs2gpo1", 0x000000f0, 0, SROM4_2G_MCSPO + 1, 0xffff},
+	{"mcs2gpo2", 0x000000f0, 0, SROM4_2G_MCSPO + 2, 0xffff},
+	{"mcs2gpo3", 0x000000f0, 0, SROM4_2G_MCSPO + 3, 0xffff},
+	{"mcs2gpo4", 0x000000f0, 0, SROM4_2G_MCSPO + 4, 0xffff},
+	{"mcs2gpo5", 0x000000f0, 0, SROM4_2G_MCSPO + 5, 0xffff},
+	{"mcs2gpo6", 0x000000f0, 0, SROM4_2G_MCSPO + 6, 0xffff},
+	{"mcs2gpo7", 0x000000f0, 0, SROM4_2G_MCSPO + 7, 0xffff},
+	{"mcs5gpo0", 0x000000f0, 0, SROM4_5G_MCSPO, 0xffff},
+	{"mcs5gpo1", 0x000000f0, 0, SROM4_5G_MCSPO + 1, 0xffff},
+	{"mcs5gpo2", 0x000000f0, 0, SROM4_5G_MCSPO + 2, 0xffff},
+	{"mcs5gpo3", 0x000000f0, 0, SROM4_5G_MCSPO + 3, 0xffff},
+	{"mcs5gpo4", 0x000000f0, 0, SROM4_5G_MCSPO + 4, 0xffff},
+	{"mcs5gpo5", 0x000000f0, 0, SROM4_5G_MCSPO + 5, 0xffff},
+	{"mcs5gpo6", 0x000000f0, 0, SROM4_5G_MCSPO + 6, 0xffff},
+	{"mcs5gpo7", 0x000000f0, 0, SROM4_5G_MCSPO + 7, 0xffff},
+	{"mcs5glpo0", 0x000000f0, 0, SROM4_5GL_MCSPO, 0xffff},
+	{"mcs5glpo1", 0x000000f0, 0, SROM4_5GL_MCSPO + 1, 0xffff},
+	{"mcs5glpo2", 0x000000f0, 0, SROM4_5GL_MCSPO + 2, 0xffff},
+	{"mcs5glpo3", 0x000000f0, 0, SROM4_5GL_MCSPO + 3, 0xffff},
+	{"mcs5glpo4", 0x000000f0, 0, SROM4_5GL_MCSPO + 4, 0xffff},
+	{"mcs5glpo5", 0x000000f0, 0, SROM4_5GL_MCSPO + 5, 0xffff},
+	{"mcs5glpo6", 0x000000f0, 0, SROM4_5GL_MCSPO + 6, 0xffff},
+	{"mcs5glpo7", 0x000000f0, 0, SROM4_5GL_MCSPO + 7, 0xffff},
+	{"mcs5ghpo0", 0x000000f0, 0, SROM4_5GH_MCSPO, 0xffff},
+	{"mcs5ghpo1", 0x000000f0, 0, SROM4_5GH_MCSPO + 1, 0xffff},
+	{"mcs5ghpo2", 0x000000f0, 0, SROM4_5GH_MCSPO + 2, 0xffff},
+	{"mcs5ghpo3", 0x000000f0, 0, SROM4_5GH_MCSPO + 3, 0xffff},
+	{"mcs5ghpo4", 0x000000f0, 0, SROM4_5GH_MCSPO + 4, 0xffff},
+	{"mcs5ghpo5", 0x000000f0, 0, SROM4_5GH_MCSPO + 5, 0xffff},
+	{"mcs5ghpo6", 0x000000f0, 0, SROM4_5GH_MCSPO + 6, 0xffff},
+	{"mcs5ghpo7", 0x000000f0, 0, SROM4_5GH_MCSPO + 7, 0xffff},
+	{"mcs2gpo0", 0x00000100, 0, SROM8_2G_MCSPO, 0xffff},
+	{"mcs2gpo1", 0x00000100, 0, SROM8_2G_MCSPO + 1, 0xffff},
+	{"mcs2gpo2", 0x00000100, 0, SROM8_2G_MCSPO + 2, 0xffff},
+	{"mcs2gpo3", 0x00000100, 0, SROM8_2G_MCSPO + 3, 0xffff},
+	{"mcs2gpo4", 0x00000100, 0, SROM8_2G_MCSPO + 4, 0xffff},
+	{"mcs2gpo5", 0x00000100, 0, SROM8_2G_MCSPO + 5, 0xffff},
+	{"mcs2gpo6", 0x00000100, 0, SROM8_2G_MCSPO + 6, 0xffff},
+	{"mcs2gpo7", 0x00000100, 0, SROM8_2G_MCSPO + 7, 0xffff},
+	{"mcs5gpo0", 0x00000100, 0, SROM8_5G_MCSPO, 0xffff},
+	{"mcs5gpo1", 0x00000100, 0, SROM8_5G_MCSPO + 1, 0xffff},
+	{"mcs5gpo2", 0x00000100, 0, SROM8_5G_MCSPO + 2, 0xffff},
+	{"mcs5gpo3", 0x00000100, 0, SROM8_5G_MCSPO + 3, 0xffff},
+	{"mcs5gpo4", 0x00000100, 0, SROM8_5G_MCSPO + 4, 0xffff},
+	{"mcs5gpo5", 0x00000100, 0, SROM8_5G_MCSPO + 5, 0xffff},
+	{"mcs5gpo6", 0x00000100, 0, SROM8_5G_MCSPO + 6, 0xffff},
+	{"mcs5gpo7", 0x00000100, 0, SROM8_5G_MCSPO + 7, 0xffff},
+	{"mcs5glpo0", 0x00000100, 0, SROM8_5GL_MCSPO, 0xffff},
+	{"mcs5glpo1", 0x00000100, 0, SROM8_5GL_MCSPO + 1, 0xffff},
+	{"mcs5glpo2", 0x00000100, 0, SROM8_5GL_MCSPO + 2, 0xffff},
+	{"mcs5glpo3", 0x00000100, 0, SROM8_5GL_MCSPO + 3, 0xffff},
+	{"mcs5glpo4", 0x00000100, 0, SROM8_5GL_MCSPO + 4, 0xffff},
+	{"mcs5glpo5", 0x00000100, 0, SROM8_5GL_MCSPO + 5, 0xffff},
+	{"mcs5glpo6", 0x00000100, 0, SROM8_5GL_MCSPO + 6, 0xffff},
+	{"mcs5glpo7", 0x00000100, 0, SROM8_5GL_MCSPO + 7, 0xffff},
+	{"mcs5ghpo0", 0x00000100, 0, SROM8_5GH_MCSPO, 0xffff},
+	{"mcs5ghpo1", 0x00000100, 0, SROM8_5GH_MCSPO + 1, 0xffff},
+	{"mcs5ghpo2", 0x00000100, 0, SROM8_5GH_MCSPO + 2, 0xffff},
+	{"mcs5ghpo3", 0x00000100, 0, SROM8_5GH_MCSPO + 3, 0xffff},
+	{"mcs5ghpo4", 0x00000100, 0, SROM8_5GH_MCSPO + 4, 0xffff},
+	{"mcs5ghpo5", 0x00000100, 0, SROM8_5GH_MCSPO + 5, 0xffff},
+	{"mcs5ghpo6", 0x00000100, 0, SROM8_5GH_MCSPO + 6, 0xffff},
+	{"mcs5ghpo7", 0x00000100, 0, SROM8_5GH_MCSPO + 7, 0xffff},
+	{"cddpo", 0x000000f0, 0, SROM4_CDDPO, 0xffff},
+	{"stbcpo", 0x000000f0, 0, SROM4_STBCPO, 0xffff},
+	{"bw40po", 0x000000f0, 0, SROM4_BW40PO, 0xffff},
+	{"bwduppo", 0x000000f0, 0, SROM4_BWDUPPO, 0xffff},
+	{"cddpo", 0x00000100, 0, SROM8_CDDPO, 0xffff},
+	{"stbcpo", 0x00000100, 0, SROM8_STBCPO, 0xffff},
+	{"bw40po", 0x00000100, 0, SROM8_BW40PO, 0xffff},
+	{"bwduppo", 0x00000100, 0, SROM8_BWDUPPO, 0xffff},
+
+	/* power per rate from sromrev 9 */
+	{"cckbw202gpo", 0xfffffe00, 0, SROM9_2GPO_CCKBW20, 0xffff},
+	{"cckbw20ul2gpo", 0xfffffe00, 0, SROM9_2GPO_CCKBW20UL, 0xffff},
+	{"legofdmbw202gpo", 0xfffffe00, SRFL_MORE, SROM9_2GPO_LOFDMBW20,
+	 0xffff},
+	{"", 0, 0, SROM9_2GPO_LOFDMBW20 + 1, 0xffff},
+	{"legofdmbw20ul2gpo", 0xfffffe00, SRFL_MORE, SROM9_2GPO_LOFDMBW20UL,
+	 0xffff},
+	{"", 0, 0, SROM9_2GPO_LOFDMBW20UL + 1, 0xffff},
+	{"legofdmbw205glpo", 0xfffffe00, SRFL_MORE, SROM9_5GLPO_LOFDMBW20,
+	 0xffff},
+	{"", 0, 0, SROM9_5GLPO_LOFDMBW20 + 1, 0xffff},
+	{"legofdmbw20ul5glpo", 0xfffffe00, SRFL_MORE, SROM9_5GLPO_LOFDMBW20UL,
+	 0xffff},
+	{"", 0, 0, SROM9_5GLPO_LOFDMBW20UL + 1, 0xffff},
+	{"legofdmbw205gmpo", 0xfffffe00, SRFL_MORE, SROM9_5GMPO_LOFDMBW20,
+	 0xffff},
+	{"", 0, 0, SROM9_5GMPO_LOFDMBW20 + 1, 0xffff},
+	{"legofdmbw20ul5gmpo", 0xfffffe00, SRFL_MORE, SROM9_5GMPO_LOFDMBW20UL,
+	 0xffff},
+	{"", 0, 0, SROM9_5GMPO_LOFDMBW20UL + 1, 0xffff},
+	{"legofdmbw205ghpo", 0xfffffe00, SRFL_MORE, SROM9_5GHPO_LOFDMBW20,
+	 0xffff},
+	{"", 0, 0, SROM9_5GHPO_LOFDMBW20 + 1, 0xffff},
+	{"legofdmbw20ul5ghpo", 0xfffffe00, SRFL_MORE, SROM9_5GHPO_LOFDMBW20UL,
+	 0xffff},
+	{"", 0, 0, SROM9_5GHPO_LOFDMBW20UL + 1, 0xffff},
+	{"mcsbw202gpo", 0xfffffe00, SRFL_MORE, SROM9_2GPO_MCSBW20, 0xffff},
+	{"", 0, 0, SROM9_2GPO_MCSBW20 + 1, 0xffff},
+	{"mcsbw20ul2gpo", 0xfffffe00, SRFL_MORE, SROM9_2GPO_MCSBW20UL, 0xffff},
+	{"", 0, 0, SROM9_2GPO_MCSBW20UL + 1, 0xffff},
+	{"mcsbw402gpo", 0xfffffe00, SRFL_MORE, SROM9_2GPO_MCSBW40, 0xffff},
+	{"", 0, 0, SROM9_2GPO_MCSBW40 + 1, 0xffff},
+	{"mcsbw205glpo", 0xfffffe00, SRFL_MORE, SROM9_5GLPO_MCSBW20, 0xffff},
+	{"", 0, 0, SROM9_5GLPO_MCSBW20 + 1, 0xffff},
+	{"mcsbw20ul5glpo", 0xfffffe00, SRFL_MORE, SROM9_5GLPO_MCSBW20UL,
+	 0xffff},
+	{"", 0, 0, SROM9_5GLPO_MCSBW20UL + 1, 0xffff},
+	{"mcsbw405glpo", 0xfffffe00, SRFL_MORE, SROM9_5GLPO_MCSBW40, 0xffff},
+	{"", 0, 0, SROM9_5GLPO_MCSBW40 + 1, 0xffff},
+	{"mcsbw205gmpo", 0xfffffe00, SRFL_MORE, SROM9_5GMPO_MCSBW20, 0xffff},
+	{"", 0, 0, SROM9_5GMPO_MCSBW20 + 1, 0xffff},
+	{"mcsbw20ul5gmpo", 0xfffffe00, SRFL_MORE, SROM9_5GMPO_MCSBW20UL,
+	 0xffff},
+	{"", 0, 0, SROM9_5GMPO_MCSBW20UL + 1, 0xffff},
+	{"mcsbw405gmpo", 0xfffffe00, SRFL_MORE, SROM9_5GMPO_MCSBW40, 0xffff},
+	{"", 0, 0, SROM9_5GMPO_MCSBW40 + 1, 0xffff},
+	{"mcsbw205ghpo", 0xfffffe00, SRFL_MORE, SROM9_5GHPO_MCSBW20, 0xffff},
+	{"", 0, 0, SROM9_5GHPO_MCSBW20 + 1, 0xffff},
+	{"mcsbw20ul5ghpo", 0xfffffe00, SRFL_MORE, SROM9_5GHPO_MCSBW20UL,
+	 0xffff},
+	{"", 0, 0, SROM9_5GHPO_MCSBW20UL + 1, 0xffff},
+	{"mcsbw405ghpo", 0xfffffe00, SRFL_MORE, SROM9_5GHPO_MCSBW40, 0xffff},
+	{"", 0, 0, SROM9_5GHPO_MCSBW40 + 1, 0xffff},
+	{"mcs32po", 0xfffffe00, 0, SROM9_PO_MCS32, 0xffff},
+	{"legofdm40duppo", 0xfffffe00, 0, SROM9_PO_LOFDM40DUP, 0xffff},
+
+	{NULL, 0, 0, 0, 0}
+};
+
+static const sromvar_t perpath_pci_sromvars[] = {
+	{"maxp2ga", 0x000000f0, 0, SROM4_2G_ITT_MAXP, 0x00ff},
+	{"itt2ga", 0x000000f0, 0, SROM4_2G_ITT_MAXP, 0xff00},
+	{"itt5ga", 0x000000f0, 0, SROM4_5G_ITT_MAXP, 0xff00},
+	{"pa2gw0a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA, 0xffff},
+	{"pa2gw1a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA + 1, 0xffff},
+	{"pa2gw2a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA + 2, 0xffff},
+	{"pa2gw3a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA + 3, 0xffff},
+	{"maxp5ga", 0x000000f0, 0, SROM4_5G_ITT_MAXP, 0x00ff},
+	{"maxp5gha", 0x000000f0, 0, SROM4_5GLH_MAXP, 0x00ff},
+	{"maxp5gla", 0x000000f0, 0, SROM4_5GLH_MAXP, 0xff00},
+	{"pa5gw0a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA, 0xffff},
+	{"pa5gw1a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA + 1, 0xffff},
+	{"pa5gw2a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA + 2, 0xffff},
+	{"pa5gw3a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA + 3, 0xffff},
+	{"pa5glw0a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA, 0xffff},
+	{"pa5glw1a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA + 1, 0xffff},
+	{"pa5glw2a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA + 2, 0xffff},
+	{"pa5glw3a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA + 3, 0xffff},
+	{"pa5ghw0a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA, 0xffff},
+	{"pa5ghw1a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA + 1, 0xffff},
+	{"pa5ghw2a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA + 2, 0xffff},
+	{"pa5ghw3a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA + 3, 0xffff},
+	{"maxp2ga", 0xffffff00, 0, SROM8_2G_ITT_MAXP, 0x00ff},
+	{"itt2ga", 0xffffff00, 0, SROM8_2G_ITT_MAXP, 0xff00},
+	{"itt5ga", 0xffffff00, 0, SROM8_5G_ITT_MAXP, 0xff00},
+	{"pa2gw0a", 0xffffff00, SRFL_PRHEX, SROM8_2G_PA, 0xffff},
+	{"pa2gw1a", 0xffffff00, SRFL_PRHEX, SROM8_2G_PA + 1, 0xffff},
+	{"pa2gw2a", 0xffffff00, SRFL_PRHEX, SROM8_2G_PA + 2, 0xffff},
+	{"maxp5ga", 0xffffff00, 0, SROM8_5G_ITT_MAXP, 0x00ff},
+	{"maxp5gha", 0xffffff00, 0, SROM8_5GLH_MAXP, 0x00ff},
+	{"maxp5gla", 0xffffff00, 0, SROM8_5GLH_MAXP, 0xff00},
+	{"pa5gw0a", 0xffffff00, SRFL_PRHEX, SROM8_5G_PA, 0xffff},
+	{"pa5gw1a", 0xffffff00, SRFL_PRHEX, SROM8_5G_PA + 1, 0xffff},
+	{"pa5gw2a", 0xffffff00, SRFL_PRHEX, SROM8_5G_PA + 2, 0xffff},
+	{"pa5glw0a", 0xffffff00, SRFL_PRHEX, SROM8_5GL_PA, 0xffff},
+	{"pa5glw1a", 0xffffff00, SRFL_PRHEX, SROM8_5GL_PA + 1, 0xffff},
+	{"pa5glw2a", 0xffffff00, SRFL_PRHEX, SROM8_5GL_PA + 2, 0xffff},
+	{"pa5ghw0a", 0xffffff00, SRFL_PRHEX, SROM8_5GH_PA, 0xffff},
+	{"pa5ghw1a", 0xffffff00, SRFL_PRHEX, SROM8_5GH_PA + 1, 0xffff},
+	{"pa5ghw2a", 0xffffff00, SRFL_PRHEX, SROM8_5GH_PA + 2, 0xffff},
+	{NULL, 0, 0, 0, 0}
+};
+
+#if !(defined(PHY_TYPE_N) && defined(PHY_TYPE_LP))
+#define	PHY_TYPE_N		4	/* N-Phy value */
+#define	PHY_TYPE_LP		5	/* LP-Phy value */
+#endif				/* !(defined(PHY_TYPE_N) && defined(PHY_TYPE_LP)) */
+#if !defined(PHY_TYPE_NULL)
+#define	PHY_TYPE_NULL		0xf	/* Invalid Phy value */
+#endif				/* !defined(PHY_TYPE_NULL) */
+
+typedef struct {
+	uint16 phy_type;
+	uint16 bandrange;
+	uint16 chain;
+	const char *vars;
+} pavars_t;
+
+static const pavars_t pavars[] = {
+	/* NPHY */
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_2G, 0, "pa2gw0a0 pa2gw1a0 pa2gw2a0"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_2G, 1, "pa2gw0a1 pa2gw1a1 pa2gw2a1"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GL, 0,
+	 "pa5glw0a0 pa5glw1a0 pa5glw2a0"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GL, 1,
+	 "pa5glw0a1 pa5glw1a1 pa5glw2a1"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GM, 0, "pa5gw0a0 pa5gw1a0 pa5gw2a0"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GM, 1, "pa5gw0a1 pa5gw1a1 pa5gw2a1"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GH, 0,
+	 "pa5ghw0a0 pa5ghw1a0 pa5ghw2a0"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GH, 1,
+	 "pa5ghw0a1 pa5ghw1a1 pa5ghw2a1"},
+	/* LPPHY */
+	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_2G, 0, "pa0b0 pa0b1 pa0b2"},
+	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_5GL, 0, "pa1lob0 pa1lob1 pa1lob2"},
+	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_5GM, 0, "pa1b0 pa1b1 pa1b2"},
+	{PHY_TYPE_LP, WL_CHAN_FREQ_RANGE_5GH, 0, "pa1hib0 pa1hib1 pa1hib2"},
+	{PHY_TYPE_NULL, 0, 0, ""}
+};
+
+typedef struct {
+	uint16 phy_type;
+	uint16 bandrange;
+	const char *vars;
+} povars_t;
+
+static const povars_t povars[] = {
+	/* NPHY */
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_2G,
+	 "mcs2gpo0 mcs2gpo1 mcs2gpo2 mcs2gpo3 "
+	 "mcs2gpo4 mcs2gpo5 mcs2gpo6 mcs2gpo7"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GL,
+	 "mcs5glpo0 mcs5glpo1 mcs5glpo2 mcs5glpo3 "
+	 "mcs5glpo4 mcs5glpo5 mcs5glpo6 mcs5glpo7"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GM,
+	 "mcs5gpo0 mcs5gpo1 mcs5gpo2 mcs5gpo3 "
+	 "mcs5gpo4 mcs5gpo5 mcs5gpo6 mcs5gpo7"},
+	{PHY_TYPE_N, WL_CHAN_FREQ_RANGE_5GH,
+	 "mcs5ghpo0 mcs5ghpo1 mcs5ghpo2 mcs5ghpo3 "
+	 "mcs5ghpo4 mcs5ghpo5 mcs5ghpo6 mcs5ghpo7"},
+	{PHY_TYPE_NULL, 0, ""}
+};
+
+typedef struct {
+	uint8 tag;		/* Broadcom subtag name */
+	uint8 len;		/* Length field of the tuple, note that it includes the
+				 * subtag name (1 byte): 1 + tuple content length
+				 */
+	const char *params;
+} cis_tuple_t;
+
+#define OTP_RAW		(0xff - 1)	/* Reserved tuple number for wrvar Raw input */
+#define OTP_VERS_1	(0xff - 2)	/* CISTPL_VERS_1 */
+#define OTP_MANFID	(0xff - 3)	/* CISTPL_MANFID */
+#define OTP_RAW1	(0xff - 4)	/* Like RAW, but comes first */
+
+static const cis_tuple_t cis_hnbuvars[] = {
+	{OTP_RAW1, 0, ""},	/* special case */
+	{OTP_VERS_1, 0, "smanf sproductname"},	/* special case (non BRCM tuple) */
+	{OTP_MANFID, 4, "2manfid 2prodid"},	/* special case (non BRCM tuple) */
+	{HNBU_SROMREV, 2, "1sromrev"},
+	/* NOTE: subdevid is also written to boardtype.
+	 *       Need to write HNBU_BOARDTYPE to change it if it is different.
+	 */
+	{HNBU_CHIPID, 11, "2vendid 2devid 2chiprev 2subvendid 2subdevid"},
+	{HNBU_BOARDREV, 3, "2boardrev"},
+	{HNBU_PAPARMS, 10, "2pa0b0 2pa0b1 2pa0b2 1pa0itssit 1pa0maxpwr 1opo"},
+	{HNBU_AA, 3, "1aa2g 1aa5g"},
+	{HNBU_AA, 3, "1aa0 1aa1"},	/* backward compatibility */
+	{HNBU_AG, 5, "1ag0 1ag1 1ag2 1ag3"},
+	{HNBU_BOARDFLAGS, 9, "4boardflags 4boardflags2"},
+	{HNBU_LEDS, 5, "1ledbh0 1ledbh1 1ledbh2 1ledbh3"},
+	{HNBU_CCODE, 4, "2ccode 1cctl"},
+	{HNBU_CCKPO, 3, "2cckpo"},
+	{HNBU_OFDMPO, 5, "4ofdmpo"},
+	{HNBU_RDLID, 3, "2rdlid"},
+	{HNBU_RSSISMBXA2G, 3, "0rssismf2g 0rssismc2g 0rssisav2g 0bxa2g"},	/* special case */
+	{HNBU_RSSISMBXA5G, 3, "0rssismf5g 0rssismc5g 0rssisav5g 0bxa5g"},	/* special case */
+	{HNBU_XTALFREQ, 5, "4xtalfreq"},
+	{HNBU_TRI2G, 2, "1tri2g"},
+	{HNBU_TRI5G, 4, "1tri5gl 1tri5g 1tri5gh"},
+	{HNBU_RXPO2G, 2, "1rxpo2g"},
+	{HNBU_RXPO5G, 2, "1rxpo5g"},
+	{HNBU_BOARDNUM, 3, "2boardnum"},
+	{HNBU_MACADDR, 7, "6macaddr"},	/* special case */
+	{HNBU_RDLSN, 3, "2rdlsn"},
+	{HNBU_BOARDTYPE, 3, "2boardtype"},
+	{HNBU_LEDDC, 3, "2leddc"},
+	{HNBU_RDLRNDIS, 2, "1rdlndis"},
+	{HNBU_CHAINSWITCH, 5, "1txchain 1rxchain 2antswitch"},
+	{HNBU_REGREV, 2, "1regrev"},
+	{HNBU_FEM, 5, "0antswctl2g, 0triso2g, 0pdetrange2g, 0extpagain2g, 0tssipos2g" "0antswctl5g, 0triso5g, 0pdetrange5g, 0extpagain5g, 0tssipos5g"},	/* special case */
+	{HNBU_PAPARMS_C0, 31, "1maxp2ga0 1itt2ga0 2pa2gw0a0 2pa2gw1a0 "
+	 "2pa2gw2a0 1maxp5ga0 1itt5ga0 1maxp5gha0 1maxp5gla0 2pa5gw0a0 "
+	 "2pa5gw1a0 2pa5gw2a0 2pa5glw0a0 2pa5glw1a0 2pa5glw2a0 2pa5ghw0a0 "
+	 "2pa5ghw1a0 2pa5ghw2a0"},
+	{HNBU_PAPARMS_C1, 31, "1maxp2ga1 1itt2ga1 2pa2gw0a1 2pa2gw1a1 "
+	 "2pa2gw2a1 1maxp5ga1 1itt5ga1 1maxp5gha1 1maxp5gla1 2pa5gw0a1 "
+	 "2pa5gw1a1 2pa5gw2a1 2pa5glw0a1 2pa5glw1a1 2pa5glw2a1 2pa5ghw0a1 "
+	 "2pa5ghw1a1 2pa5ghw2a1"},
+	{HNBU_PO_CCKOFDM, 19, "2cck2gpo 4ofdm2gpo 4ofdm5gpo 4ofdm5glpo "
+	 "4ofdm5ghpo"},
+	{HNBU_PO_MCS2G, 17, "2mcs2gpo0 2mcs2gpo1 2mcs2gpo2 2mcs2gpo3 "
+	 "2mcs2gpo4 2mcs2gpo5 2mcs2gpo6 2mcs2gpo7"},
+	{HNBU_PO_MCS5GM, 17, "2mcs5gpo0 2mcs5gpo1 2mcs5gpo2 2mcs5gpo3 "
+	 "2mcs5gpo4 2mcs5gpo5 2mcs5gpo6 2mcs5gpo7"},
+	{HNBU_PO_MCS5GLH, 33, "2mcs5glpo0 2mcs5glpo1 2mcs5glpo2 2mcs5glpo3 "
+	 "2mcs5glpo4 2mcs5glpo5 2mcs5glpo6 2mcs5glpo7 "
+	 "2mcs5ghpo0 2mcs5ghpo1 2mcs5ghpo2 2mcs5ghpo3 "
+	 "2mcs5ghpo4 2mcs5ghpo5 2mcs5ghpo6 2mcs5ghpo7"},
+	{HNBU_CCKFILTTYPE, 2, "1cckdigfilttype"},
+	{HNBU_PO_CDD, 3, "2cddpo"},
+	{HNBU_PO_STBC, 3, "2stbcpo"},
+	{HNBU_PO_40M, 3, "2bw40po"},
+	{HNBU_PO_40MDUP, 3, "2bwduppo"},
+	{HNBU_RDLRWU, 2, "1rdlrwu"},
+	{HNBU_WPS, 3, "1wpsgpio 1wpsled"},
+	{HNBU_USBFS, 2, "1usbfs"},
+	{HNBU_CUSTOM1, 5, "4customvar1"},
+	{OTP_RAW, 0, ""},	/* special case */
+	{HNBU_OFDMPO5G, 13, "4ofdm5gpo 4ofdm5glpo 4ofdm5ghpo"},
+	{HNBU_USBEPNUM, 3, "2usbepnum"},
+	{0xFF, 0, ""}
+};
+
+#endif				/* _bcmsrom_tbl_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmutils.h b/drivers/staging/brcm80211/include/bcmutils.h
new file mode 100644
index 0000000..ed1f691
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmutils.h
@@ -0,0 +1,606 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmutils_h_
+#define	_bcmutils_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ctype replacement */
+#define _BCM_U	0x01		/* upper */
+#define _BCM_L	0x02		/* lower */
+#define _BCM_D	0x04		/* digit */
+#define _BCM_C	0x08		/* cntrl */
+#define _BCM_P	0x10		/* punct */
+#define _BCM_S	0x20		/* white space (space/lf/tab) */
+#define _BCM_X	0x40		/* hex digit */
+#define _BCM_SP	0x80		/* hard space (0x20) */
+
+	extern const unsigned char bcm_ctype[];
+#define bcm_ismask(x)	(bcm_ctype[(int)(unsigned char)(x)])
+
+#define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_isalpha(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L)) != 0)
+#define bcm_iscntrl(c)	((bcm_ismask(c)&(_BCM_C)) != 0)
+#define bcm_isdigit(c)	((bcm_ismask(c)&(_BCM_D)) != 0)
+#define bcm_isgraph(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_islower(c)	((bcm_ismask(c)&(_BCM_L)) != 0)
+#define bcm_isprint(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D|_BCM_SP)) != 0)
+#define bcm_ispunct(c)	((bcm_ismask(c)&(_BCM_P)) != 0)
+#define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
+#define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
+#define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
+#define bcm_tolower(c)	(bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
+#define bcm_toupper(c)	(bcm_islower((c)) ? ((c) + 'A' - 'a') : (c))
+
+/* Buffer structure for collecting string-formatted data
+* using bcm_bprintf() API.
+* Use bcm_binit() to initialize before use
+*/
+
+	struct bcmstrbuf {
+		char *buf;	/* pointer to current position in origbuf */
+		unsigned int size;	/* current (residual) size in bytes */
+		char *origbuf;	/* unmodified pointer to orignal buffer */
+		unsigned int origsize;	/* unmodified orignal buffer size in bytes */
+	};
+
+/* ** driver-only section ** */
+#include <osl.h>
+
+#define GPIO_PIN_NOTDEFINED 	0x20	/* Pin not defined */
+
+/*
+ * Spin at most 'us' microseconds while 'exp' is true.
+ * Caller should explicitly test 'exp' when this completes
+ * and take appropriate error action if 'exp' is still true.
+ */
+#define SPINWAIT(exp, us) { \
+	uint countdown = (us) + 9; \
+	while ((exp) && (countdown >= 10)) {\
+		OSL_DELAY(10); \
+		countdown -= 10; \
+	} \
+}
+
+/* osl multi-precedence packet queue */
+#ifndef PKTQ_LEN_DEFAULT
+#define PKTQ_LEN_DEFAULT        128	/* Max 128 packets */
+#endif
+#ifndef PKTQ_MAX_PREC
+#define PKTQ_MAX_PREC           16	/* Maximum precedence levels */
+#endif
+
+	typedef struct pktq_prec {
+		void *head;	/* first packet to dequeue */
+		void *tail;	/* last packet to dequeue */
+		uint16 len;	/* number of queued packets */
+		uint16 max;	/* maximum number of queued packets */
+	} pktq_prec_t;
+
+/* multi-priority pkt queue */
+	struct pktq {
+		uint16 num_prec;	/* number of precedences in use */
+		uint16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
+		uint16 max;	/* total max packets */
+		uint16 len;	/* total number of packets */
+		/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
+		struct pktq_prec q[PKTQ_MAX_PREC];
+	};
+
+/* simple, non-priority pkt queue */
+	struct spktq {
+		uint16 num_prec;	/* number of precedences in use (always 1) */
+		uint16 hi_prec;	/* rapid dequeue hint (>= highest non-empty prec) */
+		uint16 max;	/* total max packets */
+		uint16 len;	/* total number of packets */
+		/* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
+		struct pktq_prec q[1];
+	};
+
+#define PKTQ_PREC_ITER(pq, prec)        for (prec = (pq)->num_prec - 1; prec >= 0; prec--)
+
+/* fn(pkt, arg).  return true if pkt belongs to if */
+	typedef bool(*ifpkt_cb_t) (void *, int);
+
+/* forward definition of ether_addr structure used by some function prototypes */
+
+	struct ether_addr;
+
+	extern int ether_isbcast(const void *ea);
+	extern int ether_isnulladdr(const void *ea);
+
+/* operations on a specific precedence in packet queue */
+
+#define pktq_psetmax(pq, prec, _max)    ((pq)->q[prec].max = (_max))
+#define pktq_plen(pq, prec)             ((pq)->q[prec].len)
+#define pktq_pavail(pq, prec)           ((pq)->q[prec].max - (pq)->q[prec].len)
+#define pktq_pfull(pq, prec)            ((pq)->q[prec].len >= (pq)->q[prec].max)
+#define pktq_pempty(pq, prec)           ((pq)->q[prec].len == 0)
+
+#define pktq_ppeek(pq, prec)            ((pq)->q[prec].head)
+#define pktq_ppeek_tail(pq, prec)       ((pq)->q[prec].tail)
+
+	extern void *pktq_penq(struct pktq *pq, int prec, void *p);
+	extern void *pktq_penq_head(struct pktq *pq, int prec, void *p);
+	extern void *pktq_pdeq(struct pktq *pq, int prec);
+	extern void *pktq_pdeq_tail(struct pktq *pq, int prec);
+/* Empty the queue at particular precedence level */
+	extern void pktq_pflush(osl_t * osh, struct pktq *pq, int prec,
+				bool dir, ifpkt_cb_t fn, int arg);
+/* Remove a specified packet from its queue */
+	extern bool pktq_pdel(struct pktq *pq, void *p, int prec);
+
+/* operations on a set of precedences in packet queue */
+
+	extern int pktq_mlen(struct pktq *pq, uint prec_bmp);
+	extern void *pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out);
+
+/* operations on packet queue as a whole */
+
+#define pktq_len(pq)                    ((int)(pq)->len)
+#define pktq_max(pq)                    ((int)(pq)->max)
+#define pktq_avail(pq)                  ((int)((pq)->max - (pq)->len))
+#define pktq_full(pq)                   ((pq)->len >= (pq)->max)
+#define pktq_empty(pq)                  ((pq)->len == 0)
+
+/* operations for single precedence queues */
+#define pktenq(pq, p)		pktq_penq(((struct pktq *)pq), 0, (p))
+#define pktenq_head(pq, p)	pktq_penq_head(((struct pktq *)pq), 0, (p))
+#define pktdeq(pq)		pktq_pdeq(((struct pktq *)pq), 0)
+#define pktdeq_tail(pq)		pktq_pdeq_tail(((struct pktq *)pq), 0)
+#define pktqinit(pq, len) pktq_init(((struct pktq *)pq), 1, len)
+
+	extern void pktq_init(struct pktq *pq, int num_prec, int max_len);
+/* prec_out may be NULL if caller is not interested in return value */
+	extern void *pktq_deq(struct pktq *pq, int *prec_out);
+	extern void *pktq_deq_tail(struct pktq *pq, int *prec_out);
+	extern void *pktq_peek(struct pktq *pq, int *prec_out);
+	extern void *pktq_peek_tail(struct pktq *pq, int *prec_out);
+	extern void pktq_flush(osl_t * osh, struct pktq *pq, bool dir,
+			       ifpkt_cb_t fn, int arg);
+
+/* externs */
+/* packet */
+	extern uint pktcopy(osl_t * osh, void *p, uint offset, int len,
+			    uchar * buf);
+	extern uint pktfrombuf(osl_t * osh, void *p, uint offset, int len,
+			       uchar * buf);
+	extern uint pkttotlen(osl_t * osh, void *p);
+	extern void *pktlast(osl_t * osh, void *p);
+	extern uint pktsegcnt(osl_t * osh, void *p);
+
+/* Get priority from a packet and pass it back in scb (or equiv) */
+	extern uint pktsetprio(void *pkt, bool update_vtag);
+#define	PKTPRIO_VDSCP	0x100	/* DSCP prio found after VLAN tag */
+#define	PKTPRIO_VLAN	0x200	/* VLAN prio found */
+#define	PKTPRIO_UPD	0x400	/* DSCP used to update VLAN prio */
+#define	PKTPRIO_DSCP	0x800	/* DSCP prio found */
+
+/* string */
+	extern int BCMROMFN(bcm_atoi) (char *s);
+	extern ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base);
+	extern char *BCMROMFN(bcmstrstr) (char *haystack, char *needle);
+	extern char *BCMROMFN(bcmstrcat) (char *dest, const char *src);
+	extern char *BCMROMFN(bcmstrncat) (char *dest, const char *src,
+					   uint size);
+	extern ulong wchar2ascii(char *abuf, ushort * wbuf, ushort wbuflen,
+				 ulong abuflen);
+	char *bcmstrtok(char **string, const char *delimiters, char *tokdelim);
+	int bcmstricmp(const char *s1, const char *s2);
+	int bcmstrnicmp(const char *s1, const char *s2, int cnt);
+
+/* ethernet address */
+	extern char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf);
+	extern int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr * ea);
+
+/* ip address */
+	struct ipv4_addr;
+	extern char *bcm_ip_ntoa(struct ipv4_addr *ia, char *buf);
+
+/* delay */
+	extern void bcm_mdelay(uint ms);
+/* variable access */
+	extern char *getvar(char *vars, const char *name);
+	extern int getintvar(char *vars, const char *name);
+	extern int getintvararray(char *vars, const char *name, uint8 index);
+	extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
+#ifdef BCMDBG
+	extern void prpkt(const char *msg, osl_t * osh, void *p0);
+#endif				/* BCMDBG */
+#define bcm_perf_enable()
+#define bcmstats(fmt)
+#define	bcmlog(fmt, a1, a2)
+#define	bcmdumplog(buf, size)	*buf = '\0'
+#define	bcmdumplogent(buf, idx)	-1
+
+#define bcmtslog(tstamp, fmt, a1, a2)
+#define bcmprinttslogs()
+#define bcmprinttstamp(us)
+
+	extern char *bcm_nvram_vars(uint * length);
+	extern int bcm_nvram_cache(void *sih);
+
+/* Support for sharing code across in-driver iovar implementations.
+ * The intent is that a driver use this structure to map iovar names
+ * to its (private) iovar identifiers, and the lookup function to
+ * find the entry.  Macros are provided to map ids and get/set actions
+ * into a single number space for a switch statement.
+ */
+
+/* iovar structure */
+	typedef struct bcm_iovar {
+		const char *name;	/* name for lookup and display */
+		uint16 varid;	/* id for switch */
+		uint16 flags;	/* driver-specific flag bits */
+		uint16 type;	/* base type of argument */
+		uint16 minlen;	/* min length for buffer vars */
+	} bcm_iovar_t;
+
+/* varid definitions are per-driver, may use these get/set bits */
+
+/* IOVar action bits for id mapping */
+#define IOV_GET 0		/* Get an iovar */
+#define IOV_SET 1		/* Set an iovar */
+
+/* Varid to actionid mapping */
+#define IOV_GVAL(id)		((id)*2)
+#define IOV_SVAL(id)		(((id)*2)+IOV_SET)
+#define IOV_ISSET(actionid)	((actionid & IOV_SET) == IOV_SET)
+#define IOV_ID(actionid)	(actionid >> 1)
+
+/* flags are per-driver based on driver attributes */
+
+	extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table,
+						   const char *name);
+	extern int bcm_iovar_lencheck(const bcm_iovar_t * table, void *arg,
+				      int len, bool set);
+#if defined(BCMDBG)
+	extern int bcm_format_ssid(char *buf, const uchar ssid[],
+				   uint ssid_len);
+#endif
+
+/* Base type definitions */
+#define IOVT_VOID	0	/* no value (implictly set only) */
+#define IOVT_BOOL	1	/* any value ok (zero/nonzero) */
+#define IOVT_INT8	2	/* integer values are range-checked */
+#define IOVT_UINT8	3	/* unsigned int 8 bits */
+#define IOVT_INT16	4	/* int 16 bits */
+#define IOVT_UINT16	5	/* unsigned int 16 bits */
+#define IOVT_INT32	6	/* int 32 bits */
+#define IOVT_UINT32	7	/* unsigned int 32 bits */
+#define IOVT_BUFFER	8	/* buffer is size-checked as per minlen */
+#define BCM_IOVT_VALID(type) (((unsigned int)(type)) <= IOVT_BUFFER)
+
+/* Initializer for IOV type strings */
+#define BCM_IOV_TYPE_INIT { \
+	"void", \
+	"bool", \
+	"int8", \
+	"uint8", \
+	"int16", \
+	"uint16", \
+	"int32", \
+	"uint32", \
+	"buffer", \
+	"" }
+
+#define BCM_IOVT_IS_INT(type) (\
+	(type == IOVT_BOOL) || \
+	(type == IOVT_INT8) || \
+	(type == IOVT_UINT8) || \
+	(type == IOVT_INT16) || \
+	(type == IOVT_UINT16) || \
+	(type == IOVT_INT32) || \
+	(type == IOVT_UINT32))
+
+/* ** driver/apps-shared section ** */
+
+#define BCME_STRLEN 		64	/* Max string length for BCM errors */
+#define VALID_BCMERROR(e)  ((e <= 0) && (e >= BCME_LAST))
+
+/*
+ * error codes could be added but the defined ones shouldn't be changed/deleted
+ * these error codes are exposed to the user code
+ * when ever a new error code is added to this list
+ * please update errorstring table with the related error string and
+ * update osl files with os specific errorcode map
+*/
+
+#define BCME_OK				0	/* Success */
+#define BCME_ERROR			-1	/* Error generic */
+#define BCME_BADARG			-2	/* Bad Argument */
+#define BCME_BADOPTION			-3	/* Bad option */
+#define BCME_NOTUP			-4	/* Not up */
+#define BCME_NOTDOWN			-5	/* Not down */
+#define BCME_NOTAP			-6	/* Not AP */
+#define BCME_NOTSTA			-7	/* Not STA  */
+#define BCME_BADKEYIDX			-8	/* BAD Key Index */
+#define BCME_RADIOOFF 			-9	/* Radio Off */
+#define BCME_NOTBANDLOCKED		-10	/* Not  band locked */
+#define BCME_NOCLK			-11	/* No Clock */
+#define BCME_BADRATESET			-12	/* BAD Rate valueset */
+#define BCME_BADBAND			-13	/* BAD Band */
+#define BCME_BUFTOOSHORT		-14	/* Buffer too short */
+#define BCME_BUFTOOLONG			-15	/* Buffer too long */
+#define BCME_BUSY			-16	/* Busy */
+#define BCME_NOTASSOCIATED		-17	/* Not Associated */
+#define BCME_BADSSIDLEN			-18	/* Bad SSID len */
+#define BCME_OUTOFRANGECHAN		-19	/* Out of Range Channel */
+#define BCME_BADCHAN			-20	/* Bad Channel */
+#define BCME_BADADDR			-21	/* Bad Address */
+#define BCME_NORESOURCE			-22	/* Not Enough Resources */
+#define BCME_UNSUPPORTED		-23	/* Unsupported */
+#define BCME_BADLEN			-24	/* Bad length */
+#define BCME_NOTREADY			-25	/* Not Ready */
+#define BCME_EPERM			-26	/* Not Permitted */
+#define BCME_NOMEM			-27	/* No Memory */
+#define BCME_ASSOCIATED			-28	/* Associated */
+#define BCME_RANGE			-29	/* Not In Range */
+#define BCME_NOTFOUND			-30	/* Not Found */
+#define BCME_WME_NOT_ENABLED		-31	/* WME Not Enabled */
+#define BCME_TSPEC_NOTFOUND		-32	/* TSPEC Not Found */
+#define BCME_ACM_NOTSUPPORTED		-33	/* ACM Not Supported */
+#define BCME_NOT_WME_ASSOCIATION	-34	/* Not WME Association */
+#define BCME_SDIO_ERROR			-35	/* SDIO Bus Error */
+#define BCME_DONGLE_DOWN		-36	/* Dongle Not Accessible */
+#define BCME_VERSION			-37	/* Incorrect version */
+#define BCME_TXFAIL			-38	/* TX failure */
+#define BCME_RXFAIL			-39	/* RX failure */
+#define BCME_NODEVICE			-40	/* Device not present */
+#define BCME_NMODE_DISABLED		-41	/* NMODE disabled */
+#define BCME_NONRESIDENT		-42	/* access to nonresident overlay */
+#define BCME_LAST			BCME_NONRESIDENT
+
+/* These are collection of BCME Error strings */
+#define BCMERRSTRINGTABLE {		\
+	"OK",				\
+	"Undefined error",		\
+	"Bad Argument",			\
+	"Bad Option",			\
+	"Not up",			\
+	"Not down",			\
+	"Not AP",			\
+	"Not STA",			\
+	"Bad Key Index",		\
+	"Radio Off",			\
+	"Not band locked",		\
+	"No clock",			\
+	"Bad Rate valueset",		\
+	"Bad Band",			\
+	"Buffer too short",		\
+	"Buffer too long",		\
+	"Busy",				\
+	"Not Associated",		\
+	"Bad SSID len",			\
+	"Out of Range Channel",		\
+	"Bad Channel",			\
+	"Bad Address",			\
+	"Not Enough Resources",		\
+	"Unsupported",			\
+	"Bad length",			\
+	"Not Ready",			\
+	"Not Permitted",		\
+	"No Memory",			\
+	"Associated",			\
+	"Not In Range",			\
+	"Not Found",			\
+	"WME Not Enabled",		\
+	"TSPEC Not Found",		\
+	"ACM Not Supported",		\
+	"Not WME Association",		\
+	"SDIO Bus Error",		\
+	"Dongle Not Accessible",	\
+	"Incorrect version",		\
+	"TX Failure",			\
+	"RX Failure",			\
+	"Device Not Present",		\
+	"NMODE Disabled",		\
+	"Nonresident overlay access", \
+}
+
+#ifndef ABS
+#define	ABS(a)			(((a) < 0)?-(a):(a))
+#endif				/* ABS */
+
+#ifndef MIN
+#define	MIN(a, b)		(((a) < (b))?(a):(b))
+#endif				/* MIN */
+
+#ifndef MAX
+#define	MAX(a, b)		(((a) > (b))?(a):(b))
+#endif				/* MAX */
+
+#define CEIL(x, y)		(((x) + ((y)-1)) / (y))
+#define	ROUNDUP(x, y)		((((x)+((y)-1))/(y))*(y))
+#define	ISALIGNED(a, x)		(((a) & ((x)-1)) == 0)
+#define ALIGN_ADDR(addr, boundary) (void *)(((uintptr)(addr) + (boundary) - 1) \
+	& ~((boundary) - 1))
+#define	ISPOWEROF2(x)		((((x)-1)&(x)) == 0)
+#define VALID_MASK(mask)	!((mask) & ((mask) + 1))
+#ifndef OFFSETOF
+#define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
+#endif				/* OFFSETOF */
+#ifndef ARRAYSIZE
+#define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
+#endif
+
+/* bit map related macros */
+#ifndef setbit
+#ifndef NBBY			/* the BSD family defines NBBY */
+#define	NBBY	8		/* 8 bits per byte */
+#endif				/* #ifndef NBBY */
+#define	setbit(a, i)	(((uint8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a, i)	(((uint8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a, i)	(((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a, i)	((((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif				/* setbit */
+
+#define	NBITS(type)	(sizeof(type) * 8)
+#define NBITVAL(nbits)	(1 << (nbits))
+#define MAXBITVAL(nbits)	((1 << (nbits)) - 1)
+#define	NBITMASK(nbits)	MAXBITVAL(nbits)
+#define MAXNBVAL(nbyte)	MAXBITVAL((nbyte) * 8)
+
+/* basic mux operation - can be optimized on several architectures */
+#define MUX(pred, true, false) ((pred) ? (true) : (false))
+
+/* modulo inc/dec - assumes x E [0, bound - 1] */
+#define MODDEC(x, bound) MUX((x) == 0, (bound) - 1, (x) - 1)
+#define MODINC(x, bound) MUX((x) == (bound) - 1, 0, (x) + 1)
+
+/* modulo inc/dec, bound = 2^k */
+#define MODDEC_POW2(x, bound) (((x) - 1) & ((bound) - 1))
+#define MODINC_POW2(x, bound) (((x) + 1) & ((bound) - 1))
+
+/* modulo add/sub - assumes x, y E [0, bound - 1] */
+#define MODADD(x, y, bound) \
+    MUX((x) + (y) >= (bound), (x) + (y) - (bound), (x) + (y))
+#define MODSUB(x, y, bound) \
+    MUX(((int)(x)) - ((int)(y)) < 0, (x) - (y) + (bound), (x) - (y))
+
+/* module add/sub, bound = 2^k */
+#define MODADD_POW2(x, y, bound) (((x) + (y)) & ((bound) - 1))
+#define MODSUB_POW2(x, y, bound) (((x) - (y)) & ((bound) - 1))
+
+/* crc defines */
+#define CRC8_INIT_VALUE  0xff	/* Initial CRC8 checksum value */
+#define CRC8_GOOD_VALUE  0x9f	/* Good final CRC8 checksum value */
+#define CRC16_INIT_VALUE 0xffff	/* Initial CRC16 checksum value */
+#define CRC16_GOOD_VALUE 0xf0b8	/* Good final CRC16 checksum value */
+
+/* bcm_format_flags() bit description structure */
+	typedef struct bcm_bit_desc {
+		uint32 bit;
+		const char *name;
+	} bcm_bit_desc_t;
+
+/* tag_ID/length/value_buffer tuple */
+	typedef struct bcm_tlv {
+		uint8 id;
+		uint8 len;
+		uint8 data[1];
+	} bcm_tlv_t;
+
+/* Check that bcm_tlv_t fits into the given buflen */
+#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (int)(buflen) >= (int)(2 + (elt)->len))
+
+/* buffer length for ethernet address from bcm_ether_ntoa() */
+#define ETHER_ADDR_STR_LEN	18	/* 18-bytes of Ethernet address buffer length */
+
+/* crypto utility function */
+/* 128-bit xor: *dst = *src1 xor *src2. dst1, src1 and src2 may have any alignment */
+	static INLINE void
+	 xor_128bit_block(const uint8 * src1, const uint8 * src2, uint8 * dst) {
+		if (
+#ifdef __i386__
+			   1 ||
+#endif
+			   (((uintptr) src1 | (uintptr) src2 | (uintptr) dst) &
+			    3) == 0) {
+			/* ARM CM3 rel time: 1229 (727 if alignment check could be omitted) */
+			/* x86 supports unaligned.  This version runs 6x-9x faster on x86. */
+			((uint32 *) dst)[0] =
+			    ((const uint32 *)src1)[0] ^ ((const uint32 *)
+							 src2)[0];
+			((uint32 *) dst)[1] =
+			    ((const uint32 *)src1)[1] ^ ((const uint32 *)
+							 src2)[1];
+			((uint32 *) dst)[2] =
+			    ((const uint32 *)src1)[2] ^ ((const uint32 *)
+							 src2)[2];
+			((uint32 *) dst)[3] =
+			    ((const uint32 *)src1)[3] ^ ((const uint32 *)
+							 src2)[3];
+		} else {
+			/* ARM CM3 rel time: 4668 (4191 if alignment check could be omitted) */
+			int k;
+			for (k = 0; k < 16; k++)
+				dst[k] = src1[k] ^ src2[k];
+		}
+	}
+
+/* externs */
+/* crc */
+	extern uint8 BCMROMFN(hndcrc8) (uint8 * p, uint nbytes, uint8 crc);
+	extern uint16 BCMROMFN(hndcrc16) (uint8 * p, uint nbytes, uint16 crc);
+/* format/print */
+#if defined(BCMDBG)
+	extern int bcm_format_flags(const bcm_bit_desc_t * bd, uint32 flags,
+				    char *buf, int len);
+	extern int bcm_format_hex(char *str, const void *bytes, int len);
+#endif
+#ifdef BCMDBG
+	extern void deadbeef(void *p, uint len);
+#endif
+	extern const char *bcm_crypto_algo_name(uint algo);
+	extern char *bcm_chipname(uint chipid, char *buf, uint len);
+	extern char *bcm_brev_str(uint32 brev, char *buf);
+	extern void printbig(char *buf);
+	extern void prhex(const char *msg, uchar * buf, uint len);
+
+/* IE parsing */
+	extern bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t * elt, int *buflen);
+	extern bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen,
+						    uint key);
+	extern bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf,
+							    int buflen,
+							    uint key);
+
+/* bcmerror */
+	extern const char *bcmerrorstr(int bcmerror);
+
+/* multi-bool data type: set of bools, mbool is true if any is set */
+	typedef uint32 mbool;
+#define mboolset(mb, bit)		((mb) |= (bit))	/* set one bool */
+#define mboolclr(mb, bit)		((mb) &= ~(bit))	/* clear one bool */
+#define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* TRUE if one bool is set */
+#define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
+
+/* power conversion */
+	extern uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm);
+	extern uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw);
+
+/* generic datastruct to help dump routines */
+	struct fielddesc {
+		const char *nameandfmt;
+		uint32 offset;
+		uint32 len;
+	};
+
+	extern void bcm_binit(struct bcmstrbuf *b, char *buf, uint size);
+	extern int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...);
+	extern void bcm_inc_bytes(uchar * num, int num_bytes, uint8 amount);
+	extern int bcm_cmp_bytes(uchar * arg1, uchar * arg2, uint8 nbytes);
+	extern void bcm_print_bytes(char *name, const uchar * cdata, int len);
+
+	typedef uint32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1,
+					   uint32 offset);
+	extern uint bcmdumpfields(bcmutl_rdreg_rtn func_ptr, void *arg0,
+				  uint arg1, struct fielddesc *str, char *buf,
+				  uint32 bufsize);
+
+	extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf,
+				uint len);
+	extern uint BCMROMFN(bcm_bitcount) (uint8 * bitmap, uint bytelength);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif				/* _bcmutils_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmwifi.h b/drivers/staging/brcm80211/include/bcmwifi.h
new file mode 100644
index 0000000..80c48f6
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmwifi.h
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_bcmwifi_h_
+#define	_bcmwifi_h_
+
+/* A chanspec holds the channel number, band, bandwidth and control sideband */
+typedef uint16 chanspec_t;
+
+/* channel defines */
+#define CH_UPPER_SB			0x01
+#define CH_LOWER_SB			0x02
+#define CH_EWA_VALID			0x04
+#define CH_20MHZ_APART			4
+#define CH_10MHZ_APART			2
+#define CH_5MHZ_APART			1	/* 2G band channels are 5 Mhz apart */
+#define CH_MAX_2G_CHANNEL		14	/* Max channel in 2G band */
+#define WLC_MAX_2G_CHANNEL		CH_MAX_2G_CHANNEL	/* legacy define */
+#define	MAXCHANNEL		224	/* max # supported channels. The max channel no is 216,
+					 * this is that + 1 rounded up to a multiple of NBBY (8).
+					 * DO NOT MAKE it > 255: channels are uint8's all over
+					 */
+
+#define WL_CHANSPEC_CHAN_MASK		0x00ff
+#define WL_CHANSPEC_CHAN_SHIFT		0
+
+#define WL_CHANSPEC_CTL_SB_MASK		0x0300
+#define WL_CHANSPEC_CTL_SB_SHIFT	     8
+#define WL_CHANSPEC_CTL_SB_LOWER	0x0100
+#define WL_CHANSPEC_CTL_SB_UPPER	0x0200
+#define WL_CHANSPEC_CTL_SB_NONE		0x0300
+
+#define WL_CHANSPEC_BW_MASK		0x0C00
+#define WL_CHANSPEC_BW_SHIFT		    10
+#define WL_CHANSPEC_BW_10		0x0400
+#define WL_CHANSPEC_BW_20		0x0800
+#define WL_CHANSPEC_BW_40		0x0C00
+
+#define WL_CHANSPEC_BAND_MASK		0xf000
+#define WL_CHANSPEC_BAND_SHIFT		12
+#define WL_CHANSPEC_BAND_5G		0x1000
+#define WL_CHANSPEC_BAND_2G		0x2000
+#define INVCHANSPEC			255
+
+/* used to calculate the chan_freq = chan_factor * 500Mhz + 5 * chan_number */
+#define WF_CHAN_FACTOR_2_4_G		4814	/* 2.4 GHz band, 2407 MHz */
+#define WF_CHAN_FACTOR_5_G		10000	/* 5   GHz band, 5000 MHz */
+#define WF_CHAN_FACTOR_4_G		8000	/* 4.9 GHz band for Japan */
+
+/* channel defines */
+#define LOWER_20_SB(channel)	(((channel) > CH_10MHZ_APART) ? ((channel) - CH_10MHZ_APART) : 0)
+#define UPPER_20_SB(channel)	(((channel) < (MAXCHANNEL - CH_10MHZ_APART)) ? \
+				((channel) + CH_10MHZ_APART) : 0)
+#define CHSPEC_WLCBANDUNIT(chspec)	(CHSPEC_IS5G(chspec) ? BAND_5G_INDEX : BAND_2G_INDEX)
+#define CH20MHZ_CHSPEC(channel)	(chanspec_t)((chanspec_t)(channel) | WL_CHANSPEC_BW_20 | \
+				WL_CHANSPEC_CTL_SB_NONE | (((channel) <= CH_MAX_2G_CHANNEL) ? \
+				WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G))
+#define NEXT_20MHZ_CHAN(channel)	(((channel) < (MAXCHANNEL - CH_20MHZ_APART)) ? \
+					((channel) + CH_20MHZ_APART) : 0)
+#define CH40MHZ_CHSPEC(channel, ctlsb)	(chanspec_t) \
+					((channel) | (ctlsb) | WL_CHANSPEC_BW_40 | \
+					((channel) <= CH_MAX_2G_CHANNEL ? WL_CHANSPEC_BAND_2G : \
+					WL_CHANSPEC_BAND_5G))
+#define CHSPEC_CHANNEL(chspec)	((uint8)((chspec) & WL_CHANSPEC_CHAN_MASK))
+#define CHSPEC_BAND(chspec)	((chspec) & WL_CHANSPEC_BAND_MASK)
+
+#ifdef WL11N_20MHZONLY
+
+#define CHSPEC_CTL_SB(chspec)	WL_CHANSPEC_CTL_SB_NONE
+#define CHSPEC_BW(chspec)	WL_CHANSPEC_BW_20
+#define CHSPEC_IS10(chspec)	0
+#define CHSPEC_IS20(chspec)	1
+#ifndef CHSPEC_IS40
+#define CHSPEC_IS40(chspec)	0
+#endif
+
+#else				/* !WL11N_20MHZONLY */
+
+#define CHSPEC_CTL_SB(chspec)	((chspec) & WL_CHANSPEC_CTL_SB_MASK)
+#define CHSPEC_BW(chspec)	((chspec) & WL_CHANSPEC_BW_MASK)
+#define CHSPEC_IS10(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_10)
+#define CHSPEC_IS20(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_20)
+#ifndef CHSPEC_IS40
+#define CHSPEC_IS40(chspec)	(((chspec) & WL_CHANSPEC_BW_MASK) == WL_CHANSPEC_BW_40)
+#endif
+
+#endif				/* !WL11N_20MHZONLY */
+
+#define CHSPEC_IS5G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_5G)
+#define CHSPEC_IS2G(chspec)	(((chspec) & WL_CHANSPEC_BAND_MASK) == WL_CHANSPEC_BAND_2G)
+#define CHSPEC_SB_NONE(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_NONE)
+#define CHSPEC_SB_UPPER(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_UPPER)
+#define CHSPEC_SB_LOWER(chspec)	(((chspec) & WL_CHANSPEC_CTL_SB_MASK) == WL_CHANSPEC_CTL_SB_LOWER)
+#define CHSPEC_CTL_CHAN(chspec)  ((CHSPEC_SB_LOWER(chspec)) ? \
+				  (LOWER_20_SB(((chspec) & WL_CHANSPEC_CHAN_MASK))) : \
+				  (UPPER_20_SB(((chspec) & WL_CHANSPEC_CHAN_MASK))))
+#define CHSPEC2WLC_BAND(chspec) (CHSPEC_IS5G(chspec) ? WLC_BAND_5G : WLC_BAND_2G)
+
+#define CHANSPEC_STR_LEN    8
+
+/* defined rate in 500kbps */
+#define WLC_MAXRATE	108	/* in 500kbps units */
+#define WLC_RATE_1M	2	/* in 500kbps units */
+#define WLC_RATE_2M	4	/* in 500kbps units */
+#define WLC_RATE_5M5	11	/* in 500kbps units */
+#define WLC_RATE_11M	22	/* in 500kbps units */
+#define WLC_RATE_6M	12	/* in 500kbps units */
+#define WLC_RATE_9M	18	/* in 500kbps units */
+#define WLC_RATE_12M	24	/* in 500kbps units */
+#define WLC_RATE_18M	36	/* in 500kbps units */
+#define WLC_RATE_24M	48	/* in 500kbps units */
+#define WLC_RATE_36M	72	/* in 500kbps units */
+#define WLC_RATE_48M	96	/* in 500kbps units */
+#define WLC_RATE_54M	108	/* in 500kbps units */
+
+#define WLC_2G_25MHZ_OFFSET		5	/* 2.4GHz band channel offset */
+
+/*
+ * Convert chanspec to ascii string
+ * @param	chspec		chanspec format
+ * @param	buf		ascii string of chanspec
+ * @return	pointer to buf with room for at least CHANSPEC_STR_LEN bytes
+ */
+extern char *wf_chspec_ntoa(chanspec_t chspec, char *buf);
+
+/*
+ * Convert ascii string to chanspec
+ * @param	a		pointer to input string
+ * @return	>= 0 if successful or 0 otherwise
+ */
+extern chanspec_t wf_chspec_aton(char *a);
+
+/*
+ * Verify the chanspec is using a legal set of parameters, i.e. that the
+ * chanspec specified a band, bw, ctl_sb and channel and that the
+ * combination could be legal given any set of circumstances.
+ * RETURNS: TRUE is the chanspec is malformed, false if it looks good.
+ */
+extern bool wf_chspec_malformed(chanspec_t chanspec);
+
+/*
+ * This function returns the channel number that control traffic is being sent on, for legacy
+ * channels this is just the channel number, for 40MHZ channels it is the upper or lowre 20MHZ
+ * sideband depending on the chanspec selected
+ */
+extern uint8 wf_chspec_ctlchan(chanspec_t chspec);
+
+/*
+ * This function returns the chanspec that control traffic is being sent on, for legacy
+ * channels this is just the chanspec, for 40MHZ channels it is the upper or lowre 20MHZ
+ * sideband depending on the chanspec selected
+ */
+extern chanspec_t wf_chspec_ctlchspec(chanspec_t chspec);
+
+/*
+ * Return the channel number for a given frequency and base frequency.
+ * The returned channel number is relative to the given base frequency.
+ * If the given base frequency is zero, a base frequency of 5 GHz is assumed for
+ * frequencies from 5 - 6 GHz, and 2.407 GHz is assumed for 2.4 - 2.5 GHz.
+ *
+ * Frequency is specified in MHz.
+ * The base frequency is specified as (start_factor * 500 kHz).
+ * Constants WF_CHAN_FACTOR_2_4_G, WF_CHAN_FACTOR_5_G are defined for
+ * 2.4 GHz and 5 GHz bands.
+ *
+ * The returned channel will be in the range [1, 14] in the 2.4 GHz band
+ * and [0, 200] otherwise.
+ * -1 is returned if the start_factor is WF_CHAN_FACTOR_2_4_G and the
+ * frequency is not a 2.4 GHz channel, or if the frequency is not and even
+ * multiple of 5 MHz from the base frequency to the base plus 1 GHz.
+ *
+ * Reference 802.11 REVma, section 17.3.8.3, and 802.11B section 18.4.6.2
+ */
+extern int wf_mhz2channel(uint freq, uint start_factor);
+
+/*
+ * Return the center frequency in MHz of the given channel and base frequency.
+ * The channel number is interpreted relative to the given base frequency.
+ *
+ * The valid channel range is [1, 14] in the 2.4 GHz band and [0, 200] otherwise.
+ * The base frequency is specified as (start_factor * 500 kHz).
+ * Constants WF_CHAN_FACTOR_2_4_G, WF_CHAN_FACTOR_5_G are defined for
+ * 2.4 GHz and 5 GHz bands.
+ * The channel range of [1, 14] is only checked for a start_factor of
+ * WF_CHAN_FACTOR_2_4_G (4814).
+ * Odd start_factors produce channels on .5 MHz boundaries, in which case
+ * the answer is rounded down to an integral MHz.
+ * -1 is returned for an out of range channel.
+ *
+ * Reference 802.11 REVma, section 17.3.8.3, and 802.11B section 18.4.6.2
+ */
+extern int wf_channel2mhz(uint channel, uint start_factor);
+
+#endif				/* _bcmwifi_h_ */
diff --git a/drivers/staging/brcm80211/include/bcmwpa.h b/drivers/staging/brcm80211/include/bcmwpa.h
new file mode 100644
index 0000000..11af58b
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bcmwpa.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BCMWPA_H_
+#define _BCMWPA_H_
+
+#include <proto/wpa.h>
+#include <proto/802.11.h>
+#include <wlioctl.h>
+
+/* Field sizes for WPA key hierarchy */
+#define WPA_MIC_KEY_LEN		16
+#define WPA_ENCR_KEY_LEN	16
+#define WPA_TEMP_ENCR_KEY_LEN	16
+#define WPA_TEMP_TX_KEY_LEN	8
+#define WPA_TEMP_RX_KEY_LEN	8
+
+#define PMK_LEN			32
+#define TKIP_PTK_LEN		64
+#define TKIP_TK_LEN		32
+#define AES_PTK_LEN		48
+#define AES_TK_LEN		16
+
+/* limits for pre-shared key lengths */
+#define WPA_MIN_PSK_LEN		8
+#define WPA_MAX_PSK_LEN		64
+
+#define WLC_SW_KEYS(wlc, bsscfg) ((((wlc)->wsec_swkeys) || \
+	((bsscfg)->wsec & WSEC_SWFLAG)))
+
+#define WSEC_WEP_ENABLED(wsec)	((wsec) & WEP_ENABLED)
+#define WSEC_TKIP_ENABLED(wsec)	((wsec) & TKIP_ENABLED)
+#define WSEC_AES_ENABLED(wsec)	((wsec) & AES_ENABLED)
+#define WSEC_ENABLED(wsec)	((wsec) & (WEP_ENABLED | TKIP_ENABLED | AES_ENABLED))
+#define WSEC_SES_OW_ENABLED(wsec)	((wsec) & SES_OW_ENABLED)
+#define IS_WPA_AUTH(auth)	((auth) == WPA_AUTH_NONE || \
+				 (auth) == WPA_AUTH_UNSPECIFIED || \
+				 (auth) == WPA_AUTH_PSK)
+#define INCLUDES_WPA_AUTH(auth)	\
+			((auth) & (WPA_AUTH_NONE | WPA_AUTH_UNSPECIFIED | WPA_AUTH_PSK))
+
+#define IS_WPA2_AUTH(auth)	((auth) == WPA2_AUTH_UNSPECIFIED || \
+				 (auth) == WPA2_AUTH_PSK)(
+#define INCLUDES_WPA2_AUTH(auth) \
+			((auth) & (WPA2_AUTH_UNSPECIFIED | \
+				   WPA2_AUTH_PSK))
+
+#define IS_WPA_AKM(akm)	((akm) == RSN_AKM_NONE || \
+				 (akm) == RSN_AKM_UNSPECIFIED || \
+				 (akm) == RSN_AKM_PSK)
+#define IS_WPA2_AKM(akm)	((akm) == RSN_AKM_UNSPECIFIED || \
+				 (akm) == RSN_AKM_PSK)
+
+#define MAX_ARRAY 1
+#define MIN_ARRAY 0
+
+/* convert wsec to WPA mcast cipher. algo is needed only when WEP is enabled. */
+#define WPA_MCAST_CIPHER(wsec, algo)	(WSEC_WEP_ENABLED(wsec) ? \
+		((algo) == CRYPTO_ALGO_WEP128 ? WPA_CIPHER_WEP_104 : WPA_CIPHER_WEP_40) : \
+			WSEC_TKIP_ENABLED(wsec) ? WPA_CIPHER_TKIP : \
+			WSEC_AES_ENABLED(wsec) ? WPA_CIPHER_AES_CCM : \
+			WPA_CIPHER_NONE)
+
+/* Look for a WPA IE; return it's address if found, NULL otherwise */
+extern wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len);
+
+/* Check whether the given IE looks like WFA IE with the specific type. */
+extern bool bcm_is_wfa_ie(uint8 * ie, uint8 ** tlvs, uint * tlvs_len,
+			  uint8 type);
+/* Check whether pointed-to IE looks like WPA. */
+#define bcm_is_wpa_ie(ie, tlvs, len)	bcm_is_wfa_ie(ie, tlvs, len, WFA_OUI_TYPE_WPA)
+
+#endif				/* _BCMWPA_H_ */
diff --git a/drivers/staging/brcm80211/include/bitfuncs.h b/drivers/staging/brcm80211/include/bitfuncs.h
new file mode 100644
index 0000000..18842ef
--- /dev/null
+++ b/drivers/staging/brcm80211/include/bitfuncs.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BITFUNCS_H
+#define _BITFUNCS_H
+
+#include <typedefs.h>
+
+/* local prototypes */
+static INLINE uint32 find_msbit(uint32 x);
+
+/*
+ * find_msbit: returns index of most significant set bit in x, with index
+ *   range defined as 0-31.  NOTE: returns zero if input is zero.
+ */
+
+#if defined(USE_PENTIUM_BSR) && defined(__GNUC__)
+
+/*
+ * Implementation for Pentium processors and gcc.  Note that this
+ * instruction is actually very slow on some processors (e.g., family 5,
+ * model 2, stepping 12, "Pentium 75 - 200"), so we use the generic
+ * implementation instead.
+ */
+static INLINE uint32 find_msbit(uint32 x)
+{
+	uint msbit;
+ __asm__("bsrl %1,%0":"=r"(msbit)
+ :		"r"(x));
+	return msbit;
+}
+
+#else				/* !USE_PENTIUM_BSR || !__GNUC__ */
+
+/*
+ * Generic Implementation
+ */
+
+#define DB_POW_MASK16	0xffff0000
+#define DB_POW_MASK8	0x0000ff00
+#define DB_POW_MASK4	0x000000f0
+#define DB_POW_MASK2	0x0000000c
+#define DB_POW_MASK1	0x00000002
+
+static INLINE uint32 find_msbit(uint32 x)
+{
+	uint32 temp_x = x;
+	uint msbit = 0;
+	if (temp_x & DB_POW_MASK16) {
+		temp_x >>= 16;
+		msbit = 16;
+	}
+	if (temp_x & DB_POW_MASK8) {
+		temp_x >>= 8;
+		msbit += 8;
+	}
+	if (temp_x & DB_POW_MASK4) {
+		temp_x >>= 4;
+		msbit += 4;
+	}
+	if (temp_x & DB_POW_MASK2) {
+		temp_x >>= 2;
+		msbit += 2;
+	}
+	if (temp_x & DB_POW_MASK1) {
+		msbit += 1;
+	}
+	return (msbit);
+}
+
+#endif				/* USE_PENTIUM_BSR && __GNUC__ */
+
+#endif				/* _BITFUNCS_H */
diff --git a/drivers/staging/brcm80211/include/d11.h b/drivers/staging/brcm80211/include/d11.h
new file mode 100644
index 0000000..378832c
--- /dev/null
+++ b/drivers/staging/brcm80211/include/d11.h
@@ -0,0 +1,1775 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_D11_H
+#define	_D11_H
+
+#include <typedefs.h>
+#include <bcmdevs.h>
+#include <hndsoc.h>
+#include <sbhndpio.h>
+#include <sbhnddma.h>
+#include <proto/802.11.h>
+
+/* This marks the start of a packed structure section. */
+#include <packed_section_start.h>
+
+#ifndef WL_RSSI_ANT_MAX
+#define WL_RSSI_ANT_MAX		4	/* max possible rx antennas */
+#elif WL_RSSI_ANT_MAX != 4
+#error "WL_RSSI_ANT_MAX does not match"
+#endif
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef	PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+#define	BCN_TMPL_LEN		512	/* length of the BCN template area */
+
+/* RX FIFO numbers */
+#define	RX_FIFO			0	/* data and ctl frames */
+#define	RX_TXSTATUS_FIFO	3	/* RX fifo for tx status packages */
+
+/* TX FIFO numbers using WME Access Classes */
+#define	TX_AC_BK_FIFO		0	/* Access Category Background TX FIFO */
+#define	TX_AC_BE_FIFO		1	/* Access Category Best-Effort TX FIFO */
+#define	TX_AC_VI_FIFO		2	/* Access Class Video TX FIFO */
+#define	TX_AC_VO_FIFO		3	/* Access Class Voice TX FIFO */
+#define	TX_BCMC_FIFO		4	/* Broadcast/Multicast TX FIFO */
+#define	TX_ATIM_FIFO		5	/* TX fifo for ATIM window info */
+
+/* Addr is byte address used by SW; offset is word offset used by uCode */
+
+/* Per AC TX limit settings */
+#define M_AC_TXLMT_BASE_ADDR         (0x180 * 2)
+#define M_AC_TXLMT_ADDR(_ac)         (M_AC_TXLMT_BASE_ADDR + (2 * (_ac)))
+
+/* Legacy TX FIFO numbers */
+#define	TX_DATA_FIFO		TX_AC_BE_FIFO
+#define	TX_CTL_FIFO		TX_AC_VO_FIFO
+
+typedef volatile struct {
+	uint32 intstatus;
+	uint32 intmask;
+} intctrlregs_t;
+
+/* read: 32-bit register that can be read as 32-bit or as 2 16-bit
+ * write: only low 16b-it half can be written
+ */
+typedef volatile union {
+	uint32 pmqhostdata;	/* read only! */
+	struct {
+		uint16 pmqctrlstatus;	/* read/write */
+		uint16 PAD;
+	} w;
+} pmqreg_t;
+
+/* pio register set 2/4 bytes union for d11 fifo */
+typedef volatile union {
+	pio2regp_t b2;		/* < corerev 8 */
+	pio4regp_t b4;		/* >= corerev 8 */
+} u_pioreg_t;
+
+/* dma/pio corerev < 11 */
+typedef volatile struct {
+	dma32regp_t dmaregs[8];	/* 0x200 - 0x2fc */
+	u_pioreg_t pioregs[8];	/* 0x300 */
+} fifo32_t;
+
+/* dma/pio corerev >= 11 */
+typedef volatile struct {
+	dma64regs_t dmaxmt;	/* dma tx */
+	pio4regs_t piotx;	/* pio tx */
+	dma64regs_t dmarcv;	/* dma rx */
+	pio4regs_t piorx;	/* pio rx */
+} fifo64_t;
+
+/*
+ * Host Interface Registers
+ * - primed from hnd_cores/dot11mac/systemC/registers/ihr.h
+ * - but definitely not complete
+ */
+typedef volatile struct _d11regs {
+	/* Device Control ("semi-standard host registers") */
+	uint32 PAD[3];		/* 0x0 - 0x8 */
+	uint32 biststatus;	/* 0xC */
+	uint32 biststatus2;	/* 0x10 */
+	uint32 PAD;		/* 0x14 */
+	uint32 gptimer;		/* 0x18 *//* for corerev >= 3 */
+	uint32 usectimer;	/* 0x1c *//* for corerev >= 26 */
+
+	/* Interrupt Control *//* 0x20 */
+	intctrlregs_t intctrlregs[8];
+
+	uint32 PAD[40];		/* 0x60 - 0xFC */
+
+	/* tx fifos 6-7 and rx fifos 1-3 removed in corerev 5 */
+	uint32 intrcvlazy[4];	/* 0x100 - 0x10C */
+
+	uint32 PAD[4];		/* 0x110 - 0x11c */
+
+	uint32 maccontrol;	/* 0x120 */
+	uint32 maccommand;	/* 0x124 */
+	uint32 macintstatus;	/* 0x128 */
+	uint32 macintmask;	/* 0x12C */
+
+	/* Transmit Template Access */
+	uint32 tplatewrptr;	/* 0x130 */
+	uint32 tplatewrdata;	/* 0x134 */
+	uint32 PAD[2];		/* 0x138 - 0x13C */
+
+	/* PMQ registers */
+	pmqreg_t pmqreg;	/* 0x140 */
+	uint32 pmqpatl;		/* 0x144 */
+	uint32 pmqpath;		/* 0x148 */
+	uint32 PAD;		/* 0x14C */
+
+	uint32 chnstatus;	/* 0x150 */
+	uint32 psmdebug;	/* 0x154 *//* for corerev >= 3 */
+	uint32 phydebug;	/* 0x158 *//* for corerev >= 3 */
+	uint32 machwcap;	/* 0x15C *//* Corerev >= 13 */
+
+	/* Extended Internal Objects */
+	uint32 objaddr;		/* 0x160 */
+	uint32 objdata;		/* 0x164 */
+	uint32 PAD[2];		/* 0x168 - 0x16c */
+
+	/* New txstatus registers on corerev >= 5 */
+	uint32 frmtxstatus;	/* 0x170 */
+	uint32 frmtxstatus2;	/* 0x174 */
+	uint32 PAD[2];		/* 0x178 - 0x17c */
+
+	/* New TSF host access on corerev >= 3 */
+
+	uint32 tsf_timerlow;	/* 0x180 */
+	uint32 tsf_timerhigh;	/* 0x184 */
+	uint32 tsf_cfprep;	/* 0x188 */
+	uint32 tsf_cfpstart;	/* 0x18c */
+	uint32 tsf_cfpmaxdur32;	/* 0x190 */
+	uint32 PAD[3];		/* 0x194 - 0x19c */
+
+	uint32 maccontrol1;	/* 0x1a0 */
+	uint32 machwcap1;	/* 0x1a4 */
+	uint32 PAD[14];		/* 0x1a8 - 0x1dc */
+
+	/* Clock control and hardware workarounds (corerev >= 13) */
+	uint32 clk_ctl_st;	/* 0x1e0 */
+	uint32 hw_war;
+	uint32 d11_phypllctl;	/* 0x1e8 (corerev == 16), the phypll request/avail bits are
+				 *   moved to clk_ctl_st for corerev >= 17
+				 */
+	uint32 PAD[5];		/* 0x1ec - 0x1fc */
+
+	/* 0x200-0x37F dma/pio registers */
+	volatile union {
+		fifo32_t f32regs;	/* tx fifos 6-7 and rx fifos 1-3 (corerev < 5) */
+		fifo64_t f64regs[6];	/* on corerev >= 11 */
+	} fifo;
+
+	/* FIFO diagnostic port access */
+	dma32diag_t dmafifo;	/* 0x380 - 0x38C */
+
+	uint32 aggfifocnt;	/* 0x390 */
+	uint32 aggfifodata;	/* 0x394 */
+	uint32 PAD[16];		/* 0x398 - 0x3d4 */
+	uint16 radioregaddr;	/* 0x3d8 */
+	uint16 radioregdata;	/* 0x3da */
+
+	/* time delay between the change on rf disable input and radio shutdown corerev 10 */
+	uint32 rfdisabledly;	/* 0x3DC */
+
+	/* PHY register access */
+	uint16 phyversion;	/* 0x3e0 - 0x0 */
+	uint16 phybbconfig;	/* 0x3e2 - 0x1 */
+	uint16 phyadcbias;	/* 0x3e4 - 0x2  Bphy only */
+	uint16 phyanacore;	/* 0x3e6 - 0x3  pwwrdwn on aphy */
+	uint16 phyrxstatus0;	/* 0x3e8 - 0x4 */
+	uint16 phyrxstatus1;	/* 0x3ea - 0x5 */
+	uint16 phycrsth;	/* 0x3ec - 0x6 */
+	uint16 phytxerror;	/* 0x3ee - 0x7 */
+	uint16 phychannel;	/* 0x3f0 - 0x8 */
+	uint16 PAD[1];		/* 0x3f2 - 0x9 */
+	uint16 phytest;		/* 0x3f4 - 0xa */
+	uint16 phy4waddr;	/* 0x3f6 - 0xb */
+	uint16 phy4wdatahi;	/* 0x3f8 - 0xc */
+	uint16 phy4wdatalo;	/* 0x3fa - 0xd */
+	uint16 phyregaddr;	/* 0x3fc - 0xe */
+	uint16 phyregdata;	/* 0x3fe - 0xf */
+
+	/* IHR *//* 0x400 - 0x7FE */
+
+	/* RXE Block */
+	uint16 PAD[3];		/* 0x400 - 0x406 */
+	uint16 rcv_fifo_ctl;	/* 0x406 */
+	uint16 PAD;		/* 0x408 - 0x40a */
+	uint16 rcv_frm_cnt;	/* 0x40a */
+	uint16 PAD[4];		/* 0x40a - 0x414 */
+	uint16 rssi;		/* 0x414 */
+	uint16 PAD[5];		/* 0x414 - 0x420 */
+	uint16 rcm_ctl;		/* 0x420 */
+	uint16 rcm_mat_data;	/* 0x422 */
+	uint16 rcm_mat_mask;	/* 0x424 */
+	uint16 rcm_mat_dly;	/* 0x426 */
+	uint16 rcm_cond_mask_l;	/* 0x428 */
+	uint16 rcm_cond_mask_h;	/* 0x42A */
+	uint16 rcm_cond_dly;	/* 0x42C */
+	uint16 PAD[1];		/* 0x42E */
+	uint16 ext_ihr_addr;	/* 0x430 */
+	uint16 ext_ihr_data;	/* 0x432 */
+	uint16 rxe_phyrs_2;	/* 0x434 */
+	uint16 rxe_phyrs_3;	/* 0x436 */
+	uint16 phy_mode;	/* 0x438 */
+	uint16 rcmta_ctl;	/* 0x43a */
+	uint16 rcmta_size;	/* 0x43c */
+	uint16 rcmta_addr0;	/* 0x43e */
+	uint16 rcmta_addr1;	/* 0x440 */
+	uint16 rcmta_addr2;	/* 0x442 */
+	uint16 PAD[30];		/* 0x444 - 0x480 */
+
+	/* PSM Block *//* 0x480 - 0x500 */
+
+	uint16 PAD;		/* 0x480 */
+	uint16 psm_maccontrol_h;	/* 0x482 */
+	uint16 psm_macintstatus_l;	/* 0x484 */
+	uint16 psm_macintstatus_h;	/* 0x486 */
+	uint16 psm_macintmask_l;	/* 0x488 */
+	uint16 psm_macintmask_h;	/* 0x48A */
+	uint16 PAD;		/* 0x48C */
+	uint16 psm_maccommand;	/* 0x48E */
+	uint16 psm_brc;		/* 0x490 */
+	uint16 psm_phy_hdr_param;	/* 0x492 */
+	uint16 psm_postcard;	/* 0x494 */
+	uint16 psm_pcard_loc_l;	/* 0x496 */
+	uint16 psm_pcard_loc_h;	/* 0x498 */
+	uint16 psm_gpio_in;	/* 0x49A */
+	uint16 psm_gpio_out;	/* 0x49C */
+	uint16 psm_gpio_oe;	/* 0x49E */
+
+	uint16 psm_bred_0;	/* 0x4A0 */
+	uint16 psm_bred_1;	/* 0x4A2 */
+	uint16 psm_bred_2;	/* 0x4A4 */
+	uint16 psm_bred_3;	/* 0x4A6 */
+	uint16 psm_brcl_0;	/* 0x4A8 */
+	uint16 psm_brcl_1;	/* 0x4AA */
+	uint16 psm_brcl_2;	/* 0x4AC */
+	uint16 psm_brcl_3;	/* 0x4AE */
+	uint16 psm_brpo_0;	/* 0x4B0 */
+	uint16 psm_brpo_1;	/* 0x4B2 */
+	uint16 psm_brpo_2;	/* 0x4B4 */
+	uint16 psm_brpo_3;	/* 0x4B6 */
+	uint16 psm_brwk_0;	/* 0x4B8 */
+	uint16 psm_brwk_1;	/* 0x4BA */
+	uint16 psm_brwk_2;	/* 0x4BC */
+	uint16 psm_brwk_3;	/* 0x4BE */
+
+	uint16 psm_base_0;	/* 0x4C0 */
+	uint16 psm_base_1;	/* 0x4C2 */
+	uint16 psm_base_2;	/* 0x4C4 */
+	uint16 psm_base_3;	/* 0x4C6 */
+	uint16 psm_base_4;	/* 0x4C8 */
+	uint16 psm_base_5;	/* 0x4CA */
+	uint16 psm_base_6;	/* 0x4CC */
+	uint16 psm_pc_reg_0;	/* 0x4CE */
+	uint16 psm_pc_reg_1;	/* 0x4D0 */
+	uint16 psm_pc_reg_2;	/* 0x4D2 */
+	uint16 psm_pc_reg_3;	/* 0x4D4 */
+	uint16 PAD[0xD];	/* 0x4D6 - 0x4DE */
+	uint16 psm_corectlsts;	/* 0x4f0 *//* Corerev >= 13 */
+	uint16 PAD[0x7];	/* 0x4f2 - 0x4fE */
+
+	/* TXE0 Block *//* 0x500 - 0x580 */
+	uint16 txe_ctl;		/* 0x500 */
+	uint16 txe_aux;		/* 0x502 */
+	uint16 txe_ts_loc;	/* 0x504 */
+	uint16 txe_time_out;	/* 0x506 */
+	uint16 txe_wm_0;	/* 0x508 */
+	uint16 txe_wm_1;	/* 0x50A */
+	uint16 txe_phyctl;	/* 0x50C */
+	uint16 txe_status;	/* 0x50E */
+	uint16 txe_mmplcp0;	/* 0x510 */
+	uint16 txe_mmplcp1;	/* 0x512 */
+	uint16 txe_phyctl1;	/* 0x514 */
+
+	uint16 PAD[0x05];	/* 0x510 - 0x51E */
+
+	/* Transmit control */
+	uint16 xmtfifodef;	/* 0x520 */
+	uint16 xmtfifo_frame_cnt;	/* 0x522 *//* Corerev >= 16 */
+	uint16 xmtfifo_byte_cnt;	/* 0x524 *//* Corerev >= 16 */
+	uint16 xmtfifo_head;	/* 0x526 *//* Corerev >= 16 */
+	uint16 xmtfifo_rd_ptr;	/* 0x528 *//* Corerev >= 16 */
+	uint16 xmtfifo_wr_ptr;	/* 0x52A *//* Corerev >= 16 */
+	uint16 xmtfifodef1;	/* 0x52C *//* Corerev >= 16 */
+
+	uint16 PAD[0x09];	/* 0x52E - 0x53E */
+
+	uint16 xmtfifocmd;	/* 0x540 */
+	uint16 xmtfifoflush;	/* 0x542 */
+	uint16 xmtfifothresh;	/* 0x544 */
+	uint16 xmtfifordy;	/* 0x546 */
+	uint16 xmtfifoprirdy;	/* 0x548 */
+	uint16 xmtfiforqpri;	/* 0x54A */
+	uint16 xmttplatetxptr;	/* 0x54C */
+	uint16 PAD;		/* 0x54E */
+	uint16 xmttplateptr;	/* 0x550 */
+	uint16 smpl_clct_strptr;	/* 0x552 *//* Corerev >= 22 */
+	uint16 smpl_clct_stpptr;	/* 0x554 *//* Corerev >= 22 */
+	uint16 smpl_clct_curptr;	/* 0x556 *//* Corerev >= 22 */
+	uint16 PAD[0x04];	/* 0x558 - 0x55E */
+	uint16 xmttplatedatalo;	/* 0x560 */
+	uint16 xmttplatedatahi;	/* 0x562 */
+
+	uint16 PAD[2];		/* 0x564 - 0x566 */
+
+	uint16 xmtsel;		/* 0x568 */
+	uint16 xmttxcnt;	/* 0x56A */
+	uint16 xmttxshmaddr;	/* 0x56C */
+
+	uint16 PAD[0x09];	/* 0x56E - 0x57E */
+
+	/* TXE1 Block */
+	uint16 PAD[0x40];	/* 0x580 - 0x5FE */
+
+	/* TSF Block */
+	uint16 PAD[0X02];	/* 0x600 - 0x602 */
+	uint16 tsf_cfpstrt_l;	/* 0x604 */
+	uint16 tsf_cfpstrt_h;	/* 0x606 */
+	uint16 PAD[0X05];	/* 0x608 - 0x610 */
+	uint16 tsf_cfppretbtt;	/* 0x612 */
+	uint16 PAD[0XD];	/* 0x614 - 0x62C */
+	uint16 tsf_clk_frac_l;	/* 0x62E */
+	uint16 tsf_clk_frac_h;	/* 0x630 */
+	uint16 PAD[0X14];	/* 0x632 - 0x658 */
+	uint16 tsf_random;	/* 0x65A */
+	uint16 PAD[0x05];	/* 0x65C - 0x664 */
+	/* GPTimer 2 registers are corerev >= 3 */
+	uint16 tsf_gpt2_stat;	/* 0x666 */
+	uint16 tsf_gpt2_ctr_l;	/* 0x668 */
+	uint16 tsf_gpt2_ctr_h;	/* 0x66A */
+	uint16 tsf_gpt2_val_l;	/* 0x66C */
+	uint16 tsf_gpt2_val_h;	/* 0x66E */
+	uint16 tsf_gptall_stat;	/* 0x670 */
+	uint16 PAD[0x07];	/* 0x672 - 0x67E */
+
+	/* IFS Block */
+	uint16 ifs_sifs_rx_tx_tx;	/* 0x680 */
+	uint16 ifs_sifs_nav_tx;	/* 0x682 */
+	uint16 ifs_slot;	/* 0x684 */
+	uint16 PAD;		/* 0x686 */
+	uint16 ifs_ctl;		/* 0x688 */
+	uint16 PAD[0x3];	/* 0x68a - 0x68F */
+	uint16 ifsstat;		/* 0x690 */
+	uint16 ifsmedbusyctl;	/* 0x692 */
+	uint16 iftxdur;		/* 0x694 */
+	uint16 PAD[0x3];	/* 0x696 - 0x69b */
+	/* EDCF support in dot11macs with corerevs >= 16 */
+	uint16 ifs_aifsn;	/* 0x69c */
+	uint16 ifs_ctl1;	/* 0x69e */
+
+	/* New slow clock registers on corerev >= 5 */
+	uint16 scc_ctl;		/* 0x6a0 */
+	uint16 scc_timer_l;	/* 0x6a2 */
+	uint16 scc_timer_h;	/* 0x6a4 */
+	uint16 scc_frac;	/* 0x6a6 */
+	uint16 scc_fastpwrup_dly;	/* 0x6a8 */
+	uint16 scc_per;		/* 0x6aa */
+	uint16 scc_per_frac;	/* 0x6ac */
+	uint16 scc_cal_timer_l;	/* 0x6ae */
+	uint16 scc_cal_timer_h;	/* 0x6b0 */
+	uint16 PAD;		/* 0x6b2 */
+
+	uint16 PAD[0x26];
+
+	/* NAV Block */
+	uint16 nav_ctl;		/* 0x700 */
+	uint16 navstat;		/* 0x702 */
+	uint16 PAD[0x3e];	/* 0x702 - 0x77E */
+
+	/* WEP/PMQ Block *//* 0x780 - 0x7FE */
+	uint16 PAD[0x20];	/* 0x780 - 0x7BE */
+
+	uint16 wepctl;		/* 0x7C0 */
+	uint16 wepivloc;	/* 0x7C2 */
+	uint16 wepivkey;	/* 0x7C4 */
+	uint16 wepwkey;		/* 0x7C6 */
+
+	uint16 PAD[4];		/* 0x7C8 - 0x7CE */
+	uint16 pcmctl;		/* 0X7D0 */
+	uint16 pcmstat;		/* 0X7D2 */
+	uint16 PAD[6];		/* 0x7D4 - 0x7DE */
+
+	uint16 pmqctl;		/* 0x7E0 */
+	uint16 pmqstatus;	/* 0x7E2 */
+	uint16 pmqpat0;		/* 0x7E4 */
+	uint16 pmqpat1;		/* 0x7E6 */
+	uint16 pmqpat2;		/* 0x7E8 */
+
+	uint16 pmqdat;		/* 0x7EA */
+	uint16 pmqdator;	/* 0x7EC */
+	uint16 pmqhst;		/* 0x7EE */
+	uint16 pmqpath0;	/* 0x7F0 */
+	uint16 pmqpath1;	/* 0x7F2 */
+	uint16 pmqpath2;	/* 0x7F4 */
+	uint16 pmqdath;		/* 0x7F6 */
+
+	uint16 PAD[0x04];	/* 0x7F8 - 0x7FE */
+
+	/* SHM *//* 0x800 - 0xEFE */
+	uint16 PAD[0x380];	/* 0x800 - 0xEFE */
+
+	/* SB configuration registers: 0xF00 */
+	sbconfig_t sbconfig;	/* sb config regs occupy top 256 bytes */
+} d11regs_t;
+
+#define	PIHR_BASE	0x0400	/* byte address of packed IHR region */
+
+/* biststatus */
+#define	BT_DONE		(1U << 31)	/* bist done */
+#define	BT_B2S		(1 << 30)	/* bist2 ram summary bit */
+
+/* intstatus and intmask */
+#define	I_PC		(1 << 10)	/* pci descriptor error */
+#define	I_PD		(1 << 11)	/* pci data error */
+#define	I_DE		(1 << 12)	/* descriptor protocol error */
+#define	I_RU		(1 << 13)	/* receive descriptor underflow */
+#define	I_RO		(1 << 14)	/* receive fifo overflow */
+#define	I_XU		(1 << 15)	/* transmit fifo underflow */
+#define	I_RI		(1 << 16)	/* receive interrupt */
+#define	I_XI		(1 << 24)	/* transmit interrupt */
+
+/* interrupt receive lazy */
+#define	IRL_TO_MASK		0x00ffffff	/* timeout */
+#define	IRL_FC_MASK		0xff000000	/* frame count */
+#define	IRL_FC_SHIFT		24	/* frame count */
+
+/* maccontrol register */
+#define	MCTL_GMODE		(1U << 31)
+#define	MCTL_DISCARD_PMQ	(1 << 30)
+#define	MCTL_WAKE		(1 << 26)
+#define	MCTL_HPS		(1 << 25)
+#define	MCTL_PROMISC		(1 << 24)
+#define	MCTL_KEEPBADFCS		(1 << 23)
+#define	MCTL_KEEPCONTROL	(1 << 22)
+#define	MCTL_PHYLOCK		(1 << 21)
+#define	MCTL_BCNS_PROMISC	(1 << 20)
+#define	MCTL_LOCK_RADIO		(1 << 19)
+#define	MCTL_AP			(1 << 18)
+#define	MCTL_INFRA		(1 << 17)
+#define	MCTL_BIGEND		(1 << 16)
+#define	MCTL_GPOUT_SEL_MASK	(3 << 14)
+#define	MCTL_GPOUT_SEL_SHIFT	14
+#define	MCTL_EN_PSMDBG		(1 << 13)
+#define	MCTL_IHR_EN		(1 << 10)
+#define	MCTL_SHM_UPPER		(1 <<  9)
+#define	MCTL_SHM_EN		(1 <<  8)
+#define	MCTL_PSM_JMP_0		(1 <<  2)
+#define	MCTL_PSM_RUN		(1 <<  1)
+#define	MCTL_EN_MAC		(1 <<  0)
+
+/* maccommand register */
+#define	MCMD_BCN0VLD		(1 <<  0)
+#define	MCMD_BCN1VLD		(1 <<  1)
+#define	MCMD_DIRFRMQVAL		(1 <<  2)
+#define	MCMD_CCA		(1 <<  3)
+#define	MCMD_BG_NOISE		(1 <<  4)
+#define	MCMD_SKIP_SHMINIT	(1 <<  5)	/* only used for simulation */
+#define MCMD_SAMPLECOLL		MCMD_SKIP_SHMINIT	/* reuse for sample collect */
+
+/* macintstatus/macintmask */
+#define	MI_MACSSPNDD		(1 <<  0)	/* MAC has gracefully suspended */
+#define	MI_BCNTPL		(1 <<  1)	/* beacon template available */
+#define	MI_TBTT			(1 <<  2)	/* TBTT indication */
+#define	MI_BCNSUCCESS		(1 <<  3)	/* beacon successfully tx'd */
+#define	MI_BCNCANCLD		(1 <<  4)	/* beacon canceled (IBSS) */
+#define	MI_ATIMWINEND		(1 <<  5)	/* end of ATIM-window (IBSS) */
+#define	MI_PMQ			(1 <<  6)	/* PMQ entries available */
+#define	MI_NSPECGEN_0		(1 <<  7)	/* non-specific gen-stat bits that are set by PSM */
+#define	MI_NSPECGEN_1		(1 <<  8)	/* non-specific gen-stat bits that are set by PSM */
+#define	MI_MACTXERR		(1 <<  9)	/* MAC level Tx error */
+#define	MI_NSPECGEN_3		(1 << 10)	/* non-specific gen-stat bits that are set by PSM */
+#define	MI_PHYTXERR		(1 << 11)	/* PHY Tx error */
+#define	MI_PME			(1 << 12)	/* Power Management Event */
+#define	MI_GP0			(1 << 13)	/* General-purpose timer0 */
+#define	MI_GP1			(1 << 14)	/* General-purpose timer1 */
+#define	MI_DMAINT		(1 << 15)	/* (ORed) DMA-interrupts */
+#define	MI_TXSTOP		(1 << 16)	/* MAC has completed a TX FIFO Suspend/Flush */
+#define	MI_CCA			(1 << 17)	/* MAC has completed a CCA measurement */
+#define	MI_BG_NOISE		(1 << 18)	/* MAC has collected background noise samples */
+#define	MI_DTIM_TBTT		(1 << 19)	/* MBSS DTIM TBTT indication */
+#define MI_PRQ			(1 << 20)	/* Probe response queue needs attention */
+#define	MI_PWRUP		(1 << 21)	/* Radio/PHY has been powered back up. */
+#define	MI_RESERVED3		(1 << 22)
+#define	MI_RESERVED2		(1 << 23)
+#define MI_RESERVED1		(1 << 25)
+#define MI_RFDISABLE		(1 << 28)	/* MAC detected a change on RF Disable input
+						 * (corerev >= 10)
+						 */
+#define	MI_TFS			(1 << 29)	/* MAC has completed a TX (corerev >= 5) */
+#define	MI_PHYCHANGED		(1 << 30)	/* A phy status change wrt G mode */
+#define	MI_TO			(1U << 31)	/* general purpose timeout (corerev >= 3) */
+
+/* Mac capabilities registers */
+/* machwcap */
+#define	MCAP_TKIPMIC		0x80000000	/* TKIP MIC hardware present */
+
+/* pmqhost data */
+#define	PMQH_DATA_MASK		0xffff0000	/* data entry of head pmq entry */
+#define	PMQH_BSSCFG		0x00100000	/* PM entry for BSS config */
+#define	PMQH_PMOFF		0x00010000	/* PM Mode OFF: power save off */
+#define	PMQH_PMON		0x00020000	/* PM Mode ON: power save on */
+#define	PMQH_DASAT		0x00040000	/* Dis-associated or De-authenticated */
+#define	PMQH_ATIMFAIL		0x00080000	/* ATIM not acknowledged */
+#define	PMQH_DEL_ENTRY		0x00000001	/* delete head entry */
+#define	PMQH_DEL_MULT		0x00000002	/* delete head entry to cur read pointer -1 */
+#define	PMQH_OFLO		0x00000004	/* pmq overflow indication */
+#define	PMQH_NOT_EMPTY		0x00000008	/* entries are present in pmq */
+
+/* phydebug (corerev >= 3) */
+#define	PDBG_CRS		(1 << 0)	/* phy is asserting carrier sense */
+#define	PDBG_TXA		(1 << 1)	/* phy is taking xmit byte from mac this cycle */
+#define	PDBG_TXF		(1 << 2)	/* mac is instructing the phy to transmit a frame */
+#define	PDBG_TXE		(1 << 3)	/* phy is signalling a transmit Error to the mac */
+#define	PDBG_RXF		(1 << 4)	/* phy detected the end of a valid frame preamble */
+#define	PDBG_RXS		(1 << 5)	/* phy detected the end of a valid PLCP header */
+#define	PDBG_RXFRG		(1 << 6)	/* rx start not asserted */
+#define	PDBG_RXV		(1 << 7)	/* mac is taking receive byte from phy this cycle */
+#define	PDBG_RFD		(1 << 16)	/* RF portion of the radio is disabled */
+
+/* objaddr register */
+#define	OBJADDR_SEL_MASK	0x000F0000
+#define	OBJADDR_UCM_SEL		0x00000000
+#define	OBJADDR_SHM_SEL		0x00010000
+#define	OBJADDR_SCR_SEL		0x00020000
+#define	OBJADDR_IHR_SEL		0x00030000
+#define	OBJADDR_RCMTA_SEL	0x00040000
+#define	OBJADDR_SRCHM_SEL	0x00060000
+#define	OBJADDR_WINC		0x01000000
+#define	OBJADDR_RINC		0x02000000
+#define	OBJADDR_AUTO_INC	0x03000000
+
+#define	WEP_PCMADDR		0x07d4
+#define	WEP_PCMDATA		0x07d6
+
+/* frmtxstatus */
+#define	TXS_V			(1 << 0)	/* valid bit */
+#define	TXS_STATUS_MASK		0xffff
+/* sw mask to map txstatus for corerevs <= 4 to be the same as for corerev > 4 */
+#define	TXS_COMPAT_MASK		0x3
+#define	TXS_COMPAT_SHIFT	1
+#define	TXS_FID_MASK		0xffff0000
+#define	TXS_FID_SHIFT		16
+
+/* frmtxstatus2 */
+#define	TXS_SEQ_MASK		0xffff
+#define	TXS_PTX_MASK		0xff0000
+#define	TXS_PTX_SHIFT		16
+#define	TXS_MU_MASK		0x01000000
+#define	TXS_MU_SHIFT		24
+
+/* clk_ctl_st, corerev >= 17 */
+#define CCS_ERSRC_REQ_D11PLL	0x00000100	/* d11 core pll request */
+#define CCS_ERSRC_REQ_PHYPLL	0x00000200	/* PHY pll request */
+#define CCS_ERSRC_AVAIL_D11PLL	0x01000000	/* d11 core pll available */
+#define CCS_ERSRC_AVAIL_PHYPLL	0x02000000	/* PHY pll available */
+
+/* HT Cloclk Ctrl and Clock Avail for 4313 */
+#define CCS_ERSRC_REQ_HT    0x00000010	/* HT avail request */
+#define CCS_ERSRC_AVAIL_HT  0x00020000	/* HT clock available */
+
+/* d11_pwrctl, corerev16 only */
+#define D11_PHYPLL_AVAIL_REQ	0x000010000	/* request PHY PLL resource */
+#define D11_PHYPLL_AVAIL_STS	0x001000000	/* PHY PLL is available */
+
+/* tsf_cfprep register */
+#define	CFPREP_CBI_MASK		0xffffffc0
+#define	CFPREP_CBI_SHIFT	6
+#define	CFPREP_CFPP		0x00000001
+
+/* tx fifo sizes for corerev >= 9 */
+/* tx fifo sizes values are in terms of 256 byte blocks */
+#define TXFIFOCMD_RESET_MASK	(1 << 15)	/* reset */
+#define TXFIFOCMD_FIFOSEL_SHIFT	8	/* fifo */
+#define TXFIFO_FIFOTOP_SHIFT	8	/* fifo start */
+
+#define TXFIFO_START_BLK16	 65	/* Base address + 32 * 512 B/P */
+#define TXFIFO_START_BLK	 6	/* Base address + 6 * 256 B */
+#define TXFIFO_SIZE_UNIT	256	/* one unit corresponds to 256 bytes */
+#define MBSS16_TEMPLMEM_MINBLKS	65	/* one unit corresponds to 256 bytes */
+
+/* phy versions, PhyVersion:Revision field */
+#define	PV_AV_MASK		0xf000	/* analog block version */
+#define	PV_AV_SHIFT		12	/* analog block version bitfield offset */
+#define	PV_PT_MASK		0x0f00	/* phy type */
+#define	PV_PT_SHIFT		8	/* phy type bitfield offset */
+#define	PV_PV_MASK		0x000f	/* phy version */
+#define	PHY_TYPE(v)		((v & PV_PT_MASK) >> PV_PT_SHIFT)
+
+/* phy types, PhyVersion:PhyType field */
+#define	PHY_TYPE_N		4	/* N-Phy value */
+#define	PHY_TYPE_SSN		6	/* SSLPN-Phy value */
+#define	PHY_TYPE_LCN		8	/* LCN-Phy value */
+#define	PHY_TYPE_LCNXN		9	/* LCNXN-Phy value */
+#define	PHY_TYPE_NULL		0xf	/* Invalid Phy value */
+
+/* analog types, PhyVersion:AnalogType field */
+#define	ANA_11N_013		5
+
+/* 802.11a PLCP header def */
+typedef struct ofdm_phy_hdr ofdm_phy_hdr_t;
+BWL_PRE_PACKED_STRUCT struct ofdm_phy_hdr {
+	uint8 rlpt[3];		/* rate, length, parity, tail */
+	uint16 service;
+	uint8 pad;
+} BWL_POST_PACKED_STRUCT;
+
+#define	D11A_PHY_HDR_GRATE(phdr)	((phdr)->rlpt[0] & 0x0f)
+#define	D11A_PHY_HDR_GRES(phdr)		(((phdr)->rlpt[0] >> 4) & 0x01)
+#define	D11A_PHY_HDR_GLENGTH(phdr)	(((uint32 *)((phdr)->rlpt) >> 5) & 0x0fff)
+#define	D11A_PHY_HDR_GPARITY(phdr)	(((phdr)->rlpt[3] >> 1) & 0x01)
+#define	D11A_PHY_HDR_GTAIL(phdr)	(((phdr)->rlpt[3] >> 2) & 0x3f)
+
+/* rate encoded per 802.11a-1999 sec 17.3.4.1 */
+#define	D11A_PHY_HDR_SRATE(phdr, rate)		\
+	((phdr)->rlpt[0] = ((phdr)->rlpt[0] & 0xf0) | ((rate) & 0xf))
+/* set reserved field to zero */
+#define	D11A_PHY_HDR_SRES(phdr)		((phdr)->rlpt[0] &= 0xef)
+/* length is number of octets in PSDU */
+#define	D11A_PHY_HDR_SLENGTH(phdr, length)	\
+	(*(uint32 *)((phdr)->rlpt) = *(uint32 *)((phdr)->rlpt) | \
+	(((length) & 0x0fff) << 5))
+/* set the tail to all zeros */
+#define	D11A_PHY_HDR_STAIL(phdr)	((phdr)->rlpt[3] &= 0x03)
+
+#define	D11A_PHY_HDR_LEN_L	3	/* low-rate part of PLCP header */
+#define	D11A_PHY_HDR_LEN_R	2	/* high-rate part of PLCP header */
+
+#define	D11A_PHY_TX_DELAY	(2)	/* 2.1 usec */
+
+#define	D11A_PHY_HDR_TIME	(4)	/* low-rate part of PLCP header */
+#define	D11A_PHY_PRE_TIME	(16)
+#define	D11A_PHY_PREHDR_TIME	(D11A_PHY_PRE_TIME + D11A_PHY_HDR_TIME)
+
+/* 802.11b PLCP header def */
+typedef struct cck_phy_hdr cck_phy_hdr_t;
+BWL_PRE_PACKED_STRUCT struct cck_phy_hdr {
+	uint8 signal;
+	uint8 service;
+	uint16 length;
+	uint16 crc;
+} BWL_POST_PACKED_STRUCT;
+
+#define	D11B_PHY_HDR_LEN	6
+
+#define	D11B_PHY_TX_DELAY	(3)	/* 3.4 usec */
+
+#define	D11B_PHY_LHDR_TIME	(D11B_PHY_HDR_LEN << 3)
+#define	D11B_PHY_LPRE_TIME	(144)
+#define	D11B_PHY_LPREHDR_TIME	(D11B_PHY_LPRE_TIME + D11B_PHY_LHDR_TIME)
+
+#define	D11B_PHY_SHDR_TIME	(D11B_PHY_LHDR_TIME >> 1)
+#define	D11B_PHY_SPRE_TIME	(D11B_PHY_LPRE_TIME >> 1)
+#define	D11B_PHY_SPREHDR_TIME	(D11B_PHY_SPRE_TIME + D11B_PHY_SHDR_TIME)
+
+#define	D11B_PLCP_SIGNAL_LOCKED	(1 << 2)
+#define	D11B_PLCP_SIGNAL_LE	(1 << 7)
+
+#define MIMO_PLCP_MCS_MASK	0x7f	/* mcs index */
+#define MIMO_PLCP_40MHZ		0x80	/* 40 Hz frame */
+#define MIMO_PLCP_AMPDU		0x08	/* ampdu */
+
+#define WLC_GET_CCK_PLCP_LEN(plcp) (plcp[4] + (plcp[5] << 8))
+#define WLC_GET_MIMO_PLCP_LEN(plcp) (plcp[1] + (plcp[2] << 8))
+#define WLC_SET_MIMO_PLCP_LEN(plcp, len) \
+	plcp[1] = len & 0xff; plcp[2] = ((len >> 8) & 0xff);
+
+#define WLC_SET_MIMO_PLCP_AMPDU(plcp) (plcp[3] |= MIMO_PLCP_AMPDU)
+#define WLC_CLR_MIMO_PLCP_AMPDU(plcp) (plcp[3] &= ~MIMO_PLCP_AMPDU)
+#define WLC_IS_MIMO_PLCP_AMPDU(plcp) (plcp[3] & MIMO_PLCP_AMPDU)
+
+/* The dot11a PLCP header is 5 bytes.  To simplify the software (so that we
+ * don't need e.g. different tx DMA headers for 11a and 11b), the PLCP header has
+ * padding added in the ucode.
+ */
+#define	D11_PHY_HDR_LEN	6
+
+/* TX DMA buffer header */
+typedef struct d11txh d11txh_t;
+BWL_PRE_PACKED_STRUCT struct d11txh {
+	uint16 MacTxControlLow;	/* 0x0 */
+	uint16 MacTxControlHigh;	/* 0x1 */
+	uint16 MacFrameControl;	/* 0x2 */
+	uint16 TxFesTimeNormal;	/* 0x3 */
+	uint16 PhyTxControlWord;	/* 0x4 */
+	uint16 PhyTxControlWord_1;	/* 0x5 */
+	uint16 PhyTxControlWord_1_Fbr;	/* 0x6 */
+	uint16 PhyTxControlWord_1_Rts;	/* 0x7 */
+	uint16 PhyTxControlWord_1_FbrRts;	/* 0x8 */
+	uint16 MainRates;	/* 0x9 */
+	uint16 XtraFrameTypes;	/* 0xa */
+	uint8 IV[16];		/* 0x0b - 0x12 */
+	uint8 TxFrameRA[6];	/* 0x13 - 0x15 */
+	uint16 TxFesTimeFallback;	/* 0x16 */
+	uint8 RTSPLCPFallback[6];	/* 0x17 - 0x19 */
+	uint16 RTSDurFallback;	/* 0x1a */
+	uint8 FragPLCPFallback[6];	/* 0x1b - 1d */
+	uint16 FragDurFallback;	/* 0x1e */
+	uint16 MModeLen;	/* 0x1f */
+	uint16 MModeFbrLen;	/* 0x20 */
+	uint16 TstampLow;	/* 0x21 */
+	uint16 TstampHigh;	/* 0x22 */
+	uint16 ABI_MimoAntSel;	/* 0x23 */
+	uint16 PreloadSize;	/* 0x24 */
+	uint16 AmpduSeqCtl;	/* 0x25 */
+	uint16 TxFrameID;	/* 0x26 */
+	uint16 TxStatus;	/* 0x27 */
+	uint16 MaxNMpdus;	/* 0x28 corerev >=16 */
+	uint16 MaxABytes_MRT;	/* 0x29 corerev >=16 */
+	uint16 MaxABytes_FBR;	/* 0x2a corerev >=16 */
+	uint16 MinMBytes;	/* 0x2b corerev >=16 */
+	uint8 RTSPhyHeader[D11_PHY_HDR_LEN];	/* 0x2c - 0x2e */
+	struct dot11_rts_frame rts_frame;	/* 0x2f - 0x36 */
+	uint16 PAD;		/* 0x37 */
+} BWL_POST_PACKED_STRUCT;
+
+#define	D11_TXH_LEN		112	/* bytes */
+
+/* Frame Types */
+#define FT_CCK	0
+#define FT_OFDM	1
+#define FT_HT	2
+#define FT_N	3
+
+/* Position of MPDU inside A-MPDU; indicated with bits 10:9 of MacTxControlLow */
+#define TXC_AMPDU_SHIFT		9	/* shift for ampdu settings */
+#define TXC_AMPDU_NONE		0	/* Regular MPDU, not an A-MPDU */
+#define TXC_AMPDU_FIRST		1	/* first MPDU of an A-MPDU */
+#define TXC_AMPDU_MIDDLE	2	/* intermediate MPDU of an A-MPDU */
+#define TXC_AMPDU_LAST		3	/* last (or single) MPDU of an A-MPDU */
+
+/* MacTxControlLow */
+#define TXC_AMIC		0x8000
+#define	TXC_SENDCTS		0x0800
+#define TXC_AMPDU_MASK		0x0600
+#define TXC_BW_40		0x0100
+#define TXC_FREQBAND_5G		0x0080
+#define	TXC_DFCS		0x0040
+#define	TXC_IGNOREPMQ		0x0020
+#define	TXC_HWSEQ		0x0010
+#define	TXC_STARTMSDU		0x0008
+#define	TXC_SENDRTS		0x0004
+#define	TXC_LONGFRAME		0x0002
+#define	TXC_IMMEDACK		0x0001
+
+/* MacTxControlHigh */
+#define TXC_PREAMBLE_RTS_FB_SHORT	0x8000	/* RTS fallback preamble type 1 = SHORT 0 = LONG */
+#define TXC_PREAMBLE_RTS_MAIN_SHORT	0x4000	/* RTS main rate preamble type 1 = SHORT 0 = LONG */
+#define TXC_PREAMBLE_DATA_FB_SHORT	0x2000	/* Main fallback rate preamble type
+						 * 1 = SHORT for OFDM/GF for MIMO
+						 * 0 = LONG for CCK/MM for MIMO
+						 */
+/* TXC_PREAMBLE_DATA_MAIN is in PhyTxControl bit 5 */
+#define	TXC_AMPDU_FBR		0x1000	/* use fallback rate for this AMPDU */
+#define	TXC_SECKEY_MASK		0x0FF0
+#define	TXC_SECKEY_SHIFT	4
+#define	TXC_ALT_TXPWR		0x0008	/* Use alternate txpwr defined at loc. M_ALT_TXPWR_IDX */
+#define	TXC_SECTYPE_MASK	0x0007
+#define	TXC_SECTYPE_SHIFT	0
+
+/* Null delimiter for Fallback rate */
+#define AMPDU_FBR_NULL_DELIM  5	/* Location of Null delimiter count for AMPDU */
+
+/* PhyTxControl for Mimophy */
+#define	PHY_TXC_PWR_MASK	0xFC00
+#define	PHY_TXC_PWR_SHIFT	10
+#define	PHY_TXC_ANT_MASK	0x03C0	/* bit 6, 7, 8, 9 */
+#define	PHY_TXC_ANT_SHIFT	6
+#define	PHY_TXC_ANT_0_1		0x00C0	/* auto, last rx */
+#define	PHY_TXC_LCNPHY_ANT_LAST	0x0000
+#define	PHY_TXC_ANT_3		0x0200	/* virtual antenna 3 */
+#define	PHY_TXC_ANT_2		0x0100	/* virtual antenna 2 */
+#define	PHY_TXC_ANT_1		0x0080	/* virtual antenna 1 */
+#define	PHY_TXC_ANT_0		0x0040	/* virtual antenna 0 */
+#define	PHY_TXC_SHORT_HDR	0x0010
+
+#define	PHY_TXC_OLD_ANT_0	0x0000
+#define	PHY_TXC_OLD_ANT_1	0x0100
+#define	PHY_TXC_OLD_ANT_LAST	0x0300
+
+/* PhyTxControl_1 for Mimophy */
+#define PHY_TXC1_BW_MASK		0x0007
+#define PHY_TXC1_BW_10MHZ		0
+#define PHY_TXC1_BW_10MHZ_UP		1
+#define PHY_TXC1_BW_20MHZ		2
+#define PHY_TXC1_BW_20MHZ_UP		3
+#define PHY_TXC1_BW_40MHZ		4
+#define PHY_TXC1_BW_40MHZ_DUP		5
+#define PHY_TXC1_MODE_SHIFT		3
+#define PHY_TXC1_MODE_MASK		0x0038
+#define PHY_TXC1_MODE_SISO		0
+#define PHY_TXC1_MODE_CDD		1
+#define PHY_TXC1_MODE_STBC		2
+#define PHY_TXC1_MODE_SDM		3
+
+/* PhyTxControl for HTphy that are different from Mimophy */
+#define	PHY_TXC_HTANT_MASK		0x3fC0	/* bit 6, 7, 8, 9, 10, 11, 12, 13 */
+
+/* XtraFrameTypes */
+#define XFTS_RTS_FT_SHIFT	2
+#define XFTS_FBRRTS_FT_SHIFT	4
+#define XFTS_CHANNEL_SHIFT	8
+
+/* Antenna diversity bit in ant_wr_settle */
+#define	PHY_AWS_ANTDIV		0x2000
+
+/* IFS ctl */
+#define IFS_USEEDCF	(1 << 2)
+
+/* IFS ctl1 */
+#define IFS_CTL1_EDCRS	(1 << 3)
+#define IFS_CTL1_EDCRS_20L (1 << 4)
+#define IFS_CTL1_EDCRS_40 (1 << 5)
+
+/* ABI_MimoAntSel */
+#define ABI_MAS_ADDR_BMP_IDX_MASK	0x0f00
+#define ABI_MAS_ADDR_BMP_IDX_SHIFT	8
+#define ABI_MAS_FBR_ANT_PTN_MASK	0x00f0
+#define ABI_MAS_FBR_ANT_PTN_SHIFT	4
+#define ABI_MAS_MRT_ANT_PTN_MASK	0x000f
+
+/* tx status packet */
+typedef struct tx_status tx_status_t;
+BWL_PRE_PACKED_STRUCT struct tx_status {
+	uint16 framelen;
+	uint16 PAD;
+	uint16 frameid;
+	uint16 status;
+	uint16 lasttxtime;
+	uint16 sequence;
+	uint16 phyerr;
+	uint16 ackphyrxsh;
+} BWL_POST_PACKED_STRUCT;
+
+#define	TXSTATUS_LEN	16
+
+/* status field bit definitions */
+#define	TX_STATUS_FRM_RTX_MASK	0xF000
+#define	TX_STATUS_FRM_RTX_SHIFT	12
+#define	TX_STATUS_RTS_RTX_MASK	0x0F00
+#define	TX_STATUS_RTS_RTX_SHIFT	8
+#define TX_STATUS_MASK		0x00FE
+#define	TX_STATUS_PMINDCTD	(1 << 7)	/* PM mode indicated to AP */
+#define	TX_STATUS_INTERMEDIATE	(1 << 6)	/* intermediate or 1st ampdu pkg */
+#define	TX_STATUS_AMPDU		(1 << 5)	/* AMPDU status */
+#define TX_STATUS_SUPR_MASK	0x1C	/* suppress status bits (4:2) */
+#define TX_STATUS_SUPR_SHIFT	2
+#define	TX_STATUS_ACK_RCV	(1 << 1)	/* ACK received */
+#define	TX_STATUS_VALID		(1 << 0)	/* Tx status valid (corerev >= 5) */
+#define	TX_STATUS_NO_ACK	0
+
+/* suppress status reason codes */
+#define	TX_STATUS_SUPR_PMQ	(1 << 2)	/* PMQ entry */
+#define	TX_STATUS_SUPR_FLUSH	(2 << 2)	/* flush request */
+#define	TX_STATUS_SUPR_FRAG	(3 << 2)	/* previous frag failure */
+#define	TX_STATUS_SUPR_TBTT	(3 << 2)	/* SHARED: Probe response supr for TBTT */
+#define	TX_STATUS_SUPR_BADCH	(4 << 2)	/* channel mismatch */
+#define	TX_STATUS_SUPR_EXPTIME	(5 << 2)	/* lifetime expiry */
+#define	TX_STATUS_SUPR_UF	(6 << 2)	/* underflow */
+
+/* Unexpected tx status for rate update */
+#define TX_STATUS_UNEXP(status) \
+	((((status) & TX_STATUS_INTERMEDIATE) != 0) && \
+	 TX_STATUS_UNEXP_AMPDU(status))
+
+/* Unexpected tx status for A-MPDU rate update */
+#define TX_STATUS_UNEXP_AMPDU(status) \
+	((((status) & TX_STATUS_SUPR_MASK) != 0) && \
+	 (((status) & TX_STATUS_SUPR_MASK) != TX_STATUS_SUPR_EXPTIME))
+
+#define TX_STATUS_BA_BMAP03_MASK	0xF000	/* ba bitmap 0:3 in 1st pkg */
+#define TX_STATUS_BA_BMAP03_SHIFT	12	/* ba bitmap 0:3 in 1st pkg */
+#define TX_STATUS_BA_BMAP47_MASK	0x001E	/* ba bitmap 4:7 in 2nd pkg */
+#define TX_STATUS_BA_BMAP47_SHIFT	3	/* ba bitmap 4:7 in 2nd pkg */
+
+/* RXE (Receive Engine) */
+
+/* RCM_CTL */
+#define	RCM_INC_MASK_H		0x0080
+#define	RCM_INC_MASK_L		0x0040
+#define	RCM_INC_DATA		0x0020
+#define	RCM_INDEX_MASK		0x001F
+#define	RCM_SIZE		15
+
+#define	RCM_MAC_OFFSET		0	/* current MAC address */
+#define	RCM_BSSID_OFFSET	3	/* current BSSID address */
+#define	RCM_F_BSSID_0_OFFSET	6	/* foreign BSS CFP tracking */
+#define	RCM_F_BSSID_1_OFFSET	9	/* foreign BSS CFP tracking */
+#define	RCM_F_BSSID_2_OFFSET	12	/* foreign BSS CFP tracking */
+
+#define RCM_WEP_TA0_OFFSET	16
+#define RCM_WEP_TA1_OFFSET	19
+#define RCM_WEP_TA2_OFFSET	22
+#define RCM_WEP_TA3_OFFSET	25
+
+/* PSM Block */
+
+/* psm_phy_hdr_param bits */
+#define MAC_PHY_RESET		1
+#define MAC_PHY_CLOCK_EN	2
+#define MAC_PHY_FORCE_CLK	4
+
+/* WEP Block */
+
+/* WEP_WKEY */
+#define	WKEY_START		(1 << 8)
+#define	WKEY_SEL_MASK		0x1F
+
+/* WEP data formats */
+
+/* the number of RCMTA entries */
+#define RCMTA_SIZE 50
+
+#define M_ADDR_BMP_BLK		(0x37e * 2)
+#define M_ADDR_BMP_BLK_SZ	12
+
+#define ADDR_BMP_RA		(1 << 0)	/* Receiver Address (RA) */
+#define ADDR_BMP_TA		(1 << 1)	/* Transmitter Address (TA) */
+#define ADDR_BMP_BSSID		(1 << 2)	/* BSSID */
+#define ADDR_BMP_AP		(1 << 3)	/* Infra-BSS Access Point (AP) */
+#define ADDR_BMP_STA		(1 << 4)	/* Infra-BSS Station (STA) */
+#define ADDR_BMP_RESERVED1	(1 << 5)
+#define ADDR_BMP_RESERVED2	(1 << 6)
+#define ADDR_BMP_RESERVED3	(1 << 7)
+#define ADDR_BMP_BSS_IDX_MASK	(3 << 8)	/* BSS control block index */
+#define ADDR_BMP_BSS_IDX_SHIFT	8
+
+#define	WSEC_MAX_RCMTA_KEYS	54
+
+/* max keys in M_TKMICKEYS_BLK */
+#define	WSEC_MAX_TKMIC_ENGINE_KEYS		12	/* 8 + 4 default */
+
+/* max RXE match registers */
+#define WSEC_MAX_RXE_KEYS	4
+
+/* SECKINDXALGO (Security Key Index & Algorithm Block) word format */
+/* SKL (Security Key Lookup) */
+#define	SKL_ALGO_MASK		0x0007
+#define	SKL_ALGO_SHIFT		0
+#define	SKL_KEYID_MASK		0x0008
+#define	SKL_KEYID_SHIFT		3
+#define	SKL_INDEX_MASK		0x03F0
+#define	SKL_INDEX_SHIFT		4
+#define	SKL_GRP_ALGO_MASK	0x1c00
+#define	SKL_GRP_ALGO_SHIFT	10
+
+/* additional bits defined for IBSS group key support */
+#define	SKL_IBSS_INDEX_MASK	0x01F0
+#define	SKL_IBSS_INDEX_SHIFT	4
+#define	SKL_IBSS_KEYID1_MASK	0x0600
+#define	SKL_IBSS_KEYID1_SHIFT	9
+#define	SKL_IBSS_KEYID2_MASK	0x1800
+#define	SKL_IBSS_KEYID2_SHIFT	11
+#define	SKL_IBSS_KEYALGO_MASK	0xE000
+#define	SKL_IBSS_KEYALGO_SHIFT	13
+
+#define	WSEC_MODE_OFF		0
+#define	WSEC_MODE_HW		1
+#define	WSEC_MODE_SW		2
+
+#define	WSEC_ALGO_OFF		0
+#define	WSEC_ALGO_WEP1		1
+#define	WSEC_ALGO_TKIP		2
+#define	WSEC_ALGO_AES		3
+#define	WSEC_ALGO_WEP128	4
+#define	WSEC_ALGO_AES_LEGACY	5
+#define	WSEC_ALGO_NALG		6
+
+#define	AES_MODE_NONE		0
+#define	AES_MODE_CCM		1
+
+/* WEP_CTL (Rev 0) */
+#define	WECR0_KEYREG_SHIFT	0
+#define	WECR0_KEYREG_MASK	0x7
+#define	WECR0_DECRYPT		(1 << 3)
+#define	WECR0_IVINLINE		(1 << 4)
+#define	WECR0_WEPALG_SHIFT	5
+#define	WECR0_WEPALG_MASK	(0x7 << 5)
+#define	WECR0_WKEYSEL_SHIFT	8
+#define	WECR0_WKEYSEL_MASK	(0x7 << 8)
+#define	WECR0_WKEYSTART		(1 << 11)
+#define	WECR0_WEPINIT		(1 << 14)
+#define	WECR0_ICVERR		(1 << 15)
+
+/* Frame template map byte offsets */
+#define	T_ACTS_TPL_BASE		(0)
+#define	T_NULL_TPL_BASE		(0xc * 2)
+#define	T_QNULL_TPL_BASE	(0x1c * 2)
+#define	T_RR_TPL_BASE		(0x2c * 2)
+#define	T_BCN0_TPL_BASE		(0x34 * 2)
+#define	T_PRS_TPL_BASE		(0x134 * 2)
+#define	T_BCN1_TPL_BASE		(0x234 * 2)
+#define T_TX_FIFO_TXRAM_BASE	(T_ACTS_TPL_BASE + (TXFIFO_START_BLK * TXFIFO_SIZE_UNIT))
+
+#define T_BA_TPL_BASE		T_QNULL_TPL_BASE	/* template area for BA */
+
+#define T_RAM_ACCESS_SZ		4	/* template ram is 4 byte access only */
+
+/* Shared Mem byte offsets */
+
+/* Location where the ucode expects the corerev */
+#define	M_MACHW_VER		(0x00b * 2)
+
+/* Location where the ucode expects the MAC capabilities */
+#define	M_MACHW_CAP_L		(0x060 * 2)
+#define	M_MACHW_CAP_H	(0x061 * 2)
+
+/* WME shared memory */
+#define M_EDCF_STATUS_OFF	(0x007 * 2)
+#define M_TXF_CUR_INDEX		(0x018 * 2)
+#define M_EDCF_QINFO		(0x120 * 2)
+
+/* PS-mode related parameters */
+#define	M_DOT11_SLOT		(0x008 * 2)
+#define	M_DOT11_DTIMPERIOD	(0x009 * 2)
+#define	M_NOSLPZNATDTIM		(0x026 * 2)
+
+/* Beacon-related parameters */
+#define	M_BCN0_FRM_BYTESZ	(0x00c * 2)	/* Bcn 0 template length */
+#define	M_BCN1_FRM_BYTESZ	(0x00d * 2)	/* Bcn 1 template length */
+#define	M_BCN_TXTSF_OFFSET	(0x00e * 2)
+#define	M_TIMBPOS_INBEACON	(0x00f * 2)
+#define	M_SFRMTXCNTFBRTHSD	(0x022 * 2)
+#define	M_LFRMTXCNTFBRTHSD	(0x023 * 2)
+#define	M_BCN_PCTLWD		(0x02a * 2)
+#define M_BCN_LI		(0x05b * 2)	/* beacon listen interval */
+
+/* MAX Rx Frame len */
+#define M_MAXRXFRM_LEN		(0x010 * 2)
+
+/* ACK/CTS related params */
+#define	M_RSP_PCTLWD		(0x011 * 2)
+
+/* Hardware Power Control */
+#define M_TXPWR_N		(0x012 * 2)
+#define M_TXPWR_TARGET		(0x013 * 2)
+#define M_TXPWR_MAX		(0x014 * 2)
+#define M_TXPWR_CUR		(0x019 * 2)
+
+/* Rx-related parameters */
+#define	M_RX_PAD_DATA_OFFSET	(0x01a * 2)
+
+/* WEP Shared mem data */
+#define	M_SEC_DEFIVLOC		(0x01e * 2)
+#define	M_SEC_VALNUMSOFTMCHTA	(0x01f * 2)
+#define	M_PHYVER		(0x028 * 2)
+#define	M_PHYTYPE		(0x029 * 2)
+#define	M_SECRXKEYS_PTR		(0x02b * 2)
+#define	M_TKMICKEYS_PTR		(0x059 * 2)
+#define	M_SECKINDXALGO_BLK	(0x2ea * 2)
+#define M_SECKINDXALGO_BLK_SZ	54
+#define	M_SECPSMRXTAMCH_BLK	(0x2fa * 2)
+#define	M_TKIP_TSC_TTAK		(0x18c * 2)
+#define	D11_MAX_KEY_SIZE	16
+
+#define	M_MAX_ANTCNT		(0x02e * 2)	/* antenna swap threshold */
+
+/* Probe response related parameters */
+#define	M_SSIDLEN		(0x024 * 2)
+#define	M_PRB_RESP_FRM_LEN	(0x025 * 2)
+#define	M_PRS_MAXTIME		(0x03a * 2)
+#define	M_SSID			(0xb0 * 2)
+#define	M_CTXPRS_BLK		(0xc0 * 2)
+#define	C_CTX_PCTLWD_POS	(0x4 * 2)
+
+/* Delta between OFDM and CCK power in CCK power boost mode */
+#define M_OFDM_OFFSET		(0x027 * 2)
+
+/* TSSI for last 4 11b/g CCK packets transmitted */
+#define	M_B_TSSI_0		(0x02c * 2)
+#define	M_B_TSSI_1		(0x02d * 2)
+
+/* Host flags to turn on ucode options */
+#define	M_HOST_FLAGS1		(0x02f * 2)
+#define	M_HOST_FLAGS2		(0x030 * 2)
+#define	M_HOST_FLAGS3		(0x031 * 2)
+#define	M_HOST_FLAGS4		(0x03c * 2)
+#define	M_HOST_FLAGS5		(0x06a * 2)
+#define	M_HOST_FLAGS_SZ		16
+
+#define M_RADAR_REG		(0x033 * 2)
+
+/* TSSI for last 4 11a OFDM packets transmitted */
+#define	M_A_TSSI_0		(0x034 * 2)
+#define	M_A_TSSI_1		(0x035 * 2)
+
+/* noise interference measurement */
+#define M_NOISE_IF_COUNT	(0x034 * 2)
+#define M_NOISE_IF_TIMEOUT	(0x035 * 2)
+
+#define	M_RF_RX_SP_REG1		(0x036 * 2)
+
+/* TSSI for last 4 11g OFDM packets transmitted */
+#define	M_G_TSSI_0		(0x038 * 2)
+#define	M_G_TSSI_1		(0x039 * 2)
+
+/* Background noise measure */
+#define	M_JSSI_0		(0x44 * 2)
+#define	M_JSSI_1		(0x45 * 2)
+#define	M_JSSI_AUX		(0x46 * 2)
+
+#define	M_CUR_2050_RADIOCODE	(0x47 * 2)
+
+/* TX fifo sizes */
+#define M_FIFOSIZE0		(0x4c * 2)
+#define M_FIFOSIZE1		(0x4d * 2)
+#define M_FIFOSIZE2		(0x4e * 2)
+#define M_FIFOSIZE3		(0x4f * 2)
+#define D11_MAX_TX_FRMS		32	/* max frames allowed in tx fifo */
+
+/* Current channel number plus upper bits */
+#define M_CURCHANNEL		(0x50 * 2)
+#define D11_CURCHANNEL_5G	0x0100;
+#define D11_CURCHANNEL_40	0x0200;
+#define D11_CURCHANNEL_MAX	0x00FF;
+
+/* last posted frameid on the bcmc fifo */
+#define M_BCMC_FID		(0x54 * 2)
+#define INVALIDFID		0xffff
+
+/* extended beacon phyctl bytes for 11N */
+#define	M_BCN_PCTL1WD		(0x058 * 2)
+
+/* idle busy ratio to duty_cycle requirement  */
+#define M_TX_IDLE_BUSY_RATIO_X_16_CCK  (0x52 * 2)
+#define M_TX_IDLE_BUSY_RATIO_X_16_OFDM (0x5A * 2)
+
+/* CW RSSI for LCNPHY */
+#define M_LCN_RSSI_0 		0x1332
+#define M_LCN_RSSI_1 		0x1338
+#define M_LCN_RSSI_2 		0x133e
+#define M_LCN_RSSI_3 		0x1344
+
+/* SNR for LCNPHY */
+#define M_LCN_SNR_A_0 	0x1334
+#define M_LCN_SNR_B_0 	0x1336
+
+#define M_LCN_SNR_A_1 	0x133a
+#define M_LCN_SNR_B_1 	0x133c
+
+#define M_LCN_SNR_A_2 	0x1340
+#define M_LCN_SNR_B_2 	0x1342
+
+#define M_LCN_SNR_A_3 	0x1346
+#define M_LCN_SNR_B_3 	0x1348
+
+#define M_LCN_LAST_RESET 	(81*2)
+#define M_LCN_LAST_LOC	(63*2)
+#define M_LCNPHY_RESET_STATUS (4902)
+#define M_LCNPHY_DSC_TIME	(0x98d*2)
+#define M_LCNPHY_RESET_CNT_DSC (0x98b*2)
+#define M_LCNPHY_RESET_CNT	(0x98c*2)
+
+/* Rate table offsets */
+#define	M_RT_DIRMAP_A		(0xe0 * 2)
+#define	M_RT_BBRSMAP_A		(0xf0 * 2)
+#define	M_RT_DIRMAP_B		(0x100 * 2)
+#define	M_RT_BBRSMAP_B		(0x110 * 2)
+
+/* Rate table entry offsets */
+#define	M_RT_PRS_PLCP_POS	10
+#define	M_RT_PRS_DUR_POS	16
+#define	M_RT_OFDM_PCTL1_POS	18
+
+#define M_20IN40_IQ			(0x380 * 2)
+
+/* SHM locations where ucode stores the current power index */
+#define M_CURR_IDX1		(0x384 *2)
+#define M_CURR_IDX2		(0x387 *2)
+
+#define M_BSCALE_ANT0	(0x5e * 2)
+#define M_BSCALE_ANT1	(0x5f * 2)
+
+/* Antenna Diversity Testing */
+#define M_MIMO_ANTSEL_RXDFLT	(0x63 * 2)
+#define M_ANTSEL_CLKDIV	(0x61 * 2)
+#define M_MIMO_ANTSEL_TXDFLT	(0x64 * 2)
+
+#define M_MIMO_MAXSYM	(0x5d * 2)
+#define MIMO_MAXSYM_DEF		0x8000	/* 32k */
+#define MIMO_MAXSYM_MAX		0xffff	/* 64k */
+
+#define M_WATCHDOG_8TU		(0x1e * 2)
+#define WATCHDOG_8TU_DEF	5
+#define WATCHDOG_8TU_MAX	10
+
+/* Manufacturing Test Variables */
+#define M_PKTENG_CTRL		(0x6c * 2)	/* PER test mode */
+#define M_PKTENG_IFS		(0x6d * 2)	/* IFS for TX mode */
+#define M_PKTENG_FRMCNT_LO		(0x6e * 2)	/* Lower word of tx frmcnt/rx lostcnt */
+#define M_PKTENG_FRMCNT_HI		(0x6f * 2)	/* Upper word of tx frmcnt/rx lostcnt */
+
+/* Index variation in vbat ripple */
+#define M_LCN_PWR_IDX_MAX	(0x67 * 2)	/* highest index read by ucode */
+#define M_LCN_PWR_IDX_MIN	(0x66 * 2)	/* lowest index read by ucode */
+
+/* M_PKTENG_CTRL bit definitions */
+#define M_PKTENG_MODE_TX		0x0001
+#define M_PKTENG_MODE_TX_RIFS	        0x0004
+#define M_PKTENG_MODE_TX_CTS            0x0008
+#define M_PKTENG_MODE_RX		0x0002
+#define M_PKTENG_MODE_RX_WITH_ACK	0x0402
+#define M_PKTENG_MODE_MASK		0x0003
+#define M_PKTENG_FRMCNT_VLD		0x0100	/* TX frames indicated in the frmcnt reg */
+
+/* Sample Collect parameters (bitmap and type) */
+#define M_SMPL_COL_BMP		(0x37d * 2)	/* Trigger bitmap for sample collect */
+#define M_SMPL_COL_CTL		(0x3b2 * 2)	/* Sample collect type */
+
+#define ANTSEL_CLKDIV_4MHZ	6
+#define MIMO_ANTSEL_BUSY	0x4000	/* bit 14 (busy) */
+#define MIMO_ANTSEL_SEL		0x8000	/* bit 15 write the value */
+#define MIMO_ANTSEL_WAIT	50	/* 50us wait */
+#define MIMO_ANTSEL_OVERRIDE	0x8000	/* flag */
+
+typedef struct shm_acparams shm_acparams_t;
+BWL_PRE_PACKED_STRUCT struct shm_acparams {
+	uint16 txop;
+	uint16 cwmin;
+	uint16 cwmax;
+	uint16 cwcur;
+	uint16 aifs;
+	uint16 bslots;
+	uint16 reggap;
+	uint16 status;
+	uint16 rsvd[8];
+} BWL_POST_PACKED_STRUCT;
+#define M_EDCF_QLEN	(16 * 2)
+
+#define WME_STATUS_NEWAC	(1 << 8)
+
+/* M_HOST_FLAGS */
+#define MHFMAX		5	/* Number of valid hostflag half-word (uint16) */
+#define MHF1		0	/* Hostflag 1 index */
+#define MHF2		1	/* Hostflag 2 index */
+#define MHF3		2	/* Hostflag 3 index */
+#define MHF4		3	/* Hostflag 4 index */
+#define MHF5		4	/* Hostflag 5 index */
+
+/* Flags in M_HOST_FLAGS */
+#define	MHF1_ANTDIV		0x0001	/* Enable ucode antenna diversity help */
+#define	MHF1_EDCF		0x0100	/* Enable EDCF access control */
+#define MHF1_IQSWAP_WAR		0x0200
+#define	MHF1_FORCEFASTCLK	0x0400	/* Disable Slow clock request, for corerev < 11 */
+
+/* Flags in M_HOST_FLAGS2 */
+#define MHF2_PCISLOWCLKWAR	0x0008	/* PR16165WAR : Enable ucode PCI slow clock WAR */
+#define MHF2_TXBCMC_NOW		0x0040	/* Flush BCMC FIFO immediately */
+#define MHF2_HWPWRCTL		0x0080	/* Enable ucode/hw power control */
+#define MHF2_NPHY40MHZ_WAR	0x0800
+
+/* Flags in M_HOST_FLAGS3 */
+#define MHF3_ANTSEL_EN		0x0001	/* enabled mimo antenna selection */
+#define MHF3_ANTSEL_MODE	0x0002	/* antenna selection mode: 0: 2x3, 1: 2x4 */
+#define MHF3_RESERVED1		0x0004
+#define MHF3_RESERVED2		0x0008
+#define MHF3_NPHY_MLADV_WAR	0x0010
+
+/* Flags in M_HOST_FLAGS4 */
+#define MHF4_BPHY_TXCORE0	0x0080	/* force bphy Tx on core 0 (board level WAR) */
+#define MHF4_EXTPA_ENABLE  	0x4000	/* for 4313A0 FEM boards */
+
+/* Flags in M_HOST_FLAGS5 */
+#define MHF5_4313_GPIOCTRL	0x0001
+#define MHF5_RESERVED1		0x0002
+#define MHF5_RESERVED2		0x0004
+/* Radio power setting for ucode */
+#define	M_RADIO_PWR		(0x32 * 2)
+
+/* phy noise recorded by ucode right after tx */
+#define	M_PHY_NOISE		(0x037 * 2)
+#define	PHY_NOISE_MASK		0x00ff
+
+/* Receive Frame Data Header for 802.11b DCF-only frames */
+typedef struct d11rxhdr d11rxhdr_t;
+BWL_PRE_PACKED_STRUCT struct d11rxhdr {
+	uint16 RxFrameSize;	/* Actual byte length of the frame data received */
+	uint16 PAD;
+	uint16 PhyRxStatus_0;	/* PhyRxStatus 15:0 */
+	uint16 PhyRxStatus_1;	/* PhyRxStatus 31:16 */
+	uint16 PhyRxStatus_2;	/* PhyRxStatus 47:32 */
+	uint16 PhyRxStatus_3;	/* PhyRxStatus 63:48 */
+	uint16 PhyRxStatus_4;	/* PhyRxStatus 79:64 */
+	uint16 PhyRxStatus_5;	/* PhyRxStatus 95:80 */
+	uint16 RxStatus1;	/* MAC Rx Status */
+	uint16 RxStatus2;	/* extended MAC Rx status */
+	uint16 RxTSFTime;	/* RxTSFTime time of first MAC symbol + M_PHY_PLCPRX_DLY */
+	uint16 RxChan;		/* gain code, channel radio code, and phy type */
+} BWL_POST_PACKED_STRUCT;
+
+#define	RXHDR_LEN		24	/* sizeof d11rxhdr_t */
+#define	FRAMELEN(h)		((h)->RxFrameSize)
+
+typedef struct wlc_d11rxhdr wlc_d11rxhdr_t;
+BWL_PRE_PACKED_STRUCT struct wlc_d11rxhdr {
+	d11rxhdr_t rxhdr;
+	uint32 tsf_l;		/* TSF_L reading */
+	int8 rssi;		/* computed instanteneous rssi in BMAC */
+	int8 rxpwr0;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
+	int8 rxpwr1;		/* obsoleted, place holder for legacy ROM code. use rxpwr[] */
+	int8 do_rssi_ma;	/* do per-pkt sampling for per-antenna ma in HIGH */
+	int8 rxpwr[WL_RSSI_ANT_MAX];	/* rssi for supported antennas */
+} BWL_POST_PACKED_STRUCT;
+
+/* PhyRxStatus_0: */
+#define	PRXS0_FT_MASK		0x0003	/* NPHY only: CCK, OFDM, preN, N */
+#define	PRXS0_CLIP_MASK		0x000C	/* NPHY only: clip count adjustment steps by AGC */
+#define	PRXS0_CLIP_SHIFT	2
+#define	PRXS0_UNSRATE		0x0010	/* PHY received a frame with unsupported rate */
+#define	PRXS0_RXANT_UPSUBBAND	0x0020	/* GPHY: rx ant, NPHY: upper sideband */
+#define	PRXS0_LCRS		0x0040	/* CCK frame only: lost crs during cck frame reception */
+#define	PRXS0_SHORTH		0x0080	/* Short Preamble */
+#define	PRXS0_PLCPFV		0x0100	/* PLCP violation */
+#define	PRXS0_PLCPHCF		0x0200	/* PLCP header integrity check failed */
+#define	PRXS0_GAIN_CTL		0x4000	/* legacy PHY gain control */
+#define PRXS0_ANTSEL_MASK	0xF000	/* NPHY: Antennas used for received frame, bitmask */
+#define PRXS0_ANTSEL_SHIFT	0x12
+
+/* subfield PRXS0_FT_MASK */
+#define	PRXS0_CCK		0x0000
+#define	PRXS0_OFDM		0x0001	/* valid only for G phy, use rxh->RxChan for A phy */
+#define	PRXS0_PREN		0x0002
+#define	PRXS0_STDN		0x0003
+
+/* subfield PRXS0_ANTSEL_MASK */
+#define PRXS0_ANTSEL_0		0x0	/* antenna 0 is used */
+#define PRXS0_ANTSEL_1		0x2	/* antenna 1 is used */
+#define PRXS0_ANTSEL_2		0x4	/* antenna 2 is used */
+#define PRXS0_ANTSEL_3		0x8	/* antenna 3 is used */
+
+/* PhyRxStatus_1: */
+#define	PRXS1_JSSI_MASK		0x00FF
+#define	PRXS1_JSSI_SHIFT	0
+#define	PRXS1_SQ_MASK		0xFF00
+#define	PRXS1_SQ_SHIFT		8
+
+/* nphy PhyRxStatus_1: */
+#define PRXS1_nphy_PWR0_MASK	0x00FF
+#define PRXS1_nphy_PWR1_MASK	0xFF00
+
+/* HTPHY Rx Status defines */
+/* htphy PhyRxStatus_0: those bit are overlapped with PhyRxStatus_0 */
+#define PRXS0_BAND	        0x0400	/* 0 = 2.4G, 1 = 5G */
+#define PRXS0_RSVD	        0x0800	/* reserved; set to 0 */
+#define PRXS0_UNUSED	        0xF000	/* unused and not defined; set to 0 */
+
+/* htphy PhyRxStatus_1: */
+#define PRXS1_HTPHY_CORE_MASK	0x000F	/* core enables for {3..0}, 0=disabled, 1=enabled */
+#define PRXS1_HTPHY_ANTCFG_MASK	0x00F0	/* antenna configation */
+#define PRXS1_HTPHY_MMPLCPLenL_MASK	0xFF00	/* Mixmode PLCP Length low byte mask */
+
+/* htphy PhyRxStatus_2: */
+#define PRXS2_HTPHY_MMPLCPLenH_MASK	0x000F	/* Mixmode PLCP Length high byte maskw */
+#define PRXS2_HTPHY_MMPLCH_RATE_MASK	0x00F0	/* Mixmode PLCP rate mask */
+#define PRXS2_HTPHY_RXPWR_ANT0	0xFF00	/* Rx power on core 0 */
+
+/* htphy PhyRxStatus_3: */
+#define PRXS3_HTPHY_RXPWR_ANT1	0x00FF	/* Rx power on core 1 */
+#define PRXS3_HTPHY_RXPWR_ANT2	0xFF00	/* Rx power on core 2 */
+
+/* htphy PhyRxStatus_4: */
+#define PRXS4_HTPHY_RXPWR_ANT3	0x00FF	/* Rx power on core 3 */
+#define PRXS4_HTPHY_CFO		0xFF00	/* Coarse frequency offset */
+
+/* htphy PhyRxStatus_5: */
+#define PRXS5_HTPHY_FFO	        0x00FF	/* Fine frequency offset */
+#define PRXS5_HTPHY_AR	        0xFF00	/* Advance Retard */
+
+#define HTPHY_MMPLCPLen(rxs)	((((rxs)->PhyRxStatus_1 & PRXS1_HTPHY_MMPLCPLenL_MASK) >> 8) | \
+	(((rxs)->PhyRxStatus_2 & PRXS2_HTPHY_MMPLCPLenH_MASK) << 8))
+/* Get Rx power on core 0 */
+#define HTPHY_RXPWR_ANT0(rxs)	((((rxs)->PhyRxStatus_2) & PRXS2_HTPHY_RXPWR_ANT0) >> 8)
+/* Get Rx power on core 1 */
+#define HTPHY_RXPWR_ANT1(rxs)	(((rxs)->PhyRxStatus_3) & PRXS3_HTPHY_RXPWR_ANT1)
+/* Get Rx power on core 2 */
+#define HTPHY_RXPWR_ANT2(rxs)	((((rxs)->PhyRxStatus_3) & PRXS3_HTPHY_RXPWR_ANT2) >> 8)
+
+/* ucode RxStatus1: */
+#define	RXS_BCNSENT		0x8000
+#define	RXS_SECKINDX_MASK	0x07e0
+#define	RXS_SECKINDX_SHIFT	5
+#define	RXS_DECERR		(1 << 4)
+#define	RXS_DECATMPT		(1 << 3)
+#define	RXS_PBPRES		(1 << 2)	/* PAD bytes to make IP data 4 bytes aligned */
+#define	RXS_RESPFRAMETX		(1 << 1)
+#define	RXS_FCSERR		(1 << 0)
+
+/* ucode RxStatus2: */
+#define RXS_AMSDU_MASK		1
+#define	RXS_AGGTYPE_MASK	0x6
+#define	RXS_AGGTYPE_SHIFT	1
+#define	RXS_PHYRXST_VALID	(1 << 8)
+#define RXS_RXANT_MASK		0x3
+#define RXS_RXANT_SHIFT		12
+
+/* RxChan */
+#define RXS_CHAN_40		0x1000
+#define RXS_CHAN_5G		0x0800
+#define	RXS_CHAN_ID_MASK	0x07f8
+#define	RXS_CHAN_ID_SHIFT	3
+#define	RXS_CHAN_PHYTYPE_MASK	0x0007
+#define	RXS_CHAN_PHYTYPE_SHIFT	0
+
+/* Index of attenuations used during ucode power control. */
+#define M_PWRIND_BLKS	(0x184 * 2)
+#define M_PWRIND_MAP0	(M_PWRIND_BLKS + 0x0)
+#define M_PWRIND_MAP1	(M_PWRIND_BLKS + 0x2)
+#define M_PWRIND_MAP2	(M_PWRIND_BLKS + 0x4)
+#define M_PWRIND_MAP3	(M_PWRIND_BLKS + 0x6)
+/* M_PWRIND_MAP(core) macro */
+#define M_PWRIND_MAP(core)  (M_PWRIND_BLKS + ((core)<<1))
+
+/* PSM SHM variable offsets */
+#define	M_PSM_SOFT_REGS	0x0
+#define	M_BOM_REV_MAJOR	(M_PSM_SOFT_REGS + 0x0)
+#define	M_BOM_REV_MINOR	(M_PSM_SOFT_REGS + 0x2)
+#define	M_UCODE_DBGST	(M_PSM_SOFT_REGS + 0x40)	/* ucode debug status code */
+#define	M_UCODE_MACSTAT	(M_PSM_SOFT_REGS + 0xE0)	/* macstat counters */
+
+#define M_AGING_THRSH	(0x3e * 2)	/* max time waiting for medium before tx */
+#define	M_MBURST_SIZE	(0x40 * 2)	/* max frames in a frameburst */
+#define	M_MBURST_TXOP	(0x41 * 2)	/* max frameburst TXOP in unit of us */
+#define M_SYNTHPU_DLY	(0x4a * 2)	/* pre-wakeup for synthpu, default: 500 */
+#define	M_PRETBTT	(0x4b * 2)
+
+#define M_ALT_TXPWR_IDX		(M_PSM_SOFT_REGS + (0x3b * 2))	/* offset to the target txpwr */
+#define M_PHY_TX_FLT_PTR	(M_PSM_SOFT_REGS + (0x3d * 2))
+#define M_CTS_DURATION		(M_PSM_SOFT_REGS + (0x5c * 2))
+#define M_LP_RCCAL_OVR		(M_PSM_SOFT_REGS + (0x6b * 2))
+
+/* PKTENG Rx Stats Block */
+#define M_RXSTATS_BLK_PTR	(M_PSM_SOFT_REGS + (0x65 * 2))
+
+/* ucode debug status codes */
+#define	DBGST_INACTIVE		0	/* not valid really */
+#define	DBGST_INIT		1	/* after zeroing SHM, before suspending at init */
+#define	DBGST_ACTIVE		2	/* "normal" state */
+#define	DBGST_SUSPENDED		3	/* suspended */
+#define	DBGST_ASLEEP		4	/* asleep (PS mode) */
+
+/* Scratch Reg defs */
+typedef enum {
+	S_RSV0 = 0,
+	S_RSV1,
+	S_RSV2,
+
+	/* scratch registers for Dot11-contants */
+	S_DOT11_CWMIN,		/* CW-minimum                                   0x03 */
+	S_DOT11_CWMAX,		/* CW-maximum                                   0x04 */
+	S_DOT11_CWCUR,		/* CW-current                                   0x05 */
+	S_DOT11_SRC_LMT,	/* short retry count limit                      0x06 */
+	S_DOT11_LRC_LMT,	/* long retry count limit                       0x07 */
+	S_DOT11_DTIMCOUNT,	/* DTIM-count                                   0x08 */
+
+	/* Tx-side scratch registers */
+	S_SEQ_NUM,		/* hardware sequence number reg                 0x09 */
+	S_SEQ_NUM_FRAG,		/* seq-num for frags (Set at the start os MSDU  0x0A */
+	S_FRMRETX_CNT,		/* frame retx count                             0x0B */
+	S_SSRC,			/* Station short retry count                    0x0C */
+	S_SLRC,			/* Station long retry count                     0x0D */
+	S_EXP_RSP,		/* Expected response frame                      0x0E */
+	S_OLD_BREM,		/* Remaining backoff ctr                        0x0F */
+	S_OLD_CWWIN,		/* saved-off CW-cur                             0x10 */
+	S_TXECTL,		/* TXE-Ctl word constructed in scr-pad          0x11 */
+	S_CTXTST,		/* frm type-subtype as read from Tx-descr       0x12 */
+
+	/* Rx-side scratch registers */
+	S_RXTST,		/* Type and subtype in Rxframe                  0x13 */
+
+	/* Global state register */
+	S_STREG,		/* state storage actual bit maps below          0x14 */
+
+	S_TXPWR_SUM,		/* Tx power control: accumulator                0x15 */
+	S_TXPWR_ITER,		/* Tx power control: iteration                  0x16 */
+	S_RX_FRMTYPE,		/* Rate and PHY type for frames                 0x17 */
+	S_THIS_AGG,		/* Size of this AGG (A-MSDU)                    0x18 */
+
+	S_KEYINDX,		/*                                              0x19 */
+	S_RXFRMLEN,		/* Receive MPDU length in bytes                 0x1A */
+
+	/* Receive TSF time stored in SCR */
+	S_RXTSFTMRVAL_WD3,	/* TSF value at the start of rx                 0x1B */
+	S_RXTSFTMRVAL_WD2,	/* TSF value at the start of rx                 0x1C */
+	S_RXTSFTMRVAL_WD1,	/* TSF value at the start of rx                 0x1D */
+	S_RXTSFTMRVAL_WD0,	/* TSF value at the start of rx                 0x1E */
+	S_RXSSN,		/* Received start seq number for A-MPDU BA      0x1F */
+	S_RXQOSFLD,		/* Rx-QoS field (if present)                    0x20 */
+
+	/* Scratch pad regs used in microcode as temp storage */
+	S_TMP0,			/* stmp0                                        0x21 */
+	S_TMP1,			/* stmp1                                        0x22 */
+	S_TMP2,			/* stmp2                                        0x23 */
+	S_TMP3,			/* stmp3                                        0x24 */
+	S_TMP4,			/* stmp4                                        0x25 */
+	S_TMP5,			/* stmp5                                        0x26 */
+	S_PRQPENALTY_CTR,	/* Probe response queue penalty counter         0x27 */
+	S_ANTCNT,		/* unsuccessful attempts on current ant.        0x28 */
+	S_SYMBOL,		/* flag for possible symbol ctl frames          0x29 */
+	S_RXTP,			/* rx frame type                                0x2A */
+	S_STREG2,		/* extra state storage                          0x2B */
+	S_STREG3,		/* even more extra state storage                0x2C */
+	S_STREG4,		/* ...                                          0x2D */
+	S_STREG5,		/* remember to initialize it to zero            0x2E */
+
+	S_ADJPWR_IDX,
+	S_CUR_PTR,		/* Temp pointer for A-MPDU re-Tx SHM table      0x32 */
+	S_REVID4,		/* 0x33 */
+	S_INDX,			/* 0x34 */
+	S_ADDR0,		/* 0x35 */
+	S_ADDR1,		/* 0x36 */
+	S_ADDR2,		/* 0x37 */
+	S_ADDR3,		/* 0x38 */
+	S_ADDR4,		/* 0x39 */
+	S_ADDR5,		/* 0x3A */
+	S_TMP6,			/* 0x3B */
+	S_KEYINDX_BU,		/* Backup for Key index                         0x3C */
+	S_MFGTEST_TMP0,		/* Temp register used for RX test calculations  0x3D */
+	S_RXESN,		/* Received end sequence number for A-MPDU BA   0x3E */
+	S_STREG6,		/* 0x3F */
+} ePsmScratchPadRegDefinitions;
+
+#define S_BEACON_INDX	S_OLD_BREM
+#define S_PRS_INDX	S_OLD_CWWIN
+#define S_PHYTYPE	S_SSRC
+#define S_PHYVER	S_SLRC
+
+/* IHR SLOW_CTRL values */
+#define SLOW_CTRL_PDE		(1 << 0)
+#define SLOW_CTRL_FD		(1 << 8)
+
+/* ucode mac statistic counters in shared memory */
+typedef struct macstat {
+	uint16 txallfrm;	/* 0x80 */
+	uint16 txrtsfrm;	/* 0x82 */
+	uint16 txctsfrm;	/* 0x84 */
+	uint16 txackfrm;	/* 0x86 */
+	uint16 txdnlfrm;	/* 0x88 */
+	uint16 txbcnfrm;	/* 0x8a */
+	uint16 txfunfl[8];	/* 0x8c - 0x9b */
+	uint16 txtplunfl;	/* 0x9c */
+	uint16 txphyerr;	/* 0x9e */
+	uint16 pktengrxducast;	/* 0xa0 */
+	uint16 pktengrxdmcast;	/* 0xa2 */
+	uint16 rxfrmtoolong;	/* 0xa4 */
+	uint16 rxfrmtooshrt;	/* 0xa6 */
+	uint16 rxinvmachdr;	/* 0xa8 */
+	uint16 rxbadfcs;	/* 0xaa */
+	uint16 rxbadplcp;	/* 0xac */
+	uint16 rxcrsglitch;	/* 0xae */
+	uint16 rxstrt;		/* 0xb0 */
+	uint16 rxdfrmucastmbss;	/* 0xb2 */
+	uint16 rxmfrmucastmbss;	/* 0xb4 */
+	uint16 rxcfrmucast;	/* 0xb6 */
+	uint16 rxrtsucast;	/* 0xb8 */
+	uint16 rxctsucast;	/* 0xba */
+	uint16 rxackucast;	/* 0xbc */
+	uint16 rxdfrmocast;	/* 0xbe */
+	uint16 rxmfrmocast;	/* 0xc0 */
+	uint16 rxcfrmocast;	/* 0xc2 */
+	uint16 rxrtsocast;	/* 0xc4 */
+	uint16 rxctsocast;	/* 0xc6 */
+	uint16 rxdfrmmcast;	/* 0xc8 */
+	uint16 rxmfrmmcast;	/* 0xca */
+	uint16 rxcfrmmcast;	/* 0xcc */
+	uint16 rxbeaconmbss;	/* 0xce */
+	uint16 rxdfrmucastobss;	/* 0xd0 */
+	uint16 rxbeaconobss;	/* 0xd2 */
+	uint16 rxrsptmout;	/* 0xd4 */
+	uint16 bcntxcancl;	/* 0xd6 */
+	uint16 PAD;
+	uint16 rxf0ovfl;	/* 0xda */
+	uint16 rxf1ovfl;	/* 0xdc */
+	uint16 rxf2ovfl;	/* 0xde */
+	uint16 txsfovfl;	/* 0xe0 */
+	uint16 pmqovfl;		/* 0xe2 */
+	uint16 rxcgprqfrm;	/* 0xe4 */
+	uint16 rxcgprsqovfl;	/* 0xe6 */
+	uint16 txcgprsfail;	/* 0xe8 */
+	uint16 txcgprssuc;	/* 0xea */
+	uint16 prs_timeout;	/* 0xec */
+	uint16 rxnack;
+	uint16 frmscons;
+	uint16 txnack;
+	uint16 txglitch_nack;
+	uint16 txburst;		/* 0xf6 # tx bursts */
+	uint16 bphy_rxcrsglitch;	/* bphy rx crs glitch */
+	uint16 phywatchdog;	/* 0xfa # of phy watchdog events */
+	uint16 PAD;
+	uint16 bphy_badplcp;	/* bphy bad plcp */
+} macstat_t;
+
+/* dot11 core-specific control flags */
+#define	SICF_PCLKE		0x0004	/* PHY clock enable */
+#define	SICF_PRST		0x0008	/* PHY reset */
+#define	SICF_MPCLKE		0x0010	/* MAC PHY clockcontrol enable */
+#define	SICF_FREF		0x0020	/* PLL FreqRefSelect (corerev >= 5) */
+/* NOTE: the following bw bits only apply when the core is attached
+ * to a NPHY (and corerev >= 11 which it will always be for NPHYs).
+ */
+#define	SICF_BWMASK		0x00c0	/* phy clock mask (b6 & b7) */
+#define	SICF_BW40		0x0080	/* 40MHz BW (160MHz phyclk) */
+#define	SICF_BW20		0x0040	/* 20MHz BW (80MHz phyclk) */
+#define	SICF_BW10		0x0000	/* 10MHz BW (40MHz phyclk) */
+#define	SICF_GMODE		0x2000	/* gmode enable */
+
+/* dot11 core-specific status flags */
+#define	SISF_2G_PHY		0x0001	/* 2.4G capable phy (corerev >= 5) */
+#define	SISF_5G_PHY		0x0002	/* 5G capable phy (corerev >= 5) */
+#define	SISF_FCLKA		0x0004	/* FastClkAvailable (corerev >= 5) */
+#define	SISF_DB_PHY		0x0008	/* Dualband phy (corerev >= 11) */
+
+/* === End of MAC reg, Beginning of PHY(b/a/g/n) reg, radio and LPPHY regs are separated === */
+
+#define	BPHY_REG_OFT_BASE	0x0
+/* offsets for indirect access to bphy registers */
+#define	BPHY_BB_CONFIG		0x01
+#define	BPHY_ADCBIAS		0x02
+#define	BPHY_ANACORE		0x03
+#define	BPHY_PHYCRSTH		0x06
+#define	BPHY_TEST		0x0a
+#define	BPHY_PA_TX_TO		0x10
+#define	BPHY_SYNTH_DC_TO	0x11
+#define	BPHY_PA_TX_TIME_UP	0x12
+#define	BPHY_RX_FLTR_TIME_UP	0x13
+#define	BPHY_TX_POWER_OVERRIDE	0x14
+#define	BPHY_RF_OVERRIDE	0x15
+#define	BPHY_RF_TR_LOOKUP1	0x16
+#define	BPHY_RF_TR_LOOKUP2	0x17
+#define	BPHY_COEFFS		0x18
+#define	BPHY_PLL_OUT		0x19
+#define	BPHY_REFRESH_MAIN	0x1a
+#define	BPHY_REFRESH_TO0	0x1b
+#define	BPHY_REFRESH_TO1	0x1c
+#define	BPHY_RSSI_TRESH		0x20
+#define	BPHY_IQ_TRESH_HH	0x21
+#define	BPHY_IQ_TRESH_H		0x22
+#define	BPHY_IQ_TRESH_L		0x23
+#define	BPHY_IQ_TRESH_LL	0x24
+#define	BPHY_GAIN		0x25
+#define	BPHY_LNA_GAIN_RANGE	0x26
+#define	BPHY_JSSI		0x27
+#define	BPHY_TSSI_CTL		0x28
+#define	BPHY_TSSI		0x29
+#define	BPHY_TR_LOSS_CTL	0x2a
+#define	BPHY_LO_LEAKAGE		0x2b
+#define	BPHY_LO_RSSI_ACC	0x2c
+#define	BPHY_LO_IQMAG_ACC	0x2d
+#define	BPHY_TX_DC_OFF1		0x2e
+#define	BPHY_TX_DC_OFF2		0x2f
+#define	BPHY_PEAK_CNT_THRESH	0x30
+#define	BPHY_FREQ_OFFSET	0x31
+#define	BPHY_DIVERSITY_CTL	0x32
+#define	BPHY_PEAK_ENERGY_LO	0x33
+#define	BPHY_PEAK_ENERGY_HI	0x34
+#define	BPHY_SYNC_CTL		0x35
+#define	BPHY_TX_PWR_CTRL	0x36
+#define BPHY_TX_EST_PWR 	0x37
+#define	BPHY_STEP		0x38
+#define	BPHY_WARMUP		0x39
+#define	BPHY_LMS_CFF_READ	0x3a
+#define	BPHY_LMS_COEFF_I	0x3b
+#define	BPHY_LMS_COEFF_Q	0x3c
+#define	BPHY_SIG_POW		0x3d
+#define	BPHY_RFDC_CANCEL_CTL	0x3e
+#define	BPHY_HDR_TYPE		0x40
+#define	BPHY_SFD_TO		0x41
+#define	BPHY_SFD_CTL		0x42
+#define	BPHY_DEBUG		0x43
+#define	BPHY_RX_DELAY_COMP	0x44
+#define	BPHY_CRS_DROP_TO	0x45
+#define	BPHY_SHORT_SFD_NZEROS	0x46
+#define	BPHY_DSSS_COEFF1	0x48
+#define	BPHY_DSSS_COEFF2	0x49
+#define	BPHY_CCK_COEFF1		0x4a
+#define	BPHY_CCK_COEFF2		0x4b
+#define	BPHY_TR_CORR		0x4c
+#define	BPHY_ANGLE_SCALE	0x4d
+#define	BPHY_TX_PWR_BASE_IDX	0x4e
+#define	BPHY_OPTIONAL_MODES2	0x4f
+#define	BPHY_CCK_LMS_STEP	0x50
+#define	BPHY_BYPASS		0x51
+#define	BPHY_CCK_DELAY_LONG	0x52
+#define	BPHY_CCK_DELAY_SHORT	0x53
+#define	BPHY_PPROC_CHAN_DELAY	0x54
+#define	BPHY_DDFS_ENABLE	0x58
+#define	BPHY_PHASE_SCALE	0x59
+#define	BPHY_FREQ_CONTROL	0x5a
+#define	BPHY_LNA_GAIN_RANGE_10	0x5b
+#define	BPHY_LNA_GAIN_RANGE_32	0x5c
+#define	BPHY_OPTIONAL_MODES	0x5d
+#define	BPHY_RX_STATUS2		0x5e
+#define	BPHY_RX_STATUS3		0x5f
+#define	BPHY_DAC_CONTROL	0x60
+#define	BPHY_ANA11G_FILT_CTRL	0x62
+#define	BPHY_REFRESH_CTRL	0x64
+#define	BPHY_RF_OVERRIDE2	0x65
+#define	BPHY_SPUR_CANCEL_CTRL	0x66
+#define	BPHY_FINE_DIGIGAIN_CTRL	0x67
+#define	BPHY_RSSI_LUT		0x88
+#define	BPHY_RSSI_LUT_END	0xa7
+#define	BPHY_TSSI_LUT		0xa8
+#define	BPHY_TSSI_LUT_END	0xc7
+#define	BPHY_TSSI2PWR_LUT	0x380
+#define	BPHY_TSSI2PWR_LUT_END	0x39f
+#define	BPHY_LOCOMP_LUT		0x3a0
+#define	BPHY_LOCOMP_LUT_END	0x3bf
+#define	BPHY_TXGAIN_LUT		0x3c0
+#define	BPHY_TXGAIN_LUT_END	0x3ff
+
+/* Bits in BB_CONFIG: */
+#define	PHY_BBC_ANT_MASK	0x0180
+#define	PHY_BBC_ANT_SHIFT	7
+#define	BB_DARWIN		0x1000
+#define BBCFG_RESETCCA		0x4000
+#define BBCFG_RESETRX		0x8000
+
+/* Bits in phytest(0x0a): */
+#define	TST_DDFS		0x2000
+#define	TST_TXFILT1		0x0800
+#define	TST_UNSCRAM		0x0400
+#define	TST_CARR_SUPP		0x0200
+#define	TST_DC_COMP_LOOP	0x0100
+#define	TST_LOOPBACK		0x0080
+#define	TST_TXFILT0		0x0040
+#define	TST_TXTEST_ENABLE	0x0020
+#define	TST_TXTEST_RATE		0x0018
+#define	TST_TXTEST_PHASE	0x0007
+
+/* phytest txTestRate values */
+#define	TST_TXTEST_RATE_1MBPS	0
+#define	TST_TXTEST_RATE_2MBPS	1
+#define	TST_TXTEST_RATE_5_5MBPS	2
+#define	TST_TXTEST_RATE_11MBPS	3
+#define	TST_TXTEST_RATE_SHIFT	3
+
+/* This marks the end of a packed structure section. */
+#include <packed_section_end.h>
+
+#define SHM_BYT_CNT	0x2	/* IHR location */
+#define MAX_BYT_CNT	0x600	/* Maximum frame len */
+
+#endif				/* _D11_H */
diff --git a/drivers/staging/brcm80211/include/dbus.h b/drivers/staging/brcm80211/include/dbus.h
new file mode 100644
index 0000000..fc8e298
--- /dev/null
+++ b/drivers/staging/brcm80211/include/dbus.h
@@ -0,0 +1,355 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __DBUS_H__
+#define __DBUS_H__
+
+#include "typedefs.h"
+
+#ifdef BCMDBG
+#define DBUSERR(args)        do { if (net_ratelimit()) printf args; } while (0)
+#define DBUSTRACE(args)
+#define DBUSDBGLOCK(args)
+
+#else
+#define DBUSTRACE(args)
+#define DBUSERR(args)
+#define DBUSDBGLOCK(args)
+#endif
+
+enum {
+	DBUS_OK = 0,
+	DBUS_ERR = -200,
+	DBUS_ERR_TIMEOUT,
+	DBUS_ERR_DISCONNECT,
+	DBUS_ERR_NODEVICE,
+	DBUS_ERR_UNSUPPORTED,
+	DBUS_ERR_PENDING,
+	DBUS_ERR_NOMEM,
+	DBUS_ERR_TXFAIL,
+	DBUS_ERR_TXTIMEOUT,
+	DBUS_ERR_TXDROP,
+	DBUS_ERR_RXFAIL,
+	DBUS_ERR_RXDROP,
+	DBUS_ERR_TXCTLFAIL,
+	DBUS_ERR_RXCTLFAIL,
+	DBUS_ERR_REG_PARAM,
+	DBUS_STATUS_CANCELLED
+};
+
+#define ERR_CBMASK_TXFAIL		0x00000001
+#define ERR_CBMASK_RXFAIL		0x00000002
+#define ERR_CBMASK_ALL			0xFFFFFFFF
+
+#define DBUS_CBCTL_WRITE		0
+#define DBUS_CBCTL_READ			1
+
+#define DBUS_TX_RETRY_LIMIT		3	/* retries for failed txirb */
+#define DBUS_TX_TIMEOUT_INTERVAL	250	/* timeout for txirb complete, in ms */
+
+#define DBUS_BUFFER_SIZE_TX	5000
+#define DBUS_BUFFER_SIZE_RX	5000
+
+#define DBUS_BUFFER_SIZE_TX_NOAGG	2048
+#define DBUS_BUFFER_SIZE_RX_NOAGG	2048
+
+/* DBUS types */
+enum {
+	DBUS_USB,
+	DBUS_SDIO,
+	DBUS_SPI,
+	DBUS_UNKNOWN
+};
+
+enum dbus_state {
+	DBUS_STATE_DL_PENDING,
+	DBUS_STATE_DL_DONE,
+	DBUS_STATE_UP,
+	DBUS_STATE_DOWN,
+	DBUS_STATE_PNP_FWDL,
+	DBUS_STATE_DISCONNECT
+};
+
+enum dbus_pnp_state {
+	DBUS_PNP_DISCONNECT,
+	DBUS_PNP_SLEEP,
+	DBUS_PNP_RESUME
+};
+
+typedef enum _DEVICE_SPEED {
+	INVALID_SPEED = -1,
+	LOW_SPEED = 1,		/* USB 1.1: 1.5 Mbps */
+	FULL_SPEED,		/* USB 1.1: 12  Mbps */
+	HIGH_SPEED,		/* USB 2.0: 480 Mbps */
+	SUPER_SPEED,		/* USB 3.0: 4.8 Gbps */
+} DEVICE_SPEED;
+
+typedef struct {
+	int bustype;
+	int vid;
+	int pid;
+	int devid;
+	int chiprev;		/* chip revsion number */
+	int mtu;
+	int nchan;		/* Data Channels */
+} dbus_attrib_t;
+
+/* FIX: Account for errors related to DBUS;
+ * Let upper layer account for packets/bytes
+ */
+typedef struct {
+	uint32 rx_errors;
+	uint32 tx_errors;
+	uint32 rx_dropped;
+	uint32 tx_dropped;
+} dbus_stats_t;
+
+/*
+ * Configurable BUS parameters
+ */
+typedef struct {
+	bool rxctl_deferrespok;
+} dbus_config_t;
+
+struct dbus_callbacks;
+struct exec_parms;
+
+typedef void *(*probe_cb_t) (void *arg, const char *desc, uint32 bustype,
+			     uint32 hdrlen);
+typedef void (*disconnect_cb_t) (void *arg);
+typedef void *(*exec_cb_t) (struct exec_parms * args);
+
+/* Client callbacks registered during dbus_attach() */
+typedef struct dbus_callbacks {
+	void (*send_complete) (void *cbarg, void *info, int status);
+	void (*recv_buf) (void *cbarg, uint8 * buf, int len);
+	void (*recv_pkt) (void *cbarg, void *pkt);
+	void (*txflowcontrol) (void *cbarg, bool onoff);
+	void (*errhandler) (void *cbarg, int err);
+	void (*ctl_complete) (void *cbarg, int type, int status);
+	void (*state_change) (void *cbarg, int state);
+	void *(*pktget) (void *cbarg, uint len, bool send);
+	void (*pktfree) (void *cbarg, void *p, bool send);
+} dbus_callbacks_t;
+
+struct dbus_pub;
+struct bcmstrbuf;
+struct dbus_irb;
+struct dbus_irb_rx;
+struct dbus_irb_tx;
+struct dbus_intf_callbacks;
+
+typedef struct {
+	void *(*attach) (struct dbus_pub * pub, void *cbarg,
+			 struct dbus_intf_callbacks * cbs);
+	void (*detach) (struct dbus_pub * pub, void *bus);
+
+	int (*up) (void *bus);
+	int (*down) (void *bus);
+	int (*send_irb) (void *bus, struct dbus_irb_tx * txirb);
+	int (*recv_irb) (void *bus, struct dbus_irb_rx * rxirb);
+	int (*cancel_irb) (void *bus, struct dbus_irb_tx * txirb);
+	int (*send_ctl) (void *bus, uint8 * buf, int len);
+	int (*recv_ctl) (void *bus, uint8 * buf, int len);
+	int (*get_stats) (void *bus, dbus_stats_t * stats);
+	int (*get_attrib) (void *bus, dbus_attrib_t * attrib);
+
+	int (*pnp) (void *bus, int event);
+	int (*remove) (void *bus);
+	int (*resume) (void *bus);
+	int (*suspend) (void *bus);
+	int (*stop) (void *bus);
+	int (*reset) (void *bus);
+
+	/* Access to bus buffers directly */
+	void *(*pktget) (void *bus, int len);
+	void (*pktfree) (void *bus, void *pkt);
+
+	int (*iovar_op) (void *bus, const char *name, void *params, int plen,
+			 void *arg, int len, bool set);
+	void (*dump) (void *bus, struct bcmstrbuf * strbuf);
+	int (*set_config) (void *bus, dbus_config_t * config);
+	int (*get_config) (void *bus, dbus_config_t * config);
+
+	 bool(*device_exists) (void *bus);
+	 bool(*dlneeded) (void *bus);
+	int (*dlstart) (void *bus, uint8 * fw, int len);
+	int (*dlrun) (void *bus);
+	 bool(*recv_needed) (void *bus);
+
+	void *(*exec_rxlock) (void *bus, exec_cb_t func,
+			      struct exec_parms * args);
+	void *(*exec_txlock) (void *bus, exec_cb_t func,
+			      struct exec_parms * args);
+
+	int (*tx_timer_init) (void *bus);
+	int (*tx_timer_start) (void *bus, uint timeout);
+	int (*tx_timer_stop) (void *bus);
+
+	int (*sched_dpc) (void *bus);
+	int (*lock) (void *bus);
+	int (*unlock) (void *bus);
+	int (*sched_probe_cb) (void *bus);
+
+	int (*shutdown) (void *bus);
+
+	int (*recv_stop) (void *bus);
+	int (*recv_resume) (void *bus);
+
+	/* Add from the bottom */
+} dbus_intf_t;
+
+typedef struct dbus_pub {
+	struct osl_info *osh;
+	dbus_stats_t stats;
+	dbus_attrib_t attrib;
+	enum dbus_state busstate;
+	DEVICE_SPEED device_speed;
+	int ntxq, nrxq, rxsize;
+	void *bus;
+	struct shared_info *sh;
+} dbus_pub_t;
+
+#define BUS_INFO(bus, type) (((type *) bus)->pub->bus)
+
+/*
+ * Public Bus Function Interface
+ */
+extern int dbus_register(int vid, int pid, probe_cb_t prcb,
+			 disconnect_cb_t discb, void *prarg, void *param1,
+			 void *param2);
+extern int dbus_deregister(void);
+
+extern const dbus_pub_t *dbus_attach(struct osl_info *osh, int rxsize, int nrxq,
+				     int ntxq, void *cbarg,
+				     dbus_callbacks_t * cbs,
+				     struct shared_info *sh);
+extern void dbus_detach(const dbus_pub_t * pub);
+
+extern int dbus_up(const dbus_pub_t * pub);
+extern int dbus_down(const dbus_pub_t * pub);
+extern int dbus_stop(const dbus_pub_t * pub);
+extern int dbus_shutdown(const dbus_pub_t * pub);
+extern void dbus_flowctrl_rx(const dbus_pub_t * pub, bool on);
+
+extern int dbus_send_buf(const dbus_pub_t * pub, uint8 * buf, int len,
+			 void *info);
+extern int dbus_send_pkt(const dbus_pub_t * pub, void *pkt, void *info);
+extern int dbus_send_ctl(const dbus_pub_t * pub, uint8 * buf, int len);
+extern int dbus_recv_ctl(const dbus_pub_t * pub, uint8 * buf, int len);
+
+extern int dbus_get_stats(const dbus_pub_t * pub, dbus_stats_t * stats);
+extern int dbus_get_attrib(const dbus_pub_t * pub, dbus_attrib_t * attrib);
+extern int dbus_get_device_speed(const dbus_pub_t * pub);
+extern int dbus_set_config(const dbus_pub_t * pub, dbus_config_t * config);
+extern int dbus_get_config(const dbus_pub_t * pub, dbus_config_t * config);
+
+extern void *dbus_pktget(const dbus_pub_t * pub, int len);
+extern void dbus_pktfree(const dbus_pub_t * pub, void *pkt);
+
+extern int dbus_set_errmask(const dbus_pub_t * pub, uint32 mask);
+extern int dbus_pnp_sleep(const dbus_pub_t * pub);
+extern int dbus_pnp_resume(const dbus_pub_t * pub, int *fw_reload);
+extern int dbus_pnp_disconnect(const dbus_pub_t * pub);
+
+extern int dbus_iovar_op(const dbus_pub_t * pub, const char *name,
+			 void *params, int plen, void *arg, int len, bool set);
+#ifdef BCMDBG
+extern void dbus_hist_dump(const dbus_pub_t * pub, struct bcmstrbuf *b);
+#endif				/* BCMDBG */
+/*
+ * Private Common Bus Interface
+ */
+
+/* IO Request Block (IRB) */
+typedef struct dbus_irb {
+	struct dbus_irb *next;	/* it's casted from dbus_irb_tx or dbus_irb_rx struct */
+} dbus_irb_t;
+
+typedef struct dbus_irb_rx {
+	struct dbus_irb irb;	/* Must be first */
+	uint8 *buf;
+	int buf_len;
+	int actual_len;
+	void *pkt;
+	void *info;
+	void *arg;
+} dbus_irb_rx_t;
+
+typedef struct dbus_irb_tx {
+	struct dbus_irb irb;	/* Must be first */
+	uint8 *buf;
+	int len;
+	void *pkt;
+	int retry_count;
+	void *info;
+	void *arg;
+} dbus_irb_tx_t;
+
+/* DBUS interface callbacks are different from user callbacks
+ * so, internally, different info can be passed to upper layer
+ */
+typedef struct dbus_intf_callbacks {
+	void (*send_irb_timeout) (void *cbarg, dbus_irb_tx_t * txirb);
+	void (*send_irb_complete) (void *cbarg, dbus_irb_tx_t * txirb,
+				   int status);
+	void (*recv_irb_complete) (void *cbarg, dbus_irb_rx_t * rxirb,
+				   int status);
+	void (*errhandler) (void *cbarg, int err);
+	void (*ctl_complete) (void *cbarg, int type, int status);
+	void (*state_change) (void *cbarg, int state);
+	 bool(*isr) (void *cbarg, bool * wantdpc);
+	 bool(*dpc) (void *cbarg, bool bounded);
+	void (*watchdog) (void *cbarg);
+	void *(*pktget) (void *cbarg, uint len, bool send);
+	void (*pktfree) (void *cbarg, void *p, bool send);
+	struct dbus_irb *(*getirb) (void *cbarg, bool send);
+	void (*rxerr_indicate) (void *cbarg, bool on);
+} dbus_intf_callbacks_t;
+
+/*
+ * Porting: To support new bus, port these functions below
+ */
+
+/*
+ * Bus specific Interface
+ * Implemented by dbus_usb.c/dbus_sdio.c
+ */
+extern int dbus_bus_register(int vid, int pid, probe_cb_t prcb,
+			     disconnect_cb_t discb, void *prarg,
+			     dbus_intf_t ** intf, void *param1, void *param2);
+extern int dbus_bus_deregister(void);
+
+/*
+ * Bus-specific and OS-specific Interface
+ * Implemented by dbus_usb_[linux/ndis].c/dbus_sdio_[linux/ndis].c
+ */
+extern int dbus_bus_osl_register(int vid, int pid, probe_cb_t prcb,
+				 disconnect_cb_t discb, void *prarg,
+				 dbus_intf_t ** intf, void *param1,
+				 void *param2);
+extern int dbus_bus_osl_deregister(void);
+
+/*
+ * Bus-specific, OS-specific, HW-specific Interface
+ * Mainly for SDIO Host HW controller
+ */
+extern int dbus_bus_osl_hw_register(int vid, int pid, probe_cb_t prcb,
+				    disconnect_cb_t discb, void *prarg,
+				    dbus_intf_t ** intf);
+extern int dbus_bus_osl_hw_deregister(void);
+
+#endif				/* __DBUS_H__ */
diff --git a/drivers/staging/brcm80211/include/epivers.h b/drivers/staging/brcm80211/include/epivers.h
new file mode 100644
index 0000000..dc9b8a2
--- /dev/null
+++ b/drivers/staging/brcm80211/include/epivers.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _epivers_h_
+#define _epivers_h_
+
+#define	EPI_MAJOR_VERSION	5
+
+#define	EPI_MINOR_VERSION	75
+
+#define	EPI_RC_NUMBER		11
+
+#define	EPI_INCREMENTAL_NUMBER	0
+
+#define EPI_BUILD_NUMBER	1
+
+#define	EPI_VERSION		5, 75, 11, 0
+
+#ifdef BCMSDIO
+/* EPI_VERSION_NUM must match FW version */
+#define	EPI_VERSION_NUM		0x054b0c00
+#else
+#define	EPI_VERSION_NUM		0x054b0b00
+#endif
+
+#define EPI_VERSION_DEV		5.75.11
+
+/* Driver Version String, ASCII, 32 chars max */
+#define	EPI_VERSION_STR		"5.75.11"
+
+#endif				/* _epivers_h_ */
diff --git a/drivers/staging/brcm80211/include/hnddma.h b/drivers/staging/brcm80211/include/hnddma.h
new file mode 100644
index 0000000..747acf4
--- /dev/null
+++ b/drivers/staging/brcm80211/include/hnddma.h
@@ -0,0 +1,243 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_hnddma_h_
+#define	_hnddma_h_
+
+#ifndef _hnddma_pub_
+#define _hnddma_pub_
+typedef const struct hnddma_pub hnddma_t;
+#endif				/* _hnddma_pub_ */
+
+/* range param for dma_getnexttxp() and dma_txreclaim */
+typedef enum txd_range {
+	HNDDMA_RANGE_ALL = 1,
+	HNDDMA_RANGE_TRANSMITTED,
+	HNDDMA_RANGE_TRANSFERED
+} txd_range_t;
+
+/* dma function type */
+typedef void (*di_detach_t) (hnddma_t * dmah);
+typedef bool(*di_txreset_t) (hnddma_t * dmah);
+typedef bool(*di_rxreset_t) (hnddma_t * dmah);
+typedef bool(*di_rxidle_t) (hnddma_t * dmah);
+typedef void (*di_txinit_t) (hnddma_t * dmah);
+typedef bool(*di_txenabled_t) (hnddma_t * dmah);
+typedef void (*di_rxinit_t) (hnddma_t * dmah);
+typedef void (*di_txsuspend_t) (hnddma_t * dmah);
+typedef void (*di_txresume_t) (hnddma_t * dmah);
+typedef bool(*di_txsuspended_t) (hnddma_t * dmah);
+typedef bool(*di_txsuspendedidle_t) (hnddma_t * dmah);
+typedef int (*di_txfast_t) (hnddma_t * dmah, void *p, bool commit);
+typedef int (*di_txunframed_t) (hnddma_t * dmah, void *p, uint len,
+				bool commit);
+typedef void *(*di_getpos_t) (hnddma_t * di, bool direction);
+typedef void (*di_fifoloopbackenable_t) (hnddma_t * dmah);
+typedef bool(*di_txstopped_t) (hnddma_t * dmah);
+typedef bool(*di_rxstopped_t) (hnddma_t * dmah);
+typedef bool(*di_rxenable_t) (hnddma_t * dmah);
+typedef bool(*di_rxenabled_t) (hnddma_t * dmah);
+typedef void *(*di_rx_t) (hnddma_t * dmah);
+typedef bool(*di_rxfill_t) (hnddma_t * dmah);
+typedef void (*di_txreclaim_t) (hnddma_t * dmah, txd_range_t range);
+typedef void (*di_rxreclaim_t) (hnddma_t * dmah);
+typedef uintptr(*di_getvar_t) (hnddma_t * dmah, const char *name);
+typedef void *(*di_getnexttxp_t) (hnddma_t * dmah, txd_range_t range);
+typedef void *(*di_getnextrxp_t) (hnddma_t * dmah, bool forceall);
+typedef void *(*di_peeknexttxp_t) (hnddma_t * dmah);
+typedef void *(*di_peeknextrxp_t) (hnddma_t * dmah);
+typedef void (*di_rxparam_get_t) (hnddma_t * dmah, uint16 * rxoffset,
+				  uint16 * rxbufsize);
+typedef void (*di_txblock_t) (hnddma_t * dmah);
+typedef void (*di_txunblock_t) (hnddma_t * dmah);
+typedef uint(*di_txactive_t) (hnddma_t * dmah);
+typedef void (*di_txrotate_t) (hnddma_t * dmah);
+typedef void (*di_counterreset_t) (hnddma_t * dmah);
+typedef uint(*di_ctrlflags_t) (hnddma_t * dmah, uint mask, uint flags);
+typedef char *(*di_dump_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+			    bool dumpring);
+typedef char *(*di_dumptx_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+			      bool dumpring);
+typedef char *(*di_dumprx_t) (hnddma_t * dmah, struct bcmstrbuf * b,
+			      bool dumpring);
+typedef uint(*di_rxactive_t) (hnddma_t * dmah);
+typedef uint(*di_txpending_t) (hnddma_t * dmah);
+typedef uint(*di_txcommitted_t) (hnddma_t * dmah);
+
+/* dma opsvec */
+typedef struct di_fcn_s {
+	di_detach_t detach;
+	di_txinit_t txinit;
+	di_txreset_t txreset;
+	di_txenabled_t txenabled;
+	di_txsuspend_t txsuspend;
+	di_txresume_t txresume;
+	di_txsuspended_t txsuspended;
+	di_txsuspendedidle_t txsuspendedidle;
+	di_txfast_t txfast;
+	di_txunframed_t txunframed;
+	di_getpos_t getpos;
+	di_txstopped_t txstopped;
+	di_txreclaim_t txreclaim;
+	di_getnexttxp_t getnexttxp;
+	di_peeknexttxp_t peeknexttxp;
+	di_txblock_t txblock;
+	di_txunblock_t txunblock;
+	di_txactive_t txactive;
+	di_txrotate_t txrotate;
+
+	di_rxinit_t rxinit;
+	di_rxreset_t rxreset;
+	di_rxidle_t rxidle;
+	di_rxstopped_t rxstopped;
+	di_rxenable_t rxenable;
+	di_rxenabled_t rxenabled;
+	di_rx_t rx;
+	di_rxfill_t rxfill;
+	di_rxreclaim_t rxreclaim;
+	di_getnextrxp_t getnextrxp;
+	di_peeknextrxp_t peeknextrxp;
+	di_rxparam_get_t rxparam_get;
+
+	di_fifoloopbackenable_t fifoloopbackenable;
+	di_getvar_t d_getvar;
+	di_counterreset_t counterreset;
+	di_ctrlflags_t ctrlflags;
+	di_dump_t dump;
+	di_dumptx_t dumptx;
+	di_dumprx_t dumprx;
+	di_rxactive_t rxactive;
+	di_txpending_t txpending;
+	di_txcommitted_t txcommitted;
+	uint endnum;
+} di_fcn_t;
+
+/*
+ * Exported data structure (read-only)
+ */
+/* export structure */
+struct hnddma_pub {
+	const di_fcn_t *di_fn;	/* DMA function pointers */
+	uint txavail;		/* # free tx descriptors */
+	uint dmactrlflags;	/* dma control flags */
+
+	/* rx error counters */
+	uint rxgiants;		/* rx giant frames */
+	uint rxnobuf;		/* rx out of dma descriptors */
+	/* tx error counters */
+	uint txnobuf;		/* tx out of dma descriptors */
+};
+
+extern hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih,
+			    void *dmaregstx, void *dmaregsrx, uint ntxd,
+			    uint nrxd, uint rxbufsize, int rxextheadroom,
+			    uint nrxpost, uint rxoffset, uint * msg_level);
+#ifdef BCMDMA32
+
+#define dma_detach(di)			((di)->di_fn->detach(di))
+#define dma_txreset(di)			((di)->di_fn->txreset(di))
+#define dma_rxreset(di)			((di)->di_fn->rxreset(di))
+#define dma_rxidle(di)			((di)->di_fn->rxidle(di))
+#define dma_txinit(di)                  ((di)->di_fn->txinit(di))
+#define dma_txenabled(di)               ((di)->di_fn->txenabled(di))
+#define dma_rxinit(di)                  ((di)->di_fn->rxinit(di))
+#define dma_txsuspend(di)               ((di)->di_fn->txsuspend(di))
+#define dma_txresume(di)                ((di)->di_fn->txresume(di))
+#define dma_txsuspended(di)             ((di)->di_fn->txsuspended(di))
+#define dma_txsuspendedidle(di)         ((di)->di_fn->txsuspendedidle(di))
+#define dma_txfast(di, p, commit)	((di)->di_fn->txfast(di, p, commit))
+#define dma_fifoloopbackenable(di)      ((di)->di_fn->fifoloopbackenable(di))
+#define dma_txstopped(di)               ((di)->di_fn->txstopped(di))
+#define dma_rxstopped(di)               ((di)->di_fn->rxstopped(di))
+#define dma_rxenable(di)                ((di)->di_fn->rxenable(di))
+#define dma_rxenabled(di)               ((di)->di_fn->rxenabled(di))
+#define dma_rx(di)                      ((di)->di_fn->rx(di))
+#define dma_rxfill(di)                  ((di)->di_fn->rxfill(di))
+#define dma_txreclaim(di, range)	((di)->di_fn->txreclaim(di, range))
+#define dma_rxreclaim(di)               ((di)->di_fn->rxreclaim(di))
+#define dma_getvar(di, name)		((di)->di_fn->d_getvar(di, name))
+#define dma_getnexttxp(di, range)	((di)->di_fn->getnexttxp(di, range))
+#define dma_getnextrxp(di, forceall)    ((di)->di_fn->getnextrxp(di, forceall))
+#define dma_peeknexttxp(di)             ((di)->di_fn->peeknexttxp(di))
+#define dma_peeknextrxp(di)             ((di)->di_fn->peeknextrxp(di))
+#define dma_rxparam_get(di, off, bufs)	((di)->di_fn->rxparam_get(di, off, bufs))
+
+#define dma_txblock(di)                 ((di)->di_fn->txblock(di))
+#define dma_txunblock(di)               ((di)->di_fn->txunblock(di))
+#define dma_txactive(di)                ((di)->di_fn->txactive(di))
+#define dma_rxactive(di)                ((di)->di_fn->rxactive(di))
+#define dma_txrotate(di)                ((di)->di_fn->txrotate(di))
+#define dma_counterreset(di)            ((di)->di_fn->counterreset(di))
+#define dma_ctrlflags(di, mask, flags)  ((di)->di_fn->ctrlflags((di), (mask), (flags)))
+#define dma_txpending(di)		((di)->di_fn->txpending(di))
+#define dma_txcommitted(di)		((di)->di_fn->txcommitted(di))
+
+#else				/* BCMDMA32 */
+extern const di_fcn_t dma64proc;
+
+#define dma_detach(di)			(dma64proc.detach(di))
+#define dma_txreset(di)			(dma64proc.txreset(di))
+#define dma_rxreset(di)			(dma64proc.rxreset(di))
+#define dma_rxidle(di)			(dma64proc.rxidle(di))
+#define dma_txinit(di)                  (dma64proc.txinit(di))
+#define dma_txenabled(di)               (dma64proc.txenabled(di))
+#define dma_rxinit(di)                  (dma64proc.rxinit(di))
+#define dma_txsuspend(di)               (dma64proc.txsuspend(di))
+#define dma_txresume(di)                (dma64proc.txresume(di))
+#define dma_txsuspended(di)             (dma64proc.txsuspended(di))
+#define dma_txsuspendedidle(di)         (dma64proc.txsuspendedidle(di))
+#define dma_txfast(di, p, commit)	(dma64proc.txfast(di, p, commit))
+#define dma_txunframed(di, p, l, commit)(dma64proc.txunframed(di, p, l, commit))
+#define dma_getpos(di, dir)		(dma64proc.getpos(di, dir))
+#define dma_fifoloopbackenable(di)      (dma64proc.fifoloopbackenable(di))
+#define dma_txstopped(di)               (dma64proc.txstopped(di))
+#define dma_rxstopped(di)               (dma64proc.rxstopped(di))
+#define dma_rxenable(di)                (dma64proc.rxenable(di))
+#define dma_rxenabled(di)               (dma64proc.rxenabled(di))
+#define dma_rx(di)                      (dma64proc.rx(di))
+#define dma_rxfill(di)                  (dma64proc.rxfill(di))
+#define dma_txreclaim(di, range)	(dma64proc.txreclaim(di, range))
+#define dma_rxreclaim(di)               (dma64proc.rxreclaim(di))
+#define dma_getvar(di, name)		(dma64proc.d_getvar(di, name))
+#define dma_getnexttxp(di, range)	(dma64proc.getnexttxp(di, range))
+#define dma_getnextrxp(di, forceall)    (dma64proc.getnextrxp(di, forceall))
+#define dma_peeknexttxp(di)             (dma64proc.peeknexttxp(di))
+#define dma_peeknextrxp(di)             (dma64proc.peeknextrxp(di))
+#define dma_rxparam_get(di, off, bufs)	(dma64proc.rxparam_get(di, off, bufs))
+
+#define dma_txblock(di)                 (dma64proc.txblock(di))
+#define dma_txunblock(di)               (dma64proc.txunblock(di))
+#define dma_txactive(di)                (dma64proc.txactive(di))
+#define dma_rxactive(di)                (dma64proc.rxactive(di))
+#define dma_txrotate(di)                (dma64proc.txrotate(di))
+#define dma_counterreset(di)            (dma64proc.counterreset(di))
+#define dma_ctrlflags(di, mask, flags)  (dma64proc.ctrlflags((di), (mask), (flags)))
+#define dma_txpending(di)		(dma64proc.txpending(di))
+#define dma_txcommitted(di)		(dma64proc.txcommitted(di))
+
+#endif				/* BCMDMA32 */
+
+/* return addresswidth allowed
+ * This needs to be done after SB attach but before dma attach.
+ * SB attach provides ability to probe backplane and dma core capabilities
+ * This info is needed by DMA_ALLOC_CONSISTENT in dma attach
+ */
+extern uint dma_addrwidth(si_t * sih, void *dmaregs);
+
+/* pio helpers */
+extern void dma_txpioloopback(osl_t * osh, dma32regs_t *);
+
+#endif				/* _hnddma_h_ */
diff --git a/drivers/staging/brcm80211/include/hndpmu.h b/drivers/staging/brcm80211/include/hndpmu.h
new file mode 100644
index 0000000..57bf0c4
--- /dev/null
+++ b/drivers/staging/brcm80211/include/hndpmu.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _hndpmu_h_
+#define _hndpmu_h_
+
+#define SET_LDO_VOLTAGE_LDO1	1
+#define SET_LDO_VOLTAGE_LDO2	2
+#define SET_LDO_VOLTAGE_LDO3	3
+#define SET_LDO_VOLTAGE_PAREF	4
+#define SET_LDO_VOLTAGE_CLDO_PWM	5
+#define SET_LDO_VOLTAGE_CLDO_BURST	6
+#define SET_LDO_VOLTAGE_CBUCK_PWM	7
+#define SET_LDO_VOLTAGE_CBUCK_BURST	8
+#define SET_LDO_VOLTAGE_LNLDO1	9
+#define SET_LDO_VOLTAGE_LNLDO2_SEL	10
+
+extern void si_pmu_init(si_t * sih, osl_t * osh);
+extern void si_pmu_chip_init(si_t * sih, osl_t * osh);
+extern void si_pmu_pll_init(si_t * sih, osl_t * osh, uint32 xtalfreq);
+extern void si_pmu_res_init(si_t * sih, osl_t * osh);
+extern void si_pmu_swreg_init(si_t * sih, osl_t * osh);
+
+extern uint32 si_pmu_force_ilp(si_t * sih, osl_t * osh, bool force);
+
+extern uint32 si_pmu_si_clock(si_t * sih, osl_t * osh);
+extern uint32 si_pmu_cpu_clock(si_t * sih, osl_t * osh);
+extern uint32 si_pmu_mem_clock(si_t * sih, osl_t * osh);
+extern uint32 si_pmu_alp_clock(si_t * sih, osl_t * osh);
+extern uint32 si_pmu_ilp_clock(si_t * sih, osl_t * osh);
+
+extern void si_pmu_set_switcher_voltage(si_t * sih, osl_t * osh,
+					uint8 bb_voltage, uint8 rf_voltage);
+extern void si_pmu_set_ldo_voltage(si_t * sih, osl_t * osh, uint8 ldo,
+				   uint8 voltage);
+extern uint16 si_pmu_fast_pwrup_delay(si_t * sih, osl_t * osh);
+extern void si_pmu_rcal(si_t * sih, osl_t * osh);
+extern void si_pmu_pllupd(si_t * sih);
+extern void si_pmu_spuravoid(si_t * sih, osl_t * osh, uint8 spuravoid);
+
+extern bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh);
+extern uint32 si_pmu_measure_alpclk(si_t * sih, osl_t * osh);
+
+extern uint32 si_pmu_chipcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
+extern uint32 si_pmu_regcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
+extern uint32 si_pmu_pllcontrol(si_t * sih, uint reg, uint32 mask, uint32 val);
+extern void si_pmu_pllupd(si_t * sih);
+extern void si_pmu_sprom_enable(si_t * sih, osl_t * osh, bool enable);
+
+extern void si_pmu_radio_enable(si_t * sih, bool enable);
+extern uint32 si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh,
+					     uint32 clk, uint32 delay);
+
+extern void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on);
+extern void si_sdiod_drive_strength_init(si_t * sih, osl_t * osh,
+					 uint32 drivestrength);
+
+#endif				/* _hndpmu_h_ */
diff --git a/drivers/staging/brcm80211/include/hndsoc.h b/drivers/staging/brcm80211/include/hndsoc.h
new file mode 100644
index 0000000..9747cc4
--- /dev/null
+++ b/drivers/staging/brcm80211/include/hndsoc.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_HNDSOC_H
+#define	_HNDSOC_H
+
+/* Include the soci specific files */
+#include <sbconfig.h>
+#include <aidmp.h>
+
+/*
+ * SOC Interconnect Address Map.
+ * All regions may not exist on all chips.
+ */
+#define SI_SDRAM_BASE		0x00000000	/* Physical SDRAM */
+#define SI_PCI_MEM		0x08000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SI_PCI_MEM_SZ		(64 * 1024 * 1024)
+#define SI_PCI_CFG		0x0c000000	/* Host Mode sb2pcitranslation1 (64 MB) */
+#define	SI_SDRAM_SWAPPED	0x10000000	/* Byteswapped Physical SDRAM */
+#define SI_SDRAM_R2		0x80000000	/* Region 2 for sdram (512 MB) */
+
+#ifdef SI_ENUM_BASE_VARIABLE
+#define SI_ENUM_BASE		(sii->pub.si_enum_base)
+#else
+#define SI_ENUM_BASE    	0x18000000	/* Enumeration space base */
+#endif				/* SI_ENUM_BASE_VARIABLE */
+
+#define SI_WRAP_BASE    	0x18100000	/* Wrapper space base */
+#define SI_CORE_SIZE    	0x1000	/* each core gets 4Kbytes for registers */
+#define	SI_MAXCORES		16	/* Max cores (this is arbitrary, for software
+					 * convenience and could be changed if we
+					 * make any larger chips
+					 */
+
+#define	SI_FASTRAM		0x19000000	/* On-chip RAM on chips that also have DDR */
+#define	SI_FASTRAM_SWAPPED	0x19800000
+
+#define	SI_FLASH2		0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
+#define	SI_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
+#define	SI_ARMCM3_ROM		0x1e000000	/* ARM Cortex-M3 ROM */
+#define	SI_FLASH1		0x1fc00000	/* MIPS Flash Region 1 */
+#define	SI_FLASH1_SZ		0x00400000	/* MIPS Size of Flash Region 1 */
+#define	SI_ARM7S_ROM		0x20000000	/* ARM7TDMI-S ROM */
+#define	SI_ARMCM3_SRAM2		0x60000000	/* ARM Cortex-M3 SRAM Region 2 */
+#define	SI_ARM7S_SRAM2		0x80000000	/* ARM7TDMI-S SRAM Region 2 */
+#define	SI_ARM_FLASH1		0xffff0000	/* ARM Flash Region 1 */
+#define	SI_ARM_FLASH1_SZ	0x00010000	/* ARM Size of Flash Region 1 */
+
+#define SI_PCI_DMA		0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SI_PCI_DMA2		0x80000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SI_PCI_DMA_SZ		0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
+#define SI_PCIE_DMA_L32		0x00000000	/* PCIE Client Mode sb2pcitranslation2
+						 * (2 ZettaBytes), low 32 bits
+						 */
+#define SI_PCIE_DMA_H32		0x80000000	/* PCIE Client Mode sb2pcitranslation2
+						 * (2 ZettaBytes), high 32 bits
+						 */
+
+/* core codes */
+#define	NODEV_CORE_ID		0x700	/* Invalid coreid */
+#define	CC_CORE_ID		0x800	/* chipcommon core */
+#define	ILINE20_CORE_ID		0x801	/* iline20 core */
+#define	SRAM_CORE_ID		0x802	/* sram core */
+#define	SDRAM_CORE_ID		0x803	/* sdram core */
+#define	PCI_CORE_ID		0x804	/* pci core */
+#define	MIPS_CORE_ID		0x805	/* mips core */
+#define	ENET_CORE_ID		0x806	/* enet mac core */
+#define	CODEC_CORE_ID		0x807	/* v90 codec core */
+#define	USB_CORE_ID		0x808	/* usb 1.1 host/device core */
+#define	ADSL_CORE_ID		0x809	/* ADSL core */
+#define	ILINE100_CORE_ID	0x80a	/* iline100 core */
+#define	IPSEC_CORE_ID		0x80b	/* ipsec core */
+#define	UTOPIA_CORE_ID		0x80c	/* utopia core */
+#define	PCMCIA_CORE_ID		0x80d	/* pcmcia core */
+#define	SOCRAM_CORE_ID		0x80e	/* internal memory core */
+#define	MEMC_CORE_ID		0x80f	/* memc sdram core */
+#define	OFDM_CORE_ID		0x810	/* OFDM phy core */
+#define	EXTIF_CORE_ID		0x811	/* external interface core */
+#define	D11_CORE_ID		0x812	/* 802.11 MAC core */
+#define	APHY_CORE_ID		0x813	/* 802.11a phy core */
+#define	BPHY_CORE_ID		0x814	/* 802.11b phy core */
+#define	GPHY_CORE_ID		0x815	/* 802.11g phy core */
+#define	MIPS33_CORE_ID		0x816	/* mips3302 core */
+#define	USB11H_CORE_ID		0x817	/* usb 1.1 host core */
+#define	USB11D_CORE_ID		0x818	/* usb 1.1 device core */
+#define	USB20H_CORE_ID		0x819	/* usb 2.0 host core */
+#define	USB20D_CORE_ID		0x81a	/* usb 2.0 device core */
+#define	SDIOH_CORE_ID		0x81b	/* sdio host core */
+#define	ROBO_CORE_ID		0x81c	/* roboswitch core */
+#define	ATA100_CORE_ID		0x81d	/* parallel ATA core */
+#define	SATAXOR_CORE_ID		0x81e	/* serial ATA & XOR DMA core */
+#define	GIGETH_CORE_ID		0x81f	/* gigabit ethernet core */
+#define	PCIE_CORE_ID		0x820	/* pci express core */
+#define	NPHY_CORE_ID		0x821	/* 802.11n 2x2 phy core */
+#define	SRAMC_CORE_ID		0x822	/* SRAM controller core */
+#define	MINIMAC_CORE_ID		0x823	/* MINI MAC/phy core */
+#define	ARM11_CORE_ID		0x824	/* ARM 1176 core */
+#define	ARM7S_CORE_ID		0x825	/* ARM7tdmi-s core */
+#define	LPPHY_CORE_ID		0x826	/* 802.11a/b/g phy core */
+#define	PMU_CORE_ID		0x827	/* PMU core */
+#define	SSNPHY_CORE_ID		0x828	/* 802.11n single-stream phy core */
+#define	SDIOD_CORE_ID		0x829	/* SDIO device core */
+#define	ARMCM3_CORE_ID		0x82a	/* ARM Cortex M3 core */
+#define	HTPHY_CORE_ID		0x82b	/* 802.11n 4x4 phy core */
+#define	MIPS74K_CORE_ID		0x82c	/* mips 74k core */
+#define	GMAC_CORE_ID		0x82d	/* Gigabit MAC core */
+#define	DMEMC_CORE_ID		0x82e	/* DDR1/2 memory controller core */
+#define	PCIERC_CORE_ID		0x82f	/* PCIE Root Complex core */
+#define	OCP_CORE_ID		0x830	/* OCP2OCP bridge core */
+#define	SC_CORE_ID		0x831	/* shared common core */
+#define	AHB_CORE_ID		0x832	/* OCP2AHB bridge core */
+#define	SPIH_CORE_ID		0x833	/* SPI host core */
+#define	I2S_CORE_ID		0x834	/* I2S core */
+#define	DMEMS_CORE_ID		0x835	/* SDR/DDR1 memory controller core */
+#define	DEF_SHIM_COMP		0x837	/* SHIM component in ubus/6362 */
+#define OOB_ROUTER_CORE_ID	0x367	/* OOB router core ID */
+#define	DEF_AI_COMP		0xfff	/* Default component, in ai chips it maps all
+					 * unused address ranges
+					 */
+
+/* There are TWO constants on all HND chips: SI_ENUM_BASE above,
+ * and chipcommon being the first core:
+ */
+#define	SI_CC_IDX		0
+
+/* SOC Interconnect types (aka chip types) */
+#define	SOCI_AI			1
+
+/* Common core control flags */
+#define	SICF_BIST_EN		0x8000
+#define	SICF_PME_EN		0x4000
+#define	SICF_CORE_BITS		0x3ffc
+#define	SICF_FGC		0x0002
+#define	SICF_CLOCK_EN		0x0001
+
+/* Common core status flags */
+#define	SISF_BIST_DONE		0x8000
+#define	SISF_BIST_ERROR		0x4000
+#define	SISF_GATED_CLK		0x2000
+#define	SISF_DMA64		0x1000
+#define	SISF_CORE_BITS		0x0fff
+
+/* A register that is common to all cores to
+ * communicate w/PMU regarding clock control.
+ */
+#define SI_CLK_CTL_ST		0x1e0	/* clock control and status */
+
+/* clk_ctl_st register */
+#define	CCS_FORCEALP		0x00000001	/* force ALP request */
+#define	CCS_FORCEHT		0x00000002	/* force HT request */
+#define	CCS_FORCEILP		0x00000004	/* force ILP request */
+#define	CCS_ALPAREQ		0x00000008	/* ALP Avail Request */
+#define	CCS_HTAREQ		0x00000010	/* HT Avail Request */
+#define	CCS_FORCEHWREQOFF	0x00000020	/* Force HW Clock Request Off */
+#define CCS_ERSRC_REQ_MASK	0x00000700	/* external resource requests */
+#define CCS_ERSRC_REQ_SHIFT	8
+#define	CCS_ALPAVAIL		0x00010000	/* ALP is available */
+#define	CCS_HTAVAIL		0x00020000	/* HT is available */
+#define CCS_BP_ON_APL		0x00040000	/* RO: Backplane is running on ALP clock */
+#define CCS_BP_ON_HT		0x00080000	/* RO: Backplane is running on HT clock */
+#define CCS_ERSRC_STS_MASK	0x07000000	/* external resource status */
+#define CCS_ERSRC_STS_SHIFT	24
+
+#define	CCS0_HTAVAIL		0x00010000	/* HT avail in chipc and pcmcia on 4328a0 */
+#define	CCS0_ALPAVAIL		0x00020000	/* ALP avail in chipc and pcmcia on 4328a0 */
+
+/* Not really related to SOC Interconnect, but a couple of software
+ * conventions for the use the flash space:
+ */
+
+/* Minumum amount of flash we support */
+#define FLASH_MIN		0x00020000	/* Minimum flash size */
+
+/* A boot/binary may have an embedded block that describes its size  */
+#define	BISZ_OFFSET		0x3e0	/* At this offset into the binary */
+#define	BISZ_MAGIC		0x4249535a	/* Marked with this value: 'BISZ' */
+#define	BISZ_MAGIC_IDX		0	/* Word 0: magic */
+#define	BISZ_TXTST_IDX		1	/*      1: text start */
+#define	BISZ_TXTEND_IDX		2	/*      2: text end */
+#define	BISZ_DATAST_IDX		3	/*      3: data start */
+#define	BISZ_DATAEND_IDX	4	/*      4: data end */
+#define	BISZ_BSSST_IDX		5	/*      5: bss start */
+#define	BISZ_BSSEND_IDX		6	/*      6: bss end */
+#define BISZ_SIZE		7	/* descriptor size in 32-bit integers */
+
+#endif				/* _HNDSOC_H */
diff --git a/drivers/staging/brcm80211/include/hndtcam.h b/drivers/staging/brcm80211/include/hndtcam.h
new file mode 100644
index 0000000..575456e
--- /dev/null
+++ b/drivers/staging/brcm80211/include/hndtcam.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _hndtcam_h_
+#define _hndtcam_h_
+
+/*
+ * 0 - 1
+ * 1 - 2 Consecutive locations are patched
+ * 2 - 4 Consecutive locations are patched
+ * 3 - 8 Consecutive locations are patched
+ * 4 - 16 Consecutive locations are patched
+ * Define default to patch 2 locations
+ */
+
+#define PATCHCOUNT 0
+#define SRPC_PATCHCOUNT PATCHCOUNT
+
+/* N Consecutive location to patch */
+#define SRPC_PATCHNLOC (1 << (SRPC_PATCHCOUNT))
+
+/* patch values and address structure */
+typedef struct patchaddrvalue {
+	uint32 addr;
+	uint32 value;
+} patchaddrvalue_t;
+
+extern void hnd_patch_init(void *srp);
+extern void hnd_tcam_write(void *srp, uint16 index, uint32 data);
+extern void hnd_tcam_read(void *srp, uint16 index, uint32 * content);
+void *hnd_tcam_init(void *srp, uint no_addrs);
+extern void hnd_tcam_disablepatch(void *srp);
+extern void hnd_tcam_enablepatch(void *srp);
+extern void hnd_tcam_load(void *srp, const patchaddrvalue_t * patchtbl);
+#endif				/* _hndtcam_h_ */
diff --git a/drivers/staging/brcm80211/include/linux_osl.h b/drivers/staging/brcm80211/include/linux_osl.h
new file mode 100644
index 0000000..bec6616
--- /dev/null
+++ b/drivers/staging/brcm80211/include/linux_osl.h
@@ -0,0 +1,370 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _linux_osl_h_
+#define _linux_osl_h_
+
+#include <typedefs.h>
+
+/* Linux Kernel: File Operations: start */
+extern void *osl_os_open_image(char *filename);
+extern int osl_os_get_image_block(char *buf, int len, void *image);
+extern void osl_os_close_image(void *image);
+/* Linux Kernel: File Operations: end */
+
+extern osl_t *osl_attach(void *pdev, uint bustype, bool pkttag);
+extern void osl_detach(osl_t * osh);
+
+extern uint32 g_assert_type;
+
+#if defined(BCMDBG_ASSERT)
+#define ASSERT(exp) \
+	  do { if (!(exp)) osl_assert(#exp, __FILE__, __LINE__); } while (0)
+extern void osl_assert(char *exp, char *file, int line);
+#else
+#ifdef __GNUC__
+#define GCC_VERSION \
+			(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#if GCC_VERSION > 30100
+#define ASSERT(exp)	do {} while (0)
+#else
+			/* ASSERT could cause segmentation fault on GCC3.1, use empty instead */
+#define ASSERT(exp)
+#endif				/* GCC_VERSION > 30100 */
+#endif				/* __GNUC__ */
+#endif				/* defined(BCMDBG_ASSERT) */
+
+#define	OSL_DELAY(usec)		osl_delay(usec)
+extern void osl_delay(uint usec);
+
+#define	OSL_PCMCIA_READ_ATTR(osh, offset, buf, size) \
+	osl_pcmcia_read_attr((osh), (offset), (buf), (size))
+#define	OSL_PCMCIA_WRITE_ATTR(osh, offset, buf, size) \
+	osl_pcmcia_write_attr((osh), (offset), (buf), (size))
+extern void osl_pcmcia_read_attr(osl_t * osh, uint offset, void *buf, int size);
+extern void osl_pcmcia_write_attr(osl_t * osh, uint offset, void *buf,
+				  int size);
+
+/* PCI configuration space access macros */
+#define	OSL_PCI_READ_CONFIG(osh, offset, size) \
+	osl_pci_read_config((osh), (offset), (size))
+#define	OSL_PCI_WRITE_CONFIG(osh, offset, size, val) \
+	osl_pci_write_config((osh), (offset), (size), (val))
+extern uint32 osl_pci_read_config(osl_t * osh, uint offset, uint size);
+extern void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val);
+
+/* PCI device bus # and slot # */
+#define OSL_PCI_BUS(osh)	osl_pci_bus(osh)
+#define OSL_PCI_SLOT(osh)	osl_pci_slot(osh)
+extern uint osl_pci_bus(osl_t * osh);
+extern uint osl_pci_slot(osl_t * osh);
+
+/* Pkttag flag should be part of public information */
+typedef struct {
+	bool pkttag;
+	uint pktalloced;	/* Number of allocated packet buffers */
+	bool mmbus;		/* Bus supports memory-mapped register accesses */
+	pktfree_cb_fn_t tx_fn;	/* Callback function for PKTFREE */
+	void *tx_ctx;		/* Context to the callback function */
+#ifdef BCMSDIO
+	osl_rreg_fn_t rreg_fn;	/* Read Register function */
+	osl_wreg_fn_t wreg_fn;	/* Write Register function */
+	void *reg_ctx;		/* Context to the reg callback functions */
+#endif
+} osl_pubinfo_t;
+
+#define PKTFREESETCB(osh, _tx_fn, _tx_ctx)			\
+	do {							\
+		((osl_pubinfo_t*)osh)->tx_fn = _tx_fn;		\
+		((osl_pubinfo_t*)osh)->tx_ctx = _tx_ctx;	\
+	} while (0)
+
+#ifdef BCMSDIO
+#define REGOPSSET(osh, rreg, wreg, ctx)			\
+	do {						\
+		((osl_pubinfo_t*)osh)->rreg_fn = rreg;	\
+		((osl_pubinfo_t*)osh)->wreg_fn = wreg;	\
+		((osl_pubinfo_t*)osh)->reg_ctx = ctx;	\
+	} while (0)
+#endif
+
+#define BUS_SWAP32(v)		(v)
+
+#define MALLOC(osh, size)	osl_malloc((osh), (size))
+#define MFREE(osh, addr, size)	osl_mfree((osh), (addr), (size))
+#define MALLOCED(osh)		osl_malloced((osh))
+extern void *osl_malloc(osl_t * osh, uint size);
+extern void osl_mfree(osl_t * osh, void *addr, uint size);
+extern uint osl_malloced(osl_t * osh);
+
+#define NATIVE_MALLOC(osh, size)	kmalloc(size, GFP_ATOMIC)
+#define NATIVE_MFREE(osh, addr, size)	kfree(addr)
+#define	MALLOC_FAILED(osh)		osl_malloc_failed((osh))
+extern uint osl_malloc_failed(osl_t * osh);
+
+/* allocate/free shared (dma-able) consistent memory */
+#define	DMA_CONSISTENT_ALIGN	osl_dma_consistent_align()
+#define	DMA_ALLOC_CONSISTENT(osh, size, align, tot, pap, dmah) \
+	osl_dma_alloc_consistent((osh), (size), (align), (tot), (pap))
+#define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
+	osl_dma_free_consistent((osh), (void*)(va), (size), (pa))
+extern uint osl_dma_consistent_align(void);
+extern void *osl_dma_alloc_consistent(osl_t * osh, uint size, uint16 align,
+				      uint * tot, ulong * pap);
+extern void osl_dma_free_consistent(osl_t * osh, void *va, uint size, ulong pa);
+
+/* map/unmap direction */
+#define	DMA_TX	1		/* TX direction for DMA */
+#define	DMA_RX	2		/* RX direction for DMA */
+
+/* map/unmap shared (dma-able) memory */
+#define	DMA_MAP(osh, va, size, direction, p, dmah) \
+	osl_dma_map((osh), (va), (size), (direction))
+#define	DMA_UNMAP(osh, pa, size, direction, p, dmah) \
+	osl_dma_unmap((osh), (pa), (size), (direction))
+extern uint osl_dma_map(osl_t * osh, void *va, uint size, int direction);
+extern void osl_dma_unmap(osl_t * osh, uint pa, uint size, int direction);
+
+/* API for DMA addressing capability */
+#define OSL_DMADDRWIDTH(osh, addrwidth) do {} while (0)
+
+/* register access macros */
+#if defined(BCMSDIO)
+#include <bcmsdh.h>
+#define OSL_WRITE_REG(osh, r, v) (bcmsdh_reg_write(NULL, (uintptr)(r), sizeof(*(r)), (v)))
+#define OSL_READ_REG(osh, r) (bcmsdh_reg_read(NULL, (uintptr)(r), sizeof(*(r))))
+#endif
+
+#if defined(BCMSDIO)
+#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) if (((osl_pubinfo_t*)(osh))->mmbus) \
+		mmap_op else bus_op
+#define SELECT_BUS_READ(osh, mmap_op, bus_op) (((osl_pubinfo_t*)(osh))->mmbus) ? \
+		mmap_op : bus_op
+#else
+#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) mmap_op
+#define SELECT_BUS_READ(osh, mmap_op, bus_op) mmap_op
+#endif
+
+#define OSL_ERROR(bcmerror)	osl_error(bcmerror)
+extern int osl_error(int bcmerror);
+
+/* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
+#define	PKTBUFSZ	2048	/* largest reasonable packet buffer, driver uses for ethernet MTU */
+
+#define OSL_SYSUPTIME()		((uint32)jiffies * (1000 / HZ))
+#define	printf(fmt, args...)	printk(fmt , ## args)
+#include <linux/kernel.h>	/* for vsn/printf's */
+#include <linux/string.h>	/* for mem*, str* */
+/* bcopy's: Linux kernel doesn't provide these (anymore) */
+#define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
+#define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
+#define	bzero(b, len)		memset((b), '\0', (len))
+
+/* register access macros */
+#if defined(OSLREGOPS)
+#else
+#ifndef IL_BIGENDIAN
+#ifndef __mips__
+#define R_REG(osh, r) (\
+	SELECT_BUS_READ(osh, sizeof(*(r)) == sizeof(uint8) ? readb((volatile uint8*)(r)) : \
+	sizeof(*(r)) == sizeof(uint16) ? readw((volatile uint16*)(r)) : \
+	readl((volatile uint32*)(r)), OSL_READ_REG(osh, r)) \
+)
+#else				/* __mips__ */
+#define R_REG(osh, r) (\
+	SELECT_BUS_READ(osh, \
+		({ \
+			__typeof(*(r)) __osl_v; \
+			__asm__ __volatile__("sync"); \
+			switch (sizeof(*(r))) { \
+			case sizeof(uint8):	__osl_v = \
+				readb((volatile uint8*)(r)); break; \
+			case sizeof(uint16):	__osl_v = \
+				readw((volatile uint16*)(r)); break; \
+			case sizeof(uint32):	__osl_v = \
+				readl((volatile uint32*)(r)); break; \
+			} \
+			__asm__ __volatile__("sync"); \
+			__osl_v; \
+		}), \
+		({ \
+			__typeof(*(r)) __osl_v; \
+			__asm__ __volatile__("sync"); \
+			__osl_v = OSL_READ_REG(osh, r); \
+			__asm__ __volatile__("sync"); \
+			__osl_v; \
+		})) \
+)
+#endif				/* __mips__ */
+
+#define W_REG(osh, r, v) do { \
+	SELECT_BUS_WRITE(osh,  \
+		switch (sizeof(*(r))) { \
+		case sizeof(uint8): \
+			writeb((uint8)(v), (volatile uint8*)(r)); break; \
+		case sizeof(uint16): \
+			writew((uint16)(v), (volatile uint16*)(r)); break; \
+		case sizeof(uint32): \
+			writel((uint32)(v), (volatile uint32*)(r)); break; \
+		}, \
+		(OSL_WRITE_REG(osh, r, v))); \
+	} while (0)
+#else				/* IL_BIGENDIAN */
+#define R_REG(osh, r) (\
+	SELECT_BUS_READ(osh, \
+		({ \
+			__typeof(*(r)) __osl_v; \
+			switch (sizeof(*(r))) { \
+			case sizeof(uint8):	__osl_v = \
+				readb((volatile uint8*)((uintptr)(r)^3)); break; \
+			case sizeof(uint16):	__osl_v = \
+				readw((volatile uint16*)((uintptr)(r)^2)); break; \
+			case sizeof(uint32):	__osl_v = \
+				readl((volatile uint32*)(r)); break; \
+			} \
+			__osl_v; \
+		}), \
+		OSL_READ_REG(osh, r)) \
+)
+#define W_REG(osh, r, v) do { \
+	SELECT_BUS_WRITE(osh,  \
+		switch (sizeof(*(r))) { \
+		case sizeof(uint8):	\
+			writeb((uint8)(v), \
+			(volatile uint8*)((uintptr)(r)^3)); break; \
+		case sizeof(uint16):	\
+			writew((uint16)(v), \
+			(volatile uint16*)((uintptr)(r)^2)); break; \
+		case sizeof(uint32):	\
+			writel((uint32)(v), \
+			(volatile uint32*)(r)); break; \
+		}, \
+		(OSL_WRITE_REG(osh, r, v))); \
+	} while (0)
+#endif				/* IL_BIGENDIAN */
+
+#endif				/* OSLREGOPS */
+
+#define	AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#define	OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
+
+/* bcopy, bcmp, and bzero functions */
+#define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
+#define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
+#define	bzero(b, len)		memset((b), '\0', (len))
+
+/* uncached/cached virtual address */
+#ifdef __mips__
+#include <asm/addrspace.h>
+#define OSL_UNCACHED(va)	((void *)KSEG1ADDR((va)))
+#define OSL_CACHED(va)		((void *)KSEG0ADDR((va)))
+#else
+#define OSL_UNCACHED(va)	((void *)va)
+#define OSL_CACHED(va)		((void *)va)
+#endif				/* mips */
+
+#if defined(mips)
+#define	OSL_GETCYCLES(x)	((x) = read_c0_count() * 2)
+#elif defined(__i386__)
+#define	OSL_GETCYCLES(x)	rdtscl((x))
+#else
+#define OSL_GETCYCLES(x)	((x) = 0)
+#endif				/* defined(mips) */
+
+/* dereference an address that may cause a bus exception */
+#ifdef mips
+#define	BUSPROBE(val, addr)	get_dbe((val), (addr))
+#include <asm/paccess.h>
+#else
+#define	BUSPROBE(val, addr)	({ (val) = R_REG(NULL, (addr)); 0; })
+#endif				/* mips */
+
+/* map/unmap physical to virtual I/O */
+#if !defined(CONFIG_MMC_MSM7X00A)
+#define	REG_MAP(pa, size)	ioremap_nocache((unsigned long)(pa), (unsigned long)(size))
+#else
+#define REG_MAP(pa, size)       (void *)(0)
+#endif				/* !defined(CONFIG_MMC_MSM7X00A */
+#define	REG_UNMAP(va)		iounmap((va))
+
+#define	R_SM(r)			*(r)
+#define	W_SM(r, v)		(*(r) = (v))
+#define	BZERO_SM(r, len)	memset((r), '\0', (len))
+
+#include <linuxver.h>		/* use current 2.4.x calling conventions */
+
+/* packet primitives */
+#define	PKTGET(osh, len, send)		osl_pktget((osh), (len))
+#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
+#define	PKTFREE(osh, skb, send)		osl_pktfree((osh), (skb), (send))
+#define	PKTDATA(skb)			(((struct sk_buff*)(skb))->data)
+#define	PKTLEN(skb)			(((struct sk_buff*)(skb))->len)
+#define PKTHEADROOM(skb)		(PKTDATA(skb)-(((struct sk_buff*)(skb))->head))
+#define PKTTAILROOM(skb) ((((struct sk_buff*)(skb))->end)-(((struct sk_buff*)(skb))->tail))
+#define	PKTNEXT(skb)			(((struct sk_buff*)(skb))->next)
+#define	PKTSETNEXT(skb, x)		(((struct sk_buff*)(skb))->next = (struct sk_buff*)(x))
+#define	PKTSETLEN(skb, len)		__skb_trim((struct sk_buff*)(skb), (len))
+#define	PKTPUSH(skb, bytes)		skb_push((struct sk_buff*)(skb), (bytes))
+#define	PKTPULL(skb, bytes)		skb_pull((struct sk_buff*)(skb), (bytes))
+#define	PKTTAG(skb)			((void*)(((struct sk_buff*)(skb))->cb))
+#define PKTALLOCED(osh)			((osl_pubinfo_t *)(osh))->pktalloced
+#define PKTSETPOOL(osh, skb, x, y)	do {} while (0)
+#define PKTPOOL(osh, skb)		FALSE
+
+#define PKTUNALLOC(osh)			((osl_pubinfo_t *)(osh))->pktalloced--
+
+#define	PKTSETSKIPCT(osh, skb)
+#define	PKTCLRSKIPCT(osh, skb)
+#define	PKTSKIPCT(osh, skb)
+
+extern void osl_pktfree(osl_t * osh, void *skb, bool send);
+
+extern void *osl_pktget(osl_t * osh, uint len);
+extern void *osl_pktdup(osl_t * osh, void *skb);
+
+#define	PKTLINK(skb)			(((struct sk_buff*)(skb))->prev)
+#define	PKTSETLINK(skb, x)		(((struct sk_buff*)(skb))->prev = (struct sk_buff*)(x))
+#define	PKTPRIO(skb)			(((struct sk_buff*)(skb))->priority)
+#define	PKTSETPRIO(skb, x)		(((struct sk_buff*)(skb))->priority = (x))
+#define PKTSUMNEEDED(skb)		(((struct sk_buff*)(skb))->ip_summed == CHECKSUM_HW)
+#define PKTSETSUMGOOD(skb, x)		(((struct sk_buff*)(skb))->ip_summed = \
+						((x) ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE))
+/* PKTSETSUMNEEDED and PKTSUMGOOD are not possible because skb->ip_summed is overloaded */
+#define PKTSHARED(skb)                  (((struct sk_buff*)(skb))->cloned)
+
+#ifdef BCMSDIO
+#define RPC_READ_REG(osh, r) (\
+	sizeof(*(r)) == sizeof(uint8) ? osl_readb((osh), (volatile uint8*)(r)) : \
+	sizeof(*(r)) == sizeof(uint16) ? osl_readw((osh), (volatile uint16*)(r)) : \
+	osl_readl((osh), (volatile uint32*)(r)) \
+)
+#define RPC_WRITE_REG(osh, r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	osl_writeb((osh), (volatile uint8*)(r), (uint8)(v)); break; \
+	case sizeof(uint16):	osl_writew((osh), (volatile uint16*)(r), (uint16)(v)); break; \
+	case sizeof(uint32):	osl_writel((osh), (volatile uint32*)(r), (uint32)(v)); break; \
+	} \
+} while (0)
+
+extern uint8 osl_readb(osl_t * osh, volatile uint8 * r);
+extern uint16 osl_readw(osl_t * osh, volatile uint16 * r);
+extern uint32 osl_readl(osl_t * osh, volatile uint32 * r);
+extern void osl_writeb(osl_t * osh, volatile uint8 * r, uint8 v);
+extern void osl_writew(osl_t * osh, volatile uint16 * r, uint16 v);
+extern void osl_writel(osl_t * osh, volatile uint32 * r, uint32 v);
+#endif				/* BCMSDIO */
+
+#endif				/* _linux_osl_h_ */
diff --git a/drivers/staging/brcm80211/include/linuxver.h b/drivers/staging/brcm80211/include/linuxver.h
new file mode 100644
index 0000000..740c3fa
--- /dev/null
+++ b/drivers/staging/brcm80211/include/linuxver.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _linuxver_h_
+#define _linuxver_h_
+
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/slab.h>
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#undef IP_TOS
+#include <asm/io.h>
+
+#include <linux/workqueue.h>
+
+#define	MY_INIT_WORK(_work, _func)	INIT_WORK(_work, _func)
+
+typedef irqreturn_t(*FN_ISR) (int irq, void *dev_id, struct pt_regs * ptregs);
+
+#include <linux/sched.h>
+#include <linux/ieee80211.h>
+
+#ifndef __exit
+#define __exit
+#endif
+#ifndef __devexit
+#define __devexit
+#endif
+#ifndef __devinit
+#define __devinit	__init
+#endif
+#ifndef __devinitdata
+#define __devinitdata
+#endif
+#ifndef __devexit_p
+#define __devexit_p(x)	x
+#endif
+
+#define pci_module_init pci_register_driver
+
+#define netif_down(dev)
+
+/* Power management related macro & routines */
+#define	PCI_SAVE_STATE(a, b)	pci_save_state(a)
+#define	PCI_RESTORE_STATE(a, b)	pci_restore_state(a)
+
+/* Module refcount handled internally in 2.6.x */
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev)		do {} while (0)
+#endif
+#ifndef MOD_INC_USE_COUNT
+#define MOD_INC_USE_COUNT			do {} while (0)
+#endif
+#ifndef MOD_DEC_USE_COUNT
+#define MOD_DEC_USE_COUNT			do {} while (0)
+#endif
+#define OLD_MOD_INC_USE_COUNT		MOD_INC_USE_COUNT
+#define OLD_MOD_DEC_USE_COUNT		MOD_DEC_USE_COUNT
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)	do {} while (0)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(dev)		kfree(dev)
+#endif
+
+/* suspend args */
+#define DRV_SUSPEND_STATE_TYPE pm_message_t
+
+#define CHECKSUM_HW	CHECKSUM_PARTIAL
+
+#include <linux/time.h>
+#include <linux/wait.h>
+
+#define KILL_PROC(nr, sig) \
+	do { \
+		struct task_struct *tsk; \
+		struct pid *pid;    \
+		pid = find_get_pid((pid_t)nr);    \
+		tsk = pid_task(pid, PIDTYPE_PID);    \
+		if (tsk) send_sig(sig, tsk, 1); \
+	} while (0)
+
+#define WL_DEV_IF(dev)          ((wl_if_t*)netdev_priv(dev))
+
+#endif				/* _linuxver_h_ */
diff --git a/drivers/staging/brcm80211/include/nicpci.h b/drivers/staging/brcm80211/include/nicpci.h
new file mode 100644
index 0000000..1623c57
--- /dev/null
+++ b/drivers/staging/brcm80211/include/nicpci.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_NICPCI_H
+#define	_NICPCI_H
+
+#if defined(BCMSDIO) || (defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS))
+#define pcicore_find_pci_capability(a, b, c, d) (0)
+#define pcie_readreg(a, b, c, d) (0)
+#define pcie_writereg(a, b, c, d, e) (0)
+
+#define pcie_clkreq(a, b, c)	(0)
+#define pcie_lcreg(a, b, c)	(0)
+
+#define pcicore_init(a, b, c) (0x0dadbeef)
+#define pcicore_deinit(a)	do { } while (0)
+#define pcicore_attach(a, b, c)	do { } while (0)
+#define pcicore_hwup(a)		do { } while (0)
+#define pcicore_up(a, b)	do { } while (0)
+#define pcicore_sleep(a)	do { } while (0)
+#define pcicore_down(a, b)	do { } while (0)
+
+#define pcie_war_ovr_aspm_update(a, b)	do { } while (0)
+
+#define pcicore_pcieserdesreg(a, b, c, d, e) (0)
+#define pcicore_pciereg(a, b, c, d, e) (0)
+
+#define pcicore_pmecap_fast(a)	(FALSE)
+#define pcicore_pmeen(a)	do { } while (0)
+#define pcicore_pmeclr(a)	do { } while (0)
+#define pcicore_pmestat(a)	(FALSE)
+#else
+struct sbpcieregs;
+
+extern uint8 pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id,
+					 uchar * buf, uint32 * buflen);
+extern uint pcie_readreg(osl_t * osh, struct sbpcieregs *pcieregs,
+			 uint addrtype, uint offset);
+extern uint pcie_writereg(osl_t * osh, struct sbpcieregs *pcieregs,
+			  uint addrtype, uint offset, uint val);
+
+extern uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val);
+extern uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val);
+
+extern void *pcicore_init(si_t * sih, osl_t * osh, void *regs);
+extern void pcicore_deinit(void *pch);
+extern void pcicore_attach(void *pch, char *pvars, int state);
+extern void pcicore_hwup(void *pch);
+extern void pcicore_up(void *pch, int state);
+extern void pcicore_sleep(void *pch);
+extern void pcicore_down(void *pch, int state);
+
+extern void pcie_war_ovr_aspm_update(void *pch, uint8 aspm);
+extern uint32 pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset,
+				    uint32 mask, uint32 val);
+
+extern uint32 pcicore_pciereg(void *pch, uint32 offset, uint32 mask,
+			      uint32 val, uint type);
+
+extern bool pcicore_pmecap_fast(osl_t * osh);
+extern void pcicore_pmeen(void *pch);
+extern void pcicore_pmeclr(void *pch);
+extern bool pcicore_pmestat(void *pch);
+#endif				/* defined(BCMSDIO) || (defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS)) */
+
+#endif				/* _NICPCI_H */
diff --git a/drivers/staging/brcm80211/include/osl.h b/drivers/staging/brcm80211/include/osl.h
new file mode 100644
index 0000000..cd09f3c
--- /dev/null
+++ b/drivers/staging/brcm80211/include/osl.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _osl_h_
+#define _osl_h_
+
+/* osl handle type forward declaration */
+typedef struct osl_info osl_t;
+typedef struct osl_dmainfo osldma_t;
+
+#define OSL_PKTTAG_SZ	32	/* Size of PktTag */
+
+/* Drivers use PKTFREESETCB to register a callback function when a packet is freed by OSL */
+typedef void (*pktfree_cb_fn_t) (void *ctx, void *pkt, unsigned int status);
+
+#ifdef BCMSDIO
+/* Drivers use REGOPSSET() to register register read/write funcitons */
+typedef unsigned int (*osl_rreg_fn_t) (void *ctx, void *reg, unsigned int size);
+typedef void (*osl_wreg_fn_t) (void *ctx, void *reg, unsigned int val,
+			       unsigned int size);
+#endif
+
+#include <linux_osl.h>
+
+/* --------------------------------------------------------------------------
+** Register manipulation macros.
+*/
+
+#define	SET_REG(osh, r, mask, val)	W_REG((osh), (r), ((R_REG((osh), r) & ~(mask)) | (val)))
+
+#ifndef AND_REG
+#define AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#endif				/* !AND_REG */
+
+#ifndef OR_REG
+#define OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
+#endif				/* !OR_REG */
+
+#if !defined(OSL_SYSUPTIME)
+#define OSL_SYSUPTIME() (0)
+#define OSL_SYSUPTIME_SUPPORT FALSE
+#else
+#define OSL_SYSUPTIME_SUPPORT TRUE
+#endif				/* OSL_SYSUPTIME */
+
+#endif				/* _osl_h_ */
diff --git a/drivers/staging/brcm80211/include/packed_section_end.h b/drivers/staging/brcm80211/include/packed_section_end.h
new file mode 100644
index 0000000..04c7d43
--- /dev/null
+++ b/drivers/staging/brcm80211/include/packed_section_end.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* Error check - BWL_PACKED_SECTION is defined in packed_section_start.h
+ * and undefined in packed_section_end.h. If it is NOT defined at this
+ * point, then there is a missing include of packed_section_start.h.
+ */
+#ifdef BWL_PACKED_SECTION
+#undef BWL_PACKED_SECTION
+#else
+#error "BWL_PACKED_SECTION is NOT defined!"
+#endif
+
+/* Compiler-specific directives for structure packing are declared in
+ * packed_section_start.h. This marks the end of the structure packing section,
+ * so, undef them here.
+ */
+#undef	BWL_PRE_PACKED_STRUCT
+#undef	BWL_POST_PACKED_STRUCT
diff --git a/drivers/staging/brcm80211/include/packed_section_start.h b/drivers/staging/brcm80211/include/packed_section_start.h
new file mode 100644
index 0000000..60e862a
--- /dev/null
+++ b/drivers/staging/brcm80211/include/packed_section_start.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* Error check - BWL_PACKED_SECTION is defined in packed_section_start.h
+ * and undefined in packed_section_end.h. If it is already defined at this
+ * point, then there is a missing include of packed_section_end.h.
+ */
+#ifdef BWL_PACKED_SECTION
+#error "BWL_PACKED_SECTION is already defined!"
+#else
+#define BWL_PACKED_SECTION
+#endif
+
+/* Declare compiler-specific directives for structure packing. */
+#if defined(__GNUC__)
+#define	BWL_PRE_PACKED_STRUCT
+#define	BWL_POST_PACKED_STRUCT	__attribute__((packed))
+#elif defined(__CC_ARM)
+#define	BWL_PRE_PACKED_STRUCT	__packed
+#define	BWL_POST_PACKED_STRUCT
+#else
+#error "Unknown compiler!"
+#endif
diff --git a/drivers/staging/brcm80211/include/pci_core.h b/drivers/staging/brcm80211/include/pci_core.h
new file mode 100644
index 0000000..d0fe4c3
--- /dev/null
+++ b/drivers/staging/brcm80211/include/pci_core.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_PCI_CORE_H_
+#define	_PCI_CORE_H_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/* Sonics side: PCI core and host control registers */
+typedef struct sbpciregs {
+	uint32 control;		/* PCI control */
+	uint32 PAD[3];
+	uint32 arbcontrol;	/* PCI arbiter control */
+	uint32 clkrun;		/* Clkrun Control (>=rev11) */
+	uint32 PAD[2];
+	uint32 intstatus;	/* Interrupt status */
+	uint32 intmask;		/* Interrupt mask */
+	uint32 sbtopcimailbox;	/* Sonics to PCI mailbox */
+	uint32 PAD[9];
+	uint32 bcastaddr;	/* Sonics broadcast address */
+	uint32 bcastdata;	/* Sonics broadcast data */
+	uint32 PAD[2];
+	uint32 gpioin;		/* ro: gpio input (>=rev2) */
+	uint32 gpioout;		/* rw: gpio output (>=rev2) */
+	uint32 gpioouten;	/* rw: gpio output enable (>= rev2) */
+	uint32 gpiocontrol;	/* rw: gpio control (>= rev2) */
+	uint32 PAD[36];
+	uint32 sbtopci0;	/* Sonics to PCI translation 0 */
+	uint32 sbtopci1;	/* Sonics to PCI translation 1 */
+	uint32 sbtopci2;	/* Sonics to PCI translation 2 */
+	uint32 PAD[189];
+	uint32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
+	uint16 sprom[36];	/* SPROM shadow Area */
+	uint32 PAD[46];
+} sbpciregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* PCI control */
+#define PCI_RST_OE	0x01	/* When set, drives PCI_RESET out to pin */
+#define PCI_RST		0x02	/* Value driven out to pin */
+#define PCI_CLK_OE	0x04	/* When set, drives clock as gated by PCI_CLK out to pin */
+#define PCI_CLK		0x08	/* Gate for clock driven out to pin */
+
+/* PCI arbiter control */
+#define PCI_INT_ARB	0x01	/* When set, use an internal arbiter */
+#define PCI_EXT_ARB	0x02	/* When set, use an external arbiter */
+/* ParkID - for PCI corerev >= 8 */
+#define PCI_PARKID_MASK		0x1c	/* Selects which agent is parked on an idle bus */
+#define PCI_PARKID_SHIFT	2
+#define PCI_PARKID_EXT0		0	/* External master 0 */
+#define PCI_PARKID_EXT1		1	/* External master 1 */
+#define PCI_PARKID_EXT2		2	/* External master 2 */
+#define PCI_PARKID_EXT3		3	/* External master 3 (rev >= 11) */
+#define PCI_PARKID_INT		3	/* Internal master (rev < 11) */
+#define PCI11_PARKID_INT	4	/* Internal master (rev >= 11) */
+#define PCI_PARKID_LAST		4	/* Last active master (rev < 11) */
+#define PCI11_PARKID_LAST	5	/* Last active master (rev >= 11) */
+
+#define PCI_CLKRUN_DSBL	0x8000	/* Bit 15 forceClkrun */
+
+/* Interrupt status/mask */
+#define PCI_INTA	0x01	/* PCI INTA# is asserted */
+#define PCI_INTB	0x02	/* PCI INTB# is asserted */
+#define PCI_SERR	0x04	/* PCI SERR# has been asserted (write one to clear) */
+#define PCI_PERR	0x08	/* PCI PERR# has been asserted (write one to clear) */
+#define PCI_PME		0x10	/* PCI PME# is asserted */
+
+/* (General) PCI/SB mailbox interrupts, two bits per pci function */
+#define	MAILBOX_F0_0	0x100	/* function 0, int 0 */
+#define	MAILBOX_F0_1	0x200	/* function 0, int 1 */
+#define	MAILBOX_F1_0	0x400	/* function 1, int 0 */
+#define	MAILBOX_F1_1	0x800	/* function 1, int 1 */
+#define	MAILBOX_F2_0	0x1000	/* function 2, int 0 */
+#define	MAILBOX_F2_1	0x2000	/* function 2, int 1 */
+#define	MAILBOX_F3_0	0x4000	/* function 3, int 0 */
+#define	MAILBOX_F3_1	0x8000	/* function 3, int 1 */
+
+/* Sonics broadcast address */
+#define BCAST_ADDR_MASK	0xff	/* Broadcast register address */
+
+/* Sonics to PCI translation types */
+#define SBTOPCI0_MASK	0xfc000000
+#define SBTOPCI1_MASK	0xfc000000
+#define SBTOPCI2_MASK	0xc0000000
+#define SBTOPCI_MEM	0
+#define SBTOPCI_IO	1
+#define SBTOPCI_CFG0	2
+#define SBTOPCI_CFG1	3
+#define	SBTOPCI_PREF	0x4	/* prefetch enable */
+#define	SBTOPCI_BURST	0x8	/* burst enable */
+#define	SBTOPCI_RC_MASK		0x30	/* read command (>= rev11) */
+#define	SBTOPCI_RC_READ		0x00	/* memory read */
+#define	SBTOPCI_RC_READLINE	0x10	/* memory read line */
+#define	SBTOPCI_RC_READMULTI	0x20	/* memory read multiple */
+
+/* PCI core index in SROM shadow area */
+#define SRSH_PI_OFFSET	0	/* first word */
+#define SRSH_PI_MASK	0xf000	/* bit 15:12 */
+#define SRSH_PI_SHIFT	12	/* bit 15:12 */
+
+#endif				/* _PCI_CORE_H_ */
diff --git a/drivers/staging/brcm80211/include/pcicfg.h b/drivers/staging/brcm80211/include/pcicfg.h
new file mode 100644
index 0000000..caddca5
--- /dev/null
+++ b/drivers/staging/brcm80211/include/pcicfg.h
@@ -0,0 +1,524 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_h_pcicfg_
+#define	_h_pcicfg_
+
+/* The following inside ifndef's so we don't collide with NTDDK.H */
+#ifndef PCI_MAX_BUS
+#define PCI_MAX_BUS		0x100
+#endif
+#ifndef PCI_MAX_DEVICES
+#define PCI_MAX_DEVICES		0x20
+#endif
+#ifndef PCI_MAX_FUNCTION
+#define PCI_MAX_FUNCTION	0x8
+#endif
+
+#ifndef PCI_INVALID_VENDORID
+#define PCI_INVALID_VENDORID	0xffff
+#endif
+#ifndef PCI_INVALID_DEVICEID
+#define PCI_INVALID_DEVICEID	0xffff
+#endif
+
+/* Convert between bus-slot-function-register and config addresses */
+
+#define	PCICFG_BUS_SHIFT	16	/* Bus shift */
+#define	PCICFG_SLOT_SHIFT	11	/* Slot shift */
+#define	PCICFG_FUN_SHIFT	8	/* Function shift */
+#define	PCICFG_OFF_SHIFT	0	/* Register shift */
+
+#define	PCICFG_BUS_MASK		0xff	/* Bus mask */
+#define	PCICFG_SLOT_MASK	0x1f	/* Slot mask */
+#define	PCICFG_FUN_MASK		7	/* Function mask */
+#define	PCICFG_OFF_MASK		0xff	/* Bus mask */
+
+#define	PCI_CONFIG_ADDR(b, s, f, o)					\
+		((((b) & PCICFG_BUS_MASK) << PCICFG_BUS_SHIFT)		\
+		 | (((s) & PCICFG_SLOT_MASK) << PCICFG_SLOT_SHIFT)	\
+		 | (((f) & PCICFG_FUN_MASK) << PCICFG_FUN_SHIFT)	\
+		 | (((o) & PCICFG_OFF_MASK) << PCICFG_OFF_SHIFT))
+
+#define	PCI_CONFIG_BUS(a)	(((a) >> PCICFG_BUS_SHIFT) & PCICFG_BUS_MASK)
+#define	PCI_CONFIG_SLOT(a)	(((a) >> PCICFG_SLOT_SHIFT) & PCICFG_SLOT_MASK)
+#define	PCI_CONFIG_FUN(a)	(((a) >> PCICFG_FUN_SHIFT) & PCICFG_FUN_MASK)
+#define	PCI_CONFIG_OFF(a)	(((a) >> PCICFG_OFF_SHIFT) & PCICFG_OFF_MASK)
+
+/* PCIE Config space accessing MACROS */
+
+#define	PCIECFG_BUS_SHIFT	24	/* Bus shift */
+#define	PCIECFG_SLOT_SHIFT	19	/* Slot/Device shift */
+#define	PCIECFG_FUN_SHIFT	16	/* Function shift */
+#define	PCIECFG_OFF_SHIFT	0	/* Register shift */
+
+#define	PCIECFG_BUS_MASK	0xff	/* Bus mask */
+#define	PCIECFG_SLOT_MASK	0x1f	/* Slot/Device mask */
+#define	PCIECFG_FUN_MASK	7	/* Function mask */
+#define	PCIECFG_OFF_MASK	0xfff	/* Register mask */
+
+#define	PCIE_CONFIG_ADDR(b, s, f, o)					\
+		((((b) & PCIECFG_BUS_MASK) << PCIECFG_BUS_SHIFT)		\
+		 | (((s) & PCIECFG_SLOT_MASK) << PCIECFG_SLOT_SHIFT)	\
+		 | (((f) & PCIECFG_FUN_MASK) << PCIECFG_FUN_SHIFT)	\
+		 | (((o) & PCIECFG_OFF_MASK) << PCIECFG_OFF_SHIFT))
+
+#define	PCIE_CONFIG_BUS(a)	(((a) >> PCIECFG_BUS_SHIFT) & PCIECFG_BUS_MASK)
+#define	PCIE_CONFIG_SLOT(a)	(((a) >> PCIECFG_SLOT_SHIFT) & PCIECFG_SLOT_MASK)
+#define	PCIE_CONFIG_FUN(a)	(((a) >> PCIECFG_FUN_SHIFT) & PCIECFG_FUN_MASK)
+#define	PCIE_CONFIG_OFF(a)	(((a) >> PCIECFG_OFF_SHIFT) & PCIECFG_OFF_MASK)
+
+/* The actual config space */
+
+#define	PCI_BAR_MAX		6
+
+#define	PCI_ROM_BAR		8
+
+#define	PCR_RSVDA_MAX		2
+
+/* Bits in PCI bars' flags */
+
+#define	PCIBAR_FLAGS		0xf
+#define	PCIBAR_IO		0x1
+#define	PCIBAR_MEM1M		0x2
+#define	PCIBAR_MEM64		0x4
+#define	PCIBAR_PREFETCH		0x8
+#define	PCIBAR_MEM32_MASK	0xFFFFFF80
+
+/* pci config status reg has a bit to indicate that capability ptr is present */
+
+#define PCI_CAPPTR_PRESENT	0x0010
+
+typedef struct _pci_config_regs {
+	uint16 vendor;
+	uint16 device;
+	uint16 command;
+	uint16 status;
+	uint8 rev_id;
+	uint8 prog_if;
+	uint8 sub_class;
+	uint8 base_class;
+	uint8 cache_line_size;
+	uint8 latency_timer;
+	uint8 header_type;
+	uint8 bist;
+	uint32 base[PCI_BAR_MAX];
+	uint32 cardbus_cis;
+	uint16 subsys_vendor;
+	uint16 subsys_id;
+	uint32 baserom;
+	uint32 rsvd_a[PCR_RSVDA_MAX];
+	uint8 int_line;
+	uint8 int_pin;
+	uint8 min_gnt;
+	uint8 max_lat;
+	uint8 dev_dep[192];
+} pci_config_regs;
+
+#define	SZPCR		(sizeof (pci_config_regs))
+#define	MINSZPCR	64	/* offsetof (dev_dep[0] */
+
+/* A structure for the config registers is nice, but in most
+ * systems the config space is not memory mapped, so we need
+ * field offsetts. :-(
+ */
+#define	PCI_CFG_VID		0
+#define	PCI_CFG_DID		2
+#define	PCI_CFG_CMD		4
+#define	PCI_CFG_STAT		6
+#define	PCI_CFG_REV		8
+#define	PCI_CFG_PROGIF		9
+#define	PCI_CFG_SUBCL		0xa
+#define	PCI_CFG_BASECL		0xb
+#define	PCI_CFG_CLSZ		0xc
+#define	PCI_CFG_LATTIM		0xd
+#define	PCI_CFG_HDR		0xe
+#define	PCI_CFG_BIST		0xf
+#define	PCI_CFG_BAR0		0x10
+#define	PCI_CFG_BAR1		0x14
+#define	PCI_CFG_BAR2		0x18
+#define	PCI_CFG_BAR3		0x1c
+#define	PCI_CFG_BAR4		0x20
+#define	PCI_CFG_BAR5		0x24
+#define	PCI_CFG_CIS		0x28
+#define	PCI_CFG_SVID		0x2c
+#define	PCI_CFG_SSID		0x2e
+#define	PCI_CFG_ROMBAR		0x30
+#define PCI_CFG_CAPPTR		0x34
+#define	PCI_CFG_INT		0x3c
+#define	PCI_CFG_PIN		0x3d
+#define	PCI_CFG_MINGNT		0x3e
+#define	PCI_CFG_MAXLAT		0x3f
+
+/* Classes and subclasses */
+
+typedef enum {
+	PCI_CLASS_OLD = 0,
+	PCI_CLASS_DASDI,
+	PCI_CLASS_NET,
+	PCI_CLASS_DISPLAY,
+	PCI_CLASS_MMEDIA,
+	PCI_CLASS_MEMORY,
+	PCI_CLASS_BRIDGE,
+	PCI_CLASS_COMM,
+	PCI_CLASS_BASE,
+	PCI_CLASS_INPUT,
+	PCI_CLASS_DOCK,
+	PCI_CLASS_CPU,
+	PCI_CLASS_SERIAL,
+	PCI_CLASS_INTELLIGENT = 0xe,
+	PCI_CLASS_SATELLITE,
+	PCI_CLASS_CRYPT,
+	PCI_CLASS_DSP,
+	PCI_CLASS_XOR = 0xfe
+} pci_classes;
+
+typedef enum {
+	PCI_DASDI_SCSI,
+	PCI_DASDI_IDE,
+	PCI_DASDI_FLOPPY,
+	PCI_DASDI_IPI,
+	PCI_DASDI_RAID,
+	PCI_DASDI_OTHER = 0x80
+} pci_dasdi_subclasses;
+
+typedef enum {
+	PCI_NET_ETHER,
+	PCI_NET_TOKEN,
+	PCI_NET_FDDI,
+	PCI_NET_ATM,
+	PCI_NET_OTHER = 0x80
+} pci_net_subclasses;
+
+typedef enum {
+	PCI_DISPLAY_VGA,
+	PCI_DISPLAY_XGA,
+	PCI_DISPLAY_3D,
+	PCI_DISPLAY_OTHER = 0x80
+} pci_display_subclasses;
+
+typedef enum {
+	PCI_MMEDIA_VIDEO,
+	PCI_MMEDIA_AUDIO,
+	PCI_MMEDIA_PHONE,
+	PCI_MEDIA_OTHER = 0x80
+} pci_mmedia_subclasses;
+
+typedef enum {
+	PCI_MEMORY_RAM,
+	PCI_MEMORY_FLASH,
+	PCI_MEMORY_OTHER = 0x80
+} pci_memory_subclasses;
+
+typedef enum {
+	PCI_BRIDGE_HOST,
+	PCI_BRIDGE_ISA,
+	PCI_BRIDGE_EISA,
+	PCI_BRIDGE_MC,
+	PCI_BRIDGE_PCI,
+	PCI_BRIDGE_PCMCIA,
+	PCI_BRIDGE_NUBUS,
+	PCI_BRIDGE_CARDBUS,
+	PCI_BRIDGE_RACEWAY,
+	PCI_BRIDGE_OTHER = 0x80
+} pci_bridge_subclasses;
+
+typedef enum {
+	PCI_COMM_UART,
+	PCI_COMM_PARALLEL,
+	PCI_COMM_MULTIUART,
+	PCI_COMM_MODEM,
+	PCI_COMM_OTHER = 0x80
+} pci_comm_subclasses;
+
+typedef enum {
+	PCI_BASE_PIC,
+	PCI_BASE_DMA,
+	PCI_BASE_TIMER,
+	PCI_BASE_RTC,
+	PCI_BASE_PCI_HOTPLUG,
+	PCI_BASE_OTHER = 0x80
+} pci_base_subclasses;
+
+typedef enum {
+	PCI_INPUT_KBD,
+	PCI_INPUT_PEN,
+	PCI_INPUT_MOUSE,
+	PCI_INPUT_SCANNER,
+	PCI_INPUT_GAMEPORT,
+	PCI_INPUT_OTHER = 0x80
+} pci_input_subclasses;
+
+typedef enum {
+	PCI_DOCK_GENERIC,
+	PCI_DOCK_OTHER = 0x80
+} pci_dock_subclasses;
+
+typedef enum {
+	PCI_CPU_386,
+	PCI_CPU_486,
+	PCI_CPU_PENTIUM,
+	PCI_CPU_ALPHA = 0x10,
+	PCI_CPU_POWERPC = 0x20,
+	PCI_CPU_MIPS = 0x30,
+	PCI_CPU_COPROC = 0x40,
+	PCI_CPU_OTHER = 0x80
+} pci_cpu_subclasses;
+
+typedef enum {
+	PCI_SERIAL_IEEE1394,
+	PCI_SERIAL_ACCESS,
+	PCI_SERIAL_SSA,
+	PCI_SERIAL_USB,
+	PCI_SERIAL_FIBER,
+	PCI_SERIAL_SMBUS,
+	PCI_SERIAL_OTHER = 0x80
+} pci_serial_subclasses;
+
+typedef enum {
+	PCI_INTELLIGENT_I2O
+} pci_intelligent_subclasses;
+
+typedef enum {
+	PCI_SATELLITE_TV,
+	PCI_SATELLITE_AUDIO,
+	PCI_SATELLITE_VOICE,
+	PCI_SATELLITE_DATA,
+	PCI_SATELLITE_OTHER = 0x80
+} pci_satellite_subclasses;
+
+typedef enum {
+	PCI_CRYPT_NETWORK,
+	PCI_CRYPT_ENTERTAINMENT,
+	PCI_CRYPT_OTHER = 0x80
+} pci_crypt_subclasses;
+
+typedef enum {
+	PCI_DSP_DPIO,
+	PCI_DSP_OTHER = 0x80
+} pci_dsp_subclasses;
+
+typedef enum {
+	PCI_XOR_QDMA,
+	PCI_XOR_OTHER = 0x80
+} pci_xor_subclasses;
+
+/* Header types */
+#define	PCI_HEADER_MULTI	0x80
+#define	PCI_HEADER_MASK		0x7f
+typedef enum {
+	PCI_HEADER_NORMAL,
+	PCI_HEADER_BRIDGE,
+	PCI_HEADER_CARDBUS
+} pci_header_types;
+
+/* Overlay for a PCI-to-PCI bridge */
+
+#define	PPB_RSVDA_MAX		2
+#define	PPB_RSVDD_MAX		8
+
+typedef struct _ppb_config_regs {
+	uint16 vendor;
+	uint16 device;
+	uint16 command;
+	uint16 status;
+	uint8 rev_id;
+	uint8 prog_if;
+	uint8 sub_class;
+	uint8 base_class;
+	uint8 cache_line_size;
+	uint8 latency_timer;
+	uint8 header_type;
+	uint8 bist;
+	uint32 rsvd_a[PPB_RSVDA_MAX];
+	uint8 prim_bus;
+	uint8 sec_bus;
+	uint8 sub_bus;
+	uint8 sec_lat;
+	uint8 io_base;
+	uint8 io_lim;
+	uint16 sec_status;
+	uint16 mem_base;
+	uint16 mem_lim;
+	uint16 pf_mem_base;
+	uint16 pf_mem_lim;
+	uint32 pf_mem_base_hi;
+	uint32 pf_mem_lim_hi;
+	uint16 io_base_hi;
+	uint16 io_lim_hi;
+	uint16 subsys_vendor;
+	uint16 subsys_id;
+	uint32 rsvd_b;
+	uint8 rsvd_c;
+	uint8 int_pin;
+	uint16 bridge_ctrl;
+	uint8 chip_ctrl;
+	uint8 diag_ctrl;
+	uint16 arb_ctrl;
+	uint32 rsvd_d[PPB_RSVDD_MAX];
+	uint8 dev_dep[192];
+} ppb_config_regs;
+
+/* PCI CAPABILITY DEFINES */
+#define PCI_CAP_POWERMGMTCAP_ID		0x01
+#define PCI_CAP_MSICAP_ID		0x05
+#define PCI_CAP_VENDSPEC_ID		0x09
+#define PCI_CAP_PCIECAP_ID		0x10
+
+/* Data structure to define the Message Signalled Interrupt facility
+ * Valid for PCI and PCIE configurations
+ */
+typedef struct _pciconfig_cap_msi {
+	uint8 capID;
+	uint8 nextptr;
+	uint16 msgctrl;
+	uint32 msgaddr;
+} pciconfig_cap_msi;
+
+/* Data structure to define the Power managment facility
+ * Valid for PCI and PCIE configurations
+ */
+typedef struct _pciconfig_cap_pwrmgmt {
+	uint8 capID;
+	uint8 nextptr;
+	uint16 pme_cap;
+	uint16 pme_sts_ctrl;
+	uint8 pme_bridge_ext;
+	uint8 data;
+} pciconfig_cap_pwrmgmt;
+
+#define PME_CAP_PM_STATES (0x1f << 27)	/* Bits 31:27 states that can generate PME */
+#define PME_CSR_OFFSET	    0x4	/* 4-bytes offset */
+#define PME_CSR_PME_EN	  (1 << 8)	/* Bit 8 Enable generating of PME */
+#define PME_CSR_PME_STAT  (1 << 15)	/* Bit 15 PME got asserted */
+
+/* Data structure to define the PCIE capability */
+typedef struct _pciconfig_cap_pcie {
+	uint8 capID;
+	uint8 nextptr;
+	uint16 pcie_cap;
+	uint32 dev_cap;
+	uint16 dev_ctrl;
+	uint16 dev_status;
+	uint32 link_cap;
+	uint16 link_ctrl;
+	uint16 link_status;
+	uint32 slot_cap;
+	uint16 slot_ctrl;
+	uint16 slot_status;
+	uint16 root_ctrl;
+	uint16 root_cap;
+	uint32 root_status;
+} pciconfig_cap_pcie;
+
+/* PCIE Enhanced CAPABILITY DEFINES */
+#define PCIE_EXTCFG_OFFSET	0x100
+#define PCIE_ADVERRREP_CAPID	0x0001
+#define PCIE_VC_CAPID		0x0002
+#define PCIE_DEVSNUM_CAPID	0x0003
+#define PCIE_PWRBUDGET_CAPID	0x0004
+
+/* PCIE Extended configuration */
+#define PCIE_ADV_CORR_ERR_MASK	0x114
+#define CORR_ERR_RE	(1 << 0)	/* Receiver  */
+#define CORR_ERR_BT 	(1 << 6)	/* Bad TLP  */
+#define CORR_ERR_BD	(1 << 7)	/* Bad DLLP */
+#define CORR_ERR_RR	(1 << 8)	/* REPLAY_NUM rollover */
+#define CORR_ERR_RT	(1 << 12)	/* Reply timer timeout */
+#define ALL_CORR_ERRORS (CORR_ERR_RE | CORR_ERR_BT | CORR_ERR_BD | \
+			 CORR_ERR_RR | CORR_ERR_RT)
+
+/* PCIE Root Control Register bits (Host mode only) */
+#define	PCIE_RC_CORR_SERR_EN		0x0001
+#define	PCIE_RC_NONFATAL_SERR_EN	0x0002
+#define	PCIE_RC_FATAL_SERR_EN		0x0004
+#define	PCIE_RC_PME_INT_EN		0x0008
+#define	PCIE_RC_CRS_EN			0x0010
+
+/* PCIE Root Capability Register bits (Host mode only) */
+#define	PCIE_RC_CRS_VISIBILITY		0x0001
+
+/* Header to define the PCIE specific capabilities in the extended config space */
+typedef struct _pcie_enhanced_caphdr {
+	uint16 capID;
+	uint16 cap_ver:4;
+	uint16 next_ptr:12;
+} pcie_enhanced_caphdr;
+
+/* Everything below is BRCM HND proprietary */
+
+/* Brcm PCI configuration registers */
+#define cap_list	rsvd_a[0]
+#define bar0_window	dev_dep[0x80 - 0x40]
+#define bar1_window	dev_dep[0x84 - 0x40]
+#define sprom_control	dev_dep[0x88 - 0x40]
+#define	PCI_BAR0_WIN		0x80	/* backplane addres space accessed by BAR0 */
+#define	PCI_BAR1_WIN		0x84	/* backplane addres space accessed by BAR1 */
+#define	PCI_SPROM_CONTROL	0x88	/* sprom property control */
+#define	PCI_BAR1_CONTROL	0x8c	/* BAR1 region burst control */
+#define	PCI_INT_STATUS		0x90	/* PCI and other cores interrupts */
+#define	PCI_INT_MASK		0x94	/* mask of PCI and other cores interrupts */
+#define PCI_TO_SB_MB		0x98	/* signal backplane interrupts */
+#define PCI_BACKPLANE_ADDR	0xa0	/* address an arbitrary location on the system backplane */
+#define PCI_BACKPLANE_DATA	0xa4	/* data at the location specified by above address */
+#define	PCI_CLK_CTL_ST		0xa8	/* pci config space clock control/status (>=rev14) */
+#define	PCI_BAR0_WIN2		0xac	/* backplane addres space accessed by second 4KB of BAR0 */
+#define	PCI_GPIO_IN		0xb0	/* pci config space gpio input (>=rev3) */
+#define	PCI_GPIO_OUT		0xb4	/* pci config space gpio output (>=rev3) */
+#define	PCI_GPIO_OUTEN		0xb8	/* pci config space gpio output enable (>=rev3) */
+
+#define	PCI_BAR0_SHADOW_OFFSET	(2 * 1024)	/* bar0 + 2K accesses sprom shadow (in pci core) */
+#define	PCI_BAR0_SPROM_OFFSET	(4 * 1024)	/* bar0 + 4K accesses external sprom */
+#define	PCI_BAR0_PCIREGS_OFFSET	(6 * 1024)	/* bar0 + 6K accesses pci core registers */
+#define	PCI_BAR0_PCISBR_OFFSET	(4 * 1024)	/* pci core SB registers are at the end of the
+						 * 8KB window, so their address is the "regular"
+						 * address plus 4K
+						 */
+#define PCI_BAR0_WINSZ		(16 * 1024)	/* bar0 window size Match with corerev 13 */
+/* On pci corerev >= 13 and all pcie, the bar0 is now 16KB and it maps: */
+#define	PCI_16KB0_PCIREGS_OFFSET (8 * 1024)	/* bar0 + 8K accesses pci/pcie core registers */
+#define	PCI_16KB0_CCREGS_OFFSET	(12 * 1024)	/* bar0 + 12K accesses chipc core registers */
+#define PCI_16KBB0_WINSZ	(16 * 1024)	/* bar0 window size */
+
+/* On AI chips we have a second window to map DMP regs are mapped: */
+#define	PCI_16KB0_WIN2_OFFSET	(4 * 1024)	/* bar0 + 4K is "Window 2" */
+
+/* PCI_INT_STATUS */
+#define	PCI_SBIM_STATUS_SERR	0x4	/* backplane SBErr interrupt status */
+
+/* PCI_INT_MASK */
+#define	PCI_SBIM_SHIFT		8	/* backplane core interrupt mask bits offset */
+#define	PCI_SBIM_MASK		0xff00	/* backplane core interrupt mask */
+#define	PCI_SBIM_MASK_SERR	0x4	/* backplane SBErr interrupt mask */
+
+/* PCI_SPROM_CONTROL */
+#define SPROM_SZ_MSK		0x02	/* SPROM Size Mask */
+#define SPROM_LOCKED		0x08	/* SPROM Locked */
+#define	SPROM_BLANK		0x04	/* indicating a blank SPROM */
+#define SPROM_WRITEEN		0x10	/* SPROM write enable */
+#define SPROM_BOOTROM_WE	0x20	/* external bootrom write enable */
+#define SPROM_BACKPLANE_EN	0x40	/* Enable indirect backplane access */
+#define SPROM_OTPIN_USE		0x80	/* device OTP In use */
+
+/* Bits in PCI command and status regs */
+#define PCI_CMD_IO		0x00000001	/* I/O enable */
+#define PCI_CMD_MEMORY		0x00000002	/* Memory enable */
+#define PCI_CMD_MASTER		0x00000004	/* Master enable */
+#define PCI_CMD_SPECIAL		0x00000008	/* Special cycles enable */
+#define PCI_CMD_INVALIDATE	0x00000010	/* Invalidate? */
+#define PCI_CMD_VGA_PAL		0x00000040	/* VGA Palate */
+#define PCI_STAT_TA		0x08000000	/* target abort status */
+#endif				/* _h_pcicfg_ */
diff --git a/drivers/staging/brcm80211/include/pcie_core.h b/drivers/staging/brcm80211/include/pcie_core.h
new file mode 100644
index 0000000..0f835c1
--- /dev/null
+++ b/drivers/staging/brcm80211/include/pcie_core.h
@@ -0,0 +1,299 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_PCIE_CORE_H
+#define	_PCIE_CORE_H
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/* PCIE Enumeration space offsets */
+#define  PCIE_CORE_CONFIG_OFFSET	0x0
+#define  PCIE_FUNC0_CONFIG_OFFSET	0x400
+#define  PCIE_FUNC1_CONFIG_OFFSET	0x500
+#define  PCIE_FUNC2_CONFIG_OFFSET	0x600
+#define  PCIE_FUNC3_CONFIG_OFFSET	0x700
+#define  PCIE_SPROM_SHADOW_OFFSET	0x800
+#define  PCIE_SBCONFIG_OFFSET		0xE00
+
+/* PCIE Bar0 Address Mapping. Each function maps 16KB config space */
+#define PCIE_DEV_BAR0_SIZE		0x4000
+#define PCIE_BAR0_WINMAPCORE_OFFSET	0x0
+#define PCIE_BAR0_EXTSPROM_OFFSET	0x1000
+#define PCIE_BAR0_PCIECORE_OFFSET	0x2000
+#define PCIE_BAR0_CCCOREREG_OFFSET	0x3000
+
+/* different register spaces to access thr'u pcie indirect access */
+#define PCIE_CONFIGREGS 	1	/* Access to config space */
+#define PCIE_PCIEREGS 		2	/* Access to pcie registers */
+
+/* SB side: PCIE core and host control registers */
+typedef struct sbpcieregs {
+	uint32 control;		/* host mode only */
+	uint32 PAD[2];
+	uint32 biststatus;	/* bist Status: 0x00C */
+	uint32 gpiosel;		/* PCIE gpio sel: 0x010 */
+	uint32 gpioouten;	/* PCIE gpio outen: 0x14 */
+	uint32 PAD[2];
+	uint32 intstatus;	/* Interrupt status: 0x20 */
+	uint32 intmask;		/* Interrupt mask: 0x24 */
+	uint32 sbtopcimailbox;	/* sb to pcie mailbox: 0x028 */
+	uint32 PAD[53];
+	uint32 sbtopcie0;	/* sb to pcie translation 0: 0x100 */
+	uint32 sbtopcie1;	/* sb to pcie translation 1: 0x104 */
+	uint32 sbtopcie2;	/* sb to pcie translation 2: 0x108 */
+	uint32 PAD[5];
+
+	/* pcie core supports in direct access to config space */
+	uint32 configaddr;	/* pcie config space access: Address field: 0x120 */
+	uint32 configdata;	/* pcie config space access: Data field: 0x124 */
+
+	/* mdio access to serdes */
+	uint32 mdiocontrol;	/* controls the mdio access: 0x128 */
+	uint32 mdiodata;	/* Data to the mdio access: 0x12c */
+
+	/* pcie protocol phy/dllp/tlp register indirect access mechanism */
+	uint32 pcieindaddr;	/* indirect access to the internal register: 0x130 */
+	uint32 pcieinddata;	/* Data to/from the internal regsiter: 0x134 */
+
+	uint32 clkreqenctrl;	/* >= rev 6, Clkreq rdma control : 0x138 */
+	uint32 PAD[177];
+	uint32 pciecfg[4][64];	/* 0x400 - 0x7FF, PCIE Cfg Space */
+	uint16 sprom[64];	/* SPROM shadow Area */
+} sbpcieregs_t;
+
+/* PCI control */
+#define PCIE_RST_OE	0x01	/* When set, drives PCI_RESET out to pin */
+#define PCIE_RST	0x02	/* Value driven out to pin */
+
+#define	PCIE_CFGADDR	0x120	/* offsetof(configaddr) */
+#define	PCIE_CFGDATA	0x124	/* offsetof(configdata) */
+
+/* Interrupt status/mask */
+#define PCIE_INTA	0x01	/* PCIE INTA message is received */
+#define PCIE_INTB	0x02	/* PCIE INTB message is received */
+#define PCIE_INTFATAL	0x04	/* PCIE INTFATAL message is received */
+#define PCIE_INTNFATAL	0x08	/* PCIE INTNONFATAL message is received */
+#define PCIE_INTCORR	0x10	/* PCIE INTCORR message is received */
+#define PCIE_INTPME	0x20	/* PCIE INTPME message is received */
+
+/* SB to PCIE translation masks */
+#define SBTOPCIE0_MASK	0xfc000000
+#define SBTOPCIE1_MASK	0xfc000000
+#define SBTOPCIE2_MASK	0xc0000000
+
+/* Access type bits (0:1) */
+#define SBTOPCIE_MEM	0
+#define SBTOPCIE_IO	1
+#define SBTOPCIE_CFG0	2
+#define SBTOPCIE_CFG1	3
+
+/* Prefetch enable bit 2 */
+#define SBTOPCIE_PF		4
+
+/* Write Burst enable for memory write bit 3 */
+#define SBTOPCIE_WR_BURST	8
+
+/* config access */
+#define CONFIGADDR_FUNC_MASK	0x7000
+#define CONFIGADDR_FUNC_SHF	12
+#define CONFIGADDR_REG_MASK	0x0FFF
+#define CONFIGADDR_REG_SHF	0
+
+#define PCIE_CONFIG_INDADDR(f, r)	\
+	((((f) & CONFIGADDR_FUNC_MASK) << CONFIGADDR_FUNC_SHF) | \
+	(((r) & CONFIGADDR_REG_MASK) << CONFIGADDR_REG_SHF))
+
+/* PCIE protocol regs Indirect Address */
+#define PCIEADDR_PROT_MASK	0x300
+#define PCIEADDR_PROT_SHF	8
+#define PCIEADDR_PL_TLP		0
+#define PCIEADDR_PL_DLLP	1
+#define PCIEADDR_PL_PLP		2
+
+/* PCIE protocol PHY diagnostic registers */
+#define	PCIE_PLP_MODEREG		0x200	/* Mode */
+#define	PCIE_PLP_STATUSREG		0x204	/* Status */
+#define PCIE_PLP_LTSSMCTRLREG		0x208	/* LTSSM control */
+#define PCIE_PLP_LTLINKNUMREG		0x20c	/* Link Training Link number */
+#define PCIE_PLP_LTLANENUMREG		0x210	/* Link Training Lane number */
+#define PCIE_PLP_LTNFTSREG		0x214	/* Link Training N_FTS */
+#define PCIE_PLP_ATTNREG		0x218	/* Attention */
+#define PCIE_PLP_ATTNMASKREG		0x21C	/* Attention Mask */
+#define PCIE_PLP_RXERRCTR		0x220	/* Rx Error */
+#define PCIE_PLP_RXFRMERRCTR		0x224	/* Rx Framing Error */
+#define PCIE_PLP_RXERRTHRESHREG		0x228	/* Rx Error threshold */
+#define PCIE_PLP_TESTCTRLREG		0x22C	/* Test Control reg */
+#define PCIE_PLP_SERDESCTRLOVRDREG	0x230	/* SERDES Control Override */
+#define PCIE_PLP_TIMINGOVRDREG		0x234	/* Timing param override */
+#define PCIE_PLP_RXTXSMDIAGREG		0x238	/* RXTX State Machine Diag */
+#define PCIE_PLP_LTSSMDIAGREG		0x23C	/* LTSSM State Machine Diag */
+
+/* PCIE protocol DLLP diagnostic registers */
+#define PCIE_DLLP_LCREG			0x100	/* Link Control */
+#define PCIE_DLLP_LSREG			0x104	/* Link Status */
+#define PCIE_DLLP_LAREG			0x108	/* Link Attention */
+#define PCIE_DLLP_LAMASKREG		0x10C	/* Link Attention Mask */
+#define PCIE_DLLP_NEXTTXSEQNUMREG	0x110	/* Next Tx Seq Num */
+#define PCIE_DLLP_ACKEDTXSEQNUMREG	0x114	/* Acked Tx Seq Num */
+#define PCIE_DLLP_PURGEDTXSEQNUMREG	0x118	/* Purged Tx Seq Num */
+#define PCIE_DLLP_RXSEQNUMREG		0x11C	/* Rx Sequence Number */
+#define PCIE_DLLP_LRREG			0x120	/* Link Replay */
+#define PCIE_DLLP_LACKTOREG		0x124	/* Link Ack Timeout */
+#define PCIE_DLLP_PMTHRESHREG		0x128	/* Power Management Threshold */
+#define PCIE_DLLP_RTRYWPREG		0x12C	/* Retry buffer write ptr */
+#define PCIE_DLLP_RTRYRPREG		0x130	/* Retry buffer Read ptr */
+#define PCIE_DLLP_RTRYPPREG		0x134	/* Retry buffer Purged ptr */
+#define PCIE_DLLP_RTRRWREG		0x138	/* Retry buffer Read/Write */
+#define PCIE_DLLP_ECTHRESHREG		0x13C	/* Error Count Threshold */
+#define PCIE_DLLP_TLPERRCTRREG		0x140	/* TLP Error Counter */
+#define PCIE_DLLP_ERRCTRREG		0x144	/* Error Counter */
+#define PCIE_DLLP_NAKRXCTRREG		0x148	/* NAK Received Counter */
+#define PCIE_DLLP_TESTREG		0x14C	/* Test */
+#define PCIE_DLLP_PKTBIST		0x150	/* Packet BIST */
+#define PCIE_DLLP_PCIE11		0x154	/* DLLP PCIE 1.1 reg */
+
+#define PCIE_DLLP_LSREG_LINKUP		(1 << 16)
+
+/* PCIE protocol TLP diagnostic registers */
+#define PCIE_TLP_CONFIGREG		0x000	/* Configuration */
+#define PCIE_TLP_WORKAROUNDSREG		0x004	/* TLP Workarounds */
+#define PCIE_TLP_WRDMAUPPER		0x010	/* Write DMA Upper Address */
+#define PCIE_TLP_WRDMALOWER		0x014	/* Write DMA Lower Address */
+#define PCIE_TLP_WRDMAREQ_LBEREG	0x018	/* Write DMA Len/ByteEn Req */
+#define PCIE_TLP_RDDMAUPPER		0x01C	/* Read DMA Upper Address */
+#define PCIE_TLP_RDDMALOWER		0x020	/* Read DMA Lower Address */
+#define PCIE_TLP_RDDMALENREG		0x024	/* Read DMA Len Req */
+#define PCIE_TLP_MSIDMAUPPER		0x028	/* MSI DMA Upper Address */
+#define PCIE_TLP_MSIDMALOWER		0x02C	/* MSI DMA Lower Address */
+#define PCIE_TLP_MSIDMALENREG		0x030	/* MSI DMA Len Req */
+#define PCIE_TLP_SLVREQLENREG		0x034	/* Slave Request Len */
+#define PCIE_TLP_FCINPUTSREQ		0x038	/* Flow Control Inputs */
+#define PCIE_TLP_TXSMGRSREQ		0x03C	/* Tx StateMachine and Gated Req */
+#define PCIE_TLP_ADRACKCNTARBLEN	0x040	/* Address Ack XferCnt and ARB Len */
+#define PCIE_TLP_DMACPLHDR0		0x044	/* DMA Completion Hdr 0 */
+#define PCIE_TLP_DMACPLHDR1		0x048	/* DMA Completion Hdr 1 */
+#define PCIE_TLP_DMACPLHDR2		0x04C	/* DMA Completion Hdr 2 */
+#define PCIE_TLP_DMACPLMISC0		0x050	/* DMA Completion Misc0 */
+#define PCIE_TLP_DMACPLMISC1		0x054	/* DMA Completion Misc1 */
+#define PCIE_TLP_DMACPLMISC2		0x058	/* DMA Completion Misc2 */
+#define PCIE_TLP_SPTCTRLLEN		0x05C	/* Split Controller Req len */
+#define PCIE_TLP_SPTCTRLMSIC0		0x060	/* Split Controller Misc 0 */
+#define PCIE_TLP_SPTCTRLMSIC1		0x064	/* Split Controller Misc 1 */
+#define PCIE_TLP_BUSDEVFUNC		0x068	/* Bus/Device/Func */
+#define PCIE_TLP_RESETCTR		0x06C	/* Reset Counter */
+#define PCIE_TLP_RTRYBUF		0x070	/* Retry Buffer value */
+#define PCIE_TLP_TGTDEBUG1		0x074	/* Target Debug Reg1 */
+#define PCIE_TLP_TGTDEBUG2		0x078	/* Target Debug Reg2 */
+#define PCIE_TLP_TGTDEBUG3		0x07C	/* Target Debug Reg3 */
+#define PCIE_TLP_TGTDEBUG4		0x080	/* Target Debug Reg4 */
+
+/* MDIO control */
+#define MDIOCTL_DIVISOR_MASK		0x7f	/* clock to be used on MDIO */
+#define MDIOCTL_DIVISOR_VAL		0x2
+#define MDIOCTL_PREAM_EN		0x80	/* Enable preamble sequnce */
+#define MDIOCTL_ACCESS_DONE		0x100	/* Tranaction complete */
+
+/* MDIO Data */
+#define MDIODATA_MASK			0x0000ffff	/* data 2 bytes */
+#define MDIODATA_TA			0x00020000	/* Turnaround */
+#define MDIODATA_REGADDR_SHF_OLD	18	/* Regaddr shift (rev < 10) */
+#define MDIODATA_REGADDR_MASK_OLD	0x003c0000	/* Regaddr Mask (rev < 10) */
+#define MDIODATA_DEVADDR_SHF_OLD	22	/* Physmedia devaddr shift (rev < 10) */
+#define MDIODATA_DEVADDR_MASK_OLD	0x0fc00000	/* Physmedia devaddr Mask (rev < 10) */
+#define MDIODATA_REGADDR_SHF		18	/* Regaddr shift */
+#define MDIODATA_REGADDR_MASK		0x007c0000	/* Regaddr Mask */
+#define MDIODATA_DEVADDR_SHF		23	/* Physmedia devaddr shift */
+#define MDIODATA_DEVADDR_MASK		0x0f800000	/* Physmedia devaddr Mask */
+#define MDIODATA_WRITE			0x10000000	/* write Transaction */
+#define MDIODATA_READ			0x20000000	/* Read Transaction */
+#define MDIODATA_START			0x40000000	/* start of Transaction */
+
+#define MDIODATA_DEV_ADDR		0x0	/* dev address for serdes */
+#define	MDIODATA_BLK_ADDR		0x1F	/* blk address for serdes */
+
+/* MDIO devices (SERDES modules)
+ *  unlike old pcie cores (rev < 10), rev10 pcie serde organizes registers into a few blocks.
+ *  two layers mapping (blockidx, register offset) is required
+ */
+#define MDIO_DEV_IEEE0		0x000
+#define MDIO_DEV_IEEE1		0x001
+#define MDIO_DEV_BLK0		0x800
+#define MDIO_DEV_BLK1		0x801
+#define MDIO_DEV_BLK2		0x802
+#define MDIO_DEV_BLK3		0x803
+#define MDIO_DEV_BLK4		0x804
+#define MDIO_DEV_TXPLL		0x808	/* TXPLL register block idx */
+#define MDIO_DEV_TXCTRL0	0x820
+#define MDIO_DEV_SERDESID	0x831
+#define MDIO_DEV_RXCTRL0	0x840
+
+/* serdes regs (rev < 10) */
+#define MDIODATA_DEV_PLL       		0x1d	/* SERDES PLL Dev */
+#define MDIODATA_DEV_TX        		0x1e	/* SERDES TX Dev */
+#define MDIODATA_DEV_RX        		0x1f	/* SERDES RX Dev */
+	/* SERDES RX registers */
+#define SERDES_RX_CTRL			1	/* Rx cntrl */
+#define SERDES_RX_TIMER1		2	/* Rx Timer1 */
+#define SERDES_RX_CDR			6	/* CDR */
+#define SERDES_RX_CDRBW			7	/* CDR BW */
+
+	/* SERDES RX control register */
+#define SERDES_RX_CTRL_FORCE		0x80	/* rxpolarity_force */
+#define SERDES_RX_CTRL_POLARITY		0x40	/* rxpolarity_value */
+
+	/* SERDES PLL registers */
+#define SERDES_PLL_CTRL                 1	/* PLL control reg */
+#define PLL_CTRL_FREQDET_EN             0x4000	/* bit 14 is FREQDET on */
+
+/* Power management threshold */
+#define PCIE_L0THRESHOLDTIME_MASK       0xFF00	/* bits 0 - 7 */
+#define PCIE_L1THRESHOLDTIME_MASK       0xFF00	/* bits 8 - 15 */
+#define PCIE_L1THRESHOLDTIME_SHIFT      8	/* PCIE_L1THRESHOLDTIME_SHIFT */
+#define PCIE_L1THRESHOLD_WARVAL         0x72	/* WAR value */
+#define PCIE_ASPMTIMER_EXTEND		0x01000000	/* > rev7: enable extend ASPM timer */
+
+/* SPROM offsets */
+#define SRSH_ASPM_OFFSET		4	/* word 4 */
+#define SRSH_ASPM_ENB			0x18	/* bit 3, 4 */
+#define SRSH_ASPM_L1_ENB		0x10	/* bit 4 */
+#define SRSH_ASPM_L0s_ENB		0x8	/* bit 3 */
+#define SRSH_PCIE_MISC_CONFIG		5	/* word 5 */
+#define SRSH_L23READY_EXIT_NOPERST	0x8000	/* bit 15 */
+#define SRSH_CLKREQ_OFFSET_REV5		20	/* word 20 for srom rev <= 5 */
+#define SRSH_CLKREQ_OFFSET_REV8		52	/* word 52 for srom rev 8 */
+#define SRSH_CLKREQ_ENB			0x0800	/* bit 11 */
+#define SRSH_BD_OFFSET                  6	/* word 6 */
+#define SRSH_AUTOINIT_OFFSET            18	/* auto initialization enable */
+
+/* Linkcontrol reg offset in PCIE Cap */
+#define PCIE_CAP_LINKCTRL_OFFSET	16	/* linkctrl offset in pcie cap */
+#define PCIE_CAP_LCREG_ASPML0s		0x01	/* ASPM L0s in linkctrl */
+#define PCIE_CAP_LCREG_ASPML1		0x02	/* ASPM L1 in linkctrl */
+#define PCIE_CLKREQ_ENAB		0x100	/* CLKREQ Enab in linkctrl */
+
+#define PCIE_ASPM_ENAB			3	/* ASPM L0s & L1 in linkctrl */
+#define PCIE_ASPM_L1_ENAB		2	/* ASPM L0s & L1 in linkctrl */
+#define PCIE_ASPM_L0s_ENAB		1	/* ASPM L0s & L1 in linkctrl */
+#define PCIE_ASPM_DISAB			0	/* ASPM L0s & L1 in linkctrl */
+
+/* Status reg PCIE_PLP_STATUSREG */
+#define PCIE_PLP_POLARITYINV_STAT	0x10
+#endif				/* _PCIE_CORE_H */
diff --git a/drivers/staging/brcm80211/include/proto/802.11.h b/drivers/staging/brcm80211/include/proto/802.11.h
new file mode 100644
index 0000000..15a4dbf
--- /dev/null
+++ b/drivers/staging/brcm80211/include/proto/802.11.h
@@ -0,0 +1,1436 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _802_11_H_
+#define _802_11_H_
+
+#ifndef _TYPEDEFS_H_
+#include <typedefs.h>
+#endif
+
+#ifndef _NET_ETHERNET_H_
+#include <proto/ethernet.h>
+#endif
+
+#include <proto/wpa.h>
+
+#include <packed_section_start.h>
+
+#define DOT11_TU_TO_US			1024
+
+#define DOT11_A3_HDR_LEN		24
+#define DOT11_A4_HDR_LEN		30
+#define DOT11_MAC_HDR_LEN		DOT11_A3_HDR_LEN
+#define DOT11_FCS_LEN			4
+#define DOT11_ICV_LEN			4
+#define DOT11_ICV_AES_LEN		8
+#define DOT11_QOS_LEN			2
+#define DOT11_HTC_LEN			4
+
+#define DOT11_KEY_INDEX_SHIFT		6
+#define DOT11_IV_LEN			4
+#define DOT11_IV_TKIP_LEN		8
+#define DOT11_IV_AES_OCB_LEN		4
+#define DOT11_IV_AES_CCM_LEN		8
+#define DOT11_IV_MAX_LEN		8
+
+#define DOT11_MAX_MPDU_BODY_LEN		2304
+
+#define DOT11_MAX_MPDU_LEN		(DOT11_A4_HDR_LEN + \
+					 DOT11_QOS_LEN + \
+					 DOT11_IV_AES_CCM_LEN + \
+					 DOT11_MAX_MPDU_BODY_LEN + \
+					 DOT11_ICV_LEN + \
+					 DOT11_FCS_LEN)
+
+#define DOT11_MAX_SSID_LEN		32
+
+#define DOT11_DEFAULT_RTS_LEN		2347
+#define DOT11_MAX_RTS_LEN		2347
+
+#define DOT11_MIN_FRAG_LEN		256
+#define DOT11_MAX_FRAG_LEN		2346
+#define DOT11_DEFAULT_FRAG_LEN		2346
+
+#define DOT11_MIN_BEACON_PERIOD		1
+#define DOT11_MAX_BEACON_PERIOD		0xFFFF
+
+#define DOT11_MIN_DTIM_PERIOD		1
+#define DOT11_MAX_DTIM_PERIOD		0xFF
+
+#define DOT11_LLC_SNAP_HDR_LEN		8
+#define DOT11_OUI_LEN			3
+BWL_PRE_PACKED_STRUCT struct dot11_llc_snap_header {
+	uint8 dsap;
+	uint8 ssap;
+	uint8 ctl;
+	uint8 oui[DOT11_OUI_LEN];
+	uint16 type;
+} BWL_POST_PACKED_STRUCT;
+
+#define RFC1042_HDR_LEN	(ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN)
+
+BWL_PRE_PACKED_STRUCT struct dot11_header {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr a1;
+	struct ether_addr a2;
+	struct ether_addr a3;
+	uint16 seq;
+	struct ether_addr a4;
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct dot11_rts_frame {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr ra;
+	struct ether_addr ta;
+} BWL_POST_PACKED_STRUCT;
+#define	DOT11_RTS_LEN		16
+
+BWL_PRE_PACKED_STRUCT struct dot11_cts_frame {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr ra;
+} BWL_POST_PACKED_STRUCT;
+#define	DOT11_CTS_LEN		10
+
+BWL_PRE_PACKED_STRUCT struct dot11_ack_frame {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr ra;
+} BWL_POST_PACKED_STRUCT;
+#define	DOT11_ACK_LEN		10
+
+BWL_PRE_PACKED_STRUCT struct dot11_ps_poll_frame {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr bssid;
+	struct ether_addr ta;
+} BWL_POST_PACKED_STRUCT;
+#define	DOT11_PS_POLL_LEN	16
+
+BWL_PRE_PACKED_STRUCT struct dot11_cf_end_frame {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr ra;
+	struct ether_addr bssid;
+} BWL_POST_PACKED_STRUCT;
+#define	DOT11_CS_END_LEN	16
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_wifi_vendor_specific {
+	uint8 category;
+	uint8 OUI[3];
+	uint8 type;
+	uint8 subtype;
+	uint8 data[1040];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_action_wifi_vendor_specific
+ dot11_action_wifi_vendor_specific_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_vs_frmhdr {
+	uint8 category;
+	uint8 OUI[3];
+	uint8 type;
+	uint8 subtype;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_action_vs_frmhdr dot11_action_vs_frmhdr_t;
+#define DOT11_ACTION_VS_HDR_LEN	6
+
+#define BCM_ACTION_OUI_BYTE0	0x00
+#define BCM_ACTION_OUI_BYTE1	0x90
+#define BCM_ACTION_OUI_BYTE2	0x4c
+
+#define DOT11_BA_CTL_POLICY_NORMAL	0x0000
+#define DOT11_BA_CTL_POLICY_NOACK	0x0001
+#define DOT11_BA_CTL_POLICY_MASK	0x0001
+
+#define DOT11_BA_CTL_MTID		0x0002
+#define DOT11_BA_CTL_COMPRESSED		0x0004
+
+#define DOT11_BA_CTL_NUMMSDU_MASK	0x0FC0
+#define DOT11_BA_CTL_NUMMSDU_SHIFT	6
+
+#define DOT11_BA_CTL_TID_MASK		0xF000
+#define DOT11_BA_CTL_TID_SHIFT		12
+
+BWL_PRE_PACKED_STRUCT struct dot11_ctl_header {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr ra;
+	struct ether_addr ta;
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_CTL_HDR_LEN	16
+
+BWL_PRE_PACKED_STRUCT struct dot11_bar {
+	uint16 bar_control;
+	uint16 seqnum;
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_BAR_LEN		4
+
+#define DOT11_BA_BITMAP_LEN	128
+#define DOT11_BA_CMP_BITMAP_LEN	8
+
+BWL_PRE_PACKED_STRUCT struct dot11_ba {
+	uint16 ba_control;
+	uint16 seqnum;
+	uint8 bitmap[DOT11_BA_BITMAP_LEN];
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_BA_LEN		4
+
+BWL_PRE_PACKED_STRUCT struct dot11_management_header {
+	uint16 fc;
+	uint16 durid;
+	struct ether_addr da;
+	struct ether_addr sa;
+	struct ether_addr bssid;
+	uint16 seq;
+} BWL_POST_PACKED_STRUCT;
+#define	DOT11_MGMT_HDR_LEN	24
+
+BWL_PRE_PACKED_STRUCT struct dot11_bcn_prb {
+	uint32 timestamp[2];
+	uint16 beacon_interval;
+	uint16 capability;
+} BWL_POST_PACKED_STRUCT;
+#define	DOT11_BCN_PRB_LEN	12
+#define	DOT11_BCN_PRB_FIXED_LEN	12
+
+BWL_PRE_PACKED_STRUCT struct dot11_auth {
+	uint16 alg;
+	uint16 seq;
+	uint16 status;
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_AUTH_FIXED_LEN	6
+
+BWL_PRE_PACKED_STRUCT struct dot11_assoc_req {
+	uint16 capability;
+	uint16 listen;
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_ASSOC_REQ_FIXED_LEN	4
+
+BWL_PRE_PACKED_STRUCT struct dot11_reassoc_req {
+	uint16 capability;
+	uint16 listen;
+	struct ether_addr ap;
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_REASSOC_REQ_FIXED_LEN	10
+
+BWL_PRE_PACKED_STRUCT struct dot11_assoc_resp {
+	uint16 capability;
+	uint16 status;
+	uint16 aid;
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_ASSOC_RESP_FIXED_LEN	6
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_measure {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_ACTION_MEASURE_LEN	3
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_ht_ch_width {
+	uint8 category;
+	uint8 action;
+	uint8 ch_width;
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_ht_mimops {
+	uint8 category;
+	uint8 action;
+	uint8 control;
+} BWL_POST_PACKED_STRUCT;
+
+#define SM_PWRSAVE_ENABLE	1
+#define SM_PWRSAVE_MODE		2
+
+BWL_PRE_PACKED_STRUCT struct dot11_power_cnst {
+	uint8 id;
+	uint8 len;
+	uint8 power;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_power_cnst dot11_power_cnst_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_power_cap {
+	uint8 min;
+	uint8 max;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_power_cap dot11_power_cap_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_tpc_rep {
+	uint8 id;
+	uint8 len;
+	uint8 tx_pwr;
+	uint8 margin;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_tpc_rep dot11_tpc_rep_t;
+#define DOT11_MNG_IE_TPC_REPORT_LEN	2
+
+BWL_PRE_PACKED_STRUCT struct dot11_supp_channels {
+	uint8 id;
+	uint8 len;
+	uint8 first_channel;
+	uint8 num_channels;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_supp_channels dot11_supp_channels_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_extch {
+	uint8 id;
+	uint8 len;
+	uint8 extch;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_extch dot11_extch_ie_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_brcm_extch {
+	uint8 id;
+	uint8 len;
+	uint8 oui[3];
+	uint8 type;
+	uint8 extch;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_brcm_extch dot11_brcm_extch_ie_t;
+
+#define DOT11_EXTCH_IE_LEN	1
+#define DOT11_EXT_CH_MASK	0x03
+#define DOT11_EXT_CH_UPPER	0x01
+#define DOT11_EXT_CH_LOWER	0x03
+#define DOT11_EXT_CH_NONE	0x00
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_frmhdr {
+	uint8 category;
+	uint8 action;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_ACTION_FRMHDR_LEN	2
+
+BWL_PRE_PACKED_STRUCT struct dot11_channel_switch {
+	uint8 id;
+	uint8 len;
+	uint8 mode;
+	uint8 channel;
+	uint8 count;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_channel_switch dot11_chan_switch_ie_t;
+
+#define DOT11_SWITCH_IE_LEN	3
+
+#define DOT11_CSA_MODE_ADVISORY		0
+#define DOT11_CSA_MODE_NO_TX		1
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_switch_channel {
+	uint8 category;
+	uint8 action;
+	dot11_chan_switch_ie_t chan_switch_ie;
+	dot11_brcm_extch_ie_t extch_ie;
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct dot11_csa_body {
+	uint8 mode;
+	uint8 reg;
+	uint8 channel;
+	uint8 count;
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct dot11_ext_csa {
+	uint8 id;
+	uint8 len;
+	struct dot11_csa_body b;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_ext_csa dot11_ext_csa_ie_t;
+#define DOT11_EXT_CSA_IE_LEN	4
+
+BWL_PRE_PACKED_STRUCT struct dot11_action_ext_csa {
+	uint8 category;
+	uint8 action;
+	dot11_ext_csa_ie_t chan_switch_ie;
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct dot11y_action_ext_csa {
+	uint8 category;
+	uint8 action;
+	struct dot11_csa_body b;
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct dot11_obss_coex {
+	uint8 id;
+	uint8 len;
+	uint8 info;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_obss_coex dot11_obss_coex_t;
+#define DOT11_OBSS_COEXINFO_LEN	1
+
+#define	DOT11_OBSS_COEX_INFO_REQ		0x01
+#define	DOT11_OBSS_COEX_40MHZ_INTOLERANT	0x02
+#define	DOT11_OBSS_COEX_20MHZ_WIDTH_REQ	0x04
+
+BWL_PRE_PACKED_STRUCT struct dot11_obss_chanlist {
+	uint8 id;
+	uint8 len;
+	uint8 regclass;
+	uint8 chanlist[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_obss_chanlist dot11_obss_chanlist_t;
+#define DOT11_OBSS_CHANLIST_FIXED_LEN	1
+
+BWL_PRE_PACKED_STRUCT struct dot11_extcap_ie {
+	uint8 id;
+	uint8 len;
+	uint8 cap;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_extcap_ie dot11_extcap_ie_t;
+#define DOT11_EXTCAP_LEN	1
+
+#define DOT11_MEASURE_TYPE_BASIC 	0
+#define DOT11_MEASURE_TYPE_CCA 		1
+#define DOT11_MEASURE_TYPE_RPI		2
+#define DOT11_MEASURE_TYPE_CHLOAD		3
+#define DOT11_MEASURE_TYPE_NOISE		4
+#define DOT11_MEASURE_TYPE_BEACON		5
+#define DOT11_MEASURE_TYPE_FRAME	6
+#define DOT11_MEASURE_TYPE_STATS		7
+#define DOT11_MEASURE_TYPE_LCI		8
+#define DOT11_MEASURE_TYPE_TXSTREAM		9
+#define DOT11_MEASURE_TYPE_PAUSE		255
+
+#define DOT11_MEASURE_MODE_PARALLEL 	(1<<0)
+#define DOT11_MEASURE_MODE_ENABLE 	(1<<1)
+#define DOT11_MEASURE_MODE_REQUEST	(1<<2)
+#define DOT11_MEASURE_MODE_REPORT 	(1<<3)
+#define DOT11_MEASURE_MODE_DUR 	(1<<4)
+
+#define DOT11_MEASURE_MODE_LATE 	(1<<0)
+#define DOT11_MEASURE_MODE_INCAPABLE	(1<<1)
+#define DOT11_MEASURE_MODE_REFUSED	(1<<2)
+
+#define DOT11_MEASURE_BASIC_MAP_BSS	((uint8)(1<<0))
+#define DOT11_MEASURE_BASIC_MAP_OFDM	((uint8)(1<<1))
+#define DOT11_MEASURE_BASIC_MAP_UKNOWN	((uint8)(1<<2))
+#define DOT11_MEASURE_BASIC_MAP_RADAR	((uint8)(1<<3))
+#define DOT11_MEASURE_BASIC_MAP_UNMEAS	((uint8)(1<<4))
+
+BWL_PRE_PACKED_STRUCT struct dot11_meas_req {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 channel;
+	uint8 start_time[8];
+	uint16 duration;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_meas_req dot11_meas_req_t;
+#define DOT11_MNG_IE_MREQ_LEN 14
+
+#define DOT11_MNG_IE_MREQ_FIXED_LEN 3
+
+BWL_PRE_PACKED_STRUCT struct dot11_meas_rep {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	BWL_PRE_PACKED_STRUCT union {
+		BWL_PRE_PACKED_STRUCT struct {
+			uint8 channel;
+			uint8 start_time[8];
+			uint16 duration;
+			uint8 map;
+		} BWL_POST_PACKED_STRUCT basic;
+		uint8 data[1];
+	} BWL_POST_PACKED_STRUCT rep;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_meas_rep dot11_meas_rep_t;
+
+#define DOT11_MNG_IE_MREP_FIXED_LEN	3
+
+BWL_PRE_PACKED_STRUCT struct dot11_meas_rep_basic {
+	uint8 channel;
+	uint8 start_time[8];
+	uint16 duration;
+	uint8 map;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_meas_rep_basic dot11_meas_rep_basic_t;
+#define DOT11_MEASURE_BASIC_REP_LEN	12
+
+BWL_PRE_PACKED_STRUCT struct dot11_quiet {
+	uint8 id;
+	uint8 len;
+	uint8 count;
+	uint8 period;
+	uint16 duration;
+	uint16 offset;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_quiet dot11_quiet_t;
+
+BWL_PRE_PACKED_STRUCT struct chan_map_tuple {
+	uint8 channel;
+	uint8 map;
+} BWL_POST_PACKED_STRUCT;
+typedef struct chan_map_tuple chan_map_tuple_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_ibss_dfs {
+	uint8 id;
+	uint8 len;
+	uint8 eaddr[ETHER_ADDR_LEN];
+	uint8 interval;
+	chan_map_tuple_t map[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_ibss_dfs dot11_ibss_dfs_t;
+
+#define WME_OUI			"\x00\x50\xf2"
+#define WME_VER			1
+#define WME_TYPE		2
+#define WME_SUBTYPE_IE		0
+#define WME_SUBTYPE_PARAM_IE	1
+#define WME_SUBTYPE_TSPEC	2
+
+#define AC_BE			0
+#define AC_BK			1
+#define AC_VI			2
+#define AC_VO			3
+#define AC_COUNT		4
+
+typedef uint8 ac_bitmap_t;
+
+#define AC_BITMAP_NONE		0x0
+#define AC_BITMAP_ALL		0xf
+#define AC_BITMAP_TST(ab, ac)	(((ab) & (1 << (ac))) != 0)
+#define AC_BITMAP_SET(ab, ac)	(((ab) |= (1 << (ac))))
+#define AC_BITMAP_RESET(ab, ac) (((ab) &= ~(1 << (ac))))
+
+BWL_PRE_PACKED_STRUCT struct wme_ie {
+	uint8 oui[3];
+	uint8 type;
+	uint8 subtype;
+	uint8 version;
+	uint8 qosinfo;
+} BWL_POST_PACKED_STRUCT;
+typedef struct wme_ie wme_ie_t;
+#define WME_IE_LEN 7
+
+BWL_PRE_PACKED_STRUCT struct edcf_acparam {
+	uint8 ACI;
+	uint8 ECW;
+	uint16 TXOP;
+} BWL_POST_PACKED_STRUCT;
+typedef struct edcf_acparam edcf_acparam_t;
+
+BWL_PRE_PACKED_STRUCT struct wme_param_ie {
+	uint8 oui[3];
+	uint8 type;
+	uint8 subtype;
+	uint8 version;
+	uint8 qosinfo;
+	uint8 rsvd;
+	edcf_acparam_t acparam[AC_COUNT];
+} BWL_POST_PACKED_STRUCT;
+typedef struct wme_param_ie wme_param_ie_t;
+#define WME_PARAM_IE_LEN            24
+
+#define WME_QI_AP_APSD_MASK         0x80
+#define WME_QI_AP_APSD_SHIFT        7
+#define WME_QI_AP_COUNT_MASK        0x0f
+#define WME_QI_AP_COUNT_SHIFT       0
+
+#define WME_QI_STA_MAXSPLEN_MASK    0x60
+#define WME_QI_STA_MAXSPLEN_SHIFT   5
+#define WME_QI_STA_APSD_ALL_MASK    0xf
+#define WME_QI_STA_APSD_ALL_SHIFT   0
+#define WME_QI_STA_APSD_BE_MASK     0x8
+#define WME_QI_STA_APSD_BE_SHIFT    3
+#define WME_QI_STA_APSD_BK_MASK     0x4
+#define WME_QI_STA_APSD_BK_SHIFT    2
+#define WME_QI_STA_APSD_VI_MASK     0x2
+#define WME_QI_STA_APSD_VI_SHIFT    1
+#define WME_QI_STA_APSD_VO_MASK     0x1
+#define WME_QI_STA_APSD_VO_SHIFT    0
+
+#define EDCF_AIFSN_MIN               1
+#define EDCF_AIFSN_MAX               15
+#define EDCF_AIFSN_MASK              0x0f
+#define EDCF_ACM_MASK                0x10
+#define EDCF_ACI_MASK                0x60
+#define EDCF_ACI_SHIFT               5
+#define EDCF_AIFSN_SHIFT             12
+
+#define EDCF_ECW_MIN                 0
+#define EDCF_ECW_MAX                 15
+#define EDCF_ECW2CW(exp)             ((1 << (exp)) - 1)
+#define EDCF_ECWMIN_MASK             0x0f
+#define EDCF_ECWMAX_MASK             0xf0
+#define EDCF_ECWMAX_SHIFT            4
+
+#define EDCF_TXOP_MIN                0
+#define EDCF_TXOP_MAX                65535
+#define EDCF_TXOP2USEC(txop)         ((txop) << 5)
+
+#define NON_EDCF_AC_BE_ACI_STA          0x02
+
+#define EDCF_AC_BE_ACI_STA           0x03
+#define EDCF_AC_BE_ECW_STA           0xA4
+#define EDCF_AC_BE_TXOP_STA          0x0000
+#define EDCF_AC_BK_ACI_STA           0x27
+#define EDCF_AC_BK_ECW_STA           0xA4
+#define EDCF_AC_BK_TXOP_STA          0x0000
+#define EDCF_AC_VI_ACI_STA           0x42
+#define EDCF_AC_VI_ECW_STA           0x43
+#define EDCF_AC_VI_TXOP_STA          0x005e
+#define EDCF_AC_VO_ACI_STA           0x62
+#define EDCF_AC_VO_ECW_STA           0x32
+#define EDCF_AC_VO_TXOP_STA          0x002f
+
+#define EDCF_AC_BE_ACI_AP            0x03
+#define EDCF_AC_BE_ECW_AP            0x64
+#define EDCF_AC_BE_TXOP_AP           0x0000
+#define EDCF_AC_BK_ACI_AP            0x27
+#define EDCF_AC_BK_ECW_AP            0xA4
+#define EDCF_AC_BK_TXOP_AP           0x0000
+#define EDCF_AC_VI_ACI_AP            0x41
+#define EDCF_AC_VI_ECW_AP            0x43
+#define EDCF_AC_VI_TXOP_AP           0x005e
+#define EDCF_AC_VO_ACI_AP            0x61
+#define EDCF_AC_VO_ECW_AP            0x32
+#define EDCF_AC_VO_TXOP_AP           0x002f
+
+BWL_PRE_PACKED_STRUCT struct edca_param_ie {
+	uint8 qosinfo;
+	uint8 rsvd;
+	edcf_acparam_t acparam[AC_COUNT];
+} BWL_POST_PACKED_STRUCT;
+typedef struct edca_param_ie edca_param_ie_t;
+#define EDCA_PARAM_IE_LEN            18
+
+BWL_PRE_PACKED_STRUCT struct qos_cap_ie {
+	uint8 qosinfo;
+} BWL_POST_PACKED_STRUCT;
+typedef struct qos_cap_ie qos_cap_ie_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_qbss_load_ie {
+	uint8 id;
+	uint8 length;
+	uint16 station_count;
+	uint8 channel_utilization;
+	uint16 aac;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_qbss_load_ie dot11_qbss_load_ie_t;
+
+#define FIXED_MSDU_SIZE 0x8000
+#define MSDU_SIZE_MASK	0x7fff
+
+#define	INTEGER_SHIFT	13
+#define FRACTION_MASK	0x1FFF
+
+BWL_PRE_PACKED_STRUCT struct dot11_management_notification {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	uint8 status;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+#define DOT11_MGMT_NOTIFICATION_LEN 4
+
+#define WME_ADDTS_REQUEST	0
+#define WME_ADDTS_RESPONSE	1
+#define WME_DELTS_REQUEST	2
+
+#define WME_ADMISSION_ACCEPTED		0
+#define WME_INVALID_PARAMETERS		1
+#define WME_ADMISSION_REFUSED		3
+
+#define BCN_PRB_SSID(body) ((char*)(body) + DOT11_BCN_PRB_LEN)
+
+#define DOT11_OPEN_SYSTEM	0
+#define DOT11_SHARED_KEY	1
+#define DOT11_OPEN_SHARED	2
+#define DOT11_CHALLENGE_LEN	128
+
+#define FC_PVER_MASK		0x3
+#define FC_PVER_SHIFT		0
+#define FC_TYPE_MASK		0xC
+#define FC_TYPE_SHIFT		2
+#define FC_SUBTYPE_MASK		0xF0
+#define FC_SUBTYPE_SHIFT	4
+#define FC_TODS			0x100
+#define FC_TODS_SHIFT		8
+#define FC_FROMDS		0x200
+#define FC_FROMDS_SHIFT		9
+#define FC_MOREFRAG		0x400
+#define FC_MOREFRAG_SHIFT	10
+#define FC_RETRY		0x800
+#define FC_RETRY_SHIFT		11
+#define FC_PM			0x1000
+#define FC_PM_SHIFT		12
+#define FC_MOREDATA		0x2000
+#define FC_MOREDATA_SHIFT	13
+#define FC_WEP			0x4000
+#define FC_WEP_SHIFT		14
+#define FC_ORDER		0x8000
+#define FC_ORDER_SHIFT		15
+
+#define SEQNUM_SHIFT		4
+#define SEQNUM_MAX		0x1000
+#define FRAGNUM_MASK		0xF
+
+#define FC_TYPE_MNG		0
+#define FC_TYPE_CTL		1
+#define FC_TYPE_DATA		2
+
+#define FC_SUBTYPE_ASSOC_REQ		0
+#define FC_SUBTYPE_ASSOC_RESP		1
+#define FC_SUBTYPE_REASSOC_REQ		2
+#define FC_SUBTYPE_REASSOC_RESP		3
+#define FC_SUBTYPE_PROBE_REQ		4
+#define FC_SUBTYPE_PROBE_RESP		5
+#define FC_SUBTYPE_BEACON		8
+#define FC_SUBTYPE_ATIM			9
+#define FC_SUBTYPE_DISASSOC		10
+#define FC_SUBTYPE_AUTH			11
+#define FC_SUBTYPE_DEAUTH		12
+#define FC_SUBTYPE_ACTION		13
+#define FC_SUBTYPE_ACTION_NOACK		14
+
+#define FC_SUBTYPE_CTL_WRAPPER		7
+#define FC_SUBTYPE_BLOCKACK_REQ		8
+#define FC_SUBTYPE_BLOCKACK		9
+#define FC_SUBTYPE_PS_POLL		10
+#define FC_SUBTYPE_RTS			11
+#define FC_SUBTYPE_CTS			12
+#define FC_SUBTYPE_ACK			13
+#define FC_SUBTYPE_CF_END		14
+#define FC_SUBTYPE_CF_END_ACK		15
+
+#define FC_SUBTYPE_DATA			0
+#define FC_SUBTYPE_DATA_CF_ACK		1
+#define FC_SUBTYPE_DATA_CF_POLL		2
+#define FC_SUBTYPE_DATA_CF_ACK_POLL	3
+#define FC_SUBTYPE_NULL			4
+#define FC_SUBTYPE_CF_ACK		5
+#define FC_SUBTYPE_CF_POLL		6
+#define FC_SUBTYPE_CF_ACK_POLL		7
+#define FC_SUBTYPE_QOS_DATA		8
+#define FC_SUBTYPE_QOS_DATA_CF_ACK	9
+#define FC_SUBTYPE_QOS_DATA_CF_POLL	10
+#define FC_SUBTYPE_QOS_DATA_CF_ACK_POLL	11
+#define FC_SUBTYPE_QOS_NULL		12
+#define FC_SUBTYPE_QOS_CF_POLL		14
+#define FC_SUBTYPE_QOS_CF_ACK_POLL	15
+
+#define FC_SUBTYPE_ANY_QOS(s)		(((s) & 8) != 0)
+#define FC_SUBTYPE_ANY_NULL(s)		(((s) & 4) != 0)
+#define FC_SUBTYPE_ANY_CF_POLL(s)	(((s) & 2) != 0)
+#define FC_SUBTYPE_ANY_CF_ACK(s)	(((s) & 1) != 0)
+
+#define FC_KIND_MASK		(FC_TYPE_MASK | FC_SUBTYPE_MASK)
+
+#define FC_KIND(t, s)	(((t) << FC_TYPE_SHIFT) | ((s) << FC_SUBTYPE_SHIFT))
+
+#define FC_SUBTYPE(fc)	(((fc) & FC_SUBTYPE_MASK) >> FC_SUBTYPE_SHIFT)
+#define FC_TYPE(fc)	(((fc) & FC_TYPE_MASK) >> FC_TYPE_SHIFT)
+
+#define FC_ASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_REQ)
+#define FC_ASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ASSOC_RESP)
+#define FC_REASSOC_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_REQ)
+#define FC_REASSOC_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_REASSOC_RESP)
+#define FC_PROBE_REQ	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_REQ)
+#define FC_PROBE_RESP	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_PROBE_RESP)
+#define FC_BEACON	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_BEACON)
+#define FC_DISASSOC	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DISASSOC)
+#define FC_AUTH		FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_AUTH)
+#define FC_DEAUTH	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_DEAUTH)
+#define FC_ACTION	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION)
+#define FC_ACTION_NOACK	FC_KIND(FC_TYPE_MNG, FC_SUBTYPE_ACTION_NOACK)
+
+#define FC_CTL_WRAPPER	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTL_WRAPPER)
+#define FC_BLOCKACK_REQ	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK_REQ)
+#define FC_BLOCKACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_BLOCKACK)
+#define FC_PS_POLL	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_PS_POLL)
+#define FC_RTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_RTS)
+#define FC_CTS		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CTS)
+#define FC_ACK		FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_ACK)
+#define FC_CF_END	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END)
+#define FC_CF_END_ACK	FC_KIND(FC_TYPE_CTL, FC_SUBTYPE_CF_END_ACK)
+
+#define FC_DATA		FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA)
+#define FC_NULL_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_NULL)
+#define FC_DATA_CF_ACK	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_DATA_CF_ACK)
+#define FC_QOS_DATA	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_DATA)
+#define FC_QOS_NULL	FC_KIND(FC_TYPE_DATA, FC_SUBTYPE_QOS_NULL)
+
+#define QOS_PRIO_SHIFT		0
+#define QOS_PRIO_MASK		0x0007
+#define QOS_PRIO(qos)		(((qos) & QOS_PRIO_MASK) >> QOS_PRIO_SHIFT)
+
+#define QOS_TID_SHIFT		0
+#define QOS_TID_MASK		0x000f
+#define QOS_TID(qos)		(((qos) & QOS_TID_MASK) >> QOS_TID_SHIFT)
+
+#define QOS_EOSP_SHIFT		4
+#define QOS_EOSP_MASK		0x0010
+#define QOS_EOSP(qos)		(((qos) & QOS_EOSP_MASK) >> QOS_EOSP_SHIFT)
+
+#define QOS_ACK_NORMAL_ACK	0
+#define QOS_ACK_NO_ACK		1
+#define QOS_ACK_NO_EXP_ACK	2
+#define QOS_ACK_BLOCK_ACK	3
+#define QOS_ACK_SHIFT		5
+#define QOS_ACK_MASK		0x0060
+#define QOS_ACK(qos)		(((qos) & QOS_ACK_MASK) >> QOS_ACK_SHIFT)
+
+#define QOS_AMSDU_SHIFT		7
+#define QOS_AMSDU_MASK		0x0080
+
+#define DOT11_MNG_AUTH_ALGO_LEN		2
+#define DOT11_MNG_AUTH_SEQ_LEN		2
+#define DOT11_MNG_BEACON_INT_LEN	2
+#define DOT11_MNG_CAP_LEN		2
+#define DOT11_MNG_AP_ADDR_LEN		6
+#define DOT11_MNG_LISTEN_INT_LEN	2
+#define DOT11_MNG_REASON_LEN		2
+#define DOT11_MNG_AID_LEN		2
+#define DOT11_MNG_STATUS_LEN		2
+#define DOT11_MNG_TIMESTAMP_LEN		8
+
+#define DOT11_AID_MASK			0x3fff
+
+#define DOT11_RC_RESERVED		0
+#define DOT11_RC_UNSPECIFIED		1
+#define DOT11_RC_AUTH_INVAL		2
+#define DOT11_RC_DEAUTH_LEAVING		3
+#define DOT11_RC_INACTIVITY		4
+#define DOT11_RC_BUSY			5
+#define DOT11_RC_INVAL_CLASS_2		6
+#define DOT11_RC_INVAL_CLASS_3		7
+#define DOT11_RC_DISASSOC_LEAVING	8
+#define DOT11_RC_NOT_AUTH		9
+#define DOT11_RC_BAD_PC			10
+#define DOT11_RC_BAD_CHANNELS		11
+
+#define DOT11_RC_UNSPECIFIED_QOS	32
+#define DOT11_RC_INSUFFCIENT_BW		33
+#define DOT11_RC_EXCESSIVE_FRAMES	34
+#define DOT11_RC_TX_OUTSIDE_TXOP	35
+#define DOT11_RC_LEAVING_QBSS		36
+#define DOT11_RC_BAD_MECHANISM		37
+#define DOT11_RC_SETUP_NEEDED		38
+#define DOT11_RC_TIMEOUT		39
+
+#define DOT11_RC_MAX			23
+
+#define DOT11_SC_SUCCESS		0
+#define DOT11_SC_FAILURE		1
+#define DOT11_SC_CAP_MISMATCH		10
+#define DOT11_SC_REASSOC_FAIL		11
+#define DOT11_SC_ASSOC_FAIL		12
+#define DOT11_SC_AUTH_MISMATCH		13
+#define DOT11_SC_AUTH_SEQ		14
+#define DOT11_SC_AUTH_CHALLENGE_FAIL	15
+#define DOT11_SC_AUTH_TIMEOUT		16
+#define DOT11_SC_ASSOC_BUSY_FAIL	17
+#define DOT11_SC_ASSOC_RATE_MISMATCH	18
+#define DOT11_SC_ASSOC_SHORT_REQUIRED	19
+#define DOT11_SC_ASSOC_PBCC_REQUIRED	20
+#define DOT11_SC_ASSOC_AGILITY_REQUIRED	21
+#define DOT11_SC_ASSOC_SPECTRUM_REQUIRED	22
+#define DOT11_SC_ASSOC_BAD_POWER_CAP	23
+#define DOT11_SC_ASSOC_BAD_SUP_CHANNELS	24
+#define DOT11_SC_ASSOC_SHORTSLOT_REQUIRED	25
+#define DOT11_SC_ASSOC_ERPBCC_REQUIRED	26
+#define DOT11_SC_ASSOC_DSSOFDM_REQUIRED	27
+
+#define	DOT11_SC_DECLINED		37
+#define	DOT11_SC_INVALID_PARAMS		38
+
+#define DOT11_MNG_DS_PARAM_LEN			1
+#define DOT11_MNG_IBSS_PARAM_LEN		2
+
+#define DOT11_MNG_TIM_FIXED_LEN			3
+#define DOT11_MNG_TIM_DTIM_COUNT		0
+#define DOT11_MNG_TIM_DTIM_PERIOD		1
+#define DOT11_MNG_TIM_BITMAP_CTL		2
+#define DOT11_MNG_TIM_PVB			3
+
+#define TLV_TAG_OFF		0
+#define TLV_LEN_OFF		1
+#define TLV_HDR_LEN		2
+#define TLV_BODY_OFF		2
+
+#define DOT11_MNG_SSID_ID			0
+#define DOT11_MNG_RATES_ID			1
+#define DOT11_MNG_FH_PARMS_ID			2
+#define DOT11_MNG_DS_PARMS_ID			3
+#define DOT11_MNG_CF_PARMS_ID			4
+#define DOT11_MNG_TIM_ID			5
+#define DOT11_MNG_IBSS_PARMS_ID			6
+#define DOT11_MNG_COUNTRY_ID			7
+#define DOT11_MNG_HOPPING_PARMS_ID		8
+#define DOT11_MNG_HOPPING_TABLE_ID		9
+#define DOT11_MNG_REQUEST_ID			10
+#define DOT11_MNG_QBSS_LOAD_ID 			11
+#define DOT11_MNG_EDCA_PARAM_ID			12
+#define DOT11_MNG_CHALLENGE_ID			16
+#define DOT11_MNG_PWR_CONSTRAINT_ID		32
+#define DOT11_MNG_PWR_CAP_ID			33
+#define DOT11_MNG_TPC_REQUEST_ID 		34
+#define DOT11_MNG_TPC_REPORT_ID			35
+#define DOT11_MNG_SUPP_CHANNELS_ID		36
+#define DOT11_MNG_CHANNEL_SWITCH_ID		37
+#define DOT11_MNG_MEASURE_REQUEST_ID		38
+#define DOT11_MNG_MEASURE_REPORT_ID		39
+#define DOT11_MNG_QUIET_ID			40
+#define DOT11_MNG_IBSS_DFS_ID			41
+#define DOT11_MNG_ERP_ID			42
+#define DOT11_MNG_TS_DELAY_ID			43
+#define	DOT11_MNG_HT_CAP			45
+#define DOT11_MNG_QOS_CAP_ID			46
+#define DOT11_MNG_NONERP_ID			47
+#define DOT11_MNG_RSN_ID			48
+#define DOT11_MNG_EXT_RATES_ID			50
+#define DOT11_MNG_AP_CHREP_ID		51
+#define DOT11_MNG_NBR_REP_ID		52
+#define	DOT11_MNG_REGCLASS_ID			59
+#define DOT11_MNG_EXT_CSA_ID			60
+#define	DOT11_MNG_HT_ADD			61
+#define	DOT11_MNG_EXT_CHANNEL_OFFSET		62
+
+#define DOT11_MNG_RRM_CAP_ID		70
+#define	DOT11_MNG_HT_BSS_COEXINFO_ID		72
+#define	DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID	73
+#define	DOT11_MNG_HT_OBSS_ID			74
+#define	DOT11_MNG_EXT_CAP			127
+#define DOT11_MNG_WPA_ID			221
+#define DOT11_MNG_PROPR_ID			221
+
+#define DOT11_MNG_VS_ID				221
+
+#define DOT11_RATE_BASIC			0x80
+#define DOT11_RATE_MASK				0x7F
+
+#define DOT11_MNG_ERP_LEN			1
+#define DOT11_MNG_NONERP_PRESENT		0x01
+#define DOT11_MNG_USE_PROTECTION		0x02
+#define DOT11_MNG_BARKER_PREAMBLE		0x04
+
+#define DOT11_MGN_TS_DELAY_LEN		4
+#define TS_DELAY_FIELD_SIZE			4
+
+#define DOT11_CAP_ESS				0x0001
+#define DOT11_CAP_IBSS				0x0002
+#define DOT11_CAP_POLLABLE			0x0004
+#define DOT11_CAP_POLL_RQ			0x0008
+#define DOT11_CAP_PRIVACY			0x0010
+#define DOT11_CAP_SHORT				0x0020
+#define DOT11_CAP_PBCC				0x0040
+#define DOT11_CAP_AGILITY			0x0080
+#define DOT11_CAP_SPECTRUM			0x0100
+#define DOT11_CAP_SHORTSLOT			0x0400
+#define DOT11_CAP_RRM			0x1000
+#define DOT11_CAP_CCK_OFDM			0x2000
+
+#define DOT11_OBSS_COEX_MNG_SUPPORT	0x01
+
+#define DOT11_ACTION_HDR_LEN		2
+
+#define DOT11_ACTION_CAT_ERR_MASK	0x80
+#define DOT11_ACTION_CAT_MASK		0x7F
+#define DOT11_ACTION_CAT_SPECT_MNG	0
+#define DOT11_ACTION_CAT_QOS		1
+#define DOT11_ACTION_CAT_DLS		2
+#define DOT11_ACTION_CAT_BLOCKACK	3
+#define DOT11_ACTION_CAT_PUBLIC		4
+#define DOT11_ACTION_CAT_RRM		5
+#define DOT11_ACTION_CAT_HT		7
+#define DOT11_ACTION_NOTIFICATION	17
+#define DOT11_ACTION_CAT_VS		127
+
+#define DOT11_SM_ACTION_M_REQ		0
+#define DOT11_SM_ACTION_M_REP		1
+#define DOT11_SM_ACTION_TPC_REQ		2
+#define DOT11_SM_ACTION_TPC_REP		3
+#define DOT11_SM_ACTION_CHANNEL_SWITCH	4
+#define DOT11_SM_ACTION_EXT_CSA		5
+
+#define DOT11_ACTION_ID_HT_CH_WIDTH	0
+#define DOT11_ACTION_ID_HT_MIMO_PS	1
+
+#define DOT11_PUB_ACTION_BSS_COEX_MNG	0
+#define DOT11_PUB_ACTION_CHANNEL_SWITCH	4
+
+#define DOT11_BA_ACTION_ADDBA_REQ	0
+#define DOT11_BA_ACTION_ADDBA_RESP	1
+#define DOT11_BA_ACTION_DELBA		2
+
+#define DOT11_ADDBA_PARAM_AMSDU_SUP	0x0001
+#define DOT11_ADDBA_PARAM_POLICY_MASK	0x0002
+#define DOT11_ADDBA_PARAM_POLICY_SHIFT	1
+#define DOT11_ADDBA_PARAM_TID_MASK	0x003c
+#define DOT11_ADDBA_PARAM_TID_SHIFT	2
+#define DOT11_ADDBA_PARAM_BSIZE_MASK	0xffc0
+#define DOT11_ADDBA_PARAM_BSIZE_SHIFT	6
+
+#define DOT11_ADDBA_POLICY_DELAYED	0
+#define DOT11_ADDBA_POLICY_IMMEDIATE	1
+
+BWL_PRE_PACKED_STRUCT struct dot11_addba_req {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	uint16 addba_param_set;
+	uint16 timeout;
+	uint16 start_seqnum;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_addba_req dot11_addba_req_t;
+#define DOT11_ADDBA_REQ_LEN		9
+
+BWL_PRE_PACKED_STRUCT struct dot11_addba_resp {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	uint16 status;
+	uint16 addba_param_set;
+	uint16 timeout;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_addba_resp dot11_addba_resp_t;
+#define DOT11_ADDBA_RESP_LEN		9
+
+#define DOT11_DELBA_PARAM_INIT_MASK	0x0800
+#define DOT11_DELBA_PARAM_INIT_SHIFT	11
+#define DOT11_DELBA_PARAM_TID_MASK	0xf000
+#define DOT11_DELBA_PARAM_TID_SHIFT	12
+
+BWL_PRE_PACKED_STRUCT struct dot11_delba {
+	uint8 category;
+	uint8 action;
+	uint16 delba_param_set;
+	uint16 reason;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_delba dot11_delba_t;
+#define DOT11_DELBA_LEN			6
+
+#define DOT11_RRM_CAP_LEN		5
+BWL_PRE_PACKED_STRUCT struct dot11_rrm_cap_ie {
+	uint8 cap[DOT11_RRM_CAP_LEN];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rrm_cap_ie dot11_rrm_cap_ie_t;
+
+#define DOT11_RRM_CAP_LINK			0
+#define DOT11_RRM_CAP_NEIGHBOR_REPORT	1
+#define DOT11_RRM_CAP_PARALLEL		2
+#define DOT11_RRM_CAP_REPEATED		3
+#define DOT11_RRM_CAP_BCN_PASSIVE	4
+#define DOT11_RRM_CAP_BCN_ACTIVE	5
+#define DOT11_RRM_CAP_BCN_TABLE		6
+#define DOT11_RRM_CAP_BCN_REP_COND	7
+#define DOT11_RRM_CAP_AP_CHANREP	16
+
+#define DOT11_RM_ACTION_RM_REQ		0
+#define DOT11_RM_ACTION_RM_REP		1
+#define DOT11_RM_ACTION_LM_REQ		2
+#define DOT11_RM_ACTION_LM_REP		3
+#define DOT11_RM_ACTION_NR_REQ		4
+#define DOT11_RM_ACTION_NR_REP		5
+
+BWL_PRE_PACKED_STRUCT struct dot11_rm_action {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	uint8 data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rm_action dot11_rm_action_t;
+#define DOT11_RM_ACTION_LEN 3
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	uint16 reps;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq dot11_rmreq_t;
+#define DOT11_RMREQ_LEN	5
+
+BWL_PRE_PACKED_STRUCT struct dot11_rm_ie {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rm_ie dot11_rm_ie_t;
+#define DOT11_RM_IE_LEN	5
+
+#define DOT11_RMREQ_MODE_PARALLEL	1
+#define DOT11_RMREQ_MODE_ENABLE		2
+#define DOT11_RMREQ_MODE_REQUEST	4
+#define DOT11_RMREQ_MODE_REPORT		8
+#define DOT11_RMREQ_MODE_DURMAND	0x10
+
+#define DOT11_RMREP_MODE_LATE		1
+#define DOT11_RMREP_MODE_INCAPABLE	2
+#define DOT11_RMREP_MODE_REFUSED	4
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmreq_bcn {
+	uint8 id;
+	uint8 len;
+	uint8 token;
+	uint8 mode;
+	uint8 type;
+	uint8 reg;
+	uint8 channel;
+	uint16 interval;
+	uint16 duration;
+	uint8 bcn_mode;
+	struct ether_addr bssid;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmreq_bcn dot11_rmreq_bcn_t;
+#define DOT11_RMREQ_BCN_LEN	18
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_bcn {
+	uint8 reg;
+	uint8 channel;
+	uint32 starttime[2];
+	uint16 duration;
+	uint8 frame_info;
+	uint8 rcpi;
+	uint8 rsni;
+	struct ether_addr bssid;
+	uint8 antenna_id;
+	uint32 parent_tsf;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_bcn dot11_rmrep_bcn_t;
+#define DOT11_RMREP_BCN_LEN	26
+
+#define DOT11_RMREQ_BCN_PASSIVE	0
+#define DOT11_RMREQ_BCN_ACTIVE	1
+#define DOT11_RMREQ_BCN_TABLE	2
+
+#define DOT11_RMREQ_BCN_SSID_ID	0
+#define DOT11_RMREQ_BCN_REPINFO_ID	1
+#define DOT11_RMREQ_BCN_REPDET_ID	2
+#define DOT11_RMREQ_BCN_REQUEST_ID	10
+#define DOT11_RMREQ_BCN_APCHREP_ID	51
+
+#define DOT11_RMREQ_BCN_REPDET_FIXED	0
+#define DOT11_RMREQ_BCN_REPDET_REQUEST	1
+#define DOT11_RMREQ_BCN_REPDET_ALL	2
+
+#define DOT11_RMREP_BCN_FRM_BODY	1
+
+BWL_PRE_PACKED_STRUCT struct dot11_rmrep_nbr {
+	struct ether_addr bssid;
+	uint32 bssid_info;
+	uint8 reg;
+	uint8 channel;
+	uint8 phytype;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_rmrep_nbr dot11_rmrep_nbr_t;
+#define DOT11_RMREP_NBR_LEN	13
+
+#define DOT11_BSSTYPE_INFRASTRUCTURE		0
+#define DOT11_BSSTYPE_INDEPENDENT		1
+#define DOT11_BSSTYPE_ANY			2
+#define DOT11_SCANTYPE_ACTIVE			0
+#define DOT11_SCANTYPE_PASSIVE			1
+
+BWL_PRE_PACKED_STRUCT struct dot11_lmreq {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	uint8 txpwr;
+	uint8 maxtxpwr;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_lmreq dot11_lmreq_t;
+#define DOT11_LMREQ_LEN	5
+
+BWL_PRE_PACKED_STRUCT struct dot11_lmrep {
+	uint8 category;
+	uint8 action;
+	uint8 token;
+	dot11_tpc_rep_t tpc;
+	uint8 rxant;
+	uint8 txant;
+	uint8 rcpi;
+	uint8 rsni;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_lmrep dot11_lmrep_t;
+#define DOT11_LMREP_LEN	11
+
+#define PREN_PREAMBLE		24
+#define PREN_MM_EXT		12
+#define PREN_PREAMBLE_EXT	4
+
+#define RIFS_11N_TIME		2
+
+#define APHY_SLOT_TIME		9
+#define APHY_SIFS_TIME		16
+#define APHY_DIFS_TIME		(APHY_SIFS_TIME + (2 * APHY_SLOT_TIME))
+#define APHY_PREAMBLE_TIME	16
+#define APHY_SIGNAL_TIME	4
+#define APHY_SYMBOL_TIME	4
+#define APHY_SERVICE_NBITS	16
+#define APHY_TAIL_NBITS		6
+#define	APHY_CWMIN		15
+
+#define BPHY_SLOT_TIME		20
+#define BPHY_SIFS_TIME		10
+#define BPHY_DIFS_TIME		50
+#define BPHY_PLCP_TIME		192
+#define BPHY_PLCP_SHORT_TIME	96
+#define	BPHY_CWMIN		31
+
+#define DOT11_OFDM_SIGNAL_EXTENSION	6
+
+#define PHY_CWMAX		1023
+
+#define	DOT11_MAXNUMFRAGS	16
+
+typedef struct d11cnt {
+	uint32 txfrag;
+	uint32 txmulti;
+	uint32 txfail;
+	uint32 txretry;
+	uint32 txretrie;
+	uint32 rxdup;
+	uint32 txrts;
+	uint32 txnocts;
+	uint32 txnoack;
+	uint32 rxfrag;
+	uint32 rxmulti;
+	uint32 rxcrc;
+	uint32 txfrmsnt;
+	uint32 rxundec;
+} d11cnt_t;
+
+#define AB_GUARDCOUNT	10
+
+BWL_PRE_PACKED_STRUCT struct vndr_ie {
+	uchar id;
+	uchar len;
+	uchar oui[3];
+	uchar data[1];
+} BWL_POST_PACKED_STRUCT;
+typedef struct vndr_ie vndr_ie_t;
+
+#define VNDR_IE_HDR_LEN		2
+#define VNDR_IE_MIN_LEN		3
+#define VNDR_IE_MAX_LEN		256
+
+#define MCSSET_LEN	16
+#define MAX_MCS_NUM	(128)
+
+BWL_PRE_PACKED_STRUCT struct ht_cap_ie {
+	uint16 cap;
+	uint8 params;
+	uint8 supp_mcs[MCSSET_LEN];
+	uint16 ext_htcap;
+	uint32 txbf_cap;
+	uint8 as_cap;
+} BWL_POST_PACKED_STRUCT;
+typedef struct ht_cap_ie ht_cap_ie_t;
+
+#define HT_CAP_IE_LEN		26
+#define HT_CAP_IE_TYPE		51
+
+#define HT_CAP_LDPC_CODING	0x0001
+#define HT_CAP_40MHZ		0x0002
+#define HT_CAP_MIMO_PS_MASK	0x000C
+#define HT_CAP_MIMO_PS_SHIFT	0x0002
+#define HT_CAP_MIMO_PS_OFF	0x0003
+#define HT_CAP_MIMO_PS_RTS	0x0001
+#define HT_CAP_MIMO_PS_ON	0x0000
+#define HT_CAP_GF		0x0010
+#define HT_CAP_SHORT_GI_20	0x0020
+#define HT_CAP_SHORT_GI_40	0x0040
+#define HT_CAP_TX_STBC		0x0080
+#define HT_CAP_RX_STBC_MASK	0x0300
+#define HT_CAP_RX_STBC_SHIFT	8
+#define HT_CAP_DELAYED_BA	0x0400
+#define HT_CAP_MAX_AMSDU	0x0800
+#define HT_CAP_DSSS_CCK	0x1000
+#define HT_CAP_PSMP		0x2000
+#define HT_CAP_40MHZ_INTOLERANT 0x4000
+#define HT_CAP_LSIG_TXOP	0x8000
+
+#define HT_CAP_RX_STBC_NO		0x0
+#define HT_CAP_RX_STBC_ONE_STREAM	0x1
+#define HT_CAP_RX_STBC_TWO_STREAM	0x2
+#define HT_CAP_RX_STBC_THREE_STREAM	0x3
+
+#define HT_MAX_AMSDU		7935
+#define HT_MIN_AMSDU		3835
+
+#define HT_PARAMS_RX_FACTOR_MASK	0x03
+#define HT_PARAMS_DENSITY_MASK		0x1C
+#define HT_PARAMS_DENSITY_SHIFT	2
+
+#define AMPDU_MAX_MPDU_DENSITY	7
+#define AMPDU_RX_FACTOR_8K	0
+#define AMPDU_RX_FACTOR_16K	1
+#define AMPDU_RX_FACTOR_32K	2
+#define AMPDU_RX_FACTOR_64K	3
+#define AMPDU_RX_FACTOR_BASE	8*1024
+
+#define AMPDU_DELIMITER_LEN	4
+
+BWL_PRE_PACKED_STRUCT struct ht_add_ie {
+	uint8 ctl_ch;
+	uint8 byte1;
+	uint16 opmode;
+	uint16 misc_bits;
+	uint8 basic_mcs[MCSSET_LEN];
+} BWL_POST_PACKED_STRUCT;
+typedef struct ht_add_ie ht_add_ie_t;
+
+#define HT_ADD_IE_LEN	22
+#define HT_ADD_IE_TYPE	52
+
+#define HT_BW_ANY		0x04
+#define HT_RIFS_PERMITTED     	0x08
+
+#define HT_OPMODE_MASK	        0x0003
+#define HT_OPMODE_SHIFT		0
+#define HT_OPMODE_PURE		0x0000
+#define HT_OPMODE_OPTIONAL	0x0001
+#define HT_OPMODE_HT20IN40	0x0002
+#define HT_OPMODE_MIXED	0x0003
+#define HT_OPMODE_NONGF	0x0004
+#define DOT11N_TXBURST		0x0008
+#define DOT11N_OBSS_NONHT	0x0010
+
+#define HT_BASIC_STBC_MCS	0x007f
+#define HT_DUAL_STBC_PROT	0x0080
+#define HT_SECOND_BCN		0x0100
+#define HT_LSIG_TXOP		0x0200
+#define HT_PCO_ACTIVE		0x0400
+#define HT_PCO_PHASE		0x0800
+
+#define DOT11N_2G_TXBURST_LIMIT	6160
+#define DOT11N_5G_TXBURST_LIMIT	3080
+
+#define GET_HT_OPMODE(add_ie)	\
+	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK)  >> HT_OPMODE_SHIFT)
+#define HT_MIXEDMODE_PRESENT(add_ie)	\
+	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_MIXED)
+#define HT_HT20_PRESENT(add_ie)	\
+	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_HT20IN40)
+#define HT_OPTIONAL_PRESENT(add_ie)	\
+	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_MASK) == HT_OPMODE_OPTIONAL)
+#define HT_USE_PROTECTION(add_ie)	\
+	(HT_HT20_PRESENT((add_ie)) || HT_MIXEDMODE_PRESENT((add_ie)))
+#define HT_NONGF_PRESENT(add_ie)	\
+	((ltoh16_ua(&add_ie->opmode) & HT_OPMODE_NONGF) == HT_OPMODE_NONGF)
+#define DOT11N_TXBURST_PRESENT(add_ie)	\
+	((ltoh16_ua(&add_ie->opmode) & DOT11N_TXBURST) == DOT11N_TXBURST)
+#define DOT11N_OBSS_NONHT_PRESENT(add_ie)	\
+	((ltoh16_ua(&add_ie->opmode) & DOT11N_OBSS_NONHT) == DOT11N_OBSS_NONHT)
+
+BWL_PRE_PACKED_STRUCT struct obss_params {
+	uint16 passive_dwell;
+	uint16 active_dwell;
+	uint16 bss_widthscan_interval;
+	uint16 passive_total;
+	uint16 active_total;
+	uint16 chanwidth_transition_dly;
+	uint16 activity_threshold;
+} BWL_POST_PACKED_STRUCT;
+typedef struct obss_params obss_params_t;
+
+BWL_PRE_PACKED_STRUCT struct dot11_obss_ie {
+	uint8 id;
+	uint8 len;
+	obss_params_t obss_params;
+} BWL_POST_PACKED_STRUCT;
+typedef struct dot11_obss_ie dot11_obss_ie_t;
+#define DOT11_OBSS_SCAN_IE_LEN	sizeof(obss_params_t)
+
+#define HT_CTRL_LA_TRQ		0x00000002
+#define HT_CTRL_LA_MAI		0x0000003C
+#define HT_CTRL_LA_MAI_SHIFT	2
+#define HT_CTRL_LA_MAI_MRQ	0x00000004
+#define HT_CTRL_LA_MAI_MSI	0x00000038
+#define HT_CTRL_LA_MFSI		0x000001C0
+#define HT_CTRL_LA_MFSI_SHIFT	6
+#define HT_CTRL_LA_MFB_ASELC	0x0000FE00
+#define HT_CTRL_LA_MFB_ASELC_SH	9
+#define HT_CTRL_LA_ASELC_CMD	0x00000C00
+#define HT_CTRL_LA_ASELC_DATA	0x0000F000
+#define HT_CTRL_CAL_POS		0x00030000
+#define HT_CTRL_CAL_SEQ		0x000C0000
+#define HT_CTRL_CSI_STEERING	0x00C00000
+#define HT_CTRL_CSI_STEER_SHIFT	22
+#define HT_CTRL_CSI_STEER_NFB	0
+#define HT_CTRL_CSI_STEER_CSI	1
+#define HT_CTRL_CSI_STEER_NCOM	2
+#define HT_CTRL_CSI_STEER_COM	3
+#define HT_CTRL_NDP_ANNOUNCE	0x01000000
+#define HT_CTRL_AC_CONSTRAINT	0x40000000
+#define HT_CTRL_RDG_MOREPPDU	0x80000000
+
+#define HT_OPMODE_OPTIONAL	0x0001
+#define HT_OPMODE_HT20IN40	0x0002
+#define HT_OPMODE_MIXED	0x0003
+#define HT_OPMODE_NONGF	0x0004
+#define DOT11N_TXBURST		0x0008
+#define DOT11N_OBSS_NONHT	0x0010
+
+#define WPA_VERSION		1
+#define WPA_OUI			"\x00\x50\xF2"
+
+#define WPA2_VERSION		1
+#define WPA2_VERSION_LEN	2
+#define WPA2_OUI		"\x00\x0F\xAC"
+
+#define WPA_OUI_LEN	3
+
+#define WFA_OUI			"\x00\x50\xF2"
+#define WFA_OUI_LEN	3
+
+#define WFA_OUI_TYPE_WPA	1
+#define WFA_OUI_TYPE_WPS	4
+#define WFA_OUI_TYPE_P2P	9
+
+#define RSN_AKM_NONE		0
+#define RSN_AKM_UNSPECIFIED	1
+#define RSN_AKM_PSK		2
+
+#define DOT11_MAX_DEFAULT_KEYS	4
+#define DOT11_MAX_KEY_SIZE	32
+#define DOT11_MAX_IV_SIZE	16
+#define DOT11_EXT_IV_FLAG	(1<<5)
+#define DOT11_WPA_KEY_RSC_LEN   8
+
+#define WEP1_KEY_SIZE		5
+#define WEP1_KEY_HEX_SIZE	10
+#define WEP128_KEY_SIZE		13
+#define WEP128_KEY_HEX_SIZE	26
+#define TKIP_MIC_SIZE		8
+#define TKIP_EOM_SIZE		7
+#define TKIP_EOM_FLAG		0x5a
+#define TKIP_KEY_SIZE		32
+#define TKIP_MIC_AUTH_TX	16
+#define TKIP_MIC_AUTH_RX	24
+#define TKIP_MIC_SUP_RX		TKIP_MIC_AUTH_TX
+#define TKIP_MIC_SUP_TX		TKIP_MIC_AUTH_RX
+#define AES_KEY_SIZE		16
+#define AES_MIC_SIZE		8
+
+#define WCN_OUI			"\x00\x50\xf2"
+#define WCN_TYPE		4
+
+#include <packed_section_end.h>
+
+#endif				/* _802_11_H_ */
diff --git a/drivers/staging/brcm80211/include/proto/802.11e.h b/drivers/staging/brcm80211/include/proto/802.11e.h
new file mode 100644
index 0000000..f331e6d
--- /dev/null
+++ b/drivers/staging/brcm80211/include/proto/802.11e.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _802_11e_H_
+#define _802_11e_H_
+
+#ifndef _TYPEDEFS_H_
+#include <typedefs.h>
+#endif
+
+#include <packed_section_start.h>
+
+#define WME_TSPEC_HDR_LEN           2
+#define WME_TSPEC_BODY_OFF          2
+
+#define WME_CATEGORY_CODE_OFFSET	0
+#define WME_ACTION_CODE_OFFSET		1
+#define WME_TOKEN_CODE_OFFSET		2
+#define WME_STATUS_CODE_OFFSET		3
+
+BWL_PRE_PACKED_STRUCT struct tsinfo {
+	uint8 octets[3];
+} BWL_POST_PACKED_STRUCT;
+
+typedef struct tsinfo tsinfo_t;
+
+typedef BWL_PRE_PACKED_STRUCT struct tspec {
+	uint8 oui[DOT11_OUI_LEN];
+	uint8 type;
+	uint8 subtype;
+	uint8 version;
+	tsinfo_t tsinfo;
+	uint16 nom_msdu_size;
+	uint16 max_msdu_size;
+	uint32 min_srv_interval;
+	uint32 max_srv_interval;
+	uint32 inactivity_interval;
+	uint32 suspension_interval;
+	uint32 srv_start_time;
+	uint32 min_data_rate;
+	uint32 mean_data_rate;
+	uint32 peak_data_rate;
+	uint32 max_burst_size;
+	uint32 delay_bound;
+	uint32 min_phy_rate;
+	uint16 surplus_bw;
+	uint16 medium_time;
+} BWL_POST_PACKED_STRUCT tspec_t;
+
+#define WME_TSPEC_LEN	(sizeof(tspec_t))
+
+#define TS_INFO_TID_SHIFT		1
+#define TS_INFO_TID_MASK		(0xf << TS_INFO_TID_SHIFT)
+#define TS_INFO_CONTENTION_SHIFT	7
+#define TS_INFO_CONTENTION_MASK		(0x1 << TS_INFO_CONTENTION_SHIFT)
+#define TS_INFO_DIRECTION_SHIFT		5
+#define TS_INFO_DIRECTION_MASK		(0x3 << TS_INFO_DIRECTION_SHIFT)
+#define TS_INFO_PSB_SHIFT		2
+#define TS_INFO_PSB_MASK		(1 << TS_INFO_PSB_SHIFT)
+#define TS_INFO_UPLINK			(0 << TS_INFO_DIRECTION_SHIFT)
+#define TS_INFO_DOWNLINK		(1 << TS_INFO_DIRECTION_SHIFT)
+#define TS_INFO_BIDIRECTIONAL		(3 << TS_INFO_DIRECTION_SHIFT)
+#define TS_INFO_USER_PRIO_SHIFT		3
+#define TS_INFO_USER_PRIO_MASK		(0x7 << TS_INFO_USER_PRIO_SHIFT)
+
+#define WLC_CAC_GET_TID(pt)	((((pt).octets[0]) & \
+	TS_INFO_TID_MASK) >> TS_INFO_TID_SHIFT)
+#define WLC_CAC_GET_DIR(pt)	((((pt).octets[0]) & \
+	TS_INFO_DIRECTION_MASK) >> TS_INFO_DIRECTION_SHIFT)
+#define WLC_CAC_GET_PSB(pt)	((((pt).octets[1]) & \
+	TS_INFO_PSB_MASK) >> TS_INFO_PSB_SHIFT)
+#define WLC_CAC_GET_USER_PRIO(pt)	((((pt).octets[1]) & \
+	TS_INFO_USER_PRIO_MASK) >> TS_INFO_USER_PRIO_SHIFT)
+
+#define WLC_CAC_SET_TID(pt, id)	((((pt).octets[0]) & (~TS_INFO_TID_MASK)) | \
+	((id) << TS_INFO_TID_SHIFT))
+#define WLC_CAC_SET_USER_PRIO(pt, prio)	((((pt).octets[0]) & \
+	(~TS_INFO_USER_PRIO_MASK)) | ((prio) << TS_INFO_USER_PRIO_SHIFT))
+
+#define QBSS_LOAD_IE_LEN		5
+#define QBSS_LOAD_AAC_OFF		3
+
+#define CAC_ADDTS_RESP_TIMEOUT		300
+
+#define DOT11E_STATUS_ADMISSION_ACCEPTED	0
+#define DOT11E_STATUS_ADDTS_INVALID_PARAM	1
+#define DOT11E_STATUS_ADDTS_REFUSED_NSBW	3
+#define DOT11E_STATUS_ADDTS_REFUSED_AWHILE	47
+
+#define DOT11E_STATUS_QSTA_LEAVE_QBSS		36
+#define DOT11E_STATUS_END_TS			37
+#define DOT11E_STATUS_UNKNOWN_TS		38
+#define DOT11E_STATUS_QSTA_REQ_TIMEOUT		39
+
+#include <packed_section_end.h>
+
+#endif				/* _802_11e_H_ */
diff --git a/drivers/staging/brcm80211/include/proto/802.1d.h b/drivers/staging/brcm80211/include/proto/802.1d.h
new file mode 100644
index 0000000..9802d87
--- /dev/null
+++ b/drivers/staging/brcm80211/include/proto/802.1d.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _802_1_D_
+#define _802_1_D_
+
+#define	PRIO_8021D_NONE		2
+#define	PRIO_8021D_BK		1
+#define	PRIO_8021D_BE		0
+#define	PRIO_8021D_EE		3
+#define	PRIO_8021D_CL		4
+#define	PRIO_8021D_VI		5
+#define	PRIO_8021D_VO		6
+#define	PRIO_8021D_NC		7
+#define	MAXPRIO			7
+#define NUMPRIO			(MAXPRIO + 1)
+
+#define ALLPRIO		-1
+
+#define PRIO2PREC(prio) \
+	(((prio) == PRIO_8021D_NONE || (prio) == PRIO_8021D_BE) ? \
+	((prio^2)) : (prio))
+
+#endif				/* _802_1_D_ */
diff --git a/drivers/staging/brcm80211/include/proto/bcmevent.h b/drivers/staging/brcm80211/include/proto/bcmevent.h
new file mode 100644
index 0000000..37257f9
--- /dev/null
+++ b/drivers/staging/brcm80211/include/proto/bcmevent.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _BCMEVENT_H_
+#define _BCMEVENT_H_
+
+#ifndef _TYPEDEFS_H_
+#include <typedefs.h>
+#endif
+
+#include <packed_section_start.h>
+
+#define BCM_EVENT_MSG_VERSION		1
+#define BCM_MSG_IFNAME_MAX		16
+
+#define WLC_EVENT_MSG_LINK		0x01
+#define WLC_EVENT_MSG_FLUSHTXQ		0x02
+#define WLC_EVENT_MSG_GROUP		0x04
+
+typedef BWL_PRE_PACKED_STRUCT struct {
+	uint16 version;
+	uint16 flags;
+	uint32 event_type;
+	uint32 status;
+	uint32 reason;
+	uint32 auth_type;
+	uint32 datalen;
+	struct ether_addr addr;
+	char ifname[BCM_MSG_IFNAME_MAX];
+} BWL_POST_PACKED_STRUCT wl_event_msg_t;
+
+#define BCM_MSG_LEN	(sizeof(bcm_event_t) - sizeof(bcmeth_hdr_t) - \
+	sizeof(struct ether_header))
+
+#define WLC_E_SET_SSID		0
+#define WLC_E_JOIN		1
+#define WLC_E_START		2
+#define WLC_E_AUTH		3
+#define WLC_E_AUTH_IND		4
+#define WLC_E_DEAUTH		5
+#define WLC_E_DEAUTH_IND	6
+#define WLC_E_ASSOC		7
+#define WLC_E_ASSOC_IND		8
+#define WLC_E_REASSOC		9
+#define WLC_E_REASSOC_IND	10
+#define WLC_E_DISASSOC		11
+#define WLC_E_DISASSOC_IND	12
+#define WLC_E_QUIET_START	13
+#define WLC_E_QUIET_END		14
+#define WLC_E_BEACON_RX		15
+#define WLC_E_LINK		16
+#define WLC_E_MIC_ERROR		17
+#define WLC_E_NDIS_LINK		18
+#define WLC_E_ROAM		19
+#define WLC_E_TXFAIL		20
+#define WLC_E_PMKID_CACHE	21
+#define WLC_E_RETROGRADE_TSF	22
+#define WLC_E_PRUNE		23
+#define WLC_E_AUTOAUTH		24
+#define WLC_E_EAPOL_MSG		25
+#define WLC_E_SCAN_COMPLETE	26
+#define WLC_E_ADDTS_IND		27
+#define WLC_E_DELTS_IND		28
+#define WLC_E_BCNSENT_IND	29
+#define WLC_E_BCNRX_MSG		30
+#define WLC_E_BCNLOST_MSG	31
+#define WLC_E_ROAM_PREP		32
+#define WLC_E_PFN_NET_FOUND	33
+#define WLC_E_PFN_NET_LOST	34
+#define WLC_E_RESET_COMPLETE	35
+#define WLC_E_JOIN_START	36
+#define WLC_E_ROAM_START	37
+#define WLC_E_ASSOC_START	38
+#define WLC_E_IBSS_ASSOC	39
+#define WLC_E_RADIO		40
+#define WLC_E_PSM_WATCHDOG	41
+#define WLC_E_PROBREQ_MSG       44
+#define WLC_E_SCAN_CONFIRM_IND  45
+#define WLC_E_PSK_SUP		46
+#define WLC_E_COUNTRY_CODE_CHANGED 47
+#define	WLC_E_EXCEEDED_MEDIUM_TIME 48
+#define WLC_E_ICV_ERROR		49
+#define WLC_E_UNICAST_DECODE_ERROR 50
+#define WLC_E_MULTICAST_DECODE_ERROR 51
+#define WLC_E_TRACE		52
+#define WLC_E_IF		54
+#define WLC_E_RSSI		56
+#define WLC_E_PFN_SCAN_COMPLETE	57
+#define WLC_E_EXTLOG_MSG	58
+#define WLC_E_ACTION_FRAME      59
+#define WLC_E_ACTION_FRAME_COMPLETE 60
+#define WLC_E_PRE_ASSOC_IND	61
+#define WLC_E_PRE_REASSOC_IND	62
+#define WLC_E_CHANNEL_ADOPTED	63
+#define WLC_E_AP_STARTED	64
+#define WLC_E_DFS_AP_STOP	65
+#define WLC_E_DFS_AP_RESUME	66
+#define WLC_E_RESERVED1		67
+#define WLC_E_RESERVED2		68
+#define WLC_E_ESCAN_RESULT 	69
+#define WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE 	70
+#define WLC_E_DCS_REQUEST 73
+
+#define WLC_E_FIFO_CREDIT_MAP	74
+
+#define WLC_E_LAST		75
+
+typedef struct {
+	uint event;
+	const char *name;
+} bcmevent_name_t;
+
+extern const bcmevent_name_t bcmevent_names[];
+extern const int bcmevent_names_size;
+
+#define WLC_E_STATUS_SUCCESS		0
+#define WLC_E_STATUS_FAIL		1
+#define WLC_E_STATUS_TIMEOUT		2
+#define WLC_E_STATUS_NO_NETWORKS	3
+#define WLC_E_STATUS_ABORT		4
+#define WLC_E_STATUS_NO_ACK		5
+#define WLC_E_STATUS_UNSOLICITED	6
+#define WLC_E_STATUS_ATTEMPT		7
+#define WLC_E_STATUS_PARTIAL		8
+#define WLC_E_STATUS_NEWSCAN		9
+#define WLC_E_STATUS_NEWASSOC		10
+#define WLC_E_STATUS_11HQUIET		11
+#define WLC_E_STATUS_SUPPRESS		12
+#define WLC_E_STATUS_NOCHANS		13
+#define WLC_E_STATUS_CS_ABORT		15
+#define WLC_E_STATUS_ERROR		16
+
+#define WLC_E_REASON_INITIAL_ASSOC	0
+#define WLC_E_REASON_LOW_RSSI		1
+#define WLC_E_REASON_DEAUTH		2
+#define WLC_E_REASON_DISASSOC		3
+#define WLC_E_REASON_BCNS_LOST		4
+#define WLC_E_REASON_MINTXRATE		9
+#define WLC_E_REASON_TXFAIL		10
+
+#define WLC_E_REASON_FAST_ROAM_FAILED	5
+#define WLC_E_REASON_DIRECTED_ROAM	6
+#define WLC_E_REASON_TSPEC_REJECTED	7
+#define WLC_E_REASON_BETTER_AP		8
+
+#define WLC_E_PRUNE_ENCR_MISMATCH	1
+#define WLC_E_PRUNE_BCAST_BSSID		2
+#define WLC_E_PRUNE_MAC_DENY		3
+#define WLC_E_PRUNE_MAC_NA		4
+#define WLC_E_PRUNE_REG_PASSV		5
+#define WLC_E_PRUNE_SPCT_MGMT		6
+#define WLC_E_PRUNE_RADAR		7
+#define WLC_E_RSN_MISMATCH		8
+#define WLC_E_PRUNE_NO_COMMON_RATES	9
+#define WLC_E_PRUNE_BASIC_RATES		10
+#define WLC_E_PRUNE_CIPHER_NA		12
+#define WLC_E_PRUNE_KNOWN_STA		13
+#define WLC_E_PRUNE_WDS_PEER		15
+#define WLC_E_PRUNE_QBSS_LOAD		16
+#define WLC_E_PRUNE_HOME_AP		17
+
+#define WLC_E_SUP_OTHER			0
+#define WLC_E_SUP_DECRYPT_KEY_DATA	1
+#define WLC_E_SUP_BAD_UCAST_WEP128	2
+#define WLC_E_SUP_BAD_UCAST_WEP40	3
+#define WLC_E_SUP_UNSUP_KEY_LEN		4
+#define WLC_E_SUP_PW_KEY_CIPHER		5
+#define WLC_E_SUP_MSG3_TOO_MANY_IE	6
+#define WLC_E_SUP_MSG3_IE_MISMATCH	7
+#define WLC_E_SUP_NO_INSTALL_FLAG	8
+#define WLC_E_SUP_MSG3_NO_GTK		9
+#define WLC_E_SUP_GRP_KEY_CIPHER	10
+#define WLC_E_SUP_GRP_MSG1_NO_GTK	11
+#define WLC_E_SUP_GTK_DECRYPT_FAIL	12
+#define WLC_E_SUP_SEND_FAIL		13
+#define WLC_E_SUP_DEAUTH		14
+
+typedef struct wl_event_data_if {
+	uint8 ifidx;
+	uint8 opcode;
+	uint8 reserved;
+	uint8 bssidx;
+	uint8 role;
+} wl_event_data_if_t;
+
+#define WLC_E_IF_ADD		1
+#define WLC_E_IF_DEL		2
+#define WLC_E_IF_CHANGE		3
+
+#define WLC_E_IF_ROLE_STA		0
+#define WLC_E_IF_ROLE_AP		1
+#define WLC_E_IF_ROLE_WDS		2
+
+#define WLC_E_LINK_BCN_LOSS	1
+#define WLC_E_LINK_DISASSOC	2
+#define WLC_E_LINK_ASSOC_REC	3
+#define WLC_E_LINK_BSSCFG_DIS	4
+
+#include <packed_section_end.h>
+
+#endif				/* _BCMEVENT_H_ */
diff --git a/drivers/staging/brcm80211/include/proto/ethernet.h b/drivers/staging/brcm80211/include/proto/ethernet.h
new file mode 100644
index 0000000..9d90b8d
--- /dev/null
+++ b/drivers/staging/brcm80211/include/proto/ethernet.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NET_ETHERNET_H_
+#define _NET_ETHERNET_H_
+
+#ifndef _TYPEDEFS_H_
+#include "typedefs.h"
+#endif
+#include <packed_section_start.h>
+
+#define	ETHER_ADDR_LEN		6
+#define	ETHER_TYPE_LEN		2
+#define	ETHER_CRC_LEN		4
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)
+#define	ETHER_MIN_LEN		64
+#define	ETHER_MIN_DATA		46
+#define	ETHER_MAX_LEN		1518
+#define	ETHER_MAX_DATA		1500
+
+#define ETHER_TYPE_MIN		0x0600
+#define	ETHER_TYPE_IP		0x0800
+#define ETHER_TYPE_ARP		0x0806
+#define ETHER_TYPE_8021Q	0x8100
+#define	ETHER_TYPE_BRCM		0x886c
+#define	ETHER_TYPE_802_1X	0x888e
+#define	ETHER_TYPE_802_1X_PREAUTH 0x88c7
+
+#define ETHER_DEST_OFFSET	(0 * ETHER_ADDR_LEN)
+#define ETHER_SRC_OFFSET	(1 * ETHER_ADDR_LEN)
+#define ETHER_TYPE_OFFSET	(2 * ETHER_ADDR_LEN)
+
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+#define ETHER_FILL_MCAST_ADDR_FROM_IP(ea, mgrp_ip) {		\
+		((uint8 *)ea)[0] = 0x01;			\
+		((uint8 *)ea)[1] = 0x00;			\
+		((uint8 *)ea)[2] = 0x5e;			\
+		((uint8 *)ea)[3] = ((mgrp_ip) >> 16) & 0x7f;	\
+		((uint8 *)ea)[4] = ((mgrp_ip) >>  8) & 0xff;	\
+		((uint8 *)ea)[5] = ((mgrp_ip) >>  0) & 0xff;	\
+}
+
+BWL_PRE_PACKED_STRUCT struct ether_header {
+	uint8 ether_dhost[ETHER_ADDR_LEN];
+	uint8 ether_shost[ETHER_ADDR_LEN];
+	uint16 ether_type;
+} BWL_POST_PACKED_STRUCT;
+
+BWL_PRE_PACKED_STRUCT struct ether_addr {
+	uint8 octet[ETHER_ADDR_LEN];
+} BWL_POST_PACKED_STRUCT;
+
+#define ETHER_SET_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] | 2))
+#define ETHER_IS_LOCALADDR(ea) 	(((uint8 *)(ea))[0] & 2)
+#define ETHER_CLR_LOCALADDR(ea)	(((uint8 *)(ea))[0] = \
+	(((uint8 *)(ea))[0] & 0xd))
+#define ETHER_TOGGLE_LOCALADDR(ea)	(((uint8 *)(ea))[0] = \
+	(((uint8 *)(ea))[0] ^ 2))
+
+#define ETHER_SET_UNICAST(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] & ~1))
+
+#define ETHER_ISMULTI(ea) (((const uint8 *)(ea))[0] & 1)
+
+#define	ether_cmp(a, b)	(!(((short*)a)[0] == ((short*)b)[0]) | \
+			 !(((short*)a)[1] == ((short*)b)[1]) | \
+			 !(((short*)a)[2] == ((short*)b)[2]))
+
+#define	ether_copy(s, d) { \
+		((short*)d)[0] = ((short*)s)[0]; \
+		((short*)d)[1] = ((short*)s)[1]; \
+		((short*)d)[2] = ((short*)s)[2]; }
+
+static const struct ether_addr ether_bcast = { {255, 255, 255, 255, 255, 255} };
+static const struct ether_addr ether_null = { {0, 0, 0, 0, 0, 0} };
+
+#define ETHER_ISBCAST(ea)	((((uint8 *)(ea))[0] &		\
+	((uint8 *)(ea))[1] &		\
+	((uint8 *)(ea))[2] &		\
+	((uint8 *)(ea))[3] &		\
+	((uint8 *)(ea))[4] &		\
+	((uint8 *)(ea))[5]) == 0xff)
+#define ETHER_ISNULLADDR(ea)	((((uint8 *)(ea))[0] |		\
+	((uint8 *)(ea))[1] |		\
+	((uint8 *)(ea))[2] |		\
+	((uint8 *)(ea))[3] |		\
+	((uint8 *)(ea))[4] |		\
+	((uint8 *)(ea))[5]) == 0)
+
+#define ETHER_MOVE_HDR(d, s) \
+do { \
+	struct ether_header t; \
+	t = *(struct ether_header *)(s); \
+	*(struct ether_header *)(d) = t; \
+} while (0)
+
+#include <packed_section_end.h>
+
+#endif				/* _NET_ETHERNET_H_ */
diff --git a/drivers/staging/brcm80211/include/proto/wpa.h b/drivers/staging/brcm80211/include/proto/wpa.h
new file mode 100644
index 0000000..7512e1a
--- /dev/null
+++ b/drivers/staging/brcm80211/include/proto/wpa.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _proto_wpa_h_
+#define _proto_wpa_h_
+
+#include <typedefs.h>
+#include <proto/ethernet.h>
+
+#include <packed_section_start.h>
+
+#define DOT11_RC_INVALID_WPA_IE		13
+#define DOT11_RC_MIC_FAILURE		14
+#define DOT11_RC_4WH_TIMEOUT		15
+#define DOT11_RC_GTK_UPDATE_TIMEOUT	16
+#define DOT11_RC_WPA_IE_MISMATCH	17
+#define DOT11_RC_INVALID_MC_CIPHER	18
+#define DOT11_RC_INVALID_UC_CIPHER	19
+#define DOT11_RC_INVALID_AKMP		20
+#define DOT11_RC_BAD_WPA_VERSION	21
+#define DOT11_RC_INVALID_WPA_CAP	22
+#define DOT11_RC_8021X_AUTH_FAIL	23
+
+#define WPA2_PMKID_LEN	16
+
+typedef BWL_PRE_PACKED_STRUCT struct {
+	uint8 tag;
+	uint8 length;
+	uint8 oui[3];
+	uint8 oui_type;
+	BWL_PRE_PACKED_STRUCT struct {
+		uint8 low;
+		uint8 high;
+	} BWL_POST_PACKED_STRUCT version;
+} BWL_POST_PACKED_STRUCT wpa_ie_fixed_t;
+#define WPA_IE_OUITYPE_LEN	4
+#define WPA_IE_FIXED_LEN	8
+#define WPA_IE_TAG_FIXED_LEN	6
+
+typedef BWL_PRE_PACKED_STRUCT struct {
+	uint8 tag;
+	uint8 length;
+	BWL_PRE_PACKED_STRUCT struct {
+		uint8 low;
+		uint8 high;
+	} BWL_POST_PACKED_STRUCT version;
+} BWL_POST_PACKED_STRUCT wpa_rsn_ie_fixed_t;
+#define WPA_RSN_IE_FIXED_LEN	4
+#define WPA_RSN_IE_TAG_FIXED_LEN	2
+typedef uint8 wpa_pmkid_t[WPA2_PMKID_LEN];
+
+typedef BWL_PRE_PACKED_STRUCT struct {
+	uint8 oui[3];
+	uint8 type;
+} BWL_POST_PACKED_STRUCT wpa_suite_t, wpa_suite_mcast_t;
+#define WPA_SUITE_LEN	4
+
+typedef BWL_PRE_PACKED_STRUCT struct {
+	BWL_PRE_PACKED_STRUCT struct {
+		uint8 low;
+		uint8 high;
+	} BWL_POST_PACKED_STRUCT count;
+	wpa_suite_t list[1];
+} BWL_POST_PACKED_STRUCT wpa_suite_ucast_t, wpa_suite_auth_key_mgmt_t;
+#define WPA_IE_SUITE_COUNT_LEN	2
+typedef BWL_PRE_PACKED_STRUCT struct {
+	BWL_PRE_PACKED_STRUCT struct {
+		uint8 low;
+		uint8 high;
+	} BWL_POST_PACKED_STRUCT count;
+	wpa_pmkid_t list[1];
+} BWL_POST_PACKED_STRUCT wpa_pmkid_list_t;
+
+#define WPA_CIPHER_NONE		0
+#define WPA_CIPHER_WEP_40	1
+#define WPA_CIPHER_TKIP		2
+#define WPA_CIPHER_AES_OCB	3
+#define WPA_CIPHER_AES_CCM	4
+#define WPA_CIPHER_WEP_104	5
+
+#define IS_WPA_CIPHER(cipher)	((cipher) == WPA_CIPHER_NONE || \
+				 (cipher) == WPA_CIPHER_WEP_40 || \
+				 (cipher) == WPA_CIPHER_WEP_104 || \
+				 (cipher) == WPA_CIPHER_TKIP || \
+				 (cipher) == WPA_CIPHER_AES_OCB || \
+				 (cipher) == WPA_CIPHER_AES_CCM)
+
+#define WPA_TKIP_CM_DETECT	60
+#define WPA_TKIP_CM_BLOCK	60
+
+#define RSN_CAP_LEN		2
+
+#define RSN_CAP_PREAUTH			0x0001
+#define RSN_CAP_NOPAIRWISE		0x0002
+#define RSN_CAP_PTK_REPLAY_CNTR_MASK	0x000C
+#define RSN_CAP_PTK_REPLAY_CNTR_SHIFT	2
+#define RSN_CAP_GTK_REPLAY_CNTR_MASK	0x0030
+#define RSN_CAP_GTK_REPLAY_CNTR_SHIFT	4
+#define RSN_CAP_1_REPLAY_CNTR		0
+#define RSN_CAP_2_REPLAY_CNTRS		1
+#define RSN_CAP_4_REPLAY_CNTRS		2
+#define RSN_CAP_16_REPLAY_CNTRS		3
+
+#define WPA_CAP_4_REPLAY_CNTRS		RSN_CAP_4_REPLAY_CNTRS
+#define WPA_CAP_16_REPLAY_CNTRS		RSN_CAP_16_REPLAY_CNTRS
+#define WPA_CAP_REPLAY_CNTR_SHIFT	RSN_CAP_PTK_REPLAY_CNTR_SHIFT
+#define WPA_CAP_REPLAY_CNTR_MASK	RSN_CAP_PTK_REPLAY_CNTR_MASK
+
+#define WPA_CAP_LEN	RSN_CAP_LEN
+
+#define	WPA_CAP_WPA2_PREAUTH		RSN_CAP_PREAUTH
+
+#include <packed_section_end.h>
+
+#endif				/* _proto_wpa_h_ */
diff --git a/drivers/staging/brcm80211/include/qmath.h b/drivers/staging/brcm80211/include/qmath.h
new file mode 100644
index 0000000..594fb02
--- /dev/null
+++ b/drivers/staging/brcm80211/include/qmath.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __QMATH_H__
+#define __QMATH_H__
+
+#include <typedefs.h>
+
+int16 qm_sat32(int32 op);
+
+int32 qm_mul321616(int16 op1, int16 op2);
+
+int16 qm_mul16(int16 op1, int16 op2);
+
+int32 qm_muls321616(int16 op1, int16 op2);
+
+uint16 qm_mulu16(uint16 op1, uint16 op2);
+
+int16 qm_muls16(int16 op1, int16 op2);
+
+int32 qm_add32(int32 op1, int32 op2);
+
+int16 qm_add16(int16 op1, int16 op2);
+
+int16 qm_sub16(int16 op1, int16 op2);
+
+int32 qm_sub32(int32 op1, int32 op2);
+
+int32 qm_mac321616(int32 acc, int16 op1, int16 op2);
+
+int32 qm_shl32(int32 op, int shift);
+
+int32 qm_shr32(int32 op, int shift);
+
+int16 qm_shl16(int16 op, int shift);
+
+int16 qm_shr16(int16 op, int shift);
+
+int16 qm_norm16(int16 op);
+
+int16 qm_norm32(int32 op);
+
+int16 qm_div_s(int16 num, int16 denom);
+
+int16 qm_abs16(int16 op);
+
+int16 qm_div16(int16 num, int16 denom, int16 * qQuotient);
+
+int32 qm_abs32(int32 op);
+
+int16 qm_div163232(int32 num, int32 denom, int16 * qquotient);
+
+int32 qm_mul323216(int32 op1, int16 op2);
+
+int32 qm_mulsu321616(int16 op1, uint16 op2);
+
+int32 qm_muls323216(int32 op1, int16 op2);
+
+int32 qm_mul32(int32 a, int32 b);
+
+int32 qm_muls32(int32 a, int32 b);
+
+void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N);
+
+void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult);
+
+#endif				/* #ifndef __QMATH_H__ */
diff --git a/drivers/staging/brcm80211/include/rpc_osl.h b/drivers/staging/brcm80211/include/rpc_osl.h
new file mode 100644
index 0000000..845808e
--- /dev/null
+++ b/drivers/staging/brcm80211/include/rpc_osl.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _rpcosl_h_
+#define _rpcosl_h_
+
+typedef struct rpc_osl rpc_osl_t;
+extern rpc_osl_t *rpc_osl_attach(osl_t * osh);
+extern void rpc_osl_detach(rpc_osl_t * rpc_osh);
+
+#define RPC_OSL_LOCK(rpc_osh) rpc_osl_lock((rpc_osh))
+#define RPC_OSL_UNLOCK(rpc_osh) rpc_osl_unlock((rpc_osh))
+#define RPC_OSL_WAIT(rpc_osh, to, ptimedout)	rpc_osl_wait((rpc_osh), (to), (ptimedout))
+#define RPC_OSL_WAKE(rpc_osh)			rpc_osl_wake((rpc_osh))
+extern void rpc_osl_lock(rpc_osl_t * rpc_osh);
+extern void rpc_osl_unlock(rpc_osl_t * rpc_osh);
+extern int rpc_osl_wait(rpc_osl_t * rpc_osh, uint ms, bool * ptimedout);
+extern void rpc_osl_wake(rpc_osl_t * rpc_osh);
+
+#endif				/* _rpcosl_h_ */
diff --git a/drivers/staging/brcm80211/include/sbchipc.h b/drivers/staging/brcm80211/include/sbchipc.h
new file mode 100644
index 0000000..eb765a9
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbchipc.h
@@ -0,0 +1,1588 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SBCHIPC_H
+#define	_SBCHIPC_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+typedef volatile struct {
+	uint32 chipid;		/* 0x0 */
+	uint32 capabilities;
+	uint32 corecontrol;	/* corerev >= 1 */
+	uint32 bist;
+
+	/* OTP */
+	uint32 otpstatus;	/* 0x10, corerev >= 10 */
+	uint32 otpcontrol;
+	uint32 otpprog;
+	uint32 otplayout;	/* corerev >= 23 */
+
+	/* Interrupt control */
+	uint32 intstatus;	/* 0x20 */
+	uint32 intmask;
+
+	/* Chip specific regs */
+	uint32 chipcontrol;	/* 0x28, rev >= 11 */
+	uint32 chipstatus;	/* 0x2c, rev >= 11 */
+
+	/* Jtag Master */
+	uint32 jtagcmd;		/* 0x30, rev >= 10 */
+	uint32 jtagir;
+	uint32 jtagdr;
+	uint32 jtagctrl;
+
+	/* serial flash interface registers */
+	uint32 flashcontrol;	/* 0x40 */
+	uint32 flashaddress;
+	uint32 flashdata;
+	uint32 PAD[1];
+
+	/* Silicon backplane configuration broadcast control */
+	uint32 broadcastaddress;	/* 0x50 */
+	uint32 broadcastdata;
+
+	/* gpio - cleared only by power-on-reset */
+	uint32 gpiopullup;	/* 0x58, corerev >= 20 */
+	uint32 gpiopulldown;	/* 0x5c, corerev >= 20 */
+	uint32 gpioin;		/* 0x60 */
+	uint32 gpioout;		/* 0x64 */
+	uint32 gpioouten;	/* 0x68 */
+	uint32 gpiocontrol;	/* 0x6C */
+	uint32 gpiointpolarity;	/* 0x70 */
+	uint32 gpiointmask;	/* 0x74 */
+
+	/* GPIO events corerev >= 11 */
+	uint32 gpioevent;
+	uint32 gpioeventintmask;
+
+	/* Watchdog timer */
+	uint32 watchdog;	/* 0x80 */
+
+	/* GPIO events corerev >= 11 */
+	uint32 gpioeventintpolarity;
+
+	/* GPIO based LED powersave registers corerev >= 16 */
+	uint32 gpiotimerval;	/* 0x88 */
+	uint32 gpiotimeroutmask;
+
+	/* clock control */
+	uint32 clockcontrol_n;	/* 0x90 */
+	uint32 clockcontrol_sb;	/* aka m0 */
+	uint32 clockcontrol_pci;	/* aka m1 */
+	uint32 clockcontrol_m2;	/* mii/uart/mipsref */
+	uint32 clockcontrol_m3;	/* cpu */
+	uint32 clkdiv;		/* corerev >= 3 */
+	uint32 gpiodebugsel;	/* corerev >= 28 */
+	uint32 capabilities_ext;	/* 0xac  */
+
+	/* pll delay registers (corerev >= 4) */
+	uint32 pll_on_delay;	/* 0xb0 */
+	uint32 fref_sel_delay;
+	uint32 slow_clk_ctl;	/* 5 < corerev < 10 */
+	uint32 PAD;
+
+	/* Instaclock registers (corerev >= 10) */
+	uint32 system_clk_ctl;	/* 0xc0 */
+	uint32 clkstatestretch;
+	uint32 PAD[2];
+
+	/* Indirect backplane access (corerev >= 22) */
+	uint32 bp_addrlow;	/* 0xd0 */
+	uint32 bp_addrhigh;
+	uint32 bp_data;
+	uint32 PAD;
+	uint32 bp_indaccess;
+	uint32 PAD[3];
+
+	/* More clock dividers (corerev >= 32) */
+	uint32 clkdiv2;
+	uint32 PAD[2];
+
+	/* In AI chips, pointer to erom */
+	uint32 eromptr;		/* 0xfc */
+
+	/* ExtBus control registers (corerev >= 3) */
+	uint32 pcmcia_config;	/* 0x100 */
+	uint32 pcmcia_memwait;
+	uint32 pcmcia_attrwait;
+	uint32 pcmcia_iowait;
+	uint32 ide_config;
+	uint32 ide_memwait;
+	uint32 ide_attrwait;
+	uint32 ide_iowait;
+	uint32 prog_config;
+	uint32 prog_waitcount;
+	uint32 flash_config;
+	uint32 flash_waitcount;
+	uint32 SECI_config;	/* 0x130 SECI configuration */
+	uint32 PAD[3];
+
+	/* Enhanced Coexistence Interface (ECI) registers (corerev >= 21) */
+	uint32 eci_output;	/* 0x140 */
+	uint32 eci_control;
+	uint32 eci_inputlo;
+	uint32 eci_inputmi;
+	uint32 eci_inputhi;
+	uint32 eci_inputintpolaritylo;
+	uint32 eci_inputintpolaritymi;
+	uint32 eci_inputintpolarityhi;
+	uint32 eci_intmasklo;
+	uint32 eci_intmaskmi;
+	uint32 eci_intmaskhi;
+	uint32 eci_eventlo;
+	uint32 eci_eventmi;
+	uint32 eci_eventhi;
+	uint32 eci_eventmasklo;
+	uint32 eci_eventmaskmi;
+	uint32 eci_eventmaskhi;
+	uint32 PAD[3];
+
+	/* SROM interface (corerev >= 32) */
+	uint32 sromcontrol;	/* 0x190 */
+	uint32 sromaddress;
+	uint32 sromdata;
+	uint32 PAD[17];
+
+	/* Clock control and hardware workarounds (corerev >= 20) */
+	uint32 clk_ctl_st;	/* 0x1e0 */
+	uint32 hw_war;
+	uint32 PAD[70];
+
+	/* UARTs */
+	uint8 uart0data;	/* 0x300 */
+	uint8 uart0imr;
+	uint8 uart0fcr;
+	uint8 uart0lcr;
+	uint8 uart0mcr;
+	uint8 uart0lsr;
+	uint8 uart0msr;
+	uint8 uart0scratch;
+	uint8 PAD[248];		/* corerev >= 1 */
+
+	uint8 uart1data;	/* 0x400 */
+	uint8 uart1imr;
+	uint8 uart1fcr;
+	uint8 uart1lcr;
+	uint8 uart1mcr;
+	uint8 uart1lsr;
+	uint8 uart1msr;
+	uint8 uart1scratch;
+	uint32 PAD[126];
+
+	/* PMU registers (corerev >= 20) */
+	uint32 pmucontrol;	/* 0x600 */
+	uint32 pmucapabilities;
+	uint32 pmustatus;
+	uint32 res_state;
+	uint32 res_pending;
+	uint32 pmutimer;
+	uint32 min_res_mask;
+	uint32 max_res_mask;
+	uint32 res_table_sel;
+	uint32 res_dep_mask;
+	uint32 res_updn_timer;
+	uint32 res_timer;
+	uint32 clkstretch;
+	uint32 pmuwatchdog;
+	uint32 gpiosel;		/* 0x638, rev >= 1 */
+	uint32 gpioenable;	/* 0x63c, rev >= 1 */
+	uint32 res_req_timer_sel;
+	uint32 res_req_timer;
+	uint32 res_req_mask;
+	uint32 PAD;
+	uint32 chipcontrol_addr;	/* 0x650 */
+	uint32 chipcontrol_data;	/* 0x654 */
+	uint32 regcontrol_addr;
+	uint32 regcontrol_data;
+	uint32 pllcontrol_addr;
+	uint32 pllcontrol_data;
+	uint32 pmustrapopt;	/* 0x668, corerev >= 28 */
+	uint32 pmu_xtalfreq;	/* 0x66C, pmurev >= 10 */
+	uint32 PAD[100];
+	uint16 sromotp[768];
+} chipcregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+#if	defined(IL_BIGENDIAN) && defined(BCMHND74K)
+/* Selective swapped defines for those registers we need in
+ * big-endian code.
+ */
+#define	CC_CHIPID		4
+#define	CC_CAPABILITIES		0
+#define	CC_CHIPST		0x28
+#define	CC_EROMPTR		0xf8
+
+#else				/* !IL_BIGENDIAN || !BCMHND74K */
+
+#define	CC_CHIPID		0
+#define	CC_CAPABILITIES		4
+#define	CC_CHIPST		0x2c
+#define	CC_EROMPTR		0xfc
+
+#endif				/* IL_BIGENDIAN && BCMHND74K */
+
+#define CC_OTPST		0x10
+#define	CC_JTAGCMD		0x30
+#define	CC_JTAGIR		0x34
+#define	CC_JTAGDR		0x38
+#define	CC_JTAGCTRL		0x3c
+#define	CC_GPIOPU		0x58
+#define	CC_GPIOPD		0x5c
+#define	CC_GPIOIN		0x60
+#define	CC_GPIOOUT		0x64
+#define	CC_GPIOOUTEN		0x68
+#define	CC_GPIOCTRL		0x6c
+#define	CC_GPIOPOL		0x70
+#define	CC_GPIOINTM		0x74
+#define	CC_WATCHDOG		0x80
+#define	CC_CLKC_N		0x90
+#define	CC_CLKC_M0		0x94
+#define	CC_CLKC_M1		0x98
+#define	CC_CLKC_M2		0x9c
+#define	CC_CLKC_M3		0xa0
+#define	CC_CLKDIV		0xa4
+#define	CC_SYS_CLK_CTL		0xc0
+#define	CC_CLK_CTL_ST		SI_CLK_CTL_ST
+#define	PMU_CTL			0x600
+#define	PMU_CAP			0x604
+#define	PMU_ST			0x608
+#define PMU_RES_STATE		0x60c
+#define PMU_TIMER		0x614
+#define	PMU_MIN_RES_MASK	0x618
+#define	PMU_MAX_RES_MASK	0x61c
+#define CC_CHIPCTL_ADDR         0x650
+#define CC_CHIPCTL_DATA         0x654
+#define PMU_REG_CONTROL_ADDR	0x658
+#define PMU_REG_CONTROL_DATA	0x65C
+#define PMU_PLL_CONTROL_ADDR 	0x660
+#define PMU_PLL_CONTROL_DATA 	0x664
+#define	CC_SROM_OTP		0x800	/* SROM/OTP address space */
+
+/* chipid */
+#define	CID_ID_MASK		0x0000ffff	/* Chip Id mask */
+#define	CID_REV_MASK		0x000f0000	/* Chip Revision mask */
+#define	CID_REV_SHIFT		16	/* Chip Revision shift */
+#define	CID_PKG_MASK		0x00f00000	/* Package Option mask */
+#define	CID_PKG_SHIFT		20	/* Package Option shift */
+#define	CID_CC_MASK		0x0f000000	/* CoreCount (corerev >= 4) */
+#define CID_CC_SHIFT		24
+#define	CID_TYPE_MASK		0xf0000000	/* Chip Type */
+#define CID_TYPE_SHIFT		28
+
+/* capabilities */
+#define	CC_CAP_UARTS_MASK	0x00000003	/* Number of UARTs */
+#define CC_CAP_MIPSEB		0x00000004	/* MIPS is in big-endian mode */
+#define CC_CAP_UCLKSEL		0x00000018	/* UARTs clock select */
+#define CC_CAP_UINTCLK		0x00000008	/* UARTs are driven by internal divided clock */
+#define CC_CAP_UARTGPIO		0x00000020	/* UARTs own GPIOs 15:12 */
+#define CC_CAP_EXTBUS_MASK	0x000000c0	/* External bus mask */
+#define CC_CAP_EXTBUS_NONE	0x00000000	/* No ExtBus present */
+#define CC_CAP_EXTBUS_FULL	0x00000040	/* ExtBus: PCMCIA, IDE & Prog */
+#define CC_CAP_EXTBUS_PROG	0x00000080	/* ExtBus: ProgIf only */
+#define	CC_CAP_FLASH_MASK	0x00000700	/* Type of flash */
+#define	CC_CAP_PLL_MASK		0x00038000	/* Type of PLL */
+#define CC_CAP_PWR_CTL		0x00040000	/* Power control */
+#define CC_CAP_OTPSIZE		0x00380000	/* OTP Size (0 = none) */
+#define CC_CAP_OTPSIZE_SHIFT	19	/* OTP Size shift */
+#define CC_CAP_OTPSIZE_BASE	5	/* OTP Size base */
+#define CC_CAP_JTAGP		0x00400000	/* JTAG Master Present */
+#define CC_CAP_ROM		0x00800000	/* Internal boot rom active */
+#define CC_CAP_BKPLN64		0x08000000	/* 64-bit backplane */
+#define	CC_CAP_PMU		0x10000000	/* PMU Present, rev >= 20 */
+#define	CC_CAP_SROM		0x40000000	/* Srom Present, rev >= 32 */
+#define	CC_CAP_NFLASH		0x80000000	/* Nand flash present, rev >= 35 */
+
+#define	CC_CAP2_SECI		0x00000001	/* SECI Present, rev >= 36 */
+#define	CC_CAP2_GSIO		0x00000002	/* GSIO (spi/i2c) present, rev >= 37 */
+
+/* PLL type */
+#define PLL_NONE		0x00000000
+#define PLL_TYPE1		0x00010000	/* 48MHz base, 3 dividers */
+#define PLL_TYPE2		0x00020000	/* 48MHz, 4 dividers */
+#define PLL_TYPE3		0x00030000	/* 25MHz, 2 dividers */
+#define PLL_TYPE4		0x00008000	/* 48MHz, 4 dividers */
+#define PLL_TYPE5		0x00018000	/* 25MHz, 4 dividers */
+#define PLL_TYPE6		0x00028000	/* 100/200 or 120/240 only */
+#define PLL_TYPE7		0x00038000	/* 25MHz, 4 dividers */
+
+/* ILP clock */
+#define	ILP_CLOCK		32000
+
+/* ALP clock on pre-PMU chips */
+#define	ALP_CLOCK		20000000
+
+/* HT clock */
+#define	HT_CLOCK		80000000
+
+/* corecontrol */
+#define CC_UARTCLKO		0x00000001	/* Drive UART with internal clock */
+#define	CC_SE			0x00000002	/* sync clk out enable (corerev >= 3) */
+#define CC_UARTCLKEN		0x00000008	/* enable UART Clock (corerev > = 21 */
+
+/* chipcontrol */
+#define CHIPCTRL_4321A0_DEFAULT	0x3a4
+#define CHIPCTRL_4321A1_DEFAULT	0x0a4
+#define CHIPCTRL_4321_PLL_DOWN	0x800000	/* serdes PLL down override */
+
+/* Fields in the otpstatus register in rev >= 21 */
+#define OTPS_OL_MASK		0x000000ff
+#define OTPS_OL_MFG		0x00000001	/* manuf row is locked */
+#define OTPS_OL_OR1		0x00000002	/* otp redundancy row 1 is locked */
+#define OTPS_OL_OR2		0x00000004	/* otp redundancy row 2 is locked */
+#define OTPS_OL_GU		0x00000008	/* general use region is locked */
+#define OTPS_GUP_MASK		0x00000f00
+#define OTPS_GUP_SHIFT		8
+#define OTPS_GUP_HW		0x00000100	/* h/w subregion is programmed */
+#define OTPS_GUP_SW		0x00000200	/* s/w subregion is programmed */
+#define OTPS_GUP_CI		0x00000400	/* chipid/pkgopt subregion is programmed */
+#define OTPS_GUP_FUSE		0x00000800	/* fuse subregion is programmed */
+#define OTPS_READY		0x00001000
+#define OTPS_RV(x)		(1 << (16 + (x)))	/* redundancy entry valid */
+#define OTPS_RV_MASK		0x0fff0000
+
+/* Fields in the otpcontrol register in rev >= 21 */
+#define OTPC_PROGSEL		0x00000001
+#define OTPC_PCOUNT_MASK	0x0000000e
+#define OTPC_PCOUNT_SHIFT	1
+#define OTPC_VSEL_MASK		0x000000f0
+#define OTPC_VSEL_SHIFT		4
+#define OTPC_TMM_MASK		0x00000700
+#define OTPC_TMM_SHIFT		8
+#define OTPC_ODM		0x00000800
+#define OTPC_PROGEN		0x80000000
+
+/* Fields in otpprog in rev >= 21 and HND OTP */
+#define OTPP_COL_MASK		0x000000ff
+#define OTPP_COL_SHIFT		0
+#define OTPP_ROW_MASK		0x0000ff00
+#define OTPP_ROW_SHIFT		8
+#define OTPP_OC_MASK		0x0f000000
+#define OTPP_OC_SHIFT		24
+#define OTPP_READERR		0x10000000
+#define OTPP_VALUE_MASK		0x20000000
+#define OTPP_VALUE_SHIFT	29
+#define OTPP_START_BUSY		0x80000000
+#define	OTPP_READ		0x40000000	/* HND OTP */
+
+/* otplayout reg corerev >= 36 */
+#define OTP_CISFORMAT_NEW	0x80000000
+
+/* Opcodes for OTPP_OC field */
+#define OTPPOC_READ		0
+#define OTPPOC_BIT_PROG		1
+#define OTPPOC_VERIFY		3
+#define OTPPOC_INIT		4
+#define OTPPOC_SET		5
+#define OTPPOC_RESET		6
+#define OTPPOC_OCST		7
+#define OTPPOC_ROW_LOCK		8
+#define OTPPOC_PRESCN_TEST	9
+
+/* Jtagm characteristics that appeared at a given corerev */
+#define	JTAGM_CREV_OLD		10	/* Old command set, 16bit max IR */
+#define	JTAGM_CREV_IRP		22	/* Able to do pause-ir */
+#define	JTAGM_CREV_RTI		28	/* Able to do return-to-idle */
+
+/* jtagcmd */
+#define JCMD_START		0x80000000
+#define JCMD_BUSY		0x80000000
+#define JCMD_STATE_MASK		0x60000000
+#define JCMD_STATE_TLR		0x00000000	/* Test-logic-reset */
+#define JCMD_STATE_PIR		0x20000000	/* Pause IR */
+#define JCMD_STATE_PDR		0x40000000	/* Pause DR */
+#define JCMD_STATE_RTI		0x60000000	/* Run-test-idle */
+#define JCMD0_ACC_MASK		0x0000f000
+#define JCMD0_ACC_IRDR		0x00000000
+#define JCMD0_ACC_DR		0x00001000
+#define JCMD0_ACC_IR		0x00002000
+#define JCMD0_ACC_RESET		0x00003000
+#define JCMD0_ACC_IRPDR		0x00004000
+#define JCMD0_ACC_PDR		0x00005000
+#define JCMD0_IRW_MASK		0x00000f00
+#define JCMD_ACC_MASK		0x000f0000	/* Changes for corerev 11 */
+#define JCMD_ACC_IRDR		0x00000000
+#define JCMD_ACC_DR		0x00010000
+#define JCMD_ACC_IR		0x00020000
+#define JCMD_ACC_RESET		0x00030000
+#define JCMD_ACC_IRPDR		0x00040000
+#define JCMD_ACC_PDR		0x00050000
+#define JCMD_ACC_PIR		0x00060000
+#define JCMD_ACC_IRDR_I		0x00070000	/* rev 28: return to run-test-idle */
+#define JCMD_ACC_DR_I		0x00080000	/* rev 28: return to run-test-idle */
+#define JCMD_IRW_MASK		0x00001f00
+#define JCMD_IRW_SHIFT		8
+#define JCMD_DRW_MASK		0x0000003f
+
+/* jtagctrl */
+#define JCTRL_FORCE_CLK		4	/* Force clock */
+#define JCTRL_EXT_EN		2	/* Enable external targets */
+#define JCTRL_EN		1	/* Enable Jtag master */
+
+/* Fields in clkdiv */
+#define	CLKD_SFLASH		0x0f000000
+#define	CLKD_SFLASH_SHIFT	24
+#define	CLKD_OTP		0x000f0000
+#define	CLKD_OTP_SHIFT		16
+#define	CLKD_JTAG		0x00000f00
+#define	CLKD_JTAG_SHIFT		8
+#define	CLKD_UART		0x000000ff
+
+#define	CLKD2_SROM		0x00000003
+
+/* intstatus/intmask */
+#define	CI_GPIO			0x00000001	/* gpio intr */
+#define	CI_EI			0x00000002	/* extif intr (corerev >= 3) */
+#define	CI_TEMP			0x00000004	/* temp. ctrl intr (corerev >= 15) */
+#define	CI_SIRQ			0x00000008	/* serial IRQ intr (corerev >= 15) */
+#define	CI_PMU			0x00000020	/* pmu intr (corerev >= 21) */
+#define	CI_UART			0x00000040	/* uart intr (corerev >= 21) */
+#define	CI_WDRESET		0x80000000	/* watchdog reset occurred */
+
+/* slow_clk_ctl */
+#define SCC_SS_MASK		0x00000007	/* slow clock source mask */
+#define	SCC_SS_LPO		0x00000000	/* source of slow clock is LPO */
+#define	SCC_SS_XTAL		0x00000001	/* source of slow clock is crystal */
+#define	SCC_SS_PCI		0x00000002	/* source of slow clock is PCI */
+#define SCC_LF			0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
+#define SCC_LP			0x00000400	/* LPOPowerDown, 1: LPO is disabled,
+						 * 0: LPO is enabled
+						 */
+#define SCC_FS			0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock,
+						 * 0: power logic control
+						 */
+#define SCC_IP			0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors
+						 * PLL clock disable requests from core
+						 */
+#define SCC_XC			0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't
+						 * disable crystal when appropriate
+						 */
+#define SCC_XP			0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
+#define SCC_CD_MASK		0xffff0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
+#define SCC_CD_SHIFT		16
+
+/* system_clk_ctl */
+#define	SYCC_IE			0x00000001	/* ILPen: Enable Idle Low Power */
+#define	SYCC_AE			0x00000002	/* ALPen: Enable Active Low Power */
+#define	SYCC_FP			0x00000004	/* ForcePLLOn */
+#define	SYCC_AR			0x00000008	/* Force ALP (or HT if ALPen is not set */
+#define	SYCC_HR			0x00000010	/* Force HT */
+#define SYCC_CD_MASK		0xffff0000	/* ClkDiv  (ILP = 1/(4 * (divisor + 1)) */
+#define SYCC_CD_SHIFT		16
+
+/* Indirect backplane access */
+#define	BPIA_BYTEEN		0x0000000f
+#define	BPIA_SZ1		0x00000001
+#define	BPIA_SZ2		0x00000003
+#define	BPIA_SZ4		0x00000007
+#define	BPIA_SZ8		0x0000000f
+#define	BPIA_WRITE		0x00000100
+#define	BPIA_START		0x00000200
+#define	BPIA_BUSY		0x00000200
+#define	BPIA_ERROR		0x00000400
+
+/* pcmcia/prog/flash_config */
+#define	CF_EN			0x00000001	/* enable */
+#define	CF_EM_MASK		0x0000000e	/* mode */
+#define	CF_EM_SHIFT		1
+#define	CF_EM_FLASH		0	/* flash/asynchronous mode */
+#define	CF_EM_SYNC		2	/* synchronous mode */
+#define	CF_EM_PCMCIA		4	/* pcmcia mode */
+#define	CF_DS			0x00000010	/* destsize:  0=8bit, 1=16bit */
+#define	CF_BS			0x00000020	/* byteswap */
+#define	CF_CD_MASK		0x000000c0	/* clock divider */
+#define	CF_CD_SHIFT		6
+#define	CF_CD_DIV2		0x00000000	/* backplane/2 */
+#define	CF_CD_DIV3		0x00000040	/* backplane/3 */
+#define	CF_CD_DIV4		0x00000080	/* backplane/4 */
+#define	CF_CE			0x00000100	/* clock enable */
+#define	CF_SB			0x00000200	/* size/bytestrobe (synch only) */
+
+/* pcmcia_memwait */
+#define	PM_W0_MASK		0x0000003f	/* waitcount0 */
+#define	PM_W1_MASK		0x00001f00	/* waitcount1 */
+#define	PM_W1_SHIFT		8
+#define	PM_W2_MASK		0x001f0000	/* waitcount2 */
+#define	PM_W2_SHIFT		16
+#define	PM_W3_MASK		0x1f000000	/* waitcount3 */
+#define	PM_W3_SHIFT		24
+
+/* pcmcia_attrwait */
+#define	PA_W0_MASK		0x0000003f	/* waitcount0 */
+#define	PA_W1_MASK		0x00001f00	/* waitcount1 */
+#define	PA_W1_SHIFT		8
+#define	PA_W2_MASK		0x001f0000	/* waitcount2 */
+#define	PA_W2_SHIFT		16
+#define	PA_W3_MASK		0x1f000000	/* waitcount3 */
+#define	PA_W3_SHIFT		24
+
+/* pcmcia_iowait */
+#define	PI_W0_MASK		0x0000003f	/* waitcount0 */
+#define	PI_W1_MASK		0x00001f00	/* waitcount1 */
+#define	PI_W1_SHIFT		8
+#define	PI_W2_MASK		0x001f0000	/* waitcount2 */
+#define	PI_W2_SHIFT		16
+#define	PI_W3_MASK		0x1f000000	/* waitcount3 */
+#define	PI_W3_SHIFT		24
+
+/* prog_waitcount */
+#define	PW_W0_MASK		0x0000001f	/* waitcount0 */
+#define	PW_W1_MASK		0x00001f00	/* waitcount1 */
+#define	PW_W1_SHIFT		8
+#define	PW_W2_MASK		0x001f0000	/* waitcount2 */
+#define	PW_W2_SHIFT		16
+#define	PW_W3_MASK		0x1f000000	/* waitcount3 */
+#define	PW_W3_SHIFT		24
+
+#define PW_W0       		0x0000000c
+#define PW_W1       		0x00000a00
+#define PW_W2       		0x00020000
+#define PW_W3       		0x01000000
+
+/* flash_waitcount */
+#define	FW_W0_MASK		0x0000003f	/* waitcount0 */
+#define	FW_W1_MASK		0x00001f00	/* waitcount1 */
+#define	FW_W1_SHIFT		8
+#define	FW_W2_MASK		0x001f0000	/* waitcount2 */
+#define	FW_W2_SHIFT		16
+#define	FW_W3_MASK		0x1f000000	/* waitcount3 */
+#define	FW_W3_SHIFT		24
+
+/* When Srom support present, fields in sromcontrol */
+#define	SRC_START		0x80000000
+#define	SRC_BUSY		0x80000000
+#define	SRC_OPCODE		0x60000000
+#define	SRC_OP_READ		0x00000000
+#define	SRC_OP_WRITE		0x20000000
+#define	SRC_OP_WRDIS		0x40000000
+#define	SRC_OP_WREN		0x60000000
+#define	SRC_OTPSEL		0x00000010
+#define	SRC_LOCK		0x00000008
+#define	SRC_SIZE_MASK		0x00000006
+#define	SRC_SIZE_1K		0x00000000
+#define	SRC_SIZE_4K		0x00000002
+#define	SRC_SIZE_16K		0x00000004
+#define	SRC_SIZE_SHIFT		1
+#define	SRC_PRESENT		0x00000001
+
+/* Fields in pmucontrol */
+#define	PCTL_ILP_DIV_MASK	0xffff0000
+#define	PCTL_ILP_DIV_SHIFT	16
+#define PCTL_PLL_PLLCTL_UPD	0x00000400	/* rev 2 */
+#define PCTL_NOILP_ON_WAIT	0x00000200	/* rev 1 */
+#define	PCTL_HT_REQ_EN		0x00000100
+#define	PCTL_ALP_REQ_EN		0x00000080
+#define	PCTL_XTALFREQ_MASK	0x0000007c
+#define	PCTL_XTALFREQ_SHIFT	2
+#define	PCTL_ILP_DIV_EN		0x00000002
+#define	PCTL_LPO_SEL		0x00000001
+
+/* Fields in clkstretch */
+#define CSTRETCH_HT		0xffff0000
+#define CSTRETCH_ALP		0x0000ffff
+
+/* gpiotimerval */
+#define GPIO_ONTIME_SHIFT	16
+
+/* clockcontrol_n */
+#define	CN_N1_MASK		0x3f	/* n1 control */
+#define	CN_N2_MASK		0x3f00	/* n2 control */
+#define	CN_N2_SHIFT		8
+#define	CN_PLLC_MASK		0xf0000	/* pll control */
+#define	CN_PLLC_SHIFT		16
+
+/* clockcontrol_sb/pci/uart */
+#define	CC_M1_MASK		0x3f	/* m1 control */
+#define	CC_M2_MASK		0x3f00	/* m2 control */
+#define	CC_M2_SHIFT		8
+#define	CC_M3_MASK		0x3f0000	/* m3 control */
+#define	CC_M3_SHIFT		16
+#define	CC_MC_MASK		0x1f000000	/* mux control */
+#define	CC_MC_SHIFT		24
+
+/* N3M Clock control magic field values */
+#define	CC_F6_2			0x02	/* A factor of 2 in */
+#define	CC_F6_3			0x03	/* 6-bit fields like */
+#define	CC_F6_4			0x05	/* N1, M1 or M3 */
+#define	CC_F6_5			0x09
+#define	CC_F6_6			0x11
+#define	CC_F6_7			0x21
+
+#define	CC_F5_BIAS		5	/* 5-bit fields get this added */
+
+#define	CC_MC_BYPASS		0x08
+#define	CC_MC_M1		0x04
+#define	CC_MC_M1M2		0x02
+#define	CC_MC_M1M2M3		0x01
+#define	CC_MC_M1M3		0x11
+
+/* Type 2 Clock control magic field values */
+#define	CC_T2_BIAS		2	/* n1, n2, m1 & m3 bias */
+#define	CC_T2M2_BIAS		3	/* m2 bias */
+
+#define	CC_T2MC_M1BYP		1
+#define	CC_T2MC_M2BYP		2
+#define	CC_T2MC_M3BYP		4
+
+/* Type 6 Clock control magic field values */
+#define	CC_T6_MMASK		1	/* bits of interest in m */
+#define	CC_T6_M0		120000000	/* sb clock for m = 0 */
+#define	CC_T6_M1		100000000	/* sb clock for m = 1 */
+#define	SB2MIPS_T6(sb)		(2 * (sb))
+
+/* Common clock base */
+#define	CC_CLOCK_BASE1		24000000	/* Half the clock freq */
+#define CC_CLOCK_BASE2		12500000	/* Alternate crystal on some PLLs */
+
+/* Clock control values for 200MHz in 5350 */
+#define	CLKC_5350_N		0x0311
+#define	CLKC_5350_M		0x04020009
+
+/* Flash types in the chipcommon capabilities register */
+#define FLASH_NONE		0x000	/* No flash */
+#define SFLASH_ST		0x100	/* ST serial flash */
+#define SFLASH_AT		0x200	/* Atmel serial flash */
+#define	PFLASH			0x700	/* Parallel flash */
+
+/* Bits in the ExtBus config registers */
+#define	CC_CFG_EN		0x0001	/* Enable */
+#define	CC_CFG_EM_MASK		0x000e	/* Extif Mode */
+#define	CC_CFG_EM_ASYNC		0x0000	/*   Async/Parallel flash */
+#define	CC_CFG_EM_SYNC		0x0002	/*   Synchronous */
+#define	CC_CFG_EM_PCMCIA	0x0004	/*   PCMCIA */
+#define	CC_CFG_EM_IDE		0x0006	/*   IDE */
+#define	CC_CFG_DS		0x0010	/* Data size, 0=8bit, 1=16bit */
+#define	CC_CFG_CD_MASK		0x00e0	/* Sync: Clock divisor, rev >= 20 */
+#define	CC_CFG_CE		0x0100	/* Sync: Clock enable, rev >= 20 */
+#define	CC_CFG_SB		0x0200	/* Sync: Size/Bytestrobe, rev >= 20 */
+#define	CC_CFG_IS		0x0400	/* Extif Sync Clk Select, rev >= 20 */
+
+/* ExtBus address space */
+#define	CC_EB_BASE		0x1a000000	/* Chipc ExtBus base address */
+#define	CC_EB_PCMCIA_MEM	0x1a000000	/* PCMCIA 0 memory base address */
+#define	CC_EB_PCMCIA_IO		0x1a200000	/* PCMCIA 0 I/O base address */
+#define	CC_EB_PCMCIA_CFG	0x1a400000	/* PCMCIA 0 config base address */
+#define	CC_EB_IDE		0x1a800000	/* IDE memory base */
+#define	CC_EB_PCMCIA1_MEM	0x1a800000	/* PCMCIA 1 memory base address */
+#define	CC_EB_PCMCIA1_IO	0x1aa00000	/* PCMCIA 1 I/O base address */
+#define	CC_EB_PCMCIA1_CFG	0x1ac00000	/* PCMCIA 1 config base address */
+#define	CC_EB_PROGIF		0x1b000000	/* ProgIF Async/Sync base address */
+
+/* Start/busy bit in flashcontrol */
+#define SFLASH_OPCODE		0x000000ff
+#define SFLASH_ACTION		0x00000700
+#define	SFLASH_CS_ACTIVE	0x00001000	/* Chip Select Active, rev >= 20 */
+#define SFLASH_START		0x80000000
+#define SFLASH_BUSY		SFLASH_START
+
+/* flashcontrol action codes */
+#define	SFLASH_ACT_OPONLY	0x0000	/* Issue opcode only */
+#define	SFLASH_ACT_OP1D		0x0100	/* opcode + 1 data byte */
+#define	SFLASH_ACT_OP3A		0x0200	/* opcode + 3 addr bytes */
+#define	SFLASH_ACT_OP3A1D	0x0300	/* opcode + 3 addr & 1 data bytes */
+#define	SFLASH_ACT_OP3A4D	0x0400	/* opcode + 3 addr & 4 data bytes */
+#define	SFLASH_ACT_OP3A4X4D	0x0500	/* opcode + 3 addr, 4 don't care & 4 data bytes */
+#define	SFLASH_ACT_OP3A1X4D	0x0700	/* opcode + 3 addr, 1 don't care & 4 data bytes */
+
+/* flashcontrol action+opcodes for ST flashes */
+#define SFLASH_ST_WREN		0x0006	/* Write Enable */
+#define SFLASH_ST_WRDIS		0x0004	/* Write Disable */
+#define SFLASH_ST_RDSR		0x0105	/* Read Status Register */
+#define SFLASH_ST_WRSR		0x0101	/* Write Status Register */
+#define SFLASH_ST_READ		0x0303	/* Read Data Bytes */
+#define SFLASH_ST_PP		0x0302	/* Page Program */
+#define SFLASH_ST_SE		0x02d8	/* Sector Erase */
+#define SFLASH_ST_BE		0x00c7	/* Bulk Erase */
+#define SFLASH_ST_DP		0x00b9	/* Deep Power-down */
+#define SFLASH_ST_RES		0x03ab	/* Read Electronic Signature */
+#define SFLASH_ST_CSA		0x1000	/* Keep chip select asserted */
+#define SFLASH_ST_SSE		0x0220	/* Sub-sector Erase */
+
+/* Status register bits for ST flashes */
+#define SFLASH_ST_WIP		0x01	/* Write In Progress */
+#define SFLASH_ST_WEL		0x02	/* Write Enable Latch */
+#define SFLASH_ST_BP_MASK	0x1c	/* Block Protect */
+#define SFLASH_ST_BP_SHIFT	2
+#define SFLASH_ST_SRWD		0x80	/* Status Register Write Disable */
+
+/* flashcontrol action+opcodes for Atmel flashes */
+#define SFLASH_AT_READ				0x07e8
+#define SFLASH_AT_PAGE_READ			0x07d2
+#define SFLASH_AT_BUF1_READ
+#define SFLASH_AT_BUF2_READ
+#define SFLASH_AT_STATUS			0x01d7
+#define SFLASH_AT_BUF1_WRITE			0x0384
+#define SFLASH_AT_BUF2_WRITE			0x0387
+#define SFLASH_AT_BUF1_ERASE_PROGRAM		0x0283
+#define SFLASH_AT_BUF2_ERASE_PROGRAM		0x0286
+#define SFLASH_AT_BUF1_PROGRAM			0x0288
+#define SFLASH_AT_BUF2_PROGRAM			0x0289
+#define SFLASH_AT_PAGE_ERASE			0x0281
+#define SFLASH_AT_BLOCK_ERASE			0x0250
+#define SFLASH_AT_BUF1_WRITE_ERASE_PROGRAM	0x0382
+#define SFLASH_AT_BUF2_WRITE_ERASE_PROGRAM	0x0385
+#define SFLASH_AT_BUF1_LOAD			0x0253
+#define SFLASH_AT_BUF2_LOAD			0x0255
+#define SFLASH_AT_BUF1_COMPARE			0x0260
+#define SFLASH_AT_BUF2_COMPARE			0x0261
+#define SFLASH_AT_BUF1_REPROGRAM		0x0258
+#define SFLASH_AT_BUF2_REPROGRAM		0x0259
+
+/* Status register bits for Atmel flashes */
+#define SFLASH_AT_READY				0x80
+#define SFLASH_AT_MISMATCH			0x40
+#define SFLASH_AT_ID_MASK			0x38
+#define SFLASH_AT_ID_SHIFT			3
+
+/*
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
+
+#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
+#define UART_TX		0	/* Out: Transmit buffer (DLAB=0) */
+#define UART_DLL	0	/* Out: Divisor Latch Low (DLAB=1) */
+#define UART_IER	1	/* In/Out: Interrupt Enable Register (DLAB=0) */
+#define UART_DLM	1	/* Out: Divisor Latch High (DLAB=1) */
+#define UART_IIR	2	/* In: Interrupt Identity Register  */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+#define UART_LCR_DLAB	0x80	/* Divisor latch access bit */
+#define UART_LCR_WLEN8	0x03	/* Word length: 8 bits */
+#define UART_MCR_OUT2	0x08	/* MCR GPIO out 2 */
+#define UART_MCR_LOOP	0x10	/* Enable loopback test mode */
+#define UART_LSR_RX_FIFO 	0x80	/* Receive FIFO error */
+#define UART_LSR_TDHR		0x40	/* Data-hold-register empty */
+#define UART_LSR_THRE		0x20	/* Transmit-hold-register empty */
+#define UART_LSR_BREAK		0x10	/* Break interrupt */
+#define UART_LSR_FRAMING	0x08	/* Framing error */
+#define UART_LSR_PARITY		0x04	/* Parity error */
+#define UART_LSR_OVERRUN	0x02	/* Overrun error */
+#define UART_LSR_RXRDY		0x01	/* Receiver ready */
+#define UART_FCR_FIFO_ENABLE 1	/* FIFO control register bit controlling FIFO enable/disable */
+
+/* Interrupt Identity Register (IIR) bits */
+#define UART_IIR_FIFO_MASK	0xc0	/* IIR FIFO disable/enabled mask */
+#define UART_IIR_INT_MASK	0xf	/* IIR interrupt ID source */
+#define UART_IIR_MDM_CHG	0x0	/* Modem status changed */
+#define UART_IIR_NOINT		0x1	/* No interrupt pending */
+#define UART_IIR_THRE		0x2	/* THR empty */
+#define UART_IIR_RCVD_DATA	0x4	/* Received data available */
+#define UART_IIR_RCVR_STATUS 	0x6	/* Receiver status */
+#define UART_IIR_CHAR_TIME 	0xc	/* Character time */
+
+/* Interrupt Enable Register (IER) bits */
+#define UART_IER_EDSSI	8	/* enable modem status interrupt */
+#define UART_IER_ELSI	4	/* enable receiver line status interrupt */
+#define UART_IER_ETBEI  2	/* enable transmitter holding register empty interrupt */
+#define UART_IER_ERBFI	1	/* enable data available interrupt */
+
+/* pmustatus */
+#define PST_EXTLPOAVAIL	0x0100
+#define PST_WDRESET	0x0080
+#define	PST_INTPEND	0x0040
+#define	PST_SBCLKST	0x0030
+#define	PST_SBCLKST_ILP	0x0010
+#define	PST_SBCLKST_ALP	0x0020
+#define	PST_SBCLKST_HT	0x0030
+#define	PST_ALPAVAIL	0x0008
+#define	PST_HTAVAIL	0x0004
+#define	PST_RESINIT	0x0003
+
+/* pmucapabilities */
+#define PCAP_REV_MASK	0x000000ff
+#define PCAP_RC_MASK	0x00001f00
+#define PCAP_RC_SHIFT	8
+#define PCAP_TC_MASK	0x0001e000
+#define PCAP_TC_SHIFT	13
+#define PCAP_PC_MASK	0x001e0000
+#define PCAP_PC_SHIFT	17
+#define PCAP_VC_MASK	0x01e00000
+#define PCAP_VC_SHIFT	21
+#define PCAP_CC_MASK	0x1e000000
+#define PCAP_CC_SHIFT	25
+#define PCAP5_PC_MASK	0x003e0000	/* PMU corerev >= 5 */
+#define PCAP5_PC_SHIFT	17
+#define PCAP5_VC_MASK	0x07c00000
+#define PCAP5_VC_SHIFT	22
+#define PCAP5_CC_MASK	0xf8000000
+#define PCAP5_CC_SHIFT	27
+
+/* PMU Resource Request Timer registers */
+/* This is based on PmuRev0 */
+#define	PRRT_TIME_MASK	0x03ff
+#define	PRRT_INTEN	0x0400
+#define	PRRT_REQ_ACTIVE	0x0800
+#define	PRRT_ALP_REQ	0x1000
+#define	PRRT_HT_REQ	0x2000
+
+/* PMU resource bit position */
+#define PMURES_BIT(bit)	(1 << (bit))
+
+/* PMU resource number limit */
+#define PMURES_MAX_RESNUM	30
+
+/* PMU chip control0 register */
+#define	PMU_CHIPCTL0		0
+
+/* PMU chip control1 register */
+#define	PMU_CHIPCTL1			1
+#define	PMU_CC1_RXC_DLL_BYPASS		0x00010000
+
+#define PMU_CC1_IF_TYPE_MASK   		0x00000030
+#define PMU_CC1_IF_TYPE_RMII    	0x00000000
+#define PMU_CC1_IF_TYPE_MII     	0x00000010
+#define PMU_CC1_IF_TYPE_RGMII   	0x00000020
+
+#define PMU_CC1_SW_TYPE_MASK    	0x000000c0
+#define PMU_CC1_SW_TYPE_EPHY    	0x00000000
+#define PMU_CC1_SW_TYPE_EPHYMII 	0x00000040
+#define PMU_CC1_SW_TYPE_EPHYRMII	0x00000080
+#define PMU_CC1_SW_TYPE_RGMII   	0x000000c0
+
+/* PMU corerev and chip specific PLL controls.
+ * PMU<rev>_PLL<num>_XX where <rev> is PMU corerev and <num> is an arbitrary number
+ * to differentiate different PLLs controlled by the same PMU rev.
+ */
+/* pllcontrol registers */
+/* PDIV, div_phy, div_arm, div_adc, dith_sel, ioff, kpd_scale, lsb_sel, mash_sel, lf_c & lf_r */
+#define	PMU0_PLL0_PLLCTL0		0
+#define	PMU0_PLL0_PC0_PDIV_MASK		1
+#define	PMU0_PLL0_PC0_PDIV_FREQ		25000
+#define PMU0_PLL0_PC0_DIV_ARM_MASK	0x00000038
+#define PMU0_PLL0_PC0_DIV_ARM_SHIFT	3
+#define PMU0_PLL0_PC0_DIV_ARM_BASE	8
+
+/* PC0_DIV_ARM for PLLOUT_ARM */
+#define PMU0_PLL0_PC0_DIV_ARM_110MHZ	0
+#define PMU0_PLL0_PC0_DIV_ARM_97_7MHZ	1
+#define PMU0_PLL0_PC0_DIV_ARM_88MHZ	2
+#define PMU0_PLL0_PC0_DIV_ARM_80MHZ	3	/* Default */
+#define PMU0_PLL0_PC0_DIV_ARM_73_3MHZ	4
+#define PMU0_PLL0_PC0_DIV_ARM_67_7MHZ	5
+#define PMU0_PLL0_PC0_DIV_ARM_62_9MHZ	6
+#define PMU0_PLL0_PC0_DIV_ARM_58_6MHZ	7
+
+/* Wildcard base, stop_mod, en_lf_tp, en_cal & lf_r2 */
+#define	PMU0_PLL0_PLLCTL1		1
+#define	PMU0_PLL0_PC1_WILD_INT_MASK	0xf0000000
+#define	PMU0_PLL0_PC1_WILD_INT_SHIFT	28
+#define	PMU0_PLL0_PC1_WILD_FRAC_MASK	0x0fffff00
+#define	PMU0_PLL0_PC1_WILD_FRAC_SHIFT	8
+#define	PMU0_PLL0_PC1_STOP_MOD		0x00000040
+
+/* Wildcard base, vco_calvar, vco_swc, vco_var_selref, vso_ical & vco_sel_avdd */
+#define	PMU0_PLL0_PLLCTL2		2
+#define	PMU0_PLL0_PC2_WILD_INT_MASK	0xf
+#define	PMU0_PLL0_PC2_WILD_INT_SHIFT	4
+
+/* pllcontrol registers */
+/* ndiv_pwrdn, pwrdn_ch<x>, refcomp_pwrdn, dly_ch<x>, p1div, p2div, _bypass_sdmod */
+#define PMU1_PLL0_PLLCTL0		0
+#define PMU1_PLL0_PC0_P1DIV_MASK	0x00f00000
+#define PMU1_PLL0_PC0_P1DIV_SHIFT	20
+#define PMU1_PLL0_PC0_P2DIV_MASK	0x0f000000
+#define PMU1_PLL0_PC0_P2DIV_SHIFT	24
+
+/* m<x>div */
+#define PMU1_PLL0_PLLCTL1		1
+#define PMU1_PLL0_PC1_M1DIV_MASK	0x000000ff
+#define PMU1_PLL0_PC1_M1DIV_SHIFT	0
+#define PMU1_PLL0_PC1_M2DIV_MASK	0x0000ff00
+#define PMU1_PLL0_PC1_M2DIV_SHIFT	8
+#define PMU1_PLL0_PC1_M3DIV_MASK	0x00ff0000
+#define PMU1_PLL0_PC1_M3DIV_SHIFT	16
+#define PMU1_PLL0_PC1_M4DIV_MASK	0xff000000
+#define PMU1_PLL0_PC1_M4DIV_SHIFT	24
+
+#define DOT11MAC_880MHZ_CLK_DIVISOR_SHIFT 8
+#define DOT11MAC_880MHZ_CLK_DIVISOR_MASK (0xFF << DOT11MAC_880MHZ_CLK_DIVISOR_SHIFT)
+#define DOT11MAC_880MHZ_CLK_DIVISOR_VAL  (0xE << DOT11MAC_880MHZ_CLK_DIVISOR_SHIFT)
+
+/* m<x>div, ndiv_dither_mfb, ndiv_mode, ndiv_int */
+#define PMU1_PLL0_PLLCTL2		2
+#define PMU1_PLL0_PC2_M5DIV_MASK	0x000000ff
+#define PMU1_PLL0_PC2_M5DIV_SHIFT	0
+#define PMU1_PLL0_PC2_M6DIV_MASK	0x0000ff00
+#define PMU1_PLL0_PC2_M6DIV_SHIFT	8
+#define PMU1_PLL0_PC2_NDIV_MODE_MASK	0x000e0000
+#define PMU1_PLL0_PC2_NDIV_MODE_SHIFT	17
+#define PMU1_PLL0_PC2_NDIV_MODE_MASH	1
+#define PMU1_PLL0_PC2_NDIV_MODE_MFB	2	/* recommended for 4319 */
+#define PMU1_PLL0_PC2_NDIV_INT_MASK	0x1ff00000
+#define PMU1_PLL0_PC2_NDIV_INT_SHIFT	20
+
+/* ndiv_frac */
+#define PMU1_PLL0_PLLCTL3		3
+#define PMU1_PLL0_PC3_NDIV_FRAC_MASK	0x00ffffff
+#define PMU1_PLL0_PC3_NDIV_FRAC_SHIFT	0
+
+/* pll_ctrl */
+#define PMU1_PLL0_PLLCTL4		4
+
+/* pll_ctrl, vco_rng, clkdrive_ch<x> */
+#define PMU1_PLL0_PLLCTL5		5
+#define PMU1_PLL0_PC5_CLK_DRV_MASK 0xffffff00
+#define PMU1_PLL0_PC5_CLK_DRV_SHIFT 8
+
+/* PMU rev 2 control words */
+#define PMU2_PHY_PLL_PLLCTL		4
+#define PMU2_SI_PLL_PLLCTL		10
+
+/* PMU rev 2 */
+/* pllcontrol registers */
+/* ndiv_pwrdn, pwrdn_ch<x>, refcomp_pwrdn, dly_ch<x>, p1div, p2div, _bypass_sdmod */
+#define PMU2_PLL_PLLCTL0		0
+#define PMU2_PLL_PC0_P1DIV_MASK 	0x00f00000
+#define PMU2_PLL_PC0_P1DIV_SHIFT	20
+#define PMU2_PLL_PC0_P2DIV_MASK 	0x0f000000
+#define PMU2_PLL_PC0_P2DIV_SHIFT	24
+
+/* m<x>div */
+#define PMU2_PLL_PLLCTL1		1
+#define PMU2_PLL_PC1_M1DIV_MASK 	0x000000ff
+#define PMU2_PLL_PC1_M1DIV_SHIFT	0
+#define PMU2_PLL_PC1_M2DIV_MASK 	0x0000ff00
+#define PMU2_PLL_PC1_M2DIV_SHIFT	8
+#define PMU2_PLL_PC1_M3DIV_MASK 	0x00ff0000
+#define PMU2_PLL_PC1_M3DIV_SHIFT	16
+#define PMU2_PLL_PC1_M4DIV_MASK 	0xff000000
+#define PMU2_PLL_PC1_M4DIV_SHIFT	24
+
+/* m<x>div, ndiv_dither_mfb, ndiv_mode, ndiv_int */
+#define PMU2_PLL_PLLCTL2		2
+#define PMU2_PLL_PC2_M5DIV_MASK 	0x000000ff
+#define PMU2_PLL_PC2_M5DIV_SHIFT	0
+#define PMU2_PLL_PC2_M6DIV_MASK 	0x0000ff00
+#define PMU2_PLL_PC2_M6DIV_SHIFT	8
+#define PMU2_PLL_PC2_NDIV_MODE_MASK	0x000e0000
+#define PMU2_PLL_PC2_NDIV_MODE_SHIFT	17
+#define PMU2_PLL_PC2_NDIV_INT_MASK	0x1ff00000
+#define PMU2_PLL_PC2_NDIV_INT_SHIFT	20
+
+/* ndiv_frac */
+#define PMU2_PLL_PLLCTL3		3
+#define PMU2_PLL_PC3_NDIV_FRAC_MASK	0x00ffffff
+#define PMU2_PLL_PC3_NDIV_FRAC_SHIFT	0
+
+/* pll_ctrl */
+#define PMU2_PLL_PLLCTL4		4
+
+/* pll_ctrl, vco_rng, clkdrive_ch<x> */
+#define PMU2_PLL_PLLCTL5		5
+#define PMU2_PLL_PC5_CLKDRIVE_CH1_MASK	0x00000f00
+#define PMU2_PLL_PC5_CLKDRIVE_CH1_SHIFT	8
+#define PMU2_PLL_PC5_CLKDRIVE_CH2_MASK	0x0000f000
+#define PMU2_PLL_PC5_CLKDRIVE_CH2_SHIFT	12
+#define PMU2_PLL_PC5_CLKDRIVE_CH3_MASK	0x000f0000
+#define PMU2_PLL_PC5_CLKDRIVE_CH3_SHIFT	16
+#define PMU2_PLL_PC5_CLKDRIVE_CH4_MASK	0x00f00000
+#define PMU2_PLL_PC5_CLKDRIVE_CH4_SHIFT	20
+#define PMU2_PLL_PC5_CLKDRIVE_CH5_MASK	0x0f000000
+#define PMU2_PLL_PC5_CLKDRIVE_CH5_SHIFT	24
+#define PMU2_PLL_PC5_CLKDRIVE_CH6_MASK	0xf0000000
+#define PMU2_PLL_PC5_CLKDRIVE_CH6_SHIFT	28
+
+/* PMU rev 5 (& 6) */
+#define	PMU5_PLL_P1P2_OFF		0
+#define	PMU5_PLL_P1_MASK		0x0f000000
+#define	PMU5_PLL_P1_SHIFT		24
+#define	PMU5_PLL_P2_MASK		0x00f00000
+#define	PMU5_PLL_P2_SHIFT		20
+#define	PMU5_PLL_M14_OFF		1
+#define	PMU5_PLL_MDIV_MASK		0x000000ff
+#define	PMU5_PLL_MDIV_WIDTH		8
+#define	PMU5_PLL_NM5_OFF		2
+#define	PMU5_PLL_NDIV_MASK		0xfff00000
+#define	PMU5_PLL_NDIV_SHIFT		20
+#define	PMU5_PLL_NDIV_MODE_MASK		0x000e0000
+#define	PMU5_PLL_NDIV_MODE_SHIFT	17
+#define	PMU5_PLL_FMAB_OFF		3
+#define	PMU5_PLL_MRAT_MASK		0xf0000000
+#define	PMU5_PLL_MRAT_SHIFT		28
+#define	PMU5_PLL_ABRAT_MASK		0x08000000
+#define	PMU5_PLL_ABRAT_SHIFT		27
+#define	PMU5_PLL_FDIV_MASK		0x07ffffff
+#define	PMU5_PLL_PLLCTL_OFF		4
+#define	PMU5_PLL_PCHI_OFF		5
+#define	PMU5_PLL_PCHI_MASK		0x0000003f
+
+/* pmu XtalFreqRatio */
+#define	PMU_XTALFREQ_REG_ILPCTR_MASK	0x00001FFF
+#define	PMU_XTALFREQ_REG_MEASURE_MASK	0x80000000
+#define	PMU_XTALFREQ_REG_MEASURE_SHIFT	31
+
+/* Divider allocation in 4716/47162/5356/5357 */
+#define	PMU5_MAINPLL_CPU		1
+#define	PMU5_MAINPLL_MEM		2
+#define	PMU5_MAINPLL_SI			3
+
+#define PMU7_PLL_PLLCTL7                7
+#define PMU7_PLL_PLLCTL8                8
+#define PMU7_PLL_PLLCTL11		11
+
+/* PLL usage in 4716/47162 */
+#define	PMU4716_MAINPLL_PLL0		12
+
+/* PLL usage in 5356/5357 */
+#define	PMU5356_MAINPLL_PLL0		0
+#define	PMU5357_MAINPLL_PLL0		0
+
+/* 4716/47162 resources */
+#define RES4716_PROC_PLL_ON		0x00000040
+#define RES4716_PROC_HT_AVAIL		0x00000080
+
+/* 4716/4717/4718 Chip specific ChipControl register bits */
+#define CCTRL471X_I2S_PINS_ENABLE          0x0080	/* I2S pins off by default, shared with pflash */
+
+/* 5354 resources */
+#define RES5354_EXT_SWITCHER_PWM	0	/* 0x00001 */
+#define RES5354_BB_SWITCHER_PWM		1	/* 0x00002 */
+#define RES5354_BB_SWITCHER_BURST	2	/* 0x00004 */
+#define RES5354_BB_EXT_SWITCHER_BURST	3	/* 0x00008 */
+#define RES5354_ILP_REQUEST		4	/* 0x00010 */
+#define RES5354_RADIO_SWITCHER_PWM	5	/* 0x00020 */
+#define RES5354_RADIO_SWITCHER_BURST	6	/* 0x00040 */
+#define RES5354_ROM_SWITCH		7	/* 0x00080 */
+#define RES5354_PA_REF_LDO		8	/* 0x00100 */
+#define RES5354_RADIO_LDO		9	/* 0x00200 */
+#define RES5354_AFE_LDO			10	/* 0x00400 */
+#define RES5354_PLL_LDO			11	/* 0x00800 */
+#define RES5354_BG_FILTBYP		12	/* 0x01000 */
+#define RES5354_TX_FILTBYP		13	/* 0x02000 */
+#define RES5354_RX_FILTBYP		14	/* 0x04000 */
+#define RES5354_XTAL_PU			15	/* 0x08000 */
+#define RES5354_XTAL_EN			16	/* 0x10000 */
+#define RES5354_BB_PLL_FILTBYP		17	/* 0x20000 */
+#define RES5354_RF_PLL_FILTBYP		18	/* 0x40000 */
+#define RES5354_BB_PLL_PU		19	/* 0x80000 */
+
+/* 5357 Chip specific ChipControl register bits */
+#define CCTRL5357_EXTPA                 (1<<14)	/* extPA in ChipControl 1, bit 14 */
+#define CCTRL5357_ANT_MUX_2o3		(1<<15)	/* 2o3 in ChipControl 1, bit 15 */
+
+/* 4328 resources */
+#define RES4328_EXT_SWITCHER_PWM	0	/* 0x00001 */
+#define RES4328_BB_SWITCHER_PWM		1	/* 0x00002 */
+#define RES4328_BB_SWITCHER_BURST	2	/* 0x00004 */
+#define RES4328_BB_EXT_SWITCHER_BURST	3	/* 0x00008 */
+#define RES4328_ILP_REQUEST		4	/* 0x00010 */
+#define RES4328_RADIO_SWITCHER_PWM	5	/* 0x00020 */
+#define RES4328_RADIO_SWITCHER_BURST	6	/* 0x00040 */
+#define RES4328_ROM_SWITCH		7	/* 0x00080 */
+#define RES4328_PA_REF_LDO		8	/* 0x00100 */
+#define RES4328_RADIO_LDO		9	/* 0x00200 */
+#define RES4328_AFE_LDO			10	/* 0x00400 */
+#define RES4328_PLL_LDO			11	/* 0x00800 */
+#define RES4328_BG_FILTBYP		12	/* 0x01000 */
+#define RES4328_TX_FILTBYP		13	/* 0x02000 */
+#define RES4328_RX_FILTBYP		14	/* 0x04000 */
+#define RES4328_XTAL_PU			15	/* 0x08000 */
+#define RES4328_XTAL_EN			16	/* 0x10000 */
+#define RES4328_BB_PLL_FILTBYP		17	/* 0x20000 */
+#define RES4328_RF_PLL_FILTBYP		18	/* 0x40000 */
+#define RES4328_BB_PLL_PU		19	/* 0x80000 */
+
+/* 4325 A0/A1 resources */
+#define RES4325_BUCK_BOOST_BURST	0	/* 0x00000001 */
+#define RES4325_CBUCK_BURST		1	/* 0x00000002 */
+#define RES4325_CBUCK_PWM		2	/* 0x00000004 */
+#define RES4325_CLDO_CBUCK_BURST	3	/* 0x00000008 */
+#define RES4325_CLDO_CBUCK_PWM		4	/* 0x00000010 */
+#define RES4325_BUCK_BOOST_PWM		5	/* 0x00000020 */
+#define RES4325_ILP_REQUEST		6	/* 0x00000040 */
+#define RES4325_ABUCK_BURST		7	/* 0x00000080 */
+#define RES4325_ABUCK_PWM		8	/* 0x00000100 */
+#define RES4325_LNLDO1_PU		9	/* 0x00000200 */
+#define RES4325_OTP_PU			10	/* 0x00000400 */
+#define RES4325_LNLDO3_PU		11	/* 0x00000800 */
+#define RES4325_LNLDO4_PU		12	/* 0x00001000 */
+#define RES4325_XTAL_PU			13	/* 0x00002000 */
+#define RES4325_ALP_AVAIL		14	/* 0x00004000 */
+#define RES4325_RX_PWRSW_PU		15	/* 0x00008000 */
+#define RES4325_TX_PWRSW_PU		16	/* 0x00010000 */
+#define RES4325_RFPLL_PWRSW_PU		17	/* 0x00020000 */
+#define RES4325_LOGEN_PWRSW_PU		18	/* 0x00040000 */
+#define RES4325_AFE_PWRSW_PU		19	/* 0x00080000 */
+#define RES4325_BBPLL_PWRSW_PU		20	/* 0x00100000 */
+#define RES4325_HT_AVAIL		21	/* 0x00200000 */
+
+/* 4325 B0/C0 resources */
+#define RES4325B0_CBUCK_LPOM		1	/* 0x00000002 */
+#define RES4325B0_CBUCK_BURST		2	/* 0x00000004 */
+#define RES4325B0_CBUCK_PWM		3	/* 0x00000008 */
+#define RES4325B0_CLDO_PU		4	/* 0x00000010 */
+
+/* 4325 C1 resources */
+#define RES4325C1_LNLDO2_PU		12	/* 0x00001000 */
+
+/* 4325 chip-specific ChipStatus register bits */
+#define CST4325_SPROM_OTP_SEL_MASK	0x00000003
+#define CST4325_DEFCIS_SEL		0	/* OTP is powered up, use def. CIS, no SPROM */
+#define CST4325_SPROM_SEL		1	/* OTP is powered up, SPROM is present */
+#define CST4325_OTP_SEL			2	/* OTP is powered up, no SPROM */
+#define CST4325_OTP_PWRDN		3	/* OTP is powered down, SPROM is present */
+#define CST4325_SDIO_USB_MODE_MASK	0x00000004
+#define CST4325_SDIO_USB_MODE_SHIFT	2
+#define CST4325_RCAL_VALID_MASK		0x00000008
+#define CST4325_RCAL_VALID_SHIFT	3
+#define CST4325_RCAL_VALUE_MASK		0x000001f0
+#define CST4325_RCAL_VALUE_SHIFT	4
+#define CST4325_PMUTOP_2B_MASK 		0x00000200	/* 1 for 2b, 0 for to 2a */
+#define CST4325_PMUTOP_2B_SHIFT   	9
+
+#define RES4329_RESERVED0		0	/* 0x00000001 */
+#define RES4329_CBUCK_LPOM		1	/* 0x00000002 */
+#define RES4329_CBUCK_BURST		2	/* 0x00000004 */
+#define RES4329_CBUCK_PWM		3	/* 0x00000008 */
+#define RES4329_CLDO_PU			4	/* 0x00000010 */
+#define RES4329_PALDO_PU		5	/* 0x00000020 */
+#define RES4329_ILP_REQUEST		6	/* 0x00000040 */
+#define RES4329_RESERVED7		7	/* 0x00000080 */
+#define RES4329_RESERVED8		8	/* 0x00000100 */
+#define RES4329_LNLDO1_PU		9	/* 0x00000200 */
+#define RES4329_OTP_PU			10	/* 0x00000400 */
+#define RES4329_RESERVED11		11	/* 0x00000800 */
+#define RES4329_LNLDO2_PU		12	/* 0x00001000 */
+#define RES4329_XTAL_PU			13	/* 0x00002000 */
+#define RES4329_ALP_AVAIL		14	/* 0x00004000 */
+#define RES4329_RX_PWRSW_PU		15	/* 0x00008000 */
+#define RES4329_TX_PWRSW_PU		16	/* 0x00010000 */
+#define RES4329_RFPLL_PWRSW_PU		17	/* 0x00020000 */
+#define RES4329_LOGEN_PWRSW_PU		18	/* 0x00040000 */
+#define RES4329_AFE_PWRSW_PU		19	/* 0x00080000 */
+#define RES4329_BBPLL_PWRSW_PU		20	/* 0x00100000 */
+#define RES4329_HT_AVAIL		21	/* 0x00200000 */
+
+#define CST4329_SPROM_OTP_SEL_MASK	0x00000003
+#define CST4329_DEFCIS_SEL		0	/* OTP is powered up, use def. CIS, no SPROM */
+#define CST4329_SPROM_SEL		1	/* OTP is powered up, SPROM is present */
+#define CST4329_OTP_SEL			2	/* OTP is powered up, no SPROM */
+#define CST4329_OTP_PWRDN		3	/* OTP is powered down, SPROM is present */
+#define CST4329_SPI_SDIO_MODE_MASK	0x00000004
+#define CST4329_SPI_SDIO_MODE_SHIFT	2
+
+/* 4312 chip-specific ChipStatus register bits */
+#define CST4312_SPROM_OTP_SEL_MASK	0x00000003
+#define CST4312_DEFCIS_SEL		0	/* OTP is powered up, use def. CIS, no SPROM */
+#define CST4312_SPROM_SEL		1	/* OTP is powered up, SPROM is present */
+#define CST4312_OTP_SEL			2	/* OTP is powered up, no SPROM */
+#define CST4312_OTP_BAD			3	/* OTP is broken, SPROM is present */
+
+/* 4312 resources (all PMU chips with little memory constraint) */
+#define RES4312_SWITCHER_BURST		0	/* 0x00000001 */
+#define RES4312_SWITCHER_PWM    	1	/* 0x00000002 */
+#define RES4312_PA_REF_LDO		2	/* 0x00000004 */
+#define RES4312_CORE_LDO_BURST		3	/* 0x00000008 */
+#define RES4312_CORE_LDO_PWM		4	/* 0x00000010 */
+#define RES4312_RADIO_LDO		5	/* 0x00000020 */
+#define RES4312_ILP_REQUEST		6	/* 0x00000040 */
+#define RES4312_BG_FILTBYP		7	/* 0x00000080 */
+#define RES4312_TX_FILTBYP		8	/* 0x00000100 */
+#define RES4312_RX_FILTBYP		9	/* 0x00000200 */
+#define RES4312_XTAL_PU			10	/* 0x00000400 */
+#define RES4312_ALP_AVAIL		11	/* 0x00000800 */
+#define RES4312_BB_PLL_FILTBYP		12	/* 0x00001000 */
+#define RES4312_RF_PLL_FILTBYP		13	/* 0x00002000 */
+#define RES4312_HT_AVAIL		14	/* 0x00004000 */
+
+/* 4322 resources */
+#define RES4322_RF_LDO			0
+#define RES4322_ILP_REQUEST		1
+#define RES4322_XTAL_PU			2
+#define RES4322_ALP_AVAIL		3
+#define RES4322_SI_PLL_ON		4
+#define RES4322_HT_SI_AVAIL		5
+#define RES4322_PHY_PLL_ON		6
+#define RES4322_HT_PHY_AVAIL		7
+#define RES4322_OTP_PU			8
+
+/* 4322 chip-specific ChipStatus register bits */
+#define CST4322_XTAL_FREQ_20_40MHZ	0x00000020
+#define CST4322_SPROM_OTP_SEL_MASK	0x000000c0
+#define CST4322_SPROM_OTP_SEL_SHIFT	6
+#define CST4322_NO_SPROM_OTP		0	/* no OTP, no SPROM */
+#define CST4322_SPROM_PRESENT		1	/* SPROM is present */
+#define CST4322_OTP_PRESENT		2	/* OTP is present */
+#define CST4322_PCI_OR_USB		0x00000100
+#define CST4322_BOOT_MASK		0x00000600
+#define CST4322_BOOT_SHIFT		9
+#define CST4322_BOOT_FROM_SRAM		0	/* boot from SRAM, ARM in reset */
+#define CST4322_BOOT_FROM_ROM		1	/* boot from ROM */
+#define CST4322_BOOT_FROM_FLASH		2	/* boot from FLASH */
+#define CST4322_BOOT_FROM_INVALID	3
+#define CST4322_ILP_DIV_EN		0x00000800
+#define CST4322_FLASH_TYPE_MASK		0x00001000
+#define CST4322_FLASH_TYPE_SHIFT	12
+#define CST4322_FLASH_TYPE_SHIFT_ST	0	/* ST serial FLASH */
+#define CST4322_FLASH_TYPE_SHIFT_ATMEL	1	/* ATMEL flash */
+#define CST4322_ARM_TAP_SEL		0x00002000
+#define CST4322_RES_INIT_MODE_MASK	0x0000c000
+#define CST4322_RES_INIT_MODE_SHIFT	14
+#define CST4322_RES_INIT_MODE_ILPAVAIL	0	/* resinitmode: ILP available */
+#define CST4322_RES_INIT_MODE_ILPREQ	1	/* resinitmode: ILP request */
+#define CST4322_RES_INIT_MODE_ALPAVAIL	2	/* resinitmode: ALP available */
+#define CST4322_RES_INIT_MODE_HTAVAIL	3	/* resinitmode: HT available */
+#define CST4322_PCIPLLCLK_GATING	0x00010000
+#define CST4322_CLK_SWITCH_PCI_TO_ALP	0x00020000
+#define CST4322_PCI_CARDBUS_MODE	0x00040000
+
+/* 43224 chip-specific ChipControl register bits */
+#define CCTRL43224_GPIO_TOGGLE          0x8000
+#define CCTRL_43224A0_12MA_LED_DRIVE    0x00F000F0	/* 12 mA drive strength */
+#define CCTRL_43224B0_12MA_LED_DRIVE    0xF0	/* 12 mA drive strength for later 43224s */
+
+/* 43236 resources */
+#define RES43236_REGULATOR		0
+#define RES43236_ILP_REQUEST		1
+#define RES43236_XTAL_PU		2
+#define RES43236_ALP_AVAIL		3
+#define RES43236_SI_PLL_ON		4
+#define RES43236_HT_SI_AVAIL		5
+
+/* 43236 chip-specific ChipControl register bits */
+#define CCTRL43236_BT_COEXIST		(1<<0)	/* 0 disable */
+#define CCTRL43236_SECI			(1<<1)	/* 0 SECI is disabled (JATG functional) */
+#define CCTRL43236_EXT_LNA		(1<<2)	/* 0 disable */
+#define CCTRL43236_ANT_MUX_2o3          (1<<3)	/* 2o3 mux, chipcontrol bit 3 */
+#define CCTRL43236_GSIO			(1<<4)	/* 0 disable */
+
+/* 43236 Chip specific ChipStatus register bits */
+#define CST43236_SFLASH_MASK		0x00000040
+#define CST43236_OTP_MASK		0x00000080
+#define CST43236_HSIC_MASK		0x00000100	/* USB/HSIC */
+#define CST43236_BP_CLK			0x00000200	/* 120/96Mbps */
+#define CST43236_BOOT_MASK		0x00001800
+#define CST43236_BOOT_SHIFT		11
+#define CST43236_BOOT_FROM_SRAM		0	/* boot from SRAM, ARM in reset */
+#define CST43236_BOOT_FROM_ROM		1	/* boot from ROM */
+#define CST43236_BOOT_FROM_FLASH	2	/* boot from FLASH */
+#define CST43236_BOOT_FROM_INVALID	3
+
+/* 4331 resources */
+#define RES4331_REGULATOR		0
+#define RES4331_ILP_REQUEST		1
+#define RES4331_XTAL_PU			2
+#define RES4331_ALP_AVAIL		3
+#define RES4331_SI_PLL_ON		4
+#define RES4331_HT_SI_AVAIL		5
+
+/* 4331 chip-specific ChipControl register bits */
+#define CCTRL4331_BT_COEXIST		(1<<0)	/* 0 disable */
+#define CCTRL4331_SECI			(1<<1)	/* 0 SECI is disabled (JATG functional) */
+#define CCTRL4331_EXT_LNA		(1<<2)	/* 0 disable */
+#define CCTRL4331_SPROM_GPIO13_15       (1<<3)	/* sprom/gpio13-15 mux */
+#define CCTRL4331_EXTPA_EN		(1<<4)	/* 0 ext pa disable, 1 ext pa enabled */
+#define CCTRL4331_GPIOCLK_ON_SPROMCS	<1<<5)	/* set drive out GPIO_CLK on sprom_cs pin */
+#define CCTRL4331_PCIE_MDIO_ON_SPROMCS	(1<<6)	/* use sprom_cs pin as PCIE mdio interface */
+#define CCTRL4331_EXTPA_ON_GPIO2_5	(1<<7)	/* aband extpa will be at gpio2/5 and sprom_dout */
+#define CCTRL4331_OVR_PIPEAUXCLKEN	(1<<8)	/* override core control on pipe_AuxClkEnable */
+#define CCTRL4331_OVR_PIPEAUXPWRDOWN	(1<<9)	/* override core control on pipe_AuxPowerDown */
+#define CCTRL4331_PCIE_AUXCLKEN		<1<<10)	/* pcie_auxclkenable */
+#define CCTRL4331_PCIE_PIPE_PLLDOWN	<1<<11)	/* pcie_pipe_pllpowerdown */
+#define CCTRL4331_BT_SHD0_ON_GPIO4	<1<<16)	/* enable bt_shd0 at gpio4 */
+#define CCTRL4331_BT_SHD1_ON_GPIO5	<1<<17)	/* enable bt_shd1 at gpio5 */
+
+/* 4331 Chip specific ChipStatus register bits */
+#define	CST4331_XTAL_FREQ		0x00000001	/* crystal frequency 20/40Mhz */
+#define	CST4331_SPROM_PRESENT		0x00000002
+#define	CST4331_OTP_PRESENT		0x00000004
+#define	CST4331_LDO_RF			0x00000008
+#define	CST4331_LDO_PAR			0x00000010
+
+/* 4315 resources */
+#define RES4315_CBUCK_LPOM		1	/* 0x00000002 */
+#define RES4315_CBUCK_BURST		2	/* 0x00000004 */
+#define RES4315_CBUCK_PWM		3	/* 0x00000008 */
+#define RES4315_CLDO_PU			4	/* 0x00000010 */
+#define RES4315_PALDO_PU		5	/* 0x00000020 */
+#define RES4315_ILP_REQUEST		6	/* 0x00000040 */
+#define RES4315_LNLDO1_PU		9	/* 0x00000200 */
+#define RES4315_OTP_PU			10	/* 0x00000400 */
+#define RES4315_LNLDO2_PU		12	/* 0x00001000 */
+#define RES4315_XTAL_PU			13	/* 0x00002000 */
+#define RES4315_ALP_AVAIL		14	/* 0x00004000 */
+#define RES4315_RX_PWRSW_PU		15	/* 0x00008000 */
+#define RES4315_TX_PWRSW_PU		16	/* 0x00010000 */
+#define RES4315_RFPLL_PWRSW_PU		17	/* 0x00020000 */
+#define RES4315_LOGEN_PWRSW_PU		18	/* 0x00040000 */
+#define RES4315_AFE_PWRSW_PU		19	/* 0x00080000 */
+#define RES4315_BBPLL_PWRSW_PU		20	/* 0x00100000 */
+#define RES4315_HT_AVAIL		21	/* 0x00200000 */
+
+/* 4315 chip-specific ChipStatus register bits */
+#define CST4315_SPROM_OTP_SEL_MASK	0x00000003	/* gpio [7:6], SDIO CIS selection */
+#define CST4315_DEFCIS_SEL		0x00000000	/* use default CIS, OTP is powered up */
+#define CST4315_SPROM_SEL		0x00000001	/* use SPROM, OTP is powered up */
+#define CST4315_OTP_SEL			0x00000002	/* use OTP, OTP is powered up */
+#define CST4315_OTP_PWRDN		0x00000003	/* use SPROM, OTP is powered down */
+#define CST4315_SDIO_MODE		0x00000004	/* gpio [8], sdio/usb mode */
+#define CST4315_RCAL_VALID		0x00000008
+#define CST4315_RCAL_VALUE_MASK		0x000001f0
+#define CST4315_RCAL_VALUE_SHIFT	4
+#define CST4315_PALDO_EXTPNP		0x00000200	/* PALDO is configured with external PNP */
+#define CST4315_CBUCK_MODE_MASK		0x00000c00
+#define CST4315_CBUCK_MODE_BURST	0x00000400
+#define CST4315_CBUCK_MODE_LPBURST	0x00000c00
+
+/* 4319 resources */
+#define RES4319_CBUCK_LPOM		1	/* 0x00000002 */
+#define RES4319_CBUCK_BURST		2	/* 0x00000004 */
+#define RES4319_CBUCK_PWM		3	/* 0x00000008 */
+#define RES4319_CLDO_PU			4	/* 0x00000010 */
+#define RES4319_PALDO_PU		5	/* 0x00000020 */
+#define RES4319_ILP_REQUEST		6	/* 0x00000040 */
+#define RES4319_LNLDO1_PU		9	/* 0x00000200 */
+#define RES4319_OTP_PU			10	/* 0x00000400 */
+#define RES4319_LNLDO2_PU		12	/* 0x00001000 */
+#define RES4319_XTAL_PU			13	/* 0x00002000 */
+#define RES4319_ALP_AVAIL		14	/* 0x00004000 */
+#define RES4319_RX_PWRSW_PU		15	/* 0x00008000 */
+#define RES4319_TX_PWRSW_PU		16	/* 0x00010000 */
+#define RES4319_RFPLL_PWRSW_PU		17	/* 0x00020000 */
+#define RES4319_LOGEN_PWRSW_PU		18	/* 0x00040000 */
+#define RES4319_AFE_PWRSW_PU		19	/* 0x00080000 */
+#define RES4319_BBPLL_PWRSW_PU		20	/* 0x00100000 */
+#define RES4319_HT_AVAIL		21	/* 0x00200000 */
+
+/* 4319 chip-specific ChipStatus register bits */
+#define	CST4319_SPI_CPULESSUSB		0x00000001
+#define	CST4319_SPI_CLK_POL		0x00000002
+#define	CST4319_SPI_CLK_PH		0x00000008
+#define	CST4319_SPROM_OTP_SEL_MASK	0x000000c0	/* gpio [7:6], SDIO CIS selection */
+#define	CST4319_SPROM_OTP_SEL_SHIFT	6
+#define	CST4319_DEFCIS_SEL		0x00000000	/* use default CIS, OTP is powered up */
+#define	CST4319_SPROM_SEL		0x00000040	/* use SPROM, OTP is powered up */
+#define	CST4319_OTP_SEL			0x00000080	/* use OTP, OTP is powered up */
+#define	CST4319_OTP_PWRDN		0x000000c0	/* use SPROM, OTP is powered down */
+#define	CST4319_SDIO_USB_MODE		0x00000100	/* gpio [8], sdio/usb mode */
+#define	CST4319_REMAP_SEL_MASK		0x00000600
+#define	CST4319_ILPDIV_EN		0x00000800
+#define	CST4319_XTAL_PD_POL		0x00001000
+#define	CST4319_LPO_SEL			0x00002000
+#define	CST4319_RES_INIT_MODE		0x0000c000
+#define	CST4319_PALDO_EXTPNP		0x00010000	/* PALDO is configured with external PNP */
+#define	CST4319_CBUCK_MODE_MASK		0x00060000
+#define CST4319_CBUCK_MODE_BURST	0x00020000
+#define CST4319_CBUCK_MODE_LPBURST	0x00060000
+#define	CST4319_RCAL_VALID		0x01000000
+#define	CST4319_RCAL_VALUE_MASK		0x3e000000
+#define	CST4319_RCAL_VALUE_SHIFT	25
+
+#define PMU1_PLL0_CHIPCTL0		0
+#define PMU1_PLL0_CHIPCTL1		1
+#define PMU1_PLL0_CHIPCTL2		2
+#define CCTL_4319USB_XTAL_SEL_MASK	0x00180000
+#define CCTL_4319USB_XTAL_SEL_SHIFT	19
+#define CCTL_4319USB_48MHZ_PLL_SEL	1
+#define CCTL_4319USB_24MHZ_PLL_SEL	2
+
+/* PMU resources for 4336 */
+#define	RES4336_CBUCK_LPOM		0
+#define	RES4336_CBUCK_BURST		1
+#define	RES4336_CBUCK_LP_PWM		2
+#define	RES4336_CBUCK_PWM		3
+#define	RES4336_CLDO_PU			4
+#define	RES4336_DIS_INT_RESET_PD	5
+#define	RES4336_ILP_REQUEST		6
+#define	RES4336_LNLDO_PU		7
+#define	RES4336_LDO3P3_PU		8
+#define	RES4336_OTP_PU			9
+#define	RES4336_XTAL_PU			10
+#define	RES4336_ALP_AVAIL		11
+#define	RES4336_RADIO_PU		12
+#define	RES4336_BG_PU			13
+#define	RES4336_VREG1p4_PU_PU		14
+#define	RES4336_AFE_PWRSW_PU		15
+#define	RES4336_RX_PWRSW_PU		16
+#define	RES4336_TX_PWRSW_PU		17
+#define	RES4336_BB_PWRSW_PU		18
+#define	RES4336_SYNTH_PWRSW_PU		19
+#define	RES4336_MISC_PWRSW_PU		20
+#define	RES4336_LOGEN_PWRSW_PU		21
+#define	RES4336_BBPLL_PWRSW_PU		22
+#define	RES4336_MACPHY_CLKAVAIL		23
+#define	RES4336_HT_AVAIL		24
+#define	RES4336_RSVD			25
+
+/* 4336 chip-specific ChipStatus register bits */
+#define	CST4336_SPI_MODE_MASK		0x00000001
+#define	CST4336_SPROM_PRESENT		0x00000002
+#define	CST4336_OTP_PRESENT		0x00000004
+#define	CST4336_ARMREMAP_0		0x00000008
+#define	CST4336_ILPDIV_EN_MASK		0x00000010
+#define	CST4336_ILPDIV_EN_SHIFT		4
+#define	CST4336_XTAL_PD_POL_MASK	0x00000020
+#define	CST4336_XTAL_PD_POL_SHIFT	5
+#define	CST4336_LPO_SEL_MASK		0x00000040
+#define	CST4336_LPO_SEL_SHIFT		6
+#define	CST4336_RES_INIT_MODE_MASK	0x00000180
+#define	CST4336_RES_INIT_MODE_SHIFT	7
+#define	CST4336_CBUCK_MODE_MASK		0x00000600
+#define	CST4336_CBUCK_MODE_SHIFT	9
+
+/* 4330 resources */
+#define	RES4330_CBUCK_LPOM		0
+#define	RES4330_CBUCK_BURST		1
+#define	RES4330_CBUCK_LP_PWM		2
+#define	RES4330_CBUCK_PWM		3
+#define	RES4330_CLDO_PU			4
+#define	RES4330_DIS_INT_RESET_PD	5
+#define	RES4330_ILP_REQUEST		6
+#define	RES4330_LNLDO_PU		7
+#define	RES4330_LDO3P3_PU		8
+#define	RES4330_OTP_PU			9
+#define	RES4330_XTAL_PU			10
+#define	RES4330_ALP_AVAIL		11
+#define	RES4330_RADIO_PU		12
+#define	RES4330_BG_PU			13
+#define	RES4330_VREG1p4_PU_PU		14
+#define	RES4330_AFE_PWRSW_PU		15
+#define	RES4330_RX_PWRSW_PU		16
+#define	RES4330_TX_PWRSW_PU		17
+#define	RES4330_BB_PWRSW_PU		18
+#define	RES4330_SYNTH_PWRSW_PU		19
+#define	RES4330_MISC_PWRSW_PU		20
+#define	RES4330_LOGEN_PWRSW_PU		21
+#define	RES4330_BBPLL_PWRSW_PU		22
+#define	RES4330_MACPHY_CLKAVAIL		23
+#define	RES4330_HT_AVAIL		24
+#define	RES4330_5gRX_PWRSW_PU		25
+#define	RES4330_5gTX_PWRSW_PU		26
+#define	RES4330_5g_LOGEN_PWRSW_PU	27
+
+/* 4330 chip-specific ChipStatus register bits */
+#define CST4330_CHIPMODE_SDIOD(cs)	(((cs) & 0x7) < 6)	/* SDIO || gSPI */
+#define CST4330_CHIPMODE_USB20D(cs)	(((cs) & 0x7) >= 6)	/* USB || USBDA */
+#define CST4330_CHIPMODE_SDIO(cs)	(((cs) & 0x4) == 0)	/* SDIO */
+#define CST4330_CHIPMODE_GSPI(cs)	(((cs) & 0x6) == 4)	/* gSPI */
+#define CST4330_CHIPMODE_USB(cs)	(((cs) & 0x7) == 6)	/* USB packet-oriented */
+#define CST4330_CHIPMODE_USBDA(cs)	(((cs) & 0x7) == 7)	/* USB Direct Access */
+#define	CST4330_OTP_PRESENT		0x00000010
+#define	CST4330_LPO_AUTODET_EN		0x00000020
+#define	CST4330_ARMREMAP_0		0x00000040
+#define	CST4330_SPROM_PRESENT		0x00000080	/* takes priority over OTP if both set */
+#define	CST4330_ILPDIV_EN		0x00000100
+#define	CST4330_LPO_SEL			0x00000200
+#define	CST4330_RES_INIT_MODE_SHIFT	10
+#define	CST4330_RES_INIT_MODE_MASK	0x00000c00
+#define CST4330_CBUCK_MODE_SHIFT	12
+#define CST4330_CBUCK_MODE_MASK		0x00003000
+#define	CST4330_CBUCK_POWER_OK		0x00004000
+#define	CST4330_BB_PLL_LOCKED		0x00008000
+#define SOCDEVRAM_4330_BP_ADDR		0x1E000000
+#define SOCDEVRAM_4330_ARM_ADDR		0x00800000
+
+/* 4313 resources */
+#define	RES4313_BB_PU_RSRC		0
+#define	RES4313_ILP_REQ_RSRC		1
+#define	RES4313_XTAL_PU_RSRC		2
+#define	RES4313_ALP_AVAIL_RSRC		3
+#define	RES4313_RADIO_PU_RSRC		4
+#define	RES4313_BG_PU_RSRC		5
+#define	RES4313_VREG1P4_PU_RSRC		6
+#define	RES4313_AFE_PWRSW_RSRC		7
+#define	RES4313_RX_PWRSW_RSRC		8
+#define	RES4313_TX_PWRSW_RSRC		9
+#define	RES4313_BB_PWRSW_RSRC		10
+#define	RES4313_SYNTH_PWRSW_RSRC	11
+#define	RES4313_MISC_PWRSW_RSRC		12
+#define	RES4313_BB_PLL_PWRSW_RSRC	13
+#define	RES4313_HT_AVAIL_RSRC		14
+#define	RES4313_MACPHY_CLK_AVAIL_RSRC	15
+
+/* 4313 chip-specific ChipStatus register bits */
+#define	CST4313_SPROM_PRESENT			1
+#define	CST4313_OTP_PRESENT			2
+#define	CST4313_SPROM_OTP_SEL_MASK		0x00000002
+#define	CST4313_SPROM_OTP_SEL_SHIFT		0
+
+/* 4313 Chip specific ChipControl register bits */
+#define CCTRL_4313_12MA_LED_DRIVE    0x00000007	/* 12 mA drive strengh for later 4313 */
+
+/* 43228 resources */
+#define RES43228_NOT_USED		0
+#define RES43228_ILP_REQUEST		1
+#define RES43228_XTAL_PU		2
+#define RES43228_ALP_AVAIL		3
+#define RES43228_PLL_EN			4
+#define RES43228_HT_PHY_AVAIL		5
+
+/* 43228 chipstatus  reg bits */
+#define CST43228_ILP_DIV_EN		0x1
+#define	CST43228_OTP_PRESENT		0x2
+#define	CST43228_SERDES_REFCLK_PADSEL	0x4
+#define	CST43228_SDIO_MODE		0x8
+
+#define	CST43228_SDIO_OTP_PRESENT	0x10
+#define	CST43228_SDIO_RESET		0x20
+
+/*
+* Maximum delay for the PMU state transition in us.
+* This is an upper bound intended for spinwaits etc.
+*/
+#define PMU_MAX_TRANSITION_DLY	15000
+
+/* PMU resource up transition time in ILP cycles */
+#define PMURES_UP_TRANSITION	2
+
+/*
+* Register eci_inputlo bitfield values.
+* - BT packet type information bits [7:0]
+*/
+/*  [3:0] - Task (link) type */
+#define BT_ACL				0x00
+#define BT_SCO				0x01
+#define BT_eSCO				0x02
+#define BT_A2DP				0x03
+#define BT_SNIFF			0x04
+#define BT_PAGE_SCAN			0x05
+#define BT_INQUIRY_SCAN			0x06
+#define BT_PAGE				0x07
+#define BT_INQUIRY			0x08
+#define BT_MSS				0x09
+#define BT_PARK				0x0a
+#define BT_RSSISCAN			0x0b
+#define BT_MD_ACL			0x0c
+#define BT_MD_eSCO			0x0d
+#define BT_SCAN_WITH_SCO_LINK		0x0e
+#define BT_SCAN_WITHOUT_SCO_LINK	0x0f
+/* [7:4] = packet duration code */
+/* [8] - Master / Slave */
+#define BT_MASTER			0
+#define BT_SLAVE			1
+/* [11:9] - multi-level priority */
+#define BT_LOWEST_PRIO			0x0
+#define BT_HIGHEST_PRIO			0x3
+
+/* WLAN - number of antenna */
+#define WLAN_NUM_ANT1 TXANT_0
+#define WLAN_NUM_ANT2 TXANT_1
+
+#endif				/* _SBCHIPC_H */
diff --git a/drivers/staging/brcm80211/include/sbconfig.h b/drivers/staging/brcm80211/include/sbconfig.h
new file mode 100644
index 0000000..c296f60
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbconfig.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SBCONFIG_H
+#define	_SBCONFIG_H
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/* enumeration in SB is based on the premise that cores are contiguos in the
+ * enumeration space.
+ */
+#define SB_BUS_SIZE		0x10000	/* Each bus gets 64Kbytes for cores */
+#define SB_BUS_BASE(b)		(SI_ENUM_BASE + (b) * SB_BUS_SIZE)
+#define	SB_BUS_MAXCORES		(SB_BUS_SIZE / SI_CORE_SIZE)	/* Max cores per bus */
+
+/*
+ * Sonics Configuration Space Registers.
+ */
+#define	SBCONFIGOFF		0xf00	/* core sbconfig regs are top 256bytes of regs */
+#define	SBCONFIGSIZE		256	/* sizeof (sbconfig_t) */
+
+#define SBIPSFLAG		0x08
+#define SBTPSFLAG		0x18
+#define	SBTMERRLOGA		0x48	/* sonics >= 2.3 */
+#define	SBTMERRLOG		0x50	/* sonics >= 2.3 */
+#define SBADMATCH3		0x60
+#define SBADMATCH2		0x68
+#define SBADMATCH1		0x70
+#define SBIMSTATE		0x90
+#define SBINTVEC		0x94
+#define SBTMSTATELOW		0x98
+#define SBTMSTATEHIGH		0x9c
+#define SBBWA0			0xa0
+#define SBIMCONFIGLOW		0xa8
+#define SBIMCONFIGHIGH		0xac
+#define SBADMATCH0		0xb0
+#define SBTMCONFIGLOW		0xb8
+#define SBTMCONFIGHIGH		0xbc
+#define SBBCONFIG		0xc0
+#define SBBSTATE		0xc8
+#define SBACTCNFG		0xd8
+#define	SBFLAGST		0xe8
+#define SBIDLOW			0xf8
+#define SBIDHIGH		0xfc
+
+/* All the previous registers are above SBCONFIGOFF, but with Sonics 2.3, we have
+ * a few registers *below* that line. I think it would be very confusing to try
+ * and change the value of SBCONFIGOFF, so I'm definig them as absolute offsets here,
+ */
+
+#define SBIMERRLOGA		0xea8
+#define SBIMERRLOG		0xeb0
+#define SBTMPORTCONNID0		0xed8
+#define SBTMPORTLOCK0		0xef8
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+typedef volatile struct _sbconfig {
+	uint32 PAD[2];
+	uint32 sbipsflag;	/* initiator port ocp slave flag */
+	uint32 PAD[3];
+	uint32 sbtpsflag;	/* target port ocp slave flag */
+	uint32 PAD[11];
+	uint32 sbtmerrloga;	/* (sonics >= 2.3) */
+	uint32 PAD;
+	uint32 sbtmerrlog;	/* (sonics >= 2.3) */
+	uint32 PAD[3];
+	uint32 sbadmatch3;	/* address match3 */
+	uint32 PAD;
+	uint32 sbadmatch2;	/* address match2 */
+	uint32 PAD;
+	uint32 sbadmatch1;	/* address match1 */
+	uint32 PAD[7];
+	uint32 sbimstate;	/* initiator agent state */
+	uint32 sbintvec;	/* interrupt mask */
+	uint32 sbtmstatelow;	/* target state */
+	uint32 sbtmstatehigh;	/* target state */
+	uint32 sbbwa0;		/* bandwidth allocation table0 */
+	uint32 PAD;
+	uint32 sbimconfiglow;	/* initiator configuration */
+	uint32 sbimconfighigh;	/* initiator configuration */
+	uint32 sbadmatch0;	/* address match0 */
+	uint32 PAD;
+	uint32 sbtmconfiglow;	/* target configuration */
+	uint32 sbtmconfighigh;	/* target configuration */
+	uint32 sbbconfig;	/* broadcast configuration */
+	uint32 PAD;
+	uint32 sbbstate;	/* broadcast state */
+	uint32 PAD[3];
+	uint32 sbactcnfg;	/* activate configuration */
+	uint32 PAD[3];
+	uint32 sbflagst;	/* current sbflags */
+	uint32 PAD[3];
+	uint32 sbidlow;		/* identification */
+	uint32 sbidhigh;	/* identification */
+} sbconfig_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* sbipsflag */
+#define	SBIPS_INT1_MASK		0x3f	/* which sbflags get routed to mips interrupt 1 */
+#define	SBIPS_INT1_SHIFT	0
+#define	SBIPS_INT2_MASK		0x3f00	/* which sbflags get routed to mips interrupt 2 */
+#define	SBIPS_INT2_SHIFT	8
+#define	SBIPS_INT3_MASK		0x3f0000	/* which sbflags get routed to mips interrupt 3 */
+#define	SBIPS_INT3_SHIFT	16
+#define	SBIPS_INT4_MASK		0x3f000000	/* which sbflags get routed to mips interrupt 4 */
+#define	SBIPS_INT4_SHIFT	24
+
+/* sbtpsflag */
+#define	SBTPS_NUM0_MASK		0x3f	/* interrupt sbFlag # generated by this core */
+#define	SBTPS_F0EN0		0x40	/* interrupt is always sent on the backplane */
+
+/* sbtmerrlog */
+#define	SBTMEL_CM		0x00000007	/* command */
+#define	SBTMEL_CI		0x0000ff00	/* connection id */
+#define	SBTMEL_EC		0x0f000000	/* error code */
+#define	SBTMEL_ME		0x80000000	/* multiple error */
+
+/* sbimstate */
+#define	SBIM_PC			0xf	/* pipecount */
+#define	SBIM_AP_MASK		0x30	/* arbitration policy */
+#define	SBIM_AP_BOTH		0x00	/* use both timeslaces and token */
+#define	SBIM_AP_TS		0x10	/* use timesliaces only */
+#define	SBIM_AP_TK		0x20	/* use token only */
+#define	SBIM_AP_RSV		0x30	/* reserved */
+#define	SBIM_IBE		0x20000	/* inbanderror */
+#define	SBIM_TO			0x40000	/* timeout */
+#define	SBIM_BY			0x01800000	/* busy (sonics >= 2.3) */
+#define	SBIM_RJ			0x02000000	/* reject (sonics >= 2.3) */
+
+/* sbtmstatelow */
+#define	SBTML_RESET		0x0001	/* reset */
+#define	SBTML_REJ_MASK		0x0006	/* reject field */
+#define	SBTML_REJ		0x0002	/* reject */
+#define	SBTML_TMPREJ		0x0004	/* temporary reject, for error recovery */
+
+#define	SBTML_SICF_SHIFT	16	/* Shift to locate the SI control flags in sbtml */
+
+/* sbtmstatehigh */
+#define	SBTMH_SERR		0x0001	/* serror */
+#define	SBTMH_INT		0x0002	/* interrupt */
+#define	SBTMH_BUSY		0x0004	/* busy */
+#define	SBTMH_TO		0x0020	/* timeout (sonics >= 2.3) */
+
+#define	SBTMH_SISF_SHIFT	16	/* Shift to locate the SI status flags in sbtmh */
+
+/* sbbwa0 */
+#define	SBBWA_TAB0_MASK		0xffff	/* lookup table 0 */
+#define	SBBWA_TAB1_MASK		0xffff	/* lookup table 1 */
+#define	SBBWA_TAB1_SHIFT	16
+
+/* sbimconfiglow */
+#define	SBIMCL_STO_MASK		0x7	/* service timeout */
+#define	SBIMCL_RTO_MASK		0x70	/* request timeout */
+#define	SBIMCL_RTO_SHIFT	4
+#define	SBIMCL_CID_MASK		0xff0000	/* connection id */
+#define	SBIMCL_CID_SHIFT	16
+
+/* sbimconfighigh */
+#define	SBIMCH_IEM_MASK		0xc	/* inband error mode */
+#define	SBIMCH_TEM_MASK		0x30	/* timeout error mode */
+#define	SBIMCH_TEM_SHIFT	4
+#define	SBIMCH_BEM_MASK		0xc0	/* bus error mode */
+#define	SBIMCH_BEM_SHIFT	6
+
+/* sbadmatch0 */
+#define	SBAM_TYPE_MASK		0x3	/* address type */
+#define	SBAM_AD64		0x4	/* reserved */
+#define	SBAM_ADINT0_MASK	0xf8	/* type0 size */
+#define	SBAM_ADINT0_SHIFT	3
+#define	SBAM_ADINT1_MASK	0x1f8	/* type1 size */
+#define	SBAM_ADINT1_SHIFT	3
+#define	SBAM_ADINT2_MASK	0x1f8	/* type2 size */
+#define	SBAM_ADINT2_SHIFT	3
+#define	SBAM_ADEN		0x400	/* enable */
+#define	SBAM_ADNEG		0x800	/* negative decode */
+#define	SBAM_BASE0_MASK		0xffffff00	/* type0 base address */
+#define	SBAM_BASE0_SHIFT	8
+#define	SBAM_BASE1_MASK		0xfffff000	/* type1 base address for the core */
+#define	SBAM_BASE1_SHIFT	12
+#define	SBAM_BASE2_MASK		0xffff0000	/* type2 base address for the core */
+#define	SBAM_BASE2_SHIFT	16
+
+/* sbtmconfiglow */
+#define	SBTMCL_CD_MASK		0xff	/* clock divide */
+#define	SBTMCL_CO_MASK		0xf800	/* clock offset */
+#define	SBTMCL_CO_SHIFT		11
+#define	SBTMCL_IF_MASK		0xfc0000	/* interrupt flags */
+#define	SBTMCL_IF_SHIFT		18
+#define	SBTMCL_IM_MASK		0x3000000	/* interrupt mode */
+#define	SBTMCL_IM_SHIFT		24
+
+/* sbtmconfighigh */
+#define	SBTMCH_BM_MASK		0x3	/* busy mode */
+#define	SBTMCH_RM_MASK		0x3	/* retry mode */
+#define	SBTMCH_RM_SHIFT		2
+#define	SBTMCH_SM_MASK		0x30	/* stop mode */
+#define	SBTMCH_SM_SHIFT		4
+#define	SBTMCH_EM_MASK		0x300	/* sb error mode */
+#define	SBTMCH_EM_SHIFT		8
+#define	SBTMCH_IM_MASK		0xc00	/* int mode */
+#define	SBTMCH_IM_SHIFT		10
+
+/* sbbconfig */
+#define	SBBC_LAT_MASK		0x3	/* sb latency */
+#define	SBBC_MAX0_MASK		0xf0000	/* maxccntr0 */
+#define	SBBC_MAX0_SHIFT		16
+#define	SBBC_MAX1_MASK		0xf00000	/* maxccntr1 */
+#define	SBBC_MAX1_SHIFT		20
+
+/* sbbstate */
+#define	SBBS_SRD		0x1	/* st reg disable */
+#define	SBBS_HRD		0x2	/* hold reg disable */
+
+/* sbidlow */
+#define	SBIDL_CS_MASK		0x3	/* config space */
+#define	SBIDL_AR_MASK		0x38	/* # address ranges supported */
+#define	SBIDL_AR_SHIFT		3
+#define	SBIDL_SYNCH		0x40	/* sync */
+#define	SBIDL_INIT		0x80	/* initiator */
+#define	SBIDL_MINLAT_MASK	0xf00	/* minimum backplane latency */
+#define	SBIDL_MINLAT_SHIFT	8
+#define	SBIDL_MAXLAT		0xf000	/* maximum backplane latency */
+#define	SBIDL_MAXLAT_SHIFT	12
+#define	SBIDL_FIRST		0x10000	/* this initiator is first */
+#define	SBIDL_CW_MASK		0xc0000	/* cycle counter width */
+#define	SBIDL_CW_SHIFT		18
+#define	SBIDL_TP_MASK		0xf00000	/* target ports */
+#define	SBIDL_TP_SHIFT		20
+#define	SBIDL_IP_MASK		0xf000000	/* initiator ports */
+#define	SBIDL_IP_SHIFT		24
+#define	SBIDL_RV_MASK		0xf0000000	/* sonics backplane revision code */
+#define	SBIDL_RV_SHIFT		28
+#define	SBIDL_RV_2_2		0x00000000	/* version 2.2 or earlier */
+#define	SBIDL_RV_2_3		0x10000000	/* version 2.3 */
+
+/* sbidhigh */
+#define	SBIDH_RC_MASK		0x000f	/* revision code */
+#define	SBIDH_RCE_MASK		0x7000	/* revision code extension field */
+#define	SBIDH_RCE_SHIFT		8
+#define	SBCOREREV(sbidh) \
+	((((sbidh) & SBIDH_RCE_MASK) >> SBIDH_RCE_SHIFT) | ((sbidh) & SBIDH_RC_MASK))
+#define	SBIDH_CC_MASK		0x8ff0	/* core code */
+#define	SBIDH_CC_SHIFT		4
+#define	SBIDH_VC_MASK		0xffff0000	/* vendor code */
+#define	SBIDH_VC_SHIFT		16
+
+#define	SB_COMMIT		0xfd8	/* update buffered registers value */
+
+/* vendor codes */
+#define	SB_VEND_BCM		0x4243	/* Broadcom's SB vendor code */
+
+#endif				/* _SBCONFIG_H */
diff --git a/drivers/staging/brcm80211/include/sbhnddma.h b/drivers/staging/brcm80211/include/sbhnddma.h
new file mode 100644
index 0000000..598d68b
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbhnddma.h
@@ -0,0 +1,315 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_sbhnddma_h_
+#define	_sbhnddma_h_
+
+/* DMA structure:
+ *  support two DMA engines: 32 bits address or 64 bit addressing
+ *  basic DMA register set is per channel(transmit or receive)
+ *  a pair of channels is defined for convenience
+ */
+
+/* 32 bits addressing */
+
+/* dma registers per channel(xmt or rcv) */
+typedef volatile struct {
+	uint32 control;		/* enable, et al */
+	uint32 addr;		/* descriptor ring base address (4K aligned) */
+	uint32 ptr;		/* last descriptor posted to chip */
+	uint32 status;		/* current active descriptor, et al */
+} dma32regs_t;
+
+typedef volatile struct {
+	dma32regs_t xmt;	/* dma tx channel */
+	dma32regs_t rcv;	/* dma rx channel */
+} dma32regp_t;
+
+typedef volatile struct {	/* diag access */
+	uint32 fifoaddr;	/* diag address */
+	uint32 fifodatalow;	/* low 32bits of data */
+	uint32 fifodatahigh;	/* high 32bits of data */
+	uint32 pad;		/* reserved */
+} dma32diag_t;
+
+/*
+ * DMA Descriptor
+ * Descriptors are only read by the hardware, never written back.
+ */
+typedef volatile struct {
+	uint32 ctrl;		/* misc control bits & bufcount */
+	uint32 addr;		/* data buffer address */
+} dma32dd_t;
+
+/*
+ * Each descriptor ring must be 4096byte aligned, and fit within a single 4096byte page.
+ */
+#define	D32RINGALIGN_BITS	12
+#define	D32MAXRINGSZ		(1 << D32RINGALIGN_BITS)
+#define	D32RINGALIGN		(1 << D32RINGALIGN_BITS)
+
+#define	D32MAXDD	(D32MAXRINGSZ / sizeof (dma32dd_t))
+
+/* transmit channel control */
+#define	XC_XE		((uint32)1 << 0)	/* transmit enable */
+#define	XC_SE		((uint32)1 << 1)	/* transmit suspend request */
+#define	XC_LE		((uint32)1 << 2)	/* loopback enable */
+#define	XC_FL		((uint32)1 << 4)	/* flush request */
+#define	XC_PD		((uint32)1 << 11)	/* parity check disable */
+#define	XC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	XC_AE_SHIFT	16
+
+/* transmit descriptor table pointer */
+#define	XP_LD_MASK	0xfff	/* last valid descriptor */
+
+/* transmit channel status */
+#define	XS_CD_MASK	0x0fff	/* current descriptor pointer */
+#define	XS_XS_MASK	0xf000	/* transmit state */
+#define	XS_XS_SHIFT	12
+#define	XS_XS_DISABLED	0x0000	/* disabled */
+#define	XS_XS_ACTIVE	0x1000	/* active */
+#define	XS_XS_IDLE	0x2000	/* idle wait */
+#define	XS_XS_STOPPED	0x3000	/* stopped */
+#define	XS_XS_SUSP	0x4000	/* suspend pending */
+#define	XS_XE_MASK	0xf0000	/* transmit errors */
+#define	XS_XE_SHIFT	16
+#define	XS_XE_NOERR	0x00000	/* no error */
+#define	XS_XE_DPE	0x10000	/* descriptor protocol error */
+#define	XS_XE_DFU	0x20000	/* data fifo underrun */
+#define	XS_XE_BEBR	0x30000	/* bus error on buffer read */
+#define	XS_XE_BEDA	0x40000	/* bus error on descriptor access */
+#define	XS_AD_MASK	0xfff00000	/* active descriptor */
+#define	XS_AD_SHIFT	20
+
+/* receive channel control */
+#define	RC_RE		((uint32)1 << 0)	/* receive enable */
+#define	RC_RO_MASK	0xfe	/* receive frame offset */
+#define	RC_RO_SHIFT	1
+#define	RC_FM		((uint32)1 << 8)	/* direct fifo receive (pio) mode */
+#define	RC_SH		((uint32)1 << 9)	/* separate rx header descriptor enable */
+#define	RC_OC		((uint32)1 << 10)	/* overflow continue */
+#define	RC_PD		((uint32)1 << 11)	/* parity check disable */
+#define	RC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	RC_AE_SHIFT	16
+
+/* receive descriptor table pointer */
+#define	RP_LD_MASK	0xfff	/* last valid descriptor */
+
+/* receive channel status */
+#define	RS_CD_MASK	0x0fff	/* current descriptor pointer */
+#define	RS_RS_MASK	0xf000	/* receive state */
+#define	RS_RS_SHIFT	12
+#define	RS_RS_DISABLED	0x0000	/* disabled */
+#define	RS_RS_ACTIVE	0x1000	/* active */
+#define	RS_RS_IDLE	0x2000	/* idle wait */
+#define	RS_RS_STOPPED	0x3000	/* reserved */
+#define	RS_RE_MASK	0xf0000	/* receive errors */
+#define	RS_RE_SHIFT	16
+#define	RS_RE_NOERR	0x00000	/* no error */
+#define	RS_RE_DPE	0x10000	/* descriptor protocol error */
+#define	RS_RE_DFO	0x20000	/* data fifo overflow */
+#define	RS_RE_BEBW	0x30000	/* bus error on buffer write */
+#define	RS_RE_BEDA	0x40000	/* bus error on descriptor access */
+#define	RS_AD_MASK	0xfff00000	/* active descriptor */
+#define	RS_AD_SHIFT	20
+
+/* fifoaddr */
+#define	FA_OFF_MASK	0xffff	/* offset */
+#define	FA_SEL_MASK	0xf0000	/* select */
+#define	FA_SEL_SHIFT	16
+#define	FA_SEL_XDD	0x00000	/* transmit dma data */
+#define	FA_SEL_XDP	0x10000	/* transmit dma pointers */
+#define	FA_SEL_RDD	0x40000	/* receive dma data */
+#define	FA_SEL_RDP	0x50000	/* receive dma pointers */
+#define	FA_SEL_XFD	0x80000	/* transmit fifo data */
+#define	FA_SEL_XFP	0x90000	/* transmit fifo pointers */
+#define	FA_SEL_RFD	0xc0000	/* receive fifo data */
+#define	FA_SEL_RFP	0xd0000	/* receive fifo pointers */
+#define	FA_SEL_RSD	0xe0000	/* receive frame status data */
+#define	FA_SEL_RSP	0xf0000	/* receive frame status pointers */
+
+/* descriptor control flags */
+#define	CTRL_BC_MASK	0x00001fff	/* buffer byte count, real data len must <= 4KB */
+#define	CTRL_AE		((uint32)3 << 16)	/* address extension bits */
+#define	CTRL_AE_SHIFT	16
+#define	CTRL_PARITY	((uint32)3 << 18)	/* parity bit */
+#define	CTRL_EOT	((uint32)1 << 28)	/* end of descriptor table */
+#define	CTRL_IOC	((uint32)1 << 29)	/* interrupt on completion */
+#define	CTRL_EOF	((uint32)1 << 30)	/* end of frame */
+#define	CTRL_SOF	((uint32)1 << 31)	/* start of frame */
+
+/* control flags in the range [27:20] are core-specific and not defined here */
+#define	CTRL_CORE_MASK	0x0ff00000
+
+/* 64 bits addressing */
+
+/* dma registers per channel(xmt or rcv) */
+typedef volatile struct {
+	uint32 control;		/* enable, et al */
+	uint32 ptr;		/* last descriptor posted to chip */
+	uint32 addrlow;		/* descriptor ring base address low 32-bits (8K aligned) */
+	uint32 addrhigh;	/* descriptor ring base address bits 63:32 (8K aligned) */
+	uint32 status0;		/* current descriptor, xmt state */
+	uint32 status1;		/* active descriptor, xmt error */
+} dma64regs_t;
+
+typedef volatile struct {
+	dma64regs_t tx;		/* dma64 tx channel */
+	dma64regs_t rx;		/* dma64 rx channel */
+} dma64regp_t;
+
+typedef volatile struct {	/* diag access */
+	uint32 fifoaddr;	/* diag address */
+	uint32 fifodatalow;	/* low 32bits of data */
+	uint32 fifodatahigh;	/* high 32bits of data */
+	uint32 pad;		/* reserved */
+} dma64diag_t;
+
+/*
+ * DMA Descriptor
+ * Descriptors are only read by the hardware, never written back.
+ */
+typedef volatile struct {
+	uint32 ctrl1;		/* misc control bits & bufcount */
+	uint32 ctrl2;		/* buffer count and address extension */
+	uint32 addrlow;		/* memory address of the date buffer, bits 31:0 */
+	uint32 addrhigh;	/* memory address of the date buffer, bits 63:32 */
+} dma64dd_t;
+
+/*
+ * Each descriptor ring must be 8kB aligned, and fit within a contiguous 8kB physical addresss.
+ */
+#define D64RINGALIGN_BITS	13
+#define	D64MAXRINGSZ		(1 << D64RINGALIGN_BITS)
+#define	D64RINGALIGN		(1 << D64RINGALIGN_BITS)
+
+#define	D64MAXDD	(D64MAXRINGSZ / sizeof (dma64dd_t))
+
+/* transmit channel control */
+#define	D64_XC_XE		0x00000001	/* transmit enable */
+#define	D64_XC_SE		0x00000002	/* transmit suspend request */
+#define	D64_XC_LE		0x00000004	/* loopback enable */
+#define	D64_XC_FL		0x00000010	/* flush request */
+#define	D64_XC_PD		0x00000800	/* parity check disable */
+#define	D64_XC_AE		0x00030000	/* address extension bits */
+#define	D64_XC_AE_SHIFT		16
+
+/* transmit descriptor table pointer */
+#define	D64_XP_LD_MASK		0x00000fff	/* last valid descriptor */
+
+/* transmit channel status */
+#define	D64_XS0_CD_MASK		0x00001fff	/* current descriptor pointer */
+#define	D64_XS0_XS_MASK		0xf0000000	/* transmit state */
+#define	D64_XS0_XS_SHIFT		28
+#define	D64_XS0_XS_DISABLED	0x00000000	/* disabled */
+#define	D64_XS0_XS_ACTIVE	0x10000000	/* active */
+#define	D64_XS0_XS_IDLE		0x20000000	/* idle wait */
+#define	D64_XS0_XS_STOPPED	0x30000000	/* stopped */
+#define	D64_XS0_XS_SUSP		0x40000000	/* suspend pending */
+
+#define	D64_XS1_AD_MASK		0x00001fff	/* active descriptor */
+#define	D64_XS1_XE_MASK		0xf0000000	/* transmit errors */
+#define	D64_XS1_XE_SHIFT		28
+#define	D64_XS1_XE_NOERR	0x00000000	/* no error */
+#define	D64_XS1_XE_DPE		0x10000000	/* descriptor protocol error */
+#define	D64_XS1_XE_DFU		0x20000000	/* data fifo underrun */
+#define	D64_XS1_XE_DTE		0x30000000	/* data transfer error */
+#define	D64_XS1_XE_DESRE	0x40000000	/* descriptor read error */
+#define	D64_XS1_XE_COREE	0x50000000	/* core error */
+
+/* receive channel control */
+#define	D64_RC_RE		0x00000001	/* receive enable */
+#define	D64_RC_RO_MASK		0x000000fe	/* receive frame offset */
+#define	D64_RC_RO_SHIFT		1
+#define	D64_RC_FM		0x00000100	/* direct fifo receive (pio) mode */
+#define	D64_RC_SH		0x00000200	/* separate rx header descriptor enable */
+#define	D64_RC_OC		0x00000400	/* overflow continue */
+#define	D64_RC_PD		0x00000800	/* parity check disable */
+#define	D64_RC_AE		0x00030000	/* address extension bits */
+#define	D64_RC_AE_SHIFT		16
+
+/* flags for dma controller */
+#define DMA_CTRL_PEN		(1 << 0)	/* partity enable */
+#define DMA_CTRL_ROC		(1 << 1)	/* rx overflow continue */
+#define DMA_CTRL_RXMULTI	(1 << 2)	/* allow rx scatter to multiple descriptors */
+#define DMA_CTRL_UNFRAMED	(1 << 3)	/* Unframed Rx/Tx data */
+
+/* receive descriptor table pointer */
+#define	D64_RP_LD_MASK		0x00000fff	/* last valid descriptor */
+
+/* receive channel status */
+#define	D64_RS0_CD_MASK		0x00001fff	/* current descriptor pointer */
+#define	D64_RS0_RS_MASK		0xf0000000	/* receive state */
+#define	D64_RS0_RS_SHIFT		28
+#define	D64_RS0_RS_DISABLED	0x00000000	/* disabled */
+#define	D64_RS0_RS_ACTIVE	0x10000000	/* active */
+#define	D64_RS0_RS_IDLE		0x20000000	/* idle wait */
+#define	D64_RS0_RS_STOPPED	0x30000000	/* stopped */
+#define	D64_RS0_RS_SUSP		0x40000000	/* suspend pending */
+
+#define	D64_RS1_AD_MASK		0x0001ffff	/* active descriptor */
+#define	D64_RS1_RE_MASK		0xf0000000	/* receive errors */
+#define	D64_RS1_RE_SHIFT		28
+#define	D64_RS1_RE_NOERR	0x00000000	/* no error */
+#define	D64_RS1_RE_DPO		0x10000000	/* descriptor protocol error */
+#define	D64_RS1_RE_DFU		0x20000000	/* data fifo overflow */
+#define	D64_RS1_RE_DTE		0x30000000	/* data transfer error */
+#define	D64_RS1_RE_DESRE	0x40000000	/* descriptor read error */
+#define	D64_RS1_RE_COREE	0x50000000	/* core error */
+
+/* fifoaddr */
+#define	D64_FA_OFF_MASK		0xffff	/* offset */
+#define	D64_FA_SEL_MASK		0xf0000	/* select */
+#define	D64_FA_SEL_SHIFT	16
+#define	D64_FA_SEL_XDD		0x00000	/* transmit dma data */
+#define	D64_FA_SEL_XDP		0x10000	/* transmit dma pointers */
+#define	D64_FA_SEL_RDD		0x40000	/* receive dma data */
+#define	D64_FA_SEL_RDP		0x50000	/* receive dma pointers */
+#define	D64_FA_SEL_XFD		0x80000	/* transmit fifo data */
+#define	D64_FA_SEL_XFP		0x90000	/* transmit fifo pointers */
+#define	D64_FA_SEL_RFD		0xc0000	/* receive fifo data */
+#define	D64_FA_SEL_RFP		0xd0000	/* receive fifo pointers */
+#define	D64_FA_SEL_RSD		0xe0000	/* receive frame status data */
+#define	D64_FA_SEL_RSP		0xf0000	/* receive frame status pointers */
+
+/* descriptor control flags 1 */
+#define D64_CTRL_COREFLAGS	0x0ff00000	/* core specific flags */
+#define	D64_CTRL1_EOT		((uint32)1 << 28)	/* end of descriptor table */
+#define	D64_CTRL1_IOC		((uint32)1 << 29)	/* interrupt on completion */
+#define	D64_CTRL1_EOF		((uint32)1 << 30)	/* end of frame */
+#define	D64_CTRL1_SOF		((uint32)1 << 31)	/* start of frame */
+
+/* descriptor control flags 2 */
+#define	D64_CTRL2_BC_MASK	0x00007fff	/* buffer byte count. real data len must <= 16KB */
+#define	D64_CTRL2_AE		0x00030000	/* address extension bits */
+#define	D64_CTRL2_AE_SHIFT	16
+#define D64_CTRL2_PARITY	0x00040000	/* parity bit */
+
+/* control flags in the range [27:20] are core-specific and not defined here */
+#define	D64_CTRL_CORE_MASK	0x0ff00000
+
+#define D64_RX_FRM_STS_LEN	0x0000ffff	/* frame length mask */
+#define D64_RX_FRM_STS_OVFL	0x00800000	/* RxOverFlow */
+#define D64_RX_FRM_STS_DSCRCNT	0x0f000000	/* no. of descriptors used - 1, d11corerev >= 22 */
+#define D64_RX_FRM_STS_DATATYPE	0xf0000000	/* core-dependent data type */
+
+/* receive frame status */
+typedef volatile struct {
+	uint16 len;
+	uint16 flags;
+} dma_rxh_t;
+
+#endif				/* _sbhnddma_h_ */
diff --git a/drivers/staging/brcm80211/include/sbhndpio.h b/drivers/staging/brcm80211/include/sbhndpio.h
new file mode 100644
index 0000000..e64f6aa
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbhndpio.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_sbhndpio_h_
+#define	_sbhndpio_h_
+
+/* PIO structure,
+ *  support two PIO format: 2 bytes access and 4 bytes access
+ *  basic FIFO register set is per channel(transmit or receive)
+ *  a pair of channels is defined for convenience
+ */
+
+/* 2byte-wide pio register set per channel(xmt or rcv) */
+typedef volatile struct {
+	uint16 fifocontrol;
+	uint16 fifodata;
+	uint16 fifofree;	/* only valid in xmt channel, not in rcv channel */
+	uint16 PAD;
+} pio2regs_t;
+
+/* a pair of pio channels(tx and rx) */
+typedef volatile struct {
+	pio2regs_t tx;
+	pio2regs_t rx;
+} pio2regp_t;
+
+/* 4byte-wide pio register set per channel(xmt or rcv) */
+typedef volatile struct {
+	uint32 fifocontrol;
+	uint32 fifodata;
+} pio4regs_t;
+
+/* a pair of pio channels(tx and rx) */
+typedef volatile struct {
+	pio4regs_t tx;
+	pio4regs_t rx;
+} pio4regp_t;
+
+#endif				/* _sbhndpio_h_ */
diff --git a/drivers/staging/brcm80211/include/sbpcmcia.h b/drivers/staging/brcm80211/include/sbpcmcia.h
new file mode 100644
index 0000000..6b9923f
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbpcmcia.h
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SBPCMCIA_H
+#define	_SBPCMCIA_H
+
+/* All the addresses that are offsets in attribute space are divided
+ * by two to account for the fact that odd bytes are invalid in
+ * attribute space and our read/write routines make the space appear
+ * as if they didn't exist. Still we want to show the original numbers
+ * as documented in the hnd_pcmcia core manual.
+ */
+
+/* PCMCIA Function Configuration Registers */
+#define	PCMCIA_FCR		(0x700 / 2)
+
+#define	FCR0_OFF		0
+#define	FCR1_OFF		(0x40 / 2)
+#define	FCR2_OFF		(0x80 / 2)
+#define	FCR3_OFF		(0xc0 / 2)
+
+#define	PCMCIA_FCR0		(0x700 / 2)
+#define	PCMCIA_FCR1		(0x740 / 2)
+#define	PCMCIA_FCR2		(0x780 / 2)
+#define	PCMCIA_FCR3		(0x7c0 / 2)
+
+/* Standard PCMCIA FCR registers */
+
+#define	PCMCIA_COR		0
+
+#define	COR_RST			0x80
+#define	COR_LEV			0x40
+#define	COR_IRQEN		0x04
+#define	COR_BLREN		0x01
+#define	COR_FUNEN		0x01
+
+#define	PCICIA_FCSR		(2 / 2)
+#define	PCICIA_PRR		(4 / 2)
+#define	PCICIA_SCR		(6 / 2)
+#define	PCICIA_ESR		(8 / 2)
+
+#define PCM_MEMOFF		0x0000
+#define F0_MEMOFF		0x1000
+#define F1_MEMOFF		0x2000
+#define F2_MEMOFF		0x3000
+#define F3_MEMOFF		0x4000
+
+/* Memory base in the function fcr's */
+#define MEM_ADDR0		(0x728 / 2)
+#define MEM_ADDR1		(0x72a / 2)
+#define MEM_ADDR2		(0x72c / 2)
+
+/* PCMCIA base plus Srom access in fcr0: */
+#define PCMCIA_ADDR0		(0x072e / 2)
+#define PCMCIA_ADDR1		(0x0730 / 2)
+#define PCMCIA_ADDR2		(0x0732 / 2)
+
+#define MEM_SEG			(0x0734 / 2)
+#define SROM_CS			(0x0736 / 2)
+#define SROM_DATAL		(0x0738 / 2)
+#define SROM_DATAH		(0x073a / 2)
+#define SROM_ADDRL		(0x073c / 2)
+#define SROM_ADDRH		(0x073e / 2)
+#define	SROM_INFO2		(0x0772 / 2)	/* Corerev >= 2 && <= 5 */
+#define	SROM_INFO		(0x07be / 2)	/* Corerev >= 6 */
+
+/*  Values for srom_cs: */
+#define SROM_IDLE		0
+#define SROM_WRITE		1
+#define SROM_READ		2
+#define SROM_WEN		4
+#define SROM_WDS		7
+#define SROM_DONE		8
+
+/* Fields in srom_info: */
+#define	SRI_SZ_MASK		0x03
+#define	SRI_BLANK		0x04
+#define	SRI_OTP			0x80
+
+#if !defined(ESTA_POSTMOGRIFY_REMOVAL)
+/* CIS stuff */
+
+/* The CIS stops where the FCRs start */
+#define	CIS_SIZE		PCMCIA_FCR
+
+/* CIS tuple length field max */
+#define CIS_TUPLE_LEN_MAX	0xff
+
+/* Standard tuples we know about */
+
+#define CISTPL_NULL			0x00
+#define	CISTPL_VERS_1		0x15	/* CIS ver, manf, dev & ver strings */
+#define	CISTPL_MANFID		0x20	/* Manufacturer and device id */
+#define CISTPL_FUNCID		0x21	/* Function identification */
+#define	CISTPL_FUNCE		0x22	/* Function extensions */
+#define	CISTPL_CFTABLE		0x1b	/* Config table entry */
+#define	CISTPL_END		0xff	/* End of the CIS tuple chain */
+
+/* Function identifier provides context for the function extentions tuple */
+#define CISTPL_FID_SDIO		0x0c	/* Extensions defined by SDIO spec */
+
+/* Function extensions for LANs (assumed for extensions other than SDIO) */
+#define	LAN_TECH		1	/* Technology type */
+#define	LAN_SPEED		2	/* Raw bit rate */
+#define	LAN_MEDIA		3	/* Transmission media */
+#define	LAN_NID			4	/* Node identification (aka MAC addr) */
+#define	LAN_CONN		5	/* Connector standard */
+
+/* CFTable */
+#define CFTABLE_REGWIN_2K	0x08	/* 2k reg windows size */
+#define CFTABLE_REGWIN_4K	0x10	/* 4k reg windows size */
+#define CFTABLE_REGWIN_8K	0x20	/* 8k reg windows size */
+
+/* Vendor unique tuples are 0x80-0x8f. Within Broadcom we'll
+ * take one for HNBU, and use "extensions" (a la FUNCE) within it.
+ */
+
+#define	CISTPL_BRCM_HNBU	0x80
+
+/* Subtypes of BRCM_HNBU: */
+
+#define HNBU_SROMREV		0x00	/* A byte with sromrev, 1 if not present */
+#define HNBU_CHIPID		0x01	/* Two 16bit values: PCI vendor & device id */
+#define HNBU_BOARDREV		0x02	/* One byte board revision */
+#define HNBU_PAPARMS		0x03	/* PA parameters: 8 (sromrev == 1)
+					 * or 9 (sromrev > 1) bytes
+					 */
+#define HNBU_OEM		0x04	/* Eight bytes OEM data (sromrev == 1) */
+#define HNBU_CC			0x05	/* Default country code (sromrev == 1) */
+#define	HNBU_AA			0x06	/* Antennas available */
+#define	HNBU_AG			0x07	/* Antenna gain */
+#define HNBU_BOARDFLAGS		0x08	/* board flags (2 or 4 bytes) */
+#define HNBU_LEDS		0x09	/* LED set */
+#define HNBU_CCODE		0x0a	/* Country code (2 bytes ascii + 1 byte cctl)
+					 * in rev 2
+					 */
+#define HNBU_CCKPO		0x0b	/* 2 byte cck power offsets in rev 3 */
+#define HNBU_OFDMPO		0x0c	/* 4 byte 11g ofdm power offsets in rev 3 */
+#define HNBU_GPIOTIMER		0x0d	/* 2 bytes with on/off values in rev 3 */
+#define HNBU_PAPARMS5G		0x0e	/* 5G PA params */
+#define HNBU_ANT5G		0x0f	/* 4328 5G antennas available/gain */
+#define HNBU_RDLID		0x10	/* 2 byte USB remote downloader (RDL) product Id */
+#define HNBU_RSSISMBXA2G	0x11	/* 4328 2G RSSI mid pt sel & board switch arch,
+					 * 2 bytes, rev 3.
+					 */
+#define HNBU_RSSISMBXA5G	0x12	/* 4328 5G RSSI mid pt sel & board switch arch,
+					 * 2 bytes, rev 3.
+					 */
+#define HNBU_XTALFREQ		0x13	/* 4 byte Crystal frequency in kilohertz */
+#define HNBU_TRI2G		0x14	/* 4328 2G TR isolation, 1 byte */
+#define HNBU_TRI5G		0x15	/* 4328 5G TR isolation, 3 bytes */
+#define HNBU_RXPO2G		0x16	/* 4328 2G RX power offset, 1 byte */
+#define HNBU_RXPO5G		0x17	/* 4328 5G RX power offset, 1 byte */
+#define HNBU_BOARDNUM		0x18	/* board serial number, independent of mac addr */
+#define HNBU_MACADDR		0x19	/* mac addr override for the standard CIS LAN_NID */
+#define HNBU_RDLSN		0x1a	/* 2 bytes; serial # advertised in USB descriptor */
+#define HNBU_BOARDTYPE		0x1b	/* 2 bytes; boardtype */
+#define HNBU_LEDDC		0x1c	/* 2 bytes; LED duty cycle */
+#define HNBU_HNBUCIS		0x1d	/* what follows is proprietary HNBU CIS format */
+#define HNBU_PAPARMS_SSLPNPHY	0x1e	/* SSLPNPHY PA params */
+#define HNBU_RSSISMBXA2G_SSLPNPHY 0x1f	/* SSLPNPHY RSSI mid pt sel & board switch arch */
+#define HNBU_RDLRNDIS		0x20	/* 1 byte; 1 = RDL advertises RNDIS config */
+#define HNBU_CHAINSWITCH	0x21	/* 2 byte; txchain, rxchain */
+#define HNBU_REGREV		0x22	/* 1 byte; */
+#define HNBU_FEM		0x23	/* 2 or 4 byte: 11n frontend specification */
+#define HNBU_PAPARMS_C0		0x24	/* 8 or 30 bytes: 11n pa paramater for chain 0 */
+#define HNBU_PAPARMS_C1		0x25	/* 8 or 30 bytes: 11n pa paramater for chain 1 */
+#define HNBU_PAPARMS_C2		0x26	/* 8 or 30 bytes: 11n pa paramater for chain 2 */
+#define HNBU_PAPARMS_C3		0x27	/* 8 or 30 bytes: 11n pa paramater for chain 3 */
+#define HNBU_PO_CCKOFDM		0x28	/* 6 or 18 bytes: cck2g/ofdm2g/ofdm5g power offset */
+#define HNBU_PO_MCS2G		0x29	/* 8 bytes: mcs2g power offset */
+#define HNBU_PO_MCS5GM		0x2a	/* 8 bytes: mcs5g mid band power offset */
+#define HNBU_PO_MCS5GLH		0x2b	/* 16 bytes: mcs5g low-high band power offset */
+#define HNBU_PO_CDD		0x2c	/* 2 bytes: cdd2g/5g power offset */
+#define HNBU_PO_STBC		0x2d	/* 2 bytes: stbc2g/5g power offset */
+#define HNBU_PO_40M		0x2e	/* 2 bytes: 40Mhz channel 2g/5g power offset */
+#define HNBU_PO_40MDUP		0x2f	/* 2 bytes: 40Mhz channel dup 2g/5g power offset */
+
+#define HNBU_RDLRWU		0x30	/* 1 byte; 1 = RDL advertises Remote Wake-up */
+#define HNBU_WPS		0x31	/* 1 byte; GPIO pin for WPS button */
+#define HNBU_USBFS		0x32	/* 1 byte; 1 = USB advertises FS mode only */
+#define HNBU_BRMIN		0x33	/* 4 byte bootloader min resource mask */
+#define HNBU_BRMAX		0x34	/* 4 byte bootloader max resource mask */
+#define HNBU_PATCH		0x35	/* bootloader patch addr(2b) & data(4b) pair */
+#define HNBU_CCKFILTTYPE	0x36	/* CCK digital filter selection options */
+#define HNBU_OFDMPO5G		0x37	/* 4 * 3 = 12 byte 11a ofdm power offsets in rev 3 */
+
+#define HNBU_USBEPNUM		0x40	/* USB endpoint numbers */
+#define HNBU_SROM3SWRGN		0x80	/* 78 bytes; srom rev 3 s/w region without crc8
+					 * plus extra info appended.
+					 */
+#define HNBU_RESERVED		0x81	/* Reserved for non-BRCM post-mfg additions */
+#define HNBU_CUSTOM1		0x82	/* 4 byte; For non-BRCM post-mfg additions */
+#define HNBU_CUSTOM2		0x83	/* Reserved; For non-BRCM post-mfg additions */
+#endif				/* !defined(ESTA_POSTMOGRIFY_REMOVAL) */
+
+/* sbtmstatelow */
+#define SBTML_INT_ACK		0x40000	/* ack the sb interrupt */
+#define SBTML_INT_EN		0x20000	/* enable sb interrupt */
+
+/* sbtmstatehigh */
+#define SBTMH_INT_STATUS	0x40000	/* sb interrupt status */
+
+#endif				/* _SBPCMCIA_H */
diff --git a/drivers/staging/brcm80211/include/sbsdio.h b/drivers/staging/brcm80211/include/sbsdio.h
new file mode 100644
index 0000000..6afdbbe
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbsdio.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SBSDIO_H
+#define	_SBSDIO_H
+
+#define SBSDIO_NUM_FUNCTION		3	/* as of sdiod rev 0, supports 3 functions */
+
+/* function 1 miscellaneous registers */
+#define SBSDIO_SPROM_CS			0x10000	/* sprom command and status */
+#define SBSDIO_SPROM_INFO		0x10001	/* sprom info register */
+#define SBSDIO_SPROM_DATA_LOW		0x10002	/* sprom indirect access data byte 0 */
+#define SBSDIO_SPROM_DATA_HIGH		0x10003	/* sprom indirect access data byte 1 */
+#define SBSDIO_SPROM_ADDR_LOW		0x10004	/* sprom indirect access addr byte 0 */
+#define SBSDIO_SPROM_ADDR_HIGH		0x10005	/* sprom indirect access addr byte 0 */
+#define SBSDIO_CHIP_CTRL_DATA		0x10006	/* xtal_pu (gpio) output */
+#define SBSDIO_CHIP_CTRL_EN		0x10007	/* xtal_pu (gpio) enable */
+#define SBSDIO_WATERMARK		0x10008	/* rev < 7, watermark for sdio device */
+#define SBSDIO_DEVICE_CTL		0x10009	/* control busy signal generation */
+
+/* registers introduced in rev 8, some content (mask/bits) defs in sbsdpcmdev.h */
+#define SBSDIO_FUNC1_SBADDRLOW		0x1000A	/* SB Address Window Low (b15) */
+#define SBSDIO_FUNC1_SBADDRMID		0x1000B	/* SB Address Window Mid (b23:b16) */
+#define SBSDIO_FUNC1_SBADDRHIGH		0x1000C	/* SB Address Window High (b31:b24)    */
+#define SBSDIO_FUNC1_FRAMECTRL		0x1000D	/* Frame Control (frame term/abort) */
+#define SBSDIO_FUNC1_CHIPCLKCSR		0x1000E	/* ChipClockCSR (ALP/HT ctl/status) */
+#define SBSDIO_FUNC1_SDIOPULLUP 	0x1000F	/* SdioPullUp (on cmd, d0-d2) */
+#define SBSDIO_FUNC1_WFRAMEBCLO		0x10019	/* Write Frame Byte Count Low */
+#define SBSDIO_FUNC1_WFRAMEBCHI		0x1001A	/* Write Frame Byte Count High */
+#define SBSDIO_FUNC1_RFRAMEBCLO		0x1001B	/* Read Frame Byte Count Low */
+#define SBSDIO_FUNC1_RFRAMEBCHI		0x1001C	/* Read Frame Byte Count High */
+
+#define SBSDIO_FUNC1_MISC_REG_START	0x10000	/* f1 misc register start */
+#define SBSDIO_FUNC1_MISC_REG_LIMIT	0x1001C	/* f1 misc register end */
+
+/* SBSDIO_SPROM_CS */
+#define SBSDIO_SPROM_IDLE		0
+#define SBSDIO_SPROM_WRITE		1
+#define SBSDIO_SPROM_READ		2
+#define SBSDIO_SPROM_WEN		4
+#define SBSDIO_SPROM_WDS		7
+#define SBSDIO_SPROM_DONE		8
+
+/* SBSDIO_SPROM_INFO */
+#define SROM_SZ_MASK			0x03	/* SROM size, 1: 4k, 2: 16k */
+#define SROM_BLANK			0x04	/* depreciated in corerev 6 */
+#define	SROM_OTP			0x80	/* OTP present */
+
+/* SBSDIO_CHIP_CTRL */
+#define SBSDIO_CHIP_CTRL_XTAL		0x01	/* or'd with onchip xtal_pu,
+						 * 1: power on oscillator
+						 * (for 4318 only)
+						 */
+/* SBSDIO_WATERMARK */
+#define SBSDIO_WATERMARK_MASK		0x7f	/* number of words - 1 for sd device
+						 * to wait before sending data to host
+						 */
+
+/* SBSDIO_DEVICE_CTL */
+#define SBSDIO_DEVCTL_SETBUSY		0x01	/* 1: device will assert busy signal when
+						 * receiving CMD53
+						 */
+#define SBSDIO_DEVCTL_SPI_INTR_SYNC	0x02	/* 1: assertion of sdio interrupt is
+						 * synchronous to the sdio clock
+						 */
+#define SBSDIO_DEVCTL_CA_INT_ONLY	0x04	/* 1: mask all interrupts to host
+						 * except the chipActive (rev 8)
+						 */
+#define SBSDIO_DEVCTL_PADS_ISO		0x08	/* 1: isolate internal sdio signals, put
+						 * external pads in tri-state; requires
+						 * sdio bus power cycle to clear (rev 9)
+						 */
+#define SBSDIO_DEVCTL_SB_RST_CTL	0x30	/* Force SD->SB reset mapping (rev 11) */
+#define SBSDIO_DEVCTL_RST_CORECTL	0x00	/*   Determined by CoreControl bit */
+#define SBSDIO_DEVCTL_RST_BPRESET	0x10	/*   Force backplane reset */
+#define SBSDIO_DEVCTL_RST_NOBPRESET	0x20	/*   Force no backplane reset */
+
+/* SBSDIO_FUNC1_CHIPCLKCSR */
+#define SBSDIO_FORCE_ALP		0x01	/* Force ALP request to backplane */
+#define SBSDIO_FORCE_HT			0x02	/* Force HT request to backplane */
+#define SBSDIO_FORCE_ILP		0x04	/* Force ILP request to backplane */
+#define SBSDIO_ALP_AVAIL_REQ		0x08	/* Make ALP ready (power up xtal) */
+#define SBSDIO_HT_AVAIL_REQ		0x10	/* Make HT ready (power up PLL) */
+#define SBSDIO_FORCE_HW_CLKREQ_OFF	0x20	/* Squelch clock requests from HW */
+#define SBSDIO_ALP_AVAIL		0x40	/* Status: ALP is ready */
+#define SBSDIO_HT_AVAIL			0x80	/* Status: HT is ready */
+/* In rev8, actual avail bits followed original docs */
+#define SBSDIO_Rev8_HT_AVAIL		0x40
+#define SBSDIO_Rev8_ALP_AVAIL		0x80
+
+#define SBSDIO_AVBITS			(SBSDIO_HT_AVAIL | SBSDIO_ALP_AVAIL)
+#define SBSDIO_ALPAV(regval)		((regval) & SBSDIO_AVBITS)
+#define SBSDIO_HTAV(regval)		(((regval) & SBSDIO_AVBITS) == SBSDIO_AVBITS)
+#define SBSDIO_ALPONLY(regval)		(SBSDIO_ALPAV(regval) && !SBSDIO_HTAV(regval))
+#define SBSDIO_CLKAV(regval, alponly)	(SBSDIO_ALPAV(regval) && \
+					(alponly ? 1 : SBSDIO_HTAV(regval)))
+
+/* SBSDIO_FUNC1_SDIOPULLUP */
+#define SBSDIO_PULLUP_D0		0x01	/* Enable D0/MISO pullup */
+#define SBSDIO_PULLUP_D1		0x02	/* Enable D1/INT# pullup */
+#define SBSDIO_PULLUP_D2		0x04	/* Enable D2 pullup */
+#define SBSDIO_PULLUP_CMD		0x08	/* Enable CMD/MOSI pullup */
+#define SBSDIO_PULLUP_ALL		0x0f	/* All valid bits */
+
+/* function 1 OCP space */
+#define SBSDIO_SB_OFT_ADDR_MASK		0x07FFF	/* sb offset addr is <= 15 bits, 32k */
+#define SBSDIO_SB_OFT_ADDR_LIMIT	0x08000
+#define SBSDIO_SB_ACCESS_2_4B_FLAG	0x08000	/* with b15, maps to 32-bit SB access */
+
+/* some duplication with sbsdpcmdev.h here */
+/* valid bits in SBSDIO_FUNC1_SBADDRxxx regs */
+#define SBSDIO_SBADDRLOW_MASK		0x80	/* Valid bits in SBADDRLOW */
+#define SBSDIO_SBADDRMID_MASK		0xff	/* Valid bits in SBADDRMID */
+#define SBSDIO_SBADDRHIGH_MASK		0xffU	/* Valid bits in SBADDRHIGH */
+#define SBSDIO_SBWINDOW_MASK		0xffff8000	/* Address bits from SBADDR regs */
+
+/* direct(mapped) cis space */
+#define SBSDIO_CIS_BASE_COMMON		0x1000	/* MAPPED common CIS address */
+#define SBSDIO_CIS_SIZE_LIMIT		0x200	/* maximum bytes in one CIS */
+#define SBSDIO_OTP_CIS_SIZE_LIMIT       0x078	/* maximum bytes OTP CIS */
+
+#define SBSDIO_CIS_OFT_ADDR_MASK	0x1FFFF	/* cis offset addr is < 17 bits */
+
+#define SBSDIO_CIS_MANFID_TUPLE_LEN	6	/* manfid tuple length, include tuple,
+						 * link bytes
+						 */
+
+/* indirect cis access (in sprom) */
+#define SBSDIO_SPROM_CIS_OFFSET		0x8	/* 8 control bytes first, CIS starts from
+						 * 8th byte
+						 */
+
+#define SBSDIO_BYTEMODE_DATALEN_MAX	64	/* sdio byte mode: maximum length of one
+						 * data comamnd
+						 */
+
+#define SBSDIO_CORE_ADDR_MASK		0x1FFFF	/* sdio core function one address mask */
+
+#endif				/* _SBSDIO_H */
diff --git a/drivers/staging/brcm80211/include/sbsdpcmdev.h b/drivers/staging/brcm80211/include/sbsdpcmdev.h
new file mode 100644
index 0000000..d07a13c
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbsdpcmdev.h
@@ -0,0 +1,281 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_sbsdpcmdev_h_
+#define	_sbsdpcmdev_h_
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+typedef volatile struct {
+	dma64regs_t xmt;	/* dma tx */
+	uint32 PAD[2];
+	dma64regs_t rcv;	/* dma rx */
+	uint32 PAD[2];
+} dma64p_t;
+
+/* dma64 sdiod corerev >= 1 */
+typedef volatile struct {
+	dma64p_t dma64regs[2];
+	dma64diag_t dmafifo;	/* DMA Diagnostic Regs, 0x280-0x28c */
+	uint32 PAD[92];
+} sdiodma64_t;
+
+/* dma32 sdiod corerev == 0 */
+typedef volatile struct {
+	dma32regp_t dma32regs[2];	/* dma tx & rx, 0x200-0x23c */
+	dma32diag_t dmafifo;	/* DMA Diagnostic Regs, 0x240-0x24c */
+	uint32 PAD[108];
+} sdiodma32_t;
+
+/* dma32 regs for pcmcia core */
+typedef volatile struct {
+	dma32regp_t dmaregs;	/* DMA Regs, 0x200-0x21c, rev8 */
+	dma32diag_t dmafifo;	/* DMA Diagnostic Regs, 0x220-0x22c */
+	uint32 PAD[116];
+} pcmdma32_t;
+
+/* core registers */
+typedef volatile struct {
+	uint32 corecontrol;	/* CoreControl, 0x000, rev8 */
+	uint32 corestatus;	/* CoreStatus, 0x004, rev8  */
+	uint32 PAD[1];
+	uint32 biststatus;	/* BistStatus, 0x00c, rev8  */
+
+	/* PCMCIA access */
+	uint16 pcmciamesportaladdr;	/* PcmciaMesPortalAddr, 0x010, rev8   */
+	uint16 PAD[1];
+	uint16 pcmciamesportalmask;	/* PcmciaMesPortalMask, 0x014, rev8   */
+	uint16 PAD[1];
+	uint16 pcmciawrframebc;	/* PcmciaWrFrameBC, 0x018, rev8   */
+	uint16 PAD[1];
+	uint16 pcmciaunderflowtimer;	/* PcmciaUnderflowTimer, 0x01c, rev8   */
+	uint16 PAD[1];
+
+	/* interrupt */
+	uint32 intstatus;	/* IntStatus, 0x020, rev8   */
+	uint32 hostintmask;	/* IntHostMask, 0x024, rev8   */
+	uint32 intmask;		/* IntSbMask, 0x028, rev8   */
+	uint32 sbintstatus;	/* SBIntStatus, 0x02c, rev8   */
+	uint32 sbintmask;	/* SBIntMask, 0x030, rev8   */
+	uint32 funcintmask;	/* SDIO Function Interrupt Mask, SDIO rev4 */
+	uint32 PAD[2];
+	uint32 tosbmailbox;	/* ToSBMailbox, 0x040, rev8   */
+	uint32 tohostmailbox;	/* ToHostMailbox, 0x044, rev8   */
+	uint32 tosbmailboxdata;	/* ToSbMailboxData, 0x048, rev8   */
+	uint32 tohostmailboxdata;	/* ToHostMailboxData, 0x04c, rev8   */
+
+	/* synchronized access to registers in SDIO clock domain */
+	uint32 sdioaccess;	/* SdioAccess, 0x050, rev8   */
+	uint32 PAD[3];
+
+	/* PCMCIA frame control */
+	uint8 pcmciaframectrl;	/* pcmciaFrameCtrl, 0x060, rev8   */
+	uint8 PAD[3];
+	uint8 pcmciawatermark;	/* pcmciaWaterMark, 0x064, rev8   */
+	uint8 PAD[155];
+
+	/* interrupt batching control */
+	uint32 intrcvlazy;	/* IntRcvLazy, 0x100, rev8 */
+	uint32 PAD[3];
+
+	/* counters */
+	uint32 cmd52rd;		/* Cmd52RdCount, 0x110, rev8, SDIO: cmd52 reads */
+	uint32 cmd52wr;		/* Cmd52WrCount, 0x114, rev8, SDIO: cmd52 writes */
+	uint32 cmd53rd;		/* Cmd53RdCount, 0x118, rev8, SDIO: cmd53 reads */
+	uint32 cmd53wr;		/* Cmd53WrCount, 0x11c, rev8, SDIO: cmd53 writes */
+	uint32 abort;		/* AbortCount, 0x120, rev8, SDIO: aborts */
+	uint32 datacrcerror;	/* DataCrcErrorCount, 0x124, rev8, SDIO: frames w/bad CRC */
+	uint32 rdoutofsync;	/* RdOutOfSyncCount, 0x128, rev8, SDIO/PCMCIA: Rd Frm OOS */
+	uint32 wroutofsync;	/* RdOutOfSyncCount, 0x12c, rev8, SDIO/PCMCIA: Wr Frm OOS */
+	uint32 writebusy;	/* WriteBusyCount, 0x130, rev8, SDIO: dev asserted "busy" */
+	uint32 readwait;	/* ReadWaitCount, 0x134, rev8, SDIO: read: no data avail */
+	uint32 readterm;	/* ReadTermCount, 0x138, rev8, SDIO: rd frm terminates */
+	uint32 writeterm;	/* WriteTermCount, 0x13c, rev8, SDIO: wr frm terminates */
+	uint32 PAD[40];
+	uint32 clockctlstatus;	/* ClockCtlStatus, 0x1e0, rev8 */
+	uint32 PAD[7];
+
+	/* DMA engines */
+	volatile union {
+		pcmdma32_t pcm32;
+		sdiodma32_t sdiod32;
+		sdiodma64_t sdiod64;
+	} dma;
+
+	/* SDIO/PCMCIA CIS region */
+	char cis[512];		/* 512 byte CIS, 0x400-0x5ff, rev6 */
+
+	/* PCMCIA function control registers */
+	char pcmciafcr[256];	/* PCMCIA FCR, 0x600-6ff, rev6 */
+	uint16 PAD[55];
+
+	/* PCMCIA backplane access */
+	uint16 backplanecsr;	/* BackplaneCSR, 0x76E, rev6 */
+	uint16 backplaneaddr0;	/* BackplaneAddr0, 0x770, rev6 */
+	uint16 backplaneaddr1;	/* BackplaneAddr1, 0x772, rev6 */
+	uint16 backplaneaddr2;	/* BackplaneAddr2, 0x774, rev6 */
+	uint16 backplaneaddr3;	/* BackplaneAddr3, 0x776, rev6 */
+	uint16 backplanedata0;	/* BackplaneData0, 0x778, rev6 */
+	uint16 backplanedata1;	/* BackplaneData1, 0x77a, rev6 */
+	uint16 backplanedata2;	/* BackplaneData2, 0x77c, rev6 */
+	uint16 backplanedata3;	/* BackplaneData3, 0x77e, rev6 */
+	uint16 PAD[31];
+
+	/* sprom "size" & "blank" info */
+	uint16 spromstatus;	/* SPROMStatus, 0x7BE, rev2 */
+	uint32 PAD[464];
+
+	/* Sonics SiliconBackplane registers */
+	sbconfig_t sbconfig;	/* SbConfig Regs, 0xf00-0xfff, rev8 */
+} sdpcmd_regs_t;
+
+/* corecontrol */
+#define CC_CISRDY		(1 << 0)	/* CIS Ready */
+#define CC_BPRESEN		(1 << 1)	/* CCCR RES signal causes backplane reset */
+#define CC_F2RDY		(1 << 2)	/* set CCCR IOR2 bit */
+#define CC_CLRPADSISO		(1 << 3)	/* clear SDIO pads isolation bit (rev 11) */
+#define CC_XMTDATAAVAIL_MODE	(1 << 4)	/* data avail generates an interrupt */
+#define CC_XMTDATAAVAIL_CTRL	(1 << 5)	/* data avail interrupt ctrl */
+
+/* corestatus */
+#define CS_PCMCIAMODE	(1 << 0)	/* Device Mode; 0=SDIO, 1=PCMCIA */
+#define CS_SMARTDEV	(1 << 1)	/* 1=smartDev enabled */
+#define CS_F2ENABLED	(1 << 2)	/* 1=host has enabled the device */
+
+#define PCMCIA_MES_PA_MASK	0x7fff	/* PCMCIA Message Portal Address Mask */
+#define PCMCIA_MES_PM_MASK	0x7fff	/* PCMCIA Message Portal Mask Mask */
+#define PCMCIA_WFBC_MASK	0xffff	/* PCMCIA Write Frame Byte Count Mask */
+#define PCMCIA_UT_MASK		0x07ff	/* PCMCIA Underflow Timer Mask */
+
+/* intstatus */
+#define I_SMB_SW0	(1 << 0)	/* To SB Mail S/W interrupt 0 */
+#define I_SMB_SW1	(1 << 1)	/* To SB Mail S/W interrupt 1 */
+#define I_SMB_SW2	(1 << 2)	/* To SB Mail S/W interrupt 2 */
+#define I_SMB_SW3	(1 << 3)	/* To SB Mail S/W interrupt 3 */
+#define I_SMB_SW_MASK	0x0000000f	/* To SB Mail S/W interrupts mask */
+#define I_SMB_SW_SHIFT	0	/* To SB Mail S/W interrupts shift */
+#define I_HMB_SW0	(1 << 4)	/* To Host Mail S/W interrupt 0 */
+#define I_HMB_SW1	(1 << 5)	/* To Host Mail S/W interrupt 1 */
+#define I_HMB_SW2	(1 << 6)	/* To Host Mail S/W interrupt 2 */
+#define I_HMB_SW3	(1 << 7)	/* To Host Mail S/W interrupt 3 */
+#define I_HMB_SW_MASK	0x000000f0	/* To Host Mail S/W interrupts mask */
+#define I_HMB_SW_SHIFT	4	/* To Host Mail S/W interrupts shift */
+#define I_WR_OOSYNC	(1 << 8)	/* Write Frame Out Of Sync */
+#define I_RD_OOSYNC	(1 << 9)	/* Read Frame Out Of Sync */
+#define	I_PC		(1 << 10)	/* descriptor error */
+#define	I_PD		(1 << 11)	/* data error */
+#define	I_DE		(1 << 12)	/* Descriptor protocol Error */
+#define	I_RU		(1 << 13)	/* Receive descriptor Underflow */
+#define	I_RO		(1 << 14)	/* Receive fifo Overflow */
+#define	I_XU		(1 << 15)	/* Transmit fifo Underflow */
+#define	I_RI		(1 << 16)	/* Receive Interrupt */
+#define I_BUSPWR	(1 << 17)	/* SDIO Bus Power Change (rev 9) */
+#define I_XMTDATA_AVAIL (1 << 23)	/* bits in fifo */
+#define	I_XI		(1 << 24)	/* Transmit Interrupt */
+#define I_RF_TERM	(1 << 25)	/* Read Frame Terminate */
+#define I_WF_TERM	(1 << 26)	/* Write Frame Terminate */
+#define I_PCMCIA_XU	(1 << 27)	/* PCMCIA Transmit FIFO Underflow */
+#define I_SBINT		(1 << 28)	/* sbintstatus Interrupt */
+#define I_CHIPACTIVE	(1 << 29)	/* chip transitioned from doze to active state */
+#define I_SRESET	(1 << 30)	/* CCCR RES interrupt */
+#define I_IOE2		(1U << 31)	/* CCCR IOE2 Bit Changed */
+#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU)	/* DMA Errors */
+#define I_DMA		(I_RI | I_XI | I_ERRORS)
+
+/* sbintstatus */
+#define I_SB_SERR	(1 << 8)	/* Backplane SError (write) */
+#define I_SB_RESPERR	(1 << 9)	/* Backplane Response Error (read) */
+#define I_SB_SPROMERR	(1 << 10)	/* Error accessing the sprom */
+
+/* sdioaccess */
+#define SDA_DATA_MASK	0x000000ff	/* Read/Write Data Mask */
+#define SDA_ADDR_MASK	0x000fff00	/* Read/Write Address Mask */
+#define SDA_ADDR_SHIFT	8	/* Read/Write Address Shift */
+#define SDA_WRITE	0x01000000	/* Write bit  */
+#define SDA_READ	0x00000000	/* Write bit cleared for Read */
+#define SDA_BUSY	0x80000000	/* Busy bit */
+
+/* sdioaccess-accessible register address spaces */
+#define SDA_CCCR_SPACE		0x000	/* sdioAccess CCCR register space */
+#define SDA_F1_FBR_SPACE	0x100	/* sdioAccess F1 FBR register space */
+#define SDA_F2_FBR_SPACE	0x200	/* sdioAccess F2 FBR register space */
+#define SDA_F1_REG_SPACE	0x300	/* sdioAccess F1 core-specific register space */
+
+/* SDA_F1_REG_SPACE sdioaccess-accessible F1 reg space register offsets */
+#define SDA_CHIPCONTROLDATA	0x006	/* ChipControlData */
+#define SDA_CHIPCONTROLENAB	0x007	/* ChipControlEnable */
+#define SDA_F2WATERMARK		0x008	/* Function 2 Watermark */
+#define SDA_DEVICECONTROL	0x009	/* DeviceControl */
+#define SDA_SBADDRLOW		0x00a	/* SbAddrLow */
+#define SDA_SBADDRMID		0x00b	/* SbAddrMid */
+#define SDA_SBADDRHIGH		0x00c	/* SbAddrHigh */
+#define SDA_FRAMECTRL		0x00d	/* FrameCtrl */
+#define SDA_CHIPCLOCKCSR	0x00e	/* ChipClockCSR */
+#define SDA_SDIOPULLUP		0x00f	/* SdioPullUp */
+#define SDA_SDIOWRFRAMEBCLOW	0x019	/* SdioWrFrameBCLow */
+#define SDA_SDIOWRFRAMEBCHIGH	0x01a	/* SdioWrFrameBCHigh */
+#define SDA_SDIORDFRAMEBCLOW	0x01b	/* SdioRdFrameBCLow */
+#define SDA_SDIORDFRAMEBCHIGH	0x01c	/* SdioRdFrameBCHigh */
+
+/* SDA_F2WATERMARK */
+#define SDA_F2WATERMARK_MASK	0x7f	/* F2Watermark Mask */
+
+/* SDA_SBADDRLOW */
+#define SDA_SBADDRLOW_MASK	0x80	/* SbAddrLow Mask */
+
+/* SDA_SBADDRMID */
+#define SDA_SBADDRMID_MASK	0xff	/* SbAddrMid Mask */
+
+/* SDA_SBADDRHIGH */
+#define SDA_SBADDRHIGH_MASK	0xff	/* SbAddrHigh Mask */
+
+/* SDA_FRAMECTRL */
+#define SFC_RF_TERM	(1 << 0)	/* Read Frame Terminate */
+#define SFC_WF_TERM	(1 << 1)	/* Write Frame Terminate */
+#define SFC_CRC4WOOS	(1 << 2)	/* HW reports CRC error for write out of sync */
+#define SFC_ABORTALL	(1 << 3)	/* Abort cancels all in-progress frames */
+
+/* pcmciaframectrl */
+#define PFC_RF_TERM	(1 << 0)	/* Read Frame Terminate */
+#define PFC_WF_TERM	(1 << 1)	/* Write Frame Terminate */
+
+/* intrcvlazy */
+#define	IRL_TO_MASK	0x00ffffff	/* timeout */
+#define	IRL_FC_MASK	0xff000000	/* frame count */
+#define	IRL_FC_SHIFT	24	/* frame count */
+
+/* rx header */
+typedef volatile struct {
+	uint16 len;
+	uint16 flags;
+} sdpcmd_rxh_t;
+
+/* rx header flags */
+#define RXF_CRC		0x0001	/* CRC error detected */
+#define RXF_WOOS	0x0002	/* write frame out of sync */
+#define RXF_WF_TERM	0x0004	/* write frame terminated */
+#define RXF_ABORT	0x0008	/* write frame aborted */
+#define RXF_DISCARD	(RXF_CRC | RXF_WOOS | RXF_WF_TERM | RXF_ABORT)	/* bad frame */
+
+/* HW frame tag */
+#define SDPCM_FRAMETAG_LEN	4	/* HW frametag: 2 bytes len, 2 bytes check val */
+
+#endif				/* _sbsdpcmdev_h_ */
diff --git a/drivers/staging/brcm80211/include/sbsocram.h b/drivers/staging/brcm80211/include/sbsocram.h
new file mode 100644
index 0000000..7b09be9
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sbsocram.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SBSOCRAM_H
+#define	_SBSOCRAM_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+/* Memcsocram core registers */
+typedef volatile struct sbsocramregs {
+	uint32 coreinfo;
+	uint32 bwalloc;
+	uint32 extracoreinfo;
+	uint32 biststat;
+	uint32 bankidx;
+	uint32 standbyctrl;
+
+	uint32 errlogstatus;	/* rev 6 */
+	uint32 errlogaddr;	/* rev 6 */
+	/* used for patching rev 3 & 5 */
+	uint32 cambankidx;
+	uint32 cambankstandbyctrl;
+	uint32 cambankpatchctrl;
+	uint32 cambankpatchtblbaseaddr;
+	uint32 cambankcmdreg;
+	uint32 cambankdatareg;
+	uint32 cambankmaskreg;
+	uint32 PAD[1];
+	uint32 bankinfo;	/* corev 8 */
+	uint32 PAD[15];
+	uint32 extmemconfig;
+	uint32 extmemparitycsr;
+	uint32 extmemparityerrdata;
+	uint32 extmemparityerrcnt;
+	uint32 extmemwrctrlandsize;
+	uint32 PAD[84];
+	uint32 workaround;
+	uint32 pwrctl;		/* corerev >= 2 */
+} sbsocramregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* Register offsets */
+#define	SR_COREINFO		0x00
+#define	SR_BWALLOC		0x04
+#define	SR_BISTSTAT		0x0c
+#define	SR_BANKINDEX		0x10
+#define	SR_BANKSTBYCTL		0x14
+#define SR_PWRCTL		0x1e8
+
+/* Coreinfo register */
+#define	SRCI_PT_MASK		0x00070000	/* corerev >= 6; port type[18:16] */
+#define	SRCI_PT_SHIFT		16
+/* port types : SRCI_PT_<processorPT>_<backplanePT> */
+#define SRCI_PT_OCP_OCP		0
+#define SRCI_PT_AXI_OCP		1
+#define SRCI_PT_ARM7AHB_OCP	2
+#define SRCI_PT_CM3AHB_OCP	3
+#define SRCI_PT_AXI_AXI		4
+#define SRCI_PT_AHB_AXI		5
+/* corerev >= 3 */
+#define SRCI_LSS_MASK		0x00f00000
+#define SRCI_LSS_SHIFT		20
+#define SRCI_LRS_MASK		0x0f000000
+#define SRCI_LRS_SHIFT		24
+
+/* In corerev 0, the memory size is 2 to the power of the
+ * base plus 16 plus to the contents of the memsize field plus 1.
+ */
+#define	SRCI_MS0_MASK		0xf
+#define SR_MS0_BASE		16
+
+/*
+ * In corerev 1 the bank size is 2 ^ the bank size field plus 14,
+ * the memory size is number of banks times bank size.
+ * The same applies to rom size.
+ */
+#define	SRCI_ROMNB_MASK		0xf000
+#define	SRCI_ROMNB_SHIFT	12
+#define	SRCI_ROMBSZ_MASK	0xf00
+#define	SRCI_ROMBSZ_SHIFT	8
+#define	SRCI_SRNB_MASK		0xf0
+#define	SRCI_SRNB_SHIFT		4
+#define	SRCI_SRBSZ_MASK		0xf
+#define	SRCI_SRBSZ_SHIFT	0
+
+#define SR_BSZ_BASE		14
+
+/* Standby control register */
+#define	SRSC_SBYOVR_MASK	0x80000000
+#define	SRSC_SBYOVR_SHIFT	31
+#define	SRSC_SBYOVRVAL_MASK	0x60000000
+#define	SRSC_SBYOVRVAL_SHIFT	29
+#define	SRSC_SBYEN_MASK		0x01000000	/* rev >= 3 */
+#define	SRSC_SBYEN_SHIFT	24
+
+/* Power control register */
+#define SRPC_PMU_STBYDIS_MASK	0x00000010	/* rev >= 3 */
+#define SRPC_PMU_STBYDIS_SHIFT	4
+#define SRPC_STBYOVRVAL_MASK	0x00000008
+#define SRPC_STBYOVRVAL_SHIFT	3
+#define SRPC_STBYOVR_MASK	0x00000007
+#define SRPC_STBYOVR_SHIFT	0
+
+/* Extra core capability register */
+#define SRECC_NUM_BANKS_MASK   0x000000F0
+#define SRECC_NUM_BANKS_SHIFT  4
+#define SRECC_BANKSIZE_MASK    0x0000000F
+#define SRECC_BANKSIZE_SHIFT   0
+
+#define SRECC_BANKSIZE(value)	 (1 << (value))
+
+/* CAM bank patch control */
+#define SRCBPC_PATCHENABLE 0x80000000
+
+#define SRP_ADDRESS   0x0001FFFC
+#define SRP_VALID     0x8000
+
+/* CAM bank command reg */
+#define SRCMD_WRITE  0x00020000
+#define SRCMD_READ   0x00010000
+#define SRCMD_DONE   0x80000000
+
+#define SRCMD_DONE_DLY	1000
+
+/* bankidx and bankinfo reg defines corerev >= 8 */
+#define SOCRAM_BANKINFO_SZMASK		0x3f
+#define SOCRAM_BANKIDX_ROM_MASK		0x100
+
+#define SOCRAM_BANKIDX_MEMTYPE_SHIFT	8
+/* socram bankinfo memtype */
+#define SOCRAM_MEMTYPE_RAM		0
+#define SOCRAM_MEMTYPE_R0M		1
+#define SOCRAM_MEMTYPE_DEVRAM		2
+
+#define	SOCRAM_BANKINFO_REG		0x40
+#define	SOCRAM_BANKIDX_REG		0x10
+#define	SOCRAM_BANKINFO_STDBY_MASK	0x400
+#define	SOCRAM_BANKINFO_STDBY_TIMER	0x800
+
+/* bankinfo rev >= 10 */
+#define SOCRAM_BANKINFO_DEVRAMSEL_SHIFT	13
+#define SOCRAM_BANKINFO_DEVRAMSEL_MASK	0x2000
+#define SOCRAM_BANKINFO_DEVRAMPRO_SHIFT	14
+#define SOCRAM_BANKINFO_DEVRAMPRO_MASK	0x4000
+
+/* extracoreinfo register */
+#define SOCRAM_DEVRAMBANK_MASK		0xF000
+#define SOCRAM_DEVRAMBANK_SHIFT		12
+
+/* bank info to calculate bank size */
+#define	SOCRAM_BANKINFO_SZBASE		8192
+#define SOCRAM_BANKSIZE_SHIFT		13	/* SOCRAM_BANKINFO_SZBASE */
+
+#endif				/* _SBSOCRAM_H */
diff --git a/drivers/staging/brcm80211/include/sdio.h b/drivers/staging/brcm80211/include/sdio.h
new file mode 100644
index 0000000..8769c45
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sdio.h
@@ -0,0 +1,552 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SDIO_H
+#define	_SDIO_H
+
+#ifdef BCMSDIO
+
+/* CCCR structure for function 0 */
+typedef volatile struct {
+	uint8 cccr_sdio_rev;	/* RO, cccr and sdio revision */
+	uint8 sd_rev;		/* RO, sd spec revision */
+	uint8 io_en;		/* I/O enable */
+	uint8 io_rdy;		/* I/O ready reg */
+	uint8 intr_ctl;		/* Master and per function interrupt enable control */
+	uint8 intr_status;	/* RO, interrupt pending status */
+	uint8 io_abort;		/* read/write abort or reset all functions */
+	uint8 bus_inter;	/* bus interface control */
+	uint8 capability;	/* RO, card capability */
+
+	uint8 cis_base_low;	/* 0x9 RO, common CIS base address, LSB */
+	uint8 cis_base_mid;
+	uint8 cis_base_high;	/* 0xB RO, common CIS base address, MSB */
+
+	/* suspend/resume registers */
+	uint8 bus_suspend;	/* 0xC */
+	uint8 func_select;	/* 0xD */
+	uint8 exec_flag;	/* 0xE */
+	uint8 ready_flag;	/* 0xF */
+
+	uint8 fn0_blk_size[2];	/* 0x10(LSB), 0x11(MSB) */
+
+	uint8 power_control;	/* 0x12 (SDIO version 1.10) */
+
+	uint8 speed_control;	/* 0x13 */
+} sdio_regs_t;
+
+/* SDIO Device CCCR offsets */
+#define SDIOD_CCCR_REV			0x00
+#define SDIOD_CCCR_SDREV		0x01
+#define SDIOD_CCCR_IOEN			0x02
+#define SDIOD_CCCR_IORDY		0x03
+#define SDIOD_CCCR_INTEN		0x04
+#define SDIOD_CCCR_INTPEND		0x05
+#define SDIOD_CCCR_IOABORT		0x06
+#define SDIOD_CCCR_BICTRL		0x07
+#define SDIOD_CCCR_CAPABLITIES		0x08
+#define SDIOD_CCCR_CISPTR_0		0x09
+#define SDIOD_CCCR_CISPTR_1		0x0A
+#define SDIOD_CCCR_CISPTR_2		0x0B
+#define SDIOD_CCCR_BUSSUSP		0x0C
+#define SDIOD_CCCR_FUNCSEL		0x0D
+#define SDIOD_CCCR_EXECFLAGS		0x0E
+#define SDIOD_CCCR_RDYFLAGS		0x0F
+#define SDIOD_CCCR_BLKSIZE_0		0x10
+#define SDIOD_CCCR_BLKSIZE_1		0x11
+#define SDIOD_CCCR_POWER_CONTROL	0x12
+#define SDIOD_CCCR_SPEED_CONTROL	0x13
+
+/* Broadcom extensions (corerev >= 1) */
+#define SDIOD_CCCR_BRCM_SEPINT		0xf2
+
+/* cccr_sdio_rev */
+#define SDIO_REV_SDIOID_MASK	0xf0	/* SDIO spec revision number */
+#define SDIO_REV_CCCRID_MASK	0x0f	/* CCCR format version number */
+
+/* sd_rev */
+#define SD_REV_PHY_MASK		0x0f	/* SD format version number */
+
+/* io_en */
+#define SDIO_FUNC_ENABLE_1	0x02	/* function 1 I/O enable */
+#define SDIO_FUNC_ENABLE_2	0x04	/* function 2 I/O enable */
+
+/* io_rdys */
+#define SDIO_FUNC_READY_1	0x02	/* function 1 I/O ready */
+#define SDIO_FUNC_READY_2	0x04	/* function 2 I/O ready */
+
+/* intr_ctl */
+#define INTR_CTL_MASTER_EN	0x1	/* interrupt enable master */
+#define INTR_CTL_FUNC1_EN	0x2	/* interrupt enable for function 1 */
+#define INTR_CTL_FUNC2_EN	0x4	/* interrupt enable for function 2 */
+
+/* intr_status */
+#define INTR_STATUS_FUNC1	0x2	/* interrupt pending for function 1 */
+#define INTR_STATUS_FUNC2	0x4	/* interrupt pending for function 2 */
+
+/* io_abort */
+#define IO_ABORT_RESET_ALL	0x08	/* I/O card reset */
+#define IO_ABORT_FUNC_MASK	0x07	/* abort selction: function x */
+
+/* bus_inter */
+#define BUS_CARD_DETECT_DIS	0x80	/* Card Detect disable */
+#define BUS_SPI_CONT_INTR_CAP	0x40	/* support continuous SPI interrupt */
+#define BUS_SPI_CONT_INTR_EN	0x20	/* continuous SPI interrupt enable */
+#define BUS_SD_DATA_WIDTH_MASK	0x03	/* bus width mask */
+#define BUS_SD_DATA_WIDTH_4BIT	0x02	/* bus width 4-bit mode */
+#define BUS_SD_DATA_WIDTH_1BIT	0x00	/* bus width 1-bit mode */
+
+/* capability */
+#define SDIO_CAP_4BLS		0x80	/* 4-bit support for low speed card */
+#define SDIO_CAP_LSC		0x40	/* low speed card */
+#define SDIO_CAP_E4MI		0x20	/* enable interrupt between block of data in 4-bit mode */
+#define SDIO_CAP_S4MI		0x10	/* support interrupt between block of data in 4-bit mode */
+#define SDIO_CAP_SBS		0x08	/* support suspend/resume */
+#define SDIO_CAP_SRW		0x04	/* support read wait */
+#define SDIO_CAP_SMB		0x02	/* support multi-block transfer */
+#define SDIO_CAP_SDC		0x01	/* Support Direct commands during multi-byte transfer */
+
+/* power_control */
+#define SDIO_POWER_SMPC		0x01	/* supports master power control (RO) */
+#define SDIO_POWER_EMPC		0x02	/* enable master power control (allow > 200mA) (RW) */
+
+/* speed_control (control device entry into high-speed clocking mode) */
+#define SDIO_SPEED_SHS		0x01	/* supports high-speed [clocking] mode (RO) */
+#define SDIO_SPEED_EHS		0x02	/* enable high-speed [clocking] mode (RW) */
+
+/* brcm sepint */
+#define SDIO_SEPINT_MASK	0x01	/* route sdpcmdev intr onto separate pad (chip-specific) */
+#define SDIO_SEPINT_OE		0x02	/* 1 asserts output enable for above pad */
+#define SDIO_SEPINT_ACT_HI	0x04	/* use active high interrupt level instead of active low */
+
+/* FBR structure for function 1-7, FBR addresses and register offsets */
+typedef volatile struct {
+	uint8 devctr;		/* device interface, CSA control */
+	uint8 ext_dev;		/* extended standard I/O device type code */
+	uint8 pwr_sel;		/* power selection support */
+	uint8 PAD[6];		/* reserved */
+
+	uint8 cis_low;		/* CIS LSB */
+	uint8 cis_mid;
+	uint8 cis_high;		/* CIS MSB */
+	uint8 csa_low;		/* code storage area, LSB */
+	uint8 csa_mid;
+	uint8 csa_high;		/* code storage area, MSB */
+	uint8 csa_dat_win;	/* data access window to function */
+
+	uint8 fnx_blk_size[2];	/* block size, little endian */
+} sdio_fbr_t;
+
+/* Maximum number of I/O funcs */
+#define SDIOD_MAX_IOFUNCS		7
+
+/* SDIO Device FBR Start Address  */
+#define SDIOD_FBR_STARTADDR		0x100
+
+/* SDIO Device FBR Size */
+#define SDIOD_FBR_SIZE			0x100
+
+/* Macro to calculate FBR register base */
+#define SDIOD_FBR_BASE(n)		((n) * 0x100)
+
+/* Function register offsets */
+#define SDIOD_FBR_DEVCTR		0x00	/* basic info for function */
+#define SDIOD_FBR_EXT_DEV		0x01	/* extended I/O device code */
+#define SDIOD_FBR_PWR_SEL		0x02	/* power selection bits */
+
+/* SDIO Function CIS ptr offset */
+#define SDIOD_FBR_CISPTR_0		0x09
+#define SDIOD_FBR_CISPTR_1		0x0A
+#define SDIOD_FBR_CISPTR_2		0x0B
+
+/* Code Storage Area pointer */
+#define SDIOD_FBR_CSA_ADDR_0		0x0C
+#define SDIOD_FBR_CSA_ADDR_1		0x0D
+#define SDIOD_FBR_CSA_ADDR_2		0x0E
+#define SDIOD_FBR_CSA_DATA		0x0F
+
+/* SDIO Function I/O Block Size */
+#define SDIOD_FBR_BLKSIZE_0		0x10
+#define SDIOD_FBR_BLKSIZE_1		0x11
+
+/* devctr */
+#define SDIOD_FBR_DEVCTR_DIC	0x0f	/* device interface code */
+#define SDIOD_FBR_DECVTR_CSA	0x40	/* CSA support flag */
+#define SDIOD_FBR_DEVCTR_CSA_EN	0x80	/* CSA enabled */
+/* interface codes */
+#define SDIOD_DIC_NONE		0	/* SDIO standard interface is not supported */
+#define SDIOD_DIC_UART		1
+#define SDIOD_DIC_BLUETOOTH_A	2
+#define SDIOD_DIC_BLUETOOTH_B	3
+#define SDIOD_DIC_GPS		4
+#define SDIOD_DIC_CAMERA	5
+#define SDIOD_DIC_PHS		6
+#define SDIOD_DIC_WLAN		7
+#define SDIOD_DIC_EXT		0xf	/* extended device interface, read ext_dev register */
+
+/* pwr_sel */
+#define SDIOD_PWR_SEL_SPS	0x01	/* supports power selection */
+#define SDIOD_PWR_SEL_EPS	0x02	/* enable power selection (low-current mode) */
+
+/* misc defines */
+#define SDIO_FUNC_0		0
+#define SDIO_FUNC_1		1
+#define SDIO_FUNC_2		2
+#define SDIO_FUNC_3		3
+#define SDIO_FUNC_4		4
+#define SDIO_FUNC_5		5
+#define SDIO_FUNC_6		6
+#define SDIO_FUNC_7		7
+
+#define SD_CARD_TYPE_UNKNOWN	0	/* bad type or unrecognized */
+#define SD_CARD_TYPE_IO		1	/* IO only card */
+#define SD_CARD_TYPE_MEMORY	2	/* memory only card */
+#define SD_CARD_TYPE_COMBO	3	/* IO and memory combo card */
+
+#define SDIO_MAX_BLOCK_SIZE	2048	/* maximum block size for block mode operation */
+#define SDIO_MIN_BLOCK_SIZE	1	/* minimum block size for block mode operation */
+
+/* Card registers: status bit position */
+#define CARDREG_STATUS_BIT_OUTOFRANGE		31
+#define CARDREG_STATUS_BIT_COMCRCERROR		23
+#define CARDREG_STATUS_BIT_ILLEGALCOMMAND	22
+#define CARDREG_STATUS_BIT_ERROR		19
+#define CARDREG_STATUS_BIT_IOCURRENTSTATE3	12
+#define CARDREG_STATUS_BIT_IOCURRENTSTATE2	11
+#define CARDREG_STATUS_BIT_IOCURRENTSTATE1	10
+#define CARDREG_STATUS_BIT_IOCURRENTSTATE0	9
+#define CARDREG_STATUS_BIT_FUN_NUM_ERROR	4
+
+#define SD_CMD_GO_IDLE_STATE		0	/* mandatory for SDIO */
+#define SD_CMD_SEND_OPCOND		1
+#define SD_CMD_MMC_SET_RCA		3
+#define SD_CMD_IO_SEND_OP_COND		5	/* mandatory for SDIO */
+#define SD_CMD_SELECT_DESELECT_CARD	7
+#define SD_CMD_SEND_CSD			9
+#define SD_CMD_SEND_CID			10
+#define SD_CMD_STOP_TRANSMISSION	12
+#define SD_CMD_SEND_STATUS		13
+#define SD_CMD_GO_INACTIVE_STATE	15
+#define SD_CMD_SET_BLOCKLEN		16
+#define SD_CMD_READ_SINGLE_BLOCK	17
+#define SD_CMD_READ_MULTIPLE_BLOCK	18
+#define SD_CMD_WRITE_BLOCK		24
+#define SD_CMD_WRITE_MULTIPLE_BLOCK	25
+#define SD_CMD_PROGRAM_CSD		27
+#define SD_CMD_SET_WRITE_PROT		28
+#define SD_CMD_CLR_WRITE_PROT		29
+#define SD_CMD_SEND_WRITE_PROT		30
+#define SD_CMD_ERASE_WR_BLK_START	32
+#define SD_CMD_ERASE_WR_BLK_END		33
+#define SD_CMD_ERASE			38
+#define SD_CMD_LOCK_UNLOCK		42
+#define SD_CMD_IO_RW_DIRECT		52	/* mandatory for SDIO */
+#define SD_CMD_IO_RW_EXTENDED		53	/* mandatory for SDIO */
+#define SD_CMD_APP_CMD			55
+#define SD_CMD_GEN_CMD			56
+#define SD_CMD_READ_OCR			58
+#define SD_CMD_CRC_ON_OFF		59	/* mandatory for SDIO */
+#define SD_ACMD_SD_STATUS		13
+#define SD_ACMD_SEND_NUM_WR_BLOCKS	22
+#define SD_ACMD_SET_WR_BLOCK_ERASE_CNT	23
+#define SD_ACMD_SD_SEND_OP_COND		41
+#define SD_ACMD_SET_CLR_CARD_DETECT	42
+#define SD_ACMD_SEND_SCR		51
+
+/* argument for SD_CMD_IO_RW_DIRECT and SD_CMD_IO_RW_EXTENDED */
+#define SD_IO_OP_READ		0	/* Read_Write: Read */
+#define SD_IO_OP_WRITE		1	/* Read_Write: Write */
+#define SD_IO_RW_NORMAL		0	/* no RAW */
+#define SD_IO_RW_RAW		1	/* RAW */
+#define SD_IO_BYTE_MODE		0	/* Byte Mode */
+#define SD_IO_BLOCK_MODE	1	/* BlockMode */
+#define SD_IO_FIXED_ADDRESS	0	/* fix Address */
+#define SD_IO_INCREMENT_ADDRESS	1	/* IncrementAddress */
+
+/* build SD_CMD_IO_RW_DIRECT Argument */
+#define SDIO_IO_RW_DIRECT_ARG(rw, raw, func, addr, data) \
+	((((rw) & 1) << 31) | (((func) & 0x7) << 28) | (((raw) & 1) << 27) | \
+	 (((addr) & 0x1FFFF) << 9) | ((data) & 0xFF))
+
+/* build SD_CMD_IO_RW_EXTENDED Argument */
+#define SDIO_IO_RW_EXTENDED_ARG(rw, blk, func, addr, inc_addr, count) \
+	((((rw) & 1) << 31) | (((func) & 0x7) << 28) | (((blk) & 1) << 27) | \
+	 (((inc_addr) & 1) << 26) | (((addr) & 0x1FFFF) << 9) | ((count) & 0x1FF))
+
+/* SDIO response parameters */
+#define SD_RSP_NO_NONE			0
+#define SD_RSP_NO_1			1
+#define SD_RSP_NO_2			2
+#define SD_RSP_NO_3			3
+#define SD_RSP_NO_4			4
+#define SD_RSP_NO_5			5
+#define SD_RSP_NO_6			6
+
+	/* Modified R6 response (to CMD3) */
+#define SD_RSP_MR6_COM_CRC_ERROR	0x8000
+#define SD_RSP_MR6_ILLEGAL_COMMAND	0x4000
+#define SD_RSP_MR6_ERROR		0x2000
+
+	/* Modified R1 in R4 Response (to CMD5) */
+#define SD_RSP_MR1_SBIT			0x80
+#define SD_RSP_MR1_PARAMETER_ERROR	0x40
+#define SD_RSP_MR1_RFU5			0x20
+#define SD_RSP_MR1_FUNC_NUM_ERROR	0x10
+#define SD_RSP_MR1_COM_CRC_ERROR	0x08
+#define SD_RSP_MR1_ILLEGAL_COMMAND	0x04
+#define SD_RSP_MR1_RFU1			0x02
+#define SD_RSP_MR1_IDLE_STATE		0x01
+
+	/* R5 response (to CMD52 and CMD53) */
+#define SD_RSP_R5_COM_CRC_ERROR		0x80
+#define SD_RSP_R5_ILLEGAL_COMMAND	0x40
+#define SD_RSP_R5_IO_CURRENTSTATE1	0x20
+#define SD_RSP_R5_IO_CURRENTSTATE0	0x10
+#define SD_RSP_R5_ERROR			0x08
+#define SD_RSP_R5_RFU			0x04
+#define SD_RSP_R5_FUNC_NUM_ERROR	0x02
+#define SD_RSP_R5_OUT_OF_RANGE		0x01
+
+#define SD_RSP_R5_ERRBITS		0xCB
+
+/* ------------------------------------------------
+ *  SDIO Commands and responses
+ *
+ *  I/O only commands are:
+ *      CMD0, CMD3, CMD5, CMD7, CMD15, CMD52, CMD53
+ * ------------------------------------------------
+ */
+
+/* SDIO Commands */
+#define SDIOH_CMD_0		0
+#define SDIOH_CMD_3		3
+#define SDIOH_CMD_5		5
+#define SDIOH_CMD_7		7
+#define SDIOH_CMD_15		15
+#define SDIOH_CMD_52		52
+#define SDIOH_CMD_53		53
+#define SDIOH_CMD_59		59
+
+/* SDIO Command Responses */
+#define SDIOH_RSP_NONE		0
+#define SDIOH_RSP_R1		1
+#define SDIOH_RSP_R2		2
+#define SDIOH_RSP_R3		3
+#define SDIOH_RSP_R4		4
+#define SDIOH_RSP_R5		5
+#define SDIOH_RSP_R6		6
+
+/*
+ *  SDIO Response Error flags
+ */
+#define SDIOH_RSP5_ERROR_FLAGS	0xCB
+
+/* ------------------------------------------------
+ * SDIO Command structures. I/O only commands are:
+ *
+ * 	CMD0, CMD3, CMD5, CMD7, CMD15, CMD52, CMD53
+ * ------------------------------------------------
+ */
+
+#define CMD5_OCR_M		BITFIELD_MASK(24)
+#define CMD5_OCR_S		0
+
+#define CMD7_RCA_M		BITFIELD_MASK(16)
+#define CMD7_RCA_S		16
+
+#define CMD_15_RCA_M		BITFIELD_MASK(16)
+#define CMD_15_RCA_S		16
+
+#define CMD52_DATA_M		BITFIELD_MASK(8)	/* Bits [7:0]    - Write Data/Stuff bits of CMD52
+							 */
+#define CMD52_DATA_S		0
+#define CMD52_REG_ADDR_M	BITFIELD_MASK(17)	/* Bits [25:9]   - register address */
+#define CMD52_REG_ADDR_S	9
+#define CMD52_RAW_M		BITFIELD_MASK(1)	/* Bit  27       - Read after Write flag */
+#define CMD52_RAW_S		27
+#define CMD52_FUNCTION_M	BITFIELD_MASK(3)	/* Bits [30:28]  - Function number */
+#define CMD52_FUNCTION_S	28
+#define CMD52_RW_FLAG_M		BITFIELD_MASK(1)	/* Bit  31       - R/W flag */
+#define CMD52_RW_FLAG_S		31
+
+#define CMD53_BYTE_BLK_CNT_M	BITFIELD_MASK(9)	/* Bits [8:0]     - Byte/Block Count of CMD53 */
+#define CMD53_BYTE_BLK_CNT_S	0
+#define CMD53_REG_ADDR_M	BITFIELD_MASK(17)	/* Bits [25:9]   - register address */
+#define CMD53_REG_ADDR_S	9
+#define CMD53_OP_CODE_M		BITFIELD_MASK(1)	/* Bit  26       - R/W Operation Code */
+#define CMD53_OP_CODE_S		26
+#define CMD53_BLK_MODE_M	BITFIELD_MASK(1)	/* Bit  27       - Block Mode */
+#define CMD53_BLK_MODE_S	27
+#define CMD53_FUNCTION_M	BITFIELD_MASK(3)	/* Bits [30:28]  - Function number */
+#define CMD53_FUNCTION_S	28
+#define CMD53_RW_FLAG_M		BITFIELD_MASK(1)	/* Bit  31       - R/W flag */
+#define CMD53_RW_FLAG_S		31
+
+/* ------------------------------------------------------
+ * SDIO Command Response structures for SD1 and SD4 modes
+ *  -----------------------------------------------------
+ */
+#define RSP4_IO_OCR_M		BITFIELD_MASK(24)	/* Bits [23:0]  - Card's OCR Bits [23:0] */
+#define RSP4_IO_OCR_S		0
+#define RSP4_STUFF_M		BITFIELD_MASK(3)	/* Bits [26:24] - Stuff bits */
+#define RSP4_STUFF_S		24
+#define RSP4_MEM_PRESENT_M	BITFIELD_MASK(1)	/* Bit  27      - Memory present */
+#define RSP4_MEM_PRESENT_S	27
+#define RSP4_NUM_FUNCS_M	BITFIELD_MASK(3)	/* Bits [30:28] - Number of I/O funcs */
+#define RSP4_NUM_FUNCS_S	28
+#define RSP4_CARD_READY_M	BITFIELD_MASK(1)	/* Bit  31      - SDIO card ready */
+#define RSP4_CARD_READY_S	31
+
+#define RSP6_STATUS_M		BITFIELD_MASK(16)	/* Bits [15:0]  - Card status bits [19,22,23,12:0]
+							 */
+#define RSP6_STATUS_S		0
+#define RSP6_IO_RCA_M		BITFIELD_MASK(16)	/* Bits [31:16] - RCA bits[31-16] */
+#define RSP6_IO_RCA_S		16
+
+#define RSP1_AKE_SEQ_ERROR_M	BITFIELD_MASK(1)	/* Bit 3       - Authentication seq error */
+#define RSP1_AKE_SEQ_ERROR_S	3
+#define RSP1_APP_CMD_M		BITFIELD_MASK(1)	/* Bit 5       - Card expects ACMD */
+#define RSP1_APP_CMD_S		5
+#define RSP1_READY_FOR_DATA_M	BITFIELD_MASK(1)	/* Bit 8       - Ready for data (buff empty) */
+#define RSP1_READY_FOR_DATA_S	8
+#define RSP1_CURR_STATE_M	BITFIELD_MASK(4)	/* Bits [12:9] - State of card
+							 * when Cmd was received
+							 */
+#define RSP1_CURR_STATE_S	9
+#define RSP1_EARSE_RESET_M	BITFIELD_MASK(1)	/* Bit 13   - Erase seq cleared */
+#define RSP1_EARSE_RESET_S	13
+#define RSP1_CARD_ECC_DISABLE_M	BITFIELD_MASK(1)	/* Bit 14   - Card ECC disabled */
+#define RSP1_CARD_ECC_DISABLE_S	14
+#define RSP1_WP_ERASE_SKIP_M	BITFIELD_MASK(1)	/* Bit 15   - Partial blocks erased due to W/P */
+#define RSP1_WP_ERASE_SKIP_S	15
+#define RSP1_CID_CSD_OVERW_M	BITFIELD_MASK(1)	/* Bit 16   - Illegal write to CID or R/O bits
+							 * of CSD
+							 */
+#define RSP1_CID_CSD_OVERW_S	16
+#define RSP1_ERROR_M		BITFIELD_MASK(1)	/* Bit 19   - General/Unknown error */
+#define RSP1_ERROR_S		19
+#define RSP1_CC_ERROR_M		BITFIELD_MASK(1)	/* Bit 20   - Internal Card Control error */
+#define RSP1_CC_ERROR_S		20
+#define RSP1_CARD_ECC_FAILED_M	BITFIELD_MASK(1)	/* Bit 21   - Card internal ECC failed
+							 * to correct data
+							 */
+#define RSP1_CARD_ECC_FAILED_S	21
+#define RSP1_ILLEGAL_CMD_M	BITFIELD_MASK(1)	/* Bit 22   - Cmd not legal for the card state */
+#define RSP1_ILLEGAL_CMD_S	22
+#define RSP1_COM_CRC_ERROR_M	BITFIELD_MASK(1)	/* Bit 23   - CRC check of previous command failed
+							 */
+#define RSP1_COM_CRC_ERROR_S	23
+#define RSP1_LOCK_UNLOCK_FAIL_M	BITFIELD_MASK(1)	/* Bit 24   - Card lock-unlock Cmd Seq error */
+#define RSP1_LOCK_UNLOCK_FAIL_S	24
+#define RSP1_CARD_LOCKED_M	BITFIELD_MASK(1)	/* Bit 25   - Card locked by the host */
+#define RSP1_CARD_LOCKED_S	25
+#define RSP1_WP_VIOLATION_M	BITFIELD_MASK(1)	/* Bit 26   - Attempt to program
+							 * write-protected blocks
+							 */
+#define RSP1_WP_VIOLATION_S	26
+#define RSP1_ERASE_PARAM_M	BITFIELD_MASK(1)	/* Bit 27   - Invalid erase blocks */
+#define RSP1_ERASE_PARAM_S	27
+#define RSP1_ERASE_SEQ_ERR_M	BITFIELD_MASK(1)	/* Bit 28   - Erase Cmd seq error */
+#define RSP1_ERASE_SEQ_ERR_S	28
+#define RSP1_BLK_LEN_ERR_M	BITFIELD_MASK(1)	/* Bit 29   - Block length error */
+#define RSP1_BLK_LEN_ERR_S	29
+#define RSP1_ADDR_ERR_M		BITFIELD_MASK(1)	/* Bit 30   - Misaligned address */
+#define RSP1_ADDR_ERR_S		30
+#define RSP1_OUT_OF_RANGE_M	BITFIELD_MASK(1)	/* Bit 31   - Cmd arg was out of range */
+#define RSP1_OUT_OF_RANGE_S	31
+
+#define RSP5_DATA_M		BITFIELD_MASK(8)	/* Bits [0:7]   - data */
+#define RSP5_DATA_S		0
+#define RSP5_FLAGS_M		BITFIELD_MASK(8)	/* Bit  [15:8]  - Rsp flags */
+#define RSP5_FLAGS_S		8
+#define RSP5_STUFF_M		BITFIELD_MASK(16)	/* Bits [31:16] - Stuff bits */
+#define RSP5_STUFF_S		16
+
+/* ----------------------------------------------
+ * SDIO Command Response structures for SPI mode
+ * ----------------------------------------------
+ */
+#define SPIRSP4_IO_OCR_M	BITFIELD_MASK(16)	/* Bits [15:0]    - Card's OCR Bits [23:8] */
+#define SPIRSP4_IO_OCR_S	0
+#define SPIRSP4_STUFF_M		BITFIELD_MASK(3)	/* Bits [18:16]   - Stuff bits */
+#define SPIRSP4_STUFF_S		16
+#define SPIRSP4_MEM_PRESENT_M	BITFIELD_MASK(1)	/* Bit  19        - Memory present */
+#define SPIRSP4_MEM_PRESENT_S	19
+#define SPIRSP4_NUM_FUNCS_M	BITFIELD_MASK(3)	/* Bits [22:20]   - Number of I/O funcs */
+#define SPIRSP4_NUM_FUNCS_S	20
+#define SPIRSP4_CARD_READY_M	BITFIELD_MASK(1)	/* Bit  23        - SDIO card ready */
+#define SPIRSP4_CARD_READY_S	23
+#define SPIRSP4_IDLE_STATE_M	BITFIELD_MASK(1)	/* Bit  24        - idle state */
+#define SPIRSP4_IDLE_STATE_S	24
+#define SPIRSP4_ILLEGAL_CMD_M	BITFIELD_MASK(1)	/* Bit  26        - Illegal Cmd error */
+#define SPIRSP4_ILLEGAL_CMD_S	26
+#define SPIRSP4_COM_CRC_ERROR_M	BITFIELD_MASK(1)	/* Bit  27        - COM CRC error */
+#define SPIRSP4_COM_CRC_ERROR_S	27
+#define SPIRSP4_FUNC_NUM_ERROR_M	BITFIELD_MASK(1)	/* Bit  28        - Function number error
+								 */
+#define SPIRSP4_FUNC_NUM_ERROR_S	28
+#define SPIRSP4_PARAM_ERROR_M	BITFIELD_MASK(1)	/* Bit  30        - Parameter Error Bit */
+#define SPIRSP4_PARAM_ERROR_S	30
+#define SPIRSP4_START_BIT_M	BITFIELD_MASK(1)	/* Bit  31        - Start Bit */
+#define SPIRSP4_START_BIT_S	31
+
+#define SPIRSP5_DATA_M			BITFIELD_MASK(8)	/* Bits [23:16]   - R/W Data */
+#define SPIRSP5_DATA_S			16
+#define SPIRSP5_IDLE_STATE_M		BITFIELD_MASK(1)	/* Bit  24        - Idle state */
+#define SPIRSP5_IDLE_STATE_S		24
+#define SPIRSP5_ILLEGAL_CMD_M		BITFIELD_MASK(1)	/* Bit  26        - Illegal Cmd error */
+#define SPIRSP5_ILLEGAL_CMD_S		26
+#define SPIRSP5_COM_CRC_ERROR_M		BITFIELD_MASK(1)	/* Bit  27        - COM CRC error */
+#define SPIRSP5_COM_CRC_ERROR_S		27
+#define SPIRSP5_FUNC_NUM_ERROR_M	BITFIELD_MASK(1)	/* Bit  28        - Function number error
+								 */
+#define SPIRSP5_FUNC_NUM_ERROR_S	28
+#define SPIRSP5_PARAM_ERROR_M		BITFIELD_MASK(1)	/* Bit  30        - Parameter Error Bit */
+#define SPIRSP5_PARAM_ERROR_S		30
+#define SPIRSP5_START_BIT_M		BITFIELD_MASK(1)	/* Bit  31        - Start Bit */
+#define SPIRSP5_START_BIT_S		31
+
+/* RSP6 card status format; Pg 68 Physical Layer spec v 1.10 */
+#define RSP6STAT_AKE_SEQ_ERROR_M	BITFIELD_MASK(1)	/* Bit 3      - Authentication seq error
+								 */
+#define RSP6STAT_AKE_SEQ_ERROR_S	3
+#define RSP6STAT_APP_CMD_M		BITFIELD_MASK(1)	/* Bit 5      - Card expects ACMD */
+#define RSP6STAT_APP_CMD_S		5
+#define RSP6STAT_READY_FOR_DATA_M	BITFIELD_MASK(1)	/* Bit 8      - Ready for data
+								 * (buff empty)
+								 */
+#define RSP6STAT_READY_FOR_DATA_S	8
+#define RSP6STAT_CURR_STATE_M		BITFIELD_MASK(4)	/* Bits [12:9] - Card state at
+								 * Cmd reception
+								 */
+#define RSP6STAT_CURR_STATE_S		9
+#define RSP6STAT_ERROR_M		BITFIELD_MASK(1)	/* Bit 13  - General/Unknown error Bit 19
+								 */
+#define RSP6STAT_ERROR_S		13
+#define RSP6STAT_ILLEGAL_CMD_M		BITFIELD_MASK(1)	/* Bit 14  - Illegal cmd for
+								 * card state Bit 22
+								 */
+#define RSP6STAT_ILLEGAL_CMD_S		14
+#define RSP6STAT_COM_CRC_ERROR_M	BITFIELD_MASK(1)	/* Bit 15  - CRC previous command
+								 * failed Bit 23
+								 */
+#define RSP6STAT_COM_CRC_ERROR_S	15
+
+#define SDIOH_XFER_TYPE_READ    SD_IO_OP_READ
+#define SDIOH_XFER_TYPE_WRITE   SD_IO_OP_WRITE
+
+#endif				/* def BCMSDIO */
+#endif				/* _SDIO_H */
diff --git a/drivers/staging/brcm80211/include/sdioh.h b/drivers/staging/brcm80211/include/sdioh.h
new file mode 100644
index 0000000..f96aaf9
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sdioh.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SDIOH_H
+#define	_SDIOH_H
+
+#define SD_SysAddr			0x000
+#define SD_BlockSize			0x004
+#define SD_BlockCount 			0x006
+#define SD_Arg0				0x008
+#define SD_Arg1 			0x00A
+#define SD_TransferMode			0x00C
+#define SD_Command 			0x00E
+#define SD_Response0			0x010
+#define SD_Response1 			0x012
+#define SD_Response2			0x014
+#define SD_Response3 			0x016
+#define SD_Response4			0x018
+#define SD_Response5 			0x01A
+#define SD_Response6			0x01C
+#define SD_Response7 			0x01E
+#define SD_BufferDataPort0		0x020
+#define SD_BufferDataPort1 		0x022
+#define SD_PresentState			0x024
+#define SD_HostCntrl			0x028
+#define SD_PwrCntrl			0x029
+#define SD_BlockGapCntrl 		0x02A
+#define SD_WakeupCntrl 			0x02B
+#define SD_ClockCntrl			0x02C
+#define SD_TimeoutCntrl 		0x02E
+#define SD_SoftwareReset		0x02F
+#define SD_IntrStatus			0x030
+#define SD_ErrorIntrStatus 		0x032
+#define SD_IntrStatusEnable		0x034
+#define SD_ErrorIntrStatusEnable 	0x036
+#define SD_IntrSignalEnable		0x038
+#define SD_ErrorIntrSignalEnable 	0x03A
+#define SD_CMD12ErrorStatus		0x03C
+#define SD_Capabilities			0x040
+#define SD_Capabilities_Reserved	0x044
+#define SD_MaxCurCap			0x048
+#define SD_MaxCurCap_Reserved		0x04C
+#define SD_ADMA_SysAddr			0x58
+#define SD_SlotInterruptStatus		0x0FC
+#define SD_HostControllerVersion 	0x0FE
+
+/* SD specific registers in PCI config space */
+#define SD_SlotInfo	0x40
+
+#endif				/* _SDIOH_H */
diff --git a/drivers/staging/brcm80211/include/sdiovar.h b/drivers/staging/brcm80211/include/sdiovar.h
new file mode 100644
index 0000000..2112cb6
--- /dev/null
+++ b/drivers/staging/brcm80211/include/sdiovar.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _sdiovar_h_
+#define _sdiovar_h_
+
+#include <typedefs.h>
+
+/* require default structure packing */
+#define BWL_DEFAULT_PACKING
+#include <packed_section_start.h>
+
+typedef struct sdreg {
+	int func;
+	int offset;
+	int value;
+} sdreg_t;
+
+/* Common msglevel constants */
+#define SDH_ERROR_VAL		0x0001	/* Error */
+#define SDH_TRACE_VAL		0x0002	/* Trace */
+#define SDH_INFO_VAL		0x0004	/* Info */
+#define SDH_DEBUG_VAL		0x0008	/* Debug */
+#define SDH_DATA_VAL		0x0010	/* Data */
+#define SDH_CTRL_VAL		0x0020	/* Control Regs */
+#define SDH_LOG_VAL		0x0040	/* Enable bcmlog */
+#define SDH_DMA_VAL		0x0080	/* DMA */
+
+#define NUM_PREV_TRANSACTIONS	16
+
+#include <packed_section_end.h>
+
+#endif				/* _sdiovar_h_ */
diff --git a/drivers/staging/brcm80211/include/siutils.h b/drivers/staging/brcm80211/include/siutils.h
new file mode 100644
index 0000000..13925b2
--- /dev/null
+++ b/drivers/staging/brcm80211/include/siutils.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_siutils_h_
+#define	_siutils_h_
+
+#include <hndsoc.h>
+
+#if !defined(WLC_LOW)
+#include "bcm_rpc.h"
+#endif
+/*
+ * Data structure to export all chip specific common variables
+ *   public (read-only) portion of siutils handle returned by si_attach()
+ */
+struct si_pub {
+	uint socitype;		/* SOCI_SB, SOCI_AI */
+
+	uint bustype;		/* SI_BUS, PCI_BUS */
+	uint buscoretype;	/* PCI_CORE_ID, PCIE_CORE_ID, PCMCIA_CORE_ID */
+	uint buscorerev;	/* buscore rev */
+	uint buscoreidx;	/* buscore index */
+	int ccrev;		/* chip common core rev */
+	uint32 cccaps;		/* chip common capabilities */
+	uint32 cccaps_ext;	/* chip common capabilities extension */
+	int pmurev;		/* pmu core rev */
+	uint32 pmucaps;		/* pmu capabilities */
+	uint boardtype;		/* board type */
+	uint boardvendor;	/* board vendor */
+	uint boardflags;	/* board flags */
+	uint boardflags2;	/* board flags2 */
+	uint chip;		/* chip number */
+	uint chiprev;		/* chip revision */
+	uint chippkg;		/* chip package option */
+	uint32 chipst;		/* chip status */
+	bool issim;		/* chip is in simulation or emulation */
+	uint socirev;		/* SOC interconnect rev */
+	bool pci_pr32414;
+
+#if !defined(WLC_LOW)
+	rpc_info_t *rpc;
+#endif
+};
+
+/* for HIGH_ONLY driver, the si_t must be writable to allow states sync from BMAC to HIGH driver
+ * for monolithic driver, it is readonly to prevent accident change
+ */
+#if !defined(WLC_LOW)
+typedef struct si_pub si_t;
+#else
+typedef const struct si_pub si_t;
+#endif
+
+/*
+ * Many of the routines below take an 'sih' handle as their first arg.
+ * Allocate this by calling si_attach().  Free it by calling si_detach().
+ * At any one time, the sih is logically focused on one particular si core
+ * (the "current core").
+ * Use si_setcore() or si_setcoreidx() to change the association to another core.
+ */
+
+#define	BADIDX		(SI_MAXCORES + 1)
+
+/* clkctl xtal what flags */
+#define	XTAL			0x1	/* primary crystal oscillator (2050) */
+#define	PLL			0x2	/* main chip pll */
+
+/* clkctl clk mode */
+#define	CLK_FAST		0	/* force fast (pll) clock */
+#define	CLK_DYNAMIC		2	/* enable dynamic clock control */
+
+/* GPIO usage priorities */
+#define GPIO_DRV_PRIORITY	0	/* Driver */
+#define GPIO_APP_PRIORITY	1	/* Application */
+#define GPIO_HI_PRIORITY	2	/* Highest priority. Ignore GPIO reservation */
+
+/* GPIO pull up/down */
+#define GPIO_PULLUP		0
+#define GPIO_PULLDN		1
+
+/* GPIO event regtype */
+#define GPIO_REGEVT		0	/* GPIO register event */
+#define GPIO_REGEVT_INTMSK	1	/* GPIO register event int mask */
+#define GPIO_REGEVT_INTPOL	2	/* GPIO register event int polarity */
+
+/* device path */
+#define SI_DEVPATH_BUFSZ	16	/* min buffer size in bytes */
+
+/* SI routine enumeration: to be used by update function with multiple hooks */
+#define	SI_DOATTACH	1
+#define SI_PCIDOWN	2
+#define SI_PCIUP	3
+
+#define	ISSIM_ENAB(sih)	0
+
+/* PMU clock/power control */
+#if defined(BCMPMUCTL)
+#define PMUCTL_ENAB(sih)	(BCMPMUCTL)
+#else
+#define PMUCTL_ENAB(sih)	((sih)->cccaps & CC_CAP_PMU)
+#endif
+
+/* chipcommon clock/power control (exclusive with PMU's) */
+#if defined(BCMPMUCTL) && BCMPMUCTL
+#define CCCTL_ENAB(sih)		(0)
+#define CCPLL_ENAB(sih)		(0)
+#else
+#define CCCTL_ENAB(sih)		((sih)->cccaps & CC_CAP_PWR_CTL)
+#define CCPLL_ENAB(sih)		((sih)->cccaps & CC_CAP_PLL_MASK)
+#endif
+
+typedef void (*gpio_handler_t) (uint32 stat, void *arg);
+
+/* External PA enable mask */
+#define GPIO_CTRL_EPA_EN_MASK 0x40
+
+/* === exported functions === */
+extern si_t *si_attach(uint pcidev, osl_t * osh, void *regs, uint bustype,
+		       void *sdh, char **vars, uint * varsz);
+
+extern void si_detach(si_t * sih);
+extern bool si_pci_war16165(si_t * sih);
+
+extern uint si_corelist(si_t * sih, uint coreid[]);
+extern uint si_coreid(si_t * sih);
+extern uint si_flag(si_t * sih);
+extern uint si_intflag(si_t * sih);
+extern uint si_coreidx(si_t * sih);
+extern uint si_coreunit(si_t * sih);
+extern uint si_corevendor(si_t * sih);
+extern uint si_corerev(si_t * sih);
+extern void *si_osh(si_t * sih);
+extern void si_setosh(si_t * sih, osl_t * osh);
+extern uint si_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+		       uint val);
+extern void *si_coreregs(si_t * sih);
+extern void si_write_wrapperreg(si_t * sih, uint32 offset, uint32 val);
+extern uint32 si_core_cflags(si_t * sih, uint32 mask, uint32 val);
+extern void si_core_cflags_wo(si_t * sih, uint32 mask, uint32 val);
+extern uint32 si_core_sflags(si_t * sih, uint32 mask, uint32 val);
+extern bool si_iscoreup(si_t * sih);
+extern uint si_findcoreidx(si_t * sih, uint coreid, uint coreunit);
+#ifndef BCMSDIO
+extern void *si_setcoreidx(si_t * sih, uint coreidx);
+#endif
+extern void *si_setcore(si_t * sih, uint coreid, uint coreunit);
+extern void *si_switch_core(si_t * sih, uint coreid, uint * origidx,
+			    uint * intr_val);
+extern void si_restore_core(si_t * sih, uint coreid, uint intr_val);
+extern int si_numaddrspaces(si_t * sih);
+extern uint32 si_addrspace(si_t * sih, uint asidx);
+extern uint32 si_addrspacesize(si_t * sih, uint asidx);
+extern int si_corebist(si_t * sih);
+extern void si_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
+extern void si_core_disable(si_t * sih, uint32 bits);
+extern uint32 si_clock_rate(uint32 pll_type, uint32 n, uint32 m);
+extern uint32 si_clock(si_t * sih);
+extern uint32 si_alp_clock(si_t * sih);
+extern uint32 si_ilp_clock(si_t * sih);
+extern void si_pci_setup(si_t * sih, uint coremask);
+extern void si_setint(si_t * sih, int siflag);
+extern bool si_backplane64(si_t * sih);
+extern void si_register_intr_callback(si_t * sih, void *intrsoff_fn,
+				      void *intrsrestore_fn,
+				      void *intrsenabled_fn, void *intr_arg);
+extern void si_deregister_intr_callback(si_t * sih);
+extern void si_clkctl_init(si_t * sih);
+extern uint16 si_clkctl_fast_pwrup_delay(si_t * sih);
+extern bool si_clkctl_cc(si_t * sih, uint mode);
+extern int si_clkctl_xtal(si_t * sih, uint what, bool on);
+extern uint32 si_gpiotimerval(si_t * sih, uint32 mask, uint32 val);
+extern bool si_deviceremoved(si_t * sih);
+extern uint32 si_socram_size(si_t * sih);
+extern uint32 si_socdevram_size(si_t * sih);
+extern void si_socdevram(si_t * sih, bool set, uint8 * ennable,
+			 uint8 * protect);
+extern bool si_socdevram_pkg(si_t * sih);
+
+extern void si_watchdog(si_t * sih, uint ticks);
+extern void si_watchdog_ms(si_t * sih, uint32 ms);
+extern void *si_gpiosetcore(si_t * sih);
+extern uint32 si_gpiocontrol(si_t * sih, uint32 mask, uint32 val,
+			     uint8 priority);
+extern uint32 si_gpioouten(si_t * sih, uint32 mask, uint32 val, uint8 priority);
+extern uint32 si_gpioout(si_t * sih, uint32 mask, uint32 val, uint8 priority);
+extern uint32 si_gpioin(si_t * sih);
+extern uint32 si_gpiointpolarity(si_t * sih, uint32 mask, uint32 val,
+				 uint8 priority);
+extern uint32 si_gpiointmask(si_t * sih, uint32 mask, uint32 val,
+			     uint8 priority);
+extern uint32 si_gpioled(si_t * sih, uint32 mask, uint32 val);
+extern uint32 si_gpioreserve(si_t * sih, uint32 gpio_num, uint8 priority);
+extern uint32 si_gpiorelease(si_t * sih, uint32 gpio_num, uint8 priority);
+extern uint32 si_gpiopull(si_t * sih, bool updown, uint32 mask, uint32 val);
+extern uint32 si_gpioevent(si_t * sih, uint regtype, uint32 mask, uint32 val);
+extern uint32 si_gpio_int_enable(si_t * sih, bool enable);
+
+/* GPIO event handlers */
+extern void *si_gpio_handler_register(si_t * sih, uint32 e, bool lev,
+				      gpio_handler_t cb, void *arg);
+extern void si_gpio_handler_unregister(si_t * sih, void *gpioh);
+extern void si_gpio_handler_process(si_t * sih);
+
+/* Wake-on-wireless-LAN (WOWL) */
+extern bool si_pci_pmecap(si_t * sih);
+struct osl_info;
+extern bool si_pci_fastpmecap(struct osl_info *osh);
+extern bool si_pci_pmestat(si_t * sih);
+extern void si_pci_pmeclr(si_t * sih);
+extern void si_pci_pmeen(si_t * sih);
+extern uint si_pcie_readreg(void *sih, uint addrtype, uint offset);
+
+#ifdef BCMSDIO
+extern void si_sdio_init(si_t * sih);
+#endif
+
+extern uint16 si_d11_devid(si_t * sih);
+
+#define si_eci(sih) 0
+#define si_eci_init(sih) (0)
+#define si_eci_notify_bt(sih, type, val)  (0)
+#define si_seci(sih) 0
+static INLINE void *si_seci_init(si_t * sih, uint8 use_seci)
+{
+	return NULL;
+}
+
+/* OTP status */
+extern bool si_is_otp_disabled(si_t * sih);
+extern bool si_is_otp_powered(si_t * sih);
+extern void si_otp_power(si_t * sih, bool on);
+
+/* SPROM availability */
+extern bool si_is_sprom_available(si_t * sih);
+extern bool si_is_sprom_enabled(si_t * sih);
+extern void si_sprom_enable(si_t * sih, bool enable);
+#ifdef SI_SPROM_PROBE
+extern void si_sprom_init(si_t * sih);
+#endif				/* SI_SPROM_PROBE */
+
+/* OTP/SROM CIS stuff */
+extern int si_cis_source(si_t * sih);
+#define CIS_DEFAULT	0
+#define CIS_SROM	1
+#define CIS_OTP		2
+
+/* Fab-id information */
+#define	DEFAULT_FAB	0x0	/* Original/first fab used for this chip */
+#define	CSM_FAB7	0x1	/* CSM Fab7 chip */
+#define	TSMC_FAB12	0x2	/* TSMC Fab12/Fab14 chip */
+#define	SMIC_FAB4	0x3	/* SMIC Fab4 chip */
+
+#define	SI_ERROR(args)
+
+#ifdef BCMDBG
+#define	SI_MSG(args)	printf args
+#else
+#define	SI_MSG(args)
+#endif				/* BCMDBG */
+
+/* Define SI_VMSG to printf for verbose debugging, but don't check it in */
+#define	SI_VMSG(args)
+
+#define	IS_SIM(chippkg)	((chippkg == HDLSIM_PKG_ID) || (chippkg == HWSIM_PKG_ID))
+
+typedef uint32(*si_intrsoff_t) (void *intr_arg);
+typedef void (*si_intrsrestore_t) (void *intr_arg, uint32 arg);
+typedef bool(*si_intrsenabled_t) (void *intr_arg);
+
+typedef struct gpioh_item {
+	void *arg;
+	bool level;
+	gpio_handler_t handler;
+	uint32 event;
+	struct gpioh_item *next;
+} gpioh_item_t;
+
+/* misc si info needed by some of the routines */
+typedef struct si_info {
+	struct si_pub pub;	/* back plane public state (must be first field) */
+	void *osh;		/* osl os handle */
+	void *sdh;		/* bcmsdh handle */
+	uint dev_coreid;	/* the core provides driver functions */
+	void *intr_arg;		/* interrupt callback function arg */
+	si_intrsoff_t intrsoff_fn;	/* turns chip interrupts off */
+	si_intrsrestore_t intrsrestore_fn;	/* restore chip interrupts */
+	si_intrsenabled_t intrsenabled_fn;	/* check if interrupts are enabled */
+
+	void *pch;		/* PCI/E core handle */
+
+	gpioh_item_t *gpioh_head;	/* GPIO event handlers list */
+
+	bool memseg;		/* flag to toggle MEM_SEG register */
+
+	char *vars;
+	uint varsz;
+
+	void *curmap;		/* current regs va */
+	void *regs[SI_MAXCORES];	/* other regs va */
+
+	uint curidx;		/* current core index */
+	uint numcores;		/* # discovered cores */
+	uint coreid[SI_MAXCORES];	/* id of each core */
+	uint32 coresba[SI_MAXCORES];	/* backplane address of each core */
+	void *regs2[SI_MAXCORES];	/* va of each core second register set (usbh20) */
+	uint32 coresba2[SI_MAXCORES];	/* address of each core second register set (usbh20) */
+	uint32 coresba_size[SI_MAXCORES];	/* backplane address space size */
+	uint32 coresba2_size[SI_MAXCORES];	/* second address space size */
+
+	void *curwrap;		/* current wrapper va */
+	void *wrappers[SI_MAXCORES];	/* other cores wrapper va */
+	uint32 wrapba[SI_MAXCORES];	/* address of controlling wrapper */
+
+	uint32 cia[SI_MAXCORES];	/* erom cia entry for each core */
+	uint32 cib[SI_MAXCORES];	/* erom cia entry for each core */
+	uint32 oob_router;	/* oob router registers for axi */
+} si_info_t;
+
+#define	SI_INFO(sih)	(si_info_t *)(uintptr)sih
+
+#define	GOODCOREADDR(x, b) (((x) >= (b)) && ((x) < ((b) + SI_MAXCORES * SI_CORE_SIZE)) && \
+		ISALIGNED((x), SI_CORE_SIZE))
+#define	GOODREGS(regs)	((regs) != NULL && ISALIGNED((uintptr)(regs), SI_CORE_SIZE))
+#define BADCOREADDR	0
+#define	GOODIDX(idx)	(((uint)idx) < SI_MAXCORES)
+#define	NOREV		-1	/* Invalid rev */
+
+/* Newer chips can access PCI/PCIE and CC core without requiring to change
+ * PCI BAR0 WIN
+ */
+#define SI_FAST(si) (((si)->pub.buscoretype == PCIE_CORE_ID) ||	\
+		     (((si)->pub.buscoretype == PCI_CORE_ID) && (si)->pub.buscorerev >= 13))
+
+#define PCIEREGS(si) (((char *)((si)->curmap) + PCI_16KB0_PCIREGS_OFFSET))
+#define CCREGS_FAST(si) (((char *)((si)->curmap) + PCI_16KB0_CCREGS_OFFSET))
+
+/*
+ * Macros to disable/restore function core(D11, ENET, ILINE20, etc) interrupts
+ * before after core switching to avoid invalid register accesss inside ISR.
+ */
+#define INTR_OFF(si, intr_val) \
+	if ((si)->intrsoff_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
+		intr_val = (*(si)->intrsoff_fn)((si)->intr_arg); }
+#define INTR_RESTORE(si, intr_val) \
+	if ((si)->intrsrestore_fn && (si)->coreid[(si)->curidx] == (si)->dev_coreid) {	\
+		(*(si)->intrsrestore_fn)((si)->intr_arg, intr_val); }
+
+/* dynamic clock control defines */
+#define	LPOMINFREQ		25000	/* low power oscillator min */
+#define	LPOMAXFREQ		43000	/* low power oscillator max */
+#define	XTALMINFREQ		19800000	/* 20 MHz - 1% */
+#define	XTALMAXFREQ		20200000	/* 20 MHz + 1% */
+#define	PCIMINFREQ		25000000	/* 25 MHz */
+#define	PCIMAXFREQ		34000000	/* 33 MHz + fudge */
+
+#define	ILP_DIV_5MHZ		0	/* ILP = 5 MHz */
+#define	ILP_DIV_1MHZ		4	/* ILP = 1 MHz */
+
+#define PCI(si)		((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
+			 ((si)->pub.buscoretype == PCI_CORE_ID))
+#define PCIE(si)	((BUSTYPE((si)->pub.bustype) == PCI_BUS) &&	\
+			 ((si)->pub.buscoretype == PCIE_CORE_ID))
+#define PCI_FORCEHT(si)	\
+	(PCIE(si) && (si->pub.chip == BCM4716_CHIP_ID))
+
+/* GPIO Based LED powersave defines */
+#define DEFAULT_GPIO_ONTIME	10	/* Default: 10% on */
+#define DEFAULT_GPIO_OFFTIME	90	/* Default: 10% on */
+
+#ifndef DEFAULT_GPIOTIMERVAL
+#define DEFAULT_GPIOTIMERVAL  ((DEFAULT_GPIO_ONTIME << GPIO_ONTIME_SHIFT) | DEFAULT_GPIO_OFFTIME)
+#endif
+
+/*
+ * Build device path. Path size must be >= SI_DEVPATH_BUFSZ.
+ * The returned path is NULL terminated and has trailing '/'.
+ * Return 0 on success, nonzero otherwise.
+ */
+extern int si_devpath(si_t * sih, char *path, int size);
+/* Read variable with prepending the devpath to the name */
+extern char *si_getdevpathvar(si_t * sih, const char *name);
+extern int si_getdevpathintvar(si_t * sih, const char *name);
+
+extern uint8 si_pcieclkreq(si_t * sih, uint32 mask, uint32 val);
+extern uint32 si_pcielcreg(si_t * sih, uint32 mask, uint32 val);
+extern void si_war42780_clkreq(si_t * sih, bool clkreq);
+extern void si_pci_sleep(si_t * sih);
+extern void si_pci_down(si_t * sih);
+extern void si_pci_up(si_t * sih);
+extern void si_pcie_war_ovr_update(si_t * sih, uint8 aspm);
+extern void si_pcie_extendL1timer(si_t * sih, bool extend);
+extern int si_pci_fixcfg(si_t * sih);
+extern void si_chippkg_set(si_t * sih, uint);
+
+extern void si_chipcontrl_epa4331(si_t * sih, bool on);
+/* Enable Ex-PA for 4313 */
+extern void si_epa_4313war(si_t * sih);
+
+/* === debug routines === */
+extern uint32 si_pciereg(si_t * sih, uint32 offset, uint32 mask, uint32 val,
+			 uint type);
+extern uint32 si_pcieserdesreg(si_t * sih, uint32 mdioslave, uint32 offset,
+			       uint32 mask, uint32 val);
+
+char *si_getnvramflvar(si_t * sih, const char *name);
+
+/* AMBA Interconnect exported externs */
+extern si_t *ai_attach(uint pcidev, osl_t * osh, void *regs, uint bustype,
+		       void *sdh, char **vars, uint * varsz);
+extern si_t *ai_kattach(osl_t * osh);
+extern void ai_scan(si_t * sih, void *regs, uint devid);
+
+extern uint ai_flag(si_t * sih);
+extern void ai_setint(si_t * sih, int siflag);
+extern uint ai_coreidx(si_t * sih);
+extern uint ai_corevendor(si_t * sih);
+extern uint ai_corerev(si_t * sih);
+extern bool ai_iscoreup(si_t * sih);
+extern void *ai_setcoreidx(si_t * sih, uint coreidx);
+extern uint32 ai_core_cflags(si_t * sih, uint32 mask, uint32 val);
+extern void ai_core_cflags_wo(si_t * sih, uint32 mask, uint32 val);
+extern uint32 ai_core_sflags(si_t * sih, uint32 mask, uint32 val);
+extern uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+		       uint val);
+extern void ai_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
+extern void ai_core_disable(si_t * sih, uint32 bits);
+extern int ai_numaddrspaces(si_t * sih);
+extern uint32 ai_addrspace(si_t * sih, uint asidx);
+extern uint32 ai_addrspacesize(si_t * sih, uint asidx);
+extern void ai_write_wrap_reg(si_t * sih, uint32 offset, uint32 val);
+
+#ifdef BCMDBG
+extern void ai_view(si_t * sih, bool verbose);
+#endif
+
+#ifdef BCMSDIO
+#define si_setcoreidx(sih, idx) sb_setcoreidx(sih, idx)
+#define si_coreid(sih) sb_coreid(sih)
+#define si_corerev(sih) sb_corerev(sih)
+#endif
+
+#endif				/* _siutils_h_ */
diff --git a/drivers/staging/brcm80211/include/spid.h b/drivers/staging/brcm80211/include/spid.h
new file mode 100644
index 0000000..9cf4e0b
--- /dev/null
+++ b/drivers/staging/brcm80211/include/spid.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SPI_H
+#define	_SPI_H
+
+/*
+ * Brcm SPI Device Register Map.
+ *
+ */
+
+typedef volatile struct {
+	uint8 config;		/* 0x00, len, endian, clock, speed, polarity, wakeup */
+	uint8 response_delay;	/* 0x01, read response delay in bytes (corerev < 3) */
+	uint8 status_enable;	/* 0x02, status-enable, intr with status, response_delay
+				 * function selection, command/data error check
+				 */
+	uint8 reset_bp;		/* 0x03, reset on wlan/bt backplane reset (corerev >= 1) */
+	uint16 intr_reg;	/* 0x04, Intr status register */
+	uint16 intr_en_reg;	/* 0x06, Intr mask register */
+	uint32 status_reg;	/* 0x08, RO, Status bits of last spi transfer */
+	uint16 f1_info_reg;	/* 0x0c, RO, enabled, ready for data transfer, blocksize */
+	uint16 f2_info_reg;	/* 0x0e, RO, enabled, ready for data transfer, blocksize */
+	uint16 f3_info_reg;	/* 0x10, RO, enabled, ready for data transfer, blocksize */
+	uint32 test_read;	/* 0x14, RO 0xfeedbead signature */
+	uint32 test_rw;		/* 0x18, RW */
+	uint8 resp_delay_f0;	/* 0x1c, read resp delay bytes for F0 (corerev >= 3) */
+	uint8 resp_delay_f1;	/* 0x1d, read resp delay bytes for F1 (corerev >= 3) */
+	uint8 resp_delay_f2;	/* 0x1e, read resp delay bytes for F2 (corerev >= 3) */
+	uint8 resp_delay_f3;	/* 0x1f, read resp delay bytes for F3 (corerev >= 3) */
+} spi_regs_t;
+
+/* SPI device register offsets */
+#define SPID_CONFIG			0x00
+#define SPID_RESPONSE_DELAY		0x01
+#define SPID_STATUS_ENABLE		0x02
+#define SPID_RESET_BP			0x03	/* (corerev >= 1) */
+#define SPID_INTR_REG			0x04	/* 16 bits - Interrupt status */
+#define SPID_INTR_EN_REG		0x06	/* 16 bits - Interrupt mask */
+#define SPID_STATUS_REG			0x08	/* 32 bits */
+#define SPID_F1_INFO_REG		0x0C	/* 16 bits */
+#define SPID_F2_INFO_REG		0x0E	/* 16 bits */
+#define SPID_F3_INFO_REG		0x10	/* 16 bits */
+#define SPID_TEST_READ			0x14	/* 32 bits */
+#define SPID_TEST_RW			0x18	/* 32 bits */
+#define SPID_RESP_DELAY_F0		0x1c	/* 8 bits (corerev >= 3) */
+#define SPID_RESP_DELAY_F1		0x1d	/* 8 bits (corerev >= 3) */
+#define SPID_RESP_DELAY_F2		0x1e	/* 8 bits (corerev >= 3) */
+#define SPID_RESP_DELAY_F3		0x1f	/* 8 bits (corerev >= 3) */
+
+/* Bit masks for SPID_CONFIG device register */
+#define WORD_LENGTH_32	0x1	/* 0/1 16/32 bit word length */
+#define ENDIAN_BIG	0x2	/* 0/1 Little/Big Endian */
+#define CLOCK_PHASE	0x4	/* 0/1 clock phase delay */
+#define CLOCK_POLARITY	0x8	/* 0/1 Idle state clock polarity is low/high */
+#define HIGH_SPEED_MODE	0x10	/* 1/0 High Speed mode / Normal mode */
+#define INTR_POLARITY	0x20	/* 1/0 Interrupt active polarity is high/low */
+#define WAKE_UP		0x80	/* 0/1 Wake-up command from Host to WLAN */
+
+/* Bit mask for SPID_RESPONSE_DELAY device register */
+#define RESPONSE_DELAY_MASK	0xFF	/* Configurable rd response delay in multiples of 8 bits */
+
+/* Bit mask for SPID_STATUS_ENABLE device register */
+#define STATUS_ENABLE		0x1	/* 1/0 Status sent/not sent to host after read/write */
+#define INTR_WITH_STATUS	0x2	/* 0/1 Do-not / do-interrupt if status is sent */
+#define RESP_DELAY_ALL		0x4	/* Applicability of resp delay to F1 or all func's read */
+#define DWORD_PKT_LEN_EN	0x8	/* Packet len denoted in dwords instead of bytes */
+#define CMD_ERR_CHK_EN		0x20	/* Command error check enable */
+#define DATA_ERR_CHK_EN		0x40	/* Data error check enable */
+
+/* Bit mask for SPID_RESET_BP device register */
+#define RESET_ON_WLAN_BP_RESET	0x4	/* enable reset for WLAN backplane */
+#define RESET_ON_BT_BP_RESET	0x8	/* enable reset for BT backplane */
+#define RESET_SPI		0x80	/* reset the above enabled logic */
+
+/* Bit mask for SPID_INTR_REG device register */
+#define DATA_UNAVAILABLE	0x0001	/* Requested data not available; Clear by writing a "1" */
+#define F2_F3_FIFO_RD_UNDERFLOW	0x0002
+#define F2_F3_FIFO_WR_OVERFLOW	0x0004
+#define COMMAND_ERROR		0x0008	/* Cleared by writing 1 */
+#define DATA_ERROR		0x0010	/* Cleared by writing 1 */
+#define F2_PACKET_AVAILABLE	0x0020
+#define F3_PACKET_AVAILABLE	0x0040
+#define F1_OVERFLOW		0x0080	/* Due to last write. Bkplane has pending write requests */
+#define MISC_INTR0		0x0100
+#define MISC_INTR1		0x0200
+#define MISC_INTR2		0x0400
+#define MISC_INTR3		0x0800
+#define MISC_INTR4		0x1000
+#define F1_INTR			0x2000
+#define F2_INTR			0x4000
+#define F3_INTR			0x8000
+
+/* Bit mask for 32bit SPID_STATUS_REG device register */
+#define STATUS_DATA_NOT_AVAILABLE	0x00000001
+#define STATUS_UNDERFLOW		0x00000002
+#define STATUS_OVERFLOW			0x00000004
+#define STATUS_F2_INTR			0x00000008
+#define STATUS_F3_INTR			0x00000010
+#define STATUS_F2_RX_READY		0x00000020
+#define STATUS_F3_RX_READY		0x00000040
+#define STATUS_HOST_CMD_DATA_ERR	0x00000080
+#define STATUS_F2_PKT_AVAILABLE		0x00000100
+#define STATUS_F2_PKT_LEN_MASK		0x000FFE00
+#define STATUS_F2_PKT_LEN_SHIFT		9
+#define STATUS_F3_PKT_AVAILABLE		0x00100000
+#define STATUS_F3_PKT_LEN_MASK		0xFFE00000
+#define STATUS_F3_PKT_LEN_SHIFT		21
+
+/* Bit mask for 16 bits SPID_F1_INFO_REG device register */
+#define F1_ENABLED 			0x0001
+#define F1_RDY_FOR_DATA_TRANSFER	0x0002
+#define F1_MAX_PKT_SIZE			0x01FC
+
+/* Bit mask for 16 bits SPID_F2_INFO_REG device register */
+#define F2_ENABLED 			0x0001
+#define F2_RDY_FOR_DATA_TRANSFER	0x0002
+#define F2_MAX_PKT_SIZE			0x3FFC
+
+/* Bit mask for 16 bits SPID_F3_INFO_REG device register */
+#define F3_ENABLED 			0x0001
+#define F3_RDY_FOR_DATA_TRANSFER	0x0002
+#define F3_MAX_PKT_SIZE			0x3FFC
+
+/* Bit mask for 32 bits SPID_TEST_READ device register read in 16bit LE mode */
+#define TEST_RO_DATA_32BIT_LE		0xFEEDBEAD
+
+/* Maximum number of I/O funcs */
+#define SPI_MAX_IOFUNCS		4
+
+#define SPI_MAX_PKT_LEN		(2048*4)
+
+/* Misc defines */
+#define SPI_FUNC_0		0
+#define SPI_FUNC_1		1
+#define SPI_FUNC_2		2
+#define SPI_FUNC_3		3
+
+#define WAIT_F2RXFIFORDY	100
+#define WAIT_F2RXFIFORDY_DELAY	20
+
+#endif				/* _SPI_H */
diff --git a/drivers/staging/brcm80211/include/typedefs.h b/drivers/staging/brcm80211/include/typedefs.h
new file mode 100644
index 0000000..f7d1a5e
--- /dev/null
+++ b/drivers/staging/brcm80211/include/typedefs.h
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _TYPEDEFS_H_
+#define _TYPEDEFS_H_
+
+/*
+ * Infer the compile environment based on preprocessor symbols and pragmas.
+ * Override type definitions as needed, and include configuration-dependent
+ * header files to define types.
+ */
+
+#if defined(__x86_64__)
+#define TYPEDEF_UINTPTR
+typedef unsigned long long int uintptr;
+#endif
+
+#if defined(_NEED_SIZE_T_)
+typedef long unsigned int size_t;
+#endif
+
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#define TYPEDEF_ULONG
+#include <linux/version.h>
+#define TYPEDEF_BOOL
+
+/* Do not support the (u)int64 types with strict ansi for GNU C */
+#if defined(__GNUC__) && defined(__STRICT_ANSI__)
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+#endif
+
+#include <linux/types.h>
+
+/*
+ * Default Typedefs
+ */
+#ifndef TYPEDEF_BOOL
+typedef /* @abstract@ */ unsigned char bool;
+#endif
+
+/* define uchar, ushort, uint, ulong */
+
+#ifndef TYPEDEF_UCHAR
+typedef unsigned char uchar;
+#endif
+
+#ifndef TYPEDEF_USHORT
+typedef unsigned short ushort;
+#endif
+
+#ifndef TYPEDEF_UINT
+typedef unsigned int uint;
+#endif
+
+#ifndef TYPEDEF_ULONG
+typedef unsigned long ulong;
+#endif
+
+/* define [u]int8/16/32/64, uintptr */
+
+#ifndef TYPEDEF_UINT8
+typedef unsigned char uint8;
+#endif
+
+#ifndef TYPEDEF_UINT16
+typedef unsigned short uint16;
+#endif
+
+#ifndef TYPEDEF_UINT32
+typedef unsigned int uint32;
+#endif
+
+#ifndef TYPEDEF_UINT64
+typedef unsigned long long uint64;
+#endif
+
+#ifndef TYPEDEF_UINTPTR
+typedef unsigned int uintptr;
+#endif
+
+#ifndef TYPEDEF_INT8
+typedef signed char int8;
+#endif
+
+#ifndef TYPEDEF_INT16
+typedef signed short int16;
+#endif
+
+#ifndef TYPEDEF_INT32
+typedef signed int int32;
+#endif
+
+#ifndef TYPEDEF_INT64
+typedef signed long long int64;
+#endif
+
+/* define float32/64, float_t */
+
+#ifndef TYPEDEF_FLOAT32
+typedef float float32;
+#endif
+
+#ifndef TYPEDEF_FLOAT64
+typedef double float64;
+#endif
+
+/*
+ * abstracted floating point type allows for compile time selection of
+ * single or double precision arithmetic.  Compiling with -DFLOAT32
+ * selects single precision; the default is double precision.
+ */
+
+#ifndef TYPEDEF_FLOAT_T
+
+#if defined(FLOAT32)
+typedef float32 float_t;
+#else				/* default to double precision floating point */
+typedef float64 float_t;
+#endif
+
+#endif				/* TYPEDEF_FLOAT_T */
+
+/* define macro values */
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#ifndef TRUE
+#define TRUE	1		/* TRUE */
+#endif
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#ifndef ON
+#define	ON	1		/* ON = 1 */
+#endif
+
+#define	AUTO	(-1)		/* Auto = -1 */
+
+/* define PTRSZ, INLINE */
+
+#ifndef PTRSZ
+#define	PTRSZ	sizeof(char*)
+#endif
+
+/* Detect compiler type. */
+#if defined(__GNUC__)
+#define BWL_COMPILER_GNU
+#elif defined(__CC_ARM) && __CC_ARM
+#define BWL_COMPILER_ARMCC
+#else
+#error "Unknown compiler!"
+#endif
+
+#ifndef INLINE
+#if defined(BWL_COMPILER_GNU)
+#define INLINE __inline__
+#elif defined(BWL_COMPILER_ARMCC)
+#define INLINE	__inline
+#else
+#define INLINE
+#endif
+#endif				/* INLINE */
+
+#undef TYPEDEF_BOOL
+#undef TYPEDEF_UCHAR
+#undef TYPEDEF_USHORT
+#undef TYPEDEF_UINT
+#undef TYPEDEF_ULONG
+#undef TYPEDEF_UINT8
+#undef TYPEDEF_UINT16
+#undef TYPEDEF_UINT32
+#undef TYPEDEF_UINT64
+#undef TYPEDEF_UINTPTR
+#undef TYPEDEF_INT8
+#undef TYPEDEF_INT16
+#undef TYPEDEF_INT32
+#undef TYPEDEF_INT64
+#undef TYPEDEF_FLOAT32
+#undef TYPEDEF_FLOAT64
+#undef TYPEDEF_FLOAT_T
+
+/* Suppress unused parameter warning */
+#define UNUSED_PARAMETER(x) (void)(x)
+
+/*
+ * Including the bcmdefs.h here, to make sure everyone including typedefs.h
+ * gets this automatically
+*/
+#include <bcmdefs.h>
+
+#endif				/* _TYPEDEFS_H_ */
diff --git a/drivers/staging/brcm80211/include/wlioctl.h b/drivers/staging/brcm80211/include/wlioctl.h
new file mode 100644
index 0000000..970573b
--- /dev/null
+++ b/drivers/staging/brcm80211/include/wlioctl.h
@@ -0,0 +1,2007 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlioctl_h_
+#define	_wlioctl_h_
+
+#include <typedefs.h>
+#include <proto/ethernet.h>
+#include <proto/bcmevent.h>
+#include <proto/802.11.h>
+#include <bcmwifi.h>
+
+#ifndef INTF_NAME_SIZ
+#define INTF_NAME_SIZ	16
+#endif
+
+/* require default structure packing */
+#define BWL_DEFAULT_PACKING
+#include <packed_section_start.h>
+
+/* Legacy structure to help keep backward compatible wl tool and tray app */
+
+#define	LEGACY_WL_BSS_INFO_VERSION	107	/* older version of wl_bss_info struct */
+
+typedef struct wl_bss_info_107 {
+	uint32 version;		/* version field */
+	uint32 length;		/* byte length of data in this record,
+				 * starting at version and including IEs
+				 */
+	struct ether_addr BSSID;
+	uint16 beacon_period;	/* units are Kusec */
+	uint16 capability;	/* Capability information */
+	uint8 SSID_len;
+	uint8 SSID[32];
+	struct {
+		uint count;	/* # rates in this set */
+		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+	} rateset;		/* supported rates */
+	uint8 channel;		/* Channel no. */
+	uint16 atim_window;	/* units are Kusec */
+	uint8 dtim_period;	/* DTIM period */
+	int16 RSSI;		/* receive signal strength (in dBm) */
+	int8 phy_noise;		/* noise (in dBm) */
+	uint32 ie_length;	/* byte length of Information Elements */
+	/* variable length Information Elements */
+} wl_bss_info_107_t;
+
+/*
+ * Per-BSS information structure.
+ */
+
+#define	LEGACY2_WL_BSS_INFO_VERSION	108	/* old version of wl_bss_info struct */
+
+/* BSS info structure
+ * Applications MUST CHECK ie_offset field and length field to access IEs and
+ * next bss_info structure in a vector (in wl_scan_results_t)
+ */
+typedef struct wl_bss_info_108 {
+	uint32 version;		/* version field */
+	uint32 length;		/* byte length of data in this record,
+				 * starting at version and including IEs
+				 */
+	struct ether_addr BSSID;
+	uint16 beacon_period;	/* units are Kusec */
+	uint16 capability;	/* Capability information */
+	uint8 SSID_len;
+	uint8 SSID[32];
+	struct {
+		uint count;	/* # rates in this set */
+		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+	} rateset;		/* supported rates */
+	chanspec_t chanspec;	/* chanspec for bss */
+	uint16 atim_window;	/* units are Kusec */
+	uint8 dtim_period;	/* DTIM period */
+	int16 RSSI;		/* receive signal strength (in dBm) */
+	int8 phy_noise;		/* noise (in dBm) */
+
+	uint8 n_cap;		/* BSS is 802.11N Capable */
+	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
+	uint8 ctl_ch;		/* 802.11N BSS control channel number */
+	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
+	uint8 flags;		/* flags */
+	uint8 reserved[3];	/* Reserved for expansion of BSS properties */
+	uint8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+
+	uint16 ie_offset;	/* offset at which IEs start, from beginning */
+	uint32 ie_length;	/* byte length of Information Elements */
+	/* Add new fields here */
+	/* variable length Information Elements */
+} wl_bss_info_108_t;
+
+#define	WL_BSS_INFO_VERSION	109	/* current version of wl_bss_info struct */
+
+/* BSS info structure
+ * Applications MUST CHECK ie_offset field and length field to access IEs and
+ * next bss_info structure in a vector (in wl_scan_results_t)
+ */
+typedef struct wl_bss_info {
+	uint32 version;		/* version field */
+	uint32 length;		/* byte length of data in this record,
+				 * starting at version and including IEs
+				 */
+	struct ether_addr BSSID;
+	uint16 beacon_period;	/* units are Kusec */
+	uint16 capability;	/* Capability information */
+	uint8 SSID_len;
+	uint8 SSID[32];
+	struct {
+		uint count;	/* # rates in this set */
+		uint8 rates[16];	/* rates in 500kbps units w/hi bit set if basic */
+	} rateset;		/* supported rates */
+	chanspec_t chanspec;	/* chanspec for bss */
+	uint16 atim_window;	/* units are Kusec */
+	uint8 dtim_period;	/* DTIM period */
+	int16 RSSI;		/* receive signal strength (in dBm) */
+	int8 phy_noise;		/* noise (in dBm) */
+
+	uint8 n_cap;		/* BSS is 802.11N Capable */
+	uint32 nbss_cap;	/* 802.11N BSS Capabilities (based on HT_CAP_*) */
+	uint8 ctl_ch;		/* 802.11N BSS control channel number */
+	uint32 reserved32[1];	/* Reserved for expansion of BSS properties */
+	uint8 flags;		/* flags */
+	uint8 reserved[3];	/* Reserved for expansion of BSS properties */
+	uint8 basic_mcs[MCSSET_LEN];	/* 802.11N BSS required MCS set */
+
+	uint16 ie_offset;	/* offset at which IEs start, from beginning */
+	uint32 ie_length;	/* byte length of Information Elements */
+	int16 SNR;		/* average SNR of during frame reception */
+	/* Add new fields here */
+	/* variable length Information Elements */
+} wl_bss_info_t;
+
+typedef struct wlc_ssid {
+	uint32 SSID_len;
+	uchar SSID[32];
+} wlc_ssid_t;
+
+typedef struct chan_scandata {
+	uint8 txpower;
+	uint8 pad;
+	chanspec_t channel;	/* Channel num, bw, ctrl_sb and band */
+	uint32 channel_mintime;
+	uint32 channel_maxtime;
+} chan_scandata_t;
+
+typedef enum wl_scan_type {
+	EXTDSCAN_FOREGROUND_SCAN,
+	EXTDSCAN_BACKGROUND_SCAN,
+	EXTDSCAN_FORCEDBACKGROUND_SCAN
+} wl_scan_type_t;
+
+#define WLC_EXTDSCAN_MAX_SSID		5
+
+#define WL_BSS_FLAGS_FROM_BEACON	0x01	/* bss_info derived from beacon */
+#define WL_BSS_FLAGS_FROM_CACHE		0x02	/* bss_info collected from cache */
+#define WL_BSS_FLAGS_RSSI_ONCHANNEL     0x04	/* rssi info was received on channel (vs offchannel) */
+
+typedef struct wl_extdscan_params {
+	int8 nprobes;		/* 0, passive, otherwise active */
+	int8 split_scan;	/* split scan */
+	int8 band;		/* band */
+	int8 pad;
+	wlc_ssid_t ssid[WLC_EXTDSCAN_MAX_SSID];	/* ssid list */
+	uint32 tx_rate;		/* in 500ksec units */
+	wl_scan_type_t scan_type;	/* enum */
+	int32 channel_num;
+	chan_scandata_t channel_list[1];	/* list of chandata structs */
+} wl_extdscan_params_t;
+
+#define WL_EXTDSCAN_PARAMS_FIXED_SIZE 	(sizeof(wl_extdscan_params_t) - sizeof(chan_scandata_t))
+
+#define WL_BSSTYPE_INFRA 1
+#define WL_BSSTYPE_INDEP 0
+#define WL_BSSTYPE_ANY   2
+
+/* Bitmask for scan_type */
+#define WL_SCANFLAGS_PASSIVE 0x01	/* force passive scan */
+#define WL_SCANFLAGS_RESERVED 0x02	/* Reserved */
+#define WL_SCANFLAGS_PROHIBITED 0x04	/* allow scanning prohibited channels */
+
+typedef struct wl_scan_params {
+	wlc_ssid_t ssid;	/* default: {0, ""} */
+	struct ether_addr bssid;	/* default: bcast */
+	int8 bss_type;		/* default: any,
+				 * DOT11_BSSTYPE_ANY/INFRASTRUCTURE/INDEPENDENT
+				 */
+	uint8 scan_type;	/* flags, 0 use default */
+	int32 nprobes;		/* -1 use default, number of probes per channel */
+	int32 active_time;	/* -1 use default, dwell time per channel for
+				 * active scanning
+				 */
+	int32 passive_time;	/* -1 use default, dwell time per channel
+				 * for passive scanning
+				 */
+	int32 home_time;	/* -1 use default, dwell time for the home channel
+				 * between channel scans
+				 */
+	int32 channel_num;	/* count of channels and ssids that follow
+				 *
+				 * low half is count of channels in channel_list, 0
+				 * means default (use all available channels)
+				 *
+				 * high half is entries in wlc_ssid_t array that
+				 * follows channel_list, aligned for int32 (4 bytes)
+				 * meaning an odd channel count implies a 2-byte pad
+				 * between end of channel_list and first ssid
+				 *
+				 * if ssid count is zero, single ssid in the fixed
+				 * parameter portion is assumed, otherwise ssid in
+				 * the fixed portion is ignored
+				 */
+	uint16 channel_list[1];	/* list of chanspecs */
+} wl_scan_params_t;
+
+/* size of wl_scan_params not including variable length array */
+#define WL_SCAN_PARAMS_FIXED_SIZE 64
+
+/* masks for channel and ssid count */
+#define WL_SCAN_PARAMS_COUNT_MASK 0x0000ffff
+#define WL_SCAN_PARAMS_NSSID_SHIFT 16
+
+#define WL_SCAN_ACTION_START      1
+#define WL_SCAN_ACTION_CONTINUE   2
+#define WL_SCAN_ACTION_ABORT      3
+
+#define ISCAN_REQ_VERSION 1
+
+/* incremental scan struct */
+typedef struct wl_iscan_params {
+	uint32 version;
+	uint16 action;
+	uint16 scan_duration;
+	wl_scan_params_t params;
+} wl_iscan_params_t;
+
+/* 3 fields + size of wl_scan_params, not including variable length array */
+#define WL_ISCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_iscan_params_t, params) + sizeof(wlc_ssid_t))
+
+typedef struct wl_scan_results {
+	uint32 buflen;
+	uint32 version;
+	uint32 count;
+	wl_bss_info_t bss_info[1];
+} wl_scan_results_t;
+
+/* size of wl_scan_results not including variable length array */
+#define WL_SCAN_RESULTS_FIXED_SIZE (sizeof(wl_scan_results_t) - sizeof(wl_bss_info_t))
+
+/* wl_iscan_results status values */
+#define WL_SCAN_RESULTS_SUCCESS	0
+#define WL_SCAN_RESULTS_PARTIAL	1
+#define WL_SCAN_RESULTS_PENDING	2
+#define WL_SCAN_RESULTS_ABORTED	3
+
+#define ESCAN_REQ_VERSION 1
+
+typedef struct wl_escan_params {
+	uint32 version;
+	uint16 action;
+	uint16 sync_id;
+	wl_scan_params_t params;
+} wl_escan_params_t;
+
+#define WL_ESCAN_PARAMS_FIXED_SIZE (OFFSETOF(wl_escan_params_t, params) + sizeof(wlc_ssid_t))
+
+typedef struct wl_escan_result {
+	uint32 buflen;
+	uint32 version;
+	uint16 sync_id;
+	uint16 bss_count;
+	wl_bss_info_t bss_info[1];
+} wl_escan_result_t;
+
+#define WL_ESCAN_RESULTS_FIXED_SIZE (sizeof(wl_escan_result_t) - sizeof(wl_bss_info_t))
+
+/* incremental scan results struct */
+typedef struct wl_iscan_results {
+	uint32 status;
+	wl_scan_results_t results;
+} wl_iscan_results_t;
+
+/* size of wl_iscan_results not including variable length array */
+#define WL_ISCAN_RESULTS_FIXED_SIZE \
+	(WL_SCAN_RESULTS_FIXED_SIZE + OFFSETOF(wl_iscan_results_t, results))
+
+typedef struct wl_probe_params {
+	wlc_ssid_t ssid;
+	struct ether_addr bssid;
+	struct ether_addr mac;
+} wl_probe_params_t;
+
+#define WL_NUMRATES		16	/* max # of rates in a rateset */
+typedef struct wl_rateset {
+	uint32 count;		/* # rates in this set */
+	uint8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+} wl_rateset_t;
+
+typedef struct wl_rateset_args {
+	uint32 count;		/* # rates in this set */
+	uint8 rates[WL_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	uint8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
+} wl_rateset_args_t;
+
+/* uint32 list */
+typedef struct wl_uint32_list {
+	/* in - # of elements, out - # of entries */
+	uint32 count;
+	/* variable length uint32 list */
+	uint32 element[1];
+} wl_uint32_list_t;
+
+/* used for association with a specific BSSID and chanspec list */
+typedef struct wl_assoc_params {
+	struct ether_addr bssid;	/* 00:00:00:00:00:00: broadcast scan */
+	int32 chanspec_num;	/* 0: all available channels,
+				 * otherwise count of chanspecs in chanspec_list
+				 */
+	chanspec_t chanspec_list[1];	/* list of chanspecs */
+} wl_assoc_params_t;
+#define WL_ASSOC_PARAMS_FIXED_SIZE 	(sizeof(wl_assoc_params_t) - sizeof(chanspec_t))
+
+/* used for reassociation/roam to a specific BSSID and channel */
+typedef wl_assoc_params_t wl_reassoc_params_t;
+#define WL_REASSOC_PARAMS_FIXED_SIZE	WL_ASSOC_PARAMS_FIXED_SIZE
+
+/* used for join with or without a specific bssid and channel list */
+typedef struct wl_join_params {
+	wlc_ssid_t ssid;
+	wl_assoc_params_t params;	/* optional field, but it must include the fixed portion
+					 * of the wl_assoc_params_t struct when it does present.
+					 */
+} wl_join_params_t;
+#define WL_JOIN_PARAMS_FIXED_SIZE 	(sizeof(wl_join_params_t) - sizeof(chanspec_t))
+
+/* defines used by the nrate iovar */
+#define NRATE_MCS_INUSE	0x00000080	/* MSC in use,indicates b0-6 holds an mcs */
+#define NRATE_RATE_MASK 0x0000007f	/* rate/mcs value */
+#define NRATE_STF_MASK	0x0000ff00	/* stf mode mask: siso, cdd, stbc, sdm */
+#define NRATE_STF_SHIFT	8	/* stf mode shift */
+#define NRATE_OVERRIDE	0x80000000	/* bit indicates override both rate & mode */
+#define NRATE_OVERRIDE_MCS_ONLY 0x40000000	/* bit indicate to override mcs only */
+#define NRATE_SGI_MASK  0x00800000	/* sgi mode */
+#define NRATE_SGI_SHIFT 23	/* sgi mode */
+#define NRATE_LDPC_CODING 0x00400000	/* bit indicates adv coding in use */
+#define NRATE_LDPC_SHIFT 22	/* ldpc shift */
+
+#define NRATE_STF_SISO	0	/* stf mode SISO */
+#define NRATE_STF_CDD	1	/* stf mode CDD */
+#define NRATE_STF_STBC	2	/* stf mode STBC */
+#define NRATE_STF_SDM	3	/* stf mode SDM */
+
+#define ANTENNA_NUM_1	1	/* total number of antennas to be used */
+#define ANTENNA_NUM_2	2
+#define ANTENNA_NUM_3	3
+#define ANTENNA_NUM_4	4
+
+#define ANT_SELCFG_AUTO		0x80	/* bit indicates antenna sel AUTO */
+#define ANT_SELCFG_MASK		0x33	/* antenna configuration mask */
+#define ANT_SELCFG_MAX		4	/* max number of antenna configurations */
+#define ANT_SELCFG_TX_UNICAST	0	/* unicast tx antenna configuration */
+#define ANT_SELCFG_RX_UNICAST	1	/* unicast rx antenna configuration */
+#define ANT_SELCFG_TX_DEF	2	/* default tx antenna configuration */
+#define ANT_SELCFG_RX_DEF	3	/* default rx antenna configuration */
+
+#define MAX_STREAMS_SUPPORTED	4	/* max number of streams supported */
+
+typedef struct {
+	uint8 ant_config[ANT_SELCFG_MAX];	/* antenna configuration */
+	uint8 num_antcfg;	/* number of available antenna configurations */
+} wlc_antselcfg_t;
+
+#define HIGHEST_SINGLE_STREAM_MCS	7	/* MCS values greater than this enable multiple streams */
+
+#define MAX_CCA_CHANNELS 38	/* Max number of 20 Mhz wide channels */
+#define MAX_CCA_SECS     60	/* CCA keeps this many seconds history */
+
+#define IBSS_MED        15	/* Mediom in-bss congestion percentage */
+#define IBSS_HI         25	/* Hi in-bss congestion percentage */
+#define OBSS_MED        12
+#define OBSS_HI         25
+#define INTERFER_MED    5
+#define INTERFER_HI     10
+
+#define  CCA_FLAG_2G_ONLY		0x01	/* Return a channel from 2.4 Ghz band */
+#define  CCA_FLAG_5G_ONLY		0x02	/* Return a channel from 2.4 Ghz band */
+#define  CCA_FLAG_IGNORE_DURATION	0x04	/* Ignore dwell time for each channel */
+#define  CCA_FLAGS_PREFER_1_6_11	0x10
+#define  CCA_FLAG_IGNORE_INTERFER 	0x20	/* do not exlude channel based on interfer level */
+
+#define CCA_ERRNO_BAND 		1	/* After filtering for band pref, no choices left */
+#define CCA_ERRNO_DURATION	2	/* After filtering for duration, no choices left */
+#define CCA_ERRNO_PREF_CHAN	3	/* After filtering for chan pref, no choices left */
+#define CCA_ERRNO_INTERFER	4	/* After filtering for interference, no choices left */
+#define CCA_ERRNO_TOO_FEW	5	/* Only 1 channel was input */
+
+typedef struct {
+	uint32 duration;	/* millisecs spent sampling this channel */
+	uint32 congest_ibss;	/* millisecs in our bss (presumably this traffic will */
+	/*  move if cur bss moves channels) */
+	uint32 congest_obss;	/* traffic not in our bss */
+	uint32 interference;	/* millisecs detecting a non 802.11 interferer. */
+	uint32 timestamp;	/* second timestamp */
+} cca_congest_t;
+
+typedef struct {
+	chanspec_t chanspec;	/* Which channel? */
+	uint8 num_secs;		/* How many secs worth of data */
+	cca_congest_t secs[1];	/* Data */
+} cca_congest_channel_req_t;
+
+#define WLC_CNTRY_BUF_SZ	4	/* Country string is 3 bytes + NUL */
+
+typedef struct wl_country {
+	char country_abbrev[WLC_CNTRY_BUF_SZ];	/* nul-terminated country code used in
+						 * the Country IE
+						 */
+	int32 rev;		/* revision specifier for ccode
+				 * on set, -1 indicates unspecified.
+				 * on get, rev >= 0
+				 */
+	char ccode[WLC_CNTRY_BUF_SZ];	/* nul-terminated built-in country code.
+					 * variable length, but fixed size in
+					 * struct allows simple allocation for
+					 * expected country strings <= 3 chars.
+					 */
+} wl_country_t;
+
+typedef struct wl_channels_in_country {
+	uint32 buflen;
+	uint32 band;
+	char country_abbrev[WLC_CNTRY_BUF_SZ];
+	uint32 count;
+	uint32 channel[1];
+} wl_channels_in_country_t;
+
+typedef struct wl_country_list {
+	uint32 buflen;
+	uint32 band_set;
+	uint32 band;
+	uint32 count;
+	char country_abbrev[1];
+} wl_country_list_t;
+
+#define WL_NUM_RPI_BINS		8
+#define WL_RM_TYPE_BASIC	1
+#define WL_RM_TYPE_CCA		2
+#define WL_RM_TYPE_RPI		3
+
+#define WL_RM_FLAG_PARALLEL	(1<<0)
+
+#define WL_RM_FLAG_LATE		(1<<1)
+#define WL_RM_FLAG_INCAPABLE	(1<<2)
+#define WL_RM_FLAG_REFUSED	(1<<3)
+
+typedef struct wl_rm_req_elt {
+	int8 type;
+	int8 flags;
+	chanspec_t chanspec;
+	uint32 token;		/* token for this measurement */
+	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
+	uint32 tsf_l;		/* TSF low 32-bits */
+	uint32 dur;		/* TUs */
+} wl_rm_req_elt_t;
+
+typedef struct wl_rm_req {
+	uint32 token;		/* overall measurement set token */
+	uint32 count;		/* number of measurement requests */
+	void *cb;		/* completion callback function: may be NULL */
+	void *cb_arg;		/* arg to completion callback function */
+	wl_rm_req_elt_t req[1];	/* variable length block of requests */
+} wl_rm_req_t;
+#define WL_RM_REQ_FIXED_LEN	OFFSETOF(wl_rm_req_t, req)
+
+typedef struct wl_rm_rep_elt {
+	int8 type;
+	int8 flags;
+	chanspec_t chanspec;
+	uint32 token;		/* token for this measurement */
+	uint32 tsf_h;		/* TSF high 32-bits of Measurement start time */
+	uint32 tsf_l;		/* TSF low 32-bits */
+	uint32 dur;		/* TUs */
+	uint32 len;		/* byte length of data block */
+	uint8 data[1];		/* variable length data block */
+} wl_rm_rep_elt_t;
+#define WL_RM_REP_ELT_FIXED_LEN	24	/* length excluding data block */
+
+#define WL_RPI_REP_BIN_NUM 8
+typedef struct wl_rm_rpi_rep {
+	uint8 rpi[WL_RPI_REP_BIN_NUM];
+	int8 rpi_max[WL_RPI_REP_BIN_NUM];
+} wl_rm_rpi_rep_t;
+
+typedef struct wl_rm_rep {
+	uint32 token;		/* overall measurement set token */
+	uint32 len;		/* length of measurement report block */
+	wl_rm_rep_elt_t rep[1];	/* variable length block of reports */
+} wl_rm_rep_t;
+#define WL_RM_REP_FIXED_LEN	8
+
+/* Enumerate crypto algorithms */
+#define	CRYPTO_ALGO_OFF			0
+#define	CRYPTO_ALGO_WEP1		1
+#define	CRYPTO_ALGO_TKIP		2
+#define	CRYPTO_ALGO_WEP128		3
+#define CRYPTO_ALGO_AES_CCM		4
+#define CRYPTO_ALGO_AES_RESERVED1	5
+#define CRYPTO_ALGO_AES_RESERVED2	6
+#define CRYPTO_ALGO_NALG		7
+
+#define WSEC_GEN_MIC_ERROR	0x0001
+#define WSEC_GEN_REPLAY		0x0002
+#define WSEC_GEN_ICV_ERROR	0x0004
+
+#define WL_SOFT_KEY	(1 << 0)	/* Indicates this key is using soft encrypt */
+#define WL_PRIMARY_KEY	(1 << 1)	/* Indicates this key is the primary (ie tx) key */
+#define WL_KF_RES_4	(1 << 4)	/* Reserved for backward compat */
+#define WL_KF_RES_5	(1 << 5)	/* Reserved for backward compat */
+#define WL_IBSS_PEER_GROUP_KEY	(1 << 6)	/* Indicates a group key for a IBSS PEER */
+
+typedef struct wl_wsec_key {
+	uint32 index;		/* key index */
+	uint32 len;		/* key length */
+	uint8 data[DOT11_MAX_KEY_SIZE];	/* key data */
+	uint32 pad_1[18];
+	uint32 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	uint32 flags;		/* misc flags */
+	uint32 pad_2[2];
+	int pad_3;
+	int iv_initialized;	/* has IV been initialized already? */
+	int pad_4;
+	/* Rx IV */
+	struct {
+		uint32 hi;	/* upper 32 bits of IV */
+		uint16 lo;	/* lower 16 bits of IV */
+	} rxiv;
+	uint32 pad_5[2];
+	struct ether_addr ea;	/* per station */
+} wl_wsec_key_t;
+
+#define WSEC_MIN_PSK_LEN	8
+#define WSEC_MAX_PSK_LEN	64
+
+/* Flag for key material needing passhash'ing */
+#define WSEC_PASSPHRASE		(1<<0)
+
+/* receptacle for WLC_SET_WSEC_PMK parameter */
+typedef struct {
+	ushort key_len;		/* octets in key material */
+	ushort flags;		/* key handling qualification */
+	uint8 key[WSEC_MAX_PSK_LEN];	/* PMK material */
+} wsec_pmk_t;
+
+/* wireless security bitvec */
+#define WEP_ENABLED		0x0001
+#define TKIP_ENABLED		0x0002
+#define AES_ENABLED		0x0004
+#define WSEC_SWFLAG		0x0008
+#define SES_OW_ENABLED		0x0040	/* to go into transition mode without setting wep */
+
+/* WPA authentication mode bitvec */
+#define WPA_AUTH_DISABLED	0x0000	/* Legacy (i.e., non-WPA) */
+#define WPA_AUTH_NONE		0x0001	/* none (IBSS) */
+#define WPA_AUTH_UNSPECIFIED	0x0002	/* over 802.1x */
+#define WPA_AUTH_PSK		0x0004	/* Pre-shared key */
+#define WPA_AUTH_RESERVED1	0x0008
+#define WPA_AUTH_RESERVED2	0x0010
+					/* #define WPA_AUTH_8021X 0x0020 *//* 802.1x, reserved */
+#define WPA2_AUTH_RESERVED1	0x0020
+#define WPA2_AUTH_UNSPECIFIED	0x0040	/* over 802.1x */
+#define WPA2_AUTH_PSK		0x0080	/* Pre-shared key */
+#define WPA2_AUTH_RESERVED3	0x0200
+#define WPA2_AUTH_RESERVED4	0x0400
+#define WPA2_AUTH_RESERVED5	0x0800
+
+/* pmkid */
+#define	MAXPMKID		16
+
+typedef struct _pmkid {
+	struct ether_addr BSSID;
+	uint8 PMKID[WPA2_PMKID_LEN];
+} pmkid_t;
+
+typedef struct _pmkid_list {
+	uint32 npmkid;
+	pmkid_t pmkid[1];
+} pmkid_list_t;
+
+typedef struct _pmkid_cand {
+	struct ether_addr BSSID;
+	uint8 preauth;
+} pmkid_cand_t;
+
+typedef struct _pmkid_cand_list {
+	uint32 npmkid_cand;
+	pmkid_cand_t pmkid_cand[1];
+} pmkid_cand_list_t;
+
+typedef struct wl_led_info {
+	uint32 index;		/* led index */
+	uint32 behavior;
+	uint8 activehi;
+} wl_led_info_t;
+
+typedef struct wl_assoc_info {
+	uint32 req_len;
+	uint32 resp_len;
+	uint32 flags;
+	struct dot11_assoc_req req;
+	struct ether_addr reassoc_bssid;	/* used in reassoc's */
+	struct dot11_assoc_resp resp;
+} wl_assoc_info_t;
+
+/* flags */
+#define WLC_ASSOC_REQ_IS_REASSOC 0x01	/* assoc req was actually a reassoc */
+
+/* srom read/write struct passed through ioctl */
+typedef struct {
+	uint byteoff;		/* byte offset */
+	uint nbytes;		/* number of bytes */
+	uint16 buf[1];
+} srom_rw_t;
+
+/* similar cis (srom or otp) struct [iovar: may not be aligned] */
+typedef struct {
+	uint32 source;		/* cis source */
+	uint32 byteoff;		/* byte offset */
+	uint32 nbytes;		/* number of bytes */
+	/* data follows here */
+} cis_rw_t;
+
+#define WLC_CIS_DEFAULT	0	/* built-in default */
+#define WLC_CIS_SROM	1	/* source is sprom */
+#define WLC_CIS_OTP	2	/* source is otp */
+
+/* R_REG and W_REG struct passed through ioctl */
+typedef struct {
+	uint32 byteoff;		/* byte offset of the field in d11regs_t */
+	uint32 val;		/* read/write value of the field */
+	uint32 size;		/* sizeof the field */
+	uint band;		/* band (optional) */
+} rw_reg_t;
+
+/* Structure used by GET/SET_ATTEN ioctls - it controls power in b/g-band */
+/* PCL - Power Control Loop */
+/* current gain setting is replaced by user input */
+#define WL_ATTEN_APP_INPUT_PCL_OFF	0	/* turn off PCL, apply supplied input */
+#define WL_ATTEN_PCL_ON			1	/* turn on PCL */
+/* current gain setting is maintained */
+#define WL_ATTEN_PCL_OFF		2	/* turn off PCL. */
+
+typedef struct {
+	uint16 auto_ctrl;	/* WL_ATTEN_XX */
+	uint16 bb;		/* Baseband attenuation */
+	uint16 radio;		/* Radio attenuation */
+	uint16 txctl1;		/* Radio TX_CTL1 value */
+} atten_t;
+
+/* Per-AC retry parameters */
+struct wme_tx_params_s {
+	uint8 short_retry;
+	uint8 short_fallback;
+	uint8 long_retry;
+	uint8 long_fallback;
+	uint16 max_rate;	/* In units of 512 Kbps */
+};
+
+typedef struct wme_tx_params_s wme_tx_params_t;
+
+#define WL_WME_TX_PARAMS_IO_BYTES (sizeof(wme_tx_params_t) * AC_COUNT)
+
+/* defines used by poweridx iovar - it controls power in a-band */
+/* current gain setting is maintained */
+#define WL_PWRIDX_PCL_OFF	-2	/* turn off PCL.  */
+#define WL_PWRIDX_PCL_ON	-1	/* turn on PCL */
+#define WL_PWRIDX_LOWER_LIMIT	-2	/* lower limit */
+#define WL_PWRIDX_UPPER_LIMIT	63	/* upper limit */
+/* value >= 0 causes
+ *	- input to be set to that value
+ *	- PCL to be off
+ */
+
+/* Used to get specific link/ac parameters */
+typedef struct {
+	int ac;
+	uint8 val;
+	struct ether_addr ea;
+} link_val_t;
+
+#define BCM_MAC_STATUS_INDICATION	(0x40010200L)
+
+typedef struct {
+	uint16 ver;		/* version of this struct */
+	uint16 len;		/* length in bytes of this structure */
+	uint16 cap;		/* sta's advertised capabilities */
+	uint32 flags;		/* flags defined below */
+	uint32 idle;		/* time since data pkt rx'd from sta */
+	struct ether_addr ea;	/* Station address */
+	wl_rateset_t rateset;	/* rateset in use */
+	uint32 in;		/* seconds elapsed since associated */
+	uint32 listen_interval_inms;	/* Min Listen interval in ms for this STA */
+	uint32 tx_pkts;		/* # of packets transmitted */
+	uint32 tx_failures;	/* # of packets failed */
+	uint32 rx_ucast_pkts;	/* # of unicast packets received */
+	uint32 rx_mcast_pkts;	/* # of multicast packets received */
+	uint32 tx_rate;		/* Rate of last successful tx frame */
+	uint32 rx_rate;		/* Rate of last successful rx frame */
+	uint32 rx_decrypt_succeeds;	/* # of packet decrypted successfully */
+	uint32 rx_decrypt_failures;	/* # of packet decrypted unsuccessfully */
+} sta_info_t;
+
+#define WL_OLD_STAINFO_SIZE	OFFSETOF(sta_info_t, tx_pkts)
+
+#define WL_STA_VER		3
+
+/* Flags for sta_info_t indicating properties of STA */
+#define WL_STA_BRCM		0x1	/* Running a Broadcom driver */
+#define WL_STA_WME		0x2	/* WMM association */
+#define WL_STA_ABCAP		0x4
+#define WL_STA_AUTHE		0x8	/* Authenticated */
+#define WL_STA_ASSOC		0x10	/* Associated */
+#define WL_STA_AUTHO		0x20	/* Authorized */
+#define WL_STA_WDS		0x40	/* Wireless Distribution System */
+#define WL_STA_WDS_LINKUP	0x80	/* WDS traffic/probes flowing properly */
+#define WL_STA_PS		0x100	/* STA is in power save mode from AP's viewpoint */
+#define WL_STA_APSD_BE		0x200	/* APSD delv/trigger for AC_BE is default enabled */
+#define WL_STA_APSD_BK		0x400	/* APSD delv/trigger for AC_BK is default enabled */
+#define WL_STA_APSD_VI		0x800	/* APSD delv/trigger for AC_VI is default enabled */
+#define WL_STA_APSD_VO		0x1000	/* APSD delv/trigger for AC_VO is default enabled */
+#define WL_STA_N_CAP		0x2000	/* STA 802.11n capable */
+#define WL_STA_SCBSTATS		0x4000	/* Per STA debug stats */
+
+#define WL_WDS_LINKUP		WL_STA_WDS_LINKUP	/* deprecated */
+
+/* Used to get specific STA parameters */
+typedef struct {
+	uint32 val;
+	struct ether_addr ea;
+} scb_val_t;
+
+/* channel encoding */
+typedef struct channel_info {
+	int hw_channel;
+	int target_channel;
+	int scan_channel;
+} channel_info_t;
+
+/* For ioctls that take a list of MAC addresses */
+struct maclist {
+	uint count;		/* number of MAC addresses */
+	struct ether_addr ea[1];	/* variable length array of MAC addresses */
+};
+
+/* get pkt count struct passed through ioctl */
+typedef struct get_pktcnt {
+	uint rx_good_pkt;
+	uint rx_bad_pkt;
+	uint tx_good_pkt;
+	uint tx_bad_pkt;
+	uint rx_ocast_good_pkt;	/* unicast packets destined for others */
+} get_pktcnt_t;
+
+/* Linux network driver ioctl encoding */
+typedef struct wl_ioctl {
+	uint cmd;		/* common ioctl definition */
+	void *buf;		/* pointer to user buffer */
+	uint len;		/* length of user buffer */
+	uint8 set;		/* get or set request (optional) */
+	uint used;		/* bytes read or written (optional) */
+	uint needed;		/* bytes needed (optional) */
+} wl_ioctl_t;
+
+/* reference to wl_ioctl_t struct used by usermode driver */
+#define ioctl_subtype	set	/* subtype param */
+#define ioctl_pid	used	/* pid param */
+#define ioctl_status	needed	/* status param */
+
+/*
+ * Structure for passing hardware and software
+ * revision info up from the driver.
+ */
+typedef struct wlc_rev_info {
+	uint vendorid;		/* PCI vendor id */
+	uint deviceid;		/* device id of chip */
+	uint radiorev;		/* radio revision */
+	uint chiprev;		/* chip revision */
+	uint corerev;		/* core revision */
+	uint boardid;		/* board identifier (usu. PCI sub-device id) */
+	uint boardvendor;	/* board vendor (usu. PCI sub-vendor id) */
+	uint boardrev;		/* board revision */
+	uint driverrev;		/* driver version */
+	uint ucoderev;		/* microcode version */
+	uint bus;		/* bus type */
+	uint chipnum;		/* chip number */
+	uint phytype;		/* phy type */
+	uint phyrev;		/* phy revision */
+	uint anarev;		/* anacore rev */
+	uint chippkg;		/* chip package info */
+} wlc_rev_info_t;
+
+#define WL_REV_INFO_LEGACY_LENGTH	48
+
+#define WL_BRAND_MAX 10
+typedef struct wl_instance_info {
+	uint instance;
+	char brand[WL_BRAND_MAX];
+} wl_instance_info_t;
+
+/* structure to change size of tx fifo */
+typedef struct wl_txfifo_sz {
+	uint16 magic;
+	uint16 fifo;
+	uint16 size;
+} wl_txfifo_sz_t;
+/* magic pattern used for mismatch driver and wl */
+#define WL_TXFIFO_SZ_MAGIC	0xa5a5
+
+/* Transfer info about an IOVar from the driver */
+/* Max supported IOV name size in bytes, + 1 for nul termination */
+#define WLC_IOV_NAME_LEN 30
+typedef struct wlc_iov_trx_s {
+	uint8 module;
+	uint8 type;
+	char name[WLC_IOV_NAME_LEN];
+} wlc_iov_trx_t;
+
+/* check this magic number */
+#define WLC_IOCTL_MAGIC		0x14e46c77
+
+#define PROC_ENTRY_NAME "brcm_debug"
+/* bump this number if you change the ioctl interface */
+#define WLC_IOCTL_VERSION	1
+
+#define	WLC_IOCTL_MAXLEN		3072	/* max length ioctl buffer required */
+#define	WLC_IOCTL_SMLEN			256	/* "small" length ioctl buffer required */
+#define WLC_IOCTL_MEDLEN		1536	/* "med" length ioctl buffer required */
+#define WLC_SAMPLECOLLECT_MAXLEN	10240	/* Max Sample Collect buffer for two cores */
+
+/* common ioctl definitions */
+#define WLC_GET_MAGIC				0
+#define WLC_GET_VERSION				1
+#define WLC_UP					2
+#define WLC_DOWN				3
+#define WLC_GET_LOOP				4
+#define WLC_SET_LOOP				5
+#define WLC_DUMP				6
+#define WLC_GET_MSGLEVEL			7
+#define WLC_SET_MSGLEVEL			8
+#define WLC_GET_PROMISC				9
+#define WLC_SET_PROMISC				10
+#define WLC_OVERLAY_IOCTL			11
+#define WLC_GET_RATE				12
+						      /* #define WLC_SET_RATE				13 *//* no longer supported */
+#define WLC_GET_INSTANCE			14
+						      /* #define WLC_GET_FRAG				15 *//* no longer supported */
+						      /* #define WLC_SET_FRAG				16 *//* no longer supported */
+						      /* #define WLC_GET_RTS				17 *//* no longer supported */
+						      /* #define WLC_SET_RTS				18 *//* no longer supported */
+#define WLC_GET_INFRA				19
+#define WLC_SET_INFRA				20
+#define WLC_GET_AUTH				21
+#define WLC_SET_AUTH				22
+#define WLC_GET_BSSID				23
+#define WLC_SET_BSSID				24
+#define WLC_GET_SSID				25
+#define WLC_SET_SSID				26
+#define WLC_RESTART				27
+						      /* #define WLC_DUMP_SCB				28 *//* no longer supported */
+#define WLC_GET_CHANNEL				29
+#define WLC_SET_CHANNEL				30
+#define WLC_GET_SRL				31
+#define WLC_SET_SRL				32
+#define WLC_GET_LRL				33
+#define WLC_SET_LRL				34
+#define WLC_GET_PLCPHDR				35
+#define WLC_SET_PLCPHDR				36
+#define WLC_GET_RADIO				37
+#define WLC_SET_RADIO				38
+#define WLC_GET_PHYTYPE				39
+#define WLC_DUMP_RATE				40
+#define WLC_SET_RATE_PARAMS			41
+#define WLC_GET_FIXRATE				42
+#define WLC_SET_FIXRATE				43
+						      /* #define WLC_GET_WEP				42 *//* no longer supported */
+						      /* #define WLC_SET_WEP				43 *//* no longer supported */
+#define WLC_GET_KEY				44
+#define WLC_SET_KEY				45
+#define WLC_GET_REGULATORY			46
+#define WLC_SET_REGULATORY			47
+#define WLC_GET_PASSIVE_SCAN			48
+#define WLC_SET_PASSIVE_SCAN			49
+#define WLC_SCAN				50
+#define WLC_SCAN_RESULTS			51
+#define WLC_DISASSOC				52
+#define WLC_REASSOC				53
+#define WLC_GET_ROAM_TRIGGER			54
+#define WLC_SET_ROAM_TRIGGER			55
+#define WLC_GET_ROAM_DELTA			56
+#define WLC_SET_ROAM_DELTA			57
+#define WLC_GET_ROAM_SCAN_PERIOD		58
+#define WLC_SET_ROAM_SCAN_PERIOD		59
+#define WLC_EVM					60	/* diag */
+#define WLC_GET_TXANT				61
+#define WLC_SET_TXANT				62
+#define WLC_GET_ANTDIV				63
+#define WLC_SET_ANTDIV				64
+						      /* #define WLC_GET_TXPWR			65 *//* no longer supported */
+						      /* #define WLC_SET_TXPWR			66 *//* no longer supported */
+#define WLC_GET_CLOSED				67
+#define WLC_SET_CLOSED				68
+#define WLC_GET_MACLIST				69
+#define WLC_SET_MACLIST				70
+#define WLC_GET_RATESET				71
+#define WLC_SET_RATESET				72
+						      /* #define WLC_GET_LOCALE			73 *//* no longer supported */
+#define WLC_LONGTRAIN				74
+#define WLC_GET_BCNPRD				75
+#define WLC_SET_BCNPRD				76
+#define WLC_GET_DTIMPRD				77
+#define WLC_SET_DTIMPRD				78
+#define WLC_GET_SROM				79
+#define WLC_SET_SROM				80
+#define WLC_GET_WEP_RESTRICT			81
+#define WLC_SET_WEP_RESTRICT			82
+#define WLC_GET_COUNTRY				83
+#define WLC_SET_COUNTRY				84
+#define WLC_GET_PM				85
+#define WLC_SET_PM				86
+#define WLC_GET_WAKE				87
+#define WLC_SET_WAKE				88
+						      /* #define WLC_GET_D11CNTS			89 *//* -> "counters" iovar */
+#define WLC_GET_FORCELINK			90	/* ndis only */
+#define WLC_SET_FORCELINK			91	/* ndis only */
+#define WLC_FREQ_ACCURACY			92	/* diag */
+#define WLC_CARRIER_SUPPRESS			93	/* diag */
+#define WLC_GET_PHYREG				94
+#define WLC_SET_PHYREG				95
+#define WLC_GET_RADIOREG			96
+#define WLC_SET_RADIOREG			97
+#define WLC_GET_REVINFO				98
+#define WLC_GET_UCANTDIV			99
+#define WLC_SET_UCANTDIV			100
+#define WLC_R_REG				101
+#define WLC_W_REG				102
+/* #define WLC_DIAG_LOOPBACK			103	old tray diag */
+						       /* #define WLC_RESET_D11CNTS			104 *//* -> "reset_d11cnts" iovar */
+#define WLC_GET_MACMODE				105
+#define WLC_SET_MACMODE				106
+#define WLC_GET_MONITOR				107
+#define WLC_SET_MONITOR				108
+#define WLC_GET_GMODE				109
+#define WLC_SET_GMODE				110
+#define WLC_GET_LEGACY_ERP			111
+#define WLC_SET_LEGACY_ERP			112
+#define WLC_GET_RX_ANT				113
+#define WLC_GET_CURR_RATESET			114	/* current rateset */
+#define WLC_GET_SCANSUPPRESS			115
+#define WLC_SET_SCANSUPPRESS			116
+#define WLC_GET_AP				117
+#define WLC_SET_AP				118
+#define WLC_GET_EAP_RESTRICT			119
+#define WLC_SET_EAP_RESTRICT			120
+#define WLC_SCB_AUTHORIZE			121
+#define WLC_SCB_DEAUTHORIZE			122
+#define WLC_GET_WDSLIST				123
+#define WLC_SET_WDSLIST				124
+#define WLC_GET_ATIM				125
+#define WLC_SET_ATIM				126
+#define WLC_GET_RSSI				127
+#define WLC_GET_PHYANTDIV			128
+#define WLC_SET_PHYANTDIV			129
+#define WLC_AP_RX_ONLY				130
+#define WLC_GET_TX_PATH_PWR			131
+#define WLC_SET_TX_PATH_PWR			132
+#define WLC_GET_WSEC				133
+#define WLC_SET_WSEC				134
+#define WLC_GET_PHY_NOISE			135
+#define WLC_GET_BSS_INFO			136
+#define WLC_GET_PKTCNTS				137
+#define WLC_GET_LAZYWDS				138
+#define WLC_SET_LAZYWDS				139
+#define WLC_GET_BANDLIST			140
+#define WLC_GET_BAND				141
+#define WLC_SET_BAND				142
+#define WLC_SCB_DEAUTHENTICATE			143
+#define WLC_GET_SHORTSLOT			144
+#define WLC_GET_SHORTSLOT_OVERRIDE		145
+#define WLC_SET_SHORTSLOT_OVERRIDE		146
+#define WLC_GET_SHORTSLOT_RESTRICT		147
+#define WLC_SET_SHORTSLOT_RESTRICT		148
+#define WLC_GET_GMODE_PROTECTION		149
+#define WLC_GET_GMODE_PROTECTION_OVERRIDE	150
+#define WLC_SET_GMODE_PROTECTION_OVERRIDE	151
+#define WLC_UPGRADE				152
+						       /* #define WLC_GET_MRATE			153 *//* no longer supported */
+						       /* #define WLC_SET_MRATE			154 *//* no longer supported */
+#define WLC_GET_IGNORE_BCNS			155
+#define WLC_SET_IGNORE_BCNS			156
+#define WLC_GET_SCB_TIMEOUT			157
+#define WLC_SET_SCB_TIMEOUT			158
+#define WLC_GET_ASSOCLIST			159
+#define WLC_GET_CLK				160
+#define WLC_SET_CLK				161
+#define WLC_GET_UP				162
+#define WLC_OUT					163
+#define WLC_GET_WPA_AUTH			164
+#define WLC_SET_WPA_AUTH			165
+#define WLC_GET_UCFLAGS				166
+#define WLC_SET_UCFLAGS				167
+#define WLC_GET_PWRIDX				168
+#define WLC_SET_PWRIDX				169
+#define WLC_GET_TSSI				170
+#define WLC_GET_SUP_RATESET_OVERRIDE		171
+#define WLC_SET_SUP_RATESET_OVERRIDE		172
+						       /* #define WLC_SET_FAST_TIMER			173 *//* no longer supported */
+						       /* #define WLC_GET_FAST_TIMER			174 *//* no longer supported */
+						       /* #define WLC_SET_SLOW_TIMER			175 *//* no longer supported */
+						       /* #define WLC_GET_SLOW_TIMER			176 *//* no longer supported */
+						       /* #define WLC_DUMP_PHYREGS			177 *//* no longer supported */
+#define WLC_GET_PROTECTION_CONTROL		178
+#define WLC_SET_PROTECTION_CONTROL		179
+#define WLC_GET_PHYLIST				180
+#define WLC_ENCRYPT_STRENGTH			181	/* ndis only */
+#define WLC_DECRYPT_STATUS			182	/* ndis only */
+#define WLC_GET_KEY_SEQ				183
+#define WLC_GET_SCAN_CHANNEL_TIME		184
+#define WLC_SET_SCAN_CHANNEL_TIME		185
+#define WLC_GET_SCAN_UNASSOC_TIME		186
+#define WLC_SET_SCAN_UNASSOC_TIME		187
+#define WLC_GET_SCAN_HOME_TIME			188
+#define WLC_SET_SCAN_HOME_TIME			189
+#define WLC_GET_SCAN_NPROBES			190
+#define WLC_SET_SCAN_NPROBES			191
+#define WLC_GET_PRB_RESP_TIMEOUT		192
+#define WLC_SET_PRB_RESP_TIMEOUT		193
+#define WLC_GET_ATTEN				194
+#define WLC_SET_ATTEN				195
+#define WLC_GET_SHMEM				196	/* diag */
+#define WLC_SET_SHMEM				197	/* diag */
+						       /* #define WLC_GET_GMODE_PROTECTION_CTS		198 *//* no longer supported */
+						       /* #define WLC_SET_GMODE_PROTECTION_CTS		199 *//* no longer supported */
+#define WLC_SET_WSEC_TEST			200
+#define WLC_SCB_DEAUTHENTICATE_FOR_REASON	201
+#define WLC_TKIP_COUNTERMEASURES		202
+#define WLC_GET_PIOMODE				203
+#define WLC_SET_PIOMODE				204
+#define WLC_SET_ASSOC_PREFER			205
+#define WLC_GET_ASSOC_PREFER			206
+#define WLC_SET_ROAM_PREFER			207
+#define WLC_GET_ROAM_PREFER			208
+#define WLC_SET_LED				209
+#define WLC_GET_LED				210
+#define WLC_RESERVED6				211
+#define WLC_RESERVED7				212
+#define WLC_GET_CHANNEL_QA			213
+#define WLC_START_CHANNEL_QA			214
+#define WLC_GET_CHANNEL_SEL			215
+#define WLC_START_CHANNEL_SEL			216
+#define WLC_GET_VALID_CHANNELS			217
+#define WLC_GET_FAKEFRAG			218
+#define WLC_SET_FAKEFRAG			219
+#define WLC_GET_PWROUT_PERCENTAGE		220
+#define WLC_SET_PWROUT_PERCENTAGE		221
+#define WLC_SET_BAD_FRAME_PREEMPT		222
+#define WLC_GET_BAD_FRAME_PREEMPT		223
+#define WLC_SET_LEAP_LIST			224
+#define WLC_GET_LEAP_LIST			225
+#define WLC_GET_CWMIN				226
+#define WLC_SET_CWMIN				227
+#define WLC_GET_CWMAX				228
+#define WLC_SET_CWMAX				229
+#define WLC_GET_WET				230
+#define WLC_SET_WET				231
+#define WLC_GET_PUB				232
+						       /* #define WLC_SET_GLACIAL_TIMER		233 *//* no longer supported */
+						       /* #define WLC_GET_GLACIAL_TIMER		234 *//* no longer supported */
+#define WLC_GET_KEY_PRIMARY			235
+#define WLC_SET_KEY_PRIMARY			236
+						       /* #define WLC_DUMP_RADIOREGS			237 *//* no longer supported */
+#define WLC_RESERVED4				238
+#define WLC_RESERVED5				239
+#define WLC_UNSET_CALLBACK			240
+#define WLC_SET_CALLBACK			241
+#define WLC_GET_RADAR				242
+#define WLC_SET_RADAR				243
+#define WLC_SET_SPECT_MANAGMENT			244
+#define WLC_GET_SPECT_MANAGMENT			245
+#define WLC_WDS_GET_REMOTE_HWADDR		246	/* handled in wl_linux.c/wl_vx.c */
+#define WLC_WDS_GET_WPA_SUP			247
+#define WLC_SET_CS_SCAN_TIMER			248
+#define WLC_GET_CS_SCAN_TIMER			249
+#define WLC_MEASURE_REQUEST			250
+#define WLC_INIT				251
+#define WLC_SEND_QUIET				252
+#define WLC_KEEPALIVE			253
+#define WLC_SEND_PWR_CONSTRAINT			254
+#define WLC_UPGRADE_STATUS			255
+#define WLC_CURRENT_PWR				256
+#define WLC_GET_SCAN_PASSIVE_TIME		257
+#define WLC_SET_SCAN_PASSIVE_TIME		258
+#define WLC_LEGACY_LINK_BEHAVIOR		259
+#define WLC_GET_CHANNELS_IN_COUNTRY		260
+#define WLC_GET_COUNTRY_LIST			261
+#define WLC_GET_VAR				262	/* get value of named variable */
+#define WLC_SET_VAR				263	/* set named variable to value */
+#define WLC_NVRAM_GET				264	/* deprecated */
+#define WLC_NVRAM_SET				265
+#define WLC_NVRAM_DUMP				266
+#define WLC_REBOOT				267
+#define WLC_SET_WSEC_PMK			268
+#define WLC_GET_AUTH_MODE			269
+#define WLC_SET_AUTH_MODE			270
+#define WLC_GET_WAKEENTRY			271
+#define WLC_SET_WAKEENTRY			272
+#define WLC_NDCONFIG_ITEM			273	/* currently handled in wl_oid.c */
+#define WLC_NVOTPW				274
+#define WLC_OTPW				275
+#define WLC_IOV_BLOCK_GET			276
+#define WLC_IOV_MODULES_GET			277
+#define WLC_SOFT_RESET				278
+#define WLC_GET_ALLOW_MODE			279
+#define WLC_SET_ALLOW_MODE			280
+#define WLC_GET_DESIRED_BSSID			281
+#define WLC_SET_DESIRED_BSSID			282
+#define	WLC_DISASSOC_MYAP			283
+#define WLC_GET_RESERVED10			284
+#define WLC_GET_RESERVED11			285
+#define WLC_GET_RESERVED12			286
+#define WLC_GET_RESERVED13			287
+#define WLC_GET_RESERVED14			288
+#define WLC_SET_RESERVED15			289
+#define WLC_SET_RESERVED16			290
+#define WLC_GET_RESERVED17			291
+#define WLC_GET_RESERVED18			292
+#define WLC_GET_RESERVED19			293
+#define WLC_SET_RESERVED1A			294
+#define WLC_GET_RESERVED1B			295
+#define WLC_GET_RESERVED1C			296
+#define WLC_GET_RESERVED1D			297
+#define WLC_SET_RESERVED1E			298
+#define WLC_GET_RESERVED1F			299
+#define WLC_GET_RESERVED20			300
+#define WLC_GET_RESERVED21			301
+#define WLC_GET_RESERVED22			302
+#define WLC_GET_RESERVED23			303
+#define WLC_GET_RESERVED24			304
+#define WLC_SET_RESERVED25			305
+#define WLC_GET_RESERVED26			306
+#define WLC_NPHY_SAMPLE_COLLECT			307	/* Nphy sample collect mode */
+#define WLC_UM_PRIV				308	/* for usermode driver private ioctl */
+#define WLC_GET_CMD				309
+							/* #define WLC_LAST				310 *//* Never used - can be reused */
+#define WLC_RESERVED8				311
+#define WLC_RESERVED9				312
+#define WLC_RESERVED1				313
+#define WLC_RESERVED2				314
+#define WLC_RESERVED3				315
+#define WLC_LAST				316
+
+#ifndef EPICTRL_COOKIE
+#define EPICTRL_COOKIE		0xABADCEDE
+#endif
+
+#define WL_DECRYPT_STATUS_SUCCESS	1
+#define WL_DECRYPT_STATUS_FAILURE	2
+#define WL_DECRYPT_STATUS_UNKNOWN	3
+
+/* allows user-mode app to poll the status of USB image upgrade */
+#define WLC_UPGRADE_SUCCESS			0
+#define WLC_UPGRADE_PENDING			1
+
+/* WLC_GET_AUTH, WLC_SET_AUTH values */
+#define WL_AUTH_OPEN_SYSTEM		0	/* d11 open authentication */
+#define WL_AUTH_SHARED_KEY		1	/* d11 shared authentication */
+#define WL_AUTH_OPEN_SHARED		2	/* try open, then shared if open failed w/rc 13 */
+
+/* Bit masks for radio disabled status - returned by WL_GET_RADIO */
+#define WL_RADIO_SW_DISABLE		(1<<0)
+#define WL_RADIO_HW_DISABLE		(1<<1)
+#define WL_RADIO_MPC_DISABLE		(1<<2)
+#define WL_RADIO_COUNTRY_DISABLE	(1<<3)	/* some countries don't support any channel */
+
+#define	WL_SPURAVOID_OFF	0
+#define	WL_SPURAVOID_ON1	1
+#define	WL_SPURAVOID_ON2	2
+
+/* Override bit for WLC_SET_TXPWR.  if set, ignore other level limits */
+#define WL_TXPWR_OVERRIDE	(1U<<31)
+
+#define WL_PHY_PAVARS_LEN	6	/* Phy type, Band range, chain, a1, b0, b1 */
+
+typedef struct wl_po {
+	uint16 phy_type;	/* Phy type */
+	uint16 band;
+	uint16 cckpo;
+	uint32 ofdmpo;
+	uint16 mcspo[8];
+} wl_po_t;
+
+/* a large TX Power as an init value to factor out of MIN() calculations,
+ * keep low enough to fit in an int8, units are .25 dBm
+ */
+#define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
+
+/* "diag" iovar argument and error code */
+#define WL_DIAG_INTERRUPT			1	/* d11 loopback interrupt test */
+#define WL_DIAG_LOOPBACK			2	/* d11 loopback data test */
+#define WL_DIAG_MEMORY				3	/* d11 memory test */
+#define WL_DIAG_LED				4	/* LED test */
+#define WL_DIAG_REG				5	/* d11/phy register test */
+#define WL_DIAG_SROM				6	/* srom read/crc test */
+#define WL_DIAG_DMA				7	/* DMA test */
+
+#define WL_DIAGERR_SUCCESS			0
+#define WL_DIAGERR_FAIL_TO_RUN			1	/* unable to run requested diag */
+#define WL_DIAGERR_NOT_SUPPORTED		2	/* diag requested is not supported */
+#define WL_DIAGERR_INTERRUPT_FAIL		3	/* loopback interrupt test failed */
+#define WL_DIAGERR_LOOPBACK_FAIL		4	/* loopback data test failed */
+#define WL_DIAGERR_SROM_FAIL			5	/* srom read failed */
+#define WL_DIAGERR_SROM_BADCRC			6	/* srom crc failed */
+#define WL_DIAGERR_REG_FAIL			7	/* d11/phy register test failed */
+#define WL_DIAGERR_MEMORY_FAIL			8	/* d11 memory test failed */
+#define WL_DIAGERR_NOMEM			9	/* diag test failed due to no memory */
+#define WL_DIAGERR_DMA_FAIL			10	/* DMA test failed */
+
+#define WL_DIAGERR_MEMORY_TIMEOUT		11	/* d11 memory test didn't finish in time */
+#define WL_DIAGERR_MEMORY_BADPATTERN		12	/* d11 memory test result in bad pattern */
+
+/* band types */
+#define	WLC_BAND_AUTO		0	/* auto-select */
+#define	WLC_BAND_5G		1	/* 5 Ghz */
+#define	WLC_BAND_2G		2	/* 2.4 Ghz */
+#define	WLC_BAND_ALL		3	/* all bands */
+
+/* band range returned by band_range iovar */
+#define WL_CHAN_FREQ_RANGE_2G      0
+#define WL_CHAN_FREQ_RANGE_5GL     1
+#define WL_CHAN_FREQ_RANGE_5GM     2
+#define WL_CHAN_FREQ_RANGE_5GH     3
+
+/* phy types (returned by WLC_GET_PHYTPE) */
+#define	WLC_PHY_TYPE_A		0
+#define	WLC_PHY_TYPE_B		1
+#define	WLC_PHY_TYPE_G		2
+#define	WLC_PHY_TYPE_N		4
+#define	WLC_PHY_TYPE_LP		5
+#define	WLC_PHY_TYPE_SSN	6
+#define	WLC_PHY_TYPE_HT		7
+#define	WLC_PHY_TYPE_LCN	8
+#define	WLC_PHY_TYPE_NULL	0xf
+
+/* MAC list modes */
+#define WLC_MACMODE_DISABLED	0	/* MAC list disabled */
+#define WLC_MACMODE_DENY	1	/* Deny specified (i.e. allow unspecified) */
+#define WLC_MACMODE_ALLOW	2	/* Allow specified (i.e. deny unspecified) */
+
+/*
+ * 54g modes (basic bits may still be overridden)
+ *
+ * GMODE_LEGACY_B			Rateset: 1b, 2b, 5.5, 11
+ *					Preamble: Long
+ *					Shortslot: Off
+ * GMODE_AUTO				Rateset: 1b, 2b, 5.5b, 11b, 18, 24, 36, 54
+ *					Extended Rateset: 6, 9, 12, 48
+ *					Preamble: Long
+ *					Shortslot: Auto
+ * GMODE_ONLY				Rateset: 1b, 2b, 5.5b, 11b, 18, 24b, 36, 54
+ *					Extended Rateset: 6b, 9, 12b, 48
+ *					Preamble: Short required
+ *					Shortslot: Auto
+ * GMODE_B_DEFERRED			Rateset: 1b, 2b, 5.5b, 11b, 18, 24, 36, 54
+ *					Extended Rateset: 6, 9, 12, 48
+ *					Preamble: Long
+ *					Shortslot: On
+ * GMODE_PERFORMANCE			Rateset: 1b, 2b, 5.5b, 6b, 9, 11b, 12b, 18, 24b, 36, 48, 54
+ *					Preamble: Short required
+ *					Shortslot: On and required
+ * GMODE_LRS				Rateset: 1b, 2b, 5.5b, 11b
+ *					Extended Rateset: 6, 9, 12, 18, 24, 36, 48, 54
+ *					Preamble: Long
+ *					Shortslot: Auto
+ */
+#define GMODE_LEGACY_B		0
+#define GMODE_AUTO		1
+#define GMODE_ONLY		2
+#define GMODE_B_DEFERRED	3
+#define GMODE_PERFORMANCE	4
+#define GMODE_LRS		5
+#define GMODE_MAX		6
+
+/* values for PLCPHdr_override */
+#define WLC_PLCP_AUTO	-1
+#define WLC_PLCP_SHORT	0
+#define WLC_PLCP_LONG	1
+
+/* values for g_protection_override and n_protection_override */
+#define WLC_PROTECTION_AUTO		-1
+#define WLC_PROTECTION_OFF		0
+#define WLC_PROTECTION_ON		1
+#define WLC_PROTECTION_MMHDR_ONLY	2
+#define WLC_PROTECTION_CTS_ONLY		3
+
+/* values for g_protection_control and n_protection_control */
+#define WLC_PROTECTION_CTL_OFF		0
+#define WLC_PROTECTION_CTL_LOCAL	1
+#define WLC_PROTECTION_CTL_OVERLAP	2
+
+/* values for n_protection */
+#define WLC_N_PROTECTION_OFF		0
+#define WLC_N_PROTECTION_OPTIONAL	1
+#define WLC_N_PROTECTION_20IN40		2
+#define WLC_N_PROTECTION_MIXEDMODE	3
+
+/* values for n_preamble_type */
+#define WLC_N_PREAMBLE_MIXEDMODE	0
+#define WLC_N_PREAMBLE_GF		1
+#define WLC_N_PREAMBLE_GF_BRCM          2
+
+/* values for band specific 40MHz capabilities */
+#define WLC_N_BW_20ALL			0
+#define WLC_N_BW_40ALL			1
+#define WLC_N_BW_20IN2G_40IN5G		2
+
+/* values to force tx/rx chain */
+#define WLC_N_TXRX_CHAIN0		0
+#define WLC_N_TXRX_CHAIN1		1
+
+/* bitflags for SGI support (sgi_rx iovar) */
+#define WLC_N_SGI_20			0x01
+#define WLC_N_SGI_40			0x02
+
+/* Values for PM */
+#define PM_OFF	0
+#define PM_MAX	1
+
+/* interference mitigation options */
+#define	INTERFERE_OVRRIDE_OFF	-1	/* interference override off */
+#define	INTERFERE_NONE	0	/* off */
+#define	NON_WLAN	1	/* foreign/non 802.11 interference, no auto detect */
+#define	WLAN_MANUAL	2	/* ACI: no auto detection */
+#define	WLAN_AUTO	3	/* ACI: auto detect */
+#define	WLAN_AUTO_W_NOISE	4	/* ACI: auto - detect and non 802.11 interference */
+#define	AUTO_ACTIVE	(1 << 7)	/* Auto is currently active */
+
+#define WL_RSSI_ANT_VERSION	1	/* current version of wl_rssi_ant_t */
+#define WL_ANT_RX_MAX		2	/* max 2 receive antennas */
+#define WL_ANT_HT_RX_MAX	3	/* max 3 receive antennas/cores */
+#define WL_ANT_IDX_1		0	/* antenna index 1 */
+#define WL_ANT_IDX_2		1	/* antenna index 2 */
+
+#ifndef WL_RSSI_ANT_MAX
+#define WL_RSSI_ANT_MAX		4	/* max possible rx antennas */
+#elif WL_RSSI_ANT_MAX != 4
+#error "WL_RSSI_ANT_MAX does not match"
+#endif
+
+/* RSSI per antenna */
+typedef struct {
+	uint32 version;		/* version field */
+	uint32 count;		/* number of valid antenna rssi */
+	int8 rssi_ant[WL_RSSI_ANT_MAX];	/* rssi per antenna */
+} wl_rssi_ant_t;
+
+#define NUM_PWRCTRL_RATES 12
+
+typedef struct {
+	uint8 txpwr_band_max[NUM_PWRCTRL_RATES];	/* User set target */
+	uint8 txpwr_limit[NUM_PWRCTRL_RATES];	/* reg and local power limit */
+	uint8 txpwr_local_max;	/* local max according to the AP */
+	uint8 txpwr_local_constraint;	/* local constraint according to the AP */
+	uint8 txpwr_chan_reg_max;	/* Regulatory max for this channel */
+	uint8 txpwr_target[2][NUM_PWRCTRL_RATES];	/* Latest target for 2.4 and 5 Ghz */
+	uint8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
+	uint8 txpwr_opo[NUM_PWRCTRL_RATES];	/* On G phy, OFDM power offset */
+	uint8 txpwr_bphy_cck_max[NUM_PWRCTRL_RATES];	/* Max CCK power for this band (SROM) */
+	uint8 txpwr_bphy_ofdm_max;	/* Max OFDM power for this band (SROM) */
+	uint8 txpwr_aphy_max[NUM_PWRCTRL_RATES];	/* Max power for A band (SROM) */
+	int8 txpwr_antgain[2];	/* Ant gain for each band - from SROM */
+	uint8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
+} tx_power_legacy_t;
+
+#define WL_TX_POWER_RATES_LEGACY	45
+#define WL_TX_POWER_MCS20_FIRST	        12
+#define WL_TX_POWER_MCS20_NUM	        16
+#define WL_TX_POWER_MCS40_FIRST	        28
+#define WL_TX_POWER_MCS40_NUM	        17
+
+typedef struct {
+	uint32 flags;
+	chanspec_t chanspec;	/* txpwr report for this channel */
+	chanspec_t local_chanspec;	/* channel on which we are associated */
+	uint8 local_max;	/* local max according to the AP */
+	uint8 local_constraint;	/* local constraint according to the AP */
+	int8 antgain[2];	/* Ant gain for each band - from SROM */
+	uint8 rf_cores;		/* count of RF Cores being reported */
+	uint8 est_Pout[4];	/* Latest tx power out estimate per RF
+				 * chain without adjustment
+				 */
+	uint8 est_Pout_cck;	/* Latest CCK tx power out estimate */
+	uint8 user_limit[WL_TX_POWER_RATES_LEGACY];	/* User limit */
+	uint8 reg_limit[WL_TX_POWER_RATES_LEGACY];	/* Regulatory power limit */
+	uint8 board_limit[WL_TX_POWER_RATES_LEGACY];	/* Max power board can support (SROM) */
+	uint8 target[WL_TX_POWER_RATES_LEGACY];	/* Latest target power */
+} tx_power_legacy2_t;
+
+#define WL_TX_POWER_RATES	       101
+#define WL_TX_POWER_CCK_FIRST	       0
+#define WL_TX_POWER_CCK_NUM	       4
+#define WL_TX_POWER_OFDM_FIRST	       4	/* Index for first 20MHz OFDM SISO rate */
+#define WL_TX_POWER_OFDM20_CDD_FIRST   12	/* Index for first 20MHz OFDM CDD rate */
+#define WL_TX_POWER_OFDM40_SISO_FIRST  52	/* Index for first 40MHz OFDM SISO rate */
+#define WL_TX_POWER_OFDM40_CDD_FIRST   60	/* Index for first 40MHz OFDM CDD rate */
+#define WL_TX_POWER_OFDM_NUM	       8
+#define WL_TX_POWER_MCS20_SISO_FIRST   20	/* Index for first 20MHz MCS SISO rate */
+#define WL_TX_POWER_MCS20_CDD_FIRST    28	/* Index for first 20MHz MCS CDD rate */
+#define WL_TX_POWER_MCS20_STBC_FIRST   36	/* Index for first 20MHz MCS STBC rate */
+#define WL_TX_POWER_MCS20_SDM_FIRST    44	/* Index for first 20MHz MCS SDM rate */
+#define WL_TX_POWER_MCS40_SISO_FIRST   68	/* Index for first 40MHz MCS SISO rate */
+#define WL_TX_POWER_MCS40_CDD_FIRST    76	/* Index for first 40MHz MCS CDD rate */
+#define WL_TX_POWER_MCS40_STBC_FIRST   84	/* Index for first 40MHz MCS STBC rate */
+#define WL_TX_POWER_MCS40_SDM_FIRST    92	/* Index for first 40MHz MCS SDM rate */
+#define WL_TX_POWER_MCS_1_STREAM_NUM   8
+#define WL_TX_POWER_MCS_2_STREAM_NUM   8
+#define WL_TX_POWER_MCS_32	       100	/* Index for 40MHz rate MCS 32 */
+#define WL_TX_POWER_MCS_32_NUM	       1
+
+/* sslpnphy specifics */
+#define WL_TX_POWER_MCS20_SISO_FIRST_SSN   12	/* Index for first 20MHz MCS SISO rate */
+
+/* tx_power_t.flags bits */
+#define WL_TX_POWER_F_ENABLED	1
+#define WL_TX_POWER_F_HW	2
+#define WL_TX_POWER_F_MIMO	4
+#define WL_TX_POWER_F_SISO	8
+
+typedef struct {
+	uint32 flags;
+	chanspec_t chanspec;	/* txpwr report for this channel */
+	chanspec_t local_chanspec;	/* channel on which we are associated */
+	uint8 local_max;	/* local max according to the AP */
+	uint8 local_constraint;	/* local constraint according to the AP */
+	int8 antgain[2];	/* Ant gain for each band - from SROM */
+	uint8 rf_cores;		/* count of RF Cores being reported */
+	uint8 est_Pout[4];	/* Latest tx power out estimate per RF chain */
+	uint8 est_Pout_act[4];	/* Latest tx power out estimate per RF chain
+				 * without adjustment
+				 */
+	uint8 est_Pout_cck;	/* Latest CCK tx power out estimate */
+	uint8 tx_power_max[4];	/* Maximum target power among all rates */
+	uint8 tx_power_max_rate_ind[4];	/* Index of the rate with the max target power */
+	uint8 user_limit[WL_TX_POWER_RATES];	/* User limit */
+	uint8 reg_limit[WL_TX_POWER_RATES];	/* Regulatory power limit */
+	uint8 board_limit[WL_TX_POWER_RATES];	/* Max power board can support (SROM) */
+	uint8 target[WL_TX_POWER_RATES];	/* Latest target power */
+} tx_power_t;
+
+typedef struct tx_inst_power {
+	uint8 txpwr_est_Pout[2];	/* Latest estimate for 2.4 and 5 Ghz */
+	uint8 txpwr_est_Pout_gofdm;	/* Pwr estimate for 2.4 OFDM */
+} tx_inst_power_t;
+
+/* Message levels */
+#define WL_ERROR_VAL		0x00000001
+#define WL_TRACE_VAL		0x00000002
+#define WL_AMPDU_VAL		0x20000000
+#define WL_FFPLD_VAL		0x40000000
+
+/* maximum channels returned by the get valid channels iovar */
+#define WL_NUMCHANNELS		64
+#define WL_NUMCHANSPECS		100
+
+struct tsinfo_arg {
+	uint8 octets[3];
+};
+
+#define	NFIFO			6	/* # tx/rx fifopairs */
+
+#define	WL_CNT_T_VERSION	7	/* current version of wl_cnt_t struct */
+
+typedef struct {
+	uint16 version;		/* see definition of WL_CNT_T_VERSION */
+	uint16 length;		/* length of entire structure */
+
+	/* transmit stat counters */
+	uint32 txframe;		/* tx data frames */
+	uint32 txbyte;		/* tx data bytes */
+	uint32 txretrans;	/* tx mac retransmits */
+	uint32 txerror;		/* tx data errors (derived: sum of others) */
+	uint32 txctl;		/* tx management frames */
+	uint32 txprshort;	/* tx short preamble frames */
+	uint32 txserr;		/* tx status errors */
+	uint32 txnobuf;		/* tx out of buffers errors */
+	uint32 txnoassoc;	/* tx discard because we're not associated */
+	uint32 txrunt;		/* tx runt frames */
+	uint32 txchit;		/* tx header cache hit (fastpath) */
+	uint32 txcmiss;		/* tx header cache miss (slowpath) */
+	uint32 ieee_tx_status;	/* calls to ieee80211_tx_status */
+	uint32 ieee_tx;		/* tx calls frm mac0211 */
+	uint32 ieee_rx;		/* calls to ieee_rx */
+
+	/* transmit chip error counters */
+	uint32 txuflo;		/* tx fifo underflows */
+	uint32 txphyerr;	/* tx phy errors (indicated in tx status) */
+	uint32 txphycrs;
+
+	/* receive stat counters */
+	uint32 rxframe;		/* rx data frames */
+	uint32 rxbyte;		/* rx data bytes */
+	uint32 rxerror;		/* rx data errors (derived: sum of others) */
+	uint32 rxctl;		/* rx management frames */
+	uint32 rxnobuf;		/* rx out of buffers errors */
+	uint32 rxnondata;	/* rx non data frames in the data channel errors */
+	uint32 rxbadds;		/* rx bad DS errors */
+	uint32 rxbadcm;		/* rx bad control or management frames */
+	uint32 rxfragerr;	/* rx fragmentation errors */
+	uint32 rxrunt;		/* rx runt frames */
+	uint32 rxgiant;		/* rx giant frames */
+	uint32 rxnoscb;		/* rx no scb error */
+	uint32 rxbadproto;	/* rx invalid frames */
+	uint32 rxbadsrcmac;	/* rx frames with Invalid Src Mac */
+	uint32 rxbadda;		/* rx frames tossed for invalid da */
+	uint32 rxfilter;	/* rx frames filtered out */
+
+	/* receive chip error counters */
+	uint32 rxoflo;		/* rx fifo overflow errors */
+	uint32 rxuflo[NFIFO];	/* rx dma descriptor underflow errors */
+
+	uint32 d11cnt_txrts_off;	/* d11cnt txrts value when reset d11cnt */
+	uint32 d11cnt_rxcrc_off;	/* d11cnt rxcrc value when reset d11cnt */
+	uint32 d11cnt_txnocts_off;	/* d11cnt txnocts value when reset d11cnt */
+
+	/* misc counters */
+	uint32 dmade;		/* tx/rx dma descriptor errors */
+	uint32 dmada;		/* tx/rx dma data errors */
+	uint32 dmape;		/* tx/rx dma descriptor protocol errors */
+	uint32 reset;		/* reset count */
+	uint32 tbtt;		/* cnts the TBTT int's */
+	uint32 txdmawar;
+	uint32 pkt_callback_reg_fail;	/* callbacks register failure */
+
+	/* MAC counters: 32-bit version of d11.h's macstat_t */
+	uint32 txallfrm;	/* total number of frames sent, incl. Data, ACK, RTS, CTS,
+				 * Control Management (includes retransmissions)
+				 */
+	uint32 txrtsfrm;	/* number of RTS sent out by the MAC */
+	uint32 txctsfrm;	/* number of CTS sent out by the MAC */
+	uint32 txackfrm;	/* number of ACK frames sent out */
+	uint32 txdnlfrm;	/* Not used */
+	uint32 txbcnfrm;	/* beacons transmitted */
+	uint32 txfunfl[8];	/* per-fifo tx underflows */
+	uint32 txtplunfl;	/* Template underflows (mac was too slow to transmit ACK/CTS
+				 * or BCN)
+				 */
+	uint32 txphyerror;	/* Transmit phy error, type of error is reported in tx-status for
+				 * driver enqueued frames
+				 */
+	uint32 rxfrmtoolong;	/* Received frame longer than legal limit (2346 bytes) */
+	uint32 rxfrmtooshrt;	/* Received frame did not contain enough bytes for its frame type */
+	uint32 rxinvmachdr;	/* Either the protocol version != 0 or frame type not
+				 * data/control/management
+				 */
+	uint32 rxbadfcs;	/* number of frames for which the CRC check failed in the MAC */
+	uint32 rxbadplcp;	/* parity check of the PLCP header failed */
+	uint32 rxcrsglitch;	/* PHY was able to correlate the preamble but not the header */
+	uint32 rxstrt;		/* Number of received frames with a good PLCP
+				 * (i.e. passing parity check)
+				 */
+	uint32 rxdfrmucastmbss;	/* Number of received DATA frames with good FCS and matching RA */
+	uint32 rxmfrmucastmbss;	/* number of received mgmt frames with good FCS and matching RA */
+	uint32 rxcfrmucast;	/* number of received CNTRL frames with good FCS and matching RA */
+	uint32 rxrtsucast;	/* number of unicast RTS addressed to the MAC (good FCS) */
+	uint32 rxctsucast;	/* number of unicast CTS addressed to the MAC (good FCS) */
+	uint32 rxackucast;	/* number of ucast ACKS received (good FCS) */
+	uint32 rxdfrmocast;	/* number of received DATA frames (good FCS and not matching RA) */
+	uint32 rxmfrmocast;	/* number of received MGMT frames (good FCS and not matching RA) */
+	uint32 rxcfrmocast;	/* number of received CNTRL frame (good FCS and not matching RA) */
+	uint32 rxrtsocast;	/* number of received RTS not addressed to the MAC */
+	uint32 rxctsocast;	/* number of received CTS not addressed to the MAC */
+	uint32 rxdfrmmcast;	/* number of RX Data multicast frames received by the MAC */
+	uint32 rxmfrmmcast;	/* number of RX Management multicast frames received by the MAC */
+	uint32 rxcfrmmcast;	/* number of RX Control multicast frames received by the MAC
+				 * (unlikely to see these)
+				 */
+	uint32 rxbeaconmbss;	/* beacons received from member of BSS */
+	uint32 rxdfrmucastobss;	/* number of unicast frames addressed to the MAC from
+				 * other BSS (WDS FRAME)
+				 */
+	uint32 rxbeaconobss;	/* beacons received from other BSS */
+	uint32 rxrsptmout;	/* Number of response timeouts for transmitted frames
+				 * expecting a response
+				 */
+	uint32 bcntxcancl;	/* transmit beacons canceled due to receipt of beacon (IBSS) */
+	uint32 rxf0ovfl;	/* Number of receive fifo 0 overflows */
+	uint32 rxf1ovfl;	/* Number of receive fifo 1 overflows (obsolete) */
+	uint32 rxf2ovfl;	/* Number of receive fifo 2 overflows (obsolete) */
+	uint32 txsfovfl;	/* Number of transmit status fifo overflows (obsolete) */
+	uint32 pmqovfl;		/* Number of PMQ overflows */
+	uint32 rxcgprqfrm;	/* Number of received Probe requests that made it into
+				 * the PRQ fifo
+				 */
+	uint32 rxcgprsqovfl;	/* Rx Probe Request Que overflow in the AP */
+	uint32 txcgprsfail;	/* Tx Probe Response Fail. AP sent probe response but did
+				 * not get ACK
+				 */
+	uint32 txcgprssuc;	/* Tx Probe Response Success (ACK was received) */
+	uint32 prs_timeout;	/* Number of probe requests that were dropped from the PRQ
+				 * fifo because a probe response could not be sent out within
+				 * the time limit defined in M_PRS_MAXTIME
+				 */
+	uint32 rxnack;
+	uint32 frmscons;
+	uint32 txnack;
+	uint32 txglitch_nack;	/* obsolete */
+	uint32 txburst;		/* obsolete */
+
+	/* 802.11 MIB counters, pp. 614 of 802.11 reaff doc. */
+	uint32 txfrag;		/* dot11TransmittedFragmentCount */
+	uint32 txmulti;		/* dot11MulticastTransmittedFrameCount */
+	uint32 txfail;		/* dot11FailedCount */
+	uint32 txretry;		/* dot11RetryCount */
+	uint32 txretrie;	/* dot11MultipleRetryCount */
+	uint32 rxdup;		/* dot11FrameduplicateCount */
+	uint32 txrts;		/* dot11RTSSuccessCount */
+	uint32 txnocts;		/* dot11RTSFailureCount */
+	uint32 txnoack;		/* dot11ACKFailureCount */
+	uint32 rxfrag;		/* dot11ReceivedFragmentCount */
+	uint32 rxmulti;		/* dot11MulticastReceivedFrameCount */
+	uint32 rxcrc;		/* dot11FCSErrorCount */
+	uint32 txfrmsnt;	/* dot11TransmittedFrameCount (bogus MIB?) */
+	uint32 rxundec;		/* dot11WEPUndecryptableCount */
+
+	/* WPA2 counters (see rxundec for DecryptFailureCount) */
+	uint32 tkipmicfaill;	/* TKIPLocalMICFailures */
+	uint32 tkipcntrmsr;	/* TKIPCounterMeasuresInvoked */
+	uint32 tkipreplay;	/* TKIPReplays */
+	uint32 ccmpfmterr;	/* CCMPFormatErrors */
+	uint32 ccmpreplay;	/* CCMPReplays */
+	uint32 ccmpundec;	/* CCMPDecryptErrors */
+	uint32 fourwayfail;	/* FourWayHandshakeFailures */
+	uint32 wepundec;	/* dot11WEPUndecryptableCount */
+	uint32 wepicverr;	/* dot11WEPICVErrorCount */
+	uint32 decsuccess;	/* DecryptSuccessCount */
+	uint32 tkipicverr;	/* TKIPICVErrorCount */
+	uint32 wepexcluded;	/* dot11WEPExcludedCount */
+
+	uint32 rxundec_mcst;	/* dot11WEPUndecryptableCount */
+
+	/* WPA2 counters (see rxundec for DecryptFailureCount) */
+	uint32 tkipmicfaill_mcst;	/* TKIPLocalMICFailures */
+	uint32 tkipcntrmsr_mcst;	/* TKIPCounterMeasuresInvoked */
+	uint32 tkipreplay_mcst;	/* TKIPReplays */
+	uint32 ccmpfmterr_mcst;	/* CCMPFormatErrors */
+	uint32 ccmpreplay_mcst;	/* CCMPReplays */
+	uint32 ccmpundec_mcst;	/* CCMPDecryptErrors */
+	uint32 fourwayfail_mcst;	/* FourWayHandshakeFailures */
+	uint32 wepundec_mcst;	/* dot11WEPUndecryptableCount */
+	uint32 wepicverr_mcst;	/* dot11WEPICVErrorCount */
+	uint32 decsuccess_mcst;	/* DecryptSuccessCount */
+	uint32 tkipicverr_mcst;	/* TKIPICVErrorCount */
+	uint32 wepexcluded_mcst;	/* dot11WEPExcludedCount */
+
+	uint32 txchanrej;	/* Tx frames suppressed due to channel rejection */
+	uint32 txexptime;	/* Tx frames suppressed due to timer expiration */
+	uint32 psmwds;		/* Count PSM watchdogs */
+	uint32 phywatchdog;	/* Count Phy watchdogs (triggered by ucode) */
+
+	/* MBSS counters, AP only */
+	uint32 prq_entries_handled;	/* PRQ entries read in */
+	uint32 prq_undirected_entries;	/*    which were bcast bss & ssid */
+	uint32 prq_bad_entries;	/*    which could not be translated to info */
+	uint32 atim_suppress_count;	/* TX suppressions on ATIM fifo */
+	uint32 bcn_template_not_ready;	/* Template marked in use on send bcn ... */
+	uint32 bcn_template_not_ready_done;	/* ...but "DMA done" interrupt rcvd */
+	uint32 late_tbtt_dpc;	/* TBTT DPC did not happen in time */
+
+	/* per-rate receive stat counters */
+	uint32 rx1mbps;		/* packets rx at 1Mbps */
+	uint32 rx2mbps;		/* packets rx at 2Mbps */
+	uint32 rx5mbps5;	/* packets rx at 5.5Mbps */
+	uint32 rx6mbps;		/* packets rx at 6Mbps */
+	uint32 rx9mbps;		/* packets rx at 9Mbps */
+	uint32 rx11mbps;	/* packets rx at 11Mbps */
+	uint32 rx12mbps;	/* packets rx at 12Mbps */
+	uint32 rx18mbps;	/* packets rx at 18Mbps */
+	uint32 rx24mbps;	/* packets rx at 24Mbps */
+	uint32 rx36mbps;	/* packets rx at 36Mbps */
+	uint32 rx48mbps;	/* packets rx at 48Mbps */
+	uint32 rx54mbps;	/* packets rx at 54Mbps */
+	uint32 rx108mbps;	/* packets rx at 108mbps */
+	uint32 rx162mbps;	/* packets rx at 162mbps */
+	uint32 rx216mbps;	/* packets rx at 216 mbps */
+	uint32 rx270mbps;	/* packets rx at 270 mbps */
+	uint32 rx324mbps;	/* packets rx at 324 mbps */
+	uint32 rx378mbps;	/* packets rx at 378 mbps */
+	uint32 rx432mbps;	/* packets rx at 432 mbps */
+	uint32 rx486mbps;	/* packets rx at 486 mbps */
+	uint32 rx540mbps;	/* packets rx at 540 mbps */
+
+	/* pkteng rx frame stats */
+	uint32 pktengrxducast;	/* unicast frames rxed by the pkteng code */
+	uint32 pktengrxdmcast;	/* multicast frames rxed by the pkteng code */
+
+	uint32 rfdisable;	/* count of radio disables */
+	uint32 bphy_rxcrsglitch;	/* PHY count of bphy glitches */
+
+	uint32 txmpdu_sgi;	/* count for sgi transmit */
+	uint32 rxmpdu_sgi;	/* count for sgi received */
+	uint32 txmpdu_stbc;	/* count for stbc transmit */
+	uint32 rxmpdu_stbc;	/* count for stbc received */
+} wl_cnt_t;
+
+#define	WL_DELTA_STATS_T_VERSION	1	/* current version of wl_delta_stats_t struct */
+
+typedef struct {
+	uint16 version;		/* see definition of WL_DELTA_STATS_T_VERSION */
+	uint16 length;		/* length of entire structure */
+
+	/* transmit stat counters */
+	uint32 txframe;		/* tx data frames */
+	uint32 txbyte;		/* tx data bytes */
+	uint32 txretrans;	/* tx mac retransmits */
+	uint32 txfail;		/* tx failures */
+
+	/* receive stat counters */
+	uint32 rxframe;		/* rx data frames */
+	uint32 rxbyte;		/* rx data bytes */
+
+	/* per-rate receive stat counters */
+	uint32 rx1mbps;		/* packets rx at 1Mbps */
+	uint32 rx2mbps;		/* packets rx at 2Mbps */
+	uint32 rx5mbps5;	/* packets rx at 5.5Mbps */
+	uint32 rx6mbps;		/* packets rx at 6Mbps */
+	uint32 rx9mbps;		/* packets rx at 9Mbps */
+	uint32 rx11mbps;	/* packets rx at 11Mbps */
+	uint32 rx12mbps;	/* packets rx at 12Mbps */
+	uint32 rx18mbps;	/* packets rx at 18Mbps */
+	uint32 rx24mbps;	/* packets rx at 24Mbps */
+	uint32 rx36mbps;	/* packets rx at 36Mbps */
+	uint32 rx48mbps;	/* packets rx at 48Mbps */
+	uint32 rx54mbps;	/* packets rx at 54Mbps */
+	uint32 rx108mbps;	/* packets rx at 108mbps */
+	uint32 rx162mbps;	/* packets rx at 162mbps */
+	uint32 rx216mbps;	/* packets rx at 216 mbps */
+	uint32 rx270mbps;	/* packets rx at 270 mbps */
+	uint32 rx324mbps;	/* packets rx at 324 mbps */
+	uint32 rx378mbps;	/* packets rx at 378 mbps */
+	uint32 rx432mbps;	/* packets rx at 432 mbps */
+	uint32 rx486mbps;	/* packets rx at 486 mbps */
+	uint32 rx540mbps;	/* packets rx at 540 mbps */
+} wl_delta_stats_t;
+
+#define WL_WME_CNT_VERSION	1	/* current version of wl_wme_cnt_t */
+
+typedef struct {
+	uint32 packets;
+	uint32 bytes;
+} wl_traffic_stats_t;
+
+typedef struct {
+	uint16 version;		/* see definition of WL_WME_CNT_VERSION */
+	uint16 length;		/* length of entire structure */
+
+	wl_traffic_stats_t tx[AC_COUNT];	/* Packets transmitted */
+	wl_traffic_stats_t tx_failed[AC_COUNT];	/* Packets dropped or failed to transmit */
+	wl_traffic_stats_t rx[AC_COUNT];	/* Packets received */
+	wl_traffic_stats_t rx_failed[AC_COUNT];	/* Packets failed to receive */
+
+	wl_traffic_stats_t forward[AC_COUNT];	/* Packets forwarded by AP */
+
+	wl_traffic_stats_t tx_expired[AC_COUNT];	/* packets dropped due to lifetime expiry */
+
+} wl_wme_cnt_t;
+
+struct wl_msglevel2 {
+	uint32 low;
+	uint32 high;
+};
+
+#ifdef WLBA
+
+#define	WLC_BA_CNT_VERSION	1	/* current version of wlc_ba_cnt_t */
+
+/* block ack related stats */
+typedef struct wlc_ba_cnt {
+	uint16 version;		/* WLC_BA_CNT_VERSION */
+	uint16 length;		/* length of entire structure */
+
+	/* transmit stat counters */
+	uint32 txpdu;		/* pdus sent */
+	uint32 txsdu;		/* sdus sent */
+	uint32 txfc;		/* tx side flow controlled packets */
+	uint32 txfci;		/* tx side flow control initiated */
+	uint32 txretrans;	/* retransmitted pdus */
+	uint32 txbatimer;	/* ba resend due to timer */
+	uint32 txdrop;		/* dropped packets */
+	uint32 txaddbareq;	/* addba req sent */
+	uint32 txaddbaresp;	/* addba resp sent */
+	uint32 txdelba;		/* delba sent */
+	uint32 txba;		/* ba sent */
+	uint32 txbar;		/* bar sent */
+	uint32 txpad[4];	/* future */
+
+	/* receive side counters */
+	uint32 rxpdu;		/* pdus recd */
+	uint32 rxqed;		/* pdus buffered before sending up */
+	uint32 rxdup;		/* duplicate pdus */
+	uint32 rxnobuf;		/* pdus discarded due to no buf */
+	uint32 rxaddbareq;	/* addba req recd */
+	uint32 rxaddbaresp;	/* addba resp recd */
+	uint32 rxdelba;		/* delba recd */
+	uint32 rxba;		/* ba recd */
+	uint32 rxbar;		/* bar recd */
+	uint32 rxinvba;		/* invalid ba recd */
+	uint32 rxbaholes;	/* ba recd with holes */
+	uint32 rxunexp;		/* unexpected packets */
+	uint32 rxpad[4];	/* future */
+} wlc_ba_cnt_t;
+#endif				/* WLBA */
+
+/* structure for per-tid ampdu control */
+struct ampdu_tid_control {
+	uint8 tid;		/* tid */
+	uint8 enable;		/* enable/disable */
+};
+
+/* structure for identifying ea/tid for sending addba/delba */
+struct ampdu_ea_tid {
+	struct ether_addr ea;	/* Station address */
+	uint8 tid;		/* tid */
+};
+/* structure for identifying retry/tid for retry_limit_tid/rr_retry_limit_tid */
+struct ampdu_retry_tid {
+	uint8 tid;		/* tid */
+	uint8 retry;		/* retry value */
+};
+
+/* structure for addts arguments */
+/* For ioctls that take a list of TSPEC */
+struct tslist {
+	int count;		/* number of tspecs */
+	struct tsinfo_arg tsinfo[1];	/* variable length array of tsinfo */
+};
+
+/* structure for addts/delts arguments */
+typedef struct tspec_arg {
+	uint16 version;		/* see definition of TSPEC_ARG_VERSION */
+	uint16 length;		/* length of entire structure */
+	uint flag;		/* bit field */
+	/* TSPEC Arguments */
+	struct tsinfo_arg tsinfo;	/* TS Info bit field */
+	uint16 nom_msdu_size;	/* (Nominal or fixed) MSDU Size (bytes) */
+	uint16 max_msdu_size;	/* Maximum MSDU Size (bytes) */
+	uint min_srv_interval;	/* Minimum Service Interval (us) */
+	uint max_srv_interval;	/* Maximum Service Interval (us) */
+	uint inactivity_interval;	/* Inactivity Interval (us) */
+	uint suspension_interval;	/* Suspension Interval (us) */
+	uint srv_start_time;	/* Service Start Time (us) */
+	uint min_data_rate;	/* Minimum Data Rate (bps) */
+	uint mean_data_rate;	/* Mean Data Rate (bps) */
+	uint peak_data_rate;	/* Peak Data Rate (bps) */
+	uint max_burst_size;	/* Maximum Burst Size (bytes) */
+	uint delay_bound;	/* Delay Bound (us) */
+	uint min_phy_rate;	/* Minimum PHY Rate (bps) */
+	uint16 surplus_bw;	/* Surplus Bandwidth Allowance (range 1.0 to 8.0) */
+	uint16 medium_time;	/* Medium Time (32 us/s periods) */
+	uint8 dialog_token;	/* dialog token */
+} tspec_arg_t;
+
+/* tspec arg for desired station */
+typedef struct tspec_per_sta_arg {
+	struct ether_addr ea;
+	struct tspec_arg ts;
+} tspec_per_sta_arg_t;
+
+/* structure for max bandwidth for each access category */
+typedef struct wme_max_bandwidth {
+	uint32 ac[AC_COUNT];	/* max bandwidth for each access category */
+} wme_max_bandwidth_t;
+
+#define WL_WME_MBW_PARAMS_IO_BYTES (sizeof(wme_max_bandwidth_t))
+
+/* current version of wl_tspec_arg_t struct */
+#define	TSPEC_ARG_VERSION		2	/* current version of wl_tspec_arg_t struct */
+#define TSPEC_ARG_LENGTH		55	/* argument length from tsinfo to medium_time */
+#define TSPEC_DEFAULT_DIALOG_TOKEN	42	/* default dialog token */
+#define TSPEC_DEFAULT_SBW_FACTOR	0x3000	/* default surplus bw */
+
+/* define for flag */
+#define TSPEC_PENDING		0	/* TSPEC pending */
+#define TSPEC_ACCEPTED		1	/* TSPEC accepted */
+#define TSPEC_REJECTED		2	/* TSPEC rejected */
+#define TSPEC_UNKNOWN		3	/* TSPEC unknown */
+#define TSPEC_STATUS_MASK	7	/* TSPEC status mask */
+
+/* Software feature flag defines used by wlfeatureflag */
+#define WL_SWFL_NOHWRADIO	0x0004
+#define WL_SWFL_FLOWCONTROL     0x0008	/* Enable backpressure to OS stack */
+#define WL_SWFL_WLBSSSORT	0x0010	/* Per-port supports sorting of BSS */
+
+#define WL_LIFETIME_MAX 0xFFFF	/* Max value in ms */
+
+/*
+ * Dongle pattern matching filter.
+ */
+
+/* Packet filter types. Currently, only pattern matching is supported. */
+typedef enum wl_pkt_filter_type {
+	WL_PKT_FILTER_TYPE_PATTERN_MATCH	/* Pattern matching filter */
+} wl_pkt_filter_type_t;
+
+#define WL_PKT_FILTER_TYPE wl_pkt_filter_type_t
+
+/* Pattern matching filter. Specifies an offset within received packets to
+ * start matching, the pattern to match, the size of the pattern, and a bitmask
+ * that indicates which bits within the pattern should be matched.
+ */
+typedef struct wl_pkt_filter_pattern {
+	uint32 offset;		/* Offset within received packet to start pattern matching.
+				 * Offset '0' is the first byte of the ethernet header.
+				 */
+	uint32 size_bytes;	/* Size of the pattern.  Bitmask must be the same size. */
+	uint8 mask_and_pattern[1];	/* Variable length mask and pattern data.  mask starts
+					 * at offset 0.  Pattern immediately follows mask.
+					 */
+} wl_pkt_filter_pattern_t;
+
+/* IOVAR "pkt_filter_add" parameter. Used to install packet filters. */
+typedef struct wl_pkt_filter {
+	uint32 id;		/* Unique filter id, specified by app. */
+	uint32 type;		/* Filter type (WL_PKT_FILTER_TYPE_xxx). */
+	uint32 negate_match;	/* Negate the result of filter matches */
+	union {			/* Filter definitions */
+		wl_pkt_filter_pattern_t pattern;	/* Pattern matching filter */
+	} u;
+} wl_pkt_filter_t;
+
+#define WL_PKT_FILTER_FIXED_LEN		  OFFSETOF(wl_pkt_filter_t, u)
+#define WL_PKT_FILTER_PATTERN_FIXED_LEN	  OFFSETOF(wl_pkt_filter_pattern_t, mask_and_pattern)
+
+/* IOVAR "pkt_filter_enable" parameter. */
+typedef struct wl_pkt_filter_enable {
+	uint32 id;		/* Unique filter id */
+	uint32 enable;		/* Enable/disable bool */
+} wl_pkt_filter_enable_t;
+
+/* IOVAR "pkt_filter_list" parameter. Used to retrieve a list of installed filters. */
+typedef struct wl_pkt_filter_list {
+	uint32 num;		/* Number of installed packet filters */
+	wl_pkt_filter_t filter[1];	/* Variable array of packet filters. */
+} wl_pkt_filter_list_t;
+
+#define WL_PKT_FILTER_LIST_FIXED_LEN	  OFFSETOF(wl_pkt_filter_list_t, filter)
+
+/* IOVAR "pkt_filter_stats" parameter. Used to retrieve debug statistics. */
+typedef struct wl_pkt_filter_stats {
+	uint32 num_pkts_matched;	/* # filter matches for specified filter id */
+	uint32 num_pkts_forwarded;	/* # packets fwded from dongle to host for all filters */
+	uint32 num_pkts_discarded;	/* # packets discarded by dongle for all filters */
+} wl_pkt_filter_stats_t;
+
+typedef struct wl_pkteng {
+	uint32 flags;
+	uint32 delay;		/* Inter-packet delay */
+	uint32 nframes;		/* Number of frames */
+	uint32 length;		/* Packet length */
+	uint8 seqno;		/* Enable/disable sequence no. */
+	struct ether_addr dest;	/* Destination address */
+	struct ether_addr src;	/* Source address */
+} wl_pkteng_t;
+
+#define	WLC_RSSI_INVALID	 0	/* invalid RSSI value */
+
+/* require default structure packing */
+#include <packed_section_end.h>
+
+/* n-mode support capability */
+/* 2x2 includes both 1x1 & 2x2 devices
+ * reserved #define 2 for future when we want to separate 1x1 & 2x2 and
+ * control it independently
+ */
+#define WL_11N_2x2			1
+#define WL_11N_3x3			3
+#define WL_11N_4x4			4
+
+/* define 11n feature disable flags */
+#define WLFEATURE_DISABLE_11N		0x00000001
+#define WLFEATURE_DISABLE_11N_STBC_TX	0x00000002
+#define WLFEATURE_DISABLE_11N_STBC_RX	0x00000004
+#define WLFEATURE_DISABLE_11N_SGI_TX	0x00000008
+#define WLFEATURE_DISABLE_11N_SGI_RX	0x00000010
+#define WLFEATURE_DISABLE_11N_AMPDU_TX	0x00000020
+#define WLFEATURE_DISABLE_11N_AMPDU_RX	0x00000040
+#define WLFEATURE_DISABLE_11N_GF	0x00000080
+
+#endif				/* _wlioctl_h_ */
diff --git a/drivers/staging/brcm80211/phy/phy_version.h b/drivers/staging/brcm80211/phy/phy_version.h
new file mode 100644
index 0000000..209a785
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/phy_version.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef phy_version_h_
+#define phy_version_h_
+
+#define	PHY_MAJOR_VERSION		1
+
+#define	PHY_MINOR_VERSION		82
+
+#define	PHY_RC_NUMBER		8
+
+#define	PHY_INCREMENTAL_NUMBER	0
+
+#define	PHY_BUILD_NUMBER		0
+
+#define	PHY_VERSION			1, 82, 8, 0
+
+#define	PHY_VERSION_NUM		0x01520800
+
+#define	PHY_VERSION_STR		"1.82.8.0"
+
+#endif				/* phy_version_h_ */
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_cmn.c b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
new file mode 100644
index 0000000..5c7858a
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phy_cmn.c
@@ -0,0 +1,3438 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+
+#include <osl.h>
+#include <bcmendian.h>
+#include <bcmnvram.h>
+#include <sbchipc.h>
+
+#include <wlc_phy_int.h>
+#include <wlc_phyreg_n.h>
+#include <wlc_phy_radio.h>
+#include <wlc_phy_lcn.h>
+
+uint32 phyhal_msg_level = PHYHAL_ERROR;
+
+typedef struct _chan_info_basic {
+	uint16 chan;
+	uint16 freq;
+} chan_info_basic_t;
+
+static chan_info_basic_t chan_info_all[] = {
+
+	{1, 2412},
+	{2, 2417},
+	{3, 2422},
+	{4, 2427},
+	{5, 2432},
+	{6, 2437},
+	{7, 2442},
+	{8, 2447},
+	{9, 2452},
+	{10, 2457},
+	{11, 2462},
+	{12, 2467},
+	{13, 2472},
+	{14, 2484},
+
+	{34, 5170},
+	{38, 5190},
+	{42, 5210},
+	{46, 5230},
+
+	{36, 5180},
+	{40, 5200},
+	{44, 5220},
+	{48, 5240},
+	{52, 5260},
+	{56, 5280},
+	{60, 5300},
+	{64, 5320},
+
+	{100, 5500},
+	{104, 5520},
+	{108, 5540},
+	{112, 5560},
+	{116, 5580},
+	{120, 5600},
+	{124, 5620},
+	{128, 5640},
+	{132, 5660},
+	{136, 5680},
+	{140, 5700},
+
+	{149, 5745},
+	{153, 5765},
+	{157, 5785},
+	{161, 5805},
+	{165, 5825},
+
+	{184, 4920},
+	{188, 4940},
+	{192, 4960},
+	{196, 4980},
+	{200, 5000},
+	{204, 5020},
+	{208, 5040},
+	{212, 5060},
+	{216, 50800}
+};
+
+uint16 ltrn_list[PHY_LTRN_LIST_LEN] = {
+	0x18f9, 0x0d01, 0x00e4, 0xdef4, 0x06f1, 0x0ffc,
+	0xfa27, 0x1dff, 0x10f0, 0x0918, 0xf20a, 0xe010,
+	0x1417, 0x1104, 0xf114, 0xf2fa, 0xf7db, 0xe2fc,
+	0xe1fb, 0x13ee, 0xff0d, 0xe91c, 0x171a, 0x0318,
+	0xda00, 0x03e8, 0x17e6, 0xe9e4, 0xfff3, 0x1312,
+	0xe105, 0xe204, 0xf725, 0xf206, 0xf1ec, 0x11fc,
+	0x14e9, 0xe0f0, 0xf2f6, 0x09e8, 0x1010, 0x1d01,
+	0xfad9, 0x0f04, 0x060f, 0xde0c, 0x001c, 0x0dff,
+	0x1807, 0xf61a, 0xe40e, 0x0f16, 0x05f9, 0x18ec,
+	0x0a1b, 0xff1e, 0x2600, 0xffe2, 0x0ae5, 0x1814,
+	0x0507, 0x0fea, 0xe4f2, 0xf6e6
+};
+
+const uint8 ofdm_rate_lookup[] = {
+
+	WLC_RATE_48M,
+	WLC_RATE_24M,
+	WLC_RATE_12M,
+	WLC_RATE_6M,
+	WLC_RATE_54M,
+	WLC_RATE_36M,
+	WLC_RATE_18M,
+	WLC_RATE_9M
+};
+
+#define PHY_WREG_LIMIT	24
+
+static void wlc_set_phy_uninitted(phy_info_t * pi);
+static uint32 wlc_phy_get_radio_ver(phy_info_t * pi);
+static void wlc_phy_timercb_phycal(void *arg);
+
+static bool wlc_phy_noise_calc_phy(phy_info_t * pi, uint32 * cmplx_pwr,
+				   int8 * pwr_ant);
+
+static void wlc_phy_cal_perical_mphase_schedule(phy_info_t * pi, uint delay);
+static void wlc_phy_noise_cb(phy_info_t * pi, uint8 channel, int8 noise_dbm);
+static void wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason,
+					 uint8 ch);
+
+static void wlc_phy_txpower_reg_limit_calc(phy_info_t * pi,
+					   struct txpwr_limits *tp, chanspec_t);
+static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t * pi);
+
+static int8 wlc_user_txpwr_antport_to_rfport(phy_info_t * pi, uint chan,
+					     uint32 band, uint8 rate);
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t * pi, uint32 band);
+static int8 wlc_phy_env_measure_vbat(phy_info_t * pi);
+static int8 wlc_phy_env_measure_temperature(phy_info_t * pi);
+
+char *phy_getvar(phy_info_t * pi, const char *name)
+{
+	char *vars = pi->vars;
+	char *s;
+	int len;
+
+	ASSERT(pi->vars != (char *)&pi->vars);
+
+	if (!name)
+		return NULL;
+
+	len = strlen(name);
+	if (len == 0)
+		return NULL;
+
+	for (s = vars; s && *s;) {
+		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
+			return (&s[len + 1]);
+
+		while (*s++) ;
+	}
+
+	return (nvram_get(name));
+}
+
+int phy_getintvar(phy_info_t * pi, const char *name)
+{
+	char *val;
+
+	if ((val = PHY_GETVAR(pi, name)) == NULL)
+		return (0);
+
+	return (bcm_strtoul(val, NULL, 0));
+}
+
+void wlc_phyreg_enter(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	wlapi_bmac_ucode_wake_override_phyreg_set(pi->sh->physhim);
+}
+
+void wlc_phyreg_exit(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	wlapi_bmac_ucode_wake_override_phyreg_clear(pi->sh->physhim);
+}
+
+void wlc_radioreg_enter(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, MCTL_LOCK_RADIO);
+
+	OSL_DELAY(10);
+}
+
+void wlc_radioreg_exit(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	volatile uint16 dummy;
+
+	dummy = R_REG(pi->sh->osh, &pi->regs->phyversion);
+	pi->phy_wreg = 0;
+	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, 0);
+}
+
+uint16 read_radio_reg(phy_info_t * pi, uint16 addr)
+{
+	uint16 data;
+
+	if ((addr == RADIO_IDCODE))
+		return 0xffff;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return (NORADIO_IDCODE & 0xffff);
+
+	switch (pi->pubpi.phy_type) {
+	case PHY_TYPE_N:
+		CASECHECK(PHYTYPE, PHY_TYPE_N);
+		if (NREV_GE(pi->pubpi.phy_rev, 7))
+			addr |= RADIO_2057_READ_OFF;
+		else
+			addr |= RADIO_2055_READ_OFF;
+		break;
+
+	case PHY_TYPE_LCN:
+		CASECHECK(PHYTYPE, PHY_TYPE_LCN);
+		addr |= RADIO_2064_READ_OFF;
+		break;
+
+	default:
+		ASSERT(VALID_PHYTYPE(pi->pubpi.phy_type));
+	}
+
+	if ((D11REV_GE(pi->sh->corerev, 24)) ||
+	    (D11REV_IS(pi->sh->corerev, 22)
+	     && (pi->pubpi.phy_type != PHY_TYPE_SSN))) {
+		W_REG(pi->sh->osh, &pi->regs->radioregaddr, addr);
+#ifdef __mips__
+		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
+#endif
+		data = R_REG(pi->sh->osh, &pi->regs->radioregdata);
+	} else {
+		W_REG(pi->sh->osh, &pi->regs->phy4waddr, addr);
+#ifdef __mips__
+		(void)R_REG(pi->sh->osh, &pi->regs->phy4waddr);
+#endif
+
+#ifdef __ARM_ARCH_4T__
+		__asm__(" .align 4 ");
+		__asm__(" nop ");
+		data = R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
+#else
+		data = R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
+#endif
+
+	}
+	pi->phy_wreg = 0;
+
+	return data;
+}
+
+void write_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+{
+	osl_t *osh;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	osh = pi->sh->osh;
+
+	if ((D11REV_GE(pi->sh->corerev, 24)) ||
+	    (D11REV_IS(pi->sh->corerev, 22)
+	     && (pi->pubpi.phy_type != PHY_TYPE_SSN))) {
+
+		W_REG(osh, &pi->regs->radioregaddr, addr);
+#ifdef __mips__
+		(void)R_REG(osh, &pi->regs->radioregaddr);
+#endif
+		W_REG(osh, &pi->regs->radioregdata, val);
+	} else {
+		W_REG(osh, &pi->regs->phy4waddr, addr);
+#ifdef __mips__
+		(void)R_REG(osh, &pi->regs->phy4waddr);
+#endif
+		W_REG(osh, &pi->regs->phy4wdatalo, val);
+	}
+
+	if (BUSTYPE(pi->sh->bustype) == PCI_BUS) {
+		if (++pi->phy_wreg >= pi->phy_wreg_limit) {
+			(void)R_REG(osh, &pi->regs->maccontrol);
+			pi->phy_wreg = 0;
+		}
+	}
+}
+
+static uint32 read_radio_id(phy_info_t * pi)
+{
+	uint32 id;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return (NORADIO_IDCODE);
+
+	if (D11REV_GE(pi->sh->corerev, 24)) {
+		uint32 b0, b1, b2;
+
+		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 0);
+#ifdef __mips__
+		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
+#endif
+		b0 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 1);
+#ifdef __mips__
+		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
+#endif
+		b1 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 2);
+#ifdef __mips__
+		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
+#endif
+		b2 = (uint32) R_REG(pi->sh->osh, &pi->regs->radioregdata);
+
+		id = ((b0 & 0xf) << 28) | (((b2 << 8) | b1) << 12) | ((b0 >> 4)
+								      & 0xf);
+	} else {
+		W_REG(pi->sh->osh, &pi->regs->phy4waddr, RADIO_IDCODE);
+#ifdef __mips__
+		(void)R_REG(pi->sh->osh, &pi->regs->phy4waddr);
+#endif
+		id = (uint32) R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
+		id |= (uint32) R_REG(pi->sh->osh, &pi->regs->phy4wdatahi) << 16;
+	}
+	pi->phy_wreg = 0;
+	return id;
+}
+
+void and_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+{
+	uint16 rval;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	rval = read_radio_reg(pi, addr);
+	write_radio_reg(pi, addr, (rval & val));
+}
+
+void or_radio_reg(phy_info_t * pi, uint16 addr, uint16 val)
+{
+	uint16 rval;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	rval = read_radio_reg(pi, addr);
+	write_radio_reg(pi, addr, (rval | val));
+}
+
+void xor_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask)
+{
+	uint16 rval;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	rval = read_radio_reg(pi, addr);
+	write_radio_reg(pi, addr, (rval ^ mask));
+}
+
+void mod_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
+{
+	uint16 rval;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	rval = read_radio_reg(pi, addr);
+	write_radio_reg(pi, addr, (rval & ~mask) | (val & mask));
+}
+
+void write_phy_channel_reg(phy_info_t * pi, uint val)
+{
+	W_REG(pi->sh->osh, &pi->regs->phychannel, val);
+}
+
+#if defined(BCMDBG)
+static bool wlc_phy_war41476(phy_info_t * pi)
+{
+	uint32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
+
+	return ((mc & MCTL_EN_MAC) == 0)
+	    || ((mc & MCTL_PHYLOCK) == MCTL_PHYLOCK);
+}
+#endif
+
+uint16 read_phy_reg(phy_info_t * pi, uint16 addr)
+{
+	osl_t *osh;
+	d11regs_t *regs;
+
+	osh = pi->sh->osh;
+	regs = pi->regs;
+
+	W_REG(osh, &regs->phyregaddr, addr);
+#ifdef __mips__
+	(void)R_REG(osh, &regs->phyregaddr);
+#endif
+
+	ASSERT(!
+	       (D11REV_IS(pi->sh->corerev, 11)
+		|| D11REV_IS(pi->sh->corerev, 12)) || wlc_phy_war41476(pi));
+
+	pi->phy_wreg = 0;
+	return (R_REG(osh, &regs->phyregdata));
+}
+
+void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+{
+	osl_t *osh;
+	d11regs_t *regs;
+
+	osh = pi->sh->osh;
+	regs = pi->regs;
+
+#ifdef __mips__
+	W_REG(osh, &regs->phyregaddr, addr);
+	(void)R_REG(osh, &regs->phyregaddr);
+	W_REG(osh, &regs->phyregdata, val);
+	if (addr == 0x72)
+		(void)R_REG(osh, &regs->phyregdata);
+#else
+	W_REG(osh, (volatile uint32 *)(uintptr) (&regs->phyregaddr),
+	      addr | (val << 16));
+	if (BUSTYPE(pi->sh->bustype) == PCI_BUS) {
+		if (++pi->phy_wreg >= pi->phy_wreg_limit) {
+			pi->phy_wreg = 0;
+			(void)R_REG(osh, &regs->phyversion);
+		}
+	}
+#endif
+}
+
+void and_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+{
+	osl_t *osh;
+	d11regs_t *regs;
+
+	osh = pi->sh->osh;
+	regs = pi->regs;
+
+	W_REG(osh, &regs->phyregaddr, addr);
+#ifdef __mips__
+	(void)R_REG(osh, &regs->phyregaddr);
+#endif
+
+	ASSERT(!
+	       (D11REV_IS(pi->sh->corerev, 11)
+		|| D11REV_IS(pi->sh->corerev, 12)) || wlc_phy_war41476(pi));
+
+	W_REG(osh, &regs->phyregdata, (R_REG(osh, &regs->phyregdata) & val));
+	pi->phy_wreg = 0;
+}
+
+void or_phy_reg(phy_info_t * pi, uint16 addr, uint16 val)
+{
+	osl_t *osh;
+	d11regs_t *regs;
+
+	osh = pi->sh->osh;
+	regs = pi->regs;
+
+	W_REG(osh, &regs->phyregaddr, addr);
+#ifdef __mips__
+	(void)R_REG(osh, &regs->phyregaddr);
+#endif
+
+	ASSERT(!
+	       (D11REV_IS(pi->sh->corerev, 11)
+		|| D11REV_IS(pi->sh->corerev, 12)) || wlc_phy_war41476(pi));
+
+	W_REG(osh, &regs->phyregdata, (R_REG(osh, &regs->phyregdata) | val));
+	pi->phy_wreg = 0;
+}
+
+void mod_phy_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val)
+{
+	osl_t *osh;
+	d11regs_t *regs;
+
+	osh = pi->sh->osh;
+	regs = pi->regs;
+
+	W_REG(osh, &regs->phyregaddr, addr);
+#ifdef __mips__
+	(void)R_REG(osh, &regs->phyregaddr);
+#endif
+
+	ASSERT(!
+	       (D11REV_IS(pi->sh->corerev, 11)
+		|| D11REV_IS(pi->sh->corerev, 12)) || wlc_phy_war41476(pi));
+
+	W_REG(osh, &regs->phyregdata,
+	      ((R_REG(osh, &regs->phyregdata) & ~mask) | (val & mask)));
+	pi->phy_wreg = 0;
+}
+
+static void WLBANDINITFN(wlc_set_phy_uninitted) (phy_info_t * pi) {
+	int i, j;
+
+	pi->initialized = FALSE;
+
+	pi->tx_vos = 0xffff;
+	pi->nrssi_table_delta = 0x7fffffff;
+	pi->rc_cal = 0xffff;
+	pi->mintxbias = 0xffff;
+	pi->txpwridx = -1;
+	if (ISNPHY(pi)) {
+		pi->phy_spuravoid = SPURAVOID_DISABLE;
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)
+		    && NREV_LT(pi->pubpi.phy_rev, 7))
+			pi->phy_spuravoid = SPURAVOID_AUTO;
+
+		pi->nphy_papd_skip = 0;
+		pi->nphy_papd_epsilon_offset[0] = 0xf588;
+		pi->nphy_papd_epsilon_offset[1] = 0xf588;
+		pi->nphy_txpwr_idx[0] = 128;
+		pi->nphy_txpwr_idx[1] = 128;
+		pi->nphy_txpwrindex[0].index_internal = 40;
+		pi->nphy_txpwrindex[1].index_internal = 40;
+		pi->phy_pabias = 0;
+	} else {
+		pi->phy_spuravoid = SPURAVOID_AUTO;
+	}
+	pi->radiopwr = 0xffff;
+	for (i = 0; i < STATIC_NUM_RF; i++) {
+		for (j = 0; j < STATIC_NUM_BB; j++) {
+			pi->stats_11b_txpower[i][j] = -1;
+		}
+	}
+}
+
+shared_phy_t *BCMATTACHFN(wlc_phy_shared_attach) (shared_phy_params_t * shp) {
+	shared_phy_t *sh;
+
+	if ((sh =
+	     (shared_phy_t *) MALLOC(shp->osh, sizeof(shared_phy_t))) == NULL) {
+		return NULL;
+	}
+	bzero((char *)sh, sizeof(shared_phy_t));
+
+	sh->osh = shp->osh;
+	sh->sih = shp->sih;
+	sh->physhim = shp->physhim;
+	sh->unit = shp->unit;
+	sh->corerev = shp->corerev;
+
+	sh->vid = shp->vid;
+	sh->did = shp->did;
+	sh->chip = shp->chip;
+	sh->chiprev = shp->chiprev;
+	sh->chippkg = shp->chippkg;
+	sh->sromrev = shp->sromrev;
+	sh->boardtype = shp->boardtype;
+	sh->boardrev = shp->boardrev;
+	sh->boardvendor = shp->boardvendor;
+	sh->boardflags = shp->boardflags;
+	sh->boardflags2 = shp->boardflags2;
+	sh->bustype = shp->bustype;
+	sh->buscorerev = shp->buscorerev;
+
+	sh->fast_timer = PHY_SW_TIMER_FAST;
+	sh->slow_timer = PHY_SW_TIMER_SLOW;
+	sh->glacial_timer = PHY_SW_TIMER_GLACIAL;
+
+	sh->rssi_mode = RSSI_ANT_MERGE_MAX;
+
+	return sh;
+}
+
+void BCMATTACHFN(wlc_phy_shared_detach) (shared_phy_t * phy_sh) {
+	osl_t *osh;
+
+	if (phy_sh) {
+		osh = phy_sh->osh;
+
+		if (phy_sh->phy_head) {
+			ASSERT(!phy_sh->phy_head);
+		}
+		MFREE(osh, phy_sh, sizeof(shared_phy_t));
+	}
+}
+
+wlc_phy_t *BCMATTACHFN(wlc_phy_attach) (shared_phy_t * sh, void *regs,
+					int bandtype, char *vars) {
+	phy_info_t *pi;
+	uint32 sflags = 0;
+	uint phyversion;
+	int i;
+	osl_t *osh;
+
+	osh = sh->osh;
+
+	if (D11REV_IS(sh->corerev, 4))
+		sflags = SISF_2G_PHY | SISF_5G_PHY;
+	else
+		sflags = si_core_sflags(sh->sih, 0, 0);
+
+	if (BAND_5G(bandtype)) {
+		if ((sflags & (SISF_5G_PHY | SISF_DB_PHY)) == 0) {
+			return NULL;
+		}
+	}
+
+	if ((sflags & SISF_DB_PHY) && (pi = sh->phy_head)) {
+
+		wlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);
+		pi->refcnt++;
+		return &pi->pubpi_ro;
+	}
+
+	if ((pi = (phy_info_t *) MALLOC(osh, sizeof(phy_info_t))) == NULL) {
+		return NULL;
+	}
+	bzero((char *)pi, sizeof(phy_info_t));
+	pi->regs = (d11regs_t *) regs;
+	pi->sh = sh;
+	pi->phy_init_por = TRUE;
+	pi->phy_wreg_limit = PHY_WREG_LIMIT;
+
+	pi->vars = vars;
+
+	pi->txpwr_percent = 100;
+
+	pi->do_initcal = TRUE;
+
+	pi->phycal_tempdelta = 0;
+
+	if (BAND_2G(bandtype) && (sflags & SISF_2G_PHY)) {
+
+		pi->pubpi.coreflags = SICF_GMODE;
+	}
+
+	wlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);
+	phyversion = R_REG(osh, &pi->regs->phyversion);
+
+	pi->pubpi.phy_type = PHY_TYPE(phyversion);
+	pi->pubpi.phy_rev = phyversion & PV_PV_MASK;
+
+	if (pi->pubpi.phy_type == PHY_TYPE_LCNXN) {
+		pi->pubpi.phy_type = PHY_TYPE_N;
+		pi->pubpi.phy_rev += LCNXN_BASEREV;
+	}
+	pi->pubpi.phy_corenum = PHY_CORE_NUM_2;
+	pi->pubpi.ana_rev = (phyversion & PV_AV_MASK) >> PV_AV_SHIFT;
+
+	if (!VALID_PHYTYPE(pi->pubpi.phy_type)) {
+		goto err;
+	}
+	if (BAND_5G(bandtype)) {
+		if (!ISNPHY(pi)) {
+			goto err;
+		}
+	} else {
+		if (!ISNPHY(pi) && !ISLCNPHY(pi)) {
+			goto err;
+		}
+	}
+
+	if (ISSIM_ENAB(pi->sh->sih)) {
+		pi->pubpi.radioid = NORADIO_ID;
+		pi->pubpi.radiorev = 5;
+	} else {
+		uint32 idcode;
+
+		wlc_phy_anacore((wlc_phy_t *) pi, ON);
+
+		idcode = wlc_phy_get_radio_ver(pi);
+		pi->pubpi.radioid =
+		    (idcode & IDCODE_ID_MASK) >> IDCODE_ID_SHIFT;
+		pi->pubpi.radiorev =
+		    (idcode & IDCODE_REV_MASK) >> IDCODE_REV_SHIFT;
+		pi->pubpi.radiover =
+		    (idcode & IDCODE_VER_MASK) >> IDCODE_VER_SHIFT;
+		if (!VALID_RADIO(pi, pi->pubpi.radioid)) {
+			goto err;
+		}
+
+		wlc_phy_switch_radio((wlc_phy_t *) pi, OFF);
+	}
+
+	wlc_set_phy_uninitted(pi);
+
+	pi->bw = WL_CHANSPEC_BW_20;
+	pi->radio_chanspec =
+	    BAND_2G(bandtype) ? CH20MHZ_CHSPEC(1) : CH20MHZ_CHSPEC(36);
+
+	pi->rxiq_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;
+	pi->rxiq_antsel = ANT_RX_DIV_DEF;
+
+	pi->watchdog_override = TRUE;
+
+	pi->cal_type_override = PHY_PERICAL_AUTO;
+
+	pi->nphy_saved_noisevars.bufcount = 0;
+
+	if (ISNPHY(pi))
+		pi->min_txpower = PHY_TXPWR_MIN_NPHY;
+	else
+		pi->min_txpower = PHY_TXPWR_MIN;
+
+	pi->sh->phyrxchain = 0x3;
+
+	pi->rx2tx_biasentry = -1;
+
+	pi->phy_txcore_disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;
+	pi->phy_txcore_enable_temp =
+	    PHY_CHAIN_TX_DISABLE_TEMP - PHY_HYSTERESIS_DELTATEMP;
+	pi->phy_tempsense_offset = 0;
+	pi->phy_txcore_heatedup = FALSE;
+
+	pi->nphy_lastcal_temp = -50;
+
+	pi->phynoise_polling = TRUE;
+	if (ISNPHY(pi) || ISLCNPHY(pi))
+		pi->phynoise_polling = FALSE;
+
+	for (i = 0; i < TXP_NUM_RATES; i++) {
+		pi->txpwr_limit[i] = WLC_TXPWR_MAX;
+		pi->txpwr_env_limit[i] = WLC_TXPWR_MAX;
+		pi->tx_user_target[i] = WLC_TXPWR_MAX;
+	}
+
+	pi->radiopwr_override = RADIOPWR_OVERRIDE_DEF;
+
+	pi->user_txpwr_at_rfport = FALSE;
+
+	if (ISNPHY(pi)) {
+
+		if (!(pi->phycal_timer = wlapi_init_timer(pi->sh->physhim,
+							  wlc_phy_timercb_phycal,
+							  pi, "phycal"))) {
+			goto err;
+		}
+
+		if (!wlc_phy_attach_nphy(pi))
+			goto err;
+
+	} else if (ISLCNPHY(pi)) {
+		if (!wlc_phy_attach_lcnphy(pi))
+			goto err;
+
+	} else {
+
+	}
+
+	pi->refcnt++;
+	pi->next = pi->sh->phy_head;
+	sh->phy_head = pi;
+
+	pi->vars = (char *)&pi->vars;
+
+	bcopy(&pi->pubpi, &pi->pubpi_ro, sizeof(wlc_phy_t));
+
+	return &pi->pubpi_ro;
+
+ err:
+	if (pi)
+		MFREE(sh->osh, pi, sizeof(phy_info_t));
+	return NULL;
+}
+
+void BCMATTACHFN(wlc_phy_detach) (wlc_phy_t * pih) {
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (pih) {
+		if (--pi->refcnt) {
+			return;
+		}
+
+		if (pi->phycal_timer) {
+			wlapi_free_timer(pi->sh->physhim, pi->phycal_timer);
+			pi->phycal_timer = NULL;
+		}
+
+		if (pi->sh->phy_head == pi)
+			pi->sh->phy_head = pi->next;
+		else if (pi->sh->phy_head->next == pi)
+			pi->sh->phy_head->next = NULL;
+		else
+			ASSERT(0);
+
+		if (pi->pi_fptr.detach)
+			(pi->pi_fptr.detach) (pi);
+
+		MFREE(pi->sh->osh, pi, sizeof(phy_info_t));
+	}
+}
+
+bool
+wlc_phy_get_phyversion(wlc_phy_t * pih, uint16 * phytype, uint16 * phyrev,
+		       uint16 * radioid, uint16 * radiover)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	*phytype = (uint16) pi->pubpi.phy_type;
+	*phyrev = (uint16) pi->pubpi.phy_rev;
+	*radioid = pi->pubpi.radioid;
+	*radiover = pi->pubpi.radiorev;
+
+	return TRUE;
+}
+
+bool wlc_phy_get_encore(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	return pi->pubpi.abgphy_encore;
+}
+
+uint32 wlc_phy_get_coreflags(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	return pi->pubpi.coreflags;
+}
+
+static void wlc_phy_timercb_phycal(void *arg)
+{
+	phy_info_t *pi = (phy_info_t *) arg;
+	uint delay = 5;
+
+	if (PHY_PERICAL_MPHASE_PENDING(pi)) {
+		if (!pi->sh->up) {
+			wlc_phy_cal_perical_mphase_reset(pi);
+			return;
+		}
+
+		if (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)) {
+
+			delay = 1000;
+			wlc_phy_cal_perical_mphase_restart(pi);
+		} else
+			wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_AUTO);
+		wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, delay, 0);
+		return;
+	}
+
+}
+
+void wlc_phy_anacore(wlc_phy_t * pih, bool on)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (ISNPHY(pi)) {
+		if (on) {
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				write_phy_reg(pi, 0xa6, 0x0d);
+				write_phy_reg(pi, 0x8f, 0x0);
+				write_phy_reg(pi, 0xa7, 0x0d);
+				write_phy_reg(pi, 0xa5, 0x0);
+			} else {
+				write_phy_reg(pi, 0xa5, 0x0);
+			}
+		} else {
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				write_phy_reg(pi, 0x8f, 0x07ff);
+				write_phy_reg(pi, 0xa6, 0x0fd);
+				write_phy_reg(pi, 0xa5, 0x07ff);
+				write_phy_reg(pi, 0xa7, 0x0fd);
+			} else {
+				write_phy_reg(pi, 0xa5, 0x7fff);
+			}
+		}
+	} else if (ISLCNPHY(pi)) {
+		if (on) {
+			and_phy_reg(pi, 0x43b,
+				    ~((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+		} else {
+			or_phy_reg(pi, 0x43c,
+				   (0x1 << 0) | (0x1 << 1) | (0x1 << 2));
+			or_phy_reg(pi, 0x43b,
+				   (0x1 << 0) | (0x1 << 1) | (0x1 << 2));
+		}
+	}
+}
+
+uint32 wlc_phy_clk_bwbits(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	uint32 phy_bw_clkbits = 0;
+
+	if (pi && (ISNPHY(pi) || ISLCNPHY(pi))) {
+		switch (pi->bw) {
+		case WL_CHANSPEC_BW_10:
+			phy_bw_clkbits = SICF_BW10;
+			break;
+		case WL_CHANSPEC_BW_20:
+			phy_bw_clkbits = SICF_BW20;
+			break;
+		case WL_CHANSPEC_BW_40:
+			phy_bw_clkbits = SICF_BW40;
+			break;
+		default:
+			ASSERT(0);
+			break;
+		}
+	}
+
+	return phy_bw_clkbits;
+}
+
+void WLBANDINITFN(wlc_phy_por_inform) (wlc_phy_t * ppi) {
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	pi->phy_init_por = TRUE;
+}
+
+void wlc_phy_edcrs_lock(wlc_phy_t * pih, bool lock)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	pi->edcrs_threshold_lock = lock;
+
+	write_phy_reg(pi, 0x22c, 0x46b);
+	write_phy_reg(pi, 0x22d, 0x46b);
+	write_phy_reg(pi, 0x22e, 0x3c0);
+	write_phy_reg(pi, 0x22f, 0x3c0);
+}
+
+void wlc_phy_initcal_enable(wlc_phy_t * pih, bool initcal)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	pi->do_initcal = initcal;
+}
+
+void wlc_phy_hw_clk_state_upd(wlc_phy_t * pih, bool newstate)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (!pi || !pi->sh)
+		return;
+
+	pi->sh->clk = newstate;
+}
+
+void wlc_phy_hw_state_upd(wlc_phy_t * pih, bool newstate)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (!pi || !pi->sh)
+		return;
+
+	pi->sh->up = newstate;
+}
+
+void WLBANDINITFN(wlc_phy_init) (wlc_phy_t * pih, chanspec_t chanspec) {
+	uint32 mc;
+	initfn_t phy_init = NULL;
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (pi->init_in_progress)
+		return;
+
+	pi->init_in_progress = TRUE;
+
+	pi->radio_chanspec = chanspec;
+
+	mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
+	if ((mc & MCTL_EN_MAC) != 0) {
+		ASSERT((const char *)
+		       "wlc_phy_init: Called with the MAC running!" == NULL);
+	}
+
+	ASSERT(pi != NULL);
+
+	if (!(pi->measure_hold & PHY_HOLD_FOR_SCAN)) {
+		pi->measure_hold |= PHY_HOLD_FOR_NOT_ASSOC;
+	}
+
+	if (D11REV_GE(pi->sh->corerev, 5))
+		ASSERT(si_core_sflags(pi->sh->sih, 0, 0) & SISF_FCLKA);
+
+	phy_init = pi->pi_fptr.init;
+
+	if (phy_init == NULL) {
+		ASSERT(phy_init != NULL);
+		return;
+	}
+
+	wlc_phy_anacore(pih, ON);
+
+	if (CHSPEC_BW(pi->radio_chanspec) != pi->bw)
+		wlapi_bmac_bw_set(pi->sh->physhim,
+				  CHSPEC_BW(pi->radio_chanspec));
+
+	pi->nphy_gain_boost = TRUE;
+
+	wlc_phy_switch_radio((wlc_phy_t *) pi, ON);
+
+	(*phy_init) (pi);
+
+	pi->phy_init_por = FALSE;
+
+	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
+		wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+
+	if (!(ISNPHY(pi)))
+		wlc_phy_txpower_update_shm(pi);
+
+	wlc_phy_ant_rxdiv_set((wlc_phy_t *) pi, pi->sh->rx_antdiv);
+
+	pi->init_in_progress = FALSE;
+}
+
+void BCMINITFN(wlc_phy_cal_init) (wlc_phy_t * pih) {
+	phy_info_t *pi = (phy_info_t *) pih;
+	initfn_t cal_init = NULL;
+
+	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);
+
+	if (!pi->initialized) {
+		cal_init = pi->pi_fptr.calinit;
+		if (cal_init)
+			(*cal_init) (pi);
+
+		pi->initialized = TRUE;
+	}
+}
+
+int BCMUNINITFN(wlc_phy_down) (wlc_phy_t * pih) {
+	phy_info_t *pi = (phy_info_t *) pih;
+	int callbacks = 0;
+
+	ASSERT(pi->phytest_on == FALSE);
+
+	if (pi->phycal_timer
+	    && !wlapi_del_timer(pi->sh->physhim, pi->phycal_timer))
+		callbacks++;
+
+	pi->nphy_iqcal_chanspec_2G = 0;
+	pi->nphy_iqcal_chanspec_5G = 0;
+
+	return callbacks;
+}
+
+static uint32 wlc_phy_get_radio_ver(phy_info_t * pi)
+{
+	uint32 ver;
+
+	ver = read_radio_id(pi);
+
+	return ver;
+}
+
+void
+wlc_phy_table_addr(phy_info_t * pi, uint tbl_id, uint tbl_offset,
+		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+{
+	write_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);
+
+	pi->tbl_data_hi = tblDataHi;
+	pi->tbl_data_lo = tblDataLo;
+
+	if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
+	     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
+	    (pi->sh->chiprev == 1)) {
+		pi->tbl_addr = tblAddr;
+		pi->tbl_save_id = tbl_id;
+		pi->tbl_save_offset = tbl_offset;
+	}
+}
+
+void wlc_phy_table_data_write(phy_info_t * pi, uint width, uint32 val)
+{
+	ASSERT((width == 8) || (width == 16) || (width == 32));
+
+	if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
+	     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
+	    (pi->sh->chiprev == 1) &&
+	    (pi->tbl_save_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {
+		read_phy_reg(pi, pi->tbl_data_lo);
+
+		write_phy_reg(pi, pi->tbl_addr,
+			      (pi->tbl_save_id << 10) | pi->tbl_save_offset);
+		pi->tbl_save_offset++;
+	}
+
+	if (width == 32) {
+
+		write_phy_reg(pi, pi->tbl_data_hi, (uint16) (val >> 16));
+		write_phy_reg(pi, pi->tbl_data_lo, (uint16) val);
+	} else {
+
+		write_phy_reg(pi, pi->tbl_data_lo, (uint16) val);
+	}
+}
+
+void
+wlc_phy_write_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
+		    uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+{
+	uint idx;
+	uint tbl_id = ptbl_info->tbl_id;
+	uint tbl_offset = ptbl_info->tbl_offset;
+	uint tbl_width = ptbl_info->tbl_width;
+	const uint8 *ptbl_8b = (const uint8 *)ptbl_info->tbl_ptr;
+	const uint16 *ptbl_16b = (const uint16 *)ptbl_info->tbl_ptr;
+	const uint32 *ptbl_32b = (const uint32 *)ptbl_info->tbl_ptr;
+
+	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
+
+	write_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);
+
+	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {
+
+		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
+		     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
+		    (pi->sh->chiprev == 1) &&
+		    (tbl_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {
+			read_phy_reg(pi, tblDataLo);
+
+			write_phy_reg(pi, tblAddr,
+				      (tbl_id << 10) | (tbl_offset + idx));
+		}
+
+		if (tbl_width == 32) {
+
+			write_phy_reg(pi, tblDataHi,
+				      (uint16) (ptbl_32b[idx] >> 16));
+			write_phy_reg(pi, tblDataLo, (uint16) ptbl_32b[idx]);
+		} else if (tbl_width == 16) {
+
+			write_phy_reg(pi, tblDataLo, ptbl_16b[idx]);
+		} else {
+
+			write_phy_reg(pi, tblDataLo, ptbl_8b[idx]);
+		}
+	}
+}
+
+void
+wlc_phy_read_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
+		   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
+{
+	uint idx;
+	uint tbl_id = ptbl_info->tbl_id;
+	uint tbl_offset = ptbl_info->tbl_offset;
+	uint tbl_width = ptbl_info->tbl_width;
+	uint8 *ptbl_8b = (uint8 *) (uintptr) ptbl_info->tbl_ptr;
+	uint16 *ptbl_16b = (uint16 *) (uintptr) ptbl_info->tbl_ptr;
+	uint32 *ptbl_32b = (uint32 *) (uintptr) ptbl_info->tbl_ptr;
+
+	ASSERT((tbl_width == 8) || (tbl_width == 16) || (tbl_width == 32));
+
+	write_phy_reg(pi, tblAddr, (tbl_id << 10) | tbl_offset);
+
+	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {
+
+		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
+		     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
+		    (pi->sh->chiprev == 1)) {
+			(void)read_phy_reg(pi, tblDataLo);
+
+			write_phy_reg(pi, tblAddr,
+				      (tbl_id << 10) | (tbl_offset + idx));
+		}
+
+		if (tbl_width == 32) {
+
+			ptbl_32b[idx] = read_phy_reg(pi, tblDataLo);
+			ptbl_32b[idx] |= (read_phy_reg(pi, tblDataHi) << 16);
+		} else if (tbl_width == 16) {
+
+			ptbl_16b[idx] = read_phy_reg(pi, tblDataLo);
+		} else {
+
+			ptbl_8b[idx] = (uint8) read_phy_reg(pi, tblDataLo);
+		}
+	}
+}
+
+uint
+wlc_phy_init_radio_regs_allbands(phy_info_t * pi, radio_20xx_regs_t * radioregs)
+{
+	uint i = 0;
+
+	do {
+		if (radioregs[i].do_init) {
+			write_radio_reg(pi, radioregs[i].address,
+					(uint16) radioregs[i].init);
+		}
+
+		i++;
+	} while (radioregs[i].address != 0xffff);
+
+	return i;
+}
+
+uint
+wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
+			uint16 core_offset)
+{
+	uint i = 0;
+	uint count = 0;
+
+	do {
+		if (CHSPEC_IS5G(pi->radio_chanspec)) {
+			if (radioregs[i].do_init_a) {
+				write_radio_reg(pi,
+						radioregs[i].
+						address | core_offset,
+						(uint16) radioregs[i].init_a);
+				if (ISNPHY(pi) && (++count % 4 == 0))
+					WLC_PHY_WAR_PR51571(pi);
+			}
+		} else {
+			if (radioregs[i].do_init_g) {
+				write_radio_reg(pi,
+						radioregs[i].
+						address | core_offset,
+						(uint16) radioregs[i].init_g);
+				if (ISNPHY(pi) && (++count % 4 == 0))
+					WLC_PHY_WAR_PR51571(pi);
+			}
+		}
+
+		i++;
+	} while (radioregs[i].address != 0xffff);
+
+	return i;
+}
+
+void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on)
+{
+#define	DUMMY_PKT_LEN	20
+	d11regs_t *regs = pi->regs;
+	int i, count;
+	uint8 ofdmpkt[DUMMY_PKT_LEN] = {
+		0xcc, 0x01, 0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
+	};
+	uint8 cckpkt[DUMMY_PKT_LEN] = {
+		0x6e, 0x84, 0x0b, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
+	};
+	uint32 *dummypkt;
+
+	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);
+
+	dummypkt = (uint32 *) (ofdm ? ofdmpkt : cckpkt);
+	wlapi_bmac_write_template_ram(pi->sh->physhim, 0, DUMMY_PKT_LEN,
+				      dummypkt);
+
+	W_REG(pi->sh->osh, &regs->xmtsel, 0);
+
+	if (D11REV_GE(pi->sh->corerev, 11))
+		W_REG(pi->sh->osh, &regs->wepctl, 0x100);
+	else
+		W_REG(pi->sh->osh, &regs->wepctl, 0);
+
+	W_REG(pi->sh->osh, &regs->txe_phyctl, (ofdm ? 1 : 0) | PHY_TXC_ANT_0);
+	if (ISNPHY(pi) || ISLCNPHY(pi)) {
+		ASSERT(ofdm);
+		W_REG(pi->sh->osh, &regs->txe_phyctl1, 0x1A02);
+	}
+
+	W_REG(pi->sh->osh, &regs->txe_wm_0, 0);
+	W_REG(pi->sh->osh, &regs->txe_wm_1, 0);
+
+	W_REG(pi->sh->osh, &regs->xmttplatetxptr, 0);
+	W_REG(pi->sh->osh, &regs->xmttxcnt, DUMMY_PKT_LEN);
+
+	W_REG(pi->sh->osh, &regs->xmtsel, ((8 << 8) | (1 << 5) | (1 << 2) | 2));
+
+	W_REG(pi->sh->osh, &regs->txe_ctl, 0);
+
+	if (!pa_on) {
+		if (ISNPHY(pi))
+			wlc_phy_pa_override_nphy(pi, OFF);
+	}
+
+	if (ISNPHY(pi) || ISLCNPHY(pi))
+		W_REG(pi->sh->osh, &regs->txe_aux, 0xD0);
+	else
+		W_REG(pi->sh->osh, &regs->txe_aux, ((1 << 5) | (1 << 4)));
+
+	(void)R_REG(pi->sh->osh, &regs->txe_aux);
+
+	i = 0;
+	count = ofdm ? 30 : 250;
+
+	if (ISSIM_ENAB(pi->sh->sih)) {
+		count *= 100;
+	}
+
+	while ((i++ < count)
+	       && (R_REG(pi->sh->osh, &regs->txe_status) & (1 << 7))) {
+		OSL_DELAY(10);
+	}
+
+	i = 0;
+
+	while ((i++ < 10)
+	       && ((R_REG(pi->sh->osh, &regs->txe_status) & (1 << 10)) == 0)) {
+		OSL_DELAY(10);
+	}
+
+	i = 0;
+
+	while ((i++ < 10) && ((R_REG(pi->sh->osh, &regs->ifsstat) & (1 << 8)))) {
+		OSL_DELAY(10);
+	}
+	if (!pa_on) {
+		if (ISNPHY(pi))
+			wlc_phy_pa_override_nphy(pi, ON);
+	}
+}
+
+void wlc_phy_hold_upd(wlc_phy_t * pih, mbool id, bool set)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	ASSERT(id);
+
+	if (set) {
+		mboolset(pi->measure_hold, id);
+	} else {
+		mboolclr(pi->measure_hold, id);
+	}
+
+	return;
+}
+
+void wlc_phy_mute_upd(wlc_phy_t * pih, bool mute, mbool flags)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (mute) {
+		mboolset(pi->measure_hold, PHY_HOLD_FOR_MUTE);
+	} else {
+		mboolclr(pi->measure_hold, PHY_HOLD_FOR_MUTE);
+	}
+
+	if (!mute && (flags & PHY_MUTE_FOR_PREISM))
+		pi->nphy_perical_last = pi->sh->now - pi->sh->glacial_timer;
+	return;
+}
+
+void wlc_phy_clear_tssi(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (ISNPHY(pi)) {
+		return;
+	} else {
+		wlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_0, NULL_TSSI_W);
+		wlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_1, NULL_TSSI_W);
+		wlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_0, NULL_TSSI_W);
+		wlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_1, NULL_TSSI_W);
+	}
+}
+
+static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t * pi)
+{
+	return FALSE;
+}
+
+void wlc_phy_switch_radio(wlc_phy_t * pih, bool on)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	{
+		uint mc;
+
+		mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
+	}
+
+	if (ISNPHY(pi)) {
+		wlc_phy_switch_radio_nphy(pi, on);
+
+	} else if (ISLCNPHY(pi)) {
+		if (on) {
+			and_phy_reg(pi, 0x44c,
+				    ~((0x1 << 8) |
+				      (0x1 << 9) |
+				      (0x1 << 10) | (0x1 << 11) | (0x1 << 12)));
+			and_phy_reg(pi, 0x4b0, ~((0x1 << 3) | (0x1 << 11)));
+			and_phy_reg(pi, 0x4f9, ~(0x1 << 3));
+		} else {
+			and_phy_reg(pi, 0x44d,
+				    ~((0x1 << 10) |
+				      (0x1 << 11) |
+				      (0x1 << 12) | (0x1 << 13) | (0x1 << 14)));
+			or_phy_reg(pi, 0x44c,
+				   (0x1 << 8) |
+				   (0x1 << 9) |
+				   (0x1 << 10) | (0x1 << 11) | (0x1 << 12));
+
+			and_phy_reg(pi, 0x4b7, ~((0x7f << 8)));
+			and_phy_reg(pi, 0x4b1, ~((0x1 << 13)));
+			or_phy_reg(pi, 0x4b0, (0x1 << 3) | (0x1 << 11));
+			and_phy_reg(pi, 0x4fa, ~((0x1 << 3)));
+			or_phy_reg(pi, 0x4f9, (0x1 << 3));
+		}
+	}
+}
+
+uint16 wlc_phy_bw_state_get(wlc_phy_t * ppi)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	return pi->bw;
+}
+
+void wlc_phy_bw_state_set(wlc_phy_t * ppi, uint16 bw)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	pi->bw = bw;
+}
+
+void wlc_phy_chanspec_radio_set(wlc_phy_t * ppi, chanspec_t newch)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	pi->radio_chanspec = newch;
+
+}
+
+chanspec_t wlc_phy_chanspec_get(wlc_phy_t * ppi)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	return pi->radio_chanspec;
+}
+
+void wlc_phy_chanspec_set(wlc_phy_t * ppi, chanspec_t chanspec)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint16 m_cur_channel;
+	chansetfn_t chanspec_set = NULL;
+
+	ASSERT(!wf_chspec_malformed(chanspec));
+
+	m_cur_channel = CHSPEC_CHANNEL(chanspec);
+	if (CHSPEC_IS5G(chanspec))
+		m_cur_channel |= D11_CURCHANNEL_5G;
+	if (CHSPEC_IS40(chanspec))
+		m_cur_channel |= D11_CURCHANNEL_40;
+	wlapi_bmac_write_shm(pi->sh->physhim, M_CURCHANNEL, m_cur_channel);
+
+	chanspec_set = pi->pi_fptr.chanset;
+	if (chanspec_set)
+		(*chanspec_set) (pi, chanspec);
+
+}
+
+int wlc_phy_chanspec_freq2bandrange_lpssn(uint freq)
+{
+	int range = -1;
+
+	if (freq < 2500)
+		range = WL_CHAN_FREQ_RANGE_2G;
+	else if (freq <= 5320)
+		range = WL_CHAN_FREQ_RANGE_5GL;
+	else if (freq <= 5700)
+		range = WL_CHAN_FREQ_RANGE_5GM;
+	else
+		range = WL_CHAN_FREQ_RANGE_5GH;
+
+	return range;
+}
+
+int wlc_phy_chanspec_bandrange_get(phy_info_t * pi, chanspec_t chanspec)
+{
+	int range = -1;
+	uint channel = CHSPEC_CHANNEL(chanspec);
+	uint freq = wlc_phy_channel2freq(channel);
+
+	if (ISNPHY(pi)) {
+		range = wlc_phy_get_chan_freq_range_nphy(pi, channel);
+	} else if (ISLCNPHY(pi)) {
+		range = wlc_phy_chanspec_freq2bandrange_lpssn(freq);
+	} else
+		ASSERT(0);
+
+	return range;
+}
+
+void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t * ppi, bool wide_filter)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	pi->channel_14_wide_filter = wide_filter;
+
+}
+
+int wlc_phy_channel2freq(uint channel)
+{
+	uint i;
+
+	for (i = 0; i < ARRAYSIZE(chan_info_all); i++)
+		if (chan_info_all[i].chan == channel)
+			return (chan_info_all[i].freq);
+	return (0);
+}
+
+void
+wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band, chanvec_t * channels)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint i;
+	uint channel;
+
+	ASSERT((band == WLC_BAND_2G) || (band == WLC_BAND_5G));
+
+	bzero(channels, sizeof(chanvec_t));
+
+	for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
+		channel = chan_info_all[i].chan;
+
+		if ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM)
+		    && (channel <= LAST_REF5_CHANNUM))
+			continue;
+
+		if (((band == WLC_BAND_2G) && (channel <= CH_MAX_2G_CHANNEL)) ||
+		    ((band == WLC_BAND_5G) && (channel > CH_MAX_2G_CHANNEL)))
+			setbit(channels->vec, channel);
+	}
+}
+
+chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint i;
+	uint channel;
+	chanspec_t chspec;
+
+	ASSERT((band == WLC_BAND_2G) || (band == WLC_BAND_5G));
+
+	for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
+		channel = chan_info_all[i].chan;
+
+		if (ISNPHY(pi) && IS40MHZ(pi)) {
+			uint j;
+
+			for (j = 0; j < ARRAYSIZE(chan_info_all); j++) {
+				if (chan_info_all[j].chan ==
+				    channel + CH_10MHZ_APART)
+					break;
+			}
+
+			if (j == ARRAYSIZE(chan_info_all))
+				continue;
+
+			channel = UPPER_20_SB(channel);
+			chspec =
+			    channel | WL_CHANSPEC_BW_40 |
+			    WL_CHANSPEC_CTL_SB_LOWER;
+			if (band == WLC_BAND_2G)
+				chspec |= WL_CHANSPEC_BAND_2G;
+			else
+				chspec |= WL_CHANSPEC_BAND_5G;
+		} else
+			chspec = CH20MHZ_CHSPEC(channel);
+
+		if ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM)
+		    && (channel <= LAST_REF5_CHANNUM))
+			continue;
+
+		if (((band == WLC_BAND_2G) && (channel <= CH_MAX_2G_CHANNEL)) ||
+		    ((band == WLC_BAND_5G) && (channel > CH_MAX_2G_CHANNEL)))
+			return chspec;
+	}
+
+	ASSERT(0);
+
+	return (chanspec_t) INVCHANSPEC;
+}
+
+int wlc_phy_txpower_get(wlc_phy_t * ppi, uint * qdbm, bool * override)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	ASSERT(qdbm != NULL);
+	*qdbm = pi->tx_user_target[0];
+	if (override != NULL)
+		*override = pi->txpwroverride;
+	return (0);
+}
+
+void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr)
+{
+	bool mac_enabled = FALSE;
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	bcopy(&txpwr->cck[0], &pi->tx_user_target[TXP_FIRST_CCK],
+	      WLC_NUM_RATES_CCK);
+
+	bcopy(&txpwr->ofdm[0], &pi->tx_user_target[TXP_FIRST_OFDM],
+	      WLC_NUM_RATES_OFDM);
+	bcopy(&txpwr->ofdm_cdd[0], &pi->tx_user_target[TXP_FIRST_OFDM_20_CDD],
+	      WLC_NUM_RATES_OFDM);
+
+	bcopy(&txpwr->ofdm_40_siso[0],
+	      &pi->tx_user_target[TXP_FIRST_OFDM_40_SISO], WLC_NUM_RATES_OFDM);
+	bcopy(&txpwr->ofdm_40_cdd[0],
+	      &pi->tx_user_target[TXP_FIRST_OFDM_40_CDD], WLC_NUM_RATES_OFDM);
+
+	bcopy(&txpwr->mcs_20_siso[0],
+	      &pi->tx_user_target[TXP_FIRST_MCS_20_SISO],
+	      WLC_NUM_RATES_MCS_1_STREAM);
+	bcopy(&txpwr->mcs_20_cdd[0], &pi->tx_user_target[TXP_FIRST_MCS_20_CDD],
+	      WLC_NUM_RATES_MCS_1_STREAM);
+	bcopy(&txpwr->mcs_20_stbc[0],
+	      &pi->tx_user_target[TXP_FIRST_MCS_20_STBC],
+	      WLC_NUM_RATES_MCS_1_STREAM);
+	bcopy(&txpwr->mcs_20_mimo[0], &pi->tx_user_target[TXP_FIRST_MCS_20_SDM],
+	      WLC_NUM_RATES_MCS_2_STREAM);
+
+	bcopy(&txpwr->mcs_40_siso[0],
+	      &pi->tx_user_target[TXP_FIRST_MCS_40_SISO],
+	      WLC_NUM_RATES_MCS_1_STREAM);
+	bcopy(&txpwr->mcs_40_cdd[0], &pi->tx_user_target[TXP_FIRST_MCS_40_CDD],
+	      WLC_NUM_RATES_MCS_1_STREAM);
+	bcopy(&txpwr->mcs_40_stbc[0],
+	      &pi->tx_user_target[TXP_FIRST_MCS_40_STBC],
+	      WLC_NUM_RATES_MCS_1_STREAM);
+	bcopy(&txpwr->mcs_40_mimo[0], &pi->tx_user_target[TXP_FIRST_MCS_40_SDM],
+	      WLC_NUM_RATES_MCS_2_STREAM);
+
+	if (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC)
+		mac_enabled = TRUE;
+
+	if (mac_enabled)
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+	wlc_phy_txpower_recalc_target(pi);
+	wlc_phy_cal_txpower_recalc_sw(pi);
+
+	if (mac_enabled)
+		wlapi_enable_mac(pi->sh->physhim);
+}
+
+int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	int i;
+
+	if (qdbm > 127)
+		return 5;
+
+	for (i = 0; i < TXP_NUM_RATES; i++)
+		pi->tx_user_target[i] = (uint8) qdbm;
+
+	pi->txpwroverride = FALSE;
+
+	if (pi->sh->up) {
+		if (!SCAN_INPROG_PHY(pi)) {
+			bool suspend;
+
+			suspend =
+			    (0 ==
+			     (R_REG(pi->sh->osh, &pi->regs->maccontrol) &
+			      MCTL_EN_MAC));
+
+			if (!suspend)
+				wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+			wlc_phy_txpower_recalc_target(pi);
+			wlc_phy_cal_txpower_recalc_sw(pi);
+
+			if (!suspend)
+				wlapi_enable_mac(pi->sh->physhim);
+		}
+	}
+	return (0);
+}
+
+void
+wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint channel, uint8 * min_pwr,
+			  uint8 * max_pwr, int txp_rate_idx)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint i;
+
+	*min_pwr = pi->min_txpower * WLC_TXPWR_DB_FACTOR;
+
+	if (ISNPHY(pi)) {
+		if (txp_rate_idx < 0)
+			txp_rate_idx = TXP_FIRST_CCK;
+		wlc_phy_txpower_sromlimit_get_nphy(pi, channel, max_pwr,
+						   (uint8) txp_rate_idx);
+
+	} else if ((channel <= CH_MAX_2G_CHANNEL)) {
+		if (txp_rate_idx < 0)
+			txp_rate_idx = TXP_FIRST_CCK;
+		*max_pwr = pi->tx_srom_max_rate_2g[txp_rate_idx];
+	} else {
+
+		*max_pwr = WLC_TXPWR_MAX;
+
+		if (txp_rate_idx < 0)
+			txp_rate_idx = TXP_FIRST_OFDM;
+
+		for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
+			if (channel == chan_info_all[i].chan) {
+				break;
+			}
+		}
+		ASSERT(i < ARRAYSIZE(chan_info_all));
+
+		if (pi->hwtxpwr) {
+			*max_pwr = pi->hwtxpwr[i];
+		} else {
+
+			if ((i >= FIRST_MID_5G_CHAN) && (i <= LAST_MID_5G_CHAN))
+				*max_pwr =
+				    pi->tx_srom_max_rate_5g_mid[txp_rate_idx];
+			if ((i >= FIRST_HIGH_5G_CHAN)
+			    && (i <= LAST_HIGH_5G_CHAN))
+				*max_pwr =
+				    pi->tx_srom_max_rate_5g_hi[txp_rate_idx];
+			if ((i >= FIRST_LOW_5G_CHAN) && (i <= LAST_LOW_5G_CHAN))
+				*max_pwr =
+				    pi->tx_srom_max_rate_5g_low[txp_rate_idx];
+		}
+	}
+}
+
+void
+wlc_phy_txpower_sromlimit_max_get(wlc_phy_t * ppi, uint chan, uint8 * max_txpwr,
+				  uint8 * min_txpwr)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint8 tx_pwr_max = 0;
+	uint8 tx_pwr_min = 255;
+	uint8 max_num_rate;
+	uint8 maxtxpwr, mintxpwr, rate, pactrl;
+
+	pactrl = 0;
+
+	max_num_rate = ISNPHY(pi) ? TXP_NUM_RATES :
+	    ISLCNPHY(pi) ? (TXP_LAST_SISO_MCS_20 + 1) : (TXP_LAST_OFDM + 1);
+
+	for (rate = 0; rate < max_num_rate; rate++) {
+
+		wlc_phy_txpower_sromlimit(ppi, chan, &mintxpwr, &maxtxpwr,
+					  rate);
+
+		maxtxpwr = (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;
+
+		maxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;
+
+		tx_pwr_max = MAX(tx_pwr_max, maxtxpwr);
+		tx_pwr_min = MIN(tx_pwr_min, maxtxpwr);
+	}
+	*max_txpwr = tx_pwr_max;
+	*min_txpwr = tx_pwr_min;
+}
+
+void
+wlc_phy_txpower_boardlimit_band(wlc_phy_t * ppi, uint bandunit, int32 * max_pwr,
+				int32 * min_pwr, uint32 * step_pwr)
+{
+	return;
+}
+
+uint8 wlc_phy_txpower_get_target_min(wlc_phy_t * ppi)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	return pi->tx_power_min;
+}
+
+uint8 wlc_phy_txpower_get_target_max(wlc_phy_t * ppi)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	return pi->tx_power_max;
+}
+
+void wlc_phy_txpower_recalc_target(phy_info_t * pi)
+{
+	uint8 maxtxpwr, mintxpwr, rate, pactrl;
+	uint target_chan;
+	uint8 tx_pwr_target[TXP_NUM_RATES];
+	uint8 tx_pwr_max = 0;
+	uint8 tx_pwr_min = 255;
+	uint8 tx_pwr_max_rate_ind = 0;
+	uint8 max_num_rate;
+	uint8 start_rate = 0;
+	chanspec_t chspec;
+	uint32 band = CHSPEC2WLC_BAND(pi->radio_chanspec);
+	initfn_t txpwr_recalc_fn = NULL;
+
+	chspec = pi->radio_chanspec;
+	if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_NONE)
+		target_chan = CHSPEC_CHANNEL(chspec);
+	else if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_UPPER)
+		target_chan = UPPER_20_SB(CHSPEC_CHANNEL(chspec));
+	else
+		target_chan = LOWER_20_SB(CHSPEC_CHANNEL(chspec));
+
+	pactrl = 0;
+	if (ISLCNPHY(pi)) {
+		uint32 offset_mcs, i;
+
+		if (CHSPEC_IS40(pi->radio_chanspec)) {
+			offset_mcs = pi->mcs40_po;
+			for (i = TXP_FIRST_SISO_MCS_20;
+			     i <= TXP_LAST_SISO_MCS_20; i++) {
+				pi->tx_srom_max_rate_2g[i - 8] =
+				    pi->tx_srom_max_2g -
+				    ((offset_mcs & 0xf) * 2);
+				offset_mcs >>= 4;
+			}
+		} else {
+			offset_mcs = pi->mcs20_po;
+			for (i = TXP_FIRST_SISO_MCS_20;
+			     i <= TXP_LAST_SISO_MCS_20; i++) {
+				pi->tx_srom_max_rate_2g[i - 8] =
+				    pi->tx_srom_max_2g -
+				    ((offset_mcs & 0xf) * 2);
+				offset_mcs >>= 4;
+			}
+		}
+	}
+#if WL11N
+	max_num_rate = ((ISNPHY(pi)) ? (TXP_NUM_RATES) :
+			((ISLCNPHY(pi)) ?
+			 (TXP_LAST_SISO_MCS_20 + 1) : (TXP_LAST_OFDM + 1)));
+#else
+	max_num_rate = ((ISNPHY(pi)) ? (TXP_NUM_RATES) : (TXP_LAST_OFDM + 1));
+#endif
+
+	wlc_phy_upd_env_txpwr_rate_limits(pi, band);
+
+	for (rate = start_rate; rate < max_num_rate; rate++) {
+
+		tx_pwr_target[rate] = pi->tx_user_target[rate];
+
+		if (pi->user_txpwr_at_rfport) {
+			tx_pwr_target[rate] +=
+			    wlc_user_txpwr_antport_to_rfport(pi, target_chan,
+							     band, rate);
+		}
+
+		{
+
+			wlc_phy_txpower_sromlimit((wlc_phy_t *) pi, target_chan,
+						  &mintxpwr, &maxtxpwr, rate);
+
+			maxtxpwr = MIN(maxtxpwr, pi->txpwr_limit[rate]);
+
+			maxtxpwr =
+			    (maxtxpwr > pactrl) ? (maxtxpwr - pactrl) : 0;
+
+			maxtxpwr = (maxtxpwr > 6) ? (maxtxpwr - 6) : 0;
+
+			maxtxpwr = MIN(maxtxpwr, tx_pwr_target[rate]);
+
+			if (pi->txpwr_percent <= 100)
+				maxtxpwr = (maxtxpwr * pi->txpwr_percent) / 100;
+
+			tx_pwr_target[rate] = MAX(maxtxpwr, mintxpwr);
+		}
+
+		tx_pwr_target[rate] =
+		    MIN(tx_pwr_target[rate], pi->txpwr_env_limit[rate]);
+
+		if (tx_pwr_target[rate] > tx_pwr_max)
+			tx_pwr_max_rate_ind = rate;
+
+		tx_pwr_max = MAX(tx_pwr_max, tx_pwr_target[rate]);
+		tx_pwr_min = MIN(tx_pwr_min, tx_pwr_target[rate]);
+	}
+
+	bzero(pi->tx_power_offset, sizeof(pi->tx_power_offset));
+	pi->tx_power_max = tx_pwr_max;
+	pi->tx_power_min = tx_pwr_min;
+	pi->tx_power_max_rate_ind = tx_pwr_max_rate_ind;
+	for (rate = 0; rate < max_num_rate; rate++) {
+
+		pi->tx_power_target[rate] = tx_pwr_target[rate];
+
+		if (!pi->hwpwrctrl || ISNPHY(pi)) {
+			pi->tx_power_offset[rate] =
+			    pi->tx_power_max - pi->tx_power_target[rate];
+		} else {
+			pi->tx_power_offset[rate] =
+			    pi->tx_power_target[rate] - pi->tx_power_min;
+		}
+	}
+
+	txpwr_recalc_fn = pi->pi_fptr.txpwrrecalc;
+	if (txpwr_recalc_fn)
+		(*txpwr_recalc_fn) (pi);
+}
+
+void
+wlc_phy_txpower_reg_limit_calc(phy_info_t * pi, struct txpwr_limits *txpwr,
+			       chanspec_t chanspec)
+{
+	uint8 tmp_txpwr_limit[2 * WLC_NUM_RATES_OFDM];
+	uint8 *txpwr_ptr1 = NULL, *txpwr_ptr2 = NULL;
+	int rate_start_index = 0, rate1, rate2, k;
+
+	for (rate1 = WL_TX_POWER_CCK_FIRST, rate2 = 0;
+	     rate2 < WL_TX_POWER_CCK_NUM; rate1++, rate2++)
+		pi->txpwr_limit[rate1] = txpwr->cck[rate2];
+
+	for (rate1 = WL_TX_POWER_OFDM_FIRST, rate2 = 0;
+	     rate2 < WL_TX_POWER_OFDM_NUM; rate1++, rate2++)
+		pi->txpwr_limit[rate1] = txpwr->ofdm[rate2];
+
+	if (ISNPHY(pi)) {
+
+		for (k = 0; k < 4; k++) {
+			switch (k) {
+			case 0:
+
+				txpwr_ptr1 = txpwr->mcs_20_siso;
+				txpwr_ptr2 = txpwr->ofdm;
+				rate_start_index = WL_TX_POWER_OFDM_FIRST;
+				break;
+			case 1:
+
+				txpwr_ptr1 = txpwr->mcs_20_cdd;
+				txpwr_ptr2 = txpwr->ofdm_cdd;
+				rate_start_index = WL_TX_POWER_OFDM20_CDD_FIRST;
+				break;
+			case 2:
+
+				txpwr_ptr1 = txpwr->mcs_40_siso;
+				txpwr_ptr2 = txpwr->ofdm_40_siso;
+				rate_start_index =
+				    WL_TX_POWER_OFDM40_SISO_FIRST;
+				break;
+			case 3:
+
+				txpwr_ptr1 = txpwr->mcs_40_cdd;
+				txpwr_ptr2 = txpwr->ofdm_40_cdd;
+				rate_start_index = WL_TX_POWER_OFDM40_CDD_FIRST;
+				break;
+			}
+
+			for (rate2 = 0; rate2 < WLC_NUM_RATES_OFDM; rate2++) {
+				tmp_txpwr_limit[rate2] = 0;
+				tmp_txpwr_limit[WLC_NUM_RATES_OFDM + rate2] =
+				    txpwr_ptr1[rate2];
+			}
+			wlc_phy_mcs_to_ofdm_powers_nphy(tmp_txpwr_limit, 0,
+							WLC_NUM_RATES_OFDM - 1,
+							WLC_NUM_RATES_OFDM);
+			for (rate1 = rate_start_index, rate2 = 0;
+			     rate2 < WLC_NUM_RATES_OFDM; rate1++, rate2++)
+				pi->txpwr_limit[rate1] =
+				    MIN(txpwr_ptr2[rate2],
+					tmp_txpwr_limit[rate2]);
+		}
+
+		for (k = 0; k < 4; k++) {
+			switch (k) {
+			case 0:
+
+				txpwr_ptr1 = txpwr->ofdm;
+				txpwr_ptr2 = txpwr->mcs_20_siso;
+				rate_start_index = WL_TX_POWER_MCS20_SISO_FIRST;
+				break;
+			case 1:
+
+				txpwr_ptr1 = txpwr->ofdm_cdd;
+				txpwr_ptr2 = txpwr->mcs_20_cdd;
+				rate_start_index = WL_TX_POWER_MCS20_CDD_FIRST;
+				break;
+			case 2:
+
+				txpwr_ptr1 = txpwr->ofdm_40_siso;
+				txpwr_ptr2 = txpwr->mcs_40_siso;
+				rate_start_index = WL_TX_POWER_MCS40_SISO_FIRST;
+				break;
+			case 3:
+
+				txpwr_ptr1 = txpwr->ofdm_40_cdd;
+				txpwr_ptr2 = txpwr->mcs_40_cdd;
+				rate_start_index = WL_TX_POWER_MCS40_CDD_FIRST;
+				break;
+			}
+			for (rate2 = 0; rate2 < WLC_NUM_RATES_OFDM; rate2++) {
+				tmp_txpwr_limit[rate2] = 0;
+				tmp_txpwr_limit[WLC_NUM_RATES_OFDM + rate2] =
+				    txpwr_ptr1[rate2];
+			}
+			wlc_phy_ofdm_to_mcs_powers_nphy(tmp_txpwr_limit, 0,
+							WLC_NUM_RATES_OFDM - 1,
+							WLC_NUM_RATES_OFDM);
+			for (rate1 = rate_start_index, rate2 = 0;
+			     rate2 < WLC_NUM_RATES_MCS_1_STREAM;
+			     rate1++, rate2++)
+				pi->txpwr_limit[rate1] =
+				    MIN(txpwr_ptr2[rate2],
+					tmp_txpwr_limit[rate2]);
+		}
+
+		for (k = 0; k < 2; k++) {
+			switch (k) {
+			case 0:
+
+				rate_start_index = WL_TX_POWER_MCS20_STBC_FIRST;
+				txpwr_ptr1 = txpwr->mcs_20_stbc;
+				break;
+			case 1:
+
+				rate_start_index = WL_TX_POWER_MCS40_STBC_FIRST;
+				txpwr_ptr1 = txpwr->mcs_40_stbc;
+				break;
+			}
+			for (rate1 = rate_start_index, rate2 = 0;
+			     rate2 < WLC_NUM_RATES_MCS_1_STREAM;
+			     rate1++, rate2++)
+				pi->txpwr_limit[rate1] = txpwr_ptr1[rate2];
+		}
+
+		for (k = 0; k < 2; k++) {
+			switch (k) {
+			case 0:
+
+				rate_start_index = WL_TX_POWER_MCS20_SDM_FIRST;
+				txpwr_ptr1 = txpwr->mcs_20_mimo;
+				break;
+			case 1:
+
+				rate_start_index = WL_TX_POWER_MCS40_SDM_FIRST;
+				txpwr_ptr1 = txpwr->mcs_40_mimo;
+				break;
+			}
+			for (rate1 = rate_start_index, rate2 = 0;
+			     rate2 < WLC_NUM_RATES_MCS_2_STREAM;
+			     rate1++, rate2++)
+				pi->txpwr_limit[rate1] = txpwr_ptr1[rate2];
+		}
+
+		pi->txpwr_limit[WL_TX_POWER_MCS_32] = txpwr->mcs32;
+
+		pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST] =
+		    MIN(pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST],
+			pi->txpwr_limit[WL_TX_POWER_MCS_32]);
+		pi->txpwr_limit[WL_TX_POWER_MCS_32] =
+		    pi->txpwr_limit[WL_TX_POWER_MCS40_CDD_FIRST];
+	}
+}
+
+void wlc_phy_txpwr_percent_set(wlc_phy_t * ppi, uint8 txpwr_percent)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	pi->txpwr_percent = txpwr_percent;
+}
+
+void wlc_phy_machwcap_set(wlc_phy_t * ppi, uint32 machwcap)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	pi->sh->machwcap = machwcap;
+}
+
+void wlc_phy_runbist_config(wlc_phy_t * ppi, bool start_end)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint16 rxc;
+	rxc = 0;
+
+	if (start_end == ON) {
+		if (!ISNPHY(pi))
+			return;
+
+		if (NREV_IS(pi->pubpi.phy_rev, 3)
+		    || NREV_IS(pi->pubpi.phy_rev, 4)) {
+			W_REG(pi->sh->osh, &pi->regs->phyregaddr, 0xa0);
+			(void)R_REG(pi->sh->osh, &pi->regs->phyregaddr);
+			rxc = R_REG(pi->sh->osh, &pi->regs->phyregdata);
+			W_REG(pi->sh->osh, &pi->regs->phyregdata,
+			      (0x1 << 15) | rxc);
+		}
+	} else {
+		if (NREV_IS(pi->pubpi.phy_rev, 3)
+		    || NREV_IS(pi->pubpi.phy_rev, 4)) {
+			W_REG(pi->sh->osh, &pi->regs->phyregaddr, 0xa0);
+			(void)R_REG(pi->sh->osh, &pi->regs->phyregaddr);
+			W_REG(pi->sh->osh, &pi->regs->phyregdata, rxc);
+		}
+
+		wlc_phy_por_inform(ppi);
+	}
+}
+
+void
+wlc_phy_txpower_limit_set(wlc_phy_t * ppi, struct txpwr_limits *txpwr,
+			  chanspec_t chanspec)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	wlc_phy_txpower_reg_limit_calc(pi, txpwr, chanspec);
+
+	if (ISLCNPHY(pi)) {
+		int i, j;
+		for (i = TXP_FIRST_OFDM_20_CDD, j = 0;
+		     j < WLC_NUM_RATES_MCS_1_STREAM; i++, j++) {
+			if (txpwr->mcs_20_siso[j])
+				pi->txpwr_limit[i] = txpwr->mcs_20_siso[j];
+			else
+				pi->txpwr_limit[i] = txpwr->ofdm[j];
+		}
+	}
+
+	wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+	wlc_phy_txpower_recalc_target(pi);
+	wlc_phy_cal_txpower_recalc_sw(pi);
+	wlapi_enable_mac(pi->sh->physhim);
+}
+
+void wlc_phy_ofdm_rateset_war(wlc_phy_t * pih, bool war)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	pi->ofdm_rateset_war = war;
+}
+
+void wlc_phy_bf_preempt_enable(wlc_phy_t * pih, bool bf_preempt)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	pi->bf_preempt_4306 = bf_preempt;
+}
+
+void wlc_phy_txpower_update_shm(phy_info_t * pi)
+{
+	int j;
+	if (ISNPHY(pi)) {
+		ASSERT(0);
+		return;
+	}
+
+	if (!pi->sh->clk)
+		return;
+
+	if (pi->hwpwrctrl) {
+		uint16 offset;
+
+		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_MAX, 63);
+		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_N,
+				     1 << NUM_TSSI_FRAMES);
+
+		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_TARGET,
+				     pi->tx_power_min << NUM_TSSI_FRAMES);
+
+		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_CUR,
+				     pi->hwpwr_txcur);
+
+		for (j = TXP_FIRST_OFDM; j <= TXP_LAST_OFDM; j++) {
+			const uint8 ucode_ofdm_rates[] = {
+				0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c
+			};
+			offset = wlapi_bmac_rate_shm_offset(pi->sh->physhim,
+							    ucode_ofdm_rates[j -
+									     TXP_FIRST_OFDM]);
+			wlapi_bmac_write_shm(pi->sh->physhim, offset + 6,
+					     pi->tx_power_offset[j]);
+			wlapi_bmac_write_shm(pi->sh->physhim, offset + 14,
+					     -(pi->tx_power_offset[j] / 2));
+		}
+
+		wlapi_bmac_mhf(pi->sh->physhim, MHF2, MHF2_HWPWRCTL,
+			       MHF2_HWPWRCTL, WLC_BAND_ALL);
+	} else {
+		int i;
+
+		for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++)
+			pi->tx_power_offset[i] =
+			    (uint8) ROUNDUP(pi->tx_power_offset[i], 8);
+		wlapi_bmac_write_shm(pi->sh->physhim, M_OFDM_OFFSET,
+				     (uint16) ((pi->
+						tx_power_offset[TXP_FIRST_OFDM]
+						+ 7) >> 3));
+	}
+}
+
+bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t * ppi)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	if (ISNPHY(pi)) {
+		return pi->nphy_txpwrctrl;
+	} else {
+		return pi->hwpwrctrl;
+	}
+}
+
+void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t * ppi, bool hwpwrctrl)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	bool cur_hwpwrctrl = pi->hwpwrctrl;
+	bool suspend;
+
+	if (!pi->hwpwrctrl_capable) {
+		return;
+	}
+
+	pi->hwpwrctrl = hwpwrctrl;
+	pi->nphy_txpwrctrl = hwpwrctrl;
+	pi->txpwrctrl = hwpwrctrl;
+
+	if (ISNPHY(pi)) {
+		suspend =
+		    (0 ==
+		     (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+		if (!suspend)
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+		wlc_phy_txpwrctrl_enable_nphy(pi, pi->nphy_txpwrctrl);
+		if (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF) {
+			wlc_phy_txpwr_fixpower_nphy(pi);
+		} else {
+
+			mod_phy_reg(pi, 0x1e7, (0x7f << 0),
+				    pi->saved_txpwr_idx);
+		}
+
+		if (!suspend)
+			wlapi_enable_mac(pi->sh->physhim);
+	} else if (hwpwrctrl != cur_hwpwrctrl) {
+
+		return;
+	}
+}
+
+void wlc_phy_txpower_ipa_upd(phy_info_t * pi)
+{
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		pi->ipa2g_on = (pi->srom_fem2g.extpagain == 2);
+		pi->ipa5g_on = (pi->srom_fem5g.extpagain == 2);
+	} else {
+		pi->ipa2g_on = FALSE;
+		pi->ipa5g_on = FALSE;
+	}
+}
+
+static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi);
+
+static uint32 wlc_phy_txpower_est_power_nphy(phy_info_t * pi)
+{
+	int16 tx0_status, tx1_status;
+	uint16 estPower1, estPower2;
+	uint8 pwr0, pwr1, adj_pwr0, adj_pwr1;
+	uint32 est_pwr;
+
+	estPower1 = read_phy_reg(pi, 0x118);
+	estPower2 = read_phy_reg(pi, 0x119);
+
+	if ((estPower1 & (0x1 << 8))
+	    == (0x1 << 8)) {
+		pwr0 = (uint8) (estPower1 & (0xff << 0))
+		    >> 0;
+	} else {
+		pwr0 = 0x80;
+	}
+
+	if ((estPower2 & (0x1 << 8))
+	    == (0x1 << 8)) {
+		pwr1 = (uint8) (estPower2 & (0xff << 0))
+		    >> 0;
+	} else {
+		pwr1 = 0x80;
+	}
+
+	tx0_status = read_phy_reg(pi, 0x1ed);
+	tx1_status = read_phy_reg(pi, 0x1ee);
+
+	if ((tx0_status & (0x1 << 15))
+	    == (0x1 << 15)) {
+		adj_pwr0 = (uint8) (tx0_status & (0xff << 0))
+		    >> 0;
+	} else {
+		adj_pwr0 = 0x80;
+	}
+	if ((tx1_status & (0x1 << 15))
+	    == (0x1 << 15)) {
+		adj_pwr1 = (uint8) (tx1_status & (0xff << 0))
+		    >> 0;
+	} else {
+		adj_pwr1 = 0x80;
+	}
+
+	est_pwr =
+	    (uint32) ((pwr0 << 24) | (pwr1 << 16) | (adj_pwr0 << 8) | adj_pwr1);
+	return (est_pwr);
+}
+
+void
+wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power, uint channel)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint rate, num_rates;
+	uint8 min_pwr, max_pwr;
+
+#if WL_TX_POWER_RATES != TXP_NUM_RATES
+#error "tx_power_t struct out of sync with this fn"
+#endif
+
+	if (ISNPHY(pi)) {
+		power->rf_cores = 2;
+		power->flags |= (WL_TX_POWER_F_MIMO);
+		if (pi->nphy_txpwrctrl == PHY_TPC_HW_ON)
+			power->flags |=
+			    (WL_TX_POWER_F_ENABLED | WL_TX_POWER_F_HW);
+	} else if (ISLCNPHY(pi)) {
+		power->rf_cores = 1;
+		power->flags |= (WL_TX_POWER_F_SISO);
+		if (pi->radiopwr_override == RADIOPWR_OVERRIDE_DEF)
+			power->flags |= WL_TX_POWER_F_ENABLED;
+		if (pi->hwpwrctrl)
+			power->flags |= WL_TX_POWER_F_HW;
+	}
+
+	num_rates = ((ISNPHY(pi)) ? (TXP_NUM_RATES) :
+		     ((ISLCNPHY(pi)) ?
+		      (TXP_LAST_OFDM_20_CDD + 1) : (TXP_LAST_OFDM + 1)));
+
+	for (rate = 0; rate < num_rates; rate++) {
+		power->user_limit[rate] = pi->tx_user_target[rate];
+		wlc_phy_txpower_sromlimit(ppi, channel, &min_pwr, &max_pwr,
+					  rate);
+		power->board_limit[rate] = (uint8) max_pwr;
+		power->target[rate] = pi->tx_power_target[rate];
+	}
+
+	if (ISNPHY(pi)) {
+		uint32 est_pout;
+
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+		wlc_phyreg_enter((wlc_phy_t *) pi);
+		est_pout = wlc_phy_txpower_est_power_nphy(pi);
+		wlc_phyreg_exit((wlc_phy_t *) pi);
+		wlapi_enable_mac(pi->sh->physhim);
+
+		power->est_Pout[0] = (est_pout >> 8) & 0xff;
+		power->est_Pout[1] = est_pout & 0xff;
+
+		power->est_Pout_act[0] = est_pout >> 24;
+		power->est_Pout_act[1] = (est_pout >> 16) & 0xff;
+
+		if (power->est_Pout[0] == 0x80)
+			power->est_Pout[0] = 0;
+		if (power->est_Pout[1] == 0x80)
+			power->est_Pout[1] = 0;
+
+		if (power->est_Pout_act[0] == 0x80)
+			power->est_Pout_act[0] = 0;
+		if (power->est_Pout_act[1] == 0x80)
+			power->est_Pout_act[1] = 0;
+
+		power->est_Pout_cck = 0;
+
+		power->tx_power_max[0] = pi->tx_power_max;
+		power->tx_power_max[1] = pi->tx_power_max;
+
+		power->tx_power_max_rate_ind[0] = pi->tx_power_max_rate_ind;
+		power->tx_power_max_rate_ind[1] = pi->tx_power_max_rate_ind;
+	} else if (!pi->hwpwrctrl) {
+	} else if (pi->sh->up) {
+
+		wlc_phyreg_enter(ppi);
+		if (ISLCNPHY(pi)) {
+
+			power->tx_power_max[0] = pi->tx_power_max;
+			power->tx_power_max[1] = pi->tx_power_max;
+
+			power->tx_power_max_rate_ind[0] =
+			    pi->tx_power_max_rate_ind;
+			power->tx_power_max_rate_ind[1] =
+			    pi->tx_power_max_rate_ind;
+
+			if (wlc_phy_tpc_isenabled_lcnphy(pi))
+				power->flags |=
+				    (WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
+			else
+				power->flags &=
+				    ~(WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
+
+			wlc_lcnphy_get_tssi(pi, (int8 *) & power->est_Pout[0],
+					    (int8 *) & power->est_Pout_cck);
+		}
+		wlc_phyreg_exit(ppi);
+	}
+}
+
+void wlc_phy_antsel_type_set(wlc_phy_t * ppi, uint8 antsel_type)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	pi->antsel_type = antsel_type;
+}
+
+bool wlc_phy_test_ison(wlc_phy_t * ppi)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	return (pi->phytest_on);
+}
+
+bool wlc_phy_ant_rxdiv_get(wlc_phy_t * ppi, uint8 * pval)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	bool ret = TRUE;
+
+	wlc_phyreg_enter(ppi);
+
+	if (ISNPHY(pi)) {
+
+		ret = FALSE;
+	} else if (ISLCNPHY(pi)) {
+		uint16 crsctrl = read_phy_reg(pi, 0x410);
+		uint16 div = crsctrl & (0x1 << 1);
+		*pval = (div | ((crsctrl & (0x1 << 0)) ^ (div >> 1)));
+	}
+
+	wlc_phyreg_exit(ppi);
+
+	return ret;
+}
+
+void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	bool suspend;
+
+	pi->sh->rx_antdiv = val;
+
+	if (!(ISNPHY(pi) && D11REV_IS(pi->sh->corerev, 16))) {
+		if (val > ANT_RX_DIV_FORCE_1)
+			wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV,
+				       MHF1_ANTDIV, WLC_BAND_ALL);
+		else
+			wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV, 0,
+				       WLC_BAND_ALL);
+	}
+
+	if (ISNPHY(pi)) {
+
+		return;
+	}
+
+	if (!pi->sh->clk)
+		return;
+
+	suspend =
+	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+	if (!suspend)
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+	if (ISLCNPHY(pi)) {
+		if (val > ANT_RX_DIV_FORCE_1) {
+			mod_phy_reg(pi, 0x410, (0x1 << 1), 0x01 << 1);
+			mod_phy_reg(pi, 0x410,
+				    (0x1 << 0),
+				    ((ANT_RX_DIV_START_1 == val) ? 1 : 0) << 0);
+		} else {
+			mod_phy_reg(pi, 0x410, (0x1 << 1), 0x00 << 1);
+			mod_phy_reg(pi, 0x410, (0x1 << 0), (uint16) val << 0);
+		}
+	} else {
+		ASSERT(0);
+	}
+
+	if (!suspend)
+		wlapi_enable_mac(pi->sh->physhim);
+
+	return;
+}
+
+static bool
+wlc_phy_noise_calc_phy(phy_info_t * pi, uint32 * cmplx_pwr, int8 * pwr_ant)
+{
+	int8 cmplx_pwr_dbm[PHY_CORE_MAX];
+	uint8 i;
+
+	bzero((uint8 *) cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));
+	ASSERT(pi->pubpi.phy_corenum <= PHY_CORE_MAX);
+	wlc_phy_compute_dB(cmplx_pwr, cmplx_pwr_dbm, pi->pubpi.phy_corenum);
+
+	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
+		if (NREV_GE(pi->pubpi.phy_rev, 3))
+			cmplx_pwr_dbm[i] += (int8) PHY_NOISE_OFFSETFACT_4322;
+		else
+
+			cmplx_pwr_dbm[i] += (int8) (16 - (15) * 3 - 70);
+	}
+
+	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
+		pi->nphy_noise_win[i][pi->nphy_noise_index] = cmplx_pwr_dbm[i];
+		pwr_ant[i] = cmplx_pwr_dbm[i];
+	}
+	pi->nphy_noise_index =
+	    MODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);
+	return TRUE;
+}
+
+static void
+wlc_phy_noise_sample_request(wlc_phy_t * pih, uint8 reason, uint8 ch)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	bool sampling_in_progress = (pi->phynoise_state != 0);
+	bool wait_for_intr = TRUE;
+
+	if (NORADIO_ENAB(pi->pubpi)) {
+		return;
+	}
+
+	switch (reason) {
+	case PHY_NOISE_SAMPLE_MON:
+
+		pi->phynoise_chan_watchdog = ch;
+		pi->phynoise_state |= PHY_NOISE_STATE_MON;
+
+		break;
+
+	case PHY_NOISE_SAMPLE_EXTERNAL:
+
+		pi->phynoise_state |= PHY_NOISE_STATE_EXTERNAL;
+		break;
+
+	default:
+		ASSERT(0);
+		break;
+	}
+
+	if (sampling_in_progress)
+		return;
+
+	pi->phynoise_now = pi->sh->now;
+
+	if (pi->phy_fixed_noise) {
+		if (ISNPHY(pi)) {
+			pi->nphy_noise_win[WL_ANT_IDX_1][pi->nphy_noise_index] =
+			    PHY_NOISE_FIXED_VAL_NPHY;
+			pi->nphy_noise_win[WL_ANT_IDX_2][pi->nphy_noise_index] =
+			    PHY_NOISE_FIXED_VAL_NPHY;
+			pi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,
+							   PHY_NOISE_WINDOW_SZ);
+
+			noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+		} else {
+
+			noise_dbm = PHY_NOISE_FIXED_VAL;
+		}
+
+		wait_for_intr = FALSE;
+		goto done;
+	}
+
+	if (ISLCNPHY(pi)) {
+		if (!pi->phynoise_polling
+		    || (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {
+			wlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_0, 0);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);
+
+			OR_REG(pi->sh->osh, &pi->regs->maccommand,
+			       MCMD_BG_NOISE);
+		} else {
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+			wlc_lcnphy_deaf_mode(pi, (bool) 0);
+			noise_dbm = (int8) wlc_lcnphy_rx_signal_power(pi, 20);
+			wlc_lcnphy_deaf_mode(pi, (bool) 1);
+			wlapi_enable_mac(pi->sh->physhim);
+			wait_for_intr = FALSE;
+		}
+	} else if (ISNPHY(pi)) {
+		if (!pi->phynoise_polling
+		    || (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {
+
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);
+
+			OR_REG(pi->sh->osh, &pi->regs->maccommand,
+			       MCMD_BG_NOISE);
+		} else {
+			phy_iq_est_t est[PHY_CORE_MAX];
+			uint32 cmplx_pwr[PHY_CORE_MAX];
+			int8 noise_dbm_ant[PHY_CORE_MAX];
+			uint16 log_num_samps, num_samps, classif_state = 0;
+			uint8 wait_time = 32;
+			uint8 wait_crs = 0;
+			uint8 i;
+
+			bzero((uint8 *) est, sizeof(est));
+			bzero((uint8 *) cmplx_pwr, sizeof(cmplx_pwr));
+			bzero((uint8 *) noise_dbm_ant, sizeof(noise_dbm_ant));
+
+			log_num_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;
+			num_samps = 1 << log_num_samps;
+
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+			classif_state = wlc_phy_classifier_nphy(pi, 0, 0);
+			wlc_phy_classifier_nphy(pi, 3, 0);
+			wlc_phy_rx_iq_est_nphy(pi, est, num_samps, wait_time,
+					       wait_crs);
+			wlc_phy_classifier_nphy(pi, (0x7 << 0), classif_state);
+			wlapi_enable_mac(pi->sh->physhim);
+
+			for (i = 0; i < pi->pubpi.phy_corenum; i++)
+				cmplx_pwr[i] =
+				    (est[i].i_pwr +
+				     est[i].q_pwr) >> log_num_samps;
+
+			wlc_phy_noise_calc_phy(pi, cmplx_pwr, noise_dbm_ant);
+
+			for (i = 0; i < pi->pubpi.phy_corenum; i++) {
+				pi->nphy_noise_win[i][pi->nphy_noise_index] =
+				    noise_dbm_ant[i];
+
+				if (noise_dbm_ant[i] > noise_dbm)
+					noise_dbm = noise_dbm_ant[i];
+			}
+			pi->nphy_noise_index = MODINC_POW2(pi->nphy_noise_index,
+							   PHY_NOISE_WINDOW_SZ);
+
+			wait_for_intr = FALSE;
+		}
+	}
+
+ done:
+
+	if (!wait_for_intr)
+		wlc_phy_noise_cb(pi, ch, noise_dbm);
+
+}
+
+void wlc_phy_noise_sample_request_external(wlc_phy_t * pih)
+{
+	uint8 channel;
+
+	channel = CHSPEC_CHANNEL(wlc_phy_chanspec_get(pih));
+
+	wlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_EXTERNAL, channel);
+}
+
+static void wlc_phy_noise_cb(phy_info_t * pi, uint8 channel, int8 noise_dbm)
+{
+	if (!pi->phynoise_state)
+		return;
+
+	if (pi->phynoise_state & PHY_NOISE_STATE_MON) {
+		if (pi->phynoise_chan_watchdog == channel) {
+			pi->sh->phy_noise_window[pi->sh->phy_noise_index] =
+			    noise_dbm;
+			pi->sh->phy_noise_index =
+			    MODINC(pi->sh->phy_noise_index, MA_WINDOW_SZ);
+		}
+		pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
+	}
+
+	if (pi->phynoise_state & PHY_NOISE_STATE_EXTERNAL) {
+		pi->phynoise_state &= ~PHY_NOISE_STATE_EXTERNAL;
+	}
+
+}
+
+static int8 wlc_phy_noise_read_shmem(phy_info_t * pi)
+{
+	uint32 cmplx_pwr[PHY_CORE_MAX];
+	int8 noise_dbm_ant[PHY_CORE_MAX];
+	uint16 lo, hi;
+	uint32 cmplx_pwr_tot = 0;
+	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+	uint8 idx, core;
+
+	ASSERT(pi->pubpi.phy_corenum <= PHY_CORE_MAX);
+	bzero((uint8 *) cmplx_pwr, sizeof(cmplx_pwr));
+	bzero((uint8 *) noise_dbm_ant, sizeof(noise_dbm_ant));
+
+	for (idx = 0, core = 0; core < pi->pubpi.phy_corenum; idx += 2, core++) {
+		lo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(idx));
+		hi = wlapi_bmac_read_shm(pi->sh->physhim,
+					 M_PWRIND_MAP(idx + 1));
+		cmplx_pwr[core] = (hi << 16) + lo;
+		cmplx_pwr_tot += cmplx_pwr[core];
+		if (cmplx_pwr[core] == 0) {
+			noise_dbm_ant[core] = PHY_NOISE_FIXED_VAL_NPHY;
+		} else
+			cmplx_pwr[core] >>= PHY_NOISE_SAMPLE_LOG_NUM_UCODE;
+	}
+
+	if (cmplx_pwr_tot != 0)
+		wlc_phy_noise_calc_phy(pi, cmplx_pwr, noise_dbm_ant);
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+		pi->nphy_noise_win[core][pi->nphy_noise_index] =
+		    noise_dbm_ant[core];
+
+		if (noise_dbm_ant[core] > noise_dbm)
+			noise_dbm = noise_dbm_ant[core];
+	}
+	pi->nphy_noise_index =
+	    MODINC_POW2(pi->nphy_noise_index, PHY_NOISE_WINDOW_SZ);
+
+	return noise_dbm;
+
+}
+
+void wlc_phy_noise_sample_intr(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	uint16 jssi_aux;
+	uint8 channel = 0;
+	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
+
+	if (ISLCNPHY(pi)) {
+		uint32 cmplx_pwr, cmplx_pwr0, cmplx_pwr1;
+		uint16 lo, hi;
+		int32 pwr_offset_dB, gain_dB;
+		uint16 status_0, status_1;
+
+		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
+		channel = jssi_aux & D11_CURCHANNEL_MAX;
+
+		lo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP0);
+		hi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP1);
+		cmplx_pwr0 = (hi << 16) + lo;
+
+		lo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP2);
+		hi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP3);
+		cmplx_pwr1 = (hi << 16) + lo;
+		cmplx_pwr = (cmplx_pwr0 + cmplx_pwr1) >> 6;
+
+		status_0 = 0x44;
+		status_1 = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_0);
+		if ((cmplx_pwr > 0 && cmplx_pwr < 500)
+		    && ((status_1 & 0xc000) == 0x4000)) {
+
+			wlc_phy_compute_dB(&cmplx_pwr, &noise_dbm,
+					   pi->pubpi.phy_corenum);
+			pwr_offset_dB = (read_phy_reg(pi, 0x434) & 0xFF);
+			if (pwr_offset_dB > 127)
+				pwr_offset_dB -= 256;
+
+			noise_dbm += (int8) (pwr_offset_dB - 30);
+
+			gain_dB = (status_0 & 0x1ff);
+			noise_dbm -= (int8) (gain_dB);
+		} else {
+			noise_dbm = PHY_NOISE_FIXED_VAL_LCNPHY;
+		}
+	} else if (ISNPHY(pi)) {
+
+		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
+		channel = jssi_aux & D11_CURCHANNEL_MAX;
+
+		noise_dbm = wlc_phy_noise_read_shmem(pi);
+	} else {
+		ASSERT(0);
+	}
+
+	wlc_phy_noise_cb(pi, channel, noise_dbm);
+
+}
+
+int8 lcnphy_gain_index_offset_for_pkt_rssi[] = {
+	8,
+	8,
+	8,
+	8,
+	8,
+	8,
+	8,
+	9,
+	10,
+	8,
+	8,
+	7,
+	7,
+	1,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	1,
+	1,
+	0,
+	0,
+	0,
+	0
+};
+
+void wlc_phy_compute_dB(uint32 * cmplx_pwr, int8 * p_cmplx_pwr_dB, uint8 core)
+{
+	uint8 shift_ct, lsb, msb, secondmsb, i;
+	uint32 tmp;
+
+	for (i = 0; i < core; i++) {
+		tmp = cmplx_pwr[i];
+		shift_ct = msb = secondmsb = 0;
+		while (tmp != 0) {
+			tmp = tmp >> 1;
+			shift_ct++;
+			lsb = (uint8) (tmp & 1);
+			if (lsb == 1)
+				msb = shift_ct;
+		}
+		secondmsb = (uint8) ((cmplx_pwr[i] >> (msb - 1)) & 1);
+		p_cmplx_pwr_dB[i] = (int8) (3 * msb + 2 * secondmsb);
+	}
+}
+
+void BCMFASTPATH wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx)
+{
+	wlc_d11rxhdr_t *wlc_rxhdr = (wlc_d11rxhdr_t *) ctx;
+	d11rxhdr_t *rxh = &wlc_rxhdr->rxhdr;
+	int rssi = ltoh16(rxh->PhyRxStatus_1) & PRXS1_JSSI_MASK;
+	uint radioid = pih->radioid;
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (NORADIO_ENAB(pi->pubpi)) {
+		rssi = WLC_RSSI_INVALID;
+		goto end;
+	}
+
+	if ((pi->sh->corerev >= 11)
+	    && !(ltoh16(rxh->RxStatus2) & RXS_PHYRXST_VALID)) {
+		rssi = WLC_RSSI_INVALID;
+		goto end;
+	}
+
+	if (ISLCNPHY(pi)) {
+		uint8 gidx = (ltoh16(rxh->PhyRxStatus_2) & 0xFC00) >> 10;
+		phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+		if (rssi > 127)
+			rssi -= 256;
+
+		rssi = rssi + lcnphy_gain_index_offset_for_pkt_rssi[gidx];
+		if ((rssi > -46) && (gidx > 18))
+			rssi = rssi + 7;
+
+		rssi = rssi + pi_lcn->lcnphy_pkteng_rssi_slope;
+
+		rssi = rssi + 2;
+
+	}
+
+	if (ISLCNPHY(pi)) {
+
+		if (rssi > 127)
+			rssi -= 256;
+	} else if (radioid == BCM2055_ID || radioid == BCM2056_ID
+		   || radioid == BCM2057_ID) {
+		ASSERT(ISNPHY(pi));
+		rssi = wlc_phy_rssi_compute_nphy(pi, wlc_rxhdr);
+	} else {
+		ASSERT((const char *)"Unknown radio" == NULL);
+	}
+
+ end:
+	wlc_rxhdr->rssi = (int8) rssi;
+}
+
+void wlc_phy_freqtrack_start(wlc_phy_t * pih)
+{
+	return;
+}
+
+void wlc_phy_freqtrack_end(wlc_phy_t * pih)
+{
+	return;
+}
+
+void wlc_phy_set_deaf(wlc_phy_t * ppi, bool user_flag)
+{
+	phy_info_t *pi;
+	pi = (phy_info_t *) ppi;
+
+	if (ISLCNPHY(pi))
+		wlc_lcnphy_deaf_mode(pi, TRUE);
+	else if (ISNPHY(pi))
+		wlc_nphy_deaf_mode(pi, TRUE);
+	else {
+		ASSERT(0);
+	}
+}
+
+void wlc_phy_watchdog(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	bool delay_phy_cal = FALSE;
+	pi->sh->now++;
+
+	if (!pi->watchdog_override)
+		return;
+
+	if (!(SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi))) {
+		wlc_phy_noise_sample_request((wlc_phy_t *) pi,
+					     PHY_NOISE_SAMPLE_MON,
+					     CHSPEC_CHANNEL(pi->
+							    radio_chanspec));
+	}
+
+	if (pi->phynoise_state && (pi->sh->now - pi->phynoise_now) > 5) {
+		pi->phynoise_state = 0;
+	}
+
+	if ((!pi->phycal_txpower) ||
+	    ((pi->sh->now - pi->phycal_txpower) >= pi->sh->fast_timer)) {
+
+		if (!SCAN_INPROG_PHY(pi) && wlc_phy_cal_txpower_recalc_sw(pi)) {
+			pi->phycal_txpower = pi->sh->now;
+		}
+	}
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	if ((SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)
+	     || ASSOC_INPROG_PHY(pi)))
+		return;
+
+	if (ISNPHY(pi) && !pi->disable_percal && !delay_phy_cal) {
+
+		if ((pi->nphy_perical != PHY_PERICAL_DISABLE) &&
+		    (pi->nphy_perical != PHY_PERICAL_MANUAL) &&
+		    ((pi->sh->now - pi->nphy_perical_last) >=
+		     pi->sh->glacial_timer))
+			wlc_phy_cal_perical((wlc_phy_t *) pi,
+					    PHY_PERICAL_WATCHDOG);
+
+		wlc_phy_txpwr_papd_cal_nphy(pi);
+	}
+
+	if (ISLCNPHY(pi)) {
+		if (pi->phy_forcecal ||
+		    ((pi->sh->now - pi->phy_lastcal) >=
+		     pi->sh->glacial_timer)) {
+			if (!(SCAN_RM_IN_PROGRESS(pi) || ASSOC_INPROG_PHY(pi)))
+				wlc_lcnphy_calib_modes(pi,
+						       LCNPHY_PERICAL_TEMPBASED_TXPWRCTRL);
+			if (!
+			    (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi)
+			     || ASSOC_INPROG_PHY(pi)
+			     || pi->carrier_suppr_disable
+			     || pi->pkteng_in_progress || pi->disable_percal))
+				wlc_lcnphy_calib_modes(pi,
+						       PHY_PERICAL_WATCHDOG);
+		}
+	}
+}
+
+void wlc_phy_BSSinit(wlc_phy_t * pih, bool bonlyap, int rssi)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	uint i;
+	uint k;
+
+	for (i = 0; i < MA_WINDOW_SZ; i++) {
+		pi->sh->phy_noise_window[i] = (int8) (rssi & 0xff);
+	}
+	if (ISLCNPHY(pi)) {
+		for (i = 0; i < MA_WINDOW_SZ; i++)
+			pi->sh->phy_noise_window[i] =
+			    PHY_NOISE_FIXED_VAL_LCNPHY;
+	}
+	pi->sh->phy_noise_index = 0;
+
+	for (i = 0; i < PHY_NOISE_WINDOW_SZ; i++) {
+		for (k = WL_ANT_IDX_1; k < WL_ANT_RX_MAX; k++)
+			pi->nphy_noise_win[k][i] = PHY_NOISE_FIXED_VAL_NPHY;
+	}
+	pi->nphy_noise_index = 0;
+}
+
+void
+wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 * eps_real, int32 * eps_imag)
+{
+	if ((*eps_imag = (epsilon >> 13)) > 0xfff)
+		*eps_imag -= 0x2000;
+	if ((*eps_real = (epsilon & 0x1fff)) > 0xfff)
+		*eps_real -= 0x2000;
+}
+
+static const fixed AtanTbl[] = {
+	2949120,
+	1740967,
+	919879,
+	466945,
+	234379,
+	117304,
+	58666,
+	29335,
+	14668,
+	7334,
+	3667,
+	1833,
+	917,
+	458,
+	229,
+	115,
+	57,
+	29
+};
+
+void wlc_phy_cordic(fixed theta, cint32 * val)
+{
+	fixed angle, valtmp;
+	unsigned iter;
+	int signx = 1;
+	int signtheta;
+
+	val[0].i = CORDIC_AG;
+	val[0].q = 0;
+	angle = 0;
+
+	signtheta = (theta < 0) ? -1 : 1;
+	theta =
+	    ((theta + FIXED(180) * signtheta) % FIXED(360)) -
+	    FIXED(180) * signtheta;
+
+	if (FLOAT(theta) > 90) {
+		theta -= FIXED(180);
+		signx = -1;
+	} else if (FLOAT(theta) < -90) {
+		theta += FIXED(180);
+		signx = -1;
+	}
+
+	for (iter = 0; iter < CORDIC_NI; iter++) {
+		if (theta > angle) {
+			valtmp = val[0].i - (val[0].q >> iter);
+			val[0].q = (val[0].i >> iter) + val[0].q;
+			val[0].i = valtmp;
+			angle += AtanTbl[iter];
+		} else {
+			valtmp = val[0].i + (val[0].q >> iter);
+			val[0].q = -(val[0].i >> iter) + val[0].q;
+			val[0].i = valtmp;
+			angle -= AtanTbl[iter];
+		}
+	}
+
+	val[0].i = val[0].i * signx;
+	val[0].q = val[0].q * signx;
+}
+
+void wlc_phy_cal_perical_mphase_reset(phy_info_t * pi)
+{
+	wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);
+
+	pi->cal_type_override = PHY_PERICAL_AUTO;
+	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_IDLE;
+	pi->mphase_txcal_cmdidx = 0;
+}
+
+static void wlc_phy_cal_perical_mphase_schedule(phy_info_t * pi, uint delay)
+{
+
+	if ((pi->nphy_perical != PHY_PERICAL_MPHASE) &&
+	    (pi->nphy_perical != PHY_PERICAL_MANUAL))
+		return;
+
+	wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);
+
+	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;
+	wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, delay, 0);
+}
+
+void wlc_phy_cal_perical(wlc_phy_t * pih, uint8 reason)
+{
+	int16 nphy_currtemp = 0;
+	int16 delta_temp = 0;
+	bool do_periodic_cal = TRUE;
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	if (!ISNPHY(pi))
+		return;
+
+	if ((pi->nphy_perical == PHY_PERICAL_DISABLE) ||
+	    (pi->nphy_perical == PHY_PERICAL_MANUAL))
+		return;
+
+	switch (reason) {
+	case PHY_PERICAL_DRIVERUP:
+		break;
+
+	case PHY_PERICAL_PHYINIT:
+		if (pi->nphy_perical == PHY_PERICAL_MPHASE) {
+			if (PHY_PERICAL_MPHASE_PENDING(pi)) {
+				wlc_phy_cal_perical_mphase_reset(pi);
+			}
+			wlc_phy_cal_perical_mphase_schedule(pi,
+							    PHY_PERICAL_INIT_DELAY);
+		}
+		break;
+
+	case PHY_PERICAL_JOIN_BSS:
+	case PHY_PERICAL_START_IBSS:
+	case PHY_PERICAL_UP_BSS:
+		if ((pi->nphy_perical == PHY_PERICAL_MPHASE) &&
+		    PHY_PERICAL_MPHASE_PENDING(pi)) {
+			wlc_phy_cal_perical_mphase_reset(pi);
+		}
+
+		pi->first_cal_after_assoc = TRUE;
+
+		pi->cal_type_override = PHY_PERICAL_FULL;
+
+		if (pi->phycal_tempdelta) {
+			pi->nphy_lastcal_temp = wlc_phy_tempsense_nphy(pi);
+		}
+		wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_FULL);
+		break;
+
+	case PHY_PERICAL_WATCHDOG:
+		if (pi->phycal_tempdelta) {
+			nphy_currtemp = wlc_phy_tempsense_nphy(pi);
+			delta_temp =
+			    (nphy_currtemp > pi->nphy_lastcal_temp) ?
+			    nphy_currtemp - pi->nphy_lastcal_temp :
+			    pi->nphy_lastcal_temp - nphy_currtemp;
+
+			if ((delta_temp < (int16) pi->phycal_tempdelta) &&
+			    (pi->nphy_txiqlocal_chanspec ==
+			     pi->radio_chanspec)) {
+				do_periodic_cal = FALSE;
+			} else {
+				pi->nphy_lastcal_temp = nphy_currtemp;
+			}
+		}
+
+		if (do_periodic_cal) {
+
+			if (pi->nphy_perical == PHY_PERICAL_MPHASE) {
+
+				if (!PHY_PERICAL_MPHASE_PENDING(pi))
+					wlc_phy_cal_perical_mphase_schedule(pi,
+									    PHY_PERICAL_WDOG_DELAY);
+			} else if (pi->nphy_perical == PHY_PERICAL_SPHASE)
+				wlc_phy_cal_perical_nphy_run(pi,
+							     PHY_PERICAL_AUTO);
+			else {
+				ASSERT(0);
+			}
+		}
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+}
+
+void wlc_phy_cal_perical_mphase_restart(phy_info_t * pi)
+{
+	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_INIT;
+	pi->mphase_txcal_cmdidx = 0;
+}
+
+uint8 wlc_phy_nbits(int32 value)
+{
+	int32 abs_val;
+	uint8 nbits = 0;
+
+	abs_val = ABS(value);
+	while ((abs_val >> nbits) > 0)
+		nbits++;
+
+	return nbits;
+}
+
+uint32 wlc_phy_sqrt_int(uint32 value)
+{
+	uint32 root = 0, shift = 0;
+
+	for (shift = 0; shift < 32; shift += 2) {
+		if (((0x40000000 >> shift) + root) <= value) {
+			value -= ((0x40000000 >> shift) + root);
+			root = (root >> 1) | (0x40000000 >> shift);
+		} else {
+			root = root >> 1;
+		}
+	}
+
+	if (root < value)
+		++root;
+
+	return root;
+}
+
+void wlc_phy_stf_chain_init(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	pi->sh->hw_phytxchain = txchain;
+	pi->sh->hw_phyrxchain = rxchain;
+	pi->sh->phytxchain = txchain;
+	pi->sh->phyrxchain = rxchain;
+	pi->pubpi.phy_corenum = (uint8) PHY_BITSCNT(pi->sh->phyrxchain);
+}
+
+void wlc_phy_stf_chain_set(wlc_phy_t * pih, uint8 txchain, uint8 rxchain)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	pi->sh->phytxchain = txchain;
+
+	if (ISNPHY(pi)) {
+		wlc_phy_rxcore_setstate_nphy(pih, rxchain);
+	}
+	pi->pubpi.phy_corenum = (uint8) PHY_BITSCNT(pi->sh->phyrxchain);
+}
+
+void wlc_phy_stf_chain_get(wlc_phy_t * pih, uint8 * txchain, uint8 * rxchain)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	*txchain = pi->sh->phytxchain;
+	*rxchain = pi->sh->phyrxchain;
+}
+
+uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih)
+{
+	int16 nphy_currtemp;
+	uint8 active_bitmap;
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	active_bitmap = (pi->phy_txcore_heatedup) ? 0x31 : 0x33;
+
+	if (!pi->watchdog_override)
+		return active_bitmap;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+		nphy_currtemp = wlc_phy_tempsense_nphy(pi);
+		wlapi_enable_mac(pi->sh->physhim);
+
+		if (!pi->phy_txcore_heatedup) {
+			if (nphy_currtemp >= pi->phy_txcore_disable_temp) {
+				active_bitmap &= 0xFD;
+				pi->phy_txcore_heatedup = TRUE;
+			}
+		} else {
+			if (nphy_currtemp <= pi->phy_txcore_enable_temp) {
+				active_bitmap |= 0x2;
+				pi->phy_txcore_heatedup = FALSE;
+			}
+		}
+	}
+
+	return active_bitmap;
+}
+
+int8 wlc_phy_stf_ssmode_get(wlc_phy_t * pih, chanspec_t chanspec)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	uint8 siso_mcs_id, cdd_mcs_id;
+
+	siso_mcs_id =
+	    (CHSPEC_IS40(chanspec)) ? TXP_FIRST_MCS_40_SISO :
+	    TXP_FIRST_MCS_20_SISO;
+	cdd_mcs_id =
+	    (CHSPEC_IS40(chanspec)) ? TXP_FIRST_MCS_40_CDD :
+	    TXP_FIRST_MCS_20_CDD;
+
+	if (pi->tx_power_target[siso_mcs_id] >
+	    (pi->tx_power_target[cdd_mcs_id] + 12))
+		return PHY_TXC1_MODE_SISO;
+	else
+		return PHY_TXC1_MODE_CDD;
+}
+
+const uint8 *wlc_phy_get_ofdm_rate_lookup(void)
+{
+	return ofdm_rate_lookup;
+}
+
+void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode)
+{
+	if ((CHIPID(pi->sh->chip) == BCM4313_CHIP_ID) &&
+	    (pi->sh->boardflags & BFL_FEM)) {
+		if (mode) {
+			uint16 txant = 0;
+			txant = wlapi_bmac_get_txant(pi->sh->physhim);
+			if (txant == 1) {
+				mod_phy_reg(pi, 0x44d, (0x1 << 2), (1) << 2);
+
+				mod_phy_reg(pi, 0x44c, (0x1 << 2), (1) << 2);
+
+			}
+			si_corereg(pi->sh->sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, gpiocontrol), ~0x0,
+				   0x0);
+			si_corereg(pi->sh->sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, gpioout), 0x40, 0x40);
+			si_corereg(pi->sh->sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, gpioouten), 0x40,
+				   0x40);
+		} else {
+			mod_phy_reg(pi, 0x44c, (0x1 << 2), (0) << 2);
+
+			mod_phy_reg(pi, 0x44d, (0x1 << 2), (0) << 2);
+
+			si_corereg(pi->sh->sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, gpioout), 0x40, 0x00);
+			si_corereg(pi->sh->sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, gpioouten), 0x40, 0x0);
+			si_corereg(pi->sh->sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, gpiocontrol), ~0x0,
+				   0x40);
+		}
+	}
+}
+
+static int8
+wlc_user_txpwr_antport_to_rfport(phy_info_t * pi, uint chan, uint32 band,
+				 uint8 rate)
+{
+	int8 offset = 0;
+
+	if (!pi->user_txpwr_at_rfport)
+		return offset;
+	return offset;
+}
+
+static int8 wlc_phy_env_measure_vbat(phy_info_t * pi)
+{
+	if (ISLCNPHY(pi))
+		return wlc_lcnphy_vbatsense(pi, 0);
+	else
+		return 0;
+}
+
+static int8 wlc_phy_env_measure_temperature(phy_info_t * pi)
+{
+	if (ISLCNPHY(pi))
+		return wlc_lcnphy_tempsense_degree(pi, 0);
+	else
+		return 0;
+}
+
+static void wlc_phy_upd_env_txpwr_rate_limits(phy_info_t * pi, uint32 band)
+{
+	uint8 i;
+	int8 temp, vbat;
+
+	for (i = 0; i < TXP_NUM_RATES; i++)
+		pi->txpwr_env_limit[i] = WLC_TXPWR_MAX;
+
+	vbat = wlc_phy_env_measure_vbat(pi);
+	temp = wlc_phy_env_measure_temperature(pi);
+
+}
+
+void wlc_phy_ldpc_override_set(wlc_phy_t * ppi, bool ldpc)
+{
+	return;
+}
+
+void
+wlc_phy_get_pwrdet_offsets(phy_info_t * pi, int8 * cckoffset, int8 * ofdmoffset)
+{
+	*cckoffset = 0;
+	*ofdmoffset = 0;
+}
+
+uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor, uint8 precision)
+{
+	uint32 quotient, remainder, roundup, rbit;
+
+	ASSERT(divisor);
+
+	quotient = dividend / divisor;
+	remainder = dividend % divisor;
+	rbit = divisor & 1;
+	roundup = (divisor >> 1) + rbit;
+
+	while (precision--) {
+		quotient <<= 1;
+		if (remainder >= roundup) {
+			quotient++;
+			remainder = ((remainder - roundup) << 1) + rbit;
+		} else {
+			remainder <<= 1;
+		}
+	}
+
+	if (remainder >= roundup)
+		quotient++;
+
+	return quotient;
+}
+
+int8 wlc_phy_upd_rssi_offset(phy_info_t * pi, int8 rssi, chanspec_t chanspec)
+{
+
+	return rssi;
+}
+
+bool wlc_phy_txpower_ipa_ison(wlc_phy_t * ppi)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	if (ISNPHY(pi))
+		return (wlc_phy_n_txpower_ipa_ison(pi));
+	else
+		return 0;
+}
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_hal.h b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
new file mode 100644
index 0000000..18e0f55
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phy_hal.h
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_phy_h_
+#define _wlc_phy_h_
+
+#include <typedefs.h>
+#include <wlioctl.h>
+#include <siutils.h>
+#include <d11.h>
+#include <wlc_phy_shim.h>
+
+#define	IDCODE_VER_MASK		0x0000000f
+#define	IDCODE_VER_SHIFT	0
+#define	IDCODE_MFG_MASK		0x00000fff
+#define	IDCODE_MFG_SHIFT	0
+#define	IDCODE_ID_MASK		0x0ffff000
+#define	IDCODE_ID_SHIFT		12
+#define	IDCODE_REV_MASK		0xf0000000
+#define	IDCODE_REV_SHIFT	28
+
+#define	NORADIO_ID		0xe4f5
+#define	NORADIO_IDCODE		0x4e4f5246
+
+#define BCM2055_ID		0x2055
+#define BCM2055_IDCODE		0x02055000
+#define BCM2055A0_IDCODE	0x1205517f
+
+#define BCM2056_ID		0x2056
+#define BCM2056_IDCODE		0x02056000
+#define BCM2056A0_IDCODE	0x1205617f
+
+#define BCM2057_ID		0x2057
+#define BCM2057_IDCODE		0x02057000
+#define BCM2057A0_IDCODE	0x1205717f
+
+#define BCM2064_ID		0x2064
+#define BCM2064_IDCODE		0x02064000
+#define BCM2064A0_IDCODE	0x0206417f
+
+#define PHY_TPC_HW_OFF		FALSE
+#define PHY_TPC_HW_ON		TRUE
+
+#define PHY_PERICAL_DRIVERUP	1
+#define PHY_PERICAL_WATCHDOG	2
+#define PHY_PERICAL_PHYINIT	3
+#define PHY_PERICAL_JOIN_BSS	4
+#define PHY_PERICAL_START_IBSS	5
+#define PHY_PERICAL_UP_BSS	6
+#define PHY_PERICAL_CHAN	7
+#define PHY_FULLCAL	8
+
+#define PHY_PERICAL_DISABLE	0
+#define PHY_PERICAL_SPHASE	1
+#define PHY_PERICAL_MPHASE	2
+#define PHY_PERICAL_MANUAL	3
+
+#define PHY_HOLD_FOR_ASSOC	1
+#define PHY_HOLD_FOR_SCAN	2
+#define PHY_HOLD_FOR_RM		4
+#define PHY_HOLD_FOR_PLT	8
+#define PHY_HOLD_FOR_MUTE	16
+#define PHY_HOLD_FOR_NOT_ASSOC 0x20
+
+#define PHY_MUTE_FOR_PREISM	1
+#define PHY_MUTE_ALL		0xffffffff
+
+#define PHY_NOISE_FIXED_VAL 		(-95)
+#define PHY_NOISE_FIXED_VAL_NPHY       	(-92)
+#define PHY_NOISE_FIXED_VAL_LCNPHY     	(-92)
+
+#define PHY_MODE_CAL		0x0002
+#define PHY_MODE_NOISEM		0x0004
+
+#define WLC_TXPWR_DB_FACTOR	4
+
+#define WLC_NUM_RATES_CCK           4
+#define WLC_NUM_RATES_OFDM          8
+#define WLC_NUM_RATES_MCS_1_STREAM  8
+#define WLC_NUM_RATES_MCS_2_STREAM  8
+#define WLC_NUM_RATES_MCS_3_STREAM  8
+#define WLC_NUM_RATES_MCS_4_STREAM  8
+typedef struct txpwr_limits {
+	uint8 cck[WLC_NUM_RATES_CCK];
+	uint8 ofdm[WLC_NUM_RATES_OFDM];
+
+	uint8 ofdm_cdd[WLC_NUM_RATES_OFDM];
+
+	uint8 ofdm_40_siso[WLC_NUM_RATES_OFDM];
+	uint8 ofdm_40_cdd[WLC_NUM_RATES_OFDM];
+
+	uint8 mcs_20_siso[WLC_NUM_RATES_MCS_1_STREAM];
+	uint8 mcs_20_cdd[WLC_NUM_RATES_MCS_1_STREAM];
+	uint8 mcs_20_stbc[WLC_NUM_RATES_MCS_1_STREAM];
+	uint8 mcs_20_mimo[WLC_NUM_RATES_MCS_2_STREAM];
+
+	uint8 mcs_40_siso[WLC_NUM_RATES_MCS_1_STREAM];
+	uint8 mcs_40_cdd[WLC_NUM_RATES_MCS_1_STREAM];
+	uint8 mcs_40_stbc[WLC_NUM_RATES_MCS_1_STREAM];
+	uint8 mcs_40_mimo[WLC_NUM_RATES_MCS_2_STREAM];
+	uint8 mcs32;
+} txpwr_limits_t;
+
+typedef struct {
+	uint8 vec[MAXCHANNEL / NBBY];
+} chanvec_t;
+
+struct rpc_info;
+typedef struct shared_phy shared_phy_t;
+
+struct phy_pub;
+
+#ifdef WLC_HIGH_ONLY
+typedef struct wlc_rpc_phy wlc_phy_t;
+#else
+typedef struct phy_pub wlc_phy_t;
+#endif
+
+typedef struct shared_phy_params {
+	void *osh;
+	si_t *sih;
+	void *physhim;
+	uint unit;
+	uint corerev;
+	uint bustype;
+	uint buscorerev;
+	char *vars;
+	uint16 vid;
+	uint16 did;
+	uint chip;
+	uint chiprev;
+	uint chippkg;
+	uint sromrev;
+	uint boardtype;
+	uint boardrev;
+	uint boardvendor;
+	uint32 boardflags;
+	uint32 boardflags2;
+} shared_phy_params_t;
+
+#ifdef WLC_LOW
+
+extern shared_phy_t *wlc_phy_shared_attach(shared_phy_params_t * shp);
+extern void wlc_phy_shared_detach(shared_phy_t * phy_sh);
+extern wlc_phy_t *wlc_phy_attach(shared_phy_t * sh, void *regs, int bandtype,
+				 char *vars);
+extern void wlc_phy_detach(wlc_phy_t * ppi);
+
+extern bool wlc_phy_get_phyversion(wlc_phy_t * pih, uint16 * phytype,
+				   uint16 * phyrev, uint16 * radioid,
+				   uint16 * radiover);
+extern bool wlc_phy_get_encore(wlc_phy_t * pih);
+extern uint32 wlc_phy_get_coreflags(wlc_phy_t * pih);
+
+extern void wlc_phy_hw_clk_state_upd(wlc_phy_t * ppi, bool newstate);
+extern void wlc_phy_hw_state_upd(wlc_phy_t * ppi, bool newstate);
+extern void wlc_phy_init(wlc_phy_t * ppi, chanspec_t chanspec);
+extern void wlc_phy_watchdog(wlc_phy_t * ppi);
+extern int wlc_phy_down(wlc_phy_t * ppi);
+extern uint32 wlc_phy_clk_bwbits(wlc_phy_t * pih);
+extern void wlc_phy_cal_init(wlc_phy_t * ppi);
+extern void wlc_phy_antsel_init(wlc_phy_t * ppi, bool lut_init);
+
+extern void wlc_phy_chanspec_set(wlc_phy_t * ppi, chanspec_t chanspec);
+extern chanspec_t wlc_phy_chanspec_get(wlc_phy_t * ppi);
+extern void wlc_phy_chanspec_radio_set(wlc_phy_t * ppi, chanspec_t newch);
+extern uint16 wlc_phy_bw_state_get(wlc_phy_t * ppi);
+extern void wlc_phy_bw_state_set(wlc_phy_t * ppi, uint16 bw);
+
+extern void wlc_phy_rssi_compute(wlc_phy_t * pih, void *ctx);
+extern void wlc_phy_por_inform(wlc_phy_t * ppi);
+extern void wlc_phy_noise_sample_intr(wlc_phy_t * ppi);
+extern bool wlc_phy_bist_check_phy(wlc_phy_t * ppi);
+
+extern void wlc_phy_set_deaf(wlc_phy_t * ppi, bool user_flag);
+
+extern void wlc_phy_switch_radio(wlc_phy_t * ppi, bool on);
+extern void wlc_phy_anacore(wlc_phy_t * ppi, bool on);
+
+#endif				/* WLC_LOW */
+
+extern void wlc_phy_BSSinit(wlc_phy_t * ppi, bool bonlyap, int rssi);
+
+extern void wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t * ppi,
+						 bool wide_filter);
+extern void wlc_phy_chanspec_band_validch(wlc_phy_t * ppi, uint band,
+					  chanvec_t * channels);
+extern chanspec_t wlc_phy_chanspec_band_firstch(wlc_phy_t * ppi, uint band);
+
+extern void wlc_phy_txpower_sromlimit(wlc_phy_t * ppi, uint chan,
+				      uint8 * _min_, uint8 * _max_, int rate);
+extern void wlc_phy_txpower_sromlimit_max_get(wlc_phy_t * ppi, uint chan,
+					      uint8 * _max_, uint8 * _min_);
+extern void wlc_phy_txpower_boardlimit_band(wlc_phy_t * ppi, uint band, int32 *,
+					    int32 *, uint32 *);
+extern void wlc_phy_txpower_limit_set(wlc_phy_t * ppi, struct txpwr_limits *,
+				      chanspec_t chanspec);
+extern int wlc_phy_txpower_get(wlc_phy_t * ppi, uint * qdbm, bool * override);
+extern int wlc_phy_txpower_set(wlc_phy_t * ppi, uint qdbm, bool override);
+extern void wlc_phy_txpower_target_set(wlc_phy_t * ppi, struct txpwr_limits *);
+extern bool wlc_phy_txpower_hw_ctrl_get(wlc_phy_t * ppi);
+extern void wlc_phy_txpower_hw_ctrl_set(wlc_phy_t * ppi, bool hwpwrctrl);
+extern uint8 wlc_phy_txpower_get_target_min(wlc_phy_t * ppi);
+extern uint8 wlc_phy_txpower_get_target_max(wlc_phy_t * ppi);
+extern bool wlc_phy_txpower_ipa_ison(wlc_phy_t * pih);
+
+extern void wlc_phy_stf_chain_init(wlc_phy_t * pih, uint8 txchain,
+				   uint8 rxchain);
+extern void wlc_phy_stf_chain_set(wlc_phy_t * pih, uint8 txchain,
+				  uint8 rxchain);
+extern void wlc_phy_stf_chain_get(wlc_phy_t * pih, uint8 * txchain,
+				  uint8 * rxchain);
+extern uint8 wlc_phy_stf_chain_active_get(wlc_phy_t * pih);
+extern int8 wlc_phy_stf_ssmode_get(wlc_phy_t * pih, chanspec_t chanspec);
+extern void wlc_phy_ldpc_override_set(wlc_phy_t * ppi, bool val);
+
+extern void wlc_phy_cal_perical(wlc_phy_t * ppi, uint8 reason);
+extern void wlc_phy_noise_sample_request_external(wlc_phy_t * ppi);
+extern void wlc_phy_edcrs_lock(wlc_phy_t * pih, bool lock);
+extern void wlc_phy_cal_papd_recal(wlc_phy_t * ppi);
+
+extern void wlc_phy_ant_rxdiv_set(wlc_phy_t * ppi, uint8 val);
+extern bool wlc_phy_ant_rxdiv_get(wlc_phy_t * ppi, uint8 * pval);
+extern void wlc_phy_clear_tssi(wlc_phy_t * ppi);
+extern void wlc_phy_hold_upd(wlc_phy_t * ppi, mbool id, bool val);
+extern void wlc_phy_mute_upd(wlc_phy_t * ppi, bool val, mbool flags);
+
+extern void wlc_phy_antsel_type_set(wlc_phy_t * ppi, uint8 antsel_type);
+
+extern void wlc_phy_txpower_get_current(wlc_phy_t * ppi, tx_power_t * power,
+					uint channel);
+
+extern void wlc_phy_initcal_enable(wlc_phy_t * pih, bool initcal);
+extern bool wlc_phy_test_ison(wlc_phy_t * ppi);
+extern void wlc_phy_txpwr_percent_set(wlc_phy_t * ppi, uint8 txpwr_percent);
+extern void wlc_phy_ofdm_rateset_war(wlc_phy_t * pih, bool war);
+extern void wlc_phy_bf_preempt_enable(wlc_phy_t * pih, bool bf_preempt);
+extern void wlc_phy_machwcap_set(wlc_phy_t * ppi, uint32 machwcap);
+
+extern void wlc_phy_runbist_config(wlc_phy_t * ppi, bool start_end);
+
+extern void wlc_phy_freqtrack_start(wlc_phy_t * ppi);
+extern void wlc_phy_freqtrack_end(wlc_phy_t * ppi);
+
+extern const uint8 *wlc_phy_get_ofdm_rate_lookup(void);
+
+extern int8 wlc_phy_get_tx_power_offset_by_mcs(wlc_phy_t * ppi,
+					       uint8 mcs_offset);
+extern int8 wlc_phy_get_tx_power_offset(wlc_phy_t * ppi, uint8 tbl_offset);
+#endif				/* _wlc_phy_h_ */
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_int.h b/drivers/staging/brcm80211/phy/wlc_phy_int.h
new file mode 100644
index 0000000..54c61d6
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phy_int.h
@@ -0,0 +1,1229 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_phy_int_h_
+#define _wlc_phy_int_h_
+
+#include <typedefs.h>
+#include <bcmutils.h>
+
+#include <bcmsrom_fmt.h>
+#include <wlc_phy_hal.h>
+
+#define PHYHAL_ERROR	0x0001
+#define PHYHAL_TRACE	0x0002
+#define PHYHAL_INFORM	0x0004
+
+extern uint32 phyhal_msg_level;
+
+#define PHY_INFORM_ON()		(phyhal_msg_level & PHYHAL_INFORM)
+#define PHY_THERMAL_ON()	(phyhal_msg_level & PHYHAL_THERMAL)
+#define PHY_CAL_ON()		(phyhal_msg_level & PHYHAL_CAL)
+
+#ifdef BOARD_TYPE
+#define BOARDTYPE(_type) BOARD_TYPE
+#else
+#define BOARDTYPE(_type) _type
+#endif
+
+#define LCNXN_BASEREV		16
+
+struct wlc_hw_info;
+typedef struct phy_info phy_info_t;
+typedef void (*initfn_t) (phy_info_t *);
+typedef void (*chansetfn_t) (phy_info_t *, chanspec_t);
+typedef int (*longtrnfn_t) (phy_info_t *, int);
+typedef void (*txiqccgetfn_t) (phy_info_t *, uint16 *, uint16 *);
+typedef void (*txiqccsetfn_t) (phy_info_t *, uint16, uint16);
+typedef uint16(*txloccgetfn_t) (phy_info_t *);
+typedef void (*radioloftgetfn_t) (phy_info_t *, uint8 *, uint8 *, uint8 *,
+				  uint8 *);
+typedef int32(*rxsigpwrfn_t) (phy_info_t *, int32);
+typedef void (*detachfn_t) (phy_info_t *);
+
+#undef ISNPHY
+#undef ISLCNPHY
+#define ISNPHY(pi)	PHYTYPE_IS((pi)->pubpi.phy_type, PHY_TYPE_N)
+#define ISLCNPHY(pi)  	PHYTYPE_IS((pi)->pubpi.phy_type, PHY_TYPE_LCN)
+
+#define ISPHY_11N_CAP(pi)	(ISNPHY(pi) || ISLCNPHY(pi))
+
+#define IS20MHZ(pi)	((pi)->bw == WL_CHANSPEC_BW_20)
+#define IS40MHZ(pi)	((pi)->bw == WL_CHANSPEC_BW_40)
+
+#define PHY_GET_RFATTN(rfgain)	((rfgain) & 0x0f)
+#define PHY_GET_PADMIX(rfgain)	(((rfgain) & 0x10) >> 4)
+#define PHY_GET_RFGAINID(rfattn, padmix, width)	((rfattn) + ((padmix)*(width)))
+#define PHY_SAT(x, n)		((x) > ((1<<((n)-1))-1) ? ((1<<((n)-1))-1) : \
+				((x) < -(1<<((n)-1)) ? -(1<<((n)-1)) : (x)))
+#define PHY_SHIFT_ROUND(x, n)	((x) >= 0 ? ((x)+(1<<((n)-1)))>>(n) : (x)>>(n))
+#define PHY_HW_ROUND(x, s)		((x >> s) + ((x >> (s-1)) & (s != 0)))
+
+#define CH_5G_GROUP	3
+#define A_LOW_CHANS	0
+#define A_MID_CHANS	1
+#define A_HIGH_CHANS	2
+#define CH_2G_GROUP	1
+#define G_ALL_CHANS	0
+
+#define FIRST_REF5_CHANNUM	149
+#define LAST_REF5_CHANNUM	165
+#define	FIRST_5G_CHAN		14
+#define	LAST_5G_CHAN		50
+#define	FIRST_MID_5G_CHAN	14
+#define	LAST_MID_5G_CHAN	35
+#define	FIRST_HIGH_5G_CHAN	36
+#define	LAST_HIGH_5G_CHAN	41
+#define	FIRST_LOW_5G_CHAN	42
+#define	LAST_LOW_5G_CHAN	50
+
+#define BASE_LOW_5G_CHAN	4900
+#define BASE_MID_5G_CHAN	5100
+#define BASE_HIGH_5G_CHAN	5500
+
+#define CHAN5G_FREQ(chan)  (5000 + chan*5)
+#define CHAN2G_FREQ(chan)  (2407 + chan*5)
+
+#define TXP_FIRST_CCK		0
+#define TXP_LAST_CCK		3
+#define TXP_FIRST_OFDM		4
+#define TXP_LAST_OFDM		11
+#define TXP_FIRST_OFDM_20_CDD	12
+#define TXP_LAST_OFDM_20_CDD	19
+#define TXP_FIRST_MCS_20_SISO	20
+#define TXP_LAST_MCS_20_SISO	27
+#define TXP_FIRST_MCS_20_CDD	28
+#define TXP_LAST_MCS_20_CDD	35
+#define TXP_FIRST_MCS_20_STBC	36
+#define TXP_LAST_MCS_20_STBC	43
+#define TXP_FIRST_MCS_20_SDM	44
+#define TXP_LAST_MCS_20_SDM	51
+#define TXP_FIRST_OFDM_40_SISO	52
+#define TXP_LAST_OFDM_40_SISO	59
+#define TXP_FIRST_OFDM_40_CDD	60
+#define TXP_LAST_OFDM_40_CDD	67
+#define TXP_FIRST_MCS_40_SISO	68
+#define TXP_LAST_MCS_40_SISO	75
+#define TXP_FIRST_MCS_40_CDD	76
+#define TXP_LAST_MCS_40_CDD	83
+#define TXP_FIRST_MCS_40_STBC	84
+#define TXP_LAST_MCS_40_STBC	91
+#define TXP_FIRST_MCS_40_SDM	92
+#define TXP_LAST_MCS_40_SDM	99
+#define TXP_MCS_32	        100
+#define TXP_NUM_RATES		101
+#define ADJ_PWR_TBL_LEN		84
+
+#define TXP_FIRST_SISO_MCS_20	20
+#define TXP_LAST_SISO_MCS_20	27
+
+#define PHY_CORE_NUM_1	1
+#define PHY_CORE_NUM_2	2
+#define PHY_CORE_NUM_3	3
+#define PHY_CORE_NUM_4	4
+#define PHY_CORE_MAX	PHY_CORE_NUM_4
+#define PHY_CORE_0	0
+#define PHY_CORE_1	1
+#define PHY_CORE_2	2
+#define PHY_CORE_3	3
+
+#define MA_WINDOW_SZ		8
+
+#define PHY_NOISE_SAMPLE_MON		1
+#define PHY_NOISE_SAMPLE_EXTERNAL	2
+#define PHY_NOISE_WINDOW_SZ	16
+#define PHY_NOISE_GLITCH_INIT_MA 10
+#define PHY_NOISE_GLITCH_INIT_MA_BADPlCP 10
+#define PHY_NOISE_STATE_MON		0x1
+#define PHY_NOISE_STATE_EXTERNAL	0x2
+#define PHY_NOISE_SAMPLE_LOG_NUM_NPHY	10
+#define PHY_NOISE_SAMPLE_LOG_NUM_UCODE	9
+
+#define PHY_NOISE_OFFSETFACT_4322  (-103)
+#define PHY_NOISE_MA_WINDOW_SZ	2
+
+#define	PHY_RSSI_TABLE_SIZE	64
+#define RSSI_ANT_MERGE_MAX	0
+#define RSSI_ANT_MERGE_MIN	1
+#define RSSI_ANT_MERGE_AVG	2
+
+#define	PHY_TSSI_TABLE_SIZE	64
+#define	APHY_TSSI_TABLE_SIZE	256
+#define	TX_GAIN_TABLE_LENGTH	64
+#define	DEFAULT_11A_TXP_IDX	24
+#define NUM_TSSI_FRAMES        4
+#define	NULL_TSSI		0x7f
+#define	NULL_TSSI_W		0x7f7f
+
+#define PHY_PAPD_EPS_TBL_SIZE_LCNPHY 64
+
+#define LCNPHY_PERICAL_TEMPBASED_TXPWRCTRL 9
+
+#define PHY_TXPWR_MIN		10
+#define PHY_TXPWR_MIN_NPHY	8
+#define RADIOPWR_OVERRIDE_DEF	(-1)
+
+#define PWRTBL_NUM_COEFF	3
+
+#define SPURAVOID_DISABLE	0
+#define SPURAVOID_AUTO		1
+#define SPURAVOID_FORCEON	2
+#define SPURAVOID_FORCEON2	3
+
+#define PHY_SW_TIMER_FAST		15
+#define PHY_SW_TIMER_SLOW		60
+#define PHY_SW_TIMER_GLACIAL	120
+
+#define PHY_PERICAL_AUTO	0
+#define PHY_PERICAL_FULL	1
+#define PHY_PERICAL_PARTIAL	2
+
+#define PHY_PERICAL_NODELAY	0
+#define PHY_PERICAL_INIT_DELAY	5
+#define PHY_PERICAL_ASSOC_DELAY	5
+#define PHY_PERICAL_WDOG_DELAY	5
+
+#define MPHASE_TXCAL_NUMCMDS	2
+#define PHY_PERICAL_MPHASE_PENDING(pi)	(pi->mphase_cal_phase_id > MPHASE_CAL_STATE_IDLE)
+
+enum {
+	MPHASE_CAL_STATE_IDLE = 0,
+	MPHASE_CAL_STATE_INIT = 1,
+	MPHASE_CAL_STATE_TXPHASE0,
+	MPHASE_CAL_STATE_TXPHASE1,
+	MPHASE_CAL_STATE_TXPHASE2,
+	MPHASE_CAL_STATE_TXPHASE3,
+	MPHASE_CAL_STATE_TXPHASE4,
+	MPHASE_CAL_STATE_TXPHASE5,
+	MPHASE_CAL_STATE_PAPDCAL,
+	MPHASE_CAL_STATE_RXCAL,
+	MPHASE_CAL_STATE_RSSICAL,
+	MPHASE_CAL_STATE_IDLETSSI
+};
+
+typedef enum {
+	CAL_FULL,
+	CAL_RECAL,
+	CAL_CURRECAL,
+	CAL_DIGCAL,
+	CAL_GCTRL,
+	CAL_SOFT,
+	CAL_DIGLO
+} phy_cal_mode_t;
+
+#define RDR_NTIERS  1
+#define RDR_TIER_SIZE 64
+#define RDR_LIST_SIZE 512/3
+#define RDR_EPOCH_SIZE 40
+#define RDR_NANTENNAS 2
+#define RDR_NTIER_SIZE  RDR_LIST_SIZE
+#define RDR_LP_BUFFER_SIZE 64
+#define LP_LEN_HIS_SIZE 10
+
+#define STATIC_NUM_RF 32
+#define STATIC_NUM_BB 9
+
+#define BB_MULT_MASK		0x0000ffff
+#define BB_MULT_VALID_MASK	0x80000000
+
+#define CORDIC_AG	39797
+#define	CORDIC_NI	18
+#define	FIXED(X)	((int32)((X) << 16))
+#define	FLOAT(X)	(((X) >= 0) ? ((((X) >> 15) + 1) >> 1) : -((((-(X)) >> 15) + 1) >> 1))
+
+#define PHY_CHAIN_TX_DISABLE_TEMP	115
+#define PHY_HYSTERESIS_DELTATEMP	5
+
+#define PHY_BITSCNT(x)	bcm_bitcount((uint8 *)&(x), sizeof(uint8))
+
+#define MOD_PHY_REG(pi, phy_type, reg_name, field, value) \
+	mod_phy_reg(pi, phy_type##_##reg_name, phy_type##_##reg_name##_##field##_MASK, \
+	(value) << phy_type##_##reg_name##_##field##_##SHIFT);
+#define READ_PHY_REG(pi, phy_type, reg_name, field) \
+	((read_phy_reg(pi, phy_type##_##reg_name) & phy_type##_##reg_name##_##field##_##MASK)\
+	>> phy_type##_##reg_name##_##field##_##SHIFT)
+
+#define	VALID_PHYTYPE(phytype)	(((uint)phytype == PHY_TYPE_N) || \
+				((uint)phytype == PHY_TYPE_LCN))
+
+#define VALID_N_RADIO(radioid)	((radioid == BCM2055_ID) || (radioid == BCM2056_ID) || \
+				(radioid == BCM2057_ID))
+#define VALID_LCN_RADIO(radioid)	(radioid == BCM2064_ID)
+
+#define	VALID_RADIO(pi, radioid)	(\
+	(ISNPHY(pi) ? VALID_N_RADIO(radioid) : FALSE) || \
+	(ISLCNPHY(pi) ? VALID_LCN_RADIO(radioid) : FALSE))
+
+#define SCAN_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_SCAN))
+#define RM_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_RM))
+#define PLT_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_PLT))
+#define ASSOC_INPROG_PHY(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_ASSOC))
+#define SCAN_RM_IN_PROGRESS(pi) (mboolisset(pi->measure_hold, PHY_HOLD_FOR_SCAN | PHY_HOLD_FOR_RM))
+#define PHY_MUTED(pi)		(mboolisset(pi->measure_hold, PHY_HOLD_FOR_MUTE))
+#define PUB_NOT_ASSOC(pi)	(mboolisset(pi->measure_hold, PHY_HOLD_FOR_NOT_ASSOC))
+
+#if defined(EXT_CBALL)
+#define NORADIO_ENAB(pub) ((pub).radioid == NORADIO_ID)
+#else
+#define NORADIO_ENAB(pub) 0
+#endif
+
+#define PHY_LTRN_LIST_LEN	64
+extern uint16 ltrn_list[PHY_LTRN_LIST_LEN];
+
+typedef struct _phy_table_info {
+	uint table;
+	int q;
+	uint max;
+} phy_table_info_t;
+
+typedef struct phytbl_info {
+	const void *tbl_ptr;
+	uint32 tbl_len;
+	uint32 tbl_id;
+	uint32 tbl_offset;
+	uint32 tbl_width;
+} phytbl_info_t;
+
+typedef struct {
+	uint8 curr_home_channel;
+	uint16 crsminpwrthld_40_stored;
+	uint16 crsminpwrthld_20L_stored;
+	uint16 crsminpwrthld_20U_stored;
+	uint16 init_gain_code_core1_stored;
+	uint16 init_gain_code_core2_stored;
+	uint16 init_gain_codeb_core1_stored;
+	uint16 init_gain_codeb_core2_stored;
+	uint16 init_gain_table_stored[4];
+
+	uint16 clip1_hi_gain_code_core1_stored;
+	uint16 clip1_hi_gain_code_core2_stored;
+	uint16 clip1_hi_gain_codeb_core1_stored;
+	uint16 clip1_hi_gain_codeb_core2_stored;
+	uint16 nb_clip_thresh_core1_stored;
+	uint16 nb_clip_thresh_core2_stored;
+	uint16 init_ofdmlna2gainchange_stored[4];
+	uint16 init_ccklna2gainchange_stored[4];
+	uint16 clip1_lo_gain_code_core1_stored;
+	uint16 clip1_lo_gain_code_core2_stored;
+	uint16 clip1_lo_gain_codeb_core1_stored;
+	uint16 clip1_lo_gain_codeb_core2_stored;
+	uint16 w1_clip_thresh_core1_stored;
+	uint16 w1_clip_thresh_core2_stored;
+	uint16 radio_2056_core1_rssi_gain_stored;
+	uint16 radio_2056_core2_rssi_gain_stored;
+	uint16 energy_drop_timeout_len_stored;
+
+	uint16 ed_crs40_assertthld0_stored;
+	uint16 ed_crs40_assertthld1_stored;
+	uint16 ed_crs40_deassertthld0_stored;
+	uint16 ed_crs40_deassertthld1_stored;
+	uint16 ed_crs20L_assertthld0_stored;
+	uint16 ed_crs20L_assertthld1_stored;
+	uint16 ed_crs20L_deassertthld0_stored;
+	uint16 ed_crs20L_deassertthld1_stored;
+	uint16 ed_crs20U_assertthld0_stored;
+	uint16 ed_crs20U_assertthld1_stored;
+	uint16 ed_crs20U_deassertthld0_stored;
+	uint16 ed_crs20U_deassertthld1_stored;
+
+	uint16 badplcp_ma;
+	uint16 badplcp_ma_previous;
+	uint16 badplcp_ma_total;
+	uint16 badplcp_ma_list[MA_WINDOW_SZ];
+	int badplcp_ma_index;
+	int16 pre_badplcp_cnt;
+	int16 bphy_pre_badplcp_cnt;
+
+	uint16 init_gain_core1;
+	uint16 init_gain_core2;
+	uint16 init_gainb_core1;
+	uint16 init_gainb_core2;
+	uint16 init_gain_rfseq[4];
+
+	uint16 crsminpwr0;
+	uint16 crsminpwrl0;
+	uint16 crsminpwru0;
+
+	int16 crsminpwr_index;
+
+	uint16 radio_2057_core1_rssi_wb1a_gc_stored;
+	uint16 radio_2057_core2_rssi_wb1a_gc_stored;
+	uint16 radio_2057_core1_rssi_wb1g_gc_stored;
+	uint16 radio_2057_core2_rssi_wb1g_gc_stored;
+	uint16 radio_2057_core1_rssi_wb2_gc_stored;
+	uint16 radio_2057_core2_rssi_wb2_gc_stored;
+	uint16 radio_2057_core1_rssi_nb_gc_stored;
+	uint16 radio_2057_core2_rssi_nb_gc_stored;
+
+} interference_info_t;
+
+typedef struct {
+	uint16 rc_cal_ovr;
+	uint16 phycrsth1;
+	uint16 phycrsth2;
+	uint16 init_n1p1_gain;
+	uint16 p1_p2_gain;
+	uint16 n1_n2_gain;
+	uint16 n1_p1_gain;
+	uint16 div_search_gain;
+	uint16 div_p1_p2_gain;
+	uint16 div_search_gn_change;
+	uint16 table_7_2;
+	uint16 table_7_3;
+	uint16 cckshbits_gnref;
+	uint16 clip_thresh;
+	uint16 clip2_thresh;
+	uint16 clip3_thresh;
+	uint16 clip_p2_thresh;
+	uint16 clip_pwdn_thresh;
+	uint16 clip_n1p1_thresh;
+	uint16 clip_n1_pwdn_thresh;
+	uint16 bbconfig;
+	uint16 cthr_sthr_shdin;
+	uint16 energy;
+	uint16 clip_p1_p2_thresh;
+	uint16 threshold;
+	uint16 reg15;
+	uint16 reg16;
+	uint16 reg17;
+	uint16 div_srch_idx;
+	uint16 div_srch_p1_p2;
+	uint16 div_srch_gn_back;
+	uint16 ant_dwell;
+	uint16 ant_wr_settle;
+} aci_save_gphy_t;
+
+typedef struct _lo_complex_t {
+	int8 i;
+	int8 q;
+} lo_complex_abgphy_info_t;
+
+typedef struct _nphy_iq_comp {
+	int16 a0;
+	int16 b0;
+	int16 a1;
+	int16 b1;
+} nphy_iq_comp_t;
+
+typedef struct _nphy_txpwrindex {
+	int8 index;
+	int8 index_internal;
+	int8 index_internal_save;
+	uint16 AfectrlOverride;
+	uint16 AfeCtrlDacGain;
+	uint16 rad_gain;
+	uint8 bbmult;
+	uint16 iqcomp_a;
+	uint16 iqcomp_b;
+	uint16 locomp;
+} phy_txpwrindex_t;
+
+typedef struct {
+
+	uint16 txcal_coeffs_2G[8];
+	uint16 txcal_radio_regs_2G[8];
+	nphy_iq_comp_t rxcal_coeffs_2G;
+
+	uint16 txcal_coeffs_5G[8];
+	uint16 txcal_radio_regs_5G[8];
+	nphy_iq_comp_t rxcal_coeffs_5G;
+} txiqcal_cache_t;
+
+typedef struct _nphy_pwrctrl {
+	int8 max_pwr_2g;
+	int8 idle_targ_2g;
+	int16 pwrdet_2g_a1;
+	int16 pwrdet_2g_b0;
+	int16 pwrdet_2g_b1;
+	int8 max_pwr_5gm;
+	int8 idle_targ_5gm;
+	int8 max_pwr_5gh;
+	int8 max_pwr_5gl;
+	int16 pwrdet_5gm_a1;
+	int16 pwrdet_5gm_b0;
+	int16 pwrdet_5gm_b1;
+	int16 pwrdet_5gl_a1;
+	int16 pwrdet_5gl_b0;
+	int16 pwrdet_5gl_b1;
+	int16 pwrdet_5gh_a1;
+	int16 pwrdet_5gh_b0;
+	int16 pwrdet_5gh_b1;
+	int8 idle_targ_5gl;
+	int8 idle_targ_5gh;
+	int8 idle_tssi_2g;
+	int8 idle_tssi_5g;
+	int8 idle_tssi;
+	int16 a1;
+	int16 b0;
+	int16 b1;
+} phy_pwrctrl_t;
+
+typedef struct _nphy_txgains {
+	uint16 txlpf[2];
+	uint16 txgm[2];
+	uint16 pga[2];
+	uint16 pad[2];
+	uint16 ipa[2];
+} nphy_txgains_t;
+
+#define PHY_NOISEVAR_BUFSIZE 10
+
+typedef struct _nphy_noisevar_buf {
+	int bufcount;
+	int tone_id[PHY_NOISEVAR_BUFSIZE];
+	uint32 noise_vars[PHY_NOISEVAR_BUFSIZE];
+	uint32 min_noise_vars[PHY_NOISEVAR_BUFSIZE];
+} phy_noisevar_buf_t;
+
+typedef struct {
+	uint16 rssical_radio_regs_2G[2];
+	uint16 rssical_phyregs_2G[12];
+
+	uint16 rssical_radio_regs_5G[2];
+	uint16 rssical_phyregs_5G[12];
+} rssical_cache_t;
+
+typedef struct {
+
+	uint16 txiqlocal_a;
+	uint16 txiqlocal_b;
+	uint16 txiqlocal_didq;
+	uint8 txiqlocal_ei0;
+	uint8 txiqlocal_eq0;
+	uint8 txiqlocal_fi0;
+	uint8 txiqlocal_fq0;
+
+	uint16 txiqlocal_bestcoeffs[11];
+	uint16 txiqlocal_bestcoeffs_valid;
+
+	uint32 papd_eps_tbl[PHY_PAPD_EPS_TBL_SIZE_LCNPHY];
+	uint16 analog_gain_ref;
+	uint16 lut_begin;
+	uint16 lut_end;
+	uint16 lut_step;
+	uint16 rxcompdbm;
+	uint16 papdctrl;
+	uint16 sslpnCalibClkEnCtrl;
+
+	uint16 rxiqcal_coeff_a0;
+	uint16 rxiqcal_coeff_b0;
+} lcnphy_cal_results_t;
+
+struct shared_phy {
+	struct phy_info *phy_head;
+	uint unit;
+	osl_t *osh;
+	si_t *sih;
+	void *physhim;
+	uint corerev;
+	uint32 machwcap;
+	bool up;
+	bool clk;
+	uint now;
+	uint16 vid;
+	uint16 did;
+	uint chip;
+	uint chiprev;
+	uint chippkg;
+	uint sromrev;
+	uint boardtype;
+	uint boardrev;
+	uint boardvendor;
+	uint32 boardflags;
+	uint32 boardflags2;
+	uint bustype;
+	uint buscorerev;
+	uint fast_timer;
+	uint slow_timer;
+	uint glacial_timer;
+	uint8 rx_antdiv;
+	int8 phy_noise_window[MA_WINDOW_SZ];
+	uint phy_noise_index;
+	uint8 hw_phytxchain;
+	uint8 hw_phyrxchain;
+	uint8 phytxchain;
+	uint8 phyrxchain;
+	uint8 rssi_mode;
+	bool _rifs_phy;
+};
+
+struct phy_pub {
+	uint phy_type;
+	uint phy_rev;
+	uint8 phy_corenum;
+	uint16 radioid;
+	uint8 radiorev;
+	uint8 radiover;
+
+	uint coreflags;
+	uint ana_rev;
+	bool abgphy_encore;
+};
+
+struct phy_info_nphy;
+typedef struct phy_info_nphy phy_info_nphy_t;
+
+struct phy_info_lcnphy;
+typedef struct phy_info_lcnphy phy_info_lcnphy_t;
+
+struct phy_func_ptr {
+	initfn_t init;
+	initfn_t calinit;
+	chansetfn_t chanset;
+	initfn_t txpwrrecalc;
+	longtrnfn_t longtrn;
+	txiqccgetfn_t txiqccget;
+	txiqccsetfn_t txiqccset;
+	txloccgetfn_t txloccget;
+	radioloftgetfn_t radioloftget;
+	initfn_t carrsuppr;
+	rxsigpwrfn_t rxsigpwr;
+	detachfn_t detach;
+};
+typedef struct phy_func_ptr phy_func_ptr_t;
+
+struct phy_info {
+	wlc_phy_t pubpi_ro;
+	shared_phy_t *sh;
+	phy_func_ptr_t pi_fptr;
+	void *pi_ptr;
+
+	union {
+		phy_info_lcnphy_t *pi_lcnphy;
+	} u;
+	bool user_txpwr_at_rfport;
+
+	d11regs_t *regs;
+	struct phy_info *next;
+	char *vars;
+	wlc_phy_t pubpi;
+
+	bool do_initcal;
+	bool phytest_on;
+	bool ofdm_rateset_war;
+	bool bf_preempt_4306;
+	chanspec_t radio_chanspec;
+	uint8 antsel_type;
+	uint16 bw;
+	uint8 txpwr_percent;
+	bool phy_init_por;
+
+	bool init_in_progress;
+	bool initialized;
+	bool sbtml_gm;
+	uint refcnt;
+	bool watchdog_override;
+	uint8 phynoise_state;
+	uint phynoise_now;
+	int phynoise_chan_watchdog;
+	bool phynoise_polling;
+	bool disable_percal;
+	mbool measure_hold;
+
+	int16 txpa_2g[PWRTBL_NUM_COEFF];
+	int16 txpa_2g_low_temp[PWRTBL_NUM_COEFF];
+	int16 txpa_2g_high_temp[PWRTBL_NUM_COEFF];
+	int16 txpa_5g_low[PWRTBL_NUM_COEFF];
+	int16 txpa_5g_mid[PWRTBL_NUM_COEFF];
+	int16 txpa_5g_hi[PWRTBL_NUM_COEFF];
+
+	uint8 tx_srom_max_2g;
+	uint8 tx_srom_max_5g_low;
+	uint8 tx_srom_max_5g_mid;
+	uint8 tx_srom_max_5g_hi;
+	uint8 tx_srom_max_rate_2g[TXP_NUM_RATES];
+	uint8 tx_srom_max_rate_5g_low[TXP_NUM_RATES];
+	uint8 tx_srom_max_rate_5g_mid[TXP_NUM_RATES];
+	uint8 tx_srom_max_rate_5g_hi[TXP_NUM_RATES];
+	uint8 tx_user_target[TXP_NUM_RATES];
+	int8 tx_power_offset[TXP_NUM_RATES];
+	uint8 tx_power_target[TXP_NUM_RATES];
+
+	srom_fem_t srom_fem2g;
+	srom_fem_t srom_fem5g;
+
+	uint8 tx_power_max;
+	uint8 tx_power_max_rate_ind;
+	bool hwpwrctrl;
+	uint8 nphy_txpwrctrl;
+	int8 nphy_txrx_chain;
+	bool phy_5g_pwrgain;
+
+	uint16 phy_wreg;
+	uint16 phy_wreg_limit;
+
+	int8 n_preamble_override;
+	uint8 antswitch;
+	uint8 aa2g, aa5g;
+
+	int8 idle_tssi[CH_5G_GROUP];
+	int8 target_idle_tssi;
+	int8 txpwr_est_Pout;
+	uint8 tx_power_min;
+	uint8 txpwr_limit[TXP_NUM_RATES];
+	uint8 txpwr_env_limit[TXP_NUM_RATES];
+	uint8 adj_pwr_tbl_nphy[ADJ_PWR_TBL_LEN];
+
+	bool channel_14_wide_filter;
+
+	bool txpwroverride;
+	bool txpwridx_override_aphy;
+	int16 radiopwr_override;
+	uint16 hwpwr_txcur;
+	uint8 saved_txpwr_idx;
+
+	bool edcrs_threshold_lock;
+
+	uint32 tr_R_gain_val;
+	uint32 tr_T_gain_val;
+
+	int16 ofdm_analog_filt_bw_override;
+	int16 cck_analog_filt_bw_override;
+	int16 ofdm_rccal_override;
+	int16 cck_rccal_override;
+	uint16 extlna_type;
+
+	uint interference_mode_crs_time;
+	uint16 crsglitch_prev;
+	bool interference_mode_crs;
+
+	uint32 phy_tx_tone_freq;
+	uint phy_lastcal;
+	bool phy_forcecal;
+	bool phy_fixed_noise;
+	uint32 xtalfreq;
+	uint8 pdiv;
+	int8 carrier_suppr_disable;
+
+	bool phy_bphy_evm;
+	bool phy_bphy_rfcs;
+	int8 phy_scraminit;
+	uint8 phy_gpiosel;
+
+	int16 phy_txcore_disable_temp;
+	int16 phy_txcore_enable_temp;
+	int8 phy_tempsense_offset;
+	bool phy_txcore_heatedup;
+
+	uint16 radiopwr;
+	uint16 bb_atten;
+	uint16 txctl1;
+
+	uint16 mintxbias;
+	uint16 mintxmag;
+	lo_complex_abgphy_info_t gphy_locomp_iq[STATIC_NUM_RF][STATIC_NUM_BB];
+	int8 stats_11b_txpower[STATIC_NUM_RF][STATIC_NUM_BB];
+	uint16 gain_table[TX_GAIN_TABLE_LENGTH];
+	bool loopback_gain;
+	int16 max_lpback_gain_hdB;
+	int16 trsw_rx_gain_hdB;
+	uint8 power_vec[8];
+
+	uint16 rc_cal;
+	int nrssi_table_delta;
+	int nrssi_slope_scale;
+	int nrssi_slope_offset;
+	int min_rssi;
+	int max_rssi;
+
+	int8 txpwridx;
+	uint8 min_txpower;
+
+	uint8 a_band_high_disable;
+
+	uint16 tx_vos;
+	uint16 global_tx_bb_dc_bias_loft;
+
+	int rf_max;
+	int bb_max;
+	int rf_list_size;
+	int bb_list_size;
+	uint16 *rf_attn_list;
+	uint16 *bb_attn_list;
+	uint16 padmix_mask;
+	uint16 padmix_reg;
+	uint16 *txmag_list;
+	uint txmag_len;
+	bool txmag_enable;
+
+	int8 *a_tssi_to_dbm;
+	int8 *m_tssi_to_dbm;
+	int8 *l_tssi_to_dbm;
+	int8 *h_tssi_to_dbm;
+	uint8 *hwtxpwr;
+
+	uint16 freqtrack_saved_regs[2];
+	int cur_interference_mode;
+	bool hwpwrctrl_capable;
+	bool temppwrctrl_capable;
+
+	uint phycal_nslope;
+	uint phycal_noffset;
+	uint phycal_mlo;
+	uint phycal_txpower;
+
+	bool pkteng_in_progress;
+	uint8 phy_aa2g;
+
+	bool nphy_tableloaded;
+	int8 nphy_rssisel;
+	uint32 nphy_bb_mult_save;
+	uint16 nphy_txiqlocal_bestc[11];
+	bool nphy_txiqlocal_coeffsvalid;
+	phy_txpwrindex_t nphy_txpwrindex[PHY_CORE_NUM_2];
+	phy_pwrctrl_t nphy_pwrctrl_info[PHY_CORE_NUM_2];
+	uint16 cck2gpo;
+	uint32 ofdm2gpo;
+	uint32 ofdm5gpo;
+	uint32 ofdm5glpo;
+	uint32 ofdm5ghpo;
+	uint8 bw402gpo;
+	uint8 bw405gpo;
+	uint8 bw405glpo;
+	uint8 bw405ghpo;
+	uint8 cdd2gpo;
+	uint8 cdd5gpo;
+	uint8 cdd5glpo;
+	uint8 cdd5ghpo;
+	uint8 stbc2gpo;
+	uint8 stbc5gpo;
+	uint8 stbc5glpo;
+	uint8 stbc5ghpo;
+	uint8 bwdup2gpo;
+	uint8 bwdup5gpo;
+	uint8 bwdup5glpo;
+	uint8 bwdup5ghpo;
+	uint16 mcs2gpo[8];
+	uint16 mcs5gpo[8];
+	uint16 mcs5glpo[8];
+	uint16 mcs5ghpo[8];
+	uint32 nphy_rxcalparams;
+
+	uint8 phy_spuravoid;
+	bool phy_isspuravoid;
+
+	uint8 phy_pabias;
+	uint8 nphy_papd_skip;
+	uint8 nphy_tssi_slope;
+
+	int16 nphy_noise_win[PHY_CORE_MAX][PHY_NOISE_WINDOW_SZ];
+	uint8 nphy_noise_index;
+
+	uint8 nphy_txpid2g[PHY_CORE_NUM_2];
+	uint8 nphy_txpid5g[PHY_CORE_NUM_2];
+	uint8 nphy_txpid5gl[PHY_CORE_NUM_2];
+	uint8 nphy_txpid5gh[PHY_CORE_NUM_2];
+
+	bool nphy_gain_boost;
+	bool nphy_elna_gain_config;
+	uint16 old_bphy_test;
+	uint16 old_bphy_testcontrol;
+
+	bool phyhang_avoid;
+
+	bool rssical_nphy;
+	uint8 nphy_perical;
+	uint nphy_perical_last;
+	uint8 cal_type_override;
+	uint8 mphase_cal_phase_id;
+	uint8 mphase_txcal_cmdidx;
+	uint8 mphase_txcal_numcmds;
+	uint16 mphase_txcal_bestcoeffs[11];
+	chanspec_t nphy_txiqlocal_chanspec;
+	chanspec_t nphy_iqcal_chanspec_2G;
+	chanspec_t nphy_iqcal_chanspec_5G;
+	chanspec_t nphy_rssical_chanspec_2G;
+	chanspec_t nphy_rssical_chanspec_5G;
+	struct wlapi_timer *phycal_timer;
+	bool use_int_tx_iqlo_cal_nphy;
+	bool internal_tx_iqlo_cal_tapoff_intpa_nphy;
+	int16 nphy_lastcal_temp;
+
+	txiqcal_cache_t calibration_cache;
+	rssical_cache_t rssical_cache;
+
+	uint8 nphy_txpwr_idx[2];
+	uint8 nphy_papd_cal_type;
+	uint nphy_papd_last_cal;
+	uint16 nphy_papd_tx_gain_at_last_cal[2];
+	uint8 nphy_papd_cal_gain_index[2];
+	int16 nphy_papd_epsilon_offset[2];
+	bool nphy_papd_recal_enable;
+	uint32 nphy_papd_recal_counter;
+	bool nphy_force_papd_cal;
+	bool nphy_papdcomp;
+	bool ipa2g_on;
+	bool ipa5g_on;
+
+	uint16 classifier_state;
+	uint16 clip_state[2];
+	uint nphy_deaf_count;
+	uint8 rxiq_samps;
+	uint8 rxiq_antsel;
+
+	uint16 rfctrlIntc1_save;
+	uint16 rfctrlIntc2_save;
+	bool first_cal_after_assoc;
+	uint16 tx_rx_cal_radio_saveregs[22];
+	uint16 tx_rx_cal_phy_saveregs[15];
+
+	uint8 nphy_cal_orig_pwr_idx[2];
+	uint8 nphy_txcal_pwr_idx[2];
+	uint8 nphy_rxcal_pwr_idx[2];
+	uint16 nphy_cal_orig_tx_gain[2];
+	nphy_txgains_t nphy_cal_target_gain;
+	uint16 nphy_txcal_bbmult;
+	uint16 nphy_gmval;
+
+	uint16 nphy_saved_bbconf;
+
+	bool nphy_gband_spurwar_en;
+	bool nphy_gband_spurwar2_en;
+	bool nphy_aband_spurwar_en;
+	uint16 nphy_rccal_value;
+	uint16 nphy_crsminpwr[3];
+	phy_noisevar_buf_t nphy_saved_noisevars;
+	bool nphy_anarxlpf_adjusted;
+	bool nphy_crsminpwr_adjusted;
+	bool nphy_noisevars_adjusted;
+
+	bool nphy_rxcal_active;
+	uint16 radar_percal_mask;
+	bool dfs_lp_buffer_nphy;
+
+	uint16 nphy_fineclockgatecontrol;
+
+	int8 rx2tx_biasentry;
+
+	uint16 crsminpwr0;
+	uint16 crsminpwrl0;
+	uint16 crsminpwru0;
+	int16 noise_crsminpwr_index;
+	uint16 init_gain_core1;
+	uint16 init_gain_core2;
+	uint16 init_gainb_core1;
+	uint16 init_gainb_core2;
+	uint8 aci_noise_curr_channel;
+	uint16 init_gain_rfseq[4];
+
+	bool radio_is_on;
+
+	bool nphy_sample_play_lpf_bw_ctl_ovr;
+
+	uint16 tbl_data_hi;
+	uint16 tbl_data_lo;
+	uint16 tbl_addr;
+
+	uint tbl_save_id;
+	uint tbl_save_offset;
+
+	uint8 txpwrctrl;
+	int8 txpwrindex[PHY_CORE_MAX];
+
+	uint8 phycal_tempdelta;
+	uint32 mcs20_po;
+	uint32 mcs40_po;
+};
+
+typedef int32 fixed;
+
+typedef struct _cint32 {
+	fixed q;
+	fixed i;
+} cint32;
+
+typedef struct radio_regs {
+	uint16 address;
+	uint32 init_a;
+	uint32 init_g;
+	uint8 do_init_a;
+	uint8 do_init_g;
+} radio_regs_t;
+
+typedef struct radio_20xx_regs {
+	uint16 address;
+	uint8 init;
+	uint8 do_init;
+} radio_20xx_regs_t;
+
+typedef struct lcnphy_radio_regs {
+	uint16 address;
+	uint8 init_a;
+	uint8 init_g;
+	uint8 do_init_a;
+	uint8 do_init_g;
+} lcnphy_radio_regs_t;
+
+extern lcnphy_radio_regs_t lcnphy_radio_regs_2064[];
+extern lcnphy_radio_regs_t lcnphy_radio_regs_2066[];
+extern radio_regs_t regs_2055[], regs_SYN_2056[], regs_TX_2056[],
+    regs_RX_2056[];
+extern radio_regs_t regs_SYN_2056_A1[], regs_TX_2056_A1[], regs_RX_2056_A1[];
+extern radio_regs_t regs_SYN_2056_rev5[], regs_TX_2056_rev5[],
+    regs_RX_2056_rev5[];
+extern radio_regs_t regs_SYN_2056_rev6[], regs_TX_2056_rev6[],
+    regs_RX_2056_rev6[];
+extern radio_regs_t regs_SYN_2056_rev7[], regs_TX_2056_rev7[],
+    regs_RX_2056_rev7[];
+extern radio_regs_t regs_SYN_2056_rev8[], regs_TX_2056_rev8[],
+    regs_RX_2056_rev8[];
+extern radio_20xx_regs_t regs_2057_rev4[], regs_2057_rev5[], regs_2057_rev5v1[];
+extern radio_20xx_regs_t regs_2057_rev7[], regs_2057_rev8[];
+
+extern char *phy_getvar(phy_info_t * pi, const char *name);
+extern int phy_getintvar(phy_info_t * pi, const char *name);
+#define PHY_GETVAR(pi, name)	phy_getvar(pi, name)
+#define PHY_GETINTVAR(pi, name)	phy_getintvar(pi, name)
+
+extern uint16 read_phy_reg(phy_info_t * pi, uint16 addr);
+extern void write_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
+extern void and_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
+extern void or_phy_reg(phy_info_t * pi, uint16 addr, uint16 val);
+extern void mod_phy_reg(phy_info_t * pi, uint16 addr, uint16 mask, uint16 val);
+
+extern uint16 read_radio_reg(phy_info_t * pi, uint16 addr);
+extern void or_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
+extern void and_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
+extern void mod_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask,
+			  uint16 val);
+extern void xor_radio_reg(phy_info_t * pi, uint16 addr, uint16 mask);
+
+extern void write_radio_reg(phy_info_t * pi, uint16 addr, uint16 val);
+
+extern void wlc_phyreg_enter(wlc_phy_t * pih);
+extern void wlc_phyreg_exit(wlc_phy_t * pih);
+extern void wlc_radioreg_enter(wlc_phy_t * pih);
+extern void wlc_radioreg_exit(wlc_phy_t * pih);
+
+extern void wlc_phy_read_table(phy_info_t * pi, const phytbl_info_t * ptbl_info,
+			       uint16 tblAddr, uint16 tblDataHi,
+			       uint16 tblDatalo);
+extern void wlc_phy_write_table(phy_info_t * pi,
+				const phytbl_info_t * ptbl_info, uint16 tblAddr,
+				uint16 tblDataHi, uint16 tblDatalo);
+extern void wlc_phy_table_addr(phy_info_t * pi, uint tbl_id, uint tbl_offset,
+			       uint16 tblAddr, uint16 tblDataHi,
+			       uint16 tblDataLo);
+extern void wlc_phy_table_data_write(phy_info_t * pi, uint width, uint32 val);
+
+extern void write_phy_channel_reg(phy_info_t * pi, uint val);
+extern void wlc_phy_txpower_update_shm(phy_info_t * pi);
+
+extern void wlc_phy_cordic(fixed theta, cint32 * val);
+extern uint8 wlc_phy_nbits(int32 value);
+extern uint32 wlc_phy_sqrt_int(uint32 value);
+extern void wlc_phy_compute_dB(uint32 * cmplx_pwr, int8 * p_dB, uint8 core);
+
+extern uint wlc_phy_init_radio_regs_allbands(phy_info_t * pi,
+					     radio_20xx_regs_t * radioregs);
+extern uint wlc_phy_init_radio_regs(phy_info_t * pi, radio_regs_t * radioregs,
+				    uint16 core_offset);
+
+extern void wlc_phy_txpower_ipa_upd(phy_info_t * pi);
+
+extern void wlc_phy_do_dummy_tx(phy_info_t * pi, bool ofdm, bool pa_on);
+extern void wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 * eps_real,
+					int32 * eps_imag);
+
+extern void wlc_phy_cal_perical_mphase_reset(phy_info_t * pi);
+extern void wlc_phy_cal_perical_mphase_restart(phy_info_t * pi);
+
+extern bool wlc_phy_attach_nphy(phy_info_t * pi);
+extern bool wlc_phy_attach_lcnphy(phy_info_t * pi);
+
+extern void wlc_phy_detach_lcnphy(phy_info_t * pi);
+
+extern void wlc_phy_init_nphy(phy_info_t * pi);
+extern void wlc_phy_init_lcnphy(phy_info_t * pi);
+
+extern void wlc_phy_cal_init_nphy(phy_info_t * pi);
+extern void wlc_phy_cal_init_lcnphy(phy_info_t * pi);
+
+extern void wlc_phy_chanspec_set_nphy(phy_info_t * pi, chanspec_t chanspec);
+extern void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec);
+extern void wlc_phy_chanspec_set_fixup_lcnphy(phy_info_t * pi,
+					      chanspec_t chanspec);
+extern int wlc_phy_channel2freq(uint channel);
+extern int wlc_phy_chanspec_freq2bandrange_lpssn(uint);
+extern int wlc_phy_chanspec_bandrange_get(phy_info_t *, chanspec_t);
+
+extern void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t * pi, uint16 mode);
+extern int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t * pi);
+
+extern void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi);
+extern void wlc_lcnphy_txpower_recalc_target(phy_info_t * pi);
+extern void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t * pi);
+
+extern void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index);
+extern void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable);
+extern void wlc_lcnphy_stop_tx_tone(phy_info_t * pi);
+extern void wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz,
+				     uint16 max_val, bool iqcalmode);
+
+extern void wlc_phy_txpower_sromlimit_get_nphy(phy_info_t * pi, uint chan,
+					       uint8 * max_pwr, uint8 rate_id);
+extern void wlc_phy_ofdm_to_mcs_powers_nphy(uint8 * power, uint8 rate_mcs_start,
+					    uint8 rate_mcs_end,
+					    uint8 rate_ofdm_start);
+extern void wlc_phy_mcs_to_ofdm_powers_nphy(uint8 * power,
+					    uint8 rate_ofdm_start,
+					    uint8 rate_ofdm_end,
+					    uint8 rate_mcs_start);
+
+extern uint16 wlc_lcnphy_tempsense(phy_info_t * pi, bool mode);
+extern int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode);
+extern int8 wlc_lcnphy_tempsense_degree(phy_info_t * pi, bool mode);
+extern int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode);
+extern void wlc_phy_carrier_suppress_lcnphy(phy_info_t * pi);
+extern void wlc_lcnphy_crsuprs(phy_info_t * pi, int channel);
+extern void wlc_lcnphy_epa_switch(phy_info_t * pi, bool mode);
+extern void wlc_2064_vco_cal(phy_info_t * pi);
+
+extern void wlc_phy_txpower_recalc_target(phy_info_t * pi);
+extern uint32 wlc_phy_qdiv_roundup(uint32 dividend, uint32 divisor,
+				   uint8 precision);
+
+#define LCNPHY_TBL_ID_PAPDCOMPDELTATBL	0x18
+#define LCNPHY_TX_POWER_TABLE_SIZE	128
+#define LCNPHY_MAX_TX_POWER_INDEX	(LCNPHY_TX_POWER_TABLE_SIZE - 1)
+#define LCNPHY_TBL_ID_TXPWRCTL 	0x07
+#define LCNPHY_TX_PWR_CTRL_OFF	0
+#define LCNPHY_TX_PWR_CTRL_SW		(0x1 << 15)
+#define LCNPHY_TX_PWR_CTRL_HW         ((0x1 << 15) | \
+					(0x1 << 14) | \
+					(0x1 << 13))
+
+#define LCNPHY_TX_PWR_CTRL_TEMPBASED	0xE001
+
+extern void wlc_lcnphy_write_table(phy_info_t * pi, const phytbl_info_t * pti);
+extern void wlc_lcnphy_read_table(phy_info_t * pi, phytbl_info_t * pti);
+extern void wlc_lcnphy_set_tx_iqcc(phy_info_t * pi, uint16 a, uint16 b);
+extern void wlc_lcnphy_set_tx_locc(phy_info_t * pi, uint16 didq);
+extern void wlc_lcnphy_get_tx_iqcc(phy_info_t * pi, uint16 * a, uint16 * b);
+extern uint16 wlc_lcnphy_get_tx_locc(phy_info_t * pi);
+extern void wlc_lcnphy_get_radio_loft(phy_info_t * pi, uint8 * ei0,
+				      uint8 * eq0, uint8 * fi0, uint8 * fq0);
+extern void wlc_lcnphy_calib_modes(phy_info_t * pi, uint mode);
+extern void wlc_lcnphy_deaf_mode(phy_info_t * pi, bool mode);
+extern bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t * pi);
+extern void wlc_lcnphy_tx_pwr_update_npt(phy_info_t * pi);
+extern int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1);
+extern void wlc_lcnphy_get_tssi(phy_info_t * pi, int8 * ofdm_pwr,
+				int8 * cck_pwr);
+extern void wlc_lcnphy_tx_power_adjustment(wlc_phy_t * ppi);
+
+extern int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index);
+
+#define NPHY_MAX_HPVGA1_INDEX		10
+#define NPHY_DEF_HPVGA1_INDEXLIMIT	7
+
+typedef struct _phy_iq_est {
+	int32 iq_prod;
+	uint32 i_pwr;
+	uint32 q_pwr;
+} phy_iq_est_t;
+
+extern void wlc_phy_stay_in_carriersearch_nphy(phy_info_t * pi, bool enable);
+extern void wlc_nphy_deaf_mode(phy_info_t * pi, bool mode);
+
+#define wlc_phy_write_table_nphy(pi, pti)	wlc_phy_write_table(pi, pti, 0x72, \
+	0x74, 0x73)
+#define wlc_phy_read_table_nphy(pi, pti)	wlc_phy_read_table(pi, pti, 0x72, \
+	0x74, 0x73)
+#define wlc_nphy_table_addr(pi, id, off)	wlc_phy_table_addr((pi), (id), (off), \
+	0x72, 0x74, 0x73)
+#define wlc_nphy_table_data_write(pi, w, v)	wlc_phy_table_data_write((pi), (w), (v))
+
+extern void wlc_phy_table_read_nphy(phy_info_t * pi, uint32, uint32 l, uint32 o,
+				    uint32 w, void *d);
+extern void wlc_phy_table_write_nphy(phy_info_t * pi, uint32, uint32, uint32,
+				     uint32, const void *);
+
+#define	PHY_IPA(pi) \
+	((pi->ipa2g_on && CHSPEC_IS2G(pi->radio_chanspec)) || \
+	 (pi->ipa5g_on && CHSPEC_IS5G(pi->radio_chanspec)))
+
+#define WLC_PHY_WAR_PR51571(pi) \
+	if ((BUSTYPE((pi)->sh->bustype) == PCI_BUS) && NREV_LT((pi)->pubpi.phy_rev, 3)) \
+		(void)R_REG((pi)->sh->osh, &(pi)->regs->maccontrol)
+
+extern void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype);
+extern void wlc_phy_aci_reset_nphy(phy_info_t * pi);
+extern void wlc_phy_pa_override_nphy(phy_info_t * pi, bool en);
+
+extern uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t * pi, uint chan);
+extern void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on);
+
+extern void wlc_phy_stf_chain_upd_nphy(phy_info_t * pi);
+
+extern void wlc_phy_force_rfseq_nphy(phy_info_t * pi, uint8 cmd);
+extern int16 wlc_phy_tempsense_nphy(phy_info_t * pi);
+
+extern uint16 wlc_phy_classifier_nphy(phy_info_t * pi, uint16 mask, uint16 val);
+
+extern void wlc_phy_rx_iq_est_nphy(phy_info_t * pi, phy_iq_est_t * est,
+				   uint16 num_samps, uint8 wait_time,
+				   uint8 wait_for_crs);
+
+extern void wlc_phy_rx_iq_coeffs_nphy(phy_info_t * pi, uint8 write,
+				      nphy_iq_comp_t * comp);
+extern void wlc_phy_aci_and_noise_reduction_nphy(phy_info_t * pi);
+
+extern void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask);
+extern uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t * pih);
+
+extern void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type);
+extern void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi);
+extern void wlc_phy_txpwr_apply_nphy(phy_info_t * pi);
+extern void wlc_phy_txpwr_papd_cal_nphy(phy_info_t * pi);
+extern uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t * pi);
+
+extern nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t * pi);
+extern int wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+				   bool full, bool m);
+extern int wlc_phy_cal_rxiq_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+				 uint8 type, bool d);
+extern void wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask,
+				     int8 txpwrindex, bool res);
+extern void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core, uint8 rssi_type);
+extern int wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type,
+				  int32 * rssi_buf, uint8 nsamps);
+extern void wlc_phy_rssi_cal_nphy(phy_info_t * pi);
+extern int wlc_phy_aci_scan_nphy(phy_info_t * pi);
+extern void wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower,
+					bool debug);
+extern int wlc_phy_tx_tone_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
+				uint8 mode, uint8, bool);
+extern void wlc_phy_stopplayback_nphy(phy_info_t * pi);
+extern void wlc_phy_est_tonepwr_nphy(phy_info_t * pi, int32 * qdBm_pwrbuf,
+				     uint8 num_samps);
+extern void wlc_phy_radio205x_vcocal_nphy(phy_info_t * pi);
+
+extern int wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh);
+
+#define NPHY_TESTPATTERN_BPHY_EVM   0
+#define NPHY_TESTPATTERN_BPHY_RFCS  1
+
+extern void wlc_phy_nphy_tkip_rifs_war(phy_info_t * pi, uint8 rifs);
+
+void wlc_phy_get_pwrdet_offsets(phy_info_t * pi, int8 * cckoffset,
+				int8 * ofdmoffset);
+extern int8 wlc_phy_upd_rssi_offset(phy_info_t * pi, int8 rssi,
+				    chanspec_t chanspec);
+
+extern bool wlc_phy_n_txpower_ipa_ison(phy_info_t * pih);
+#endif				/* _wlc_phy_int_h_ */
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_lcn.c b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
new file mode 100644
index 0000000..5953841
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.c
@@ -0,0 +1,5312 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <qmath.h>
+#include <osl.h>
+#include <siutils.h>
+#include <bitfuncs.h>
+#include <hndpmu.h>
+
+#include <wlc_phy_radio.h>
+#include <wlc_phy_int.h>
+#include <wlc_phy_lcn.h>
+#include <wlc_phytbl_lcn.h>
+
+#define PLL_2064_NDIV		90
+#define PLL_2064_LOW_END_VCO 	3000
+#define PLL_2064_LOW_END_KVCO 	27
+#define PLL_2064_HIGH_END_VCO	4200
+#define PLL_2064_HIGH_END_KVCO	68
+#define PLL_2064_LOOP_BW_DOUBLER	200
+#define PLL_2064_D30_DOUBLER		10500
+#define PLL_2064_LOOP_BW	260
+#define PLL_2064_D30		8000
+#define PLL_2064_CAL_REF_TO	8
+#define PLL_2064_MHZ		1000000
+#define PLL_2064_OPEN_LOOP_DELAY	5
+
+#define TEMPSENSE 			1
+#define VBATSENSE           2
+
+#define NOISE_IF_UPD_CHK_INTERVAL	1
+#define NOISE_IF_UPD_RST_INTERVAL	60
+#define NOISE_IF_UPD_THRESHOLD_CNT	1
+#define NOISE_IF_UPD_TRHRESHOLD	50
+#define NOISE_IF_UPD_TIMEOUT		1000
+#define NOISE_IF_OFF			0
+#define NOISE_IF_CHK			1
+#define NOISE_IF_ON			2
+
+#define PAPD_BLANKING_PROFILE 		3
+#define PAPD2LUT			0
+#define PAPD_CORR_NORM 			0
+#define PAPD_BLANKING_THRESHOLD 	0
+#define PAPD_STOP_AFTER_LAST_UPDATE	0
+
+#define LCN_TARGET_PWR  60
+
+#define LCN_VBAT_OFFSET_433X 34649679
+#define LCN_VBAT_SLOPE_433X  8258032
+
+#define LCN_VBAT_SCALE_NOM  53
+#define LCN_VBAT_SCALE_DEN  432
+
+#define LCN_TEMPSENSE_OFFSET  80812
+#define LCN_TEMPSENSE_DEN  2647
+
+#define LCNPHY_txgainctrlovrval1_pagain_ovr_val1_SHIFT \
+	(0 + 8)
+#define LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK \
+	(0x7f << LCNPHY_txgainctrlovrval1_pagain_ovr_val1_SHIFT)
+
+#define LCNPHY_stxtxgainctrlovrval1_pagain_ovr_val1_SHIFT \
+	(0 + 8)
+#define LCNPHY_stxtxgainctrlovrval1_pagain_ovr_val1_MASK \
+	(0x7f << LCNPHY_stxtxgainctrlovrval1_pagain_ovr_val1_SHIFT)
+
+#define wlc_lcnphy_enable_tx_gain_override(pi) \
+	wlc_lcnphy_set_tx_gain_override(pi, TRUE)
+#define wlc_lcnphy_disable_tx_gain_override(pi) \
+	wlc_lcnphy_set_tx_gain_override(pi, FALSE)
+
+#define wlc_lcnphy_iqcal_active(pi)	\
+	(read_phy_reg((pi), 0x451) & \
+	((0x1 << 15) | (0x1 << 14)))
+
+#define txpwrctrl_off(pi) (0x7 != ((read_phy_reg(pi, 0x4a4) & 0xE000) >> 13))
+#define wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi) \
+	(pi->temppwrctrl_capable)
+#define wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi) \
+	(pi->hwpwrctrl_capable)
+
+#define SWCTRL_BT_TX		0x18
+#define SWCTRL_OVR_DISABLE	0x40
+
+#define	AFE_CLK_INIT_MODE_TXRX2X	1
+#define	AFE_CLK_INIT_MODE_PAPD		0
+
+#define LCNPHY_TBL_ID_IQLOCAL			0x00
+
+#define LCNPHY_TBL_ID_RFSEQ         0x08
+#define LCNPHY_TBL_ID_GAIN_IDX		0x0d
+#define LCNPHY_TBL_ID_SW_CTRL			0x0f
+#define LCNPHY_TBL_ID_GAIN_TBL		0x12
+#define LCNPHY_TBL_ID_SPUR			0x14
+#define LCNPHY_TBL_ID_SAMPLEPLAY		0x15
+#define LCNPHY_TBL_ID_SAMPLEPLAY1		0x16
+
+#define LCNPHY_TX_PWR_CTRL_RATE_OFFSET 	832
+#define LCNPHY_TX_PWR_CTRL_MAC_OFFSET 	128
+#define LCNPHY_TX_PWR_CTRL_GAIN_OFFSET 	192
+#define LCNPHY_TX_PWR_CTRL_IQ_OFFSET		320
+#define LCNPHY_TX_PWR_CTRL_LO_OFFSET		448
+#define LCNPHY_TX_PWR_CTRL_PWR_OFFSET		576
+
+#define LCNPHY_TX_PWR_CTRL_START_INDEX_2G_4313	140
+
+#define LCNPHY_TX_PWR_CTRL_START_NPT		1
+#define LCNPHY_TX_PWR_CTRL_MAX_NPT			7
+
+#define LCNPHY_NOISE_SAMPLES_DEFAULT 5000
+
+#define LCNPHY_ACI_DETECT_START      1
+#define LCNPHY_ACI_DETECT_PROGRESS   2
+#define LCNPHY_ACI_DETECT_STOP       3
+
+#define LCNPHY_ACI_CRSHIFRMLO_TRSH 100
+#define LCNPHY_ACI_GLITCH_TRSH 2000
+#define	LCNPHY_ACI_TMOUT 250
+#define LCNPHY_ACI_DETECT_TIMEOUT  2
+#define LCNPHY_ACI_START_DELAY 0
+
+#define wlc_lcnphy_tx_gain_override_enabled(pi) \
+	(0 != (read_phy_reg((pi), 0x43b) & (0x1 << 6)))
+
+#define wlc_lcnphy_total_tx_frames(pi) \
+	wlapi_bmac_read_shm((pi)->sh->physhim, M_UCODE_MACSTAT + OFFSETOF(macstat_t, txallfrm))
+
+typedef struct {
+	uint16 gm_gain;
+	uint16 pga_gain;
+	uint16 pad_gain;
+	uint16 dac_gain;
+} lcnphy_txgains_t;
+
+typedef enum {
+	LCNPHY_CAL_FULL,
+	LCNPHY_CAL_RECAL,
+	LCNPHY_CAL_CURRECAL,
+	LCNPHY_CAL_DIGCAL,
+	LCNPHY_CAL_GCTRL
+} lcnphy_cal_mode_t;
+
+typedef struct {
+	lcnphy_txgains_t gains;
+	bool useindex;
+	uint8 index;
+} lcnphy_txcalgains_t;
+
+typedef struct {
+	uint8 chan;
+	int16 a;
+	int16 b;
+} lcnphy_rx_iqcomp_t;
+
+typedef struct {
+	int16 re;
+	int16 im;
+} lcnphy_spb_tone_t;
+
+typedef struct {
+	uint16 re;
+	uint16 im;
+} lcnphy_unsign16_struct;
+
+typedef struct {
+	uint32 iq_prod;
+	uint32 i_pwr;
+	uint32 q_pwr;
+} lcnphy_iq_est_t;
+
+typedef struct {
+	uint16 ptcentreTs20;
+	uint16 ptcentreFactor;
+} lcnphy_sfo_cfg_t;
+
+typedef enum {
+	LCNPHY_PAPD_CAL_CW,
+	LCNPHY_PAPD_CAL_OFDM
+} lcnphy_papd_cal_type_t;
+
+typedef uint16 iqcal_gain_params_lcnphy[9];
+
+static const iqcal_gain_params_lcnphy tbl_iqcal_gainparams_lcnphy_2G[] = {
+	{0, 0, 0, 0, 0, 0, 0, 0, 0},
+};
+
+static const iqcal_gain_params_lcnphy *tbl_iqcal_gainparams_lcnphy[1] = {
+	tbl_iqcal_gainparams_lcnphy_2G,
+};
+
+static const uint16 iqcal_gainparams_numgains_lcnphy[1] = {
+	sizeof(tbl_iqcal_gainparams_lcnphy_2G) /
+	    sizeof(*tbl_iqcal_gainparams_lcnphy_2G),
+};
+
+static const lcnphy_sfo_cfg_t lcnphy_sfo_cfg[] = {
+	{965, 1087},
+	{967, 1085},
+	{969, 1082},
+	{971, 1080},
+	{973, 1078},
+	{975, 1076},
+	{977, 1073},
+	{979, 1071},
+	{981, 1069},
+	{983, 1067},
+	{985, 1065},
+	{987, 1063},
+	{989, 1060},
+	{994, 1055}
+};
+
+static const
+uint16 lcnphy_iqcal_loft_gainladder[] = {
+	((2 << 8) | 0),
+	((3 << 8) | 0),
+	((4 << 8) | 0),
+	((6 << 8) | 0),
+	((8 << 8) | 0),
+	((11 << 8) | 0),
+	((16 << 8) | 0),
+	((16 << 8) | 1),
+	((16 << 8) | 2),
+	((16 << 8) | 3),
+	((16 << 8) | 4),
+	((16 << 8) | 5),
+	((16 << 8) | 6),
+	((16 << 8) | 7),
+	((23 << 8) | 7),
+	((32 << 8) | 7),
+	((45 << 8) | 7),
+	((64 << 8) | 7),
+	((91 << 8) | 7),
+	((128 << 8) | 7)
+};
+
+static const
+uint16 lcnphy_iqcal_ir_gainladder[] = {
+	((1 << 8) | 0),
+	((2 << 8) | 0),
+	((4 << 8) | 0),
+	((6 << 8) | 0),
+	((8 << 8) | 0),
+	((11 << 8) | 0),
+	((16 << 8) | 0),
+	((23 << 8) | 0),
+	((32 << 8) | 0),
+	((45 << 8) | 0),
+	((64 << 8) | 0),
+	((64 << 8) | 1),
+	((64 << 8) | 2),
+	((64 << 8) | 3),
+	((64 << 8) | 4),
+	((64 << 8) | 5),
+	((64 << 8) | 6),
+	((64 << 8) | 7),
+	((91 << 8) | 7),
+	((128 << 8) | 7)
+};
+
+static const
+lcnphy_spb_tone_t lcnphy_spb_tone_3750[] = {
+	{88, 0},
+	{73, 49},
+	{34, 81},
+	{-17, 86},
+	{-62, 62},
+	{-86, 17},
+	{-81, -34},
+	{-49, -73},
+	{0, -88},
+	{49, -73},
+	{81, -34},
+	{86, 17},
+	{62, 62},
+	{17, 86},
+	{-34, 81},
+	{-73, 49},
+	{-88, 0},
+	{-73, -49},
+	{-34, -81},
+	{17, -86},
+	{62, -62},
+	{86, -17},
+	{81, 34},
+	{49, 73},
+	{0, 88},
+	{-49, 73},
+	{-81, 34},
+	{-86, -17},
+	{-62, -62},
+	{-17, -86},
+	{34, -81},
+	{73, -49},
+};
+
+static const
+uint16 iqlo_loopback_rf_regs[20] = {
+	RADIO_2064_REG036,
+	RADIO_2064_REG11A,
+	RADIO_2064_REG03A,
+	RADIO_2064_REG025,
+	RADIO_2064_REG028,
+	RADIO_2064_REG005,
+	RADIO_2064_REG112,
+	RADIO_2064_REG0FF,
+	RADIO_2064_REG11F,
+	RADIO_2064_REG00B,
+	RADIO_2064_REG113,
+	RADIO_2064_REG007,
+	RADIO_2064_REG0FC,
+	RADIO_2064_REG0FD,
+	RADIO_2064_REG012,
+	RADIO_2064_REG057,
+	RADIO_2064_REG059,
+	RADIO_2064_REG05C,
+	RADIO_2064_REG078,
+	RADIO_2064_REG092,
+};
+
+static const
+uint16 tempsense_phy_regs[14] = {
+	0x503,
+	0x4a4,
+	0x4d0,
+	0x4d9,
+	0x4da,
+	0x4a6,
+	0x938,
+	0x939,
+	0x4d8,
+	0x4d0,
+	0x4d7,
+	0x4a5,
+	0x40d,
+	0x4a2,
+};
+
+static const
+uint16 rxiq_cal_rf_reg[11] = {
+	RADIO_2064_REG098,
+	RADIO_2064_REG116,
+	RADIO_2064_REG12C,
+	RADIO_2064_REG06A,
+	RADIO_2064_REG00B,
+	RADIO_2064_REG01B,
+	RADIO_2064_REG113,
+	RADIO_2064_REG01D,
+	RADIO_2064_REG114,
+	RADIO_2064_REG02E,
+	RADIO_2064_REG12A,
+};
+
+static const
+lcnphy_rx_iqcomp_t lcnphy_rx_iqcomp_table_rev0[] = {
+	{1, 0, 0},
+	{2, 0, 0},
+	{3, 0, 0},
+	{4, 0, 0},
+	{5, 0, 0},
+	{6, 0, 0},
+	{7, 0, 0},
+	{8, 0, 0},
+	{9, 0, 0},
+	{10, 0, 0},
+	{11, 0, 0},
+	{12, 0, 0},
+	{13, 0, 0},
+	{14, 0, 0},
+	{34, 0, 0},
+	{38, 0, 0},
+	{42, 0, 0},
+	{46, 0, 0},
+	{36, 0, 0},
+	{40, 0, 0},
+	{44, 0, 0},
+	{48, 0, 0},
+	{52, 0, 0},
+	{56, 0, 0},
+	{60, 0, 0},
+	{64, 0, 0},
+	{100, 0, 0},
+	{104, 0, 0},
+	{108, 0, 0},
+	{112, 0, 0},
+	{116, 0, 0},
+	{120, 0, 0},
+	{124, 0, 0},
+	{128, 0, 0},
+	{132, 0, 0},
+	{136, 0, 0},
+	{140, 0, 0},
+	{149, 0, 0},
+	{153, 0, 0},
+	{157, 0, 0},
+	{161, 0, 0},
+	{165, 0, 0},
+	{184, 0, 0},
+	{188, 0, 0},
+	{192, 0, 0},
+	{196, 0, 0},
+	{200, 0, 0},
+	{204, 0, 0},
+	{208, 0, 0},
+	{212, 0, 0},
+	{216, 0, 0},
+};
+
+static const uint32 lcnphy_23bitgaincode_table[] = {
+	0x200100,
+	0x200200,
+	0x200004,
+	0x200014,
+	0x200024,
+	0x200034,
+	0x200134,
+	0x200234,
+	0x200334,
+	0x200434,
+	0x200037,
+	0x200137,
+	0x200237,
+	0x200337,
+	0x200437,
+	0x000035,
+	0x000135,
+	0x000235,
+	0x000037,
+	0x000137,
+	0x000237,
+	0x000337,
+	0x00013f,
+	0x00023f,
+	0x00033f,
+	0x00034f,
+	0x00044f,
+	0x00144f,
+	0x00244f,
+	0x00254f,
+	0x00354f,
+	0x00454f,
+	0x00464f,
+	0x01464f,
+	0x02464f,
+	0x03464f,
+	0x04464f,
+};
+
+static const int8 lcnphy_gain_table[] = {
+	-16,
+	-13,
+	10,
+	7,
+	4,
+	0,
+	3,
+	6,
+	9,
+	12,
+	15,
+	18,
+	21,
+	24,
+	27,
+	30,
+	33,
+	36,
+	39,
+	42,
+	45,
+	48,
+	50,
+	53,
+	56,
+	59,
+	62,
+	65,
+	68,
+	71,
+	74,
+	77,
+	80,
+	83,
+	86,
+	89,
+	92,
+};
+
+static const int8 lcnphy_gain_index_offset_for_rssi[] = {
+	7,
+	7,
+	7,
+	7,
+	7,
+	7,
+	7,
+	8,
+	7,
+	7,
+	6,
+	7,
+	7,
+	4,
+	4,
+	4,
+	4,
+	4,
+	4,
+	4,
+	4,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	4,
+	2,
+	2,
+	2,
+	2,
+	2,
+	2,
+	-1,
+	-2,
+	-2,
+	-2
+};
+
+extern CONST uint8 spur_tbl_rev0[];
+extern CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev1;
+extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[];
+extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa;
+extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250;
+
+typedef struct _chan_info_2064_lcnphy {
+	uint chan;
+	uint freq;
+	uint8 logen_buftune;
+	uint8 logen_rccr_tx;
+	uint8 txrf_mix_tune_ctrl;
+	uint8 pa_input_tune_g;
+	uint8 logen_rccr_rx;
+	uint8 pa_rxrf_lna1_freq_tune;
+	uint8 pa_rxrf_lna2_freq_tune;
+	uint8 rxrf_rxrf_spare1;
+} chan_info_2064_lcnphy_t;
+
+static chan_info_2064_lcnphy_t chan_info_2064_lcnphy[] = {
+	{1, 2412, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{2, 2417, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{3, 2422, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{4, 2427, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{5, 2432, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{6, 2437, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{7, 2442, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{8, 2447, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{9, 2452, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{10, 2457, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{11, 2462, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{12, 2467, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{13, 2472, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+	{14, 2484, 0x0B, 0x0A, 0x00, 0x07, 0x0A, 0x88, 0x88, 0x80},
+};
+
+lcnphy_radio_regs_t lcnphy_radio_regs_2064[] = {
+	{0x00, 0, 0, 0, 0},
+	{0x01, 0x64, 0x64, 0, 0},
+	{0x02, 0x20, 0x20, 0, 0},
+	{0x03, 0x66, 0x66, 0, 0},
+	{0x04, 0xf8, 0xf8, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0x10, 0x10, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0x37, 0x37, 0, 0},
+	{0x0B, 0x6, 0x6, 0, 0},
+	{0x0C, 0x55, 0x55, 0, 0},
+	{0x0D, 0x8b, 0x8b, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0x5, 0x5, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0xe, 0xe, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0xb, 0xb, 0, 0},
+	{0x14, 0x2, 0x2, 0, 0},
+	{0x15, 0x12, 0x12, 0, 0},
+	{0x16, 0x12, 0x12, 0, 0},
+	{0x17, 0xc, 0xc, 0, 0},
+	{0x18, 0xc, 0xc, 0, 0},
+	{0x19, 0xc, 0xc, 0, 0},
+	{0x1A, 0x8, 0x8, 0, 0},
+	{0x1B, 0x2, 0x2, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0x1, 0x1, 0, 0},
+	{0x1E, 0x12, 0x12, 0, 0},
+	{0x1F, 0x6e, 0x6e, 0, 0},
+	{0x20, 0x2, 0x2, 0, 0},
+	{0x21, 0x23, 0x23, 0, 0},
+	{0x22, 0x8, 0x8, 0, 0},
+	{0x23, 0, 0, 0, 0},
+	{0x24, 0, 0, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0x33, 0x33, 0, 0},
+	{0x27, 0x55, 0x55, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x30, 0x30, 0, 0},
+	{0x2A, 0xb, 0xb, 0, 0},
+	{0x2B, 0x1b, 0x1b, 0, 0},
+	{0x2C, 0x3, 0x3, 0, 0},
+	{0x2D, 0x1b, 0x1b, 0, 0},
+	{0x2E, 0, 0, 0, 0},
+	{0x2F, 0x20, 0x20, 0, 0},
+	{0x30, 0xa, 0xa, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0x62, 0x62, 0, 0},
+	{0x33, 0x19, 0x19, 0, 0},
+	{0x34, 0x33, 0x33, 0, 0},
+	{0x35, 0x77, 0x77, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x70, 0x70, 0, 0},
+	{0x38, 0x3, 0x3, 0, 0},
+	{0x39, 0xf, 0xf, 0, 0},
+	{0x3A, 0x6, 0x6, 0, 0},
+	{0x3B, 0xcf, 0xcf, 0, 0},
+	{0x3C, 0x1a, 0x1a, 0, 0},
+	{0x3D, 0x6, 0x6, 0, 0},
+	{0x3E, 0x42, 0x42, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0xfb, 0xfb, 0, 0},
+	{0x41, 0x9a, 0x9a, 0, 0},
+	{0x42, 0x7a, 0x7a, 0, 0},
+	{0x43, 0x29, 0x29, 0, 0},
+	{0x44, 0, 0, 0, 0},
+	{0x45, 0x8, 0x8, 0, 0},
+	{0x46, 0xce, 0xce, 0, 0},
+	{0x47, 0x27, 0x27, 0, 0},
+	{0x48, 0x62, 0x62, 0, 0},
+	{0x49, 0x6, 0x6, 0, 0},
+	{0x4A, 0x58, 0x58, 0, 0},
+	{0x4B, 0xf7, 0xf7, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0xb3, 0xb3, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0, 0, 0, 0},
+	{0x51, 0x9, 0x9, 0, 0},
+	{0x52, 0x5, 0x5, 0, 0},
+	{0x53, 0x17, 0x17, 0, 0},
+	{0x54, 0x38, 0x38, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0xb, 0xb, 0, 0},
+	{0x58, 0, 0, 0, 0},
+	{0x59, 0, 0, 0, 0},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0, 0, 0, 0},
+	{0x5C, 0, 0, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x88, 0x88, 0, 0},
+	{0x5F, 0xcc, 0xcc, 0, 0},
+	{0x60, 0x74, 0x74, 0, 0},
+	{0x61, 0x74, 0x74, 0, 0},
+	{0x62, 0x74, 0x74, 0, 0},
+	{0x63, 0x44, 0x44, 0, 0},
+	{0x64, 0x77, 0x77, 0, 0},
+	{0x65, 0x44, 0x44, 0, 0},
+	{0x66, 0x77, 0x77, 0, 0},
+	{0x67, 0x55, 0x55, 0, 0},
+	{0x68, 0x77, 0x77, 0, 0},
+	{0x69, 0x77, 0x77, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0x7f, 0x7f, 0, 0},
+	{0x6C, 0x8, 0x8, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0x88, 0x88, 0, 0},
+	{0x6F, 0x66, 0x66, 0, 0},
+	{0x70, 0x66, 0x66, 0, 0},
+	{0x71, 0x28, 0x28, 0, 0},
+	{0x72, 0x55, 0x55, 0, 0},
+	{0x73, 0x4, 0x4, 0, 0},
+	{0x74, 0, 0, 0, 0},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0, 0, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0xd6, 0xd6, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0xb4, 0xb4, 0, 0},
+	{0x84, 0x1, 0x1, 0, 0},
+	{0x85, 0x20, 0x20, 0, 0},
+	{0x86, 0x5, 0x5, 0, 0},
+	{0x87, 0xff, 0xff, 0, 0},
+	{0x88, 0x7, 0x7, 0, 0},
+	{0x89, 0x77, 0x77, 0, 0},
+	{0x8A, 0x77, 0x77, 0, 0},
+	{0x8B, 0x77, 0x77, 0, 0},
+	{0x8C, 0x77, 0x77, 0, 0},
+	{0x8D, 0x8, 0x8, 0, 0},
+	{0x8E, 0xa, 0xa, 0, 0},
+	{0x8F, 0x8, 0x8, 0, 0},
+	{0x90, 0x18, 0x18, 0, 0},
+	{0x91, 0x5, 0x5, 0, 0},
+	{0x92, 0x1f, 0x1f, 0, 0},
+	{0x93, 0x10, 0x10, 0, 0},
+	{0x94, 0x3, 0x3, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0xaa, 0xaa, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0x23, 0x23, 0, 0},
+	{0x9A, 0x7, 0x7, 0, 0},
+	{0x9B, 0xf, 0xf, 0, 0},
+	{0x9C, 0x10, 0x10, 0, 0},
+	{0x9D, 0x3, 0x3, 0, 0},
+	{0x9E, 0x4, 0x4, 0, 0},
+	{0x9F, 0x20, 0x20, 0, 0},
+	{0xA0, 0, 0, 0, 0},
+	{0xA1, 0, 0, 0, 0},
+	{0xA2, 0, 0, 0, 0},
+	{0xA3, 0, 0, 0, 0},
+	{0xA4, 0x1, 0x1, 0, 0},
+	{0xA5, 0x77, 0x77, 0, 0},
+	{0xA6, 0x77, 0x77, 0, 0},
+	{0xA7, 0x77, 0x77, 0, 0},
+	{0xA8, 0x77, 0x77, 0, 0},
+	{0xA9, 0x8c, 0x8c, 0, 0},
+	{0xAA, 0x88, 0x88, 0, 0},
+	{0xAB, 0x78, 0x78, 0, 0},
+	{0xAC, 0x57, 0x57, 0, 0},
+	{0xAD, 0x88, 0x88, 0, 0},
+	{0xAE, 0, 0, 0, 0},
+	{0xAF, 0x8, 0x8, 0, 0},
+	{0xB0, 0x88, 0x88, 0, 0},
+	{0xB1, 0, 0, 0, 0},
+	{0xB2, 0x1b, 0x1b, 0, 0},
+	{0xB3, 0x3, 0x3, 0, 0},
+	{0xB4, 0x24, 0x24, 0, 0},
+	{0xB5, 0x3, 0x3, 0, 0},
+	{0xB6, 0x1b, 0x1b, 0, 0},
+	{0xB7, 0x24, 0x24, 0, 0},
+	{0xB8, 0x3, 0x3, 0, 0},
+	{0xB9, 0, 0, 0, 0},
+	{0xBA, 0xaa, 0xaa, 0, 0},
+	{0xBB, 0, 0, 0, 0},
+	{0xBC, 0x4, 0x4, 0, 0},
+	{0xBD, 0, 0, 0, 0},
+	{0xBE, 0x8, 0x8, 0, 0},
+	{0xBF, 0x11, 0x11, 0, 0},
+	{0xC0, 0, 0, 0, 0},
+	{0xC1, 0, 0, 0, 0},
+	{0xC2, 0x62, 0x62, 0, 0},
+	{0xC3, 0x1e, 0x1e, 0, 0},
+	{0xC4, 0x33, 0x33, 0, 0},
+	{0xC5, 0x37, 0x37, 0, 0},
+	{0xC6, 0, 0, 0, 0},
+	{0xC7, 0x70, 0x70, 0, 0},
+	{0xC8, 0x1e, 0x1e, 0, 0},
+	{0xC9, 0x6, 0x6, 0, 0},
+	{0xCA, 0x4, 0x4, 0, 0},
+	{0xCB, 0x2f, 0x2f, 0, 0},
+	{0xCC, 0xf, 0xf, 0, 0},
+	{0xCD, 0, 0, 0, 0},
+	{0xCE, 0xff, 0xff, 0, 0},
+	{0xCF, 0x8, 0x8, 0, 0},
+	{0xD0, 0x3f, 0x3f, 0, 0},
+	{0xD1, 0x3f, 0x3f, 0, 0},
+	{0xD2, 0x3f, 0x3f, 0, 0},
+	{0xD3, 0, 0, 0, 0},
+	{0xD4, 0, 0, 0, 0},
+	{0xD5, 0, 0, 0, 0},
+	{0xD6, 0xcc, 0xcc, 0, 0},
+	{0xD7, 0, 0, 0, 0},
+	{0xD8, 0x8, 0x8, 0, 0},
+	{0xD9, 0x8, 0x8, 0, 0},
+	{0xDA, 0x8, 0x8, 0, 0},
+	{0xDB, 0x11, 0x11, 0, 0},
+	{0xDC, 0, 0, 0, 0},
+	{0xDD, 0x87, 0x87, 0, 0},
+	{0xDE, 0x88, 0x88, 0, 0},
+	{0xDF, 0x8, 0x8, 0, 0},
+	{0xE0, 0x8, 0x8, 0, 0},
+	{0xE1, 0x8, 0x8, 0, 0},
+	{0xE2, 0, 0, 0, 0},
+	{0xE3, 0, 0, 0, 0},
+	{0xE4, 0, 0, 0, 0},
+	{0xE5, 0xf5, 0xf5, 0, 0},
+	{0xE6, 0x30, 0x30, 0, 0},
+	{0xE7, 0x1, 0x1, 0, 0},
+	{0xE8, 0, 0, 0, 0},
+	{0xE9, 0xff, 0xff, 0, 0},
+	{0xEA, 0, 0, 0, 0},
+	{0xEB, 0, 0, 0, 0},
+	{0xEC, 0x22, 0x22, 0, 0},
+	{0xED, 0, 0, 0, 0},
+	{0xEE, 0, 0, 0, 0},
+	{0xEF, 0, 0, 0, 0},
+	{0xF0, 0x3, 0x3, 0, 0},
+	{0xF1, 0x1, 0x1, 0, 0},
+	{0xF2, 0, 0, 0, 0},
+	{0xF3, 0, 0, 0, 0},
+	{0xF4, 0, 0, 0, 0},
+	{0xF5, 0, 0, 0, 0},
+	{0xF6, 0, 0, 0, 0},
+	{0xF7, 0x6, 0x6, 0, 0},
+	{0xF8, 0, 0, 0, 0},
+	{0xF9, 0, 0, 0, 0},
+	{0xFA, 0x40, 0x40, 0, 0},
+	{0xFB, 0, 0, 0, 0},
+	{0xFC, 0x1, 0x1, 0, 0},
+	{0xFD, 0x80, 0x80, 0, 0},
+	{0xFE, 0x2, 0x2, 0, 0},
+	{0xFF, 0x10, 0x10, 0, 0},
+	{0x100, 0x2, 0x2, 0, 0},
+	{0x101, 0x1e, 0x1e, 0, 0},
+	{0x102, 0x1e, 0x1e, 0, 0},
+	{0x103, 0, 0, 0, 0},
+	{0x104, 0x1f, 0x1f, 0, 0},
+	{0x105, 0, 0x8, 0, 1},
+	{0x106, 0x2a, 0x2a, 0, 0},
+	{0x107, 0xf, 0xf, 0, 0},
+	{0x108, 0, 0, 0, 0},
+	{0x109, 0, 0, 0, 0},
+	{0x10A, 0, 0, 0, 0},
+	{0x10B, 0, 0, 0, 0},
+	{0x10C, 0, 0, 0, 0},
+	{0x10D, 0, 0, 0, 0},
+	{0x10E, 0, 0, 0, 0},
+	{0x10F, 0, 0, 0, 0},
+	{0x110, 0, 0, 0, 0},
+	{0x111, 0, 0, 0, 0},
+	{0x112, 0, 0, 0, 0},
+	{0x113, 0, 0, 0, 0},
+	{0x114, 0, 0, 0, 0},
+	{0x115, 0, 0, 0, 0},
+	{0x116, 0, 0, 0, 0},
+	{0x117, 0, 0, 0, 0},
+	{0x118, 0, 0, 0, 0},
+	{0x119, 0, 0, 0, 0},
+	{0x11A, 0, 0, 0, 0},
+	{0x11B, 0, 0, 0, 0},
+	{0x11C, 0x1, 0x1, 0, 0},
+	{0x11D, 0, 0, 0, 0},
+	{0x11E, 0, 0, 0, 0},
+	{0x11F, 0, 0, 0, 0},
+	{0x120, 0, 0, 0, 0},
+	{0x121, 0, 0, 0, 0},
+	{0x122, 0x80, 0x80, 0, 0},
+	{0x123, 0, 0, 0, 0},
+	{0x124, 0xf8, 0xf8, 0, 0},
+	{0x125, 0, 0, 0, 0},
+	{0x126, 0, 0, 0, 0},
+	{0x127, 0, 0, 0, 0},
+	{0x128, 0, 0, 0, 0},
+	{0x129, 0, 0, 0, 0},
+	{0x12A, 0, 0, 0, 0},
+	{0x12B, 0, 0, 0, 0},
+	{0x12C, 0, 0, 0, 0},
+	{0x12D, 0, 0, 0, 0},
+	{0x12E, 0, 0, 0, 0},
+	{0x12F, 0, 0, 0, 0},
+	{0x130, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+#define LCNPHY_NUM_DIG_FILT_COEFFS 16
+#define LCNPHY_NUM_TX_DIG_FILTERS_CCK 13
+
+uint16
+    LCNPHY_txdigfiltcoeffs_cck[LCNPHY_NUM_TX_DIG_FILTERS_CCK]
+    [LCNPHY_NUM_DIG_FILT_COEFFS + 1] = {
+	{0, 1, 415, 1874, 64, 128, 64, 792, 1656, 64, 128, 64, 778, 1582, 64,
+	 128, 64,},
+	{1, 1, 402, 1847, 259, 59, 259, 671, 1794, 68, 54, 68, 608, 1863, 93,
+	 167, 93,},
+	{2, 1, 415, 1874, 64, 128, 64, 792, 1656, 192, 384, 192, 778, 1582, 64,
+	 128, 64,},
+	{3, 1, 302, 1841, 129, 258, 129, 658, 1720, 205, 410, 205, 754, 1760,
+	 170, 340, 170,},
+	{20, 1, 360, 1884, 242, 1734, 242, 752, 1720, 205, 1845, 205, 767, 1760,
+	 256, 185, 256,},
+	{21, 1, 360, 1884, 149, 1874, 149, 752, 1720, 205, 1883, 205, 767, 1760,
+	 256, 273, 256,},
+	{22, 1, 360, 1884, 98, 1948, 98, 752, 1720, 205, 1924, 205, 767, 1760,
+	 256, 352, 256,},
+	{23, 1, 350, 1884, 116, 1966, 116, 752, 1720, 205, 2008, 205, 767, 1760,
+	 128, 233, 128,},
+	{24, 1, 325, 1884, 32, 40, 32, 756, 1720, 256, 471, 256, 766, 1760, 256,
+	 1881, 256,},
+	{25, 1, 299, 1884, 51, 64, 51, 736, 1720, 256, 471, 256, 765, 1760, 256,
+	 1881, 256,},
+	{26, 1, 277, 1943, 39, 117, 88, 637, 1838, 64, 192, 144, 614, 1864, 128,
+	 384, 288,},
+	{27, 1, 245, 1943, 49, 147, 110, 626, 1838, 256, 768, 576, 613, 1864,
+	 128, 384, 288,},
+	{30, 1, 302, 1841, 61, 122, 61, 658, 1720, 205, 410, 205, 754, 1760,
+	 170, 340, 170,},
+};
+
+#define LCNPHY_NUM_TX_DIG_FILTERS_OFDM 3
+uint16
+    LCNPHY_txdigfiltcoeffs_ofdm[LCNPHY_NUM_TX_DIG_FILTERS_OFDM]
+    [LCNPHY_NUM_DIG_FILT_COEFFS + 1] = {
+	{0, 0, 0xa2, 0x0, 0x100, 0x100, 0x0, 0x0, 0x0, 0x100, 0x0, 0x0,
+	 0x278, 0xfea0, 0x80, 0x100, 0x80,},
+	{1, 0, 374, 0xFF79, 16, 32, 16, 799, 0xFE74, 50, 32, 50,
+	 750, 0xFE2B, 212, 0xFFCE, 212,},
+	{2, 0, 375, 0xFF16, 37, 76, 37, 799, 0xFE74, 32, 20, 32, 748,
+	 0xFEF2, 128, 0xFFE2, 128}
+};
+
+#define wlc_lcnphy_set_start_tx_pwr_idx(pi, idx) \
+	mod_phy_reg(pi, 0x4a4, \
+		(0x1ff << 0), \
+		(uint16)(idx) << 0)
+
+#define wlc_lcnphy_set_tx_pwr_npt(pi, npt) \
+	mod_phy_reg(pi, 0x4a5, \
+		(0x7 << 8), \
+		(uint16)(npt) << 8)
+
+#define wlc_lcnphy_get_tx_pwr_ctrl(pi) \
+	(read_phy_reg((pi), 0x4a4) & \
+			((0x1 << 15) | \
+			(0x1 << 14) | \
+			(0x1 << 13)))
+
+#define wlc_lcnphy_get_tx_pwr_npt(pi) \
+	((read_phy_reg(pi, 0x4a5) & \
+		(0x7 << 8)) >> \
+		8)
+
+#define wlc_lcnphy_get_current_tx_pwr_idx_if_pwrctrl_on(pi) \
+	(read_phy_reg(pi, 0x473) & 0x1ff)
+
+#define wlc_lcnphy_get_target_tx_pwr(pi) \
+	((read_phy_reg(pi, 0x4a7) & \
+		(0xff << 0)) >> \
+		0)
+
+#define wlc_lcnphy_set_target_tx_pwr(pi, target) \
+	mod_phy_reg(pi, 0x4a7, \
+		(0xff << 0), \
+		(uint16)(target) << 0)
+
+#define wlc_radio_2064_rcal_done(pi) (0 != (read_radio_reg(pi, RADIO_2064_REG05C) & 0x20))
+#define tempsense_done(pi) (0x8000 == (read_phy_reg(pi, 0x476) & 0x8000))
+
+#define LCNPHY_IQLOCC_READ(val) ((uint8)(-(int8)(((val) & 0xf0) >> 4) + (int8)((val) & 0x0f)))
+#define FIXED_TXPWR 78
+#define LCNPHY_TEMPSENSE(val) ((int16)((val > 255)?(val - 512):val))
+
+static uint32 wlc_lcnphy_qdiv_roundup(uint32 divident, uint32 divisor,
+				      uint8 precision);
+static void wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t * pi,
+						   uint16 ext_lna, uint16 trsw,
+						   uint16 biq2, uint16 biq1,
+						   uint16 tia, uint16 lna2,
+						   uint16 lna1);
+static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t * pi);
+static void wlc_lcnphy_set_pa_gain(phy_info_t * pi, uint16 gain);
+static void wlc_lcnphy_set_trsw_override(phy_info_t * pi, bool tx, bool rx);
+static void wlc_lcnphy_set_bbmult(phy_info_t * pi, uint8 m0);
+static uint8 wlc_lcnphy_get_bbmult(phy_info_t * pi);
+static void wlc_lcnphy_get_tx_gain(phy_info_t * pi, lcnphy_txgains_t * gains);
+static void wlc_lcnphy_set_tx_gain_override(phy_info_t * pi, bool bEnable);
+static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t * pi);
+static void wlc_lcnphy_rx_gain_override_enable(phy_info_t * pi, bool enable);
+static void wlc_lcnphy_set_tx_gain(phy_info_t * pi,
+				   lcnphy_txgains_t * target_gains);
+static bool wlc_lcnphy_rx_iq_est(phy_info_t * pi, uint16 num_samps,
+				 uint8 wait_time, lcnphy_iq_est_t * iq_est);
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps);
+static uint16 wlc_lcnphy_get_pa_gain(phy_info_t * pi);
+static void wlc_lcnphy_afe_clk_init(phy_info_t * pi, uint8 mode);
+extern void wlc_lcnphy_tx_pwr_ctrl_init(wlc_phy_t * ppi);
+extern void wlc_lcnphy_pktengtx(wlc_phy_t * ppi, wl_pkteng_t * pkteng,
+				uint8 rate, struct ether_addr *sa,
+				uint32 wait_delay);
+static void wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi,
+						    uint8 channel);
+
+static void wlc_lcnphy_load_tx_gain_table(phy_info_t * pi,
+					  const lcnphy_tx_gain_tbl_entry * g);
+
+static void wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo,
+				uint16 thresh, int16 * ptr, int mode);
+static int wlc_lcnphy_calc_floor(int16 coeff, int type);
+static void wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi,
+					uint16 * values_to_save);
+static void wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t * pi,
+						uint16 * values_to_save);
+static void wlc_lcnphy_set_cc(phy_info_t * pi, int cal_type, int16 coeff_x,
+			      int16 coeff_y);
+static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t * pi, int cal_type);
+static void wlc_lcnphy_a1(phy_info_t * pi, int cal_type,
+			  int num_levels, int step_size_lg2);
+static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t * pi);
+
+static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi,
+					   chanspec_t chanspec);
+static void wlc_lcnphy_agc_temp_init(phy_info_t * pi);
+static void wlc_lcnphy_temp_adj(phy_info_t * pi);
+static void wlc_lcnphy_clear_papd_comptable(phy_info_t * pi);
+static void wlc_lcnphy_baseband_init(phy_info_t * pi);
+static void wlc_lcnphy_radio_init(phy_info_t * pi);
+static void wlc_lcnphy_rc_cal(phy_info_t * pi);
+static void wlc_lcnphy_rcal(phy_info_t * pi);
+static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t * pi, bool enable);
+static int wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm,
+					 int16 filt_type);
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t * pi, uint16 a, uint16 b);
+
+void wlc_lcnphy_write_table(phy_info_t * pi, const phytbl_info_t * pti)
+{
+	wlc_phy_write_table(pi, pti, 0x455, 0x457, 0x456);
+}
+
+void wlc_lcnphy_read_table(phy_info_t * pi, phytbl_info_t * pti)
+{
+	wlc_phy_read_table(pi, pti, 0x455, 0x457, 0x456);
+}
+
+static void
+wlc_lcnphy_common_read_table(phy_info_t * pi, uint32 tbl_id,
+			     CONST void *tbl_ptr, uint32 tbl_len,
+			     uint32 tbl_width, uint32 tbl_offset)
+{
+	phytbl_info_t tab;
+	tab.tbl_id = tbl_id;
+	tab.tbl_ptr = tbl_ptr;
+	tab.tbl_len = tbl_len;
+	tab.tbl_width = tbl_width;
+	tab.tbl_offset = tbl_offset;
+	wlc_lcnphy_read_table(pi, &tab);
+}
+
+static void
+wlc_lcnphy_common_write_table(phy_info_t * pi, uint32 tbl_id,
+			      CONST void *tbl_ptr, uint32 tbl_len,
+			      uint32 tbl_width, uint32 tbl_offset)
+{
+
+	phytbl_info_t tab;
+	tab.tbl_id = tbl_id;
+	tab.tbl_ptr = tbl_ptr;
+	tab.tbl_len = tbl_len;
+	tab.tbl_width = tbl_width;
+	tab.tbl_offset = tbl_offset;
+	wlc_lcnphy_write_table(pi, &tab);
+}
+
+static uint32
+wlc_lcnphy_qdiv_roundup(uint32 dividend, uint32 divisor, uint8 precision)
+{
+	uint32 quotient, remainder, roundup, rbit;
+
+	ASSERT(divisor);
+
+	quotient = dividend / divisor;
+	remainder = dividend % divisor;
+	rbit = divisor & 1;
+	roundup = (divisor >> 1) + rbit;
+
+	while (precision--) {
+		quotient <<= 1;
+		if (remainder >= roundup) {
+			quotient++;
+			remainder = ((remainder - roundup) << 1) + rbit;
+		} else {
+			remainder <<= 1;
+		}
+	}
+
+	if (remainder >= roundup)
+		quotient++;
+
+	return quotient;
+}
+
+static int wlc_lcnphy_calc_floor(int16 coeff_x, int type)
+{
+	int k;
+	k = 0;
+	if (type == 0) {
+		if (coeff_x < 0) {
+			k = (coeff_x - 1) / 2;
+		} else {
+			k = coeff_x / 2;
+		}
+	}
+	if (type == 1) {
+		if ((coeff_x + 1) < 0)
+			k = (coeff_x) / 2;
+		else
+			k = (coeff_x + 1) / 2;
+	}
+	return k;
+}
+
+int8 wlc_lcnphy_get_current_tx_pwr_idx(phy_info_t * pi)
+{
+	int8 index;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (txpwrctrl_off(pi))
+		index = pi_lcn->lcnphy_current_index;
+	else if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
+		index =
+		    (int8) (wlc_lcnphy_get_current_tx_pwr_idx_if_pwrctrl_on(pi)
+			    / 2);
+	else
+		index = pi_lcn->lcnphy_current_index;
+	return index;
+}
+
+static uint32 wlc_lcnphy_measure_digital_power(phy_info_t * pi, uint16 nsamples)
+{
+	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
+
+	if (!wlc_lcnphy_rx_iq_est(pi, nsamples, 32, &iq_est))
+		return 0;
+	return (iq_est.i_pwr + iq_est.q_pwr) / nsamples;
+}
+
+void wlc_lcnphy_crsuprs(phy_info_t * pi, int channel)
+{
+	uint16 afectrlovr, afectrlovrval;
+	afectrlovr = read_phy_reg(pi, 0x43b);
+	afectrlovrval = read_phy_reg(pi, 0x43c);
+	if (channel != 0) {
+		mod_phy_reg(pi, 0x43b, (0x1 << 1), (1) << 1);
+
+		mod_phy_reg(pi, 0x43c, (0x1 << 1), (0) << 1);
+
+		mod_phy_reg(pi, 0x43b, (0x1 << 4), (1) << 4);
+
+		mod_phy_reg(pi, 0x43c, (0x1 << 6), (0) << 6);
+
+		write_phy_reg(pi, 0x44b, 0xffff);
+		wlc_lcnphy_tx_pu(pi, 1);
+
+		mod_phy_reg(pi, 0x634, (0xff << 8), (0) << 8);
+
+		or_phy_reg(pi, 0x6da, 0x0080);
+
+		or_phy_reg(pi, 0x00a, 0x228);
+	} else {
+		and_phy_reg(pi, 0x00a, ~(0x228));
+
+		and_phy_reg(pi, 0x6da, 0xFF7F);
+		write_phy_reg(pi, 0x43b, afectrlovr);
+		write_phy_reg(pi, 0x43c, afectrlovrval);
+	}
+}
+
+static void wlc_lcnphy_toggle_afe_pwdn(phy_info_t * pi)
+{
+	uint16 save_AfeCtrlOvrVal, save_AfeCtrlOvr;
+
+	save_AfeCtrlOvrVal = read_phy_reg(pi, 0x43c);
+	save_AfeCtrlOvr = read_phy_reg(pi, 0x43b);
+
+	write_phy_reg(pi, 0x43c, save_AfeCtrlOvrVal | 0x1);
+	write_phy_reg(pi, 0x43b, save_AfeCtrlOvr | 0x1);
+
+	write_phy_reg(pi, 0x43c, save_AfeCtrlOvrVal & 0xfffe);
+	write_phy_reg(pi, 0x43b, save_AfeCtrlOvr & 0xfffe);
+
+	write_phy_reg(pi, 0x43c, save_AfeCtrlOvrVal);
+	write_phy_reg(pi, 0x43b, save_AfeCtrlOvr);
+}
+
+static void wlc_lcnphy_txrx_spur_avoidance_mode(phy_info_t * pi, bool enable)
+{
+	if (enable) {
+		write_phy_reg(pi, 0x942, 0x7);
+		write_phy_reg(pi, 0x93b, ((1 << 13) + 23));
+		write_phy_reg(pi, 0x93c, ((1 << 13) + 1989));
+
+		write_phy_reg(pi, 0x44a, 0x084);
+		write_phy_reg(pi, 0x44a, 0x080);
+		write_phy_reg(pi, 0x6d3, 0x2222);
+		write_phy_reg(pi, 0x6d3, 0x2220);
+	} else {
+		write_phy_reg(pi, 0x942, 0x0);
+		write_phy_reg(pi, 0x93b, ((0 << 13) + 23));
+		write_phy_reg(pi, 0x93c, ((0 << 13) + 1989));
+	}
+	wlapi_switch_macfreq(pi->sh->physhim, enable);
+}
+
+void wlc_phy_chanspec_set_lcnphy(phy_info_t * pi, chanspec_t chanspec)
+{
+	uint8 channel = CHSPEC_CHANNEL(chanspec);
+
+	wlc_phy_chanspec_radio_set((wlc_phy_t *) pi, chanspec);
+
+	wlc_lcnphy_set_chanspec_tweaks(pi, pi->radio_chanspec);
+
+	or_phy_reg(pi, 0x44a, 0x44);
+	write_phy_reg(pi, 0x44a, 0x80);
+
+	if (!NORADIO_ENAB(pi->pubpi)) {
+		wlc_lcnphy_radio_2064_channel_tune_4313(pi, channel);
+		OSL_DELAY(1000);
+	}
+
+	wlc_lcnphy_toggle_afe_pwdn(pi);
+
+	write_phy_reg(pi, 0x657, lcnphy_sfo_cfg[channel - 1].ptcentreTs20);
+	write_phy_reg(pi, 0x658, lcnphy_sfo_cfg[channel - 1].ptcentreFactor);
+
+	if (CHSPEC_CHANNEL(pi->radio_chanspec) == 14) {
+		mod_phy_reg(pi, 0x448, (0x3 << 8), (2) << 8);
+
+		wlc_lcnphy_load_tx_iir_filter(pi, FALSE, 3);
+	} else {
+		mod_phy_reg(pi, 0x448, (0x3 << 8), (1) << 8);
+
+		wlc_lcnphy_load_tx_iir_filter(pi, FALSE, 2);
+	}
+
+	wlc_lcnphy_load_tx_iir_filter(pi, TRUE, 0);
+
+	mod_phy_reg(pi, 0x4eb, (0x7 << 3), (1) << 3);
+
+}
+
+static void wlc_lcnphy_set_dac_gain(phy_info_t * pi, uint16 dac_gain)
+{
+	uint16 dac_ctrl;
+
+	dac_ctrl = (read_phy_reg(pi, 0x439) >> 0);
+	dac_ctrl = dac_ctrl & 0xc7f;
+	dac_ctrl = dac_ctrl | (dac_gain << 7);
+	mod_phy_reg(pi, 0x439, (0xfff << 0), (dac_ctrl) << 0);
+
+}
+
+static void wlc_lcnphy_set_tx_gain_override(phy_info_t * pi, bool bEnable)
+{
+	uint16 bit = bEnable ? 1 : 0;
+
+	mod_phy_reg(pi, 0x4b0, (0x1 << 7), bit << 7);
+
+	mod_phy_reg(pi, 0x4b0, (0x1 << 14), bit << 14);
+
+	mod_phy_reg(pi, 0x43b, (0x1 << 6), bit << 6);
+}
+
+static uint16 wlc_lcnphy_get_pa_gain(phy_info_t * pi)
+{
+	uint16 pa_gain;
+
+	pa_gain = (read_phy_reg(pi, 0x4fb) &
+		   LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK) >>
+	    LCNPHY_txgainctrlovrval1_pagain_ovr_val1_SHIFT;
+
+	return pa_gain;
+}
+
+static void
+wlc_lcnphy_set_tx_gain(phy_info_t * pi, lcnphy_txgains_t * target_gains)
+{
+	uint16 pa_gain = wlc_lcnphy_get_pa_gain(pi);
+
+	mod_phy_reg(pi, 0x4b5,
+		    (0xffff << 0),
+		    ((target_gains->gm_gain) | (target_gains->pga_gain << 8)) <<
+		    0);
+	mod_phy_reg(pi, 0x4fb,
+		    (0x7fff << 0),
+		    ((target_gains->pad_gain) | (pa_gain << 8)) << 0);
+
+	mod_phy_reg(pi, 0x4fc,
+		    (0xffff << 0),
+		    ((target_gains->gm_gain) | (target_gains->pga_gain << 8)) <<
+		    0);
+	mod_phy_reg(pi, 0x4fd,
+		    (0x7fff << 0),
+		    ((target_gains->pad_gain) | (pa_gain << 8)) << 0);
+
+	wlc_lcnphy_set_dac_gain(pi, target_gains->dac_gain);
+
+	wlc_lcnphy_enable_tx_gain_override(pi);
+}
+
+static void wlc_lcnphy_set_bbmult(phy_info_t * pi, uint8 m0)
+{
+	uint16 m0m1 = (uint16) m0 << 8;
+	phytbl_info_t tab;
+
+	tab.tbl_ptr = &m0m1;
+	tab.tbl_len = 1;
+	tab.tbl_id = LCNPHY_TBL_ID_IQLOCAL;
+	tab.tbl_offset = 87;
+	tab.tbl_width = 16;
+	wlc_lcnphy_write_table(pi, &tab);
+}
+
+static void wlc_lcnphy_clear_tx_power_offsets(phy_info_t * pi)
+{
+	uint32 data_buf[64];
+	phytbl_info_t tab;
+
+	bzero(data_buf, sizeof(data_buf));
+
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_ptr = data_buf;
+
+	if (!wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
+
+		tab.tbl_len = 30;
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_RATE_OFFSET;
+		wlc_lcnphy_write_table(pi, &tab);
+	}
+
+	tab.tbl_len = 64;
+	tab.tbl_offset = LCNPHY_TX_PWR_CTRL_MAC_OFFSET;
+	wlc_lcnphy_write_table(pi, &tab);
+}
+
+typedef enum {
+	LCNPHY_TSSI_PRE_PA,
+	LCNPHY_TSSI_POST_PA,
+	LCNPHY_TSSI_EXT
+} lcnphy_tssi_mode_t;
+
+static void wlc_lcnphy_set_tssi_mux(phy_info_t * pi, lcnphy_tssi_mode_t pos)
+{
+	mod_phy_reg(pi, 0x4d7, (0x1 << 0), (0x1) << 0);
+
+	mod_phy_reg(pi, 0x4d7, (0x1 << 6), (1) << 6);
+
+	if (LCNPHY_TSSI_POST_PA == pos) {
+		mod_phy_reg(pi, 0x4d9, (0x1 << 2), (0) << 2);
+
+		mod_phy_reg(pi, 0x4d9, (0x1 << 3), (1) << 3);
+
+		if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
+			mod_radio_reg(pi, RADIO_2064_REG086, 0x4, 0x4);
+		} else {
+			mod_radio_reg(pi, RADIO_2064_REG03A, 1, 0x1);
+			mod_radio_reg(pi, RADIO_2064_REG11A, 0x8, 0x8);
+		}
+	} else {
+		mod_phy_reg(pi, 0x4d9, (0x1 << 2), (0x1) << 2);
+
+		mod_phy_reg(pi, 0x4d9, (0x1 << 3), (0) << 3);
+
+		if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
+			mod_radio_reg(pi, RADIO_2064_REG086, 0x4, 0x4);
+		} else {
+			mod_radio_reg(pi, RADIO_2064_REG03A, 1, 0);
+			mod_radio_reg(pi, RADIO_2064_REG11A, 0x8, 0x8);
+		}
+	}
+	mod_phy_reg(pi, 0x637, (0x3 << 14), (0) << 14);
+
+	if (LCNPHY_TSSI_EXT == pos) {
+		write_radio_reg(pi, RADIO_2064_REG07F, 1);
+		mod_radio_reg(pi, RADIO_2064_REG005, 0x7, 0x2);
+		mod_radio_reg(pi, RADIO_2064_REG112, 0x80, 0x1 << 7);
+		mod_radio_reg(pi, RADIO_2064_REG028, 0x1f, 0x3);
+	}
+}
+
+static uint16 wlc_lcnphy_rfseq_tbl_adc_pwrup(phy_info_t * pi)
+{
+	uint16 N1, N2, N3, N4, N5, N6, N;
+	N1 = ((read_phy_reg(pi, 0x4a5) & (0xff << 0))
+	      >> 0);
+	N2 = 1 << ((read_phy_reg(pi, 0x4a5) & (0x7 << 12))
+		   >> 12);
+	N3 = ((read_phy_reg(pi, 0x40d) & (0xff << 0))
+	      >> 0);
+	N4 = 1 << ((read_phy_reg(pi, 0x40d) & (0x7 << 8))
+		   >> 8);
+	N5 = ((read_phy_reg(pi, 0x4a2) & (0xff << 0))
+	      >> 0);
+	N6 = 1 << ((read_phy_reg(pi, 0x4a2) & (0x7 << 8))
+		   >> 8);
+	N = 2 * (N1 + N2 + N3 + N4 + 2 * (N5 + N6)) + 80;
+	if (N < 1600)
+		N = 1600;
+	return N;
+}
+
+static void wlc_lcnphy_pwrctrl_rssiparams(phy_info_t * pi)
+{
+	uint16 auxpga_vmid, auxpga_vmid_temp, auxpga_gain_temp;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	auxpga_vmid =
+	    (2 << 8) | (pi_lcn->lcnphy_rssi_vc << 4) | pi_lcn->lcnphy_rssi_vf;
+	auxpga_vmid_temp = (2 << 8) | (8 << 4) | 4;
+	auxpga_gain_temp = 2;
+
+	mod_phy_reg(pi, 0x4d8, (0x1 << 0), (0) << 0);
+
+	mod_phy_reg(pi, 0x4d8, (0x1 << 1), (0) << 1);
+
+	mod_phy_reg(pi, 0x4d7, (0x1 << 3), (0) << 3);
+
+	mod_phy_reg(pi, 0x4db,
+		    (0x3ff << 0) |
+		    (0x7 << 12),
+		    (auxpga_vmid << 0) | (pi_lcn->lcnphy_rssi_gs << 12));
+
+	mod_phy_reg(pi, 0x4dc,
+		    (0x3ff << 0) |
+		    (0x7 << 12),
+		    (auxpga_vmid << 0) | (pi_lcn->lcnphy_rssi_gs << 12));
+
+	mod_phy_reg(pi, 0x40a,
+		    (0x3ff << 0) |
+		    (0x7 << 12),
+		    (auxpga_vmid << 0) | (pi_lcn->lcnphy_rssi_gs << 12));
+
+	mod_phy_reg(pi, 0x40b,
+		    (0x3ff << 0) |
+		    (0x7 << 12),
+		    (auxpga_vmid_temp << 0) | (auxpga_gain_temp << 12));
+
+	mod_phy_reg(pi, 0x40c,
+		    (0x3ff << 0) |
+		    (0x7 << 12),
+		    (auxpga_vmid_temp << 0) | (auxpga_gain_temp << 12));
+
+	mod_radio_reg(pi, RADIO_2064_REG082, (1 << 5), (1 << 5));
+}
+
+static void wlc_lcnphy_tssi_setup(phy_info_t * pi)
+{
+	phytbl_info_t tab;
+	uint32 rfseq, ind;
+
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_ptr = &ind;
+	tab.tbl_len = 1;
+	tab.tbl_offset = 0;
+	for (ind = 0; ind < 128; ind++) {
+		wlc_lcnphy_write_table(pi, &tab);
+		tab.tbl_offset++;
+	}
+	tab.tbl_offset = 704;
+	for (ind = 0; ind < 128; ind++) {
+		wlc_lcnphy_write_table(pi, &tab);
+		tab.tbl_offset++;
+	}
+	mod_phy_reg(pi, 0x503, (0x1 << 0), (0) << 0);
+
+	mod_phy_reg(pi, 0x503, (0x1 << 2), (0) << 2);
+
+	mod_phy_reg(pi, 0x503, (0x1 << 4), (1) << 4);
+
+	wlc_lcnphy_set_tssi_mux(pi, LCNPHY_TSSI_EXT);
+	mod_phy_reg(pi, 0x4a4, (0x1 << 14), (0) << 14);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 15), (1) << 15);
+
+	mod_phy_reg(pi, 0x4d0, (0x1 << 5), (0) << 5);
+
+	mod_phy_reg(pi, 0x4a4, (0x1ff << 0), (0) << 0);
+
+	mod_phy_reg(pi, 0x4a5, (0xff << 0), (255) << 0);
+
+	mod_phy_reg(pi, 0x4a5, (0x7 << 12), (5) << 12);
+
+	mod_phy_reg(pi, 0x4a5, (0x7 << 8), (0) << 8);
+
+	mod_phy_reg(pi, 0x40d, (0xff << 0), (64) << 0);
+
+	mod_phy_reg(pi, 0x40d, (0x7 << 8), (4) << 8);
+
+	mod_phy_reg(pi, 0x4a2, (0xff << 0), (64) << 0);
+
+	mod_phy_reg(pi, 0x4a2, (0x7 << 8), (4) << 8);
+
+	mod_phy_reg(pi, 0x4d0, (0x1ff << 6), (0) << 6);
+
+	mod_phy_reg(pi, 0x4a8, (0xff << 0), (0x1) << 0);
+
+	wlc_lcnphy_clear_tx_power_offsets(pi);
+
+	mod_phy_reg(pi, 0x4a6, (0x1 << 15), (1) << 15);
+
+	mod_phy_reg(pi, 0x4a6, (0x1ff << 0), (0xff) << 0);
+
+	mod_phy_reg(pi, 0x49a, (0x1ff << 0), (0xff) << 0);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
+		mod_radio_reg(pi, RADIO_2064_REG028, 0xf, 0xe);
+		mod_radio_reg(pi, RADIO_2064_REG086, 0x4, 0x4);
+	} else {
+		mod_radio_reg(pi, RADIO_2064_REG03A, 0x1, 1);
+		mod_radio_reg(pi, RADIO_2064_REG11A, 0x8, 1 << 3);
+	}
+
+	write_radio_reg(pi, RADIO_2064_REG025, 0xc);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
+		mod_radio_reg(pi, RADIO_2064_REG03A, 0x1, 1);
+	} else {
+		if (CHSPEC_IS2G(pi->radio_chanspec))
+			mod_radio_reg(pi, RADIO_2064_REG03A, 0x2, 1 << 1);
+		else
+			mod_radio_reg(pi, RADIO_2064_REG03A, 0x2, 0 << 1);
+	}
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2))
+		mod_radio_reg(pi, RADIO_2064_REG03A, 0x2, 1 << 1);
+	else
+		mod_radio_reg(pi, RADIO_2064_REG03A, 0x4, 1 << 2);
+
+	mod_radio_reg(pi, RADIO_2064_REG11A, 0x1, 1 << 0);
+
+	mod_radio_reg(pi, RADIO_2064_REG005, 0x8, 1 << 3);
+
+	if (!wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
+		mod_phy_reg(pi, 0x4d7,
+			    (0x1 << 3) | (0x7 << 12), 0 << 3 | 2 << 12);
+	}
+
+	rfseq = wlc_lcnphy_rfseq_tbl_adc_pwrup(pi);
+	tab.tbl_id = LCNPHY_TBL_ID_RFSEQ;
+	tab.tbl_width = 16;
+	tab.tbl_ptr = &rfseq;
+	tab.tbl_len = 1;
+	tab.tbl_offset = 6;
+	wlc_lcnphy_write_table(pi, &tab);
+
+	mod_phy_reg(pi, 0x938, (0x1 << 2), (1) << 2);
+
+	mod_phy_reg(pi, 0x939, (0x1 << 2), (1) << 2);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 12), (1) << 12);
+
+	mod_phy_reg(pi, 0x4d7, (0x1 << 2), (1) << 2);
+
+	mod_phy_reg(pi, 0x4d7, (0xf << 8), (0) << 8);
+
+	wlc_lcnphy_pwrctrl_rssiparams(pi);
+}
+
+void wlc_lcnphy_tx_pwr_update_npt(phy_info_t * pi)
+{
+	uint16 tx_cnt, tx_total, npt;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	tx_total = wlc_lcnphy_total_tx_frames(pi);
+	tx_cnt = tx_total - pi_lcn->lcnphy_tssi_tx_cnt;
+	npt = wlc_lcnphy_get_tx_pwr_npt(pi);
+
+	if (tx_cnt > (1 << npt)) {
+
+		pi_lcn->lcnphy_tssi_tx_cnt = tx_total;
+
+		pi_lcn->lcnphy_tssi_idx = wlc_lcnphy_get_current_tx_pwr_idx(pi);
+		pi_lcn->lcnphy_tssi_npt = npt;
+
+	}
+}
+
+int32 wlc_lcnphy_tssi2dbm(int32 tssi, int32 a1, int32 b0, int32 b1)
+{
+	int32 a, b, p;
+
+	a = 32768 + (a1 * tssi);
+	b = (1024 * b0) + (64 * b1 * tssi);
+	p = ((2 * b) + a) / (2 * a);
+
+	return p;
+}
+
+static void wlc_lcnphy_txpower_reset_npt(phy_info_t * pi)
+{
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
+		return;
+
+	pi_lcn->lcnphy_tssi_idx = LCNPHY_TX_PWR_CTRL_START_INDEX_2G_4313;
+	pi_lcn->lcnphy_tssi_npt = LCNPHY_TX_PWR_CTRL_START_NPT;
+}
+
+void wlc_lcnphy_txpower_recalc_target(phy_info_t * pi)
+{
+	phytbl_info_t tab;
+	uint32 rate_table[WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM +
+			  WLC_NUM_RATES_MCS_1_STREAM];
+	uint i, j;
+	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
+		return;
+
+	for (i = 0, j = 0; i < ARRAYSIZE(rate_table); i++, j++) {
+
+		if (i == WLC_NUM_RATES_CCK + WLC_NUM_RATES_OFDM)
+			j = TXP_FIRST_MCS_20_SISO;
+
+		rate_table[i] = (uint32) ((int32) (-pi->tx_power_offset[j]));
+	}
+
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_len = ARRAYSIZE(rate_table);
+	tab.tbl_ptr = rate_table;
+	tab.tbl_offset = LCNPHY_TX_PWR_CTRL_RATE_OFFSET;
+	wlc_lcnphy_write_table(pi, &tab);
+
+	if (wlc_lcnphy_get_target_tx_pwr(pi) != pi->tx_power_min) {
+		wlc_lcnphy_set_target_tx_pwr(pi, pi->tx_power_min);
+
+		wlc_lcnphy_txpower_reset_npt(pi);
+	}
+}
+
+static void wlc_lcnphy_set_tx_pwr_soft_ctrl(phy_info_t * pi, int8 index)
+{
+	uint32 cck_offset[4] = { 22, 22, 22, 22 };
+	uint32 ofdm_offset, reg_offset_cck;
+	int i;
+	uint16 index2;
+	phytbl_info_t tab;
+
+	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
+		return;
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 14), (0x1) << 14);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 14), (0x0) << 14);
+
+	or_phy_reg(pi, 0x6da, 0x0040);
+
+	reg_offset_cck = 0;
+	for (i = 0; i < 4; i++)
+		cck_offset[i] -= reg_offset_cck;
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_len = 4;
+	tab.tbl_ptr = cck_offset;
+	tab.tbl_offset = LCNPHY_TX_PWR_CTRL_RATE_OFFSET;
+	wlc_lcnphy_write_table(pi, &tab);
+	ofdm_offset = 0;
+	tab.tbl_len = 1;
+	tab.tbl_ptr = &ofdm_offset;
+	for (i = 836; i < 862; i++) {
+		tab.tbl_offset = i;
+		wlc_lcnphy_write_table(pi, &tab);
+	}
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 15), (0x1) << 15);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 14), (0x1) << 14);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 13), (0x1) << 13);
+
+	mod_phy_reg(pi, 0x4b0, (0x1 << 7), (0) << 7);
+
+	mod_phy_reg(pi, 0x43b, (0x1 << 6), (0) << 6);
+
+	mod_phy_reg(pi, 0x4a9, (0x1 << 15), (1) << 15);
+
+	index2 = (uint16) (index * 2);
+	mod_phy_reg(pi, 0x4a9, (0x1ff << 0), (index2) << 0);
+
+	mod_phy_reg(pi, 0x6a3, (0x1 << 4), (0) << 4);
+
+}
+
+static int8 wlc_lcnphy_tempcompensated_txpwrctrl(phy_info_t * pi)
+{
+	int8 index, delta_brd, delta_temp, new_index, tempcorrx;
+	int16 manp, meas_temp, temp_diff;
+	bool neg = 0;
+	uint16 temp;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi))
+		return pi_lcn->lcnphy_current_index;
+
+	index = FIXED_TXPWR;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return index;
+
+	if (pi_lcn->lcnphy_tempsense_slope == 0) {
+		return index;
+	}
+	temp = (uint16) wlc_lcnphy_tempsense(pi, 0);
+	meas_temp = LCNPHY_TEMPSENSE(temp);
+
+	if (pi->tx_power_min != 0) {
+		delta_brd = (pi_lcn->lcnphy_measPower - pi->tx_power_min);
+	} else {
+		delta_brd = 0;
+	}
+
+	manp = LCNPHY_TEMPSENSE(pi_lcn->lcnphy_rawtempsense);
+	temp_diff = manp - meas_temp;
+	if (temp_diff < 0) {
+
+		neg = 1;
+
+		temp_diff = -temp_diff;
+	}
+
+	delta_temp = (int8) wlc_lcnphy_qdiv_roundup((uint32) (temp_diff * 192),
+						    (uint32) (pi_lcn->
+							      lcnphy_tempsense_slope
+							      * 10), 0);
+	if (neg)
+		delta_temp = -delta_temp;
+
+	if (pi_lcn->lcnphy_tempsense_option == 3
+	    && LCNREV_IS(pi->pubpi.phy_rev, 0))
+		delta_temp = 0;
+	if (pi_lcn->lcnphy_tempcorrx > 31)
+		tempcorrx = (int8) (pi_lcn->lcnphy_tempcorrx - 64);
+	else
+		tempcorrx = (int8) pi_lcn->lcnphy_tempcorrx;
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
+		tempcorrx = 4;
+	new_index =
+	    index + delta_brd + delta_temp - pi_lcn->lcnphy_bandedge_corr;
+	new_index += tempcorrx;
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
+		index = 127;
+	if (new_index < 0 || new_index > 126) {
+		return index;
+	}
+	return new_index;
+}
+
+static uint16 wlc_lcnphy_set_tx_pwr_ctrl_mode(phy_info_t * pi, uint16 mode)
+{
+
+	uint16 current_mode = mode;
+	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi) &&
+	    mode == LCNPHY_TX_PWR_CTRL_HW)
+		current_mode = LCNPHY_TX_PWR_CTRL_TEMPBASED;
+	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi) &&
+	    mode == LCNPHY_TX_PWR_CTRL_TEMPBASED)
+		current_mode = LCNPHY_TX_PWR_CTRL_HW;
+	return current_mode;
+}
+
+void wlc_lcnphy_set_tx_pwr_ctrl(phy_info_t * pi, uint16 mode)
+{
+	uint16 old_mode = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	int8 index;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	ASSERT((LCNPHY_TX_PWR_CTRL_OFF == mode) ||
+	       (LCNPHY_TX_PWR_CTRL_SW == mode) ||
+	       (LCNPHY_TX_PWR_CTRL_HW == mode) ||
+	       (LCNPHY_TX_PWR_CTRL_TEMPBASED == mode));
+
+	mode = wlc_lcnphy_set_tx_pwr_ctrl_mode(pi, mode);
+	old_mode = wlc_lcnphy_set_tx_pwr_ctrl_mode(pi, old_mode);
+
+	mod_phy_reg(pi, 0x6da, (0x1 << 6),
+		    ((LCNPHY_TX_PWR_CTRL_HW == mode) ? 1 : 0) << 6);
+
+	mod_phy_reg(pi, 0x6a3, (0x1 << 4),
+		    ((LCNPHY_TX_PWR_CTRL_HW == mode) ? 0 : 1) << 4);
+
+	if (old_mode != mode) {
+		if (LCNPHY_TX_PWR_CTRL_HW == old_mode) {
+
+			wlc_lcnphy_tx_pwr_update_npt(pi);
+
+			wlc_lcnphy_clear_tx_power_offsets(pi);
+		}
+		if (LCNPHY_TX_PWR_CTRL_HW == mode) {
+
+			wlc_lcnphy_txpower_recalc_target(pi);
+
+			wlc_lcnphy_set_start_tx_pwr_idx(pi,
+							pi_lcn->
+							lcnphy_tssi_idx);
+			wlc_lcnphy_set_tx_pwr_npt(pi, pi_lcn->lcnphy_tssi_npt);
+			mod_radio_reg(pi, RADIO_2064_REG11F, 0x4, 0);
+
+			pi_lcn->lcnphy_tssi_tx_cnt =
+			    wlc_lcnphy_total_tx_frames(pi);
+
+			wlc_lcnphy_disable_tx_gain_override(pi);
+			pi_lcn->lcnphy_tx_power_idx_override = -1;
+		} else
+			wlc_lcnphy_enable_tx_gain_override(pi);
+
+		mod_phy_reg(pi, 0x4a4,
+			    ((0x1 << 15) | (0x1 << 14) | (0x1 << 13)), mode);
+		if (mode == LCNPHY_TX_PWR_CTRL_TEMPBASED) {
+			index = wlc_lcnphy_tempcompensated_txpwrctrl(pi);
+			wlc_lcnphy_set_tx_pwr_soft_ctrl(pi, index);
+			pi_lcn->lcnphy_current_index = (int8)
+			    ((read_phy_reg(pi, 0x4a9) & 0xFF) / 2);
+		}
+	}
+}
+
+static bool wlc_lcnphy_iqcal_wait(phy_info_t * pi)
+{
+	uint delay_count = 0;
+
+	while (wlc_lcnphy_iqcal_active(pi)) {
+		OSL_DELAY(100);
+		delay_count++;
+
+		if (delay_count > (10 * 500))
+			break;
+	}
+
+	return (0 == wlc_lcnphy_iqcal_active(pi));
+}
+
+static void
+wlc_lcnphy_tx_iqlo_cal(phy_info_t * pi,
+		       lcnphy_txgains_t * target_gains,
+		       lcnphy_cal_mode_t cal_mode, bool keep_tone)
+{
+
+	lcnphy_txgains_t cal_gains, temp_gains;
+	uint16 hash;
+	uint8 band_idx;
+	int j;
+	uint16 ncorr_override[5];
+	uint16 syst_coeffs[] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+	};
+
+	uint16 commands_fullcal[] =
+	    { 0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
+
+	uint16 commands_recal[] =
+	    { 0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234 };
+
+	uint16 command_nums_fullcal[] =
+	    { 0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
+
+	uint16 command_nums_recal[] =
+	    { 0x7a97, 0x7a97, 0x7a97, 0x7a87, 0x7a87, 0x7b97 };
+	uint16 *command_nums = command_nums_fullcal;
+
+	uint16 *start_coeffs = NULL, *cal_cmds = NULL, cal_type, diq_start;
+	uint16 tx_pwr_ctrl_old, save_txpwrctrlrfctrl2;
+	uint16 save_sslpnCalibClkEnCtrl, save_sslpnRxFeClkEnCtrl;
+	bool tx_gain_override_old;
+	lcnphy_txgains_t old_gains;
+	uint i, n_cal_cmds = 0, n_cal_start = 0;
+	uint16 *values_to_save;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	if (NULL == (values_to_save = MALLOC(pi->sh->osh, sizeof(uint16) * 20))) {
+		return;
+	}
+
+	save_sslpnRxFeClkEnCtrl = read_phy_reg(pi, 0x6db);
+	save_sslpnCalibClkEnCtrl = read_phy_reg(pi, 0x6da);
+
+	or_phy_reg(pi, 0x6da, 0x40);
+	or_phy_reg(pi, 0x6db, 0x3);
+
+	switch (cal_mode) {
+	case LCNPHY_CAL_FULL:
+		start_coeffs = syst_coeffs;
+		cal_cmds = commands_fullcal;
+		n_cal_cmds = ARRAYSIZE(commands_fullcal);
+		break;
+
+	case LCNPHY_CAL_RECAL:
+		ASSERT(pi_lcn->lcnphy_cal_results.txiqlocal_bestcoeffs_valid);
+
+		start_coeffs = syst_coeffs;
+
+		cal_cmds = commands_recal;
+		n_cal_cmds = ARRAYSIZE(commands_recal);
+		command_nums = command_nums_recal;
+		break;
+	default:
+		ASSERT(FALSE);
+	}
+
+	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+				      start_coeffs, 11, 16, 64);
+
+	write_phy_reg(pi, 0x6da, 0xffff);
+	mod_phy_reg(pi, 0x503, (0x1 << 3), (1) << 3);
+
+	tx_pwr_ctrl_old = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 12), (1) << 12);
+
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);
+
+	save_txpwrctrlrfctrl2 = read_phy_reg(pi, 0x4db);
+
+	mod_phy_reg(pi, 0x4db, (0x3ff << 0), (0x2a6) << 0);
+
+	mod_phy_reg(pi, 0x4db, (0x7 << 12), (2) << 12);
+
+	wlc_lcnphy_tx_iqlo_loopback(pi, values_to_save);
+
+	tx_gain_override_old = wlc_lcnphy_tx_gain_override_enabled(pi);
+	if (tx_gain_override_old)
+		wlc_lcnphy_get_tx_gain(pi, &old_gains);
+
+	if (!target_gains) {
+		if (!tx_gain_override_old)
+			wlc_lcnphy_set_tx_pwr_by_index(pi,
+						       pi_lcn->lcnphy_tssi_idx);
+		wlc_lcnphy_get_tx_gain(pi, &temp_gains);
+		target_gains = &temp_gains;
+	}
+
+	hash = (target_gains->gm_gain << 8) |
+	    (target_gains->pga_gain << 4) | (target_gains->pad_gain);
+
+	band_idx = (CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0);
+
+	cal_gains = *target_gains;
+	bzero(ncorr_override, sizeof(ncorr_override));
+	for (j = 0; j < iqcal_gainparams_numgains_lcnphy[band_idx]; j++) {
+		if (hash == tbl_iqcal_gainparams_lcnphy[band_idx][j][0]) {
+			cal_gains.gm_gain =
+			    tbl_iqcal_gainparams_lcnphy[band_idx][j][1];
+			cal_gains.pga_gain =
+			    tbl_iqcal_gainparams_lcnphy[band_idx][j][2];
+			cal_gains.pad_gain =
+			    tbl_iqcal_gainparams_lcnphy[band_idx][j][3];
+			bcopy(&tbl_iqcal_gainparams_lcnphy[band_idx][j][3],
+			      ncorr_override, sizeof(ncorr_override));
+			break;
+		}
+	}
+
+	wlc_lcnphy_set_tx_gain(pi, &cal_gains);
+
+	write_phy_reg(pi, 0x453, 0xaa9);
+	write_phy_reg(pi, 0x93d, 0xc0);
+
+	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+				      (CONST void *)
+				      lcnphy_iqcal_loft_gainladder,
+				      ARRAYSIZE(lcnphy_iqcal_loft_gainladder),
+				      16, 0);
+
+	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+				      (CONST void *)lcnphy_iqcal_ir_gainladder,
+				      ARRAYSIZE(lcnphy_iqcal_ir_gainladder), 16,
+				      32);
+
+	if (pi->phy_tx_tone_freq) {
+
+		wlc_lcnphy_stop_tx_tone(pi);
+		OSL_DELAY(5);
+		wlc_lcnphy_start_tx_tone(pi, 3750, 88, 1);
+	} else {
+		wlc_lcnphy_start_tx_tone(pi, 3750, 88, 1);
+	}
+
+	write_phy_reg(pi, 0x6da, 0xffff);
+
+	for (i = n_cal_start; i < n_cal_cmds; i++) {
+		uint16 zero_diq = 0;
+		uint16 best_coeffs[11];
+		uint16 command_num;
+
+		cal_type = (cal_cmds[i] & 0x0f00) >> 8;
+
+		command_num = command_nums[i];
+		if (ncorr_override[cal_type])
+			command_num =
+			    ncorr_override[cal_type] << 8 | (command_num &
+							     0xff);
+
+		write_phy_reg(pi, 0x452, command_num);
+
+		if ((cal_type == 3) || (cal_type == 4)) {
+
+			wlc_lcnphy_common_read_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+						     &diq_start, 1, 16, 69);
+
+			wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+						      &zero_diq, 1, 16, 69);
+		}
+
+		write_phy_reg(pi, 0x451, cal_cmds[i]);
+
+		if (!wlc_lcnphy_iqcal_wait(pi)) {
+
+			goto cleanup;
+		}
+
+		wlc_lcnphy_common_read_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+					     best_coeffs,
+					     ARRAYSIZE(best_coeffs), 16, 96);
+		wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+					      best_coeffs,
+					      ARRAYSIZE(best_coeffs), 16, 64);
+
+		if ((cal_type == 3) || (cal_type == 4)) {
+			wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+						      &diq_start, 1, 16, 69);
+		}
+		wlc_lcnphy_common_read_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+					     pi_lcn->lcnphy_cal_results.
+					     txiqlocal_bestcoeffs,
+					     ARRAYSIZE(pi_lcn->
+						       lcnphy_cal_results.
+						       txiqlocal_bestcoeffs),
+					     16, 96);
+	}
+
+	wlc_lcnphy_common_read_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+				     pi_lcn->lcnphy_cal_results.
+				     txiqlocal_bestcoeffs,
+				     ARRAYSIZE(pi_lcn->lcnphy_cal_results.
+					       txiqlocal_bestcoeffs), 16, 96);
+	pi_lcn->lcnphy_cal_results.txiqlocal_bestcoeffs_valid = TRUE;
+
+	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+				      &pi_lcn->lcnphy_cal_results.
+				      txiqlocal_bestcoeffs[0], 4, 16, 80);
+
+	wlc_lcnphy_common_write_table(pi, LCNPHY_TBL_ID_IQLOCAL,
+				      &pi_lcn->lcnphy_cal_results.
+				      txiqlocal_bestcoeffs[5], 2, 16, 85);
+
+ cleanup:
+	wlc_lcnphy_tx_iqlo_loopback_cleanup(pi, values_to_save);
+	MFREE(pi->sh->osh, values_to_save, 20 * sizeof(uint16));
+
+	if (!keep_tone)
+		wlc_lcnphy_stop_tx_tone(pi);
+
+	write_phy_reg(pi, 0x4db, save_txpwrctrlrfctrl2);
+
+	write_phy_reg(pi, 0x453, 0);
+
+	if (tx_gain_override_old)
+		wlc_lcnphy_set_tx_gain(pi, &old_gains);
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, tx_pwr_ctrl_old);
+
+	write_phy_reg(pi, 0x6da, save_sslpnCalibClkEnCtrl);
+	write_phy_reg(pi, 0x6db, save_sslpnRxFeClkEnCtrl);
+
+}
+
+static void wlc_lcnphy_idle_tssi_est(wlc_phy_t * ppi)
+{
+	bool suspend, tx_gain_override_old;
+	lcnphy_txgains_t old_gains;
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint16 idleTssi, idleTssi0_2C, idleTssi0_OB, idleTssi0_regvalue_OB,
+	    idleTssi0_regvalue_2C;
+	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	uint16 SAVE_lpfgain = read_radio_reg(pi, RADIO_2064_REG112);
+	uint16 SAVE_jtag_bb_afe_switch =
+	    read_radio_reg(pi, RADIO_2064_REG007) & 1;
+	uint16 SAVE_jtag_auxpga = read_radio_reg(pi, RADIO_2064_REG0FF) & 0x10;
+	uint16 SAVE_iqadc_aux_en = read_radio_reg(pi, RADIO_2064_REG11F) & 4;
+	idleTssi = read_phy_reg(pi, 0x4ab);
+	suspend =
+	    (0 ==
+	     (R_REG(pi->sh->osh, &((phy_info_t *) pi)->regs->maccontrol) &
+	      MCTL_EN_MAC));
+	if (!suspend)
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);
+
+	tx_gain_override_old = wlc_lcnphy_tx_gain_override_enabled(pi);
+	wlc_lcnphy_get_tx_gain(pi, &old_gains);
+
+	wlc_lcnphy_enable_tx_gain_override(pi);
+	wlc_lcnphy_set_tx_pwr_by_index(pi, 127);
+	write_radio_reg(pi, RADIO_2064_REG112, 0x6);
+	mod_radio_reg(pi, RADIO_2064_REG007, 0x1, 1);
+	mod_radio_reg(pi, RADIO_2064_REG0FF, 0x10, 1 << 4);
+	mod_radio_reg(pi, RADIO_2064_REG11F, 0x4, 1 << 2);
+	wlc_lcnphy_tssi_setup(pi);
+	wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+	idleTssi = ((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
+		    >> 0);
+
+	idleTssi0_2C = ((read_phy_reg(pi, 0x63e) & (0x1ff << 0))
+			>> 0);
+
+	if (idleTssi0_2C >= 256)
+		idleTssi0_OB = idleTssi0_2C - 256;
+	else
+		idleTssi0_OB = idleTssi0_2C + 256;
+
+	idleTssi0_regvalue_OB = idleTssi0_OB;
+	if (idleTssi0_regvalue_OB >= 256)
+		idleTssi0_regvalue_2C = idleTssi0_regvalue_OB - 256;
+	else
+		idleTssi0_regvalue_2C = idleTssi0_regvalue_OB + 256;
+	mod_phy_reg(pi, 0x4a6, (0x1ff << 0), (idleTssi0_regvalue_2C) << 0);
+
+	mod_phy_reg(pi, 0x44c, (0x1 << 12), (0) << 12);
+
+	wlc_lcnphy_set_tx_gain_override(pi, tx_gain_override_old);
+	wlc_lcnphy_set_tx_gain(pi, &old_gains);
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_txpwrctrl);
+
+	write_radio_reg(pi, RADIO_2064_REG112, SAVE_lpfgain);
+	mod_radio_reg(pi, RADIO_2064_REG007, 0x1, SAVE_jtag_bb_afe_switch);
+	mod_radio_reg(pi, RADIO_2064_REG0FF, 0x10, SAVE_jtag_auxpga);
+	mod_radio_reg(pi, RADIO_2064_REG11F, 0x4, SAVE_iqadc_aux_en);
+	mod_radio_reg(pi, RADIO_2064_REG112, 0x80, 1 << 7);
+	if (!suspend)
+		wlapi_enable_mac(pi->sh->physhim);
+}
+
+static void wlc_lcnphy_vbat_temp_sense_setup(phy_info_t * pi, uint8 mode)
+{
+	bool suspend;
+	uint16 save_txpwrCtrlEn;
+	uint8 auxpga_vmidcourse, auxpga_vmidfine, auxpga_gain;
+	uint16 auxpga_vmid;
+	phytbl_info_t tab;
+	uint32 val;
+	uint8 save_reg007, save_reg0FF, save_reg11F, save_reg005, save_reg025,
+	    save_reg112;
+	uint16 values_to_save[14];
+	int8 index;
+	int i;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+	OSL_DELAY(999);
+
+	save_reg007 = (uint8) read_radio_reg(pi, RADIO_2064_REG007);
+	save_reg0FF = (uint8) read_radio_reg(pi, RADIO_2064_REG0FF);
+	save_reg11F = (uint8) read_radio_reg(pi, RADIO_2064_REG11F);
+	save_reg005 = (uint8) read_radio_reg(pi, RADIO_2064_REG005);
+	save_reg025 = (uint8) read_radio_reg(pi, RADIO_2064_REG025);
+	save_reg112 = (uint8) read_radio_reg(pi, RADIO_2064_REG112);
+
+	for (i = 0; i < 14; i++)
+		values_to_save[i] = read_phy_reg(pi, tempsense_phy_regs[i]);
+	suspend =
+	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+	if (!suspend)
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+	save_txpwrCtrlEn = read_radio_reg(pi, 0x4a4);
+
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);
+	index = pi_lcn->lcnphy_current_index;
+	wlc_lcnphy_set_tx_pwr_by_index(pi, 127);
+	mod_radio_reg(pi, RADIO_2064_REG007, 0x1, 0x1);
+	mod_radio_reg(pi, RADIO_2064_REG0FF, 0x10, 0x1 << 4);
+	mod_radio_reg(pi, RADIO_2064_REG11F, 0x4, 0x1 << 2);
+	mod_phy_reg(pi, 0x503, (0x1 << 0), (0) << 0);
+
+	mod_phy_reg(pi, 0x503, (0x1 << 2), (0) << 2);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 14), (0) << 14);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 15), (0) << 15);
+
+	mod_phy_reg(pi, 0x4d0, (0x1 << 5), (0) << 5);
+
+	mod_phy_reg(pi, 0x4a5, (0xff << 0), (255) << 0);
+
+	mod_phy_reg(pi, 0x4a5, (0x7 << 12), (5) << 12);
+
+	mod_phy_reg(pi, 0x4a5, (0x7 << 8), (0) << 8);
+
+	mod_phy_reg(pi, 0x40d, (0xff << 0), (64) << 0);
+
+	mod_phy_reg(pi, 0x40d, (0x7 << 8), (6) << 8);
+
+	mod_phy_reg(pi, 0x4a2, (0xff << 0), (64) << 0);
+
+	mod_phy_reg(pi, 0x4a2, (0x7 << 8), (6) << 8);
+
+	mod_phy_reg(pi, 0x4d9, (0x7 << 4), (2) << 4);
+
+	mod_phy_reg(pi, 0x4d9, (0x7 << 8), (3) << 8);
+
+	mod_phy_reg(pi, 0x4d9, (0x7 << 12), (1) << 12);
+
+	mod_phy_reg(pi, 0x4da, (0x1 << 12), (0) << 12);
+
+	mod_phy_reg(pi, 0x4da, (0x1 << 13), (1) << 13);
+
+	mod_phy_reg(pi, 0x4a6, (0x1 << 15), (1) << 15);
+
+	write_radio_reg(pi, RADIO_2064_REG025, 0xC);
+
+	mod_radio_reg(pi, RADIO_2064_REG005, 0x8, 0x1 << 3);
+
+	mod_phy_reg(pi, 0x938, (0x1 << 2), (1) << 2);
+
+	mod_phy_reg(pi, 0x939, (0x1 << 2), (1) << 2);
+
+	mod_phy_reg(pi, 0x4a4, (0x1 << 12), (1) << 12);
+
+	val = wlc_lcnphy_rfseq_tbl_adc_pwrup(pi);
+	tab.tbl_id = LCNPHY_TBL_ID_RFSEQ;
+	tab.tbl_width = 16;
+	tab.tbl_len = 1;
+	tab.tbl_ptr = &val;
+	tab.tbl_offset = 6;
+	wlc_lcnphy_write_table(pi, &tab);
+	if (mode == TEMPSENSE) {
+		mod_phy_reg(pi, 0x4d7, (0x1 << 3), (1) << 3);
+
+		mod_phy_reg(pi, 0x4d7, (0x7 << 12), (1) << 12);
+
+		auxpga_vmidcourse = 8;
+		auxpga_vmidfine = 0x4;
+		auxpga_gain = 2;
+		mod_radio_reg(pi, RADIO_2064_REG082, 0x20, 1 << 5);
+	} else {
+		mod_phy_reg(pi, 0x4d7, (0x1 << 3), (1) << 3);
+
+		mod_phy_reg(pi, 0x4d7, (0x7 << 12), (3) << 12);
+
+		auxpga_vmidcourse = 7;
+		auxpga_vmidfine = 0xa;
+		auxpga_gain = 2;
+	}
+	auxpga_vmid =
+	    (uint16) ((2 << 8) | (auxpga_vmidcourse << 4) | auxpga_vmidfine);
+	mod_phy_reg(pi, 0x4d8, (0x1 << 0), (1) << 0);
+
+	mod_phy_reg(pi, 0x4d8, (0x3ff << 2), (auxpga_vmid) << 2);
+
+	mod_phy_reg(pi, 0x4d8, (0x1 << 1), (1) << 1);
+
+	mod_phy_reg(pi, 0x4d8, (0x7 << 12), (auxpga_gain) << 12);
+
+	mod_phy_reg(pi, 0x4d0, (0x1 << 5), (1) << 5);
+
+	write_radio_reg(pi, RADIO_2064_REG112, 0x6);
+
+	wlc_phy_do_dummy_tx(pi, TRUE, OFF);
+	if (!tempsense_done(pi))
+		OSL_DELAY(10);
+
+	write_radio_reg(pi, RADIO_2064_REG007, (uint16) save_reg007);
+	write_radio_reg(pi, RADIO_2064_REG0FF, (uint16) save_reg0FF);
+	write_radio_reg(pi, RADIO_2064_REG11F, (uint16) save_reg11F);
+	write_radio_reg(pi, RADIO_2064_REG005, (uint16) save_reg005);
+	write_radio_reg(pi, RADIO_2064_REG025, (uint16) save_reg025);
+	write_radio_reg(pi, RADIO_2064_REG112, (uint16) save_reg112);
+	for (i = 0; i < 14; i++)
+		write_phy_reg(pi, tempsense_phy_regs[i], values_to_save[i]);
+	wlc_lcnphy_set_tx_pwr_by_index(pi, (int)index);
+
+	write_radio_reg(pi, 0x4a4, save_txpwrCtrlEn);
+	if (!suspend)
+		wlapi_enable_mac(pi->sh->physhim);
+	OSL_DELAY(999);
+}
+
+void WLBANDINITFN(wlc_lcnphy_tx_pwr_ctrl_init) (wlc_phy_t * ppi) {
+	lcnphy_txgains_t tx_gains;
+	uint8 bbmult;
+	phytbl_info_t tab;
+	int32 a1, b0, b1;
+	int32 tssi, pwr, maxtargetpwr, mintargetpwr;
+	bool suspend;
+	phy_info_t *pi = (phy_info_t *) ppi;
+
+	suspend =
+	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+	if (!suspend)
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+	if (NORADIO_ENAB(pi->pubpi)) {
+		wlc_lcnphy_set_bbmult(pi, 0x30);
+		if (!suspend)
+			wlapi_enable_mac(pi->sh->physhim);
+		return;
+	}
+
+	if (!pi->hwpwrctrl_capable) {
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			tx_gains.gm_gain = 4;
+			tx_gains.pga_gain = 12;
+			tx_gains.pad_gain = 12;
+			tx_gains.dac_gain = 0;
+
+			bbmult = 150;
+		} else {
+			tx_gains.gm_gain = 7;
+			tx_gains.pga_gain = 15;
+			tx_gains.pad_gain = 14;
+			tx_gains.dac_gain = 0;
+
+			bbmult = 150;
+		}
+		wlc_lcnphy_set_tx_gain(pi, &tx_gains);
+		wlc_lcnphy_set_bbmult(pi, bbmult);
+		wlc_lcnphy_vbat_temp_sense_setup(pi, TEMPSENSE);
+	} else {
+
+		wlc_lcnphy_idle_tssi_est(ppi);
+
+		wlc_lcnphy_clear_tx_power_offsets(pi);
+
+		b0 = pi->txpa_2g[0];
+		b1 = pi->txpa_2g[1];
+		a1 = pi->txpa_2g[2];
+		maxtargetpwr = wlc_lcnphy_tssi2dbm(10, a1, b0, b1);
+		mintargetpwr = wlc_lcnphy_tssi2dbm(125, a1, b0, b1);
+
+		tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+		tab.tbl_width = 32;
+		tab.tbl_ptr = &pwr;
+		tab.tbl_len = 1;
+		tab.tbl_offset = 0;
+		for (tssi = 0; tssi < 128; tssi++) {
+			pwr = wlc_lcnphy_tssi2dbm(tssi, a1, b0, b1);
+
+			pwr = (pwr < mintargetpwr) ? mintargetpwr : pwr;
+			wlc_lcnphy_write_table(pi, &tab);
+			tab.tbl_offset++;
+		}
+
+		mod_phy_reg(pi, 0x410, (0x1 << 7), (0) << 7);
+
+		write_phy_reg(pi, 0x4a8, 10);
+
+		wlc_lcnphy_set_target_tx_pwr(pi, LCN_TARGET_PWR);
+
+		wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_HW);
+	}
+	if (!suspend)
+		wlapi_enable_mac(pi->sh->physhim);
+}
+
+static uint8 wlc_lcnphy_get_bbmult(phy_info_t * pi)
+{
+	uint16 m0m1;
+	phytbl_info_t tab;
+
+	tab.tbl_ptr = &m0m1;
+	tab.tbl_len = 1;
+	tab.tbl_id = LCNPHY_TBL_ID_IQLOCAL;
+	tab.tbl_offset = 87;
+	tab.tbl_width = 16;
+	wlc_lcnphy_read_table(pi, &tab);
+
+	return (uint8) ((m0m1 & 0xff00) >> 8);
+}
+
+static void wlc_lcnphy_set_pa_gain(phy_info_t * pi, uint16 gain)
+{
+	mod_phy_reg(pi, 0x4fb,
+		    LCNPHY_txgainctrlovrval1_pagain_ovr_val1_MASK,
+		    gain << LCNPHY_txgainctrlovrval1_pagain_ovr_val1_SHIFT);
+	mod_phy_reg(pi, 0x4fd,
+		    LCNPHY_stxtxgainctrlovrval1_pagain_ovr_val1_MASK,
+		    gain << LCNPHY_stxtxgainctrlovrval1_pagain_ovr_val1_SHIFT);
+}
+
+void
+wlc_lcnphy_get_radio_loft(phy_info_t * pi,
+			  uint8 * ei0, uint8 * eq0, uint8 * fi0, uint8 * fq0)
+{
+	*ei0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG089));
+	*eq0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG08A));
+	*fi0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG08B));
+	*fq0 = LCNPHY_IQLOCC_READ(read_radio_reg(pi, RADIO_2064_REG08C));
+}
+
+static void wlc_lcnphy_get_tx_gain(phy_info_t * pi, lcnphy_txgains_t * gains)
+{
+	uint16 dac_gain;
+
+	dac_gain = read_phy_reg(pi, 0x439) >> 0;
+	gains->dac_gain = (dac_gain & 0x380) >> 7;
+
+	{
+		uint16 rfgain0, rfgain1;
+
+		rfgain0 = (read_phy_reg(pi, 0x4b5) & (0xffff << 0)) >> 0;
+		rfgain1 = (read_phy_reg(pi, 0x4fb) & (0x7fff << 0)) >> 0;
+
+		gains->gm_gain = rfgain0 & 0xff;
+		gains->pga_gain = (rfgain0 >> 8) & 0xff;
+		gains->pad_gain = rfgain1 & 0xff;
+	}
+}
+
+void wlc_lcnphy_set_tx_iqcc(phy_info_t * pi, uint16 a, uint16 b)
+{
+	phytbl_info_t tab;
+	uint16 iqcc[2];
+
+	iqcc[0] = a;
+	iqcc[1] = b;
+
+	tab.tbl_id = LCNPHY_TBL_ID_IQLOCAL;
+	tab.tbl_width = 16;
+	tab.tbl_ptr = iqcc;
+	tab.tbl_len = 2;
+	tab.tbl_offset = 80;
+	wlc_lcnphy_write_table(pi, &tab);
+}
+
+void wlc_lcnphy_set_tx_locc(phy_info_t * pi, uint16 didq)
+{
+	phytbl_info_t tab;
+
+	tab.tbl_id = LCNPHY_TBL_ID_IQLOCAL;
+	tab.tbl_width = 16;
+	tab.tbl_ptr = &didq;
+	tab.tbl_len = 1;
+	tab.tbl_offset = 85;
+	wlc_lcnphy_write_table(pi, &tab);
+}
+
+void wlc_lcnphy_set_tx_pwr_by_index(phy_info_t * pi, int index)
+{
+	phytbl_info_t tab;
+	uint16 a, b;
+	uint8 bb_mult;
+	uint32 bbmultiqcomp, txgain, locoeffs, rfpower;
+	lcnphy_txgains_t gains;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	ASSERT(index <= LCNPHY_MAX_TX_POWER_INDEX);
+
+	pi_lcn->lcnphy_tx_power_idx_override = (int8) index;
+	pi_lcn->lcnphy_current_index = (uint8) index;
+
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_len = 1;
+
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);
+
+	tab.tbl_offset = LCNPHY_TX_PWR_CTRL_IQ_OFFSET + index;
+	tab.tbl_ptr = &bbmultiqcomp;
+	wlc_lcnphy_read_table(pi, &tab);
+
+	tab.tbl_offset = LCNPHY_TX_PWR_CTRL_GAIN_OFFSET + index;
+	tab.tbl_width = 32;
+	tab.tbl_ptr = &txgain;
+	wlc_lcnphy_read_table(pi, &tab);
+
+	gains.gm_gain = (uint16) (txgain & 0xff);
+	gains.pga_gain = (uint16) (txgain >> 8) & 0xff;
+	gains.pad_gain = (uint16) (txgain >> 16) & 0xff;
+	gains.dac_gain = (uint16) (bbmultiqcomp >> 28) & 0x07;
+	wlc_lcnphy_set_tx_gain(pi, &gains);
+	wlc_lcnphy_set_pa_gain(pi, (uint16) (txgain >> 24) & 0x7f);
+
+	bb_mult = (uint8) ((bbmultiqcomp >> 20) & 0xff);
+	wlc_lcnphy_set_bbmult(pi, bb_mult);
+
+	wlc_lcnphy_enable_tx_gain_override(pi);
+
+	if (!wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
+
+		a = (uint16) ((bbmultiqcomp >> 10) & 0x3ff);
+		b = (uint16) (bbmultiqcomp & 0x3ff);
+		wlc_lcnphy_set_tx_iqcc(pi, a, b);
+
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_LO_OFFSET + index;
+		tab.tbl_ptr = &locoeffs;
+		wlc_lcnphy_read_table(pi, &tab);
+
+		wlc_lcnphy_set_tx_locc(pi, (uint16) locoeffs);
+
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_PWR_OFFSET + index;
+		tab.tbl_ptr = &rfpower;
+		wlc_lcnphy_read_table(pi, &tab);
+		mod_phy_reg(pi, 0x6a6, (0x1fff << 0), (rfpower * 8) << 0);
+
+	}
+}
+
+static void wlc_lcnphy_set_trsw_override(phy_info_t * pi, bool tx, bool rx)
+{
+
+	mod_phy_reg(pi, 0x44d,
+		    (0x1 << 1) |
+		    (0x1 << 0), (tx ? (0x1 << 1) : 0) | (rx ? (0x1 << 0) : 0));
+
+	or_phy_reg(pi, 0x44c, (0x1 << 1) | (0x1 << 0));
+}
+
+static void wlc_lcnphy_clear_papd_comptable(phy_info_t * pi)
+{
+	uint32 j;
+	phytbl_info_t tab;
+	uint32 temp_offset[128];
+	tab.tbl_ptr = temp_offset;
+	tab.tbl_len = 128;
+	tab.tbl_id = LCNPHY_TBL_ID_PAPDCOMPDELTATBL;
+	tab.tbl_width = 32;
+	tab.tbl_offset = 0;
+
+	bzero(temp_offset, sizeof(temp_offset));
+	for (j = 1; j < 128; j += 2)
+		temp_offset[j] = 0x80000;
+
+	wlc_lcnphy_write_table(pi, &tab);
+	return;
+}
+
+static void
+wlc_lcnphy_set_rx_gain_by_distribution(phy_info_t * pi,
+				       uint16 trsw,
+				       uint16 ext_lna,
+				       uint16 biq2,
+				       uint16 biq1,
+				       uint16 tia, uint16 lna2, uint16 lna1)
+{
+	uint16 gain0_15, gain16_19;
+
+	gain16_19 = biq2 & 0xf;
+	gain0_15 = ((biq1 & 0xf) << 12) |
+	    ((tia & 0xf) << 8) |
+	    ((lna2 & 0x3) << 6) |
+	    ((lna2 & 0x3) << 4) | ((lna1 & 0x3) << 2) | ((lna1 & 0x3) << 0);
+
+	mod_phy_reg(pi, 0x4b6, (0xffff << 0), gain0_15 << 0);
+	mod_phy_reg(pi, 0x4b7, (0xf << 0), gain16_19 << 0);
+	mod_phy_reg(pi, 0x4b1, (0x3 << 11), lna1 << 11);
+
+	if (LCNREV_LT(pi->pubpi.phy_rev, 2)) {
+		mod_phy_reg(pi, 0x4b1, (0x1 << 9), ext_lna << 9);
+		mod_phy_reg(pi, 0x4b1, (0x1 << 10), ext_lna << 10);
+	} else {
+		mod_phy_reg(pi, 0x4b1, (0x1 << 10), 0 << 10);
+
+		mod_phy_reg(pi, 0x4b1, (0x1 << 15), 0 << 15);
+
+		mod_phy_reg(pi, 0x4b1, (0x1 << 9), ext_lna << 9);
+	}
+
+	mod_phy_reg(pi, 0x44d, (0x1 << 0), (!trsw) << 0);
+
+}
+
+static void wlc_lcnphy_rx_gain_override_enable(phy_info_t * pi, bool enable)
+{
+	uint16 ebit = enable ? 1 : 0;
+
+	mod_phy_reg(pi, 0x4b0, (0x1 << 8), ebit << 8);
+
+	mod_phy_reg(pi, 0x44c, (0x1 << 0), ebit << 0);
+
+	if (LCNREV_LT(pi->pubpi.phy_rev, 2)) {
+		mod_phy_reg(pi, 0x44c, (0x1 << 4), ebit << 4);
+		mod_phy_reg(pi, 0x44c, (0x1 << 6), ebit << 6);
+		mod_phy_reg(pi, 0x4b0, (0x1 << 5), ebit << 5);
+		mod_phy_reg(pi, 0x4b0, (0x1 << 6), ebit << 6);
+	} else {
+		mod_phy_reg(pi, 0x4b0, (0x1 << 12), ebit << 12);
+		mod_phy_reg(pi, 0x4b0, (0x1 << 13), ebit << 13);
+		mod_phy_reg(pi, 0x4b0, (0x1 << 5), ebit << 5);
+	}
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		mod_phy_reg(pi, 0x4b0, (0x1 << 10), ebit << 10);
+		mod_phy_reg(pi, 0x4e5, (0x1 << 3), ebit << 3);
+	}
+}
+
+void wlc_lcnphy_tx_pu(phy_info_t * pi, bool bEnable)
+{
+	if (!bEnable) {
+
+		and_phy_reg(pi, 0x43b, ~(uint16) ((0x1 << 1) | (0x1 << 4)));
+
+		mod_phy_reg(pi, 0x43c, (0x1 << 1), 1 << 1);
+
+		and_phy_reg(pi, 0x44c,
+			    ~(uint16) ((0x1 << 3) |
+				       (0x1 << 5) |
+				       (0x1 << 12) |
+				       (0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+
+		and_phy_reg(pi, 0x44d,
+			    ~(uint16) ((0x1 << 3) | (0x1 << 5) | (0x1 << 14)));
+		mod_phy_reg(pi, 0x44d, (0x1 << 2), 1 << 2);
+
+		mod_phy_reg(pi, 0x44d, (0x1 << 1) | (0x1 << 0), (0x1 << 0));
+
+		and_phy_reg(pi, 0x4f9,
+			    ~(uint16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+
+		and_phy_reg(pi, 0x4fa,
+			    ~(uint16) ((0x1 << 0) | (0x1 << 1) | (0x1 << 2)));
+	} else {
+
+		mod_phy_reg(pi, 0x43b, (0x1 << 1), 1 << 1);
+		mod_phy_reg(pi, 0x43c, (0x1 << 1), 0 << 1);
+
+		mod_phy_reg(pi, 0x43b, (0x1 << 4), 1 << 4);
+		mod_phy_reg(pi, 0x43c, (0x1 << 6), 0 << 6);
+
+		mod_phy_reg(pi, 0x44c, (0x1 << 12), 1 << 12);
+		mod_phy_reg(pi, 0x44d, (0x1 << 14), 1 << 14);
+
+		wlc_lcnphy_set_trsw_override(pi, TRUE, FALSE);
+
+		mod_phy_reg(pi, 0x44d, (0x1 << 2), 0 << 2);
+		mod_phy_reg(pi, 0x44c, (0x1 << 2), 1 << 2);
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+
+			mod_phy_reg(pi, 0x44c, (0x1 << 3), 1 << 3);
+			mod_phy_reg(pi, 0x44d, (0x1 << 3), 1 << 3);
+
+			mod_phy_reg(pi, 0x44c, (0x1 << 5), 1 << 5);
+			mod_phy_reg(pi, 0x44d, (0x1 << 5), 0 << 5);
+
+			mod_phy_reg(pi, 0x4f9, (0x1 << 1), 1 << 1);
+			mod_phy_reg(pi, 0x4fa, (0x1 << 1), 1 << 1);
+
+			mod_phy_reg(pi, 0x4f9, (0x1 << 2), 1 << 2);
+			mod_phy_reg(pi, 0x4fa, (0x1 << 2), 1 << 2);
+
+			mod_phy_reg(pi, 0x4f9, (0x1 << 0), 1 << 0);
+			mod_phy_reg(pi, 0x4fa, (0x1 << 0), 1 << 0);
+		} else {
+
+			mod_phy_reg(pi, 0x44c, (0x1 << 3), 1 << 3);
+			mod_phy_reg(pi, 0x44d, (0x1 << 3), 0 << 3);
+
+			mod_phy_reg(pi, 0x44c, (0x1 << 5), 1 << 5);
+			mod_phy_reg(pi, 0x44d, (0x1 << 5), 1 << 5);
+
+			mod_phy_reg(pi, 0x4f9, (0x1 << 1), 1 << 1);
+			mod_phy_reg(pi, 0x4fa, (0x1 << 1), 0 << 1);
+
+			mod_phy_reg(pi, 0x4f9, (0x1 << 2), 1 << 2);
+			mod_phy_reg(pi, 0x4fa, (0x1 << 2), 0 << 2);
+
+			mod_phy_reg(pi, 0x4f9, (0x1 << 0), 1 << 0);
+			mod_phy_reg(pi, 0x4fa, (0x1 << 0), 0 << 0);
+		}
+	}
+}
+
+static void
+wlc_lcnphy_run_samples(phy_info_t * pi,
+		       uint16 num_samps,
+		       uint16 num_loops, uint16 wait, bool iqcalmode)
+{
+
+	or_phy_reg(pi, 0x6da, 0x8080);
+
+	mod_phy_reg(pi, 0x642, (0x7f << 0), (num_samps - 1) << 0);
+	if (num_loops != 0xffff)
+		num_loops--;
+	mod_phy_reg(pi, 0x640, (0xffff << 0), num_loops << 0);
+
+	mod_phy_reg(pi, 0x641, (0xffff << 0), wait << 0);
+
+	if (iqcalmode) {
+
+		and_phy_reg(pi, 0x453, (uint16) ~ (0x1 << 15));
+		or_phy_reg(pi, 0x453, (0x1 << 15));
+	} else {
+		write_phy_reg(pi, 0x63f, 1);
+		wlc_lcnphy_tx_pu(pi, 1);
+	}
+
+	or_radio_reg(pi, RADIO_2064_REG112, 0x6);
+}
+
+void wlc_lcnphy_deaf_mode(phy_info_t * pi, bool mode)
+{
+
+	uint8 phybw40;
+	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
+
+	if (LCNREV_LT(pi->pubpi.phy_rev, 2)) {
+		mod_phy_reg(pi, 0x4b0, (0x1 << 5), (mode) << 5);
+		mod_phy_reg(pi, 0x4b1, (0x1 << 9), 0 << 9);
+	} else {
+		mod_phy_reg(pi, 0x4b0, (0x1 << 5), (mode) << 5);
+		mod_phy_reg(pi, 0x4b1, (0x1 << 9), 0 << 9);
+	}
+
+	if (phybw40 == 0) {
+		mod_phy_reg((pi), 0x410,
+			    (0x1 << 6) |
+			    (0x1 << 5),
+			    ((CHSPEC_IS2G(pi->radio_chanspec)) ? (!mode) : 0) <<
+			    6 | (!mode) << 5);
+		mod_phy_reg(pi, 0x410, (0x1 << 7), (mode) << 7);
+	}
+}
+
+void
+wlc_lcnphy_start_tx_tone(phy_info_t * pi, int32 f_kHz, uint16 max_val,
+			 bool iqcalmode)
+{
+	uint8 phy_bw;
+	uint16 num_samps, t, k;
+	uint32 bw;
+	fixed theta = 0, rot = 0;
+	cint32 tone_samp;
+	uint32 data_buf[64];
+	uint16 i_samp, q_samp;
+	phytbl_info_t tab;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	pi->phy_tx_tone_freq = f_kHz;
+
+	wlc_lcnphy_deaf_mode(pi, TRUE);
+
+	phy_bw = 40;
+	if (pi_lcn->lcnphy_spurmod) {
+		write_phy_reg(pi, 0x942, 0x2);
+		write_phy_reg(pi, 0x93b, 0x0);
+		write_phy_reg(pi, 0x93c, 0x0);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, FALSE);
+	}
+
+	if (f_kHz) {
+		k = 1;
+		do {
+			bw = phy_bw * 1000 * k;
+			num_samps = bw / ABS(f_kHz);
+			ASSERT(num_samps <= ARRAYSIZE(data_buf));
+			k++;
+		} while ((num_samps * (uint32) (ABS(f_kHz))) != bw);
+	} else
+		num_samps = 2;
+
+	rot = FIXED((f_kHz * 36) / phy_bw) / 100;
+	theta = 0;
+
+	for (t = 0; t < num_samps; t++) {
+
+		wlc_phy_cordic(theta, &tone_samp);
+
+		theta += rot;
+
+		i_samp = (uint16) (FLOAT(tone_samp.i * max_val) & 0x3ff);
+		q_samp = (uint16) (FLOAT(tone_samp.q * max_val) & 0x3ff);
+		data_buf[t] = (i_samp << 10) | q_samp;
+	}
+
+	mod_phy_reg(pi, 0x6d6, (0x3 << 0), 0 << 0);
+
+	mod_phy_reg(pi, 0x6da, (0x1 << 3), 1 << 3);
+
+	tab.tbl_ptr = data_buf;
+	tab.tbl_len = num_samps;
+	tab.tbl_id = LCNPHY_TBL_ID_SAMPLEPLAY;
+	tab.tbl_offset = 0;
+	tab.tbl_width = 32;
+	wlc_lcnphy_write_table(pi, &tab);
+
+	wlc_lcnphy_run_samples(pi, num_samps, 0xffff, 0, iqcalmode);
+}
+
+void wlc_lcnphy_stop_tx_tone(phy_info_t * pi)
+{
+	int16 playback_status;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	pi->phy_tx_tone_freq = 0;
+	if (pi_lcn->lcnphy_spurmod) {
+		write_phy_reg(pi, 0x942, 0x7);
+		write_phy_reg(pi, 0x93b, 0x2017);
+		write_phy_reg(pi, 0x93c, 0x27c5);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, TRUE);
+	}
+
+	playback_status = read_phy_reg(pi, 0x644);
+	if (playback_status & (0x1 << 0)) {
+		wlc_lcnphy_tx_pu(pi, 0);
+		mod_phy_reg(pi, 0x63f, (0x1 << 1), 1 << 1);
+	} else if (playback_status & (0x1 << 1))
+		mod_phy_reg(pi, 0x453, (0x1 << 15), 0 << 15);
+
+	mod_phy_reg(pi, 0x6d6, (0x3 << 0), 1 << 0);
+
+	mod_phy_reg(pi, 0x6da, (0x1 << 3), 0 << 3);
+
+	mod_phy_reg(pi, 0x6da, (0x1 << 7), 0 << 7);
+
+	and_radio_reg(pi, RADIO_2064_REG112, 0xFFF9);
+
+	wlc_lcnphy_deaf_mode(pi, FALSE);
+}
+
+static void wlc_lcnphy_clear_trsw_override(phy_info_t * pi)
+{
+
+	and_phy_reg(pi, 0x44c, (uint16) ~ ((0x1 << 1) | (0x1 << 0)));
+}
+
+void wlc_lcnphy_get_tx_iqcc(phy_info_t * pi, uint16 * a, uint16 * b)
+{
+	uint16 iqcc[2];
+	phytbl_info_t tab;
+
+	tab.tbl_ptr = iqcc;
+	tab.tbl_len = 2;
+	tab.tbl_id = 0;
+	tab.tbl_offset = 80;
+	tab.tbl_width = 16;
+	wlc_lcnphy_read_table(pi, &tab);
+
+	*a = iqcc[0];
+	*b = iqcc[1];
+}
+
+uint16 wlc_lcnphy_get_tx_locc(phy_info_t * pi)
+{
+	phytbl_info_t tab;
+	uint16 didq;
+
+	tab.tbl_id = 0;
+	tab.tbl_width = 16;
+	tab.tbl_ptr = &didq;
+	tab.tbl_len = 1;
+	tab.tbl_offset = 85;
+	wlc_lcnphy_read_table(pi, &tab);
+
+	return didq;
+}
+
+static void wlc_lcnphy_txpwrtbl_iqlo_cal(phy_info_t * pi)
+{
+
+	lcnphy_txgains_t target_gains, old_gains;
+	uint8 save_bb_mult;
+	uint16 a, b, didq, save_pa_gain = 0;
+	uint idx, SAVE_txpwrindex = 0xFF;
+	uint32 val;
+	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	phytbl_info_t tab;
+	uint8 ei0, eq0, fi0, fq0;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	wlc_lcnphy_get_tx_gain(pi, &old_gains);
+	save_pa_gain = wlc_lcnphy_get_pa_gain(pi);
+
+	save_bb_mult = wlc_lcnphy_get_bbmult(pi);
+
+	if (SAVE_txpwrctrl == LCNPHY_TX_PWR_CTRL_OFF)
+		SAVE_txpwrindex = wlc_lcnphy_get_current_tx_pwr_idx(pi);
+
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);
+
+	target_gains.gm_gain = 7;
+	target_gains.pga_gain = 0;
+	target_gains.pad_gain = 21;
+	target_gains.dac_gain = 0;
+	wlc_lcnphy_set_tx_gain(pi, &target_gains);
+	wlc_lcnphy_set_tx_pwr_by_index(pi, 16);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1) || pi_lcn->lcnphy_hw_iqcal_en) {
+
+		wlc_lcnphy_set_tx_pwr_by_index(pi, 30);
+
+		wlc_lcnphy_tx_iqlo_cal(pi, &target_gains,
+				       (pi_lcn->
+					lcnphy_recal ? LCNPHY_CAL_RECAL :
+					LCNPHY_CAL_FULL), FALSE);
+	} else {
+
+		wlc_lcnphy_tx_iqlo_soft_cal_full(pi);
+	}
+
+	wlc_lcnphy_get_radio_loft(pi, &ei0, &eq0, &fi0, &fq0);
+	if ((ABS((int8) fi0) == 15) && (ABS((int8) fq0) == 15)) {
+		if (CHSPEC_IS5G(pi->radio_chanspec)) {
+			target_gains.gm_gain = 255;
+			target_gains.pga_gain = 255;
+			target_gains.pad_gain = 0xf0;
+			target_gains.dac_gain = 0;
+		} else {
+			target_gains.gm_gain = 7;
+			target_gains.pga_gain = 45;
+			target_gains.pad_gain = 186;
+			target_gains.dac_gain = 0;
+		}
+
+		if (LCNREV_IS(pi->pubpi.phy_rev, 1)
+		    || pi_lcn->lcnphy_hw_iqcal_en) {
+
+			target_gains.pga_gain = 0;
+			target_gains.pad_gain = 30;
+			wlc_lcnphy_set_tx_pwr_by_index(pi, 16);
+			wlc_lcnphy_tx_iqlo_cal(pi, &target_gains,
+					       LCNPHY_CAL_FULL, FALSE);
+		} else {
+
+			wlc_lcnphy_tx_iqlo_soft_cal_full(pi);
+		}
+
+	}
+
+	wlc_lcnphy_get_tx_iqcc(pi, &a, &b);
+
+	didq = wlc_lcnphy_get_tx_locc(pi);
+
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_ptr = &val;
+
+	tab.tbl_len = 1;
+	tab.tbl_offset = LCNPHY_TX_PWR_CTRL_RATE_OFFSET;
+
+	for (idx = 0; idx < 128; idx++) {
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_IQ_OFFSET + idx;
+
+		wlc_lcnphy_read_table(pi, &tab);
+		val = (val & 0xfff00000) |
+		    ((uint32) (a & 0x3FF) << 10) | (b & 0x3ff);
+		wlc_lcnphy_write_table(pi, &tab);
+
+		val = didq;
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_LO_OFFSET + idx;
+		wlc_lcnphy_write_table(pi, &tab);
+	}
+
+	pi_lcn->lcnphy_cal_results.txiqlocal_a = a;
+	pi_lcn->lcnphy_cal_results.txiqlocal_b = b;
+	pi_lcn->lcnphy_cal_results.txiqlocal_didq = didq;
+	pi_lcn->lcnphy_cal_results.txiqlocal_ei0 = ei0;
+	pi_lcn->lcnphy_cal_results.txiqlocal_eq0 = eq0;
+	pi_lcn->lcnphy_cal_results.txiqlocal_fi0 = fi0;
+	pi_lcn->lcnphy_cal_results.txiqlocal_fq0 = fq0;
+
+	wlc_lcnphy_set_bbmult(pi, save_bb_mult);
+	wlc_lcnphy_set_pa_gain(pi, save_pa_gain);
+	wlc_lcnphy_set_tx_gain(pi, &old_gains);
+
+	if (SAVE_txpwrctrl != LCNPHY_TX_PWR_CTRL_OFF)
+		wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_txpwrctrl);
+	else
+		wlc_lcnphy_set_tx_pwr_by_index(pi, SAVE_txpwrindex);
+}
+
+int16 wlc_lcnphy_tempsense_new(phy_info_t * pi, bool mode)
+{
+	uint16 tempsenseval1, tempsenseval2;
+	int16 avg = 0;
+	bool suspend = 0;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return -1;
+
+	if (mode == 1) {
+		suspend =
+		    (0 ==
+		     (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+		if (!suspend)
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+		wlc_lcnphy_vbat_temp_sense_setup(pi, TEMPSENSE);
+	}
+	tempsenseval1 = read_phy_reg(pi, 0x476) & 0x1FF;
+	tempsenseval2 = read_phy_reg(pi, 0x477) & 0x1FF;
+
+	if (tempsenseval1 > 255)
+		avg = (int16) (tempsenseval1 - 512);
+	else
+		avg = (int16) tempsenseval1;
+
+	if (tempsenseval2 > 255)
+		avg += (int16) (tempsenseval2 - 512);
+	else
+		avg += (int16) tempsenseval2;
+
+	avg /= 2;
+
+	if (mode == 1) {
+
+		mod_phy_reg(pi, 0x448, (0x1 << 14), (1) << 14);
+
+		OSL_DELAY(100);
+		mod_phy_reg(pi, 0x448, (0x1 << 14), (0) << 14);
+
+		if (!suspend)
+			wlapi_enable_mac(pi->sh->physhim);
+	}
+	return avg;
+}
+
+uint16 wlc_lcnphy_tempsense(phy_info_t * pi, bool mode)
+{
+	uint16 tempsenseval1, tempsenseval2;
+	int32 avg = 0;
+	bool suspend = 0;
+	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return -1;
+
+	if (mode == 1) {
+		suspend =
+		    (0 ==
+		     (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+		if (!suspend)
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+		wlc_lcnphy_vbat_temp_sense_setup(pi, TEMPSENSE);
+	}
+	tempsenseval1 = read_phy_reg(pi, 0x476) & 0x1FF;
+	tempsenseval2 = read_phy_reg(pi, 0x477) & 0x1FF;
+
+	if (tempsenseval1 > 255)
+		avg = (int)(tempsenseval1 - 512);
+	else
+		avg = (int)tempsenseval1;
+
+	if (pi_lcn->lcnphy_tempsense_option == 1 || pi->hwpwrctrl_capable) {
+		if (tempsenseval2 > 255)
+			avg = (int)(avg - tempsenseval2 + 512);
+		else
+			avg = (int)(avg - tempsenseval2);
+	} else {
+		if (tempsenseval2 > 255)
+			avg = (int)(avg + tempsenseval2 - 512);
+		else
+			avg = (int)(avg + tempsenseval2);
+		avg = avg / 2;
+	}
+	if (avg < 0)
+		avg = avg + 512;
+
+	if (pi_lcn->lcnphy_tempsense_option == 2)
+		avg = tempsenseval1;
+
+	if (mode)
+		wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_txpwrctrl);
+
+	if (mode == 1) {
+
+		mod_phy_reg(pi, 0x448, (0x1 << 14), (1) << 14);
+
+		OSL_DELAY(100);
+		mod_phy_reg(pi, 0x448, (0x1 << 14), (0) << 14);
+
+		if (!suspend)
+			wlapi_enable_mac(pi->sh->physhim);
+	}
+	return (uint16) avg;
+}
+
+int8 wlc_lcnphy_tempsense_degree(phy_info_t * pi, bool mode)
+{
+	int32 degree = wlc_lcnphy_tempsense_new(pi, mode);
+	degree =
+	    ((degree << 10) + LCN_TEMPSENSE_OFFSET + (LCN_TEMPSENSE_DEN >> 1))
+	    / LCN_TEMPSENSE_DEN;
+	return (int8) degree;
+}
+
+int8 wlc_lcnphy_vbatsense(phy_info_t * pi, bool mode)
+{
+	uint16 vbatsenseval;
+	int32 avg = 0;
+	bool suspend = 0;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return -1;
+
+	if (mode == 1) {
+		suspend =
+		    (0 ==
+		     (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+		if (!suspend)
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+		wlc_lcnphy_vbat_temp_sense_setup(pi, VBATSENSE);
+	}
+
+	vbatsenseval = read_phy_reg(pi, 0x475) & 0x1FF;
+
+	if (vbatsenseval > 255)
+		avg = (int32) (vbatsenseval - 512);
+	else
+		avg = (int32) vbatsenseval;
+
+	avg =
+	    (avg * LCN_VBAT_SCALE_NOM +
+	     (LCN_VBAT_SCALE_DEN >> 1)) / LCN_VBAT_SCALE_DEN;
+
+	if (mode == 1) {
+		if (!suspend)
+			wlapi_enable_mac(pi->sh->physhim);
+	}
+	return (int8) avg;
+}
+
+static void wlc_lcnphy_afe_clk_init(phy_info_t * pi, uint8 mode)
+{
+	uint8 phybw40;
+	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
+
+	mod_phy_reg(pi, 0x6d1, (0x1 << 7), (1) << 7);
+
+	if (((mode == AFE_CLK_INIT_MODE_PAPD) && (phybw40 == 0)) ||
+	    (mode == AFE_CLK_INIT_MODE_TXRX2X))
+		write_phy_reg(pi, 0x6d0, 0x7);
+
+	wlc_lcnphy_toggle_afe_pwdn(pi);
+}
+
+static bool
+wlc_lcnphy_rx_iq_est(phy_info_t * pi,
+		     uint16 num_samps,
+		     uint8 wait_time, lcnphy_iq_est_t * iq_est)
+{
+	int wait_count = 0;
+	bool result = TRUE;
+	uint8 phybw40;
+	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
+
+	mod_phy_reg(pi, 0x6da, (0x1 << 5), (1) << 5);
+
+	mod_phy_reg(pi, 0x410, (0x1 << 3), (0) << 3);
+
+	mod_phy_reg(pi, 0x482, (0xffff << 0), (num_samps) << 0);
+
+	mod_phy_reg(pi, 0x481, (0xff << 0), ((uint16) wait_time) << 0);
+
+	mod_phy_reg(pi, 0x481, (0x1 << 8), (0) << 8);
+
+	mod_phy_reg(pi, 0x481, (0x1 << 9), (1) << 9);
+
+	while (read_phy_reg(pi, 0x481) & (0x1 << 9)) {
+
+		if (wait_count > (10 * 500)) {
+			result = FALSE;
+			goto cleanup;
+		}
+		OSL_DELAY(100);
+		wait_count++;
+	}
+
+	iq_est->iq_prod = ((uint32) read_phy_reg(pi, 0x483) << 16) |
+	    (uint32) read_phy_reg(pi, 0x484);
+	iq_est->i_pwr = ((uint32) read_phy_reg(pi, 0x485) << 16) |
+	    (uint32) read_phy_reg(pi, 0x486);
+	iq_est->q_pwr = ((uint32) read_phy_reg(pi, 0x487) << 16) |
+	    (uint32) read_phy_reg(pi, 0x488);
+
+ cleanup:
+	mod_phy_reg(pi, 0x410, (0x1 << 3), (1) << 3);
+
+	mod_phy_reg(pi, 0x6da, (0x1 << 5), (0) << 5);
+
+	return result;
+}
+
+static bool wlc_lcnphy_calc_rx_iq_comp(phy_info_t * pi, uint16 num_samps)
+{
+#define LCNPHY_MIN_RXIQ_PWR 2
+	bool result;
+	uint16 a0_new, b0_new;
+	lcnphy_iq_est_t iq_est = { 0, 0, 0 };
+	int32 a, b, temp;
+	int16 iq_nbits, qq_nbits, arsh, brsh;
+	int32 iq;
+	uint32 ii, qq;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	a0_new = ((read_phy_reg(pi, 0x645) & (0x3ff << 0)) >> 0);
+	b0_new = ((read_phy_reg(pi, 0x646) & (0x3ff << 0)) >> 0);
+	mod_phy_reg(pi, 0x6d1, (0x1 << 2), (0) << 2);
+
+	mod_phy_reg(pi, 0x64b, (0x1 << 6), (1) << 6);
+
+	wlc_lcnphy_set_rx_iq_comp(pi, 0, 0);
+
+	if (!(result = wlc_lcnphy_rx_iq_est(pi, num_samps, 32, &iq_est)))
+		goto cleanup;
+
+	iq = (int32) iq_est.iq_prod;
+	ii = iq_est.i_pwr;
+	qq = iq_est.q_pwr;
+
+	if ((ii + qq) < LCNPHY_MIN_RXIQ_PWR) {
+		result = FALSE;
+		goto cleanup;
+	}
+
+	iq_nbits = wlc_phy_nbits(iq);
+	qq_nbits = wlc_phy_nbits(qq);
+
+	arsh = 10 - (30 - iq_nbits);
+	if (arsh >= 0) {
+		a = (-(iq << (30 - iq_nbits)) + (ii >> (1 + arsh)));
+		temp = (int32) (ii >> arsh);
+		if (temp == 0) {
+			return FALSE;
+		}
+	} else {
+		a = (-(iq << (30 - iq_nbits)) + (ii << (-1 - arsh)));
+		temp = (int32) (ii << -arsh);
+		if (temp == 0) {
+			return FALSE;
+		}
+	}
+	a /= temp;
+	brsh = qq_nbits - 31 + 20;
+	if (brsh >= 0) {
+		b = (qq << (31 - qq_nbits));
+		temp = (int32) (ii >> brsh);
+		if (temp == 0) {
+			return FALSE;
+		}
+	} else {
+		b = (qq << (31 - qq_nbits));
+		temp = (int32) (ii << -brsh);
+		if (temp == 0) {
+			return FALSE;
+		}
+	}
+	b /= temp;
+	b -= a * a;
+	b = (int32) wlc_phy_sqrt_int((uint32) b);
+	b -= (1 << 10);
+	a0_new = (uint16) (a & 0x3ff);
+	b0_new = (uint16) (b & 0x3ff);
+ cleanup:
+
+	wlc_lcnphy_set_rx_iq_comp(pi, a0_new, b0_new);
+
+	mod_phy_reg(pi, 0x64b, (0x1 << 0), (1) << 0);
+
+	mod_phy_reg(pi, 0x64b, (0x1 << 3), (1) << 3);
+
+	pi_lcn->lcnphy_cal_results.rxiqcal_coeff_a0 = a0_new;
+	pi_lcn->lcnphy_cal_results.rxiqcal_coeff_b0 = b0_new;
+
+	return result;
+}
+
+static bool
+wlc_lcnphy_rx_iq_cal(phy_info_t * pi, const lcnphy_rx_iqcomp_t * iqcomp,
+		     int iqcomp_sz, bool tx_switch, bool rx_switch, int module,
+		     int tx_gain_idx)
+{
+	lcnphy_txgains_t old_gains;
+	uint16 tx_pwr_ctrl;
+	uint8 tx_gain_index_old = 0;
+	bool result = FALSE, tx_gain_override_old = FALSE;
+	uint16 i, Core1TxControl_old, RFOverride0_old,
+	    RFOverrideVal0_old, rfoverride2_old, rfoverride2val_old,
+	    rfoverride3_old, rfoverride3val_old, rfoverride4_old,
+	    rfoverride4val_old, afectrlovr_old, afectrlovrval_old;
+	int tia_gain;
+	uint32 received_power, rx_pwr_threshold;
+	uint16 old_sslpnCalibClkEnCtrl, old_sslpnRxFeClkEnCtrl;
+	uint16 values_to_save[11];
+	int16 *ptr;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (NULL == (ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131))) {
+		return FALSE;
+	}
+	if (module == 2) {
+		ASSERT(iqcomp_sz);
+
+		while (iqcomp_sz--) {
+			if (iqcomp[iqcomp_sz].chan ==
+			    CHSPEC_CHANNEL(pi->radio_chanspec)) {
+
+				wlc_lcnphy_set_rx_iq_comp(pi,
+							  (uint16)
+							  iqcomp[iqcomp_sz].a,
+							  (uint16)
+							  iqcomp[iqcomp_sz].b);
+				result = TRUE;
+				break;
+			}
+		}
+		ASSERT(result);
+		goto cal_done;
+	}
+
+	if (module == 1) {
+
+		tx_pwr_ctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+		wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);
+
+		for (i = 0; i < 11; i++) {
+			values_to_save[i] =
+			    read_radio_reg(pi, rxiq_cal_rf_reg[i]);
+		}
+		Core1TxControl_old = read_phy_reg(pi, 0x631);
+
+		or_phy_reg(pi, 0x631, 0x0015);
+
+		RFOverride0_old = read_phy_reg(pi, 0x44c);
+		RFOverrideVal0_old = read_phy_reg(pi, 0x44d);
+		rfoverride2_old = read_phy_reg(pi, 0x4b0);
+		rfoverride2val_old = read_phy_reg(pi, 0x4b1);
+		rfoverride3_old = read_phy_reg(pi, 0x4f9);
+		rfoverride3val_old = read_phy_reg(pi, 0x4fa);
+		rfoverride4_old = read_phy_reg(pi, 0x938);
+		rfoverride4val_old = read_phy_reg(pi, 0x939);
+		afectrlovr_old = read_phy_reg(pi, 0x43b);
+		afectrlovrval_old = read_phy_reg(pi, 0x43c);
+		old_sslpnCalibClkEnCtrl = read_phy_reg(pi, 0x6da);
+		old_sslpnRxFeClkEnCtrl = read_phy_reg(pi, 0x6db);
+
+		tx_gain_override_old = wlc_lcnphy_tx_gain_override_enabled(pi);
+		if (tx_gain_override_old) {
+			wlc_lcnphy_get_tx_gain(pi, &old_gains);
+			tx_gain_index_old = pi_lcn->lcnphy_current_index;
+		}
+
+		wlc_lcnphy_set_tx_pwr_by_index(pi, tx_gain_idx);
+
+		mod_phy_reg(pi, 0x4f9, (0x1 << 0), 1 << 0);
+		mod_phy_reg(pi, 0x4fa, (0x1 << 0), 0 << 0);
+
+		mod_phy_reg(pi, 0x43b, (0x1 << 1), 1 << 1);
+		mod_phy_reg(pi, 0x43c, (0x1 << 1), 0 << 1);
+
+		write_radio_reg(pi, RADIO_2064_REG116, 0x06);
+		write_radio_reg(pi, RADIO_2064_REG12C, 0x07);
+		write_radio_reg(pi, RADIO_2064_REG06A, 0xd3);
+		write_radio_reg(pi, RADIO_2064_REG098, 0x03);
+		write_radio_reg(pi, RADIO_2064_REG00B, 0x7);
+		mod_radio_reg(pi, RADIO_2064_REG113, 1 << 4, 1 << 4);
+		write_radio_reg(pi, RADIO_2064_REG01D, 0x01);
+		write_radio_reg(pi, RADIO_2064_REG114, 0x01);
+		write_radio_reg(pi, RADIO_2064_REG02E, 0x10);
+		write_radio_reg(pi, RADIO_2064_REG12A, 0x08);
+
+		mod_phy_reg(pi, 0x938, (0x1 << 0), 1 << 0);
+		mod_phy_reg(pi, 0x939, (0x1 << 0), 0 << 0);
+		mod_phy_reg(pi, 0x938, (0x1 << 1), 1 << 1);
+		mod_phy_reg(pi, 0x939, (0x1 << 1), 1 << 1);
+		mod_phy_reg(pi, 0x938, (0x1 << 2), 1 << 2);
+		mod_phy_reg(pi, 0x939, (0x1 << 2), 1 << 2);
+		mod_phy_reg(pi, 0x938, (0x1 << 3), 1 << 3);
+		mod_phy_reg(pi, 0x939, (0x1 << 3), 1 << 3);
+		mod_phy_reg(pi, 0x938, (0x1 << 5), 1 << 5);
+		mod_phy_reg(pi, 0x939, (0x1 << 5), 0 << 5);
+
+		mod_phy_reg(pi, 0x43b, (0x1 << 0), 1 << 0);
+		mod_phy_reg(pi, 0x43c, (0x1 << 0), 0 << 0);
+
+		wlc_lcnphy_start_tx_tone(pi, 2000, 120, 0);
+		write_phy_reg(pi, 0x6da, 0xffff);
+		or_phy_reg(pi, 0x6db, 0x3);
+		wlc_lcnphy_set_trsw_override(pi, tx_switch, rx_switch);
+		wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
+
+		tia_gain = 8;
+		rx_pwr_threshold = 950;
+		while (tia_gain > 0) {
+			tia_gain -= 1;
+			wlc_lcnphy_set_rx_gain_by_distribution(pi,
+							       0, 0, 2, 2,
+							       (uint16)
+							       tia_gain, 1, 0);
+			OSL_DELAY(500);
+
+			received_power =
+			    wlc_lcnphy_measure_digital_power(pi, 2000);
+			if (received_power < rx_pwr_threshold)
+				break;
+		}
+		result = wlc_lcnphy_calc_rx_iq_comp(pi, 0xffff);
+
+		wlc_lcnphy_stop_tx_tone(pi);
+
+		write_phy_reg(pi, 0x631, Core1TxControl_old);
+
+		write_phy_reg(pi, 0x44c, RFOverrideVal0_old);
+		write_phy_reg(pi, 0x44d, RFOverrideVal0_old);
+		write_phy_reg(pi, 0x4b0, rfoverride2_old);
+		write_phy_reg(pi, 0x4b1, rfoverride2val_old);
+		write_phy_reg(pi, 0x4f9, rfoverride3_old);
+		write_phy_reg(pi, 0x4fa, rfoverride3val_old);
+		write_phy_reg(pi, 0x938, rfoverride4_old);
+		write_phy_reg(pi, 0x939, rfoverride4val_old);
+		write_phy_reg(pi, 0x43b, afectrlovr_old);
+		write_phy_reg(pi, 0x43c, afectrlovrval_old);
+		write_phy_reg(pi, 0x6da, old_sslpnCalibClkEnCtrl);
+		write_phy_reg(pi, 0x6db, old_sslpnRxFeClkEnCtrl);
+
+		wlc_lcnphy_clear_trsw_override(pi);
+
+		mod_phy_reg(pi, 0x44c, (0x1 << 2), 0 << 2);
+
+		for (i = 0; i < 11; i++) {
+			write_radio_reg(pi, rxiq_cal_rf_reg[i],
+					values_to_save[i]);
+		}
+
+		if (tx_gain_override_old) {
+			wlc_lcnphy_set_tx_pwr_by_index(pi, tx_gain_index_old);
+		} else
+			wlc_lcnphy_disable_tx_gain_override(pi);
+		wlc_lcnphy_set_tx_pwr_ctrl(pi, tx_pwr_ctrl);
+
+		wlc_lcnphy_rx_gain_override_enable(pi, FALSE);
+	}
+
+ cal_done:
+	MFREE(pi->sh->osh, ptr, 131 * sizeof(int16));
+	return result;
+}
+
+static void wlc_lcnphy_temp_adj(phy_info_t * pi)
+{
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+}
+
+static void wlc_lcnphy_glacial_timer_based_cal(phy_info_t * pi)
+{
+	bool suspend;
+	int8 index;
+	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+	suspend =
+	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+	if (!suspend)
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+	wlc_lcnphy_deaf_mode(pi, TRUE);
+	pi->phy_lastcal = pi->sh->now;
+	pi->phy_forcecal = FALSE;
+	index = pi_lcn->lcnphy_current_index;
+
+	wlc_lcnphy_txpwrtbl_iqlo_cal(pi);
+
+	wlc_lcnphy_set_tx_pwr_by_index(pi, index);
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_pwrctrl);
+	wlc_lcnphy_deaf_mode(pi, FALSE);
+	if (!suspend)
+		wlapi_enable_mac(pi->sh->physhim);
+
+}
+
+static void wlc_lcnphy_periodic_cal(phy_info_t * pi)
+{
+	bool suspend, full_cal;
+	const lcnphy_rx_iqcomp_t *rx_iqcomp;
+	int rx_iqcomp_sz;
+	uint16 SAVE_pwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	int8 index;
+	phytbl_info_t tab;
+	int32 a1, b0, b1;
+	int32 tssi, pwr, maxtargetpwr, mintargetpwr;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	pi->phy_lastcal = pi->sh->now;
+	pi->phy_forcecal = FALSE;
+	full_cal =
+	    (pi_lcn->lcnphy_full_cal_channel !=
+	     CHSPEC_CHANNEL(pi->radio_chanspec));
+	pi_lcn->lcnphy_full_cal_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
+	index = pi_lcn->lcnphy_current_index;
+
+	suspend =
+	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+	if (!suspend) {
+
+		wlapi_bmac_write_shm(pi->sh->physhim, M_CTS_DURATION, 10000);
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+	}
+	wlc_lcnphy_deaf_mode(pi, TRUE);
+
+	wlc_lcnphy_txpwrtbl_iqlo_cal(pi);
+
+	rx_iqcomp = lcnphy_rx_iqcomp_table_rev0;
+	rx_iqcomp_sz = ARRAYSIZE(lcnphy_rx_iqcomp_table_rev0);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, TRUE, FALSE, 1, 40);
+	else
+		wlc_lcnphy_rx_iq_cal(pi, NULL, 0, TRUE, FALSE, 1, 127);
+
+	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi)) {
+
+		wlc_lcnphy_idle_tssi_est((wlc_phy_t *) pi);
+
+		b0 = pi->txpa_2g[0];
+		b1 = pi->txpa_2g[1];
+		a1 = pi->txpa_2g[2];
+		maxtargetpwr = wlc_lcnphy_tssi2dbm(10, a1, b0, b1);
+		mintargetpwr = wlc_lcnphy_tssi2dbm(125, a1, b0, b1);
+
+		tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+		tab.tbl_width = 32;
+		tab.tbl_ptr = &pwr;
+		tab.tbl_len = 1;
+		tab.tbl_offset = 0;
+		for (tssi = 0; tssi < 128; tssi++) {
+			pwr = wlc_lcnphy_tssi2dbm(tssi, a1, b0, b1);
+			pwr = (pwr < mintargetpwr) ? mintargetpwr : pwr;
+			wlc_lcnphy_write_table(pi, &tab);
+			tab.tbl_offset++;
+		}
+	}
+
+	wlc_lcnphy_set_tx_pwr_by_index(pi, index);
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, SAVE_pwrctrl);
+	wlc_lcnphy_deaf_mode(pi, FALSE);
+	if (!suspend)
+		wlapi_enable_mac(pi->sh->physhim);
+}
+
+void wlc_lcnphy_calib_modes(phy_info_t * pi, uint mode)
+{
+	uint16 temp_new;
+	int temp1, temp2, temp_diff;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	switch (mode) {
+	case PHY_PERICAL_CHAN:
+
+		break;
+	case PHY_FULLCAL:
+		wlc_lcnphy_periodic_cal(pi);
+		break;
+	case PHY_PERICAL_PHYINIT:
+		wlc_lcnphy_periodic_cal(pi);
+		break;
+	case PHY_PERICAL_WATCHDOG:
+		if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
+			temp_new = wlc_lcnphy_tempsense(pi, 0);
+			temp1 = LCNPHY_TEMPSENSE(temp_new);
+			temp2 = LCNPHY_TEMPSENSE(pi_lcn->lcnphy_cal_temper);
+			temp_diff = temp1 - temp2;
+			if ((pi_lcn->lcnphy_cal_counter > 90) ||
+			    (temp_diff > 60) || (temp_diff < -60)) {
+				wlc_lcnphy_glacial_timer_based_cal(pi);
+				wlc_2064_vco_cal(pi);
+				pi_lcn->lcnphy_cal_temper = temp_new;
+				pi_lcn->lcnphy_cal_counter = 0;
+			} else
+				pi_lcn->lcnphy_cal_counter++;
+		}
+		break;
+	case LCNPHY_PERICAL_TEMPBASED_TXPWRCTRL:
+		if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
+			wlc_lcnphy_tx_power_adjustment((wlc_phy_t *) pi);
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+}
+
+void wlc_lcnphy_get_tssi(phy_info_t * pi, int8 * ofdm_pwr, int8 * cck_pwr)
+{
+	int8 cck_offset;
+	uint16 status;
+	if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi) &&
+	    ((status = (read_phy_reg(pi, 0x4ab))) & (0x1 << 15))) {
+		*ofdm_pwr = (int8) (((read_phy_reg(pi, 0x4ab) & (0x1ff << 0))
+				     >> 0) >> 1);
+
+		if (wlc_phy_tpc_isenabled_lcnphy(pi))
+			cck_offset = pi->tx_power_offset[TXP_FIRST_CCK];
+		else
+			cck_offset = 0;
+
+		*cck_pwr = *ofdm_pwr + cck_offset;
+	} else {
+		*cck_pwr = 0;
+		*ofdm_pwr = 0;
+	}
+}
+
+void WLBANDINITFN(wlc_phy_cal_init_lcnphy) (phy_info_t * pi) {
+	return;
+
+}
+
+static void wlc_lcnphy_set_chanspec_tweaks(phy_info_t * pi, chanspec_t chanspec)
+{
+	uint8 channel = CHSPEC_CHANNEL(chanspec);
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	if (channel == 14) {
+		mod_phy_reg(pi, 0x448, (0x3 << 8), (2) << 8);
+
+	} else {
+		mod_phy_reg(pi, 0x448, (0x3 << 8), (1) << 8);
+
+	}
+	pi_lcn->lcnphy_bandedge_corr = 2;
+	if (channel == 1)
+		pi_lcn->lcnphy_bandedge_corr = 4;
+
+	if (channel == 1 || channel == 2 || channel == 3 ||
+	    channel == 4 || channel == 9 ||
+	    channel == 10 || channel == 11 || channel == 12) {
+		si_pmu_pllcontrol(pi->sh->sih, 0x2, 0xffffffff, 0x03000c04);
+		si_pmu_pllcontrol(pi->sh->sih, 0x3, 0xffffff, 0x0);
+		si_pmu_pllcontrol(pi->sh->sih, 0x4, 0xffffffff, 0x200005c0);
+
+		si_pmu_pllupd(pi->sh->sih);
+		write_phy_reg(pi, 0x942, 0);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, FALSE);
+		pi_lcn->lcnphy_spurmod = 0;
+		mod_phy_reg(pi, 0x424, (0xff << 8), (0x1b) << 8);
+
+		write_phy_reg(pi, 0x425, 0x5907);
+	} else {
+		si_pmu_pllcontrol(pi->sh->sih, 0x2, 0xffffffff, 0x03140c04);
+		si_pmu_pllcontrol(pi->sh->sih, 0x3, 0xffffff, 0x333333);
+		si_pmu_pllcontrol(pi->sh->sih, 0x4, 0xffffffff, 0x202c2820);
+
+		si_pmu_pllupd(pi->sh->sih);
+		write_phy_reg(pi, 0x942, 0);
+		wlc_lcnphy_txrx_spur_avoidance_mode(pi, TRUE);
+
+		pi_lcn->lcnphy_spurmod = 0;
+		mod_phy_reg(pi, 0x424, (0xff << 8), (0x1f) << 8);
+
+		write_phy_reg(pi, 0x425, 0x590a);
+	}
+
+	or_phy_reg(pi, 0x44a, 0x44);
+	write_phy_reg(pi, 0x44a, 0x80);
+}
+
+void
+wlc_lcnphy_pktengtx(wlc_phy_t * ppi, wl_pkteng_t * pkteng, uint8 rate,
+		    struct ether_addr *sa, uint32 wait_delay)
+{
+}
+
+void wlc_lcnphy_tx_power_adjustment(wlc_phy_t * ppi)
+{
+	int8 index;
+	uint16 index2;
+	phy_info_t *pi = (phy_info_t *) ppi;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+	uint16 SAVE_txpwrctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi) && SAVE_txpwrctrl) {
+		index = wlc_lcnphy_tempcompensated_txpwrctrl(pi);
+		index2 = (uint16) (index * 2);
+		mod_phy_reg(pi, 0x4a9, (0x1ff << 0), (index2) << 0);
+
+		pi_lcn->lcnphy_current_index = (int8)
+		    ((read_phy_reg(pi, 0x4a9) & 0xFF) / 2);
+	}
+}
+
+static void wlc_lcnphy_set_rx_iq_comp(phy_info_t * pi, uint16 a, uint16 b)
+{
+	mod_phy_reg(pi, 0x645, (0x3ff << 0), (a) << 0);
+
+	mod_phy_reg(pi, 0x646, (0x3ff << 0), (b) << 0);
+
+	mod_phy_reg(pi, 0x647, (0x3ff << 0), (a) << 0);
+
+	mod_phy_reg(pi, 0x648, (0x3ff << 0), (b) << 0);
+
+	mod_phy_reg(pi, 0x649, (0x3ff << 0), (a) << 0);
+
+	mod_phy_reg(pi, 0x64a, (0x3ff << 0), (b) << 0);
+
+}
+
+void WLBANDINITFN(wlc_phy_init_lcnphy) (phy_info_t * pi) {
+	uint8 phybw40;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
+
+	pi_lcn->lcnphy_cal_counter = 0;
+	pi_lcn->lcnphy_cal_temper = pi_lcn->lcnphy_rawtempsense;
+
+	or_phy_reg(pi, 0x44a, 0x80);
+	and_phy_reg(pi, 0x44a, 0x7f);
+
+	wlc_lcnphy_afe_clk_init(pi, AFE_CLK_INIT_MODE_TXRX2X);
+
+	write_phy_reg(pi, 0x60a, 160);
+
+	write_phy_reg(pi, 0x46a, 25);
+
+	wlc_lcnphy_baseband_init(pi);
+
+	wlc_lcnphy_radio_init(pi);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec))
+		wlc_lcnphy_tx_pwr_ctrl_init((wlc_phy_t *) pi);
+
+	wlc_phy_chanspec_set((wlc_phy_t *) pi, pi->radio_chanspec);
+
+	si_pmu_regcontrol(pi->sh->sih, 0, 0xf, 0x9);
+
+	si_pmu_chipcontrol(pi->sh->sih, 0, 0xffffffff, 0x03CDDDDD);
+
+	if ((pi->sh->boardflags & BFL_FEM)
+	    && wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
+		wlc_lcnphy_set_tx_pwr_by_index(pi, FIXED_TXPWR);
+
+	wlc_lcnphy_agc_temp_init(pi);
+
+	wlc_lcnphy_temp_adj(pi);
+
+	mod_phy_reg(pi, 0x448, (0x1 << 14), (1) << 14);
+
+	OSL_DELAY(100);
+	mod_phy_reg(pi, 0x448, (0x1 << 14), (0) << 14);
+
+	wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_HW);
+	pi_lcn->lcnphy_noise_samples = LCNPHY_NOISE_SAMPLES_DEFAULT;
+	wlc_lcnphy_calib_modes(pi, PHY_PERICAL_PHYINIT);
+}
+
+static void
+wlc_lcnphy_tx_iqlo_loopback(phy_info_t * pi, uint16 * values_to_save)
+{
+	uint16 vmid;
+	int i;
+	for (i = 0; i < 20; i++) {
+		values_to_save[i] =
+		    read_radio_reg(pi, iqlo_loopback_rf_regs[i]);
+	}
+
+	mod_phy_reg(pi, 0x44c, (0x1 << 12), 1 << 12);
+	mod_phy_reg(pi, 0x44d, (0x1 << 14), 1 << 14);
+
+	mod_phy_reg(pi, 0x44c, (0x1 << 11), 1 << 11);
+	mod_phy_reg(pi, 0x44d, (0x1 << 13), 0 << 13);
+
+	mod_phy_reg(pi, 0x43b, (0x1 << 1), 1 << 1);
+	mod_phy_reg(pi, 0x43c, (0x1 << 1), 0 << 1);
+
+	mod_phy_reg(pi, 0x43b, (0x1 << 0), 1 << 0);
+	mod_phy_reg(pi, 0x43c, (0x1 << 0), 0 << 0);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2))
+		and_radio_reg(pi, RADIO_2064_REG03A, 0xFD);
+	else
+		and_radio_reg(pi, RADIO_2064_REG03A, 0xF9);
+	or_radio_reg(pi, RADIO_2064_REG11A, 0x1);
+
+	or_radio_reg(pi, RADIO_2064_REG036, 0x01);
+	or_radio_reg(pi, RADIO_2064_REG11A, 0x18);
+	OSL_DELAY(20);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
+		if (CHSPEC_IS5G(pi->radio_chanspec))
+			mod_radio_reg(pi, RADIO_2064_REG03A, 1, 0);
+		else
+			or_radio_reg(pi, RADIO_2064_REG03A, 1);
+	} else {
+		if (CHSPEC_IS5G(pi->radio_chanspec))
+			mod_radio_reg(pi, RADIO_2064_REG03A, 3, 1);
+		else
+			or_radio_reg(pi, RADIO_2064_REG03A, 0x3);
+	}
+
+	OSL_DELAY(20);
+
+	write_radio_reg(pi, RADIO_2064_REG025, 0xF);
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
+		if (CHSPEC_IS5G(pi->radio_chanspec))
+			mod_radio_reg(pi, RADIO_2064_REG028, 0xF, 0x4);
+		else
+			mod_radio_reg(pi, RADIO_2064_REG028, 0xF, 0x6);
+	} else {
+		if (CHSPEC_IS5G(pi->radio_chanspec))
+			mod_radio_reg(pi, RADIO_2064_REG028, 0x1e, 0x4 << 1);
+		else
+			mod_radio_reg(pi, RADIO_2064_REG028, 0x1e, 0x6 << 1);
+	}
+
+	OSL_DELAY(20);
+
+	write_radio_reg(pi, RADIO_2064_REG005, 0x8);
+	or_radio_reg(pi, RADIO_2064_REG112, 0x80);
+	OSL_DELAY(20);
+
+	or_radio_reg(pi, RADIO_2064_REG0FF, 0x10);
+	or_radio_reg(pi, RADIO_2064_REG11F, 0x44);
+	OSL_DELAY(20);
+
+	or_radio_reg(pi, RADIO_2064_REG00B, 0x7);
+	or_radio_reg(pi, RADIO_2064_REG113, 0x10);
+	OSL_DELAY(20);
+
+	write_radio_reg(pi, RADIO_2064_REG007, 0x1);
+	OSL_DELAY(20);
+
+	vmid = 0x2A6;
+	mod_radio_reg(pi, RADIO_2064_REG0FC, 0x3 << 0, (vmid >> 8) & 0x3);
+	write_radio_reg(pi, RADIO_2064_REG0FD, (vmid & 0xff));
+	or_radio_reg(pi, RADIO_2064_REG11F, 0x44);
+	OSL_DELAY(20);
+
+	or_radio_reg(pi, RADIO_2064_REG0FF, 0x10);
+	OSL_DELAY(20);
+	write_radio_reg(pi, RADIO_2064_REG012, 0x02);
+	or_radio_reg(pi, RADIO_2064_REG112, 0x06);
+	write_radio_reg(pi, RADIO_2064_REG036, 0x11);
+	write_radio_reg(pi, RADIO_2064_REG059, 0xcc);
+	write_radio_reg(pi, RADIO_2064_REG05C, 0x2e);
+	write_radio_reg(pi, RADIO_2064_REG078, 0xd7);
+	write_radio_reg(pi, RADIO_2064_REG092, 0x15);
+}
+
+static void
+wlc_lcnphy_samp_cap(phy_info_t * pi, int clip_detect_algo, uint16 thresh,
+		    int16 * ptr, int mode)
+{
+	uint32 curval1, curval2, stpptr, curptr, strptr, val;
+	uint16 sslpnCalibClkEnCtrl, timer;
+	uint16 old_sslpnCalibClkEnCtrl;
+	int16 imag, real;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	timer = 0;
+	old_sslpnCalibClkEnCtrl = read_phy_reg(pi, 0x6da);
+
+	curval1 = R_REG(pi->sh->osh, &pi->regs->psm_corectlsts);
+	ptr[130] = 0;
+	W_REG(pi->sh->osh, &pi->regs->psm_corectlsts, ((1 << 6) | curval1));
+
+	W_REG(pi->sh->osh, &pi->regs->smpl_clct_strptr, 0x7E00);
+	W_REG(pi->sh->osh, &pi->regs->smpl_clct_stpptr, 0x8000);
+	OSL_DELAY(20);
+	curval2 = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param);
+	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, curval2 | 0x30);
+
+	write_phy_reg(pi, 0x555, 0x0);
+	write_phy_reg(pi, 0x5a6, 0x5);
+
+	write_phy_reg(pi, 0x5a2, (uint16) (mode | mode << 6));
+	write_phy_reg(pi, 0x5cf, 3);
+	write_phy_reg(pi, 0x5a5, 0x3);
+	write_phy_reg(pi, 0x583, 0x0);
+	write_phy_reg(pi, 0x584, 0x0);
+	write_phy_reg(pi, 0x585, 0x0fff);
+	write_phy_reg(pi, 0x586, 0x0000);
+
+	write_phy_reg(pi, 0x580, 0x4501);
+
+	sslpnCalibClkEnCtrl = read_phy_reg(pi, 0x6da);
+	write_phy_reg(pi, 0x6da, (uint32) (sslpnCalibClkEnCtrl | 0x2008));
+	stpptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_stpptr);
+	curptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_curptr);
+	do {
+		OSL_DELAY(10);
+		curptr = R_REG(pi->sh->osh, &pi->regs->smpl_clct_curptr);
+		timer++;
+	} while ((curptr != stpptr) && (timer < 500));
+
+	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, 0x2);
+	strptr = 0x7E00;
+	W_REG(pi->sh->osh, &pi->regs->tplatewrptr, strptr);
+	while (strptr < 0x8000) {
+		val = R_REG(pi->sh->osh, &pi->regs->tplatewrdata);
+		imag = ((val >> 16) & 0x3ff);
+		real = ((val) & 0x3ff);
+		if (imag > 511) {
+			imag -= 1024;
+		}
+		if (real > 511) {
+			real -= 1024;
+		}
+		if (pi_lcn->lcnphy_iqcal_swp_dis)
+			ptr[(strptr - 0x7E00) / 4] = real;
+		else
+			ptr[(strptr - 0x7E00) / 4] = imag;
+		if (clip_detect_algo) {
+			if (imag > thresh || imag < -thresh) {
+				strptr = 0x8000;
+				ptr[130] = 1;
+			}
+		}
+		strptr += 4;
+	}
+
+	write_phy_reg(pi, 0x6da, old_sslpnCalibClkEnCtrl);
+	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, curval2);
+	W_REG(pi->sh->osh, &pi->regs->psm_corectlsts, curval1);
+}
+
+static void wlc_lcnphy_tx_iqlo_soft_cal_full(phy_info_t * pi)
+{
+	lcnphy_unsign16_struct iqcc0, locc2, locc3, locc4;
+
+	wlc_lcnphy_set_cc(pi, 0, 0, 0);
+	wlc_lcnphy_set_cc(pi, 2, 0, 0);
+	wlc_lcnphy_set_cc(pi, 3, 0, 0);
+	wlc_lcnphy_set_cc(pi, 4, 0, 0);
+
+	wlc_lcnphy_a1(pi, 4, 0, 0);
+	wlc_lcnphy_a1(pi, 3, 0, 0);
+	wlc_lcnphy_a1(pi, 2, 3, 2);
+	wlc_lcnphy_a1(pi, 0, 5, 8);
+	wlc_lcnphy_a1(pi, 2, 2, 1);
+	wlc_lcnphy_a1(pi, 0, 4, 3);
+
+	iqcc0 = wlc_lcnphy_get_cc(pi, 0);
+	locc2 = wlc_lcnphy_get_cc(pi, 2);
+	locc3 = wlc_lcnphy_get_cc(pi, 3);
+	locc4 = wlc_lcnphy_get_cc(pi, 4);
+}
+
+static void
+wlc_lcnphy_set_cc(phy_info_t * pi, int cal_type, int16 coeff_x, int16 coeff_y)
+{
+	uint16 di0dq0;
+	uint16 x, y, data_rf;
+	int k;
+	switch (cal_type) {
+	case 0:
+		wlc_lcnphy_set_tx_iqcc(pi, coeff_x, coeff_y);
+		break;
+	case 2:
+		di0dq0 = (coeff_x & 0xff) << 8 | (coeff_y & 0xff);
+		wlc_lcnphy_set_tx_locc(pi, di0dq0);
+		break;
+	case 3:
+		k = wlc_lcnphy_calc_floor(coeff_x, 0);
+		y = 8 + k;
+		k = wlc_lcnphy_calc_floor(coeff_x, 1);
+		x = 8 - k;
+		data_rf = (x * 16 + y);
+		write_radio_reg(pi, RADIO_2064_REG089, data_rf);
+		k = wlc_lcnphy_calc_floor(coeff_y, 0);
+		y = 8 + k;
+		k = wlc_lcnphy_calc_floor(coeff_y, 1);
+		x = 8 - k;
+		data_rf = (x * 16 + y);
+		write_radio_reg(pi, RADIO_2064_REG08A, data_rf);
+		break;
+	case 4:
+		k = wlc_lcnphy_calc_floor(coeff_x, 0);
+		y = 8 + k;
+		k = wlc_lcnphy_calc_floor(coeff_x, 1);
+		x = 8 - k;
+		data_rf = (x * 16 + y);
+		write_radio_reg(pi, RADIO_2064_REG08B, data_rf);
+		k = wlc_lcnphy_calc_floor(coeff_y, 0);
+		y = 8 + k;
+		k = wlc_lcnphy_calc_floor(coeff_y, 1);
+		x = 8 - k;
+		data_rf = (x * 16 + y);
+		write_radio_reg(pi, RADIO_2064_REG08C, data_rf);
+		break;
+	}
+}
+
+static lcnphy_unsign16_struct wlc_lcnphy_get_cc(phy_info_t * pi, int cal_type)
+{
+	uint16 a, b, didq;
+	uint8 di0, dq0, ei, eq, fi, fq;
+	lcnphy_unsign16_struct cc;
+	cc.re = 0;
+	cc.im = 0;
+	switch (cal_type) {
+	case 0:
+		wlc_lcnphy_get_tx_iqcc(pi, &a, &b);
+		cc.re = a;
+		cc.im = b;
+		break;
+	case 2:
+		didq = wlc_lcnphy_get_tx_locc(pi);
+		di0 = (((didq & 0xff00) << 16) >> 24);
+		dq0 = (((didq & 0x00ff) << 24) >> 24);
+		cc.re = (uint16) di0;
+		cc.im = (uint16) dq0;
+		break;
+	case 3:
+		wlc_lcnphy_get_radio_loft(pi, &ei, &eq, &fi, &fq);
+		cc.re = (uint16) ei;
+		cc.im = (uint16) eq;
+		break;
+	case 4:
+		wlc_lcnphy_get_radio_loft(pi, &ei, &eq, &fi, &fq);
+		cc.re = (uint16) fi;
+		cc.im = (uint16) fq;
+		break;
+	}
+	return cc;
+}
+
+static void
+wlc_lcnphy_a1(phy_info_t * pi, int cal_type, int num_levels, int step_size_lg2)
+{
+	const lcnphy_spb_tone_t *phy_c1;
+	lcnphy_spb_tone_t phy_c2;
+	lcnphy_unsign16_struct phy_c3;
+	int phy_c4, phy_c5, k, l, j, phy_c6;
+	uint16 phy_c7, phy_c8, phy_c9;
+	int16 phy_c10, phy_c11, phy_c12, phy_c13, phy_c14, phy_c15, phy_c16;
+	int16 *ptr, phy_c17;
+	int32 phy_c18, phy_c19;
+	uint32 phy_c20, phy_c21;
+	bool phy_c22, phy_c23, phy_c24, phy_c25;
+	uint16 phy_c26, phy_c27;
+	uint16 phy_c28, phy_c29, phy_c30;
+	uint16 phy_c31;
+	uint16 *phy_c32;
+	phy_c21 = 0;
+	phy_c10 = phy_c13 = phy_c14 = phy_c8 = 0;
+	if (NULL == (ptr = MALLOC(pi->sh->osh, sizeof(int16) * 131))) {
+		return;
+	}
+
+	if (NULL == (phy_c32 = MALLOC(pi->sh->osh, sizeof(uint16) * 20))) {
+		return;
+	}
+	phy_c26 = read_phy_reg(pi, 0x6da);
+	phy_c27 = read_phy_reg(pi, 0x6db);
+	phy_c31 = read_radio_reg(pi, RADIO_2064_REG026);
+	write_phy_reg(pi, 0x93d, 0xC0);
+
+	wlc_lcnphy_start_tx_tone(pi, 3750, 88, 0);
+	write_phy_reg(pi, 0x6da, 0xffff);
+	or_phy_reg(pi, 0x6db, 0x3);
+
+	wlc_lcnphy_tx_iqlo_loopback(pi, phy_c32);
+	OSL_DELAY(500);
+	phy_c28 = read_phy_reg(pi, 0x938);
+	phy_c29 = read_phy_reg(pi, 0x4d7);
+	phy_c30 = read_phy_reg(pi, 0x4d8);
+	or_phy_reg(pi, 0x938, 0x1 << 2);
+	or_phy_reg(pi, 0x4d7, 0x1 << 2);
+	or_phy_reg(pi, 0x4d7, 0x1 << 3);
+	mod_phy_reg(pi, 0x4d7, (0x7 << 12), 0x2 << 12);
+	or_phy_reg(pi, 0x4d8, 1 << 0);
+	or_phy_reg(pi, 0x4d8, 1 << 1);
+	mod_phy_reg(pi, 0x4d8, (0x3ff << 2), 0x23A << 2);
+	mod_phy_reg(pi, 0x4d8, (0x7 << 12), 0x7 << 12);
+	phy_c1 = &lcnphy_spb_tone_3750[0];
+	phy_c4 = 32;
+
+	if (num_levels == 0) {
+		if (cal_type != 0) {
+			num_levels = 4;
+		} else {
+			num_levels = 9;
+		}
+	}
+	if (step_size_lg2 == 0) {
+		if (cal_type != 0) {
+			step_size_lg2 = 3;
+		} else {
+			step_size_lg2 = 8;
+		}
+	}
+
+	phy_c7 = (1 << step_size_lg2);
+	phy_c3 = wlc_lcnphy_get_cc(pi, cal_type);
+	phy_c15 = (int16) phy_c3.re;
+	phy_c16 = (int16) phy_c3.im;
+	if (cal_type == 2) {
+		if (phy_c3.re > 127)
+			phy_c15 = phy_c3.re - 256;
+		if (phy_c3.im > 127)
+			phy_c16 = phy_c3.im - 256;
+	}
+	wlc_lcnphy_set_cc(pi, cal_type, phy_c15, phy_c16);
+	OSL_DELAY(20);
+	for (phy_c8 = 0; phy_c7 != 0 && phy_c8 < num_levels; phy_c8++) {
+		phy_c23 = 1;
+		phy_c22 = 0;
+		switch (cal_type) {
+		case 0:
+			phy_c10 = 511;
+			break;
+		case 2:
+			phy_c10 = 127;
+			break;
+		case 3:
+			phy_c10 = 15;
+			break;
+		case 4:
+			phy_c10 = 15;
+			break;
+		}
+
+		phy_c9 = read_phy_reg(pi, 0x93d);
+		phy_c9 = 2 * phy_c9;
+		phy_c24 = 0;
+		phy_c5 = 7;
+		phy_c25 = 1;
+		while (1) {
+			write_radio_reg(pi, RADIO_2064_REG026,
+					(phy_c5 & 0x7) | ((phy_c5 & 0x7) << 4));
+			OSL_DELAY(50);
+			phy_c22 = 0;
+			ptr[130] = 0;
+			wlc_lcnphy_samp_cap(pi, 1, phy_c9, &ptr[0], 2);
+			if (ptr[130] == 1)
+				phy_c22 = 1;
+			if (phy_c22)
+				phy_c5 -= 1;
+			if ((phy_c22 != phy_c24) && (!phy_c25))
+				break;
+			if (!phy_c22)
+				phy_c5 += 1;
+			if (phy_c5 <= 0 || phy_c5 >= 7)
+				break;
+			phy_c24 = phy_c22;
+			phy_c25 = 0;
+		}
+
+		if (phy_c5 < 0)
+			phy_c5 = 0;
+		else if (phy_c5 > 7)
+			phy_c5 = 7;
+
+		for (k = -phy_c7; k <= phy_c7; k += phy_c7) {
+			for (l = -phy_c7; l <= phy_c7; l += phy_c7) {
+				phy_c11 = phy_c15 + k;
+				phy_c12 = phy_c16 + l;
+
+				if (phy_c11 < -phy_c10)
+					phy_c11 = -phy_c10;
+				else if (phy_c11 > phy_c10)
+					phy_c11 = phy_c10;
+				if (phy_c12 < -phy_c10)
+					phy_c12 = -phy_c10;
+				else if (phy_c12 > phy_c10)
+					phy_c12 = phy_c10;
+				wlc_lcnphy_set_cc(pi, cal_type, phy_c11,
+						  phy_c12);
+				OSL_DELAY(20);
+				wlc_lcnphy_samp_cap(pi, 0, 0, ptr, 2);
+
+				phy_c18 = 0;
+				phy_c19 = 0;
+				for (j = 0; j < 128; j++) {
+					if (cal_type != 0) {
+						phy_c6 = j % phy_c4;
+					} else {
+						phy_c6 = (2 * j) % phy_c4;
+					}
+					phy_c2.re = phy_c1[phy_c6].re;
+					phy_c2.im = phy_c1[phy_c6].im;
+					phy_c17 = ptr[j];
+					phy_c18 = phy_c18 + phy_c17 * phy_c2.re;
+					phy_c19 = phy_c19 + phy_c17 * phy_c2.im;
+				}
+
+				phy_c18 = phy_c18 >> 10;
+				phy_c19 = phy_c19 >> 10;
+				phy_c20 =
+				    ((phy_c18 * phy_c18) + (phy_c19 * phy_c19));
+
+				if (phy_c23 || phy_c20 < phy_c21) {
+					phy_c21 = phy_c20;
+					phy_c13 = phy_c11;
+					phy_c14 = phy_c12;
+				}
+				phy_c23 = 0;
+			}
+		}
+		phy_c23 = 1;
+		phy_c15 = phy_c13;
+		phy_c16 = phy_c14;
+		phy_c7 = phy_c7 >> 1;
+		wlc_lcnphy_set_cc(pi, cal_type, phy_c15, phy_c16);
+		OSL_DELAY(20);
+	}
+	goto cleanup;
+ cleanup:
+	wlc_lcnphy_tx_iqlo_loopback_cleanup(pi, phy_c32);
+	wlc_lcnphy_stop_tx_tone(pi);
+	write_phy_reg(pi, 0x6da, phy_c26);
+	write_phy_reg(pi, 0x6db, phy_c27);
+	write_phy_reg(pi, 0x938, phy_c28);
+	write_phy_reg(pi, 0x4d7, phy_c29);
+	write_phy_reg(pi, 0x4d8, phy_c30);
+	write_radio_reg(pi, RADIO_2064_REG026, phy_c31);
+
+	MFREE(pi->sh->osh, phy_c32, 20 * sizeof(uint16));
+	MFREE(pi->sh->osh, ptr, 131 * sizeof(int16));
+}
+
+static void
+wlc_lcnphy_tx_iqlo_loopback_cleanup(phy_info_t * pi, uint16 * values_to_save)
+{
+	int i;
+
+	and_phy_reg(pi, 0x44c, 0x0 >> 11);
+
+	and_phy_reg(pi, 0x43b, 0xC);
+
+	for (i = 0; i < 20; i++) {
+		write_radio_reg(pi, iqlo_loopback_rf_regs[i],
+				values_to_save[i]);
+	}
+}
+
+static void
+WLBANDINITFN(wlc_lcnphy_load_tx_gain_table) (phy_info_t * pi,
+					     const lcnphy_tx_gain_tbl_entry *
+					     gain_table) {
+	uint32 j;
+	phytbl_info_t tab;
+	uint32 val;
+	uint16 pa_gain;
+	uint16 gm_gain;
+
+	if (CHSPEC_IS5G(pi->radio_chanspec))
+		pa_gain = 0x70;
+	else
+		pa_gain = 0x70;
+
+	if (pi->sh->boardflags & BFL_FEM)
+		pa_gain = 0x10;
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_len = 1;
+	tab.tbl_ptr = &val;
+
+	for (j = 0; j < 128; j++) {
+		gm_gain = gain_table[j].gm;
+		val = (((uint32) pa_gain << 24) |
+		       (gain_table[j].pad << 16) |
+		       (gain_table[j].pga << 8) | gm_gain);
+
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_GAIN_OFFSET + j;
+		wlc_lcnphy_write_table(pi, &tab);
+
+		val = (gain_table[j].dac << 28) | (gain_table[j].bb_mult << 20);
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_IQ_OFFSET + j;
+		wlc_lcnphy_write_table(pi, &tab);
+	}
+}
+
+static void wlc_lcnphy_load_rfpower(phy_info_t * pi)
+{
+	phytbl_info_t tab;
+	uint32 val, bbmult, rfgain;
+	uint8 index;
+	uint8 scale_factor = 1;
+	int16 temp, temp1, temp2, qQ, qQ1, qQ2, shift;
+
+	tab.tbl_id = LCNPHY_TBL_ID_TXPWRCTL;
+	tab.tbl_width = 32;
+	tab.tbl_len = 1;
+
+	for (index = 0; index < 128; index++) {
+		tab.tbl_ptr = &bbmult;
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_IQ_OFFSET + index;
+		wlc_lcnphy_read_table(pi, &tab);
+		bbmult = bbmult >> 20;
+
+		tab.tbl_ptr = &rfgain;
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_GAIN_OFFSET + index;
+		wlc_lcnphy_read_table(pi, &tab);
+
+		qm_log10((int32) (bbmult), 0, &temp1, &qQ1);
+		qm_log10((int32) (1 << 6), 0, &temp2, &qQ2);
+
+		if (qQ1 < qQ2) {
+			temp2 = qm_shr16(temp2, qQ2 - qQ1);
+			qQ = qQ1;
+		} else {
+			temp1 = qm_shr16(temp1, qQ1 - qQ2);
+			qQ = qQ2;
+		}
+		temp = qm_sub16(temp1, temp2);
+
+		if (qQ >= 4)
+			shift = qQ - 4;
+		else
+			shift = 4 - qQ;
+
+		val = (((index << shift) + (5 * temp) +
+			(1 << (scale_factor + shift - 3))) >> (scale_factor +
+							       shift - 2));
+
+		tab.tbl_ptr = &val;
+		tab.tbl_offset = LCNPHY_TX_PWR_CTRL_PWR_OFFSET + index;
+		wlc_lcnphy_write_table(pi, &tab);
+	}
+}
+
+static void WLBANDINITFN(wlc_lcnphy_tbl_init) (phy_info_t * pi) {
+	uint idx;
+	uint8 phybw40;
+	phytbl_info_t tab;
+	uint32 val;
+
+	phybw40 = CHSPEC_IS40(pi->radio_chanspec);
+
+	for (idx = 0; idx < dot11lcnphytbl_info_sz_rev0; idx++) {
+		wlc_lcnphy_write_table(pi, &dot11lcnphytbl_info_rev0[idx]);
+	}
+
+	if (pi->sh->boardflags & BFL_FEM_BT) {
+		tab.tbl_id = LCNPHY_TBL_ID_RFSEQ;
+		tab.tbl_width = 16;
+		tab.tbl_ptr = &val;
+		tab.tbl_len = 1;
+		val = 100;
+		tab.tbl_offset = 4;
+		wlc_lcnphy_write_table(pi, &tab);
+	}
+
+	tab.tbl_id = LCNPHY_TBL_ID_RFSEQ;
+	tab.tbl_width = 16;
+	tab.tbl_ptr = &val;
+	tab.tbl_len = 1;
+
+	val = 114;
+	tab.tbl_offset = 0;
+	wlc_lcnphy_write_table(pi, &tab);
+
+	val = 130;
+	tab.tbl_offset = 1;
+	wlc_lcnphy_write_table(pi, &tab);
+
+	val = 6;
+	tab.tbl_offset = 8;
+	wlc_lcnphy_write_table(pi, &tab);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		if (pi->sh->boardflags & BFL_FEM)
+			wlc_lcnphy_load_tx_gain_table(pi,
+						      dot11lcnphy_2GHz_extPA_gaintable_rev0);
+		else
+			wlc_lcnphy_load_tx_gain_table(pi,
+						      dot11lcnphy_2GHz_gaintable_rev0);
+	}
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			for (idx = 0;
+			     idx < dot11lcnphytbl_rx_gain_info_2G_rev2_sz;
+			     idx++)
+				if (pi->sh->boardflags & BFL_EXTLNA)
+					wlc_lcnphy_write_table(pi,
+							       &dot11lcnphytbl_rx_gain_info_extlna_2G_rev2
+							       [idx]);
+				else
+					wlc_lcnphy_write_table(pi,
+							       &dot11lcnphytbl_rx_gain_info_2G_rev2
+							       [idx]);
+		} else {
+			for (idx = 0;
+			     idx < dot11lcnphytbl_rx_gain_info_5G_rev2_sz;
+			     idx++)
+				if (pi->sh->boardflags & BFL_EXTLNA_5GHz)
+					wlc_lcnphy_write_table(pi,
+							       &dot11lcnphytbl_rx_gain_info_extlna_5G_rev2
+							       [idx]);
+				else
+					wlc_lcnphy_write_table(pi,
+							       &dot11lcnphytbl_rx_gain_info_5G_rev2
+							       [idx]);
+		}
+	}
+
+	if ((pi->sh->boardflags & BFL_FEM)
+	    && !(pi->sh->boardflags & BFL_FEM_BT))
+		wlc_lcnphy_write_table(pi, &dot11lcn_sw_ctrl_tbl_info_4313_epa);
+	else if (pi->sh->boardflags & BFL_FEM_BT) {
+		if (pi->sh->boardrev < 0x1250)
+			wlc_lcnphy_write_table(pi,
+					       &dot11lcn_sw_ctrl_tbl_info_4313_bt_epa);
+		else
+			wlc_lcnphy_write_table(pi,
+					       &dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250);
+	} else
+		wlc_lcnphy_write_table(pi, &dot11lcn_sw_ctrl_tbl_info_4313);
+
+	wlc_lcnphy_load_rfpower(pi);
+
+	wlc_lcnphy_clear_papd_comptable(pi);
+}
+
+static void WLBANDINITFN(wlc_lcnphy_rev0_baseband_init) (phy_info_t * pi) {
+	uint16 afectrl1;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	write_radio_reg(pi, RADIO_2064_REG11C, 0x0);
+
+	write_phy_reg(pi, 0x43b, 0x0);
+	write_phy_reg(pi, 0x43c, 0x0);
+	write_phy_reg(pi, 0x44c, 0x0);
+	write_phy_reg(pi, 0x4e6, 0x0);
+	write_phy_reg(pi, 0x4f9, 0x0);
+	write_phy_reg(pi, 0x4b0, 0x0);
+	write_phy_reg(pi, 0x938, 0x0);
+	write_phy_reg(pi, 0x4b0, 0x0);
+	write_phy_reg(pi, 0x44e, 0);
+
+	or_phy_reg(pi, 0x567, 0x03);
+
+	or_phy_reg(pi, 0x44a, 0x44);
+	write_phy_reg(pi, 0x44a, 0x80);
+
+	if (!(pi->sh->boardflags & BFL_FEM))
+		wlc_lcnphy_set_tx_pwr_by_index(pi, 52);
+
+	if (0) {
+		afectrl1 = 0;
+		afectrl1 = (uint16) ((pi_lcn->lcnphy_rssi_vf) |
+				     (pi_lcn->lcnphy_rssi_vc << 4) | (pi_lcn->
+								      lcnphy_rssi_gs
+								      << 10));
+		write_phy_reg(pi, 0x43e, afectrl1);
+	}
+
+	mod_phy_reg(pi, 0x634, (0xff << 0), 0xC << 0);
+	if (pi->sh->boardflags & BFL_FEM) {
+		mod_phy_reg(pi, 0x634, (0xff << 0), 0xA << 0);
+
+		write_phy_reg(pi, 0x910, 0x1);
+	}
+
+	mod_phy_reg(pi, 0x448, (0x3 << 8), 1 << 8);
+	mod_phy_reg(pi, 0x608, (0xff << 0), 0x17 << 0);
+	mod_phy_reg(pi, 0x604, (0x7ff << 0), 0x3EA << 0);
+
+}
+
+static void WLBANDINITFN(wlc_lcnphy_rev2_baseband_init) (phy_info_t * pi) {
+	if (CHSPEC_IS5G(pi->radio_chanspec)) {
+		mod_phy_reg(pi, 0x416, (0xff << 0), 80 << 0);
+
+		mod_phy_reg(pi, 0x416, (0xff << 8), 80 << 8);
+	}
+}
+
+static void wlc_lcnphy_agc_temp_init(phy_info_t * pi)
+{
+	int16 temp;
+	phytbl_info_t tab;
+	uint32 tableBuffer[2];
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	temp = (int16) read_phy_reg(pi, 0x4df);
+	pi_lcn->lcnphy_ofdmgainidxtableoffset = (temp & (0xff << 0)) >> 0;
+
+	if (pi_lcn->lcnphy_ofdmgainidxtableoffset > 127)
+		pi_lcn->lcnphy_ofdmgainidxtableoffset -= 256;
+
+	pi_lcn->lcnphy_dsssgainidxtableoffset = (temp & (0xff << 8)) >> 8;
+
+	if (pi_lcn->lcnphy_dsssgainidxtableoffset > 127)
+		pi_lcn->lcnphy_dsssgainidxtableoffset -= 256;
+
+	tab.tbl_ptr = tableBuffer;
+	tab.tbl_len = 2;
+	tab.tbl_id = 17;
+	tab.tbl_offset = 59;
+	tab.tbl_width = 32;
+	wlc_lcnphy_read_table(pi, &tab);
+
+	if (tableBuffer[0] > 63)
+		tableBuffer[0] -= 128;
+	pi_lcn->lcnphy_tr_R_gain_val = tableBuffer[0];
+
+	if (tableBuffer[1] > 63)
+		tableBuffer[1] -= 128;
+	pi_lcn->lcnphy_tr_T_gain_val = tableBuffer[1];
+
+	temp = (int16) (read_phy_reg(pi, 0x434)
+			& (0xff << 0));
+	if (temp > 127)
+		temp -= 256;
+	pi_lcn->lcnphy_input_pwr_offset_db = (int8) temp;
+
+	pi_lcn->lcnphy_Med_Low_Gain_db = (read_phy_reg(pi, 0x424)
+					  & (0xff << 8))
+	    >> 8;
+	pi_lcn->lcnphy_Very_Low_Gain_db = (read_phy_reg(pi, 0x425)
+					   & (0xff << 0))
+	    >> 0;
+
+	tab.tbl_ptr = tableBuffer;
+	tab.tbl_len = 2;
+	tab.tbl_id = LCNPHY_TBL_ID_GAIN_IDX;
+	tab.tbl_offset = 28;
+	tab.tbl_width = 32;
+	wlc_lcnphy_read_table(pi, &tab);
+
+	pi_lcn->lcnphy_gain_idx_14_lowword = tableBuffer[0];
+	pi_lcn->lcnphy_gain_idx_14_hiword = tableBuffer[1];
+
+}
+
+static void WLBANDINITFN(wlc_lcnphy_bu_tweaks) (phy_info_t * pi) {
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	or_phy_reg(pi, 0x805, 0x1);
+
+	mod_phy_reg(pi, 0x42f, (0x7 << 0), (0x3) << 0);
+
+	mod_phy_reg(pi, 0x030, (0x7 << 0), (0x3) << 0);
+
+	write_phy_reg(pi, 0x414, 0x1e10);
+	write_phy_reg(pi, 0x415, 0x0640);
+
+	mod_phy_reg(pi, 0x4df, (0xff << 8), -9 << 8);
+
+	or_phy_reg(pi, 0x44a, 0x44);
+	write_phy_reg(pi, 0x44a, 0x80);
+	mod_phy_reg(pi, 0x434, (0xff << 0), (0xFD) << 0);
+
+	mod_phy_reg(pi, 0x420, (0xff << 0), (16) << 0);
+
+	if (!(pi->sh->boardrev < 0x1204))
+		mod_radio_reg(pi, RADIO_2064_REG09B, 0xF0, 0xF0);
+
+	write_phy_reg(pi, 0x7d6, 0x0902);
+	mod_phy_reg(pi, 0x429, (0xf << 0), (0x9) << 0);
+
+	mod_phy_reg(pi, 0x429, (0x3f << 4), (0xe) << 4);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1)) {
+		mod_phy_reg(pi, 0x423, (0xff << 0), (0x46) << 0);
+
+		mod_phy_reg(pi, 0x411, (0xff << 0), (1) << 0);
+
+		mod_phy_reg(pi, 0x434, (0xff << 0), (0xFF) << 0);
+
+		mod_phy_reg(pi, 0x656, (0xf << 0), (2) << 0);
+
+		mod_phy_reg(pi, 0x44d, (0x1 << 2), (1) << 2);
+
+		mod_radio_reg(pi, RADIO_2064_REG0F7, 0x4, 0x4);
+		mod_radio_reg(pi, RADIO_2064_REG0F1, 0x3, 0);
+		mod_radio_reg(pi, RADIO_2064_REG0F2, 0xF8, 0x90);
+		mod_radio_reg(pi, RADIO_2064_REG0F3, 0x3, 0x2);
+		mod_radio_reg(pi, RADIO_2064_REG0F3, 0xf0, 0xa0);
+
+		mod_radio_reg(pi, RADIO_2064_REG11F, 0x2, 0x2);
+
+		wlc_lcnphy_clear_tx_power_offsets(pi);
+		mod_phy_reg(pi, 0x4d0, (0x1ff << 6), (10) << 6);
+
+	}
+}
+
+static void WLBANDINITFN(wlc_lcnphy_baseband_init) (phy_info_t * pi) {
+
+	wlc_lcnphy_tbl_init(pi);
+	wlc_lcnphy_rev0_baseband_init(pi);
+	if (LCNREV_IS(pi->pubpi.phy_rev, 2))
+		wlc_lcnphy_rev2_baseband_init(pi);
+	wlc_lcnphy_bu_tweaks(pi);
+}
+
+static void WLBANDINITFN(wlc_radio_2064_init) (phy_info_t * pi) {
+	uint32 i;
+	lcnphy_radio_regs_t *lcnphyregs = NULL;
+
+	lcnphyregs = lcnphy_radio_regs_2064;
+
+	for (i = 0; lcnphyregs[i].address != 0xffff; i++)
+		if (CHSPEC_IS5G(pi->radio_chanspec) && lcnphyregs[i].do_init_a)
+			write_radio_reg(pi,
+					((lcnphyregs[i].address & 0x3fff) |
+					 RADIO_DEFAULT_CORE),
+					(uint16) lcnphyregs[i].init_a);
+		else if (lcnphyregs[i].do_init_g)
+			write_radio_reg(pi,
+					((lcnphyregs[i].address & 0x3fff) |
+					 RADIO_DEFAULT_CORE),
+					(uint16) lcnphyregs[i].init_g);
+
+	write_radio_reg(pi, RADIO_2064_REG032, 0x62);
+	write_radio_reg(pi, RADIO_2064_REG033, 0x19);
+
+	write_radio_reg(pi, RADIO_2064_REG090, 0x10);
+
+	write_radio_reg(pi, RADIO_2064_REG010, 0x00);
+
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1)) {
+
+		write_radio_reg(pi, RADIO_2064_REG060, 0x7f);
+		write_radio_reg(pi, RADIO_2064_REG061, 0x72);
+		write_radio_reg(pi, RADIO_2064_REG062, 0x7f);
+	}
+
+	write_radio_reg(pi, RADIO_2064_REG01D, 0x02);
+	write_radio_reg(pi, RADIO_2064_REG01E, 0x06);
+
+	mod_phy_reg(pi, 0x4ea, (0x7 << 0), 0 << 0);
+
+	mod_phy_reg(pi, 0x4ea, (0x7 << 3), 1 << 3);
+
+	mod_phy_reg(pi, 0x4ea, (0x7 << 6), 2 << 6);
+
+	mod_phy_reg(pi, 0x4ea, (0x7 << 9), 3 << 9);
+
+	mod_phy_reg(pi, 0x4ea, (0x7 << 12), 4 << 12);
+
+	write_phy_reg(pi, 0x4ea, 0x4688);
+
+	mod_phy_reg(pi, 0x4eb, (0x7 << 0), 2 << 0);
+
+	mod_phy_reg(pi, 0x4eb, (0x7 << 6), 0 << 6);
+
+	mod_phy_reg(pi, 0x46a, (0xffff << 0), 25 << 0);
+
+	wlc_lcnphy_set_tx_locc(pi, 0);
+
+	wlc_lcnphy_rcal(pi);
+
+	wlc_lcnphy_rc_cal(pi);
+}
+
+static void WLBANDINITFN(wlc_lcnphy_radio_init) (phy_info_t * pi) {
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	wlc_radio_2064_init(pi);
+}
+
+static void wlc_lcnphy_rcal(phy_info_t * pi)
+{
+	uint8 rcal_value;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	and_radio_reg(pi, RADIO_2064_REG05B, 0xfD);
+
+	or_radio_reg(pi, RADIO_2064_REG004, 0x40);
+	or_radio_reg(pi, RADIO_2064_REG120, 0x10);
+
+	or_radio_reg(pi, RADIO_2064_REG078, 0x80);
+	or_radio_reg(pi, RADIO_2064_REG129, 0x02);
+
+	or_radio_reg(pi, RADIO_2064_REG057, 0x01);
+
+	or_radio_reg(pi, RADIO_2064_REG05B, 0x02);
+	OSL_DELAY(5000);
+	SPINWAIT(!wlc_radio_2064_rcal_done(pi), 10 * 1000 * 1000);
+
+	if (wlc_radio_2064_rcal_done(pi)) {
+		rcal_value = (uint8) read_radio_reg(pi, RADIO_2064_REG05C);
+		rcal_value = rcal_value & 0x1f;
+	}
+
+	and_radio_reg(pi, RADIO_2064_REG05B, 0xfD);
+
+	and_radio_reg(pi, RADIO_2064_REG057, 0xFE);
+}
+
+static void wlc_lcnphy_rc_cal(phy_info_t * pi)
+{
+	uint8 dflt_rc_cal_val;
+	uint16 flt_val;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	dflt_rc_cal_val = 7;
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1))
+		dflt_rc_cal_val = 11;
+	flt_val =
+	    (dflt_rc_cal_val << 10) | (dflt_rc_cal_val << 5) |
+	    (dflt_rc_cal_val);
+	write_phy_reg(pi, 0x933, flt_val);
+	write_phy_reg(pi, 0x934, flt_val);
+	write_phy_reg(pi, 0x935, flt_val);
+	write_phy_reg(pi, 0x936, flt_val);
+	write_phy_reg(pi, 0x937, (flt_val & 0x1FF));
+
+	return;
+}
+
+static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_lcnphy) (phy_info_t * pi) {
+	int8 txpwr = 0;
+	int i;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		uint16 cckpo = 0;
+		uint32 offset_ofdm, offset_mcs;
+
+		pi_lcn->lcnphy_tr_isolation_mid =
+		    (uint8) PHY_GETINTVAR(pi, "triso2g");
+
+		pi_lcn->lcnphy_rx_power_offset =
+		    (uint8) PHY_GETINTVAR(pi, "rxpo2g");
+
+		pi->txpa_2g[0] = (int16) PHY_GETINTVAR(pi, "pa0b0");
+		pi->txpa_2g[1] = (int16) PHY_GETINTVAR(pi, "pa0b1");
+		pi->txpa_2g[2] = (int16) PHY_GETINTVAR(pi, "pa0b2");
+
+		pi_lcn->lcnphy_rssi_vf = (uint8) PHY_GETINTVAR(pi, "rssismf2g");
+		pi_lcn->lcnphy_rssi_vc = (uint8) PHY_GETINTVAR(pi, "rssismc2g");
+		pi_lcn->lcnphy_rssi_gs = (uint8) PHY_GETINTVAR(pi, "rssisav2g");
+
+		{
+			pi_lcn->lcnphy_rssi_vf_lowtemp = pi_lcn->lcnphy_rssi_vf;
+			pi_lcn->lcnphy_rssi_vc_lowtemp = pi_lcn->lcnphy_rssi_vc;
+			pi_lcn->lcnphy_rssi_gs_lowtemp = pi_lcn->lcnphy_rssi_gs;
+
+			pi_lcn->lcnphy_rssi_vf_hightemp =
+			    pi_lcn->lcnphy_rssi_vf;
+			pi_lcn->lcnphy_rssi_vc_hightemp =
+			    pi_lcn->lcnphy_rssi_vc;
+			pi_lcn->lcnphy_rssi_gs_hightemp =
+			    pi_lcn->lcnphy_rssi_gs;
+		}
+
+		txpwr = (int8) PHY_GETINTVAR(pi, "maxp2ga0");
+		pi->tx_srom_max_2g = txpwr;
+
+		for (i = 0; i < PWRTBL_NUM_COEFF; i++) {
+			pi->txpa_2g_low_temp[i] = pi->txpa_2g[i];
+			pi->txpa_2g_high_temp[i] = pi->txpa_2g[i];
+		}
+
+		cckpo = (uint16) PHY_GETINTVAR(pi, "cck2gpo");
+		if (cckpo) {
+			uint max_pwr_chan = txpwr;
+
+			for (i = TXP_FIRST_CCK; i <= TXP_LAST_CCK; i++) {
+				pi->tx_srom_max_rate_2g[i] = max_pwr_chan -
+				    ((cckpo & 0xf) * 2);
+				cckpo >>= 4;
+			}
+
+			offset_ofdm = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+			for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++) {
+				pi->tx_srom_max_rate_2g[i] = max_pwr_chan -
+				    ((offset_ofdm & 0xf) * 2);
+				offset_ofdm >>= 4;
+			}
+		} else {
+			uint8 opo = 0;
+
+			opo = (uint8) PHY_GETINTVAR(pi, "opo");
+
+			for (i = TXP_FIRST_CCK; i <= TXP_LAST_CCK; i++) {
+				pi->tx_srom_max_rate_2g[i] = txpwr;
+			}
+
+			offset_ofdm = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+
+			for (i = TXP_FIRST_OFDM; i <= TXP_LAST_OFDM; i++) {
+				pi->tx_srom_max_rate_2g[i] = txpwr -
+				    ((offset_ofdm & 0xf) * 2);
+				offset_ofdm >>= 4;
+			}
+			offset_mcs =
+			    ((uint16) PHY_GETINTVAR(pi, "mcs2gpo1") << 16) |
+			    (uint16) PHY_GETINTVAR(pi, "mcs2gpo0");
+			pi_lcn->lcnphy_mcs20_po = offset_mcs;
+			for (i = TXP_FIRST_SISO_MCS_20;
+			     i <= TXP_LAST_SISO_MCS_20; i++) {
+				pi->tx_srom_max_rate_2g[i] =
+				    txpwr - ((offset_mcs & 0xf) * 2);
+				offset_mcs >>= 4;
+			}
+		}
+
+		pi_lcn->lcnphy_rawtempsense =
+		    (uint16) PHY_GETINTVAR(pi, "rawtempsense");
+		pi_lcn->lcnphy_measPower =
+		    (uint8) PHY_GETINTVAR(pi, "measpower");
+		pi_lcn->lcnphy_tempsense_slope =
+		    (uint8) PHY_GETINTVAR(pi, "tempsense_slope");
+		pi_lcn->lcnphy_hw_iqcal_en =
+		    (bool) PHY_GETINTVAR(pi, "hw_iqcal_en");
+		pi_lcn->lcnphy_iqcal_swp_dis =
+		    (bool) PHY_GETINTVAR(pi, "iqcal_swp_dis");
+		pi_lcn->lcnphy_tempcorrx =
+		    (uint8) PHY_GETINTVAR(pi, "tempcorrx");
+		pi_lcn->lcnphy_tempsense_option =
+		    (uint8) PHY_GETINTVAR(pi, "tempsense_option");
+		pi_lcn->lcnphy_freqoffset_corr =
+		    (uint8) PHY_GETINTVAR(pi, "freqoffset_corr");
+		if ((uint8) getintvar(pi->vars, "aa2g") > 1)
+			wlc_phy_ant_rxdiv_set((wlc_phy_t *) pi,
+					      (uint8) getintvar(pi->vars,
+								"aa2g"));
+	}
+	pi_lcn->lcnphy_cck_dig_filt_type = -1;
+	if (PHY_GETVAR(pi, "cckdigfilttype")) {
+		int16 temp;
+		temp = (int16) PHY_GETINTVAR(pi, "cckdigfilttype");
+		if (temp >= 0) {
+			pi_lcn->lcnphy_cck_dig_filt_type = temp;
+		}
+	}
+
+	return TRUE;
+}
+
+void wlc_2064_vco_cal(phy_info_t * pi)
+{
+	uint8 calnrst;
+
+	mod_radio_reg(pi, RADIO_2064_REG057, 1 << 3, 1 << 3);
+	calnrst = (uint8) read_radio_reg(pi, RADIO_2064_REG056) & 0xf8;
+	write_radio_reg(pi, RADIO_2064_REG056, calnrst);
+	OSL_DELAY(1);
+	write_radio_reg(pi, RADIO_2064_REG056, calnrst | 0x03);
+	OSL_DELAY(1);
+	write_radio_reg(pi, RADIO_2064_REG056, calnrst | 0x07);
+	OSL_DELAY(300);
+	mod_radio_reg(pi, RADIO_2064_REG057, 1 << 3, 0);
+}
+
+static void
+wlc_lcnphy_radio_2064_channel_tune_4313(phy_info_t * pi, uint8 channel)
+{
+	uint i;
+	const chan_info_2064_lcnphy_t *ci;
+	uint8 rfpll_doubler = 0;
+	uint8 pll_pwrup, pll_pwrup_ovr;
+	fixed qFxtal, qFref, qFvco, qFcal;
+	uint8 d15, d16, f16, e44, e45;
+	uint32 div_int, div_frac, fvco3, fpfd, fref3, fcal_div;
+	uint16 loop_bw, d30, setCount;
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+	ci = &chan_info_2064_lcnphy[0];
+	rfpll_doubler = 1;
+
+	mod_radio_reg(pi, RADIO_2064_REG09D, 0x4, 0x1 << 2);
+
+	write_radio_reg(pi, RADIO_2064_REG09E, 0xf);
+	if (!rfpll_doubler) {
+		loop_bw = PLL_2064_LOOP_BW;
+		d30 = PLL_2064_D30;
+	} else {
+		loop_bw = PLL_2064_LOOP_BW_DOUBLER;
+		d30 = PLL_2064_D30_DOUBLER;
+	}
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		for (i = 0; i < ARRAYSIZE(chan_info_2064_lcnphy); i++)
+			if (chan_info_2064_lcnphy[i].chan == channel)
+				break;
+
+		if (i >= ARRAYSIZE(chan_info_2064_lcnphy)) {
+			return;
+		}
+
+		ci = &chan_info_2064_lcnphy[i];
+	}
+
+	write_radio_reg(pi, RADIO_2064_REG02A, ci->logen_buftune);
+
+	mod_radio_reg(pi, RADIO_2064_REG030, 0x3, ci->logen_rccr_tx);
+
+	mod_radio_reg(pi, RADIO_2064_REG091, 0x3, ci->txrf_mix_tune_ctrl);
+
+	mod_radio_reg(pi, RADIO_2064_REG038, 0xf, ci->pa_input_tune_g);
+
+	mod_radio_reg(pi, RADIO_2064_REG030, 0x3 << 2,
+		      (ci->logen_rccr_rx) << 2);
+
+	mod_radio_reg(pi, RADIO_2064_REG05E, 0xf, ci->pa_rxrf_lna1_freq_tune);
+
+	mod_radio_reg(pi, RADIO_2064_REG05E, (0xf) << 4,
+		      (ci->pa_rxrf_lna2_freq_tune) << 4);
+
+	write_radio_reg(pi, RADIO_2064_REG06C, ci->rxrf_rxrf_spare1);
+
+	pll_pwrup = (uint8) read_radio_reg(pi, RADIO_2064_REG044);
+	pll_pwrup_ovr = (uint8) read_radio_reg(pi, RADIO_2064_REG12B);
+
+	or_radio_reg(pi, RADIO_2064_REG044, 0x07);
+
+	or_radio_reg(pi, RADIO_2064_REG12B, (0x07) << 1);
+	e44 = 0;
+	e45 = 0;
+
+	fpfd = rfpll_doubler ? (pi->xtalfreq << 1) : (pi->xtalfreq);
+	if (pi->xtalfreq > 26000000)
+		e44 = 1;
+	if (pi->xtalfreq > 52000000)
+		e45 = 1;
+	if (e44 == 0)
+		fcal_div = 1;
+	else if (e45 == 0)
+		fcal_div = 2;
+	else
+		fcal_div = 4;
+	fvco3 = (ci->freq * 3);
+	fref3 = 2 * fpfd;
+
+	qFxtal = wlc_lcnphy_qdiv_roundup(pi->xtalfreq, PLL_2064_MHZ, 16);
+	qFref = wlc_lcnphy_qdiv_roundup(fpfd, PLL_2064_MHZ, 16);
+	qFcal = pi->xtalfreq * fcal_div / PLL_2064_MHZ;
+	qFvco = wlc_lcnphy_qdiv_roundup(fvco3, 2, 16);
+
+	write_radio_reg(pi, RADIO_2064_REG04F, 0x02);
+
+	d15 = (pi->xtalfreq * fcal_div * 4 / 5) / PLL_2064_MHZ - 1;
+	write_radio_reg(pi, RADIO_2064_REG052, (0x07 & (d15 >> 2)));
+	write_radio_reg(pi, RADIO_2064_REG053, (d15 & 0x3) << 5);
+
+	d16 = (qFcal * 8 / (d15 + 1)) - 1;
+	write_radio_reg(pi, RADIO_2064_REG051, d16);
+
+	f16 = ((d16 + 1) * (d15 + 1)) / qFcal;
+	setCount = f16 * 3 * (ci->freq) / 32 - 1;
+	mod_radio_reg(pi, RADIO_2064_REG053, (0x0f << 0),
+		      (uint8) (setCount >> 8));
+
+	or_radio_reg(pi, RADIO_2064_REG053, 0x10);
+	write_radio_reg(pi, RADIO_2064_REG054, (uint8) (setCount & 0xff));
+
+	div_int = ((fvco3 * (PLL_2064_MHZ >> 4)) / fref3) << 4;
+
+	div_frac = ((fvco3 * (PLL_2064_MHZ >> 4)) % fref3) << 4;
+	while (div_frac >= fref3) {
+		div_int++;
+		div_frac -= fref3;
+	}
+	div_frac = wlc_lcnphy_qdiv_roundup(div_frac, fref3, 20);
+
+	mod_radio_reg(pi, RADIO_2064_REG045, (0x1f << 0),
+		      (uint8) (div_int >> 4));
+	mod_radio_reg(pi, RADIO_2064_REG046, (0x1f << 4),
+		      (uint8) (div_int << 4));
+	mod_radio_reg(pi, RADIO_2064_REG046, (0x0f << 0),
+		      (uint8) (div_frac >> 16));
+	write_radio_reg(pi, RADIO_2064_REG047, (uint8) (div_frac >> 8) & 0xff);
+	write_radio_reg(pi, RADIO_2064_REG048, (uint8) div_frac & 0xff);
+
+	write_radio_reg(pi, RADIO_2064_REG040, 0xfb);
+
+	write_radio_reg(pi, RADIO_2064_REG041, 0x9A);
+	write_radio_reg(pi, RADIO_2064_REG042, 0xA3);
+	write_radio_reg(pi, RADIO_2064_REG043, 0x0C);
+
+	{
+		uint8 h29, h23, c28, d29, h28_ten, e30, h30_ten, cp_current;
+		uint16 c29, c38, c30, g30, d28;
+		c29 = loop_bw;
+		d29 = 200;
+		c38 = 1250;
+		h29 = d29 / c29;
+		h23 = 1;
+		c28 = 30;
+		d28 = (((PLL_2064_HIGH_END_KVCO - PLL_2064_LOW_END_KVCO) *
+			(fvco3 / 2 - PLL_2064_LOW_END_VCO)) /
+		       (PLL_2064_HIGH_END_VCO - PLL_2064_LOW_END_VCO))
+		    + PLL_2064_LOW_END_KVCO;
+		h28_ten = (d28 * 10) / c28;
+		c30 = 2640;
+		e30 = (d30 - 680) / 490;
+		g30 = 680 + (e30 * 490);
+		h30_ten = (g30 * 10) / c30;
+		cp_current = ((c38 * h29 * h23 * 100) / h28_ten) / h30_ten;
+		mod_radio_reg(pi, RADIO_2064_REG03C, 0x3f, cp_current);
+	}
+	if (channel >= 1 && channel <= 5)
+		write_radio_reg(pi, RADIO_2064_REG03C, 0x8);
+	else
+		write_radio_reg(pi, RADIO_2064_REG03C, 0x7);
+	write_radio_reg(pi, RADIO_2064_REG03D, 0x3);
+
+	mod_radio_reg(pi, RADIO_2064_REG044, 0x0c, 0x0c);
+	OSL_DELAY(1);
+
+	wlc_2064_vco_cal(pi);
+
+	write_radio_reg(pi, RADIO_2064_REG044, pll_pwrup);
+	write_radio_reg(pi, RADIO_2064_REG12B, pll_pwrup_ovr);
+	if (LCNREV_IS(pi->pubpi.phy_rev, 1)) {
+		write_radio_reg(pi, RADIO_2064_REG038, 3);
+		write_radio_reg(pi, RADIO_2064_REG091, 7);
+	}
+}
+
+bool wlc_phy_tpc_isenabled_lcnphy(phy_info_t * pi)
+{
+	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi))
+		return 0;
+	else
+		return (LCNPHY_TX_PWR_CTRL_HW ==
+			wlc_lcnphy_get_tx_pwr_ctrl((pi)));
+}
+
+void wlc_phy_txpower_recalc_target_lcnphy(phy_info_t * pi)
+{
+	uint16 pwr_ctrl;
+	if (wlc_lcnphy_tempsense_based_pwr_ctrl_enabled(pi)) {
+		wlc_lcnphy_calib_modes(pi, LCNPHY_PERICAL_TEMPBASED_TXPWRCTRL);
+	} else if (wlc_lcnphy_tssi_based_pwr_ctrl_enabled(pi)) {
+
+		pwr_ctrl = wlc_lcnphy_get_tx_pwr_ctrl(pi);
+		wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_OFF);
+		wlc_lcnphy_txpower_recalc_target(pi);
+
+		wlc_lcnphy_set_tx_pwr_ctrl(pi, pwr_ctrl);
+	} else
+		return;
+}
+
+void wlc_phy_detach_lcnphy(phy_info_t * pi)
+{
+	MFREE(pi->sh->osh, pi->u.pi_lcnphy, sizeof(phy_info_lcnphy_t));
+}
+
+bool wlc_phy_attach_lcnphy(phy_info_t * pi)
+{
+	phy_info_lcnphy_t *pi_lcn;
+
+	pi->u.pi_lcnphy =
+	    (phy_info_lcnphy_t *) MALLOC(pi->sh->osh,
+					 sizeof(phy_info_lcnphy_t));
+	if (pi->u.pi_lcnphy == NULL) {
+		return FALSE;
+	}
+	bzero((char *)pi->u.pi_lcnphy, sizeof(phy_info_lcnphy_t));
+
+	pi_lcn = pi->u.pi_lcnphy;
+
+	if ((0 == (pi->sh->boardflags & BFL_NOPA)) && !NORADIO_ENAB(pi->pubpi)) {
+		pi->hwpwrctrl = TRUE;
+		pi->hwpwrctrl_capable = TRUE;
+	}
+
+	pi->xtalfreq = si_alp_clock(pi->sh->sih);
+	ASSERT(0 == (pi->xtalfreq % 1000));
+
+	pi_lcn->lcnphy_papd_rxGnCtrl_init = 0;
+
+	pi->pi_fptr.init = wlc_phy_init_lcnphy;
+	pi->pi_fptr.calinit = wlc_phy_cal_init_lcnphy;
+	pi->pi_fptr.chanset = wlc_phy_chanspec_set_lcnphy;
+	pi->pi_fptr.txpwrrecalc = wlc_phy_txpower_recalc_target_lcnphy;
+	pi->pi_fptr.txiqccget = wlc_lcnphy_get_tx_iqcc;
+	pi->pi_fptr.txiqccset = wlc_lcnphy_set_tx_iqcc;
+	pi->pi_fptr.txloccget = wlc_lcnphy_get_tx_locc;
+	pi->pi_fptr.radioloftget = wlc_lcnphy_get_radio_loft;
+	pi->pi_fptr.detach = wlc_phy_detach_lcnphy;
+
+	if (!wlc_phy_txpwr_srom_read_lcnphy(pi))
+		return FALSE;
+
+	if ((pi->sh->boardflags & BFL_FEM) && (LCNREV_IS(pi->pubpi.phy_rev, 1))) {
+		if (pi_lcn->lcnphy_tempsense_option == 3) {
+			pi->hwpwrctrl = TRUE;
+			pi->hwpwrctrl_capable = TRUE;
+			pi->temppwrctrl_capable = FALSE;
+		} else {
+			pi->hwpwrctrl = FALSE;
+			pi->hwpwrctrl_capable = FALSE;
+			pi->temppwrctrl_capable = TRUE;
+		}
+	}
+
+	return TRUE;
+}
+
+static void wlc_lcnphy_set_rx_gain(phy_info_t * pi, uint32 gain)
+{
+	uint16 trsw, ext_lna, lna1, lna2, tia, biq0, biq1, gain0_15, gain16_19;
+
+	trsw = (gain & ((uint32) 1 << 28)) ? 0 : 1;
+	ext_lna = (uint16) (gain >> 29) & 0x01;
+	lna1 = (uint16) (gain >> 0) & 0x0f;
+	lna2 = (uint16) (gain >> 4) & 0x0f;
+	tia = (uint16) (gain >> 8) & 0xf;
+	biq0 = (uint16) (gain >> 12) & 0xf;
+	biq1 = (uint16) (gain >> 16) & 0xf;
+
+	gain0_15 = (uint16) ((lna1 & 0x3) | ((lna1 & 0x3) << 2) |
+			     ((lna2 & 0x3) << 4) | ((lna2 & 0x3) << 6) |
+			     ((tia & 0xf) << 8) | ((biq0 & 0xf) << 12));
+	gain16_19 = biq1;
+
+	mod_phy_reg(pi, 0x44d, (0x1 << 0), trsw << 0);
+	mod_phy_reg(pi, 0x4b1, (0x1 << 9), ext_lna << 9);
+	mod_phy_reg(pi, 0x4b1, (0x1 << 10), ext_lna << 10);
+	mod_phy_reg(pi, 0x4b6, (0xffff << 0), gain0_15 << 0);
+	mod_phy_reg(pi, 0x4b7, (0xf << 0), gain16_19 << 0);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		mod_phy_reg(pi, 0x4b1, (0x3 << 11), lna1 << 11);
+		mod_phy_reg(pi, 0x4e6, (0x3 << 3), lna1 << 3);
+	}
+	wlc_lcnphy_rx_gain_override_enable(pi, TRUE);
+}
+
+static uint32 wlc_lcnphy_get_receive_power(phy_info_t * pi, int32 * gain_index)
+{
+	uint32 received_power = 0;
+	int32 max_index = 0;
+	uint32 gain_code = 0;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	max_index = 36;
+	if (*gain_index >= 0)
+		gain_code = lcnphy_23bitgaincode_table[*gain_index];
+
+	if (-1 == *gain_index) {
+		*gain_index = 0;
+		while ((*gain_index <= (int32) max_index)
+		       && (received_power < 700)) {
+			wlc_lcnphy_set_rx_gain(pi,
+					       lcnphy_23bitgaincode_table
+					       [*gain_index]);
+			received_power =
+			    wlc_lcnphy_measure_digital_power(pi,
+							     pi_lcn->
+							     lcnphy_noise_samples);
+			(*gain_index)++;
+		}
+		(*gain_index)--;
+	} else {
+		wlc_lcnphy_set_rx_gain(pi, gain_code);
+		received_power =
+		    wlc_lcnphy_measure_digital_power(pi,
+						     pi_lcn->
+						     lcnphy_noise_samples);
+	}
+
+	return received_power;
+}
+
+int32 wlc_lcnphy_rx_signal_power(phy_info_t * pi, int32 gain_index)
+{
+	int32 gain = 0;
+	int32 nominal_power_db;
+	int32 log_val, gain_mismatch, desired_gain, input_power_offset_db,
+	    input_power_db;
+	int32 received_power, temperature;
+	uint freq;
+	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
+
+	received_power = wlc_lcnphy_get_receive_power(pi, &gain_index);
+
+	gain = lcnphy_gain_table[gain_index];
+
+	nominal_power_db = read_phy_reg(pi, 0x425) >> 8;
+
+	{
+		uint32 power = (received_power * 16);
+		uint32 msb1, msb2, val1, val2, diff1, diff2;
+		msb1 = find_msbit(power);
+		msb2 = msb1 + 1;
+		val1 = 1 << msb1;
+		val2 = 1 << msb2;
+		diff1 = (power - val1);
+		diff2 = (val2 - power);
+		if (diff1 < diff2)
+			log_val = msb1;
+		else
+			log_val = msb2;
+	}
+
+	log_val = log_val * 3;
+
+	gain_mismatch = (nominal_power_db / 2) - (log_val);
+
+	desired_gain = gain + gain_mismatch;
+
+	input_power_offset_db = read_phy_reg(pi, 0x434) & 0xFF;
+
+	if (input_power_offset_db > 127)
+		input_power_offset_db -= 256;
+
+	input_power_db = input_power_offset_db - desired_gain;
+
+	input_power_db =
+	    input_power_db + lcnphy_gain_index_offset_for_rssi[gain_index];
+
+	freq = wlc_phy_channel2freq(CHSPEC_CHANNEL(pi->radio_chanspec));
+	if ((freq > 2427) && (freq <= 2467))
+		input_power_db = input_power_db - 1;
+
+	temperature = pi_lcn->lcnphy_lastsensed_temperature;
+
+	if ((temperature - 15) < -30) {
+		input_power_db =
+		    input_power_db + (((temperature - 10 - 25) * 286) >> 12) -
+		    7;
+	} else if ((temperature - 15) < 4) {
+		input_power_db =
+		    input_power_db + (((temperature - 10 - 25) * 286) >> 12) -
+		    3;
+	} else {
+		input_power_db =
+		    input_power_db + (((temperature - 10 - 25) * 286) >> 12);
+	}
+
+	wlc_lcnphy_rx_gain_override_enable(pi, 0);
+
+	return input_power_db;
+}
+
+static int
+wlc_lcnphy_load_tx_iir_filter(phy_info_t * pi, bool is_ofdm, int16 filt_type)
+{
+	int16 filt_index = -1;
+	int j;
+
+	uint16 addr[] = {
+		0x910,
+		0x91e,
+		0x91f,
+		0x924,
+		0x925,
+		0x926,
+		0x920,
+		0x921,
+		0x927,
+		0x928,
+		0x929,
+		0x922,
+		0x923,
+		0x930,
+		0x931,
+		0x932
+	};
+
+	uint16 addr_ofdm[] = {
+		0x90f,
+		0x900,
+		0x901,
+		0x906,
+		0x907,
+		0x908,
+		0x902,
+		0x903,
+		0x909,
+		0x90a,
+		0x90b,
+		0x904,
+		0x905,
+		0x90c,
+		0x90d,
+		0x90e
+	};
+
+	if (!is_ofdm) {
+		for (j = 0; j < LCNPHY_NUM_TX_DIG_FILTERS_CCK; j++) {
+			if (filt_type == LCNPHY_txdigfiltcoeffs_cck[j][0]) {
+				filt_index = (int16) j;
+				break;
+			}
+		}
+
+		if (filt_index == -1) {
+			ASSERT(FALSE);
+		} else {
+			for (j = 0; j < LCNPHY_NUM_DIG_FILT_COEFFS; j++) {
+				write_phy_reg(pi, addr[j],
+					      LCNPHY_txdigfiltcoeffs_cck
+					      [filt_index][j + 1]);
+			}
+		}
+	} else {
+		for (j = 0; j < LCNPHY_NUM_TX_DIG_FILTERS_OFDM; j++) {
+			if (filt_type == LCNPHY_txdigfiltcoeffs_ofdm[j][0]) {
+				filt_index = (int16) j;
+				break;
+			}
+		}
+
+		if (filt_index == -1) {
+			ASSERT(FALSE);
+		} else {
+			for (j = 0; j < LCNPHY_NUM_DIG_FILT_COEFFS; j++) {
+				write_phy_reg(pi, addr_ofdm[j],
+					      LCNPHY_txdigfiltcoeffs_ofdm
+					      [filt_index][j + 1]);
+			}
+		}
+	}
+
+	return (filt_index != -1) ? 0 : -1;
+}
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_lcn.h b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
new file mode 100644
index 0000000..e278a2c
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phy_lcn.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_phy_lcn_h_
+#define _wlc_phy_lcn_h_
+
+#include <typedefs.h>
+
+struct phy_info_lcnphy {
+	int lcnphy_txrf_sp_9_override;
+	uint8 lcnphy_full_cal_channel;
+	uint8 lcnphy_cal_counter;
+	uint16 lcnphy_cal_temper;
+	bool lcnphy_recal;
+
+	uint8 lcnphy_rc_cap;
+	uint32 lcnphy_mcs20_po;
+
+	uint8 lcnphy_tr_isolation_mid;
+	uint8 lcnphy_tr_isolation_low;
+	uint8 lcnphy_tr_isolation_hi;
+
+	uint8 lcnphy_bx_arch;
+	uint8 lcnphy_rx_power_offset;
+	uint8 lcnphy_rssi_vf;
+	uint8 lcnphy_rssi_vc;
+	uint8 lcnphy_rssi_gs;
+	uint8 lcnphy_tssi_val;
+	uint8 lcnphy_rssi_vf_lowtemp;
+	uint8 lcnphy_rssi_vc_lowtemp;
+	uint8 lcnphy_rssi_gs_lowtemp;
+
+	uint8 lcnphy_rssi_vf_hightemp;
+	uint8 lcnphy_rssi_vc_hightemp;
+	uint8 lcnphy_rssi_gs_hightemp;
+
+	int16 lcnphy_pa0b0;
+	int16 lcnphy_pa0b1;
+	int16 lcnphy_pa0b2;
+
+	uint16 lcnphy_rawtempsense;
+	uint8 lcnphy_measPower;
+	uint8 lcnphy_tempsense_slope;
+	uint8 lcnphy_freqoffset_corr;
+	uint8 lcnphy_tempsense_option;
+	uint8 lcnphy_tempcorrx;
+	bool lcnphy_iqcal_swp_dis;
+	bool lcnphy_hw_iqcal_en;
+	uint lcnphy_bandedge_corr;
+	bool lcnphy_spurmod;
+	uint16 lcnphy_tssi_tx_cnt;
+	uint16 lcnphy_tssi_idx;
+	uint16 lcnphy_tssi_npt;
+
+	uint16 lcnphy_target_tx_freq;
+	int8 lcnphy_tx_power_idx_override;
+	uint16 lcnphy_noise_samples;
+
+	uint32 lcnphy_papdRxGnIdx;
+	uint32 lcnphy_papd_rxGnCtrl_init;
+
+	uint32 lcnphy_gain_idx_14_lowword;
+	uint32 lcnphy_gain_idx_14_hiword;
+	uint32 lcnphy_gain_idx_27_lowword;
+	uint32 lcnphy_gain_idx_27_hiword;
+	int16 lcnphy_ofdmgainidxtableoffset;
+	int16 lcnphy_dsssgainidxtableoffset;
+	uint32 lcnphy_tr_R_gain_val;
+	uint32 lcnphy_tr_T_gain_val;
+	int8 lcnphy_input_pwr_offset_db;
+	uint16 lcnphy_Med_Low_Gain_db;
+	uint16 lcnphy_Very_Low_Gain_db;
+	int8 lcnphy_lastsensed_temperature;
+	int8 lcnphy_pkteng_rssi_slope;
+	uint8 lcnphy_saved_tx_user_target[TXP_NUM_RATES];
+	uint8 lcnphy_volt_winner;
+	uint8 lcnphy_volt_low;
+	uint8 lcnphy_54_48_36_24mbps_backoff;
+	uint8 lcnphy_11n_backoff;
+	uint8 lcnphy_lowerofdm;
+	uint8 lcnphy_cck;
+	uint8 lcnphy_psat_2pt3_detected;
+	int32 lcnphy_lowest_Re_div_Im;
+	int8 lcnphy_final_papd_cal_idx;
+	uint16 lcnphy_extstxctrl4;
+	uint16 lcnphy_extstxctrl0;
+	uint16 lcnphy_extstxctrl1;
+	int16 lcnphy_cck_dig_filt_type;
+	int16 lcnphy_ofdm_dig_filt_type;
+	lcnphy_cal_results_t lcnphy_cal_results;
+
+	uint8 lcnphy_psat_pwr;
+	uint8 lcnphy_psat_indx;
+	int32 lcnphy_min_phase;
+	uint8 lcnphy_final_idx;
+	uint8 lcnphy_start_idx;
+	uint8 lcnphy_current_index;
+	uint16 lcnphy_logen_buf_1;
+	uint16 lcnphy_local_ovr_2;
+	uint16 lcnphy_local_oval_6;
+	uint16 lcnphy_local_oval_5;
+	uint16 lcnphy_logen_mixer_1;
+
+	uint8 lcnphy_aci_stat;
+	uint lcnphy_aci_start_time;
+	int8 lcnphy_tx_power_offset[TXP_NUM_RATES];
+};
+#endif				/* _wlc_phy_lcn_h_ */
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_n.c b/drivers/staging/brcm80211/phy/wlc_phy_n.c
new file mode 100644
index 0000000..950dfc6
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phy_n.c
@@ -0,0 +1,29230 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <osl.h>
+#include <siutils.h>
+#include <sbchipc.h>
+#include <bitfuncs.h>
+#include <hndpmu.h>
+#include <bcmendian.h>
+
+#include <wlc_phy_radio.h>
+#include <wlc_phy_int.h>
+#include <wlc_phyreg_n.h>
+#include <wlc_phytbl_n.h>
+
+#define	READ_RADIO_REG2(pi, radio_type, jspace, core, reg_name) \
+	read_radio_reg(pi, radio_type##_##jspace##_##reg_name | \
+	((core == PHY_CORE_0) ? radio_type##_##jspace##0 : radio_type##_##jspace##1))
+#define	WRITE_RADIO_REG2(pi, radio_type, jspace, core, reg_name, value) \
+	write_radio_reg(pi, radio_type##_##jspace##_##reg_name | \
+	((core == PHY_CORE_0) ? radio_type##_##jspace##0 : radio_type##_##jspace##1), value);
+#define	WRITE_RADIO_SYN(pi, radio_type, reg_name, value) \
+	write_radio_reg(pi, radio_type##_##SYN##_##reg_name, value);
+
+#define	READ_RADIO_REG3(pi, radio_type, jspace, core, reg_name) \
+	read_radio_reg(pi, ((core == PHY_CORE_0) ? radio_type##_##jspace##0##_##reg_name : \
+	radio_type##_##jspace##1##_##reg_name));
+#define	WRITE_RADIO_REG3(pi, radio_type, jspace, core, reg_name, value) \
+	write_radio_reg(pi, ((core == PHY_CORE_0) ? radio_type##_##jspace##0##_##reg_name : \
+	radio_type##_##jspace##1##_##reg_name), value);
+#define	READ_RADIO_REG4(pi, radio_type, jspace, core, reg_name) \
+	read_radio_reg(pi, ((core == PHY_CORE_0) ? radio_type##_##reg_name##_##jspace##0 : \
+	radio_type##_##reg_name##_##jspace##1));
+#define	WRITE_RADIO_REG4(pi, radio_type, jspace, core, reg_name, value) \
+	write_radio_reg(pi, ((core == PHY_CORE_0) ? radio_type##_##reg_name##_##jspace##0 : \
+	radio_type##_##reg_name##_##jspace##1), value);
+
+#define NPHY_ACI_MAX_UNDETECT_WINDOW_SZ 40
+#define NPHY_ACI_CHANNEL_DELTA 5
+#define NPHY_ACI_CHANNEL_SKIP 4
+#define NPHY_ACI_40MHZ_CHANNEL_DELTA 6
+#define NPHY_ACI_40MHZ_CHANNEL_SKIP 5
+#define NPHY_ACI_40MHZ_CHANNEL_DELTA_GE_REV3 6
+#define NPHY_ACI_40MHZ_CHANNEL_SKIP_GE_REV3 5
+#define NPHY_ACI_CHANNEL_DELTA_GE_REV3 4
+#define NPHY_ACI_CHANNEL_SKIP_GE_REV3 3
+
+#define NPHY_NOISE_NOASSOC_GLITCH_TH_UP 2
+
+#define NPHY_NOISE_NOASSOC_GLITCH_TH_DN 8
+
+#define NPHY_NOISE_ASSOC_GLITCH_TH_UP 2
+
+#define NPHY_NOISE_ASSOC_GLITCH_TH_DN 8
+
+#define NPHY_NOISE_ASSOC_ACI_GLITCH_TH_UP 2
+
+#define NPHY_NOISE_ASSOC_ACI_GLITCH_TH_DN 8
+
+#define NPHY_NOISE_NOASSOC_ENTER_TH  400
+
+#define NPHY_NOISE_ASSOC_ENTER_TH  400
+
+#define NPHY_NOISE_ASSOC_RX_GLITCH_BADPLCP_ENTER_TH  400
+
+#define NPHY_NOISE_CRSMINPWR_ARRAY_MAX_INDEX 44
+#define NPHY_NOISE_CRSMINPWR_ARRAY_MAX_INDEX_REV_7 56
+
+#define NPHY_NOISE_NOASSOC_CRSIDX_INCR 16
+
+#define NPHY_NOISE_ASSOC_CRSIDX_INCR 8
+
+#define NPHY_IS_SROM_REINTERPRET NREV_GE(pi->pubpi.phy_rev, 5)
+
+#define NPHY_RSSICAL_MAXREAD 31
+
+#define NPHY_RSSICAL_NPOLL 8
+#define NPHY_RSSICAL_MAXD  (1<<20)
+#define NPHY_MIN_RXIQ_PWR 2
+
+#define NPHY_RSSICAL_W1_TARGET 25
+#define NPHY_RSSICAL_W2_TARGET NPHY_RSSICAL_W1_TARGET
+#define NPHY_RSSICAL_NB_TARGET 0
+
+#define NPHY_RSSICAL_W1_TARGET_REV3 29
+#define NPHY_RSSICAL_W2_TARGET_REV3 NPHY_RSSICAL_W1_TARGET_REV3
+
+#define NPHY_CALSANITY_RSSI_NB_MAX_POS  9
+#define NPHY_CALSANITY_RSSI_NB_MAX_NEG -9
+#define NPHY_CALSANITY_RSSI_W1_MAX_POS  12
+#define NPHY_CALSANITY_RSSI_W1_MAX_NEG (NPHY_RSSICAL_W1_TARGET - NPHY_RSSICAL_MAXREAD)
+#define NPHY_CALSANITY_RSSI_W2_MAX_POS  NPHY_CALSANITY_RSSI_W1_MAX_POS
+#define NPHY_CALSANITY_RSSI_W2_MAX_NEG (NPHY_RSSICAL_W2_TARGET - NPHY_RSSICAL_MAXREAD)
+#define NPHY_RSSI_SXT(x) ((int8) (-((x) & 0x20) + ((x) & 0x1f)))
+#define NPHY_RSSI_NB_VIOL(x)  (((x) > NPHY_CALSANITY_RSSI_NB_MAX_POS) || \
+			       ((x) < NPHY_CALSANITY_RSSI_NB_MAX_NEG))
+#define NPHY_RSSI_W1_VIOL(x)  (((x) > NPHY_CALSANITY_RSSI_W1_MAX_POS) || \
+			       ((x) < NPHY_CALSANITY_RSSI_W1_MAX_NEG))
+#define NPHY_RSSI_W2_VIOL(x)  (((x) > NPHY_CALSANITY_RSSI_W2_MAX_POS) || \
+			       ((x) < NPHY_CALSANITY_RSSI_W2_MAX_NEG))
+
+#define NPHY_IQCAL_NUMGAINS 9
+#define NPHY_N_GCTL 0x66
+
+#define NPHY_PAPD_EPS_TBL_SIZE 64
+#define NPHY_PAPD_SCL_TBL_SIZE 64
+#define NPHY_NUM_DIG_FILT_COEFFS 15
+
+#define NPHY_PAPD_COMP_OFF 0
+#define NPHY_PAPD_COMP_ON  1
+
+#define NPHY_SROM_TEMPSHIFT		32
+#define NPHY_SROM_MAXTEMPOFFSET		16
+#define NPHY_SROM_MINTEMPOFFSET		-16
+
+#define NPHY_CAL_MAXTEMPDELTA		64
+
+#define NPHY_NOISEVAR_TBLLEN40 256
+#define NPHY_NOISEVAR_TBLLEN20 128
+
+#define NPHY_ANARXLPFBW_REDUCTIONFACT 7
+
+#define NPHY_ADJUSTED_MINCRSPOWER 0x1e
+
+typedef struct _nphy_iqcal_params {
+	uint16 txlpf;
+	uint16 txgm;
+	uint16 pga;
+	uint16 pad;
+	uint16 ipa;
+	uint16 cal_gain;
+	uint16 ncorr[5];
+} nphy_iqcal_params_t;
+
+typedef struct _nphy_txiqcal_ladder {
+	uint8 percent;
+	uint8 g_env;
+} nphy_txiqcal_ladder_t;
+
+typedef struct {
+	nphy_txgains_t gains;
+	bool useindex;
+	uint8 index;
+} nphy_ipa_txcalgains_t;
+
+typedef struct nphy_papd_restore_state_t {
+	uint16 fbmix[2];
+	uint16 vga_master[2];
+	uint16 intpa_master[2];
+	uint16 afectrl[2];
+	uint16 afeoverride[2];
+	uint16 pwrup[2];
+	uint16 atten[2];
+	uint16 mm;
+} nphy_papd_restore_state;
+
+typedef struct _nphy_ipa_txrxgain {
+	uint16 hpvga;
+	uint16 lpf_biq1;
+	uint16 lpf_biq0;
+	uint16 lna2;
+	uint16 lna1;
+	int8 txpwrindex;
+} nphy_ipa_txrxgain_t;
+
+#define NPHY_IPA_RXCAL_MAXGAININDEX (6 - 1)
+
+nphy_ipa_txrxgain_t nphy_ipa_rxcal_gaintbl_5GHz[] = { {0, 0, 0, 0, 0, 100},
+{0, 0, 0, 0, 0, 50},
+{0, 0, 0, 0, 0, -1},
+{0, 0, 0, 3, 0, -1},
+{0, 0, 3, 3, 0, -1},
+{0, 2, 3, 3, 0, -1}
+};
+
+nphy_ipa_txrxgain_t nphy_ipa_rxcal_gaintbl_2GHz[] = { {0, 0, 0, 0, 0, 128},
+{0, 0, 0, 0, 0, 70},
+{0, 0, 0, 0, 0, 20},
+{0, 0, 0, 3, 0, 20},
+{0, 0, 3, 3, 0, 20},
+{0, 2, 3, 3, 0, 20}
+};
+
+nphy_ipa_txrxgain_t nphy_ipa_rxcal_gaintbl_5GHz_rev7[] = { {0, 0, 0, 0, 0, 100},
+{0, 0, 0, 0, 0, 50},
+{0, 0, 0, 0, 0, -1},
+{0, 0, 0, 3, 0, -1},
+{0, 0, 3, 3, 0, -1},
+{0, 0, 5, 3, 0, -1}
+};
+
+nphy_ipa_txrxgain_t nphy_ipa_rxcal_gaintbl_2GHz_rev7[] = { {0, 0, 0, 0, 0, 10},
+{0, 0, 0, 1, 0, 10},
+{0, 0, 1, 2, 0, 10},
+{0, 0, 1, 3, 0, 10},
+{0, 0, 4, 3, 0, 10},
+{0, 0, 6, 3, 0, 10}
+};
+
+#define NPHY_RXCAL_TONEAMP 181
+#define NPHY_RXCAL_TONEFREQ_40MHz 4000
+#define NPHY_RXCAL_TONEFREQ_20MHz 2000
+
+enum {
+	NPHY_RXCAL_GAIN_INIT = 0,
+	NPHY_RXCAL_GAIN_UP,
+	NPHY_RXCAL_GAIN_DOWN
+};
+
+#define wlc_phy_get_papd_nphy(pi) \
+	(read_phy_reg((pi), 0x1e7) & \
+			((0x1 << 15) | \
+			(0x1 << 14) | \
+			(0x1 << 13)))
+
+#define TXFILT_SHAPING_OFDM20   0
+#define TXFILT_SHAPING_OFDM40   1
+#define TXFILT_SHAPING_CCK      2
+#define TXFILT_DEFAULT_OFDM20   3
+#define TXFILT_DEFAULT_OFDM40   4
+
+uint16 NPHY_IPA_REV4_txdigi_filtcoeffs[][NPHY_NUM_DIG_FILT_COEFFS] = {
+	{-377, 137, -407, 208, -1527, 956, 93, 186, 93,
+	 230, -44, 230, 201, -191, 201},
+	{-77, 20, -98, 49, -93, 60, 56, 111, 56, 26, -5,
+	 26, 34, -32, 34},
+	{-360, 164, -376, 164, -1533, 576, 308, -314, 308,
+	 121, -73, 121, 91, 124, 91},
+	{-295, 200, -363, 142, -1391, 826, 151, 301, 151,
+	 151, 301, 151, 602, -752, 602},
+	{-92, 58, -96, 49, -104, 44, 17, 35, 17,
+	 12, 25, 12, 13, 27, 13},
+	{-375, 136, -399, 209, -1479, 949, 130, 260, 130,
+	 230, -44, 230, 201, -191, 201},
+	{0xed9, 0xc8, 0xe95, 0x8e, 0xa91, 0x33a, 0x97, 0x12d, 0x97,
+	 0x97, 0x12d, 0x97, 0x25a, 0xd10, 0x25a}
+};
+
+typedef struct _chan_info_nphy_2055 {
+	uint16 chan;
+	uint16 freq;
+	uint unknown;
+	uint8 RF_pll_ref;
+	uint8 RF_rf_pll_mod1;
+	uint8 RF_rf_pll_mod0;
+	uint8 RF_vco_cap_tail;
+	uint8 RF_vco_cal1;
+	uint8 RF_vco_cal2;
+	uint8 RF_pll_lf_c1;
+	uint8 RF_pll_lf_r1;
+	uint8 RF_pll_lf_c2;
+	uint8 RF_lgbuf_cen_buf;
+	uint8 RF_lgen_tune1;
+	uint8 RF_lgen_tune2;
+	uint8 RF_core1_lgbuf_a_tune;
+	uint8 RF_core1_lgbuf_g_tune;
+	uint8 RF_core1_rxrf_reg1;
+	uint8 RF_core1_tx_pga_pad_tn;
+	uint8 RF_core1_tx_mx_bgtrim;
+	uint8 RF_core2_lgbuf_a_tune;
+	uint8 RF_core2_lgbuf_g_tune;
+	uint8 RF_core2_rxrf_reg1;
+	uint8 RF_core2_tx_pga_pad_tn;
+	uint8 RF_core2_tx_mx_bgtrim;
+	uint16 PHY_BW1a;
+	uint16 PHY_BW2;
+	uint16 PHY_BW3;
+	uint16 PHY_BW4;
+	uint16 PHY_BW5;
+	uint16 PHY_BW6;
+} chan_info_nphy_2055_t;
+
+typedef struct _chan_info_nphy_radio205x {
+	uint16 chan;
+	uint16 freq;
+	uint8 RF_SYN_pll_vcocal1;
+	uint8 RF_SYN_pll_vcocal2;
+	uint8 RF_SYN_pll_refdiv;
+	uint8 RF_SYN_pll_mmd2;
+	uint8 RF_SYN_pll_mmd1;
+	uint8 RF_SYN_pll_loopfilter1;
+	uint8 RF_SYN_pll_loopfilter2;
+	uint8 RF_SYN_pll_loopfilter3;
+	uint8 RF_SYN_pll_loopfilter4;
+	uint8 RF_SYN_pll_loopfilter5;
+	uint8 RF_SYN_reserved_addr27;
+	uint8 RF_SYN_reserved_addr28;
+	uint8 RF_SYN_reserved_addr29;
+	uint8 RF_SYN_logen_VCOBUF1;
+	uint8 RF_SYN_logen_MIXER2;
+	uint8 RF_SYN_logen_BUF3;
+	uint8 RF_SYN_logen_BUF4;
+	uint8 RF_RX0_lnaa_tune;
+	uint8 RF_RX0_lnag_tune;
+	uint8 RF_TX0_intpaa_boost_tune;
+	uint8 RF_TX0_intpag_boost_tune;
+	uint8 RF_TX0_pada_boost_tune;
+	uint8 RF_TX0_padg_boost_tune;
+	uint8 RF_TX0_pgaa_boost_tune;
+	uint8 RF_TX0_pgag_boost_tune;
+	uint8 RF_TX0_mixa_boost_tune;
+	uint8 RF_TX0_mixg_boost_tune;
+	uint8 RF_RX1_lnaa_tune;
+	uint8 RF_RX1_lnag_tune;
+	uint8 RF_TX1_intpaa_boost_tune;
+	uint8 RF_TX1_intpag_boost_tune;
+	uint8 RF_TX1_pada_boost_tune;
+	uint8 RF_TX1_padg_boost_tune;
+	uint8 RF_TX1_pgaa_boost_tune;
+	uint8 RF_TX1_pgag_boost_tune;
+	uint8 RF_TX1_mixa_boost_tune;
+	uint8 RF_TX1_mixg_boost_tune;
+	uint16 PHY_BW1a;
+	uint16 PHY_BW2;
+	uint16 PHY_BW3;
+	uint16 PHY_BW4;
+	uint16 PHY_BW5;
+	uint16 PHY_BW6;
+} chan_info_nphy_radio205x_t;
+
+typedef struct _chan_info_nphy_radio2057 {
+	uint16 chan;
+	uint16 freq;
+	uint8 RF_vcocal_countval0;
+	uint8 RF_vcocal_countval1;
+	uint8 RF_rfpll_refmaster_sparextalsize;
+	uint8 RF_rfpll_loopfilter_r1;
+	uint8 RF_rfpll_loopfilter_c2;
+	uint8 RF_rfpll_loopfilter_c1;
+	uint8 RF_cp_kpd_idac;
+	uint8 RF_rfpll_mmd0;
+	uint8 RF_rfpll_mmd1;
+	uint8 RF_vcobuf_tune;
+	uint8 RF_logen_mx2g_tune;
+	uint8 RF_logen_mx5g_tune;
+	uint8 RF_logen_indbuf2g_tune;
+	uint8 RF_logen_indbuf5g_tune;
+	uint8 RF_txmix2g_tune_boost_pu_core0;
+	uint8 RF_pad2g_tune_pus_core0;
+	uint8 RF_pga_boost_tune_core0;
+	uint8 RF_txmix5g_boost_tune_core0;
+	uint8 RF_pad5g_tune_misc_pus_core0;
+	uint8 RF_lna2g_tune_core0;
+	uint8 RF_lna5g_tune_core0;
+	uint8 RF_txmix2g_tune_boost_pu_core1;
+	uint8 RF_pad2g_tune_pus_core1;
+	uint8 RF_pga_boost_tune_core1;
+	uint8 RF_txmix5g_boost_tune_core1;
+	uint8 RF_pad5g_tune_misc_pus_core1;
+	uint8 RF_lna2g_tune_core1;
+	uint8 RF_lna5g_tune_core1;
+	uint16 PHY_BW1a;
+	uint16 PHY_BW2;
+	uint16 PHY_BW3;
+	uint16 PHY_BW4;
+	uint16 PHY_BW5;
+	uint16 PHY_BW6;
+} chan_info_nphy_radio2057_t;
+
+typedef struct _chan_info_nphy_radio2057_rev5 {
+	uint16 chan;
+	uint16 freq;
+	uint8 RF_vcocal_countval0;
+	uint8 RF_vcocal_countval1;
+	uint8 RF_rfpll_refmaster_sparextalsize;
+	uint8 RF_rfpll_loopfilter_r1;
+	uint8 RF_rfpll_loopfilter_c2;
+	uint8 RF_rfpll_loopfilter_c1;
+	uint8 RF_cp_kpd_idac;
+	uint8 RF_rfpll_mmd0;
+	uint8 RF_rfpll_mmd1;
+	uint8 RF_vcobuf_tune;
+	uint8 RF_logen_mx2g_tune;
+	uint8 RF_logen_indbuf2g_tune;
+	uint8 RF_txmix2g_tune_boost_pu_core0;
+	uint8 RF_pad2g_tune_pus_core0;
+	uint8 RF_lna2g_tune_core0;
+	uint8 RF_txmix2g_tune_boost_pu_core1;
+	uint8 RF_pad2g_tune_pus_core1;
+	uint8 RF_lna2g_tune_core1;
+	uint16 PHY_BW1a;
+	uint16 PHY_BW2;
+	uint16 PHY_BW3;
+	uint16 PHY_BW4;
+	uint16 PHY_BW5;
+	uint16 PHY_BW6;
+} chan_info_nphy_radio2057_rev5_t;
+
+typedef struct nphy_sfo_cfg {
+	uint16 PHY_BW1a;
+	uint16 PHY_BW2;
+	uint16 PHY_BW3;
+	uint16 PHY_BW4;
+	uint16 PHY_BW5;
+	uint16 PHY_BW6;
+} nphy_sfo_cfg_t;
+
+static chan_info_nphy_2055_t chan_info_nphy_2055[] = {
+	{
+	 184, 4920, 3280, 0x71, 0x01, 0xEC, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7B4, 0x7B0, 0x7AC, 0x214, 0x215, 0x216},
+	{
+	 186, 4930, 3287, 0x71, 0x01, 0xED, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7B8, 0x7B4, 0x7B0, 0x213, 0x214, 0x215},
+	{
+	 188, 4940, 3293, 0x71, 0x01, 0xEE, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7BC, 0x7B8, 0x7B4, 0x212, 0x213, 0x214},
+	{
+	 190, 4950, 3300, 0x71, 0x01, 0xEF, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7C0, 0x7BC, 0x7B8, 0x211, 0x212, 0x213},
+	{
+	 192, 4960, 3307, 0x71, 0x01, 0xF0, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7C4, 0x7C0, 0x7BC, 0x20F, 0x211, 0x212},
+	{
+	 194, 4970, 3313, 0x71, 0x01, 0xF1, 0x0F, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xEE, 0xEE, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7C8, 0x7C4, 0x7C0, 0x20E, 0x20F, 0x211},
+	{
+	 196, 4980, 3320, 0x71, 0x01, 0xF2, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7CC, 0x7C8, 0x7C4, 0x20D, 0x20E, 0x20F},
+	{
+	 198, 4990, 3327, 0x71, 0x01, 0xF3, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7D0, 0x7CC, 0x7C8, 0x20C, 0x20D, 0x20E},
+	{
+	 200, 5000, 3333, 0x71, 0x01, 0xF4, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7D4, 0x7D0, 0x7CC, 0x20B, 0x20C, 0x20D},
+	{
+	 202, 5010, 3340, 0x71, 0x01, 0xF5, 0x0E, 0xFF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xDD, 0xDD, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7D8, 0x7D4, 0x7D0, 0x20A, 0x20B, 0x20C},
+	{
+	 204, 5020, 3347, 0x71, 0x01, 0xF6, 0x0E, 0xF7, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7DC, 0x7D8, 0x7D4, 0x209, 0x20A, 0x20B},
+	{
+	 206, 5030, 3353, 0x71, 0x01, 0xF7, 0x0E, 0xF7, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7E0, 0x7DC, 0x7D8, 0x208, 0x209, 0x20A},
+	{
+	 208, 5040, 3360, 0x71, 0x01, 0xF8, 0x0D, 0xEF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7E4, 0x7E0, 0x7DC, 0x207, 0x208, 0x209},
+	{
+	 210, 5050, 3367, 0x71, 0x01, 0xF9, 0x0D, 0xEF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xCC, 0xCC, 0xFF, 0x00, 0x0F, 0x0F, 0x8F, 0xFF, 0x00, 0x0F,
+	 0x0F, 0x8F, 0x7E8, 0x7E4, 0x7E0, 0x206, 0x207, 0x208},
+	{
+	 212, 5060, 3373, 0x71, 0x01, 0xFA, 0x0D, 0xE6, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xBB, 0xBB, 0xFF, 0x00, 0x0E, 0x0F, 0x8E, 0xFF, 0x00, 0x0E,
+	 0x0F, 0x8E, 0x7EC, 0x7E8, 0x7E4, 0x205, 0x206, 0x207},
+	{
+	 214, 5070, 3380, 0x71, 0x01, 0xFB, 0x0D, 0xE6, 0x01, 0x04, 0x0A,
+	 0x00, 0x8F, 0xBB, 0xBB, 0xFF, 0x00, 0x0E, 0x0F, 0x8E, 0xFF, 0x00, 0x0E,
+	 0x0F, 0x8E, 0x7F0, 0x7EC, 0x7E8, 0x204, 0x205, 0x206},
+	{
+	 216, 5080, 3387, 0x71, 0x01, 0xFC, 0x0D, 0xDE, 0x01, 0x04, 0x0A,
+	 0x00, 0x8E, 0xBB, 0xBB, 0xEE, 0x00, 0x0E, 0x0F, 0x8D, 0xEE, 0x00, 0x0E,
+	 0x0F, 0x8D, 0x7F4, 0x7F0, 0x7EC, 0x203, 0x204, 0x205},
+	{
+	 218, 5090, 3393, 0x71, 0x01, 0xFD, 0x0D, 0xDE, 0x01, 0x04, 0x0A,
+	 0x00, 0x8E, 0xBB, 0xBB, 0xEE, 0x00, 0x0E, 0x0F, 0x8D, 0xEE, 0x00, 0x0E,
+	 0x0F, 0x8D, 0x7F8, 0x7F4, 0x7F0, 0x202, 0x203, 0x204},
+	{
+	 220, 5100, 3400, 0x71, 0x01, 0xFE, 0x0C, 0xD6, 0x01, 0x04, 0x0A,
+	 0x00, 0x8E, 0xAA, 0xAA, 0xEE, 0x00, 0x0D, 0x0F, 0x8D, 0xEE, 0x00, 0x0D,
+	 0x0F, 0x8D, 0x7FC, 0x7F8, 0x7F4, 0x201, 0x202, 0x203},
+	{
+	 222, 5110, 3407, 0x71, 0x01, 0xFF, 0x0C, 0xD6, 0x01, 0x04, 0x0A,
+	 0x00, 0x8E, 0xAA, 0xAA, 0xEE, 0x00, 0x0D, 0x0F, 0x8D, 0xEE, 0x00, 0x0D,
+	 0x0F, 0x8D, 0x800, 0x7FC, 0x7F8, 0x200, 0x201, 0x202},
+	{
+	 224, 5120, 3413, 0x71, 0x02, 0x00, 0x0C, 0xCE, 0x01, 0x04, 0x0A,
+	 0x00, 0x8D, 0xAA, 0xAA, 0xDD, 0x00, 0x0D, 0x0F, 0x8C, 0xDD, 0x00, 0x0D,
+	 0x0F, 0x8C, 0x804, 0x800, 0x7FC, 0x1FF, 0x200, 0x201},
+	{
+	 226, 5130, 3420, 0x71, 0x02, 0x01, 0x0C, 0xCE, 0x01, 0x04, 0x0A,
+	 0x00, 0x8D, 0xAA, 0xAA, 0xDD, 0x00, 0x0D, 0x0F, 0x8C, 0xDD, 0x00, 0x0D,
+	 0x0F, 0x8C, 0x808, 0x804, 0x800, 0x1FE, 0x1FF, 0x200},
+	{
+	 228, 5140, 3427, 0x71, 0x02, 0x02, 0x0C, 0xC6, 0x01, 0x04, 0x0A,
+	 0x00, 0x8D, 0x99, 0x99, 0xDD, 0x00, 0x0C, 0x0E, 0x8B, 0xDD, 0x00, 0x0C,
+	 0x0E, 0x8B, 0x80C, 0x808, 0x804, 0x1FD, 0x1FE, 0x1FF},
+	{
+	 32, 5160, 3440, 0x71, 0x02, 0x04, 0x0B, 0xBE, 0x01, 0x04, 0x0A,
+	 0x00, 0x8C, 0x99, 0x99, 0xCC, 0x00, 0x0B, 0x0D, 0x8A, 0xCC, 0x00, 0x0B,
+	 0x0D, 0x8A, 0x814, 0x810, 0x80C, 0x1FB, 0x1FC, 0x1FD},
+	{
+	 34, 5170, 3447, 0x71, 0x02, 0x05, 0x0B, 0xBE, 0x01, 0x04, 0x0A,
+	 0x00, 0x8C, 0x99, 0x99, 0xCC, 0x00, 0x0B, 0x0D, 0x8A, 0xCC, 0x00, 0x0B,
+	 0x0D, 0x8A, 0x818, 0x814, 0x810, 0x1FA, 0x1FB, 0x1FC},
+	{
+	 36, 5180, 3453, 0x71, 0x02, 0x06, 0x0B, 0xB6, 0x01, 0x04, 0x0A,
+	 0x00, 0x8C, 0x88, 0x88, 0xCC, 0x00, 0x0B, 0x0C, 0x89, 0xCC, 0x00, 0x0B,
+	 0x0C, 0x89, 0x81C, 0x818, 0x814, 0x1F9, 0x1FA, 0x1FB},
+	{
+	 38, 5190, 3460, 0x71, 0x02, 0x07, 0x0B, 0xB6, 0x01, 0x04, 0x0A,
+	 0x00, 0x8C, 0x88, 0x88, 0xCC, 0x00, 0x0B, 0x0C, 0x89, 0xCC, 0x00, 0x0B,
+	 0x0C, 0x89, 0x820, 0x81C, 0x818, 0x1F8, 0x1F9, 0x1FA},
+	{
+	 40, 5200, 3467, 0x71, 0x02, 0x08, 0x0B, 0xAF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8B, 0x88, 0x88, 0xBB, 0x00, 0x0A, 0x0B, 0x89, 0xBB, 0x00, 0x0A,
+	 0x0B, 0x89, 0x824, 0x820, 0x81C, 0x1F7, 0x1F8, 0x1F9},
+	{
+	 42, 5210, 3473, 0x71, 0x02, 0x09, 0x0B, 0xAF, 0x01, 0x04, 0x0A,
+	 0x00, 0x8B, 0x88, 0x88, 0xBB, 0x00, 0x0A, 0x0B, 0x89, 0xBB, 0x00, 0x0A,
+	 0x0B, 0x89, 0x828, 0x824, 0x820, 0x1F6, 0x1F7, 0x1F8},
+	{
+	 44, 5220, 3480, 0x71, 0x02, 0x0A, 0x0A, 0xA7, 0x01, 0x04, 0x0A,
+	 0x00, 0x8B, 0x77, 0x77, 0xBB, 0x00, 0x09, 0x0A, 0x88, 0xBB, 0x00, 0x09,
+	 0x0A, 0x88, 0x82C, 0x828, 0x824, 0x1F5, 0x1F6, 0x1F7},
+	{
+	 46, 5230, 3487, 0x71, 0x02, 0x0B, 0x0A, 0xA7, 0x01, 0x04, 0x0A,
+	 0x00, 0x8B, 0x77, 0x77, 0xBB, 0x00, 0x09, 0x0A, 0x88, 0xBB, 0x00, 0x09,
+	 0x0A, 0x88, 0x830, 0x82C, 0x828, 0x1F4, 0x1F5, 0x1F6},
+	{
+	 48, 5240, 3493, 0x71, 0x02, 0x0C, 0x0A, 0xA0, 0x01, 0x04, 0x0A,
+	 0x00, 0x8A, 0x77, 0x77, 0xAA, 0x00, 0x09, 0x0A, 0x87, 0xAA, 0x00, 0x09,
+	 0x0A, 0x87, 0x834, 0x830, 0x82C, 0x1F3, 0x1F4, 0x1F5},
+	{
+	 50, 5250, 3500, 0x71, 0x02, 0x0D, 0x0A, 0xA0, 0x01, 0x04, 0x0A,
+	 0x00, 0x8A, 0x77, 0x77, 0xAA, 0x00, 0x09, 0x0A, 0x87, 0xAA, 0x00, 0x09,
+	 0x0A, 0x87, 0x838, 0x834, 0x830, 0x1F2, 0x1F3, 0x1F4},
+	{
+	 52, 5260, 3507, 0x71, 0x02, 0x0E, 0x0A, 0x98, 0x01, 0x04, 0x0A,
+	 0x00, 0x8A, 0x66, 0x66, 0xAA, 0x00, 0x08, 0x09, 0x87, 0xAA, 0x00, 0x08,
+	 0x09, 0x87, 0x83C, 0x838, 0x834, 0x1F1, 0x1F2, 0x1F3},
+	{
+	 54, 5270, 3513, 0x71, 0x02, 0x0F, 0x0A, 0x98, 0x01, 0x04, 0x0A,
+	 0x00, 0x8A, 0x66, 0x66, 0xAA, 0x00, 0x08, 0x09, 0x87, 0xAA, 0x00, 0x08,
+	 0x09, 0x87, 0x840, 0x83C, 0x838, 0x1F0, 0x1F1, 0x1F2},
+	{
+	 56, 5280, 3520, 0x71, 0x02, 0x10, 0x09, 0x91, 0x01, 0x04, 0x0A,
+	 0x00, 0x89, 0x66, 0x66, 0x99, 0x00, 0x08, 0x08, 0x86, 0x99, 0x00, 0x08,
+	 0x08, 0x86, 0x844, 0x840, 0x83C, 0x1F0, 0x1F0, 0x1F1},
+	{
+	 58, 5290, 3527, 0x71, 0x02, 0x11, 0x09, 0x91, 0x01, 0x04, 0x0A,
+	 0x00, 0x89, 0x66, 0x66, 0x99, 0x00, 0x08, 0x08, 0x86, 0x99, 0x00, 0x08,
+	 0x08, 0x86, 0x848, 0x844, 0x840, 0x1EF, 0x1F0, 0x1F0},
+	{
+	 60, 5300, 3533, 0x71, 0x02, 0x12, 0x09, 0x8A, 0x01, 0x04, 0x0A,
+	 0x00, 0x89, 0x55, 0x55, 0x99, 0x00, 0x08, 0x07, 0x85, 0x99, 0x00, 0x08,
+	 0x07, 0x85, 0x84C, 0x848, 0x844, 0x1EE, 0x1EF, 0x1F0},
+	{
+	 62, 5310, 3540, 0x71, 0x02, 0x13, 0x09, 0x8A, 0x01, 0x04, 0x0A,
+	 0x00, 0x89, 0x55, 0x55, 0x99, 0x00, 0x08, 0x07, 0x85, 0x99, 0x00, 0x08,
+	 0x07, 0x85, 0x850, 0x84C, 0x848, 0x1ED, 0x1EE, 0x1EF},
+	{
+	 64, 5320, 3547, 0x71, 0x02, 0x14, 0x09, 0x83, 0x01, 0x04, 0x0A,
+	 0x00, 0x88, 0x55, 0x55, 0x88, 0x00, 0x07, 0x07, 0x84, 0x88, 0x00, 0x07,
+	 0x07, 0x84, 0x854, 0x850, 0x84C, 0x1EC, 0x1ED, 0x1EE},
+	{
+	 66, 5330, 3553, 0x71, 0x02, 0x15, 0x09, 0x83, 0x01, 0x04, 0x0A,
+	 0x00, 0x88, 0x55, 0x55, 0x88, 0x00, 0x07, 0x07, 0x84, 0x88, 0x00, 0x07,
+	 0x07, 0x84, 0x858, 0x854, 0x850, 0x1EB, 0x1EC, 0x1ED},
+	{
+	 68, 5340, 3560, 0x71, 0x02, 0x16, 0x08, 0x7C, 0x01, 0x04, 0x0A,
+	 0x00, 0x88, 0x44, 0x44, 0x88, 0x00, 0x07, 0x06, 0x84, 0x88, 0x00, 0x07,
+	 0x06, 0x84, 0x85C, 0x858, 0x854, 0x1EA, 0x1EB, 0x1EC},
+	{
+	 70, 5350, 3567, 0x71, 0x02, 0x17, 0x08, 0x7C, 0x01, 0x04, 0x0A,
+	 0x00, 0x88, 0x44, 0x44, 0x88, 0x00, 0x07, 0x06, 0x84, 0x88, 0x00, 0x07,
+	 0x06, 0x84, 0x860, 0x85C, 0x858, 0x1E9, 0x1EA, 0x1EB},
+	{
+	 72, 5360, 3573, 0x71, 0x02, 0x18, 0x08, 0x75, 0x01, 0x04, 0x0A,
+	 0x00, 0x87, 0x44, 0x44, 0x77, 0x00, 0x06, 0x05, 0x83, 0x77, 0x00, 0x06,
+	 0x05, 0x83, 0x864, 0x860, 0x85C, 0x1E8, 0x1E9, 0x1EA},
+	{
+	 74, 5370, 3580, 0x71, 0x02, 0x19, 0x08, 0x75, 0x01, 0x04, 0x0A,
+	 0x00, 0x87, 0x44, 0x44, 0x77, 0x00, 0x06, 0x05, 0x83, 0x77, 0x00, 0x06,
+	 0x05, 0x83, 0x868, 0x864, 0x860, 0x1E7, 0x1E8, 0x1E9},
+	{
+	 76, 5380, 3587, 0x71, 0x02, 0x1A, 0x08, 0x6E, 0x01, 0x04, 0x0A,
+	 0x00, 0x87, 0x33, 0x33, 0x77, 0x00, 0x06, 0x04, 0x82, 0x77, 0x00, 0x06,
+	 0x04, 0x82, 0x86C, 0x868, 0x864, 0x1E6, 0x1E7, 0x1E8},
+	{
+	 78, 5390, 3593, 0x71, 0x02, 0x1B, 0x08, 0x6E, 0x01, 0x04, 0x0A,
+	 0x00, 0x87, 0x33, 0x33, 0x77, 0x00, 0x06, 0x04, 0x82, 0x77, 0x00, 0x06,
+	 0x04, 0x82, 0x870, 0x86C, 0x868, 0x1E5, 0x1E6, 0x1E7},
+	{
+	 80, 5400, 3600, 0x71, 0x02, 0x1C, 0x07, 0x67, 0x01, 0x04, 0x0A,
+	 0x00, 0x86, 0x33, 0x33, 0x66, 0x00, 0x05, 0x04, 0x81, 0x66, 0x00, 0x05,
+	 0x04, 0x81, 0x874, 0x870, 0x86C, 0x1E5, 0x1E5, 0x1E6},
+	{
+	 82, 5410, 3607, 0x71, 0x02, 0x1D, 0x07, 0x67, 0x01, 0x04, 0x0A,
+	 0x00, 0x86, 0x33, 0x33, 0x66, 0x00, 0x05, 0x04, 0x81, 0x66, 0x00, 0x05,
+	 0x04, 0x81, 0x878, 0x874, 0x870, 0x1E4, 0x1E5, 0x1E5},
+	{
+	 84, 5420, 3613, 0x71, 0x02, 0x1E, 0x07, 0x61, 0x01, 0x04, 0x0A,
+	 0x00, 0x86, 0x22, 0x22, 0x66, 0x00, 0x05, 0x03, 0x80, 0x66, 0x00, 0x05,
+	 0x03, 0x80, 0x87C, 0x878, 0x874, 0x1E3, 0x1E4, 0x1E5},
+	{
+	 86, 5430, 3620, 0x71, 0x02, 0x1F, 0x07, 0x61, 0x01, 0x04, 0x0A,
+	 0x00, 0x86, 0x22, 0x22, 0x66, 0x00, 0x05, 0x03, 0x80, 0x66, 0x00, 0x05,
+	 0x03, 0x80, 0x880, 0x87C, 0x878, 0x1E2, 0x1E3, 0x1E4},
+	{
+	 88, 5440, 3627, 0x71, 0x02, 0x20, 0x07, 0x5A, 0x01, 0x04, 0x0A,
+	 0x00, 0x85, 0x22, 0x22, 0x55, 0x00, 0x04, 0x02, 0x80, 0x55, 0x00, 0x04,
+	 0x02, 0x80, 0x884, 0x880, 0x87C, 0x1E1, 0x1E2, 0x1E3},
+	{
+	 90, 5450, 3633, 0x71, 0x02, 0x21, 0x07, 0x5A, 0x01, 0x04, 0x0A,
+	 0x00, 0x85, 0x22, 0x22, 0x55, 0x00, 0x04, 0x02, 0x80, 0x55, 0x00, 0x04,
+	 0x02, 0x80, 0x888, 0x884, 0x880, 0x1E0, 0x1E1, 0x1E2},
+	{
+	 92, 5460, 3640, 0x71, 0x02, 0x22, 0x06, 0x53, 0x01, 0x04, 0x0A,
+	 0x00, 0x85, 0x11, 0x11, 0x55, 0x00, 0x04, 0x01, 0x80, 0x55, 0x00, 0x04,
+	 0x01, 0x80, 0x88C, 0x888, 0x884, 0x1DF, 0x1E0, 0x1E1},
+	{
+	 94, 5470, 3647, 0x71, 0x02, 0x23, 0x06, 0x53, 0x01, 0x04, 0x0A,
+	 0x00, 0x85, 0x11, 0x11, 0x55, 0x00, 0x04, 0x01, 0x80, 0x55, 0x00, 0x04,
+	 0x01, 0x80, 0x890, 0x88C, 0x888, 0x1DE, 0x1DF, 0x1E0},
+	{
+	 96, 5480, 3653, 0x71, 0x02, 0x24, 0x06, 0x4D, 0x01, 0x04, 0x0A,
+	 0x00, 0x84, 0x11, 0x11, 0x44, 0x00, 0x03, 0x00, 0x80, 0x44, 0x00, 0x03,
+	 0x00, 0x80, 0x894, 0x890, 0x88C, 0x1DD, 0x1DE, 0x1DF},
+	{
+	 98, 5490, 3660, 0x71, 0x02, 0x25, 0x06, 0x4D, 0x01, 0x04, 0x0A,
+	 0x00, 0x84, 0x11, 0x11, 0x44, 0x00, 0x03, 0x00, 0x80, 0x44, 0x00, 0x03,
+	 0x00, 0x80, 0x898, 0x894, 0x890, 0x1DD, 0x1DD, 0x1DE},
+	{
+	 100, 5500, 3667, 0x71, 0x02, 0x26, 0x06, 0x47, 0x01, 0x04, 0x0A,
+	 0x00, 0x84, 0x00, 0x00, 0x44, 0x00, 0x03, 0x00, 0x80, 0x44, 0x00, 0x03,
+	 0x00, 0x80, 0x89C, 0x898, 0x894, 0x1DC, 0x1DD, 0x1DD},
+	{
+	 102, 5510, 3673, 0x71, 0x02, 0x27, 0x06, 0x47, 0x01, 0x04, 0x0A,
+	 0x00, 0x84, 0x00, 0x00, 0x44, 0x00, 0x03, 0x00, 0x80, 0x44, 0x00, 0x03,
+	 0x00, 0x80, 0x8A0, 0x89C, 0x898, 0x1DB, 0x1DC, 0x1DD},
+	{
+	 104, 5520, 3680, 0x71, 0x02, 0x28, 0x05, 0x40, 0x01, 0x04, 0x0A,
+	 0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00, 0x80, 0x33, 0x00, 0x02,
+	 0x00, 0x80, 0x8A4, 0x8A0, 0x89C, 0x1DA, 0x1DB, 0x1DC},
+	{
+	 106, 5530, 3687, 0x71, 0x02, 0x29, 0x05, 0x40, 0x01, 0x04, 0x0A,
+	 0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00, 0x80, 0x33, 0x00, 0x02,
+	 0x00, 0x80, 0x8A8, 0x8A4, 0x8A0, 0x1D9, 0x1DA, 0x1DB},
+	{
+	 108, 5540, 3693, 0x71, 0x02, 0x2A, 0x05, 0x3A, 0x01, 0x04, 0x0A,
+	 0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00, 0x80, 0x33, 0x00, 0x02,
+	 0x00, 0x80, 0x8AC, 0x8A8, 0x8A4, 0x1D8, 0x1D9, 0x1DA},
+	{
+	 110, 5550, 3700, 0x71, 0x02, 0x2B, 0x05, 0x3A, 0x01, 0x04, 0x0A,
+	 0x00, 0x83, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00, 0x80, 0x33, 0x00, 0x02,
+	 0x00, 0x80, 0x8B0, 0x8AC, 0x8A8, 0x1D7, 0x1D8, 0x1D9},
+	{
+	 112, 5560, 3707, 0x71, 0x02, 0x2C, 0x05, 0x34, 0x01, 0x04, 0x0A,
+	 0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00, 0x80, 0x22, 0x00, 0x01,
+	 0x00, 0x80, 0x8B4, 0x8B0, 0x8AC, 0x1D7, 0x1D7, 0x1D8},
+	{
+	 114, 5570, 3713, 0x71, 0x02, 0x2D, 0x05, 0x34, 0x01, 0x04, 0x0A,
+	 0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00, 0x80, 0x22, 0x00, 0x01,
+	 0x00, 0x80, 0x8B8, 0x8B4, 0x8B0, 0x1D6, 0x1D7, 0x1D7},
+	{
+	 116, 5580, 3720, 0x71, 0x02, 0x2E, 0x04, 0x2E, 0x01, 0x04, 0x0A,
+	 0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00, 0x80, 0x22, 0x00, 0x01,
+	 0x00, 0x80, 0x8BC, 0x8B8, 0x8B4, 0x1D5, 0x1D6, 0x1D7},
+	{
+	 118, 5590, 3727, 0x71, 0x02, 0x2F, 0x04, 0x2E, 0x01, 0x04, 0x0A,
+	 0x00, 0x82, 0x00, 0x00, 0x22, 0x00, 0x01, 0x00, 0x80, 0x22, 0x00, 0x01,
+	 0x00, 0x80, 0x8C0, 0x8BC, 0x8B8, 0x1D4, 0x1D5, 0x1D6},
+	{
+	 120, 5600, 3733, 0x71, 0x02, 0x30, 0x04, 0x28, 0x01, 0x04, 0x0A,
+	 0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x01, 0x00, 0x80, 0x11, 0x00, 0x01,
+	 0x00, 0x80, 0x8C4, 0x8C0, 0x8BC, 0x1D3, 0x1D4, 0x1D5},
+	{
+	 122, 5610, 3740, 0x71, 0x02, 0x31, 0x04, 0x28, 0x01, 0x04, 0x0A,
+	 0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x01, 0x00, 0x80, 0x11, 0x00, 0x01,
+	 0x00, 0x80, 0x8C8, 0x8C4, 0x8C0, 0x1D2, 0x1D3, 0x1D4},
+	{
+	 124, 5620, 3747, 0x71, 0x02, 0x32, 0x04, 0x21, 0x01, 0x04, 0x0A,
+	 0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00,
+	 0x00, 0x80, 0x8CC, 0x8C8, 0x8C4, 0x1D2, 0x1D2, 0x1D3},
+	{
+	 126, 5630, 3753, 0x71, 0x02, 0x33, 0x04, 0x21, 0x01, 0x04, 0x0A,
+	 0x00, 0x81, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00,
+	 0x00, 0x80, 0x8D0, 0x8CC, 0x8C8, 0x1D1, 0x1D2, 0x1D2},
+	{
+	 128, 5640, 3760, 0x71, 0x02, 0x34, 0x03, 0x1C, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8D4, 0x8D0, 0x8CC, 0x1D0, 0x1D1, 0x1D2},
+	{
+	 130, 5650, 3767, 0x71, 0x02, 0x35, 0x03, 0x1C, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8D8, 0x8D4, 0x8D0, 0x1CF, 0x1D0, 0x1D1},
+	{
+	 132, 5660, 3773, 0x71, 0x02, 0x36, 0x03, 0x16, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8DC, 0x8D8, 0x8D4, 0x1CE, 0x1CF, 0x1D0},
+	{
+	 134, 5670, 3780, 0x71, 0x02, 0x37, 0x03, 0x16, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8E0, 0x8DC, 0x8D8, 0x1CE, 0x1CE, 0x1CF},
+	{
+	 136, 5680, 3787, 0x71, 0x02, 0x38, 0x03, 0x10, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8E4, 0x8E0, 0x8DC, 0x1CD, 0x1CE, 0x1CE},
+	{
+	 138, 5690, 3793, 0x71, 0x02, 0x39, 0x03, 0x10, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8E8, 0x8E4, 0x8E0, 0x1CC, 0x1CD, 0x1CE},
+	{
+	 140, 5700, 3800, 0x71, 0x02, 0x3A, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8EC, 0x8E8, 0x8E4, 0x1CB, 0x1CC, 0x1CD},
+	{
+	 142, 5710, 3807, 0x71, 0x02, 0x3B, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8F0, 0x8EC, 0x8E8, 0x1CA, 0x1CB, 0x1CC},
+	{
+	 144, 5720, 3813, 0x71, 0x02, 0x3C, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8F4, 0x8F0, 0x8EC, 0x1C9, 0x1CA, 0x1CB},
+	{
+	 145, 5725, 3817, 0x72, 0x04, 0x79, 0x02, 0x03, 0x01, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8F6, 0x8F2, 0x8EE, 0x1C9, 0x1CA, 0x1CB},
+	{
+	 146, 5730, 3820, 0x71, 0x02, 0x3D, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8F8, 0x8F4, 0x8F0, 0x1C9, 0x1C9, 0x1CA},
+	{
+	 147, 5735, 3823, 0x72, 0x04, 0x7B, 0x02, 0x03, 0x01, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8FA, 0x8F6, 0x8F2, 0x1C8, 0x1C9, 0x1CA},
+	{
+	 148, 5740, 3827, 0x71, 0x02, 0x3E, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8FC, 0x8F8, 0x8F4, 0x1C8, 0x1C9, 0x1C9},
+	{
+	 149, 5745, 3830, 0x72, 0x04, 0x7D, 0x02, 0xFE, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x8FE, 0x8FA, 0x8F6, 0x1C8, 0x1C8, 0x1C9},
+	{
+	 150, 5750, 3833, 0x71, 0x02, 0x3F, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x900, 0x8FC, 0x8F8, 0x1C7, 0x1C8, 0x1C9},
+	{
+	 151, 5755, 3837, 0x72, 0x04, 0x7F, 0x02, 0xFE, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x902, 0x8FE, 0x8FA, 0x1C7, 0x1C8, 0x1C8},
+	{
+	 152, 5760, 3840, 0x71, 0x02, 0x40, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x904, 0x900, 0x8FC, 0x1C6, 0x1C7, 0x1C8},
+	{
+	 153, 5765, 3843, 0x72, 0x04, 0x81, 0x02, 0xF8, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x906, 0x902, 0x8FE, 0x1C6, 0x1C7, 0x1C8},
+	{
+	 154, 5770, 3847, 0x71, 0x02, 0x41, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x908, 0x904, 0x900, 0x1C6, 0x1C6, 0x1C7},
+	{
+	 155, 5775, 3850, 0x72, 0x04, 0x83, 0x02, 0xF8, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x90A, 0x906, 0x902, 0x1C5, 0x1C6, 0x1C7},
+	{
+	 156, 5780, 3853, 0x71, 0x02, 0x42, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x90C, 0x908, 0x904, 0x1C5, 0x1C6, 0x1C6},
+	{
+	 157, 5785, 3857, 0x72, 0x04, 0x85, 0x02, 0xF2, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x90E, 0x90A, 0x906, 0x1C4, 0x1C5, 0x1C6},
+	{
+	 158, 5790, 3860, 0x71, 0x02, 0x43, 0x02, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x910, 0x90C, 0x908, 0x1C4, 0x1C5, 0x1C6},
+	{
+	 159, 5795, 3863, 0x72, 0x04, 0x87, 0x02, 0xF2, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x912, 0x90E, 0x90A, 0x1C4, 0x1C4, 0x1C5},
+	{
+	 160, 5800, 3867, 0x71, 0x02, 0x44, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x914, 0x910, 0x90C, 0x1C3, 0x1C4, 0x1C5},
+	{
+	 161, 5805, 3870, 0x72, 0x04, 0x89, 0x01, 0xED, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x916, 0x912, 0x90E, 0x1C3, 0x1C4, 0x1C4},
+	{
+	 162, 5810, 3873, 0x71, 0x02, 0x45, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x918, 0x914, 0x910, 0x1C2, 0x1C3, 0x1C4},
+	{
+	 163, 5815, 3877, 0x72, 0x04, 0x8B, 0x01, 0xED, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x91A, 0x916, 0x912, 0x1C2, 0x1C3, 0x1C4},
+	{
+	 164, 5820, 3880, 0x71, 0x02, 0x46, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x91C, 0x918, 0x914, 0x1C2, 0x1C2, 0x1C3},
+	{
+	 165, 5825, 3883, 0x72, 0x04, 0x8D, 0x01, 0xED, 0x00, 0x03, 0x14,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x91E, 0x91A, 0x916, 0x1C1, 0x1C2, 0x1C3},
+	{
+	 166, 5830, 3887, 0x71, 0x02, 0x47, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x920, 0x91C, 0x918, 0x1C1, 0x1C2, 0x1C2},
+	{
+	 168, 5840, 3893, 0x71, 0x02, 0x48, 0x01, 0x0A, 0x01, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x924, 0x920, 0x91C, 0x1C0, 0x1C1, 0x1C2},
+	{
+	 170, 5850, 3900, 0x71, 0x02, 0x49, 0x01, 0xE0, 0x00, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x928, 0x924, 0x920, 0x1BF, 0x1C0, 0x1C1},
+	{
+	 172, 5860, 3907, 0x71, 0x02, 0x4A, 0x01, 0xDE, 0x00, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x92C, 0x928, 0x924, 0x1BF, 0x1BF, 0x1C0},
+	{
+	 174, 5870, 3913, 0x71, 0x02, 0x4B, 0x00, 0xDB, 0x00, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x930, 0x92C, 0x928, 0x1BE, 0x1BF, 0x1BF},
+	{
+	 176, 5880, 3920, 0x71, 0x02, 0x4C, 0x00, 0xD8, 0x00, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x934, 0x930, 0x92C, 0x1BD, 0x1BE, 0x1BF},
+	{
+	 178, 5890, 3927, 0x71, 0x02, 0x4D, 0x00, 0xD6, 0x00, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x938, 0x934, 0x930, 0x1BC, 0x1BD, 0x1BE},
+	{
+	 180, 5900, 3933, 0x71, 0x02, 0x4E, 0x00, 0xD3, 0x00, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x93C, 0x938, 0x934, 0x1BC, 0x1BC, 0x1BD},
+	{
+	 182, 5910, 3940, 0x71, 0x02, 0x4F, 0x00, 0xD6, 0x00, 0x04, 0x0A,
+	 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
+	 0x00, 0x80, 0x940, 0x93C, 0x938, 0x1BB, 0x1BC, 0x1BC},
+	{
+	 1, 2412, 3216, 0x73, 0x09, 0x6C, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0D, 0x0C, 0x80, 0xFF, 0x88, 0x0D,
+	 0x0C, 0x80, 0x3C9, 0x3C5, 0x3C1, 0x43A, 0x43F, 0x443},
+	{
+	 2, 2417, 3223, 0x73, 0x09, 0x71, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x0B, 0x80, 0xFF, 0x88, 0x0C,
+	 0x0B, 0x80, 0x3CB, 0x3C7, 0x3C3, 0x438, 0x43D, 0x441},
+	{
+	 3, 2422, 3229, 0x73, 0x09, 0x76, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x0A, 0x80, 0xFF, 0x88, 0x0C,
+	 0x0A, 0x80, 0x3CD, 0x3C9, 0x3C5, 0x436, 0x43A, 0x43F},
+	{
+	 4, 2427, 3236, 0x73, 0x09, 0x7B, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x0A, 0x80, 0xFF, 0x88, 0x0C,
+	 0x0A, 0x80, 0x3CF, 0x3CB, 0x3C7, 0x434, 0x438, 0x43D},
+	{
+	 5, 2432, 3243, 0x73, 0x09, 0x80, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0C, 0x09, 0x80, 0xFF, 0x88, 0x0C,
+	 0x09, 0x80, 0x3D1, 0x3CD, 0x3C9, 0x431, 0x436, 0x43A},
+	{
+	 6, 2437, 3249, 0x73, 0x09, 0x85, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0B, 0x08, 0x80, 0xFF, 0x88, 0x0B,
+	 0x08, 0x80, 0x3D3, 0x3CF, 0x3CB, 0x42F, 0x434, 0x438},
+	{
+	 7, 2442, 3256, 0x73, 0x09, 0x8A, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0A, 0x07, 0x80, 0xFF, 0x88, 0x0A,
+	 0x07, 0x80, 0x3D5, 0x3D1, 0x3CD, 0x42D, 0x431, 0x436},
+	{
+	 8, 2447, 3263, 0x73, 0x09, 0x8F, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x0A, 0x06, 0x80, 0xFF, 0x88, 0x0A,
+	 0x06, 0x80, 0x3D7, 0x3D3, 0x3CF, 0x42B, 0x42F, 0x434},
+	{
+	 9, 2452, 3269, 0x73, 0x09, 0x94, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x09, 0x06, 0x80, 0xFF, 0x88, 0x09,
+	 0x06, 0x80, 0x3D9, 0x3D5, 0x3D1, 0x429, 0x42D, 0x431},
+	{
+	 10, 2457, 3276, 0x73, 0x09, 0x99, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x08, 0x05, 0x80, 0xFF, 0x88, 0x08,
+	 0x05, 0x80, 0x3DB, 0x3D7, 0x3D3, 0x427, 0x42B, 0x42F},
+	{
+	 11, 2462, 3283, 0x73, 0x09, 0x9E, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x08, 0x04, 0x80, 0xFF, 0x88, 0x08,
+	 0x04, 0x80, 0x3DD, 0x3D9, 0x3D5, 0x424, 0x429, 0x42D},
+	{
+	 12, 2467, 3289, 0x73, 0x09, 0xA3, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x08, 0x03, 0x80, 0xFF, 0x88, 0x08,
+	 0x03, 0x80, 0x3DF, 0x3DB, 0x3D7, 0x422, 0x427, 0x42B},
+	{
+	 13, 2472, 3296, 0x73, 0x09, 0xA8, 0x0F, 0x00, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x07, 0x03, 0x80, 0xFF, 0x88, 0x07,
+	 0x03, 0x80, 0x3E1, 0x3DD, 0x3D9, 0x420, 0x424, 0x429},
+	{
+	 14, 2484, 3312, 0x73, 0x09, 0xB4, 0x0F, 0xFF, 0x01, 0x07, 0x15,
+	 0x01, 0x8F, 0xFF, 0xFF, 0xFF, 0x88, 0x07, 0x01, 0x80, 0xFF, 0x88, 0x07,
+	 0x01, 0x80, 0x3E6, 0x3E2, 0x3DE, 0x41B, 0x41F, 0x424}
+};
+
+static chan_info_nphy_radio205x_t chan_info_nphyrev3_2056[] = {
+	{
+	 184, 4920, 0xff, 0x01, 0x01, 0x01, 0xec, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07b4, 0x07b0, 0x07ac, 0x0214, 0x0215, 0x0216},
+	{
+	 186, 4930, 0xff, 0x01, 0x01, 0x01, 0xed, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07b8, 0x07b4, 0x07b0, 0x0213, 0x0214, 0x0215},
+	{
+	 188, 4940, 0xff, 0x01, 0x01, 0x01, 0xee, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07bc, 0x07b8, 0x07b4, 0x0212, 0x0213, 0x0214},
+	{
+	 190, 4950, 0xff, 0x01, 0x01, 0x01, 0xef, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07c0, 0x07bc, 0x07b8, 0x0211, 0x0212, 0x0213},
+	{
+	 192, 4960, 0xff, 0x01, 0x01, 0x01, 0xf0, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07c4, 0x07c0, 0x07bc, 0x020f, 0x0211, 0x0212},
+	{
+	 194, 4970, 0xff, 0x01, 0x01, 0x01, 0xf1, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07c8, 0x07c4, 0x07c0, 0x020e, 0x020f, 0x0211},
+	{
+	 196, 4980, 0xff, 0x01, 0x01, 0x01, 0xf2, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07cc, 0x07c8, 0x07c4, 0x020d, 0x020e, 0x020f},
+	{
+	 198, 4990, 0xff, 0x01, 0x01, 0x01, 0xf3, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07d0, 0x07cc, 0x07c8, 0x020c, 0x020d, 0x020e},
+	{
+	 200, 5000, 0xff, 0x01, 0x01, 0x01, 0xf4, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07d4, 0x07d0, 0x07cc, 0x020b, 0x020c, 0x020d},
+	{
+	 202, 5010, 0xff, 0x01, 0x01, 0x01, 0xf5, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07d8, 0x07d4, 0x07d0, 0x020a, 0x020b, 0x020c},
+	{
+	 204, 5020, 0xf7, 0x01, 0x01, 0x01, 0xf6, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07dc, 0x07d8, 0x07d4, 0x0209, 0x020a, 0x020b},
+	{
+	 206, 5030, 0xf7, 0x01, 0x01, 0x01, 0xf7, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07e0, 0x07dc, 0x07d8, 0x0208, 0x0209, 0x020a},
+	{
+	 208, 5040, 0xef, 0x01, 0x01, 0x01, 0xf8, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07e4, 0x07e0, 0x07dc, 0x0207, 0x0208, 0x0209},
+	{
+	 210, 5050, 0xef, 0x01, 0x01, 0x01, 0xf9, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07e8, 0x07e4, 0x07e0, 0x0206, 0x0207, 0x0208},
+	{
+	 212, 5060, 0xe6, 0x01, 0x01, 0x01, 0xfa, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07ec, 0x07e8, 0x07e4, 0x0205, 0x0206, 0x0207},
+	{
+	 214, 5070, 0xe6, 0x01, 0x01, 0x01, 0xfb, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07f0, 0x07ec, 0x07e8, 0x0204, 0x0205, 0x0206},
+	{
+	 216, 5080, 0xde, 0x01, 0x01, 0x01, 0xfc, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07f4, 0x07f0, 0x07ec, 0x0203, 0x0204, 0x0205},
+	{
+	 218, 5090, 0xde, 0x01, 0x01, 0x01, 0xfd, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07f8, 0x07f4, 0x07f0, 0x0202, 0x0203, 0x0204},
+	{
+	 220, 5100, 0xd6, 0x01, 0x01, 0x01, 0xfe, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xff, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xff, 0x00, 0x07fc, 0x07f8, 0x07f4, 0x0201, 0x0202, 0x0203},
+	{
+	 222, 5110, 0xd6, 0x01, 0x01, 0x01, 0xff, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x0800, 0x07fc, 0x07f8, 0x0200, 0x0201, 0x0202},
+	{
+	 224, 5120, 0xce, 0x01, 0x01, 0x02, 0x00, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x0804, 0x0800, 0x07fc, 0x01ff, 0x0200, 0x0201},
+	{
+	 226, 5130, 0xce, 0x01, 0x01, 0x02, 0x01, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x0808, 0x0804, 0x0800, 0x01fe, 0x01ff, 0x0200},
+	{
+	 228, 5140, 0xc6, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x080c, 0x0808, 0x0804, 0x01fd, 0x01fe, 0x01ff},
+	{
+	 32, 5160, 0xbe, 0x01, 0x01, 0x02, 0x04, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x0814, 0x0810, 0x080c, 0x01fb, 0x01fc, 0x01fd},
+	{
+	 34, 5170, 0xbe, 0x01, 0x01, 0x02, 0x05, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xff, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x0818, 0x0814, 0x0810, 0x01fa, 0x01fb, 0x01fc},
+	{
+	 36, 5180, 0xb6, 0x01, 0x01, 0x02, 0x06, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xef, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xef, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x081c, 0x0818, 0x0814, 0x01f9, 0x01fa, 0x01fb},
+	{
+	 38, 5190, 0xb6, 0x01, 0x01, 0x02, 0x07, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xef, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xfc, 0x00, 0xef, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xfc, 0x00, 0x0820, 0x081c, 0x0818, 0x01f8, 0x01f9, 0x01fa},
+	{
+	 40, 5200, 0xaf, 0x01, 0x01, 0x02, 0x08, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xef, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xef, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0824, 0x0820, 0x081c, 0x01f7, 0x01f8, 0x01f9},
+	{
+	 42, 5210, 0xaf, 0x01, 0x01, 0x02, 0x09, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xdf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xdf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0828, 0x0824, 0x0820, 0x01f6, 0x01f7, 0x01f8},
+	{
+	 44, 5220, 0xa7, 0x01, 0x01, 0x02, 0x0a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xdf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xdf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x082c, 0x0828, 0x0824, 0x01f5, 0x01f6, 0x01f7},
+	{
+	 46, 5230, 0xa7, 0x01, 0x01, 0x02, 0x0b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xdf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xdf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0830, 0x082c, 0x0828, 0x01f4, 0x01f5, 0x01f6},
+	{
+	 48, 5240, 0xa0, 0x01, 0x01, 0x02, 0x0c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0834, 0x0830, 0x082c, 0x01f3, 0x01f4, 0x01f5},
+	{
+	 50, 5250, 0xa0, 0x01, 0x01, 0x02, 0x0d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0838, 0x0834, 0x0830, 0x01f2, 0x01f3, 0x01f4},
+	{
+	 52, 5260, 0x98, 0x01, 0x01, 0x02, 0x0e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x083c, 0x0838, 0x0834, 0x01f1, 0x01f2, 0x01f3},
+	{
+	 54, 5270, 0x98, 0x01, 0x01, 0x02, 0x0f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0840, 0x083c, 0x0838, 0x01f0, 0x01f1, 0x01f2},
+	{
+	 56, 5280, 0x91, 0x01, 0x01, 0x02, 0x10, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xbf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xbf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0844, 0x0840, 0x083c, 0x01f0, 0x01f0, 0x01f1},
+	{
+	 58, 5290, 0x91, 0x01, 0x01, 0x02, 0x11, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xbf, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xfc, 0x00, 0xbf, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xfc, 0x00, 0x0848, 0x0844, 0x0840, 0x01ef, 0x01f0, 0x01f0},
+	{
+	 60, 5300, 0x8a, 0x01, 0x01, 0x02, 0x12, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xbf, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfc, 0x00, 0xbf, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfc, 0x00, 0x084c, 0x0848, 0x0844, 0x01ee, 0x01ef, 0x01f0},
+	{
+	 62, 5310, 0x8a, 0x01, 0x01, 0x02, 0x13, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xbf, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0xbf, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x0850, 0x084c, 0x0848, 0x01ed, 0x01ee, 0x01ef},
+	{
+	 64, 5320, 0x83, 0x01, 0x01, 0x02, 0x14, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xbf, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0xbf, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x0854, 0x0850, 0x084c, 0x01ec, 0x01ed, 0x01ee},
+	{
+	 66, 5330, 0x83, 0x01, 0x01, 0x02, 0x15, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xaf, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0xaf, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x0858, 0x0854, 0x0850, 0x01eb, 0x01ec, 0x01ed},
+	{
+	 68, 5340, 0x7c, 0x01, 0x01, 0x02, 0x16, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xaf, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0xaf, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x085c, 0x0858, 0x0854, 0x01ea, 0x01eb, 0x01ec},
+	{
+	 70, 5350, 0x7c, 0x01, 0x01, 0x02, 0x17, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x0860, 0x085c, 0x0858, 0x01e9, 0x01ea, 0x01eb},
+	{
+	 72, 5360, 0x75, 0x01, 0x01, 0x02, 0x18, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x0864, 0x0860, 0x085c, 0x01e8, 0x01e9, 0x01ea},
+	{
+	 74, 5370, 0x75, 0x01, 0x01, 0x02, 0x19, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x0868, 0x0864, 0x0860, 0x01e7, 0x01e8, 0x01e9},
+	{
+	 76, 5380, 0x6e, 0x01, 0x01, 0x02, 0x1a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x086c, 0x0868, 0x0864, 0x01e6, 0x01e7, 0x01e8},
+	{
+	 78, 5390, 0x6e, 0x01, 0x01, 0x02, 0x1b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x8f, 0x00, 0x05, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xfa, 0x00, 0x8f, 0x00, 0x05, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xfa, 0x00, 0x0870, 0x086c, 0x0868, 0x01e5, 0x01e6, 0x01e7},
+	{
+	 80, 5400, 0x67, 0x01, 0x01, 0x02, 0x1c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8f, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xfa, 0x00, 0x8f, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xfa, 0x00, 0x0874, 0x0870, 0x086c, 0x01e5, 0x01e5, 0x01e6},
+	{
+	 82, 5410, 0x67, 0x01, 0x01, 0x02, 0x1d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8f, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xfa, 0x00, 0x8f, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xfa, 0x00, 0x0878, 0x0874, 0x0870, 0x01e4, 0x01e5, 0x01e5},
+	{
+	 84, 5420, 0x61, 0x01, 0x01, 0x02, 0x1e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8e, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xfa, 0x00, 0x8e, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xfa, 0x00, 0x087c, 0x0878, 0x0874, 0x01e3, 0x01e4, 0x01e5},
+	{
+	 86, 5430, 0x61, 0x01, 0x01, 0x02, 0x1f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8e, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xfa, 0x00, 0x8e, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xfa, 0x00, 0x0880, 0x087c, 0x0878, 0x01e2, 0x01e3, 0x01e4},
+	{
+	 88, 5440, 0x5a, 0x01, 0x01, 0x02, 0x20, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x7e, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xfa, 0x00, 0x7e, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xfa, 0x00, 0x0884, 0x0880, 0x087c, 0x01e1, 0x01e2, 0x01e3},
+	{
+	 90, 5450, 0x5a, 0x01, 0x01, 0x02, 0x21, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x7d, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xfa, 0x00, 0x7d, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xfa, 0x00, 0x0888, 0x0884, 0x0880, 0x01e0, 0x01e1, 0x01e2},
+	{
+	 92, 5460, 0x53, 0x01, 0x01, 0x02, 0x22, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x6d, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xf8, 0x00, 0x6d, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xf8, 0x00, 0x088c, 0x0888, 0x0884, 0x01df, 0x01e0, 0x01e1},
+	{
+	 94, 5470, 0x53, 0x01, 0x01, 0x02, 0x23, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x6d, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xf8, 0x00, 0x6d, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xf8, 0x00, 0x0890, 0x088c, 0x0888, 0x01de, 0x01df, 0x01e0},
+	{
+	 96, 5480, 0x4d, 0x01, 0x01, 0x02, 0x24, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x5d, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xf8, 0x00, 0x5d, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xf8, 0x00, 0x0894, 0x0890, 0x088c, 0x01dd, 0x01de, 0x01df},
+	{
+	 98, 5490, 0x4d, 0x01, 0x01, 0x02, 0x25, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x5c, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x08, 0x00, 0xf8, 0x00, 0x5c, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x08,
+	 0x00, 0xf8, 0x00, 0x0898, 0x0894, 0x0890, 0x01dd, 0x01dd, 0x01de},
+	{
+	 100, 5500, 0x47, 0x01, 0x01, 0x02, 0x26, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x5c, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x5c, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x089c, 0x0898, 0x0894, 0x01dc, 0x01dd, 0x01dd},
+	{
+	 102, 5510, 0x47, 0x01, 0x01, 0x02, 0x27, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x4c, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x4c, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08a0, 0x089c, 0x0898, 0x01db, 0x01dc, 0x01dd},
+	{
+	 104, 5520, 0x40, 0x01, 0x01, 0x02, 0x28, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x4c, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x4c, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08a4, 0x08a0, 0x089c, 0x01da, 0x01db, 0x01dc},
+	{
+	 106, 5530, 0x40, 0x01, 0x01, 0x02, 0x29, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x3b, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x3b, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08a8, 0x08a4, 0x08a0, 0x01d9, 0x01da, 0x01db},
+	{
+	 108, 5540, 0x3a, 0x01, 0x01, 0x02, 0x2a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x3b, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x3b, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08ac, 0x08a8, 0x08a4, 0x01d8, 0x01d9, 0x01da},
+	{
+	 110, 5550, 0x3a, 0x01, 0x01, 0x02, 0x2b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x3b, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x3b, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08b0, 0x08ac, 0x08a8, 0x01d7, 0x01d8, 0x01d9},
+	{
+	 112, 5560, 0x34, 0x01, 0x01, 0x02, 0x2c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x2b, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x2b, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08b4, 0x08b0, 0x08ac, 0x01d7, 0x01d7, 0x01d8},
+	{
+	 114, 5570, 0x34, 0x01, 0x01, 0x02, 0x2d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x2a, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x2a, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08b8, 0x08b4, 0x08b0, 0x01d6, 0x01d7, 0x01d7},
+	{
+	 116, 5580, 0x2e, 0x01, 0x01, 0x02, 0x2e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x1a, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x1a, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08bc, 0x08b8, 0x08b4, 0x01d5, 0x01d6, 0x01d7},
+	{
+	 118, 5590, 0x2e, 0x01, 0x01, 0x02, 0x2f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x1a, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x1a, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08c0, 0x08bc, 0x08b8, 0x01d4, 0x01d5, 0x01d6},
+	{
+	 120, 5600, 0x28, 0x01, 0x01, 0x02, 0x30, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x1a, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x1a, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08c4, 0x08c0, 0x08bc, 0x01d3, 0x01d4, 0x01d5},
+	{
+	 122, 5610, 0x28, 0x01, 0x01, 0x02, 0x31, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x19, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x19, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08c8, 0x08c4, 0x08c0, 0x01d2, 0x01d3, 0x01d4},
+	{
+	 124, 5620, 0x21, 0x01, 0x01, 0x02, 0x32, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x19, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x19, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08cc, 0x08c8, 0x08c4, 0x01d2, 0x01d2, 0x01d3},
+	{
+	 126, 5630, 0x21, 0x01, 0x01, 0x02, 0x33, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x09, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x09, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08d0, 0x08cc, 0x08c8, 0x01d1, 0x01d2, 0x01d2},
+	{
+	 128, 5640, 0x1c, 0x01, 0x01, 0x02, 0x34, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x09, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x09, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08d4, 0x08d0, 0x08cc, 0x01d0, 0x01d1, 0x01d2},
+	{
+	 130, 5650, 0x1c, 0x01, 0x01, 0x02, 0x35, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf8, 0x00, 0x08, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf8, 0x00, 0x08d8, 0x08d4, 0x08d0, 0x01cf, 0x01d0, 0x01d1},
+	{
+	 132, 5660, 0x16, 0x01, 0x01, 0x02, 0x36, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf6, 0x00, 0x08, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf6, 0x00, 0x08dc, 0x08d8, 0x08d4, 0x01ce, 0x01cf, 0x01d0},
+	{
+	 134, 5670, 0x16, 0x01, 0x01, 0x02, 0x37, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf6, 0x00, 0x08, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf6, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce, 0x01ce, 0x01cf},
+	{
+	 136, 5680, 0x10, 0x01, 0x01, 0x02, 0x38, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf6, 0x00, 0x08, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf6, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd, 0x01ce, 0x01ce},
+	{
+	 138, 5690, 0x10, 0x01, 0x01, 0x02, 0x39, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x07, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf6, 0x00, 0x07, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf6, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc, 0x01cd, 0x01ce},
+	{
+	 140, 5700, 0x0a, 0x01, 0x01, 0x02, 0x3a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x07, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf6, 0x00, 0x07, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf6, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb, 0x01cc, 0x01cd},
+	{
+	 142, 5710, 0x0a, 0x01, 0x01, 0x02, 0x3b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x07, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x07, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca, 0x01cb, 0x01cc},
+	{
+	 144, 5720, 0x0a, 0x01, 0x01, 0x02, 0x3c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x07, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x07, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 145, 5725, 0x03, 0x01, 0x02, 0x04, 0x79, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x06, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 146, 5730, 0x0a, 0x01, 0x01, 0x02, 0x3d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x06, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9, 0x01c9, 0x01ca},
+	{
+	 147, 5735, 0x03, 0x01, 0x02, 0x04, 0x7b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x06, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8, 0x01c9, 0x01ca},
+	{
+	 148, 5740, 0x0a, 0x01, 0x01, 0x02, 0x3e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x06, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8, 0x01c9, 0x01c9},
+	{
+	 149, 5745, 0xfe, 0x00, 0x02, 0x04, 0x7d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x06, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8, 0x01c8, 0x01c9},
+	{
+	 150, 5750, 0x0a, 0x01, 0x01, 0x02, 0x3f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x06, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7, 0x01c8, 0x01c9},
+	{
+	 151, 5755, 0xfe, 0x00, 0x02, 0x04, 0x7f, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x05, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7, 0x01c8, 0x01c8},
+	{
+	 152, 5760, 0x0a, 0x01, 0x01, 0x02, 0x40, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x05, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 153, 5765, 0xf8, 0x00, 0x02, 0x04, 0x81, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x05, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 154, 5770, 0x0a, 0x01, 0x01, 0x02, 0x41, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x05, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6, 0x01c6, 0x01c7},
+	{
+	 155, 5775, 0xf8, 0x00, 0x02, 0x04, 0x83, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x05, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5, 0x01c6, 0x01c7},
+	{
+	 156, 5780, 0x0a, 0x01, 0x01, 0x02, 0x42, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x05, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5, 0x01c6, 0x01c6},
+	{
+	 157, 5785, 0xf2, 0x00, 0x02, 0x04, 0x85, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x04, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 158, 5790, 0x0a, 0x01, 0x01, 0x02, 0x43, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x04, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 159, 5795, 0xf2, 0x00, 0x02, 0x04, 0x87, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x04, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4, 0x01c4, 0x01c5},
+	{
+	 160, 5800, 0x0a, 0x01, 0x01, 0x02, 0x44, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3, 0x01c4, 0x01c5},
+	{
+	 161, 5805, 0xed, 0x00, 0x02, 0x04, 0x89, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3, 0x01c4, 0x01c4},
+	{
+	 162, 5810, 0x0a, 0x01, 0x01, 0x02, 0x45, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 163, 5815, 0xed, 0x00, 0x02, 0x04, 0x8b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 164, 5820, 0x0a, 0x01, 0x01, 0x02, 0x46, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x03, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2, 0x01c2, 0x01c3},
+	{
+	 165, 5825, 0xed, 0x00, 0x02, 0x04, 0x8d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x03, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1, 0x01c2, 0x01c3},
+	{
+	 166, 5830, 0x0a, 0x01, 0x01, 0x02, 0x47, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x03, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1, 0x01c2, 0x01c2},
+	{
+	 168, 5840, 0x0a, 0x01, 0x01, 0x02, 0x48, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x03, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0, 0x01c1, 0x01c2},
+	{
+	 170, 5850, 0xe0, 0x00, 0x01, 0x02, 0x49, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf4, 0x00, 0x03, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf4, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf, 0x01c0, 0x01c1},
+	{
+	 172, 5860, 0xde, 0x00, 0x01, 0x02, 0x4a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf2, 0x00, 0x03, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf2, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf, 0x01bf, 0x01c0},
+	{
+	 174, 5870, 0xdb, 0x00, 0x01, 0x02, 0x4b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x02, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf2, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf2, 0x00, 0x0930, 0x092c, 0x0928, 0x01be, 0x01bf, 0x01bf},
+	{
+	 176, 5880, 0xd8, 0x00, 0x01, 0x02, 0x4c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x02, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf2, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf2, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd, 0x01be, 0x01bf},
+	{
+	 178, 5890, 0xd6, 0x00, 0x01, 0x02, 0x4d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x02, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x06, 0x00, 0xf2, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x06,
+	 0x00, 0xf2, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc, 0x01bd, 0x01be},
+	{
+	 180, 5900, 0xd3, 0x00, 0x01, 0x02, 0x4e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x87, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x05, 0x00, 0xf2, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x05,
+	 0x00, 0xf2, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc, 0x01bc, 0x01bd},
+	{
+	 182, 5910, 0xd6, 0x00, 0x01, 0x02, 0x4f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x87, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x05, 0x00, 0xf2, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x05,
+	 0x00, 0xf2, 0x00, 0x0940, 0x093c, 0x0938, 0x01bb, 0x01bc, 0x01bc},
+	{
+	 1, 2412, 0x00, 0x01, 0x03, 0x09, 0x6c, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x04, 0x04, 0x04, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xff, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xff, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03c9, 0x03c5, 0x03c1, 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x00, 0x01, 0x03, 0x09, 0x71, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xff, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xff, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03cb, 0x03c7, 0x03c3, 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x00, 0x01, 0x03, 0x09, 0x76, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xff, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xff, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03cd, 0x03c9, 0x03c5, 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x00, 0x01, 0x03, 0x09, 0x7b, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xfd, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03cf, 0x03cb, 0x03c7, 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x00, 0x01, 0x03, 0x09, 0x80, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xfb, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xfb, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03d1, 0x03cd, 0x03c9, 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x00, 0x01, 0x03, 0x09, 0x85, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xfa, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03d3, 0x03cf, 0x03cb, 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x00, 0x01, 0x03, 0x09, 0x8a, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03d5, 0x03d1, 0x03cd, 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x00, 0x01, 0x03, 0x09, 0x8f, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xf7, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03d7, 0x03d3, 0x03cf, 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x00, 0x01, 0x03, 0x09, 0x94, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0f, 0x00, 0xf6, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0f, 0x03d9, 0x03d5, 0x03d1, 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x00, 0x01, 0x03, 0x09, 0x99, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf5, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0d, 0x00, 0xf5, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0d, 0x03db, 0x03d7, 0x03d3, 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x00, 0x01, 0x03, 0x09, 0x9e, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf4, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0d, 0x00, 0xf4, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0d, 0x03dd, 0x03d9, 0x03d5, 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x00, 0x01, 0x03, 0x09, 0xa3, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf3, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0d, 0x00, 0xf3, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0d, 0x03df, 0x03db, 0x03d7, 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x00, 0x01, 0x03, 0x09, 0xa8, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf2, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0d, 0x00, 0xf2, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0d, 0x03e1, 0x03dd, 0x03d9, 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0xff, 0x01, 0x03, 0x09, 0xb4, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x05, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0d, 0x00, 0xf0, 0x00, 0x05, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0d, 0x03e6, 0x03e2, 0x03de, 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio205x_t chan_info_nphyrev4_2056_A1[] = {
+	{
+	 184, 4920, 0xff, 0x01, 0x01, 0x01, 0xec, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07b4, 0x07b0, 0x07ac, 0x0214, 0x0215, 0x0216},
+	{
+	 186, 4930, 0xff, 0x01, 0x01, 0x01, 0xed, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07b8, 0x07b4, 0x07b0, 0x0213, 0x0214, 0x0215},
+	{
+	 188, 4940, 0xff, 0x01, 0x01, 0x01, 0xee, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07bc, 0x07b8, 0x07b4, 0x0212, 0x0213, 0x0214},
+	{
+	 190, 4950, 0xff, 0x01, 0x01, 0x01, 0xef, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07c0, 0x07bc, 0x07b8, 0x0211, 0x0212, 0x0213},
+	{
+	 192, 4960, 0xff, 0x01, 0x01, 0x01, 0xf0, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07c4, 0x07c0, 0x07bc, 0x020f, 0x0211, 0x0212},
+	{
+	 194, 4970, 0xff, 0x01, 0x01, 0x01, 0xf1, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07c8, 0x07c4, 0x07c0, 0x020e, 0x020f, 0x0211},
+	{
+	 196, 4980, 0xff, 0x01, 0x01, 0x01, 0xf2, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07cc, 0x07c8, 0x07c4, 0x020d, 0x020e, 0x020f},
+	{
+	 198, 4990, 0xff, 0x01, 0x01, 0x01, 0xf3, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0e, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0e, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07d0, 0x07cc, 0x07c8, 0x020c, 0x020d, 0x020e},
+	{
+	 200, 5000, 0xff, 0x01, 0x01, 0x01, 0xf4, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07d4, 0x07d0, 0x07cc, 0x020b, 0x020c, 0x020d},
+	{
+	 202, 5010, 0xff, 0x01, 0x01, 0x01, 0xf5, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07d8, 0x07d4, 0x07d0, 0x020a, 0x020b, 0x020c},
+	{
+	 204, 5020, 0xf7, 0x01, 0x01, 0x01, 0xf6, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07dc, 0x07d8, 0x07d4, 0x0209, 0x020a, 0x020b},
+	{
+	 206, 5030, 0xf7, 0x01, 0x01, 0x01, 0xf7, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07e0, 0x07dc, 0x07d8, 0x0208, 0x0209, 0x020a},
+	{
+	 208, 5040, 0xef, 0x01, 0x01, 0x01, 0xf8, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07e4, 0x07e0, 0x07dc, 0x0207, 0x0208, 0x0209},
+	{
+	 210, 5050, 0xef, 0x01, 0x01, 0x01, 0xf9, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07e8, 0x07e4, 0x07e0, 0x0206, 0x0207, 0x0208},
+	{
+	 212, 5060, 0xe6, 0x01, 0x01, 0x01, 0xfa, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07ec, 0x07e8, 0x07e4, 0x0205, 0x0206, 0x0207},
+	{
+	 214, 5070, 0xe6, 0x01, 0x01, 0x01, 0xfb, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07f0, 0x07ec, 0x07e8, 0x0204, 0x0205, 0x0206},
+	{
+	 216, 5080, 0xde, 0x01, 0x01, 0x01, 0xfc, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07f4, 0x07f0, 0x07ec, 0x0203, 0x0204, 0x0205},
+	{
+	 218, 5090, 0xde, 0x01, 0x01, 0x01, 0xfd, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0d, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xff, 0x00, 0x0d, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xff, 0x00, 0x07f8, 0x07f4, 0x07f0, 0x0202, 0x0203, 0x0204},
+	{
+	 220, 5100, 0xd6, 0x01, 0x01, 0x01, 0xfe, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xff, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x07fc, 0x07f8, 0x07f4, 0x0201, 0x0202, 0x0203},
+	{
+	 222, 5110, 0xd6, 0x01, 0x01, 0x01, 0xff, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xff, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x0800, 0x07fc, 0x07f8, 0x0200, 0x0201, 0x0202},
+	{
+	 224, 5120, 0xce, 0x01, 0x01, 0x02, 0x00, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xff, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x0804, 0x0800, 0x07fc, 0x01ff, 0x0200, 0x0201},
+	{
+	 226, 5130, 0xce, 0x01, 0x01, 0x02, 0x01, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xff, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x0808, 0x0804, 0x0800, 0x01fe, 0x01ff, 0x0200},
+	{
+	 228, 5140, 0xc6, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xff, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x080c, 0x0808, 0x0804, 0x01fd, 0x01fe, 0x01ff},
+	{
+	 32, 5160, 0xbe, 0x01, 0x01, 0x02, 0x04, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xff, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x0814, 0x0810, 0x080c, 0x01fb, 0x01fc, 0x01fd},
+	{
+	 34, 5170, 0xbe, 0x01, 0x01, 0x02, 0x05, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xff, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x0818, 0x0814, 0x0810, 0x01fa, 0x01fb, 0x01fc},
+	{
+	 36, 5180, 0xb6, 0x01, 0x01, 0x02, 0x06, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xef, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xef, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x081c, 0x0818, 0x0814, 0x01f9, 0x01fa, 0x01fb},
+	{
+	 38, 5190, 0xb6, 0x01, 0x01, 0x02, 0x07, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xef, 0x00, 0x0c, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfe, 0x00, 0xef, 0x00, 0x0c, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfe, 0x00, 0x0820, 0x081c, 0x0818, 0x01f8, 0x01f9, 0x01fa},
+	{
+	 40, 5200, 0xaf, 0x01, 0x01, 0x02, 0x08, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xef, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xef, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0824, 0x0820, 0x081c, 0x01f7, 0x01f8, 0x01f9},
+	{
+	 42, 5210, 0xaf, 0x01, 0x01, 0x02, 0x09, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xdf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xdf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0828, 0x0824, 0x0820, 0x01f6, 0x01f7, 0x01f8},
+	{
+	 44, 5220, 0xa7, 0x01, 0x01, 0x02, 0x0a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xdf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xdf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x082c, 0x0828, 0x0824, 0x01f5, 0x01f6, 0x01f7},
+	{
+	 46, 5230, 0xa7, 0x01, 0x01, 0x02, 0x0b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xdf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xdf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0830, 0x082c, 0x0828, 0x01f4, 0x01f5, 0x01f6},
+	{
+	 48, 5240, 0xa0, 0x01, 0x01, 0x02, 0x0c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0834, 0x0830, 0x082c, 0x01f3, 0x01f4, 0x01f5},
+	{
+	 50, 5250, 0xa0, 0x01, 0x01, 0x02, 0x0d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0838, 0x0834, 0x0830, 0x01f2, 0x01f3, 0x01f4},
+	{
+	 52, 5260, 0x98, 0x01, 0x01, 0x02, 0x0e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x083c, 0x0838, 0x0834, 0x01f1, 0x01f2, 0x01f3},
+	{
+	 54, 5270, 0x98, 0x01, 0x01, 0x02, 0x0f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xcf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xcf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0840, 0x083c, 0x0838, 0x01f0, 0x01f1, 0x01f2},
+	{
+	 56, 5280, 0x91, 0x01, 0x01, 0x02, 0x10, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xbf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xbf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0844, 0x0840, 0x083c, 0x01f0, 0x01f0, 0x01f1},
+	{
+	 58, 5290, 0x91, 0x01, 0x01, 0x02, 0x11, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xbf, 0x00, 0x0a, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfc, 0x00, 0xbf, 0x00, 0x0a, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfc, 0x00, 0x0848, 0x0844, 0x0840, 0x01ef, 0x01f0, 0x01f0},
+	{
+	 60, 5300, 0x8a, 0x01, 0x01, 0x02, 0x12, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xbf, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0xbf, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x084c, 0x0848, 0x0844, 0x01ee, 0x01ef, 0x01f0},
+	{
+	 62, 5310, 0x8a, 0x01, 0x01, 0x02, 0x13, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xbf, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0xbf, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x0850, 0x084c, 0x0848, 0x01ed, 0x01ee, 0x01ef},
+	{
+	 64, 5320, 0x83, 0x01, 0x01, 0x02, 0x14, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xbf, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0xbf, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x0854, 0x0850, 0x084c, 0x01ec, 0x01ed, 0x01ee},
+	{
+	 66, 5330, 0x83, 0x01, 0x01, 0x02, 0x15, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xaf, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0xaf, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x0858, 0x0854, 0x0850, 0x01eb, 0x01ec, 0x01ed},
+	{
+	 68, 5340, 0x7c, 0x01, 0x01, 0x02, 0x16, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xaf, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0xaf, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x085c, 0x0858, 0x0854, 0x01ea, 0x01eb, 0x01ec},
+	{
+	 70, 5350, 0x7c, 0x01, 0x01, 0x02, 0x17, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x0860, 0x085c, 0x0858, 0x01e9, 0x01ea, 0x01eb},
+	{
+	 72, 5360, 0x75, 0x01, 0x01, 0x02, 0x18, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x0864, 0x0860, 0x085c, 0x01e8, 0x01e9, 0x01ea},
+	{
+	 74, 5370, 0x75, 0x01, 0x01, 0x02, 0x19, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x0868, 0x0864, 0x0860, 0x01e7, 0x01e8, 0x01e9},
+	{
+	 76, 5380, 0x6e, 0x01, 0x01, 0x02, 0x1a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x9f, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0x9f, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x086c, 0x0868, 0x0864, 0x01e6, 0x01e7, 0x01e8},
+	{
+	 78, 5390, 0x6e, 0x01, 0x01, 0x02, 0x1b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x8f, 0x00, 0x08, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xfa, 0x00, 0x8f, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xfa, 0x00, 0x0870, 0x086c, 0x0868, 0x01e5, 0x01e6, 0x01e7},
+	{
+	 80, 5400, 0x67, 0x01, 0x01, 0x02, 0x1c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8f, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x8f, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0874, 0x0870, 0x086c, 0x01e5, 0x01e5, 0x01e6},
+	{
+	 82, 5410, 0x67, 0x01, 0x01, 0x02, 0x1d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8f, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x8f, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0878, 0x0874, 0x0870, 0x01e4, 0x01e5, 0x01e5},
+	{
+	 84, 5420, 0x61, 0x01, 0x01, 0x02, 0x1e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8e, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x8e, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x087c, 0x0878, 0x0874, 0x01e3, 0x01e4, 0x01e5},
+	{
+	 86, 5430, 0x61, 0x01, 0x01, 0x02, 0x1f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x8e, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x8e, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0880, 0x087c, 0x0878, 0x01e2, 0x01e3, 0x01e4},
+	{
+	 88, 5440, 0x5a, 0x01, 0x01, 0x02, 0x20, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x7e, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x7e, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0884, 0x0880, 0x087c, 0x01e1, 0x01e2, 0x01e3},
+	{
+	 90, 5450, 0x5a, 0x01, 0x01, 0x02, 0x21, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x7d, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x7d, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0888, 0x0884, 0x0880, 0x01e0, 0x01e1, 0x01e2},
+	{
+	 92, 5460, 0x53, 0x01, 0x01, 0x02, 0x22, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x6d, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x6d, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x088c, 0x0888, 0x0884, 0x01df, 0x01e0, 0x01e1},
+	{
+	 94, 5470, 0x53, 0x01, 0x01, 0x02, 0x23, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x6d, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x6d, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0890, 0x088c, 0x0888, 0x01de, 0x01df, 0x01e0},
+	{
+	 96, 5480, 0x4d, 0x01, 0x01, 0x02, 0x24, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x5d, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x5d, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0894, 0x0890, 0x088c, 0x01dd, 0x01de, 0x01df},
+	{
+	 98, 5490, 0x4d, 0x01, 0x01, 0x02, 0x25, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x5c, 0x00, 0x07, 0x00, 0x7f,
+	 0x00, 0x0f, 0x00, 0xf8, 0x00, 0x5c, 0x00, 0x07, 0x00, 0x7f, 0x00, 0x0f,
+	 0x00, 0xf8, 0x00, 0x0898, 0x0894, 0x0890, 0x01dd, 0x01dd, 0x01de},
+	{
+	 100, 5500, 0x47, 0x01, 0x01, 0x02, 0x26, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x5c, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x5c, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x089c, 0x0898, 0x0894, 0x01dc, 0x01dd, 0x01dd},
+	{
+	 102, 5510, 0x47, 0x01, 0x01, 0x02, 0x27, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x4c, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x4c, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08a0, 0x089c, 0x0898, 0x01db, 0x01dc, 0x01dd},
+	{
+	 104, 5520, 0x40, 0x01, 0x01, 0x02, 0x28, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x4c, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x4c, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08a4, 0x08a0, 0x089c, 0x01da, 0x01db, 0x01dc},
+	{
+	 106, 5530, 0x40, 0x01, 0x01, 0x02, 0x29, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x3b, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x3b, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08a8, 0x08a4, 0x08a0, 0x01d9, 0x01da, 0x01db},
+	{
+	 108, 5540, 0x3a, 0x01, 0x01, 0x02, 0x2a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x3b, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x3b, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08ac, 0x08a8, 0x08a4, 0x01d8, 0x01d9, 0x01da},
+	{
+	 110, 5550, 0x3a, 0x01, 0x01, 0x02, 0x2b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x3b, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x3b, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08b0, 0x08ac, 0x08a8, 0x01d7, 0x01d8, 0x01d9},
+	{
+	 112, 5560, 0x34, 0x01, 0x01, 0x02, 0x2c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x2b, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x2b, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08b4, 0x08b0, 0x08ac, 0x01d7, 0x01d7, 0x01d8},
+	{
+	 114, 5570, 0x34, 0x01, 0x01, 0x02, 0x2d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x2a, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x2a, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08b8, 0x08b4, 0x08b0, 0x01d6, 0x01d7, 0x01d7},
+	{
+	 116, 5580, 0x2e, 0x01, 0x01, 0x02, 0x2e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x1a, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x1a, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08bc, 0x08b8, 0x08b4, 0x01d5, 0x01d6, 0x01d7},
+	{
+	 118, 5590, 0x2e, 0x01, 0x01, 0x02, 0x2f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x1a, 0x00, 0x06, 0x00, 0x7f,
+	 0x00, 0x0d, 0x00, 0xf6, 0x00, 0x1a, 0x00, 0x06, 0x00, 0x7f, 0x00, 0x0d,
+	 0x00, 0xf6, 0x00, 0x08c0, 0x08bc, 0x08b8, 0x01d4, 0x01d5, 0x01d6},
+	{
+	 120, 5600, 0x28, 0x01, 0x01, 0x02, 0x30, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x1a, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x1a, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08c4, 0x08c0, 0x08bc, 0x01d3, 0x01d4, 0x01d5},
+	{
+	 122, 5610, 0x28, 0x01, 0x01, 0x02, 0x31, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x19, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x19, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08c8, 0x08c4, 0x08c0, 0x01d2, 0x01d3, 0x01d4},
+	{
+	 124, 5620, 0x21, 0x01, 0x01, 0x02, 0x32, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x19, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x19, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08cc, 0x08c8, 0x08c4, 0x01d2, 0x01d2, 0x01d3},
+	{
+	 126, 5630, 0x21, 0x01, 0x01, 0x02, 0x33, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x09, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x09, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08d0, 0x08cc, 0x08c8, 0x01d1, 0x01d2, 0x01d2},
+	{
+	 128, 5640, 0x1c, 0x01, 0x01, 0x02, 0x34, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x09, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x09, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08d4, 0x08d0, 0x08cc, 0x01d0, 0x01d1, 0x01d2},
+	{
+	 130, 5650, 0x1c, 0x01, 0x01, 0x02, 0x35, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x08, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08d8, 0x08d4, 0x08d0, 0x01cf, 0x01d0, 0x01d1},
+	{
+	 132, 5660, 0x16, 0x01, 0x01, 0x02, 0x36, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x08, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08dc, 0x08d8, 0x08d4, 0x01ce, 0x01cf, 0x01d0},
+	{
+	 134, 5670, 0x16, 0x01, 0x01, 0x02, 0x37, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x08, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce, 0x01ce, 0x01cf},
+	{
+	 136, 5680, 0x10, 0x01, 0x01, 0x02, 0x38, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x08, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x08, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd, 0x01ce, 0x01ce},
+	{
+	 138, 5690, 0x10, 0x01, 0x01, 0x02, 0x39, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x07, 0x00, 0x04, 0x00, 0x7f,
+	 0x00, 0x0b, 0x00, 0xf4, 0x00, 0x07, 0x00, 0x04, 0x00, 0x7f, 0x00, 0x0b,
+	 0x00, 0xf4, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc, 0x01cd, 0x01ce},
+	{
+	 140, 5700, 0x0a, 0x01, 0x01, 0x02, 0x3a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x07, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x07, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb, 0x01cc, 0x01cd},
+	{
+	 142, 5710, 0x0a, 0x01, 0x01, 0x02, 0x3b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x07, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x07, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca, 0x01cb, 0x01cc},
+	{
+	 144, 5720, 0x0a, 0x01, 0x01, 0x02, 0x3c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x07, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x07, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 145, 5725, 0x03, 0x01, 0x02, 0x04, 0x79, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x06, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 146, 5730, 0x0a, 0x01, 0x01, 0x02, 0x3d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x06, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9, 0x01c9, 0x01ca},
+	{
+	 147, 5735, 0x03, 0x01, 0x02, 0x04, 0x7b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x06, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8, 0x01c9, 0x01ca},
+	{
+	 148, 5740, 0x0a, 0x01, 0x01, 0x02, 0x3e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x06, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8, 0x01c9, 0x01c9},
+	{
+	 149, 5745, 0xfe, 0x00, 0x02, 0x04, 0x7d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x06, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8, 0x01c8, 0x01c9},
+	{
+	 150, 5750, 0x0a, 0x01, 0x01, 0x02, 0x3f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x06, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x06, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7, 0x01c8, 0x01c9},
+	{
+	 151, 5755, 0xfe, 0x00, 0x02, 0x04, 0x7f, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x05, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7, 0x01c8, 0x01c8},
+	{
+	 152, 5760, 0x0a, 0x01, 0x01, 0x02, 0x40, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x05, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 153, 5765, 0xf8, 0x00, 0x02, 0x04, 0x81, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x05, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 154, 5770, 0x0a, 0x01, 0x01, 0x02, 0x41, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x05, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6, 0x01c6, 0x01c7},
+	{
+	 155, 5775, 0xf8, 0x00, 0x02, 0x04, 0x83, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x05, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5, 0x01c6, 0x01c7},
+	{
+	 156, 5780, 0x0a, 0x01, 0x01, 0x02, 0x42, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x05, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x05, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5, 0x01c6, 0x01c6},
+	{
+	 157, 5785, 0xf2, 0x00, 0x02, 0x04, 0x85, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x04, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x04, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 158, 5790, 0x0a, 0x01, 0x01, 0x02, 0x43, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x04, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x04, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 159, 5795, 0xf2, 0x00, 0x02, 0x04, 0x87, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x04, 0x00, 0x03, 0x00, 0x7f,
+	 0x00, 0x0a, 0x00, 0xf2, 0x00, 0x04, 0x00, 0x03, 0x00, 0x7f, 0x00, 0x0a,
+	 0x00, 0xf2, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4, 0x01c4, 0x01c5},
+	{
+	 160, 5800, 0x0a, 0x01, 0x01, 0x02, 0x44, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x04, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3, 0x01c4, 0x01c5},
+	{
+	 161, 5805, 0xed, 0x00, 0x02, 0x04, 0x89, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x04, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3, 0x01c4, 0x01c4},
+	{
+	 162, 5810, 0x0a, 0x01, 0x01, 0x02, 0x45, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x04, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 163, 5815, 0xed, 0x00, 0x02, 0x04, 0x8b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x04, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x04, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 164, 5820, 0x0a, 0x01, 0x01, 0x02, 0x46, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x03, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2, 0x01c2, 0x01c3},
+	{
+	 165, 5825, 0xed, 0x00, 0x02, 0x04, 0x8d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x03, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1, 0x01c2, 0x01c3},
+	{
+	 166, 5830, 0x0a, 0x01, 0x01, 0x02, 0x47, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x03, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1, 0x01c2, 0x01c2},
+	{
+	 168, 5840, 0x0a, 0x01, 0x01, 0x02, 0x48, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x03, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0, 0x01c1, 0x01c2},
+	{
+	 170, 5850, 0xe0, 0x00, 0x01, 0x02, 0x49, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x03, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf, 0x01c0, 0x01c1},
+	{
+	 172, 5860, 0xde, 0x00, 0x01, 0x02, 0x4a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x03, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x03, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf, 0x01bf, 0x01c0},
+	{
+	 174, 5870, 0xdb, 0x00, 0x01, 0x02, 0x4b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x02, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x02, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0930, 0x092c, 0x0928, 0x01be, 0x01bf, 0x01bf},
+	{
+	 176, 5880, 0xd8, 0x00, 0x01, 0x02, 0x4c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x02, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x02, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd, 0x01be, 0x01bf},
+	{
+	 178, 5890, 0xd6, 0x00, 0x01, 0x02, 0x4d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x02, 0x00, 0x02, 0x00, 0x7f,
+	 0x00, 0x09, 0x00, 0xf0, 0x00, 0x02, 0x00, 0x02, 0x00, 0x7f, 0x00, 0x09,
+	 0x00, 0xf0, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc, 0x01bd, 0x01be},
+	{
+	 180, 5900, 0xd3, 0x00, 0x01, 0x02, 0x4e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x87, 0x03, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf0, 0x00, 0x02, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf0, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc, 0x01bc, 0x01bd},
+	{
+	 182, 5910, 0xd6, 0x00, 0x01, 0x02, 0x4f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x87, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7f,
+	 0x00, 0x07, 0x00, 0xf0, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x07,
+	 0x00, 0xf0, 0x00, 0x0940, 0x093c, 0x0938, 0x01bb, 0x01bc, 0x01bc},
+	{
+	 1, 2412, 0x00, 0x01, 0x03, 0x09, 0x6c, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x04, 0x04, 0x04, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xff, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xff, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03c9, 0x03c5, 0x03c1, 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x00, 0x01, 0x03, 0x09, 0x71, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xff, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xff, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03cb, 0x03c7, 0x03c3, 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x00, 0x01, 0x03, 0x09, 0x76, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xff, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xff, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03cd, 0x03c9, 0x03c5, 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x00, 0x01, 0x03, 0x09, 0x7b, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xfd, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03cf, 0x03cb, 0x03c7, 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x00, 0x01, 0x03, 0x09, 0x80, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xfb, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xfb, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03d1, 0x03cd, 0x03c9, 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x00, 0x01, 0x03, 0x09, 0x85, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xfa, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03d3, 0x03cf, 0x03cb, 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x00, 0x01, 0x03, 0x09, 0x8a, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf8, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03d5, 0x03d1, 0x03cd, 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x00, 0x01, 0x03, 0x09, 0x8f, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf7, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf7, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03d7, 0x03d3, 0x03cf, 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x00, 0x01, 0x03, 0x09, 0x94, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf6, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03d9, 0x03d5, 0x03d1, 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x00, 0x01, 0x03, 0x09, 0x99, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf5, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf5, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03db, 0x03d7, 0x03d3, 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x00, 0x01, 0x03, 0x09, 0x9e, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf4, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf4, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03dd, 0x03d9, 0x03d5, 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x00, 0x01, 0x03, 0x09, 0xa3, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf3, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf3, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03df, 0x03db, 0x03d7, 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x00, 0x01, 0x03, 0x09, 0xa8, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf2, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf2, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03e1, 0x03dd, 0x03d9, 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0xff, 0x01, 0x03, 0x09, 0xb4, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x04, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0e, 0x00, 0xf0, 0x00, 0x04, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0e, 0x03e6, 0x03e2, 0x03de, 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio205x_t chan_info_nphyrev5_2056v5[] = {
+	{
+	 184, 4920, 0xff, 0x01, 0x01, 0x01, 0xec, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0f, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b4, 0x07b0, 0x07ac, 0x0214, 0x0215, 0x0216},
+	{
+	 186, 4930, 0xff, 0x01, 0x01, 0x01, 0xed, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07b8, 0x07b4, 0x07b0, 0x0213, 0x0214, 0x0215},
+	{
+	 188, 4940, 0xff, 0x01, 0x01, 0x01, 0xee, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07bc, 0x07b8, 0x07b4, 0x0212, 0x0213, 0x0214},
+	{
+	 190, 4950, 0xff, 0x01, 0x01, 0x01, 0xef, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07c0, 0x07bc, 0x07b8, 0x0211, 0x0212, 0x0213},
+	{
+	 192, 4960, 0xff, 0x01, 0x01, 0x01, 0xf0, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07c4, 0x07c0, 0x07bc, 0x020f, 0x0211, 0x0212},
+	{
+	 194, 4970, 0xff, 0x01, 0x01, 0x01, 0xf1, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07c8, 0x07c4, 0x07c0, 0x020e, 0x020f, 0x0211},
+	{
+	 196, 4980, 0xff, 0x01, 0x01, 0x01, 0xf2, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07cc, 0x07c8, 0x07c4, 0x020d, 0x020e, 0x020f},
+	{
+	 198, 4990, 0xff, 0x01, 0x01, 0x01, 0xf3, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07d0, 0x07cc, 0x07c8, 0x020c, 0x020d, 0x020e},
+	{
+	 200, 5000, 0xff, 0x01, 0x01, 0x01, 0xf4, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07d4, 0x07d0, 0x07cc, 0x020b, 0x020c, 0x020d},
+	{
+	 202, 5010, 0xff, 0x01, 0x01, 0x01, 0xf5, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07d8, 0x07d4, 0x07d0, 0x020a, 0x020b, 0x020c},
+	{
+	 204, 5020, 0xf7, 0x01, 0x01, 0x01, 0xf6, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07dc, 0x07d8, 0x07d4, 0x0209, 0x020a, 0x020b},
+	{
+	 206, 5030, 0xf7, 0x01, 0x01, 0x01, 0xf7, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07e0, 0x07dc, 0x07d8, 0x0208, 0x0209, 0x020a},
+	{
+	 208, 5040, 0xef, 0x01, 0x01, 0x01, 0xf8, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07e4, 0x07e0, 0x07dc, 0x0207, 0x0208, 0x0209},
+	{
+	 210, 5050, 0xef, 0x01, 0x01, 0x01, 0xf9, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07e8, 0x07e4, 0x07e0, 0x0206, 0x0207, 0x0208},
+	{
+	 212, 5060, 0xe6, 0x01, 0x01, 0x01, 0xfa, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07ec, 0x07e8, 0x07e4, 0x0205, 0x0206, 0x0207},
+	{
+	 214, 5070, 0xe6, 0x01, 0x01, 0x01, 0xfb, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfd, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07f0, 0x07ec, 0x07e8, 0x0204, 0x0205, 0x0206},
+	{
+	 216, 5080, 0xde, 0x01, 0x01, 0x01, 0xfc, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07f4, 0x07f0, 0x07ec, 0x0203, 0x0204, 0x0205},
+	{
+	 218, 5090, 0xde, 0x01, 0x01, 0x01, 0xfd, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07f8, 0x07f4, 0x07f0, 0x0202, 0x0203, 0x0204},
+	{
+	 220, 5100, 0xd6, 0x01, 0x01, 0x01, 0xfe, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07fc, 0x07f8, 0x07f4, 0x0201, 0x0202, 0x0203},
+	{
+	 222, 5110, 0xd6, 0x01, 0x01, 0x01, 0xff, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0800, 0x07fc, 0x07f8, 0x0200, 0x0201, 0x0202},
+	{
+	 224, 5120, 0xce, 0x01, 0x01, 0x02, 0x00, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0804, 0x0800, 0x07fc, 0x01ff, 0x0200, 0x0201},
+	{
+	 226, 5130, 0xce, 0x01, 0x01, 0x02, 0x01, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0a, 0x00, 0x9f, 0x00, 0xfb, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0808, 0x0804, 0x0800, 0x01fe, 0x01ff, 0x0200},
+	{
+	 228, 5140, 0xc6, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x07, 0x00, 0x70,
+	 0x00, 0x0a, 0x00, 0x9f, 0x00, 0xfb, 0x00, 0x07, 0x00, 0x70, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x080c, 0x0808, 0x0804, 0x01fd, 0x01fe, 0x01ff},
+	{
+	 32, 5160, 0xbe, 0x01, 0x01, 0x02, 0x04, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x07, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfb, 0x00, 0x07, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0814, 0x0810, 0x080c, 0x01fb, 0x01fc, 0x01fd},
+	{
+	 34, 5170, 0xbe, 0x01, 0x01, 0x02, 0x05, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfb, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0818, 0x0814, 0x0810, 0x01fa, 0x01fb, 0x01fc},
+	{
+	 36, 5180, 0xb6, 0x01, 0x01, 0x02, 0x06, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x081c, 0x0818, 0x0814, 0x01f9, 0x01fa, 0x01fb},
+	{
+	 38, 5190, 0xb6, 0x01, 0x01, 0x02, 0x07, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0820, 0x081c, 0x0818, 0x01f8, 0x01f9, 0x01fa},
+	{
+	 40, 5200, 0xaf, 0x01, 0x01, 0x02, 0x08, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0824, 0x0820, 0x081c, 0x01f7, 0x01f8, 0x01f9},
+	{
+	 42, 5210, 0xaf, 0x01, 0x01, 0x02, 0x09, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0828, 0x0824, 0x0820, 0x01f6, 0x01f7, 0x01f8},
+	{
+	 44, 5220, 0xa7, 0x01, 0x01, 0x02, 0x0a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x082c, 0x0828, 0x0824, 0x01f5, 0x01f6, 0x01f7},
+	{
+	 46, 5230, 0xa7, 0x01, 0x01, 0x02, 0x0b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xea, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9e, 0x00, 0xea, 0x00, 0x06, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6e, 0x00, 0x0830, 0x082c, 0x0828, 0x01f4, 0x01f5, 0x01f6},
+	{
+	 48, 5240, 0xa0, 0x01, 0x01, 0x02, 0x0c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xe9, 0x00, 0x05, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9d, 0x00, 0xe9, 0x00, 0x05, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6d, 0x00, 0x0834, 0x0830, 0x082c, 0x01f3, 0x01f4, 0x01f5},
+	{
+	 50, 5250, 0xa0, 0x01, 0x01, 0x02, 0x0d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xe9, 0x00, 0x05, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9d, 0x00, 0xe9, 0x00, 0x05, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6d, 0x00, 0x0838, 0x0834, 0x0830, 0x01f2, 0x01f3, 0x01f4},
+	{
+	 52, 5260, 0x98, 0x01, 0x01, 0x02, 0x0e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xd9, 0x00, 0x05, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9d, 0x00, 0xd9, 0x00, 0x05, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6d, 0x00, 0x083c, 0x0838, 0x0834, 0x01f1, 0x01f2, 0x01f3},
+	{
+	 54, 5270, 0x98, 0x01, 0x01, 0x02, 0x0f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xd8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xd8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0840, 0x083c, 0x0838, 0x01f0, 0x01f1, 0x01f2},
+	{
+	 56, 5280, 0x91, 0x01, 0x01, 0x02, 0x10, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0844, 0x0840, 0x083c, 0x01f0, 0x01f0, 0x01f1},
+	{
+	 58, 5290, 0x91, 0x01, 0x01, 0x02, 0x11, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0f, 0x00, 0xff, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0848, 0x0844, 0x0840, 0x01ef, 0x01f0, 0x01f0},
+	{
+	 60, 5300, 0x8a, 0x01, 0x01, 0x02, 0x12, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x084c, 0x0848, 0x0844, 0x01ee, 0x01ef, 0x01f0},
+	{
+	 62, 5310, 0x8a, 0x01, 0x01, 0x02, 0x13, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0850, 0x084c, 0x0848, 0x01ed, 0x01ee, 0x01ef},
+	{
+	 64, 5320, 0x83, 0x01, 0x01, 0x02, 0x14, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xb8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xb8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0854, 0x0850, 0x084c, 0x01ec, 0x01ed, 0x01ee},
+	{
+	 66, 5330, 0x83, 0x01, 0x01, 0x02, 0x15, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xb7, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9b, 0x00, 0xb7, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6b, 0x00, 0x0858, 0x0854, 0x0850, 0x01eb, 0x01ec, 0x01ed},
+	{
+	 68, 5340, 0x7c, 0x01, 0x01, 0x02, 0x16, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xb7, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9b, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6b, 0x00, 0x085c, 0x0858, 0x0854, 0x01ea, 0x01eb, 0x01ec},
+	{
+	 70, 5350, 0x7c, 0x01, 0x01, 0x02, 0x17, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xa7, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9b, 0x00, 0xa7, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x6b, 0x00, 0x0860, 0x085c, 0x0858, 0x01e9, 0x01ea, 0x01eb},
+	{
+	 72, 5360, 0x75, 0x01, 0x01, 0x02, 0x18, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xa6, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9b, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x6b, 0x00, 0x0864, 0x0860, 0x085c, 0x01e8, 0x01e9, 0x01ea},
+	{
+	 74, 5370, 0x75, 0x01, 0x01, 0x02, 0x19, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0xa6, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9b, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x5b, 0x00, 0x0868, 0x0864, 0x0860, 0x01e7, 0x01e8, 0x01e9},
+	{
+	 76, 5380, 0x6e, 0x01, 0x01, 0x02, 0x1a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x96, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9a, 0x00, 0x96, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x5a, 0x00, 0x086c, 0x0868, 0x0864, 0x01e6, 0x01e7, 0x01e8},
+	{
+	 78, 5390, 0x6e, 0x01, 0x01, 0x02, 0x1b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8f, 0x0e, 0x00, 0xff, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x5a, 0x00, 0x0870, 0x086c, 0x0868, 0x01e5, 0x01e6, 0x01e7},
+	{
+	 80, 5400, 0x67, 0x01, 0x01, 0x02, 0x1c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x5a, 0x00, 0x0874, 0x0870, 0x086c, 0x01e5, 0x01e5, 0x01e6},
+	{
+	 82, 5410, 0x67, 0x01, 0x01, 0x02, 0x1d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x5a, 0x00, 0x0878, 0x0874, 0x0870, 0x01e4, 0x01e5, 0x01e5},
+	{
+	 84, 5420, 0x61, 0x01, 0x01, 0x02, 0x1e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x5a, 0x00, 0x087c, 0x0878, 0x0874, 0x01e3, 0x01e4, 0x01e5},
+	{
+	 86, 5430, 0x61, 0x01, 0x01, 0x02, 0x1f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xc8, 0x85, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x99, 0x00, 0x85, 0x00, 0x02, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x59, 0x00, 0x0880, 0x087c, 0x0878, 0x01e2, 0x01e3, 0x01e4},
+	{
+	 88, 5440, 0x5a, 0x01, 0x01, 0x02, 0x20, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x84, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x99, 0x00, 0x84, 0x00, 0x02, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x59, 0x00, 0x0884, 0x0880, 0x087c, 0x01e1, 0x01e2, 0x01e3},
+	{
+	 90, 5450, 0x5a, 0x01, 0x01, 0x02, 0x21, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x84, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x99, 0x00, 0x84, 0x00, 0x02, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x59, 0x00, 0x0888, 0x0884, 0x0880, 0x01e0, 0x01e1, 0x01e2},
+	{
+	 92, 5460, 0x53, 0x01, 0x01, 0x02, 0x22, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x84, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x99, 0x00, 0x84, 0x00, 0x02, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x088c, 0x0888, 0x0884, 0x01df, 0x01e0, 0x01e1},
+	{
+	 94, 5470, 0x53, 0x01, 0x01, 0x02, 0x23, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x74, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x99, 0x00, 0x74, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x0890, 0x088c, 0x0888, 0x01de, 0x01df, 0x01e0},
+	{
+	 96, 5480, 0x4d, 0x01, 0x01, 0x02, 0x24, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0894, 0x0890, 0x088c, 0x01dd, 0x01de, 0x01df},
+	{
+	 98, 5490, 0x4d, 0x01, 0x01, 0x02, 0x25, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0d, 0x00, 0xc8, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0898, 0x0894, 0x0890, 0x01dd, 0x01dd, 0x01de},
+	{
+	 100, 5500, 0x47, 0x01, 0x01, 0x02, 0x26, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x089c, 0x0898, 0x0894, 0x01dc, 0x01dd, 0x01dd},
+	{
+	 102, 5510, 0x47, 0x01, 0x01, 0x02, 0x27, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x08a0, 0x089c, 0x0898, 0x01db, 0x01dc, 0x01dd},
+	{
+	 104, 5520, 0x40, 0x01, 0x01, 0x02, 0x28, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x08a4, 0x08a0, 0x089c, 0x01da, 0x01db, 0x01dc},
+	{
+	 106, 5530, 0x40, 0x01, 0x01, 0x02, 0x29, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x63, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x98, 0x00, 0x63, 0x00, 0x01, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x78, 0x00, 0x08a8, 0x08a4, 0x08a0, 0x01d9, 0x01da, 0x01db},
+	{
+	 108, 5540, 0x3a, 0x01, 0x01, 0x02, 0x2a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x62, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x97, 0x00, 0x62, 0x00, 0x00, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x77, 0x00, 0x08ac, 0x08a8, 0x08a4, 0x01d8, 0x01d9, 0x01da},
+	{
+	 110, 5550, 0x3a, 0x01, 0x01, 0x02, 0x2b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x62, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x97, 0x00, 0x62, 0x00, 0x00, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x77, 0x00, 0x08b0, 0x08ac, 0x08a8, 0x01d7, 0x01d8, 0x01d9},
+	{
+	 112, 5560, 0x34, 0x01, 0x01, 0x02, 0x2c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x62, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x97, 0x00, 0x62, 0x00, 0x00, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x77, 0x00, 0x08b4, 0x08b0, 0x08ac, 0x01d7, 0x01d7, 0x01d8},
+	{
+	 114, 5570, 0x34, 0x01, 0x01, 0x02, 0x2d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x52, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x52, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08b8, 0x08b4, 0x08b0, 0x01d6, 0x01d7, 0x01d7},
+	{
+	 116, 5580, 0x2e, 0x01, 0x01, 0x02, 0x2e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x52, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x52, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08bc, 0x08b8, 0x08b4, 0x01d5, 0x01d6, 0x01d7},
+	{
+	 118, 5590, 0x2e, 0x01, 0x01, 0x02, 0x2f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8d, 0x0b, 0x00, 0x84, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08c0, 0x08bc, 0x08b8, 0x01d4, 0x01d5, 0x01d6},
+	{
+	 120, 5600, 0x28, 0x01, 0x01, 0x02, 0x30, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08c4, 0x08c0, 0x08bc, 0x01d3, 0x01d4, 0x01d5},
+	{
+	 122, 5610, 0x28, 0x01, 0x01, 0x02, 0x31, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08c8, 0x08c4, 0x08c0, 0x01d2, 0x01d3, 0x01d4},
+	{
+	 124, 5620, 0x21, 0x01, 0x01, 0x02, 0x32, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08cc, 0x08c8, 0x08c4, 0x01d2, 0x01d2, 0x01d3},
+	{
+	 126, 5630, 0x21, 0x01, 0x01, 0x02, 0x33, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08d0, 0x08cc, 0x08c8, 0x01d1, 0x01d2, 0x01d2},
+	{
+	 128, 5640, 0x1c, 0x01, 0x01, 0x02, 0x34, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x95, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x75, 0x00, 0x08d4, 0x08d0, 0x08cc, 0x01d0, 0x01d1, 0x01d2},
+	{
+	 130, 5650, 0x1c, 0x01, 0x01, 0x02, 0x35, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x50, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x95, 0x00, 0x50, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x75, 0x00, 0x08d8, 0x08d4, 0x08d0, 0x01cf, 0x01d0, 0x01d1},
+	{
+	 132, 5660, 0x16, 0x01, 0x01, 0x02, 0x36, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x50, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x95, 0x00, 0x50, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x75, 0x00, 0x08dc, 0x08d8, 0x08d4, 0x01ce, 0x01cf, 0x01d0},
+	{
+	 134, 5670, 0x16, 0x01, 0x01, 0x02, 0x37, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x74, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce, 0x01ce, 0x01cf},
+	{
+	 136, 5680, 0x10, 0x01, 0x01, 0x02, 0x38, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x74, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd, 0x01ce, 0x01ce},
+	{
+	 138, 5690, 0x10, 0x01, 0x01, 0x02, 0x39, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8b, 0x09, 0x00, 0x70, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x74, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc, 0x01cd, 0x01ce},
+	{
+	 140, 5700, 0x0a, 0x01, 0x01, 0x02, 0x3a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x74, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb, 0x01cc, 0x01cd},
+	{
+	 142, 5710, 0x0a, 0x01, 0x01, 0x02, 0x3b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x74, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca, 0x01cb, 0x01cc},
+	{
+	 144, 5720, 0x0a, 0x01, 0x01, 0x02, 0x3c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x74, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 145, 5725, 0x03, 0x01, 0x02, 0x04, 0x79, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x74, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 146, 5730, 0x0a, 0x01, 0x01, 0x02, 0x3d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x84, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9, 0x01c9, 0x01ca},
+	{
+	 147, 5735, 0x03, 0x01, 0x02, 0x04, 0x7b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x83, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8, 0x01c9, 0x01ca},
+	{
+	 148, 5740, 0x0a, 0x01, 0x01, 0x02, 0x3e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x83, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8, 0x01c9, 0x01c9},
+	{
+	 149, 5745, 0xfe, 0x00, 0x02, 0x04, 0x7d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x83, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8, 0x01c8, 0x01c9},
+	{
+	 150, 5750, 0x0a, 0x01, 0x01, 0x02, 0x3f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x83, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7, 0x01c8, 0x01c9},
+	{
+	 151, 5755, 0xfe, 0x00, 0x02, 0x04, 0x7f, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x83, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7, 0x01c8, 0x01c8},
+	{
+	 152, 5760, 0x0a, 0x01, 0x01, 0x02, 0x40, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x83, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 153, 5765, 0xf8, 0x00, 0x02, 0x04, 0x81, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 154, 5770, 0x0a, 0x01, 0x01, 0x02, 0x41, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6, 0x01c6, 0x01c7},
+	{
+	 155, 5775, 0xf8, 0x00, 0x02, 0x04, 0x83, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5, 0x01c6, 0x01c7},
+	{
+	 156, 5780, 0x0a, 0x01, 0x01, 0x02, 0x42, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x8a, 0x06, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5, 0x01c6, 0x01c6},
+	{
+	 157, 5785, 0xf2, 0x00, 0x02, 0x04, 0x85, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 158, 5790, 0x0a, 0x01, 0x01, 0x02, 0x43, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 159, 5795, 0xf2, 0x00, 0x02, 0x04, 0x87, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x8a, 0x06, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4, 0x01c4, 0x01c5},
+	{
+	 160, 5800, 0x0a, 0x01, 0x01, 0x02, 0x44, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3, 0x01c4, 0x01c5},
+	{
+	 161, 5805, 0xed, 0x00, 0x02, 0x04, 0x89, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3, 0x01c4, 0x01c4},
+	{
+	 162, 5810, 0x0a, 0x01, 0x01, 0x02, 0x45, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 163, 5815, 0xed, 0x00, 0x02, 0x04, 0x8b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 164, 5820, 0x0a, 0x01, 0x01, 0x02, 0x46, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2, 0x01c2, 0x01c3},
+	{
+	 165, 5825, 0xed, 0x00, 0x02, 0x04, 0x8d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x82, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1, 0x01c2, 0x01c3},
+	{
+	 166, 5830, 0x0a, 0x01, 0x01, 0x02, 0x47, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x72, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1, 0x01c2, 0x01c2},
+	{
+	 168, 5840, 0x0a, 0x01, 0x01, 0x02, 0x48, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x72, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0, 0x01c1, 0x01c2},
+	{
+	 170, 5850, 0xe0, 0x00, 0x01, 0x02, 0x49, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x72, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf, 0x01c0, 0x01c1},
+	{
+	 172, 5860, 0xde, 0x00, 0x01, 0x02, 0x4a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x72, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf, 0x01bf, 0x01c0},
+	{
+	 174, 5870, 0xdb, 0x00, 0x01, 0x02, 0x4b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x71, 0x00, 0x0930, 0x092c, 0x0928, 0x01be, 0x01bf, 0x01bf},
+	{
+	 176, 5880, 0xd8, 0x00, 0x01, 0x02, 0x4c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x71, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd, 0x01be, 0x01bf},
+	{
+	 178, 5890, 0xd6, 0x00, 0x01, 0x02, 0x4d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x88, 0x04, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x71, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc, 0x01bd, 0x01be},
+	{
+	 180, 5900, 0xd3, 0x00, 0x01, 0x02, 0x4e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x87, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x71, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc, 0x01bc, 0x01bd},
+	{
+	 182, 5910, 0xd6, 0x00, 0x01, 0x02, 0x4f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x87, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x71, 0x00, 0x0940, 0x093c, 0x0938, 0x01bb, 0x01bc, 0x01bc},
+	{
+	 1, 2412, 0x00, 0x01, 0x03, 0x09, 0x6c, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x04, 0x04, 0x04, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0b, 0x00, 0x1f, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0b, 0x03c9, 0x03c5, 0x03c1, 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x00, 0x01, 0x03, 0x09, 0x71, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x1f, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0a, 0x03cb, 0x03c7, 0x03c3, 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x00, 0x01, 0x03, 0x09, 0x76, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x0e, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0a, 0x03cd, 0x03c9, 0x03c5, 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x00, 0x01, 0x03, 0x09, 0x7b, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x0d, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03cf, 0x03cb, 0x03c7, 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x00, 0x01, 0x03, 0x09, 0x80, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x0c, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03d1, 0x03cd, 0x03c9, 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x00, 0x01, 0x03, 0x09, 0x85, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x0b, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03d3, 0x03cf, 0x03cb, 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x00, 0x01, 0x03, 0x09, 0x8a, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x09, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03d5, 0x03d1, 0x03cd, 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x00, 0x01, 0x03, 0x09, 0x8f, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x09, 0x00, 0x08, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x09, 0x03d7, 0x03d3, 0x03cf, 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x00, 0x01, 0x03, 0x09, 0x94, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x07, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x09, 0x00, 0x07, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x09, 0x03d9, 0x03d5, 0x03d1, 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x00, 0x01, 0x03, 0x09, 0x99, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x06, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x09, 0x00, 0x06, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x09, 0x03db, 0x03d7, 0x03d3, 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x00, 0x01, 0x03, 0x09, 0x9e, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x09, 0x00, 0x05, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x09, 0x03dd, 0x03d9, 0x03d5, 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x00, 0x01, 0x03, 0x09, 0xa3, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x08, 0x03df, 0x03db, 0x03d7, 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x00, 0x01, 0x03, 0x09, 0xa8, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x08, 0x00, 0x03, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x08, 0x03e1, 0x03dd, 0x03d9, 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0xff, 0x01, 0x03, 0x09, 0xb4, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x08, 0x03e6, 0x03e2, 0x03de, 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio205x_t chan_info_nphyrev6_2056v6[] = {
+	{
+	 184, 4920, 0xff, 0x01, 0x01, 0x01, 0xec, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b4, 0x07b0, 0x07ac, 0x0214, 0x0215, 0x0216},
+	{
+	 186, 4930, 0xff, 0x01, 0x01, 0x01, 0xed, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b8, 0x07b4, 0x07b0, 0x0213, 0x0214, 0x0215},
+	{
+	 188, 4940, 0xff, 0x01, 0x01, 0x01, 0xee, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07bc, 0x07b8, 0x07b4, 0x0212, 0x0213, 0x0214},
+	{
+	 190, 4950, 0xff, 0x01, 0x01, 0x01, 0xef, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c0, 0x07bc, 0x07b8, 0x0211, 0x0212, 0x0213},
+	{
+	 192, 4960, 0xff, 0x01, 0x01, 0x01, 0xf0, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c4, 0x07c0, 0x07bc, 0x020f, 0x0211, 0x0212},
+	{
+	 194, 4970, 0xff, 0x01, 0x01, 0x01, 0xf1, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c8, 0x07c4, 0x07c0, 0x020e, 0x020f, 0x0211},
+	{
+	 196, 4980, 0xff, 0x01, 0x01, 0x01, 0xf2, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07cc, 0x07c8, 0x07c4, 0x020d, 0x020e, 0x020f},
+	{
+	 198, 4990, 0xff, 0x01, 0x01, 0x01, 0xf3, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d0, 0x07cc, 0x07c8, 0x020c, 0x020d, 0x020e},
+	{
+	 200, 5000, 0xff, 0x01, 0x01, 0x01, 0xf4, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d4, 0x07d0, 0x07cc, 0x020b, 0x020c, 0x020d},
+	{
+	 202, 5010, 0xff, 0x01, 0x01, 0x01, 0xf5, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d8, 0x07d4, 0x07d0, 0x020a, 0x020b, 0x020c},
+	{
+	 204, 5020, 0xf7, 0x01, 0x01, 0x01, 0xf6, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07dc, 0x07d8, 0x07d4, 0x0209, 0x020a, 0x020b},
+	{
+	 206, 5030, 0xf7, 0x01, 0x01, 0x01, 0xf7, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e0, 0x07dc, 0x07d8, 0x0208, 0x0209, 0x020a},
+	{
+	 208, 5040, 0xef, 0x01, 0x01, 0x01, 0xf8, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e4, 0x07e0, 0x07dc, 0x0207, 0x0208, 0x0209},
+	{
+	 210, 5050, 0xef, 0x01, 0x01, 0x01, 0xf9, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e8, 0x07e4, 0x07e0, 0x0206, 0x0207, 0x0208},
+	{
+	 212, 5060, 0xe6, 0x01, 0x01, 0x01, 0xfa, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07ec, 0x07e8, 0x07e4, 0x0205, 0x0206, 0x0207},
+	{
+	 214, 5070, 0xe6, 0x01, 0x01, 0x01, 0xfb, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f0, 0x07ec, 0x07e8, 0x0204, 0x0205, 0x0206},
+	{
+	 216, 5080, 0xde, 0x01, 0x01, 0x01, 0xfc, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f4, 0x07f0, 0x07ec, 0x0203, 0x0204, 0x0205},
+	{
+	 218, 5090, 0xde, 0x01, 0x01, 0x01, 0xfd, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f8, 0x07f4, 0x07f0, 0x0202, 0x0203, 0x0204},
+	{
+	 220, 5100, 0xd6, 0x01, 0x01, 0x01, 0xfe, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07fc, 0x07f8, 0x07f4, 0x0201, 0x0202, 0x0203},
+	{
+	 222, 5110, 0xd6, 0x01, 0x01, 0x01, 0xff, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0800, 0x07fc, 0x07f8, 0x0200, 0x0201, 0x0202},
+	{
+	 224, 5120, 0xce, 0x01, 0x01, 0x02, 0x00, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0804, 0x0800, 0x07fc, 0x01ff, 0x0200, 0x0201},
+	{
+	 226, 5130, 0xce, 0x01, 0x01, 0x02, 0x01, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0808, 0x0804, 0x0800, 0x01fe, 0x01ff, 0x0200},
+	{
+	 228, 5140, 0xc6, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfb, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x080c, 0x0808, 0x0804, 0x01fd, 0x01fe, 0x01ff},
+	{
+	 32, 5160, 0xbe, 0x01, 0x01, 0x02, 0x04, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x07, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xfa, 0x00, 0x07, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x0814, 0x0810, 0x080c, 0x01fb, 0x01fc, 0x01fd},
+	{
+	 34, 5170, 0xbe, 0x01, 0x01, 0x02, 0x05, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x07, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xfa, 0x00, 0x07, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x0818, 0x0814, 0x0810, 0x01fa, 0x01fb, 0x01fc},
+	{
+	 36, 5180, 0xb6, 0x01, 0x01, 0x02, 0x06, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x06, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x06, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x081c, 0x0818, 0x0814, 0x01f9, 0x01fa, 0x01fb},
+	{
+	 38, 5190, 0xb6, 0x01, 0x01, 0x02, 0x07, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x06, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x06, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0820, 0x081c, 0x0818, 0x01f8, 0x01f9, 0x01fa},
+	{
+	 40, 5200, 0xaf, 0x01, 0x01, 0x02, 0x08, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0824, 0x0820, 0x081c, 0x01f7, 0x01f8, 0x01f9},
+	{
+	 42, 5210, 0xaf, 0x01, 0x01, 0x02, 0x09, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0828, 0x0824, 0x0820, 0x01f6, 0x01f7, 0x01f8},
+	{
+	 44, 5220, 0xa7, 0x01, 0x01, 0x02, 0x0a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xfe, 0xd8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xd8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x082c, 0x0828, 0x0824, 0x01f5, 0x01f6, 0x01f7},
+	{
+	 46, 5230, 0xa7, 0x01, 0x01, 0x02, 0x0b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xd8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xd8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0830, 0x082c, 0x0828, 0x01f4, 0x01f5, 0x01f6},
+	{
+	 48, 5240, 0xa0, 0x01, 0x01, 0x02, 0x0c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xc8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0834, 0x0830, 0x082c, 0x01f3, 0x01f4, 0x01f5},
+	{
+	 50, 5250, 0xa0, 0x01, 0x01, 0x02, 0x0d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xed, 0xc7, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0838, 0x0834, 0x0830, 0x01f2, 0x01f3, 0x01f4},
+	{
+	 52, 5260, 0x98, 0x01, 0x01, 0x02, 0x0e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0e, 0x00, 0xed, 0xc7, 0x00, 0x04, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x04, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x083c, 0x0838, 0x0834, 0x01f1, 0x01f2, 0x01f3},
+	{
+	 54, 5270, 0x98, 0x01, 0x01, 0x02, 0x0f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8e, 0x0e, 0x00, 0xed, 0xc7, 0x00, 0x04, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x04, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0840, 0x083c, 0x0838, 0x01f0, 0x01f1, 0x01f2},
+	{
+	 56, 5280, 0x91, 0x01, 0x01, 0x02, 0x10, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0844, 0x0840, 0x083c, 0x01f0, 0x01f0, 0x01f1},
+	{
+	 58, 5290, 0x91, 0x01, 0x01, 0x02, 0x11, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0848, 0x0844, 0x0840, 0x01ef, 0x01f0, 0x01f0},
+	{
+	 60, 5300, 0x8a, 0x01, 0x01, 0x02, 0x12, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x084c, 0x0848, 0x0844, 0x01ee, 0x01ef, 0x01f0},
+	{
+	 62, 5310, 0x8a, 0x01, 0x01, 0x02, 0x13, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0850, 0x084c, 0x0848, 0x01ed, 0x01ee, 0x01ef},
+	{
+	 64, 5320, 0x83, 0x01, 0x01, 0x02, 0x14, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdb, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0854, 0x0850, 0x084c, 0x01ec, 0x01ed, 0x01ee},
+	{
+	 66, 5330, 0x83, 0x01, 0x01, 0x02, 0x15, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xcb, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0858, 0x0854, 0x0850, 0x01eb, 0x01ec, 0x01ed},
+	{
+	 68, 5340, 0x7c, 0x01, 0x01, 0x02, 0x16, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xca, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x085c, 0x0858, 0x0854, 0x01ea, 0x01eb, 0x01ec},
+	{
+	 70, 5350, 0x7c, 0x01, 0x01, 0x02, 0x17, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xca, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0860, 0x085c, 0x0858, 0x01e9, 0x01ea, 0x01eb},
+	{
+	 72, 5360, 0x75, 0x01, 0x01, 0x02, 0x18, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0864, 0x0860, 0x085c, 0x01e8, 0x01e9, 0x01ea},
+	{
+	 74, 5370, 0x75, 0x01, 0x01, 0x02, 0x19, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0868, 0x0864, 0x0860, 0x01e7, 0x01e8, 0x01e9},
+	{
+	 76, 5380, 0x6e, 0x01, 0x01, 0x02, 0x1a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x086c, 0x0868, 0x0864, 0x01e6, 0x01e7, 0x01e8},
+	{
+	 78, 5390, 0x6e, 0x01, 0x01, 0x02, 0x1b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x84, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0870, 0x086c, 0x0868, 0x01e5, 0x01e6, 0x01e7},
+	{
+	 80, 5400, 0x67, 0x01, 0x01, 0x02, 0x1c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x84, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0874, 0x0870, 0x086c, 0x01e5, 0x01e5, 0x01e6},
+	{
+	 82, 5410, 0x67, 0x01, 0x01, 0x02, 0x1d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb7, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0878, 0x0874, 0x0870, 0x01e4, 0x01e5, 0x01e5},
+	{
+	 84, 5420, 0x61, 0x01, 0x01, 0x02, 0x1e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xa7, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x087c, 0x0878, 0x0874, 0x01e3, 0x01e4, 0x01e5},
+	{
+	 86, 5430, 0x61, 0x01, 0x01, 0x02, 0x1f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0b, 0x00, 0xa6, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0880, 0x087c, 0x0878, 0x01e2, 0x01e3, 0x01e4},
+	{
+	 88, 5440, 0x5a, 0x01, 0x01, 0x02, 0x20, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0xa6, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0884, 0x0880, 0x087c, 0x01e1, 0x01e2, 0x01e3},
+	{
+	 90, 5450, 0x5a, 0x01, 0x01, 0x02, 0x21, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0888, 0x0884, 0x0880, 0x01e0, 0x01e1, 0x01e2},
+	{
+	 92, 5460, 0x53, 0x01, 0x01, 0x02, 0x22, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x088c, 0x0888, 0x0884, 0x01df, 0x01e0, 0x01e1},
+	{
+	 94, 5470, 0x53, 0x01, 0x01, 0x02, 0x23, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x94, 0x73, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0890, 0x088c, 0x0888, 0x01de, 0x01df, 0x01e0},
+	{
+	 96, 5480, 0x4d, 0x01, 0x01, 0x02, 0x24, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x84, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0894, 0x0890, 0x088c, 0x01dd, 0x01de, 0x01df},
+	{
+	 98, 5490, 0x4d, 0x01, 0x01, 0x02, 0x25, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x83, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0898, 0x0894, 0x0890, 0x01dd, 0x01dd, 0x01de},
+	{
+	 100, 5500, 0x47, 0x01, 0x01, 0x02, 0x26, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x089c, 0x0898, 0x0894, 0x01dc, 0x01dd, 0x01dd},
+	{
+	 102, 5510, 0x47, 0x01, 0x01, 0x02, 0x27, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a0, 0x089c, 0x0898, 0x01db, 0x01dc, 0x01dd},
+	{
+	 104, 5520, 0x40, 0x01, 0x01, 0x02, 0x28, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x72, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a4, 0x08a0, 0x089c, 0x01da, 0x01db, 0x01dc},
+	{
+	 106, 5530, 0x40, 0x01, 0x01, 0x02, 0x29, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x72, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a8, 0x08a4, 0x08a0, 0x01d9, 0x01da, 0x01db},
+	{
+	 108, 5540, 0x3a, 0x01, 0x01, 0x02, 0x2a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x71, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08ac, 0x08a8, 0x08a4, 0x01d8, 0x01d9, 0x01da},
+	{
+	 110, 5550, 0x3a, 0x01, 0x01, 0x02, 0x2b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b0, 0x08ac, 0x08a8, 0x01d7, 0x01d8, 0x01d9},
+	{
+	 112, 5560, 0x34, 0x01, 0x01, 0x02, 0x2c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b4, 0x08b0, 0x08ac, 0x01d7, 0x01d7, 0x01d8},
+	{
+	 114, 5570, 0x34, 0x01, 0x01, 0x02, 0x2d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x62, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x62, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b8, 0x08b4, 0x08b0, 0x01d6, 0x01d7, 0x01d7},
+	{
+	 116, 5580, 0x2e, 0x01, 0x01, 0x02, 0x2e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x60, 0x62, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x62, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08bc, 0x08b8, 0x08b4, 0x01d5, 0x01d6, 0x01d7},
+	{
+	 118, 5590, 0x2e, 0x01, 0x01, 0x02, 0x2f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x50, 0x61, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x61, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c0, 0x08bc, 0x08b8, 0x01d4, 0x01d5, 0x01d6},
+	{
+	 120, 5600, 0x28, 0x01, 0x01, 0x02, 0x30, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x51, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c4, 0x08c0, 0x08bc, 0x01d3, 0x01d4, 0x01d5},
+	{
+	 122, 5610, 0x28, 0x01, 0x01, 0x02, 0x31, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x51, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c8, 0x08c4, 0x08c0, 0x01d2, 0x01d3, 0x01d4},
+	{
+	 124, 5620, 0x21, 0x01, 0x01, 0x02, 0x32, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08cc, 0x08c8, 0x08c4, 0x01d2, 0x01d2, 0x01d3},
+	{
+	 126, 5630, 0x21, 0x01, 0x01, 0x02, 0x33, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x50, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d0, 0x08cc, 0x08c8, 0x01d1, 0x01d2, 0x01d2},
+	{
+	 128, 5640, 0x1c, 0x01, 0x01, 0x02, 0x34, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d4, 0x08d0, 0x08cc, 0x01d0, 0x01d1, 0x01d2},
+	{
+	 130, 5650, 0x1c, 0x01, 0x01, 0x02, 0x35, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x40, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d8, 0x08d4, 0x08d0, 0x01cf, 0x01d0, 0x01d1},
+	{
+	 132, 5660, 0x16, 0x01, 0x01, 0x02, 0x36, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x40, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08dc, 0x08d8, 0x08d4, 0x01ce, 0x01cf, 0x01d0},
+	{
+	 134, 5670, 0x16, 0x01, 0x01, 0x02, 0x37, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce, 0x01ce, 0x01cf},
+	{
+	 136, 5680, 0x10, 0x01, 0x01, 0x02, 0x38, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd, 0x01ce, 0x01ce},
+	{
+	 138, 5690, 0x10, 0x01, 0x01, 0x02, 0x39, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc, 0x01cd, 0x01ce},
+	{
+	 140, 5700, 0x0a, 0x01, 0x01, 0x02, 0x3a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb, 0x01cc, 0x01cd},
+	{
+	 142, 5710, 0x0a, 0x01, 0x01, 0x02, 0x3b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca, 0x01cb, 0x01cc},
+	{
+	 144, 5720, 0x0a, 0x01, 0x01, 0x02, 0x3c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 145, 5725, 0x03, 0x01, 0x02, 0x04, 0x79, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 146, 5730, 0x0a, 0x01, 0x01, 0x02, 0x3d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9, 0x01c9, 0x01ca},
+	{
+	 147, 5735, 0x03, 0x01, 0x02, 0x04, 0x7b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8, 0x01c9, 0x01ca},
+	{
+	 148, 5740, 0x0a, 0x01, 0x01, 0x02, 0x3e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8, 0x01c9, 0x01c9},
+	{
+	 149, 5745, 0xfe, 0x00, 0x02, 0x04, 0x7d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8, 0x01c8, 0x01c9},
+	{
+	 150, 5750, 0x0a, 0x01, 0x01, 0x02, 0x3f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6d, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6d, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7, 0x01c8, 0x01c9},
+	{
+	 151, 5755, 0xfe, 0x00, 0x02, 0x04, 0x7f, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7, 0x01c8, 0x01c8},
+	{
+	 152, 5760, 0x0a, 0x01, 0x01, 0x02, 0x40, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 153, 5765, 0xf8, 0x00, 0x02, 0x04, 0x81, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 154, 5770, 0x0a, 0x01, 0x01, 0x02, 0x41, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6, 0x01c6, 0x01c7},
+	{
+	 155, 5775, 0xf8, 0x00, 0x02, 0x04, 0x83, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5, 0x01c6, 0x01c7},
+	{
+	 156, 5780, 0x0a, 0x01, 0x01, 0x02, 0x42, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5, 0x01c6, 0x01c6},
+	{
+	 157, 5785, 0xf2, 0x00, 0x02, 0x04, 0x85, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 158, 5790, 0x0a, 0x01, 0x01, 0x02, 0x43, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 159, 5795, 0xf2, 0x00, 0x02, 0x04, 0x87, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4, 0x01c4, 0x01c5},
+	{
+	 160, 5800, 0x0a, 0x01, 0x01, 0x02, 0x44, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3, 0x01c4, 0x01c5},
+	{
+	 161, 5805, 0xed, 0x00, 0x02, 0x04, 0x89, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3, 0x01c4, 0x01c4},
+	{
+	 162, 5810, 0x0a, 0x01, 0x01, 0x02, 0x45, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 163, 5815, 0xed, 0x00, 0x02, 0x04, 0x8b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 164, 5820, 0x0a, 0x01, 0x01, 0x02, 0x46, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2, 0x01c2, 0x01c3},
+	{
+	 165, 5825, 0xed, 0x00, 0x02, 0x04, 0x8d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x69, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1, 0x01c2, 0x01c3},
+	{
+	 166, 5830, 0x0a, 0x01, 0x01, 0x02, 0x47, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x69, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1, 0x01c2, 0x01c2},
+	{
+	 168, 5840, 0x0a, 0x01, 0x01, 0x02, 0x48, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0, 0x01c1, 0x01c2},
+	{
+	 170, 5850, 0xe0, 0x00, 0x01, 0x02, 0x49, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf, 0x01c0, 0x01c1},
+	{
+	 172, 5860, 0xde, 0x00, 0x01, 0x02, 0x4a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf, 0x01bf, 0x01c0},
+	{
+	 174, 5870, 0xdb, 0x00, 0x01, 0x02, 0x4b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0930, 0x092c, 0x0928, 0x01be, 0x01bf, 0x01bf},
+	{
+	 176, 5880, 0xd8, 0x00, 0x01, 0x02, 0x4c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd, 0x01be, 0x01bf},
+	{
+	 178, 5890, 0xd6, 0x00, 0x01, 0x02, 0x4d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc, 0x01bd, 0x01be},
+	{
+	 180, 5900, 0xd3, 0x00, 0x01, 0x02, 0x4e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc, 0x01bc, 0x01bd},
+	{
+	 182, 5910, 0xd6, 0x00, 0x01, 0x02, 0x4f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0940, 0x093c, 0x0938, 0x01bb, 0x01bc, 0x01bc},
+	{
+	 1, 2412, 0x00, 0x01, 0x03, 0x09, 0x6c, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x04, 0x04, 0x04, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x78, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x78, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03c9, 0x03c5, 0x03c1, 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x00, 0x01, 0x03, 0x09, 0x71, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x78, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x78, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03cb, 0x03c7, 0x03c3, 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x00, 0x01, 0x03, 0x09, 0x76, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x67, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x67, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03cd, 0x03c9, 0x03c5, 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x00, 0x01, 0x03, 0x09, 0x7b, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x57, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x57, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03cf, 0x03cb, 0x03c7, 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x00, 0x01, 0x03, 0x09, 0x80, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x56, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x56, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d1, 0x03cd, 0x03c9, 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x00, 0x01, 0x03, 0x09, 0x85, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x46, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x46, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d3, 0x03cf, 0x03cb, 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x00, 0x01, 0x03, 0x09, 0x8a, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x45, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x45, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d5, 0x03d1, 0x03cd, 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x00, 0x01, 0x03, 0x09, 0x8f, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x34, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x34, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03d7, 0x03d3, 0x03cf, 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x00, 0x01, 0x03, 0x09, 0x94, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x23, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x23, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03d9, 0x03d5, 0x03d1, 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x00, 0x01, 0x03, 0x09, 0x99, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x12, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x12, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03db, 0x03d7, 0x03d3, 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x00, 0x01, 0x03, 0x09, 0x9e, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x02, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03dd, 0x03d9, 0x03d5, 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x00, 0x01, 0x03, 0x09, 0xa3, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x01, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03df, 0x03db, 0x03d7, 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x00, 0x01, 0x03, 0x09, 0xa8, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x01, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03e1, 0x03dd, 0x03d9, 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0xff, 0x01, 0x03, 0x09, 0xb4, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03e6, 0x03e2, 0x03de, 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio205x_t chan_info_nphyrev5n6_2056v7[] = {
+	{
+	 184, 4920, 0xff, 0x01, 0x01, 0x01, 0xec, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0f, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b4, 0x07b0, 0x07ac, 0x0214, 0x0215, 0x0216},
+	{
+	 186, 4930, 0xff, 0x01, 0x01, 0x01, 0xed, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07b8, 0x07b4, 0x07b0, 0x0213, 0x0214, 0x0215},
+	{
+	 188, 4940, 0xff, 0x01, 0x01, 0x01, 0xee, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07bc, 0x07b8, 0x07b4, 0x0212, 0x0213, 0x0214},
+	{
+	 190, 4950, 0xff, 0x01, 0x01, 0x01, 0xef, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0b, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0b, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07c0, 0x07bc, 0x07b8, 0x0211, 0x0212, 0x0213},
+	{
+	 192, 4960, 0xff, 0x01, 0x01, 0x01, 0xf0, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0e, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x07c4, 0x07c0, 0x07bc, 0x020f, 0x0211, 0x0212},
+	{
+	 194, 4970, 0xff, 0x01, 0x01, 0x01, 0xf1, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07c8, 0x07c4, 0x07c0, 0x020e, 0x020f, 0x0211},
+	{
+	 196, 4980, 0xff, 0x01, 0x01, 0x01, 0xf2, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07cc, 0x07c8, 0x07c4, 0x020d, 0x020e, 0x020f},
+	{
+	 198, 4990, 0xff, 0x01, 0x01, 0x01, 0xf3, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07d0, 0x07cc, 0x07c8, 0x020c, 0x020d, 0x020e},
+	{
+	 200, 5000, 0xff, 0x01, 0x01, 0x01, 0xf4, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07d4, 0x07d0, 0x07cc, 0x020b, 0x020c, 0x020d},
+	{
+	 202, 5010, 0xff, 0x01, 0x01, 0x01, 0xf5, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x0a, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x0a, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07d8, 0x07d4, 0x07d0, 0x020a, 0x020b, 0x020c},
+	{
+	 204, 5020, 0xf7, 0x01, 0x01, 0x01, 0xf6, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0d, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x07dc, 0x07d8, 0x07d4, 0x0209, 0x020a, 0x020b},
+	{
+	 206, 5030, 0xf7, 0x01, 0x01, 0x01, 0xf7, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xff, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xff, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07e0, 0x07dc, 0x07d8, 0x0208, 0x0209, 0x020a},
+	{
+	 208, 5040, 0xef, 0x01, 0x01, 0x01, 0xf8, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07e4, 0x07e0, 0x07dc, 0x0207, 0x0208, 0x0209},
+	{
+	 210, 5050, 0xef, 0x01, 0x01, 0x01, 0xf9, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07e8, 0x07e4, 0x07e0, 0x0206, 0x0207, 0x0208},
+	{
+	 212, 5060, 0xe6, 0x01, 0x01, 0x01, 0xfa, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x70,
+	 0x00, 0x0c, 0x00, 0x9f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x70, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x07ec, 0x07e8, 0x07e4, 0x0205, 0x0206, 0x0207},
+	{
+	 214, 5070, 0xe6, 0x01, 0x01, 0x01, 0xfb, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfd, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07f0, 0x07ec, 0x07e8, 0x0204, 0x0205, 0x0206},
+	{
+	 216, 5080, 0xde, 0x01, 0x01, 0x01, 0xfc, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07f4, 0x07f0, 0x07ec, 0x0203, 0x0204, 0x0205},
+	{
+	 218, 5090, 0xde, 0x01, 0x01, 0x01, 0xfd, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07f8, 0x07f4, 0x07f0, 0x0202, 0x0203, 0x0204},
+	{
+	 220, 5100, 0xd6, 0x01, 0x01, 0x01, 0xfe, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x07fc, 0x07f8, 0x07f4, 0x0201, 0x0202, 0x0203},
+	{
+	 222, 5110, 0xd6, 0x01, 0x01, 0x01, 0xff, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0800, 0x07fc, 0x07f8, 0x0200, 0x0201, 0x0202},
+	{
+	 224, 5120, 0xce, 0x01, 0x01, 0x02, 0x00, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0b, 0x00, 0x9f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0804, 0x0800, 0x07fc, 0x01ff, 0x0200, 0x0201},
+	{
+	 226, 5130, 0xce, 0x01, 0x01, 0x02, 0x01, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x08, 0x00, 0x70,
+	 0x00, 0x0a, 0x00, 0x9f, 0x00, 0xfb, 0x00, 0x08, 0x00, 0x70, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0808, 0x0804, 0x0800, 0x01fe, 0x01ff, 0x0200},
+	{
+	 228, 5140, 0xc6, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x07, 0x00, 0x70,
+	 0x00, 0x0a, 0x00, 0x9f, 0x00, 0xfb, 0x00, 0x07, 0x00, 0x70, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x080c, 0x0808, 0x0804, 0x01fd, 0x01fe, 0x01ff},
+	{
+	 32, 5160, 0xbe, 0x01, 0x01, 0x02, 0x04, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x07, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfb, 0x00, 0x07, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0814, 0x0810, 0x080c, 0x01fb, 0x01fc, 0x01fd},
+	{
+	 34, 5170, 0xbe, 0x01, 0x01, 0x02, 0x05, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfb, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0818, 0x0814, 0x0810, 0x01fa, 0x01fb, 0x01fc},
+	{
+	 36, 5180, 0xb6, 0x01, 0x01, 0x02, 0x06, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x081c, 0x0818, 0x0814, 0x01f9, 0x01fa, 0x01fb},
+	{
+	 38, 5190, 0xb6, 0x01, 0x01, 0x02, 0x07, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0820, 0x081c, 0x0818, 0x01f8, 0x01f9, 0x01fa},
+	{
+	 40, 5200, 0xaf, 0x01, 0x01, 0x02, 0x08, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0824, 0x0820, 0x081c, 0x01f7, 0x01f8, 0x01f9},
+	{
+	 42, 5210, 0xaf, 0x01, 0x01, 0x02, 0x09, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x0828, 0x0824, 0x0820, 0x01f6, 0x01f7, 0x01f8},
+	{
+	 44, 5220, 0xa7, 0x01, 0x01, 0x02, 0x0a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xfe, 0xfa, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x09, 0x00, 0x9e, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x70, 0x00, 0x09,
+	 0x00, 0x6e, 0x00, 0x082c, 0x0828, 0x0824, 0x01f5, 0x01f6, 0x01f7},
+	{
+	 46, 5230, 0xa7, 0x01, 0x01, 0x02, 0x0b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xea, 0x00, 0x06, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9e, 0x00, 0xea, 0x00, 0x06, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6e, 0x00, 0x0830, 0x082c, 0x0828, 0x01f4, 0x01f5, 0x01f6},
+	{
+	 48, 5240, 0xa0, 0x01, 0x01, 0x02, 0x0c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xe9, 0x00, 0x05, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9d, 0x00, 0xe9, 0x00, 0x05, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6d, 0x00, 0x0834, 0x0830, 0x082c, 0x01f3, 0x01f4, 0x01f5},
+	{
+	 50, 5250, 0xa0, 0x01, 0x01, 0x02, 0x0d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xed, 0xe9, 0x00, 0x05, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9d, 0x00, 0xe9, 0x00, 0x05, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6d, 0x00, 0x0838, 0x0834, 0x0830, 0x01f2, 0x01f3, 0x01f4},
+	{
+	 52, 5260, 0x98, 0x01, 0x01, 0x02, 0x0e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0e, 0x00, 0xed, 0xd9, 0x00, 0x05, 0x00, 0x70,
+	 0x00, 0x08, 0x00, 0x9d, 0x00, 0xd9, 0x00, 0x05, 0x00, 0x70, 0x00, 0x08,
+	 0x00, 0x6d, 0x00, 0x083c, 0x0838, 0x0834, 0x01f1, 0x01f2, 0x01f3},
+	{
+	 54, 5270, 0x98, 0x01, 0x01, 0x02, 0x0f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8e, 0x0e, 0x00, 0xed, 0xd8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xd8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0840, 0x083c, 0x0838, 0x01f0, 0x01f1, 0x01f2},
+	{
+	 56, 5280, 0x91, 0x01, 0x01, 0x02, 0x10, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0844, 0x0840, 0x083c, 0x01f0, 0x01f0, 0x01f1},
+	{
+	 58, 5290, 0x91, 0x01, 0x01, 0x02, 0x11, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0848, 0x0844, 0x0840, 0x01ef, 0x01f0, 0x01f0},
+	{
+	 60, 5300, 0x8a, 0x01, 0x01, 0x02, 0x12, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x084c, 0x0848, 0x0844, 0x01ee, 0x01ef, 0x01f0},
+	{
+	 62, 5310, 0x8a, 0x01, 0x01, 0x02, 0x13, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xc8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xc8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0850, 0x084c, 0x0848, 0x01ed, 0x01ee, 0x01ef},
+	{
+	 64, 5320, 0x83, 0x01, 0x01, 0x02, 0x14, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdb, 0xb8, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9c, 0x00, 0xb8, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6c, 0x00, 0x0854, 0x0850, 0x084c, 0x01ec, 0x01ed, 0x01ee},
+	{
+	 66, 5330, 0x83, 0x01, 0x01, 0x02, 0x15, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xcb, 0xb7, 0x00, 0x04, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9b, 0x00, 0xb7, 0x00, 0x04, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6b, 0x00, 0x0858, 0x0854, 0x0850, 0x01eb, 0x01ec, 0x01ed},
+	{
+	 68, 5340, 0x7c, 0x01, 0x01, 0x02, 0x16, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xca, 0xb7, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x07, 0x00, 0x9b, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x70, 0x00, 0x07,
+	 0x00, 0x6b, 0x00, 0x085c, 0x0858, 0x0854, 0x01ea, 0x01eb, 0x01ec},
+	{
+	 70, 5350, 0x7c, 0x01, 0x01, 0x02, 0x17, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xca, 0xa7, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9b, 0x00, 0xa7, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x6b, 0x00, 0x0860, 0x085c, 0x0858, 0x01e9, 0x01ea, 0x01eb},
+	{
+	 72, 5360, 0x75, 0x01, 0x01, 0x02, 0x18, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0xa6, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9b, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x6b, 0x00, 0x0864, 0x0860, 0x085c, 0x01e8, 0x01e9, 0x01ea},
+	{
+	 74, 5370, 0x75, 0x01, 0x01, 0x02, 0x19, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0xa6, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9b, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x7b, 0x00, 0x0868, 0x0864, 0x0860, 0x01e7, 0x01e8, 0x01e9},
+	{
+	 76, 5380, 0x6e, 0x01, 0x01, 0x02, 0x1a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x96, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9a, 0x00, 0x96, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x7a, 0x00, 0x086c, 0x0868, 0x0864, 0x01e6, 0x01e7, 0x01e8},
+	{
+	 78, 5390, 0x6e, 0x01, 0x01, 0x02, 0x1b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x7a, 0x00, 0x0870, 0x086c, 0x0868, 0x01e5, 0x01e6, 0x01e7},
+	{
+	 80, 5400, 0x67, 0x01, 0x01, 0x02, 0x1c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x06, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x06,
+	 0x00, 0x7a, 0x00, 0x0874, 0x0870, 0x086c, 0x01e5, 0x01e5, 0x01e6},
+	{
+	 82, 5410, 0x67, 0x01, 0x01, 0x02, 0x1d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb7, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x7a, 0x00, 0x0878, 0x0874, 0x0870, 0x01e4, 0x01e5, 0x01e5},
+	{
+	 84, 5420, 0x61, 0x01, 0x01, 0x02, 0x1e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xa7, 0x95, 0x00, 0x03, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x9a, 0x00, 0x95, 0x00, 0x03, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x7a, 0x00, 0x087c, 0x0878, 0x0874, 0x01e3, 0x01e4, 0x01e5},
+	{
+	 86, 5430, 0x61, 0x01, 0x01, 0x02, 0x1f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0b, 0x00, 0xa6, 0x85, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x99, 0x00, 0x85, 0x00, 0x02, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x79, 0x00, 0x0880, 0x087c, 0x0878, 0x01e2, 0x01e3, 0x01e4},
+	{
+	 88, 5440, 0x5a, 0x01, 0x01, 0x02, 0x20, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0xa6, 0x84, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x99, 0x00, 0x84, 0x00, 0x02, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x79, 0x00, 0x0884, 0x0880, 0x087c, 0x01e1, 0x01e2, 0x01e3},
+	{
+	 90, 5450, 0x5a, 0x01, 0x01, 0x02, 0x21, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x05, 0x00, 0x99, 0x00, 0x84, 0x00, 0x02, 0x00, 0x70, 0x00, 0x05,
+	 0x00, 0x79, 0x00, 0x0888, 0x0884, 0x0880, 0x01e0, 0x01e1, 0x01e2},
+	{
+	 92, 5460, 0x53, 0x01, 0x01, 0x02, 0x22, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x02, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x99, 0x00, 0x84, 0x00, 0x02, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x79, 0x00, 0x088c, 0x0888, 0x0884, 0x01df, 0x01e0, 0x01e1},
+	{
+	 94, 5470, 0x53, 0x01, 0x01, 0x02, 0x23, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x94, 0x74, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x99, 0x00, 0x74, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x79, 0x00, 0x0890, 0x088c, 0x0888, 0x01de, 0x01df, 0x01e0},
+	{
+	 96, 5480, 0x4d, 0x01, 0x01, 0x02, 0x24, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x84, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x0894, 0x0890, 0x088c, 0x01dd, 0x01de, 0x01df},
+	{
+	 98, 5490, 0x4d, 0x01, 0x01, 0x02, 0x25, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x83, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x0898, 0x0894, 0x0890, 0x01dd, 0x01dd, 0x01de},
+	{
+	 100, 5500, 0x47, 0x01, 0x01, 0x02, 0x26, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x089c, 0x0898, 0x0894, 0x01dc, 0x01dd, 0x01dd},
+	{
+	 102, 5510, 0x47, 0x01, 0x01, 0x02, 0x27, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x08a0, 0x089c, 0x0898, 0x01db, 0x01dc, 0x01dd},
+	{
+	 104, 5520, 0x40, 0x01, 0x01, 0x02, 0x28, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x72, 0x73, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x04, 0x00, 0x98, 0x00, 0x73, 0x00, 0x01, 0x00, 0x70, 0x00, 0x04,
+	 0x00, 0x78, 0x00, 0x08a4, 0x08a0, 0x089c, 0x01da, 0x01db, 0x01dc},
+	{
+	 106, 5530, 0x40, 0x01, 0x01, 0x02, 0x29, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x72, 0x63, 0x00, 0x01, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x98, 0x00, 0x63, 0x00, 0x01, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x78, 0x00, 0x08a8, 0x08a4, 0x08a0, 0x01d9, 0x01da, 0x01db},
+	{
+	 108, 5540, 0x3a, 0x01, 0x01, 0x02, 0x2a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x71, 0x62, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x97, 0x00, 0x62, 0x00, 0x00, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x77, 0x00, 0x08ac, 0x08a8, 0x08a4, 0x01d8, 0x01d9, 0x01da},
+	{
+	 110, 5550, 0x3a, 0x01, 0x01, 0x02, 0x2b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x62, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x97, 0x00, 0x62, 0x00, 0x00, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x77, 0x00, 0x08b0, 0x08ac, 0x08a8, 0x01d7, 0x01d8, 0x01d9},
+	{
+	 112, 5560, 0x34, 0x01, 0x01, 0x02, 0x2c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x62, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x03, 0x00, 0x97, 0x00, 0x62, 0x00, 0x00, 0x00, 0x70, 0x00, 0x03,
+	 0x00, 0x77, 0x00, 0x08b4, 0x08b0, 0x08ac, 0x01d7, 0x01d7, 0x01d8},
+	{
+	 114, 5570, 0x34, 0x01, 0x01, 0x02, 0x2d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x52, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x52, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x76, 0x00, 0x08b8, 0x08b4, 0x08b0, 0x01d6, 0x01d7, 0x01d7},
+	{
+	 116, 5580, 0x2e, 0x01, 0x01, 0x02, 0x2e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x60, 0x52, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x52, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x86, 0x00, 0x08bc, 0x08b8, 0x08b4, 0x01d5, 0x01d6, 0x01d7},
+	{
+	 118, 5590, 0x2e, 0x01, 0x01, 0x02, 0x2f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x86, 0x00, 0x08c0, 0x08bc, 0x08b8, 0x01d4, 0x01d5, 0x01d6},
+	{
+	 120, 5600, 0x28, 0x01, 0x01, 0x02, 0x30, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x86, 0x00, 0x08c4, 0x08c0, 0x08bc, 0x01d3, 0x01d4, 0x01d5},
+	{
+	 122, 5610, 0x28, 0x01, 0x01, 0x02, 0x31, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x86, 0x00, 0x08c8, 0x08c4, 0x08c0, 0x01d2, 0x01d3, 0x01d4},
+	{
+	 124, 5620, 0x21, 0x01, 0x01, 0x02, 0x32, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x86, 0x00, 0x08cc, 0x08c8, 0x08c4, 0x01d2, 0x01d2, 0x01d3},
+	{
+	 126, 5630, 0x21, 0x01, 0x01, 0x02, 0x33, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x96, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x86, 0x00, 0x08d0, 0x08cc, 0x08c8, 0x01d1, 0x01d2, 0x01d2},
+	{
+	 128, 5640, 0x1c, 0x01, 0x01, 0x02, 0x34, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x51, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x02, 0x00, 0x95, 0x00, 0x51, 0x00, 0x00, 0x00, 0x70, 0x00, 0x02,
+	 0x00, 0x85, 0x00, 0x08d4, 0x08d0, 0x08cc, 0x01d0, 0x01d1, 0x01d2},
+	{
+	 130, 5650, 0x1c, 0x01, 0x01, 0x02, 0x35, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x50, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x95, 0x00, 0x50, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x85, 0x00, 0x08d8, 0x08d4, 0x08d0, 0x01cf, 0x01d0, 0x01d1},
+	{
+	 132, 5660, 0x16, 0x01, 0x01, 0x02, 0x36, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x50, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x95, 0x00, 0x50, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x85, 0x00, 0x08dc, 0x08d8, 0x08d4, 0x01ce, 0x01cf, 0x01d0},
+	{
+	 134, 5670, 0x16, 0x01, 0x01, 0x02, 0x37, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x84, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce, 0x01ce, 0x01cf},
+	{
+	 136, 5680, 0x10, 0x01, 0x01, 0x02, 0x38, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x84, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd, 0x01ce, 0x01ce},
+	{
+	 138, 5690, 0x10, 0x01, 0x01, 0x02, 0x39, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x94, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc, 0x01cd, 0x01ce},
+	{
+	 140, 5700, 0x0a, 0x01, 0x01, 0x02, 0x3a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x94, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb, 0x01cc, 0x01cd},
+	{
+	 142, 5710, 0x0a, 0x01, 0x01, 0x02, 0x3b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x94, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca, 0x01cb, 0x01cc},
+	{
+	 144, 5720, 0x0a, 0x01, 0x01, 0x02, 0x3c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x94, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 145, 5725, 0x03, 0x01, 0x02, 0x04, 0x79, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x40, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x40, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x94, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 146, 5730, 0x0a, 0x01, 0x01, 0x02, 0x3d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x01, 0x00, 0x94, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x01,
+	 0x00, 0x94, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9, 0x01c9, 0x01ca},
+	{
+	 147, 5735, 0x03, 0x01, 0x02, 0x04, 0x7b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x93, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8, 0x01c9, 0x01ca},
+	{
+	 148, 5740, 0x0a, 0x01, 0x01, 0x02, 0x3e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x93, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8, 0x01c9, 0x01c9},
+	{
+	 149, 5745, 0xfe, 0x00, 0x02, 0x04, 0x7d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x93, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8, 0x01c8, 0x01c9},
+	{
+	 150, 5750, 0x0a, 0x01, 0x01, 0x02, 0x3f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x93, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7, 0x01c8, 0x01c9},
+	{
+	 151, 5755, 0xfe, 0x00, 0x02, 0x04, 0x7f, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x10, 0x30, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x30, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x93, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7, 0x01c8, 0x01c8},
+	{
+	 152, 5760, 0x0a, 0x01, 0x01, 0x02, 0x40, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x93, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x93, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 153, 5765, 0xf8, 0x00, 0x02, 0x04, 0x81, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 154, 5770, 0x0a, 0x01, 0x01, 0x02, 0x41, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6, 0x01c6, 0x01c7},
+	{
+	 155, 5775, 0xf8, 0x00, 0x02, 0x04, 0x83, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x20, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5, 0x01c6, 0x01c7},
+	{
+	 156, 5780, 0x0a, 0x01, 0x01, 0x02, 0x42, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5, 0x01c6, 0x01c6},
+	{
+	 157, 5785, 0xf2, 0x00, 0x02, 0x04, 0x85, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 158, 5790, 0x0a, 0x01, 0x01, 0x02, 0x43, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 159, 5795, 0xf2, 0x00, 0x02, 0x04, 0x87, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4, 0x01c4, 0x01c5},
+	{
+	 160, 5800, 0x0a, 0x01, 0x01, 0x02, 0x44, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3, 0x01c4, 0x01c5},
+	{
+	 161, 5805, 0xed, 0x00, 0x02, 0x04, 0x89, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3, 0x01c4, 0x01c4},
+	{
+	 162, 5810, 0x0a, 0x01, 0x01, 0x02, 0x45, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 163, 5815, 0xed, 0x00, 0x02, 0x04, 0x8b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 164, 5820, 0x0a, 0x01, 0x01, 0x02, 0x46, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2, 0x01c2, 0x01c3},
+	{
+	 165, 5825, 0xed, 0x00, 0x02, 0x04, 0x8d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1, 0x01c2, 0x01c3},
+	{
+	 166, 5830, 0x0a, 0x01, 0x01, 0x02, 0x47, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1, 0x01c2, 0x01c2},
+	{
+	 168, 5840, 0x0a, 0x01, 0x01, 0x02, 0x48, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x10, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0, 0x01c1, 0x01c2},
+	{
+	 170, 5850, 0xe0, 0x00, 0x01, 0x02, 0x49, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf, 0x01c0, 0x01c1},
+	{
+	 172, 5860, 0xde, 0x00, 0x01, 0x02, 0x4a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x92, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf, 0x01bf, 0x01c0},
+	{
+	 174, 5870, 0xdb, 0x00, 0x01, 0x02, 0x4b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x91, 0x00, 0x0930, 0x092c, 0x0928, 0x01be, 0x01bf, 0x01bf},
+	{
+	 176, 5880, 0xd8, 0x00, 0x01, 0x02, 0x4c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x91, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd, 0x01be, 0x01bf},
+	{
+	 178, 5890, 0xd6, 0x00, 0x01, 0x02, 0x4d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x91, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc, 0x01bd, 0x01be},
+	{
+	 180, 5900, 0xd3, 0x00, 0x01, 0x02, 0x4e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x91, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc, 0x01bc, 0x01bd},
+	{
+	 182, 5910, 0xd6, 0x00, 0x01, 0x02, 0x4f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
+	 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
+	 0x00, 0x91, 0x00, 0x0940, 0x093c, 0x0938, 0x01bb, 0x01bc, 0x01bc},
+	{
+	 1, 2412, 0x00, 0x01, 0x03, 0x09, 0x6c, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x04, 0x04, 0x04, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x89, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0b, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0b, 0x03c9, 0x03c5, 0x03c1, 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x00, 0x01, 0x03, 0x09, 0x71, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x89, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0a, 0x03cb, 0x03c7, 0x03c3, 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x00, 0x01, 0x03, 0x09, 0x76, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x89, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0f, 0x00, 0x0a, 0x03cd, 0x03c9, 0x03c5, 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x00, 0x01, 0x03, 0x09, 0x7b, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x78, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x78, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03cf, 0x03cb, 0x03c7, 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x00, 0x01, 0x03, 0x09, 0x80, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x77, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03d1, 0x03cd, 0x03c9, 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x00, 0x01, 0x03, 0x09, 0x85, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x76, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x76, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03d3, 0x03cf, 0x03cb, 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x00, 0x01, 0x03, 0x09, 0x8a, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x66, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x0a, 0x00, 0x66, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x0a, 0x03d5, 0x03d1, 0x03cd, 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x00, 0x01, 0x03, 0x09, 0x8f, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x55, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x09, 0x00, 0x55, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x09, 0x03d7, 0x03d3, 0x03cf, 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x00, 0x01, 0x03, 0x09, 0x94, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x45, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0e, 0x00, 0x09, 0x00, 0x45, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0e, 0x00, 0x09, 0x03d9, 0x03d5, 0x03d1, 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x00, 0x01, 0x03, 0x09, 0x99, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x34, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x09, 0x00, 0x34, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x09, 0x03db, 0x03d7, 0x03d3, 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x00, 0x01, 0x03, 0x09, 0x9e, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x09, 0x00, 0x33, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x09, 0x03dd, 0x03d9, 0x03d5, 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x00, 0x01, 0x03, 0x09, 0xa3, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x08, 0x00, 0x22, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x08, 0x03df, 0x03db, 0x03d7, 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x00, 0x01, 0x03, 0x09, 0xa8, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x11, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x08, 0x00, 0x11, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x08, 0x03e1, 0x03dd, 0x03d9, 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0xff, 0x01, 0x03, 0x09, 0xb4, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0d, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0d, 0x00, 0x08, 0x03e6, 0x03e2, 0x03de, 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio205x_t chan_info_nphyrev6_2056v8[] = {
+	{
+	 184, 4920, 0xff, 0x01, 0x01, 0x01, 0xec, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b4, 0x07b0, 0x07ac, 0x0214, 0x0215, 0x0216},
+	{
+	 186, 4930, 0xff, 0x01, 0x01, 0x01, 0xed, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b8, 0x07b4, 0x07b0, 0x0213, 0x0214, 0x0215},
+	{
+	 188, 4940, 0xff, 0x01, 0x01, 0x01, 0xee, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07bc, 0x07b8, 0x07b4, 0x0212, 0x0213, 0x0214},
+	{
+	 190, 4950, 0xff, 0x01, 0x01, 0x01, 0xef, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c0, 0x07bc, 0x07b8, 0x0211, 0x0212, 0x0213},
+	{
+	 192, 4960, 0xff, 0x01, 0x01, 0x01, 0xf0, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c4, 0x07c0, 0x07bc, 0x020f, 0x0211, 0x0212},
+	{
+	 194, 4970, 0xff, 0x01, 0x01, 0x01, 0xf1, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c8, 0x07c4, 0x07c0, 0x020e, 0x020f, 0x0211},
+	{
+	 196, 4980, 0xff, 0x01, 0x01, 0x01, 0xf2, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07cc, 0x07c8, 0x07c4, 0x020d, 0x020e, 0x020f},
+	{
+	 198, 4990, 0xff, 0x01, 0x01, 0x01, 0xf3, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d0, 0x07cc, 0x07c8, 0x020c, 0x020d, 0x020e},
+	{
+	 200, 5000, 0xff, 0x01, 0x01, 0x01, 0xf4, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d4, 0x07d0, 0x07cc, 0x020b, 0x020c, 0x020d},
+	{
+	 202, 5010, 0xff, 0x01, 0x01, 0x01, 0xf5, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d8, 0x07d4, 0x07d0, 0x020a, 0x020b, 0x020c},
+	{
+	 204, 5020, 0xf7, 0x01, 0x01, 0x01, 0xf6, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07dc, 0x07d8, 0x07d4, 0x0209, 0x020a, 0x020b},
+	{
+	 206, 5030, 0xf7, 0x01, 0x01, 0x01, 0xf7, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e0, 0x07dc, 0x07d8, 0x0208, 0x0209, 0x020a},
+	{
+	 208, 5040, 0xef, 0x01, 0x01, 0x01, 0xf8, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e4, 0x07e0, 0x07dc, 0x0207, 0x0208, 0x0209},
+	{
+	 210, 5050, 0xef, 0x01, 0x01, 0x01, 0xf9, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e8, 0x07e4, 0x07e0, 0x0206, 0x0207, 0x0208},
+	{
+	 212, 5060, 0xe6, 0x01, 0x01, 0x01, 0xfa, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07ec, 0x07e8, 0x07e4, 0x0205, 0x0206, 0x0207},
+	{
+	 214, 5070, 0xe6, 0x01, 0x01, 0x01, 0xfb, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f0, 0x07ec, 0x07e8, 0x0204, 0x0205, 0x0206},
+	{
+	 216, 5080, 0xde, 0x01, 0x01, 0x01, 0xfc, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f4, 0x07f0, 0x07ec, 0x0203, 0x0204, 0x0205},
+	{
+	 218, 5090, 0xde, 0x01, 0x01, 0x01, 0xfd, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f8, 0x07f4, 0x07f0, 0x0202, 0x0203, 0x0204},
+	{
+	 220, 5100, 0xd6, 0x01, 0x01, 0x01, 0xfe, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07fc, 0x07f8, 0x07f4, 0x0201, 0x0202, 0x0203},
+	{
+	 222, 5110, 0xd6, 0x01, 0x01, 0x01, 0xff, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0800, 0x07fc, 0x07f8, 0x0200, 0x0201, 0x0202},
+	{
+	 224, 5120, 0xce, 0x01, 0x01, 0x02, 0x00, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0804, 0x0800, 0x07fc, 0x01ff, 0x0200, 0x0201},
+	{
+	 226, 5130, 0xce, 0x01, 0x01, 0x02, 0x01, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0808, 0x0804, 0x0800, 0x01fe, 0x01ff, 0x0200},
+	{
+	 228, 5140, 0xc6, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfb, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x080c, 0x0808, 0x0804, 0x01fd, 0x01fe, 0x01ff},
+	{
+	 32, 5160, 0xbe, 0x01, 0x01, 0x02, 0x04, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x07, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xfa, 0x00, 0x07, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x0814, 0x0810, 0x080c, 0x01fb, 0x01fc, 0x01fd},
+	{
+	 34, 5170, 0xbe, 0x01, 0x01, 0x02, 0x05, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x07, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xfa, 0x00, 0x07, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x0818, 0x0814, 0x0810, 0x01fa, 0x01fb, 0x01fc},
+	{
+	 36, 5180, 0xb6, 0x01, 0x01, 0x02, 0x06, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x06, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x06, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x081c, 0x0818, 0x0814, 0x01f9, 0x01fa, 0x01fb},
+	{
+	 38, 5190, 0xb6, 0x01, 0x01, 0x02, 0x07, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x06, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x06, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0820, 0x081c, 0x0818, 0x01f8, 0x01f9, 0x01fa},
+	{
+	 40, 5200, 0xaf, 0x01, 0x01, 0x02, 0x08, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0824, 0x0820, 0x081c, 0x01f7, 0x01f8, 0x01f9},
+	{
+	 42, 5210, 0xaf, 0x01, 0x01, 0x02, 0x09, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0828, 0x0824, 0x0820, 0x01f6, 0x01f7, 0x01f8},
+	{
+	 44, 5220, 0xa7, 0x01, 0x01, 0x02, 0x0a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xfe, 0xd8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xd8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x082c, 0x0828, 0x0824, 0x01f5, 0x01f6, 0x01f7},
+	{
+	 46, 5230, 0xa7, 0x01, 0x01, 0x02, 0x0b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xd8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xd8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0830, 0x082c, 0x0828, 0x01f4, 0x01f5, 0x01f6},
+	{
+	 48, 5240, 0xa0, 0x01, 0x01, 0x02, 0x0c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xc8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0834, 0x0830, 0x082c, 0x01f3, 0x01f4, 0x01f5},
+	{
+	 50, 5250, 0xa0, 0x01, 0x01, 0x02, 0x0d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xed, 0xc7, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0838, 0x0834, 0x0830, 0x01f2, 0x01f3, 0x01f4},
+	{
+	 52, 5260, 0x98, 0x01, 0x01, 0x02, 0x0e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0e, 0x00, 0xed, 0xc7, 0x00, 0x04, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x04, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x083c, 0x0838, 0x0834, 0x01f1, 0x01f2, 0x01f3},
+	{
+	 54, 5270, 0x98, 0x01, 0x01, 0x02, 0x0f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8e, 0x0e, 0x00, 0xed, 0xc7, 0x00, 0x04, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x04, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0840, 0x083c, 0x0838, 0x01f0, 0x01f1, 0x01f2},
+	{
+	 56, 5280, 0x91, 0x01, 0x01, 0x02, 0x10, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0844, 0x0840, 0x083c, 0x01f0, 0x01f0, 0x01f1},
+	{
+	 58, 5290, 0x91, 0x01, 0x01, 0x02, 0x11, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0848, 0x0844, 0x0840, 0x01ef, 0x01f0, 0x01f0},
+	{
+	 60, 5300, 0x8a, 0x01, 0x01, 0x02, 0x12, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x084c, 0x0848, 0x0844, 0x01ee, 0x01ef, 0x01f0},
+	{
+	 62, 5310, 0x8a, 0x01, 0x01, 0x02, 0x13, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0850, 0x084c, 0x0848, 0x01ed, 0x01ee, 0x01ef},
+	{
+	 64, 5320, 0x83, 0x01, 0x01, 0x02, 0x14, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdb, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0854, 0x0850, 0x084c, 0x01ec, 0x01ed, 0x01ee},
+	{
+	 66, 5330, 0x83, 0x01, 0x01, 0x02, 0x15, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xcb, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0858, 0x0854, 0x0850, 0x01eb, 0x01ec, 0x01ed},
+	{
+	 68, 5340, 0x7c, 0x01, 0x01, 0x02, 0x16, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xca, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x085c, 0x0858, 0x0854, 0x01ea, 0x01eb, 0x01ec},
+	{
+	 70, 5350, 0x7c, 0x01, 0x01, 0x02, 0x17, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xca, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0860, 0x085c, 0x0858, 0x01e9, 0x01ea, 0x01eb},
+	{
+	 72, 5360, 0x75, 0x01, 0x01, 0x02, 0x18, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0864, 0x0860, 0x085c, 0x01e8, 0x01e9, 0x01ea},
+	{
+	 74, 5370, 0x75, 0x01, 0x01, 0x02, 0x19, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0868, 0x0864, 0x0860, 0x01e7, 0x01e8, 0x01e9},
+	{
+	 76, 5380, 0x6e, 0x01, 0x01, 0x02, 0x1a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x086c, 0x0868, 0x0864, 0x01e6, 0x01e7, 0x01e8},
+	{
+	 78, 5390, 0x6e, 0x01, 0x01, 0x02, 0x1b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x84, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0870, 0x086c, 0x0868, 0x01e5, 0x01e6, 0x01e7},
+	{
+	 80, 5400, 0x67, 0x01, 0x01, 0x02, 0x1c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x84, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0874, 0x0870, 0x086c, 0x01e5, 0x01e5, 0x01e6},
+	{
+	 82, 5410, 0x67, 0x01, 0x01, 0x02, 0x1d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb7, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0878, 0x0874, 0x0870, 0x01e4, 0x01e5, 0x01e5},
+	{
+	 84, 5420, 0x61, 0x01, 0x01, 0x02, 0x1e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xa7, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x087c, 0x0878, 0x0874, 0x01e3, 0x01e4, 0x01e5},
+	{
+	 86, 5430, 0x61, 0x01, 0x01, 0x02, 0x1f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0b, 0x00, 0xa6, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0880, 0x087c, 0x0878, 0x01e2, 0x01e3, 0x01e4},
+	{
+	 88, 5440, 0x5a, 0x01, 0x01, 0x02, 0x20, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0xa6, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0884, 0x0880, 0x087c, 0x01e1, 0x01e2, 0x01e3},
+	{
+	 90, 5450, 0x5a, 0x01, 0x01, 0x02, 0x21, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0888, 0x0884, 0x0880, 0x01e0, 0x01e1, 0x01e2},
+	{
+	 92, 5460, 0x53, 0x01, 0x01, 0x02, 0x22, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x088c, 0x0888, 0x0884, 0x01df, 0x01e0, 0x01e1},
+	{
+	 94, 5470, 0x53, 0x01, 0x01, 0x02, 0x23, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x94, 0x73, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0890, 0x088c, 0x0888, 0x01de, 0x01df, 0x01e0},
+	{
+	 96, 5480, 0x4d, 0x01, 0x01, 0x02, 0x24, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x84, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0894, 0x0890, 0x088c, 0x01dd, 0x01de, 0x01df},
+	{
+	 98, 5490, 0x4d, 0x01, 0x01, 0x02, 0x25, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x83, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0898, 0x0894, 0x0890, 0x01dd, 0x01dd, 0x01de},
+	{
+	 100, 5500, 0x47, 0x01, 0x01, 0x02, 0x26, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x089c, 0x0898, 0x0894, 0x01dc, 0x01dd, 0x01dd},
+	{
+	 102, 5510, 0x47, 0x01, 0x01, 0x02, 0x27, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a0, 0x089c, 0x0898, 0x01db, 0x01dc, 0x01dd},
+	{
+	 104, 5520, 0x40, 0x01, 0x01, 0x02, 0x28, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x72, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a4, 0x08a0, 0x089c, 0x01da, 0x01db, 0x01dc},
+	{
+	 106, 5530, 0x40, 0x01, 0x01, 0x02, 0x29, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x72, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a8, 0x08a4, 0x08a0, 0x01d9, 0x01da, 0x01db},
+	{
+	 108, 5540, 0x3a, 0x01, 0x01, 0x02, 0x2a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x71, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08ac, 0x08a8, 0x08a4, 0x01d8, 0x01d9, 0x01da},
+	{
+	 110, 5550, 0x3a, 0x01, 0x01, 0x02, 0x2b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b0, 0x08ac, 0x08a8, 0x01d7, 0x01d8, 0x01d9},
+	{
+	 112, 5560, 0x34, 0x01, 0x01, 0x02, 0x2c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b4, 0x08b0, 0x08ac, 0x01d7, 0x01d7, 0x01d8},
+	{
+	 114, 5570, 0x34, 0x01, 0x01, 0x02, 0x2d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x62, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x62, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b8, 0x08b4, 0x08b0, 0x01d6, 0x01d7, 0x01d7},
+	{
+	 116, 5580, 0x2e, 0x01, 0x01, 0x02, 0x2e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x60, 0x62, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x62, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08bc, 0x08b8, 0x08b4, 0x01d5, 0x01d6, 0x01d7},
+	{
+	 118, 5590, 0x2e, 0x01, 0x01, 0x02, 0x2f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x50, 0x61, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x61, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c0, 0x08bc, 0x08b8, 0x01d4, 0x01d5, 0x01d6},
+	{
+	 120, 5600, 0x28, 0x01, 0x01, 0x02, 0x30, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x51, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c4, 0x08c0, 0x08bc, 0x01d3, 0x01d4, 0x01d5},
+	{
+	 122, 5610, 0x28, 0x01, 0x01, 0x02, 0x31, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x51, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c8, 0x08c4, 0x08c0, 0x01d2, 0x01d3, 0x01d4},
+	{
+	 124, 5620, 0x21, 0x01, 0x01, 0x02, 0x32, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08cc, 0x08c8, 0x08c4, 0x01d2, 0x01d2, 0x01d3},
+	{
+	 126, 5630, 0x21, 0x01, 0x01, 0x02, 0x33, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x50, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d0, 0x08cc, 0x08c8, 0x01d1, 0x01d2, 0x01d2},
+	{
+	 128, 5640, 0x1c, 0x01, 0x01, 0x02, 0x34, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d4, 0x08d0, 0x08cc, 0x01d0, 0x01d1, 0x01d2},
+	{
+	 130, 5650, 0x1c, 0x01, 0x01, 0x02, 0x35, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x40, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d8, 0x08d4, 0x08d0, 0x01cf, 0x01d0, 0x01d1},
+	{
+	 132, 5660, 0x16, 0x01, 0x01, 0x02, 0x36, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x40, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08dc, 0x08d8, 0x08d4, 0x01ce, 0x01cf, 0x01d0},
+	{
+	 134, 5670, 0x16, 0x01, 0x01, 0x02, 0x37, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce, 0x01ce, 0x01cf},
+	{
+	 136, 5680, 0x10, 0x01, 0x01, 0x02, 0x38, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd, 0x01ce, 0x01ce},
+	{
+	 138, 5690, 0x10, 0x01, 0x01, 0x02, 0x39, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc, 0x01cd, 0x01ce},
+	{
+	 140, 5700, 0x0a, 0x01, 0x01, 0x02, 0x3a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb, 0x01cc, 0x01cd},
+	{
+	 142, 5710, 0x0a, 0x01, 0x01, 0x02, 0x3b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca, 0x01cb, 0x01cc},
+	{
+	 144, 5720, 0x0a, 0x01, 0x01, 0x02, 0x3c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 145, 5725, 0x03, 0x01, 0x02, 0x04, 0x79, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 146, 5730, 0x0a, 0x01, 0x01, 0x02, 0x3d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9, 0x01c9, 0x01ca},
+	{
+	 147, 5735, 0x03, 0x01, 0x02, 0x04, 0x7b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8, 0x01c9, 0x01ca},
+	{
+	 148, 5740, 0x0a, 0x01, 0x01, 0x02, 0x3e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8, 0x01c9, 0x01c9},
+	{
+	 149, 5745, 0xfe, 0x00, 0x02, 0x04, 0x7d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8, 0x01c8, 0x01c9},
+	{
+	 150, 5750, 0x0a, 0x01, 0x01, 0x02, 0x3f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6d, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6d, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7, 0x01c8, 0x01c9},
+	{
+	 151, 5755, 0xfe, 0x00, 0x02, 0x04, 0x7f, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7, 0x01c8, 0x01c8},
+	{
+	 152, 5760, 0x0a, 0x01, 0x01, 0x02, 0x40, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 153, 5765, 0xf8, 0x00, 0x02, 0x04, 0x81, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 154, 5770, 0x0a, 0x01, 0x01, 0x02, 0x41, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6, 0x01c6, 0x01c7},
+	{
+	 155, 5775, 0xf8, 0x00, 0x02, 0x04, 0x83, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5, 0x01c6, 0x01c7},
+	{
+	 156, 5780, 0x0a, 0x01, 0x01, 0x02, 0x42, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5, 0x01c6, 0x01c6},
+	{
+	 157, 5785, 0xf2, 0x00, 0x02, 0x04, 0x85, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 158, 5790, 0x0a, 0x01, 0x01, 0x02, 0x43, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 159, 5795, 0xf2, 0x00, 0x02, 0x04, 0x87, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4, 0x01c4, 0x01c5},
+	{
+	 160, 5800, 0x0a, 0x01, 0x01, 0x02, 0x44, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3, 0x01c4, 0x01c5},
+	{
+	 161, 5805, 0xed, 0x00, 0x02, 0x04, 0x89, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3, 0x01c4, 0x01c4},
+	{
+	 162, 5810, 0x0a, 0x01, 0x01, 0x02, 0x45, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 163, 5815, 0xed, 0x00, 0x02, 0x04, 0x8b, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 164, 5820, 0x0a, 0x01, 0x01, 0x02, 0x46, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2, 0x01c2, 0x01c3},
+	{
+	 165, 5825, 0xed, 0x00, 0x02, 0x04, 0x8d, 0x07, 0x07, 0x04, 0x10, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x69, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1, 0x01c2, 0x01c3},
+	{
+	 166, 5830, 0x0a, 0x01, 0x01, 0x02, 0x47, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x69, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1, 0x01c2, 0x01c2},
+	{
+	 168, 5840, 0x0a, 0x01, 0x01, 0x02, 0x48, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0, 0x01c1, 0x01c2},
+	{
+	 170, 5850, 0xe0, 0x00, 0x01, 0x02, 0x49, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf, 0x01c0, 0x01c1},
+	{
+	 172, 5860, 0xde, 0x00, 0x01, 0x02, 0x4a, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf, 0x01bf, 0x01c0},
+	{
+	 174, 5870, 0xdb, 0x00, 0x01, 0x02, 0x4b, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0930, 0x092c, 0x0928, 0x01be, 0x01bf, 0x01bf},
+	{
+	 176, 5880, 0xd8, 0x00, 0x01, 0x02, 0x4c, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd, 0x01be, 0x01bf},
+	{
+	 178, 5890, 0xd6, 0x00, 0x01, 0x02, 0x4d, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc, 0x01bd, 0x01be},
+	{
+	 180, 5900, 0xd3, 0x00, 0x01, 0x02, 0x4e, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc, 0x01bc, 0x01bd},
+	{
+	 182, 5910, 0xd6, 0x00, 0x01, 0x02, 0x4f, 0x05, 0x05, 0x04, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0940, 0x093c, 0x0938, 0x01bb, 0x01bc, 0x01bc},
+	{
+	 1, 2412, 0x00, 0x01, 0x03, 0x09, 0x6c, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x04, 0x04, 0x04, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x78, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03c9, 0x03c5, 0x03c1, 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x00, 0x01, 0x03, 0x09, 0x71, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x78, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03cb, 0x03c7, 0x03c3, 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x00, 0x01, 0x03, 0x09, 0x76, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x67, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03cd, 0x03c9, 0x03c5, 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x00, 0x01, 0x03, 0x09, 0x7b, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x57, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x78, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03cf, 0x03cb, 0x03c7, 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x00, 0x01, 0x03, 0x09, 0x80, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x56, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x77, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d1, 0x03cd, 0x03c9, 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x00, 0x01, 0x03, 0x09, 0x85, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x46, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x76, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d3, 0x03cf, 0x03cb, 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x00, 0x01, 0x03, 0x09, 0x8a, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x45, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x66, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d5, 0x03d1, 0x03cd, 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x00, 0x01, 0x03, 0x09, 0x8f, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x34, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x55, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03d7, 0x03d3, 0x03cf, 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x00, 0x01, 0x03, 0x09, 0x94, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x23, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x45, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03d9, 0x03d5, 0x03d1, 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x00, 0x01, 0x03, 0x09, 0x99, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x12, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x34, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03db, 0x03d7, 0x03d3, 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x00, 0x01, 0x03, 0x09, 0x9e, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x33, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03dd, 0x03d9, 0x03d5, 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x00, 0x01, 0x03, 0x09, 0xa3, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x22, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03df, 0x03db, 0x03d7, 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x00, 0x01, 0x03, 0x09, 0xa8, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x11, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03e1, 0x03dd, 0x03d9, 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0xff, 0x01, 0x03, 0x09, 0xb4, 0x08, 0x08, 0x04, 0x16, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03e6, 0x03e2, 0x03de, 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio205x_t chan_info_nphyrev6_2056v11[] = {
+	{
+	 184, 4920, 0xff, 0x01, 0x01, 0x01, 0xec, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b4, 0x07b0, 0x07ac, 0x0214, 0x0215, 0x0216},
+	{
+	 186, 4930, 0xff, 0x01, 0x01, 0x01, 0xed, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07b8, 0x07b4, 0x07b0, 0x0213, 0x0214, 0x0215},
+	{
+	 188, 4940, 0xff, 0x01, 0x01, 0x01, 0xee, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07bc, 0x07b8, 0x07b4, 0x0212, 0x0213, 0x0214},
+	{
+	 190, 4950, 0xff, 0x01, 0x01, 0x01, 0xef, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x00, 0x00, 0x00, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c0, 0x07bc, 0x07b8, 0x0211, 0x0212, 0x0213},
+	{
+	 192, 4960, 0xff, 0x01, 0x01, 0x01, 0xf0, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c4, 0x07c0, 0x07bc, 0x020f, 0x0211, 0x0212},
+	{
+	 194, 4970, 0xff, 0x01, 0x01, 0x01, 0xf1, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07c8, 0x07c4, 0x07c0, 0x020e, 0x020f, 0x0211},
+	{
+	 196, 4980, 0xff, 0x01, 0x01, 0x01, 0xf2, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07cc, 0x07c8, 0x07c4, 0x020d, 0x020e, 0x020f},
+	{
+	 198, 4990, 0xff, 0x01, 0x01, 0x01, 0xf3, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d0, 0x07cc, 0x07c8, 0x020c, 0x020d, 0x020e},
+	{
+	 200, 5000, 0xff, 0x01, 0x01, 0x01, 0xf4, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d4, 0x07d0, 0x07cc, 0x020b, 0x020c, 0x020d},
+	{
+	 202, 5010, 0xff, 0x01, 0x01, 0x01, 0xf5, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07d8, 0x07d4, 0x07d0, 0x020a, 0x020b, 0x020c},
+	{
+	 204, 5020, 0xf7, 0x01, 0x01, 0x01, 0xf6, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07dc, 0x07d8, 0x07d4, 0x0209, 0x020a, 0x020b},
+	{
+	 206, 5030, 0xf7, 0x01, 0x01, 0x01, 0xf7, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e0, 0x07dc, 0x07d8, 0x0208, 0x0209, 0x020a},
+	{
+	 208, 5040, 0xef, 0x01, 0x01, 0x01, 0xf8, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e4, 0x07e0, 0x07dc, 0x0207, 0x0208, 0x0209},
+	{
+	 210, 5050, 0xef, 0x01, 0x01, 0x01, 0xf9, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07e8, 0x07e4, 0x07e0, 0x0206, 0x0207, 0x0208},
+	{
+	 212, 5060, 0xe6, 0x01, 0x01, 0x01, 0xfa, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfe, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfe, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07ec, 0x07e8, 0x07e4, 0x0205, 0x0206, 0x0207},
+	{
+	 214, 5070, 0xe6, 0x01, 0x01, 0x01, 0xfb, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f0, 0x07ec, 0x07e8, 0x0204, 0x0205, 0x0206},
+	{
+	 216, 5080, 0xde, 0x01, 0x01, 0x01, 0xfc, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f4, 0x07f0, 0x07ec, 0x0203, 0x0204, 0x0205},
+	{
+	 218, 5090, 0xde, 0x01, 0x01, 0x01, 0xfd, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x01, 0x01, 0x01, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x09, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x09, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07f8, 0x07f4, 0x07f0, 0x0202, 0x0203, 0x0204},
+	{
+	 220, 5100, 0xd6, 0x01, 0x01, 0x01, 0xfe, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfd, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfd, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x07fc, 0x07f8, 0x07f4, 0x0201, 0x0202, 0x0203},
+	{
+	 222, 5110, 0xd6, 0x01, 0x01, 0x01, 0xff, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0800, 0x07fc, 0x07f8, 0x0200, 0x0201, 0x0202},
+	{
+	 224, 5120, 0xce, 0x01, 0x01, 0x02, 0x00, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0804, 0x0800, 0x07fc, 0x01ff, 0x0200, 0x0201},
+	{
+	 226, 5130, 0xce, 0x01, 0x01, 0x02, 0x01, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfc, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfc, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x0808, 0x0804, 0x0800, 0x01fe, 0x01ff, 0x0200},
+	{
+	 228, 5140, 0xc6, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfb, 0x00, 0x08, 0x00, 0x77,
+	 0x00, 0x0f, 0x00, 0x6f, 0x00, 0xfb, 0x00, 0x08, 0x00, 0x77, 0x00, 0x0f,
+	 0x00, 0x6f, 0x00, 0x080c, 0x0808, 0x0804, 0x01fd, 0x01fe, 0x01ff},
+	{
+	 32, 5160, 0xbe, 0x01, 0x01, 0x02, 0x04, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x07, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xfa, 0x00, 0x07, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x0814, 0x0810, 0x080c, 0x01fb, 0x01fc, 0x01fd},
+	{
+	 34, 5170, 0xbe, 0x01, 0x01, 0x02, 0x05, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xfa, 0x00, 0x07, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xfa, 0x00, 0x07, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x0818, 0x0814, 0x0810, 0x01fa, 0x01fb, 0x01fc},
+	{
+	 36, 5180, 0xb6, 0x01, 0x01, 0x02, 0x06, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x06, 0x00, 0x77,
+	 0x00, 0x0e, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x06, 0x00, 0x77, 0x00, 0x0e,
+	 0x00, 0x6f, 0x00, 0x081c, 0x0818, 0x0814, 0x01f9, 0x01fa, 0x01fb},
+	{
+	 38, 5190, 0xb6, 0x01, 0x01, 0x02, 0x07, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x06, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x06, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0820, 0x081c, 0x0818, 0x01f8, 0x01f9, 0x01fa},
+	{
+	 40, 5200, 0xaf, 0x01, 0x01, 0x02, 0x08, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0824, 0x0820, 0x081c, 0x01f7, 0x01f8, 0x01f9},
+	{
+	 42, 5210, 0xaf, 0x01, 0x01, 0x02, 0x09, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8f, 0x0f, 0x00, 0xff, 0xf9, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xf9, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0828, 0x0824, 0x0820, 0x01f6, 0x01f7, 0x01f8},
+	{
+	 44, 5220, 0xa7, 0x01, 0x01, 0x02, 0x0a, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xfe, 0xd8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xd8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x082c, 0x0828, 0x0824, 0x01f5, 0x01f6, 0x01f7},
+	{
+	 46, 5230, 0xa7, 0x01, 0x01, 0x02, 0x0b, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xd8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xd8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0830, 0x082c, 0x0828, 0x01f4, 0x01f5, 0x01f6},
+	{
+	 48, 5240, 0xa0, 0x01, 0x01, 0x02, 0x0c, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xee, 0xc8, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc8, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0834, 0x0830, 0x082c, 0x01f3, 0x01f4, 0x01f5},
+	{
+	 50, 5250, 0xa0, 0x01, 0x01, 0x02, 0x0d, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0f, 0x00, 0xed, 0xc7, 0x00, 0x05, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x05, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x0838, 0x0834, 0x0830, 0x01f2, 0x01f3, 0x01f4},
+	{
+	 52, 5260, 0x98, 0x01, 0x01, 0x02, 0x0e, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x02, 0x02, 0x02, 0x8e, 0x0e, 0x00, 0xed, 0xc7, 0x00, 0x04, 0x00, 0x77,
+	 0x00, 0x0d, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x04, 0x00, 0x77, 0x00, 0x0d,
+	 0x00, 0x6f, 0x00, 0x083c, 0x0838, 0x0834, 0x01f1, 0x01f2, 0x01f3},
+	{
+	 54, 5270, 0x98, 0x01, 0x01, 0x02, 0x0f, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8e, 0x0e, 0x00, 0xed, 0xc7, 0x00, 0x04, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xc7, 0x00, 0x04, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0840, 0x083c, 0x0838, 0x01f0, 0x01f1, 0x01f2},
+	{
+	 56, 5280, 0x91, 0x01, 0x01, 0x02, 0x10, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0844, 0x0840, 0x083c, 0x01f0, 0x01f0, 0x01f1},
+	{
+	 58, 5290, 0x91, 0x01, 0x01, 0x02, 0x11, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0848, 0x0844, 0x0840, 0x01ef, 0x01f0, 0x01f0},
+	{
+	 60, 5300, 0x8a, 0x01, 0x01, 0x02, 0x12, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x084c, 0x0848, 0x0844, 0x01ee, 0x01ef, 0x01f0},
+	{
+	 62, 5310, 0x8a, 0x01, 0x01, 0x02, 0x13, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdc, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0850, 0x084c, 0x0848, 0x01ed, 0x01ee, 0x01ef},
+	{
+	 64, 5320, 0x83, 0x01, 0x01, 0x02, 0x14, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0e, 0x00, 0xdb, 0xb7, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0c, 0x00, 0x6f, 0x00, 0xb7, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0c,
+	 0x00, 0x6f, 0x00, 0x0854, 0x0850, 0x084c, 0x01ec, 0x01ed, 0x01ee},
+	{
+	 66, 5330, 0x83, 0x01, 0x01, 0x02, 0x15, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xcb, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0858, 0x0854, 0x0850, 0x01eb, 0x01ec, 0x01ed},
+	{
+	 68, 5340, 0x7c, 0x01, 0x01, 0x02, 0x16, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8d, 0x0d, 0x00, 0xca, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x085c, 0x0858, 0x0854, 0x01ea, 0x01eb, 0x01ec},
+	{
+	 70, 5350, 0x7c, 0x01, 0x01, 0x02, 0x17, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xca, 0xa6, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0b, 0x00, 0x6f, 0x00, 0xa6, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0b,
+	 0x00, 0x6f, 0x00, 0x0860, 0x085c, 0x0858, 0x01e9, 0x01ea, 0x01eb},
+	{
+	 72, 5360, 0x75, 0x01, 0x01, 0x02, 0x18, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0864, 0x0860, 0x085c, 0x01e8, 0x01e9, 0x01ea},
+	{
+	 74, 5370, 0x75, 0x01, 0x01, 0x02, 0x19, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0d, 0x00, 0xc9, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0868, 0x0864, 0x0860, 0x01e7, 0x01e8, 0x01e9},
+	{
+	 76, 5380, 0x6e, 0x01, 0x01, 0x02, 0x1a, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x95, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x95, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x086c, 0x0868, 0x0864, 0x01e6, 0x01e7, 0x01e8},
+	{
+	 78, 5390, 0x6e, 0x01, 0x01, 0x02, 0x1b, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x84, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0870, 0x086c, 0x0868, 0x01e5, 0x01e6, 0x01e7},
+	{
+	 80, 5400, 0x67, 0x01, 0x01, 0x02, 0x1c, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb8, 0x84, 0x00, 0x03, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x03, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0874, 0x0870, 0x086c, 0x01e5, 0x01e5, 0x01e6},
+	{
+	 82, 5410, 0x67, 0x01, 0x01, 0x02, 0x1d, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xb7, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0878, 0x0874, 0x0870, 0x01e4, 0x01e5, 0x01e5},
+	{
+	 84, 5420, 0x61, 0x01, 0x01, 0x02, 0x1e, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0c, 0x00, 0xa7, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x087c, 0x0878, 0x0874, 0x01e3, 0x01e4, 0x01e5},
+	{
+	 86, 5430, 0x61, 0x01, 0x01, 0x02, 0x1f, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x03, 0x03, 0x03, 0x8c, 0x0b, 0x00, 0xa6, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x0a, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x0a,
+	 0x00, 0x6f, 0x00, 0x0880, 0x087c, 0x0878, 0x01e2, 0x01e3, 0x01e4},
+	{
+	 88, 5440, 0x5a, 0x01, 0x01, 0x02, 0x20, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0xa6, 0x84, 0x00, 0x02, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x02, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0884, 0x0880, 0x087c, 0x01e1, 0x01e2, 0x01e3},
+	{
+	 90, 5450, 0x5a, 0x01, 0x01, 0x02, 0x21, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0888, 0x0884, 0x0880, 0x01e0, 0x01e1, 0x01e2},
+	{
+	 92, 5460, 0x53, 0x01, 0x01, 0x02, 0x22, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x95, 0x84, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x84, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x088c, 0x0888, 0x0884, 0x01df, 0x01e0, 0x01e1},
+	{
+	 94, 5470, 0x53, 0x01, 0x01, 0x02, 0x23, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8b, 0x0b, 0x00, 0x94, 0x73, 0x00, 0x01, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x01, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0890, 0x088c, 0x0888, 0x01de, 0x01df, 0x01e0},
+	{
+	 96, 5480, 0x4d, 0x01, 0x01, 0x02, 0x24, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x84, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0894, 0x0890, 0x088c, 0x01dd, 0x01de, 0x01df},
+	{
+	 98, 5490, 0x4d, 0x01, 0x01, 0x02, 0x25, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x83, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x0898, 0x0894, 0x0890, 0x01dd, 0x01dd, 0x01de},
+	{
+	 100, 5500, 0x47, 0x01, 0x01, 0x02, 0x26, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x089c, 0x0898, 0x0894, 0x01dc, 0x01dd, 0x01dd},
+	{
+	 102, 5510, 0x47, 0x01, 0x01, 0x02, 0x27, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x82, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a0, 0x089c, 0x0898, 0x01db, 0x01dc, 0x01dd},
+	{
+	 104, 5520, 0x40, 0x01, 0x01, 0x02, 0x28, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x0a, 0x00, 0x72, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a4, 0x08a0, 0x089c, 0x01da, 0x01db, 0x01dc},
+	{
+	 106, 5530, 0x40, 0x01, 0x01, 0x02, 0x29, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x72, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08a8, 0x08a4, 0x08a0, 0x01d9, 0x01da, 0x01db},
+	{
+	 108, 5540, 0x3a, 0x01, 0x01, 0x02, 0x2a, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x8a, 0x09, 0x00, 0x71, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08ac, 0x08a8, 0x08a4, 0x01d8, 0x01d9, 0x01da},
+	{
+	 110, 5550, 0x3a, 0x01, 0x01, 0x02, 0x2b, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b0, 0x08ac, 0x08a8, 0x01d7, 0x01d8, 0x01d9},
+	{
+	 112, 5560, 0x34, 0x01, 0x01, 0x02, 0x2c, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b4, 0x08b0, 0x08ac, 0x01d7, 0x01d7, 0x01d8},
+	{
+	 114, 5570, 0x34, 0x01, 0x01, 0x02, 0x2d, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x09, 0x00, 0x61, 0x62, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x09, 0x00, 0x6f, 0x00, 0x62, 0x00, 0x00, 0x00, 0x77, 0x00, 0x09,
+	 0x00, 0x6f, 0x00, 0x08b8, 0x08b4, 0x08b0, 0x01d6, 0x01d7, 0x01d7},
+	{
+	 116, 5580, 0x2e, 0x01, 0x01, 0x02, 0x2e, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x60, 0x62, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x62, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08bc, 0x08b8, 0x08b4, 0x01d5, 0x01d6, 0x01d7},
+	{
+	 118, 5590, 0x2e, 0x01, 0x01, 0x02, 0x2f, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x04, 0x04, 0x04, 0x89, 0x08, 0x00, 0x50, 0x61, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x61, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c0, 0x08bc, 0x08b8, 0x01d4, 0x01d5, 0x01d6},
+	{
+	 120, 5600, 0x28, 0x01, 0x01, 0x02, 0x30, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x51, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c4, 0x08c0, 0x08bc, 0x01d3, 0x01d4, 0x01d5},
+	{
+	 122, 5610, 0x28, 0x01, 0x01, 0x02, 0x31, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x51, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x08, 0x00, 0x6f, 0x00, 0x51, 0x00, 0x00, 0x00, 0x77, 0x00, 0x08,
+	 0x00, 0x6f, 0x00, 0x08c8, 0x08c4, 0x08c0, 0x01d2, 0x01d3, 0x01d4},
+	{
+	 124, 5620, 0x21, 0x01, 0x01, 0x02, 0x32, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x89, 0x08, 0x00, 0x50, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08cc, 0x08c8, 0x08c4, 0x01d2, 0x01d2, 0x01d3},
+	{
+	 126, 5630, 0x21, 0x01, 0x01, 0x02, 0x33, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x50, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d0, 0x08cc, 0x08c8, 0x01d1, 0x01d2, 0x01d2},
+	{
+	 128, 5640, 0x1c, 0x01, 0x01, 0x02, 0x34, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x50, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x50, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d4, 0x08d0, 0x08cc, 0x01d0, 0x01d1, 0x01d2},
+	{
+	 130, 5650, 0x1c, 0x01, 0x01, 0x02, 0x35, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x07, 0x00, 0x6f, 0x00, 0x40, 0x00, 0x00, 0x00, 0x77, 0x00, 0x07,
+	 0x00, 0x6f, 0x00, 0x08d8, 0x08d4, 0x08d0, 0x01cf, 0x01d0, 0x01d1},
+	{
+	 132, 5660, 0x16, 0x01, 0x01, 0x02, 0x36, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x40, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08dc, 0x08d8, 0x08d4, 0x01ce, 0x01cf, 0x01d0},
+	{
+	 134, 5670, 0x16, 0x01, 0x01, 0x02, 0x37, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x88, 0x07, 0x00, 0x40, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce, 0x01ce, 0x01cf},
+	{
+	 136, 5680, 0x10, 0x01, 0x01, 0x02, 0x38, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd, 0x01ce, 0x01ce},
+	{
+	 138, 5690, 0x10, 0x01, 0x01, 0x02, 0x39, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6f, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6f, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc, 0x01cd, 0x01ce},
+	{
+	 140, 5700, 0x0a, 0x01, 0x01, 0x02, 0x3a, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb, 0x01cc, 0x01cd},
+	{
+	 142, 5710, 0x0a, 0x01, 0x01, 0x02, 0x3b, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca, 0x01cb, 0x01cc},
+	{
+	 144, 5720, 0x0a, 0x01, 0x01, 0x02, 0x3c, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 145, 5725, 0x03, 0x01, 0x02, 0x04, 0x79, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x06, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9, 0x01ca, 0x01cb},
+	{
+	 146, 5730, 0x0a, 0x01, 0x01, 0x02, 0x3d, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6e, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6e, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9, 0x01c9, 0x01ca},
+	{
+	 147, 5735, 0x03, 0x01, 0x02, 0x04, 0x7b, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8, 0x01c9, 0x01ca},
+	{
+	 148, 5740, 0x0a, 0x01, 0x01, 0x02, 0x3e, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8, 0x01c9, 0x01c9},
+	{
+	 149, 5745, 0xfe, 0x00, 0x02, 0x04, 0x7d, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x06, 0x00, 0x6d, 0x00, 0x30, 0x00, 0x00, 0x00, 0x77, 0x00, 0x06,
+	 0x00, 0x6d, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8, 0x01c8, 0x01c9},
+	{
+	 150, 5750, 0x0a, 0x01, 0x01, 0x02, 0x3f, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6d, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6d, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7, 0x01c8, 0x01c9},
+	{
+	 151, 5755, 0xfe, 0x00, 0x02, 0x04, 0x7f, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x05, 0x05, 0x05, 0x87, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7, 0x01c8, 0x01c8},
+	{
+	 152, 5760, 0x0a, 0x01, 0x01, 0x02, 0x40, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x20, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 153, 5765, 0xf8, 0x00, 0x02, 0x04, 0x81, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x05, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6c, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6c, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6, 0x01c7, 0x01c8},
+	{
+	 154, 5770, 0x0a, 0x01, 0x01, 0x02, 0x41, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6, 0x01c6, 0x01c7},
+	{
+	 155, 5775, 0xf8, 0x00, 0x02, 0x04, 0x83, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5, 0x01c6, 0x01c7},
+	{
+	 156, 5780, 0x0a, 0x01, 0x01, 0x02, 0x42, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x05, 0x05, 0x05, 0x86, 0x04, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5, 0x01c6, 0x01c6},
+	{
+	 157, 5785, 0xf2, 0x00, 0x02, 0x04, 0x85, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 158, 5790, 0x0a, 0x01, 0x01, 0x02, 0x43, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x10, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4, 0x01c5, 0x01c6},
+	{
+	 159, 5795, 0xf2, 0x00, 0x02, 0x04, 0x87, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4, 0x01c4, 0x01c5},
+	{
+	 160, 5800, 0x0a, 0x01, 0x01, 0x02, 0x44, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6b, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3, 0x01c4, 0x01c5},
+	{
+	 161, 5805, 0xed, 0x00, 0x02, 0x04, 0x89, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3, 0x01c4, 0x01c4},
+	{
+	 162, 5810, 0x0a, 0x01, 0x01, 0x02, 0x45, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 163, 5815, 0xed, 0x00, 0x02, 0x04, 0x8b, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2, 0x01c3, 0x01c4},
+	{
+	 164, 5820, 0x0a, 0x01, 0x01, 0x02, 0x46, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x6a, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2, 0x01c2, 0x01c3},
+	{
+	 165, 5825, 0xed, 0x00, 0x02, 0x04, 0x8d, 0x05, 0x05, 0x02, 0x15, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x69, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1, 0x01c2, 0x01c3},
+	{
+	 166, 5830, 0x0a, 0x01, 0x01, 0x02, 0x47, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x05, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x05,
+	 0x00, 0x69, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1, 0x01c2, 0x01c2},
+	{
+	 168, 5840, 0x0a, 0x01, 0x01, 0x02, 0x48, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0, 0x01c1, 0x01c2},
+	{
+	 170, 5850, 0xe0, 0x00, 0x01, 0x02, 0x49, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf, 0x01c0, 0x01c1},
+	{
+	 172, 5860, 0xde, 0x00, 0x01, 0x02, 0x4a, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x69, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf, 0x01bf, 0x01c0},
+	{
+	 174, 5870, 0xdb, 0x00, 0x01, 0x02, 0x4b, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0930, 0x092c, 0x0928, 0x01be, 0x01bf, 0x01bf},
+	{
+	 176, 5880, 0xd8, 0x00, 0x01, 0x02, 0x4c, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd, 0x01be, 0x01bf},
+	{
+	 178, 5890, 0xd6, 0x00, 0x01, 0x02, 0x4d, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc, 0x01bd, 0x01be},
+	{
+	 180, 5900, 0xd3, 0x00, 0x01, 0x02, 0x4e, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc, 0x01bc, 0x01bd},
+	{
+	 182, 5910, 0xd6, 0x00, 0x01, 0x02, 0x4f, 0x05, 0x05, 0x02, 0x0c, 0x01,
+	 0x06, 0x06, 0x06, 0x85, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
+	 0x00, 0x04, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x04,
+	 0x00, 0x68, 0x00, 0x0940, 0x093c, 0x0938, 0x01bb, 0x01bc, 0x01bc},
+	{
+	 1, 2412, 0x00, 0x01, 0x03, 0x09, 0x6c, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x04, 0x04, 0x04, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x78, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03c9, 0x03c5, 0x03c1, 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x00, 0x01, 0x03, 0x09, 0x71, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x78, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03cb, 0x03c7, 0x03c3, 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x00, 0x01, 0x03, 0x09, 0x76, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x67, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0b, 0x00, 0x0a, 0x00, 0x89, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0b, 0x00, 0x0a, 0x03cd, 0x03c9, 0x03c5, 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x00, 0x01, 0x03, 0x09, 0x7b, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x57, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x78, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03cf, 0x03cb, 0x03c7, 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x00, 0x01, 0x03, 0x09, 0x80, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x56, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x77, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d1, 0x03cd, 0x03c9, 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x00, 0x01, 0x03, 0x09, 0x85, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x46, 0x00, 0x03, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x76, 0x00, 0x03, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d3, 0x03cf, 0x03cb, 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x00, 0x01, 0x03, 0x09, 0x8a, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x05, 0x05, 0x05, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x45, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x66, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x0a, 0x03d5, 0x03d1, 0x03cd, 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x00, 0x01, 0x03, 0x09, 0x8f, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x34, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x55, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03d7, 0x03d3, 0x03cf, 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x00, 0x01, 0x03, 0x09, 0x94, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x23, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x45, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03d9, 0x03d5, 0x03d1, 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x00, 0x01, 0x03, 0x09, 0x99, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x12, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x34, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x0a, 0x00, 0x09, 0x03db, 0x03d7, 0x03d3, 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x00, 0x01, 0x03, 0x09, 0x9e, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x33, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03dd, 0x03d9, 0x03d5, 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x00, 0x01, 0x03, 0x09, 0xa3, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x06, 0x06, 0x06, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x22, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03df, 0x03db, 0x03d7, 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x00, 0x01, 0x03, 0x09, 0xa8, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x30, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x11, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03e1, 0x03dd, 0x03d9, 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0xff, 0x01, 0x03, 0x09, 0xb4, 0x06, 0x06, 0x04, 0x2b, 0x01,
+	 0x07, 0x07, 0x07, 0x8f, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
+	 0x70, 0x00, 0x09, 0x00, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x70, 0x00,
+	 0x09, 0x00, 0x09, 0x03e6, 0x03e2, 0x03de, 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio2057_t chan_info_nphyrev7_2057_rev4[] = {
+	{
+	 184, 4920, 0x68, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xec, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07b4, 0x07b0, 0x07ac, 0x0214,
+	 0x0215,
+	 0x0216,
+	 },
+	{
+	 186, 4930, 0x6b, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xed, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07b8, 0x07b4, 0x07b0, 0x0213,
+	 0x0214,
+	 0x0215,
+	 },
+	{
+	 188, 4940, 0x6e, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xee, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07bc, 0x07b8, 0x07b4, 0x0212,
+	 0x0213,
+	 0x0214,
+	 },
+	{
+	 190, 4950, 0x72, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xef, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07c0, 0x07bc, 0x07b8, 0x0211,
+	 0x0212,
+	 0x0213,
+	 },
+	{
+	 192, 4960, 0x75, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf0, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07c4, 0x07c0, 0x07bc, 0x020f,
+	 0x0211,
+	 0x0212,
+	 },
+	{
+	 194, 4970, 0x78, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf1, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07c8, 0x07c4, 0x07c0, 0x020e,
+	 0x020f,
+	 0x0211,
+	 },
+	{
+	 196, 4980, 0x7c, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf2, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07cc, 0x07c8, 0x07c4, 0x020d,
+	 0x020e,
+	 0x020f,
+	 },
+	{
+	 198, 4990, 0x7f, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf3, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07d0, 0x07cc, 0x07c8, 0x020c,
+	 0x020d,
+	 0x020e,
+	 },
+	{
+	 200, 5000, 0x82, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf4, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07d4, 0x07d0, 0x07cc, 0x020b,
+	 0x020c,
+	 0x020d,
+	 },
+	{
+	 202, 5010, 0x86, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf5, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07d8, 0x07d4, 0x07d0, 0x020a,
+	 0x020b,
+	 0x020c,
+	 },
+	{
+	 204, 5020, 0x89, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf6, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07dc, 0x07d8, 0x07d4, 0x0209,
+	 0x020a,
+	 0x020b,
+	 },
+	{
+	 206, 5030, 0x8c, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf7, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07e0, 0x07dc, 0x07d8, 0x0208,
+	 0x0209,
+	 0x020a,
+	 },
+	{
+	 208, 5040, 0x90, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf8, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07e4, 0x07e0, 0x07dc, 0x0207,
+	 0x0208,
+	 0x0209,
+	 },
+	{
+	 210, 5050, 0x93, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf9, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xf3, 0x00, 0xef, 0x07e8, 0x07e4, 0x07e0, 0x0206,
+	 0x0207,
+	 0x0208,
+	 },
+	{
+	 212, 5060, 0x96, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfa, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xe3, 0x00, 0xef, 0x00,
+	 0x00, 0x0f, 0x0f, 0xe3, 0x00, 0xef, 0x07ec, 0x07e8, 0x07e4, 0x0205,
+	 0x0206,
+	 0x0207,
+	 },
+	{
+	 214, 5070, 0x9a, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfb, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xef, 0x00,
+	 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xef, 0x07f0, 0x07ec, 0x07e8, 0x0204,
+	 0x0205,
+	 0x0206,
+	 },
+	{
+	 216, 5080, 0x9d, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfc, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xef, 0x00,
+	 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xef, 0x07f4, 0x07f0, 0x07ec, 0x0203,
+	 0x0204,
+	 0x0205,
+	 },
+	{
+	 218, 5090, 0xa0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfd, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x07f8, 0x07f4, 0x07f0, 0x0202,
+	 0x0203,
+	 0x0204,
+	 },
+	{
+	 220, 5100, 0xa4, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfe, 0x01, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x07fc, 0x07f8, 0x07f4, 0x0201,
+	 0x0202,
+	 0x0203,
+	 },
+	{
+	 222, 5110, 0xa7, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xff, 0x01, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x0800, 0x07fc, 0x07f8, 0x0200,
+	 0x0201,
+	 0x0202,
+	 },
+	{
+	 224, 5120, 0xaa, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x00, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x0804, 0x0800, 0x07fc, 0x01ff,
+	 0x0200,
+	 0x0201,
+	 },
+	{
+	 226, 5130, 0xae, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x01, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0e, 0x0f, 0xe3, 0x00, 0xd6, 0x0808, 0x0804, 0x0800, 0x01fe,
+	 0x01ff,
+	 0x0200,
+	 },
+	{
+	 228, 5140, 0xb1, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x02, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0e, 0x0e, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0e, 0x0e, 0xe3, 0x00, 0xd6, 0x080c, 0x0808, 0x0804, 0x01fd,
+	 0x01fe,
+	 0x01ff,
+	 },
+	{
+	 32, 5160, 0xb8, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x04, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0d, 0x0e, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0d, 0x0e, 0xe3, 0x00, 0xd6, 0x0814, 0x0810, 0x080c, 0x01fb,
+	 0x01fc,
+	 0x01fd,
+	 },
+	{
+	 34, 5170, 0xbb, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x05, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0d, 0x0e, 0xe3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0d, 0x0e, 0xe3, 0x00, 0xd6, 0x0818, 0x0814, 0x0810, 0x01fa,
+	 0x01fb,
+	 0x01fc,
+	 },
+	{
+	 36, 5180, 0xbe, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x06, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x081c, 0x0818, 0x0814, 0x01f9,
+	 0x01fa,
+	 0x01fb,
+	 },
+	{
+	 38, 5190, 0xc2, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x07, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x0820, 0x081c, 0x0818, 0x01f8,
+	 0x01f9,
+	 0x01fa,
+	 },
+	{
+	 40, 5200, 0xc5, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x08, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x0824, 0x0820, 0x081c, 0x01f7,
+	 0x01f8,
+	 0x01f9,
+	 },
+	{
+	 42, 5210, 0xc8, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x09, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0d, 0x0e, 0xd3, 0x00, 0xd6, 0x0828, 0x0824, 0x0820, 0x01f6,
+	 0x01f7,
+	 0x01f8,
+	 },
+	{
+	 44, 5220, 0xcc, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0a, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x082c, 0x0828, 0x0824, 0x01f5,
+	 0x01f6,
+	 0x01f7,
+	 },
+	{
+	 46, 5230, 0xcf, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0b, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x0830, 0x082c, 0x0828, 0x01f4,
+	 0x01f5,
+	 0x01f6,
+	 },
+	{
+	 48, 5240, 0xd2, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0c, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x0834, 0x0830, 0x082c, 0x01f3,
+	 0x01f4,
+	 0x01f5,
+	 },
+	{
+	 50, 5250, 0xd6, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0d, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0c, 0x0e, 0xd3, 0x00, 0xd6, 0x0838, 0x0834, 0x0830, 0x01f2,
+	 0x01f3,
+	 0x01f4,
+	 },
+	{
+	 52, 5260, 0xd9, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0e, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0c, 0x0d, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0c, 0x0d, 0xd3, 0x00, 0xd6, 0x083c, 0x0838, 0x0834, 0x01f1,
+	 0x01f2,
+	 0x01f3,
+	 },
+	{
+	 54, 5270, 0xdc, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0f, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0c, 0x0d, 0xd3, 0x00, 0xd6, 0x00,
+	 0x00, 0x0c, 0x0d, 0xd3, 0x00, 0xd6, 0x0840, 0x083c, 0x0838, 0x01f0,
+	 0x01f1,
+	 0x01f2,
+	 },
+	{
+	 56, 5280, 0xe0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x10, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0c, 0x0c, 0xc3, 0x00, 0xd4, 0x00,
+	 0x00, 0x0c, 0x0c, 0xc3, 0x00, 0xd4, 0x0844, 0x0840, 0x083c, 0x01f0,
+	 0x01f0,
+	 0x01f1,
+	 },
+	{
+	 58, 5290, 0xe3, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x11, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0c, 0x0c, 0xc3, 0x00, 0xd4, 0x00,
+	 0x00, 0x0c, 0x0c, 0xc3, 0x00, 0xd4, 0x0848, 0x0844, 0x0840, 0x01ef,
+	 0x01f0,
+	 0x01f0,
+	 },
+	{
+	 60, 5300, 0xe6, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x12, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0c, 0x0c, 0xc3, 0x00, 0xd4, 0x00,
+	 0x00, 0x0c, 0x0c, 0xc3, 0x00, 0xd4, 0x084c, 0x0848, 0x0844, 0x01ee,
+	 0x01ef,
+	 0x01f0,
+	 },
+	{
+	 62, 5310, 0xea, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x13, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0b, 0x0c, 0xc3, 0x00, 0xd4, 0x00,
+	 0x00, 0x0b, 0x0c, 0xc3, 0x00, 0xd4, 0x0850, 0x084c, 0x0848, 0x01ed,
+	 0x01ee,
+	 0x01ef,
+	 },
+	{
+	 64, 5320, 0xed, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x14, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0b, 0x0c, 0xc3, 0x00, 0xd4, 0x00,
+	 0x00, 0x0b, 0x0c, 0xc3, 0x00, 0xd4, 0x0854, 0x0850, 0x084c, 0x01ec,
+	 0x01ed,
+	 0x01ee,
+	 },
+	{
+	 66, 5330, 0xf0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x15, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0b, 0x0c, 0xc3, 0x00, 0xd4, 0x00,
+	 0x00, 0x0b, 0x0c, 0xc3, 0x00, 0xd4, 0x0858, 0x0854, 0x0850, 0x01eb,
+	 0x01ec,
+	 0x01ed,
+	 },
+	{
+	 68, 5340, 0xf4, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x16, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0a, 0x0c, 0xc3, 0x00, 0xa1, 0x00,
+	 0x00, 0x0a, 0x0c, 0xc3, 0x00, 0xa1, 0x085c, 0x0858, 0x0854, 0x01ea,
+	 0x01eb,
+	 0x01ec,
+	 },
+	{
+	 70, 5350, 0xf7, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x17, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x00,
+	 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x0860, 0x085c, 0x0858, 0x01e9,
+	 0x01ea,
+	 0x01eb,
+	 },
+	{
+	 72, 5360, 0xfa, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x18, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x00,
+	 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x0864, 0x0860, 0x085c, 0x01e8,
+	 0x01e9,
+	 0x01ea,
+	 },
+	{
+	 74, 5370, 0xfe, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x19, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x00,
+	 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x0868, 0x0864, 0x0860, 0x01e7,
+	 0x01e8,
+	 0x01e9,
+	 },
+	{
+	 76, 5380, 0x01, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1a, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x00,
+	 0x00, 0x0a, 0x0b, 0xb3, 0x00, 0xa1, 0x086c, 0x0868, 0x0864, 0x01e6,
+	 0x01e7,
+	 0x01e8,
+	 },
+	{
+	 78, 5390, 0x04, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1b, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0a, 0x0a, 0xa3, 0x00, 0xa1, 0x00,
+	 0x00, 0x0a, 0x0a, 0xa3, 0x00, 0xa1, 0x0870, 0x086c, 0x0868, 0x01e5,
+	 0x01e6,
+	 0x01e7,
+	 },
+	{
+	 80, 5400, 0x08, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1c, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x09, 0x0a, 0xa3, 0x00, 0x90, 0x00,
+	 0x00, 0x09, 0x0a, 0xa3, 0x00, 0x90, 0x0874, 0x0870, 0x086c, 0x01e5,
+	 0x01e5,
+	 0x01e6,
+	 },
+	{
+	 82, 5410, 0x0b, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1d, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x09, 0x0a, 0xa3, 0x00, 0x90, 0x00,
+	 0x00, 0x09, 0x0a, 0xa3, 0x00, 0x90, 0x0878, 0x0874, 0x0870, 0x01e4,
+	 0x01e5,
+	 0x01e5,
+	 },
+	{
+	 84, 5420, 0x0e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1e, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x09, 0x09, 0xa3, 0x00, 0x90, 0x00,
+	 0x00, 0x09, 0x09, 0xa3, 0x00, 0x90, 0x087c, 0x0878, 0x0874, 0x01e3,
+	 0x01e4,
+	 0x01e5,
+	 },
+	{
+	 86, 5430, 0x12, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1f, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x09, 0x09, 0x93, 0x00, 0x90, 0x00,
+	 0x00, 0x09, 0x09, 0x93, 0x00, 0x90, 0x0880, 0x087c, 0x0878, 0x01e2,
+	 0x01e3,
+	 0x01e4,
+	 },
+	{
+	 88, 5440, 0x15, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x20, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x09, 0x09, 0x93, 0x00, 0x90, 0x00,
+	 0x00, 0x09, 0x09, 0x93, 0x00, 0x90, 0x0884, 0x0880, 0x087c, 0x01e1,
+	 0x01e2,
+	 0x01e3,
+	 },
+	{
+	 90, 5450, 0x18, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x21, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x09, 0x09, 0x93, 0x00, 0x90, 0x00,
+	 0x00, 0x09, 0x09, 0x93, 0x00, 0x90, 0x0888, 0x0884, 0x0880, 0x01e0,
+	 0x01e1,
+	 0x01e2,
+	 },
+	{
+	 92, 5460, 0x1c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x22, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x08, 0x08, 0x93, 0x00, 0x90, 0x00,
+	 0x00, 0x08, 0x08, 0x93, 0x00, 0x90, 0x088c, 0x0888, 0x0884, 0x01df,
+	 0x01e0,
+	 0x01e1,
+	 },
+	{
+	 94, 5470, 0x1f, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x23, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x08, 0x08, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x08, 0x93, 0x00, 0x60, 0x0890, 0x088c, 0x0888, 0x01de,
+	 0x01df,
+	 0x01e0,
+	 },
+	{
+	 96, 5480, 0x22, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x24, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x0894, 0x0890, 0x088c, 0x01dd,
+	 0x01de,
+	 0x01df,
+	 },
+	{
+	 98, 5490, 0x26, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x25, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x0898, 0x0894, 0x0890, 0x01dd,
+	 0x01dd,
+	 0x01de,
+	 },
+	{
+	 100, 5500, 0x29, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x26, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x089c, 0x0898, 0x0894, 0x01dc,
+	 0x01dd,
+	 0x01dd,
+	 },
+	{
+	 102, 5510, 0x2c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x27, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x07, 0x93, 0x00, 0x60, 0x08a0, 0x089c, 0x0898, 0x01db,
+	 0x01dc,
+	 0x01dd,
+	 },
+	{
+	 104, 5520, 0x30, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x28, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x08, 0x06, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x06, 0x93, 0x00, 0x60, 0x08a4, 0x08a0, 0x089c, 0x01da,
+	 0x01db,
+	 0x01dc,
+	 },
+	{
+	 106, 5530, 0x33, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x29, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x08, 0x06, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x06, 0x93, 0x00, 0x60, 0x08a8, 0x08a4, 0x08a0, 0x01d9,
+	 0x01da,
+	 0x01db,
+	 },
+	{
+	 108, 5540, 0x36, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2a, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x08, 0x06, 0x93, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x06, 0x93, 0x00, 0x60, 0x08ac, 0x08a8, 0x08a4, 0x01d8,
+	 0x01d9,
+	 0x01da,
+	 },
+	{
+	 110, 5550, 0x3a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2b, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x08, 0x05, 0x83, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x05, 0x83, 0x00, 0x60, 0x08b0, 0x08ac, 0x08a8, 0x01d7,
+	 0x01d8,
+	 0x01d9,
+	 },
+	{
+	 112, 5560, 0x3d, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2c, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x08, 0x05, 0x83, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x05, 0x83, 0x00, 0x60, 0x08b4, 0x08b0, 0x08ac, 0x01d7,
+	 0x01d7,
+	 0x01d8,
+	 },
+	{
+	 114, 5570, 0x40, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2d, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x08, 0x05, 0x83, 0x00, 0x60, 0x00,
+	 0x00, 0x08, 0x05, 0x83, 0x00, 0x60, 0x08b8, 0x08b4, 0x08b0, 0x01d6,
+	 0x01d7,
+	 0x01d7,
+	 },
+	{
+	 116, 5580, 0x44, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2e, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x07, 0x05, 0x83, 0x00, 0x60, 0x00,
+	 0x00, 0x07, 0x05, 0x83, 0x00, 0x60, 0x08bc, 0x08b8, 0x08b4, 0x01d5,
+	 0x01d6,
+	 0x01d7,
+	 },
+	{
+	 118, 5590, 0x47, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2f, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x07, 0x04, 0x83, 0x00, 0x60, 0x00,
+	 0x00, 0x07, 0x04, 0x83, 0x00, 0x60, 0x08c0, 0x08bc, 0x08b8, 0x01d4,
+	 0x01d5,
+	 0x01d6,
+	 },
+	{
+	 120, 5600, 0x4a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x30, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x07, 0x04, 0x73, 0x00, 0x30, 0x00,
+	 0x00, 0x07, 0x04, 0x73, 0x00, 0x30, 0x08c4, 0x08c0, 0x08bc, 0x01d3,
+	 0x01d4,
+	 0x01d5,
+	 },
+	{
+	 122, 5610, 0x4e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x31, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x00,
+	 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x08c8, 0x08c4, 0x08c0, 0x01d2,
+	 0x01d3,
+	 0x01d4,
+	 },
+	{
+	 124, 5620, 0x51, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x32, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x00,
+	 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x08cc, 0x08c8, 0x08c4, 0x01d2,
+	 0x01d2,
+	 0x01d3,
+	 },
+	{
+	 126, 5630, 0x54, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x33, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x00,
+	 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x08d0, 0x08cc, 0x08c8, 0x01d1,
+	 0x01d2,
+	 0x01d2,
+	 },
+	{
+	 128, 5640, 0x58, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x34, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x00,
+	 0x00, 0x06, 0x04, 0x73, 0x00, 0x30, 0x08d4, 0x08d0, 0x08cc, 0x01d0,
+	 0x01d1,
+	 0x01d2,
+	 },
+	{
+	 130, 5650, 0x5b, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x35, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x06, 0x03, 0x63, 0x00, 0x30, 0x00,
+	 0x00, 0x06, 0x03, 0x63, 0x00, 0x30, 0x08d8, 0x08d4, 0x08d0, 0x01cf,
+	 0x01d0,
+	 0x01d1,
+	 },
+	{
+	 132, 5660, 0x5e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x36, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x06, 0x03, 0x63, 0x00, 0x30, 0x00,
+	 0x00, 0x06, 0x03, 0x63, 0x00, 0x30, 0x08dc, 0x08d8, 0x08d4, 0x01ce,
+	 0x01cf,
+	 0x01d0,
+	 },
+	{
+	 134, 5670, 0x62, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x37, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x05, 0x03, 0x63, 0x00, 0x00, 0x00,
+	 0x00, 0x05, 0x03, 0x63, 0x00, 0x00, 0x08e0, 0x08dc, 0x08d8, 0x01ce,
+	 0x01ce,
+	 0x01cf,
+	 },
+	{
+	 136, 5680, 0x65, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x38, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x08e4, 0x08e0, 0x08dc, 0x01cd,
+	 0x01ce,
+	 0x01ce,
+	 },
+	{
+	 138, 5690, 0x68, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x39, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x08e8, 0x08e4, 0x08e0, 0x01cc,
+	 0x01cd,
+	 0x01ce,
+	 },
+	{
+	 140, 5700, 0x6c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3a, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x08ec, 0x08e8, 0x08e4, 0x01cb,
+	 0x01cc,
+	 0x01cd,
+	 },
+	{
+	 142, 5710, 0x6f, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3b, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x08f0, 0x08ec, 0x08e8, 0x01ca,
+	 0x01cb,
+	 0x01cc,
+	 },
+	{
+	 144, 5720, 0x72, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3c, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x05, 0x02, 0x53, 0x00, 0x00, 0x08f4, 0x08f0, 0x08ec, 0x01c9,
+	 0x01ca,
+	 0x01cb,
+	 },
+	{
+	 145, 5725, 0x74, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x79, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x05, 0x01, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x05, 0x01, 0x53, 0x00, 0x00, 0x08f6, 0x08f2, 0x08ee, 0x01c9,
+	 0x01ca,
+	 0x01cb,
+	 },
+	{
+	 146, 5730, 0x76, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3d, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x08f8, 0x08f4, 0x08f0, 0x01c9,
+	 0x01c9,
+	 0x01ca,
+	 },
+	{
+	 147, 5735, 0x77, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7b, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x08fa, 0x08f6, 0x08f2, 0x01c8,
+	 0x01c9,
+	 0x01ca,
+	 },
+	{
+	 148, 5740, 0x79, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3e, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x08fc, 0x08f8, 0x08f4, 0x01c8,
+	 0x01c9,
+	 0x01c9,
+	 },
+	{
+	 149, 5745, 0x7b, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7d, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x08fe, 0x08fa, 0x08f6, 0x01c8,
+	 0x01c8,
+	 0x01c9,
+	 },
+	{
+	 150, 5750, 0x7c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3f, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7,
+	 0x01c8,
+	 0x01c9,
+	 },
+	{
+	 151, 5755, 0x7e, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7f, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x53, 0x00, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7,
+	 0x01c8,
+	 0x01c8,
+	 },
+	{
+	 152, 5760, 0x80, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x40, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6,
+	 0x01c7,
+	 0x01c8,
+	 },
+	{
+	 153, 5765, 0x81, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x81, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6,
+	 0x01c7,
+	 0x01c8,
+	 },
+	{
+	 154, 5770, 0x83, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x41, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6,
+	 0x01c6,
+	 0x01c7,
+	 },
+	{
+	 155, 5775, 0x85, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x83, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x04, 0x01, 0x43, 0x00, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5,
+	 0x01c6,
+	 0x01c7,
+	 },
+	{
+	 156, 5780, 0x86, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x42, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x03, 0x01, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x01, 0x43, 0x00, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5,
+	 0x01c6,
+	 0x01c6,
+	 },
+	{
+	 157, 5785, 0x88, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x85, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4,
+	 0x01c5,
+	 0x01c6,
+	 },
+	{
+	 158, 5790, 0x8a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x43, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4,
+	 0x01c5,
+	 0x01c6,
+	 },
+	{
+	 159, 5795, 0x8b, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x87, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4,
+	 0x01c4,
+	 0x01c5,
+	 },
+	{
+	 160, 5800, 0x8d, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x44, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3,
+	 0x01c4,
+	 0x01c5,
+	 },
+	{
+	 161, 5805, 0x8f, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x89, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3,
+	 0x01c4,
+	 0x01c4,
+	 },
+	{
+	 162, 5810, 0x90, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x45, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2,
+	 0x01c3,
+	 0x01c4,
+	 },
+	{
+	 163, 5815, 0x92, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x8b, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2,
+	 0x01c3,
+	 0x01c4,
+	 },
+	{
+	 164, 5820, 0x94, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x46, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2,
+	 0x01c2,
+	 0x01c3,
+	 },
+	{
+	 165, 5825, 0x95, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x8d, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1,
+	 0x01c2,
+	 0x01c3,
+	 },
+	{
+	 166, 5830, 0x97, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x47, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1,
+	 0x01c2,
+	 0x01c2,
+	 },
+	{
+	 168, 5840, 0x9a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x48, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0,
+	 0x01c1,
+	 0x01c2,
+	 },
+	{
+	 170, 5850, 0x9e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x49, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf,
+	 0x01c0,
+	 0x01c1,
+	 },
+	{
+	 172, 5860, 0xa1, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4a, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf,
+	 0x01bf,
+	 0x01c0,
+	 },
+	{
+	 174, 5870, 0xa4, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4b, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0930, 0x092c, 0x0928, 0x01be,
+	 0x01bf,
+	 0x01bf,
+	 },
+	{
+	 176, 5880, 0xa8, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4c, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd,
+	 0x01be,
+	 0x01bf,
+	 },
+	{
+	 178, 5890, 0xab, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4d, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc,
+	 0x01bd,
+	 0x01be,
+	 },
+	{
+	 180, 5900, 0xae, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4e, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x00,
+	 0x00, 0x03, 0x00, 0x43, 0x00, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc,
+	 0x01bc,
+	 0x01bd,
+	 },
+	{
+	 1, 2412, 0x48, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x6c, 0x09, 0x0f,
+	 0x0a, 0x00, 0x0a, 0x00, 0x71, 0xa3, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x71,
+	 0xa3, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03c9, 0x03c5, 0x03c1, 0x043a,
+	 0x043f,
+	 0x0443,
+	 },
+	{
+	 2, 2417, 0x4b, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x71, 0x09, 0x0f,
+	 0x0a, 0x00, 0x0a, 0x00, 0x71, 0xa3, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x71,
+	 0xa3, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cb, 0x03c7, 0x03c3, 0x0438,
+	 0x043d,
+	 0x0441,
+	 },
+	{
+	 3, 2422, 0x4e, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x76, 0x09, 0x0f,
+	 0x09, 0x00, 0x09, 0x00, 0x71, 0x93, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x71,
+	 0x93, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cd, 0x03c9, 0x03c5, 0x0436,
+	 0x043a,
+	 0x043f,
+	 },
+	{
+	 4, 2427, 0x52, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x7b, 0x09, 0x0f,
+	 0x09, 0x00, 0x09, 0x00, 0x71, 0x93, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x71,
+	 0x93, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cf, 0x03cb, 0x03c7, 0x0434,
+	 0x0438,
+	 0x043d,
+	 },
+	{
+	 5, 2432, 0x55, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x80, 0x09, 0x0f,
+	 0x08, 0x00, 0x08, 0x00, 0x51, 0x83, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x51,
+	 0x83, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d1, 0x03cd, 0x03c9, 0x0431,
+	 0x0436,
+	 0x043a,
+	 },
+	{
+	 6, 2437, 0x58, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x85, 0x09, 0x0f,
+	 0x08, 0x00, 0x08, 0x00, 0x51, 0x83, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x51,
+	 0x83, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d3, 0x03cf, 0x03cb, 0x042f,
+	 0x0434,
+	 0x0438,
+	 },
+	{
+	 7, 2442, 0x5c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8a, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x51, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x51,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d5, 0x03d1, 0x03cd, 0x042d,
+	 0x0431,
+	 0x0436,
+	 },
+	{
+	 8, 2447, 0x5f, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8f, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x31, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x31,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d7, 0x03d3, 0x03cf, 0x042b,
+	 0x042f,
+	 0x0434,
+	 },
+	{
+	 9, 2452, 0x62, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x94, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x31, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x31,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d9, 0x03d5, 0x03d1, 0x0429,
+	 0x042d,
+	 0x0431,
+	 },
+	{
+	 10, 2457, 0x66, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x99, 0x09, 0x0f,
+	 0x06, 0x00, 0x06, 0x00, 0x31, 0x63, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x31,
+	 0x63, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03db, 0x03d7, 0x03d3, 0x0427,
+	 0x042b,
+	 0x042f,
+	 },
+	{
+	 11, 2462, 0x69, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x9e, 0x09, 0x0f,
+	 0x06, 0x00, 0x06, 0x00, 0x31, 0x63, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x31,
+	 0x63, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03dd, 0x03d9, 0x03d5, 0x0424,
+	 0x0429,
+	 0x042d,
+	 },
+	{
+	 12, 2467, 0x6c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa3, 0x09, 0x0f,
+	 0x05, 0x00, 0x05, 0x00, 0x11, 0x53, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x11,
+	 0x53, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03df, 0x03db, 0x03d7, 0x0422,
+	 0x0427,
+	 0x042b,
+	 },
+	{
+	 13, 2472, 0x70, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa8, 0x09, 0x0f,
+	 0x05, 0x00, 0x05, 0x00, 0x11, 0x53, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x11,
+	 0x53, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03e1, 0x03dd, 0x03d9, 0x0420,
+	 0x0424,
+	 0x0429,
+	 },
+	{
+	 14, 2484, 0x78, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xb4, 0x09, 0x0f,
+	 0x04, 0x00, 0x04, 0x00, 0x11, 0x43, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x11,
+	 0x43, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x03e6, 0x03e2, 0x03de, 0x041b,
+	 0x041f,
+	 0x0424}
+};
+
+static chan_info_nphy_radio2057_rev5_t chan_info_nphyrev8_2057_rev5[] = {
+	{
+	 1, 2412, 0x48, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x6c, 0x09, 0x0d,
+	 0x08, 0x0e, 0x61, 0x03, 0xff, 0x61, 0x03, 0xff, 0x03c9, 0x03c5, 0x03c1,
+	 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x4b, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x71, 0x09, 0x0d,
+	 0x08, 0x0e, 0x61, 0x03, 0xff, 0x61, 0x03, 0xff, 0x03cb, 0x03c7, 0x03c3,
+	 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x4e, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x76, 0x09, 0x0d,
+	 0x08, 0x0e, 0x61, 0x03, 0xef, 0x61, 0x03, 0xef, 0x03cd, 0x03c9, 0x03c5,
+	 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x52, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x7b, 0x09, 0x0c,
+	 0x08, 0x0e, 0x61, 0x03, 0xdf, 0x61, 0x03, 0xdf, 0x03cf, 0x03cb, 0x03c7,
+	 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x55, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x80, 0x09, 0x0c,
+	 0x07, 0x0d, 0x61, 0x03, 0xcf, 0x61, 0x03, 0xcf, 0x03d1, 0x03cd, 0x03c9,
+	 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x58, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x85, 0x09, 0x0c,
+	 0x07, 0x0d, 0x61, 0x03, 0xbf, 0x61, 0x03, 0xbf, 0x03d3, 0x03cf, 0x03cb,
+	 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x5c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8a, 0x09, 0x0b,
+	 0x07, 0x0d, 0x61, 0x03, 0xaf, 0x61, 0x03, 0xaf, 0x03d5, 0x03d1, 0x03cd,
+	 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x5f, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8f, 0x09, 0x0b,
+	 0x07, 0x0d, 0x61, 0x03, 0x9f, 0x61, 0x03, 0x9f, 0x03d7, 0x03d3, 0x03cf,
+	 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x62, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x94, 0x09, 0x0b,
+	 0x07, 0x0d, 0x61, 0x03, 0x8f, 0x61, 0x03, 0x8f, 0x03d9, 0x03d5, 0x03d1,
+	 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x66, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x99, 0x09, 0x0b,
+	 0x07, 0x0c, 0x61, 0x03, 0x7f, 0x61, 0x03, 0x7f, 0x03db, 0x03d7, 0x03d3,
+	 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x69, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x9e, 0x09, 0x0b,
+	 0x07, 0x0c, 0x61, 0x03, 0x6f, 0x61, 0x03, 0x6f, 0x03dd, 0x03d9, 0x03d5,
+	 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x6c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa3, 0x09, 0x0b,
+	 0x06, 0x0c, 0x61, 0x03, 0x5f, 0x61, 0x03, 0x5f, 0x03df, 0x03db, 0x03d7,
+	 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x70, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa8, 0x09, 0x0a,
+	 0x06, 0x0b, 0x61, 0x03, 0x4f, 0x61, 0x03, 0x4f, 0x03e1, 0x03dd, 0x03d9,
+	 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0x78, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xb4, 0x09, 0x0a,
+	 0x06, 0x0b, 0x61, 0x03, 0x3f, 0x61, 0x03, 0x3f, 0x03e6, 0x03e2, 0x03de,
+	 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio2057_rev5_t chan_info_nphyrev9_2057_rev5v1[] = {
+	{
+	 1, 2412, 0x48, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x6c, 0x09, 0x0d,
+	 0x08, 0x0e, 0x61, 0x03, 0xff, 0x61, 0x03, 0xff, 0x03c9, 0x03c5, 0x03c1,
+	 0x043a, 0x043f, 0x0443},
+	{
+	 2, 2417, 0x4b, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x71, 0x09, 0x0d,
+	 0x08, 0x0e, 0x61, 0x03, 0xff, 0x61, 0x03, 0xff, 0x03cb, 0x03c7, 0x03c3,
+	 0x0438, 0x043d, 0x0441},
+	{
+	 3, 2422, 0x4e, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x76, 0x09, 0x0d,
+	 0x08, 0x0e, 0x61, 0x03, 0xef, 0x61, 0x03, 0xef, 0x03cd, 0x03c9, 0x03c5,
+	 0x0436, 0x043a, 0x043f},
+	{
+	 4, 2427, 0x52, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x7b, 0x09, 0x0c,
+	 0x08, 0x0e, 0x61, 0x03, 0xdf, 0x61, 0x03, 0xdf, 0x03cf, 0x03cb, 0x03c7,
+	 0x0434, 0x0438, 0x043d},
+	{
+	 5, 2432, 0x55, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x80, 0x09, 0x0c,
+	 0x07, 0x0d, 0x61, 0x03, 0xcf, 0x61, 0x03, 0xcf, 0x03d1, 0x03cd, 0x03c9,
+	 0x0431, 0x0436, 0x043a},
+	{
+	 6, 2437, 0x58, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x85, 0x09, 0x0c,
+	 0x07, 0x0d, 0x61, 0x03, 0xbf, 0x61, 0x03, 0xbf, 0x03d3, 0x03cf, 0x03cb,
+	 0x042f, 0x0434, 0x0438},
+	{
+	 7, 2442, 0x5c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8a, 0x09, 0x0b,
+	 0x07, 0x0d, 0x61, 0x03, 0xaf, 0x61, 0x03, 0xaf, 0x03d5, 0x03d1, 0x03cd,
+	 0x042d, 0x0431, 0x0436},
+	{
+	 8, 2447, 0x5f, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8f, 0x09, 0x0b,
+	 0x07, 0x0d, 0x61, 0x03, 0x9f, 0x61, 0x03, 0x9f, 0x03d7, 0x03d3, 0x03cf,
+	 0x042b, 0x042f, 0x0434},
+	{
+	 9, 2452, 0x62, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x94, 0x09, 0x0b,
+	 0x07, 0x0d, 0x61, 0x03, 0x8f, 0x61, 0x03, 0x8f, 0x03d9, 0x03d5, 0x03d1,
+	 0x0429, 0x042d, 0x0431},
+	{
+	 10, 2457, 0x66, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x99, 0x09, 0x0b,
+	 0x07, 0x0c, 0x61, 0x03, 0x7f, 0x61, 0x03, 0x7f, 0x03db, 0x03d7, 0x03d3,
+	 0x0427, 0x042b, 0x042f},
+	{
+	 11, 2462, 0x69, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x9e, 0x09, 0x0b,
+	 0x07, 0x0c, 0x61, 0x03, 0x6f, 0x61, 0x03, 0x6f, 0x03dd, 0x03d9, 0x03d5,
+	 0x0424, 0x0429, 0x042d},
+	{
+	 12, 2467, 0x6c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa3, 0x09, 0x0b,
+	 0x06, 0x0c, 0x61, 0x03, 0x5f, 0x61, 0x03, 0x5f, 0x03df, 0x03db, 0x03d7,
+	 0x0422, 0x0427, 0x042b},
+	{
+	 13, 2472, 0x70, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa8, 0x09, 0x0a,
+	 0x06, 0x0b, 0x61, 0x03, 0x4f, 0x61, 0x03, 0x4f, 0x03e1, 0x03dd, 0x03d9,
+	 0x0420, 0x0424, 0x0429},
+	{
+	 14, 2484, 0x78, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xb4, 0x09, 0x0a,
+	 0x06, 0x0b, 0x61, 0x03, 0x3f, 0x61, 0x03, 0x3f, 0x03e6, 0x03e2, 0x03de,
+	 0x041b, 0x041f, 0x0424}
+};
+
+static chan_info_nphy_radio2057_t chan_info_nphyrev8_2057_rev7[] = {
+	{
+	 184, 4920, 0x68, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xec, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xd3, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07b4, 0x07b0, 0x07ac, 0x0214,
+	 0x0215,
+	 0x0216},
+	{
+	 186, 4930, 0x6b, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xed, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xd3, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07b8, 0x07b4, 0x07b0, 0x0213,
+	 0x0214,
+	 0x0215},
+	{
+	 188, 4940, 0x6e, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xee, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xd3, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07bc, 0x07b8, 0x07b4, 0x0212,
+	 0x0213,
+	 0x0214},
+	{
+	 190, 4950, 0x72, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xef, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07c0, 0x07bc, 0x07b8, 0x0211,
+	 0x0212,
+	 0x0213},
+	{
+	 192, 4960, 0x75, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf0, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07c4, 0x07c0, 0x07bc, 0x020f,
+	 0x0211,
+	 0x0212},
+	{
+	 194, 4970, 0x78, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf1, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07c8, 0x07c4, 0x07c0, 0x020e,
+	 0x020f,
+	 0x0211},
+	{
+	 196, 4980, 0x7c, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf2, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07cc, 0x07c8, 0x07c4, 0x020d,
+	 0x020e,
+	 0x020f},
+	{
+	 198, 4990, 0x7f, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf3, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07d0, 0x07cc, 0x07c8, 0x020c,
+	 0x020d,
+	 0x020e},
+	{
+	 200, 5000, 0x82, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf4, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07d4, 0x07d0, 0x07cc, 0x020b,
+	 0x020c,
+	 0x020d},
+	{
+	 202, 5010, 0x86, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf5, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07d8, 0x07d4, 0x07d0, 0x020a,
+	 0x020b,
+	 0x020c},
+	{
+	 204, 5020, 0x89, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf6, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07dc, 0x07d8, 0x07d4, 0x0209,
+	 0x020a,
+	 0x020b},
+	{
+	 206, 5030, 0x8c, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf7, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07e0, 0x07dc, 0x07d8, 0x0208,
+	 0x0209,
+	 0x020a},
+	{
+	 208, 5040, 0x90, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf8, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07e4, 0x07e0, 0x07dc, 0x0207,
+	 0x0208,
+	 0x0209},
+	{
+	 210, 5050, 0x93, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf9, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07e8, 0x07e4, 0x07e0, 0x0206,
+	 0x0207,
+	 0x0208},
+	{
+	 212, 5060, 0x96, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfa, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07ec, 0x07e8, 0x07e4, 0x0205,
+	 0x0206,
+	 0x0207},
+	{
+	 214, 5070, 0x9a, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfb, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07f0, 0x07ec, 0x07e8, 0x0204,
+	 0x0205,
+	 0x0206},
+	{
+	 216, 5080, 0x9d, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfc, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07f4, 0x07f0, 0x07ec, 0x0203,
+	 0x0204,
+	 0x0205},
+	{
+	 218, 5090, 0xa0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfd, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07f8, 0x07f4, 0x07f0, 0x0202,
+	 0x0203,
+	 0x0204},
+	{
+	 220, 5100, 0xa4, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfe, 0x01, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x07fc, 0x07f8, 0x07f4, 0x0201,
+	 0x0202,
+	 0x0203},
+	{
+	 222, 5110, 0xa7, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xff, 0x01, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0800, 0x07fc, 0x07f8, 0x0200,
+	 0x0201,
+	 0x0202},
+	{
+	 224, 5120, 0xaa, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x00, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0804, 0x0800, 0x07fc, 0x01ff,
+	 0x0200,
+	 0x0201},
+	{
+	 226, 5130, 0xae, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x01, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0808, 0x0804, 0x0800, 0x01fe,
+	 0x01ff,
+	 0x0200},
+	{
+	 228, 5140, 0xb1, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x02, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x080c, 0x0808, 0x0804, 0x01fd,
+	 0x01fe,
+	 0x01ff},
+	{
+	 32, 5160, 0xb8, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x04, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0814, 0x0810, 0x080c, 0x01fb,
+	 0x01fc,
+	 0x01fd},
+	{
+	 34, 5170, 0xbb, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x05, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0818, 0x0814, 0x0810, 0x01fa,
+	 0x01fb,
+	 0x01fc},
+	{
+	 36, 5180, 0xbe, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x06, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x081c, 0x0818, 0x0814, 0x01f9,
+	 0x01fa,
+	 0x01fb},
+	{
+	 38, 5190, 0xc2, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x07, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0820, 0x081c, 0x0818, 0x01f8,
+	 0x01f9,
+	 0x01fa},
+	{
+	 40, 5200, 0xc5, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x08, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0824, 0x0820, 0x081c, 0x01f7,
+	 0x01f8,
+	 0x01f9},
+	{
+	 42, 5210, 0xc8, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x09, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0828, 0x0824, 0x0820, 0x01f6,
+	 0x01f7,
+	 0x01f8},
+	{
+	 44, 5220, 0xcc, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0a, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x082c, 0x0828, 0x0824, 0x01f5,
+	 0x01f6,
+	 0x01f7},
+	{
+	 46, 5230, 0xcf, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0b, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0830, 0x082c, 0x0828, 0x01f4,
+	 0x01f5,
+	 0x01f6},
+	{
+	 48, 5240, 0xd2, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0c, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0834, 0x0830, 0x082c, 0x01f3,
+	 0x01f4,
+	 0x01f5},
+	{
+	 50, 5250, 0xd6, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0d, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0838, 0x0834, 0x0830, 0x01f2,
+	 0x01f3,
+	 0x01f4},
+	{
+	 52, 5260, 0xd9, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0e, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x083c, 0x0838, 0x0834, 0x01f1,
+	 0x01f2,
+	 0x01f3},
+	{
+	 54, 5270, 0xdc, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0f, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0840, 0x083c, 0x0838, 0x01f0,
+	 0x01f1,
+	 0x01f2},
+	{
+	 56, 5280, 0xe0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x10, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0844, 0x0840, 0x083c, 0x01f0,
+	 0x01f0,
+	 0x01f1},
+	{
+	 58, 5290, 0xe3, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x11, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0848, 0x0844, 0x0840, 0x01ef,
+	 0x01f0,
+	 0x01f0},
+	{
+	 60, 5300, 0xe6, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x12, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x084c, 0x0848, 0x0844, 0x01ee,
+	 0x01ef,
+	 0x01f0},
+	{
+	 62, 5310, 0xea, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x13, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0850, 0x084c, 0x0848, 0x01ed,
+	 0x01ee,
+	 0x01ef},
+	{
+	 64, 5320, 0xed, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x14, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0854, 0x0850, 0x084c, 0x01ec,
+	 0x01ed,
+	 0x01ee},
+	{
+	 66, 5330, 0xf0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x15, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0858, 0x0854, 0x0850, 0x01eb,
+	 0x01ec,
+	 0x01ed},
+	{
+	 68, 5340, 0xf4, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x16, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x085c, 0x0858, 0x0854, 0x01ea,
+	 0x01eb,
+	 0x01ec},
+	{
+	 70, 5350, 0xf7, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x17, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0860, 0x085c, 0x0858, 0x01e9,
+	 0x01ea,
+	 0x01eb},
+	{
+	 72, 5360, 0xfa, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x18, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0864, 0x0860, 0x085c, 0x01e8,
+	 0x01e9,
+	 0x01ea},
+	{
+	 74, 5370, 0xfe, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x19, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0868, 0x0864, 0x0860, 0x01e7,
+	 0x01e8,
+	 0x01e9},
+	{
+	 76, 5380, 0x01, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1a, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x086c, 0x0868, 0x0864, 0x01e6,
+	 0x01e7,
+	 0x01e8},
+	{
+	 78, 5390, 0x04, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1b, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0870, 0x086c, 0x0868, 0x01e5,
+	 0x01e6,
+	 0x01e7},
+	{
+	 80, 5400, 0x08, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1c, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0874, 0x0870, 0x086c, 0x01e5,
+	 0x01e5,
+	 0x01e6},
+	{
+	 82, 5410, 0x0b, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1d, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0878, 0x0874, 0x0870, 0x01e4,
+	 0x01e5,
+	 0x01e5},
+	{
+	 84, 5420, 0x0e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1e, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x087c, 0x0878, 0x0874, 0x01e3,
+	 0x01e4,
+	 0x01e5},
+	{
+	 86, 5430, 0x12, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1f, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0880, 0x087c, 0x0878, 0x01e2,
+	 0x01e3,
+	 0x01e4},
+	{
+	 88, 5440, 0x15, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x20, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0884, 0x0880, 0x087c, 0x01e1,
+	 0x01e2,
+	 0x01e3},
+	{
+	 90, 5450, 0x18, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x21, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0888, 0x0884, 0x0880, 0x01e0,
+	 0x01e1,
+	 0x01e2},
+	{
+	 92, 5460, 0x1c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x22, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x088c, 0x0888, 0x0884, 0x01df,
+	 0x01e0,
+	 0x01e1},
+	{
+	 94, 5470, 0x1f, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x23, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0890, 0x088c, 0x0888, 0x01de,
+	 0x01df,
+	 0x01e0},
+	{
+	 96, 5480, 0x22, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x24, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0894, 0x0890, 0x088c, 0x01dd,
+	 0x01de,
+	 0x01df},
+	{
+	 98, 5490, 0x26, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x25, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0898, 0x0894, 0x0890, 0x01dd,
+	 0x01dd,
+	 0x01de},
+	{
+	 100, 5500, 0x29, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x26, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x089c, 0x0898, 0x0894, 0x01dc,
+	 0x01dd,
+	 0x01dd},
+	{
+	 102, 5510, 0x2c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x27, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08a0, 0x089c, 0x0898, 0x01db,
+	 0x01dc,
+	 0x01dd},
+	{
+	 104, 5520, 0x30, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x28, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08a4, 0x08a0, 0x089c, 0x01da,
+	 0x01db,
+	 0x01dc},
+	{
+	 106, 5530, 0x33, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x29, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08a8, 0x08a4, 0x08a0, 0x01d9,
+	 0x01da,
+	 0x01db},
+	{
+	 108, 5540, 0x36, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2a, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08ac, 0x08a8, 0x08a4, 0x01d8,
+	 0x01d9,
+	 0x01da},
+	{
+	 110, 5550, 0x3a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2b, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08b0, 0x08ac, 0x08a8, 0x01d7,
+	 0x01d8,
+	 0x01d9},
+	{
+	 112, 5560, 0x3d, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2c, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08b4, 0x08b0, 0x08ac, 0x01d7,
+	 0x01d7,
+	 0x01d8},
+	{
+	 114, 5570, 0x40, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2d, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08b8, 0x08b4, 0x08b0, 0x01d6,
+	 0x01d7,
+	 0x01d7},
+	{
+	 116, 5580, 0x44, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2e, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08bc, 0x08b8, 0x08b4, 0x01d5,
+	 0x01d6,
+	 0x01d7},
+	{
+	 118, 5590, 0x47, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2f, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08c0, 0x08bc, 0x08b8, 0x01d4,
+	 0x01d5,
+	 0x01d6},
+	{
+	 120, 5600, 0x4a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x30, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08c4, 0x08c0, 0x08bc, 0x01d3,
+	 0x01d4,
+	 0x01d5},
+	{
+	 122, 5610, 0x4e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x31, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08c8, 0x08c4, 0x08c0, 0x01d2,
+	 0x01d3,
+	 0x01d4},
+	{
+	 124, 5620, 0x51, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x32, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08cc, 0x08c8, 0x08c4, 0x01d2,
+	 0x01d2,
+	 0x01d3},
+	{
+	 126, 5630, 0x54, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x33, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08d0, 0x08cc, 0x08c8, 0x01d1,
+	 0x01d2,
+	 0x01d2},
+	{
+	 128, 5640, 0x58, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x34, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08d4, 0x08d0, 0x08cc, 0x01d0,
+	 0x01d1,
+	 0x01d2},
+	{
+	 130, 5650, 0x5b, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x35, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x08d8, 0x08d4, 0x08d0, 0x01cf,
+	 0x01d0,
+	 0x01d1},
+	{
+	 132, 5660, 0x5e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x36, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x08dc, 0x08d8, 0x08d4, 0x01ce,
+	 0x01cf,
+	 0x01d0},
+	{
+	 134, 5670, 0x62, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x37, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x08e0, 0x08dc, 0x08d8, 0x01ce,
+	 0x01ce,
+	 0x01cf},
+	{
+	 136, 5680, 0x65, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x38, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x08e4, 0x08e0, 0x08dc, 0x01cd,
+	 0x01ce,
+	 0x01ce},
+	{
+	 138, 5690, 0x68, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x39, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x08e8, 0x08e4, 0x08e0, 0x01cc,
+	 0x01cd,
+	 0x01ce},
+	{
+	 140, 5700, 0x6c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3a, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08ec, 0x08e8, 0x08e4, 0x01cb,
+	 0x01cc,
+	 0x01cd},
+	{
+	 142, 5710, 0x6f, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3b, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f0, 0x08ec, 0x08e8, 0x01ca,
+	 0x01cb,
+	 0x01cc},
+	{
+	 144, 5720, 0x72, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3c, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f4, 0x08f0, 0x08ec, 0x01c9,
+	 0x01ca,
+	 0x01cb},
+	{
+	 145, 5725, 0x74, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x79, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f6, 0x08f2, 0x08ee, 0x01c9,
+	 0x01ca,
+	 0x01cb},
+	{
+	 146, 5730, 0x76, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3d, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f8, 0x08f4, 0x08f0, 0x01c9,
+	 0x01c9,
+	 0x01ca},
+	{
+	 147, 5735, 0x77, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7b, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08fa, 0x08f6, 0x08f2, 0x01c8,
+	 0x01c9,
+	 0x01ca},
+	{
+	 148, 5740, 0x79, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3e, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08fc, 0x08f8, 0x08f4, 0x01c8,
+	 0x01c9,
+	 0x01c9},
+	{
+	 149, 5745, 0x7b, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7d, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08fe, 0x08fa, 0x08f6, 0x01c8,
+	 0x01c8,
+	 0x01c9},
+	{
+	 150, 5750, 0x7c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3f, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7,
+	 0x01c8,
+	 0x01c9},
+	{
+	 151, 5755, 0x7e, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7f, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7,
+	 0x01c8,
+	 0x01c8},
+	{
+	 152, 5760, 0x80, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x40, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6,
+	 0x01c7,
+	 0x01c8},
+	{
+	 153, 5765, 0x81, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x81, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6,
+	 0x01c7,
+	 0x01c8},
+	{
+	 154, 5770, 0x83, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x41, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6,
+	 0x01c6,
+	 0x01c7},
+	{
+	 155, 5775, 0x85, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x83, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5,
+	 0x01c6,
+	 0x01c7},
+	{
+	 156, 5780, 0x86, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x42, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5,
+	 0x01c6,
+	 0x01c6},
+	{
+	 157, 5785, 0x88, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x85, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4,
+	 0x01c5,
+	 0x01c6},
+	{
+	 158, 5790, 0x8a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x43, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4,
+	 0x01c5,
+	 0x01c6},
+	{
+	 159, 5795, 0x8b, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x87, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4,
+	 0x01c4,
+	 0x01c5},
+	{
+	 160, 5800, 0x8d, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x44, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x01, 0x03, 0x00, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3,
+	 0x01c4,
+	 0x01c5},
+	{
+	 161, 5805, 0x8f, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x89, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3,
+	 0x01c4,
+	 0x01c4},
+	{
+	 162, 5810, 0x90, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x45, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2,
+	 0x01c3,
+	 0x01c4},
+	{
+	 163, 5815, 0x92, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x8b, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2,
+	 0x01c3,
+	 0x01c4},
+	{
+	 164, 5820, 0x94, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x46, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2,
+	 0x01c2,
+	 0x01c3},
+	{
+	 165, 5825, 0x95, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x8d, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1,
+	 0x01c2,
+	 0x01c3},
+	{
+	 166, 5830, 0x97, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x47, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1,
+	 0x01c2,
+	 0x01c2},
+	{
+	 168, 5840, 0x9a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x48, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0,
+	 0x01c1,
+	 0x01c2},
+	{
+	 170, 5850, 0x9e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x49, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf,
+	 0x01c0,
+	 0x01c1},
+	{
+	 172, 5860, 0xa1, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4a, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf,
+	 0x01bf,
+	 0x01c0},
+	{
+	 174, 5870, 0xa4, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4b, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0930, 0x092c, 0x0928, 0x01be,
+	 0x01bf,
+	 0x01bf},
+	{
+	 176, 5880, 0xa8, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4c, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd,
+	 0x01be,
+	 0x01bf},
+	{
+	 178, 5890, 0xab, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4d, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc,
+	 0x01bd,
+	 0x01be},
+	{
+	 180, 5900, 0xae, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4e, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc,
+	 0x01bc,
+	 0x01bd},
+	{
+	 1, 2412, 0x48, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x6c, 0x09, 0x0f,
+	 0x0a, 0x00, 0x0a, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03c9, 0x03c5, 0x03c1, 0x043a,
+	 0x043f,
+	 0x0443},
+	{
+	 2, 2417, 0x4b, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x71, 0x09, 0x0f,
+	 0x0a, 0x00, 0x0a, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cb, 0x03c7, 0x03c3, 0x0438,
+	 0x043d,
+	 0x0441},
+	{
+	 3, 2422, 0x4e, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x76, 0x09, 0x0f,
+	 0x09, 0x00, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cd, 0x03c9, 0x03c5, 0x0436,
+	 0x043a,
+	 0x043f},
+	{
+	 4, 2427, 0x52, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x7b, 0x09, 0x0f,
+	 0x09, 0x00, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cf, 0x03cb, 0x03c7, 0x0434,
+	 0x0438,
+	 0x043d},
+	{
+	 5, 2432, 0x55, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x80, 0x09, 0x0f,
+	 0x08, 0x00, 0x08, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d1, 0x03cd, 0x03c9, 0x0431,
+	 0x0436,
+	 0x043a},
+	{
+	 6, 2437, 0x58, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x85, 0x09, 0x0f,
+	 0x08, 0x00, 0x08, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d3, 0x03cf, 0x03cb, 0x042f,
+	 0x0434,
+	 0x0438},
+	{
+	 7, 2442, 0x5c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8a, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d5, 0x03d1, 0x03cd, 0x042d,
+	 0x0431,
+	 0x0436},
+	{
+	 8, 2447, 0x5f, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8f, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d7, 0x03d3, 0x03cf, 0x042b,
+	 0x042f,
+	 0x0434},
+	{
+	 9, 2452, 0x62, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x94, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d9, 0x03d5, 0x03d1, 0x0429,
+	 0x042d,
+	 0x0431},
+	{
+	 10, 2457, 0x66, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x99, 0x09, 0x0f,
+	 0x06, 0x00, 0x06, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03db, 0x03d7, 0x03d3, 0x0427,
+	 0x042b,
+	 0x042f},
+	{
+	 11, 2462, 0x69, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x9e, 0x09, 0x0f,
+	 0x06, 0x00, 0x06, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03dd, 0x03d9, 0x03d5, 0x0424,
+	 0x0429,
+	 0x042d},
+	{
+	 12, 2467, 0x6c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa3, 0x09, 0x0f,
+	 0x05, 0x00, 0x05, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03df, 0x03db, 0x03d7, 0x0422,
+	 0x0427,
+	 0x042b},
+	{
+	 13, 2472, 0x70, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa8, 0x09, 0x0f,
+	 0x05, 0x00, 0x05, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03e1, 0x03dd, 0x03d9, 0x0420,
+	 0x0424,
+	 0x0429},
+	{
+	 14, 2484, 0x78, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xb4, 0x09, 0x0f,
+	 0x04, 0x00, 0x04, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x03e6, 0x03e2, 0x03de, 0x041b,
+	 0x041f,
+	 0x0424}
+};
+
+static chan_info_nphy_radio2057_t chan_info_nphyrev8_2057_rev8[] = {
+	{
+	 186, 4930, 0x6b, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xed, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xd3, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07b8, 0x07b4, 0x07b0, 0x0213,
+	 0x0214,
+	 0x0215},
+	{
+	 188, 4940, 0x6e, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xee, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0xd3, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07bc, 0x07b8, 0x07b4, 0x0212,
+	 0x0213,
+	 0x0214},
+	{
+	 190, 4950, 0x72, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xef, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07c0, 0x07bc, 0x07b8, 0x0211,
+	 0x0212,
+	 0x0213},
+	{
+	 192, 4960, 0x75, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf0, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07c4, 0x07c0, 0x07bc, 0x020f,
+	 0x0211,
+	 0x0212},
+	{
+	 194, 4970, 0x78, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf1, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07c8, 0x07c4, 0x07c0, 0x020e,
+	 0x020f,
+	 0x0211},
+	{
+	 196, 4980, 0x7c, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf2, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07cc, 0x07c8, 0x07c4, 0x020d,
+	 0x020e,
+	 0x020f},
+	{
+	 198, 4990, 0x7f, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf3, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xd3, 0x00, 0xff, 0x07d0, 0x07cc, 0x07c8, 0x020c,
+	 0x020d,
+	 0x020e},
+	{
+	 200, 5000, 0x82, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf4, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07d4, 0x07d0, 0x07cc, 0x020b,
+	 0x020c,
+	 0x020d},
+	{
+	 202, 5010, 0x86, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf5, 0x01, 0x0f,
+	 0x00, 0x0f, 0x00, 0xff, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07d8, 0x07d4, 0x07d0, 0x020a,
+	 0x020b,
+	 0x020c},
+	{
+	 204, 5020, 0x89, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf6, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07dc, 0x07d8, 0x07d4, 0x0209,
+	 0x020a,
+	 0x020b},
+	{
+	 206, 5030, 0x8c, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf7, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07e0, 0x07dc, 0x07d8, 0x0208,
+	 0x0209,
+	 0x020a},
+	{
+	 208, 5040, 0x90, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf8, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07e4, 0x07e0, 0x07dc, 0x0207,
+	 0x0208,
+	 0x0209},
+	{
+	 210, 5050, 0x93, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xf9, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07e8, 0x07e4, 0x07e0, 0x0206,
+	 0x0207,
+	 0x0208},
+	{
+	 212, 5060, 0x96, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfa, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07ec, 0x07e8, 0x07e4, 0x0205,
+	 0x0206,
+	 0x0207},
+	{
+	 214, 5070, 0x9a, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfb, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07f0, 0x07ec, 0x07e8, 0x0204,
+	 0x0205,
+	 0x0206},
+	{
+	 216, 5080, 0x9d, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfc, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07f4, 0x07f0, 0x07ec, 0x0203,
+	 0x0204,
+	 0x0205},
+	{
+	 218, 5090, 0xa0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfd, 0x01, 0x0e,
+	 0x00, 0x0e, 0x00, 0xee, 0x00, 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x00,
+	 0x00, 0x0f, 0x0f, 0xb3, 0x00, 0xff, 0x07f8, 0x07f4, 0x07f0, 0x0202,
+	 0x0203,
+	 0x0204},
+	{
+	 220, 5100, 0xa4, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xfe, 0x01, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x07fc, 0x07f8, 0x07f4, 0x0201,
+	 0x0202,
+	 0x0203},
+	{
+	 222, 5110, 0xa7, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0xff, 0x01, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0800, 0x07fc, 0x07f8, 0x0200,
+	 0x0201,
+	 0x0202},
+	{
+	 224, 5120, 0xaa, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x00, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0804, 0x0800, 0x07fc, 0x01ff,
+	 0x0200,
+	 0x0201},
+	{
+	 226, 5130, 0xae, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x01, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0808, 0x0804, 0x0800, 0x01fe,
+	 0x01ff,
+	 0x0200},
+	{
+	 228, 5140, 0xb1, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x02, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x080c, 0x0808, 0x0804, 0x01fd,
+	 0x01fe,
+	 0x01ff},
+	{
+	 32, 5160, 0xb8, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x04, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0814, 0x0810, 0x080c, 0x01fb,
+	 0x01fc,
+	 0x01fd},
+	{
+	 34, 5170, 0xbb, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x05, 0x02, 0x0d,
+	 0x00, 0x0d, 0x00, 0xdd, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0818, 0x0814, 0x0810, 0x01fa,
+	 0x01fb,
+	 0x01fc},
+	{
+	 36, 5180, 0xbe, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x06, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x081c, 0x0818, 0x0814, 0x01f9,
+	 0x01fa,
+	 0x01fb},
+	{
+	 38, 5190, 0xc2, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x07, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x00,
+	 0x00, 0x0f, 0x0f, 0xa3, 0x00, 0xfc, 0x0820, 0x081c, 0x0818, 0x01f8,
+	 0x01f9,
+	 0x01fa},
+	{
+	 40, 5200, 0xc5, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x08, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0824, 0x0820, 0x081c, 0x01f7,
+	 0x01f8,
+	 0x01f9},
+	{
+	 42, 5210, 0xc8, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x09, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0828, 0x0824, 0x0820, 0x01f6,
+	 0x01f7,
+	 0x01f8},
+	{
+	 44, 5220, 0xcc, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0a, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x082c, 0x0828, 0x0824, 0x01f5,
+	 0x01f6,
+	 0x01f7},
+	{
+	 46, 5230, 0xcf, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0b, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0830, 0x082c, 0x0828, 0x01f4,
+	 0x01f5,
+	 0x01f6},
+	{
+	 48, 5240, 0xd2, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0c, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0834, 0x0830, 0x082c, 0x01f3,
+	 0x01f4,
+	 0x01f5},
+	{
+	 50, 5250, 0xd6, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0d, 0x02, 0x0c,
+	 0x00, 0x0c, 0x00, 0xcc, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0838, 0x0834, 0x0830, 0x01f2,
+	 0x01f3,
+	 0x01f4},
+	{
+	 52, 5260, 0xd9, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0e, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x083c, 0x0838, 0x0834, 0x01f1,
+	 0x01f2,
+	 0x01f3},
+	{
+	 54, 5270, 0xdc, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x0f, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0840, 0x083c, 0x0838, 0x01f0,
+	 0x01f1,
+	 0x01f2},
+	{
+	 56, 5280, 0xe0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x10, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0844, 0x0840, 0x083c, 0x01f0,
+	 0x01f0,
+	 0x01f1},
+	{
+	 58, 5290, 0xe3, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x11, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x00,
+	 0x00, 0x0f, 0x0f, 0x93, 0x00, 0xf8, 0x0848, 0x0844, 0x0840, 0x01ef,
+	 0x01f0,
+	 0x01f0},
+	{
+	 60, 5300, 0xe6, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x12, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x084c, 0x0848, 0x0844, 0x01ee,
+	 0x01ef,
+	 0x01f0},
+	{
+	 62, 5310, 0xea, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x13, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0850, 0x084c, 0x0848, 0x01ed,
+	 0x01ee,
+	 0x01ef},
+	{
+	 64, 5320, 0xed, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x14, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0854, 0x0850, 0x084c, 0x01ec,
+	 0x01ed,
+	 0x01ee},
+	{
+	 66, 5330, 0xf0, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x15, 0x02, 0x0b,
+	 0x00, 0x0b, 0x00, 0xbb, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0858, 0x0854, 0x0850, 0x01eb,
+	 0x01ec,
+	 0x01ed},
+	{
+	 68, 5340, 0xf4, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x16, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x085c, 0x0858, 0x0854, 0x01ea,
+	 0x01eb,
+	 0x01ec},
+	{
+	 70, 5350, 0xf7, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x17, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0860, 0x085c, 0x0858, 0x01e9,
+	 0x01ea,
+	 0x01eb},
+	{
+	 72, 5360, 0xfa, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x18, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0864, 0x0860, 0x085c, 0x01e8,
+	 0x01e9,
+	 0x01ea},
+	{
+	 74, 5370, 0xfe, 0x16, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x19, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0868, 0x0864, 0x0860, 0x01e7,
+	 0x01e8,
+	 0x01e9},
+	{
+	 76, 5380, 0x01, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1a, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x086c, 0x0868, 0x0864, 0x01e6,
+	 0x01e7,
+	 0x01e8},
+	{
+	 78, 5390, 0x04, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1b, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x00,
+	 0x00, 0x0f, 0x0c, 0x83, 0x00, 0xf5, 0x0870, 0x086c, 0x0868, 0x01e5,
+	 0x01e6,
+	 0x01e7},
+	{
+	 80, 5400, 0x08, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1c, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0874, 0x0870, 0x086c, 0x01e5,
+	 0x01e5,
+	 0x01e6},
+	{
+	 82, 5410, 0x0b, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1d, 0x02, 0x0a,
+	 0x00, 0x0a, 0x00, 0xaa, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0878, 0x0874, 0x0870, 0x01e4,
+	 0x01e5,
+	 0x01e5},
+	{
+	 84, 5420, 0x0e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1e, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x087c, 0x0878, 0x0874, 0x01e3,
+	 0x01e4,
+	 0x01e5},
+	{
+	 86, 5430, 0x12, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x1f, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0880, 0x087c, 0x0878, 0x01e2,
+	 0x01e3,
+	 0x01e4},
+	{
+	 88, 5440, 0x15, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x20, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0884, 0x0880, 0x087c, 0x01e1,
+	 0x01e2,
+	 0x01e3},
+	{
+	 90, 5450, 0x18, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x21, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0888, 0x0884, 0x0880, 0x01e0,
+	 0x01e1,
+	 0x01e2},
+	{
+	 92, 5460, 0x1c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x22, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x088c, 0x0888, 0x0884, 0x01df,
+	 0x01e0,
+	 0x01e1},
+	{
+	 94, 5470, 0x1f, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x23, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0890, 0x088c, 0x0888, 0x01de,
+	 0x01df,
+	 0x01e0},
+	{
+	 96, 5480, 0x22, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x24, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0894, 0x0890, 0x088c, 0x01dd,
+	 0x01de,
+	 0x01df},
+	{
+	 98, 5490, 0x26, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x25, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x00,
+	 0x00, 0x0d, 0x09, 0x53, 0x00, 0xb1, 0x0898, 0x0894, 0x0890, 0x01dd,
+	 0x01dd,
+	 0x01de},
+	{
+	 100, 5500, 0x29, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x26, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x089c, 0x0898, 0x0894, 0x01dc,
+	 0x01dd,
+	 0x01dd},
+	{
+	 102, 5510, 0x2c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x27, 0x02, 0x09,
+	 0x00, 0x09, 0x00, 0x99, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08a0, 0x089c, 0x0898, 0x01db,
+	 0x01dc,
+	 0x01dd},
+	{
+	 104, 5520, 0x30, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x28, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08a4, 0x08a0, 0x089c, 0x01da,
+	 0x01db,
+	 0x01dc},
+	{
+	 106, 5530, 0x33, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x29, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08a8, 0x08a4, 0x08a0, 0x01d9,
+	 0x01da,
+	 0x01db},
+	{
+	 108, 5540, 0x36, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2a, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08ac, 0x08a8, 0x08a4, 0x01d8,
+	 0x01d9,
+	 0x01da},
+	{
+	 110, 5550, 0x3a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2b, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08b0, 0x08ac, 0x08a8, 0x01d7,
+	 0x01d8,
+	 0x01d9},
+	{
+	 112, 5560, 0x3d, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2c, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08b4, 0x08b0, 0x08ac, 0x01d7,
+	 0x01d7,
+	 0x01d8},
+	{
+	 114, 5570, 0x40, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2d, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08b8, 0x08b4, 0x08b0, 0x01d6,
+	 0x01d7,
+	 0x01d7},
+	{
+	 116, 5580, 0x44, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2e, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08bc, 0x08b8, 0x08b4, 0x01d5,
+	 0x01d6,
+	 0x01d7},
+	{
+	 118, 5590, 0x47, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x2f, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x00,
+	 0x00, 0x0a, 0x06, 0x43, 0x00, 0x80, 0x08c0, 0x08bc, 0x08b8, 0x01d4,
+	 0x01d5,
+	 0x01d6},
+	{
+	 120, 5600, 0x4a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x30, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08c4, 0x08c0, 0x08bc, 0x01d3,
+	 0x01d4,
+	 0x01d5},
+	{
+	 122, 5610, 0x4e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x31, 0x02, 0x08,
+	 0x00, 0x08, 0x00, 0x88, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08c8, 0x08c4, 0x08c0, 0x01d2,
+	 0x01d3,
+	 0x01d4},
+	{
+	 124, 5620, 0x51, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x32, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08cc, 0x08c8, 0x08c4, 0x01d2,
+	 0x01d2,
+	 0x01d3},
+	{
+	 126, 5630, 0x54, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x33, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08d0, 0x08cc, 0x08c8, 0x01d1,
+	 0x01d2,
+	 0x01d2},
+	{
+	 128, 5640, 0x58, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x34, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x04, 0x23, 0x00, 0x60, 0x08d4, 0x08d0, 0x08cc, 0x01d0,
+	 0x01d1,
+	 0x01d2},
+	{
+	 130, 5650, 0x5b, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x35, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x08d8, 0x08d4, 0x08d0, 0x01cf,
+	 0x01d0,
+	 0x01d1},
+	{
+	 132, 5660, 0x5e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x36, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x08dc, 0x08d8, 0x08d4, 0x01ce,
+	 0x01cf,
+	 0x01d0},
+	{
+	 134, 5670, 0x62, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x37, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x03, 0x23, 0x00, 0x60, 0x08e0, 0x08dc, 0x08d8, 0x01ce,
+	 0x01ce,
+	 0x01cf},
+	{
+	 136, 5680, 0x65, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x38, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x08e4, 0x08e0, 0x08dc, 0x01cd,
+	 0x01ce,
+	 0x01ce},
+	{
+	 138, 5690, 0x68, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x39, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x00,
+	 0x00, 0x09, 0x02, 0x23, 0x00, 0x60, 0x08e8, 0x08e4, 0x08e0, 0x01cc,
+	 0x01cd,
+	 0x01ce},
+	{
+	 140, 5700, 0x6c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3a, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08ec, 0x08e8, 0x08e4, 0x01cb,
+	 0x01cc,
+	 0x01cd},
+	{
+	 142, 5710, 0x6f, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3b, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f0, 0x08ec, 0x08e8, 0x01ca,
+	 0x01cb,
+	 0x01cc},
+	{
+	 144, 5720, 0x72, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3c, 0x02, 0x07,
+	 0x00, 0x07, 0x00, 0x77, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f4, 0x08f0, 0x08ec, 0x01c9,
+	 0x01ca,
+	 0x01cb},
+	{
+	 145, 5725, 0x74, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x79, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f6, 0x08f2, 0x08ee, 0x01c9,
+	 0x01ca,
+	 0x01cb},
+	{
+	 146, 5730, 0x76, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3d, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08f8, 0x08f4, 0x08f0, 0x01c9,
+	 0x01c9,
+	 0x01ca},
+	{
+	 147, 5735, 0x77, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7b, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08fa, 0x08f6, 0x08f2, 0x01c8,
+	 0x01c9,
+	 0x01ca},
+	{
+	 148, 5740, 0x79, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3e, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08fc, 0x08f8, 0x08f4, 0x01c8,
+	 0x01c9,
+	 0x01c9},
+	{
+	 149, 5745, 0x7b, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7d, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x30, 0x08fe, 0x08fa, 0x08f6, 0x01c8,
+	 0x01c8,
+	 0x01c9},
+	{
+	 150, 5750, 0x7c, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x3f, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0900, 0x08fc, 0x08f8, 0x01c7,
+	 0x01c8,
+	 0x01c9},
+	{
+	 151, 5755, 0x7e, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x7f, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0902, 0x08fe, 0x08fa, 0x01c7,
+	 0x01c8,
+	 0x01c8},
+	{
+	 152, 5760, 0x80, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x40, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0904, 0x0900, 0x08fc, 0x01c6,
+	 0x01c7,
+	 0x01c8},
+	{
+	 153, 5765, 0x81, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x81, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0906, 0x0902, 0x08fe, 0x01c6,
+	 0x01c7,
+	 0x01c8},
+	{
+	 154, 5770, 0x83, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x41, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0908, 0x0904, 0x0900, 0x01c6,
+	 0x01c6,
+	 0x01c7},
+	{
+	 155, 5775, 0x85, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x83, 0x04, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x090a, 0x0906, 0x0902, 0x01c5,
+	 0x01c6,
+	 0x01c7},
+	{
+	 156, 5780, 0x86, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x42, 0x02, 0x06,
+	 0x00, 0x06, 0x00, 0x66, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x090c, 0x0908, 0x0904, 0x01c5,
+	 0x01c6,
+	 0x01c6},
+	{
+	 157, 5785, 0x88, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x85, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x090e, 0x090a, 0x0906, 0x01c4,
+	 0x01c5,
+	 0x01c6},
+	{
+	 158, 5790, 0x8a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x43, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0910, 0x090c, 0x0908, 0x01c4,
+	 0x01c5,
+	 0x01c6},
+	{
+	 159, 5795, 0x8b, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x87, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x02, 0x13, 0x00, 0x00, 0x0912, 0x090e, 0x090a, 0x01c4,
+	 0x01c4,
+	 0x01c5},
+	{
+	 160, 5800, 0x8d, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x44, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x08, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x08, 0x01, 0x03, 0x00, 0x00, 0x0914, 0x0910, 0x090c, 0x01c3,
+	 0x01c4,
+	 0x01c5},
+	{
+	 161, 5805, 0x8f, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x89, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0916, 0x0912, 0x090e, 0x01c3,
+	 0x01c4,
+	 0x01c4},
+	{
+	 162, 5810, 0x90, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x45, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0918, 0x0914, 0x0910, 0x01c2,
+	 0x01c3,
+	 0x01c4},
+	{
+	 163, 5815, 0x92, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x8b, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x091a, 0x0916, 0x0912, 0x01c2,
+	 0x01c3,
+	 0x01c4},
+	{
+	 164, 5820, 0x94, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x46, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x091c, 0x0918, 0x0914, 0x01c2,
+	 0x01c2,
+	 0x01c3},
+	{
+	 165, 5825, 0x95, 0x17, 0x20, 0x14, 0x08, 0x08, 0x30, 0x8d, 0x04, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x091e, 0x091a, 0x0916, 0x01c1,
+	 0x01c2,
+	 0x01c3},
+	{
+	 166, 5830, 0x97, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x47, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0920, 0x091c, 0x0918, 0x01c1,
+	 0x01c2,
+	 0x01c2},
+	{
+	 168, 5840, 0x9a, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x48, 0x02, 0x05,
+	 0x00, 0x05, 0x00, 0x55, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0924, 0x0920, 0x091c, 0x01c0,
+	 0x01c1,
+	 0x01c2},
+	{
+	 170, 5850, 0x9e, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x49, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0928, 0x0924, 0x0920, 0x01bf,
+	 0x01c0,
+	 0x01c1},
+	{
+	 172, 5860, 0xa1, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4a, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x092c, 0x0928, 0x0924, 0x01bf,
+	 0x01bf,
+	 0x01c0},
+	{
+	 174, 5870, 0xa4, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4b, 0x02, 0x04,
+	 0x00, 0x04, 0x00, 0x44, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0930, 0x092c, 0x0928, 0x01be,
+	 0x01bf,
+	 0x01bf},
+	{
+	 176, 5880, 0xa8, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4c, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0934, 0x0930, 0x092c, 0x01bd,
+	 0x01be,
+	 0x01bf},
+	{
+	 178, 5890, 0xab, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4d, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x0938, 0x0934, 0x0930, 0x01bc,
+	 0x01bd,
+	 0x01be},
+	{
+	 180, 5900, 0xae, 0x17, 0x10, 0x0c, 0x0c, 0x0c, 0x30, 0x4e, 0x02, 0x03,
+	 0x00, 0x03, 0x00, 0x33, 0x00, 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x00,
+	 0x00, 0x06, 0x01, 0x03, 0x00, 0x00, 0x093c, 0x0938, 0x0934, 0x01bc,
+	 0x01bc,
+	 0x01bd},
+	{
+	 1, 2412, 0x48, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x6c, 0x09, 0x0f,
+	 0x0a, 0x00, 0x0a, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03c9, 0x03c5, 0x03c1, 0x043a,
+	 0x043f,
+	 0x0443},
+	{
+	 2, 2417, 0x4b, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x71, 0x09, 0x0f,
+	 0x0a, 0x00, 0x0a, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cb, 0x03c7, 0x03c3, 0x0438,
+	 0x043d,
+	 0x0441},
+	{
+	 3, 2422, 0x4e, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x76, 0x09, 0x0f,
+	 0x09, 0x00, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cd, 0x03c9, 0x03c5, 0x0436,
+	 0x043a,
+	 0x043f},
+	{
+	 4, 2427, 0x52, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x7b, 0x09, 0x0f,
+	 0x09, 0x00, 0x09, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03cf, 0x03cb, 0x03c7, 0x0434,
+	 0x0438,
+	 0x043d},
+	{
+	 5, 2432, 0x55, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x80, 0x09, 0x0f,
+	 0x08, 0x00, 0x08, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d1, 0x03cd, 0x03c9, 0x0431,
+	 0x0436,
+	 0x043a},
+	{
+	 6, 2437, 0x58, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x85, 0x09, 0x0f,
+	 0x08, 0x00, 0x08, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d3, 0x03cf, 0x03cb, 0x042f,
+	 0x0434,
+	 0x0438},
+	{
+	 7, 2442, 0x5c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8a, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d5, 0x03d1, 0x03cd, 0x042d,
+	 0x0431,
+	 0x0436},
+	{
+	 8, 2447, 0x5f, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x8f, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d7, 0x03d3, 0x03cf, 0x042b,
+	 0x042f,
+	 0x0434},
+	{
+	 9, 2452, 0x62, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x94, 0x09, 0x0f,
+	 0x07, 0x00, 0x07, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03d9, 0x03d5, 0x03d1, 0x0429,
+	 0x042d,
+	 0x0431},
+	{
+	 10, 2457, 0x66, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x99, 0x09, 0x0f,
+	 0x06, 0x00, 0x06, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03db, 0x03d7, 0x03d3, 0x0427,
+	 0x042b,
+	 0x042f},
+	{
+	 11, 2462, 0x69, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0x9e, 0x09, 0x0f,
+	 0x06, 0x00, 0x06, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03dd, 0x03d9, 0x03d5, 0x0424,
+	 0x0429,
+	 0x042d},
+	{
+	 12, 2467, 0x6c, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa3, 0x09, 0x0f,
+	 0x05, 0x00, 0x05, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03df, 0x03db, 0x03d7, 0x0422,
+	 0x0427,
+	 0x042b},
+	{
+	 13, 2472, 0x70, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xa8, 0x09, 0x0f,
+	 0x05, 0x00, 0x05, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x03e1, 0x03dd, 0x03d9, 0x0420,
+	 0x0424,
+	 0x0429},
+	{
+	 14, 2484, 0x78, 0x16, 0x30, 0x1b, 0x0a, 0x0a, 0x30, 0xb4, 0x09, 0x0f,
+	 0x04, 0x00, 0x04, 0x00, 0x61, 0x73, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x61,
+	 0x73, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x03e6, 0x03e2, 0x03de, 0x041b,
+	 0x041f,
+	 0x0424}
+};
+
+radio_regs_t regs_2055[] = {
+	{0x02, 0x80, 0x80, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0x27, 0x27, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0x27, 0x27, 0, 0},
+	{0x07, 0x7f, 0x7f, 1, 1},
+	{0x08, 0x7, 0x7, 1, 1},
+	{0x09, 0x7f, 0x7f, 1, 1},
+	{0x0A, 0x7, 0x7, 1, 1},
+	{0x0B, 0x15, 0x15, 0, 0},
+	{0x0C, 0x15, 0x15, 0, 0},
+	{0x0D, 0x4f, 0x4f, 1, 1},
+	{0x0E, 0x5, 0x5, 1, 1},
+	{0x0F, 0x4f, 0x4f, 1, 1},
+	{0x10, 0x5, 0x5, 1, 1},
+	{0x11, 0xd0, 0xd0, 0, 0},
+	{0x12, 0x2, 0x2, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0x40, 0x40, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0xc0, 0xc0, 0, 0},
+	{0x1E, 0xff, 0xff, 0, 0},
+	{0x1F, 0xc0, 0xc0, 0, 0},
+	{0x20, 0xff, 0xff, 0, 0},
+	{0x21, 0xc0, 0xc0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x2c, 0x2c, 0, 0},
+	{0x24, 0, 0, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0xa4, 0xa4, 0, 0},
+	{0x2E, 0x38, 0x38, 0, 0},
+	{0x2F, 0, 0, 0, 0},
+	{0x30, 0x4, 0x4, 1, 1},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0xa, 0xa, 0, 0},
+	{0x33, 0x87, 0x87, 0, 0},
+	{0x34, 0x9, 0x9, 0, 0},
+	{0x35, 0x70, 0x70, 0, 0},
+	{0x36, 0x11, 0x11, 0, 0},
+	{0x37, 0x18, 0x18, 1, 1},
+	{0x38, 0x6, 0x6, 0, 0},
+	{0x39, 0x4, 0x4, 1, 1},
+	{0x3A, 0x6, 0x6, 0, 0},
+	{0x3B, 0x9e, 0x9e, 0, 0},
+	{0x3C, 0x9, 0x9, 0, 0},
+	{0x3D, 0xc8, 0xc8, 1, 1},
+	{0x3E, 0x88, 0x88, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0, 0, 0, 0},
+	{0x42, 0x1, 0x1, 0, 0},
+	{0x43, 0x2, 0x2, 0, 0},
+	{0x44, 0x96, 0x96, 0, 0},
+	{0x45, 0x3e, 0x3e, 0, 0},
+	{0x46, 0x3e, 0x3e, 0, 0},
+	{0x47, 0x13, 0x13, 0, 0},
+	{0x48, 0x2, 0x2, 0, 0},
+	{0x49, 0x15, 0x15, 0, 0},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0, 0, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0, 0, 0, 0},
+	{0x50, 0x8, 0x8, 0, 0},
+	{0x51, 0x8, 0x8, 0, 0},
+	{0x52, 0x6, 0x6, 0, 0},
+	{0x53, 0x84, 0x84, 1, 1},
+	{0x54, 0xc3, 0xc3, 0, 0},
+	{0x55, 0x8f, 0x8f, 0, 0},
+	{0x56, 0xff, 0xff, 0, 0},
+	{0x57, 0xff, 0xff, 0, 0},
+	{0x58, 0x88, 0x88, 0, 0},
+	{0x59, 0x88, 0x88, 0, 0},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0xcc, 0xcc, 0, 0},
+	{0x5C, 0x6, 0x6, 0, 0},
+	{0x5D, 0x80, 0x80, 0, 0},
+	{0x5E, 0x80, 0x80, 0, 0},
+	{0x5F, 0xf8, 0xf8, 0, 0},
+	{0x60, 0x88, 0x88, 0, 0},
+	{0x61, 0x88, 0x88, 0, 0},
+	{0x62, 0x88, 0x8, 1, 1},
+	{0x63, 0x88, 0x88, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0x1, 0x1, 1, 1},
+	{0x66, 0x8a, 0x8a, 0, 0},
+	{0x67, 0x8, 0x8, 0, 0},
+	{0x68, 0x83, 0x83, 0, 0},
+	{0x69, 0x6, 0x6, 0, 0},
+	{0x6A, 0xa0, 0xa0, 0, 0},
+	{0x6B, 0xa, 0xa, 0, 0},
+	{0x6C, 0x87, 0x87, 1, 1},
+	{0x6D, 0x2a, 0x2a, 0, 0},
+	{0x6E, 0x2a, 0x2a, 0, 0},
+	{0x6F, 0x2a, 0x2a, 0, 0},
+	{0x70, 0x2a, 0x2a, 0, 0},
+	{0x71, 0x18, 0x18, 0, 0},
+	{0x72, 0x6a, 0x6a, 1, 1},
+	{0x73, 0xab, 0xab, 1, 1},
+	{0x74, 0x13, 0x13, 1, 1},
+	{0x75, 0xc1, 0xc1, 1, 1},
+	{0x76, 0xaa, 0xaa, 1, 1},
+	{0x77, 0x87, 0x87, 1, 1},
+	{0x78, 0, 0, 0, 0},
+	{0x79, 0x6, 0x6, 0, 0},
+	{0x7A, 0x7, 0x7, 0, 0},
+	{0x7B, 0x7, 0x7, 0, 0},
+	{0x7C, 0x15, 0x15, 0, 0},
+	{0x7D, 0x55, 0x55, 0, 0},
+	{0x7E, 0x97, 0x97, 1, 1},
+	{0x7F, 0x8, 0x8, 0, 0},
+	{0x80, 0x14, 0x14, 1, 1},
+	{0x81, 0x33, 0x33, 0, 0},
+	{0x82, 0x88, 0x88, 0, 0},
+	{0x83, 0x6, 0x6, 0, 0},
+	{0x84, 0x3, 0x3, 1, 1},
+	{0x85, 0xa, 0xa, 0, 0},
+	{0x86, 0x3, 0x3, 1, 1},
+	{0x87, 0x2a, 0x2a, 0, 0},
+	{0x88, 0xa4, 0xa4, 0, 0},
+	{0x89, 0x18, 0x18, 0, 0},
+	{0x8A, 0x28, 0x28, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0x4a, 0x4a, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0xf8, 0xf8, 0, 0},
+	{0x8F, 0x88, 0x88, 0, 0},
+	{0x90, 0x88, 0x88, 0, 0},
+	{0x91, 0x88, 0x8, 1, 1},
+	{0x92, 0x88, 0x88, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0x1, 0x1, 1, 1},
+	{0x95, 0x8a, 0x8a, 0, 0},
+	{0x96, 0x8, 0x8, 0, 0},
+	{0x97, 0x83, 0x83, 0, 0},
+	{0x98, 0x6, 0x6, 0, 0},
+	{0x99, 0xa0, 0xa0, 0, 0},
+	{0x9A, 0xa, 0xa, 0, 0},
+	{0x9B, 0x87, 0x87, 1, 1},
+	{0x9C, 0x2a, 0x2a, 0, 0},
+	{0x9D, 0x2a, 0x2a, 0, 0},
+	{0x9E, 0x2a, 0x2a, 0, 0},
+	{0x9F, 0x2a, 0x2a, 0, 0},
+	{0xA0, 0x18, 0x18, 0, 0},
+	{0xA1, 0x6a, 0x6a, 1, 1},
+	{0xA2, 0xab, 0xab, 1, 1},
+	{0xA3, 0x13, 0x13, 1, 1},
+	{0xA4, 0xc1, 0xc1, 1, 1},
+	{0xA5, 0xaa, 0xaa, 1, 1},
+	{0xA6, 0x87, 0x87, 1, 1},
+	{0xA7, 0, 0, 0, 0},
+	{0xA8, 0x6, 0x6, 0, 0},
+	{0xA9, 0x7, 0x7, 0, 0},
+	{0xAA, 0x7, 0x7, 0, 0},
+	{0xAB, 0x15, 0x15, 0, 0},
+	{0xAC, 0x55, 0x55, 0, 0},
+	{0xAD, 0x97, 0x97, 1, 1},
+	{0xAE, 0x8, 0x8, 0, 0},
+	{0xAF, 0x14, 0x14, 1, 1},
+	{0xB0, 0x33, 0x33, 0, 0},
+	{0xB1, 0x88, 0x88, 0, 0},
+	{0xB2, 0x6, 0x6, 0, 0},
+	{0xB3, 0x3, 0x3, 1, 1},
+	{0xB4, 0xa, 0xa, 0, 0},
+	{0xB5, 0x3, 0x3, 1, 1},
+	{0xB6, 0x2a, 0x2a, 0, 0},
+	{0xB7, 0xa4, 0xa4, 0, 0},
+	{0xB8, 0x18, 0x18, 0, 0},
+	{0xB9, 0x28, 0x28, 0, 0},
+	{0xBA, 0, 0, 0, 0},
+	{0xBB, 0x4a, 0x4a, 0, 0},
+	{0xBC, 0, 0, 0, 0},
+	{0xBD, 0x71, 0x71, 0, 0},
+	{0xBE, 0x72, 0x72, 0, 0},
+	{0xBF, 0x73, 0x73, 0, 0},
+	{0xC0, 0x74, 0x74, 0, 0},
+	{0xC1, 0x75, 0x75, 0, 0},
+	{0xC2, 0x76, 0x76, 0, 0},
+	{0xC3, 0x77, 0x77, 0, 0},
+	{0xC4, 0x78, 0x78, 0, 0},
+	{0xC5, 0x79, 0x79, 0, 0},
+	{0xC6, 0x7a, 0x7a, 0, 0},
+	{0xC7, 0, 0, 0, 0},
+	{0xC8, 0, 0, 0, 0},
+	{0xC9, 0, 0, 0, 0},
+	{0xCA, 0, 0, 0, 0},
+	{0xCB, 0, 0, 0, 0},
+	{0xCC, 0, 0, 0, 0},
+	{0xCD, 0, 0, 0, 0},
+	{0xCE, 0x6, 0x6, 0, 0},
+	{0xCF, 0, 0, 0, 0},
+	{0xD0, 0, 0, 0, 0},
+	{0xD1, 0x18, 0x18, 0, 0},
+	{0xD2, 0x88, 0x88, 0, 0},
+	{0xD3, 0, 0, 0, 0},
+	{0xD4, 0, 0, 0, 0},
+	{0xD5, 0, 0, 0, 0},
+	{0xD6, 0, 0, 0, 0},
+	{0xD7, 0, 0, 0, 0},
+	{0xD8, 0, 0, 0, 0},
+	{0xD9, 0, 0, 0, 0},
+	{0xDA, 0x6, 0x6, 0, 0},
+	{0xDB, 0, 0, 0, 0},
+	{0xDC, 0, 0, 0, 0},
+	{0xDD, 0x18, 0x18, 0, 0},
+	{0xDE, 0x88, 0x88, 0, 0},
+	{0xDF, 0, 0, 0, 0},
+	{0xE0, 0, 0, 0, 0},
+	{0xE1, 0, 0, 0, 0},
+	{0xE2, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_SYN_2056[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0x1, 0x1, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0x60, 0x60, 0, 0},
+	{0x23, 0x6, 0x6, 0, 0},
+	{0x24, 0xc, 0xc, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0x1, 0x1, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0xd, 0xd, 0, 0},
+	{0x2F, 0x1f, 0x1f, 0, 0},
+	{0x30, 0x15, 0x15, 0, 0},
+	{0x31, 0xf, 0xf, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0, 0, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0, 0, 0, 0},
+	{0x38, 0, 0, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0, 0, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x13, 0x13, 0, 0},
+	{0x3D, 0xf, 0xf, 0, 0},
+	{0x3E, 0x18, 0x18, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x20, 0x20, 0, 0},
+	{0x42, 0x20, 0x20, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x77, 0x77, 0, 0},
+	{0x45, 0x7, 0x7, 0, 0},
+	{0x46, 0x1, 0x1, 0, 0},
+	{0x47, 0x4, 0x4, 0, 0},
+	{0x48, 0xf, 0xf, 0, 0},
+	{0x49, 0x30, 0x30, 0, 0},
+	{0x4A, 0x32, 0x32, 0, 0},
+	{0x4B, 0xd, 0xd, 0, 0},
+	{0x4C, 0xd, 0xd, 0, 0},
+	{0x4D, 0x4, 0x4, 0, 0},
+	{0x4E, 0x6, 0x6, 0, 0},
+	{0x4F, 0x1, 0x1, 0, 0},
+	{0x50, 0x1c, 0x1c, 0, 0},
+	{0x51, 0x2, 0x2, 0, 0},
+	{0x52, 0x2, 0x2, 0, 0},
+	{0x53, 0xf7, 0xf7, 1, 1},
+	{0x54, 0xb4, 0xb4, 0, 0},
+	{0x55, 0xd2, 0xd2, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x4, 0x4, 0, 0},
+	{0x59, 0x96, 0x96, 0, 0},
+	{0x5A, 0x3e, 0x3e, 0, 0},
+	{0x5B, 0x3e, 0x3e, 0, 0},
+	{0x5C, 0x13, 0x13, 0, 0},
+	{0x5D, 0x2, 0x2, 0, 0},
+	{0x5E, 0, 0, 0, 0},
+	{0x5F, 0x7, 0x7, 0, 0},
+	{0x60, 0x7, 0x7, 1, 1},
+	{0x61, 0x8, 0x8, 0, 0},
+	{0x62, 0x3, 0x3, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0x40, 0x40, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0x1, 0x1, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0x60, 0x60, 0, 0},
+	{0x71, 0x66, 0x66, 0, 0},
+	{0x72, 0xc, 0xc, 0, 0},
+	{0x73, 0x66, 0x66, 0, 0},
+	{0x74, 0x8f, 0x8f, 1, 1},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0xcc, 0xcc, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0x66, 0x66, 0, 0},
+	{0x79, 0x66, 0x66, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0xff, 0xff, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0, 0, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0, 0, 0, 0},
+	{0x9A, 0, 0, 0, 0},
+	{0x9B, 0, 0, 0, 0},
+	{0x9C, 0, 0, 0, 0},
+	{0x9D, 0, 0, 0, 0},
+	{0x9E, 0, 0, 0, 0},
+	{0x9F, 0x6, 0x6, 0, 0},
+	{0xA0, 0x66, 0x66, 0, 0},
+	{0xA1, 0x66, 0x66, 0, 0},
+	{0xA2, 0x66, 0x66, 0, 0},
+	{0xA3, 0x66, 0x66, 0, 0},
+	{0xA4, 0x66, 0x66, 0, 0},
+	{0xA5, 0x66, 0x66, 0, 0},
+	{0xA6, 0x66, 0x66, 0, 0},
+	{0xA7, 0x66, 0x66, 0, 0},
+	{0xA8, 0x66, 0x66, 0, 0},
+	{0xA9, 0x66, 0x66, 0, 0},
+	{0xAA, 0x66, 0x66, 0, 0},
+	{0xAB, 0x66, 0x66, 0, 0},
+	{0xAC, 0x66, 0x66, 0, 0},
+	{0xAD, 0x66, 0x66, 0, 0},
+	{0xAE, 0x66, 0x66, 0, 0},
+	{0xAF, 0x66, 0x66, 0, 0},
+	{0xB0, 0x66, 0x66, 0, 0},
+	{0xB1, 0x66, 0x66, 0, 0},
+	{0xB2, 0x66, 0x66, 0, 0},
+	{0xB3, 0xa, 0xa, 0, 0},
+	{0xB4, 0, 0, 0, 0},
+	{0xB5, 0, 0, 0, 0},
+	{0xB6, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_TX_2056[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0x88, 0x88, 0, 0},
+	{0x22, 0x88, 0x88, 0, 0},
+	{0x23, 0x88, 0x88, 0, 0},
+	{0x24, 0x88, 0x88, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0x3, 0x3, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x3, 0x3, 0, 0},
+	{0x2A, 0x37, 0x37, 0, 0},
+	{0x2B, 0x3, 0x3, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0x1, 0x1, 0, 0},
+	{0x2F, 0x1, 0x1, 0, 0},
+	{0x30, 0, 0, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0x11, 0x11, 0, 0},
+	{0x34, 0x11, 0x11, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x3, 0x3, 0, 0},
+	{0x38, 0xf, 0xf, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0x2d, 0x2d, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x6e, 0x6e, 0, 0},
+	{0x3D, 0xf0, 0xf0, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x3, 0x3, 0, 0},
+	{0x42, 0x3, 0x3, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x1e, 0x1e, 0, 0},
+	{0x45, 0, 0, 0, 0},
+	{0x46, 0x6e, 0x6e, 0, 0},
+	{0x47, 0xf0, 0xf0, 1, 1},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x2, 0x2, 0, 0},
+	{0x4A, 0xff, 0xff, 1, 1},
+	{0x4B, 0xc, 0xc, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0x38, 0x38, 0, 0},
+	{0x4E, 0x70, 0x70, 1, 1},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0x88, 0x88, 0, 0},
+	{0x51, 0xc, 0xc, 0, 0},
+	{0x52, 0, 0, 0, 0},
+	{0x53, 0x8, 0x8, 0, 0},
+	{0x54, 0x70, 0x70, 1, 1},
+	{0x55, 0x2, 0x2, 0, 0},
+	{0x56, 0xff, 0xff, 1, 1},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x83, 0x83, 0, 0},
+	{0x59, 0x77, 0x77, 1, 1},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x88, 0x88, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x8, 0x8, 0, 0},
+	{0x5F, 0x77, 0x77, 1, 1},
+	{0x60, 0x1, 0x1, 0, 0},
+	{0x61, 0, 0, 0, 0},
+	{0x62, 0x7, 0x7, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0x7, 0x7, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0x74, 0x74, 1, 1},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0xa, 0xa, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0x2, 0x2, 0, 0},
+	{0x72, 0, 0, 0, 0},
+	{0x73, 0, 0, 0, 0},
+	{0x74, 0xe, 0xe, 0, 0},
+	{0x75, 0xe, 0xe, 0, 0},
+	{0x76, 0xe, 0xe, 0, 0},
+	{0x77, 0x13, 0x13, 0, 0},
+	{0x78, 0x13, 0x13, 0, 0},
+	{0x79, 0x1b, 0x1b, 0, 0},
+	{0x7A, 0x1b, 0x1b, 0, 0},
+	{0x7B, 0x55, 0x55, 0, 0},
+	{0x7C, 0x5b, 0x5b, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_RX_2056[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0x3, 0x3, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x90, 0x90, 0, 0},
+	{0x24, 0x55, 0x55, 0, 0},
+	{0x25, 0x15, 0x15, 0, 0},
+	{0x26, 0x5, 0x5, 0, 0},
+	{0x27, 0x15, 0x15, 0, 0},
+	{0x28, 0x5, 0x5, 0, 0},
+	{0x29, 0x20, 0x20, 0, 0},
+	{0x2A, 0x11, 0x11, 0, 0},
+	{0x2B, 0x90, 0x90, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0x88, 0x88, 0, 0},
+	{0x2E, 0x32, 0x32, 0, 0},
+	{0x2F, 0x77, 0x77, 0, 0},
+	{0x30, 0x17, 0x17, 1, 1},
+	{0x31, 0xff, 0xff, 1, 1},
+	{0x32, 0x20, 0x20, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0x88, 0x88, 0, 0},
+	{0x35, 0x32, 0x32, 0, 0},
+	{0x36, 0x77, 0x77, 0, 0},
+	{0x37, 0x17, 0x17, 1, 1},
+	{0x38, 0xf0, 0xf0, 1, 1},
+	{0x39, 0x20, 0x20, 0, 0},
+	{0x3A, 0x8, 0x8, 0, 0},
+	{0x3B, 0x99, 0x99, 0, 0},
+	{0x3C, 0, 0, 0, 0},
+	{0x3D, 0x44, 0x44, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0x44, 0x44, 0, 0},
+	{0x40, 0xf, 0xf, 1, 1},
+	{0x41, 0x6, 0x6, 0, 0},
+	{0x42, 0x4, 0x4, 0, 0},
+	{0x43, 0x50, 0x50, 1, 1},
+	{0x44, 0x8, 0x8, 0, 0},
+	{0x45, 0x99, 0x99, 0, 0},
+	{0x46, 0, 0, 0, 0},
+	{0x47, 0x11, 0x11, 0, 0},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x44, 0x44, 0, 0},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0x6, 0x6, 0, 0},
+	{0x4C, 0x4, 0x4, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x66, 0x66, 0, 0},
+	{0x50, 0x66, 0x66, 0, 0},
+	{0x51, 0x57, 0x57, 0, 0},
+	{0x52, 0x57, 0x57, 0, 0},
+	{0x53, 0x44, 0x44, 0, 0},
+	{0x54, 0, 0, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0x8, 0x8, 0, 0},
+	{0x57, 0x8, 0x8, 0, 0},
+	{0x58, 0x7, 0x7, 0, 0},
+	{0x59, 0x22, 0x22, 0, 0},
+	{0x5A, 0x22, 0x22, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x23, 0x23, 0, 0},
+	{0x5D, 0x7, 0x7, 0, 0},
+	{0x5E, 0x55, 0x55, 0, 0},
+	{0x5F, 0x23, 0x23, 0, 0},
+	{0x60, 0x41, 0x41, 0, 0},
+	{0x61, 0x1, 0x1, 0, 0},
+	{0x62, 0xa, 0xa, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0xc, 0xc, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0, 0, 0, 0},
+	{0x72, 0x22, 0x22, 0, 0},
+	{0x73, 0x22, 0x22, 0, 0},
+	{0x74, 0x2, 0x2, 0, 0},
+	{0x75, 0xa, 0xa, 0, 0},
+	{0x76, 0x1, 0x1, 0, 0},
+	{0x77, 0x22, 0x22, 0, 0},
+	{0x78, 0x30, 0x30, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_SYN_2056_A1[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0x1, 0x1, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0x60, 0x60, 0, 0},
+	{0x23, 0x6, 0x6, 0, 0},
+	{0x24, 0xc, 0xc, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0x1, 0x1, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0xd, 0xd, 0, 0},
+	{0x2F, 0x1f, 0x1f, 0, 0},
+	{0x30, 0x15, 0x15, 0, 0},
+	{0x31, 0xf, 0xf, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0, 0, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0, 0, 0, 0},
+	{0x38, 0, 0, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0, 0, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x13, 0x13, 0, 0},
+	{0x3D, 0xf, 0xf, 0, 0},
+	{0x3E, 0x18, 0x18, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x20, 0x20, 0, 0},
+	{0x42, 0x20, 0x20, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x77, 0x77, 0, 0},
+	{0x45, 0x7, 0x7, 0, 0},
+	{0x46, 0x1, 0x1, 0, 0},
+	{0x47, 0x4, 0x4, 0, 0},
+	{0x48, 0xf, 0xf, 0, 0},
+	{0x49, 0x30, 0x30, 0, 0},
+	{0x4A, 0x32, 0x32, 0, 0},
+	{0x4B, 0xd, 0xd, 0, 0},
+	{0x4C, 0xd, 0xd, 0, 0},
+	{0x4D, 0x4, 0x4, 0, 0},
+	{0x4E, 0x6, 0x6, 0, 0},
+	{0x4F, 0x1, 0x1, 0, 0},
+	{0x50, 0x1c, 0x1c, 0, 0},
+	{0x51, 0x2, 0x2, 0, 0},
+	{0x52, 0x2, 0x2, 0, 0},
+	{0x53, 0xf7, 0xf7, 1, 1},
+	{0x54, 0xb4, 0xb4, 0, 0},
+	{0x55, 0xd2, 0xd2, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x4, 0x4, 0, 0},
+	{0x59, 0x96, 0x96, 0, 0},
+	{0x5A, 0x3e, 0x3e, 0, 0},
+	{0x5B, 0x3e, 0x3e, 0, 0},
+	{0x5C, 0x13, 0x13, 0, 0},
+	{0x5D, 0x2, 0x2, 0, 0},
+	{0x5E, 0, 0, 0, 0},
+	{0x5F, 0x7, 0x7, 0, 0},
+	{0x60, 0x7, 0x7, 1, 1},
+	{0x61, 0x8, 0x8, 0, 0},
+	{0x62, 0x3, 0x3, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0x40, 0x40, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0x1, 0x1, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0x60, 0x60, 0, 0},
+	{0x71, 0x66, 0x66, 0, 0},
+	{0x72, 0xc, 0xc, 0, 0},
+	{0x73, 0x66, 0x66, 0, 0},
+	{0x74, 0x8f, 0x8f, 1, 1},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0xcc, 0xcc, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0x66, 0x66, 0, 0},
+	{0x79, 0x66, 0x66, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0xff, 0xff, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0, 0, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0, 0, 0, 0},
+	{0x9A, 0, 0, 0, 0},
+	{0x9B, 0, 0, 0, 0},
+	{0x9C, 0, 0, 0, 0},
+	{0x9D, 0, 0, 0, 0},
+	{0x9E, 0, 0, 0, 0},
+	{0x9F, 0x6, 0x6, 0, 0},
+	{0xA0, 0x66, 0x66, 0, 0},
+	{0xA1, 0x66, 0x66, 0, 0},
+	{0xA2, 0x66, 0x66, 0, 0},
+	{0xA3, 0x66, 0x66, 0, 0},
+	{0xA4, 0x66, 0x66, 0, 0},
+	{0xA5, 0x66, 0x66, 0, 0},
+	{0xA6, 0x66, 0x66, 0, 0},
+	{0xA7, 0x66, 0x66, 0, 0},
+	{0xA8, 0x66, 0x66, 0, 0},
+	{0xA9, 0x66, 0x66, 0, 0},
+	{0xAA, 0x66, 0x66, 0, 0},
+	{0xAB, 0x66, 0x66, 0, 0},
+	{0xAC, 0x66, 0x66, 0, 0},
+	{0xAD, 0x66, 0x66, 0, 0},
+	{0xAE, 0x66, 0x66, 0, 0},
+	{0xAF, 0x66, 0x66, 0, 0},
+	{0xB0, 0x66, 0x66, 0, 0},
+	{0xB1, 0x66, 0x66, 0, 0},
+	{0xB2, 0x66, 0x66, 0, 0},
+	{0xB3, 0xa, 0xa, 0, 0},
+	{0xB4, 0, 0, 0, 0},
+	{0xB5, 0, 0, 0, 0},
+	{0xB6, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_TX_2056_A1[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0x88, 0x88, 0, 0},
+	{0x22, 0x88, 0x88, 0, 0},
+	{0x23, 0x88, 0x88, 0, 0},
+	{0x24, 0x88, 0x88, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0x3, 0x3, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x3, 0x3, 0, 0},
+	{0x2A, 0x37, 0x37, 0, 0},
+	{0x2B, 0x3, 0x3, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0x1, 0x1, 0, 0},
+	{0x2F, 0x1, 0x1, 0, 0},
+	{0x30, 0, 0, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0x11, 0x11, 0, 0},
+	{0x34, 0x11, 0x11, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x3, 0x3, 0, 0},
+	{0x38, 0xf, 0xf, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0x2d, 0x2d, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x6e, 0x6e, 0, 0},
+	{0x3D, 0xf0, 0xf0, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x3, 0x3, 0, 0},
+	{0x42, 0x3, 0x3, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x1e, 0x1e, 0, 0},
+	{0x45, 0, 0, 0, 0},
+	{0x46, 0x6e, 0x6e, 0, 0},
+	{0x47, 0xf0, 0xf0, 1, 1},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x2, 0x2, 0, 0},
+	{0x4A, 0xff, 0xff, 1, 1},
+	{0x4B, 0xc, 0xc, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0x38, 0x38, 0, 0},
+	{0x4E, 0x70, 0x70, 1, 1},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0x88, 0x88, 0, 0},
+	{0x51, 0xc, 0xc, 0, 0},
+	{0x52, 0, 0, 0, 0},
+	{0x53, 0x8, 0x8, 0, 0},
+	{0x54, 0x70, 0x70, 1, 1},
+	{0x55, 0x2, 0x2, 0, 0},
+	{0x56, 0xff, 0xff, 1, 1},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x83, 0x83, 0, 0},
+	{0x59, 0x77, 0x77, 1, 1},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x88, 0x88, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x8, 0x8, 0, 0},
+	{0x5F, 0x77, 0x77, 1, 1},
+	{0x60, 0x1, 0x1, 0, 0},
+	{0x61, 0, 0, 0, 0},
+	{0x62, 0x7, 0x7, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0x7, 0x7, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0x72, 0x72, 1, 1},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0xa, 0xa, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0x2, 0x2, 0, 0},
+	{0x72, 0, 0, 0, 0},
+	{0x73, 0, 0, 0, 0},
+	{0x74, 0xe, 0xe, 0, 0},
+	{0x75, 0xe, 0xe, 0, 0},
+	{0x76, 0xe, 0xe, 0, 0},
+	{0x77, 0x13, 0x13, 0, 0},
+	{0x78, 0x13, 0x13, 0, 0},
+	{0x79, 0x1b, 0x1b, 0, 0},
+	{0x7A, 0x1b, 0x1b, 0, 0},
+	{0x7B, 0x55, 0x55, 0, 0},
+	{0x7C, 0x5b, 0x5b, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_RX_2056_A1[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0x3, 0x3, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x90, 0x90, 0, 0},
+	{0x24, 0x55, 0x55, 0, 0},
+	{0x25, 0x15, 0x15, 0, 0},
+	{0x26, 0x5, 0x5, 0, 0},
+	{0x27, 0x15, 0x15, 0, 0},
+	{0x28, 0x5, 0x5, 0, 0},
+	{0x29, 0x20, 0x20, 0, 0},
+	{0x2A, 0x11, 0x11, 0, 0},
+	{0x2B, 0x90, 0x90, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0x88, 0x88, 0, 0},
+	{0x2E, 0x32, 0x32, 0, 0},
+	{0x2F, 0x77, 0x77, 0, 0},
+	{0x30, 0x17, 0x17, 1, 1},
+	{0x31, 0xff, 0xff, 1, 1},
+	{0x32, 0x20, 0x20, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0x88, 0x88, 0, 0},
+	{0x35, 0x32, 0x32, 0, 0},
+	{0x36, 0x77, 0x77, 0, 0},
+	{0x37, 0x17, 0x17, 1, 1},
+	{0x38, 0xf0, 0xf0, 1, 1},
+	{0x39, 0x20, 0x20, 0, 0},
+	{0x3A, 0x8, 0x8, 0, 0},
+	{0x3B, 0x55, 0x55, 1, 1},
+	{0x3C, 0, 0, 0, 0},
+	{0x3D, 0x44, 0x44, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0x44, 0x44, 0, 0},
+	{0x40, 0xf, 0xf, 1, 1},
+	{0x41, 0x6, 0x6, 0, 0},
+	{0x42, 0x4, 0x4, 0, 0},
+	{0x43, 0x50, 0x50, 1, 1},
+	{0x44, 0x8, 0x8, 0, 0},
+	{0x45, 0x55, 0x55, 1, 1},
+	{0x46, 0, 0, 0, 0},
+	{0x47, 0x11, 0x11, 0, 0},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x44, 0x44, 0, 0},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0x6, 0x6, 0, 0},
+	{0x4C, 0x4, 0x4, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x26, 0x26, 1, 1},
+	{0x50, 0x26, 0x26, 1, 1},
+	{0x51, 0xf, 0xf, 1, 1},
+	{0x52, 0xf, 0xf, 1, 1},
+	{0x53, 0x44, 0x44, 0, 0},
+	{0x54, 0, 0, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0x8, 0x8, 0, 0},
+	{0x57, 0x8, 0x8, 0, 0},
+	{0x58, 0x7, 0x7, 0, 0},
+	{0x59, 0x22, 0x22, 0, 0},
+	{0x5A, 0x22, 0x22, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x2f, 0x2f, 1, 1},
+	{0x5D, 0x7, 0x7, 0, 0},
+	{0x5E, 0x55, 0x55, 0, 0},
+	{0x5F, 0x23, 0x23, 0, 0},
+	{0x60, 0x41, 0x41, 0, 0},
+	{0x61, 0x1, 0x1, 0, 0},
+	{0x62, 0xa, 0xa, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0xc, 0xc, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0, 0, 0, 0},
+	{0x72, 0x22, 0x22, 0, 0},
+	{0x73, 0x22, 0x22, 0, 0},
+	{0x74, 0, 0, 1, 1},
+	{0x75, 0xa, 0xa, 0, 0},
+	{0x76, 0x1, 0x1, 0, 0},
+	{0x77, 0x22, 0x22, 0, 0},
+	{0x78, 0x30, 0x30, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_SYN_2056_rev5[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0x1, 0x1, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0x60, 0x60, 0, 0},
+	{0x23, 0x6, 0x6, 0, 0},
+	{0x24, 0xc, 0xc, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0x1, 0x1, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0, 0, 0, 0},
+	{0x2F, 0x1f, 0x1f, 0, 0},
+	{0x30, 0x15, 0x15, 0, 0},
+	{0x31, 0xf, 0xf, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0, 0, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0, 0, 0, 0},
+	{0x38, 0, 0, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0, 0, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x13, 0x13, 0, 0},
+	{0x3D, 0xf, 0xf, 0, 0},
+	{0x3E, 0x18, 0x18, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x20, 0x20, 0, 0},
+	{0x42, 0x20, 0x20, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x77, 0x77, 0, 0},
+	{0x45, 0x7, 0x7, 0, 0},
+	{0x46, 0x1, 0x1, 0, 0},
+	{0x47, 0x4, 0x4, 0, 0},
+	{0x48, 0xf, 0xf, 0, 0},
+	{0x49, 0x30, 0x30, 0, 0},
+	{0x4A, 0x32, 0x32, 0, 0},
+	{0x4B, 0xd, 0xd, 0, 0},
+	{0x4C, 0xd, 0xd, 0, 0},
+	{0x4D, 0x4, 0x4, 0, 0},
+	{0x4E, 0x6, 0x6, 0, 0},
+	{0x4F, 0x1, 0x1, 0, 0},
+	{0x50, 0x1c, 0x1c, 0, 0},
+	{0x51, 0x2, 0x2, 0, 0},
+	{0x52, 0x2, 0x2, 0, 0},
+	{0x53, 0xf7, 0xf7, 1, 1},
+	{0x54, 0xb4, 0xb4, 0, 0},
+	{0x55, 0xd2, 0xd2, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x4, 0x4, 0, 0},
+	{0x59, 0x96, 0x96, 0, 0},
+	{0x5A, 0x3e, 0x3e, 0, 0},
+	{0x5B, 0x3e, 0x3e, 0, 0},
+	{0x5C, 0x13, 0x13, 0, 0},
+	{0x5D, 0x2, 0x2, 0, 0},
+	{0x5E, 0, 0, 0, 0},
+	{0x5F, 0x7, 0x7, 0, 0},
+	{0x60, 0x7, 0x7, 1, 1},
+	{0x61, 0x8, 0x8, 0, 0},
+	{0x62, 0x3, 0x3, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0x40, 0x40, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0x1, 0x1, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0x60, 0x60, 0, 0},
+	{0x71, 0x66, 0x66, 0, 0},
+	{0x72, 0xc, 0xc, 0, 0},
+	{0x73, 0x66, 0x66, 0, 0},
+	{0x74, 0x8f, 0x8f, 1, 1},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0xcc, 0xcc, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0x66, 0x66, 0, 0},
+	{0x79, 0x66, 0x66, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0xff, 0xff, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0, 0, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0, 0, 0, 0},
+	{0x9A, 0, 0, 0, 0},
+	{0x9B, 0, 0, 0, 0},
+	{0x9C, 0, 0, 0, 0},
+	{0x9D, 0, 0, 0, 0},
+	{0x9E, 0, 0, 0, 0},
+	{0x9F, 0x6, 0x6, 0, 0},
+	{0xA0, 0x66, 0x66, 0, 0},
+	{0xA1, 0x66, 0x66, 0, 0},
+	{0xA2, 0x66, 0x66, 0, 0},
+	{0xA3, 0x66, 0x66, 0, 0},
+	{0xA4, 0x66, 0x66, 0, 0},
+	{0xA5, 0x66, 0x66, 0, 0},
+	{0xA6, 0x66, 0x66, 0, 0},
+	{0xA7, 0x66, 0x66, 0, 0},
+	{0xA8, 0x66, 0x66, 0, 0},
+	{0xA9, 0x66, 0x66, 0, 0},
+	{0xAA, 0x66, 0x66, 0, 0},
+	{0xAB, 0x66, 0x66, 0, 0},
+	{0xAC, 0x66, 0x66, 0, 0},
+	{0xAD, 0x66, 0x66, 0, 0},
+	{0xAE, 0x66, 0x66, 0, 0},
+	{0xAF, 0x66, 0x66, 0, 0},
+	{0xB0, 0x66, 0x66, 0, 0},
+	{0xB1, 0x66, 0x66, 0, 0},
+	{0xB2, 0x66, 0x66, 0, 0},
+	{0xB3, 0xa, 0xa, 0, 0},
+	{0xB4, 0, 0, 0, 0},
+	{0xB5, 0, 0, 0, 0},
+	{0xB6, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_TX_2056_rev5[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0x88, 0x88, 0, 0},
+	{0x22, 0x88, 0x88, 0, 0},
+	{0x23, 0x88, 0x88, 0, 0},
+	{0x24, 0x88, 0x88, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0x3, 0x3, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x3, 0x3, 0, 0},
+	{0x2A, 0x37, 0x37, 0, 0},
+	{0x2B, 0x3, 0x3, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0x1, 0x1, 0, 0},
+	{0x2F, 0x1, 0x1, 0, 0},
+	{0x30, 0, 0, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0x11, 0x11, 0, 0},
+	{0x34, 0x11, 0x11, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x3, 0x3, 0, 0},
+	{0x38, 0xf, 0xf, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0x2d, 0x2d, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x6e, 0x6e, 0, 0},
+	{0x3D, 0xf0, 0xf0, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x3, 0x3, 0, 0},
+	{0x42, 0x3, 0x3, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x1e, 0x1e, 0, 0},
+	{0x45, 0, 0, 0, 0},
+	{0x46, 0x6e, 0x6e, 0, 0},
+	{0x47, 0xf0, 0xf0, 1, 1},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x2, 0x2, 0, 0},
+	{0x4A, 0xff, 0xff, 1, 1},
+	{0x4B, 0xc, 0xc, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0x38, 0x38, 0, 0},
+	{0x4E, 0x70, 0x70, 1, 1},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0x88, 0x88, 0, 0},
+	{0x51, 0xc, 0xc, 0, 0},
+	{0x52, 0, 0, 0, 0},
+	{0x53, 0x8, 0x8, 0, 0},
+	{0x54, 0x70, 0x70, 1, 1},
+	{0x55, 0x2, 0x2, 0, 0},
+	{0x56, 0xff, 0xff, 1, 1},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x83, 0x83, 0, 0},
+	{0x59, 0x77, 0x77, 1, 1},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x88, 0x88, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x8, 0x8, 0, 0},
+	{0x5F, 0x77, 0x77, 1, 1},
+	{0x60, 0x1, 0x1, 0, 0},
+	{0x61, 0, 0, 0, 0},
+	{0x62, 0x7, 0x7, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0x7, 0x7, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 1, 1},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0xa, 0xa, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0x2, 0x2, 0, 0},
+	{0x72, 0, 0, 0, 0},
+	{0x73, 0, 0, 0, 0},
+	{0x74, 0xe, 0xe, 0, 0},
+	{0x75, 0xe, 0xe, 0, 0},
+	{0x76, 0xe, 0xe, 0, 0},
+	{0x77, 0x13, 0x13, 0, 0},
+	{0x78, 0x13, 0x13, 0, 0},
+	{0x79, 0x1b, 0x1b, 0, 0},
+	{0x7A, 0x1b, 0x1b, 0, 0},
+	{0x7B, 0x55, 0x55, 0, 0},
+	{0x7C, 0x5b, 0x5b, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0x70, 0x70, 0, 0},
+	{0x94, 0x70, 0x70, 0, 0},
+	{0x95, 0x71, 0x71, 1, 1},
+	{0x96, 0x71, 0x71, 1, 1},
+	{0x97, 0x72, 0x72, 1, 1},
+	{0x98, 0x73, 0x73, 1, 1},
+	{0x99, 0x74, 0x74, 1, 1},
+	{0x9A, 0x75, 0x75, 1, 1},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_RX_2056_rev5[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0x3, 0x3, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x90, 0x90, 0, 0},
+	{0x24, 0x55, 0x55, 0, 0},
+	{0x25, 0x15, 0x15, 0, 0},
+	{0x26, 0x5, 0x5, 0, 0},
+	{0x27, 0x15, 0x15, 0, 0},
+	{0x28, 0x5, 0x5, 0, 0},
+	{0x29, 0x20, 0x20, 0, 0},
+	{0x2A, 0x11, 0x11, 0, 0},
+	{0x2B, 0x90, 0x90, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0x88, 0x88, 0, 0},
+	{0x2E, 0x32, 0x32, 0, 0},
+	{0x2F, 0x77, 0x77, 0, 0},
+	{0x30, 0x17, 0x17, 1, 1},
+	{0x31, 0xff, 0xff, 1, 1},
+	{0x32, 0x20, 0x20, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0x88, 0x88, 0, 0},
+	{0x35, 0x32, 0x32, 0, 0},
+	{0x36, 0x77, 0x77, 0, 0},
+	{0x37, 0x17, 0x17, 1, 1},
+	{0x38, 0xf0, 0xf0, 1, 1},
+	{0x39, 0x20, 0x20, 0, 0},
+	{0x3A, 0x8, 0x8, 0, 0},
+	{0x3B, 0x55, 0x55, 1, 1},
+	{0x3C, 0, 0, 0, 0},
+	{0x3D, 0x88, 0x88, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 1, 1},
+	{0x40, 0x7, 0x7, 1, 1},
+	{0x41, 0x6, 0x6, 0, 0},
+	{0x42, 0x4, 0x4, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x8, 0x8, 0, 0},
+	{0x45, 0x55, 0x55, 1, 1},
+	{0x46, 0, 0, 0, 0},
+	{0x47, 0x11, 0x11, 0, 0},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0, 0, 1, 1},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0x6, 0x6, 0, 0},
+	{0x4C, 0x4, 0x4, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x26, 0x26, 1, 1},
+	{0x50, 0x26, 0x26, 1, 1},
+	{0x51, 0xf, 0xf, 1, 1},
+	{0x52, 0xf, 0xf, 1, 1},
+	{0x53, 0x44, 0x44, 0, 0},
+	{0x54, 0, 0, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0x8, 0x8, 0, 0},
+	{0x57, 0x8, 0x8, 0, 0},
+	{0x58, 0x7, 0x7, 0, 0},
+	{0x59, 0x22, 0x22, 0, 0},
+	{0x5A, 0x22, 0x22, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x4, 0x4, 1, 1},
+	{0x5D, 0x7, 0x7, 0, 0},
+	{0x5E, 0x55, 0x55, 0, 0},
+	{0x5F, 0x23, 0x23, 0, 0},
+	{0x60, 0x41, 0x41, 0, 0},
+	{0x61, 0x1, 0x1, 0, 0},
+	{0x62, 0xa, 0xa, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0xc, 0xc, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0, 0, 0, 0},
+	{0x72, 0x22, 0x22, 0, 0},
+	{0x73, 0x22, 0x22, 0, 0},
+	{0x74, 0, 0, 1, 1},
+	{0x75, 0xa, 0xa, 0, 0},
+	{0x76, 0x1, 0x1, 0, 0},
+	{0x77, 0x22, 0x22, 0, 0},
+	{0x78, 0x30, 0x30, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_SYN_2056_rev6[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0x1, 0x1, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0x60, 0x60, 0, 0},
+	{0x23, 0x6, 0x6, 0, 0},
+	{0x24, 0xc, 0xc, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0x1, 0x1, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0, 0, 0, 0},
+	{0x2F, 0x1f, 0x1f, 0, 0},
+	{0x30, 0x15, 0x15, 0, 0},
+	{0x31, 0xf, 0xf, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0, 0, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0, 0, 0, 0},
+	{0x38, 0, 0, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0, 0, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x13, 0x13, 0, 0},
+	{0x3D, 0xf, 0xf, 0, 0},
+	{0x3E, 0x18, 0x18, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x20, 0x20, 0, 0},
+	{0x42, 0x20, 0x20, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x77, 0x77, 0, 0},
+	{0x45, 0x7, 0x7, 0, 0},
+	{0x46, 0x1, 0x1, 0, 0},
+	{0x47, 0x4, 0x4, 0, 0},
+	{0x48, 0xf, 0xf, 0, 0},
+	{0x49, 0x30, 0x30, 0, 0},
+	{0x4A, 0x32, 0x32, 0, 0},
+	{0x4B, 0xd, 0xd, 0, 0},
+	{0x4C, 0xd, 0xd, 0, 0},
+	{0x4D, 0x4, 0x4, 0, 0},
+	{0x4E, 0x6, 0x6, 0, 0},
+	{0x4F, 0x1, 0x1, 0, 0},
+	{0x50, 0x1c, 0x1c, 0, 0},
+	{0x51, 0x2, 0x2, 0, 0},
+	{0x52, 0x2, 0x2, 0, 0},
+	{0x53, 0xf7, 0xf7, 1, 1},
+	{0x54, 0xb4, 0xb4, 0, 0},
+	{0x55, 0xd2, 0xd2, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x4, 0x4, 0, 0},
+	{0x59, 0x96, 0x96, 0, 0},
+	{0x5A, 0x3e, 0x3e, 0, 0},
+	{0x5B, 0x3e, 0x3e, 0, 0},
+	{0x5C, 0x13, 0x13, 0, 0},
+	{0x5D, 0x2, 0x2, 0, 0},
+	{0x5E, 0, 0, 0, 0},
+	{0x5F, 0x7, 0x7, 0, 0},
+	{0x60, 0x7, 0x7, 1, 1},
+	{0x61, 0x8, 0x8, 0, 0},
+	{0x62, 0x3, 0x3, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0x40, 0x40, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0x1, 0x1, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0x60, 0x60, 0, 0},
+	{0x71, 0x66, 0x66, 0, 0},
+	{0x72, 0xc, 0xc, 0, 0},
+	{0x73, 0x66, 0x66, 0, 0},
+	{0x74, 0x8f, 0x8f, 1, 1},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0xcc, 0xcc, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0x66, 0x66, 0, 0},
+	{0x79, 0x66, 0x66, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0xff, 0xff, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0, 0, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0, 0, 0, 0},
+	{0x9A, 0, 0, 0, 0},
+	{0x9B, 0, 0, 0, 0},
+	{0x9C, 0, 0, 0, 0},
+	{0x9D, 0, 0, 0, 0},
+	{0x9E, 0, 0, 0, 0},
+	{0x9F, 0x6, 0x6, 0, 0},
+	{0xA0, 0x66, 0x66, 0, 0},
+	{0xA1, 0x66, 0x66, 0, 0},
+	{0xA2, 0x66, 0x66, 0, 0},
+	{0xA3, 0x66, 0x66, 0, 0},
+	{0xA4, 0x66, 0x66, 0, 0},
+	{0xA5, 0x66, 0x66, 0, 0},
+	{0xA6, 0x66, 0x66, 0, 0},
+	{0xA7, 0x66, 0x66, 0, 0},
+	{0xA8, 0x66, 0x66, 0, 0},
+	{0xA9, 0x66, 0x66, 0, 0},
+	{0xAA, 0x66, 0x66, 0, 0},
+	{0xAB, 0x66, 0x66, 0, 0},
+	{0xAC, 0x66, 0x66, 0, 0},
+	{0xAD, 0x66, 0x66, 0, 0},
+	{0xAE, 0x66, 0x66, 0, 0},
+	{0xAF, 0x66, 0x66, 0, 0},
+	{0xB0, 0x66, 0x66, 0, 0},
+	{0xB1, 0x66, 0x66, 0, 0},
+	{0xB2, 0x66, 0x66, 0, 0},
+	{0xB3, 0xa, 0xa, 0, 0},
+	{0xB4, 0, 0, 0, 0},
+	{0xB5, 0, 0, 0, 0},
+	{0xB6, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_TX_2056_rev6[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0x88, 0x88, 0, 0},
+	{0x22, 0x88, 0x88, 0, 0},
+	{0x23, 0x88, 0x88, 0, 0},
+	{0x24, 0x88, 0x88, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0x3, 0x3, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x3, 0x3, 0, 0},
+	{0x2A, 0x37, 0x37, 0, 0},
+	{0x2B, 0x3, 0x3, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0x1, 0x1, 0, 0},
+	{0x2F, 0x1, 0x1, 0, 0},
+	{0x30, 0, 0, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0x11, 0x11, 0, 0},
+	{0x34, 0xee, 0xee, 1, 1},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x3, 0x3, 0, 0},
+	{0x38, 0x50, 0x50, 1, 1},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0x50, 0x50, 1, 1},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x6e, 0x6e, 0, 0},
+	{0x3D, 0xf0, 0xf0, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x3, 0x3, 0, 0},
+	{0x42, 0x3, 0x3, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x1e, 0x1e, 0, 0},
+	{0x45, 0, 0, 0, 0},
+	{0x46, 0x6e, 0x6e, 0, 0},
+	{0x47, 0xf0, 0xf0, 1, 1},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x2, 0x2, 0, 0},
+	{0x4A, 0xff, 0xff, 1, 1},
+	{0x4B, 0xc, 0xc, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0x38, 0x38, 0, 0},
+	{0x4E, 0x70, 0x70, 1, 1},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0x88, 0x88, 0, 0},
+	{0x51, 0xc, 0xc, 0, 0},
+	{0x52, 0, 0, 0, 0},
+	{0x53, 0x8, 0x8, 0, 0},
+	{0x54, 0x70, 0x70, 1, 1},
+	{0x55, 0x2, 0x2, 0, 0},
+	{0x56, 0xff, 0xff, 1, 1},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x83, 0x83, 0, 0},
+	{0x59, 0x77, 0x77, 1, 1},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x88, 0x88, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x8, 0x8, 0, 0},
+	{0x5F, 0x77, 0x77, 1, 1},
+	{0x60, 0x1, 0x1, 0, 0},
+	{0x61, 0, 0, 0, 0},
+	{0x62, 0x7, 0x7, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0x7, 0x7, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 1, 1},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0xa, 0xa, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0x2, 0x2, 0, 0},
+	{0x72, 0, 0, 0, 0},
+	{0x73, 0, 0, 0, 0},
+	{0x74, 0xe, 0xe, 0, 0},
+	{0x75, 0xe, 0xe, 0, 0},
+	{0x76, 0xe, 0xe, 0, 0},
+	{0x77, 0x13, 0x13, 0, 0},
+	{0x78, 0x13, 0x13, 0, 0},
+	{0x79, 0x1b, 0x1b, 0, 0},
+	{0x7A, 0x1b, 0x1b, 0, 0},
+	{0x7B, 0x55, 0x55, 0, 0},
+	{0x7C, 0x5b, 0x5b, 0, 0},
+	{0x7D, 0x30, 0x30, 1, 1},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0x70, 0x70, 0, 0},
+	{0x94, 0x70, 0x70, 0, 0},
+	{0x95, 0x70, 0x70, 0, 0},
+	{0x96, 0x70, 0x70, 0, 0},
+	{0x97, 0x70, 0x70, 0, 0},
+	{0x98, 0x70, 0x70, 0, 0},
+	{0x99, 0x70, 0x70, 0, 0},
+	{0x9A, 0x70, 0x70, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_RX_2056_rev6[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0x3, 0x3, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x90, 0x90, 0, 0},
+	{0x24, 0x55, 0x55, 0, 0},
+	{0x25, 0x15, 0x15, 0, 0},
+	{0x26, 0x5, 0x5, 0, 0},
+	{0x27, 0x15, 0x15, 0, 0},
+	{0x28, 0x5, 0x5, 0, 0},
+	{0x29, 0x20, 0x20, 0, 0},
+	{0x2A, 0x11, 0x11, 0, 0},
+	{0x2B, 0x90, 0x90, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0x88, 0x88, 0, 0},
+	{0x2E, 0x32, 0x32, 0, 0},
+	{0x2F, 0x77, 0x77, 0, 0},
+	{0x30, 0x17, 0x17, 1, 1},
+	{0x31, 0xff, 0xff, 1, 1},
+	{0x32, 0x20, 0x20, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0x88, 0x88, 0, 0},
+	{0x35, 0x32, 0x32, 0, 0},
+	{0x36, 0x77, 0x77, 0, 0},
+	{0x37, 0x17, 0x17, 1, 1},
+	{0x38, 0xf0, 0xf0, 1, 1},
+	{0x39, 0x20, 0x20, 0, 0},
+	{0x3A, 0x8, 0x8, 0, 0},
+	{0x3B, 0x55, 0x55, 1, 1},
+	{0x3C, 0, 0, 0, 0},
+	{0x3D, 0x88, 0x88, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0x44, 0x44, 0, 0},
+	{0x40, 0x7, 0x7, 1, 1},
+	{0x41, 0x6, 0x6, 0, 0},
+	{0x42, 0x4, 0x4, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x8, 0x8, 0, 0},
+	{0x45, 0x55, 0x55, 1, 1},
+	{0x46, 0, 0, 0, 0},
+	{0x47, 0x11, 0x11, 0, 0},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x44, 0x44, 0, 0},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0x6, 0x6, 0, 0},
+	{0x4C, 0x4, 0x4, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x26, 0x26, 1, 1},
+	{0x50, 0x26, 0x26, 1, 1},
+	{0x51, 0xf, 0xf, 1, 1},
+	{0x52, 0xf, 0xf, 1, 1},
+	{0x53, 0x44, 0x44, 0, 0},
+	{0x54, 0, 0, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0x8, 0x8, 0, 0},
+	{0x57, 0x8, 0x8, 0, 0},
+	{0x58, 0x7, 0x7, 0, 0},
+	{0x59, 0x22, 0x22, 0, 0},
+	{0x5A, 0x22, 0x22, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x4, 0x4, 1, 1},
+	{0x5D, 0x7, 0x7, 0, 0},
+	{0x5E, 0x55, 0x55, 0, 0},
+	{0x5F, 0x23, 0x23, 0, 0},
+	{0x60, 0x41, 0x41, 0, 0},
+	{0x61, 0x1, 0x1, 0, 0},
+	{0x62, 0xa, 0xa, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0xc, 0xc, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0, 0, 0, 0},
+	{0x72, 0x22, 0x22, 0, 0},
+	{0x73, 0x22, 0x22, 0, 0},
+	{0x74, 0, 0, 1, 1},
+	{0x75, 0xa, 0xa, 0, 0},
+	{0x76, 0x1, 0x1, 0, 0},
+	{0x77, 0x22, 0x22, 0, 0},
+	{0x78, 0x30, 0x30, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0x5, 0x5, 1, 1},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0}
+};
+
+radio_regs_t regs_SYN_2056_rev7[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0x1, 0x1, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0x60, 0x60, 0, 0},
+	{0x23, 0x6, 0x6, 0, 0},
+	{0x24, 0xc, 0xc, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0x1, 0x1, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0, 0, 0, 0},
+	{0x2F, 0x1f, 0x1f, 0, 0},
+	{0x30, 0x15, 0x15, 0, 0},
+	{0x31, 0xf, 0xf, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0, 0, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0, 0, 0, 0},
+	{0x38, 0, 0, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0, 0, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x13, 0x13, 0, 0},
+	{0x3D, 0xf, 0xf, 0, 0},
+	{0x3E, 0x18, 0x18, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x20, 0x20, 0, 0},
+	{0x42, 0x20, 0x20, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x77, 0x77, 0, 0},
+	{0x45, 0x7, 0x7, 0, 0},
+	{0x46, 0x1, 0x1, 0, 0},
+	{0x47, 0x4, 0x4, 0, 0},
+	{0x48, 0xf, 0xf, 0, 0},
+	{0x49, 0x30, 0x30, 0, 0},
+	{0x4A, 0x32, 0x32, 0, 0},
+	{0x4B, 0xd, 0xd, 0, 0},
+	{0x4C, 0xd, 0xd, 0, 0},
+	{0x4D, 0x4, 0x4, 0, 0},
+	{0x4E, 0x6, 0x6, 0, 0},
+	{0x4F, 0x1, 0x1, 0, 0},
+	{0x50, 0x1c, 0x1c, 0, 0},
+	{0x51, 0x2, 0x2, 0, 0},
+	{0x52, 0x2, 0x2, 0, 0},
+	{0x53, 0xf7, 0xf7, 1, 1},
+	{0x54, 0xb4, 0xb4, 0, 0},
+	{0x55, 0xd2, 0xd2, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x4, 0x4, 0, 0},
+	{0x59, 0x96, 0x96, 0, 0},
+	{0x5A, 0x3e, 0x3e, 0, 0},
+	{0x5B, 0x3e, 0x3e, 0, 0},
+	{0x5C, 0x13, 0x13, 0, 0},
+	{0x5D, 0x2, 0x2, 0, 0},
+	{0x5E, 0, 0, 0, 0},
+	{0x5F, 0x7, 0x7, 0, 0},
+	{0x60, 0x7, 0x7, 1, 1},
+	{0x61, 0x8, 0x8, 0, 0},
+	{0x62, 0x3, 0x3, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0x40, 0x40, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0x1, 0x1, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0x60, 0x60, 0, 0},
+	{0x71, 0x66, 0x66, 0, 0},
+	{0x72, 0xc, 0xc, 0, 0},
+	{0x73, 0x66, 0x66, 0, 0},
+	{0x74, 0x8f, 0x8f, 1, 1},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0xcc, 0xcc, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0x66, 0x66, 0, 0},
+	{0x79, 0x66, 0x66, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0xff, 0xff, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0, 0, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0, 0, 0, 0},
+	{0x9A, 0, 0, 0, 0},
+	{0x9B, 0, 0, 0, 0},
+	{0x9C, 0, 0, 0, 0},
+	{0x9D, 0, 0, 0, 0},
+	{0x9E, 0, 0, 0, 0},
+	{0x9F, 0x6, 0x6, 0, 0},
+	{0xA0, 0x66, 0x66, 0, 0},
+	{0xA1, 0x66, 0x66, 0, 0},
+	{0xA2, 0x66, 0x66, 0, 0},
+	{0xA3, 0x66, 0x66, 0, 0},
+	{0xA4, 0x66, 0x66, 0, 0},
+	{0xA5, 0x66, 0x66, 0, 0},
+	{0xA6, 0x66, 0x66, 0, 0},
+	{0xA7, 0x66, 0x66, 0, 0},
+	{0xA8, 0x66, 0x66, 0, 0},
+	{0xA9, 0x66, 0x66, 0, 0},
+	{0xAA, 0x66, 0x66, 0, 0},
+	{0xAB, 0x66, 0x66, 0, 0},
+	{0xAC, 0x66, 0x66, 0, 0},
+	{0xAD, 0x66, 0x66, 0, 0},
+	{0xAE, 0x66, 0x66, 0, 0},
+	{0xAF, 0x66, 0x66, 0, 0},
+	{0xB0, 0x66, 0x66, 0, 0},
+	{0xB1, 0x66, 0x66, 0, 0},
+	{0xB2, 0x66, 0x66, 0, 0},
+	{0xB3, 0xa, 0xa, 0, 0},
+	{0xB4, 0, 0, 0, 0},
+	{0xB5, 0, 0, 0, 0},
+	{0xB6, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_TX_2056_rev7[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0x88, 0x88, 0, 0},
+	{0x22, 0x88, 0x88, 0, 0},
+	{0x23, 0x88, 0x88, 0, 0},
+	{0x24, 0x88, 0x88, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0x3, 0x3, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x3, 0x3, 0, 0},
+	{0x2A, 0x37, 0x37, 0, 0},
+	{0x2B, 0x3, 0x3, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0x1, 0x1, 0, 0},
+	{0x2F, 0x1, 0x1, 0, 0},
+	{0x30, 0, 0, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0x11, 0x11, 0, 0},
+	{0x34, 0xee, 0xee, 1, 1},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x3, 0x3, 0, 0},
+	{0x38, 0x50, 0x50, 1, 1},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0x50, 0x50, 1, 1},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x6e, 0x6e, 0, 0},
+	{0x3D, 0xf0, 0xf0, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x3, 0x3, 0, 0},
+	{0x42, 0x3, 0x3, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x1e, 0x1e, 0, 0},
+	{0x45, 0, 0, 0, 0},
+	{0x46, 0x6e, 0x6e, 0, 0},
+	{0x47, 0xf0, 0xf0, 1, 1},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x2, 0x2, 0, 0},
+	{0x4A, 0xff, 0xff, 1, 1},
+	{0x4B, 0xc, 0xc, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0x38, 0x38, 0, 0},
+	{0x4E, 0x70, 0x70, 1, 1},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0x88, 0x88, 0, 0},
+	{0x51, 0xc, 0xc, 0, 0},
+	{0x52, 0, 0, 0, 0},
+	{0x53, 0x8, 0x8, 0, 0},
+	{0x54, 0x70, 0x70, 1, 1},
+	{0x55, 0x2, 0x2, 0, 0},
+	{0x56, 0xff, 0xff, 1, 1},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x83, 0x83, 0, 0},
+	{0x59, 0x77, 0x77, 1, 1},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x88, 0x88, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x8, 0x8, 0, 0},
+	{0x5F, 0x77, 0x77, 1, 1},
+	{0x60, 0x1, 0x1, 0, 0},
+	{0x61, 0, 0, 0, 0},
+	{0x62, 0x7, 0x7, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0x7, 0x7, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 1, 1},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0xa, 0xa, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0x2, 0x2, 0, 0},
+	{0x72, 0, 0, 0, 0},
+	{0x73, 0, 0, 0, 0},
+	{0x74, 0xe, 0xe, 0, 0},
+	{0x75, 0xe, 0xe, 0, 0},
+	{0x76, 0xe, 0xe, 0, 0},
+	{0x77, 0x13, 0x13, 0, 0},
+	{0x78, 0x13, 0x13, 0, 0},
+	{0x79, 0x1b, 0x1b, 0, 0},
+	{0x7A, 0x1b, 0x1b, 0, 0},
+	{0x7B, 0x55, 0x55, 0, 0},
+	{0x7C, 0x5b, 0x5b, 0, 0},
+	{0x7D, 0x30, 0x30, 1, 1},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0x70, 0x70, 0, 0},
+	{0x94, 0x70, 0x70, 0, 0},
+	{0x95, 0x71, 0x71, 1, 1},
+	{0x96, 0x71, 0x71, 1, 1},
+	{0x97, 0x72, 0x72, 1, 1},
+	{0x98, 0x73, 0x73, 1, 1},
+	{0x99, 0x74, 0x74, 1, 1},
+	{0x9A, 0x75, 0x75, 1, 1},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_RX_2056_rev7[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0x3, 0x3, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x90, 0x90, 0, 0},
+	{0x24, 0x55, 0x55, 0, 0},
+	{0x25, 0x15, 0x15, 0, 0},
+	{0x26, 0x5, 0x5, 0, 0},
+	{0x27, 0x15, 0x15, 0, 0},
+	{0x28, 0x5, 0x5, 0, 0},
+	{0x29, 0x20, 0x20, 0, 0},
+	{0x2A, 0x11, 0x11, 0, 0},
+	{0x2B, 0x90, 0x90, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0x88, 0x88, 0, 0},
+	{0x2E, 0x32, 0x32, 0, 0},
+	{0x2F, 0x77, 0x77, 0, 0},
+	{0x30, 0x17, 0x17, 1, 1},
+	{0x31, 0xff, 0xff, 1, 1},
+	{0x32, 0x20, 0x20, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0x88, 0x88, 0, 0},
+	{0x35, 0x32, 0x32, 0, 0},
+	{0x36, 0x77, 0x77, 0, 0},
+	{0x37, 0x17, 0x17, 1, 1},
+	{0x38, 0xf0, 0xf0, 1, 1},
+	{0x39, 0x20, 0x20, 0, 0},
+	{0x3A, 0x8, 0x8, 0, 0},
+	{0x3B, 0x55, 0x55, 1, 1},
+	{0x3C, 0, 0, 0, 0},
+	{0x3D, 0x88, 0x88, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 1, 1},
+	{0x40, 0x7, 0x7, 1, 1},
+	{0x41, 0x6, 0x6, 0, 0},
+	{0x42, 0x4, 0x4, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x8, 0x8, 0, 0},
+	{0x45, 0x55, 0x55, 1, 1},
+	{0x46, 0, 0, 0, 0},
+	{0x47, 0x11, 0x11, 0, 0},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0, 0, 1, 1},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0x6, 0x6, 0, 0},
+	{0x4C, 0x4, 0x4, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x26, 0x26, 1, 1},
+	{0x50, 0x26, 0x26, 1, 1},
+	{0x51, 0xf, 0xf, 1, 1},
+	{0x52, 0xf, 0xf, 1, 1},
+	{0x53, 0x44, 0x44, 0, 0},
+	{0x54, 0, 0, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0x8, 0x8, 0, 0},
+	{0x57, 0x8, 0x8, 0, 0},
+	{0x58, 0x7, 0x7, 0, 0},
+	{0x59, 0x22, 0x22, 0, 0},
+	{0x5A, 0x22, 0x22, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x4, 0x4, 1, 1},
+	{0x5D, 0x7, 0x7, 0, 0},
+	{0x5E, 0x55, 0x55, 0, 0},
+	{0x5F, 0x23, 0x23, 0, 0},
+	{0x60, 0x41, 0x41, 0, 0},
+	{0x61, 0x1, 0x1, 0, 0},
+	{0x62, 0xa, 0xa, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0xc, 0xc, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0, 0, 0, 0},
+	{0x72, 0x22, 0x22, 0, 0},
+	{0x73, 0x22, 0x22, 0, 0},
+	{0x74, 0, 0, 1, 1},
+	{0x75, 0xa, 0xa, 0, 0},
+	{0x76, 0x1, 0x1, 0, 0},
+	{0x77, 0x22, 0x22, 0, 0},
+	{0x78, 0x30, 0x30, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_SYN_2056_rev8[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0x1, 0x1, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0x60, 0x60, 0, 0},
+	{0x23, 0x6, 0x6, 0, 0},
+	{0x24, 0xc, 0xc, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0x1, 0x1, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0, 0, 0, 0},
+	{0x2F, 0x1f, 0x1f, 0, 0},
+	{0x30, 0x15, 0x15, 0, 0},
+	{0x31, 0xf, 0xf, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0, 0, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0, 0, 0, 0},
+	{0x38, 0, 0, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0, 0, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x13, 0x13, 0, 0},
+	{0x3D, 0xf, 0xf, 0, 0},
+	{0x3E, 0x18, 0x18, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x20, 0x20, 0, 0},
+	{0x42, 0x20, 0x20, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x77, 0x77, 0, 0},
+	{0x45, 0x7, 0x7, 0, 0},
+	{0x46, 0x1, 0x1, 0, 0},
+	{0x47, 0x4, 0x4, 0, 0},
+	{0x48, 0xf, 0xf, 0, 0},
+	{0x49, 0x30, 0x30, 0, 0},
+	{0x4A, 0x32, 0x32, 0, 0},
+	{0x4B, 0xd, 0xd, 0, 0},
+	{0x4C, 0xd, 0xd, 0, 0},
+	{0x4D, 0x4, 0x4, 0, 0},
+	{0x4E, 0x6, 0x6, 0, 0},
+	{0x4F, 0x1, 0x1, 0, 0},
+	{0x50, 0x1c, 0x1c, 0, 0},
+	{0x51, 0x2, 0x2, 0, 0},
+	{0x52, 0x2, 0x2, 0, 0},
+	{0x53, 0xf7, 0xf7, 1, 1},
+	{0x54, 0xb4, 0xb4, 0, 0},
+	{0x55, 0xd2, 0xd2, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x4, 0x4, 0, 0},
+	{0x59, 0x96, 0x96, 0, 0},
+	{0x5A, 0x3e, 0x3e, 0, 0},
+	{0x5B, 0x3e, 0x3e, 0, 0},
+	{0x5C, 0x13, 0x13, 0, 0},
+	{0x5D, 0x2, 0x2, 0, 0},
+	{0x5E, 0, 0, 0, 0},
+	{0x5F, 0x7, 0x7, 0, 0},
+	{0x60, 0x7, 0x7, 1, 1},
+	{0x61, 0x8, 0x8, 0, 0},
+	{0x62, 0x3, 0x3, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0x40, 0x40, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0x1, 0x1, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0x60, 0x60, 0, 0},
+	{0x71, 0x66, 0x66, 0, 0},
+	{0x72, 0xc, 0xc, 0, 0},
+	{0x73, 0x66, 0x66, 0, 0},
+	{0x74, 0x8f, 0x8f, 1, 1},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0xcc, 0xcc, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0x66, 0x66, 0, 0},
+	{0x79, 0x66, 0x66, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0xff, 0xff, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0, 0, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0, 0, 0, 0},
+	{0x9A, 0, 0, 0, 0},
+	{0x9B, 0, 0, 0, 0},
+	{0x9C, 0, 0, 0, 0},
+	{0x9D, 0, 0, 0, 0},
+	{0x9E, 0, 0, 0, 0},
+	{0x9F, 0x6, 0x6, 0, 0},
+	{0xA0, 0x66, 0x66, 0, 0},
+	{0xA1, 0x66, 0x66, 0, 0},
+	{0xA2, 0x66, 0x66, 0, 0},
+	{0xA3, 0x66, 0x66, 0, 0},
+	{0xA4, 0x66, 0x66, 0, 0},
+	{0xA5, 0x66, 0x66, 0, 0},
+	{0xA6, 0x66, 0x66, 0, 0},
+	{0xA7, 0x66, 0x66, 0, 0},
+	{0xA8, 0x66, 0x66, 0, 0},
+	{0xA9, 0x66, 0x66, 0, 0},
+	{0xAA, 0x66, 0x66, 0, 0},
+	{0xAB, 0x66, 0x66, 0, 0},
+	{0xAC, 0x66, 0x66, 0, 0},
+	{0xAD, 0x66, 0x66, 0, 0},
+	{0xAE, 0x66, 0x66, 0, 0},
+	{0xAF, 0x66, 0x66, 0, 0},
+	{0xB0, 0x66, 0x66, 0, 0},
+	{0xB1, 0x66, 0x66, 0, 0},
+	{0xB2, 0x66, 0x66, 0, 0},
+	{0xB3, 0xa, 0xa, 0, 0},
+	{0xB4, 0, 0, 0, 0},
+	{0xB5, 0, 0, 0, 0},
+	{0xB6, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_TX_2056_rev8[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0x88, 0x88, 0, 0},
+	{0x22, 0x88, 0x88, 0, 0},
+	{0x23, 0x88, 0x88, 0, 0},
+	{0x24, 0x88, 0x88, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0x3, 0x3, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x3, 0x3, 0, 0},
+	{0x2A, 0x37, 0x37, 0, 0},
+	{0x2B, 0x3, 0x3, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0x1, 0x1, 0, 0},
+	{0x2F, 0x1, 0x1, 0, 0},
+	{0x30, 0, 0, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0x11, 0x11, 0, 0},
+	{0x34, 0xee, 0xee, 1, 1},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x3, 0x3, 0, 0},
+	{0x38, 0x50, 0x50, 1, 1},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0x50, 0x50, 1, 1},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x6e, 0x6e, 0, 0},
+	{0x3D, 0xf0, 0xf0, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x3, 0x3, 0, 0},
+	{0x42, 0x3, 0x3, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x1e, 0x1e, 0, 0},
+	{0x45, 0, 0, 0, 0},
+	{0x46, 0x6e, 0x6e, 0, 0},
+	{0x47, 0xf0, 0xf0, 1, 1},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x2, 0x2, 0, 0},
+	{0x4A, 0xff, 0xff, 1, 1},
+	{0x4B, 0xc, 0xc, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0x38, 0x38, 0, 0},
+	{0x4E, 0x70, 0x70, 1, 1},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0x88, 0x88, 0, 0},
+	{0x51, 0xc, 0xc, 0, 0},
+	{0x52, 0, 0, 0, 0},
+	{0x53, 0x8, 0x8, 0, 0},
+	{0x54, 0x70, 0x70, 1, 1},
+	{0x55, 0x2, 0x2, 0, 0},
+	{0x56, 0xff, 0xff, 1, 1},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x83, 0x83, 0, 0},
+	{0x59, 0x77, 0x77, 1, 1},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x88, 0x88, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x8, 0x8, 0, 0},
+	{0x5F, 0x77, 0x77, 1, 1},
+	{0x60, 0x1, 0x1, 0, 0},
+	{0x61, 0, 0, 0, 0},
+	{0x62, 0x7, 0x7, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0x7, 0x7, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 1, 1},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0xa, 0xa, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0x2, 0x2, 0, 0},
+	{0x72, 0, 0, 0, 0},
+	{0x73, 0, 0, 0, 0},
+	{0x74, 0xe, 0xe, 0, 0},
+	{0x75, 0xe, 0xe, 0, 0},
+	{0x76, 0xe, 0xe, 0, 0},
+	{0x77, 0x13, 0x13, 0, 0},
+	{0x78, 0x13, 0x13, 0, 0},
+	{0x79, 0x1b, 0x1b, 0, 0},
+	{0x7A, 0x1b, 0x1b, 0, 0},
+	{0x7B, 0x55, 0x55, 0, 0},
+	{0x7C, 0x5b, 0x5b, 0, 0},
+	{0x7D, 0x30, 0x30, 1, 1},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0x70, 0x70, 0, 0},
+	{0x94, 0x70, 0x70, 0, 0},
+	{0x95, 0x70, 0x70, 0, 0},
+	{0x96, 0x70, 0x70, 0, 0},
+	{0x97, 0x70, 0x70, 0, 0},
+	{0x98, 0x70, 0x70, 0, 0},
+	{0x99, 0x70, 0x70, 0, 0},
+	{0x9A, 0x70, 0x70, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_RX_2056_rev8[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0x3, 0x3, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x90, 0x90, 0, 0},
+	{0x24, 0x55, 0x55, 0, 0},
+	{0x25, 0x15, 0x15, 0, 0},
+	{0x26, 0x5, 0x5, 0, 0},
+	{0x27, 0x15, 0x15, 0, 0},
+	{0x28, 0x5, 0x5, 0, 0},
+	{0x29, 0x20, 0x20, 0, 0},
+	{0x2A, 0x11, 0x11, 0, 0},
+	{0x2B, 0x90, 0x90, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0x88, 0x88, 0, 0},
+	{0x2E, 0x32, 0x32, 0, 0},
+	{0x2F, 0x77, 0x77, 0, 0},
+	{0x30, 0x17, 0x17, 1, 1},
+	{0x31, 0xff, 0xff, 1, 1},
+	{0x32, 0x20, 0x20, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0x88, 0x88, 0, 0},
+	{0x35, 0x32, 0x32, 0, 0},
+	{0x36, 0x77, 0x77, 0, 0},
+	{0x37, 0x17, 0x17, 1, 1},
+	{0x38, 0xf0, 0xf0, 1, 1},
+	{0x39, 0x20, 0x20, 0, 0},
+	{0x3A, 0x8, 0x8, 0, 0},
+	{0x3B, 0x55, 0x55, 1, 1},
+	{0x3C, 0, 0, 0, 0},
+	{0x3D, 0x88, 0x88, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0x44, 0x44, 0, 0},
+	{0x40, 0x7, 0x7, 1, 1},
+	{0x41, 0x6, 0x6, 0, 0},
+	{0x42, 0x4, 0x4, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x8, 0x8, 0, 0},
+	{0x45, 0x55, 0x55, 1, 1},
+	{0x46, 0, 0, 0, 0},
+	{0x47, 0x11, 0x11, 0, 0},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x44, 0x44, 0, 0},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0x6, 0x6, 0, 0},
+	{0x4C, 0x4, 0x4, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x26, 0x26, 1, 1},
+	{0x50, 0x26, 0x26, 1, 1},
+	{0x51, 0xf, 0xf, 1, 1},
+	{0x52, 0xf, 0xf, 1, 1},
+	{0x53, 0x44, 0x44, 0, 0},
+	{0x54, 0, 0, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0x8, 0x8, 0, 0},
+	{0x57, 0x8, 0x8, 0, 0},
+	{0x58, 0x7, 0x7, 0, 0},
+	{0x59, 0x22, 0x22, 0, 0},
+	{0x5A, 0x22, 0x22, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x4, 0x4, 1, 1},
+	{0x5D, 0x7, 0x7, 0, 0},
+	{0x5E, 0x55, 0x55, 0, 0},
+	{0x5F, 0x23, 0x23, 0, 0},
+	{0x60, 0x41, 0x41, 0, 0},
+	{0x61, 0x1, 0x1, 0, 0},
+	{0x62, 0xa, 0xa, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0xc, 0xc, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0, 0, 0, 0},
+	{0x72, 0x22, 0x22, 0, 0},
+	{0x73, 0x22, 0x22, 0, 0},
+	{0x74, 0, 0, 1, 1},
+	{0x75, 0xa, 0xa, 0, 0},
+	{0x76, 0x1, 0x1, 0, 0},
+	{0x77, 0x22, 0x22, 0, 0},
+	{0x78, 0x30, 0x30, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0x5, 0x5, 1, 1},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_SYN_2056_rev11[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0x1, 0x1, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0x60, 0x60, 0, 0},
+	{0x23, 0x6, 0x6, 0, 0},
+	{0x24, 0xc, 0xc, 0, 0},
+	{0x25, 0, 0, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0, 0, 0, 0},
+	{0x28, 0x1, 0x1, 0, 0},
+	{0x29, 0, 0, 0, 0},
+	{0x2A, 0, 0, 0, 0},
+	{0x2B, 0, 0, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0, 0, 0, 0},
+	{0x2F, 0x1f, 0x1f, 0, 0},
+	{0x30, 0x15, 0x15, 0, 0},
+	{0x31, 0xf, 0xf, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0, 0, 0, 0},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0, 0, 0, 0},
+	{0x38, 0, 0, 0, 0},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0, 0, 0, 0},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x13, 0x13, 0, 0},
+	{0x3D, 0xf, 0xf, 0, 0},
+	{0x3E, 0x18, 0x18, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x20, 0x20, 0, 0},
+	{0x42, 0x20, 0x20, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x77, 0x77, 0, 0},
+	{0x45, 0x7, 0x7, 0, 0},
+	{0x46, 0x1, 0x1, 0, 0},
+	{0x47, 0x6, 0x6, 1, 1},
+	{0x48, 0xf, 0xf, 0, 0},
+	{0x49, 0x3f, 0x3f, 1, 1},
+	{0x4A, 0x32, 0x32, 0, 0},
+	{0x4B, 0x6, 0x6, 1, 1},
+	{0x4C, 0x6, 0x6, 1, 1},
+	{0x4D, 0x4, 0x4, 0, 0},
+	{0x4E, 0x2b, 0x2b, 1, 1},
+	{0x4F, 0x1, 0x1, 0, 0},
+	{0x50, 0x1c, 0x1c, 0, 0},
+	{0x51, 0x2, 0x2, 0, 0},
+	{0x52, 0x2, 0x2, 0, 0},
+	{0x53, 0xf7, 0xf7, 1, 1},
+	{0x54, 0xb4, 0xb4, 0, 0},
+	{0x55, 0xd2, 0xd2, 0, 0},
+	{0x56, 0, 0, 0, 0},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x4, 0x4, 0, 0},
+	{0x59, 0x96, 0x96, 0, 0},
+	{0x5A, 0x3e, 0x3e, 0, 0},
+	{0x5B, 0x3e, 0x3e, 0, 0},
+	{0x5C, 0x13, 0x13, 0, 0},
+	{0x5D, 0x2, 0x2, 0, 0},
+	{0x5E, 0, 0, 0, 0},
+	{0x5F, 0x7, 0x7, 0, 0},
+	{0x60, 0x7, 0x7, 1, 1},
+	{0x61, 0x8, 0x8, 0, 0},
+	{0x62, 0x3, 0x3, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0x40, 0x40, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0x1, 0x1, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0x60, 0x60, 0, 0},
+	{0x71, 0x66, 0x66, 0, 0},
+	{0x72, 0xc, 0xc, 0, 0},
+	{0x73, 0x66, 0x66, 0, 0},
+	{0x74, 0x8f, 0x8f, 1, 1},
+	{0x75, 0, 0, 0, 0},
+	{0x76, 0xcc, 0xcc, 0, 0},
+	{0x77, 0x1, 0x1, 0, 0},
+	{0x78, 0x66, 0x66, 0, 0},
+	{0x79, 0x66, 0x66, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0, 0, 0, 0},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0xff, 0xff, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0x95, 0, 0, 0, 0},
+	{0x96, 0, 0, 0, 0},
+	{0x97, 0, 0, 0, 0},
+	{0x98, 0, 0, 0, 0},
+	{0x99, 0, 0, 0, 0},
+	{0x9A, 0, 0, 0, 0},
+	{0x9B, 0, 0, 0, 0},
+	{0x9C, 0, 0, 0, 0},
+	{0x9D, 0, 0, 0, 0},
+	{0x9E, 0, 0, 0, 0},
+	{0x9F, 0x6, 0x6, 0, 0},
+	{0xA0, 0x66, 0x66, 0, 0},
+	{0xA1, 0x66, 0x66, 0, 0},
+	{0xA2, 0x66, 0x66, 0, 0},
+	{0xA3, 0x66, 0x66, 0, 0},
+	{0xA4, 0x66, 0x66, 0, 0},
+	{0xA5, 0x66, 0x66, 0, 0},
+	{0xA6, 0x66, 0x66, 0, 0},
+	{0xA7, 0x66, 0x66, 0, 0},
+	{0xA8, 0x66, 0x66, 0, 0},
+	{0xA9, 0x66, 0x66, 0, 0},
+	{0xAA, 0x66, 0x66, 0, 0},
+	{0xAB, 0x66, 0x66, 0, 0},
+	{0xAC, 0x66, 0x66, 0, 0},
+	{0xAD, 0x66, 0x66, 0, 0},
+	{0xAE, 0x66, 0x66, 0, 0},
+	{0xAF, 0x66, 0x66, 0, 0},
+	{0xB0, 0x66, 0x66, 0, 0},
+	{0xB1, 0x66, 0x66, 0, 0},
+	{0xB2, 0x66, 0x66, 0, 0},
+	{0xB3, 0xa, 0xa, 0, 0},
+	{0xB4, 0, 0, 0, 0},
+	{0xB5, 0, 0, 0, 0},
+	{0xB6, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_TX_2056_rev11[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0, 0, 0, 0},
+	{0x21, 0x88, 0x88, 0, 0},
+	{0x22, 0x88, 0x88, 0, 0},
+	{0x23, 0x88, 0x88, 0, 0},
+	{0x24, 0x88, 0x88, 0, 0},
+	{0x25, 0xc, 0xc, 0, 0},
+	{0x26, 0, 0, 0, 0},
+	{0x27, 0x3, 0x3, 0, 0},
+	{0x28, 0, 0, 0, 0},
+	{0x29, 0x3, 0x3, 0, 0},
+	{0x2A, 0x37, 0x37, 0, 0},
+	{0x2B, 0x3, 0x3, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0, 0, 0, 0},
+	{0x2E, 0x1, 0x1, 0, 0},
+	{0x2F, 0x1, 0x1, 0, 0},
+	{0x30, 0, 0, 0, 0},
+	{0x31, 0, 0, 0, 0},
+	{0x32, 0, 0, 0, 0},
+	{0x33, 0x11, 0x11, 0, 0},
+	{0x34, 0xee, 0xee, 1, 1},
+	{0x35, 0, 0, 0, 0},
+	{0x36, 0, 0, 0, 0},
+	{0x37, 0x3, 0x3, 0, 0},
+	{0x38, 0x50, 0x50, 1, 1},
+	{0x39, 0, 0, 0, 0},
+	{0x3A, 0x50, 0x50, 1, 1},
+	{0x3B, 0, 0, 0, 0},
+	{0x3C, 0x6e, 0x6e, 0, 0},
+	{0x3D, 0xf0, 0xf0, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0, 0, 0, 0},
+	{0x40, 0, 0, 0, 0},
+	{0x41, 0x3, 0x3, 0, 0},
+	{0x42, 0x3, 0x3, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x1e, 0x1e, 0, 0},
+	{0x45, 0, 0, 0, 0},
+	{0x46, 0x6e, 0x6e, 0, 0},
+	{0x47, 0xf0, 0xf0, 1, 1},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x2, 0x2, 0, 0},
+	{0x4A, 0xff, 0xff, 1, 1},
+	{0x4B, 0xc, 0xc, 0, 0},
+	{0x4C, 0, 0, 0, 0},
+	{0x4D, 0x38, 0x38, 0, 0},
+	{0x4E, 0x70, 0x70, 1, 1},
+	{0x4F, 0x2, 0x2, 0, 0},
+	{0x50, 0x88, 0x88, 0, 0},
+	{0x51, 0xc, 0xc, 0, 0},
+	{0x52, 0, 0, 0, 0},
+	{0x53, 0x8, 0x8, 0, 0},
+	{0x54, 0x70, 0x70, 1, 1},
+	{0x55, 0x2, 0x2, 0, 0},
+	{0x56, 0xff, 0xff, 1, 1},
+	{0x57, 0, 0, 0, 0},
+	{0x58, 0x83, 0x83, 0, 0},
+	{0x59, 0x77, 0x77, 1, 1},
+	{0x5A, 0, 0, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x88, 0x88, 0, 0},
+	{0x5D, 0, 0, 0, 0},
+	{0x5E, 0x8, 0x8, 0, 0},
+	{0x5F, 0x77, 0x77, 1, 1},
+	{0x60, 0x1, 0x1, 0, 0},
+	{0x61, 0, 0, 0, 0},
+	{0x62, 0x7, 0x7, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0x7, 0x7, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 1, 1},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0xa, 0xa, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0, 0, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0x2, 0x2, 0, 0},
+	{0x72, 0, 0, 0, 0},
+	{0x73, 0, 0, 0, 0},
+	{0x74, 0xe, 0xe, 0, 0},
+	{0x75, 0xe, 0xe, 0, 0},
+	{0x76, 0xe, 0xe, 0, 0},
+	{0x77, 0x13, 0x13, 0, 0},
+	{0x78, 0x13, 0x13, 0, 0},
+	{0x79, 0x1b, 0x1b, 0, 0},
+	{0x7A, 0x1b, 0x1b, 0, 0},
+	{0x7B, 0x55, 0x55, 0, 0},
+	{0x7C, 0x5b, 0x5b, 0, 0},
+	{0x7D, 0x30, 0x30, 1, 1},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0x70, 0x70, 0, 0},
+	{0x94, 0x70, 0x70, 0, 0},
+	{0x95, 0x70, 0x70, 0, 0},
+	{0x96, 0x70, 0x70, 0, 0},
+	{0x97, 0x70, 0x70, 0, 0},
+	{0x98, 0x70, 0x70, 0, 0},
+	{0x99, 0x70, 0x70, 0, 0},
+	{0x9A, 0x70, 0x70, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_regs_t regs_RX_2056_rev11[] = {
+	{0x02, 0, 0, 0, 0},
+	{0x03, 0, 0, 0, 0},
+	{0x04, 0, 0, 0, 0},
+	{0x05, 0, 0, 0, 0},
+	{0x06, 0, 0, 0, 0},
+	{0x07, 0, 0, 0, 0},
+	{0x08, 0, 0, 0, 0},
+	{0x09, 0, 0, 0, 0},
+	{0x0A, 0, 0, 0, 0},
+	{0x0B, 0, 0, 0, 0},
+	{0x0C, 0, 0, 0, 0},
+	{0x0D, 0, 0, 0, 0},
+	{0x0E, 0, 0, 0, 0},
+	{0x0F, 0, 0, 0, 0},
+	{0x10, 0, 0, 0, 0},
+	{0x11, 0, 0, 0, 0},
+	{0x12, 0, 0, 0, 0},
+	{0x13, 0, 0, 0, 0},
+	{0x14, 0, 0, 0, 0},
+	{0x15, 0, 0, 0, 0},
+	{0x16, 0, 0, 0, 0},
+	{0x17, 0, 0, 0, 0},
+	{0x18, 0, 0, 0, 0},
+	{0x19, 0, 0, 0, 0},
+	{0x1A, 0, 0, 0, 0},
+	{0x1B, 0, 0, 0, 0},
+	{0x1C, 0, 0, 0, 0},
+	{0x1D, 0, 0, 0, 0},
+	{0x1E, 0, 0, 0, 0},
+	{0x1F, 0, 0, 0, 0},
+	{0x20, 0x3, 0x3, 0, 0},
+	{0x21, 0, 0, 0, 0},
+	{0x22, 0, 0, 0, 0},
+	{0x23, 0x90, 0x90, 0, 0},
+	{0x24, 0x55, 0x55, 0, 0},
+	{0x25, 0x15, 0x15, 0, 0},
+	{0x26, 0x5, 0x5, 0, 0},
+	{0x27, 0x15, 0x15, 0, 0},
+	{0x28, 0x5, 0x5, 0, 0},
+	{0x29, 0x20, 0x20, 0, 0},
+	{0x2A, 0x11, 0x11, 0, 0},
+	{0x2B, 0x90, 0x90, 0, 0},
+	{0x2C, 0, 0, 0, 0},
+	{0x2D, 0x88, 0x88, 0, 0},
+	{0x2E, 0x32, 0x32, 0, 0},
+	{0x2F, 0x77, 0x77, 0, 0},
+	{0x30, 0x17, 0x17, 1, 1},
+	{0x31, 0xff, 0xff, 1, 1},
+	{0x32, 0x20, 0x20, 0, 0},
+	{0x33, 0, 0, 0, 0},
+	{0x34, 0x88, 0x88, 0, 0},
+	{0x35, 0x32, 0x32, 0, 0},
+	{0x36, 0x77, 0x77, 0, 0},
+	{0x37, 0x17, 0x17, 1, 1},
+	{0x38, 0xf0, 0xf0, 1, 1},
+	{0x39, 0x20, 0x20, 0, 0},
+	{0x3A, 0x8, 0x8, 0, 0},
+	{0x3B, 0x55, 0x55, 1, 1},
+	{0x3C, 0, 0, 0, 0},
+	{0x3D, 0x88, 0x88, 1, 1},
+	{0x3E, 0, 0, 0, 0},
+	{0x3F, 0x44, 0x44, 0, 0},
+	{0x40, 0x7, 0x7, 1, 1},
+	{0x41, 0x6, 0x6, 0, 0},
+	{0x42, 0x4, 0x4, 0, 0},
+	{0x43, 0, 0, 0, 0},
+	{0x44, 0x8, 0x8, 0, 0},
+	{0x45, 0x55, 0x55, 1, 1},
+	{0x46, 0, 0, 0, 0},
+	{0x47, 0x11, 0x11, 0, 0},
+	{0x48, 0, 0, 0, 0},
+	{0x49, 0x44, 0x44, 0, 0},
+	{0x4A, 0x7, 0x7, 0, 0},
+	{0x4B, 0x6, 0x6, 0, 0},
+	{0x4C, 0x4, 0x4, 0, 0},
+	{0x4D, 0, 0, 0, 0},
+	{0x4E, 0, 0, 0, 0},
+	{0x4F, 0x26, 0x26, 1, 1},
+	{0x50, 0x26, 0x26, 1, 1},
+	{0x51, 0xf, 0xf, 1, 1},
+	{0x52, 0xf, 0xf, 1, 1},
+	{0x53, 0x44, 0x44, 0, 0},
+	{0x54, 0, 0, 0, 0},
+	{0x55, 0, 0, 0, 0},
+	{0x56, 0x8, 0x8, 0, 0},
+	{0x57, 0x8, 0x8, 0, 0},
+	{0x58, 0x7, 0x7, 0, 0},
+	{0x59, 0x22, 0x22, 0, 0},
+	{0x5A, 0x22, 0x22, 0, 0},
+	{0x5B, 0x2, 0x2, 0, 0},
+	{0x5C, 0x4, 0x4, 1, 1},
+	{0x5D, 0x7, 0x7, 0, 0},
+	{0x5E, 0x55, 0x55, 0, 0},
+	{0x5F, 0x23, 0x23, 0, 0},
+	{0x60, 0x41, 0x41, 0, 0},
+	{0x61, 0x1, 0x1, 0, 0},
+	{0x62, 0xa, 0xa, 0, 0},
+	{0x63, 0, 0, 0, 0},
+	{0x64, 0, 0, 0, 0},
+	{0x65, 0, 0, 0, 0},
+	{0x66, 0, 0, 0, 0},
+	{0x67, 0, 0, 0, 0},
+	{0x68, 0, 0, 0, 0},
+	{0x69, 0, 0, 0, 0},
+	{0x6A, 0, 0, 0, 0},
+	{0x6B, 0xc, 0xc, 0, 0},
+	{0x6C, 0, 0, 0, 0},
+	{0x6D, 0, 0, 0, 0},
+	{0x6E, 0, 0, 0, 0},
+	{0x6F, 0, 0, 0, 0},
+	{0x70, 0, 0, 0, 0},
+	{0x71, 0, 0, 0, 0},
+	{0x72, 0x22, 0x22, 0, 0},
+	{0x73, 0x22, 0x22, 0, 0},
+	{0x74, 0, 0, 1, 1},
+	{0x75, 0xa, 0xa, 0, 0},
+	{0x76, 0x1, 0x1, 0, 0},
+	{0x77, 0x22, 0x22, 0, 0},
+	{0x78, 0x30, 0x30, 0, 0},
+	{0x79, 0, 0, 0, 0},
+	{0x7A, 0, 0, 0, 0},
+	{0x7B, 0, 0, 0, 0},
+	{0x7C, 0, 0, 0, 0},
+	{0x7D, 0x5, 0x5, 1, 1},
+	{0x7E, 0, 0, 0, 0},
+	{0x7F, 0, 0, 0, 0},
+	{0x80, 0, 0, 0, 0},
+	{0x81, 0, 0, 0, 0},
+	{0x82, 0, 0, 0, 0},
+	{0x83, 0, 0, 0, 0},
+	{0x84, 0, 0, 0, 0},
+	{0x85, 0, 0, 0, 0},
+	{0x86, 0, 0, 0, 0},
+	{0x87, 0, 0, 0, 0},
+	{0x88, 0, 0, 0, 0},
+	{0x89, 0, 0, 0, 0},
+	{0x8A, 0, 0, 0, 0},
+	{0x8B, 0, 0, 0, 0},
+	{0x8C, 0, 0, 0, 0},
+	{0x8D, 0, 0, 0, 0},
+	{0x8E, 0, 0, 0, 0},
+	{0x8F, 0, 0, 0, 0},
+	{0x90, 0, 0, 0, 0},
+	{0x91, 0, 0, 0, 0},
+	{0x92, 0, 0, 0, 0},
+	{0x93, 0, 0, 0, 0},
+	{0x94, 0, 0, 0, 0},
+	{0xFFFF, 0, 0, 0, 0},
+};
+
+radio_20xx_regs_t regs_2057_rev4[] = {
+	{0x00, 0x84, 0},
+	{0x01, 0, 0},
+	{0x02, 0x60, 0},
+	{0x03, 0x1f, 0},
+	{0x04, 0x4, 0},
+	{0x05, 0x2, 0},
+	{0x06, 0x1, 0},
+	{0x07, 0x1, 0},
+	{0x08, 0x1, 0},
+	{0x09, 0x69, 0},
+	{0x0A, 0x66, 0},
+	{0x0B, 0x6, 0},
+	{0x0C, 0x18, 0},
+	{0x0D, 0x3, 0},
+	{0x0E, 0x20, 1},
+	{0x0F, 0x20, 0},
+	{0x10, 0, 0},
+	{0x11, 0x7c, 0},
+	{0x12, 0x42, 0},
+	{0x13, 0xbd, 0},
+	{0x14, 0x7, 0},
+	{0x15, 0xf7, 0},
+	{0x16, 0x8, 0},
+	{0x17, 0x17, 0},
+	{0x18, 0x7, 0},
+	{0x19, 0, 0},
+	{0x1A, 0x2, 0},
+	{0x1B, 0x13, 0},
+	{0x1C, 0x3e, 0},
+	{0x1D, 0x3e, 0},
+	{0x1E, 0x96, 0},
+	{0x1F, 0x4, 0},
+	{0x20, 0, 0},
+	{0x21, 0, 0},
+	{0x22, 0x17, 0},
+	{0x23, 0x4, 0},
+	{0x24, 0x1, 0},
+	{0x25, 0x6, 0},
+	{0x26, 0x4, 0},
+	{0x27, 0xd, 0},
+	{0x28, 0xd, 0},
+	{0x29, 0x30, 0},
+	{0x2A, 0x32, 0},
+	{0x2B, 0x8, 0},
+	{0x2C, 0x1c, 0},
+	{0x2D, 0x2, 0},
+	{0x2E, 0x4, 0},
+	{0x2F, 0x7f, 0},
+	{0x30, 0x27, 0},
+	{0x31, 0, 1},
+	{0x32, 0, 1},
+	{0x33, 0, 1},
+	{0x34, 0, 0},
+	{0x35, 0x26, 1},
+	{0x36, 0x18, 0},
+	{0x37, 0x7, 0},
+	{0x38, 0x66, 0},
+	{0x39, 0x66, 0},
+	{0x3A, 0x66, 0},
+	{0x3B, 0x66, 0},
+	{0x3C, 0xff, 1},
+	{0x3D, 0xff, 1},
+	{0x3E, 0xff, 1},
+	{0x3F, 0xff, 1},
+	{0x40, 0x16, 0},
+	{0x41, 0x7, 0},
+	{0x42, 0x19, 0},
+	{0x43, 0x7, 0},
+	{0x44, 0x6, 0},
+	{0x45, 0x3, 0},
+	{0x46, 0x1, 0},
+	{0x47, 0x7, 0},
+	{0x48, 0x33, 0},
+	{0x49, 0x5, 0},
+	{0x4A, 0x77, 0},
+	{0x4B, 0x66, 0},
+	{0x4C, 0x66, 0},
+	{0x4D, 0, 0},
+	{0x4E, 0x4, 0},
+	{0x4F, 0xc, 0},
+	{0x50, 0, 0},
+	{0x51, 0x75, 0},
+	{0x56, 0x7, 0},
+	{0x57, 0, 0},
+	{0x58, 0, 0},
+	{0x59, 0xa8, 0},
+	{0x5A, 0, 0},
+	{0x5B, 0x1f, 0},
+	{0x5C, 0x30, 0},
+	{0x5D, 0x1, 0},
+	{0x5E, 0x30, 0},
+	{0x5F, 0x70, 0},
+	{0x60, 0, 0},
+	{0x61, 0, 0},
+	{0x62, 0x33, 1},
+	{0x63, 0x19, 0},
+	{0x64, 0x62, 0},
+	{0x65, 0, 0},
+	{0x66, 0x11, 0},
+	{0x69, 0, 0},
+	{0x6A, 0x7e, 0},
+	{0x6B, 0x3f, 0},
+	{0x6C, 0x7f, 0},
+	{0x6D, 0x78, 0},
+	{0x6E, 0xc8, 0},
+	{0x6F, 0x88, 0},
+	{0x70, 0x8, 0},
+	{0x71, 0xf, 0},
+	{0x72, 0xbc, 0},
+	{0x73, 0x8, 0},
+	{0x74, 0x60, 0},
+	{0x75, 0x1e, 0},
+	{0x76, 0x70, 0},
+	{0x77, 0, 0},
+	{0x78, 0, 0},
+	{0x79, 0, 0},
+	{0x7A, 0x33, 0},
+	{0x7B, 0x1e, 0},
+	{0x7C, 0x62, 0},
+	{0x7D, 0x11, 0},
+	{0x80, 0x3c, 0},
+	{0x81, 0x9c, 0},
+	{0x82, 0xa, 0},
+	{0x83, 0x9d, 0},
+	{0x84, 0xa, 0},
+	{0x85, 0, 0},
+	{0x86, 0x40, 0},
+	{0x87, 0x40, 0},
+	{0x88, 0x88, 0},
+	{0x89, 0x10, 0},
+	{0x8A, 0xf0, 1},
+	{0x8B, 0x10, 1},
+	{0x8C, 0xf0, 1},
+	{0x8D, 0, 0},
+	{0x8E, 0, 0},
+	{0x8F, 0x10, 0},
+	{0x90, 0x55, 0},
+	{0x91, 0x3f, 1},
+	{0x92, 0x36, 1},
+	{0x93, 0, 0},
+	{0x94, 0, 0},
+	{0x95, 0, 0},
+	{0x96, 0x87, 0},
+	{0x97, 0x11, 0},
+	{0x98, 0, 0},
+	{0x99, 0x33, 0},
+	{0x9A, 0x88, 0},
+	{0x9B, 0, 0},
+	{0x9C, 0x87, 0},
+	{0x9D, 0x11, 0},
+	{0x9E, 0, 0},
+	{0x9F, 0x33, 0},
+	{0xA0, 0x88, 0},
+	{0xA1, 0xe1, 0},
+	{0xA2, 0x3f, 0},
+	{0xA3, 0x44, 0},
+	{0xA4, 0x8c, 1},
+	{0xA5, 0x6d, 0},
+	{0xA6, 0x22, 0},
+	{0xA7, 0xbe, 0},
+	{0xA8, 0x55, 1},
+	{0xA9, 0xc, 0},
+	{0xAA, 0xc, 0},
+	{0xAB, 0xaa, 0},
+	{0xAC, 0x2, 0},
+	{0xAD, 0, 0},
+	{0xAE, 0x10, 0},
+	{0xAF, 0x1, 1},
+	{0xB0, 0, 0},
+	{0xB1, 0, 0},
+	{0xB2, 0x80, 0},
+	{0xB3, 0x60, 0},
+	{0xB4, 0x44, 0},
+	{0xB5, 0x55, 0},
+	{0xB6, 0x1, 0},
+	{0xB7, 0x55, 0},
+	{0xB8, 0x1, 0},
+	{0xB9, 0x5, 0},
+	{0xBA, 0x55, 0},
+	{0xBB, 0x55, 0},
+	{0xC1, 0, 0},
+	{0xC2, 0, 0},
+	{0xC3, 0, 0},
+	{0xC4, 0, 0},
+	{0xC5, 0, 0},
+	{0xC6, 0, 0},
+	{0xC7, 0, 0},
+	{0xC8, 0, 0},
+	{0xC9, 0, 0},
+	{0xCA, 0, 0},
+	{0xCB, 0, 0},
+	{0xCC, 0, 0},
+	{0xCD, 0, 0},
+	{0xCE, 0x5e, 0},
+	{0xCF, 0xc, 0},
+	{0xD0, 0xc, 0},
+	{0xD1, 0xc, 0},
+	{0xD2, 0, 0},
+	{0xD3, 0x2b, 0},
+	{0xD4, 0xc, 0},
+	{0xD5, 0, 0},
+	{0xD6, 0x75, 0},
+	{0xDB, 0x7, 0},
+	{0xDC, 0, 0},
+	{0xDD, 0, 0},
+	{0xDE, 0xa8, 0},
+	{0xDF, 0, 0},
+	{0xE0, 0x1f, 0},
+	{0xE1, 0x30, 0},
+	{0xE2, 0x1, 0},
+	{0xE3, 0x30, 0},
+	{0xE4, 0x70, 0},
+	{0xE5, 0, 0},
+	{0xE6, 0, 0},
+	{0xE7, 0x33, 0},
+	{0xE8, 0x19, 0},
+	{0xE9, 0x62, 0},
+	{0xEA, 0, 0},
+	{0xEB, 0x11, 0},
+	{0xEE, 0, 0},
+	{0xEF, 0x7e, 0},
+	{0xF0, 0x3f, 0},
+	{0xF1, 0x7f, 0},
+	{0xF2, 0x78, 0},
+	{0xF3, 0xc8, 0},
+	{0xF4, 0x88, 0},
+	{0xF5, 0x8, 0},
+	{0xF6, 0xf, 0},
+	{0xF7, 0xbc, 0},
+	{0xF8, 0x8, 0},
+	{0xF9, 0x60, 0},
+	{0xFA, 0x1e, 0},
+	{0xFB, 0x70, 0},
+	{0xFC, 0, 0},
+	{0xFD, 0, 0},
+	{0xFE, 0, 0},
+	{0xFF, 0x33, 0},
+	{0x100, 0x1e, 0},
+	{0x101, 0x62, 0},
+	{0x102, 0x11, 0},
+	{0x105, 0x3c, 0},
+	{0x106, 0x9c, 0},
+	{0x107, 0xa, 0},
+	{0x108, 0x9d, 0},
+	{0x109, 0xa, 0},
+	{0x10A, 0, 0},
+	{0x10B, 0x40, 0},
+	{0x10C, 0x40, 0},
+	{0x10D, 0x88, 0},
+	{0x10E, 0x10, 0},
+	{0x10F, 0xf0, 1},
+	{0x110, 0x10, 1},
+	{0x111, 0xf0, 1},
+	{0x112, 0, 0},
+	{0x113, 0, 0},
+	{0x114, 0x10, 0},
+	{0x115, 0x55, 0},
+	{0x116, 0x3f, 1},
+	{0x117, 0x36, 1},
+	{0x118, 0, 0},
+	{0x119, 0, 0},
+	{0x11A, 0, 0},
+	{0x11B, 0x87, 0},
+	{0x11C, 0x11, 0},
+	{0x11D, 0, 0},
+	{0x11E, 0x33, 0},
+	{0x11F, 0x88, 0},
+	{0x120, 0, 0},
+	{0x121, 0x87, 0},
+	{0x122, 0x11, 0},
+	{0x123, 0, 0},
+	{0x124, 0x33, 0},
+	{0x125, 0x88, 0},
+	{0x126, 0xe1, 0},
+	{0x127, 0x3f, 0},
+	{0x128, 0x44, 0},
+	{0x129, 0x8c, 1},
+	{0x12A, 0x6d, 0},
+	{0x12B, 0x22, 0},
+	{0x12C, 0xbe, 0},
+	{0x12D, 0x55, 1},
+	{0x12E, 0xc, 0},
+	{0x12F, 0xc, 0},
+	{0x130, 0xaa, 0},
+	{0x131, 0x2, 0},
+	{0x132, 0, 0},
+	{0x133, 0x10, 0},
+	{0x134, 0x1, 1},
+	{0x135, 0, 0},
+	{0x136, 0, 0},
+	{0x137, 0x80, 0},
+	{0x138, 0x60, 0},
+	{0x139, 0x44, 0},
+	{0x13A, 0x55, 0},
+	{0x13B, 0x1, 0},
+	{0x13C, 0x55, 0},
+	{0x13D, 0x1, 0},
+	{0x13E, 0x5, 0},
+	{0x13F, 0x55, 0},
+	{0x140, 0x55, 0},
+	{0x146, 0, 0},
+	{0x147, 0, 0},
+	{0x148, 0, 0},
+	{0x149, 0, 0},
+	{0x14A, 0, 0},
+	{0x14B, 0, 0},
+	{0x14C, 0, 0},
+	{0x14D, 0, 0},
+	{0x14E, 0, 0},
+	{0x14F, 0, 0},
+	{0x150, 0, 0},
+	{0x151, 0, 0},
+	{0x152, 0, 0},
+	{0x153, 0, 0},
+	{0x154, 0xc, 0},
+	{0x155, 0xc, 0},
+	{0x156, 0xc, 0},
+	{0x157, 0, 0},
+	{0x158, 0x2b, 0},
+	{0x159, 0x84, 0},
+	{0x15A, 0x15, 0},
+	{0x15B, 0xf, 0},
+	{0x15C, 0, 0},
+	{0x15D, 0, 0},
+	{0x15E, 0, 1},
+	{0x15F, 0, 1},
+	{0x160, 0, 1},
+	{0x161, 0, 1},
+	{0x162, 0, 1},
+	{0x163, 0, 1},
+	{0x164, 0, 0},
+	{0x165, 0, 0},
+	{0x166, 0, 0},
+	{0x167, 0, 0},
+	{0x168, 0, 0},
+	{0x169, 0x2, 1},
+	{0x16A, 0, 1},
+	{0x16B, 0, 1},
+	{0x16C, 0, 1},
+	{0x16D, 0, 0},
+	{0x170, 0, 0},
+	{0x171, 0x77, 0},
+	{0x172, 0x77, 0},
+	{0x173, 0x77, 0},
+	{0x174, 0x77, 0},
+	{0x175, 0, 0},
+	{0x176, 0x3, 0},
+	{0x177, 0x37, 0},
+	{0x178, 0x3, 0},
+	{0x179, 0, 0},
+	{0x17A, 0x21, 0},
+	{0x17B, 0x21, 0},
+	{0x17C, 0, 0},
+	{0x17D, 0xaa, 0},
+	{0x17E, 0, 0},
+	{0x17F, 0xaa, 0},
+	{0x180, 0, 0},
+	{0x190, 0, 0},
+	{0x191, 0x77, 0},
+	{0x192, 0x77, 0},
+	{0x193, 0x77, 0},
+	{0x194, 0x77, 0},
+	{0x195, 0, 0},
+	{0x196, 0x3, 0},
+	{0x197, 0x37, 0},
+	{0x198, 0x3, 0},
+	{0x199, 0, 0},
+	{0x19A, 0x21, 0},
+	{0x19B, 0x21, 0},
+	{0x19C, 0, 0},
+	{0x19D, 0xaa, 0},
+	{0x19E, 0, 0},
+	{0x19F, 0xaa, 0},
+	{0x1A0, 0, 0},
+	{0x1A1, 0x2, 0},
+	{0x1A2, 0xf, 0},
+	{0x1A3, 0xf, 0},
+	{0x1A4, 0, 1},
+	{0x1A5, 0, 1},
+	{0x1A6, 0, 1},
+	{0x1A7, 0x2, 0},
+	{0x1A8, 0xf, 0},
+	{0x1A9, 0xf, 0},
+	{0x1AA, 0, 1},
+	{0x1AB, 0, 1},
+	{0x1AC, 0, 1},
+	{0xFFFF, 0, 0},
+};
+
+radio_20xx_regs_t regs_2057_rev5[] = {
+	{0x00, 0, 1},
+	{0x01, 0x57, 1},
+	{0x02, 0x20, 1},
+	{0x03, 0x1f, 0},
+	{0x04, 0x4, 0},
+	{0x05, 0x2, 0},
+	{0x06, 0x1, 0},
+	{0x07, 0x1, 0},
+	{0x08, 0x1, 0},
+	{0x09, 0x69, 0},
+	{0x0A, 0x66, 0},
+	{0x0B, 0x6, 0},
+	{0x0C, 0x18, 0},
+	{0x0D, 0x3, 0},
+	{0x0E, 0x20, 0},
+	{0x0F, 0x20, 0},
+	{0x10, 0, 0},
+	{0x11, 0x7c, 0},
+	{0x12, 0x42, 0},
+	{0x13, 0xbd, 0},
+	{0x14, 0x7, 0},
+	{0x15, 0x87, 0},
+	{0x16, 0x8, 0},
+	{0x17, 0x17, 0},
+	{0x18, 0x7, 0},
+	{0x19, 0, 0},
+	{0x1A, 0x2, 0},
+	{0x1B, 0x13, 0},
+	{0x1C, 0x3e, 0},
+	{0x1D, 0x3e, 0},
+	{0x1E, 0x96, 0},
+	{0x1F, 0x4, 0},
+	{0x20, 0, 0},
+	{0x21, 0, 0},
+	{0x22, 0x17, 0},
+	{0x23, 0x6, 1},
+	{0x24, 0x1, 0},
+	{0x25, 0x6, 0},
+	{0x26, 0x4, 0},
+	{0x27, 0xd, 0},
+	{0x28, 0xd, 0},
+	{0x29, 0x30, 0},
+	{0x2A, 0x32, 0},
+	{0x2B, 0x8, 0},
+	{0x2C, 0x1c, 0},
+	{0x2D, 0x2, 0},
+	{0x2E, 0x4, 0},
+	{0x2F, 0x7f, 0},
+	{0x30, 0x27, 0},
+	{0x31, 0, 1},
+	{0x32, 0, 1},
+	{0x33, 0, 1},
+	{0x34, 0, 0},
+	{0x35, 0x20, 0},
+	{0x36, 0x18, 0},
+	{0x37, 0x7, 0},
+	{0x38, 0x66, 0},
+	{0x39, 0x66, 0},
+	{0x3C, 0xff, 0},
+	{0x3D, 0xff, 0},
+	{0x40, 0x16, 0},
+	{0x41, 0x7, 0},
+	{0x45, 0x3, 0},
+	{0x46, 0x1, 0},
+	{0x47, 0x7, 0},
+	{0x4B, 0x66, 0},
+	{0x4C, 0x66, 0},
+	{0x4D, 0, 0},
+	{0x4E, 0x4, 0},
+	{0x4F, 0xc, 0},
+	{0x50, 0, 0},
+	{0x51, 0x70, 1},
+	{0x56, 0x7, 0},
+	{0x57, 0, 0},
+	{0x58, 0, 0},
+	{0x59, 0x88, 1},
+	{0x5A, 0, 0},
+	{0x5B, 0x1f, 0},
+	{0x5C, 0x20, 1},
+	{0x5D, 0x1, 0},
+	{0x5E, 0x30, 0},
+	{0x5F, 0x70, 0},
+	{0x60, 0, 0},
+	{0x61, 0, 0},
+	{0x62, 0x33, 1},
+	{0x63, 0xf, 1},
+	{0x64, 0xf, 1},
+	{0x65, 0, 0},
+	{0x66, 0x11, 0},
+	{0x80, 0x3c, 0},
+	{0x81, 0x1, 1},
+	{0x82, 0xa, 0},
+	{0x85, 0, 0},
+	{0x86, 0x40, 0},
+	{0x87, 0x40, 0},
+	{0x88, 0x88, 0},
+	{0x89, 0x10, 0},
+	{0x8A, 0xf0, 0},
+	{0x8B, 0x10, 0},
+	{0x8C, 0xf0, 0},
+	{0x8F, 0x10, 0},
+	{0x90, 0x55, 0},
+	{0x91, 0x3f, 1},
+	{0x92, 0x36, 1},
+	{0x93, 0, 0},
+	{0x94, 0, 0},
+	{0x95, 0, 0},
+	{0x96, 0x87, 0},
+	{0x97, 0x11, 0},
+	{0x98, 0, 0},
+	{0x99, 0x33, 0},
+	{0x9A, 0x88, 0},
+	{0xA1, 0x20, 1},
+	{0xA2, 0x3f, 0},
+	{0xA3, 0x44, 0},
+	{0xA4, 0x8c, 0},
+	{0xA5, 0x6c, 0},
+	{0xA6, 0x22, 0},
+	{0xA7, 0xbe, 0},
+	{0xA8, 0x55, 0},
+	{0xAA, 0xc, 0},
+	{0xAB, 0xaa, 0},
+	{0xAC, 0x2, 0},
+	{0xAD, 0, 0},
+	{0xAE, 0x10, 0},
+	{0xAF, 0x1, 0},
+	{0xB0, 0, 0},
+	{0xB1, 0, 0},
+	{0xB2, 0x80, 0},
+	{0xB3, 0x60, 0},
+	{0xB4, 0x44, 0},
+	{0xB5, 0x55, 0},
+	{0xB6, 0x1, 0},
+	{0xB7, 0x55, 0},
+	{0xB8, 0x1, 0},
+	{0xB9, 0x5, 0},
+	{0xBA, 0x55, 0},
+	{0xBB, 0x55, 0},
+	{0xC3, 0, 0},
+	{0xC4, 0, 0},
+	{0xC5, 0, 0},
+	{0xC6, 0, 0},
+	{0xC7, 0, 0},
+	{0xC8, 0, 0},
+	{0xC9, 0, 0},
+	{0xCA, 0, 0},
+	{0xCB, 0, 0},
+	{0xCD, 0, 0},
+	{0xCE, 0x5e, 0},
+	{0xCF, 0xc, 0},
+	{0xD0, 0xc, 0},
+	{0xD1, 0xc, 0},
+	{0xD2, 0, 0},
+	{0xD3, 0x2b, 0},
+	{0xD4, 0xc, 0},
+	{0xD5, 0, 0},
+	{0xD6, 0x70, 1},
+	{0xDB, 0x7, 0},
+	{0xDC, 0, 0},
+	{0xDD, 0, 0},
+	{0xDE, 0x88, 1},
+	{0xDF, 0, 0},
+	{0xE0, 0x1f, 0},
+	{0xE1, 0x20, 1},
+	{0xE2, 0x1, 0},
+	{0xE3, 0x30, 0},
+	{0xE4, 0x70, 0},
+	{0xE5, 0, 0},
+	{0xE6, 0, 0},
+	{0xE7, 0x33, 0},
+	{0xE8, 0xf, 1},
+	{0xE9, 0xf, 1},
+	{0xEA, 0, 0},
+	{0xEB, 0x11, 0},
+	{0x105, 0x3c, 0},
+	{0x106, 0x1, 1},
+	{0x107, 0xa, 0},
+	{0x10A, 0, 0},
+	{0x10B, 0x40, 0},
+	{0x10C, 0x40, 0},
+	{0x10D, 0x88, 0},
+	{0x10E, 0x10, 0},
+	{0x10F, 0xf0, 0},
+	{0x110, 0x10, 0},
+	{0x111, 0xf0, 0},
+	{0x114, 0x10, 0},
+	{0x115, 0x55, 0},
+	{0x116, 0x3f, 1},
+	{0x117, 0x36, 1},
+	{0x118, 0, 0},
+	{0x119, 0, 0},
+	{0x11A, 0, 0},
+	{0x11B, 0x87, 0},
+	{0x11C, 0x11, 0},
+	{0x11D, 0, 0},
+	{0x11E, 0x33, 0},
+	{0x11F, 0x88, 0},
+	{0x126, 0x20, 1},
+	{0x127, 0x3f, 0},
+	{0x128, 0x44, 0},
+	{0x129, 0x8c, 0},
+	{0x12A, 0x6c, 0},
+	{0x12B, 0x22, 0},
+	{0x12C, 0xbe, 0},
+	{0x12D, 0x55, 0},
+	{0x12F, 0xc, 0},
+	{0x130, 0xaa, 0},
+	{0x131, 0x2, 0},
+	{0x132, 0, 0},
+	{0x133, 0x10, 0},
+	{0x134, 0x1, 0},
+	{0x135, 0, 0},
+	{0x136, 0, 0},
+	{0x137, 0x80, 0},
+	{0x138, 0x60, 0},
+	{0x139, 0x44, 0},
+	{0x13A, 0x55, 0},
+	{0x13B, 0x1, 0},
+	{0x13C, 0x55, 0},
+	{0x13D, 0x1, 0},
+	{0x13E, 0x5, 0},
+	{0x13F, 0x55, 0},
+	{0x140, 0x55, 0},
+	{0x148, 0, 0},
+	{0x149, 0, 0},
+	{0x14A, 0, 0},
+	{0x14B, 0, 0},
+	{0x14C, 0, 0},
+	{0x14D, 0, 0},
+	{0x14E, 0, 0},
+	{0x14F, 0, 0},
+	{0x150, 0, 0},
+	{0x154, 0xc, 0},
+	{0x155, 0xc, 0},
+	{0x156, 0xc, 0},
+	{0x157, 0, 0},
+	{0x158, 0x2b, 0},
+	{0x159, 0x84, 0},
+	{0x15A, 0x15, 0},
+	{0x15B, 0xf, 0},
+	{0x15C, 0, 0},
+	{0x15D, 0, 0},
+	{0x15E, 0, 1},
+	{0x15F, 0, 1},
+	{0x160, 0, 1},
+	{0x161, 0, 1},
+	{0x162, 0, 1},
+	{0x163, 0, 1},
+	{0x164, 0, 0},
+	{0x165, 0, 0},
+	{0x166, 0, 0},
+	{0x167, 0, 0},
+	{0x168, 0, 0},
+	{0x169, 0, 0},
+	{0x16A, 0, 1},
+	{0x16B, 0, 1},
+	{0x16C, 0, 1},
+	{0x16D, 0, 0},
+	{0x170, 0, 0},
+	{0x171, 0x77, 0},
+	{0x172, 0x77, 0},
+	{0x173, 0x77, 0},
+	{0x174, 0x77, 0},
+	{0x175, 0, 0},
+	{0x176, 0x3, 0},
+	{0x177, 0x37, 0},
+	{0x178, 0x3, 0},
+	{0x179, 0, 0},
+	{0x17B, 0x21, 0},
+	{0x17C, 0, 0},
+	{0x17D, 0xaa, 0},
+	{0x17E, 0, 0},
+	{0x190, 0, 0},
+	{0x191, 0x77, 0},
+	{0x192, 0x77, 0},
+	{0x193, 0x77, 0},
+	{0x194, 0x77, 0},
+	{0x195, 0, 0},
+	{0x196, 0x3, 0},
+	{0x197, 0x37, 0},
+	{0x198, 0x3, 0},
+	{0x199, 0, 0},
+	{0x19B, 0x21, 0},
+	{0x19C, 0, 0},
+	{0x19D, 0xaa, 0},
+	{0x19E, 0, 0},
+	{0x1A1, 0x2, 0},
+	{0x1A2, 0xf, 0},
+	{0x1A3, 0xf, 0},
+	{0x1A4, 0, 1},
+	{0x1A5, 0, 1},
+	{0x1A6, 0, 1},
+	{0x1A7, 0x2, 0},
+	{0x1A8, 0xf, 0},
+	{0x1A9, 0xf, 0},
+	{0x1AA, 0, 1},
+	{0x1AB, 0, 1},
+	{0x1AC, 0, 1},
+	{0x1AD, 0x84, 0},
+	{0x1AE, 0x60, 0},
+	{0x1AF, 0x47, 0},
+	{0x1B0, 0x47, 0},
+	{0x1B1, 0, 0},
+	{0x1B2, 0, 0},
+	{0x1B3, 0, 0},
+	{0x1B4, 0, 0},
+	{0x1B5, 0, 0},
+	{0x1B6, 0, 0},
+	{0x1B7, 0xc, 1},
+	{0x1B8, 0, 0},
+	{0x1B9, 0, 0},
+	{0x1BA, 0, 0},
+	{0x1BB, 0, 0},
+	{0x1BC, 0, 0},
+	{0x1BD, 0, 0},
+	{0x1BE, 0, 0},
+	{0x1BF, 0, 0},
+	{0x1C0, 0, 0},
+	{0x1C1, 0x1, 1},
+	{0x1C2, 0x80, 1},
+	{0x1C3, 0, 0},
+	{0x1C4, 0, 0},
+	{0x1C5, 0, 0},
+	{0x1C6, 0, 0},
+	{0x1C7, 0, 0},
+	{0x1C8, 0, 0},
+	{0x1C9, 0, 0},
+	{0x1CA, 0, 0},
+	{0xFFFF, 0, 0}
+};
+
+radio_20xx_regs_t regs_2057_rev5v1[] = {
+	{0x00, 0x15, 1},
+	{0x01, 0x57, 1},
+	{0x02, 0x20, 1},
+	{0x03, 0x1f, 0},
+	{0x04, 0x4, 0},
+	{0x05, 0x2, 0},
+	{0x06, 0x1, 0},
+	{0x07, 0x1, 0},
+	{0x08, 0x1, 0},
+	{0x09, 0x69, 0},
+	{0x0A, 0x66, 0},
+	{0x0B, 0x6, 0},
+	{0x0C, 0x18, 0},
+	{0x0D, 0x3, 0},
+	{0x0E, 0x20, 0},
+	{0x0F, 0x20, 0},
+	{0x10, 0, 0},
+	{0x11, 0x7c, 0},
+	{0x12, 0x42, 0},
+	{0x13, 0xbd, 0},
+	{0x14, 0x7, 0},
+	{0x15, 0x87, 0},
+	{0x16, 0x8, 0},
+	{0x17, 0x17, 0},
+	{0x18, 0x7, 0},
+	{0x19, 0, 0},
+	{0x1A, 0x2, 0},
+	{0x1B, 0x13, 0},
+	{0x1C, 0x3e, 0},
+	{0x1D, 0x3e, 0},
+	{0x1E, 0x96, 0},
+	{0x1F, 0x4, 0},
+	{0x20, 0, 0},
+	{0x21, 0, 0},
+	{0x22, 0x17, 0},
+	{0x23, 0x6, 1},
+	{0x24, 0x1, 0},
+	{0x25, 0x6, 0},
+	{0x26, 0x4, 0},
+	{0x27, 0xd, 0},
+	{0x28, 0xd, 0},
+	{0x29, 0x30, 0},
+	{0x2A, 0x32, 0},
+	{0x2B, 0x8, 0},
+	{0x2C, 0x1c, 0},
+	{0x2D, 0x2, 0},
+	{0x2E, 0x4, 0},
+	{0x2F, 0x7f, 0},
+	{0x30, 0x27, 0},
+	{0x31, 0, 1},
+	{0x32, 0, 1},
+	{0x33, 0, 1},
+	{0x34, 0, 0},
+	{0x35, 0x20, 0},
+	{0x36, 0x18, 0},
+	{0x37, 0x7, 0},
+	{0x38, 0x66, 0},
+	{0x39, 0x66, 0},
+	{0x3C, 0xff, 0},
+	{0x3D, 0xff, 0},
+	{0x40, 0x16, 0},
+	{0x41, 0x7, 0},
+	{0x45, 0x3, 0},
+	{0x46, 0x1, 0},
+	{0x47, 0x7, 0},
+	{0x4B, 0x66, 0},
+	{0x4C, 0x66, 0},
+	{0x4D, 0, 0},
+	{0x4E, 0x4, 0},
+	{0x4F, 0xc, 0},
+	{0x50, 0, 0},
+	{0x51, 0x70, 1},
+	{0x56, 0x7, 0},
+	{0x57, 0, 0},
+	{0x58, 0, 0},
+	{0x59, 0x88, 1},
+	{0x5A, 0, 0},
+	{0x5B, 0x1f, 0},
+	{0x5C, 0x20, 1},
+	{0x5D, 0x1, 0},
+	{0x5E, 0x30, 0},
+	{0x5F, 0x70, 0},
+	{0x60, 0, 0},
+	{0x61, 0, 0},
+	{0x62, 0x33, 1},
+	{0x63, 0xf, 1},
+	{0x64, 0xf, 1},
+	{0x65, 0, 0},
+	{0x66, 0x11, 0},
+	{0x80, 0x3c, 0},
+	{0x81, 0x1, 1},
+	{0x82, 0xa, 0},
+	{0x85, 0, 0},
+	{0x86, 0x40, 0},
+	{0x87, 0x40, 0},
+	{0x88, 0x88, 0},
+	{0x89, 0x10, 0},
+	{0x8A, 0xf0, 0},
+	{0x8B, 0x10, 0},
+	{0x8C, 0xf0, 0},
+	{0x8F, 0x10, 0},
+	{0x90, 0x55, 0},
+	{0x91, 0x3f, 1},
+	{0x92, 0x36, 1},
+	{0x93, 0, 0},
+	{0x94, 0, 0},
+	{0x95, 0, 0},
+	{0x96, 0x87, 0},
+	{0x97, 0x11, 0},
+	{0x98, 0, 0},
+	{0x99, 0x33, 0},
+	{0x9A, 0x88, 0},
+	{0xA1, 0x20, 1},
+	{0xA2, 0x3f, 0},
+	{0xA3, 0x44, 0},
+	{0xA4, 0x8c, 0},
+	{0xA5, 0x6c, 0},
+	{0xA6, 0x22, 0},
+	{0xA7, 0xbe, 0},
+	{0xA8, 0x55, 0},
+	{0xAA, 0xc, 0},
+	{0xAB, 0xaa, 0},
+	{0xAC, 0x2, 0},
+	{0xAD, 0, 0},
+	{0xAE, 0x10, 0},
+	{0xAF, 0x1, 0},
+	{0xB0, 0, 0},
+	{0xB1, 0, 0},
+	{0xB2, 0x80, 0},
+	{0xB3, 0x60, 0},
+	{0xB4, 0x44, 0},
+	{0xB5, 0x55, 0},
+	{0xB6, 0x1, 0},
+	{0xB7, 0x55, 0},
+	{0xB8, 0x1, 0},
+	{0xB9, 0x5, 0},
+	{0xBA, 0x55, 0},
+	{0xBB, 0x55, 0},
+	{0xC3, 0, 0},
+	{0xC4, 0, 0},
+	{0xC5, 0, 0},
+	{0xC6, 0, 0},
+	{0xC7, 0, 0},
+	{0xC8, 0, 0},
+	{0xC9, 0x1, 1},
+	{0xCA, 0, 0},
+	{0xCB, 0, 0},
+	{0xCD, 0, 0},
+	{0xCE, 0x5e, 0},
+	{0xCF, 0xc, 0},
+	{0xD0, 0xc, 0},
+	{0xD1, 0xc, 0},
+	{0xD2, 0, 0},
+	{0xD3, 0x2b, 0},
+	{0xD4, 0xc, 0},
+	{0xD5, 0, 0},
+	{0xD6, 0x70, 1},
+	{0xDB, 0x7, 0},
+	{0xDC, 0, 0},
+	{0xDD, 0, 0},
+	{0xDE, 0x88, 1},
+	{0xDF, 0, 0},
+	{0xE0, 0x1f, 0},
+	{0xE1, 0x20, 1},
+	{0xE2, 0x1, 0},
+	{0xE3, 0x30, 0},
+	{0xE4, 0x70, 0},
+	{0xE5, 0, 0},
+	{0xE6, 0, 0},
+	{0xE7, 0x33, 0},
+	{0xE8, 0xf, 1},
+	{0xE9, 0xf, 1},
+	{0xEA, 0, 0},
+	{0xEB, 0x11, 0},
+	{0x105, 0x3c, 0},
+	{0x106, 0x1, 1},
+	{0x107, 0xa, 0},
+	{0x10A, 0, 0},
+	{0x10B, 0x40, 0},
+	{0x10C, 0x40, 0},
+	{0x10D, 0x88, 0},
+	{0x10E, 0x10, 0},
+	{0x10F, 0xf0, 0},
+	{0x110, 0x10, 0},
+	{0x111, 0xf0, 0},
+	{0x114, 0x10, 0},
+	{0x115, 0x55, 0},
+	{0x116, 0x3f, 1},
+	{0x117, 0x36, 1},
+	{0x118, 0, 0},
+	{0x119, 0, 0},
+	{0x11A, 0, 0},
+	{0x11B, 0x87, 0},
+	{0x11C, 0x11, 0},
+	{0x11D, 0, 0},
+	{0x11E, 0x33, 0},
+	{0x11F, 0x88, 0},
+	{0x126, 0x20, 1},
+	{0x127, 0x3f, 0},
+	{0x128, 0x44, 0},
+	{0x129, 0x8c, 0},
+	{0x12A, 0x6c, 0},
+	{0x12B, 0x22, 0},
+	{0x12C, 0xbe, 0},
+	{0x12D, 0x55, 0},
+	{0x12F, 0xc, 0},
+	{0x130, 0xaa, 0},
+	{0x131, 0x2, 0},
+	{0x132, 0, 0},
+	{0x133, 0x10, 0},
+	{0x134, 0x1, 0},
+	{0x135, 0, 0},
+	{0x136, 0, 0},
+	{0x137, 0x80, 0},
+	{0x138, 0x60, 0},
+	{0x139, 0x44, 0},
+	{0x13A, 0x55, 0},
+	{0x13B, 0x1, 0},
+	{0x13C, 0x55, 0},
+	{0x13D, 0x1, 0},
+	{0x13E, 0x5, 0},
+	{0x13F, 0x55, 0},
+	{0x140, 0x55, 0},
+	{0x148, 0, 0},
+	{0x149, 0, 0},
+	{0x14A, 0, 0},
+	{0x14B, 0, 0},
+	{0x14C, 0, 0},
+	{0x14D, 0, 0},
+	{0x14E, 0x1, 1},
+	{0x14F, 0, 0},
+	{0x150, 0, 0},
+	{0x154, 0xc, 0},
+	{0x155, 0xc, 0},
+	{0x156, 0xc, 0},
+	{0x157, 0, 0},
+	{0x158, 0x2b, 0},
+	{0x159, 0x84, 0},
+	{0x15A, 0x15, 0},
+	{0x15B, 0xf, 0},
+	{0x15C, 0, 0},
+	{0x15D, 0, 0},
+	{0x15E, 0, 1},
+	{0x15F, 0, 1},
+	{0x160, 0, 1},
+	{0x161, 0, 1},
+	{0x162, 0, 1},
+	{0x163, 0, 1},
+	{0x164, 0, 0},
+	{0x165, 0, 0},
+	{0x166, 0, 0},
+	{0x167, 0, 0},
+	{0x168, 0, 0},
+	{0x169, 0, 0},
+	{0x16A, 0, 1},
+	{0x16B, 0, 1},
+	{0x16C, 0, 1},
+	{0x16D, 0, 0},
+	{0x170, 0, 0},
+	{0x171, 0x77, 0},
+	{0x172, 0x77, 0},
+	{0x173, 0x77, 0},
+	{0x174, 0x77, 0},
+	{0x175, 0, 0},
+	{0x176, 0x3, 0},
+	{0x177, 0x37, 0},
+	{0x178, 0x3, 0},
+	{0x179, 0, 0},
+	{0x17B, 0x21, 0},
+	{0x17C, 0, 0},
+	{0x17D, 0xaa, 0},
+	{0x17E, 0, 0},
+	{0x190, 0, 0},
+	{0x191, 0x77, 0},
+	{0x192, 0x77, 0},
+	{0x193, 0x77, 0},
+	{0x194, 0x77, 0},
+	{0x195, 0, 0},
+	{0x196, 0x3, 0},
+	{0x197, 0x37, 0},
+	{0x198, 0x3, 0},
+	{0x199, 0, 0},
+	{0x19B, 0x21, 0},
+	{0x19C, 0, 0},
+	{0x19D, 0xaa, 0},
+	{0x19E, 0, 0},
+	{0x1A1, 0x2, 0},
+	{0x1A2, 0xf, 0},
+	{0x1A3, 0xf, 0},
+	{0x1A4, 0, 1},
+	{0x1A5, 0, 1},
+	{0x1A6, 0, 1},
+	{0x1A7, 0x2, 0},
+	{0x1A8, 0xf, 0},
+	{0x1A9, 0xf, 0},
+	{0x1AA, 0, 1},
+	{0x1AB, 0, 1},
+	{0x1AC, 0, 1},
+	{0x1AD, 0x84, 0},
+	{0x1AE, 0x60, 0},
+	{0x1AF, 0x47, 0},
+	{0x1B0, 0x47, 0},
+	{0x1B1, 0, 0},
+	{0x1B2, 0, 0},
+	{0x1B3, 0, 0},
+	{0x1B4, 0, 0},
+	{0x1B5, 0, 0},
+	{0x1B6, 0, 0},
+	{0x1B7, 0xc, 1},
+	{0x1B8, 0, 0},
+	{0x1B9, 0, 0},
+	{0x1BA, 0, 0},
+	{0x1BB, 0, 0},
+	{0x1BC, 0, 0},
+	{0x1BD, 0, 0},
+	{0x1BE, 0, 0},
+	{0x1BF, 0, 0},
+	{0x1C0, 0, 0},
+	{0x1C1, 0x1, 1},
+	{0x1C2, 0x80, 1},
+	{0x1C3, 0, 0},
+	{0x1C4, 0, 0},
+	{0x1C5, 0, 0},
+	{0x1C6, 0, 0},
+	{0x1C7, 0, 0},
+	{0x1C8, 0, 0},
+	{0x1C9, 0, 0},
+	{0x1CA, 0, 0},
+	{0xFFFF, 0, 0}
+};
+
+radio_20xx_regs_t regs_2057_rev7[] = {
+	{0x00, 0, 1},
+	{0x01, 0x57, 1},
+	{0x02, 0x20, 1},
+	{0x03, 0x1f, 0},
+	{0x04, 0x4, 0},
+	{0x05, 0x2, 0},
+	{0x06, 0x1, 0},
+	{0x07, 0x1, 0},
+	{0x08, 0x1, 0},
+	{0x09, 0x69, 0},
+	{0x0A, 0x66, 0},
+	{0x0B, 0x6, 0},
+	{0x0C, 0x18, 0},
+	{0x0D, 0x3, 0},
+	{0x0E, 0x20, 0},
+	{0x0F, 0x20, 0},
+	{0x10, 0, 0},
+	{0x11, 0x7c, 0},
+	{0x12, 0x42, 0},
+	{0x13, 0xbd, 0},
+	{0x14, 0x7, 0},
+	{0x15, 0x87, 0},
+	{0x16, 0x8, 0},
+	{0x17, 0x17, 0},
+	{0x18, 0x7, 0},
+	{0x19, 0, 0},
+	{0x1A, 0x2, 0},
+	{0x1B, 0x13, 0},
+	{0x1C, 0x3e, 0},
+	{0x1D, 0x3e, 0},
+	{0x1E, 0x96, 0},
+	{0x1F, 0x4, 0},
+	{0x20, 0, 0},
+	{0x21, 0, 0},
+	{0x22, 0x17, 0},
+	{0x23, 0x6, 0},
+	{0x24, 0x1, 0},
+	{0x25, 0x6, 0},
+	{0x26, 0x4, 0},
+	{0x27, 0xd, 0},
+	{0x28, 0xd, 0},
+	{0x29, 0x30, 0},
+	{0x2A, 0x32, 0},
+	{0x2B, 0x8, 0},
+	{0x2C, 0x1c, 0},
+	{0x2D, 0x2, 0},
+	{0x2E, 0x4, 0},
+	{0x2F, 0x7f, 0},
+	{0x30, 0x27, 0},
+	{0x31, 0, 1},
+	{0x32, 0, 1},
+	{0x33, 0, 1},
+	{0x34, 0, 0},
+	{0x35, 0x20, 0},
+	{0x36, 0x18, 0},
+	{0x37, 0x7, 0},
+	{0x38, 0x66, 0},
+	{0x39, 0x66, 0},
+	{0x3A, 0x66, 0},
+	{0x3B, 0x66, 0},
+	{0x3C, 0xff, 0},
+	{0x3D, 0xff, 0},
+	{0x3E, 0xff, 0},
+	{0x3F, 0xff, 0},
+	{0x40, 0x16, 0},
+	{0x41, 0x7, 0},
+	{0x42, 0x19, 0},
+	{0x43, 0x7, 0},
+	{0x44, 0x6, 0},
+	{0x45, 0x3, 0},
+	{0x46, 0x1, 0},
+	{0x47, 0x7, 0},
+	{0x48, 0x33, 0},
+	{0x49, 0x5, 0},
+	{0x4A, 0x77, 0},
+	{0x4B, 0x66, 0},
+	{0x4C, 0x66, 0},
+	{0x4D, 0, 0},
+	{0x4E, 0x4, 0},
+	{0x4F, 0xc, 0},
+	{0x50, 0, 0},
+	{0x51, 0x70, 1},
+	{0x56, 0x7, 0},
+	{0x57, 0, 0},
+	{0x58, 0, 0},
+	{0x59, 0x88, 1},
+	{0x5A, 0, 0},
+	{0x5B, 0x1f, 0},
+	{0x5C, 0x20, 1},
+	{0x5D, 0x1, 0},
+	{0x5E, 0x30, 0},
+	{0x5F, 0x70, 0},
+	{0x60, 0, 0},
+	{0x61, 0, 0},
+	{0x62, 0x33, 1},
+	{0x63, 0xf, 1},
+	{0x64, 0x13, 1},
+	{0x65, 0, 0},
+	{0x66, 0xee, 1},
+	{0x69, 0, 0},
+	{0x6A, 0x7e, 0},
+	{0x6B, 0x3f, 0},
+	{0x6C, 0x7f, 0},
+	{0x6D, 0x78, 0},
+	{0x6E, 0x58, 1},
+	{0x6F, 0x88, 0},
+	{0x70, 0x8, 0},
+	{0x71, 0xf, 0},
+	{0x72, 0xbc, 0},
+	{0x73, 0x8, 0},
+	{0x74, 0x60, 0},
+	{0x75, 0x13, 1},
+	{0x76, 0x70, 0},
+	{0x77, 0, 0},
+	{0x78, 0, 0},
+	{0x79, 0, 0},
+	{0x7A, 0x33, 0},
+	{0x7B, 0x13, 1},
+	{0x7C, 0x14, 1},
+	{0x7D, 0xee, 1},
+	{0x80, 0x3c, 0},
+	{0x81, 0x1, 1},
+	{0x82, 0xa, 0},
+	{0x83, 0x9d, 0},
+	{0x84, 0xa, 0},
+	{0x85, 0, 0},
+	{0x86, 0x40, 0},
+	{0x87, 0x40, 0},
+	{0x88, 0x88, 0},
+	{0x89, 0x10, 0},
+	{0x8A, 0xf0, 0},
+	{0x8B, 0x10, 0},
+	{0x8C, 0xf0, 0},
+	{0x8D, 0, 0},
+	{0x8E, 0, 0},
+	{0x8F, 0x10, 0},
+	{0x90, 0x55, 0},
+	{0x91, 0x3f, 1},
+	{0x92, 0x36, 1},
+	{0x93, 0, 0},
+	{0x94, 0, 0},
+	{0x95, 0, 0},
+	{0x96, 0x87, 0},
+	{0x97, 0x11, 0},
+	{0x98, 0, 0},
+	{0x99, 0x33, 0},
+	{0x9A, 0x88, 0},
+	{0x9B, 0, 0},
+	{0x9C, 0x87, 0},
+	{0x9D, 0x11, 0},
+	{0x9E, 0, 0},
+	{0x9F, 0x33, 0},
+	{0xA0, 0x88, 0},
+	{0xA1, 0x20, 1},
+	{0xA2, 0x3f, 0},
+	{0xA3, 0x44, 0},
+	{0xA4, 0x8c, 0},
+	{0xA5, 0x6c, 0},
+	{0xA6, 0x22, 0},
+	{0xA7, 0xbe, 0},
+	{0xA8, 0x55, 0},
+	{0xAA, 0xc, 0},
+	{0xAB, 0xaa, 0},
+	{0xAC, 0x2, 0},
+	{0xAD, 0, 0},
+	{0xAE, 0x10, 0},
+	{0xAF, 0x1, 0},
+	{0xB0, 0, 0},
+	{0xB1, 0, 0},
+	{0xB2, 0x80, 0},
+	{0xB3, 0x60, 0},
+	{0xB4, 0x44, 0},
+	{0xB5, 0x55, 0},
+	{0xB6, 0x1, 0},
+	{0xB7, 0x55, 0},
+	{0xB8, 0x1, 0},
+	{0xB9, 0x5, 0},
+	{0xBA, 0x55, 0},
+	{0xBB, 0x55, 0},
+	{0xC1, 0, 0},
+	{0xC2, 0, 0},
+	{0xC3, 0, 0},
+	{0xC4, 0, 0},
+	{0xC5, 0, 0},
+	{0xC6, 0, 0},
+	{0xC7, 0, 0},
+	{0xC8, 0, 0},
+	{0xC9, 0, 0},
+	{0xCA, 0, 0},
+	{0xCB, 0, 0},
+	{0xCC, 0, 0},
+	{0xCD, 0, 0},
+	{0xCE, 0x5e, 0},
+	{0xCF, 0xc, 0},
+	{0xD0, 0xc, 0},
+	{0xD1, 0xc, 0},
+	{0xD2, 0, 0},
+	{0xD3, 0x2b, 0},
+	{0xD4, 0xc, 0},
+	{0xD5, 0, 0},
+	{0xD6, 0x70, 1},
+	{0xDB, 0x7, 0},
+	{0xDC, 0, 0},
+	{0xDD, 0, 0},
+	{0xDE, 0x88, 1},
+	{0xDF, 0, 0},
+	{0xE0, 0x1f, 0},
+	{0xE1, 0x20, 1},
+	{0xE2, 0x1, 0},
+	{0xE3, 0x30, 0},
+	{0xE4, 0x70, 0},
+	{0xE5, 0, 0},
+	{0xE6, 0, 0},
+	{0xE7, 0x33, 0},
+	{0xE8, 0xf, 1},
+	{0xE9, 0x13, 1},
+	{0xEA, 0, 0},
+	{0xEB, 0xee, 1},
+	{0xEE, 0, 0},
+	{0xEF, 0x7e, 0},
+	{0xF0, 0x3f, 0},
+	{0xF1, 0x7f, 0},
+	{0xF2, 0x78, 0},
+	{0xF3, 0x58, 1},
+	{0xF4, 0x88, 0},
+	{0xF5, 0x8, 0},
+	{0xF6, 0xf, 0},
+	{0xF7, 0xbc, 0},
+	{0xF8, 0x8, 0},
+	{0xF9, 0x60, 0},
+	{0xFA, 0x13, 1},
+	{0xFB, 0x70, 0},
+	{0xFC, 0, 0},
+	{0xFD, 0, 0},
+	{0xFE, 0, 0},
+	{0xFF, 0x33, 0},
+	{0x100, 0x13, 1},
+	{0x101, 0x14, 1},
+	{0x102, 0xee, 1},
+	{0x105, 0x3c, 0},
+	{0x106, 0x1, 1},
+	{0x107, 0xa, 0},
+	{0x108, 0x9d, 0},
+	{0x109, 0xa, 0},
+	{0x10A, 0, 0},
+	{0x10B, 0x40, 0},
+	{0x10C, 0x40, 0},
+	{0x10D, 0x88, 0},
+	{0x10E, 0x10, 0},
+	{0x10F, 0xf0, 0},
+	{0x110, 0x10, 0},
+	{0x111, 0xf0, 0},
+	{0x112, 0, 0},
+	{0x113, 0, 0},
+	{0x114, 0x10, 0},
+	{0x115, 0x55, 0},
+	{0x116, 0x3f, 1},
+	{0x117, 0x36, 1},
+	{0x118, 0, 0},
+	{0x119, 0, 0},
+	{0x11A, 0, 0},
+	{0x11B, 0x87, 0},
+	{0x11C, 0x11, 0},
+	{0x11D, 0, 0},
+	{0x11E, 0x33, 0},
+	{0x11F, 0x88, 0},
+	{0x120, 0, 0},
+	{0x121, 0x87, 0},
+	{0x122, 0x11, 0},
+	{0x123, 0, 0},
+	{0x124, 0x33, 0},
+	{0x125, 0x88, 0},
+	{0x126, 0x20, 1},
+	{0x127, 0x3f, 0},
+	{0x128, 0x44, 0},
+	{0x129, 0x8c, 0},
+	{0x12A, 0x6c, 0},
+	{0x12B, 0x22, 0},
+	{0x12C, 0xbe, 0},
+	{0x12D, 0x55, 0},
+	{0x12F, 0xc, 0},
+	{0x130, 0xaa, 0},
+	{0x131, 0x2, 0},
+	{0x132, 0, 0},
+	{0x133, 0x10, 0},
+	{0x134, 0x1, 0},
+	{0x135, 0, 0},
+	{0x136, 0, 0},
+	{0x137, 0x80, 0},
+	{0x138, 0x60, 0},
+	{0x139, 0x44, 0},
+	{0x13A, 0x55, 0},
+	{0x13B, 0x1, 0},
+	{0x13C, 0x55, 0},
+	{0x13D, 0x1, 0},
+	{0x13E, 0x5, 0},
+	{0x13F, 0x55, 0},
+	{0x140, 0x55, 0},
+	{0x146, 0, 0},
+	{0x147, 0, 0},
+	{0x148, 0, 0},
+	{0x149, 0, 0},
+	{0x14A, 0, 0},
+	{0x14B, 0, 0},
+	{0x14C, 0, 0},
+	{0x14D, 0, 0},
+	{0x14E, 0, 0},
+	{0x14F, 0, 0},
+	{0x150, 0, 0},
+	{0x151, 0, 0},
+	{0x154, 0xc, 0},
+	{0x155, 0xc, 0},
+	{0x156, 0xc, 0},
+	{0x157, 0, 0},
+	{0x158, 0x2b, 0},
+	{0x159, 0x84, 0},
+	{0x15A, 0x15, 0},
+	{0x15B, 0xf, 0},
+	{0x15C, 0, 0},
+	{0x15D, 0, 0},
+	{0x15E, 0, 1},
+	{0x15F, 0, 1},
+	{0x160, 0, 1},
+	{0x161, 0, 1},
+	{0x162, 0, 1},
+	{0x163, 0, 1},
+	{0x164, 0, 0},
+	{0x165, 0, 0},
+	{0x166, 0, 0},
+	{0x167, 0, 0},
+	{0x168, 0, 0},
+	{0x169, 0, 0},
+	{0x16A, 0, 1},
+	{0x16B, 0, 1},
+	{0x16C, 0, 1},
+	{0x16D, 0, 0},
+	{0x170, 0, 0},
+	{0x171, 0x77, 0},
+	{0x172, 0x77, 0},
+	{0x173, 0x77, 0},
+	{0x174, 0x77, 0},
+	{0x175, 0, 0},
+	{0x176, 0x3, 0},
+	{0x177, 0x37, 0},
+	{0x178, 0x3, 0},
+	{0x179, 0, 0},
+	{0x17A, 0x21, 0},
+	{0x17B, 0x21, 0},
+	{0x17C, 0, 0},
+	{0x17D, 0xaa, 0},
+	{0x17E, 0, 0},
+	{0x17F, 0xaa, 0},
+	{0x180, 0, 0},
+	{0x190, 0, 0},
+	{0x191, 0x77, 0},
+	{0x192, 0x77, 0},
+	{0x193, 0x77, 0},
+	{0x194, 0x77, 0},
+	{0x195, 0, 0},
+	{0x196, 0x3, 0},
+	{0x197, 0x37, 0},
+	{0x198, 0x3, 0},
+	{0x199, 0, 0},
+	{0x19A, 0x21, 0},
+	{0x19B, 0x21, 0},
+	{0x19C, 0, 0},
+	{0x19D, 0xaa, 0},
+	{0x19E, 0, 0},
+	{0x19F, 0xaa, 0},
+	{0x1A0, 0, 0},
+	{0x1A1, 0x2, 0},
+	{0x1A2, 0xf, 0},
+	{0x1A3, 0xf, 0},
+	{0x1A4, 0, 1},
+	{0x1A5, 0, 1},
+	{0x1A6, 0, 1},
+	{0x1A7, 0x2, 0},
+	{0x1A8, 0xf, 0},
+	{0x1A9, 0xf, 0},
+	{0x1AA, 0, 1},
+	{0x1AB, 0, 1},
+	{0x1AC, 0, 1},
+	{0x1AD, 0x84, 0},
+	{0x1AE, 0x60, 0},
+	{0x1AF, 0x47, 0},
+	{0x1B0, 0x47, 0},
+	{0x1B1, 0, 0},
+	{0x1B2, 0, 0},
+	{0x1B3, 0, 0},
+	{0x1B4, 0, 0},
+	{0x1B5, 0, 0},
+	{0x1B6, 0, 0},
+	{0x1B7, 0x5, 1},
+	{0x1B8, 0, 0},
+	{0x1B9, 0, 0},
+	{0x1BA, 0, 0},
+	{0x1BB, 0, 0},
+	{0x1BC, 0, 0},
+	{0x1BD, 0, 0},
+	{0x1BE, 0, 0},
+	{0x1BF, 0, 0},
+	{0x1C0, 0, 0},
+	{0x1C1, 0, 0},
+	{0x1C2, 0xa0, 1},
+	{0x1C3, 0, 0},
+	{0x1C4, 0, 0},
+	{0x1C5, 0, 0},
+	{0x1C6, 0, 0},
+	{0x1C7, 0, 0},
+	{0x1C8, 0, 0},
+	{0x1C9, 0, 0},
+	{0x1CA, 0, 0},
+	{0xFFFF, 0, 0}
+};
+
+radio_20xx_regs_t regs_2057_rev8[] = {
+	{0x00, 0x8, 1},
+	{0x01, 0x57, 1},
+	{0x02, 0x20, 1},
+	{0x03, 0x1f, 0},
+	{0x04, 0x4, 0},
+	{0x05, 0x2, 0},
+	{0x06, 0x1, 0},
+	{0x07, 0x1, 0},
+	{0x08, 0x1, 0},
+	{0x09, 0x69, 0},
+	{0x0A, 0x66, 0},
+	{0x0B, 0x6, 0},
+	{0x0C, 0x18, 0},
+	{0x0D, 0x3, 0},
+	{0x0E, 0x20, 0},
+	{0x0F, 0x20, 0},
+	{0x10, 0, 0},
+	{0x11, 0x7c, 0},
+	{0x12, 0x42, 0},
+	{0x13, 0xbd, 0},
+	{0x14, 0x7, 0},
+	{0x15, 0x87, 0},
+	{0x16, 0x8, 0},
+	{0x17, 0x17, 0},
+	{0x18, 0x7, 0},
+	{0x19, 0, 0},
+	{0x1A, 0x2, 0},
+	{0x1B, 0x13, 0},
+	{0x1C, 0x3e, 0},
+	{0x1D, 0x3e, 0},
+	{0x1E, 0x96, 0},
+	{0x1F, 0x4, 0},
+	{0x20, 0, 0},
+	{0x21, 0, 0},
+	{0x22, 0x17, 0},
+	{0x23, 0x6, 0},
+	{0x24, 0x1, 0},
+	{0x25, 0x6, 0},
+	{0x26, 0x4, 0},
+	{0x27, 0xd, 0},
+	{0x28, 0xd, 0},
+	{0x29, 0x30, 0},
+	{0x2A, 0x32, 0},
+	{0x2B, 0x8, 0},
+	{0x2C, 0x1c, 0},
+	{0x2D, 0x2, 0},
+	{0x2E, 0x4, 0},
+	{0x2F, 0x7f, 0},
+	{0x30, 0x27, 0},
+	{0x31, 0, 1},
+	{0x32, 0, 1},
+	{0x33, 0, 1},
+	{0x34, 0, 0},
+	{0x35, 0x20, 0},
+	{0x36, 0x18, 0},
+	{0x37, 0x7, 0},
+	{0x38, 0x66, 0},
+	{0x39, 0x66, 0},
+	{0x3A, 0x66, 0},
+	{0x3B, 0x66, 0},
+	{0x3C, 0xff, 0},
+	{0x3D, 0xff, 0},
+	{0x3E, 0xff, 0},
+	{0x3F, 0xff, 0},
+	{0x40, 0x16, 0},
+	{0x41, 0x7, 0},
+	{0x42, 0x19, 0},
+	{0x43, 0x7, 0},
+	{0x44, 0x6, 0},
+	{0x45, 0x3, 0},
+	{0x46, 0x1, 0},
+	{0x47, 0x7, 0},
+	{0x48, 0x33, 0},
+	{0x49, 0x5, 0},
+	{0x4A, 0x77, 0},
+	{0x4B, 0x66, 0},
+	{0x4C, 0x66, 0},
+	{0x4D, 0, 0},
+	{0x4E, 0x4, 0},
+	{0x4F, 0xc, 0},
+	{0x50, 0, 0},
+	{0x51, 0x70, 1},
+	{0x56, 0x7, 0},
+	{0x57, 0, 0},
+	{0x58, 0, 0},
+	{0x59, 0x88, 1},
+	{0x5A, 0, 0},
+	{0x5B, 0x1f, 0},
+	{0x5C, 0x20, 1},
+	{0x5D, 0x1, 0},
+	{0x5E, 0x30, 0},
+	{0x5F, 0x70, 0},
+	{0x60, 0, 0},
+	{0x61, 0, 0},
+	{0x62, 0x33, 1},
+	{0x63, 0xf, 1},
+	{0x64, 0xf, 1},
+	{0x65, 0, 0},
+	{0x66, 0x11, 0},
+	{0x69, 0, 0},
+	{0x6A, 0x7e, 0},
+	{0x6B, 0x3f, 0},
+	{0x6C, 0x7f, 0},
+	{0x6D, 0x78, 0},
+	{0x6E, 0x58, 1},
+	{0x6F, 0x88, 0},
+	{0x70, 0x8, 0},
+	{0x71, 0xf, 0},
+	{0x72, 0xbc, 0},
+	{0x73, 0x8, 0},
+	{0x74, 0x60, 0},
+	{0x75, 0x13, 1},
+	{0x76, 0x70, 0},
+	{0x77, 0, 0},
+	{0x78, 0, 0},
+	{0x79, 0, 0},
+	{0x7A, 0x33, 0},
+	{0x7B, 0x13, 1},
+	{0x7C, 0xf, 1},
+	{0x7D, 0xee, 1},
+	{0x80, 0x3c, 0},
+	{0x81, 0x1, 1},
+	{0x82, 0xa, 0},
+	{0x83, 0x9d, 0},
+	{0x84, 0xa, 0},
+	{0x85, 0, 0},
+	{0x86, 0x40, 0},
+	{0x87, 0x40, 0},
+	{0x88, 0x88, 0},
+	{0x89, 0x10, 0},
+	{0x8A, 0xf0, 0},
+	{0x8B, 0x10, 0},
+	{0x8C, 0xf0, 0},
+	{0x8D, 0, 0},
+	{0x8E, 0, 0},
+	{0x8F, 0x10, 0},
+	{0x90, 0x55, 0},
+	{0x91, 0x3f, 1},
+	{0x92, 0x36, 1},
+	{0x93, 0, 0},
+	{0x94, 0, 0},
+	{0x95, 0, 0},
+	{0x96, 0x87, 0},
+	{0x97, 0x11, 0},
+	{0x98, 0, 0},
+	{0x99, 0x33, 0},
+	{0x9A, 0x88, 0},
+	{0x9B, 0, 0},
+	{0x9C, 0x87, 0},
+	{0x9D, 0x11, 0},
+	{0x9E, 0, 0},
+	{0x9F, 0x33, 0},
+	{0xA0, 0x88, 0},
+	{0xA1, 0x20, 1},
+	{0xA2, 0x3f, 0},
+	{0xA3, 0x44, 0},
+	{0xA4, 0x8c, 0},
+	{0xA5, 0x6c, 0},
+	{0xA6, 0x22, 0},
+	{0xA7, 0xbe, 0},
+	{0xA8, 0x55, 0},
+	{0xAA, 0xc, 0},
+	{0xAB, 0xaa, 0},
+	{0xAC, 0x2, 0},
+	{0xAD, 0, 0},
+	{0xAE, 0x10, 0},
+	{0xAF, 0x1, 0},
+	{0xB0, 0, 0},
+	{0xB1, 0, 0},
+	{0xB2, 0x80, 0},
+	{0xB3, 0x60, 0},
+	{0xB4, 0x44, 0},
+	{0xB5, 0x55, 0},
+	{0xB6, 0x1, 0},
+	{0xB7, 0x55, 0},
+	{0xB8, 0x1, 0},
+	{0xB9, 0x5, 0},
+	{0xBA, 0x55, 0},
+	{0xBB, 0x55, 0},
+	{0xC1, 0, 0},
+	{0xC2, 0, 0},
+	{0xC3, 0, 0},
+	{0xC4, 0, 0},
+	{0xC5, 0, 0},
+	{0xC6, 0, 0},
+	{0xC7, 0, 0},
+	{0xC8, 0, 0},
+	{0xC9, 0x1, 1},
+	{0xCA, 0, 0},
+	{0xCB, 0, 0},
+	{0xCC, 0, 0},
+	{0xCD, 0, 0},
+	{0xCE, 0x5e, 0},
+	{0xCF, 0xc, 0},
+	{0xD0, 0xc, 0},
+	{0xD1, 0xc, 0},
+	{0xD2, 0, 0},
+	{0xD3, 0x2b, 0},
+	{0xD4, 0xc, 0},
+	{0xD5, 0, 0},
+	{0xD6, 0x70, 1},
+	{0xDB, 0x7, 0},
+	{0xDC, 0, 0},
+	{0xDD, 0, 0},
+	{0xDE, 0x88, 1},
+	{0xDF, 0, 0},
+	{0xE0, 0x1f, 0},
+	{0xE1, 0x20, 1},
+	{0xE2, 0x1, 0},
+	{0xE3, 0x30, 0},
+	{0xE4, 0x70, 0},
+	{0xE5, 0, 0},
+	{0xE6, 0, 0},
+	{0xE7, 0x33, 0},
+	{0xE8, 0xf, 1},
+	{0xE9, 0xf, 1},
+	{0xEA, 0, 0},
+	{0xEB, 0x11, 0},
+	{0xEE, 0, 0},
+	{0xEF, 0x7e, 0},
+	{0xF0, 0x3f, 0},
+	{0xF1, 0x7f, 0},
+	{0xF2, 0x78, 0},
+	{0xF3, 0x58, 1},
+	{0xF4, 0x88, 0},
+	{0xF5, 0x8, 0},
+	{0xF6, 0xf, 0},
+	{0xF7, 0xbc, 0},
+	{0xF8, 0x8, 0},
+	{0xF9, 0x60, 0},
+	{0xFA, 0x13, 1},
+	{0xFB, 0x70, 0},
+	{0xFC, 0, 0},
+	{0xFD, 0, 0},
+	{0xFE, 0, 0},
+	{0xFF, 0x33, 0},
+	{0x100, 0x13, 1},
+	{0x101, 0xf, 1},
+	{0x102, 0xee, 1},
+	{0x105, 0x3c, 0},
+	{0x106, 0x1, 1},
+	{0x107, 0xa, 0},
+	{0x108, 0x9d, 0},
+	{0x109, 0xa, 0},
+	{0x10A, 0, 0},
+	{0x10B, 0x40, 0},
+	{0x10C, 0x40, 0},
+	{0x10D, 0x88, 0},
+	{0x10E, 0x10, 0},
+	{0x10F, 0xf0, 0},
+	{0x110, 0x10, 0},
+	{0x111, 0xf0, 0},
+	{0x112, 0, 0},
+	{0x113, 0, 0},
+	{0x114, 0x10, 0},
+	{0x115, 0x55, 0},
+	{0x116, 0x3f, 1},
+	{0x117, 0x36, 1},
+	{0x118, 0, 0},
+	{0x119, 0, 0},
+	{0x11A, 0, 0},
+	{0x11B, 0x87, 0},
+	{0x11C, 0x11, 0},
+	{0x11D, 0, 0},
+	{0x11E, 0x33, 0},
+	{0x11F, 0x88, 0},
+	{0x120, 0, 0},
+	{0x121, 0x87, 0},
+	{0x122, 0x11, 0},
+	{0x123, 0, 0},
+	{0x124, 0x33, 0},
+	{0x125, 0x88, 0},
+	{0x126, 0x20, 1},
+	{0x127, 0x3f, 0},
+	{0x128, 0x44, 0},
+	{0x129, 0x8c, 0},
+	{0x12A, 0x6c, 0},
+	{0x12B, 0x22, 0},
+	{0x12C, 0xbe, 0},
+	{0x12D, 0x55, 0},
+	{0x12F, 0xc, 0},
+	{0x130, 0xaa, 0},
+	{0x131, 0x2, 0},
+	{0x132, 0, 0},
+	{0x133, 0x10, 0},
+	{0x134, 0x1, 0},
+	{0x135, 0, 0},
+	{0x136, 0, 0},
+	{0x137, 0x80, 0},
+	{0x138, 0x60, 0},
+	{0x139, 0x44, 0},
+	{0x13A, 0x55, 0},
+	{0x13B, 0x1, 0},
+	{0x13C, 0x55, 0},
+	{0x13D, 0x1, 0},
+	{0x13E, 0x5, 0},
+	{0x13F, 0x55, 0},
+	{0x140, 0x55, 0},
+	{0x146, 0, 0},
+	{0x147, 0, 0},
+	{0x148, 0, 0},
+	{0x149, 0, 0},
+	{0x14A, 0, 0},
+	{0x14B, 0, 0},
+	{0x14C, 0, 0},
+	{0x14D, 0, 0},
+	{0x14E, 0x1, 1},
+	{0x14F, 0, 0},
+	{0x150, 0, 0},
+	{0x151, 0, 0},
+	{0x154, 0xc, 0},
+	{0x155, 0xc, 0},
+	{0x156, 0xc, 0},
+	{0x157, 0, 0},
+	{0x158, 0x2b, 0},
+	{0x159, 0x84, 0},
+	{0x15A, 0x15, 0},
+	{0x15B, 0xf, 0},
+	{0x15C, 0, 0},
+	{0x15D, 0, 0},
+	{0x15E, 0, 1},
+	{0x15F, 0, 1},
+	{0x160, 0, 1},
+	{0x161, 0, 1},
+	{0x162, 0, 1},
+	{0x163, 0, 1},
+	{0x164, 0, 0},
+	{0x165, 0, 0},
+	{0x166, 0, 0},
+	{0x167, 0, 0},
+	{0x168, 0, 0},
+	{0x169, 0, 0},
+	{0x16A, 0, 1},
+	{0x16B, 0, 1},
+	{0x16C, 0, 1},
+	{0x16D, 0, 0},
+	{0x170, 0, 0},
+	{0x171, 0x77, 0},
+	{0x172, 0x77, 0},
+	{0x173, 0x77, 0},
+	{0x174, 0x77, 0},
+	{0x175, 0, 0},
+	{0x176, 0x3, 0},
+	{0x177, 0x37, 0},
+	{0x178, 0x3, 0},
+	{0x179, 0, 0},
+	{0x17A, 0x21, 0},
+	{0x17B, 0x21, 0},
+	{0x17C, 0, 0},
+	{0x17D, 0xaa, 0},
+	{0x17E, 0, 0},
+	{0x17F, 0xaa, 0},
+	{0x180, 0, 0},
+	{0x190, 0, 0},
+	{0x191, 0x77, 0},
+	{0x192, 0x77, 0},
+	{0x193, 0x77, 0},
+	{0x194, 0x77, 0},
+	{0x195, 0, 0},
+	{0x196, 0x3, 0},
+	{0x197, 0x37, 0},
+	{0x198, 0x3, 0},
+	{0x199, 0, 0},
+	{0x19A, 0x21, 0},
+	{0x19B, 0x21, 0},
+	{0x19C, 0, 0},
+	{0x19D, 0xaa, 0},
+	{0x19E, 0, 0},
+	{0x19F, 0xaa, 0},
+	{0x1A0, 0, 0},
+	{0x1A1, 0x2, 0},
+	{0x1A2, 0xf, 0},
+	{0x1A3, 0xf, 0},
+	{0x1A4, 0, 1},
+	{0x1A5, 0, 1},
+	{0x1A6, 0, 1},
+	{0x1A7, 0x2, 0},
+	{0x1A8, 0xf, 0},
+	{0x1A9, 0xf, 0},
+	{0x1AA, 0, 1},
+	{0x1AB, 0, 1},
+	{0x1AC, 0, 1},
+	{0x1AD, 0x84, 0},
+	{0x1AE, 0x60, 0},
+	{0x1AF, 0x47, 0},
+	{0x1B0, 0x47, 0},
+	{0x1B1, 0, 0},
+	{0x1B2, 0, 0},
+	{0x1B3, 0, 0},
+	{0x1B4, 0, 0},
+	{0x1B5, 0, 0},
+	{0x1B6, 0, 0},
+	{0x1B7, 0x5, 1},
+	{0x1B8, 0, 0},
+	{0x1B9, 0, 0},
+	{0x1BA, 0, 0},
+	{0x1BB, 0, 0},
+	{0x1BC, 0, 0},
+	{0x1BD, 0, 0},
+	{0x1BE, 0, 0},
+	{0x1BF, 0, 0},
+	{0x1C0, 0, 0},
+	{0x1C1, 0, 0},
+	{0x1C2, 0xa0, 1},
+	{0x1C3, 0, 0},
+	{0x1C4, 0, 0},
+	{0x1C5, 0, 0},
+	{0x1C6, 0, 0},
+	{0x1C7, 0, 0},
+	{0x1C8, 0, 0},
+	{0x1C9, 0, 0},
+	{0x1CA, 0, 0},
+	{0xFFFF, 0, 0}
+};
+
+static int16 nphy_def_lnagains[] = { -2, 10, 19, 25 };
+
+static int32 nphy_lnagain_est0[] = { -315, 40370 };
+static int32 nphy_lnagain_est1[] = { -224, 23242 };
+
+static const uint16 tbl_iqcal_gainparams_nphy[2][NPHY_IQCAL_NUMGAINS][8] = {
+	{
+	 {0x000, 0, 0, 2, 0x69, 0x69, 0x69, 0x69},
+	 {0x700, 7, 0, 0, 0x69, 0x69, 0x69, 0x69},
+	 {0x710, 7, 1, 0, 0x68, 0x68, 0x68, 0x68},
+	 {0x720, 7, 2, 0, 0x67, 0x67, 0x67, 0x67},
+	 {0x730, 7, 3, 0, 0x66, 0x66, 0x66, 0x66},
+	 {0x740, 7, 4, 0, 0x65, 0x65, 0x65, 0x65},
+	 {0x741, 7, 4, 1, 0x65, 0x65, 0x65, 0x65},
+	 {0x742, 7, 4, 2, 0x65, 0x65, 0x65, 0x65},
+	 {0x743, 7, 4, 3, 0x65, 0x65, 0x65, 0x65}
+	 },
+	{
+	 {0x000, 7, 0, 0, 0x79, 0x79, 0x79, 0x79},
+	 {0x700, 7, 0, 0, 0x79, 0x79, 0x79, 0x79},
+	 {0x710, 7, 1, 0, 0x79, 0x79, 0x79, 0x79},
+	 {0x720, 7, 2, 0, 0x78, 0x78, 0x78, 0x78},
+	 {0x730, 7, 3, 0, 0x78, 0x78, 0x78, 0x78},
+	 {0x740, 7, 4, 0, 0x78, 0x78, 0x78, 0x78},
+	 {0x741, 7, 4, 1, 0x78, 0x78, 0x78, 0x78},
+	 {0x742, 7, 4, 2, 0x78, 0x78, 0x78, 0x78},
+	 {0x743, 7, 4, 3, 0x78, 0x78, 0x78, 0x78}
+	 }
+};
+
+static const uint32 nphy_tpc_txgain[] = {
+	0x03cc2b44, 0x03cc2b42, 0x03cc2a44, 0x03cc2a42,
+	0x03cc2944, 0x03c82b44, 0x03c82b42, 0x03c82a44,
+	0x03c82a42, 0x03c82944, 0x03c82942, 0x03c82844,
+	0x03c82842, 0x03c42b44, 0x03c42b42, 0x03c42a44,
+	0x03c42a42, 0x03c42944, 0x03c42942, 0x03c42844,
+	0x03c42842, 0x03c42744, 0x03c42742, 0x03c42644,
+	0x03c42642, 0x03c42544, 0x03c42542, 0x03c42444,
+	0x03c42442, 0x03c02b44, 0x03c02b42, 0x03c02a44,
+	0x03c02a42, 0x03c02944, 0x03c02942, 0x03c02844,
+	0x03c02842, 0x03c02744, 0x03c02742, 0x03b02b44,
+	0x03b02b42, 0x03b02a44, 0x03b02a42, 0x03b02944,
+	0x03b02942, 0x03b02844, 0x03b02842, 0x03b02744,
+	0x03b02742, 0x03b02644, 0x03b02642, 0x03b02544,
+	0x03b02542, 0x03a02b44, 0x03a02b42, 0x03a02a44,
+	0x03a02a42, 0x03a02944, 0x03a02942, 0x03a02844,
+	0x03a02842, 0x03a02744, 0x03a02742, 0x03902b44,
+	0x03902b42, 0x03902a44, 0x03902a42, 0x03902944,
+	0x03902942, 0x03902844, 0x03902842, 0x03902744,
+	0x03902742, 0x03902644, 0x03902642, 0x03902544,
+	0x03902542, 0x03802b44, 0x03802b42, 0x03802a44,
+	0x03802a42, 0x03802944, 0x03802942, 0x03802844,
+	0x03802842, 0x03802744, 0x03802742, 0x03802644,
+	0x03802642, 0x03802544, 0x03802542, 0x03802444,
+	0x03802442, 0x03802344, 0x03802342, 0x03802244,
+	0x03802242, 0x03802144, 0x03802142, 0x03802044,
+	0x03802042, 0x03801f44, 0x03801f42, 0x03801e44,
+	0x03801e42, 0x03801d44, 0x03801d42, 0x03801c44,
+	0x03801c42, 0x03801b44, 0x03801b42, 0x03801a44,
+	0x03801a42, 0x03801944, 0x03801942, 0x03801844,
+	0x03801842, 0x03801744, 0x03801742, 0x03801644,
+	0x03801642, 0x03801544, 0x03801542, 0x03801444,
+	0x03801442, 0x03801344, 0x03801342, 0x00002b00
+};
+
+static const uint16 nphy_tpc_loscale[] = {
+	256, 256, 271, 271, 287, 256, 256, 271,
+	271, 287, 287, 304, 304, 256, 256, 271,
+	271, 287, 287, 304, 304, 322, 322, 341,
+	341, 362, 362, 383, 383, 256, 256, 271,
+	271, 287, 287, 304, 304, 322, 322, 256,
+	256, 271, 271, 287, 287, 304, 304, 322,
+	322, 341, 341, 362, 362, 256, 256, 271,
+	271, 287, 287, 304, 304, 322, 322, 256,
+	256, 271, 271, 287, 287, 304, 304, 322,
+	322, 341, 341, 362, 362, 256, 256, 271,
+	271, 287, 287, 304, 304, 322, 322, 341,
+	341, 362, 362, 383, 383, 406, 406, 430,
+	430, 455, 455, 482, 482, 511, 511, 541,
+	541, 573, 573, 607, 607, 643, 643, 681,
+	681, 722, 722, 764, 764, 810, 810, 858,
+	858, 908, 908, 962, 962, 1019, 1019, 256
+};
+
+static uint32 nphy_tpc_txgain_ipa[] = {
+	0x5ff7002d, 0x5ff7002b, 0x5ff7002a, 0x5ff70029,
+	0x5ff70028, 0x5ff70027, 0x5ff70026, 0x5ff70025,
+	0x5ef7002d, 0x5ef7002b, 0x5ef7002a, 0x5ef70029,
+	0x5ef70028, 0x5ef70027, 0x5ef70026, 0x5ef70025,
+	0x5df7002d, 0x5df7002b, 0x5df7002a, 0x5df70029,
+	0x5df70028, 0x5df70027, 0x5df70026, 0x5df70025,
+	0x5cf7002d, 0x5cf7002b, 0x5cf7002a, 0x5cf70029,
+	0x5cf70028, 0x5cf70027, 0x5cf70026, 0x5cf70025,
+	0x5bf7002d, 0x5bf7002b, 0x5bf7002a, 0x5bf70029,
+	0x5bf70028, 0x5bf70027, 0x5bf70026, 0x5bf70025,
+	0x5af7002d, 0x5af7002b, 0x5af7002a, 0x5af70029,
+	0x5af70028, 0x5af70027, 0x5af70026, 0x5af70025,
+	0x59f7002d, 0x59f7002b, 0x59f7002a, 0x59f70029,
+	0x59f70028, 0x59f70027, 0x59f70026, 0x59f70025,
+	0x58f7002d, 0x58f7002b, 0x58f7002a, 0x58f70029,
+	0x58f70028, 0x58f70027, 0x58f70026, 0x58f70025,
+	0x57f7002d, 0x57f7002b, 0x57f7002a, 0x57f70029,
+	0x57f70028, 0x57f70027, 0x57f70026, 0x57f70025,
+	0x56f7002d, 0x56f7002b, 0x56f7002a, 0x56f70029,
+	0x56f70028, 0x56f70027, 0x56f70026, 0x56f70025,
+	0x55f7002d, 0x55f7002b, 0x55f7002a, 0x55f70029,
+	0x55f70028, 0x55f70027, 0x55f70026, 0x55f70025,
+	0x54f7002d, 0x54f7002b, 0x54f7002a, 0x54f70029,
+	0x54f70028, 0x54f70027, 0x54f70026, 0x54f70025,
+	0x53f7002d, 0x53f7002b, 0x53f7002a, 0x53f70029,
+	0x53f70028, 0x53f70027, 0x53f70026, 0x53f70025,
+	0x52f7002d, 0x52f7002b, 0x52f7002a, 0x52f70029,
+	0x52f70028, 0x52f70027, 0x52f70026, 0x52f70025,
+	0x51f7002d, 0x51f7002b, 0x51f7002a, 0x51f70029,
+	0x51f70028, 0x51f70027, 0x51f70026, 0x51f70025,
+	0x50f7002d, 0x50f7002b, 0x50f7002a, 0x50f70029,
+	0x50f70028, 0x50f70027, 0x50f70026, 0x50f70025
+};
+
+static uint32 nphy_tpc_txgain_ipa_rev5[] = {
+	0x1ff7002d, 0x1ff7002b, 0x1ff7002a, 0x1ff70029,
+	0x1ff70028, 0x1ff70027, 0x1ff70026, 0x1ff70025,
+	0x1ef7002d, 0x1ef7002b, 0x1ef7002a, 0x1ef70029,
+	0x1ef70028, 0x1ef70027, 0x1ef70026, 0x1ef70025,
+	0x1df7002d, 0x1df7002b, 0x1df7002a, 0x1df70029,
+	0x1df70028, 0x1df70027, 0x1df70026, 0x1df70025,
+	0x1cf7002d, 0x1cf7002b, 0x1cf7002a, 0x1cf70029,
+	0x1cf70028, 0x1cf70027, 0x1cf70026, 0x1cf70025,
+	0x1bf7002d, 0x1bf7002b, 0x1bf7002a, 0x1bf70029,
+	0x1bf70028, 0x1bf70027, 0x1bf70026, 0x1bf70025,
+	0x1af7002d, 0x1af7002b, 0x1af7002a, 0x1af70029,
+	0x1af70028, 0x1af70027, 0x1af70026, 0x1af70025,
+	0x19f7002d, 0x19f7002b, 0x19f7002a, 0x19f70029,
+	0x19f70028, 0x19f70027, 0x19f70026, 0x19f70025,
+	0x18f7002d, 0x18f7002b, 0x18f7002a, 0x18f70029,
+	0x18f70028, 0x18f70027, 0x18f70026, 0x18f70025,
+	0x17f7002d, 0x17f7002b, 0x17f7002a, 0x17f70029,
+	0x17f70028, 0x17f70027, 0x17f70026, 0x17f70025,
+	0x16f7002d, 0x16f7002b, 0x16f7002a, 0x16f70029,
+	0x16f70028, 0x16f70027, 0x16f70026, 0x16f70025,
+	0x15f7002d, 0x15f7002b, 0x15f7002a, 0x15f70029,
+	0x15f70028, 0x15f70027, 0x15f70026, 0x15f70025,
+	0x14f7002d, 0x14f7002b, 0x14f7002a, 0x14f70029,
+	0x14f70028, 0x14f70027, 0x14f70026, 0x14f70025,
+	0x13f7002d, 0x13f7002b, 0x13f7002a, 0x13f70029,
+	0x13f70028, 0x13f70027, 0x13f70026, 0x13f70025,
+	0x12f7002d, 0x12f7002b, 0x12f7002a, 0x12f70029,
+	0x12f70028, 0x12f70027, 0x12f70026, 0x12f70025,
+	0x11f7002d, 0x11f7002b, 0x11f7002a, 0x11f70029,
+	0x11f70028, 0x11f70027, 0x11f70026, 0x11f70025,
+	0x10f7002d, 0x10f7002b, 0x10f7002a, 0x10f70029,
+	0x10f70028, 0x10f70027, 0x10f70026, 0x10f70025
+};
+
+static uint32 nphy_tpc_txgain_ipa_rev6[] = {
+	0x0ff7002d, 0x0ff7002b, 0x0ff7002a, 0x0ff70029,
+	0x0ff70028, 0x0ff70027, 0x0ff70026, 0x0ff70025,
+	0x0ef7002d, 0x0ef7002b, 0x0ef7002a, 0x0ef70029,
+	0x0ef70028, 0x0ef70027, 0x0ef70026, 0x0ef70025,
+	0x0df7002d, 0x0df7002b, 0x0df7002a, 0x0df70029,
+	0x0df70028, 0x0df70027, 0x0df70026, 0x0df70025,
+	0x0cf7002d, 0x0cf7002b, 0x0cf7002a, 0x0cf70029,
+	0x0cf70028, 0x0cf70027, 0x0cf70026, 0x0cf70025,
+	0x0bf7002d, 0x0bf7002b, 0x0bf7002a, 0x0bf70029,
+	0x0bf70028, 0x0bf70027, 0x0bf70026, 0x0bf70025,
+	0x0af7002d, 0x0af7002b, 0x0af7002a, 0x0af70029,
+	0x0af70028, 0x0af70027, 0x0af70026, 0x0af70025,
+	0x09f7002d, 0x09f7002b, 0x09f7002a, 0x09f70029,
+	0x09f70028, 0x09f70027, 0x09f70026, 0x09f70025,
+	0x08f7002d, 0x08f7002b, 0x08f7002a, 0x08f70029,
+	0x08f70028, 0x08f70027, 0x08f70026, 0x08f70025,
+	0x07f7002d, 0x07f7002b, 0x07f7002a, 0x07f70029,
+	0x07f70028, 0x07f70027, 0x07f70026, 0x07f70025,
+	0x06f7002d, 0x06f7002b, 0x06f7002a, 0x06f70029,
+	0x06f70028, 0x06f70027, 0x06f70026, 0x06f70025,
+	0x05f7002d, 0x05f7002b, 0x05f7002a, 0x05f70029,
+	0x05f70028, 0x05f70027, 0x05f70026, 0x05f70025,
+	0x04f7002d, 0x04f7002b, 0x04f7002a, 0x04f70029,
+	0x04f70028, 0x04f70027, 0x04f70026, 0x04f70025,
+	0x03f7002d, 0x03f7002b, 0x03f7002a, 0x03f70029,
+	0x03f70028, 0x03f70027, 0x03f70026, 0x03f70025,
+	0x02f7002d, 0x02f7002b, 0x02f7002a, 0x02f70029,
+	0x02f70028, 0x02f70027, 0x02f70026, 0x02f70025,
+	0x01f7002d, 0x01f7002b, 0x01f7002a, 0x01f70029,
+	0x01f70028, 0x01f70027, 0x01f70026, 0x01f70025,
+	0x00f7002d, 0x00f7002b, 0x00f7002a, 0x00f70029,
+	0x00f70028, 0x00f70027, 0x00f70026, 0x00f70025
+};
+
+static uint32 nphy_tpc_txgain_ipa_2g_2057rev3[] = {
+	0x70ff0040, 0x70f7003e, 0x70ef003b, 0x70e70039,
+	0x70df0037, 0x70d70036, 0x70cf0033, 0x70c70032,
+	0x70bf0031, 0x70b7002f, 0x70af002e, 0x70a7002d,
+	0x709f002d, 0x7097002c, 0x708f002c, 0x7087002c,
+	0x707f002b, 0x7077002c, 0x706f002c, 0x7067002d,
+	0x705f002e, 0x705f002b, 0x705f0029, 0x7057002a,
+	0x70570028, 0x704f002a, 0x7047002c, 0x7047002a,
+	0x70470028, 0x70470026, 0x70470024, 0x70470022,
+	0x7047001f, 0x70370027, 0x70370024, 0x70370022,
+	0x70370020, 0x7037001f, 0x7037001d, 0x7037001b,
+	0x7037001a, 0x70370018, 0x70370017, 0x7027001e,
+	0x7027001d, 0x7027001a, 0x701f0024, 0x701f0022,
+	0x701f0020, 0x701f001f, 0x701f001d, 0x701f001b,
+	0x701f001a, 0x701f0018, 0x701f0017, 0x701f0015,
+	0x701f0014, 0x701f0013, 0x701f0012, 0x701f0011,
+	0x70170019, 0x70170018, 0x70170016, 0x70170015,
+	0x70170014, 0x70170013, 0x70170012, 0x70170010,
+	0x70170010, 0x7017000f, 0x700f001d, 0x700f001b,
+	0x700f001a, 0x700f0018, 0x700f0017, 0x700f0015,
+	0x700f0015, 0x700f0013, 0x700f0013, 0x700f0011,
+	0x700f0010, 0x700f0010, 0x700f000f, 0x700f000e,
+	0x700f000d, 0x700f000c, 0x700f000b, 0x700f000b,
+	0x700f000b, 0x700f000a, 0x700f0009, 0x700f0009,
+	0x700f0009, 0x700f0008, 0x700f0007, 0x700f0007,
+	0x700f0006, 0x700f0006, 0x700f0006, 0x700f0006,
+	0x700f0005, 0x700f0005, 0x700f0005, 0x700f0004,
+	0x700f0004, 0x700f0004, 0x700f0004, 0x700f0004,
+	0x700f0004, 0x700f0003, 0x700f0003, 0x700f0003,
+	0x700f0003, 0x700f0002, 0x700f0002, 0x700f0002,
+	0x700f0002, 0x700f0002, 0x700f0002, 0x700f0001,
+	0x700f0001, 0x700f0001, 0x700f0001, 0x700f0001,
+	0x700f0001, 0x700f0001, 0x700f0001, 0x700f0001
+};
+
+static uint32 nphy_tpc_txgain_ipa_2g_2057rev4n6[] = {
+	0xf0ff0040, 0xf0f7003e, 0xf0ef003b, 0xf0e70039,
+	0xf0df0037, 0xf0d70036, 0xf0cf0033, 0xf0c70032,
+	0xf0bf0031, 0xf0b7002f, 0xf0af002e, 0xf0a7002d,
+	0xf09f002d, 0xf097002c, 0xf08f002c, 0xf087002c,
+	0xf07f002b, 0xf077002c, 0xf06f002c, 0xf067002d,
+	0xf05f002e, 0xf05f002b, 0xf05f0029, 0xf057002a,
+	0xf0570028, 0xf04f002a, 0xf047002c, 0xf047002a,
+	0xf0470028, 0xf0470026, 0xf0470024, 0xf0470022,
+	0xf047001f, 0xf0370027, 0xf0370024, 0xf0370022,
+	0xf0370020, 0xf037001f, 0xf037001d, 0xf037001b,
+	0xf037001a, 0xf0370018, 0xf0370017, 0xf027001e,
+	0xf027001d, 0xf027001a, 0xf01f0024, 0xf01f0022,
+	0xf01f0020, 0xf01f001f, 0xf01f001d, 0xf01f001b,
+	0xf01f001a, 0xf01f0018, 0xf01f0017, 0xf01f0015,
+	0xf01f0014, 0xf01f0013, 0xf01f0012, 0xf01f0011,
+	0xf0170019, 0xf0170018, 0xf0170016, 0xf0170015,
+	0xf0170014, 0xf0170013, 0xf0170012, 0xf0170010,
+	0xf0170010, 0xf017000f, 0xf00f001d, 0xf00f001b,
+	0xf00f001a, 0xf00f0018, 0xf00f0017, 0xf00f0015,
+	0xf00f0015, 0xf00f0013, 0xf00f0013, 0xf00f0011,
+	0xf00f0010, 0xf00f0010, 0xf00f000f, 0xf00f000e,
+	0xf00f000d, 0xf00f000c, 0xf00f000b, 0xf00f000b,
+	0xf00f000b, 0xf00f000a, 0xf00f0009, 0xf00f0009,
+	0xf00f0009, 0xf00f0008, 0xf00f0007, 0xf00f0007,
+	0xf00f0006, 0xf00f0006, 0xf00f0006, 0xf00f0006,
+	0xf00f0005, 0xf00f0005, 0xf00f0005, 0xf00f0004,
+	0xf00f0004, 0xf00f0004, 0xf00f0004, 0xf00f0004,
+	0xf00f0004, 0xf00f0003, 0xf00f0003, 0xf00f0003,
+	0xf00f0003, 0xf00f0002, 0xf00f0002, 0xf00f0002,
+	0xf00f0002, 0xf00f0002, 0xf00f0002, 0xf00f0001,
+	0xf00f0001, 0xf00f0001, 0xf00f0001, 0xf00f0001,
+	0xf00f0001, 0xf00f0001, 0xf00f0001, 0xf00f0001
+};
+
+static uint32 nphy_tpc_txgain_ipa_2g_2057rev5[] = {
+	0x30ff0031, 0x30e70031, 0x30e7002e, 0x30cf002e,
+	0x30bf002e, 0x30af002e, 0x309f002f, 0x307f0033,
+	0x307f0031, 0x307f002e, 0x3077002e, 0x306f002e,
+	0x3067002e, 0x305f002f, 0x30570030, 0x3057002d,
+	0x304f002e, 0x30470031, 0x3047002e, 0x3047002c,
+	0x30470029, 0x303f002c, 0x303f0029, 0x3037002d,
+	0x3037002a, 0x30370028, 0x302f002c, 0x302f002a,
+	0x302f0028, 0x302f0026, 0x3027002c, 0x30270029,
+	0x30270027, 0x30270025, 0x30270023, 0x301f002c,
+	0x301f002a, 0x301f0028, 0x301f0025, 0x301f0024,
+	0x301f0022, 0x301f001f, 0x3017002d, 0x3017002b,
+	0x30170028, 0x30170026, 0x30170024, 0x30170022,
+	0x30170020, 0x3017001e, 0x3017001d, 0x3017001b,
+	0x3017001a, 0x30170018, 0x30170017, 0x30170015,
+	0x300f002c, 0x300f0029, 0x300f0027, 0x300f0024,
+	0x300f0022, 0x300f0021, 0x300f001f, 0x300f001d,
+	0x300f001b, 0x300f001a, 0x300f0018, 0x300f0017,
+	0x300f0016, 0x300f0015, 0x300f0115, 0x300f0215,
+	0x300f0315, 0x300f0415, 0x300f0515, 0x300f0615,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715
+};
+
+static uint32 nphy_tpc_txgain_ipa_2g_2057rev7[] = {
+	0x30ff0031, 0x30e70031, 0x30e7002e, 0x30cf002e,
+	0x30bf002e, 0x30af002e, 0x309f002f, 0x307f0033,
+	0x307f0031, 0x307f002e, 0x3077002e, 0x306f002e,
+	0x3067002e, 0x305f002f, 0x30570030, 0x3057002d,
+	0x304f002e, 0x30470031, 0x3047002e, 0x3047002c,
+	0x30470029, 0x303f002c, 0x303f0029, 0x3037002d,
+	0x3037002a, 0x30370028, 0x302f002c, 0x302f002a,
+	0x302f0028, 0x302f0026, 0x3027002c, 0x30270029,
+	0x30270027, 0x30270025, 0x30270023, 0x301f002c,
+	0x301f002a, 0x301f0028, 0x301f0025, 0x301f0024,
+	0x301f0022, 0x301f001f, 0x3017002d, 0x3017002b,
+	0x30170028, 0x30170026, 0x30170024, 0x30170022,
+	0x30170020, 0x3017001e, 0x3017001d, 0x3017001b,
+	0x3017001a, 0x30170018, 0x30170017, 0x30170015,
+	0x300f002c, 0x300f0029, 0x300f0027, 0x300f0024,
+	0x300f0022, 0x300f0021, 0x300f001f, 0x300f001d,
+	0x300f001b, 0x300f001a, 0x300f0018, 0x300f0017,
+	0x300f0016, 0x300f0015, 0x300f0115, 0x300f0215,
+	0x300f0315, 0x300f0415, 0x300f0515, 0x300f0615,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715,
+	0x300f0715, 0x300f0715, 0x300f0715, 0x300f0715
+};
+
+static uint32 nphy_tpc_txgain_ipa_5g[] = {
+	0x7ff70035, 0x7ff70033, 0x7ff70032, 0x7ff70031,
+	0x7ff7002f, 0x7ff7002e, 0x7ff7002d, 0x7ff7002b,
+	0x7ff7002a, 0x7ff70029, 0x7ff70028, 0x7ff70027,
+	0x7ff70026, 0x7ff70024, 0x7ff70023, 0x7ff70022,
+	0x7ef70028, 0x7ef70027, 0x7ef70026, 0x7ef70025,
+	0x7ef70024, 0x7ef70023, 0x7df70028, 0x7df70027,
+	0x7df70026, 0x7df70025, 0x7df70024, 0x7df70023,
+	0x7df70022, 0x7cf70029, 0x7cf70028, 0x7cf70027,
+	0x7cf70026, 0x7cf70025, 0x7cf70023, 0x7cf70022,
+	0x7bf70029, 0x7bf70028, 0x7bf70026, 0x7bf70025,
+	0x7bf70024, 0x7bf70023, 0x7bf70022, 0x7bf70021,
+	0x7af70029, 0x7af70028, 0x7af70027, 0x7af70026,
+	0x7af70025, 0x7af70024, 0x7af70023, 0x7af70022,
+	0x79f70029, 0x79f70028, 0x79f70027, 0x79f70026,
+	0x79f70025, 0x79f70024, 0x79f70023, 0x79f70022,
+	0x78f70029, 0x78f70028, 0x78f70027, 0x78f70026,
+	0x78f70025, 0x78f70024, 0x78f70023, 0x78f70022,
+	0x77f70029, 0x77f70028, 0x77f70027, 0x77f70026,
+	0x77f70025, 0x77f70024, 0x77f70023, 0x77f70022,
+	0x76f70029, 0x76f70028, 0x76f70027, 0x76f70026,
+	0x76f70024, 0x76f70023, 0x76f70022, 0x76f70021,
+	0x75f70029, 0x75f70028, 0x75f70027, 0x75f70026,
+	0x75f70025, 0x75f70024, 0x75f70023, 0x74f70029,
+	0x74f70028, 0x74f70026, 0x74f70025, 0x74f70024,
+	0x74f70023, 0x74f70022, 0x73f70029, 0x73f70027,
+	0x73f70026, 0x73f70025, 0x73f70024, 0x73f70023,
+	0x73f70022, 0x72f70028, 0x72f70027, 0x72f70026,
+	0x72f70025, 0x72f70024, 0x72f70023, 0x72f70022,
+	0x71f70028, 0x71f70027, 0x71f70026, 0x71f70025,
+	0x71f70024, 0x71f70023, 0x70f70028, 0x70f70027,
+	0x70f70026, 0x70f70024, 0x70f70023, 0x70f70022,
+	0x70f70021, 0x70f70020, 0x70f70020, 0x70f7001f
+};
+
+static uint32 nphy_tpc_txgain_ipa_5g_2057[] = {
+	0x7f7f0044, 0x7f7f0040, 0x7f7f003c, 0x7f7f0039,
+	0x7f7f0036, 0x7e7f003c, 0x7e7f0038, 0x7e7f0035,
+	0x7d7f003c, 0x7d7f0039, 0x7d7f0036, 0x7d7f0033,
+	0x7c7f003b, 0x7c7f0037, 0x7c7f0034, 0x7b7f003a,
+	0x7b7f0036, 0x7b7f0033, 0x7a7f003c, 0x7a7f0039,
+	0x7a7f0036, 0x7a7f0033, 0x797f003b, 0x797f0038,
+	0x797f0035, 0x797f0032, 0x787f003b, 0x787f0038,
+	0x787f0035, 0x787f0032, 0x777f003a, 0x777f0037,
+	0x777f0034, 0x777f0031, 0x767f003a, 0x767f0036,
+	0x767f0033, 0x767f0031, 0x757f003a, 0x757f0037,
+	0x757f0034, 0x747f003c, 0x747f0039, 0x747f0036,
+	0x747f0033, 0x737f003b, 0x737f0038, 0x737f0035,
+	0x737f0032, 0x727f0039, 0x727f0036, 0x727f0033,
+	0x727f0030, 0x717f003a, 0x717f0037, 0x717f0034,
+	0x707f003b, 0x707f0038, 0x707f0035, 0x707f0032,
+	0x707f002f, 0x707f002d, 0x707f002a, 0x707f0028,
+	0x707f0025, 0x707f0023, 0x707f0021, 0x707f0020,
+	0x707f001e, 0x707f001c, 0x707f001b, 0x707f0019,
+	0x707f0018, 0x707f0016, 0x707f0015, 0x707f0014,
+	0x707f0013, 0x707f0012, 0x707f0011, 0x707f0010,
+	0x707f000f, 0x707f000e, 0x707f000d, 0x707f000d,
+	0x707f000c, 0x707f000b, 0x707f000b, 0x707f000a,
+	0x707f0009, 0x707f0009, 0x707f0008, 0x707f0008,
+	0x707f0007, 0x707f0007, 0x707f0007, 0x707f0006,
+	0x707f0006, 0x707f0006, 0x707f0005, 0x707f0005,
+	0x707f0005, 0x707f0004, 0x707f0004, 0x707f0004,
+	0x707f0004, 0x707f0004, 0x707f0003, 0x707f0003,
+	0x707f0003, 0x707f0003, 0x707f0003, 0x707f0003,
+	0x707f0002, 0x707f0002, 0x707f0002, 0x707f0002,
+	0x707f0002, 0x707f0002, 0x707f0002, 0x707f0002,
+	0x707f0001, 0x707f0001, 0x707f0001, 0x707f0001,
+	0x707f0001, 0x707f0001, 0x707f0001, 0x707f0001
+};
+
+static uint32 nphy_tpc_txgain_ipa_5g_2057rev7[] = {
+	0x6f7f0031, 0x6f7f002e, 0x6f7f002c, 0x6f7f002a,
+	0x6f7f0027, 0x6e7f002e, 0x6e7f002c, 0x6e7f002a,
+	0x6d7f0030, 0x6d7f002d, 0x6d7f002a, 0x6d7f0028,
+	0x6c7f0030, 0x6c7f002d, 0x6c7f002b, 0x6b7f002e,
+	0x6b7f002c, 0x6b7f002a, 0x6b7f0027, 0x6a7f002e,
+	0x6a7f002c, 0x6a7f002a, 0x697f0030, 0x697f002e,
+	0x697f002b, 0x697f0029, 0x687f002f, 0x687f002d,
+	0x687f002a, 0x687f0027, 0x677f002f, 0x677f002d,
+	0x677f002a, 0x667f0031, 0x667f002e, 0x667f002c,
+	0x667f002a, 0x657f0030, 0x657f002e, 0x657f002b,
+	0x657f0029, 0x647f0030, 0x647f002d, 0x647f002b,
+	0x647f0029, 0x637f002f, 0x637f002d, 0x637f002a,
+	0x627f0030, 0x627f002d, 0x627f002b, 0x627f0029,
+	0x617f0030, 0x617f002e, 0x617f002b, 0x617f0029,
+	0x607f002f, 0x607f002d, 0x607f002a, 0x607f0027,
+	0x607f0026, 0x607f0023, 0x607f0021, 0x607f0020,
+	0x607f001e, 0x607f001c, 0x607f001a, 0x607f0019,
+	0x607f0018, 0x607f0016, 0x607f0015, 0x607f0014,
+	0x607f0012, 0x607f0012, 0x607f0011, 0x607f000f,
+	0x607f000f, 0x607f000e, 0x607f000d, 0x607f000c,
+	0x607f000c, 0x607f000b, 0x607f000b, 0x607f000a,
+	0x607f0009, 0x607f0009, 0x607f0008, 0x607f0008,
+	0x607f0008, 0x607f0007, 0x607f0007, 0x607f0006,
+	0x607f0006, 0x607f0005, 0x607f0005, 0x607f0005,
+	0x607f0005, 0x607f0005, 0x607f0004, 0x607f0004,
+	0x607f0004, 0x607f0004, 0x607f0003, 0x607f0003,
+	0x607f0003, 0x607f0003, 0x607f0002, 0x607f0002,
+	0x607f0002, 0x607f0002, 0x607f0002, 0x607f0002,
+	0x607f0002, 0x607f0002, 0x607f0002, 0x607f0002,
+	0x607f0002, 0x607f0002, 0x607f0002, 0x607f0002,
+	0x607f0002, 0x607f0001, 0x607f0001, 0x607f0001,
+	0x607f0001, 0x607f0001, 0x607f0001, 0x607f0001
+};
+
+static int8 nphy_papd_pga_gain_delta_ipa_2g[] = {
+	-114, -108, -98, -91, -84, -78, -70, -62,
+	-54, -46, -39, -31, -23, -15, -8, 0
+};
+
+static int8 nphy_papd_pga_gain_delta_ipa_5g[] = {
+	-100, -95, -89, -83, -77, -70, -63, -56,
+	-48, -41, -33, -25, -19, -12, -6, 0
+};
+
+static int16 nphy_papd_padgain_dlt_2g_2057rev3n4[] = {
+	-159, -113, -86, -72, -62, -54, -48, -43,
+	-39, -35, -31, -28, -25, -23, -20, -18,
+	-17, -15, -13, -11, -10, -8, -7, -6,
+	-5, -4, -3, -3, -2, -1, -1, 0
+};
+
+static int16 nphy_papd_padgain_dlt_2g_2057rev5[] = {
+	-109, -109, -82, -68, -58, -50, -44, -39,
+	-35, -31, -28, -26, -23, -21, -19, -17,
+	-16, -14, -13, -11, -10, -9, -8, -7,
+	-5, -5, -4, -3, -2, -1, -1, 0
+};
+
+static int16 nphy_papd_padgain_dlt_2g_2057rev7[] = {
+	-122, -122, -95, -80, -69, -61, -54, -49,
+	-43, -39, -35, -32, -28, -26, -23, -21,
+	-18, -16, -15, -13, -11, -10, -8, -7,
+	-6, -5, -4, -3, -2, -1, -1, 0
+};
+
+static int8 nphy_papd_pgagain_dlt_5g_2057[] = {
+	-107, -101, -92, -85, -78, -71, -62, -55,
+	-47, -39, -32, -24, -19, -12, -6, 0
+};
+
+static int8 nphy_papd_pgagain_dlt_5g_2057rev7[] = {
+	-110, -104, -95, -88, -81, -74, -66, -58,
+	-50, -44, -36, -28, -23, -15, -8, 0
+};
+
+static uint8 pad_gain_codes_used_2057rev5[] = {
+	20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
+	10, 9, 8, 7, 6, 5, 4, 3, 2, 1
+};
+
+static uint8 pad_gain_codes_used_2057rev7[] = {
+	15, 14, 13, 12, 11, 10, 9, 8, 7, 6,
+	5, 4, 3, 2, 1
+};
+
+static uint8 pad_all_gain_codes_2057[] = {
+	31, 30, 29, 28, 27, 26, 25, 24, 23, 22,
+	21, 20, 19, 18, 17, 16, 15, 14, 13, 12,
+	11, 10, 9, 8, 7, 6, 5, 4, 3, 2,
+	1, 0
+};
+
+static uint8 pga_all_gain_codes_2057[] = {
+	15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+};
+
+static uint32 nphy_papd_scaltbl[] = {
+	0x0ae2002f, 0x0a3b0032, 0x09a70035, 0x09220038,
+	0x0887003c, 0x081f003f, 0x07a20043, 0x07340047,
+	0x06d2004b, 0x067a004f, 0x06170054, 0x05bf0059,
+	0x0571005e, 0x051e0064, 0x04d3006a, 0x04910070,
+	0x044c0077, 0x040f007e, 0x03d90085, 0x03a1008d,
+	0x036f0095, 0x033d009e, 0x030b00a8, 0x02e000b2,
+	0x02b900bc, 0x029200c7, 0x026d00d3, 0x024900e0,
+	0x022900ed, 0x020a00fb, 0x01ec010a, 0x01d0011a,
+	0x01b7012a, 0x019e013c, 0x0187014f, 0x01720162,
+	0x015d0177, 0x0149018e, 0x013701a5, 0x012601be,
+	0x011501d9, 0x010501f5, 0x00f70212, 0x00e90232,
+	0x00dc0253, 0x00d00276, 0x00c4029c, 0x00b902c3,
+	0x00af02ed, 0x00a5031a, 0x009c0349, 0x0093037a,
+	0x008b03af, 0x008303e7, 0x007c0422, 0x00750461,
+	0x006e04a3, 0x006804ea, 0x00620534, 0x005d0583,
+	0x005805d7, 0x0053062f, 0x004e068d, 0x004a06f1
+};
+
+static uint32 nphy_tpc_txgain_rev3[] = {
+	0x1f410044, 0x1f410042, 0x1f410040, 0x1f41003e,
+	0x1f41003c, 0x1f41003b, 0x1f410039, 0x1f410037,
+	0x1e410044, 0x1e410042, 0x1e410040, 0x1e41003e,
+	0x1e41003c, 0x1e41003b, 0x1e410039, 0x1e410037,
+	0x1d410044, 0x1d410042, 0x1d410040, 0x1d41003e,
+	0x1d41003c, 0x1d41003b, 0x1d410039, 0x1d410037,
+	0x1c410044, 0x1c410042, 0x1c410040, 0x1c41003e,
+	0x1c41003c, 0x1c41003b, 0x1c410039, 0x1c410037,
+	0x1b410044, 0x1b410042, 0x1b410040, 0x1b41003e,
+	0x1b41003c, 0x1b41003b, 0x1b410039, 0x1b410037,
+	0x1a410044, 0x1a410042, 0x1a410040, 0x1a41003e,
+	0x1a41003c, 0x1a41003b, 0x1a410039, 0x1a410037,
+	0x19410044, 0x19410042, 0x19410040, 0x1941003e,
+	0x1941003c, 0x1941003b, 0x19410039, 0x19410037,
+	0x18410044, 0x18410042, 0x18410040, 0x1841003e,
+	0x1841003c, 0x1841003b, 0x18410039, 0x18410037,
+	0x17410044, 0x17410042, 0x17410040, 0x1741003e,
+	0x1741003c, 0x1741003b, 0x17410039, 0x17410037,
+	0x16410044, 0x16410042, 0x16410040, 0x1641003e,
+	0x1641003c, 0x1641003b, 0x16410039, 0x16410037,
+	0x15410044, 0x15410042, 0x15410040, 0x1541003e,
+	0x1541003c, 0x1541003b, 0x15410039, 0x15410037,
+	0x14410044, 0x14410042, 0x14410040, 0x1441003e,
+	0x1441003c, 0x1441003b, 0x14410039, 0x14410037,
+	0x13410044, 0x13410042, 0x13410040, 0x1341003e,
+	0x1341003c, 0x1341003b, 0x13410039, 0x13410037,
+	0x12410044, 0x12410042, 0x12410040, 0x1241003e,
+	0x1241003c, 0x1241003b, 0x12410039, 0x12410037,
+	0x11410044, 0x11410042, 0x11410040, 0x1141003e,
+	0x1141003c, 0x1141003b, 0x11410039, 0x11410037,
+	0x10410044, 0x10410042, 0x10410040, 0x1041003e,
+	0x1041003c, 0x1041003b, 0x10410039, 0x10410037
+};
+
+static uint32 nphy_tpc_txgain_HiPwrEPA[] = {
+	0x0f410044, 0x0f410042, 0x0f410040, 0x0f41003e,
+	0x0f41003c, 0x0f41003b, 0x0f410039, 0x0f410037,
+	0x0e410044, 0x0e410042, 0x0e410040, 0x0e41003e,
+	0x0e41003c, 0x0e41003b, 0x0e410039, 0x0e410037,
+	0x0d410044, 0x0d410042, 0x0d410040, 0x0d41003e,
+	0x0d41003c, 0x0d41003b, 0x0d410039, 0x0d410037,
+	0x0c410044, 0x0c410042, 0x0c410040, 0x0c41003e,
+	0x0c41003c, 0x0c41003b, 0x0c410039, 0x0c410037,
+	0x0b410044, 0x0b410042, 0x0b410040, 0x0b41003e,
+	0x0b41003c, 0x0b41003b, 0x0b410039, 0x0b410037,
+	0x0a410044, 0x0a410042, 0x0a410040, 0x0a41003e,
+	0x0a41003c, 0x0a41003b, 0x0a410039, 0x0a410037,
+	0x09410044, 0x09410042, 0x09410040, 0x0941003e,
+	0x0941003c, 0x0941003b, 0x09410039, 0x09410037,
+	0x08410044, 0x08410042, 0x08410040, 0x0841003e,
+	0x0841003c, 0x0841003b, 0x08410039, 0x08410037,
+	0x07410044, 0x07410042, 0x07410040, 0x0741003e,
+	0x0741003c, 0x0741003b, 0x07410039, 0x07410037,
+	0x06410044, 0x06410042, 0x06410040, 0x0641003e,
+	0x0641003c, 0x0641003b, 0x06410039, 0x06410037,
+	0x05410044, 0x05410042, 0x05410040, 0x0541003e,
+	0x0541003c, 0x0541003b, 0x05410039, 0x05410037,
+	0x04410044, 0x04410042, 0x04410040, 0x0441003e,
+	0x0441003c, 0x0441003b, 0x04410039, 0x04410037,
+	0x03410044, 0x03410042, 0x03410040, 0x0341003e,
+	0x0341003c, 0x0341003b, 0x03410039, 0x03410037,
+	0x02410044, 0x02410042, 0x02410040, 0x0241003e,
+	0x0241003c, 0x0241003b, 0x02410039, 0x02410037,
+	0x01410044, 0x01410042, 0x01410040, 0x0141003e,
+	0x0141003c, 0x0141003b, 0x01410039, 0x01410037,
+	0x00410044, 0x00410042, 0x00410040, 0x0041003e,
+	0x0041003c, 0x0041003b, 0x00410039, 0x00410037
+};
+
+static uint32 nphy_tpc_txgain_epa_2057rev3[] = {
+	0x80f90040, 0x80e10040, 0x80e1003c, 0x80c9003d,
+	0x80b9003c, 0x80a9003d, 0x80a1003c, 0x8099003b,
+	0x8091003b, 0x8089003a, 0x8081003a, 0x80790039,
+	0x80710039, 0x8069003a, 0x8061003b, 0x8059003d,
+	0x8051003f, 0x80490042, 0x8049003e, 0x8049003b,
+	0x8041003e, 0x8041003b, 0x8039003e, 0x8039003b,
+	0x80390038, 0x80390035, 0x8031003a, 0x80310036,
+	0x80310033, 0x8029003a, 0x80290037, 0x80290034,
+	0x80290031, 0x80210039, 0x80210036, 0x80210033,
+	0x80210030, 0x8019003c, 0x80190039, 0x80190036,
+	0x80190033, 0x80190030, 0x8019002d, 0x8019002b,
+	0x80190028, 0x8011003a, 0x80110036, 0x80110033,
+	0x80110030, 0x8011002e, 0x8011002b, 0x80110029,
+	0x80110027, 0x80110024, 0x80110022, 0x80110020,
+	0x8011001f, 0x8011001d, 0x8009003a, 0x80090037,
+	0x80090034, 0x80090031, 0x8009002e, 0x8009002c,
+	0x80090029, 0x80090027, 0x80090025, 0x80090023,
+	0x80090021, 0x8009001f, 0x8009001d, 0x8009011d,
+	0x8009021d, 0x8009031d, 0x8009041d, 0x8009051d,
+	0x8009061d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d,
+	0x8009071d, 0x8009071d, 0x8009071d, 0x8009071d
+};
+
+static uint32 nphy_tpc_txgain_epa_2057rev5[] = {
+	0x10f90040, 0x10e10040, 0x10e1003c, 0x10c9003d,
+	0x10b9003c, 0x10a9003d, 0x10a1003c, 0x1099003b,
+	0x1091003b, 0x1089003a, 0x1081003a, 0x10790039,
+	0x10710039, 0x1069003a, 0x1061003b, 0x1059003d,
+	0x1051003f, 0x10490042, 0x1049003e, 0x1049003b,
+	0x1041003e, 0x1041003b, 0x1039003e, 0x1039003b,
+	0x10390038, 0x10390035, 0x1031003a, 0x10310036,
+	0x10310033, 0x1029003a, 0x10290037, 0x10290034,
+	0x10290031, 0x10210039, 0x10210036, 0x10210033,
+	0x10210030, 0x1019003c, 0x10190039, 0x10190036,
+	0x10190033, 0x10190030, 0x1019002d, 0x1019002b,
+	0x10190028, 0x1011003a, 0x10110036, 0x10110033,
+	0x10110030, 0x1011002e, 0x1011002b, 0x10110029,
+	0x10110027, 0x10110024, 0x10110022, 0x10110020,
+	0x1011001f, 0x1011001d, 0x1009003a, 0x10090037,
+	0x10090034, 0x10090031, 0x1009002e, 0x1009002c,
+	0x10090029, 0x10090027, 0x10090025, 0x10090023,
+	0x10090021, 0x1009001f, 0x1009001d, 0x1009001b,
+	0x1009001a, 0x10090018, 0x10090017, 0x10090016,
+	0x10090015, 0x10090013, 0x10090012, 0x10090011,
+	0x10090010, 0x1009000f, 0x1009000f, 0x1009000e,
+	0x1009000d, 0x1009000c, 0x1009000c, 0x1009000b,
+	0x1009000a, 0x1009000a, 0x10090009, 0x10090009,
+	0x10090008, 0x10090008, 0x10090007, 0x10090007,
+	0x10090007, 0x10090006, 0x10090006, 0x10090005,
+	0x10090005, 0x10090005, 0x10090005, 0x10090004,
+	0x10090004, 0x10090004, 0x10090004, 0x10090003,
+	0x10090003, 0x10090003, 0x10090003, 0x10090003,
+	0x10090003, 0x10090002, 0x10090002, 0x10090002,
+	0x10090002, 0x10090002, 0x10090002, 0x10090002,
+	0x10090002, 0x10090002, 0x10090001, 0x10090001,
+	0x10090001, 0x10090001, 0x10090001, 0x10090001
+};
+
+static uint32 nphy_tpc_5GHz_txgain_rev3[] = {
+	0xcff70044, 0xcff70042, 0xcff70040, 0xcff7003e,
+	0xcff7003c, 0xcff7003b, 0xcff70039, 0xcff70037,
+	0xcef70044, 0xcef70042, 0xcef70040, 0xcef7003e,
+	0xcef7003c, 0xcef7003b, 0xcef70039, 0xcef70037,
+	0xcdf70044, 0xcdf70042, 0xcdf70040, 0xcdf7003e,
+	0xcdf7003c, 0xcdf7003b, 0xcdf70039, 0xcdf70037,
+	0xccf70044, 0xccf70042, 0xccf70040, 0xccf7003e,
+	0xccf7003c, 0xccf7003b, 0xccf70039, 0xccf70037,
+	0xcbf70044, 0xcbf70042, 0xcbf70040, 0xcbf7003e,
+	0xcbf7003c, 0xcbf7003b, 0xcbf70039, 0xcbf70037,
+	0xcaf70044, 0xcaf70042, 0xcaf70040, 0xcaf7003e,
+	0xcaf7003c, 0xcaf7003b, 0xcaf70039, 0xcaf70037,
+	0xc9f70044, 0xc9f70042, 0xc9f70040, 0xc9f7003e,
+	0xc9f7003c, 0xc9f7003b, 0xc9f70039, 0xc9f70037,
+	0xc8f70044, 0xc8f70042, 0xc8f70040, 0xc8f7003e,
+	0xc8f7003c, 0xc8f7003b, 0xc8f70039, 0xc8f70037,
+	0xc7f70044, 0xc7f70042, 0xc7f70040, 0xc7f7003e,
+	0xc7f7003c, 0xc7f7003b, 0xc7f70039, 0xc7f70037,
+	0xc6f70044, 0xc6f70042, 0xc6f70040, 0xc6f7003e,
+	0xc6f7003c, 0xc6f7003b, 0xc6f70039, 0xc6f70037,
+	0xc5f70044, 0xc5f70042, 0xc5f70040, 0xc5f7003e,
+	0xc5f7003c, 0xc5f7003b, 0xc5f70039, 0xc5f70037,
+	0xc4f70044, 0xc4f70042, 0xc4f70040, 0xc4f7003e,
+	0xc4f7003c, 0xc4f7003b, 0xc4f70039, 0xc4f70037,
+	0xc3f70044, 0xc3f70042, 0xc3f70040, 0xc3f7003e,
+	0xc3f7003c, 0xc3f7003b, 0xc3f70039, 0xc3f70037,
+	0xc2f70044, 0xc2f70042, 0xc2f70040, 0xc2f7003e,
+	0xc2f7003c, 0xc2f7003b, 0xc2f70039, 0xc2f70037,
+	0xc1f70044, 0xc1f70042, 0xc1f70040, 0xc1f7003e,
+	0xc1f7003c, 0xc1f7003b, 0xc1f70039, 0xc1f70037,
+	0xc0f70044, 0xc0f70042, 0xc0f70040, 0xc0f7003e,
+	0xc0f7003c, 0xc0f7003b, 0xc0f70039, 0xc0f70037
+};
+
+static uint32 nphy_tpc_5GHz_txgain_rev4[] = {
+	0x2ff20044, 0x2ff20042, 0x2ff20040, 0x2ff2003e,
+	0x2ff2003c, 0x2ff2003b, 0x2ff20039, 0x2ff20037,
+	0x2ef20044, 0x2ef20042, 0x2ef20040, 0x2ef2003e,
+	0x2ef2003c, 0x2ef2003b, 0x2ef20039, 0x2ef20037,
+	0x2df20044, 0x2df20042, 0x2df20040, 0x2df2003e,
+	0x2df2003c, 0x2df2003b, 0x2df20039, 0x2df20037,
+	0x2cf20044, 0x2cf20042, 0x2cf20040, 0x2cf2003e,
+	0x2cf2003c, 0x2cf2003b, 0x2cf20039, 0x2cf20037,
+	0x2bf20044, 0x2bf20042, 0x2bf20040, 0x2bf2003e,
+	0x2bf2003c, 0x2bf2003b, 0x2bf20039, 0x2bf20037,
+	0x2af20044, 0x2af20042, 0x2af20040, 0x2af2003e,
+	0x2af2003c, 0x2af2003b, 0x2af20039, 0x2af20037,
+	0x29f20044, 0x29f20042, 0x29f20040, 0x29f2003e,
+	0x29f2003c, 0x29f2003b, 0x29f20039, 0x29f20037,
+	0x28f20044, 0x28f20042, 0x28f20040, 0x28f2003e,
+	0x28f2003c, 0x28f2003b, 0x28f20039, 0x28f20037,
+	0x27f20044, 0x27f20042, 0x27f20040, 0x27f2003e,
+	0x27f2003c, 0x27f2003b, 0x27f20039, 0x27f20037,
+	0x26f20044, 0x26f20042, 0x26f20040, 0x26f2003e,
+	0x26f2003c, 0x26f2003b, 0x26f20039, 0x26f20037,
+	0x25f20044, 0x25f20042, 0x25f20040, 0x25f2003e,
+	0x25f2003c, 0x25f2003b, 0x25f20039, 0x25f20037,
+	0x24f20044, 0x24f20042, 0x24f20040, 0x24f2003e,
+	0x24f2003c, 0x24f2003b, 0x24f20039, 0x24f20038,
+	0x23f20041, 0x23f20040, 0x23f2003f, 0x23f2003e,
+	0x23f2003c, 0x23f2003b, 0x23f20039, 0x23f20037,
+	0x22f20044, 0x22f20042, 0x22f20040, 0x22f2003e,
+	0x22f2003c, 0x22f2003b, 0x22f20039, 0x22f20037,
+	0x21f20044, 0x21f20042, 0x21f20040, 0x21f2003e,
+	0x21f2003c, 0x21f2003b, 0x21f20039, 0x21f20037,
+	0x20d20043, 0x20d20041, 0x20d2003e, 0x20d2003c,
+	0x20d2003a, 0x20d20038, 0x20d20036, 0x20d20034
+};
+
+static uint32 nphy_tpc_5GHz_txgain_rev5[] = {
+	0x0f62004a, 0x0f620048, 0x0f620046, 0x0f620044,
+	0x0f620042, 0x0f620040, 0x0f62003e, 0x0f62003c,
+	0x0e620044, 0x0e620042, 0x0e620040, 0x0e62003e,
+	0x0e62003c, 0x0e62003d, 0x0e62003b, 0x0e62003a,
+	0x0d620043, 0x0d620041, 0x0d620040, 0x0d62003e,
+	0x0d62003d, 0x0d62003c, 0x0d62003b, 0x0d62003a,
+	0x0c620041, 0x0c620040, 0x0c62003f, 0x0c62003e,
+	0x0c62003c, 0x0c62003b, 0x0c620039, 0x0c620037,
+	0x0b620046, 0x0b620044, 0x0b620042, 0x0b620040,
+	0x0b62003e, 0x0b62003c, 0x0b62003b, 0x0b62003a,
+	0x0a620041, 0x0a620040, 0x0a62003e, 0x0a62003c,
+	0x0a62003b, 0x0a62003a, 0x0a620039, 0x0a620038,
+	0x0962003e, 0x0962003d, 0x0962003c, 0x0962003b,
+	0x09620039, 0x09620037, 0x09620035, 0x09620033,
+	0x08620044, 0x08620042, 0x08620040, 0x0862003e,
+	0x0862003c, 0x0862003b, 0x0862003a, 0x08620039,
+	0x07620043, 0x07620042, 0x07620040, 0x0762003f,
+	0x0762003d, 0x0762003b, 0x0762003a, 0x07620039,
+	0x0662003e, 0x0662003d, 0x0662003c, 0x0662003b,
+	0x06620039, 0x06620037, 0x06620035, 0x06620033,
+	0x05620046, 0x05620044, 0x05620042, 0x05620040,
+	0x0562003e, 0x0562003c, 0x0562003b, 0x05620039,
+	0x04620044, 0x04620042, 0x04620040, 0x0462003e,
+	0x0462003c, 0x0462003b, 0x04620039, 0x04620038,
+	0x0362003c, 0x0362003b, 0x0362003a, 0x03620039,
+	0x03620038, 0x03620037, 0x03620035, 0x03620033,
+	0x0262004c, 0x0262004a, 0x02620048, 0x02620047,
+	0x02620046, 0x02620044, 0x02620043, 0x02620042,
+	0x0162004a, 0x01620048, 0x01620046, 0x01620044,
+	0x01620043, 0x01620042, 0x01620041, 0x01620040,
+	0x00620042, 0x00620040, 0x0062003e, 0x0062003c,
+	0x0062003b, 0x00620039, 0x00620037, 0x00620035
+};
+
+static uint32 nphy_tpc_5GHz_txgain_HiPwrEPA[] = {
+	0x2ff10044, 0x2ff10042, 0x2ff10040, 0x2ff1003e,
+	0x2ff1003c, 0x2ff1003b, 0x2ff10039, 0x2ff10037,
+	0x2ef10044, 0x2ef10042, 0x2ef10040, 0x2ef1003e,
+	0x2ef1003c, 0x2ef1003b, 0x2ef10039, 0x2ef10037,
+	0x2df10044, 0x2df10042, 0x2df10040, 0x2df1003e,
+	0x2df1003c, 0x2df1003b, 0x2df10039, 0x2df10037,
+	0x2cf10044, 0x2cf10042, 0x2cf10040, 0x2cf1003e,
+	0x2cf1003c, 0x2cf1003b, 0x2cf10039, 0x2cf10037,
+	0x2bf10044, 0x2bf10042, 0x2bf10040, 0x2bf1003e,
+	0x2bf1003c, 0x2bf1003b, 0x2bf10039, 0x2bf10037,
+	0x2af10044, 0x2af10042, 0x2af10040, 0x2af1003e,
+	0x2af1003c, 0x2af1003b, 0x2af10039, 0x2af10037,
+	0x29f10044, 0x29f10042, 0x29f10040, 0x29f1003e,
+	0x29f1003c, 0x29f1003b, 0x29f10039, 0x29f10037,
+	0x28f10044, 0x28f10042, 0x28f10040, 0x28f1003e,
+	0x28f1003c, 0x28f1003b, 0x28f10039, 0x28f10037,
+	0x27f10044, 0x27f10042, 0x27f10040, 0x27f1003e,
+	0x27f1003c, 0x27f1003b, 0x27f10039, 0x27f10037,
+	0x26f10044, 0x26f10042, 0x26f10040, 0x26f1003e,
+	0x26f1003c, 0x26f1003b, 0x26f10039, 0x26f10037,
+	0x25f10044, 0x25f10042, 0x25f10040, 0x25f1003e,
+	0x25f1003c, 0x25f1003b, 0x25f10039, 0x25f10037,
+	0x24f10044, 0x24f10042, 0x24f10040, 0x24f1003e,
+	0x24f1003c, 0x24f1003b, 0x24f10039, 0x24f10038,
+	0x23f10041, 0x23f10040, 0x23f1003f, 0x23f1003e,
+	0x23f1003c, 0x23f1003b, 0x23f10039, 0x23f10037,
+	0x22f10044, 0x22f10042, 0x22f10040, 0x22f1003e,
+	0x22f1003c, 0x22f1003b, 0x22f10039, 0x22f10037,
+	0x21f10044, 0x21f10042, 0x21f10040, 0x21f1003e,
+	0x21f1003c, 0x21f1003b, 0x21f10039, 0x21f10037,
+	0x20d10043, 0x20d10041, 0x20d1003e, 0x20d1003c,
+	0x20d1003a, 0x20d10038, 0x20d10036, 0x20d10034
+};
+
+static uint8 ant_sw_ctrl_tbl_rev8_2o3[] = { 0x14, 0x18 };
+static uint8 ant_sw_ctrl_tbl_rev8[] = { 0x4, 0x8, 0x4, 0x8, 0x11, 0x12 };
+static uint8 ant_sw_ctrl_tbl_rev8_2057v7_core0[] =
+    { 0x09, 0x0a, 0x15, 0x16, 0x09, 0x0a };
+static uint8 ant_sw_ctrl_tbl_rev8_2057v7_core1[] =
+    { 0x09, 0x0a, 0x09, 0x0a, 0x15, 0x16 };
+
+static bool wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
+				   chan_info_nphy_radio2057_t ** t0,
+				   chan_info_nphy_radio205x_t ** t1,
+				   chan_info_nphy_radio2057_rev5_t ** t2,
+				   chan_info_nphy_2055_t ** t3);
+static void wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chans,
+					const nphy_sfo_cfg_t * c);
+
+static void wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi,
+					    uint16 reduction_factr);
+static void wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *,
+					     uint32 * buf);
+static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr);
+static void wlc_phy_txlpfbw_nphy(phy_info_t * pi);
+static void wlc_phy_spurwar_nphy(phy_info_t * pi);
+
+static void wlc_phy_radio_preinit_2055(phy_info_t * pi);
+static void wlc_phy_radio_init_2055(phy_info_t * pi);
+static void wlc_phy_radio_postinit_2055(phy_info_t * pi);
+static void wlc_phy_radio_preinit_205x(phy_info_t * pi);
+static void wlc_phy_radio_init_2056(phy_info_t * pi);
+static void wlc_phy_radio_postinit_2056(phy_info_t * pi);
+static void wlc_phy_radio_init_2057(phy_info_t * pi);
+static void wlc_phy_radio_postinit_2057(phy_info_t * pi);
+static void wlc_phy_workarounds_nphy(phy_info_t * pi);
+static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi);
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t * pi);
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi);
+static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi);
+
+static void wlc_phy_restore_rssical_nphy(phy_info_t * pi);
+static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t * pi);
+static void wlc_phy_tx_iq_war_nphy(phy_info_t * pi);
+static int wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t tg,
+				      uint8 type, bool d);
+static void wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rxcore,
+					     uint16 * rg, uint8 type);
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t * pi, int32 preamble);
+static void wlc_phy_savecal_nphy(phy_info_t * pi);
+static void wlc_phy_restorecal_nphy(phy_info_t * pi);
+static void wlc_phy_resetcca_nphy(phy_info_t * pi);
+
+static void wlc_phy_txpwrctrl_config_nphy(phy_info_t * pi);
+static void wlc_phy_internal_cal_txgain_nphy(phy_info_t * pi);
+static void wlc_phy_precal_txgain_nphy(phy_info_t * pi);
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t * pi, uint16 core);
+
+static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t * pi);
+static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t * pi);
+static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t * pi);
+static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t * pi);
+static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t * pi, uint8 m0, uint8 m1);
+static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t * pi);
+
+static void wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32,
+			    uint32 e);
+static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core);
+static void wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t *,
+			    phy_cal_mode_t, uint8);
+static void wlc_phy_papd_cal_cleanup_nphy(phy_info_t * pi,
+					  nphy_papd_restore_state * state);
+static void wlc_phy_papd_cal_setup_nphy(phy_info_t * pi,
+					nphy_papd_restore_state * state, uint8);
+
+static void wlc_phy_clip_det_nphy(phy_info_t * pi, uint8 write, uint16 * vals);
+
+static void wlc_phy_set_rfseq_nphy(phy_info_t * pi, uint8 cmd, uint8 * evts,
+				   uint8 * dlys, uint8 len);
+
+static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset);
+
+static void
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t * pi, uint16 field, uint16 value,
+				  uint8 core_mask, uint8 off,
+				  uint8 override_id);
+
+static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type);
+static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi);
+
+static bool wlc_phy_txpwr_srom_read_nphy(phy_info_t * pi);
+static void wlc_phy_txpwr_nphy_srom_convert(uint8 * srom_max,
+					    uint16 * pwr_offset,
+					    uint8 tmp_max_pwr, uint8 rate_start,
+					    uint8 rate_end);
+
+static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t * pi);
+static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi);
+static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi);
+static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi);
+
+static bool wlc_phy_txpwr_ison_nphy(phy_info_t * pi);
+static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t * pi, uint8 core);
+static void wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t * pi, uint8 idx0,
+					   uint8 idx1);
+static void wlc_phy_a4(phy_info_t * pi, bool full_cal);
+
+static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi);
+
+static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi);
+
+static uint16 wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz,
+					    uint16 max_val,
+					    uint8 dac_test_mode);
+static void wlc_phy_loadsampletable_nphy(phy_info_t * pi, cint32 * tone_buf,
+					 uint16 num_samps);
+static void wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 n, uint16 lps,
+				    uint16 wait, uint8 iq, uint8 dac_test_mode,
+				    bool modify_bbmult);
+
+bool wlc_phy_bist_check_phy(wlc_phy_t * pih)
+{
+	phy_info_t *pi = (phy_info_t *) pih;
+	uint32 phybist0, phybist1, phybist2, phybist3, phybist4;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 16))
+		return TRUE;
+
+	phybist0 = read_phy_reg(pi, 0x0e);
+	phybist1 = read_phy_reg(pi, 0x0f);
+	phybist2 = read_phy_reg(pi, 0xea);
+	phybist3 = read_phy_reg(pi, 0xeb);
+	phybist4 = read_phy_reg(pi, 0x156);
+
+	if ((phybist0 == 0) && (phybist1 == 0x4000) && (phybist2 == 0x1fe0) &&
+	    (phybist3 == 0) && (phybist4 == 0)) {
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static void WLBANDINITFN(wlc_phy_bphy_init_nphy) (phy_info_t * pi) {
+	uint16 addr, val;
+
+	ASSERT(ISNPHY(pi));
+
+	val = 0x1e1f;
+	for (addr = (NPHY_TO_BPHY_OFF + BPHY_RSSI_LUT);
+	     addr <= (NPHY_TO_BPHY_OFF + BPHY_RSSI_LUT_END); addr++) {
+		write_phy_reg(pi, addr, val);
+		if (addr == (NPHY_TO_BPHY_OFF + 0x97))
+			val = 0x3e3f;
+		else
+			val -= 0x0202;
+	}
+
+	if (NORADIO_ENAB(pi->pubpi)) {
+
+		write_phy_reg(pi, NPHY_TO_BPHY_OFF + BPHY_PHYCRSTH, 0x3206);
+
+		write_phy_reg(pi, NPHY_TO_BPHY_OFF + BPHY_RSSI_TRESH, 0x281e);
+
+		or_phy_reg(pi, NPHY_TO_BPHY_OFF + BPHY_LNA_GAIN_RANGE, 0x1a);
+
+	} else {
+
+		write_phy_reg(pi, NPHY_TO_BPHY_OFF + BPHY_STEP, 0x668);
+	}
+}
+
+void
+wlc_phy_table_write_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
+			 uint32 width, const void *data)
+{
+	mimophytbl_info_t tbl;
+
+	tbl.tbl_id = id;
+	tbl.tbl_len = len;
+	tbl.tbl_offset = offset;
+	tbl.tbl_width = width;
+	tbl.tbl_ptr = data;
+	wlc_phy_write_table_nphy(pi, &tbl);
+}
+
+void
+wlc_phy_table_read_nphy(phy_info_t * pi, uint32 id, uint32 len, uint32 offset,
+			uint32 width, void *data)
+{
+	mimophytbl_info_t tbl;
+
+	tbl.tbl_id = id;
+	tbl.tbl_len = len;
+	tbl.tbl_offset = offset;
+	tbl.tbl_width = width;
+	tbl.tbl_ptr = data;
+	wlc_phy_read_table_nphy(pi, &tbl);
+}
+
+static void WLBANDINITFN(wlc_phy_static_table_download_nphy) (phy_info_t * pi) {
+	uint idx;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 16)) {
+		for (idx = 0; idx < mimophytbl_info_sz_rev16; idx++)
+			wlc_phy_write_table_nphy(pi,
+						 &mimophytbl_info_rev16[idx]);
+	} else if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		for (idx = 0; idx < mimophytbl_info_sz_rev7; idx++)
+			wlc_phy_write_table_nphy(pi,
+						 &mimophytbl_info_rev7[idx]);
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		for (idx = 0; idx < mimophytbl_info_sz_rev3; idx++)
+			wlc_phy_write_table_nphy(pi,
+						 &mimophytbl_info_rev3[idx]);
+	} else {
+		for (idx = 0; idx < mimophytbl_info_sz_rev0; idx++)
+			wlc_phy_write_table_nphy(pi,
+						 &mimophytbl_info_rev0[idx]);
+	}
+}
+
+static void WLBANDINITFN(wlc_phy_tbl_init_nphy) (phy_info_t * pi) {
+	uint idx = 0;
+	uint8 antswctrllut;
+
+	if (pi->phy_init_por)
+		wlc_phy_static_table_download_nphy(pi);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		antswctrllut = CHSPEC_IS2G(pi->radio_chanspec) ?
+		    pi->srom_fem2g.antswctrllut : pi->srom_fem5g.antswctrllut;
+
+		switch (antswctrllut) {
+		case 0:
+
+			break;
+
+		case 1:
+
+			if (pi->aa2g == 7) {
+
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_ANTSWCTRLLUT,
+							 2, 0x21, 8,
+							 &ant_sw_ctrl_tbl_rev8_2o3
+							 [0]);
+			} else {
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_ANTSWCTRLLUT,
+							 2, 0x21, 8,
+							 &ant_sw_ctrl_tbl_rev8
+							 [0]);
+			}
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x25, 8,
+						 &ant_sw_ctrl_tbl_rev8[2]);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x29, 8,
+						 &ant_sw_ctrl_tbl_rev8[4]);
+			break;
+
+		case 2:
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x1, 8,
+						 &ant_sw_ctrl_tbl_rev8_2057v7_core0
+						 [0]);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x5, 8,
+						 &ant_sw_ctrl_tbl_rev8_2057v7_core0
+						 [2]);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x9, 8,
+						 &ant_sw_ctrl_tbl_rev8_2057v7_core0
+						 [4]);
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x21, 8,
+						 &ant_sw_ctrl_tbl_rev8_2057v7_core1
+						 [0]);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x25, 8,
+						 &ant_sw_ctrl_tbl_rev8_2057v7_core1
+						 [2]);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 2, 0x29, 8,
+						 &ant_sw_ctrl_tbl_rev8_2057v7_core1
+						 [4]);
+			break;
+
+		default:
+
+			ASSERT(0);
+			break;
+		}
+
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		for (idx = 0; idx < mimophytbl_info_sz_rev3_volatile; idx++) {
+
+			if (idx == ANT_SWCTRL_TBL_REV3_IDX) {
+				antswctrllut = CHSPEC_IS2G(pi->radio_chanspec) ?
+				    pi->srom_fem2g.antswctrllut : pi->
+				    srom_fem5g.antswctrllut;
+				switch (antswctrllut) {
+				case 0:
+					wlc_phy_write_table_nphy(pi,
+								 &mimophytbl_info_rev3_volatile
+								 [idx]);
+					break;
+				case 1:
+					wlc_phy_write_table_nphy(pi,
+								 &mimophytbl_info_rev3_volatile1
+								 [idx]);
+					break;
+				case 2:
+					wlc_phy_write_table_nphy(pi,
+								 &mimophytbl_info_rev3_volatile2
+								 [idx]);
+					break;
+				case 3:
+					wlc_phy_write_table_nphy(pi,
+								 &mimophytbl_info_rev3_volatile3
+								 [idx]);
+					break;
+				default:
+
+					ASSERT(0);
+					break;
+				}
+			} else {
+				wlc_phy_write_table_nphy(pi,
+							 &mimophytbl_info_rev3_volatile
+							 [idx]);
+			}
+		}
+	} else {
+		for (idx = 0; idx < mimophytbl_info_sz_rev0_volatile; idx++) {
+			wlc_phy_write_table_nphy(pi,
+						 &mimophytbl_info_rev0_volatile
+						 [idx]);
+		}
+	}
+}
+
+static void
+wlc_phy_write_txmacreg_nphy(phy_info_t * pi, uint16 holdoff, uint16 delay)
+{
+	write_phy_reg(pi, 0x77, holdoff);
+	write_phy_reg(pi, 0xb4, delay);
+}
+
+void wlc_phy_nphy_tkip_rifs_war(phy_info_t * pi, uint8 rifs)
+{
+	uint16 holdoff, delay;
+
+	if (rifs) {
+
+		holdoff = 0x10;
+		delay = 0x258;
+	} else {
+
+		holdoff = 0x15;
+		delay = 0x320;
+	}
+
+	wlc_phy_write_txmacreg_nphy(pi, holdoff, delay);
+
+	if (pi && pi->sh && (pi->sh->_rifs_phy != rifs)) {
+		pi->sh->_rifs_phy = rifs;
+	}
+}
+
+bool wlc_phy_attach_nphy(phy_info_t * pi)
+{
+	uint i;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 6)) {
+		pi->phyhang_avoid = TRUE;
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
+
+		pi->nphy_gband_spurwar_en = TRUE;
+
+		if (pi->sh->boardflags2 & BFL2_SPUR_WAR) {
+			pi->nphy_aband_spurwar_en = TRUE;
+		}
+	}
+	if (NREV_GE(pi->pubpi.phy_rev, 6) && NREV_LT(pi->pubpi.phy_rev, 7)) {
+
+		if (pi->sh->boardflags2 & BFL2_2G_SPUR_WAR) {
+			pi->nphy_gband_spurwar2_en = TRUE;
+		}
+	}
+
+	pi->n_preamble_override = AUTO;
+	if (NREV_IS(pi->pubpi.phy_rev, 3) || NREV_IS(pi->pubpi.phy_rev, 4))
+		pi->n_preamble_override = WLC_N_PREAMBLE_MIXEDMODE;
+
+	pi->nphy_txrx_chain = AUTO;
+	pi->phy_scraminit = AUTO;
+
+	pi->nphy_rxcalparams = 0x010100B5;
+
+	pi->nphy_perical = PHY_PERICAL_MPHASE;
+	pi->mphase_cal_phase_id = MPHASE_CAL_STATE_IDLE;
+	pi->mphase_txcal_numcmds = MPHASE_TXCAL_NUMCMDS;
+
+	pi->nphy_gain_boost = TRUE;
+	pi->nphy_elna_gain_config = FALSE;
+	pi->radio_is_on = FALSE;
+
+	for (i = 0; i < pi->pubpi.phy_corenum; i++) {
+		pi->nphy_txpwrindex[i].index = AUTO;
+	}
+
+	wlc_phy_txpwrctrl_config_nphy(pi);
+	if (pi->nphy_txpwrctrl == PHY_TPC_HW_ON)
+		pi->hwpwrctrl_capable = TRUE;
+
+	pi->pi_fptr.init = wlc_phy_init_nphy;
+	pi->pi_fptr.calinit = wlc_phy_cal_init_nphy;
+	pi->pi_fptr.chanset = wlc_phy_chanspec_set_nphy;
+	pi->pi_fptr.txpwrrecalc = wlc_phy_txpower_recalc_target_nphy;
+
+	if (!wlc_phy_txpwr_srom_read_nphy(pi))
+		return FALSE;
+
+	return TRUE;
+}
+
+static void BCMATTACHFN(wlc_phy_txpwrctrl_config_nphy) (phy_info_t * pi) {
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
+		pi->phy_5g_pwrgain = TRUE;
+		return;
+	}
+
+	pi->nphy_txpwrctrl = PHY_TPC_HW_OFF;
+	pi->phy_5g_pwrgain = FALSE;
+
+	if ((pi->sh->boardflags2 & BFL2_TXPWRCTRL_EN) &&
+	    NREV_GE(pi->pubpi.phy_rev, 2) && (pi->sh->sromrev >= 4))
+		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;
+	else if ((pi->sh->sromrev >= 4)
+		 && (pi->sh->boardflags2 & BFL2_5G_PWRGAIN))
+		pi->phy_5g_pwrgain = TRUE;
+}
+
+void WLBANDINITFN(wlc_phy_init_nphy) (phy_info_t * pi) {
+	uint16 val;
+	uint16 clip1_ths[2];
+	nphy_txgains_t target_gain;
+	uint8 tx_pwr_ctrl_state;
+	bool do_nphy_cal = FALSE;
+	uint core;
+	uint origidx, intr_val;
+	d11regs_t *regs;
+	uint32 d11_clk_ctl_st;
+
+	core = 0;
+
+	if (!(pi->measure_hold & PHY_HOLD_FOR_SCAN)) {
+		pi->measure_hold |= PHY_HOLD_FOR_NOT_ASSOC;
+	}
+
+	if ((ISNPHY(pi)) && (NREV_GE(pi->pubpi.phy_rev, 5)) &&
+	    ((pi->sh->chippkg == BCM4717_PKG_ID) ||
+	     (pi->sh->chippkg == BCM4718_PKG_ID))) {
+		if ((pi->sh->boardflags & BFL_EXTLNA) &&
+		    (CHSPEC_IS2G(pi->radio_chanspec))) {
+			si_corereg(pi->sh->sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, chipcontrol), 0x40,
+				   0x40);
+		}
+	}
+
+	if ((!PHY_IPA(pi)) && (CHIPID(pi->sh->chip) == BCM5357_CHIP_ID)) {
+		si_pmu_chipcontrol(pi->sh->sih, 1, CCTRL5357_EXTPA,
+				   CCTRL5357_EXTPA);
+	}
+
+	if ((pi->nphy_gband_spurwar2_en) && CHSPEC_IS2G(pi->radio_chanspec) &&
+	    CHSPEC_IS40(pi->radio_chanspec)) {
+
+		regs = (d11regs_t *) si_switch_core(pi->sh->sih, D11_CORE_ID,
+						    &origidx, &intr_val);
+		ASSERT(regs != NULL);
+
+		d11_clk_ctl_st = R_REG(pi->sh->osh, &regs->clk_ctl_st);
+		AND_REG(pi->sh->osh, &regs->clk_ctl_st,
+			~(CCS_FORCEHT | CCS_HTAREQ));
+
+		W_REG(pi->sh->osh, &regs->clk_ctl_st, d11_clk_ctl_st);
+
+		si_restore_core(pi->sh->sih, origidx, intr_val);
+	}
+
+	pi->use_int_tx_iqlo_cal_nphy =
+	    (PHY_IPA(pi) ||
+	     (NREV_GE(pi->pubpi.phy_rev, 7) ||
+	      (NREV_GE(pi->pubpi.phy_rev, 5)
+	       && pi->sh->boardflags2 & BFL2_INTERNDET_TXIQCAL)));
+
+	pi->internal_tx_iqlo_cal_tapoff_intpa_nphy = FALSE;
+
+	pi->nphy_deaf_count = 0;
+
+	wlc_phy_tbl_init_nphy(pi);
+
+	pi->nphy_crsminpwr_adjusted = FALSE;
+	pi->nphy_noisevars_adjusted = FALSE;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		write_phy_reg(pi, 0xe7, 0);
+		write_phy_reg(pi, 0xec, 0);
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			write_phy_reg(pi, 0x342, 0);
+			write_phy_reg(pi, 0x343, 0);
+			write_phy_reg(pi, 0x346, 0);
+			write_phy_reg(pi, 0x347, 0);
+		}
+		write_phy_reg(pi, 0xe5, 0);
+		write_phy_reg(pi, 0xe6, 0);
+	} else {
+		write_phy_reg(pi, 0xec, 0);
+	}
+
+	write_phy_reg(pi, 0x91, 0);
+	write_phy_reg(pi, 0x92, 0);
+	if (NREV_LT(pi->pubpi.phy_rev, 6)) {
+		write_phy_reg(pi, 0x93, 0);
+		write_phy_reg(pi, 0x94, 0);
+	}
+
+	and_phy_reg(pi, 0xa1, ~3);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		write_phy_reg(pi, 0x8f, 0);
+		write_phy_reg(pi, 0xa5, 0);
+	} else {
+		write_phy_reg(pi, 0xa5, 0);
+	}
+
+	if (NREV_IS(pi->pubpi.phy_rev, 2))
+		mod_phy_reg(pi, 0xdc, 0x00ff, 0x3b);
+	else if (NREV_LT(pi->pubpi.phy_rev, 2))
+		mod_phy_reg(pi, 0xdc, 0x00ff, 0x40);
+
+	write_phy_reg(pi, 0x203, 32);
+	write_phy_reg(pi, 0x201, 32);
+
+	if (pi->sh->boardflags2 & BFL2_SKWRKFEM_BRD)
+		write_phy_reg(pi, 0x20d, 160);
+	else
+		write_phy_reg(pi, 0x20d, 184);
+
+	write_phy_reg(pi, 0x13a, 200);
+
+	write_phy_reg(pi, 0x70, 80);
+
+	write_phy_reg(pi, 0x1ff, 48);
+
+	if (NREV_LT(pi->pubpi.phy_rev, 8)) {
+		wlc_phy_update_mimoconfig_nphy(pi, pi->n_preamble_override);
+	}
+
+	wlc_phy_stf_chain_upd_nphy(pi);
+
+	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+		write_phy_reg(pi, 0x180, 0xaa8);
+		write_phy_reg(pi, 0x181, 0x9a4);
+	}
+
+	if (PHY_IPA(pi)) {
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+				    0x29b, (0x1 << 0), (1) << 0);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x298 :
+				    0x29c, (0x1ff << 7),
+				    (pi->nphy_papd_epsilon_offset[core]) << 7);
+
+		}
+
+		wlc_phy_ipa_set_tx_digi_filts_nphy(pi);
+	} else {
+
+		if (NREV_GE(pi->pubpi.phy_rev, 5)) {
+			wlc_phy_extpa_set_tx_digi_filts_nphy(pi);
+		}
+	}
+
+	wlc_phy_workarounds_nphy(pi);
+
+	wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);
+
+	val = read_phy_reg(pi, 0x01);
+	write_phy_reg(pi, 0x01, val | BBCFG_RESETCCA);
+	write_phy_reg(pi, 0x01, val & (~BBCFG_RESETCCA));
+	wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
+
+	wlapi_bmac_macphyclk_set(pi->sh->physhim, ON);
+
+	wlc_phy_pa_override_nphy(pi, OFF);
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RX2TX);
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+	wlc_phy_pa_override_nphy(pi, ON);
+
+	wlc_phy_classifier_nphy(pi, 0, 0);
+	wlc_phy_clip_det_nphy(pi, 0, clip1_ths);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec))
+		wlc_phy_bphy_init_nphy(pi);
+
+	tx_pwr_ctrl_state = pi->nphy_txpwrctrl;
+	wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
+
+	wlc_phy_txpwr_fixpower_nphy(pi);
+
+	wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
+
+	wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		uint32 *tx_pwrctrl_tbl = NULL;
+		uint16 idx;
+		int16 pga_gn = 0;
+		int16 pad_gn = 0;
+		int32 rfpwr_offset = 0;
+
+		if (PHY_IPA(pi)) {
+			tx_pwrctrl_tbl = wlc_phy_get_ipa_gaintbl_nphy(pi);
+		} else {
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				if NREV_IS
+					(pi->pubpi.phy_rev, 3) {
+					tx_pwrctrl_tbl =
+					    nphy_tpc_5GHz_txgain_rev3;
+				} else if NREV_IS
+					(pi->pubpi.phy_rev, 4) {
+					tx_pwrctrl_tbl =
+					    (pi->srom_fem5g.extpagain == 3) ?
+					    nphy_tpc_5GHz_txgain_HiPwrEPA :
+					    nphy_tpc_5GHz_txgain_rev4;
+				} else {
+					tx_pwrctrl_tbl =
+					    nphy_tpc_5GHz_txgain_rev5;
+				}
+
+			} else {
+				if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+					if (pi->pubpi.radiorev == 5) {
+						tx_pwrctrl_tbl =
+						    nphy_tpc_txgain_epa_2057rev5;
+					} else if (pi->pubpi.radiorev == 3) {
+						tx_pwrctrl_tbl =
+						    nphy_tpc_txgain_epa_2057rev3;
+					}
+
+				} else {
+					if (NREV_GE(pi->pubpi.phy_rev, 5) &&
+					    (pi->srom_fem2g.extpagain == 3)) {
+						tx_pwrctrl_tbl =
+						    nphy_tpc_txgain_HiPwrEPA;
+					} else {
+						tx_pwrctrl_tbl =
+						    nphy_tpc_txgain_rev3;
+					}
+				}
+			}
+		}
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE1TXPWRCTL, 128,
+					 192, 32, tx_pwrctrl_tbl);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 128,
+					 192, 32, tx_pwrctrl_tbl);
+
+		pi->nphy_gmval = (uint16) ((*tx_pwrctrl_tbl >> 16) & 0x7000);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+			for (idx = 0; idx < 128; idx++) {
+				pga_gn = (tx_pwrctrl_tbl[idx] >> 24) & 0xf;
+				pad_gn = (tx_pwrctrl_tbl[idx] >> 19) & 0x1f;
+
+				if (CHSPEC_IS2G(pi->radio_chanspec)) {
+					if ((pi->pubpi.radiorev == 3) ||
+					    (pi->pubpi.radiorev == 4) ||
+					    (pi->pubpi.radiorev == 6)) {
+						rfpwr_offset = (int16)
+						    nphy_papd_padgain_dlt_2g_2057rev3n4
+						    [pad_gn];
+					} else if (pi->pubpi.radiorev == 5) {
+						rfpwr_offset = (int16)
+						    nphy_papd_padgain_dlt_2g_2057rev5
+						    [pad_gn];
+					} else if ((pi->pubpi.radiorev == 7)
+						   || (pi->pubpi.radiorev ==
+						       8)) {
+						rfpwr_offset = (int16)
+						    nphy_papd_padgain_dlt_2g_2057rev7
+						    [pad_gn];
+					} else {
+						ASSERT(0);
+					}
+
+				} else {
+					if ((pi->pubpi.radiorev == 3) ||
+					    (pi->pubpi.radiorev == 4) ||
+					    (pi->pubpi.radiorev == 6)) {
+						rfpwr_offset = (int16)
+						    nphy_papd_pgagain_dlt_5g_2057
+						    [pga_gn];
+					} else if ((pi->pubpi.radiorev == 7)
+						   || (pi->pubpi.radiorev ==
+						       8)) {
+						rfpwr_offset = (int16)
+						    nphy_papd_pgagain_dlt_5g_2057rev7
+						    [pga_gn];
+					} else {
+						ASSERT(0);
+					}
+				}
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_CORE1TXPWRCTL,
+							 1, 576 + idx, 32,
+							 &rfpwr_offset);
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_CORE2TXPWRCTL,
+							 1, 576 + idx, 32,
+							 &rfpwr_offset);
+			}
+		} else {
+
+			for (idx = 0; idx < 128; idx++) {
+				pga_gn = (tx_pwrctrl_tbl[idx] >> 24) & 0xf;
+				if (CHSPEC_IS2G(pi->radio_chanspec)) {
+					rfpwr_offset = (int16)
+					    nphy_papd_pga_gain_delta_ipa_2g
+					    [pga_gn];
+				} else {
+					rfpwr_offset = (int16)
+					    nphy_papd_pga_gain_delta_ipa_5g
+					    [pga_gn];
+				}
+
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_CORE1TXPWRCTL,
+							 1, 576 + idx, 32,
+							 &rfpwr_offset);
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_CORE2TXPWRCTL,
+							 1, 576 + idx, 32,
+							 &rfpwr_offset);
+			}
+
+		}
+	} else {
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE1TXPWRCTL, 128,
+					 192, 32, nphy_tpc_txgain);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 128,
+					 192, 32, nphy_tpc_txgain);
+	}
+
+	if (pi->sh->phyrxchain != 0x3) {
+		wlc_phy_rxcore_setstate_nphy((wlc_phy_t *) pi,
+					     pi->sh->phyrxchain);
+	}
+
+	if (PHY_PERICAL_MPHASE_PENDING(pi)) {
+		wlc_phy_cal_perical_mphase_restart(pi);
+	}
+
+	if (!NORADIO_ENAB(pi->pubpi)) {
+		bool do_rssi_cal = FALSE;
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			do_rssi_cal = (CHSPEC_IS2G(pi->radio_chanspec)) ?
+			    (pi->nphy_rssical_chanspec_2G == 0) :
+			    (pi->nphy_rssical_chanspec_5G == 0);
+
+			if (do_rssi_cal) {
+				wlc_phy_rssi_cal_nphy(pi);
+			} else {
+				wlc_phy_restore_rssical_nphy(pi);
+			}
+		} else {
+			wlc_phy_rssi_cal_nphy(pi);
+		}
+
+		if (!SCAN_RM_IN_PROGRESS(pi)) {
+			do_nphy_cal = (CHSPEC_IS2G(pi->radio_chanspec)) ?
+			    (pi->nphy_iqcal_chanspec_2G == 0) :
+			    (pi->nphy_iqcal_chanspec_5G == 0);
+		}
+
+		if (!pi->do_initcal)
+			do_nphy_cal = FALSE;
+
+		if (do_nphy_cal) {
+
+			target_gain = wlc_phy_get_tx_gain_nphy(pi);
+
+			if (pi->antsel_type == ANTSEL_2x3)
+				wlc_phy_antsel_init((wlc_phy_t *) pi, TRUE);
+
+			if (pi->nphy_perical != PHY_PERICAL_MPHASE) {
+				wlc_phy_rssi_cal_nphy(pi);
+
+				if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+					pi->nphy_cal_orig_pwr_idx[0] =
+					    pi->nphy_txpwrindex[PHY_CORE_0].
+					    index_internal;
+					pi->nphy_cal_orig_pwr_idx[1] =
+					    pi->nphy_txpwrindex[PHY_CORE_1].
+					    index_internal;
+
+					wlc_phy_precal_txgain_nphy(pi);
+					target_gain =
+					    wlc_phy_get_tx_gain_nphy(pi);
+				}
+
+				if (wlc_phy_cal_txiqlo_nphy
+				    (pi, target_gain, TRUE, FALSE) == BCME_OK) {
+					if (wlc_phy_cal_rxiq_nphy
+					    (pi, target_gain, 2,
+					     FALSE) == BCME_OK) {
+						wlc_phy_savecal_nphy(pi);
+
+					}
+				}
+			} else if (pi->mphase_cal_phase_id ==
+				   MPHASE_CAL_STATE_IDLE) {
+
+				wlc_phy_cal_perical((wlc_phy_t *) pi,
+						    PHY_PERICAL_PHYINIT);
+			}
+		} else {
+			wlc_phy_restorecal_nphy(pi);
+		}
+	}
+
+	wlc_phy_txpwrctrl_coeff_setup_nphy(pi);
+
+	wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
+
+	wlc_phy_nphy_tkip_rifs_war(pi, pi->sh->_rifs_phy);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LE(pi->pubpi.phy_rev, 6))
+
+		write_phy_reg(pi, 0x70, 50);
+
+	wlc_phy_txlpfbw_nphy(pi);
+
+	wlc_phy_spurwar_nphy(pi);
+
+}
+
+static void wlc_phy_update_mimoconfig_nphy(phy_info_t * pi, int32 preamble)
+{
+	bool gf_preamble = FALSE;
+	uint16 val;
+
+	if (preamble == WLC_N_PREAMBLE_GF) {
+		gf_preamble = TRUE;
+	}
+
+	val = read_phy_reg(pi, 0xed);
+
+	val |= RX_GF_MM_AUTO;
+	val &= ~RX_GF_OR_MM;
+	if (gf_preamble)
+		val |= RX_GF_OR_MM;
+
+	write_phy_reg(pi, 0xed, val);
+}
+
+static void wlc_phy_resetcca_nphy(phy_info_t * pi)
+{
+	uint16 val;
+
+	ASSERT(0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+
+	wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);
+
+	val = read_phy_reg(pi, 0x01);
+	write_phy_reg(pi, 0x01, val | BBCFG_RESETCCA);
+	OSL_DELAY(1);
+	write_phy_reg(pi, 0x01, val & (~BBCFG_RESETCCA));
+
+	wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
+
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+}
+
+void wlc_phy_pa_override_nphy(phy_info_t * pi, bool en)
+{
+	uint16 rfctrlintc_override_val;
+
+	if (!en) {
+
+		pi->rfctrlIntc1_save = read_phy_reg(pi, 0x91);
+		pi->rfctrlIntc2_save = read_phy_reg(pi, 0x92);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			rfctrlintc_override_val = 0x1480;
+		} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			rfctrlintc_override_val =
+			    CHSPEC_IS5G(pi->radio_chanspec) ? 0x600 : 0x480;
+		} else {
+			rfctrlintc_override_val =
+			    CHSPEC_IS5G(pi->radio_chanspec) ? 0x180 : 0x120;
+		}
+
+		write_phy_reg(pi, 0x91, rfctrlintc_override_val);
+		write_phy_reg(pi, 0x92, rfctrlintc_override_val);
+	} else {
+
+		write_phy_reg(pi, 0x91, pi->rfctrlIntc1_save);
+		write_phy_reg(pi, 0x92, pi->rfctrlIntc2_save);
+	}
+
+}
+
+void wlc_phy_stf_chain_upd_nphy(phy_info_t * pi)
+{
+
+	uint16 txrx_chain =
+	    (NPHY_RfseqCoreActv_TxRxChain0 | NPHY_RfseqCoreActv_TxRxChain1);
+	bool CoreActv_override = FALSE;
+
+	if (pi->nphy_txrx_chain == WLC_N_TXRX_CHAIN0) {
+		txrx_chain = NPHY_RfseqCoreActv_TxRxChain0;
+		CoreActv_override = TRUE;
+
+		if (NREV_LE(pi->pubpi.phy_rev, 2)) {
+			and_phy_reg(pi, 0xa0, ~0x20);
+		}
+	} else if (pi->nphy_txrx_chain == WLC_N_TXRX_CHAIN1) {
+		txrx_chain = NPHY_RfseqCoreActv_TxRxChain1;
+		CoreActv_override = TRUE;
+
+		if (NREV_LE(pi->pubpi.phy_rev, 2)) {
+			or_phy_reg(pi, 0xa0, 0x20);
+		}
+	}
+
+	mod_phy_reg(pi, 0xa2, ((0xf << 0) | (0xf << 4)), txrx_chain);
+
+	if (CoreActv_override) {
+
+		pi->nphy_perical = PHY_PERICAL_DISABLE;
+		or_phy_reg(pi, 0xa1, NPHY_RfseqMode_CoreActv_override);
+	} else {
+		pi->nphy_perical = PHY_PERICAL_MPHASE;
+		and_phy_reg(pi, 0xa1, ~NPHY_RfseqMode_CoreActv_override);
+	}
+}
+
+void wlc_phy_rxcore_setstate_nphy(wlc_phy_t * pih, uint8 rxcore_bitmask)
+{
+	uint16 regval;
+	uint16 tbl_buf[16];
+	uint i;
+	phy_info_t *pi = (phy_info_t *) pih;
+	uint16 tbl_opcode;
+	bool suspend;
+
+	pi->sh->phyrxchain = rxcore_bitmask;
+
+	if (!pi->sh->clk)
+		return;
+
+	suspend =
+	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+	if (!suspend)
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	regval = read_phy_reg(pi, 0xa2);
+	regval &= ~(0xf << 4);
+	regval |= ((uint16) (rxcore_bitmask & 0x3)) << 4;
+	write_phy_reg(pi, 0xa2, regval);
+
+	if ((rxcore_bitmask & 0x3) != 0x3) {
+
+		write_phy_reg(pi, 0x20e, 1);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			if (pi->rx2tx_biasentry == -1) {
+				wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							ARRAYSIZE(tbl_buf), 80,
+							16, tbl_buf);
+
+				for (i = 0; i < ARRAYSIZE(tbl_buf); i++) {
+					if (tbl_buf[i] ==
+					    NPHY_REV3_RFSEQ_CMD_CLR_RXRX_BIAS) {
+
+						pi->rx2tx_biasentry = (uint8) i;
+						tbl_opcode =
+						    NPHY_REV3_RFSEQ_CMD_NOP;
+						wlc_phy_table_write_nphy(pi,
+									 NPHY_TBL_ID_RFSEQ,
+									 1, i,
+									 16,
+									 &tbl_opcode);
+						break;
+					} else if (tbl_buf[i] ==
+						   NPHY_REV3_RFSEQ_CMD_END) {
+						break;
+					}
+				}
+			}
+		}
+	} else {
+
+		write_phy_reg(pi, 0x20e, 30);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			if (pi->rx2tx_biasentry != -1) {
+				tbl_opcode = NPHY_REV3_RFSEQ_CMD_CLR_RXRX_BIAS;
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1, pi->rx2tx_biasentry,
+							 16, &tbl_opcode);
+				pi->rx2tx_biasentry = -1;
+			}
+		}
+	}
+
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+
+	if (!suspend)
+		wlapi_enable_mac(pi->sh->physhim);
+}
+
+uint8 wlc_phy_rxcore_getstate_nphy(wlc_phy_t * pih)
+{
+	uint16 regval, rxen_bits;
+	phy_info_t *pi = (phy_info_t *) pih;
+
+	regval = read_phy_reg(pi, 0xa2);
+	rxen_bits = (regval >> 4) & 0xf;
+
+	return ((uint8) rxen_bits);
+}
+
+bool wlc_phy_n_txpower_ipa_ison(phy_info_t * pi)
+{
+	return PHY_IPA(pi);
+}
+
+static void wlc_phy_txpwr_limit_to_tbl_nphy(phy_info_t * pi)
+{
+	uint8 idx, idx2, i, delta_ind;
+
+	for (idx = TXP_FIRST_CCK; idx <= TXP_LAST_CCK; idx++) {
+		pi->adj_pwr_tbl_nphy[idx] = pi->tx_power_offset[idx];
+	}
+
+	for (i = 0; i < 4; i++) {
+		idx2 = 0;
+
+		delta_ind = 0;
+
+		switch (i) {
+		case 0:
+
+			if (CHSPEC_IS40(pi->radio_chanspec)
+			    && NPHY_IS_SROM_REINTERPRET) {
+				idx = TXP_FIRST_MCS_40_SISO;
+			} else {
+				idx = (CHSPEC_IS40(pi->radio_chanspec)) ?
+				    TXP_FIRST_OFDM_40_SISO : TXP_FIRST_OFDM;
+				delta_ind = 1;
+			}
+			break;
+
+		case 1:
+
+			idx = (CHSPEC_IS40(pi->radio_chanspec)) ?
+			    TXP_FIRST_MCS_40_CDD : TXP_FIRST_MCS_20_CDD;
+			break;
+
+		case 2:
+
+			idx = (CHSPEC_IS40(pi->radio_chanspec)) ?
+			    TXP_FIRST_MCS_40_STBC : TXP_FIRST_MCS_20_STBC;
+			break;
+
+		case 3:
+
+			idx = (CHSPEC_IS40(pi->radio_chanspec)) ?
+			    TXP_FIRST_MCS_40_SDM : TXP_FIRST_MCS_20_SDM;
+			break;
+		}
+
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		idx = idx + delta_ind;
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx++];
+
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx++];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx++];
+
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx++];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx++];
+
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx++];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		idx = idx + 1 - delta_ind;
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+		pi->adj_pwr_tbl_nphy[4 + 4 * (idx2++) + i] =
+		    pi->tx_power_offset[idx];
+	}
+}
+
+void wlc_phy_cal_init_nphy(phy_info_t * pi)
+{
+}
+
+static void wlc_phy_war_force_trsw_to_R_cliplo_nphy(phy_info_t * pi, uint8 core)
+{
+	if (core == PHY_CORE_0) {
+		write_phy_reg(pi, 0x38, 0x4);
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			write_phy_reg(pi, 0x37, 0x0060);
+		} else {
+			write_phy_reg(pi, 0x37, 0x1080);
+		}
+	} else if (core == PHY_CORE_1) {
+		write_phy_reg(pi, 0x2ae, 0x4);
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			write_phy_reg(pi, 0x2ad, 0x0060);
+		} else {
+			write_phy_reg(pi, 0x2ad, 0x1080);
+		}
+	}
+}
+
+static void wlc_phy_war_txchain_upd_nphy(phy_info_t * pi, uint8 txchain)
+{
+	uint8 txchain0, txchain1;
+
+	txchain0 = txchain & 0x1;
+	txchain1 = (txchain & 0x2) >> 1;
+	if (!txchain0) {
+		wlc_phy_war_force_trsw_to_R_cliplo_nphy(pi, PHY_CORE_0);
+	}
+
+	if (!txchain1) {
+		wlc_phy_war_force_trsw_to_R_cliplo_nphy(pi, PHY_CORE_1);
+	}
+}
+
+static void wlc_phy_workarounds_nphy(phy_info_t * pi)
+{
+	uint8 rfseq_rx2tx_events[] = {
+		NPHY_RFSEQ_CMD_NOP,
+		NPHY_RFSEQ_CMD_RXG_FBW,
+		NPHY_RFSEQ_CMD_TR_SWITCH,
+		NPHY_RFSEQ_CMD_CLR_HIQ_DIS,
+		NPHY_RFSEQ_CMD_RXPD_TXPD,
+		NPHY_RFSEQ_CMD_TX_GAIN,
+		NPHY_RFSEQ_CMD_EXT_PA
+	};
+	uint8 rfseq_rx2tx_dlys[] = { 8, 6, 6, 2, 4, 60, 1 };
+	uint8 rfseq_tx2rx_events[] = {
+		NPHY_RFSEQ_CMD_NOP,
+		NPHY_RFSEQ_CMD_EXT_PA,
+		NPHY_RFSEQ_CMD_TX_GAIN,
+		NPHY_RFSEQ_CMD_RXPD_TXPD,
+		NPHY_RFSEQ_CMD_TR_SWITCH,
+		NPHY_RFSEQ_CMD_RXG_FBW,
+		NPHY_RFSEQ_CMD_CLR_HIQ_DIS
+	};
+	uint8 rfseq_tx2rx_dlys[] = { 8, 6, 2, 4, 4, 6, 1 };
+	uint8 rfseq_tx2rx_events_rev3[] = {
+		NPHY_REV3_RFSEQ_CMD_EXT_PA,
+		NPHY_REV3_RFSEQ_CMD_INT_PA_PU,
+		NPHY_REV3_RFSEQ_CMD_TX_GAIN,
+		NPHY_REV3_RFSEQ_CMD_RXPD_TXPD,
+		NPHY_REV3_RFSEQ_CMD_TR_SWITCH,
+		NPHY_REV3_RFSEQ_CMD_RXG_FBW,
+		NPHY_REV3_RFSEQ_CMD_CLR_HIQ_DIS,
+		NPHY_REV3_RFSEQ_CMD_END
+	};
+	uint8 rfseq_tx2rx_dlys_rev3[] = { 8, 4, 2, 2, 4, 4, 6, 1 };
+	uint8 rfseq_rx2tx_events_rev3[] = {
+		NPHY_REV3_RFSEQ_CMD_NOP,
+		NPHY_REV3_RFSEQ_CMD_RXG_FBW,
+		NPHY_REV3_RFSEQ_CMD_TR_SWITCH,
+		NPHY_REV3_RFSEQ_CMD_CLR_HIQ_DIS,
+		NPHY_REV3_RFSEQ_CMD_RXPD_TXPD,
+		NPHY_REV3_RFSEQ_CMD_TX_GAIN,
+		NPHY_REV3_RFSEQ_CMD_INT_PA_PU,
+		NPHY_REV3_RFSEQ_CMD_EXT_PA,
+		NPHY_REV3_RFSEQ_CMD_END
+	};
+	uint8 rfseq_rx2tx_dlys_rev3[] = { 8, 6, 6, 4, 4, 18, 42, 1, 1 };
+
+	uint8 rfseq_rx2tx_events_rev3_ipa[] = {
+		NPHY_REV3_RFSEQ_CMD_NOP,
+		NPHY_REV3_RFSEQ_CMD_RXG_FBW,
+		NPHY_REV3_RFSEQ_CMD_TR_SWITCH,
+		NPHY_REV3_RFSEQ_CMD_CLR_HIQ_DIS,
+		NPHY_REV3_RFSEQ_CMD_RXPD_TXPD,
+		NPHY_REV3_RFSEQ_CMD_TX_GAIN,
+		NPHY_REV3_RFSEQ_CMD_CLR_RXRX_BIAS,
+		NPHY_REV3_RFSEQ_CMD_INT_PA_PU,
+		NPHY_REV3_RFSEQ_CMD_END
+	};
+	uint8 rfseq_rx2tx_dlys_rev3_ipa[] = { 8, 6, 6, 4, 4, 16, 43, 1, 1 };
+	uint16 rfseq_rx2tx_dacbufpu_rev7[] = { 0x10f, 0x10f };
+
+	int16 alpha0, alpha1, alpha2;
+	int16 beta0, beta1, beta2;
+	uint32 leg_data_weights, ht_data_weights, nss1_data_weights,
+	    stbc_data_weights;
+	uint8 chan_freq_range = 0;
+	uint16 dac_control = 0x0002;
+	uint16 aux_adc_vmid_rev7_core0[] = { 0x8e, 0x96, 0x96, 0x96 };
+	uint16 aux_adc_vmid_rev7_core1[] = { 0x8f, 0x9f, 0x9f, 0x96 };
+	uint16 aux_adc_vmid_rev4[] = { 0xa2, 0xb4, 0xb4, 0x89 };
+	uint16 aux_adc_vmid_rev3[] = { 0xa2, 0xb4, 0xb4, 0x89 };
+	uint16 *aux_adc_vmid;
+	uint16 aux_adc_gain_rev7[] = { 0x02, 0x02, 0x02, 0x02 };
+	uint16 aux_adc_gain_rev4[] = { 0x02, 0x02, 0x02, 0x00 };
+	uint16 aux_adc_gain_rev3[] = { 0x02, 0x02, 0x02, 0x00 };
+	uint16 *aux_adc_gain;
+	uint16 sk_adc_vmid[] = { 0xb4, 0xb4, 0xb4, 0x24 };
+	uint16 sk_adc_gain[] = { 0x02, 0x02, 0x02, 0x02 };
+	int32 min_nvar_val = 0x18d;
+	int32 min_nvar_offset_6mbps = 20;
+	uint8 pdetrange;
+	uint8 triso;
+	uint16 regval;
+	uint16 afectrl_adc_ctrl1_rev7 = 0x20;
+	uint16 afectrl_adc_ctrl2_rev7 = 0x0;
+	uint16 rfseq_rx2tx_lpf_h_hpc_rev7 = 0x77;
+	uint16 rfseq_tx2rx_lpf_h_hpc_rev7 = 0x77;
+	uint16 rfseq_pktgn_lpf_h_hpc_rev7 = 0x77;
+	uint16 rfseq_htpktgn_lpf_hpc_rev7[] = { 0x77, 0x11, 0x11 };
+	uint16 rfseq_pktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
+	uint16 rfseq_cckpktgn_lpf_hpc_rev7[] = { 0x11, 0x11 };
+	uint16 ipalvlshift_3p3_war_en = 0;
+	uint16 rccal_bcap_val, rccal_scap_val;
+	uint16 rccal_tx20_11b_bcap = 0;
+	uint16 rccal_tx20_11b_scap = 0;
+	uint16 rccal_tx20_11n_bcap = 0;
+	uint16 rccal_tx20_11n_scap = 0;
+	uint16 rccal_tx40_11n_bcap = 0;
+	uint16 rccal_tx40_11n_scap = 0;
+	uint16 rx2tx_lpf_rc_lut_tx20_11b = 0;
+	uint16 rx2tx_lpf_rc_lut_tx20_11n = 0;
+	uint16 rx2tx_lpf_rc_lut_tx40_11n = 0;
+	uint16 tx_lpf_bw_ofdm_20mhz = 0;
+	uint16 tx_lpf_bw_ofdm_40mhz = 0;
+	uint16 tx_lpf_bw_11b = 0;
+	uint16 ipa2g_mainbias, ipa2g_casconv, ipa2g_biasfilt;
+	uint16 txgm_idac_bleed = 0;
+	bool rccal_ovrd = FALSE;
+	uint16 freq;
+	int coreNum;
+
+	if (CHSPEC_IS5G(pi->radio_chanspec)) {
+		wlc_phy_classifier_nphy(pi, NPHY_ClassifierCtrl_cck_en, 0);
+	} else {
+		wlc_phy_classifier_nphy(pi, NPHY_ClassifierCtrl_cck_en, 1);
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	if (!ISSIM_ENAB(pi->sh->sih)) {
+		or_phy_reg(pi, 0xb1, NPHY_IQFlip_ADC1 | NPHY_IQFlip_ADC2);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		if (NREV_IS(pi->pubpi.phy_rev, 7)) {
+			mod_phy_reg(pi, 0x221, (0x1 << 4), (1 << 4));
+
+			mod_phy_reg(pi, 0x160, (0x7f << 0), (32 << 0));
+			mod_phy_reg(pi, 0x160, (0x7f << 8), (39 << 8));
+			mod_phy_reg(pi, 0x161, (0x7f << 0), (46 << 0));
+			mod_phy_reg(pi, 0x161, (0x7f << 8), (51 << 8));
+			mod_phy_reg(pi, 0x162, (0x7f << 0), (55 << 0));
+			mod_phy_reg(pi, 0x162, (0x7f << 8), (58 << 8));
+			mod_phy_reg(pi, 0x163, (0x7f << 0), (60 << 0));
+			mod_phy_reg(pi, 0x163, (0x7f << 8), (62 << 8));
+			mod_phy_reg(pi, 0x164, (0x7f << 0), (62 << 0));
+			mod_phy_reg(pi, 0x164, (0x7f << 8), (63 << 8));
+			mod_phy_reg(pi, 0x165, (0x7f << 0), (63 << 0));
+			mod_phy_reg(pi, 0x165, (0x7f << 8), (64 << 8));
+			mod_phy_reg(pi, 0x166, (0x7f << 0), (64 << 0));
+			mod_phy_reg(pi, 0x166, (0x7f << 8), (64 << 8));
+			mod_phy_reg(pi, 0x167, (0x7f << 0), (64 << 0));
+			mod_phy_reg(pi, 0x167, (0x7f << 8), (64 << 8));
+		}
+
+		if (NREV_LE(pi->pubpi.phy_rev, 8)) {
+			write_phy_reg(pi, 0x23f, 0x1b0);
+			write_phy_reg(pi, 0x240, 0x1b0);
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 8)) {
+			mod_phy_reg(pi, 0xbd, (0xff << 0), (114 << 0));
+		}
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x00, 16,
+					 &dac_control);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x10, 16,
+					 &dac_control);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL,
+					1, 0, 32, &leg_data_weights);
+		leg_data_weights = leg_data_weights & 0xffffff;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL,
+					 1, 0, 32, &leg_data_weights);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+					 2, 0x15e, 16,
+					 rfseq_rx2tx_dacbufpu_rev7);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x16e, 16,
+					 rfseq_rx2tx_dacbufpu_rev7);
+
+		if (PHY_IPA(pi)) {
+			wlc_phy_set_rfseq_nphy(pi, NPHY_RFSEQ_RX2TX,
+					       rfseq_rx2tx_events_rev3_ipa,
+					       rfseq_rx2tx_dlys_rev3_ipa,
+					       sizeof
+					       (rfseq_rx2tx_events_rev3_ipa) /
+					       sizeof
+					       (rfseq_rx2tx_events_rev3_ipa
+						[0]));
+		}
+
+		mod_phy_reg(pi, 0x299, (0x3 << 14), (0x1 << 14));
+		mod_phy_reg(pi, 0x29d, (0x3 << 14), (0x1 << 14));
+
+		tx_lpf_bw_ofdm_20mhz = wlc_phy_read_lpf_bw_ctl_nphy(pi, 0x154);
+		tx_lpf_bw_ofdm_40mhz = wlc_phy_read_lpf_bw_ctl_nphy(pi, 0x159);
+		tx_lpf_bw_11b = wlc_phy_read_lpf_bw_ctl_nphy(pi, 0x152);
+
+		if (PHY_IPA(pi)) {
+
+			if (((pi->pubpi.radiorev == 5)
+			     && (CHSPEC_IS40(pi->radio_chanspec) == 1))
+			    || (pi->pubpi.radiorev == 7)
+			    || (pi->pubpi.radiorev == 8)) {
+
+				rccal_bcap_val =
+				    read_radio_reg(pi,
+						   RADIO_2057_RCCAL_BCAP_VAL);
+				rccal_scap_val =
+				    read_radio_reg(pi,
+						   RADIO_2057_RCCAL_SCAP_VAL);
+
+				rccal_tx20_11b_bcap = rccal_bcap_val;
+				rccal_tx20_11b_scap = rccal_scap_val;
+
+				if ((pi->pubpi.radiorev == 5) &&
+				    (CHSPEC_IS40(pi->radio_chanspec) == 1)) {
+
+					rccal_tx20_11n_bcap = rccal_bcap_val;
+					rccal_tx20_11n_scap = rccal_scap_val;
+					rccal_tx40_11n_bcap = 0xc;
+					rccal_tx40_11n_scap = 0xc;
+
+					rccal_ovrd = TRUE;
+
+				} else if ((pi->pubpi.radiorev == 7)
+					   || (pi->pubpi.radiorev == 8)) {
+
+					tx_lpf_bw_ofdm_20mhz = 4;
+					tx_lpf_bw_11b = 1;
+
+					if (CHSPEC_IS2G(pi->radio_chanspec)) {
+						rccal_tx20_11n_bcap = 0xc;
+						rccal_tx20_11n_scap = 0xc;
+						rccal_tx40_11n_bcap = 0xa;
+						rccal_tx40_11n_scap = 0xa;
+					} else {
+						rccal_tx20_11n_bcap = 0x14;
+						rccal_tx20_11n_scap = 0x14;
+						rccal_tx40_11n_bcap = 0xf;
+						rccal_tx40_11n_scap = 0xf;
+					}
+
+					rccal_ovrd = TRUE;
+				}
+			}
+
+		} else {
+
+			if (pi->pubpi.radiorev == 5) {
+
+				tx_lpf_bw_ofdm_20mhz = 1;
+				tx_lpf_bw_ofdm_40mhz = 3;
+
+				rccal_bcap_val =
+				    read_radio_reg(pi,
+						   RADIO_2057_RCCAL_BCAP_VAL);
+				rccal_scap_val =
+				    read_radio_reg(pi,
+						   RADIO_2057_RCCAL_SCAP_VAL);
+
+				rccal_tx20_11b_bcap = rccal_bcap_val;
+				rccal_tx20_11b_scap = rccal_scap_val;
+
+				rccal_tx20_11n_bcap = 0x13;
+				rccal_tx20_11n_scap = 0x11;
+				rccal_tx40_11n_bcap = 0x13;
+				rccal_tx40_11n_scap = 0x11;
+
+				rccal_ovrd = TRUE;
+			}
+		}
+
+		if (rccal_ovrd) {
+
+			rx2tx_lpf_rc_lut_tx20_11b = (rccal_tx20_11b_bcap << 8) |
+			    (rccal_tx20_11b_scap << 3) | tx_lpf_bw_11b;
+			rx2tx_lpf_rc_lut_tx20_11n = (rccal_tx20_11n_bcap << 8) |
+			    (rccal_tx20_11n_scap << 3) | tx_lpf_bw_ofdm_20mhz;
+			rx2tx_lpf_rc_lut_tx40_11n = (rccal_tx40_11n_bcap << 8) |
+			    (rccal_tx40_11n_scap << 3) | tx_lpf_bw_ofdm_40mhz;
+
+			for (coreNum = 0; coreNum <= 1; coreNum++) {
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x152 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx20_11b);
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x153 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx20_11n);
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x154 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx20_11n);
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x155 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx40_11n);
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x156 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx40_11n);
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x157 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx40_11n);
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x158 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx40_11n);
+				wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+							 1,
+							 0x159 + coreNum * 0x10,
+							 16,
+							 &rx2tx_lpf_rc_lut_tx40_11n);
+			}
+
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 4),
+							  1, 0x3, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+		}
+
+		if (!NORADIO_ENAB(pi->pubpi)) {
+			write_phy_reg(pi, 0x32f, 0x3);
+		}
+
+		if ((pi->pubpi.radiorev == 4) || (pi->pubpi.radiorev == 6)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2),
+							  1, 0x3, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		}
+
+		if ((pi->pubpi.radiorev == 3) || (pi->pubpi.radiorev == 4) ||
+		    (pi->pubpi.radiorev == 6)) {
+			if ((pi->sh->sromrev >= 8)
+			    && (pi->sh->boardflags2 & BFL2_IPALVLSHIFT_3P3))
+				ipalvlshift_3p3_war_en = 1;
+
+			if (ipalvlshift_3p3_war_en) {
+				write_radio_reg(pi, RADIO_2057_GPAIO_CONFIG,
+						0x5);
+				write_radio_reg(pi, RADIO_2057_GPAIO_SEL1,
+						0x30);
+				write_radio_reg(pi, RADIO_2057_GPAIO_SEL0, 0x0);
+				or_radio_reg(pi,
+					     RADIO_2057_RXTXBIAS_CONFIG_CORE0,
+					     0x1);
+				or_radio_reg(pi,
+					     RADIO_2057_RXTXBIAS_CONFIG_CORE1,
+					     0x1);
+
+				ipa2g_mainbias = 0x1f;
+
+				ipa2g_casconv = 0x6f;
+
+				ipa2g_biasfilt = 0xaa;
+			} else {
+
+				ipa2g_mainbias = 0x2b;
+
+				ipa2g_casconv = 0x7f;
+
+				ipa2g_biasfilt = 0xee;
+			}
+
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				for (coreNum = 0; coreNum <= 1; coreNum++) {
+					WRITE_RADIO_REG4(pi, RADIO_2057, CORE,
+							 coreNum, IPA2G_IMAIN,
+							 ipa2g_mainbias);
+					WRITE_RADIO_REG4(pi, RADIO_2057, CORE,
+							 coreNum, IPA2G_CASCONV,
+							 ipa2g_casconv);
+					WRITE_RADIO_REG4(pi, RADIO_2057, CORE,
+							 coreNum,
+							 IPA2G_BIAS_FILTER,
+							 ipa2g_biasfilt);
+				}
+			}
+		}
+
+		if (PHY_IPA(pi)) {
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				if ((pi->pubpi.radiorev == 3)
+				    || (pi->pubpi.radiorev == 4)
+				    || (pi->pubpi.radiorev == 6)) {
+
+					txgm_idac_bleed = 0x7f;
+				}
+
+				for (coreNum = 0; coreNum <= 1; coreNum++) {
+					if (txgm_idac_bleed != 0)
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, coreNum,
+								 TXGM_IDAC_BLEED,
+								 txgm_idac_bleed);
+				}
+
+				if (pi->pubpi.radiorev == 5) {
+
+					for (coreNum = 0; coreNum <= 1;
+					     coreNum++) {
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, coreNum,
+								 IPA2G_CASCONV,
+								 0x13);
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, coreNum,
+								 IPA2G_IMAIN,
+								 0x1f);
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, coreNum,
+								 IPA2G_BIAS_FILTER,
+								 0xee);
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, coreNum,
+								 PAD2G_IDACS,
+								 0x8a);
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, coreNum,
+								 PAD_BIAS_FILTER_BWS,
+								 0x3e);
+					}
+
+				} else if ((pi->pubpi.radiorev == 7)
+					   || (pi->pubpi.radiorev == 8)) {
+
+					if (CHSPEC_IS40(pi->radio_chanspec) ==
+					    0) {
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, 0,
+								 IPA2G_IMAIN,
+								 0x14);
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, 1,
+								 IPA2G_IMAIN,
+								 0x12);
+					} else {
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, 0,
+								 IPA2G_IMAIN,
+								 0x16);
+						WRITE_RADIO_REG4(pi, RADIO_2057,
+								 CORE, 1,
+								 IPA2G_IMAIN,
+								 0x16);
+					}
+				}
+
+			} else {
+				freq =
+				    CHAN5G_FREQ(CHSPEC_CHANNEL
+						(pi->radio_chanspec));
+				if (((freq >= 5180) && (freq <= 5230))
+				    || ((freq >= 5745) && (freq <= 5805))) {
+					WRITE_RADIO_REG4(pi, RADIO_2057, CORE,
+							 0, IPA5G_BIAS_FILTER,
+							 0xff);
+					WRITE_RADIO_REG4(pi, RADIO_2057, CORE,
+							 1, IPA5G_BIAS_FILTER,
+							 0xff);
+				}
+			}
+		} else {
+
+			if (pi->pubpi.radiorev != 5) {
+				for (coreNum = 0; coreNum <= 1; coreNum++) {
+					WRITE_RADIO_REG4(pi, RADIO_2057, CORE,
+							 coreNum,
+							 TXMIX2G_TUNE_BOOST_PU,
+							 0x61);
+					WRITE_RADIO_REG4(pi, RADIO_2057, CORE,
+							 coreNum,
+							 TXGM_IDAC_BLEED, 0x70);
+				}
+			}
+		}
+
+		if (pi->pubpi.radiorev == 4) {
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1,
+						 0x05, 16,
+						 &afectrl_adc_ctrl1_rev7);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1,
+						 0x15, 16,
+						 &afectrl_adc_ctrl1_rev7);
+
+			for (coreNum = 0; coreNum <= 1; coreNum++) {
+				WRITE_RADIO_REG4(pi, RADIO_2057, CORE, coreNum,
+						 AFE_VCM_CAL_MASTER, 0x0);
+				WRITE_RADIO_REG4(pi, RADIO_2057, CORE, coreNum,
+						 AFE_SET_VCM_I, 0x3f);
+				WRITE_RADIO_REG4(pi, RADIO_2057, CORE, coreNum,
+						 AFE_SET_VCM_Q, 0x3f);
+			}
+		} else {
+			mod_phy_reg(pi, 0xa6, (0x1 << 2), (0x1 << 2));
+			mod_phy_reg(pi, 0x8f, (0x1 << 2), (0x1 << 2));
+			mod_phy_reg(pi, 0xa7, (0x1 << 2), (0x1 << 2));
+			mod_phy_reg(pi, 0xa5, (0x1 << 2), (0x1 << 2));
+
+			mod_phy_reg(pi, 0xa6, (0x1 << 0), 0);
+			mod_phy_reg(pi, 0x8f, (0x1 << 0), (0x1 << 0));
+			mod_phy_reg(pi, 0xa7, (0x1 << 0), 0);
+			mod_phy_reg(pi, 0xa5, (0x1 << 0), (0x1 << 0));
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1,
+						 0x05, 16,
+						 &afectrl_adc_ctrl2_rev7);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1,
+						 0x15, 16,
+						 &afectrl_adc_ctrl2_rev7);
+
+			mod_phy_reg(pi, 0xa6, (0x1 << 2), 0);
+			mod_phy_reg(pi, 0x8f, (0x1 << 2), 0);
+			mod_phy_reg(pi, 0xa7, (0x1 << 2), 0);
+			mod_phy_reg(pi, 0xa5, (0x1 << 2), 0);
+		}
+
+		write_phy_reg(pi, 0x6a, 0x2);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1, 256, 32,
+					 &min_nvar_offset_6mbps);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x138, 16,
+					 &rfseq_pktgn_lpf_hpc_rev7);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 1, 0x141, 16,
+					 &rfseq_pktgn_lpf_h_hpc_rev7);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 3, 0x133, 16,
+					 &rfseq_htpktgn_lpf_hpc_rev7);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x146, 16,
+					 &rfseq_cckpktgn_lpf_hpc_rev7);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 1, 0x123, 16,
+					 &rfseq_tx2rx_lpf_h_hpc_rev7);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 1, 0x12A, 16,
+					 &rfseq_rx2tx_lpf_h_hpc_rev7);
+
+		if (CHSPEC_IS40(pi->radio_chanspec) == 0) {
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1, 3,
+						 32, &min_nvar_val);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1,
+						 127, 32, &min_nvar_val);
+		} else {
+			min_nvar_val = noise_var_tbl_rev7[3];
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1, 3,
+						 32, &min_nvar_val);
+
+			min_nvar_val = noise_var_tbl_rev7[127];
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1,
+						 127, 32, &min_nvar_val);
+		}
+
+		wlc_phy_workarounds_nphy_gainctrl(pi);
+
+		pdetrange =
+		    (CHSPEC_IS5G(pi->radio_chanspec)) ? pi->srom_fem5g.
+		    pdetrange : pi->srom_fem2g.pdetrange;
+
+		if (pdetrange == 0) {
+			chan_freq_range =
+			    wlc_phy_get_chan_freq_range_nphy(pi, 0);
+			if (chan_freq_range != WL_CHAN_FREQ_RANGE_2G) {
+				aux_adc_vmid_rev7_core0[3] = 0x70;
+				aux_adc_vmid_rev7_core1[3] = 0x70;
+				aux_adc_gain_rev7[3] = 2;
+			} else {
+				aux_adc_vmid_rev7_core0[3] = 0x80;
+				aux_adc_vmid_rev7_core1[3] = 0x80;
+				aux_adc_gain_rev7[3] = 3;
+			}
+		} else if (pdetrange == 1) {
+			if (chan_freq_range != WL_CHAN_FREQ_RANGE_2G) {
+				aux_adc_vmid_rev7_core0[3] = 0x7c;
+				aux_adc_vmid_rev7_core1[3] = 0x7c;
+				aux_adc_gain_rev7[3] = 2;
+			} else {
+				aux_adc_vmid_rev7_core0[3] = 0x8c;
+				aux_adc_vmid_rev7_core1[3] = 0x8c;
+				aux_adc_gain_rev7[3] = 1;
+			}
+		} else if (pdetrange == 2) {
+			if (pi->pubpi.radioid == BCM2057_ID) {
+				if ((pi->pubpi.radiorev == 5)
+				    || (pi->pubpi.radiorev == 7)
+				    || (pi->pubpi.radiorev == 8)) {
+					if (chan_freq_range ==
+					    WL_CHAN_FREQ_RANGE_2G) {
+						aux_adc_vmid_rev7_core0[3] =
+						    0x8c;
+						aux_adc_vmid_rev7_core1[3] =
+						    0x8c;
+						aux_adc_gain_rev7[3] = 0;
+					} else {
+						aux_adc_vmid_rev7_core0[3] =
+						    0x96;
+						aux_adc_vmid_rev7_core1[3] =
+						    0x96;
+						aux_adc_gain_rev7[3] = 0;
+					}
+				}
+			}
+
+		} else if (pdetrange == 3) {
+			if (chan_freq_range == WL_CHAN_FREQ_RANGE_2G) {
+				aux_adc_vmid_rev7_core0[3] = 0x89;
+				aux_adc_vmid_rev7_core1[3] = 0x89;
+				aux_adc_gain_rev7[3] = 0;
+			}
+
+		} else if (pdetrange == 5) {
+
+			if (chan_freq_range != WL_CHAN_FREQ_RANGE_2G) {
+				aux_adc_vmid_rev7_core0[3] = 0x80;
+				aux_adc_vmid_rev7_core1[3] = 0x80;
+				aux_adc_gain_rev7[3] = 3;
+			} else {
+				aux_adc_vmid_rev7_core0[3] = 0x70;
+				aux_adc_vmid_rev7_core1[3] = 0x70;
+				aux_adc_gain_rev7[3] = 2;
+			}
+		}
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4, 0x08, 16,
+					 &aux_adc_vmid_rev7_core0);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4, 0x18, 16,
+					 &aux_adc_vmid_rev7_core1);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4, 0x0c, 16,
+					 &aux_adc_gain_rev7);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4, 0x1c, 16,
+					 &aux_adc_gain_rev7);
+
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+		write_phy_reg(pi, 0x23f, 0x1f8);
+		write_phy_reg(pi, 0x240, 0x1f8);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL,
+					1, 0, 32, &leg_data_weights);
+		leg_data_weights = leg_data_weights & 0xffffff;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL,
+					 1, 0, 32, &leg_data_weights);
+
+		alpha0 = 293;
+		alpha1 = 435;
+		alpha2 = 261;
+		beta0 = 366;
+		beta1 = 205;
+		beta2 = 32;
+		write_phy_reg(pi, 0x145, alpha0);
+		write_phy_reg(pi, 0x146, alpha1);
+		write_phy_reg(pi, 0x147, alpha2);
+		write_phy_reg(pi, 0x148, beta0);
+		write_phy_reg(pi, 0x149, beta1);
+		write_phy_reg(pi, 0x14a, beta2);
+
+		write_phy_reg(pi, 0x38, 0xC);
+		write_phy_reg(pi, 0x2ae, 0xC);
+
+		wlc_phy_set_rfseq_nphy(pi, NPHY_RFSEQ_TX2RX,
+				       rfseq_tx2rx_events_rev3,
+				       rfseq_tx2rx_dlys_rev3,
+				       sizeof(rfseq_tx2rx_events_rev3) /
+				       sizeof(rfseq_tx2rx_events_rev3[0]));
+
+		if (PHY_IPA(pi)) {
+			wlc_phy_set_rfseq_nphy(pi, NPHY_RFSEQ_RX2TX,
+					       rfseq_rx2tx_events_rev3_ipa,
+					       rfseq_rx2tx_dlys_rev3_ipa,
+					       sizeof
+					       (rfseq_rx2tx_events_rev3_ipa) /
+					       sizeof
+					       (rfseq_rx2tx_events_rev3_ipa
+						[0]));
+		}
+
+		if ((pi->sh->hw_phyrxchain != 0x3) &&
+		    (pi->sh->hw_phyrxchain != pi->sh->hw_phytxchain)) {
+
+			if (PHY_IPA(pi)) {
+				rfseq_rx2tx_dlys_rev3[5] = 59;
+				rfseq_rx2tx_dlys_rev3[6] = 1;
+				rfseq_rx2tx_events_rev3[7] =
+				    NPHY_REV3_RFSEQ_CMD_END;
+			}
+
+			wlc_phy_set_rfseq_nphy(pi, NPHY_RFSEQ_RX2TX,
+					       rfseq_rx2tx_events_rev3,
+					       rfseq_rx2tx_dlys_rev3,
+					       sizeof(rfseq_rx2tx_events_rev3) /
+					       sizeof(rfseq_rx2tx_events_rev3
+						      [0]));
+		}
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			write_phy_reg(pi, 0x6a, 0x2);
+		} else {
+			write_phy_reg(pi, 0x6a, 0x9c40);
+		}
+
+		mod_phy_reg(pi, 0x294, (0xf << 8), (7 << 8));
+
+		if (CHSPEC_IS40(pi->radio_chanspec) == 0) {
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1, 3,
+						 32, &min_nvar_val);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1,
+						 127, 32, &min_nvar_val);
+		} else {
+			min_nvar_val = noise_var_tbl_rev3[3];
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1, 3,
+						 32, &min_nvar_val);
+
+			min_nvar_val = noise_var_tbl_rev3[127];
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1,
+						 127, 32, &min_nvar_val);
+		}
+
+		wlc_phy_workarounds_nphy_gainctrl(pi);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x00, 16,
+					 &dac_control);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x10, 16,
+					 &dac_control);
+
+		pdetrange =
+		    (CHSPEC_IS5G(pi->radio_chanspec)) ? pi->srom_fem5g.
+		    pdetrange : pi->srom_fem2g.pdetrange;
+
+		if (pdetrange == 0) {
+			if (NREV_GE(pi->pubpi.phy_rev, 4)) {
+				aux_adc_vmid = aux_adc_vmid_rev4;
+				aux_adc_gain = aux_adc_gain_rev4;
+			} else {
+				aux_adc_vmid = aux_adc_vmid_rev3;
+				aux_adc_gain = aux_adc_gain_rev3;
+			}
+			chan_freq_range =
+			    wlc_phy_get_chan_freq_range_nphy(pi, 0);
+			if (chan_freq_range != WL_CHAN_FREQ_RANGE_2G) {
+				switch (chan_freq_range) {
+				case WL_CHAN_FREQ_RANGE_5GL:
+					aux_adc_vmid[3] = 0x89;
+					aux_adc_gain[3] = 0;
+					break;
+				case WL_CHAN_FREQ_RANGE_5GM:
+					aux_adc_vmid[3] = 0x89;
+					aux_adc_gain[3] = 0;
+					break;
+				case WL_CHAN_FREQ_RANGE_5GH:
+					aux_adc_vmid[3] = 0x89;
+					aux_adc_gain[3] = 0;
+					break;
+				default:
+					break;
+				}
+			}
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x08, 16, aux_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x18, 16, aux_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x0c, 16, aux_adc_gain);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x1c, 16, aux_adc_gain);
+		} else if (pdetrange == 1) {
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x08, 16, sk_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x18, 16, sk_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x0c, 16, sk_adc_gain);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x1c, 16, sk_adc_gain);
+		} else if (pdetrange == 2) {
+
+			uint16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x74 };
+			uint16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x04 };
+
+			if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+				chan_freq_range =
+				    wlc_phy_get_chan_freq_range_nphy(pi, 0);
+				if (chan_freq_range != WL_CHAN_FREQ_RANGE_2G) {
+					bcm_adc_vmid[3] = 0x8e;
+					bcm_adc_gain[3] = 0x03;
+				} else {
+					bcm_adc_vmid[3] = 0x94;
+					bcm_adc_gain[3] = 0x03;
+				}
+			} else if (NREV_IS(pi->pubpi.phy_rev, 5)) {
+				bcm_adc_vmid[3] = 0x84;
+				bcm_adc_gain[3] = 0x02;
+			}
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x08, 16, bcm_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x18, 16, bcm_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x0c, 16, bcm_adc_gain);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x1c, 16, bcm_adc_gain);
+		} else if (pdetrange == 3) {
+			chan_freq_range =
+			    wlc_phy_get_chan_freq_range_nphy(pi, 0);
+			if ((NREV_GE(pi->pubpi.phy_rev, 4))
+			    && (chan_freq_range == WL_CHAN_FREQ_RANGE_2G)) {
+
+				uint16 auxadc_vmid[] =
+				    { 0xa2, 0xb4, 0xb4, 0x270 };
+				uint16 auxadc_gain[] =
+				    { 0x02, 0x02, 0x02, 0x00 };
+
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_AFECTRL, 4,
+							 0x08, 16, auxadc_vmid);
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_AFECTRL, 4,
+							 0x18, 16, auxadc_vmid);
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_AFECTRL, 4,
+							 0x0c, 16, auxadc_gain);
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_AFECTRL, 4,
+							 0x1c, 16, auxadc_gain);
+			}
+		} else if ((pdetrange == 4) || (pdetrange == 5)) {
+			uint16 bcm_adc_vmid[] = { 0xa2, 0xb4, 0xb4, 0x0 };
+			uint16 bcm_adc_gain[] = { 0x02, 0x02, 0x02, 0x0 };
+			uint16 Vmid[2], Av[2];
+
+			chan_freq_range =
+			    wlc_phy_get_chan_freq_range_nphy(pi, 0);
+			if (chan_freq_range != WL_CHAN_FREQ_RANGE_2G) {
+				Vmid[0] = (pdetrange == 4) ? 0x8e : 0x89;
+				Vmid[1] = (pdetrange == 4) ? 0x96 : 0x89;
+				Av[0] = (pdetrange == 4) ? 2 : 0;
+				Av[1] = (pdetrange == 4) ? 2 : 0;
+			} else {
+				Vmid[0] = (pdetrange == 4) ? 0x89 : 0x74;
+				Vmid[1] = (pdetrange == 4) ? 0x8b : 0x70;
+				Av[0] = (pdetrange == 4) ? 2 : 0;
+				Av[1] = (pdetrange == 4) ? 2 : 0;
+			}
+
+			bcm_adc_vmid[3] = Vmid[0];
+			bcm_adc_gain[3] = Av[0];
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x08, 16, bcm_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x0c, 16, bcm_adc_gain);
+
+			bcm_adc_vmid[3] = Vmid[1];
+			bcm_adc_gain[3] = Av[1];
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x18, 16, bcm_adc_vmid);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 4,
+						 0x1c, 16, bcm_adc_gain);
+		} else {
+			ASSERT(0);
+		}
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_MAST_BIAS | RADIO_2056_RX0),
+				0x0);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_MAST_BIAS | RADIO_2056_RX1),
+				0x0);
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_BIAS_MAIN | RADIO_2056_RX0),
+				0x6);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_BIAS_MAIN | RADIO_2056_RX1),
+				0x6);
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_BIAS_AUX | RADIO_2056_RX0),
+				0x7);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_BIAS_AUX | RADIO_2056_RX1),
+				0x7);
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_LOB_BIAS | RADIO_2056_RX0),
+				0x88);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_LOB_BIAS | RADIO_2056_RX1),
+				0x88);
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_CMFB_IDAC | RADIO_2056_RX0),
+				0x0);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXA_CMFB_IDAC | RADIO_2056_RX1),
+				0x0);
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXG_CMFB_IDAC | RADIO_2056_RX0),
+				0x0);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_MIXG_CMFB_IDAC | RADIO_2056_RX1),
+				0x0);
+
+		triso =
+		    (CHSPEC_IS5G(pi->radio_chanspec)) ? pi->srom_fem5g.
+		    triso : pi->srom_fem2g.triso;
+		if (triso == 7) {
+			wlc_phy_war_force_trsw_to_R_cliplo_nphy(pi, PHY_CORE_0);
+			wlc_phy_war_force_trsw_to_R_cliplo_nphy(pi, PHY_CORE_1);
+		}
+
+		wlc_phy_war_txchain_upd_nphy(pi, pi->sh->hw_phytxchain);
+
+		if (((pi->sh->boardflags2 & BFL2_APLL_WAR) &&
+		     (CHSPEC_IS5G(pi->radio_chanspec))) ||
+		    (((pi->sh->boardflags2 & BFL2_GPLL_WAR) ||
+		      (pi->sh->boardflags2 & BFL2_GPLL_WAR2)) &&
+		     (CHSPEC_IS2G(pi->radio_chanspec)))) {
+			nss1_data_weights = 0x00088888;
+			ht_data_weights = 0x00088888;
+			stbc_data_weights = 0x00088888;
+		} else {
+			nss1_data_weights = 0x88888888;
+			ht_data_weights = 0x88888888;
+			stbc_data_weights = 0x88888888;
+		}
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL,
+					 1, 1, 32, &nss1_data_weights);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL,
+					 1, 2, 32, &ht_data_weights);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL,
+					 1, 3, 32, &stbc_data_weights);
+
+		if (NREV_IS(pi->pubpi.phy_rev, 4)) {
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				write_radio_reg(pi,
+						RADIO_2056_TX_GMBB_IDAC |
+						RADIO_2056_TX0, 0x70);
+				write_radio_reg(pi,
+						RADIO_2056_TX_GMBB_IDAC |
+						RADIO_2056_TX1, 0x70);
+			}
+		}
+
+		if (!pi->edcrs_threshold_lock) {
+			write_phy_reg(pi, 0x224, 0x3eb);
+			write_phy_reg(pi, 0x225, 0x3eb);
+			write_phy_reg(pi, 0x226, 0x341);
+			write_phy_reg(pi, 0x227, 0x341);
+			write_phy_reg(pi, 0x228, 0x42b);
+			write_phy_reg(pi, 0x229, 0x42b);
+			write_phy_reg(pi, 0x22a, 0x381);
+			write_phy_reg(pi, 0x22b, 0x381);
+			write_phy_reg(pi, 0x22c, 0x42b);
+			write_phy_reg(pi, 0x22d, 0x42b);
+			write_phy_reg(pi, 0x22e, 0x381);
+			write_phy_reg(pi, 0x22f, 0x381);
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+
+			if (pi->sh->boardflags2 & BFL2_SINGLEANT_CCK) {
+				wlapi_bmac_mhf(pi->sh->physhim, MHF4,
+					       MHF4_BPHY_TXCORE0,
+					       MHF4_BPHY_TXCORE0, WLC_BAND_ALL);
+			}
+		}
+	} else {
+
+		if (pi->sh->boardflags2 & BFL2_SKWRKFEM_BRD ||
+		    (pi->sh->boardtype == 0x8b)) {
+			uint i;
+			uint8 war_dlys[] = { 1, 6, 6, 2, 4, 20, 1 };
+			for (i = 0; i < ARRAYSIZE(rfseq_rx2tx_dlys); i++)
+				rfseq_rx2tx_dlys[i] = war_dlys[i];
+		}
+
+		if (CHSPEC_IS5G(pi->radio_chanspec) && pi->phy_5g_pwrgain) {
+			and_radio_reg(pi, RADIO_2055_CORE1_TX_RF_SPARE, 0xf7);
+			and_radio_reg(pi, RADIO_2055_CORE2_TX_RF_SPARE, 0xf7);
+		} else {
+			or_radio_reg(pi, RADIO_2055_CORE1_TX_RF_SPARE, 0x8);
+			or_radio_reg(pi, RADIO_2055_CORE2_TX_RF_SPARE, 0x8);
+		}
+
+		regval = 0x000a;
+		wlc_phy_table_write_nphy(pi, 8, 1, 0, 16, &regval);
+		wlc_phy_table_write_nphy(pi, 8, 1, 0x10, 16, &regval);
+
+		if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+			regval = 0xcdaa;
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x02, 16, &regval);
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x12, 16, &regval);
+		}
+
+		if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+			regval = 0x0000;
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x08, 16, &regval);
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x18, 16, &regval);
+
+			regval = 0x7aab;
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x07, 16, &regval);
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x17, 16, &regval);
+
+			regval = 0x0800;
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x06, 16, &regval);
+			wlc_phy_table_write_nphy(pi, 8, 1, 0x16, 16, &regval);
+		}
+
+		write_phy_reg(pi, 0xf8, 0x02d8);
+		write_phy_reg(pi, 0xf9, 0x0301);
+		write_phy_reg(pi, 0xfa, 0x02d8);
+		write_phy_reg(pi, 0xfb, 0x0301);
+
+		wlc_phy_set_rfseq_nphy(pi, NPHY_RFSEQ_RX2TX, rfseq_rx2tx_events,
+				       rfseq_rx2tx_dlys,
+				       sizeof(rfseq_rx2tx_events) /
+				       sizeof(rfseq_rx2tx_events[0]));
+
+		wlc_phy_set_rfseq_nphy(pi, NPHY_RFSEQ_TX2RX, rfseq_tx2rx_events,
+				       rfseq_tx2rx_dlys,
+				       sizeof(rfseq_tx2rx_events) /
+				       sizeof(rfseq_tx2rx_events[0]));
+
+		wlc_phy_workarounds_nphy_gainctrl(pi);
+
+		if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+
+			if (read_phy_reg(pi, 0xa0) & NPHY_MLenable)
+				wlapi_bmac_mhf(pi->sh->physhim, MHF3,
+					       MHF3_NPHY_MLADV_WAR,
+					       MHF3_NPHY_MLADV_WAR,
+					       WLC_BAND_ALL);
+
+		} else if (NREV_IS(pi->pubpi.phy_rev, 2)) {
+			write_phy_reg(pi, 0x1e3, 0x0);
+			write_phy_reg(pi, 0x1e4, 0x0);
+		}
+
+		if (NREV_LT(pi->pubpi.phy_rev, 2))
+			mod_phy_reg(pi, 0x90, (0x1 << 7), 0);
+
+		alpha0 = 293;
+		alpha1 = 435;
+		alpha2 = 261;
+		beta0 = 366;
+		beta1 = 205;
+		beta2 = 32;
+		write_phy_reg(pi, 0x145, alpha0);
+		write_phy_reg(pi, 0x146, alpha1);
+		write_phy_reg(pi, 0x147, alpha2);
+		write_phy_reg(pi, 0x148, beta0);
+		write_phy_reg(pi, 0x149, beta1);
+		write_phy_reg(pi, 0x14a, beta2);
+
+		if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+			mod_phy_reg(pi, 0x142, (0xf << 12), 0);
+
+			write_phy_reg(pi, 0x192, 0xb5);
+			write_phy_reg(pi, 0x193, 0xa4);
+			write_phy_reg(pi, 0x194, 0x0);
+		}
+
+		if (NREV_IS(pi->pubpi.phy_rev, 2)) {
+			mod_phy_reg(pi, 0x221,
+				    NPHY_FORCESIG_DECODEGATEDCLKS,
+				    NPHY_FORCESIG_DECODEGATEDCLKS);
+		}
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static void wlc_phy_workarounds_nphy_gainctrl(phy_info_t * pi)
+{
+	uint16 w1th, hpf_code, currband;
+	int ctr;
+	uint8 rfseq_updategainu_events[] = {
+		NPHY_RFSEQ_CMD_RX_GAIN,
+		NPHY_RFSEQ_CMD_CLR_HIQ_DIS,
+		NPHY_RFSEQ_CMD_SET_HPF_BW
+	};
+	uint8 rfseq_updategainu_dlys[] = { 10, 30, 1 };
+	int8 lna1G_gain_db[] = { 7, 11, 16, 23 };
+	int8 lna1G_gain_db_rev4[] = { 8, 12, 17, 25 };
+	int8 lna1G_gain_db_rev5[] = { 9, 13, 18, 26 };
+	int8 lna1G_gain_db_rev6[] = { 8, 13, 18, 25 };
+	int8 lna1G_gain_db_rev6_224B0[] = { 10, 14, 19, 27 };
+	int8 lna1A_gain_db[] = { 7, 11, 17, 23 };
+	int8 lna1A_gain_db_rev4[] = { 8, 12, 18, 23 };
+	int8 lna1A_gain_db_rev5[] = { 6, 10, 16, 21 };
+	int8 lna1A_gain_db_rev6[] = { 6, 10, 16, 21 };
+	int8 *lna1_gain_db = NULL;
+	int8 lna2G_gain_db[] = { -5, 6, 10, 14 };
+	int8 lna2G_gain_db_rev5[] = { -3, 7, 11, 16 };
+	int8 lna2G_gain_db_rev6[] = { -5, 6, 10, 14 };
+	int8 lna2G_gain_db_rev6_224B0[] = { -5, 6, 10, 15 };
+	int8 lna2A_gain_db[] = { -6, 2, 6, 10 };
+	int8 lna2A_gain_db_rev4[] = { -5, 2, 6, 10 };
+	int8 lna2A_gain_db_rev5[] = { -7, 0, 4, 8 };
+	int8 lna2A_gain_db_rev6[] = { -7, 0, 4, 8 };
+	int8 *lna2_gain_db = NULL;
+	int8 tiaG_gain_db[] =
+	    { 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A };
+	int8 tiaA_gain_db[] =
+	    { 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13 };
+	int8 tiaA_gain_db_rev4[] =
+	    { 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
+	int8 tiaA_gain_db_rev5[] =
+	    { 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
+	int8 tiaA_gain_db_rev6[] =
+	    { 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d };
+	int8 *tia_gain_db;
+	int8 tiaG_gainbits[] =
+	    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
+	int8 tiaA_gainbits[] =
+	    { 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06 };
+	int8 tiaA_gainbits_rev4[] =
+	    { 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
+	int8 tiaA_gainbits_rev5[] =
+	    { 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
+	int8 tiaA_gainbits_rev6[] =
+	    { 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04 };
+	int8 *tia_gainbits;
+	int8 lpf_gain_db[] = { 0x00, 0x06, 0x0c, 0x12, 0x12, 0x12 };
+	int8 lpf_gainbits[] = { 0x00, 0x01, 0x02, 0x03, 0x03, 0x03 };
+	uint16 rfseqG_init_gain[] = { 0x613f, 0x613f, 0x613f, 0x613f };
+	uint16 rfseqG_init_gain_rev4[] = { 0x513f, 0x513f, 0x513f, 0x513f };
+	uint16 rfseqG_init_gain_rev5[] = { 0x413f, 0x413f, 0x413f, 0x413f };
+	uint16 rfseqG_init_gain_rev5_elna[] =
+	    { 0x013f, 0x013f, 0x013f, 0x013f };
+	uint16 rfseqG_init_gain_rev6[] = { 0x513f, 0x513f };
+	uint16 rfseqG_init_gain_rev6_224B0[] = { 0x413f, 0x413f };
+	uint16 rfseqG_init_gain_rev6_elna[] = { 0x113f, 0x113f };
+	uint16 rfseqA_init_gain[] = { 0x516f, 0x516f, 0x516f, 0x516f };
+	uint16 rfseqA_init_gain_rev4[] = { 0x614f, 0x614f, 0x614f, 0x614f };
+	uint16 rfseqA_init_gain_rev4_elna[] =
+	    { 0x314f, 0x314f, 0x314f, 0x314f };
+	uint16 rfseqA_init_gain_rev5[] = { 0x714f, 0x714f, 0x714f, 0x714f };
+	uint16 rfseqA_init_gain_rev6[] = { 0x714f, 0x714f };
+	uint16 *rfseq_init_gain;
+	uint16 initG_gaincode = 0x627e;
+	uint16 initG_gaincode_rev4 = 0x527e;
+	uint16 initG_gaincode_rev5 = 0x427e;
+	uint16 initG_gaincode_rev5_elna = 0x027e;
+	uint16 initG_gaincode_rev6 = 0x527e;
+	uint16 initG_gaincode_rev6_224B0 = 0x427e;
+	uint16 initG_gaincode_rev6_elna = 0x127e;
+	uint16 initA_gaincode = 0x52de;
+	uint16 initA_gaincode_rev4 = 0x629e;
+	uint16 initA_gaincode_rev4_elna = 0x329e;
+	uint16 initA_gaincode_rev5 = 0x729e;
+	uint16 initA_gaincode_rev6 = 0x729e;
+	uint16 init_gaincode;
+	uint16 clip1hiG_gaincode = 0x107e;
+	uint16 clip1hiG_gaincode_rev4 = 0x007e;
+	uint16 clip1hiG_gaincode_rev5 = 0x1076;
+	uint16 clip1hiG_gaincode_rev6 = 0x007e;
+	uint16 clip1hiA_gaincode = 0x00de;
+	uint16 clip1hiA_gaincode_rev4 = 0x029e;
+	uint16 clip1hiA_gaincode_rev5 = 0x029e;
+	uint16 clip1hiA_gaincode_rev6 = 0x029e;
+	uint16 clip1hi_gaincode;
+	uint16 clip1mdG_gaincode = 0x0066;
+	uint16 clip1mdA_gaincode = 0x00ca;
+	uint16 clip1mdA_gaincode_rev4 = 0x1084;
+	uint16 clip1mdA_gaincode_rev5 = 0x2084;
+	uint16 clip1mdA_gaincode_rev6 = 0x2084;
+	uint16 clip1md_gaincode = 0;
+	uint16 clip1loG_gaincode = 0x0074;
+	uint16 clip1loG_gaincode_rev5[] = {
+		0x0062, 0x0064, 0x006a, 0x106a, 0x106c, 0x1074, 0x107c, 0x207c
+	};
+	uint16 clip1loG_gaincode_rev6[] = {
+		0x106a, 0x106c, 0x1074, 0x107c, 0x007e, 0x107e, 0x207e, 0x307e
+	};
+	uint16 clip1loG_gaincode_rev6_224B0 = 0x1074;
+	uint16 clip1loA_gaincode = 0x00cc;
+	uint16 clip1loA_gaincode_rev4 = 0x0086;
+	uint16 clip1loA_gaincode_rev5 = 0x2086;
+	uint16 clip1loA_gaincode_rev6 = 0x2086;
+	uint16 clip1lo_gaincode;
+	uint8 crsminG_th = 0x18;
+	uint8 crsminG_th_rev5 = 0x18;
+	uint8 crsminG_th_rev6 = 0x18;
+	uint8 crsminA_th = 0x1e;
+	uint8 crsminA_th_rev4 = 0x24;
+	uint8 crsminA_th_rev5 = 0x24;
+	uint8 crsminA_th_rev6 = 0x24;
+	uint8 crsmin_th;
+	uint8 crsminlG_th = 0x18;
+	uint8 crsminlG_th_rev5 = 0x18;
+	uint8 crsminlG_th_rev6 = 0x18;
+	uint8 crsminlA_th = 0x1e;
+	uint8 crsminlA_th_rev4 = 0x24;
+	uint8 crsminlA_th_rev5 = 0x24;
+	uint8 crsminlA_th_rev6 = 0x24;
+	uint8 crsminl_th = 0;
+	uint8 crsminuG_th = 0x18;
+	uint8 crsminuG_th_rev5 = 0x18;
+	uint8 crsminuG_th_rev6 = 0x18;
+	uint8 crsminuA_th = 0x1e;
+	uint8 crsminuA_th_rev4 = 0x24;
+	uint8 crsminuA_th_rev5 = 0x24;
+	uint8 crsminuA_th_rev6 = 0x24;
+	uint8 crsminuA_th_rev6_224B0 = 0x2d;
+	uint8 crsminu_th;
+	uint16 nbclipG_th = 0x20d;
+	uint16 nbclipG_th_rev4 = 0x1a1;
+	uint16 nbclipG_th_rev5 = 0x1d0;
+	uint16 nbclipG_th_rev6 = 0x1d0;
+	uint16 nbclipA_th = 0x1a1;
+	uint16 nbclipA_th_rev4 = 0x107;
+	uint16 nbclipA_th_rev5 = 0x0a9;
+	uint16 nbclipA_th_rev6 = 0x0f0;
+	uint16 nbclip_th = 0;
+	uint8 w1clipG_th = 5;
+	uint8 w1clipG_th_rev5 = 9;
+	uint8 w1clipG_th_rev6 = 5;
+	uint8 w1clipA_th = 25, w1clip_th;
+	uint8 rssi_gain_default = 0x50;
+	uint8 rssiG_gain_rev6_224B0 = 0x50;
+	uint8 rssiA_gain_rev5 = 0x90;
+	uint8 rssiA_gain_rev6 = 0x90;
+	uint8 rssi_gain;
+	uint16 regval[21];
+	uint8 triso;
+
+	triso = (CHSPEC_IS5G(pi->radio_chanspec)) ? pi->srom_fem5g.triso :
+	    pi->srom_fem2g.triso;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		if (pi->pubpi.radiorev == 5) {
+
+			wlc_phy_workarounds_nphy_gainctrl_2057_rev5(pi);
+		} else if (pi->pubpi.radiorev == 7) {
+			wlc_phy_workarounds_nphy_gainctrl_2057_rev6(pi);
+
+			mod_phy_reg(pi, 0x283, (0xff << 0), (0x44 << 0));
+			mod_phy_reg(pi, 0x280, (0xff << 0), (0x44 << 0));
+
+		} else if ((pi->pubpi.radiorev == 3)
+			   || (pi->pubpi.radiorev == 8)) {
+			wlc_phy_workarounds_nphy_gainctrl_2057_rev6(pi);
+
+			if (pi->pubpi.radiorev == 8) {
+				mod_phy_reg(pi, 0x283,
+					    (0xff << 0), (0x44 << 0));
+				mod_phy_reg(pi, 0x280,
+					    (0xff << 0), (0x44 << 0));
+			}
+		} else {
+			wlc_phy_workarounds_nphy_gainctrl_2057_rev6(pi);
+		}
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+		mod_phy_reg(pi, 0xa0, (0x1 << 6), (1 << 6));
+
+		mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
+		mod_phy_reg(pi, 0x32, (0x1 << 13), (1 << 13));
+
+		currband =
+		    read_phy_reg(pi, 0x09) & NPHY_BandControl_currentBand;
+		if (currband == 0) {
+			if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+				if (pi->pubpi.radiorev == 11) {
+					lna1_gain_db = lna1G_gain_db_rev6_224B0;
+					lna2_gain_db = lna2G_gain_db_rev6_224B0;
+					rfseq_init_gain =
+					    rfseqG_init_gain_rev6_224B0;
+					init_gaincode =
+					    initG_gaincode_rev6_224B0;
+					clip1hi_gaincode =
+					    clip1hiG_gaincode_rev6;
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev6_224B0;
+					nbclip_th = nbclipG_th_rev6;
+					w1clip_th = w1clipG_th_rev6;
+					crsmin_th = crsminG_th_rev6;
+					crsminl_th = crsminlG_th_rev6;
+					crsminu_th = crsminuG_th_rev6;
+					rssi_gain = rssiG_gain_rev6_224B0;
+				} else {
+					lna1_gain_db = lna1G_gain_db_rev6;
+					lna2_gain_db = lna2G_gain_db_rev6;
+					if (pi->sh->boardflags & BFL_EXTLNA) {
+
+						rfseq_init_gain =
+						    rfseqG_init_gain_rev6_elna;
+						init_gaincode =
+						    initG_gaincode_rev6_elna;
+					} else {
+						rfseq_init_gain =
+						    rfseqG_init_gain_rev6;
+						init_gaincode =
+						    initG_gaincode_rev6;
+					}
+					clip1hi_gaincode =
+					    clip1hiG_gaincode_rev6;
+					switch (triso) {
+					case 0:
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[0];
+						break;
+					case 1:
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[1];
+						break;
+					case 2:
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[2];
+						break;
+					case 3:
+					default:
+
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[3];
+						break;
+					case 4:
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[4];
+						break;
+					case 5:
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[5];
+						break;
+					case 6:
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[6];
+						break;
+					case 7:
+						clip1lo_gaincode =
+						    clip1loG_gaincode_rev6[7];
+						break;
+					}
+					nbclip_th = nbclipG_th_rev6;
+					w1clip_th = w1clipG_th_rev6;
+					crsmin_th = crsminG_th_rev6;
+					crsminl_th = crsminlG_th_rev6;
+					crsminu_th = crsminuG_th_rev6;
+					rssi_gain = rssi_gain_default;
+				}
+			} else if (NREV_IS(pi->pubpi.phy_rev, 5)) {
+				lna1_gain_db = lna1G_gain_db_rev5;
+				lna2_gain_db = lna2G_gain_db_rev5;
+				if (pi->sh->boardflags & BFL_EXTLNA) {
+
+					rfseq_init_gain =
+					    rfseqG_init_gain_rev5_elna;
+					init_gaincode =
+					    initG_gaincode_rev5_elna;
+				} else {
+					rfseq_init_gain = rfseqG_init_gain_rev5;
+					init_gaincode = initG_gaincode_rev5;
+				}
+				clip1hi_gaincode = clip1hiG_gaincode_rev5;
+				switch (triso) {
+				case 0:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[0];
+					break;
+				case 1:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[1];
+					break;
+				case 2:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[2];
+					break;
+				case 3:
+
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[3];
+					break;
+				case 4:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[4];
+					break;
+				case 5:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[5];
+					break;
+				case 6:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[6];
+					break;
+				case 7:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[7];
+					break;
+				default:
+					clip1lo_gaincode =
+					    clip1loG_gaincode_rev5[3];
+					break;
+				}
+				nbclip_th = nbclipG_th_rev5;
+				w1clip_th = w1clipG_th_rev5;
+				crsmin_th = crsminG_th_rev5;
+				crsminl_th = crsminlG_th_rev5;
+				crsminu_th = crsminuG_th_rev5;
+				rssi_gain = rssi_gain_default;
+			} else if (NREV_IS(pi->pubpi.phy_rev, 4)) {
+				lna1_gain_db = lna1G_gain_db_rev4;
+				lna2_gain_db = lna2G_gain_db;
+				rfseq_init_gain = rfseqG_init_gain_rev4;
+				init_gaincode = initG_gaincode_rev4;
+				clip1hi_gaincode = clip1hiG_gaincode_rev4;
+				clip1lo_gaincode = clip1loG_gaincode;
+				nbclip_th = nbclipG_th_rev4;
+				w1clip_th = w1clipG_th;
+				crsmin_th = crsminG_th;
+				crsminl_th = crsminlG_th;
+				crsminu_th = crsminuG_th;
+				rssi_gain = rssi_gain_default;
+			} else {
+				lna1_gain_db = lna1G_gain_db;
+				lna2_gain_db = lna2G_gain_db;
+				rfseq_init_gain = rfseqG_init_gain;
+				init_gaincode = initG_gaincode;
+				clip1hi_gaincode = clip1hiG_gaincode;
+				clip1lo_gaincode = clip1loG_gaincode;
+				nbclip_th = nbclipG_th;
+				w1clip_th = w1clipG_th;
+				crsmin_th = crsminG_th;
+				crsminl_th = crsminlG_th;
+				crsminu_th = crsminuG_th;
+				rssi_gain = rssi_gain_default;
+			}
+			tia_gain_db = tiaG_gain_db;
+			tia_gainbits = tiaG_gainbits;
+			clip1md_gaincode = clip1mdG_gaincode;
+		} else {
+			if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+				lna1_gain_db = lna1A_gain_db_rev6;
+				lna2_gain_db = lna2A_gain_db_rev6;
+				tia_gain_db = tiaA_gain_db_rev6;
+				tia_gainbits = tiaA_gainbits_rev6;
+				rfseq_init_gain = rfseqA_init_gain_rev6;
+				init_gaincode = initA_gaincode_rev6;
+				clip1hi_gaincode = clip1hiA_gaincode_rev6;
+				clip1md_gaincode = clip1mdA_gaincode_rev6;
+				clip1lo_gaincode = clip1loA_gaincode_rev6;
+				crsmin_th = crsminA_th_rev6;
+				crsminl_th = crsminlA_th_rev6;
+				if ((pi->pubpi.radiorev == 11) &&
+				    (CHSPEC_IS40(pi->radio_chanspec) == 0)) {
+					crsminu_th = crsminuA_th_rev6_224B0;
+				} else {
+					crsminu_th = crsminuA_th_rev6;
+				}
+				nbclip_th = nbclipA_th_rev6;
+				rssi_gain = rssiA_gain_rev6;
+			} else if (NREV_IS(pi->pubpi.phy_rev, 5)) {
+				lna1_gain_db = lna1A_gain_db_rev5;
+				lna2_gain_db = lna2A_gain_db_rev5;
+				tia_gain_db = tiaA_gain_db_rev5;
+				tia_gainbits = tiaA_gainbits_rev5;
+				rfseq_init_gain = rfseqA_init_gain_rev5;
+				init_gaincode = initA_gaincode_rev5;
+				clip1hi_gaincode = clip1hiA_gaincode_rev5;
+				clip1md_gaincode = clip1mdA_gaincode_rev5;
+				clip1lo_gaincode = clip1loA_gaincode_rev5;
+				crsmin_th = crsminA_th_rev5;
+				crsminl_th = crsminlA_th_rev5;
+				crsminu_th = crsminuA_th_rev5;
+				nbclip_th = nbclipA_th_rev5;
+				rssi_gain = rssiA_gain_rev5;
+			} else if (NREV_IS(pi->pubpi.phy_rev, 4)) {
+				lna1_gain_db = lna1A_gain_db_rev4;
+				lna2_gain_db = lna2A_gain_db_rev4;
+				tia_gain_db = tiaA_gain_db_rev4;
+				tia_gainbits = tiaA_gainbits_rev4;
+				if (pi->sh->boardflags & BFL_EXTLNA_5GHz) {
+
+					rfseq_init_gain =
+					    rfseqA_init_gain_rev4_elna;
+					init_gaincode =
+					    initA_gaincode_rev4_elna;
+				} else {
+					rfseq_init_gain = rfseqA_init_gain_rev4;
+					init_gaincode = initA_gaincode_rev4;
+				}
+				clip1hi_gaincode = clip1hiA_gaincode_rev4;
+				clip1md_gaincode = clip1mdA_gaincode_rev4;
+				clip1lo_gaincode = clip1loA_gaincode_rev4;
+				crsmin_th = crsminA_th_rev4;
+				crsminl_th = crsminlA_th_rev4;
+				crsminu_th = crsminuA_th_rev4;
+				nbclip_th = nbclipA_th_rev4;
+				rssi_gain = rssi_gain_default;
+			} else {
+				lna1_gain_db = lna1A_gain_db;
+				lna2_gain_db = lna2A_gain_db;
+				tia_gain_db = tiaA_gain_db;
+				tia_gainbits = tiaA_gainbits;
+				rfseq_init_gain = rfseqA_init_gain;
+				init_gaincode = initA_gaincode;
+				clip1hi_gaincode = clip1hiA_gaincode;
+				clip1md_gaincode = clip1mdA_gaincode;
+				clip1lo_gaincode = clip1loA_gaincode;
+				crsmin_th = crsminA_th;
+				crsminl_th = crsminlA_th;
+				crsminu_th = crsminuA_th;
+				nbclip_th = nbclipA_th;
+				rssi_gain = rssi_gain_default;
+			}
+			w1clip_th = w1clipA_th;
+		}
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_BIASPOLE_LNAG1_IDAC |
+				 RADIO_2056_RX0), 0x17);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_BIASPOLE_LNAG1_IDAC |
+				 RADIO_2056_RX1), 0x17);
+
+		write_radio_reg(pi, (RADIO_2056_RX_LNAG2_IDAC | RADIO_2056_RX0),
+				0xf0);
+		write_radio_reg(pi, (RADIO_2056_RX_LNAG2_IDAC | RADIO_2056_RX1),
+				0xf0);
+
+		write_radio_reg(pi, (RADIO_2056_RX_RSSI_POLE | RADIO_2056_RX0),
+				0x0);
+		write_radio_reg(pi, (RADIO_2056_RX_RSSI_POLE | RADIO_2056_RX1),
+				0x0);
+
+		write_radio_reg(pi, (RADIO_2056_RX_RSSI_GAIN | RADIO_2056_RX0),
+				rssi_gain);
+		write_radio_reg(pi, (RADIO_2056_RX_RSSI_GAIN | RADIO_2056_RX1),
+				rssi_gain);
+
+		write_radio_reg(pi,
+				(RADIO_2056_RX_BIASPOLE_LNAA1_IDAC |
+				 RADIO_2056_RX0), 0x17);
+		write_radio_reg(pi,
+				(RADIO_2056_RX_BIASPOLE_LNAA1_IDAC |
+				 RADIO_2056_RX1), 0x17);
+
+		write_radio_reg(pi, (RADIO_2056_RX_LNAA2_IDAC | RADIO_2056_RX0),
+				0xFF);
+		write_radio_reg(pi, (RADIO_2056_RX_LNAA2_IDAC | RADIO_2056_RX1),
+				0xFF);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 4, 8,
+					 8, lna1_gain_db);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 4, 8,
+					 8, lna1_gain_db);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 4, 0x10,
+					 8, lna2_gain_db);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 4, 0x10,
+					 8, lna2_gain_db);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 10, 0x20,
+					 8, tia_gain_db);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 10, 0x20,
+					 8, tia_gain_db);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS1, 10, 0x20,
+					 8, tia_gainbits);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS2, 10, 0x20,
+					 8, tia_gainbits);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 6, 0x40,
+					 8, &lpf_gain_db);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 6, 0x40,
+					 8, &lpf_gain_db);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS1, 6, 0x40,
+					 8, &lpf_gainbits);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS2, 6, 0x40,
+					 8, &lpf_gainbits);
+
+		write_phy_reg(pi, 0x20, init_gaincode);
+		write_phy_reg(pi, 0x2a7, init_gaincode);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+					 pi->pubpi.phy_corenum, 0x106, 16,
+					 rfseq_init_gain);
+
+		write_phy_reg(pi, 0x22, clip1hi_gaincode);
+		write_phy_reg(pi, 0x2a9, clip1hi_gaincode);
+
+		write_phy_reg(pi, 0x24, clip1md_gaincode);
+		write_phy_reg(pi, 0x2ab, clip1md_gaincode);
+
+		write_phy_reg(pi, 0x37, clip1lo_gaincode);
+		write_phy_reg(pi, 0x2ad, clip1lo_gaincode);
+
+		mod_phy_reg(pi, 0x27d, (0xff << 0), (crsmin_th << 0));
+		mod_phy_reg(pi, 0x280, (0xff << 0), (crsminl_th << 0));
+		mod_phy_reg(pi, 0x283, (0xff << 0), (crsminu_th << 0));
+
+		write_phy_reg(pi, 0x2b, nbclip_th);
+		write_phy_reg(pi, 0x41, nbclip_th);
+
+		mod_phy_reg(pi, 0x27, (0x3f << 0), (w1clip_th << 0));
+		mod_phy_reg(pi, 0x3d, (0x3f << 0), (w1clip_th << 0));
+
+		write_phy_reg(pi, 0x150, 0x809c);
+
+	} else {
+
+		mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
+		mod_phy_reg(pi, 0x32, (0x1 << 13), (1 << 13));
+
+		write_phy_reg(pi, 0x2b, 0x84);
+		write_phy_reg(pi, 0x41, 0x84);
+
+		if (CHSPEC_IS20(pi->radio_chanspec)) {
+			write_phy_reg(pi, 0x6b, 0x2b);
+			write_phy_reg(pi, 0x6c, 0x2b);
+			write_phy_reg(pi, 0x6d, 0x9);
+			write_phy_reg(pi, 0x6e, 0x9);
+		}
+
+		w1th = NPHY_RSSICAL_W1_TARGET - 4;
+		mod_phy_reg(pi, 0x27, (0x3f << 0), (w1th << 0));
+		mod_phy_reg(pi, 0x3d, (0x3f << 0), (w1th << 0));
+
+		if (CHSPEC_IS20(pi->radio_chanspec)) {
+			mod_phy_reg(pi, 0x1c, (0x1f << 0), (0x1 << 0));
+			mod_phy_reg(pi, 0x32, (0x1f << 0), (0x1 << 0));
+
+			mod_phy_reg(pi, 0x1d, (0x1f << 0), (0x1 << 0));
+			mod_phy_reg(pi, 0x33, (0x1f << 0), (0x1 << 0));
+		}
+
+		write_phy_reg(pi, 0x150, 0x809c);
+
+		if (pi->nphy_gain_boost)
+			if ((CHSPEC_IS2G(pi->radio_chanspec)) &&
+			    (CHSPEC_IS40(pi->radio_chanspec)))
+				hpf_code = 4;
+			else
+				hpf_code = 5;
+		else if (CHSPEC_IS40(pi->radio_chanspec))
+			hpf_code = 6;
+		else
+			hpf_code = 7;
+
+		mod_phy_reg(pi, 0x20, (0x1f << 7), (hpf_code << 7));
+		mod_phy_reg(pi, 0x36, (0x1f << 7), (hpf_code << 7));
+
+		for (ctr = 0; ctr < 4; ctr++) {
+			regval[ctr] = (hpf_code << 8) | 0x7c;
+		}
+		wlc_phy_table_write_nphy(pi, 7, 4, 0x106, 16, regval);
+
+		wlc_phy_adjust_lnagaintbl_nphy(pi);
+
+		if (pi->nphy_elna_gain_config) {
+			regval[0] = 0;
+			regval[1] = 1;
+			regval[2] = 1;
+			regval[3] = 1;
+			wlc_phy_table_write_nphy(pi, 2, 4, 8, 16, regval);
+			wlc_phy_table_write_nphy(pi, 3, 4, 8, 16, regval);
+
+			for (ctr = 0; ctr < 4; ctr++) {
+				regval[ctr] = (hpf_code << 8) | 0x74;
+			}
+			wlc_phy_table_write_nphy(pi, 7, 4, 0x106, 16, regval);
+		}
+
+		if (NREV_IS(pi->pubpi.phy_rev, 2)) {
+			for (ctr = 0; ctr < 21; ctr++) {
+				regval[ctr] = 3 * ctr;
+			}
+			wlc_phy_table_write_nphy(pi, 0, 21, 32, 16, regval);
+			wlc_phy_table_write_nphy(pi, 1, 21, 32, 16, regval);
+
+			for (ctr = 0; ctr < 21; ctr++) {
+				regval[ctr] = (uint16) ctr;
+			}
+			wlc_phy_table_write_nphy(pi, 2, 21, 32, 16, regval);
+			wlc_phy_table_write_nphy(pi, 3, 21, 32, 16, regval);
+		}
+
+		wlc_phy_set_rfseq_nphy(pi, NPHY_RFSEQ_UPDATEGAINU,
+				       rfseq_updategainu_events,
+				       rfseq_updategainu_dlys,
+				       sizeof(rfseq_updategainu_events) /
+				       sizeof(rfseq_updategainu_events[0]));
+
+		mod_phy_reg(pi, 0x153, (0xff << 8), (90 << 8));
+
+		if (CHSPEC_IS2G(pi->radio_chanspec))
+			mod_phy_reg(pi,
+				    (NPHY_TO_BPHY_OFF + BPHY_OPTIONAL_MODES),
+				    0x7f, 0x4);
+	}
+}
+
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev5(phy_info_t * pi)
+{
+	int8 lna1_gain_db[] = { 8, 13, 17, 22 };
+	int8 lna2_gain_db[] = { -2, 7, 11, 15 };
+	int8 tia_gain_db[] = { -4, -1, 2, 5, 5, 5, 5, 5, 5, 5 };
+	int8 tia_gainbits[] =
+	    { 0x0, 0x01, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 };
+
+	mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
+	mod_phy_reg(pi, 0x32, (0x1 << 13), (1 << 13));
+
+	mod_phy_reg(pi, 0x289, (0xff << 0), (0x46 << 0));
+
+	mod_phy_reg(pi, 0x283, (0xff << 0), (0x3c << 0));
+	mod_phy_reg(pi, 0x280, (0xff << 0), (0x3c << 0));
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 4, 0x8, 8,
+				 lna1_gain_db);
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 4, 0x8, 8,
+				 lna1_gain_db);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 4, 0x10, 8,
+				 lna2_gain_db);
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 4, 0x10, 8,
+				 lna2_gain_db);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 10, 0x20, 8,
+				 tia_gain_db);
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 10, 0x20, 8,
+				 tia_gain_db);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS1, 10, 0x20, 8,
+				 tia_gainbits);
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS2, 10, 0x20, 8,
+				 tia_gainbits);
+
+	write_phy_reg(pi, 0x37, 0x74);
+	write_phy_reg(pi, 0x2ad, 0x74);
+	write_phy_reg(pi, 0x38, 0x18);
+	write_phy_reg(pi, 0x2ae, 0x18);
+
+	write_phy_reg(pi, 0x2b, 0xe8);
+	write_phy_reg(pi, 0x41, 0xe8);
+
+	if (CHSPEC_IS20(pi->radio_chanspec)) {
+
+		mod_phy_reg(pi, 0x300, (0x3f << 0), (0x12 << 0));
+		mod_phy_reg(pi, 0x301, (0x3f << 0), (0x12 << 0));
+	} else {
+
+		mod_phy_reg(pi, 0x300, (0x3f << 0), (0x10 << 0));
+		mod_phy_reg(pi, 0x301, (0x3f << 0), (0x10 << 0));
+	}
+}
+
+static void wlc_phy_workarounds_nphy_gainctrl_2057_rev6(phy_info_t * pi)
+{
+	uint16 currband;
+	int8 lna1G_gain_db_rev7[] = { 9, 14, 19, 24 };
+	int8 *lna1_gain_db = NULL;
+	int8 *lna1_gain_db_2 = NULL;
+	int8 *lna2_gain_db = NULL;
+	int8 tiaA_gain_db_rev7[] = { -9, -6, -3, 0, 3, 3, 3, 3, 3, 3 };
+	int8 *tia_gain_db;
+	int8 tiaA_gainbits_rev7[] = { 0, 1, 2, 3, 4, 4, 4, 4, 4, 4 };
+	int8 *tia_gainbits;
+	uint16 rfseqA_init_gain_rev7[] = { 0x624f, 0x624f };
+	uint16 *rfseq_init_gain;
+	uint16 init_gaincode;
+	uint16 clip1hi_gaincode;
+	uint16 clip1md_gaincode = 0;
+	uint16 clip1md_gaincode_B;
+	uint16 clip1lo_gaincode;
+	uint16 clip1lo_gaincode_B;
+	uint8 crsminl_th = 0;
+	uint8 crsminu_th;
+	uint16 nbclip_th = 0;
+	uint8 w1clip_th;
+	uint16 freq;
+	int8 nvar_baseline_offset0 = 0, nvar_baseline_offset1 = 0;
+	uint8 chg_nbclip_th = 0;
+
+	mod_phy_reg(pi, 0x1c, (0x1 << 13), (1 << 13));
+	mod_phy_reg(pi, 0x32, (0x1 << 13), (1 << 13));
+
+	currband = read_phy_reg(pi, 0x09) & NPHY_BandControl_currentBand;
+	if (currband == 0) {
+
+		lna1_gain_db = lna1G_gain_db_rev7;
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 4, 8, 8,
+					 lna1_gain_db);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 4, 8, 8,
+					 lna1_gain_db);
+
+		mod_phy_reg(pi, 0x283, (0xff << 0), (0x40 << 0));
+
+		if (CHSPEC_IS40(pi->radio_chanspec)) {
+			mod_phy_reg(pi, 0x280, (0xff << 0), (0x3e << 0));
+			mod_phy_reg(pi, 0x283, (0xff << 0), (0x3e << 0));
+		}
+
+		mod_phy_reg(pi, 0x289, (0xff << 0), (0x46 << 0));
+
+		if (CHSPEC_IS20(pi->radio_chanspec)) {
+			mod_phy_reg(pi, 0x300, (0x3f << 0), (13 << 0));
+			mod_phy_reg(pi, 0x301, (0x3f << 0), (13 << 0));
+		}
+	} else {
+
+		init_gaincode = 0x9e;
+		clip1hi_gaincode = 0x9e;
+		clip1md_gaincode_B = 0x24;
+		clip1lo_gaincode = 0x8a;
+		clip1lo_gaincode_B = 8;
+		rfseq_init_gain = rfseqA_init_gain_rev7;
+
+		tia_gain_db = tiaA_gain_db_rev7;
+		tia_gainbits = tiaA_gainbits_rev7;
+
+		freq = CHAN5G_FREQ(CHSPEC_CHANNEL(pi->radio_chanspec));
+		if (CHSPEC_IS20(pi->radio_chanspec)) {
+
+			w1clip_th = 25;
+			clip1md_gaincode = 0x82;
+
+			if ((freq <= 5080) || (freq == 5825)) {
+
+				int8 lna1A_gain_db_rev7[] = { 11, 16, 20, 24 };
+				int8 lna1A_gain_db_2_rev7[] =
+				    { 11, 17, 22, 25 };
+				int8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
+
+				crsminu_th = 0x3e;
+				lna1_gain_db = lna1A_gain_db_rev7;
+				lna1_gain_db_2 = lna1A_gain_db_2_rev7;
+				lna2_gain_db = lna2A_gain_db_rev7;
+			} else if ((freq >= 5500) && (freq <= 5700)) {
+
+				int8 lna1A_gain_db_rev7[] = { 11, 17, 21, 25 };
+				int8 lna1A_gain_db_2_rev7[] =
+				    { 12, 18, 22, 26 };
+				int8 lna2A_gain_db_rev7[] = { 1, 8, 12, 16 };
+
+				crsminu_th = 0x45;
+				clip1md_gaincode_B = 0x14;
+				nbclip_th = 0xff;
+				chg_nbclip_th = 1;
+				lna1_gain_db = lna1A_gain_db_rev7;
+				lna1_gain_db_2 = lna1A_gain_db_2_rev7;
+				lna2_gain_db = lna2A_gain_db_rev7;
+			} else {
+
+				int8 lna1A_gain_db_rev7[] = { 12, 18, 22, 26 };
+				int8 lna1A_gain_db_2_rev7[] =
+				    { 12, 18, 22, 26 };
+				int8 lna2A_gain_db_rev7[] = { -1, 6, 10, 14 };
+
+				crsminu_th = 0x41;
+				lna1_gain_db = lna1A_gain_db_rev7;
+				lna1_gain_db_2 = lna1A_gain_db_2_rev7;
+				lna2_gain_db = lna2A_gain_db_rev7;
+			}
+
+			if (freq <= 4920) {
+				nvar_baseline_offset0 = 5;
+				nvar_baseline_offset1 = 5;
+			} else if ((freq > 4920) && (freq <= 5320)) {
+				nvar_baseline_offset0 = 3;
+				nvar_baseline_offset1 = 5;
+			} else if ((freq > 5320) && (freq <= 5700)) {
+				nvar_baseline_offset0 = 3;
+				nvar_baseline_offset1 = 2;
+			} else {
+				nvar_baseline_offset0 = 4;
+				nvar_baseline_offset1 = 0;
+			}
+		} else {
+
+			crsminu_th = 0x3a;
+			crsminl_th = 0x3a;
+			w1clip_th = 20;
+
+			if ((freq >= 4920) && (freq <= 5320)) {
+				nvar_baseline_offset0 = 4;
+				nvar_baseline_offset1 = 5;
+			} else if ((freq > 5320) && (freq <= 5550)) {
+				nvar_baseline_offset0 = 4;
+				nvar_baseline_offset1 = 2;
+			} else {
+				nvar_baseline_offset0 = 5;
+				nvar_baseline_offset1 = 3;
+			}
+		}
+
+		write_phy_reg(pi, 0x20, init_gaincode);
+		write_phy_reg(pi, 0x2a7, init_gaincode);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+					 pi->pubpi.phy_corenum, 0x106, 16,
+					 rfseq_init_gain);
+
+		write_phy_reg(pi, 0x22, clip1hi_gaincode);
+		write_phy_reg(pi, 0x2a9, clip1hi_gaincode);
+
+		write_phy_reg(pi, 0x36, clip1md_gaincode_B);
+		write_phy_reg(pi, 0x2ac, clip1md_gaincode_B);
+
+		write_phy_reg(pi, 0x37, clip1lo_gaincode);
+		write_phy_reg(pi, 0x2ad, clip1lo_gaincode);
+		write_phy_reg(pi, 0x38, clip1lo_gaincode_B);
+		write_phy_reg(pi, 0x2ae, clip1lo_gaincode_B);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 10, 0x20, 8,
+					 tia_gain_db);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 10, 0x20, 8,
+					 tia_gain_db);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS1, 10, 0x20, 8,
+					 tia_gainbits);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAINBITS2, 10, 0x20, 8,
+					 tia_gainbits);
+
+		mod_phy_reg(pi, 0x283, (0xff << 0), (crsminu_th << 0));
+
+		if (chg_nbclip_th == 1) {
+			write_phy_reg(pi, 0x2b, nbclip_th);
+			write_phy_reg(pi, 0x41, nbclip_th);
+		}
+
+		mod_phy_reg(pi, 0x300, (0x3f << 0), (w1clip_th << 0));
+		mod_phy_reg(pi, 0x301, (0x3f << 0), (w1clip_th << 0));
+
+		mod_phy_reg(pi, 0x2e4,
+			    (0x3f << 0), (nvar_baseline_offset0 << 0));
+
+		mod_phy_reg(pi, 0x2e4,
+			    (0x3f << 6), (nvar_baseline_offset1 << 6));
+
+		if (CHSPEC_IS20(pi->radio_chanspec)) {
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 4, 8, 8,
+						 lna1_gain_db);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 4, 8, 8,
+						 lna1_gain_db_2);
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN1, 4, 0x10,
+						 8, lna2_gain_db);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_GAIN2, 4, 0x10,
+						 8, lna2_gain_db);
+
+			write_phy_reg(pi, 0x24, clip1md_gaincode);
+			write_phy_reg(pi, 0x2ab, clip1md_gaincode);
+		} else {
+			mod_phy_reg(pi, 0x280, (0xff << 0), (crsminl_th << 0));
+		}
+
+	}
+
+}
+
+static void wlc_phy_adjust_lnagaintbl_nphy(phy_info_t * pi)
+{
+	uint core;
+	int ctr;
+	int16 gain_delta[2];
+	uint8 curr_channel;
+	uint16 minmax_gain[2];
+	uint16 regval[4];
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	if (pi->nphy_gain_boost) {
+		if ((CHSPEC_IS2G(pi->radio_chanspec))) {
+
+			gain_delta[0] = 6;
+			gain_delta[1] = 6;
+		} else {
+
+			curr_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
+			gain_delta[0] =
+			    (int16)
+			    PHY_HW_ROUND(((nphy_lnagain_est0[0] *
+					   curr_channel) +
+					  nphy_lnagain_est0[1]), 13);
+			gain_delta[1] =
+			    (int16)
+			    PHY_HW_ROUND(((nphy_lnagain_est1[0] *
+					   curr_channel) +
+					  nphy_lnagain_est1[1]), 13);
+		}
+	} else {
+
+		gain_delta[0] = 0;
+		gain_delta[1] = 0;
+	}
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+		if (pi->nphy_elna_gain_config) {
+
+			regval[0] = nphy_def_lnagains[2] + gain_delta[core];
+			regval[1] = nphy_def_lnagains[3] + gain_delta[core];
+			regval[2] = nphy_def_lnagains[3] + gain_delta[core];
+			regval[3] = nphy_def_lnagains[3] + gain_delta[core];
+		} else {
+			for (ctr = 0; ctr < 4; ctr++) {
+				regval[ctr] =
+				    nphy_def_lnagains[ctr] + gain_delta[core];
+			}
+		}
+		wlc_phy_table_write_nphy(pi, core, 4, 8, 16, regval);
+
+		minmax_gain[core] =
+		    (uint16) (nphy_def_lnagains[2] + gain_delta[core] + 4);
+	}
+
+	mod_phy_reg(pi, 0x1e, (0xff << 0), (minmax_gain[0] << 0));
+	mod_phy_reg(pi, 0x34, (0xff << 0), (minmax_gain[1] << 0));
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+void wlc_phy_switch_radio_nphy(phy_info_t * pi, bool on)
+{
+	if (on) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			if (!pi->radio_is_on) {
+				wlc_phy_radio_preinit_205x(pi);
+				wlc_phy_radio_init_2057(pi);
+				wlc_phy_radio_postinit_2057(pi);
+			}
+
+			wlc_phy_chanspec_set((wlc_phy_t *) pi,
+					     pi->radio_chanspec);
+		} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			wlc_phy_radio_preinit_205x(pi);
+			wlc_phy_radio_init_2056(pi);
+			wlc_phy_radio_postinit_2056(pi);
+
+			wlc_phy_chanspec_set((wlc_phy_t *) pi,
+					     pi->radio_chanspec);
+		} else {
+			wlc_phy_radio_preinit_2055(pi);
+			wlc_phy_radio_init_2055(pi);
+			wlc_phy_radio_postinit_2055(pi);
+		}
+
+		pi->radio_is_on = TRUE;
+
+	} else {
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)
+		    && NREV_LT(pi->pubpi.phy_rev, 7)) {
+			and_phy_reg(pi, 0x78, ~RFCC_CHIP0_PU);
+			mod_radio_reg(pi, RADIO_2056_SYN_COM_PU, 0x2, 0x0);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_PADA_BOOST_TUNE |
+					RADIO_2056_TX0, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_PADG_BOOST_TUNE |
+					RADIO_2056_TX0, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_PGAA_BOOST_TUNE |
+					RADIO_2056_TX0, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_PGAG_BOOST_TUNE |
+					RADIO_2056_TX0, 0);
+			mod_radio_reg(pi,
+				      RADIO_2056_TX_MIXA_BOOST_TUNE |
+				      RADIO_2056_TX0, 0xf0, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_MIXG_BOOST_TUNE |
+					RADIO_2056_TX0, 0);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_PADA_BOOST_TUNE |
+					RADIO_2056_TX1, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_PADG_BOOST_TUNE |
+					RADIO_2056_TX1, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_PGAA_BOOST_TUNE |
+					RADIO_2056_TX1, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_PGAG_BOOST_TUNE |
+					RADIO_2056_TX1, 0);
+			mod_radio_reg(pi,
+				      RADIO_2056_TX_MIXA_BOOST_TUNE |
+				      RADIO_2056_TX1, 0xf0, 0);
+			write_radio_reg(pi,
+					RADIO_2056_TX_MIXG_BOOST_TUNE |
+					RADIO_2056_TX1, 0);
+
+			pi->radio_is_on = FALSE;
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 8)) {
+			and_phy_reg(pi, 0x78, ~RFCC_CHIP0_PU);
+			pi->radio_is_on = FALSE;
+		}
+
+	}
+}
+
+static void wlc_phy_radio_preinit_2055(phy_info_t * pi)
+{
+
+	and_phy_reg(pi, 0x78, ~RFCC_POR_FORCE);
+	or_phy_reg(pi, 0x78, RFCC_CHIP0_PU | RFCC_OE_POR_FORCE);
+
+	or_phy_reg(pi, 0x78, RFCC_POR_FORCE);
+}
+
+static void wlc_phy_radio_init_2055(phy_info_t * pi)
+{
+	wlc_phy_init_radio_regs(pi, regs_2055, RADIO_DEFAULT_CORE);
+}
+
+static void wlc_phy_radio_postinit_2055(phy_info_t * pi)
+{
+
+	and_radio_reg(pi, RADIO_2055_MASTER_CNTRL1,
+		      ~(RADIO_2055_JTAGCTRL_MASK | RADIO_2055_JTAGSYNC_MASK));
+
+	if (((pi->sh->sromrev >= 4)
+	     && !(pi->sh->boardflags2 & BFL2_RXBB_INT_REG_DIS))
+	    || ((pi->sh->sromrev < 4))) {
+		and_radio_reg(pi, RADIO_2055_CORE1_RXBB_REGULATOR, 0x7F);
+		and_radio_reg(pi, RADIO_2055_CORE2_RXBB_REGULATOR, 0x7F);
+	}
+
+	mod_radio_reg(pi, RADIO_2055_RRCCAL_N_OPT_SEL, 0x3F, 0x2C);
+	write_radio_reg(pi, RADIO_2055_CAL_MISC, 0x3C);
+
+	and_radio_reg(pi, RADIO_2055_CAL_MISC,
+		      ~(RADIO_2055_RRCAL_START | RADIO_2055_RRCAL_RST_N));
+
+	or_radio_reg(pi, RADIO_2055_CAL_LPO_CNTRL, RADIO_2055_CAL_LPO_ENABLE);
+
+	or_radio_reg(pi, RADIO_2055_CAL_MISC, RADIO_2055_RRCAL_RST_N);
+
+	OSL_DELAY(1000);
+
+	or_radio_reg(pi, RADIO_2055_CAL_MISC, RADIO_2055_RRCAL_START);
+
+	SPINWAIT(((read_radio_reg(pi, RADIO_2055_CAL_COUNTER_OUT2) &
+		   RADIO_2055_RCAL_DONE) != RADIO_2055_RCAL_DONE), 2000);
+
+	ASSERT((read_radio_reg(pi, RADIO_2055_CAL_COUNTER_OUT2) &
+		RADIO_2055_RCAL_DONE) == RADIO_2055_RCAL_DONE);
+
+	and_radio_reg(pi, RADIO_2055_CAL_LPO_CNTRL,
+		      ~(RADIO_2055_CAL_LPO_ENABLE));
+
+	wlc_phy_chanspec_set((wlc_phy_t *) pi, pi->radio_chanspec);
+
+	write_radio_reg(pi, RADIO_2055_CORE1_RXBB_LPF, 9);
+	write_radio_reg(pi, RADIO_2055_CORE2_RXBB_LPF, 9);
+
+	write_radio_reg(pi, RADIO_2055_CORE1_RXBB_MIDAC_HIPAS, 0x83);
+	write_radio_reg(pi, RADIO_2055_CORE2_RXBB_MIDAC_HIPAS, 0x83);
+
+	mod_radio_reg(pi, RADIO_2055_CORE1_LNA_GAINBST,
+		      RADIO_2055_GAINBST_VAL_MASK, RADIO_2055_GAINBST_CODE);
+	mod_radio_reg(pi, RADIO_2055_CORE2_LNA_GAINBST,
+		      RADIO_2055_GAINBST_VAL_MASK, RADIO_2055_GAINBST_CODE);
+	if (pi->nphy_gain_boost) {
+		and_radio_reg(pi, RADIO_2055_CORE1_RXRF_SPC1,
+			      ~(RADIO_2055_GAINBST_DISABLE));
+		and_radio_reg(pi, RADIO_2055_CORE2_RXRF_SPC1,
+			      ~(RADIO_2055_GAINBST_DISABLE));
+	} else {
+		or_radio_reg(pi, RADIO_2055_CORE1_RXRF_SPC1,
+			     RADIO_2055_GAINBST_DISABLE);
+		or_radio_reg(pi, RADIO_2055_CORE2_RXRF_SPC1,
+			     RADIO_2055_GAINBST_DISABLE);
+	}
+
+	OSL_DELAY(2);
+}
+
+static void wlc_phy_radio_preinit_205x(phy_info_t * pi)
+{
+
+	and_phy_reg(pi, 0x78, ~RFCC_CHIP0_PU);
+	and_phy_reg(pi, 0x78, RFCC_OE_POR_FORCE);
+
+	or_phy_reg(pi, 0x78, ~RFCC_OE_POR_FORCE);
+	or_phy_reg(pi, 0x78, RFCC_CHIP0_PU);
+
+}
+
+static void wlc_phy_radio_init_2056(phy_info_t * pi)
+{
+	radio_regs_t *regs_SYN_2056_ptr = NULL;
+	radio_regs_t *regs_TX_2056_ptr = NULL;
+	radio_regs_t *regs_RX_2056_ptr = NULL;
+
+	if (NREV_IS(pi->pubpi.phy_rev, 3)) {
+		regs_SYN_2056_ptr = regs_SYN_2056;
+		regs_TX_2056_ptr = regs_TX_2056;
+		regs_RX_2056_ptr = regs_RX_2056;
+	} else if (NREV_IS(pi->pubpi.phy_rev, 4)) {
+		regs_SYN_2056_ptr = regs_SYN_2056_A1;
+		regs_TX_2056_ptr = regs_TX_2056_A1;
+		regs_RX_2056_ptr = regs_RX_2056_A1;
+	} else {
+		switch (pi->pubpi.radiorev) {
+		case 5:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev5;
+			regs_TX_2056_ptr = regs_TX_2056_rev5;
+			regs_RX_2056_ptr = regs_RX_2056_rev5;
+			break;
+
+		case 6:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev6;
+			regs_TX_2056_ptr = regs_TX_2056_rev6;
+			regs_RX_2056_ptr = regs_RX_2056_rev6;
+			break;
+
+		case 7:
+		case 9:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev7;
+			regs_TX_2056_ptr = regs_TX_2056_rev7;
+			regs_RX_2056_ptr = regs_RX_2056_rev7;
+			break;
+
+		case 8:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev8;
+			regs_TX_2056_ptr = regs_TX_2056_rev8;
+			regs_RX_2056_ptr = regs_RX_2056_rev8;
+			break;
+
+		case 11:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev11;
+			regs_TX_2056_ptr = regs_TX_2056_rev11;
+			regs_RX_2056_ptr = regs_RX_2056_rev11;
+			break;
+
+		default:
+			ASSERT(0);
+			break;
+		}
+	}
+
+	wlc_phy_init_radio_regs(pi, regs_SYN_2056_ptr, (uint16) RADIO_2056_SYN);
+
+	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (uint16) RADIO_2056_TX0);
+
+	wlc_phy_init_radio_regs(pi, regs_TX_2056_ptr, (uint16) RADIO_2056_TX1);
+
+	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (uint16) RADIO_2056_RX0);
+
+	wlc_phy_init_radio_regs(pi, regs_RX_2056_ptr, (uint16) RADIO_2056_RX1);
+}
+
+static void wlc_phy_radio_postinit_2056(phy_info_t * pi)
+{
+	mod_radio_reg(pi, RADIO_2056_SYN_COM_CTRL, 0xb, 0xb);
+
+	mod_radio_reg(pi, RADIO_2056_SYN_COM_PU, 0x2, 0x2);
+	mod_radio_reg(pi, RADIO_2056_SYN_COM_RESET, 0x2, 0x2);
+	OSL_DELAY(1000);
+	mod_radio_reg(pi, RADIO_2056_SYN_COM_RESET, 0x2, 0x0);
+
+	if ((pi->sh->boardflags2 & BFL2_LEGACY)
+	    || (pi->sh->boardflags2 & BFL2_XTALBUFOUTEN)) {
+
+		mod_radio_reg(pi, RADIO_2056_SYN_PLL_MAST2, 0xf4, 0x0);
+	} else {
+
+		mod_radio_reg(pi, RADIO_2056_SYN_PLL_MAST2, 0xfc, 0x0);
+	}
+
+	mod_radio_reg(pi, RADIO_2056_SYN_RCCAL_CTRL0, 0x1, 0x0);
+
+	if (pi->phy_init_por) {
+		wlc_phy_radio205x_rcal(pi);
+	}
+}
+
+static void wlc_phy_radio_init_2057(phy_info_t * pi)
+{
+	radio_20xx_regs_t *regs_2057_ptr = NULL;
+
+	if (NREV_IS(pi->pubpi.phy_rev, 7)) {
+
+		regs_2057_ptr = regs_2057_rev4;
+	} else if (NREV_IS(pi->pubpi.phy_rev, 8)
+		   || NREV_IS(pi->pubpi.phy_rev, 9)) {
+		switch (pi->pubpi.radiorev) {
+		case 5:
+
+			if (pi->pubpi.radiover == 0x0) {
+
+				regs_2057_ptr = regs_2057_rev5;
+
+			} else if (pi->pubpi.radiover == 0x1) {
+
+				regs_2057_ptr = regs_2057_rev5v1;
+			} else {
+				ASSERT(0);
+				break;
+			}
+
+		case 7:
+
+			regs_2057_ptr = regs_2057_rev7;
+			break;
+
+		case 8:
+
+			regs_2057_ptr = regs_2057_rev8;
+			break;
+
+		default:
+			ASSERT(0);
+			break;
+		}
+	} else {
+		ASSERT(0);
+	}
+
+	wlc_phy_init_radio_regs_allbands(pi, regs_2057_ptr);
+}
+
+static void wlc_phy_radio_postinit_2057(phy_info_t * pi)
+{
+
+	mod_radio_reg(pi, RADIO_2057_XTALPUOVR_PINCTRL, 0x1, 0x1);
+
+	if (CHIPID(pi->sh->chip) == !BCM6362_CHIP_ID) {
+
+		mod_radio_reg(pi, RADIO_2057_XTALPUOVR_PINCTRL, 0x2, 0x2);
+	}
+
+	mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_CAL_RESETN, 0x78, 0x78);
+	mod_radio_reg(pi, RADIO_2057_XTAL_CONFIG2, 0x80, 0x80);
+	OSL_DELAY(2000);
+	mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_CAL_RESETN, 0x78, 0x0);
+	mod_radio_reg(pi, RADIO_2057_XTAL_CONFIG2, 0x80, 0x0);
+
+	if (pi->phy_init_por) {
+		wlc_phy_radio205x_rcal(pi);
+		wlc_phy_radio2057_rccal(pi);
+	}
+
+	mod_radio_reg(pi, RADIO_2057_RFPLL_MASTER, 0x8, 0x0);
+}
+
+static bool
+wlc_phy_chan2freq_nphy(phy_info_t * pi, uint channel, int *f,
+		       chan_info_nphy_radio2057_t ** t0,
+		       chan_info_nphy_radio205x_t ** t1,
+		       chan_info_nphy_radio2057_rev5_t ** t2,
+		       chan_info_nphy_2055_t ** t3)
+{
+	uint i;
+	chan_info_nphy_radio2057_t *chan_info_tbl_p_0 = NULL;
+	chan_info_nphy_radio205x_t *chan_info_tbl_p_1 = NULL;
+	chan_info_nphy_radio2057_rev5_t *chan_info_tbl_p_2 = NULL;
+	uint32 tbl_len = 0;
+
+	int freq = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		if (NREV_IS(pi->pubpi.phy_rev, 7)) {
+
+			chan_info_tbl_p_0 = chan_info_nphyrev7_2057_rev4;
+			tbl_len = ARRAYSIZE(chan_info_nphyrev7_2057_rev4);
+
+		} else if (NREV_IS(pi->pubpi.phy_rev, 8)
+			   || NREV_IS(pi->pubpi.phy_rev, 9)) {
+			switch (pi->pubpi.radiorev) {
+
+			case 5:
+
+				if (pi->pubpi.radiover == 0x0) {
+
+					chan_info_tbl_p_2 =
+					    chan_info_nphyrev8_2057_rev5;
+					tbl_len =
+					    ARRAYSIZE
+					    (chan_info_nphyrev8_2057_rev5);
+
+				} else if (pi->pubpi.radiover == 0x1) {
+
+					chan_info_tbl_p_2 =
+					    chan_info_nphyrev9_2057_rev5v1;
+					tbl_len =
+					    ARRAYSIZE
+					    (chan_info_nphyrev9_2057_rev5v1);
+
+				}
+				break;
+
+			case 7:
+				chan_info_tbl_p_0 =
+				    chan_info_nphyrev8_2057_rev7;
+				tbl_len =
+				    ARRAYSIZE(chan_info_nphyrev8_2057_rev7);
+				break;
+
+			case 8:
+				chan_info_tbl_p_0 =
+				    chan_info_nphyrev8_2057_rev8;
+				tbl_len =
+				    ARRAYSIZE(chan_info_nphyrev8_2057_rev8);
+				break;
+
+			default:
+				if (NORADIO_ENAB(pi->pubpi)) {
+					goto fail;
+				}
+				break;
+			}
+		} else if (NREV_IS(pi->pubpi.phy_rev, 16)) {
+
+			chan_info_tbl_p_0 = chan_info_nphyrev8_2057_rev8;
+			tbl_len = ARRAYSIZE(chan_info_nphyrev8_2057_rev8);
+		} else {
+			goto fail;
+		}
+
+		for (i = 0; i < tbl_len; i++) {
+			if (pi->pubpi.radiorev == 5) {
+
+				if (chan_info_tbl_p_2[i].chan == channel)
+					break;
+			} else {
+
+				if (chan_info_tbl_p_0[i].chan == channel)
+					break;
+			}
+		}
+
+		if (i >= tbl_len) {
+			ASSERT(i < tbl_len);
+			goto fail;
+		}
+		if (pi->pubpi.radiorev == 5) {
+			*t2 = &chan_info_tbl_p_2[i];
+			freq = chan_info_tbl_p_2[i].freq;
+		} else {
+			*t0 = &chan_info_tbl_p_0[i];
+			freq = chan_info_tbl_p_0[i].freq;
+		}
+
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if (NREV_IS(pi->pubpi.phy_rev, 3)) {
+			chan_info_tbl_p_1 = chan_info_nphyrev3_2056;
+			tbl_len = ARRAYSIZE(chan_info_nphyrev3_2056);
+		} else if (NREV_IS(pi->pubpi.phy_rev, 4)) {
+			chan_info_tbl_p_1 = chan_info_nphyrev4_2056_A1;
+			tbl_len = ARRAYSIZE(chan_info_nphyrev4_2056_A1);
+		} else if (NREV_IS(pi->pubpi.phy_rev, 5)
+			   || NREV_IS(pi->pubpi.phy_rev, 6)) {
+			switch (pi->pubpi.radiorev) {
+			case 5:
+				chan_info_tbl_p_1 = chan_info_nphyrev5_2056v5;
+				tbl_len = ARRAYSIZE(chan_info_nphyrev5_2056v5);
+				break;
+			case 6:
+				chan_info_tbl_p_1 = chan_info_nphyrev6_2056v6;
+				tbl_len = ARRAYSIZE(chan_info_nphyrev6_2056v6);
+				break;
+			case 7:
+			case 9:
+				chan_info_tbl_p_1 = chan_info_nphyrev5n6_2056v7;
+				tbl_len =
+				    ARRAYSIZE(chan_info_nphyrev5n6_2056v7);
+				break;
+			case 8:
+				chan_info_tbl_p_1 = chan_info_nphyrev6_2056v8;
+				tbl_len = ARRAYSIZE(chan_info_nphyrev6_2056v8);
+				break;
+			case 11:
+				chan_info_tbl_p_1 = chan_info_nphyrev6_2056v11;
+				tbl_len = ARRAYSIZE(chan_info_nphyrev6_2056v11);
+				break;
+			default:
+				if (NORADIO_ENAB(pi->pubpi)) {
+					goto fail;
+				}
+				break;
+			}
+		}
+
+		for (i = 0; i < tbl_len; i++) {
+			if (chan_info_tbl_p_1[i].chan == channel)
+				break;
+		}
+
+		if (i >= tbl_len) {
+			ASSERT(i < tbl_len);
+			goto fail;
+		}
+		*t1 = &chan_info_tbl_p_1[i];
+		freq = chan_info_tbl_p_1[i].freq;
+
+	} else {
+		for (i = 0; i < ARRAYSIZE(chan_info_nphy_2055); i++)
+			if (chan_info_nphy_2055[i].chan == channel)
+				break;
+
+		if (i >= ARRAYSIZE(chan_info_nphy_2055)) {
+			ASSERT(i < ARRAYSIZE(chan_info_nphy_2055));
+			goto fail;
+		}
+		*t3 = &chan_info_nphy_2055[i];
+		freq = chan_info_nphy_2055[i].freq;
+	}
+
+	*f = freq;
+	return TRUE;
+
+ fail:
+	*f = WL_CHAN_FREQ_RANGE_2G;
+	return FALSE;
+}
+
+uint8 wlc_phy_get_chan_freq_range_nphy(phy_info_t * pi, uint channel)
+{
+	int freq;
+	chan_info_nphy_radio2057_t *t0 = NULL;
+	chan_info_nphy_radio205x_t *t1 = NULL;
+	chan_info_nphy_radio2057_rev5_t *t2 = NULL;
+	chan_info_nphy_2055_t *t3 = NULL;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return WL_CHAN_FREQ_RANGE_2G;
+
+	if (channel == 0)
+		channel = CHSPEC_CHANNEL(pi->radio_chanspec);
+
+	wlc_phy_chan2freq_nphy(pi, channel, &freq, &t0, &t1, &t2, &t3);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec))
+		return WL_CHAN_FREQ_RANGE_2G;
+
+	if ((freq >= BASE_LOW_5G_CHAN) && (freq < BASE_MID_5G_CHAN)) {
+		return WL_CHAN_FREQ_RANGE_5GL;
+	} else if ((freq >= BASE_MID_5G_CHAN) && (freq < BASE_HIGH_5G_CHAN)) {
+		return WL_CHAN_FREQ_RANGE_5GM;
+	} else {
+		return WL_CHAN_FREQ_RANGE_5GH;
+	}
+}
+
+static void
+wlc_phy_chanspec_radio2055_setup(phy_info_t * pi, chan_info_nphy_2055_t * ci)
+{
+
+	write_radio_reg(pi, RADIO_2055_PLL_REF, ci->RF_pll_ref);
+	write_radio_reg(pi, RADIO_2055_RF_PLL_MOD0, ci->RF_rf_pll_mod0);
+	write_radio_reg(pi, RADIO_2055_RF_PLL_MOD1, ci->RF_rf_pll_mod1);
+	write_radio_reg(pi, RADIO_2055_VCO_CAP_TAIL, ci->RF_vco_cap_tail);
+
+	WLC_PHY_WAR_PR51571(pi);
+
+	write_radio_reg(pi, RADIO_2055_VCO_CAL1, ci->RF_vco_cal1);
+	write_radio_reg(pi, RADIO_2055_VCO_CAL2, ci->RF_vco_cal2);
+	write_radio_reg(pi, RADIO_2055_PLL_LF_C1, ci->RF_pll_lf_c1);
+	write_radio_reg(pi, RADIO_2055_PLL_LF_R1, ci->RF_pll_lf_r1);
+
+	WLC_PHY_WAR_PR51571(pi);
+
+	write_radio_reg(pi, RADIO_2055_PLL_LF_C2, ci->RF_pll_lf_c2);
+	write_radio_reg(pi, RADIO_2055_LGBUF_CEN_BUF, ci->RF_lgbuf_cen_buf);
+	write_radio_reg(pi, RADIO_2055_LGEN_TUNE1, ci->RF_lgen_tune1);
+	write_radio_reg(pi, RADIO_2055_LGEN_TUNE2, ci->RF_lgen_tune2);
+
+	WLC_PHY_WAR_PR51571(pi);
+
+	write_radio_reg(pi, RADIO_2055_CORE1_LGBUF_A_TUNE,
+			ci->RF_core1_lgbuf_a_tune);
+	write_radio_reg(pi, RADIO_2055_CORE1_LGBUF_G_TUNE,
+			ci->RF_core1_lgbuf_g_tune);
+	write_radio_reg(pi, RADIO_2055_CORE1_RXRF_REG1, ci->RF_core1_rxrf_reg1);
+	write_radio_reg(pi, RADIO_2055_CORE1_TX_PGA_PAD_TN,
+			ci->RF_core1_tx_pga_pad_tn);
+
+	WLC_PHY_WAR_PR51571(pi);
+
+	write_radio_reg(pi, RADIO_2055_CORE1_TX_MX_BGTRIM,
+			ci->RF_core1_tx_mx_bgtrim);
+	write_radio_reg(pi, RADIO_2055_CORE2_LGBUF_A_TUNE,
+			ci->RF_core2_lgbuf_a_tune);
+	write_radio_reg(pi, RADIO_2055_CORE2_LGBUF_G_TUNE,
+			ci->RF_core2_lgbuf_g_tune);
+	write_radio_reg(pi, RADIO_2055_CORE2_RXRF_REG1, ci->RF_core2_rxrf_reg1);
+
+	WLC_PHY_WAR_PR51571(pi);
+
+	write_radio_reg(pi, RADIO_2055_CORE2_TX_PGA_PAD_TN,
+			ci->RF_core2_tx_pga_pad_tn);
+	write_radio_reg(pi, RADIO_2055_CORE2_TX_MX_BGTRIM,
+			ci->RF_core2_tx_mx_bgtrim);
+
+	OSL_DELAY(50);
+
+	write_radio_reg(pi, RADIO_2055_VCO_CAL10, 0x05);
+	write_radio_reg(pi, RADIO_2055_VCO_CAL10, 0x45);
+
+	WLC_PHY_WAR_PR51571(pi);
+
+	write_radio_reg(pi, RADIO_2055_VCO_CAL10, 0x65);
+
+	OSL_DELAY(300);
+}
+
+static void
+wlc_phy_chanspec_radio2056_setup(phy_info_t * pi,
+				 const chan_info_nphy_radio205x_t * ci)
+{
+	radio_regs_t *regs_SYN_2056_ptr = NULL;
+
+	write_radio_reg(pi,
+			RADIO_2056_SYN_PLL_VCOCAL1 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_vcocal1);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_VCOCAL2 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_vcocal2);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_REFDIV | RADIO_2056_SYN,
+			ci->RF_SYN_pll_refdiv);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_MMD2 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_mmd2);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_MMD1 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_mmd1);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER1 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_loopfilter1);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER2 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_loopfilter2);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER3 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_loopfilter3);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER4 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_loopfilter4);
+	write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER5 | RADIO_2056_SYN,
+			ci->RF_SYN_pll_loopfilter5);
+	write_radio_reg(pi, RADIO_2056_SYN_RESERVED_ADDR27 | RADIO_2056_SYN,
+			ci->RF_SYN_reserved_addr27);
+	write_radio_reg(pi, RADIO_2056_SYN_RESERVED_ADDR28 | RADIO_2056_SYN,
+			ci->RF_SYN_reserved_addr28);
+	write_radio_reg(pi, RADIO_2056_SYN_RESERVED_ADDR29 | RADIO_2056_SYN,
+			ci->RF_SYN_reserved_addr29);
+	write_radio_reg(pi, RADIO_2056_SYN_LOGEN_VCOBUF1 | RADIO_2056_SYN,
+			ci->RF_SYN_logen_VCOBUF1);
+	write_radio_reg(pi, RADIO_2056_SYN_LOGEN_MIXER2 | RADIO_2056_SYN,
+			ci->RF_SYN_logen_MIXER2);
+	write_radio_reg(pi, RADIO_2056_SYN_LOGEN_BUF3 | RADIO_2056_SYN,
+			ci->RF_SYN_logen_BUF3);
+	write_radio_reg(pi, RADIO_2056_SYN_LOGEN_BUF4 | RADIO_2056_SYN,
+			ci->RF_SYN_logen_BUF4);
+
+	write_radio_reg(pi,
+			RADIO_2056_RX_LNAA_TUNE | RADIO_2056_RX0,
+			ci->RF_RX0_lnaa_tune);
+	write_radio_reg(pi, RADIO_2056_RX_LNAG_TUNE | RADIO_2056_RX0,
+			ci->RF_RX0_lnag_tune);
+	write_radio_reg(pi, RADIO_2056_TX_INTPAA_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_intpaa_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_INTPAG_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_intpag_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PADA_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_pada_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PADG_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_padg_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PGAA_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_pgaa_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PGAG_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_pgag_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_MIXA_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_mixa_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_MIXG_BOOST_TUNE | RADIO_2056_TX0,
+			ci->RF_TX0_mixg_boost_tune);
+
+	write_radio_reg(pi,
+			RADIO_2056_RX_LNAA_TUNE | RADIO_2056_RX1,
+			ci->RF_RX1_lnaa_tune);
+	write_radio_reg(pi, RADIO_2056_RX_LNAG_TUNE | RADIO_2056_RX1,
+			ci->RF_RX1_lnag_tune);
+	write_radio_reg(pi, RADIO_2056_TX_INTPAA_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_intpaa_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_INTPAG_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_intpag_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PADA_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_pada_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PADG_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_padg_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PGAA_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_pgaa_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_PGAG_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_pgag_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_MIXA_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_mixa_boost_tune);
+	write_radio_reg(pi, RADIO_2056_TX_MIXG_BOOST_TUNE | RADIO_2056_TX1,
+			ci->RF_TX1_mixg_boost_tune);
+
+	if (NREV_IS(pi->pubpi.phy_rev, 3))
+		regs_SYN_2056_ptr = regs_SYN_2056;
+	else if (NREV_IS(pi->pubpi.phy_rev, 4))
+		regs_SYN_2056_ptr = regs_SYN_2056_A1;
+	else {
+		switch (pi->pubpi.radiorev) {
+		case 5:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev5;
+			break;
+		case 6:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev6;
+			break;
+		case 7:
+		case 9:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev7;
+			break;
+		case 8:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev8;
+			break;
+		case 11:
+			regs_SYN_2056_ptr = regs_SYN_2056_rev11;
+			break;
+		}
+	}
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 |
+				RADIO_2056_SYN,
+				(uint16) regs_SYN_2056_ptr[0x49 - 2].init_g);
+	} else {
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 |
+				RADIO_2056_SYN,
+				(uint16) regs_SYN_2056_ptr[0x49 - 2].init_a);
+	}
+
+	if (pi->sh->boardflags2 & BFL2_GPLL_WAR) {
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER1 |
+					RADIO_2056_SYN, 0x1f);
+			write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER2 |
+					RADIO_2056_SYN, 0x1f);
+
+			if ((CHIPID(pi->sh->chip) == BCM4716_CHIP_ID) ||
+			    (CHIPID(pi->sh->chip) == BCM47162_CHIP_ID)) {
+
+				write_radio_reg(pi,
+						RADIO_2056_SYN_PLL_LOOPFILTER4 |
+						RADIO_2056_SYN, 0x14);
+				write_radio_reg(pi,
+						RADIO_2056_SYN_PLL_CP2 |
+						RADIO_2056_SYN, 0x00);
+			} else {
+				write_radio_reg(pi,
+						RADIO_2056_SYN_PLL_LOOPFILTER4 |
+						RADIO_2056_SYN, 0xb);
+				write_radio_reg(pi,
+						RADIO_2056_SYN_PLL_CP2 |
+						RADIO_2056_SYN, 0x14);
+			}
+		}
+	}
+
+	if ((pi->sh->boardflags2 & BFL2_GPLL_WAR2) &&
+	    (CHSPEC_IS2G(pi->radio_chanspec))) {
+		write_radio_reg(pi,
+				RADIO_2056_SYN_PLL_LOOPFILTER1 | RADIO_2056_SYN,
+				0x1f);
+		write_radio_reg(pi,
+				RADIO_2056_SYN_PLL_LOOPFILTER2 | RADIO_2056_SYN,
+				0x1f);
+		write_radio_reg(pi,
+				RADIO_2056_SYN_PLL_LOOPFILTER4 | RADIO_2056_SYN,
+				0xb);
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 | RADIO_2056_SYN,
+				0x20);
+	}
+
+	if (pi->sh->boardflags2 & BFL2_APLL_WAR) {
+		if (CHSPEC_IS5G(pi->radio_chanspec)) {
+			write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER1 |
+					RADIO_2056_SYN, 0x1f);
+			write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER2 |
+					RADIO_2056_SYN, 0x1f);
+			write_radio_reg(pi, RADIO_2056_SYN_PLL_LOOPFILTER4 |
+					RADIO_2056_SYN, 0x5);
+			write_radio_reg(pi, RADIO_2056_SYN_PLL_CP2 |
+					RADIO_2056_SYN, 0xc);
+		}
+	}
+
+	if (PHY_IPA(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
+		uint16 pag_boost_tune;
+		uint16 padg_boost_tune;
+		uint16 pgag_boost_tune;
+		uint16 mixg_boost_tune;
+		uint16 bias, cascbias;
+		uint core;
+
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+			if (NREV_GE(pi->pubpi.phy_rev, 5)) {
+
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 PADG_IDAC, 0xcc);
+
+				if ((CHIPID(pi->sh->chip) == BCM4716_CHIP_ID) ||
+				    (CHIPID(pi->sh->chip) ==
+				     BCM47162_CHIP_ID)) {
+					bias = 0x40;
+					cascbias = 0x45;
+					pag_boost_tune = 0x5;
+					pgag_boost_tune = 0x33;
+					padg_boost_tune = 0x77;
+					mixg_boost_tune = 0x55;
+				} else {
+					bias = 0x25;
+					cascbias = 0x20;
+
+					if ((CHIPID(pi->sh->chip) ==
+					     BCM43224_CHIP_ID)
+					    || (CHIPID(pi->sh->chip) ==
+						BCM43225_CHIP_ID)
+					    || (CHIPID(pi->sh->chip) ==
+						BCM43421_CHIP_ID)) {
+						if (pi->sh->chippkg ==
+						    BCM43224_FAB_SMIC) {
+							bias = 0x2a;
+							cascbias = 0x38;
+						}
+					}
+
+					pag_boost_tune = 0x4;
+					pgag_boost_tune = 0x03;
+					padg_boost_tune = 0x77;
+					mixg_boost_tune = 0x65;
+				}
+
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_IMAIN_STAT, bias);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_IAUX_STAT, bias);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_CASCBIAS, cascbias);
+
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_BOOST_TUNE,
+						 pag_boost_tune);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 PGAG_BOOST_TUNE,
+						 pgag_boost_tune);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 PADG_BOOST_TUNE,
+						 padg_boost_tune);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 MIXG_BOOST_TUNE,
+						 mixg_boost_tune);
+			} else {
+
+				bias = IS40MHZ(pi) ? 0x40 : 0x20;
+
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_IMAIN_STAT, bias);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_IAUX_STAT, bias);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_CASCBIAS, 0x30);
+			}
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, PA_SPARE1,
+					 0xee);
+		}
+	}
+
+	if (PHY_IPA(pi) && NREV_IS(pi->pubpi.phy_rev, 6)
+	    && CHSPEC_IS5G(pi->radio_chanspec)) {
+		uint16 paa_boost_tune;
+		uint16 pada_boost_tune;
+		uint16 pgaa_boost_tune;
+		uint16 mixa_boost_tune;
+		uint16 freq, pabias, cascbias;
+		uint core;
+
+		freq = CHAN5G_FREQ(CHSPEC_CHANNEL(pi->radio_chanspec));
+
+		if (freq < 5150) {
+
+			paa_boost_tune = 0xa;
+			pada_boost_tune = 0x77;
+			pgaa_boost_tune = 0xf;
+			mixa_boost_tune = 0xf;
+		} else if (freq < 5340) {
+
+			paa_boost_tune = 0x8;
+			pada_boost_tune = 0x77;
+			pgaa_boost_tune = 0xfb;
+			mixa_boost_tune = 0xf;
+		} else if (freq < 5650) {
+
+			paa_boost_tune = 0x0;
+			pada_boost_tune = 0x77;
+			pgaa_boost_tune = 0xb;
+			mixa_boost_tune = 0xf;
+		} else {
+
+			paa_boost_tune = 0x0;
+			pada_boost_tune = 0x77;
+			if (freq != 5825) {
+				pgaa_boost_tune = -(int)(freq - 18) / 36 + 168;
+			} else {
+				pgaa_boost_tune = 6;
+			}
+			mixa_boost_tune = 0xf;
+		}
+
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 INTPAA_BOOST_TUNE, paa_boost_tune);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 PADA_BOOST_TUNE, pada_boost_tune);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 PGAA_BOOST_TUNE, pgaa_boost_tune);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 MIXA_BOOST_TUNE, mixa_boost_tune);
+
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 TXSPARE1, 0x30);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 PA_SPARE2, 0xee);
+
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 PADA_CASCBIAS, 0x3);
+
+			cascbias = 0x30;
+
+			if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID) ||
+			    (CHIPID(pi->sh->chip) == BCM43225_CHIP_ID) ||
+			    (CHIPID(pi->sh->chip) == BCM43421_CHIP_ID)) {
+				if (pi->sh->chippkg == BCM43224_FAB_SMIC) {
+					cascbias = 0x35;
+				}
+			}
+
+			pabias = (pi->phy_pabias == 0) ? 0x30 : pi->phy_pabias;
+
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 INTPAA_IAUX_STAT, pabias);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 INTPAA_IMAIN_STAT, pabias);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 INTPAA_CASCBIAS, cascbias);
+		}
+	}
+
+	OSL_DELAY(50);
+
+	wlc_phy_radio205x_vcocal_nphy(pi);
+}
+
+void wlc_phy_radio205x_vcocal_nphy(phy_info_t * pi)
+{
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_EN, 0x01, 0x0);
+		mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_CAL_RESETN, 0x04, 0x0);
+		mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_CAL_RESETN, 0x04,
+			      (1 << 2));
+		mod_radio_reg(pi, RADIO_2057_RFPLL_MISC_EN, 0x01, 0x01);
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_VCOCAL12, 0x0);
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST3, 0x38);
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST3, 0x18);
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST3, 0x38);
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST3, 0x39);
+	}
+
+	OSL_DELAY(300);
+}
+
+#define MAX_205x_RCAL_WAITLOOPS 10000
+
+static uint16 wlc_phy_radio205x_rcal(phy_info_t * pi)
+{
+	uint16 rcal_reg = 0;
+	int i;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		if (pi->pubpi.radiorev == 5) {
+
+			and_phy_reg(pi, 0x342, ~(0x1 << 1));
+
+			OSL_DELAY(10);
+
+			mod_radio_reg(pi, RADIO_2057_IQTEST_SEL_PU, 0x1, 0x1);
+			mod_radio_reg(pi, RADIO_2057v7_IQTEST_SEL_PU2, 0x2,
+				      0x1);
+		}
+		mod_radio_reg(pi, RADIO_2057_RCAL_CONFIG, 0x1, 0x1);
+
+		OSL_DELAY(10);
+
+		mod_radio_reg(pi, RADIO_2057_RCAL_CONFIG, 0x3, 0x3);
+
+		for (i = 0; i < MAX_205x_RCAL_WAITLOOPS; i++) {
+			rcal_reg = read_radio_reg(pi, RADIO_2057_RCAL_STATUS);
+			if (rcal_reg & 0x1) {
+				break;
+			}
+			OSL_DELAY(100);
+		}
+
+		ASSERT(i < MAX_205x_RCAL_WAITLOOPS);
+
+		mod_radio_reg(pi, RADIO_2057_RCAL_CONFIG, 0x2, 0x0);
+
+		rcal_reg = read_radio_reg(pi, RADIO_2057_RCAL_STATUS) & 0x3e;
+
+		mod_radio_reg(pi, RADIO_2057_RCAL_CONFIG, 0x1, 0x0);
+		if (pi->pubpi.radiorev == 5) {
+
+			mod_radio_reg(pi, RADIO_2057_IQTEST_SEL_PU, 0x1, 0x0);
+			mod_radio_reg(pi, RADIO_2057v7_IQTEST_SEL_PU2, 0x2,
+				      0x0);
+		}
+
+		if ((pi->pubpi.radiorev <= 4) || (pi->pubpi.radiorev == 6)) {
+
+			mod_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG, 0x3c,
+				      rcal_reg);
+			mod_radio_reg(pi, RADIO_2057_BANDGAP_RCAL_TRIM, 0xf0,
+				      rcal_reg << 2);
+		}
+
+	} else if (NREV_IS(pi->pubpi.phy_rev, 3)) {
+		uint16 savereg;
+
+		savereg =
+		    read_radio_reg(pi,
+				   RADIO_2056_SYN_PLL_MAST2 | RADIO_2056_SYN);
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST2 | RADIO_2056_SYN,
+				savereg | 0x7);
+		OSL_DELAY(10);
+
+		write_radio_reg(pi, RADIO_2056_SYN_RCAL_MASTER | RADIO_2056_SYN,
+				0x1);
+		OSL_DELAY(10);
+
+		write_radio_reg(pi, RADIO_2056_SYN_RCAL_MASTER | RADIO_2056_SYN,
+				0x9);
+
+		for (i = 0; i < MAX_205x_RCAL_WAITLOOPS; i++) {
+			rcal_reg = read_radio_reg(pi,
+						  RADIO_2056_SYN_RCAL_CODE_OUT |
+						  RADIO_2056_SYN);
+			if (rcal_reg & 0x80) {
+				break;
+			}
+			OSL_DELAY(100);
+		}
+
+		ASSERT(i < MAX_205x_RCAL_WAITLOOPS);
+
+		write_radio_reg(pi, RADIO_2056_SYN_RCAL_MASTER | RADIO_2056_SYN,
+				0x1);
+
+		rcal_reg =
+		    read_radio_reg(pi,
+				   RADIO_2056_SYN_RCAL_CODE_OUT |
+				   RADIO_2056_SYN);
+
+		write_radio_reg(pi, RADIO_2056_SYN_RCAL_MASTER | RADIO_2056_SYN,
+				0x0);
+
+		write_radio_reg(pi, RADIO_2056_SYN_PLL_MAST2 | RADIO_2056_SYN,
+				savereg);
+
+		return (rcal_reg & 0x1f);
+	}
+	return (rcal_reg & 0x3e);
+}
+
+static void
+wlc_phy_chanspec_radio2057_setup(phy_info_t * pi,
+				 const chan_info_nphy_radio2057_t * ci,
+				 const chan_info_nphy_radio2057_rev5_t * ci2)
+{
+	int coreNum;
+	uint16 txmix2g_tune_boost_pu = 0;
+	uint16 pad2g_tune_pus = 0;
+
+	if (pi->pubpi.radiorev == 5) {
+
+		write_radio_reg(pi,
+				RADIO_2057_VCOCAL_COUNTVAL0,
+				ci2->RF_vcocal_countval0);
+		write_radio_reg(pi, RADIO_2057_VCOCAL_COUNTVAL1,
+				ci2->RF_vcocal_countval1);
+		write_radio_reg(pi, RADIO_2057_RFPLL_REFMASTER_SPAREXTALSIZE,
+				ci2->RF_rfpll_refmaster_sparextalsize);
+		write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_R1,
+				ci2->RF_rfpll_loopfilter_r1);
+		write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C2,
+				ci2->RF_rfpll_loopfilter_c2);
+		write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C1,
+				ci2->RF_rfpll_loopfilter_c1);
+		write_radio_reg(pi, RADIO_2057_CP_KPD_IDAC,
+				ci2->RF_cp_kpd_idac);
+		write_radio_reg(pi, RADIO_2057_RFPLL_MMD0, ci2->RF_rfpll_mmd0);
+		write_radio_reg(pi, RADIO_2057_RFPLL_MMD1, ci2->RF_rfpll_mmd1);
+		write_radio_reg(pi,
+				RADIO_2057_VCOBUF_TUNE, ci2->RF_vcobuf_tune);
+		write_radio_reg(pi,
+				RADIO_2057_LOGEN_MX2G_TUNE,
+				ci2->RF_logen_mx2g_tune);
+		write_radio_reg(pi, RADIO_2057_LOGEN_INDBUF2G_TUNE,
+				ci2->RF_logen_indbuf2g_tune);
+
+		write_radio_reg(pi,
+				RADIO_2057_TXMIX2G_TUNE_BOOST_PU_CORE0,
+				ci2->RF_txmix2g_tune_boost_pu_core0);
+		write_radio_reg(pi,
+				RADIO_2057_PAD2G_TUNE_PUS_CORE0,
+				ci2->RF_pad2g_tune_pus_core0);
+		write_radio_reg(pi, RADIO_2057_LNA2G_TUNE_CORE0,
+				ci2->RF_lna2g_tune_core0);
+
+		write_radio_reg(pi,
+				RADIO_2057_TXMIX2G_TUNE_BOOST_PU_CORE1,
+				ci2->RF_txmix2g_tune_boost_pu_core1);
+		write_radio_reg(pi,
+				RADIO_2057_PAD2G_TUNE_PUS_CORE1,
+				ci2->RF_pad2g_tune_pus_core1);
+		write_radio_reg(pi, RADIO_2057_LNA2G_TUNE_CORE1,
+				ci2->RF_lna2g_tune_core1);
+
+	} else {
+
+		write_radio_reg(pi,
+				RADIO_2057_VCOCAL_COUNTVAL0,
+				ci->RF_vcocal_countval0);
+		write_radio_reg(pi, RADIO_2057_VCOCAL_COUNTVAL1,
+				ci->RF_vcocal_countval1);
+		write_radio_reg(pi, RADIO_2057_RFPLL_REFMASTER_SPAREXTALSIZE,
+				ci->RF_rfpll_refmaster_sparextalsize);
+		write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_R1,
+				ci->RF_rfpll_loopfilter_r1);
+		write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C2,
+				ci->RF_rfpll_loopfilter_c2);
+		write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C1,
+				ci->RF_rfpll_loopfilter_c1);
+		write_radio_reg(pi, RADIO_2057_CP_KPD_IDAC, ci->RF_cp_kpd_idac);
+		write_radio_reg(pi, RADIO_2057_RFPLL_MMD0, ci->RF_rfpll_mmd0);
+		write_radio_reg(pi, RADIO_2057_RFPLL_MMD1, ci->RF_rfpll_mmd1);
+		write_radio_reg(pi, RADIO_2057_VCOBUF_TUNE, ci->RF_vcobuf_tune);
+		write_radio_reg(pi,
+				RADIO_2057_LOGEN_MX2G_TUNE,
+				ci->RF_logen_mx2g_tune);
+		write_radio_reg(pi, RADIO_2057_LOGEN_MX5G_TUNE,
+				ci->RF_logen_mx5g_tune);
+		write_radio_reg(pi, RADIO_2057_LOGEN_INDBUF2G_TUNE,
+				ci->RF_logen_indbuf2g_tune);
+		write_radio_reg(pi, RADIO_2057_LOGEN_INDBUF5G_TUNE,
+				ci->RF_logen_indbuf5g_tune);
+
+		write_radio_reg(pi,
+				RADIO_2057_TXMIX2G_TUNE_BOOST_PU_CORE0,
+				ci->RF_txmix2g_tune_boost_pu_core0);
+		write_radio_reg(pi,
+				RADIO_2057_PAD2G_TUNE_PUS_CORE0,
+				ci->RF_pad2g_tune_pus_core0);
+		write_radio_reg(pi, RADIO_2057_PGA_BOOST_TUNE_CORE0,
+				ci->RF_pga_boost_tune_core0);
+		write_radio_reg(pi, RADIO_2057_TXMIX5G_BOOST_TUNE_CORE0,
+				ci->RF_txmix5g_boost_tune_core0);
+		write_radio_reg(pi, RADIO_2057_PAD5G_TUNE_MISC_PUS_CORE0,
+				ci->RF_pad5g_tune_misc_pus_core0);
+		write_radio_reg(pi, RADIO_2057_LNA2G_TUNE_CORE0,
+				ci->RF_lna2g_tune_core0);
+		write_radio_reg(pi, RADIO_2057_LNA5G_TUNE_CORE0,
+				ci->RF_lna5g_tune_core0);
+
+		write_radio_reg(pi,
+				RADIO_2057_TXMIX2G_TUNE_BOOST_PU_CORE1,
+				ci->RF_txmix2g_tune_boost_pu_core1);
+		write_radio_reg(pi,
+				RADIO_2057_PAD2G_TUNE_PUS_CORE1,
+				ci->RF_pad2g_tune_pus_core1);
+		write_radio_reg(pi, RADIO_2057_PGA_BOOST_TUNE_CORE1,
+				ci->RF_pga_boost_tune_core1);
+		write_radio_reg(pi, RADIO_2057_TXMIX5G_BOOST_TUNE_CORE1,
+				ci->RF_txmix5g_boost_tune_core1);
+		write_radio_reg(pi, RADIO_2057_PAD5G_TUNE_MISC_PUS_CORE1,
+				ci->RF_pad5g_tune_misc_pus_core1);
+		write_radio_reg(pi, RADIO_2057_LNA2G_TUNE_CORE1,
+				ci->RF_lna2g_tune_core1);
+		write_radio_reg(pi, RADIO_2057_LNA5G_TUNE_CORE1,
+				ci->RF_lna5g_tune_core1);
+	}
+
+	if ((pi->pubpi.radiorev <= 4) || (pi->pubpi.radiorev == 6)) {
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_R1,
+					0x3f);
+			write_radio_reg(pi, RADIO_2057_CP_KPD_IDAC, 0x3f);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C1,
+					0x8);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C2,
+					0x8);
+		} else {
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_R1,
+					0x1f);
+			write_radio_reg(pi, RADIO_2057_CP_KPD_IDAC, 0x3f);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C1,
+					0x8);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C2,
+					0x8);
+		}
+	} else if ((pi->pubpi.radiorev == 5) || (pi->pubpi.radiorev == 7) ||
+		   (pi->pubpi.radiorev == 8)) {
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_R1,
+					0x1b);
+			write_radio_reg(pi, RADIO_2057_CP_KPD_IDAC, 0x30);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C1,
+					0xa);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C2,
+					0xa);
+		} else {
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_R1,
+					0x1f);
+			write_radio_reg(pi, RADIO_2057_CP_KPD_IDAC, 0x3f);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C1,
+					0x8);
+			write_radio_reg(pi, RADIO_2057_RFPLL_LOOPFILTER_C2,
+					0x8);
+		}
+
+	}
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		if (PHY_IPA(pi)) {
+			if (pi->pubpi.radiorev == 3) {
+				txmix2g_tune_boost_pu = 0x6b;
+			}
+
+			if (pi->pubpi.radiorev == 5)
+				pad2g_tune_pus = 0x73;
+
+		} else {
+			if (pi->pubpi.radiorev != 5) {
+				pad2g_tune_pus = 0x3;
+
+				txmix2g_tune_boost_pu = 0x61;
+			}
+		}
+
+		for (coreNum = 0; coreNum <= 1; coreNum++) {
+
+			if (txmix2g_tune_boost_pu != 0)
+				WRITE_RADIO_REG4(pi, RADIO_2057, CORE, coreNum,
+						 TXMIX2G_TUNE_BOOST_PU,
+						 txmix2g_tune_boost_pu);
+
+			if (pad2g_tune_pus != 0)
+				WRITE_RADIO_REG4(pi, RADIO_2057, CORE, coreNum,
+						 PAD2G_TUNE_PUS,
+						 pad2g_tune_pus);
+		}
+	}
+
+	OSL_DELAY(50);
+
+	wlc_phy_radio205x_vcocal_nphy(pi);
+}
+
+static uint16 wlc_phy_radio2057_rccal(phy_info_t * pi)
+{
+	uint16 rccal_valid;
+	int i;
+	bool chip43226_6362A0;
+
+	chip43226_6362A0 = ((pi->pubpi.radiorev == 3)
+			    || (pi->pubpi.radiorev == 4)
+			    || (pi->pubpi.radiorev == 6));
+
+	rccal_valid = 0;
+	if (chip43226_6362A0) {
+		write_radio_reg(pi, RADIO_2057_RCCAL_MASTER, 0x61);
+		write_radio_reg(pi, RADIO_2057_RCCAL_TRC0, 0xc0);
+	} else {
+		write_radio_reg(pi, RADIO_2057v7_RCCAL_MASTER, 0x61);
+
+		write_radio_reg(pi, RADIO_2057_RCCAL_TRC0, 0xe9);
+	}
+	write_radio_reg(pi, RADIO_2057_RCCAL_X1, 0x6e);
+	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x55);
+
+	for (i = 0; i < MAX_205x_RCAL_WAITLOOPS; i++) {
+		rccal_valid = read_radio_reg(pi, RADIO_2057_RCCAL_DONE_OSCCAP);
+		if (rccal_valid & 0x2) {
+			break;
+		}
+		OSL_DELAY(500);
+	}
+
+	ASSERT(rccal_valid & 0x2);
+
+	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x15);
+
+	rccal_valid = 0;
+	if (chip43226_6362A0) {
+		write_radio_reg(pi, RADIO_2057_RCCAL_MASTER, 0x69);
+		write_radio_reg(pi, RADIO_2057_RCCAL_TRC0, 0xb0);
+	} else {
+		write_radio_reg(pi, RADIO_2057v7_RCCAL_MASTER, 0x69);
+
+		write_radio_reg(pi, RADIO_2057_RCCAL_TRC0, 0xd5);
+	}
+	write_radio_reg(pi, RADIO_2057_RCCAL_X1, 0x6e);
+	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x55);
+
+	for (i = 0; i < MAX_205x_RCAL_WAITLOOPS; i++) {
+		rccal_valid = read_radio_reg(pi, RADIO_2057_RCCAL_DONE_OSCCAP);
+		if (rccal_valid & 0x2) {
+			break;
+		}
+		OSL_DELAY(500);
+	}
+
+	ASSERT(rccal_valid & 0x2);
+
+	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x15);
+
+	rccal_valid = 0;
+	if (chip43226_6362A0) {
+		write_radio_reg(pi, RADIO_2057_RCCAL_MASTER, 0x73);
+
+		write_radio_reg(pi, RADIO_2057_RCCAL_X1, 0x28);
+		write_radio_reg(pi, RADIO_2057_RCCAL_TRC0, 0xb0);
+	} else {
+		write_radio_reg(pi, RADIO_2057v7_RCCAL_MASTER, 0x73);
+		write_radio_reg(pi, RADIO_2057_RCCAL_X1, 0x6e);
+		write_radio_reg(pi, RADIO_2057_RCCAL_TRC0, 0x99);
+	}
+	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x55);
+
+	for (i = 0; i < MAX_205x_RCAL_WAITLOOPS; i++) {
+		rccal_valid = read_radio_reg(pi, RADIO_2057_RCCAL_DONE_OSCCAP);
+		if (rccal_valid & 0x2) {
+			break;
+		}
+		OSL_DELAY(500);
+	}
+
+	ASSERT(rccal_valid & 0x2);
+
+	write_radio_reg(pi, RADIO_2057_RCCAL_START_R1_Q1_P1, 0x15);
+
+	return (rccal_valid);
+}
+
+static void
+wlc_phy_adjust_rx_analpfbw_nphy(phy_info_t * pi, uint16 reduction_factr)
+{
+	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
+		if ((CHSPEC_CHANNEL(pi->radio_chanspec) == 11) &&
+		    CHSPEC_IS40(pi->radio_chanspec)) {
+			if (!pi->nphy_anarxlpf_adjusted) {
+				write_radio_reg(pi,
+						(RADIO_2056_RX_RXLPF_RCCAL_LPC |
+						 RADIO_2056_RX0),
+						((pi->nphy_rccal_value +
+						  reduction_factr) | 0x80));
+
+				pi->nphy_anarxlpf_adjusted = TRUE;
+			}
+		} else {
+			if (pi->nphy_anarxlpf_adjusted) {
+				write_radio_reg(pi,
+						(RADIO_2056_RX_RXLPF_RCCAL_LPC |
+						 RADIO_2056_RX0),
+						(pi->nphy_rccal_value | 0x80));
+
+				pi->nphy_anarxlpf_adjusted = FALSE;
+			}
+		}
+	}
+}
+
+static void
+wlc_phy_adjust_min_noisevar_nphy(phy_info_t * pi, int ntones, int *tone_id_buf,
+				 uint32 * noise_var_buf)
+{
+	int i;
+	uint32 offset;
+	int tone_id;
+	int tbllen =
+	    CHSPEC_IS40(pi->
+			radio_chanspec) ? NPHY_NOISEVAR_TBLLEN40 :
+	    NPHY_NOISEVAR_TBLLEN20;
+
+	if (pi->nphy_noisevars_adjusted) {
+		for (i = 0; i < pi->nphy_saved_noisevars.bufcount; i++) {
+			tone_id = pi->nphy_saved_noisevars.tone_id[i];
+			offset = (tone_id >= 0) ?
+			    ((tone_id * 2) + 1) : (tbllen + (tone_id * 2) + 1);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1,
+						 offset, 32,
+						 (void *)&pi->
+						 nphy_saved_noisevars.
+						 min_noise_vars[i]);
+		}
+
+		pi->nphy_saved_noisevars.bufcount = 0;
+		pi->nphy_noisevars_adjusted = FALSE;
+	}
+
+	if ((noise_var_buf != NULL) && (tone_id_buf != NULL)) {
+		pi->nphy_saved_noisevars.bufcount = 0;
+
+		for (i = 0; i < ntones; i++) {
+			tone_id = tone_id_buf[i];
+			offset = (tone_id >= 0) ?
+			    ((tone_id * 2) + 1) : (tbllen + (tone_id * 2) + 1);
+			pi->nphy_saved_noisevars.tone_id[i] = tone_id;
+			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1,
+						offset, 32,
+						&pi->nphy_saved_noisevars.
+						min_noise_vars[i]);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_NOISEVAR, 1,
+						 offset, 32,
+						 (void *)&noise_var_buf[i]);
+			pi->nphy_saved_noisevars.bufcount++;
+		}
+
+		pi->nphy_noisevars_adjusted = TRUE;
+	}
+}
+
+static void wlc_phy_adjust_crsminpwr_nphy(phy_info_t * pi, uint8 minpwr)
+{
+	uint16 regval;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if ((CHSPEC_CHANNEL(pi->radio_chanspec) == 11) &&
+		    CHSPEC_IS40(pi->radio_chanspec)) {
+			if (!pi->nphy_crsminpwr_adjusted) {
+				regval = read_phy_reg(pi, 0x27d);
+				pi->nphy_crsminpwr[0] = regval & 0xff;
+				regval &= 0xff00;
+				regval |= (uint16) minpwr;
+				write_phy_reg(pi, 0x27d, regval);
+
+				regval = read_phy_reg(pi, 0x280);
+				pi->nphy_crsminpwr[1] = regval & 0xff;
+				regval &= 0xff00;
+				regval |= (uint16) minpwr;
+				write_phy_reg(pi, 0x280, regval);
+
+				regval = read_phy_reg(pi, 0x283);
+				pi->nphy_crsminpwr[2] = regval & 0xff;
+				regval &= 0xff00;
+				regval |= (uint16) minpwr;
+				write_phy_reg(pi, 0x283, regval);
+
+				pi->nphy_crsminpwr_adjusted = TRUE;
+			}
+		} else {
+			if (pi->nphy_crsminpwr_adjusted) {
+				regval = read_phy_reg(pi, 0x27d);
+				regval &= 0xff00;
+				regval |= pi->nphy_crsminpwr[0];
+				write_phy_reg(pi, 0x27d, regval);
+
+				regval = read_phy_reg(pi, 0x280);
+				regval &= 0xff00;
+				regval |= pi->nphy_crsminpwr[1];
+				write_phy_reg(pi, 0x280, regval);
+
+				regval = read_phy_reg(pi, 0x283);
+				regval &= 0xff00;
+				regval |= pi->nphy_crsminpwr[2];
+				write_phy_reg(pi, 0x283, regval);
+
+				pi->nphy_crsminpwr_adjusted = FALSE;
+			}
+		}
+	}
+}
+
+static void wlc_phy_txlpfbw_nphy(phy_info_t * pi)
+{
+	uint8 tx_lpf_bw = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
+		if (CHSPEC_IS40(pi->radio_chanspec)) {
+			tx_lpf_bw = 3;
+		} else {
+			tx_lpf_bw = 1;
+		}
+
+		if (PHY_IPA(pi)) {
+			if (CHSPEC_IS40(pi->radio_chanspec)) {
+				tx_lpf_bw = 5;
+			} else {
+				tx_lpf_bw = 4;
+			}
+		}
+		write_phy_reg(pi, 0xe8,
+			      (tx_lpf_bw << 0) |
+			      (tx_lpf_bw << 3) |
+			      (tx_lpf_bw << 6) | (tx_lpf_bw << 9));
+
+		if (PHY_IPA(pi)) {
+
+			if (CHSPEC_IS40(pi->radio_chanspec)) {
+				tx_lpf_bw = 4;
+			} else {
+				tx_lpf_bw = 1;
+			}
+
+			write_phy_reg(pi, 0xe9,
+				      (tx_lpf_bw << 0) |
+				      (tx_lpf_bw << 3) |
+				      (tx_lpf_bw << 6) | (tx_lpf_bw << 9));
+		}
+	}
+}
+
+static void wlc_phy_spurwar_nphy(phy_info_t * pi)
+{
+	uint16 cur_channel = 0;
+	int nphy_adj_tone_id_buf[] = { 57, 58 };
+	uint32 nphy_adj_noise_var_buf[] = { 0x3ff, 0x3ff };
+	bool isAdjustNoiseVar = FALSE;
+	uint numTonesAdjust = 0;
+	uint32 tempval = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if (pi->phyhang_avoid)
+			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+		cur_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
+
+		if (pi->nphy_gband_spurwar_en) {
+
+			wlc_phy_adjust_rx_analpfbw_nphy(pi,
+							NPHY_ANARXLPFBW_REDUCTIONFACT);
+
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				if ((cur_channel == 11)
+				    && CHSPEC_IS40(pi->radio_chanspec)) {
+
+					wlc_phy_adjust_min_noisevar_nphy(pi, 2,
+									 nphy_adj_tone_id_buf,
+									 nphy_adj_noise_var_buf);
+				} else {
+
+					wlc_phy_adjust_min_noisevar_nphy(pi, 0,
+									 NULL,
+									 NULL);
+				}
+			}
+			wlc_phy_adjust_crsminpwr_nphy(pi,
+						      NPHY_ADJUSTED_MINCRSPOWER);
+		}
+
+		if ((pi->nphy_gband_spurwar2_en)
+		    && CHSPEC_IS2G(pi->radio_chanspec)) {
+
+			if (CHSPEC_IS40(pi->radio_chanspec)) {
+				switch (cur_channel) {
+				case 3:
+					nphy_adj_tone_id_buf[0] = 57;
+					nphy_adj_tone_id_buf[1] = 58;
+					nphy_adj_noise_var_buf[0] = 0x22f;
+					nphy_adj_noise_var_buf[1] = 0x25f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				case 4:
+					nphy_adj_tone_id_buf[0] = 41;
+					nphy_adj_tone_id_buf[1] = 42;
+					nphy_adj_noise_var_buf[0] = 0x22f;
+					nphy_adj_noise_var_buf[1] = 0x25f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				case 5:
+					nphy_adj_tone_id_buf[0] = 25;
+					nphy_adj_tone_id_buf[1] = 26;
+					nphy_adj_noise_var_buf[0] = 0x24f;
+					nphy_adj_noise_var_buf[1] = 0x25f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				case 6:
+					nphy_adj_tone_id_buf[0] = 9;
+					nphy_adj_tone_id_buf[1] = 10;
+					nphy_adj_noise_var_buf[0] = 0x22f;
+					nphy_adj_noise_var_buf[1] = 0x24f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				case 7:
+					nphy_adj_tone_id_buf[0] = 121;
+					nphy_adj_tone_id_buf[1] = 122;
+					nphy_adj_noise_var_buf[0] = 0x18f;
+					nphy_adj_noise_var_buf[1] = 0x24f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				case 8:
+					nphy_adj_tone_id_buf[0] = 105;
+					nphy_adj_tone_id_buf[1] = 106;
+					nphy_adj_noise_var_buf[0] = 0x22f;
+					nphy_adj_noise_var_buf[1] = 0x25f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				case 9:
+					nphy_adj_tone_id_buf[0] = 89;
+					nphy_adj_tone_id_buf[1] = 90;
+					nphy_adj_noise_var_buf[0] = 0x22f;
+					nphy_adj_noise_var_buf[1] = 0x24f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				case 10:
+					nphy_adj_tone_id_buf[0] = 73;
+					nphy_adj_tone_id_buf[1] = 74;
+					nphy_adj_noise_var_buf[0] = 0x22f;
+					nphy_adj_noise_var_buf[1] = 0x24f;
+					isAdjustNoiseVar = TRUE;
+					break;
+				default:
+					isAdjustNoiseVar = FALSE;
+					break;
+				}
+			}
+
+			if (isAdjustNoiseVar) {
+				numTonesAdjust = sizeof(nphy_adj_tone_id_buf) /
+				    sizeof(nphy_adj_tone_id_buf[0]);
+
+				wlc_phy_adjust_min_noisevar_nphy(pi,
+								 numTonesAdjust,
+								 nphy_adj_tone_id_buf,
+								 nphy_adj_noise_var_buf);
+
+				tempval = 0;
+
+			} else {
+
+				wlc_phy_adjust_min_noisevar_nphy(pi, 0, NULL,
+								 NULL);
+			}
+		}
+
+		if ((pi->nphy_aband_spurwar_en) &&
+		    (CHSPEC_IS5G(pi->radio_chanspec))) {
+			switch (cur_channel) {
+			case 54:
+				nphy_adj_tone_id_buf[0] = 32;
+				nphy_adj_noise_var_buf[0] = 0x25f;
+				break;
+			case 38:
+			case 102:
+			case 118:
+				if ((CHIPID(pi->sh->chip) == BCM4716_CHIP_ID) &&
+				    (pi->sh->chippkg == BCM4717_PKG_ID)) {
+					nphy_adj_tone_id_buf[0] = 32;
+					nphy_adj_noise_var_buf[0] = 0x21f;
+				} else {
+					nphy_adj_tone_id_buf[0] = 0;
+					nphy_adj_noise_var_buf[0] = 0x0;
+				}
+				break;
+			case 134:
+				nphy_adj_tone_id_buf[0] = 32;
+				nphy_adj_noise_var_buf[0] = 0x21f;
+				break;
+			case 151:
+				nphy_adj_tone_id_buf[0] = 16;
+				nphy_adj_noise_var_buf[0] = 0x23f;
+				break;
+			case 153:
+			case 161:
+				nphy_adj_tone_id_buf[0] = 48;
+				nphy_adj_noise_var_buf[0] = 0x23f;
+				break;
+			default:
+				nphy_adj_tone_id_buf[0] = 0;
+				nphy_adj_noise_var_buf[0] = 0x0;
+				break;
+			}
+
+			if (nphy_adj_tone_id_buf[0]
+			    && nphy_adj_noise_var_buf[0]) {
+				wlc_phy_adjust_min_noisevar_nphy(pi, 1,
+								 nphy_adj_tone_id_buf,
+								 nphy_adj_noise_var_buf);
+			} else {
+				wlc_phy_adjust_min_noisevar_nphy(pi, 0, NULL,
+								 NULL);
+			}
+		}
+
+		if (pi->phyhang_avoid)
+			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	}
+}
+
+static void
+wlc_phy_chanspec_nphy_setup(phy_info_t * pi, chanspec_t chanspec,
+			    const nphy_sfo_cfg_t * ci)
+{
+	uint16 val;
+
+	val = read_phy_reg(pi, 0x09) & NPHY_BandControl_currentBand;
+	if (CHSPEC_IS5G(chanspec) && !val) {
+
+		val = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param);
+		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param,
+		      (val | MAC_PHY_FORCE_CLK));
+
+		or_phy_reg(pi, (NPHY_TO_BPHY_OFF + BPHY_BB_CONFIG),
+			   (BBCFG_RESETCCA | BBCFG_RESETRX));
+
+		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, val);
+
+		or_phy_reg(pi, 0x09, NPHY_BandControl_currentBand);
+	} else if (!CHSPEC_IS5G(chanspec) && val) {
+
+		and_phy_reg(pi, 0x09, ~NPHY_BandControl_currentBand);
+
+		val = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param);
+		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param,
+		      (val | MAC_PHY_FORCE_CLK));
+
+		and_phy_reg(pi, (NPHY_TO_BPHY_OFF + BPHY_BB_CONFIG),
+			    (uint16) (~(BBCFG_RESETCCA | BBCFG_RESETRX)));
+
+		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, val);
+	}
+
+	write_phy_reg(pi, 0x1ce, ci->PHY_BW1a);
+	write_phy_reg(pi, 0x1cf, ci->PHY_BW2);
+	write_phy_reg(pi, 0x1d0, ci->PHY_BW3);
+
+	write_phy_reg(pi, 0x1d1, ci->PHY_BW4);
+	write_phy_reg(pi, 0x1d2, ci->PHY_BW5);
+	write_phy_reg(pi, 0x1d3, ci->PHY_BW6);
+
+	if (CHSPEC_CHANNEL(pi->radio_chanspec) == 14) {
+		wlc_phy_classifier_nphy(pi, NPHY_ClassifierCtrl_ofdm_en, 0);
+
+		or_phy_reg(pi, NPHY_TO_BPHY_OFF + BPHY_TEST, 0x800);
+	} else {
+		wlc_phy_classifier_nphy(pi, NPHY_ClassifierCtrl_ofdm_en,
+					NPHY_ClassifierCtrl_ofdm_en);
+
+		if (CHSPEC_IS2G(chanspec))
+			and_phy_reg(pi, NPHY_TO_BPHY_OFF + BPHY_TEST, ~0x840);
+	}
+
+	if (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF) {
+		wlc_phy_txpwr_fixpower_nphy(pi);
+	}
+
+	if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+
+		wlc_phy_adjust_lnagaintbl_nphy(pi);
+	}
+
+	wlc_phy_txlpfbw_nphy(pi);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)
+	    && (pi->phy_spuravoid != SPURAVOID_DISABLE)) {
+		uint8 spuravoid = 0;
+
+		val = CHSPEC_CHANNEL(chanspec);
+		if (!CHSPEC_IS40(pi->radio_chanspec)) {
+			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+				if ((val == 13) || (val == 14) || (val == 153)) {
+					spuravoid = 1;
+				}
+			} else {
+
+				if (((val >= 5) && (val <= 8)) || (val == 13)
+				    || (val == 14)) {
+					spuravoid = 1;
+				}
+			}
+		} else {
+			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+				if (val == 54) {
+					spuravoid = 1;
+				}
+			} else {
+
+				if (pi->nphy_aband_spurwar_en &&
+				    ((val == 38) || (val == 102)
+				     || (val == 118))) {
+					if ((CHIPID(pi->sh->chip) ==
+					     BCM4716_CHIP_ID)
+					    && (pi->sh->chippkg ==
+						BCM4717_PKG_ID)) {
+						spuravoid = 0;
+					} else {
+						spuravoid = 1;
+					}
+				}
+			}
+		}
+
+		if (pi->phy_spuravoid == SPURAVOID_FORCEON)
+			spuravoid = 1;
+
+		if ((CHIPID(pi->sh->chip) == BCM4716_CHIP_ID) ||
+		    (CHIPID(pi->sh->chip) == BCM47162_CHIP_ID)) {
+			si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, spuravoid);
+		} else {
+			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, FALSE);
+			si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, spuravoid);
+			wlapi_bmac_core_phypll_ctl(pi->sh->physhim, TRUE);
+		}
+
+		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID) ||
+		    (CHIPID(pi->sh->chip) == BCM43225_CHIP_ID) ||
+		    (CHIPID(pi->sh->chip) == BCM43421_CHIP_ID)) {
+
+			if (spuravoid == 1) {
+
+				W_REG(pi->sh->osh, &pi->regs->tsf_clk_frac_l,
+				      0x5341);
+				W_REG(pi->sh->osh, &pi->regs->tsf_clk_frac_h,
+				      0x8);
+			} else {
+
+				W_REG(pi->sh->osh, &pi->regs->tsf_clk_frac_l,
+				      0x8889);
+				W_REG(pi->sh->osh, &pi->regs->tsf_clk_frac_h,
+				      0x8);
+			}
+		}
+
+		if (!((CHIPID(pi->sh->chip) == BCM4716_CHIP_ID) ||
+		      (CHIPID(pi->sh->chip) == BCM47162_CHIP_ID))) {
+			wlapi_bmac_core_phypll_reset(pi->sh->physhim);
+		}
+
+		mod_phy_reg(pi, 0x01, (0x1 << 15),
+			    ((spuravoid > 0) ? (0x1 << 15) : 0));
+
+		wlc_phy_resetcca_nphy(pi);
+
+		pi->phy_isspuravoid = (spuravoid > 0);
+	}
+
+	if (NREV_LT(pi->pubpi.phy_rev, 7))
+		write_phy_reg(pi, 0x17e, 0x3830);
+
+	wlc_phy_spurwar_nphy(pi);
+}
+
+void wlc_phy_chanspec_set_nphy(phy_info_t * pi, chanspec_t chanspec)
+{
+	int freq;
+	chan_info_nphy_radio2057_t *t0 = NULL;
+	chan_info_nphy_radio205x_t *t1 = NULL;
+	chan_info_nphy_radio2057_rev5_t *t2 = NULL;
+	chan_info_nphy_2055_t *t3 = NULL;
+
+	if (NORADIO_ENAB(pi->pubpi)) {
+		return;
+	}
+
+	if (!wlc_phy_chan2freq_nphy
+	    (pi, CHSPEC_CHANNEL(chanspec), &freq, &t0, &t1, &t2, &t3))
+		return;
+
+	wlc_phy_chanspec_radio_set((wlc_phy_t *) pi, chanspec);
+
+	if (CHSPEC_BW(chanspec) != pi->bw)
+		wlapi_bmac_bw_set(pi->sh->physhim, CHSPEC_BW(chanspec));
+
+	if (CHSPEC_IS40(chanspec)) {
+		if (CHSPEC_SB_UPPER(chanspec)) {
+			or_phy_reg(pi, 0xa0, BPHY_BAND_SEL_UP20);
+			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+				or_phy_reg(pi, 0x310, PRIM_SEL_UP20);
+			}
+		} else {
+			and_phy_reg(pi, 0xa0, ~BPHY_BAND_SEL_UP20);
+			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+				and_phy_reg(pi, 0x310,
+					    (~PRIM_SEL_UP20 & 0xffff));
+			}
+		}
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+			if ((pi->pubpi.radiorev <= 4)
+			    || (pi->pubpi.radiorev == 6)) {
+				mod_radio_reg(pi, RADIO_2057_TIA_CONFIG_CORE0,
+					      0x2,
+					      (CHSPEC_IS5G(chanspec) ? (1 << 1)
+					       : 0));
+				mod_radio_reg(pi, RADIO_2057_TIA_CONFIG_CORE1,
+					      0x2,
+					      (CHSPEC_IS5G(chanspec) ? (1 << 1)
+					       : 0));
+			}
+
+			wlc_phy_chanspec_radio2057_setup(pi, t0, t2);
+			wlc_phy_chanspec_nphy_setup(pi, chanspec,
+						    (pi->pubpi.radiorev ==
+						     5) ? (const nphy_sfo_cfg_t
+							   *)&(t2->
+							       PHY_BW1a)
+						    : (const nphy_sfo_cfg_t *)
+						    &(t0->PHY_BW1a));
+
+		} else {
+
+			mod_radio_reg(pi,
+				      RADIO_2056_SYN_COM_CTRL | RADIO_2056_SYN,
+				      0x4,
+				      (CHSPEC_IS5G(chanspec) ? (0x1 << 2) : 0));
+			wlc_phy_chanspec_radio2056_setup(pi, t1);
+
+			wlc_phy_chanspec_nphy_setup(pi, chanspec,
+						    (const nphy_sfo_cfg_t *)
+						    &(t1->PHY_BW1a));
+		}
+
+	} else {
+
+		mod_radio_reg(pi, RADIO_2055_MASTER_CNTRL1, 0x70,
+			      (CHSPEC_IS5G(chanspec) ? (0x02 << 4)
+			       : (0x05 << 4)));
+
+		wlc_phy_chanspec_radio2055_setup(pi, t3);
+		wlc_phy_chanspec_nphy_setup(pi, chanspec,
+					    (const nphy_sfo_cfg_t *)&(t3->
+								      PHY_BW1a));
+	}
+
+}
+
+static void wlc_phy_savecal_nphy(phy_info_t * pi)
+{
+	void *tbl_ptr;
+	int coreNum;
+	uint16 *txcal_radio_regs = NULL;
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+
+		wlc_phy_rx_iq_coeffs_nphy(pi, 0,
+					  &pi->calibration_cache.
+					  rxcal_coeffs_2G);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			txcal_radio_regs =
+			    pi->calibration_cache.txcal_radio_regs_2G;
+		} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			pi->calibration_cache.txcal_radio_regs_2G[0] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_I |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_2G[1] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_Q |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_2G[2] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_I |
+					   RADIO_2056_TX1);
+			pi->calibration_cache.txcal_radio_regs_2G[3] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_Q |
+					   RADIO_2056_TX1);
+
+			pi->calibration_cache.txcal_radio_regs_2G[4] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_I |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_2G[5] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_Q |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_2G[6] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_I |
+					   RADIO_2056_TX1);
+			pi->calibration_cache.txcal_radio_regs_2G[7] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_Q |
+					   RADIO_2056_TX1);
+		} else {
+			pi->calibration_cache.txcal_radio_regs_2G[0] =
+			    read_radio_reg(pi, RADIO_2055_CORE1_TX_VOS_CNCL);
+			pi->calibration_cache.txcal_radio_regs_2G[1] =
+			    read_radio_reg(pi, RADIO_2055_CORE2_TX_VOS_CNCL);
+			pi->calibration_cache.txcal_radio_regs_2G[2] =
+			    read_radio_reg(pi, RADIO_2055_CORE1_TX_BB_MXGM);
+			pi->calibration_cache.txcal_radio_regs_2G[3] =
+			    read_radio_reg(pi, RADIO_2055_CORE2_TX_BB_MXGM);
+		}
+
+		pi->nphy_iqcal_chanspec_2G = pi->radio_chanspec;
+		tbl_ptr = pi->calibration_cache.txcal_coeffs_2G;
+	} else {
+
+		wlc_phy_rx_iq_coeffs_nphy(pi, 0,
+					  &pi->calibration_cache.
+					  rxcal_coeffs_5G);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			txcal_radio_regs =
+			    pi->calibration_cache.txcal_radio_regs_5G;
+		} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			pi->calibration_cache.txcal_radio_regs_5G[0] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_I |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_5G[1] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_Q |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_5G[2] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_I |
+					   RADIO_2056_TX1);
+			pi->calibration_cache.txcal_radio_regs_5G[3] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_FINE_Q |
+					   RADIO_2056_TX1);
+
+			pi->calibration_cache.txcal_radio_regs_5G[4] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_I |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_5G[5] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_Q |
+					   RADIO_2056_TX0);
+			pi->calibration_cache.txcal_radio_regs_5G[6] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_I |
+					   RADIO_2056_TX1);
+			pi->calibration_cache.txcal_radio_regs_5G[7] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_LOFT_COARSE_Q |
+					   RADIO_2056_TX1);
+		} else {
+			pi->calibration_cache.txcal_radio_regs_5G[0] =
+			    read_radio_reg(pi, RADIO_2055_CORE1_TX_VOS_CNCL);
+			pi->calibration_cache.txcal_radio_regs_5G[1] =
+			    read_radio_reg(pi, RADIO_2055_CORE2_TX_VOS_CNCL);
+			pi->calibration_cache.txcal_radio_regs_5G[2] =
+			    read_radio_reg(pi, RADIO_2055_CORE1_TX_BB_MXGM);
+			pi->calibration_cache.txcal_radio_regs_5G[3] =
+			    read_radio_reg(pi, RADIO_2055_CORE2_TX_BB_MXGM);
+		}
+
+		pi->nphy_iqcal_chanspec_5G = pi->radio_chanspec;
+		tbl_ptr = pi->calibration_cache.txcal_coeffs_5G;
+	}
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		for (coreNum = 0; coreNum <= 1; coreNum++) {
+
+			txcal_radio_regs[2 * coreNum] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					    LOFT_FINE_I);
+			txcal_radio_regs[2 * coreNum + 1] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					    LOFT_FINE_Q);
+
+			txcal_radio_regs[2 * coreNum + 4] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					    LOFT_COARSE_I);
+			txcal_radio_regs[2 * coreNum + 5] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					    LOFT_COARSE_Q);
+		}
+	}
+
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL, 8, 80, 16, tbl_ptr);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static void wlc_phy_restorecal_nphy(phy_info_t * pi)
+{
+	uint16 *loft_comp;
+	uint16 txcal_coeffs_bphy[4];
+	uint16 *tbl_ptr;
+	int coreNum;
+	uint16 *txcal_radio_regs = NULL;
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		if (pi->nphy_iqcal_chanspec_2G == 0)
+			return;
+
+		tbl_ptr = pi->calibration_cache.txcal_coeffs_2G;
+		loft_comp = &pi->calibration_cache.txcal_coeffs_2G[5];
+	} else {
+		if (pi->nphy_iqcal_chanspec_5G == 0)
+			return;
+
+		tbl_ptr = pi->calibration_cache.txcal_coeffs_5G;
+		loft_comp = &pi->calibration_cache.txcal_coeffs_5G[5];
+	}
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 4, 80, 16,
+				 (void *)tbl_ptr);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		txcal_coeffs_bphy[0] = tbl_ptr[0];
+		txcal_coeffs_bphy[1] = tbl_ptr[1];
+		txcal_coeffs_bphy[2] = tbl_ptr[2];
+		txcal_coeffs_bphy[3] = tbl_ptr[3];
+	} else {
+		txcal_coeffs_bphy[0] = 0;
+		txcal_coeffs_bphy[1] = 0;
+		txcal_coeffs_bphy[2] = 0;
+		txcal_coeffs_bphy[3] = 0;
+	}
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 4, 88, 16,
+				 txcal_coeffs_bphy);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 85, 16, loft_comp);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 93, 16, loft_comp);
+
+	if (NREV_LT(pi->pubpi.phy_rev, 2))
+		wlc_phy_tx_iq_war_nphy(pi);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			txcal_radio_regs =
+			    pi->calibration_cache.txcal_radio_regs_2G;
+		} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_I |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[0]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_Q |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[1]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_I |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[2]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_Q |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[3]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_I |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[4]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_Q |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[5]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_I |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[6]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_Q |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[7]);
+		} else {
+			write_radio_reg(pi, RADIO_2055_CORE1_TX_VOS_CNCL,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[0]);
+			write_radio_reg(pi, RADIO_2055_CORE2_TX_VOS_CNCL,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[1]);
+			write_radio_reg(pi, RADIO_2055_CORE1_TX_BB_MXGM,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[2]);
+			write_radio_reg(pi, RADIO_2055_CORE2_TX_BB_MXGM,
+					pi->calibration_cache.
+					txcal_radio_regs_2G[3]);
+		}
+
+		wlc_phy_rx_iq_coeffs_nphy(pi, 1,
+					  &pi->calibration_cache.
+					  rxcal_coeffs_2G);
+	} else {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			txcal_radio_regs =
+			    pi->calibration_cache.txcal_radio_regs_5G;
+		} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_I |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[0]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_Q |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[1]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_I |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[2]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_FINE_Q |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[3]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_I |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[4]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_Q |
+					RADIO_2056_TX0,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[5]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_I |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[6]);
+			write_radio_reg(pi,
+					RADIO_2056_TX_LOFT_COARSE_Q |
+					RADIO_2056_TX1,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[7]);
+		} else {
+			write_radio_reg(pi, RADIO_2055_CORE1_TX_VOS_CNCL,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[0]);
+			write_radio_reg(pi, RADIO_2055_CORE2_TX_VOS_CNCL,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[1]);
+			write_radio_reg(pi, RADIO_2055_CORE1_TX_BB_MXGM,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[2]);
+			write_radio_reg(pi, RADIO_2055_CORE2_TX_BB_MXGM,
+					pi->calibration_cache.
+					txcal_radio_regs_5G[3]);
+		}
+
+		wlc_phy_rx_iq_coeffs_nphy(pi, 1,
+					  &pi->calibration_cache.
+					  rxcal_coeffs_5G);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		for (coreNum = 0; coreNum <= 1; coreNum++) {
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					 LOFT_FINE_I,
+					 txcal_radio_regs[2 * coreNum]);
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					 LOFT_FINE_Q,
+					 txcal_radio_regs[2 * coreNum + 1]);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					 LOFT_COARSE_I,
+					 txcal_radio_regs[2 * coreNum + 4]);
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, coreNum,
+					 LOFT_COARSE_Q,
+					 txcal_radio_regs[2 * coreNum + 5]);
+		}
+	}
+}
+
+void wlc_phy_antsel_init(wlc_phy_t * ppi, bool lut_init)
+{
+	phy_info_t *pi = (phy_info_t *) ppi;
+	uint16 mask = 0xfc00;
+	uint32 mc = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7))
+		return;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		uint16 v0 = 0x211, v1 = 0x222, v2 = 0x144, v3 = 0x188;
+
+		if (lut_init == FALSE)
+			return;
+
+		if (pi->srom_fem2g.antswctrllut == 0) {
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x02, 16, &v0);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x03, 16, &v1);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x08, 16, &v2);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x0C, 16, &v3);
+		} else {
+			ASSERT(0);
+		}
+
+		if (pi->srom_fem5g.antswctrllut == 0) {
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x12, 16, &v0);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x13, 16, &v1);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x18, 16, &v2);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_ANTSWCTRLLUT,
+						 1, 0x1C, 16, &v3);
+		} else {
+			ASSERT(0);
+		}
+	} else {
+
+		write_phy_reg(pi, 0xc8, 0x0);
+		write_phy_reg(pi, 0xc9, 0x0);
+
+		si_gpiocontrol(pi->sh->sih, mask, mask, GPIO_DRV_PRIORITY);
+
+		mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
+		mc &= ~MCTL_GPOUT_SEL_MASK;
+		W_REG(pi->sh->osh, &pi->regs->maccontrol, mc);
+
+		OR_REG(pi->sh->osh, &pi->regs->psm_gpio_oe, mask);
+
+		AND_REG(pi->sh->osh, &pi->regs->psm_gpio_out, ~mask);
+
+		if (lut_init) {
+			write_phy_reg(pi, 0xf8, 0x02d8);
+			write_phy_reg(pi, 0xf9, 0x0301);
+			write_phy_reg(pi, 0xfa, 0x02d8);
+			write_phy_reg(pi, 0xfb, 0x0301);
+		}
+	}
+}
+
+uint16 wlc_phy_classifier_nphy(phy_info_t * pi, uint16 mask, uint16 val)
+{
+	uint16 curr_ctl, new_ctl;
+	bool suspended = FALSE;
+
+	if (D11REV_IS(pi->sh->corerev, 16)) {
+		suspended =
+		    (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) ?
+		    FALSE : TRUE;
+		if (!suspended)
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+	}
+
+	curr_ctl = read_phy_reg(pi, 0xb0) & (0x7 << 0);
+
+	new_ctl = (curr_ctl & (~mask)) | (val & mask);
+
+	mod_phy_reg(pi, 0xb0, (0x7 << 0), new_ctl);
+
+	if (D11REV_IS(pi->sh->corerev, 16) && !suspended)
+		wlapi_enable_mac(pi->sh->physhim);
+
+	return new_ctl;
+}
+
+static void wlc_phy_clip_det_nphy(phy_info_t * pi, uint8 write, uint16 * vals)
+{
+
+	if (write == 0) {
+		vals[0] = read_phy_reg(pi, 0x2c);
+		vals[1] = read_phy_reg(pi, 0x42);
+	} else {
+		write_phy_reg(pi, 0x2c, vals[0]);
+		write_phy_reg(pi, 0x42, vals[1]);
+	}
+}
+
+void wlc_phy_force_rfseq_nphy(phy_info_t * pi, uint8 cmd)
+{
+	uint16 trigger_mask, status_mask;
+	uint16 orig_RfseqCoreActv;
+
+	switch (cmd) {
+	case NPHY_RFSEQ_RX2TX:
+		trigger_mask = NPHY_RfseqTrigger_rx2tx;
+		status_mask = NPHY_RfseqStatus_rx2tx;
+		break;
+	case NPHY_RFSEQ_TX2RX:
+		trigger_mask = NPHY_RfseqTrigger_tx2rx;
+		status_mask = NPHY_RfseqStatus_tx2rx;
+		break;
+	case NPHY_RFSEQ_RESET2RX:
+		trigger_mask = NPHY_RfseqTrigger_reset2rx;
+		status_mask = NPHY_RfseqStatus_reset2rx;
+		break;
+	case NPHY_RFSEQ_UPDATEGAINH:
+		trigger_mask = NPHY_RfseqTrigger_updategainh;
+		status_mask = NPHY_RfseqStatus_updategainh;
+		break;
+	case NPHY_RFSEQ_UPDATEGAINL:
+		trigger_mask = NPHY_RfseqTrigger_updategainl;
+		status_mask = NPHY_RfseqStatus_updategainl;
+		break;
+	case NPHY_RFSEQ_UPDATEGAINU:
+		trigger_mask = NPHY_RfseqTrigger_updategainu;
+		status_mask = NPHY_RfseqStatus_updategainu;
+		break;
+	default:
+		return;
+	}
+
+	orig_RfseqCoreActv = read_phy_reg(pi, 0xa1);
+	or_phy_reg(pi, 0xa1,
+		   (NPHY_RfseqMode_CoreActv_override |
+		    NPHY_RfseqMode_Trigger_override));
+	or_phy_reg(pi, 0xa3, trigger_mask);
+	SPINWAIT((read_phy_reg(pi, 0xa4) & status_mask), 200000);
+	write_phy_reg(pi, 0xa1, orig_RfseqCoreActv);
+
+	ASSERT((read_phy_reg(pi, 0xa4) & status_mask) == 0);
+}
+
+static void
+wlc_phy_set_rfseq_nphy(phy_info_t * pi, uint8 cmd, uint8 * events, uint8 * dlys,
+		       uint8 len)
+{
+	uint32 t1_offset, t2_offset;
+	uint8 ctr;
+	uint8 end_event =
+	    NREV_GE(pi->pubpi.phy_rev,
+		    3) ? NPHY_REV3_RFSEQ_CMD_END : NPHY_RFSEQ_CMD_END;
+	uint8 end_dly = 1;
+
+	ASSERT(len <= 16);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	t1_offset = cmd << 4;
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, len, t1_offset, 8,
+				 events);
+	t2_offset = t1_offset + 0x080;
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, len, t2_offset, 8,
+				 dlys);
+
+	for (ctr = len; ctr < 16; ctr++) {
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 1,
+					 t1_offset + ctr, 8, &end_event);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 1,
+					 t2_offset + ctr, 8, &end_dly);
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static uint16 wlc_phy_read_lpf_bw_ctl_nphy(phy_info_t * pi, uint16 offset)
+{
+	uint16 lpf_bw_ctl_val = 0;
+	uint16 rx2tx_lpf_rc_lut_offset = 0;
+
+	if (offset == 0) {
+		if (CHSPEC_IS40(pi->radio_chanspec)) {
+			rx2tx_lpf_rc_lut_offset = 0x159;
+		} else {
+			rx2tx_lpf_rc_lut_offset = 0x154;
+		}
+	} else {
+		rx2tx_lpf_rc_lut_offset = offset;
+	}
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 1,
+				(uint32) rx2tx_lpf_rc_lut_offset, 16,
+				&lpf_bw_ctl_val);
+
+	lpf_bw_ctl_val = lpf_bw_ctl_val & 0x7;
+
+	return lpf_bw_ctl_val;
+}
+
+static void
+wlc_phy_rfctrl_override_nphy_rev7(phy_info_t * pi, uint16 field, uint16 value,
+				  uint8 core_mask, uint8 off, uint8 override_id)
+{
+	uint8 core_num;
+	uint16 addr = 0, en_addr = 0, val_addr = 0, en_mask = 0, val_mask = 0;
+	uint8 val_shift = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		en_mask = field;
+		for (core_num = 0; core_num < 2; core_num++) {
+			if (override_id == NPHY_REV7_RFCTRLOVERRIDE_ID0) {
+
+				switch (field) {
+				case (0x1 << 2):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7a :
+					    0x7d;
+					val_mask = (0x1 << 1);
+					val_shift = 1;
+					break;
+				case (0x1 << 3):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7a :
+					    0x7d;
+					val_mask = (0x1 << 2);
+					val_shift = 2;
+					break;
+				case (0x1 << 4):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7a :
+					    0x7d;
+					val_mask = (0x1 << 4);
+					val_shift = 4;
+					break;
+				case (0x1 << 5):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7a :
+					    0x7d;
+					val_mask = (0x1 << 5);
+					val_shift = 5;
+					break;
+				case (0x1 << 6):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7a :
+					    0x7d;
+					val_mask = (0x1 << 6);
+					val_shift = 6;
+					break;
+				case (0x1 << 7):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7a :
+					    0x7d;
+					val_mask = (0x1 << 7);
+					val_shift = 7;
+					break;
+				case (0x1 << 10):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0xf8 :
+					    0xfa;
+					val_mask = (0x7 << 4);
+					val_shift = 4;
+					break;
+				case (0x1 << 11):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7b :
+					    0x7e;
+					val_mask = (0xffff << 0);
+					val_shift = 0;
+					break;
+				case (0x1 << 12):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x7c :
+					    0x7f;
+					val_mask = (0xffff << 0);
+					val_shift = 0;
+					break;
+				case (0x3 << 13):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x348 :
+					    0x349;
+					val_mask = (0xff << 0);
+					val_shift = 0;
+					break;
+				case (0x1 << 13):
+					en_addr = (core_num == 0) ? 0xe7 : 0xec;
+					val_addr = (core_num == 0) ? 0x348 :
+					    0x349;
+					val_mask = (0xf << 0);
+					val_shift = 0;
+					break;
+				default:
+					addr = 0xffff;
+					break;
+				}
+			} else if (override_id == NPHY_REV7_RFCTRLOVERRIDE_ID1) {
+
+				switch (field) {
+				case (0x1 << 1):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 1);
+					val_shift = 1;
+					break;
+				case (0x1 << 3):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 3);
+					val_shift = 3;
+					break;
+				case (0x1 << 5):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 5);
+					val_shift = 5;
+					break;
+				case (0x1 << 4):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 4);
+					val_shift = 4;
+					break;
+				case (0x1 << 2):
+
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 2);
+					val_shift = 2;
+					break;
+				case (0x1 << 7):
+
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x7 << 8);
+					val_shift = 8;
+					break;
+				case (0x1 << 11):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 14);
+					val_shift = 14;
+					break;
+				case (0x1 << 10):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 13);
+					val_shift = 13;
+					break;
+				case (0x1 << 9):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 12);
+					val_shift = 12;
+					break;
+				case (0x1 << 8):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 11);
+					val_shift = 11;
+					break;
+				case (0x1 << 6):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 6);
+					val_shift = 6;
+					break;
+				case (0x1 << 0):
+					en_addr = (core_num == 0) ? 0x342 :
+					    0x343;
+					val_addr = (core_num == 0) ? 0x340 :
+					    0x341;
+					val_mask = (0x1 << 0);
+					val_shift = 0;
+					break;
+				default:
+					addr = 0xffff;
+					break;
+				}
+			} else if (override_id == NPHY_REV7_RFCTRLOVERRIDE_ID2) {
+
+				switch (field) {
+				case (0x1 << 3):
+					en_addr = (core_num == 0) ? 0x346 :
+					    0x347;
+					val_addr = (core_num == 0) ? 0x344 :
+					    0x345;
+					val_mask = (0x1 << 3);
+					val_shift = 3;
+					break;
+				case (0x1 << 1):
+					en_addr = (core_num == 0) ? 0x346 :
+					    0x347;
+					val_addr = (core_num == 0) ? 0x344 :
+					    0x345;
+					val_mask = (0x1 << 1);
+					val_shift = 1;
+					break;
+				case (0x1 << 0):
+					en_addr = (core_num == 0) ? 0x346 :
+					    0x347;
+					val_addr = (core_num == 0) ? 0x344 :
+					    0x345;
+					val_mask = (0x1 << 0);
+					val_shift = 0;
+					break;
+				case (0x1 << 2):
+					en_addr = (core_num == 0) ? 0x346 :
+					    0x347;
+					val_addr = (core_num == 0) ? 0x344 :
+					    0x345;
+					val_mask = (0x1 << 2);
+					val_shift = 2;
+					break;
+				case (0x1 << 4):
+					en_addr = (core_num == 0) ? 0x346 :
+					    0x347;
+					val_addr = (core_num == 0) ? 0x344 :
+					    0x345;
+					val_mask = (0x1 << 4);
+					val_shift = 4;
+					break;
+				default:
+					addr = 0xffff;
+					break;
+				}
+			}
+
+			if (off) {
+				and_phy_reg(pi, en_addr, ~en_mask);
+				and_phy_reg(pi, val_addr, ~val_mask);
+			} else {
+
+				if ((core_mask == 0)
+				    || (core_mask & (1 << core_num))) {
+					or_phy_reg(pi, en_addr, en_mask);
+
+					if (addr != 0xffff) {
+						mod_phy_reg(pi, val_addr,
+							    val_mask,
+							    (value <<
+							     val_shift));
+					}
+				}
+			}
+		}
+	}
+}
+
+static void
+wlc_phy_rfctrl_override_nphy(phy_info_t * pi, uint16 field, uint16 value,
+			     uint8 core_mask, uint8 off)
+{
+	uint8 core_num;
+	uint16 addr = 0, mask = 0, en_addr = 0, val_addr = 0, en_mask =
+	    0, val_mask = 0;
+	uint8 shift = 0, val_shift = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LT(pi->pubpi.phy_rev, 7)) {
+
+		en_mask = field;
+		for (core_num = 0; core_num < 2; core_num++) {
+
+			switch (field) {
+			case (0x1 << 1):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x1 << 0);
+				val_shift = 0;
+				break;
+			case (0x1 << 2):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x1 << 1);
+				val_shift = 1;
+				break;
+			case (0x1 << 3):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x1 << 2);
+				val_shift = 2;
+				break;
+			case (0x1 << 4):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x1 << 4);
+				val_shift = 4;
+				break;
+			case (0x1 << 5):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x1 << 5);
+				val_shift = 5;
+				break;
+			case (0x1 << 6):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x1 << 6);
+				val_shift = 6;
+				break;
+			case (0x1 << 7):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x1 << 7);
+				val_shift = 7;
+				break;
+			case (0x1 << 8):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x7 << 8);
+				val_shift = 8;
+				break;
+			case (0x1 << 11):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7a : 0x7d;
+				val_mask = (0x7 << 13);
+				val_shift = 13;
+				break;
+
+			case (0x1 << 9):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0xf8 : 0xfa;
+				val_mask = (0x7 << 0);
+				val_shift = 0;
+				break;
+
+			case (0x1 << 10):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0xf8 : 0xfa;
+				val_mask = (0x7 << 4);
+				val_shift = 4;
+				break;
+
+			case (0x1 << 12):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7b : 0x7e;
+				val_mask = (0xffff << 0);
+				val_shift = 0;
+				break;
+			case (0x1 << 13):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0x7c : 0x7f;
+				val_mask = (0xffff << 0);
+				val_shift = 0;
+				break;
+			case (0x1 << 14):
+				en_addr = (core_num == 0) ? 0xe7 : 0xec;
+				val_addr = (core_num == 0) ? 0xf9 : 0xfb;
+				val_mask = (0x3 << 6);
+				val_shift = 6;
+				break;
+			case (0x1 << 0):
+				en_addr = (core_num == 0) ? 0xe5 : 0xe6;
+				val_addr = (core_num == 0) ? 0xf9 : 0xfb;
+				val_mask = (0x1 << 15);
+				val_shift = 15;
+				break;
+			default:
+				addr = 0xffff;
+				break;
+			}
+
+			if (off) {
+				and_phy_reg(pi, en_addr, ~en_mask);
+				and_phy_reg(pi, val_addr, ~val_mask);
+			} else {
+
+				if ((core_mask == 0)
+				    || (core_mask & (1 << core_num))) {
+					or_phy_reg(pi, en_addr, en_mask);
+
+					if (addr != 0xffff) {
+						mod_phy_reg(pi, val_addr,
+							    val_mask,
+							    (value <<
+							     val_shift));
+					}
+				}
+			}
+		}
+	} else {
+
+		if (off) {
+			and_phy_reg(pi, 0xec, ~field);
+			value = 0x0;
+		} else {
+			or_phy_reg(pi, 0xec, field);
+		}
+
+		for (core_num = 0; core_num < 2; core_num++) {
+
+			switch (field) {
+			case (0x1 << 1):
+			case (0x1 << 9):
+			case (0x1 << 12):
+			case (0x1 << 13):
+			case (0x1 << 14):
+				addr = 0x78;
+
+				core_mask = 0x1;
+				break;
+			case (0x1 << 2):
+			case (0x1 << 3):
+			case (0x1 << 4):
+			case (0x1 << 5):
+			case (0x1 << 6):
+			case (0x1 << 7):
+			case (0x1 << 8):
+				addr = (core_num == 0) ? 0x7a : 0x7d;
+				break;
+			case (0x1 << 10):
+				addr = (core_num == 0) ? 0x7b : 0x7e;
+				break;
+			case (0x1 << 11):
+				addr = (core_num == 0) ? 0x7c : 0x7f;
+				break;
+			default:
+				addr = 0xffff;
+			}
+
+			switch (field) {
+			case (0x1 << 1):
+				mask = (0x7 << 3);
+				shift = 3;
+				break;
+			case (0x1 << 9):
+				mask = (0x1 << 2);
+				shift = 2;
+				break;
+			case (0x1 << 12):
+				mask = (0x1 << 8);
+				shift = 8;
+				break;
+			case (0x1 << 13):
+				mask = (0x1 << 9);
+				shift = 9;
+				break;
+			case (0x1 << 14):
+				mask = (0xf << 12);
+				shift = 12;
+				break;
+			case (0x1 << 2):
+				mask = (0x1 << 0);
+				shift = 0;
+				break;
+			case (0x1 << 3):
+				mask = (0x1 << 1);
+				shift = 1;
+				break;
+			case (0x1 << 4):
+				mask = (0x1 << 2);
+				shift = 2;
+				break;
+			case (0x1 << 5):
+				mask = (0x3 << 4);
+				shift = 4;
+				break;
+			case (0x1 << 6):
+				mask = (0x3 << 6);
+				shift = 6;
+				break;
+			case (0x1 << 7):
+				mask = (0x1 << 8);
+				shift = 8;
+				break;
+			case (0x1 << 8):
+				mask = (0x1 << 9);
+				shift = 9;
+				break;
+			case (0x1 << 10):
+				mask = 0x1fff;
+				shift = 0x0;
+				break;
+			case (0x1 << 11):
+				mask = 0x1fff;
+				shift = 0x0;
+				break;
+			default:
+				mask = 0x0;
+				shift = 0x0;
+				break;
+			}
+
+			if ((addr != 0xffff) && (core_mask & (1 << core_num))) {
+				mod_phy_reg(pi, addr, mask, (value << shift));
+			}
+		}
+
+		or_phy_reg(pi, 0xec, (0x1 << 0));
+		or_phy_reg(pi, 0x78, (0x1 << 0));
+		OSL_DELAY(1);
+		and_phy_reg(pi, 0xec, ~(0x1 << 0));
+	}
+}
+
+static void
+wlc_phy_rfctrl_override_1tomany_nphy(phy_info_t * pi, uint16 cmd, uint16 value,
+				     uint8 core_mask, uint8 off)
+{
+	uint16 rfmxgain = 0, lpfgain = 0;
+	uint16 tgain = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		switch (cmd) {
+		case NPHY_REV7_RfctrlOverride_cmd_rxrf_pu:
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 5),
+							  value, core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 4), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			break;
+		case NPHY_REV7_RfctrlOverride_cmd_rx_pu:
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2),
+							  value, core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 0), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 11), 0,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			break;
+		case NPHY_REV7_RfctrlOverride_cmd_tx_pu:
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2),
+							  value, core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 0), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2), value,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 11), 1,
+							  core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			break;
+		case NPHY_REV7_RfctrlOverride_cmd_rxgain:
+			rfmxgain = value & 0x000ff;
+			lpfgain = value & 0x0ff00;
+			lpfgain = lpfgain >> 8;
+
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 11),
+							  rfmxgain, core_mask,
+							  off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x3 << 13),
+							  lpfgain, core_mask,
+							  off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			break;
+		case NPHY_REV7_RfctrlOverride_cmd_txgain:
+			tgain = value & 0x7fff;
+			lpfgain = value & 0x8000;
+			lpfgain = lpfgain >> 14;
+
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 12),
+							  tgain, core_mask, off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 13),
+							  lpfgain, core_mask,
+							  off,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			break;
+		}
+	}
+}
+
+static void
+wlc_phy_scale_offset_rssi_nphy(phy_info_t * pi, uint16 scale, int8 offset,
+			       uint8 coresel, uint8 rail, uint8 rssi_type)
+{
+	uint16 valuetostuff;
+
+	offset = (offset > NPHY_RSSICAL_MAXREAD) ?
+	    NPHY_RSSICAL_MAXREAD : offset;
+	offset = (offset < (-NPHY_RSSICAL_MAXREAD - 1)) ?
+	    -NPHY_RSSICAL_MAXREAD - 1 : offset;
+
+	valuetostuff = ((scale & 0x3f) << 8) | (offset & 0x3f);
+
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_NB)) {
+		write_phy_reg(pi, 0x1a6, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_NB)) {
+		write_phy_reg(pi, 0x1ac, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_NB)) {
+		write_phy_reg(pi, 0x1b2, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_NB)) {
+		write_phy_reg(pi, 0x1b8, valuetostuff);
+	}
+
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_W1)) {
+		write_phy_reg(pi, 0x1a4, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_W1)) {
+		write_phy_reg(pi, 0x1aa, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_W1)) {
+		write_phy_reg(pi, 0x1b0, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_W1)) {
+		write_phy_reg(pi, 0x1b6, valuetostuff);
+	}
+
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_W2)) {
+		write_phy_reg(pi, 0x1a5, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_W2)) {
+		write_phy_reg(pi, 0x1ab, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_W2)) {
+		write_phy_reg(pi, 0x1b1, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_W2)) {
+		write_phy_reg(pi, 0x1b7, valuetostuff);
+	}
+
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_TBD)) {
+		write_phy_reg(pi, 0x1a7, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_TBD)) {
+		write_phy_reg(pi, 0x1ad, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_TBD)) {
+		write_phy_reg(pi, 0x1b3, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_TBD)) {
+		write_phy_reg(pi, 0x1b9, valuetostuff);
+	}
+
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_IQ)) {
+		write_phy_reg(pi, 0x1a8, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_IQ)) {
+		write_phy_reg(pi, 0x1ae, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_I) && (rssi_type == NPHY_RSSI_SEL_IQ)) {
+		write_phy_reg(pi, 0x1b4, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rail == NPHY_RAIL_Q) && (rssi_type == NPHY_RSSI_SEL_IQ)) {
+		write_phy_reg(pi, 0x1ba, valuetostuff);
+	}
+
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rssi_type == NPHY_RSSI_SEL_TSSI_2G)) {
+		write_phy_reg(pi, 0x1a9, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rssi_type == NPHY_RSSI_SEL_TSSI_2G)) {
+		write_phy_reg(pi, 0x1b5, valuetostuff);
+	}
+
+	if (((coresel == RADIO_MIMO_CORESEL_CORE1) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rssi_type == NPHY_RSSI_SEL_TSSI_5G)) {
+		write_phy_reg(pi, 0x1af, valuetostuff);
+	}
+	if (((coresel == RADIO_MIMO_CORESEL_CORE2) ||
+	     (coresel == RADIO_MIMO_CORESEL_ALLRX)) &&
+	    (rssi_type == NPHY_RSSI_SEL_TSSI_5G)) {
+		write_phy_reg(pi, 0x1bb, valuetostuff);
+	}
+}
+
+void wlc_phy_rssisel_nphy(phy_info_t * pi, uint8 core_code, uint8 rssi_type)
+{
+	uint16 mask, val;
+	uint16 afectrlovr_rssi_val, rfctrlcmd_rxen_val, rfctrlcmd_coresel_val,
+	    startseq;
+	uint16 rfctrlovr_rssi_val, rfctrlovr_rxen_val, rfctrlovr_coresel_val,
+	    rfctrlovr_trigger_val;
+	uint16 afectrlovr_rssi_mask, rfctrlcmd_mask, rfctrlovr_mask;
+	uint16 rfctrlcmd_val, rfctrlovr_val;
+	uint8 core;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if (core_code == RADIO_MIMO_CORESEL_OFF) {
+			mod_phy_reg(pi, 0x8f, (0x1 << 9), 0);
+			mod_phy_reg(pi, 0xa5, (0x1 << 9), 0);
+
+			mod_phy_reg(pi, 0xa6, (0x3 << 8), 0);
+			mod_phy_reg(pi, 0xa7, (0x3 << 8), 0);
+
+			mod_phy_reg(pi, 0xe5, (0x1 << 5), 0);
+			mod_phy_reg(pi, 0xe6, (0x1 << 5), 0);
+
+			mask = (0x1 << 2) |
+			    (0x1 << 3) | (0x1 << 4) | (0x1 << 5);
+			mod_phy_reg(pi, 0xf9, mask, 0);
+			mod_phy_reg(pi, 0xfb, mask, 0);
+
+		} else {
+			for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+				if (core_code == RADIO_MIMO_CORESEL_CORE1
+				    && core == PHY_CORE_1)
+					continue;
+				else if (core_code == RADIO_MIMO_CORESEL_CORE2
+					 && core == PHY_CORE_0)
+					continue;
+
+				mod_phy_reg(pi, (core == PHY_CORE_0) ?
+					    0x8f : 0xa5, (0x1 << 9), 1 << 9);
+
+				if (rssi_type == NPHY_RSSI_SEL_W1 ||
+				    rssi_type == NPHY_RSSI_SEL_W2 ||
+				    rssi_type == NPHY_RSSI_SEL_NB) {
+
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0xa6 : 0xa7,
+						    (0x3 << 8), 0);
+
+					mask = (0x1 << 2) |
+					    (0x1 << 3) |
+					    (0x1 << 4) | (0x1 << 5);
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0xf9 : 0xfb,
+						    mask, 0);
+
+					if (rssi_type == NPHY_RSSI_SEL_W1) {
+						if (CHSPEC_IS5G
+						    (pi->radio_chanspec)) {
+							mask = (0x1 << 2);
+							val = 1 << 2;
+						} else {
+							mask = (0x1 << 3);
+							val = 1 << 3;
+						}
+					} else if (rssi_type ==
+						   NPHY_RSSI_SEL_W2) {
+						mask = (0x1 << 4);
+						val = 1 << 4;
+					} else {
+						mask = (0x1 << 5);
+						val = 1 << 5;
+					}
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0xf9 : 0xfb,
+						    mask, val);
+
+					mask = (0x1 << 5);
+					val = 1 << 5;
+					mod_phy_reg(pi, (core == PHY_CORE_0) ?
+						    0xe5 : 0xe6, mask, val);
+				} else {
+					if (rssi_type == NPHY_RSSI_SEL_TBD) {
+
+						mask = (0x3 << 8);
+						val = 1 << 8;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0xa6
+							    : 0xa7, mask, val);
+						mask = (0x3 << 10);
+						val = 1 << 10;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0xa6
+							    : 0xa7, mask, val);
+					} else if (rssi_type ==
+						   NPHY_RSSI_SEL_IQ) {
+
+						mask = (0x3 << 8);
+						val = 2 << 8;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0xa6
+							    : 0xa7, mask, val);
+						mask = (0x3 << 10);
+						val = 2 << 10;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0xa6
+							    : 0xa7, mask, val);
+					} else {
+
+						mask = (0x3 << 8);
+						val = 3 << 8;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0xa6
+							    : 0xa7, mask, val);
+						mask = (0x3 << 10);
+						val = 3 << 10;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0xa6
+							    : 0xa7, mask, val);
+
+						if (PHY_IPA(pi)) {
+							if (NREV_GE
+							    (pi->pubpi.phy_rev,
+							     7)) {
+
+								write_radio_reg
+								    (pi,
+								     ((core ==
+								       PHY_CORE_0)
+								      ?
+								      RADIO_2057_TX0_TX_SSI_MUX
+								      :
+								      RADIO_2057_TX1_TX_SSI_MUX),
+								     (CHSPEC_IS5G
+								      (pi->
+								       radio_chanspec)
+								      ? 0xc :
+								      0xe));
+							} else {
+								write_radio_reg
+								    (pi,
+								     RADIO_2056_TX_TX_SSI_MUX
+								     |
+								     ((core ==
+								       PHY_CORE_0)
+								      ?
+								      RADIO_2056_TX0
+								      :
+								      RADIO_2056_TX1),
+								     (CHSPEC_IS5G
+								      (pi->
+								       radio_chanspec)
+								      ? 0xc :
+								      0xe));
+							}
+						} else {
+
+							if (NREV_GE
+							    (pi->pubpi.phy_rev,
+							     7)) {
+								write_radio_reg
+								    (pi,
+								     ((core ==
+								       PHY_CORE_0)
+								      ?
+								      RADIO_2057_TX0_TX_SSI_MUX
+								      :
+								      RADIO_2057_TX1_TX_SSI_MUX),
+								     0x11);
+
+								if (pi->pubpi.
+								    radioid ==
+								    BCM2057_ID)
+									write_radio_reg
+									    (pi,
+									     RADIO_2057_IQTEST_SEL_PU,
+									     0x1);
+
+							} else {
+								write_radio_reg
+								    (pi,
+								     RADIO_2056_TX_TX_SSI_MUX
+								     |
+								     ((core ==
+								       PHY_CORE_0)
+								      ?
+								      RADIO_2056_TX0
+								      :
+								      RADIO_2056_TX1),
+								     0x11);
+							}
+						}
+
+						afectrlovr_rssi_val = 1 << 9;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x8f
+							    : 0xa5, (0x1 << 9),
+							    afectrlovr_rssi_val);
+					}
+				}
+			}
+		}
+	} else {
+
+		if ((rssi_type == NPHY_RSSI_SEL_W1) ||
+		    (rssi_type == NPHY_RSSI_SEL_W2) ||
+		    (rssi_type == NPHY_RSSI_SEL_NB)) {
+
+			val = 0x0;
+		} else if (rssi_type == NPHY_RSSI_SEL_TBD) {
+
+			val = 0x1;
+		} else if (rssi_type == NPHY_RSSI_SEL_IQ) {
+
+			val = 0x2;
+		} else {
+
+			val = 0x3;
+		}
+		mask = ((0x3 << 12) | (0x3 << 14));
+		val = (val << 12) | (val << 14);
+		mod_phy_reg(pi, 0xa6, mask, val);
+		mod_phy_reg(pi, 0xa7, mask, val);
+
+		if ((rssi_type == NPHY_RSSI_SEL_W1) ||
+		    (rssi_type == NPHY_RSSI_SEL_W2) ||
+		    (rssi_type == NPHY_RSSI_SEL_NB)) {
+			if (rssi_type == NPHY_RSSI_SEL_W1) {
+				val = 0x1;
+			}
+			if (rssi_type == NPHY_RSSI_SEL_W2) {
+				val = 0x2;
+			}
+			if (rssi_type == NPHY_RSSI_SEL_NB) {
+				val = 0x3;
+			}
+			mask = (0x3 << 4);
+			val = (val << 4);
+			mod_phy_reg(pi, 0x7a, mask, val);
+			mod_phy_reg(pi, 0x7d, mask, val);
+		}
+
+		if (core_code == RADIO_MIMO_CORESEL_OFF) {
+			afectrlovr_rssi_val = 0;
+			rfctrlcmd_rxen_val = 0;
+			rfctrlcmd_coresel_val = 0;
+			rfctrlovr_rssi_val = 0;
+			rfctrlovr_rxen_val = 0;
+			rfctrlovr_coresel_val = 0;
+			rfctrlovr_trigger_val = 0;
+			startseq = 0;
+		} else {
+			afectrlovr_rssi_val = 1;
+			rfctrlcmd_rxen_val = 1;
+			rfctrlcmd_coresel_val = core_code;
+			rfctrlovr_rssi_val = 1;
+			rfctrlovr_rxen_val = 1;
+			rfctrlovr_coresel_val = 1;
+			rfctrlovr_trigger_val = 1;
+			startseq = 1;
+		}
+
+		afectrlovr_rssi_mask = ((0x1 << 12) | (0x1 << 13));
+		afectrlovr_rssi_val = (afectrlovr_rssi_val <<
+				       12) | (afectrlovr_rssi_val << 13);
+		mod_phy_reg(pi, 0xa5, afectrlovr_rssi_mask,
+			    afectrlovr_rssi_val);
+
+		if ((rssi_type == NPHY_RSSI_SEL_W1) ||
+		    (rssi_type == NPHY_RSSI_SEL_W2) ||
+		    (rssi_type == NPHY_RSSI_SEL_NB)) {
+			rfctrlcmd_mask = ((0x1 << 8) | (0x7 << 3));
+			rfctrlcmd_val = (rfctrlcmd_rxen_val << 8) |
+			    (rfctrlcmd_coresel_val << 3);
+
+			rfctrlovr_mask = ((0x1 << 5) |
+					  (0x1 << 12) |
+					  (0x1 << 1) | (0x1 << 0));
+			rfctrlovr_val = (rfctrlovr_rssi_val <<
+					 5) |
+			    (rfctrlovr_rxen_val << 12) |
+			    (rfctrlovr_coresel_val << 1) |
+			    (rfctrlovr_trigger_val << 0);
+
+			mod_phy_reg(pi, 0x78, rfctrlcmd_mask, rfctrlcmd_val);
+			mod_phy_reg(pi, 0xec, rfctrlovr_mask, rfctrlovr_val);
+
+			mod_phy_reg(pi, 0x78, (0x1 << 0), (startseq << 0));
+			OSL_DELAY(20);
+
+			mod_phy_reg(pi, 0xec, (0x1 << 0), 0);
+		}
+	}
+}
+
+int
+wlc_phy_poll_rssi_nphy(phy_info_t * pi, uint8 rssi_type, int32 * rssi_buf,
+		       uint8 nsamps)
+{
+	int16 rssi0, rssi1;
+	uint16 afectrlCore1_save = 0;
+	uint16 afectrlCore2_save = 0;
+	uint16 afectrlOverride1_save = 0;
+	uint16 afectrlOverride2_save = 0;
+	uint16 rfctrlOverrideAux0_save = 0;
+	uint16 rfctrlOverrideAux1_save = 0;
+	uint16 rfctrlMiscReg1_save = 0;
+	uint16 rfctrlMiscReg2_save = 0;
+	uint16 rfctrlcmd_save = 0;
+	uint16 rfctrloverride_save = 0;
+	uint16 rfctrlrssiothers1_save = 0;
+	uint16 rfctrlrssiothers2_save = 0;
+	int8 tmp_buf[4];
+	uint8 ctr = 0, samp = 0;
+	int32 rssi_out_val;
+	uint16 gpiosel_orig;
+
+	afectrlCore1_save = read_phy_reg(pi, 0xa6);
+	afectrlCore2_save = read_phy_reg(pi, 0xa7);
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		rfctrlMiscReg1_save = read_phy_reg(pi, 0xf9);
+		rfctrlMiscReg2_save = read_phy_reg(pi, 0xfb);
+		afectrlOverride1_save = read_phy_reg(pi, 0x8f);
+		afectrlOverride2_save = read_phy_reg(pi, 0xa5);
+		rfctrlOverrideAux0_save = read_phy_reg(pi, 0xe5);
+		rfctrlOverrideAux1_save = read_phy_reg(pi, 0xe6);
+	} else {
+		afectrlOverride1_save = read_phy_reg(pi, 0xa5);
+		rfctrlcmd_save = read_phy_reg(pi, 0x78);
+		rfctrloverride_save = read_phy_reg(pi, 0xec);
+		rfctrlrssiothers1_save = read_phy_reg(pi, 0x7a);
+		rfctrlrssiothers2_save = read_phy_reg(pi, 0x7d);
+	}
+
+	wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_ALLRX, rssi_type);
+
+	gpiosel_orig = read_phy_reg(pi, 0xca);
+	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+		write_phy_reg(pi, 0xca, 5);
+	}
+
+	for (ctr = 0; ctr < 4; ctr++) {
+		rssi_buf[ctr] = 0;
+	}
+
+	for (samp = 0; samp < nsamps; samp++) {
+		if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+			rssi0 = read_phy_reg(pi, 0x1c9);
+			rssi1 = read_phy_reg(pi, 0x1ca);
+		} else {
+			rssi0 = read_phy_reg(pi, 0x219);
+			rssi1 = read_phy_reg(pi, 0x21a);
+		}
+
+		ctr = 0;
+		tmp_buf[ctr++] = ((int8) ((rssi0 & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((int8) (((rssi0 >> 8) & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((int8) ((rssi1 & 0x3f) << 2)) >> 2;
+		tmp_buf[ctr++] = ((int8) (((rssi1 >> 8) & 0x3f) << 2)) >> 2;
+
+		for (ctr = 0; ctr < 4; ctr++) {
+			rssi_buf[ctr] += tmp_buf[ctr];
+		}
+
+	}
+
+	rssi_out_val = rssi_buf[3] & 0xff;
+	rssi_out_val |= (rssi_buf[2] & 0xff) << 8;
+	rssi_out_val |= (rssi_buf[1] & 0xff) << 16;
+	rssi_out_val |= (rssi_buf[0] & 0xff) << 24;
+
+	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+		write_phy_reg(pi, 0xca, gpiosel_orig);
+	}
+
+	write_phy_reg(pi, 0xa6, afectrlCore1_save);
+	write_phy_reg(pi, 0xa7, afectrlCore2_save);
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		write_phy_reg(pi, 0xf9, rfctrlMiscReg1_save);
+		write_phy_reg(pi, 0xfb, rfctrlMiscReg2_save);
+		write_phy_reg(pi, 0x8f, afectrlOverride1_save);
+		write_phy_reg(pi, 0xa5, afectrlOverride2_save);
+		write_phy_reg(pi, 0xe5, rfctrlOverrideAux0_save);
+		write_phy_reg(pi, 0xe6, rfctrlOverrideAux1_save);
+	} else {
+		write_phy_reg(pi, 0xa5, afectrlOverride1_save);
+		write_phy_reg(pi, 0x78, rfctrlcmd_save);
+		write_phy_reg(pi, 0xec, rfctrloverride_save);
+		write_phy_reg(pi, 0x7a, rfctrlrssiothers1_save);
+		write_phy_reg(pi, 0x7d, rfctrlrssiothers2_save);
+	}
+
+	return (rssi_out_val);
+}
+
+int16 wlc_phy_tempsense_nphy(phy_info_t * pi)
+{
+	uint16 core1_txrf_iqcal1_save, core1_txrf_iqcal2_save;
+	uint16 core2_txrf_iqcal1_save, core2_txrf_iqcal2_save;
+	uint16 pwrdet_rxtx_core1_save;
+	uint16 pwrdet_rxtx_core2_save;
+	uint16 afectrlCore1_save;
+	uint16 afectrlCore2_save;
+	uint16 afectrlOverride_save;
+	uint16 afectrlOverride2_save;
+	uint16 pd_pll_ts_save;
+	uint16 gpioSel_save;
+	int32 radio_temp[4];
+	int32 radio_temp2[4];
+	uint16 syn_tempprocsense_save;
+	int16 offset = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		uint16 auxADC_Vmid, auxADC_Av, auxADC_Vmid_save, auxADC_Av_save;
+		uint16 auxADC_rssi_ctrlL_save, auxADC_rssi_ctrlH_save;
+		uint16 auxADC_rssi_ctrlL, auxADC_rssi_ctrlH;
+		int32 auxADC_Vl;
+		uint16 RfctrlOverride5_save, RfctrlOverride6_save;
+		uint16 RfctrlMiscReg5_save, RfctrlMiscReg6_save;
+		uint16 RSSIMultCoef0QPowerDet_save;
+		uint16 tempsense_Rcal;
+
+		syn_tempprocsense_save =
+		    read_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG);
+
+		afectrlCore1_save = read_phy_reg(pi, 0xa6);
+		afectrlCore2_save = read_phy_reg(pi, 0xa7);
+		afectrlOverride_save = read_phy_reg(pi, 0x8f);
+		afectrlOverride2_save = read_phy_reg(pi, 0xa5);
+		RSSIMultCoef0QPowerDet_save = read_phy_reg(pi, 0x1ae);
+		RfctrlOverride5_save = read_phy_reg(pi, 0x346);
+		RfctrlOverride6_save = read_phy_reg(pi, 0x347);
+		RfctrlMiscReg5_save = read_phy_reg(pi, 0x344);
+		RfctrlMiscReg6_save = read_phy_reg(pi, 0x345);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0A, 16,
+					&auxADC_Vmid_save);
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0E, 16,
+					&auxADC_Av_save);
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x02, 16,
+					&auxADC_rssi_ctrlL_save);
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x03, 16,
+					&auxADC_rssi_ctrlH_save);
+
+		write_phy_reg(pi, 0x1ae, 0x0);
+
+		auxADC_rssi_ctrlL = 0x0;
+		auxADC_rssi_ctrlH = 0x20;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x02, 16,
+					 &auxADC_rssi_ctrlL);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x03, 16,
+					 &auxADC_rssi_ctrlH);
+
+		tempsense_Rcal = syn_tempprocsense_save & 0x1c;
+
+		write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG,
+				tempsense_Rcal | 0x01);
+
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1),
+						  1, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+		mod_phy_reg(pi, 0xa6, (0x1 << 7), 0);
+		mod_phy_reg(pi, 0xa7, (0x1 << 7), 0);
+		mod_phy_reg(pi, 0x8f, (0x1 << 7), (0x1 << 7));
+		mod_phy_reg(pi, 0xa5, (0x1 << 7), (0x1 << 7));
+
+		mod_phy_reg(pi, 0xa6, (0x1 << 2), (0x1 << 2));
+		mod_phy_reg(pi, 0xa7, (0x1 << 2), (0x1 << 2));
+		mod_phy_reg(pi, 0x8f, (0x1 << 2), (0x1 << 2));
+		mod_phy_reg(pi, 0xa5, (0x1 << 2), (0x1 << 2));
+		OSL_DELAY(5);
+		mod_phy_reg(pi, 0xa6, (0x1 << 2), 0);
+		mod_phy_reg(pi, 0xa7, (0x1 << 2), 0);
+		mod_phy_reg(pi, 0xa6, (0x1 << 3), 0);
+		mod_phy_reg(pi, 0xa7, (0x1 << 3), 0);
+		mod_phy_reg(pi, 0x8f, (0x1 << 3), (0x1 << 3));
+		mod_phy_reg(pi, 0xa5, (0x1 << 3), (0x1 << 3));
+		mod_phy_reg(pi, 0xa6, (0x1 << 6), 0);
+		mod_phy_reg(pi, 0xa7, (0x1 << 6), 0);
+		mod_phy_reg(pi, 0x8f, (0x1 << 6), (0x1 << 6));
+		mod_phy_reg(pi, 0xa5, (0x1 << 6), (0x1 << 6));
+
+		auxADC_Vmid = 0xA3;
+		auxADC_Av = 0x0;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0A, 16,
+					 &auxADC_Vmid);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0E, 16,
+					 &auxADC_Av);
+
+		OSL_DELAY(3);
+
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp, 1);
+		write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG,
+				tempsense_Rcal | 0x03);
+
+		OSL_DELAY(5);
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp2, 1);
+
+		auxADC_Av = 0x7;
+		if (radio_temp[1] + radio_temp2[1] < -30) {
+			auxADC_Vmid = 0x45;
+			auxADC_Vl = 263;
+		} else if (radio_temp[1] + radio_temp2[1] < -9) {
+			auxADC_Vmid = 0x200;
+			auxADC_Vl = 467;
+		} else if (radio_temp[1] + radio_temp2[1] < 11) {
+			auxADC_Vmid = 0x266;
+			auxADC_Vl = 634;
+		} else {
+			auxADC_Vmid = 0x2D5;
+			auxADC_Vl = 816;
+		}
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0A, 16,
+					 &auxADC_Vmid);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0E, 16,
+					 &auxADC_Av);
+
+		OSL_DELAY(3);
+
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp2, 1);
+		write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG,
+				tempsense_Rcal | 0x01);
+
+		OSL_DELAY(5);
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp, 1);
+
+		write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG,
+				syn_tempprocsense_save);
+
+		write_phy_reg(pi, 0xa6, afectrlCore1_save);
+		write_phy_reg(pi, 0xa7, afectrlCore2_save);
+		write_phy_reg(pi, 0x8f, afectrlOverride_save);
+		write_phy_reg(pi, 0xa5, afectrlOverride2_save);
+		write_phy_reg(pi, 0x1ae, RSSIMultCoef0QPowerDet_save);
+		write_phy_reg(pi, 0x346, RfctrlOverride5_save);
+		write_phy_reg(pi, 0x347, RfctrlOverride6_save);
+		write_phy_reg(pi, 0x344, RfctrlMiscReg5_save);
+		write_phy_reg(pi, 0x345, RfctrlMiscReg5_save);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0A, 16,
+					 &auxADC_Vmid_save);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x0E, 16,
+					 &auxADC_Av_save);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x02, 16,
+					 &auxADC_rssi_ctrlL_save);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 0x03, 16,
+					 &auxADC_rssi_ctrlH_save);
+
+		if (CHIPID(pi->sh->chip) == BCM5357_CHIP_ID) {
+			radio_temp[0] = (193 * (radio_temp[1] + radio_temp2[1])
+					 + 88 * (auxADC_Vl) - 27111 +
+					 128) / 256;
+		} else if (CHIPID(pi->sh->chip) == BCM43236_CHIP_ID) {
+			radio_temp[0] = (198 * (radio_temp[1] + radio_temp2[1])
+					 + 91 * (auxADC_Vl) - 27243 +
+					 128) / 256;
+		} else {
+			radio_temp[0] = (179 * (radio_temp[1] + radio_temp2[1])
+					 + 82 * (auxADC_Vl) - 28861 +
+					 128) / 256;
+		}
+
+		offset = (int16) pi->phy_tempsense_offset;
+
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		syn_tempprocsense_save =
+		    read_radio_reg(pi, RADIO_2056_SYN_TEMPPROCSENSE);
+
+		afectrlCore1_save = read_phy_reg(pi, 0xa6);
+		afectrlCore2_save = read_phy_reg(pi, 0xa7);
+		afectrlOverride_save = read_phy_reg(pi, 0x8f);
+		afectrlOverride2_save = read_phy_reg(pi, 0xa5);
+		gpioSel_save = read_phy_reg(pi, 0xca);
+
+		write_radio_reg(pi, RADIO_2056_SYN_TEMPPROCSENSE, 0x01);
+
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp, 1);
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		} else {
+			write_radio_reg(pi, RADIO_2056_SYN_TEMPPROCSENSE, 0x05);
+		}
+
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp2, 1);
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			write_radio_reg(pi, RADIO_2057_TEMPSENSE_CONFIG, 0x01);
+		} else {
+			write_radio_reg(pi, RADIO_2056_SYN_TEMPPROCSENSE, 0x01);
+		}
+
+		radio_temp[0] =
+		    (126 * (radio_temp[1] + radio_temp2[1]) + 3987) / 64;
+
+		write_radio_reg(pi, RADIO_2056_SYN_TEMPPROCSENSE,
+				syn_tempprocsense_save);
+
+		write_phy_reg(pi, 0xca, gpioSel_save);
+		write_phy_reg(pi, 0xa6, afectrlCore1_save);
+		write_phy_reg(pi, 0xa7, afectrlCore2_save);
+		write_phy_reg(pi, 0x8f, afectrlOverride_save);
+		write_phy_reg(pi, 0xa5, afectrlOverride2_save);
+
+		offset = (int16) pi->phy_tempsense_offset;
+	} else {
+
+		pwrdet_rxtx_core1_save =
+		    read_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE1);
+		pwrdet_rxtx_core2_save =
+		    read_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE2);
+		core1_txrf_iqcal1_save =
+		    read_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL1);
+		core1_txrf_iqcal2_save =
+		    read_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL2);
+		core2_txrf_iqcal1_save =
+		    read_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL1);
+		core2_txrf_iqcal2_save =
+		    read_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL2);
+		pd_pll_ts_save = read_radio_reg(pi, RADIO_2055_PD_PLL_TS);
+
+		afectrlCore1_save = read_phy_reg(pi, 0xa6);
+		afectrlCore2_save = read_phy_reg(pi, 0xa7);
+		afectrlOverride_save = read_phy_reg(pi, 0xa5);
+		gpioSel_save = read_phy_reg(pi, 0xca);
+
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL1, 0x01);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL1, 0x01);
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL2, 0x08);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL2, 0x08);
+		write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE1, 0x04);
+		write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE2, 0x04);
+		write_radio_reg(pi, RADIO_2055_PD_PLL_TS, 0x00);
+
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp, 1);
+		xor_radio_reg(pi, RADIO_2055_CAL_TS, 0x80);
+
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp, 1);
+		xor_radio_reg(pi, RADIO_2055_CAL_TS, 0x80);
+
+		wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_IQ, radio_temp2, 1);
+		xor_radio_reg(pi, RADIO_2055_CAL_TS, 0x80);
+
+		radio_temp[0] = (radio_temp[0] + radio_temp2[0]);
+		radio_temp[1] = (radio_temp[1] + radio_temp2[1]);
+		radio_temp[2] = (radio_temp[2] + radio_temp2[2]);
+		radio_temp[3] = (radio_temp[3] + radio_temp2[3]);
+
+		radio_temp[0] =
+		    (radio_temp[0] + radio_temp[1] + radio_temp[2] +
+		     radio_temp[3]);
+
+		radio_temp[0] =
+		    (radio_temp[0] + (8 * 32)) * (950 - 350) / 63 + (350 * 8);
+
+		radio_temp[0] = (radio_temp[0] - (8 * 420)) / 38;
+
+		write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE1,
+				pwrdet_rxtx_core1_save);
+		write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE2,
+				pwrdet_rxtx_core2_save);
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL1,
+				core1_txrf_iqcal1_save);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL1,
+				core2_txrf_iqcal1_save);
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL2,
+				core1_txrf_iqcal2_save);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL2,
+				core2_txrf_iqcal2_save);
+		write_radio_reg(pi, RADIO_2055_PD_PLL_TS, pd_pll_ts_save);
+
+		write_phy_reg(pi, 0xca, gpioSel_save);
+		write_phy_reg(pi, 0xa6, afectrlCore1_save);
+		write_phy_reg(pi, 0xa7, afectrlCore2_save);
+		write_phy_reg(pi, 0xa5, afectrlOverride_save);
+	}
+
+	return ((int16) radio_temp[0] + offset);
+}
+
+static void
+wlc_phy_set_rssi_2055_vcm(phy_info_t * pi, uint8 rssi_type, uint8 * vcm_buf)
+{
+	uint8 core;
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+		if (rssi_type == NPHY_RSSI_SEL_NB) {
+			if (core == PHY_CORE_0) {
+				mod_radio_reg(pi,
+					      RADIO_2055_CORE1_B0_NBRSSI_VCM,
+					      RADIO_2055_NBRSSI_VCM_I_MASK,
+					      vcm_buf[2 *
+						      core] <<
+					      RADIO_2055_NBRSSI_VCM_I_SHIFT);
+				mod_radio_reg(pi,
+					      RADIO_2055_CORE1_RXBB_RSSI_CTRL5,
+					      RADIO_2055_NBRSSI_VCM_Q_MASK,
+					      vcm_buf[2 * core +
+						      1] <<
+					      RADIO_2055_NBRSSI_VCM_Q_SHIFT);
+			} else {
+				mod_radio_reg(pi,
+					      RADIO_2055_CORE2_B0_NBRSSI_VCM,
+					      RADIO_2055_NBRSSI_VCM_I_MASK,
+					      vcm_buf[2 *
+						      core] <<
+					      RADIO_2055_NBRSSI_VCM_I_SHIFT);
+				mod_radio_reg(pi,
+					      RADIO_2055_CORE2_RXBB_RSSI_CTRL5,
+					      RADIO_2055_NBRSSI_VCM_Q_MASK,
+					      vcm_buf[2 * core +
+						      1] <<
+					      RADIO_2055_NBRSSI_VCM_Q_SHIFT);
+			}
+		} else {
+
+			if (core == PHY_CORE_0) {
+				mod_radio_reg(pi,
+					      RADIO_2055_CORE1_RXBB_RSSI_CTRL5,
+					      RADIO_2055_WBRSSI_VCM_IQ_MASK,
+					      vcm_buf[2 *
+						      core] <<
+					      RADIO_2055_WBRSSI_VCM_IQ_SHIFT);
+			} else {
+				mod_radio_reg(pi,
+					      RADIO_2055_CORE2_RXBB_RSSI_CTRL5,
+					      RADIO_2055_WBRSSI_VCM_IQ_MASK,
+					      vcm_buf[2 *
+						      core] <<
+					      RADIO_2055_WBRSSI_VCM_IQ_SHIFT);
+			}
+		}
+	}
+}
+
+void wlc_phy_rssi_cal_nphy(phy_info_t * pi)
+{
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+		wlc_phy_rssi_cal_nphy_rev3(pi);
+	} else {
+		wlc_phy_rssi_cal_nphy_rev2(pi, NPHY_RSSI_SEL_NB);
+		wlc_phy_rssi_cal_nphy_rev2(pi, NPHY_RSSI_SEL_W1);
+		wlc_phy_rssi_cal_nphy_rev2(pi, NPHY_RSSI_SEL_W2);
+	}
+}
+
+static void wlc_phy_rssi_cal_nphy_rev2(phy_info_t * pi, uint8 rssi_type)
+{
+	int32 target_code;
+	uint16 classif_state;
+	uint16 clip_state[2];
+	uint16 rssi_ctrl_state[2], pd_state[2];
+	uint16 rfctrlintc_state[2], rfpdcorerxtx_state[2];
+	uint16 rfctrlintc_override_val;
+	uint16 clip_off[] = { 0xffff, 0xffff };
+	uint16 rf_pd_val, pd_mask, rssi_ctrl_mask;
+	uint8 vcm, min_vcm, vcm_tmp[4];
+	uint8 vcm_final[4] = { 0, 0, 0, 0 };
+	uint8 result_idx, ctr;
+	int32 poll_results[4][4] = {
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0}
+	};
+	int32 poll_miniq[4][2] = {
+		{0, 0},
+		{0, 0},
+		{0, 0},
+		{0, 0}
+	};
+	int32 min_d, curr_d;
+	int32 fine_digital_offset[4];
+	int32 poll_results_min[4] = { 0, 0, 0, 0 };
+	int32 min_poll;
+
+	switch (rssi_type) {
+	case NPHY_RSSI_SEL_NB:
+		target_code = NPHY_RSSICAL_NB_TARGET;
+		break;
+	case NPHY_RSSI_SEL_W1:
+		target_code = NPHY_RSSICAL_W1_TARGET;
+		break;
+	case NPHY_RSSI_SEL_W2:
+		target_code = NPHY_RSSICAL_W2_TARGET;
+		break;
+	default:
+		return;
+		break;
+	}
+
+	classif_state = wlc_phy_classifier_nphy(pi, 0, 0);
+	wlc_phy_classifier_nphy(pi, (0x7 << 0), 4);
+	wlc_phy_clip_det_nphy(pi, 0, clip_state);
+	wlc_phy_clip_det_nphy(pi, 1, clip_off);
+
+	rf_pd_val = (rssi_type == NPHY_RSSI_SEL_NB) ? 0x6 : 0x4;
+	rfctrlintc_override_val =
+	    CHSPEC_IS5G(pi->radio_chanspec) ? 0x140 : 0x110;
+
+	rfctrlintc_state[0] = read_phy_reg(pi, 0x91);
+	rfpdcorerxtx_state[0] = read_radio_reg(pi, RADIO_2055_PD_CORE1_RXTX);
+	write_phy_reg(pi, 0x91, rfctrlintc_override_val);
+	write_radio_reg(pi, RADIO_2055_PD_CORE1_RXTX, rf_pd_val);
+
+	rfctrlintc_state[1] = read_phy_reg(pi, 0x92);
+	rfpdcorerxtx_state[1] = read_radio_reg(pi, RADIO_2055_PD_CORE2_RXTX);
+	write_phy_reg(pi, 0x92, rfctrlintc_override_val);
+	write_radio_reg(pi, RADIO_2055_PD_CORE2_RXTX, rf_pd_val);
+
+	pd_mask = RADIO_2055_NBRSSI_PD | RADIO_2055_WBRSSI_G1_PD |
+	    RADIO_2055_WBRSSI_G2_PD;
+	pd_state[0] =
+	    read_radio_reg(pi, RADIO_2055_PD_CORE1_RSSI_MISC) & pd_mask;
+	pd_state[1] =
+	    read_radio_reg(pi, RADIO_2055_PD_CORE2_RSSI_MISC) & pd_mask;
+	mod_radio_reg(pi, RADIO_2055_PD_CORE1_RSSI_MISC, pd_mask, 0);
+	mod_radio_reg(pi, RADIO_2055_PD_CORE2_RSSI_MISC, pd_mask, 0);
+	rssi_ctrl_mask = RADIO_2055_NBRSSI_SEL | RADIO_2055_WBRSSI_G1_SEL |
+	    RADIO_2055_WBRSSI_G2_SEL;
+	rssi_ctrl_state[0] =
+	    read_radio_reg(pi, RADIO_2055_SP_RSSI_CORE1) & rssi_ctrl_mask;
+	rssi_ctrl_state[1] =
+	    read_radio_reg(pi, RADIO_2055_SP_RSSI_CORE2) & rssi_ctrl_mask;
+	wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_ALLRX, rssi_type);
+
+	wlc_phy_scale_offset_rssi_nphy(pi, 0x0, 0x0, RADIO_MIMO_CORESEL_ALLRX,
+				       NPHY_RAIL_I, rssi_type);
+	wlc_phy_scale_offset_rssi_nphy(pi, 0x0, 0x0, RADIO_MIMO_CORESEL_ALLRX,
+				       NPHY_RAIL_Q, rssi_type);
+
+	for (vcm = 0; vcm < 4; vcm++) {
+
+		vcm_tmp[0] = vcm_tmp[1] = vcm_tmp[2] = vcm_tmp[3] = vcm;
+		if (rssi_type != NPHY_RSSI_SEL_W2) {
+			wlc_phy_set_rssi_2055_vcm(pi, rssi_type, vcm_tmp);
+		}
+
+		wlc_phy_poll_rssi_nphy(pi, rssi_type, &poll_results[vcm][0],
+				       NPHY_RSSICAL_NPOLL);
+
+		if ((rssi_type == NPHY_RSSI_SEL_W1)
+		    || (rssi_type == NPHY_RSSI_SEL_W2)) {
+			for (ctr = 0; ctr < 2; ctr++) {
+				poll_miniq[vcm][ctr] =
+				    MIN(poll_results[vcm][ctr * 2 + 0],
+					poll_results[vcm][ctr * 2 + 1]);
+			}
+		}
+	}
+
+	for (result_idx = 0; result_idx < 4; result_idx++) {
+		min_d = NPHY_RSSICAL_MAXD;
+		min_vcm = 0;
+		min_poll = NPHY_RSSICAL_MAXREAD * NPHY_RSSICAL_NPOLL + 1;
+		for (vcm = 0; vcm < 4; vcm++) {
+			curr_d = ABS(((rssi_type == NPHY_RSSI_SEL_NB) ?
+				      poll_results[vcm][result_idx] :
+				      poll_miniq[vcm][result_idx / 2]) -
+				     (target_code * NPHY_RSSICAL_NPOLL));
+			if (curr_d < min_d) {
+				min_d = curr_d;
+				min_vcm = vcm;
+			}
+			if (poll_results[vcm][result_idx] < min_poll) {
+				min_poll = poll_results[vcm][result_idx];
+			}
+		}
+		vcm_final[result_idx] = min_vcm;
+		poll_results_min[result_idx] = min_poll;
+	}
+
+	if (rssi_type != NPHY_RSSI_SEL_W2) {
+		wlc_phy_set_rssi_2055_vcm(pi, rssi_type, vcm_final);
+	}
+
+	for (result_idx = 0; result_idx < 4; result_idx++) {
+		fine_digital_offset[result_idx] =
+		    (target_code * NPHY_RSSICAL_NPOLL) -
+		    poll_results[vcm_final[result_idx]][result_idx];
+		if (fine_digital_offset[result_idx] < 0) {
+			fine_digital_offset[result_idx] =
+			    ABS(fine_digital_offset[result_idx]);
+			fine_digital_offset[result_idx] +=
+			    (NPHY_RSSICAL_NPOLL / 2);
+			fine_digital_offset[result_idx] /= NPHY_RSSICAL_NPOLL;
+			fine_digital_offset[result_idx] =
+			    -fine_digital_offset[result_idx];
+		} else {
+			fine_digital_offset[result_idx] +=
+			    (NPHY_RSSICAL_NPOLL / 2);
+			fine_digital_offset[result_idx] /= NPHY_RSSICAL_NPOLL;
+		}
+
+		if (poll_results_min[result_idx] ==
+		    NPHY_RSSICAL_MAXREAD * NPHY_RSSICAL_NPOLL) {
+			fine_digital_offset[result_idx] =
+			    (target_code - NPHY_RSSICAL_MAXREAD - 1);
+		}
+
+		wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
+					       (int8)
+					       fine_digital_offset[result_idx],
+					       (result_idx / 2 ==
+						0) ? RADIO_MIMO_CORESEL_CORE1 :
+					       RADIO_MIMO_CORESEL_CORE2,
+					       (result_idx % 2 ==
+						0) ? NPHY_RAIL_I : NPHY_RAIL_Q,
+					       rssi_type);
+	}
+
+	mod_radio_reg(pi, RADIO_2055_PD_CORE1_RSSI_MISC, pd_mask, pd_state[0]);
+	mod_radio_reg(pi, RADIO_2055_PD_CORE2_RSSI_MISC, pd_mask, pd_state[1]);
+	if (rssi_ctrl_state[0] == RADIO_2055_NBRSSI_SEL) {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE1,
+				     NPHY_RSSI_SEL_NB);
+	} else if (rssi_ctrl_state[0] == RADIO_2055_WBRSSI_G1_SEL) {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE1,
+				     NPHY_RSSI_SEL_W1);
+	} else if (rssi_ctrl_state[0] == RADIO_2055_WBRSSI_G2_SEL) {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE1,
+				     NPHY_RSSI_SEL_W2);
+	} else {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE1,
+				     NPHY_RSSI_SEL_W2);
+	}
+	if (rssi_ctrl_state[1] == RADIO_2055_NBRSSI_SEL) {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE2,
+				     NPHY_RSSI_SEL_NB);
+	} else if (rssi_ctrl_state[1] == RADIO_2055_WBRSSI_G1_SEL) {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE2,
+				     NPHY_RSSI_SEL_W1);
+	} else if (rssi_ctrl_state[1] == RADIO_2055_WBRSSI_G2_SEL) {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE2,
+				     NPHY_RSSI_SEL_W2);
+	} else {
+		wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_CORE2,
+				     NPHY_RSSI_SEL_W2);
+	}
+
+	wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_OFF, rssi_type);
+
+	write_phy_reg(pi, 0x91, rfctrlintc_state[0]);
+	write_radio_reg(pi, RADIO_2055_PD_CORE1_RXTX, rfpdcorerxtx_state[0]);
+	write_phy_reg(pi, 0x92, rfctrlintc_state[1]);
+	write_radio_reg(pi, RADIO_2055_PD_CORE2_RXTX, rfpdcorerxtx_state[1]);
+
+	wlc_phy_classifier_nphy(pi, (0x7 << 0), classif_state);
+	wlc_phy_clip_det_nphy(pi, 1, clip_state);
+
+	wlc_phy_resetcca_nphy(pi);
+}
+
+int BCMFASTPATH
+wlc_phy_rssi_compute_nphy(phy_info_t * pi, wlc_d11rxhdr_t * wlc_rxh)
+{
+	d11rxhdr_t *rxh = &wlc_rxh->rxhdr;
+	int16 rxpwr, rxpwr0, rxpwr1;
+	int16 phyRx0_l, phyRx2_l;
+
+	rxpwr = 0;
+	rxpwr0 = ltoh16(rxh->PhyRxStatus_1) & PRXS1_nphy_PWR0_MASK;
+	rxpwr1 = (ltoh16(rxh->PhyRxStatus_1) & PRXS1_nphy_PWR1_MASK) >> 8;
+
+	if (rxpwr0 > 127)
+		rxpwr0 -= 256;
+	if (rxpwr1 > 127)
+		rxpwr1 -= 256;
+
+	phyRx0_l = ltoh16(rxh->PhyRxStatus_0) & 0x00ff;
+	phyRx2_l = ltoh16(rxh->PhyRxStatus_2) & 0x00ff;
+	if (phyRx2_l > 127)
+		phyRx2_l -= 256;
+
+	if (((rxpwr0 == 16) || (rxpwr0 == 32))) {
+		rxpwr0 = rxpwr1;
+		rxpwr1 = phyRx2_l;
+	}
+
+	wlc_rxh->rxpwr[0] = (int8) rxpwr0;
+	wlc_rxh->rxpwr[1] = (int8) rxpwr1;
+	wlc_rxh->do_rssi_ma = 0;
+
+	if (pi->sh->rssi_mode == RSSI_ANT_MERGE_MAX)
+		rxpwr = (rxpwr0 > rxpwr1) ? rxpwr0 : rxpwr1;
+	else if (pi->sh->rssi_mode == RSSI_ANT_MERGE_MIN)
+		rxpwr = (rxpwr0 < rxpwr1) ? rxpwr0 : rxpwr1;
+	else if (pi->sh->rssi_mode == RSSI_ANT_MERGE_AVG)
+		rxpwr = (rxpwr0 + rxpwr1) >> 1;
+	else
+		ASSERT(0);
+
+	return rxpwr;
+}
+
+static void
+wlc_phy_rfctrlintc_override_nphy(phy_info_t * pi, uint8 field, uint16 value,
+				 uint8 core_code)
+{
+	uint16 mask;
+	uint16 val;
+	uint8 core;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+			if (core_code == RADIO_MIMO_CORESEL_CORE1
+			    && core == PHY_CORE_1)
+				continue;
+			else if (core_code == RADIO_MIMO_CORESEL_CORE2
+				 && core == PHY_CORE_0)
+				continue;
+
+			if (NREV_LT(pi->pubpi.phy_rev, 7)) {
+
+				mask = (0x1 << 10);
+				val = 1 << 10;
+				mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x91 :
+					    0x92, mask, val);
+			}
+
+			if (field == NPHY_RfctrlIntc_override_OFF) {
+
+				write_phy_reg(pi, (core == PHY_CORE_0) ? 0x91 :
+					      0x92, 0);
+
+				wlc_phy_force_rfseq_nphy(pi,
+							 NPHY_RFSEQ_RESET2RX);
+			} else if (field == NPHY_RfctrlIntc_override_TRSW) {
+
+				if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+					mask = (0x1 << 6) | (0x1 << 7);
+
+					val = value << 6;
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+
+					or_phy_reg(pi,
+						   (core ==
+						    PHY_CORE_0) ? 0x91 : 0x92,
+						   (0x1 << 10));
+
+					and_phy_reg(pi, 0x2ff, (uint16)
+						    ~ (0x3 << 14));
+					or_phy_reg(pi, 0x2ff, (0x1 << 13));
+					or_phy_reg(pi, 0x2ff, (0x1 << 0));
+				} else {
+
+					mask = (0x1 << 6) |
+					    (0x1 << 7) |
+					    (0x1 << 8) | (0x1 << 9);
+					val = value << 6;
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+
+					mask = (0x1 << 0);
+					val = 1 << 0;
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0xe7 : 0xec,
+						    mask, val);
+
+					mask = (core == PHY_CORE_0) ? (0x1 << 0)
+					    : (0x1 << 1);
+					val = 1 << ((core == PHY_CORE_0) ?
+						    0 : 1);
+					mod_phy_reg(pi, 0x78, mask, val);
+
+					SPINWAIT(((read_phy_reg(pi, 0x78) & val)
+						  != 0), 10000);
+					ASSERT((read_phy_reg(pi, 0x78) & val) ==
+					       0);
+
+					mask = (0x1 << 0);
+					val = 0 << 0;
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0xe7 : 0xec,
+						    mask, val);
+				}
+			} else if (field == NPHY_RfctrlIntc_override_PA) {
+				if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+					mask = (0x1 << 4) | (0x1 << 5);
+
+					if (CHSPEC_IS5G(pi->radio_chanspec)) {
+						val = value << 5;
+					} else {
+						val = value << 4;
+					}
+
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+
+					or_phy_reg(pi,
+						   (core ==
+						    PHY_CORE_0) ? 0x91 : 0x92,
+						   (0x1 << 12));
+				} else {
+
+					if (CHSPEC_IS5G(pi->radio_chanspec)) {
+						mask = (0x1 << 5);
+						val = value << 5;
+					} else {
+						mask = (0x1 << 4);
+						val = value << 4;
+					}
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+				}
+			} else if (field == NPHY_RfctrlIntc_override_EXT_LNA_PU) {
+				if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+					if (CHSPEC_IS5G(pi->radio_chanspec)) {
+
+						mask = (0x1 << 0);
+						val = value << 0;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, val);
+
+						mask = (0x1 << 2);
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, 0);
+					} else {
+
+						mask = (0x1 << 2);
+						val = value << 2;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, val);
+
+						mask = (0x1 << 0);
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, 0);
+					}
+
+					mask = (0x1 << 11);
+					val = 1 << 11;
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+				} else {
+
+					if (CHSPEC_IS5G(pi->radio_chanspec)) {
+						mask = (0x1 << 0);
+						val = value << 0;
+					} else {
+						mask = (0x1 << 2);
+						val = value << 2;
+					}
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+				}
+			} else if (field ==
+				   NPHY_RfctrlIntc_override_EXT_LNA_GAIN) {
+				if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+					if (CHSPEC_IS5G(pi->radio_chanspec)) {
+
+						mask = (0x1 << 1);
+						val = value << 1;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, val);
+
+						mask = (0x1 << 3);
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, 0);
+					} else {
+
+						mask = (0x1 << 3);
+						val = value << 3;
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, val);
+
+						mask = (0x1 << 1);
+						mod_phy_reg(pi,
+							    (core ==
+							     PHY_CORE_0) ? 0x91
+							    : 0x92, mask, 0);
+					}
+
+					mask = (0x1 << 11);
+					val = 1 << 11;
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+				} else {
+
+					if (CHSPEC_IS5G(pi->radio_chanspec)) {
+						mask = (0x1 << 1);
+						val = value << 1;
+					} else {
+						mask = (0x1 << 3);
+						val = value << 3;
+					}
+					mod_phy_reg(pi,
+						    (core ==
+						     PHY_CORE_0) ? 0x91 : 0x92,
+						    mask, val);
+				}
+			}
+		}
+	} else {
+		return;
+	}
+}
+
+static void wlc_phy_rssi_cal_nphy_rev3(phy_info_t * pi)
+{
+	uint16 classif_state;
+	uint16 clip_state[2];
+	uint16 clip_off[] = { 0xffff, 0xffff };
+	int32 target_code;
+	uint8 vcm, min_vcm;
+	uint8 vcm_final = 0;
+	uint8 result_idx;
+	int32 poll_results[8][4] = {
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0},
+		{0, 0, 0, 0}
+	};
+	int32 poll_result_core[4] = { 0, 0, 0, 0 };
+	int32 min_d = NPHY_RSSICAL_MAXD, curr_d;
+	int32 fine_digital_offset[4];
+	int32 poll_results_min[4] = { 0, 0, 0, 0 };
+	int32 min_poll;
+	uint8 vcm_level_max;
+	uint8 core;
+	uint8 wb_cnt;
+	uint8 rssi_type;
+	uint16 NPHY_Rfctrlintc1_save, NPHY_Rfctrlintc2_save;
+	uint16 NPHY_AfectrlOverride1_save, NPHY_AfectrlOverride2_save;
+	uint16 NPHY_AfectrlCore1_save, NPHY_AfectrlCore2_save;
+	uint16 NPHY_RfctrlOverride0_save, NPHY_RfctrlOverride1_save;
+	uint16 NPHY_RfctrlOverrideAux0_save, NPHY_RfctrlOverrideAux1_save;
+	uint16 NPHY_RfctrlCmd_save;
+	uint16 NPHY_RfctrlMiscReg1_save, NPHY_RfctrlMiscReg2_save;
+	uint16 NPHY_RfctrlRSSIOTHERS1_save, NPHY_RfctrlRSSIOTHERS2_save;
+	uint8 rxcore_state;
+	uint16 NPHY_REV7_RfctrlOverride3_save, NPHY_REV7_RfctrlOverride4_save;
+	uint16 NPHY_REV7_RfctrlOverride5_save, NPHY_REV7_RfctrlOverride6_save;
+	uint16 NPHY_REV7_RfctrlMiscReg3_save, NPHY_REV7_RfctrlMiscReg4_save;
+	uint16 NPHY_REV7_RfctrlMiscReg5_save, NPHY_REV7_RfctrlMiscReg6_save;
+
+	NPHY_REV7_RfctrlOverride3_save = NPHY_REV7_RfctrlOverride4_save =
+	    NPHY_REV7_RfctrlOverride5_save = NPHY_REV7_RfctrlOverride6_save =
+	    NPHY_REV7_RfctrlMiscReg3_save = NPHY_REV7_RfctrlMiscReg4_save =
+	    NPHY_REV7_RfctrlMiscReg5_save = NPHY_REV7_RfctrlMiscReg6_save = 0;
+
+	classif_state = wlc_phy_classifier_nphy(pi, 0, 0);
+	wlc_phy_classifier_nphy(pi, (0x7 << 0), 4);
+	wlc_phy_clip_det_nphy(pi, 0, clip_state);
+	wlc_phy_clip_det_nphy(pi, 1, clip_off);
+
+	NPHY_Rfctrlintc1_save = read_phy_reg(pi, 0x91);
+	NPHY_Rfctrlintc2_save = read_phy_reg(pi, 0x92);
+	NPHY_AfectrlOverride1_save = read_phy_reg(pi, 0x8f);
+	NPHY_AfectrlOverride2_save = read_phy_reg(pi, 0xa5);
+	NPHY_AfectrlCore1_save = read_phy_reg(pi, 0xa6);
+	NPHY_AfectrlCore2_save = read_phy_reg(pi, 0xa7);
+	NPHY_RfctrlOverride0_save = read_phy_reg(pi, 0xe7);
+	NPHY_RfctrlOverride1_save = read_phy_reg(pi, 0xec);
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		NPHY_REV7_RfctrlOverride3_save = read_phy_reg(pi, 0x342);
+		NPHY_REV7_RfctrlOverride4_save = read_phy_reg(pi, 0x343);
+		NPHY_REV7_RfctrlOverride5_save = read_phy_reg(pi, 0x346);
+		NPHY_REV7_RfctrlOverride6_save = read_phy_reg(pi, 0x347);
+	}
+	NPHY_RfctrlOverrideAux0_save = read_phy_reg(pi, 0xe5);
+	NPHY_RfctrlOverrideAux1_save = read_phy_reg(pi, 0xe6);
+	NPHY_RfctrlCmd_save = read_phy_reg(pi, 0x78);
+	NPHY_RfctrlMiscReg1_save = read_phy_reg(pi, 0xf9);
+	NPHY_RfctrlMiscReg2_save = read_phy_reg(pi, 0xfb);
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		NPHY_REV7_RfctrlMiscReg3_save = read_phy_reg(pi, 0x340);
+		NPHY_REV7_RfctrlMiscReg4_save = read_phy_reg(pi, 0x341);
+		NPHY_REV7_RfctrlMiscReg5_save = read_phy_reg(pi, 0x344);
+		NPHY_REV7_RfctrlMiscReg6_save = read_phy_reg(pi, 0x345);
+	}
+	NPHY_RfctrlRSSIOTHERS1_save = read_phy_reg(pi, 0x7a);
+	NPHY_RfctrlRSSIOTHERS2_save = read_phy_reg(pi, 0x7d);
+
+	wlc_phy_rfctrlintc_override_nphy(pi, NPHY_RfctrlIntc_override_OFF, 0,
+					 RADIO_MIMO_CORESEL_ALLRXTX);
+	wlc_phy_rfctrlintc_override_nphy(pi, NPHY_RfctrlIntc_override_TRSW, 1,
+					 RADIO_MIMO_CORESEL_ALLRXTX);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_rxrf_pu,
+						     0, 0, 0);
+	} else {
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 0), 0, 0, 0);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_rx_pu,
+						     1, 0, 0);
+	} else {
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 1), 1, 0, 0);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 7),
+						  1, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 6), 1, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+	} else {
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 7), 1, 0, 0);
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 6), 1, 0, 0);
+	}
+
+	if (CHSPEC_IS5G(pi->radio_chanspec)) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 5),
+							  0, 0, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 4), 1, 0,
+							  0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		} else {
+			wlc_phy_rfctrl_override_nphy(pi, (0x1 << 5), 0, 0, 0);
+			wlc_phy_rfctrl_override_nphy(pi, (0x1 << 4), 1, 0, 0);
+		}
+
+	} else {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 4),
+							  0, 0, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 5), 1, 0,
+							  0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		} else {
+			wlc_phy_rfctrl_override_nphy(pi, (0x1 << 4), 0, 0, 0);
+			wlc_phy_rfctrl_override_nphy(pi, (0x1 << 5), 1, 0, 0);
+		}
+	}
+
+	rxcore_state = wlc_phy_rxcore_getstate_nphy((wlc_phy_t *) pi);
+
+	vcm_level_max = 8;
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+		if ((rxcore_state & (1 << core)) == 0)
+			continue;
+
+		wlc_phy_scale_offset_rssi_nphy(pi, 0x0, 0x0,
+					       core ==
+					       PHY_CORE_0 ?
+					       RADIO_MIMO_CORESEL_CORE1 :
+					       RADIO_MIMO_CORESEL_CORE2,
+					       NPHY_RAIL_I, NPHY_RSSI_SEL_NB);
+		wlc_phy_scale_offset_rssi_nphy(pi, 0x0, 0x0,
+					       core ==
+					       PHY_CORE_0 ?
+					       RADIO_MIMO_CORESEL_CORE1 :
+					       RADIO_MIMO_CORESEL_CORE2,
+					       NPHY_RAIL_Q, NPHY_RSSI_SEL_NB);
+
+		for (vcm = 0; vcm < vcm_level_max; vcm++) {
+			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+				mod_radio_reg(pi, (core == PHY_CORE_0) ?
+					      RADIO_2057_NB_MASTER_CORE0 :
+					      RADIO_2057_NB_MASTER_CORE1,
+					      RADIO_2057_VCM_MASK, vcm);
+			} else {
+
+				mod_radio_reg(pi, RADIO_2056_RX_RSSI_MISC |
+					      ((core ==
+						PHY_CORE_0) ? RADIO_2056_RX0 :
+					       RADIO_2056_RX1),
+					      RADIO_2056_VCM_MASK,
+					      vcm << RADIO_2056_RSSI_VCM_SHIFT);
+			}
+
+			wlc_phy_poll_rssi_nphy(pi, NPHY_RSSI_SEL_NB,
+					       &poll_results[vcm][0],
+					       NPHY_RSSICAL_NPOLL);
+		}
+
+		for (result_idx = 0; result_idx < 4; result_idx++) {
+			if ((core == result_idx / 2) && (result_idx % 2 == 0)) {
+
+				min_d = NPHY_RSSICAL_MAXD;
+				min_vcm = 0;
+				min_poll =
+				    NPHY_RSSICAL_MAXREAD * NPHY_RSSICAL_NPOLL +
+				    1;
+				for (vcm = 0; vcm < vcm_level_max; vcm++) {
+					curr_d = poll_results[vcm][result_idx] *
+					    poll_results[vcm][result_idx] +
+					    poll_results[vcm][result_idx + 1] *
+					    poll_results[vcm][result_idx + 1];
+					if (curr_d < min_d) {
+						min_d = curr_d;
+						min_vcm = vcm;
+					}
+					if (poll_results[vcm][result_idx] <
+					    min_poll) {
+						min_poll =
+						    poll_results[vcm]
+						    [result_idx];
+					}
+				}
+				vcm_final = min_vcm;
+				poll_results_min[result_idx] = min_poll;
+			}
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			mod_radio_reg(pi, (core == PHY_CORE_0) ?
+				      RADIO_2057_NB_MASTER_CORE0 :
+				      RADIO_2057_NB_MASTER_CORE1,
+				      RADIO_2057_VCM_MASK, vcm_final);
+		} else {
+			mod_radio_reg(pi, RADIO_2056_RX_RSSI_MISC |
+				      ((core ==
+					PHY_CORE_0) ? RADIO_2056_RX0 :
+				       RADIO_2056_RX1), RADIO_2056_VCM_MASK,
+				      vcm_final << RADIO_2056_RSSI_VCM_SHIFT);
+		}
+
+		for (result_idx = 0; result_idx < 4; result_idx++) {
+			if (core == result_idx / 2) {
+				fine_digital_offset[result_idx] =
+				    (NPHY_RSSICAL_NB_TARGET *
+				     NPHY_RSSICAL_NPOLL) -
+				    poll_results[vcm_final][result_idx];
+				if (fine_digital_offset[result_idx] < 0) {
+					fine_digital_offset[result_idx] =
+					    ABS(fine_digital_offset
+						[result_idx]);
+					fine_digital_offset[result_idx] +=
+					    (NPHY_RSSICAL_NPOLL / 2);
+					fine_digital_offset[result_idx] /=
+					    NPHY_RSSICAL_NPOLL;
+					fine_digital_offset[result_idx] =
+					    -fine_digital_offset[result_idx];
+				} else {
+					fine_digital_offset[result_idx] +=
+					    (NPHY_RSSICAL_NPOLL / 2);
+					fine_digital_offset[result_idx] /=
+					    NPHY_RSSICAL_NPOLL;
+				}
+
+				if (poll_results_min[result_idx] ==
+				    NPHY_RSSICAL_MAXREAD * NPHY_RSSICAL_NPOLL) {
+					fine_digital_offset[result_idx] =
+					    (NPHY_RSSICAL_NB_TARGET -
+					     NPHY_RSSICAL_MAXREAD - 1);
+				}
+
+				wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
+							       (int8)
+							       fine_digital_offset
+							       [result_idx],
+							       (result_idx /
+								2 ==
+								0) ?
+							       RADIO_MIMO_CORESEL_CORE1
+							       :
+							       RADIO_MIMO_CORESEL_CORE2,
+							       (result_idx %
+								2 ==
+								0) ? NPHY_RAIL_I
+							       : NPHY_RAIL_Q,
+							       NPHY_RSSI_SEL_NB);
+			}
+		}
+
+	}
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+		if ((rxcore_state & (1 << core)) == 0)
+			continue;
+
+		for (wb_cnt = 0; wb_cnt < 2; wb_cnt++) {
+			if (wb_cnt == 0) {
+				rssi_type = NPHY_RSSI_SEL_W1;
+				target_code = NPHY_RSSICAL_W1_TARGET_REV3;
+			} else {
+				rssi_type = NPHY_RSSI_SEL_W2;
+				target_code = NPHY_RSSICAL_W2_TARGET_REV3;
+			}
+
+			wlc_phy_scale_offset_rssi_nphy(pi, 0x0, 0x0,
+						       core ==
+						       PHY_CORE_0 ?
+						       RADIO_MIMO_CORESEL_CORE1
+						       :
+						       RADIO_MIMO_CORESEL_CORE2,
+						       NPHY_RAIL_I, rssi_type);
+			wlc_phy_scale_offset_rssi_nphy(pi, 0x0, 0x0,
+						       core ==
+						       PHY_CORE_0 ?
+						       RADIO_MIMO_CORESEL_CORE1
+						       :
+						       RADIO_MIMO_CORESEL_CORE2,
+						       NPHY_RAIL_Q, rssi_type);
+
+			wlc_phy_poll_rssi_nphy(pi, rssi_type, poll_result_core,
+					       NPHY_RSSICAL_NPOLL);
+
+			for (result_idx = 0; result_idx < 4; result_idx++) {
+				if (core == result_idx / 2) {
+					fine_digital_offset[result_idx] =
+					    (target_code * NPHY_RSSICAL_NPOLL) -
+					    poll_result_core[result_idx];
+					if (fine_digital_offset[result_idx] < 0) {
+						fine_digital_offset[result_idx]
+						    =
+						    ABS(fine_digital_offset
+							[result_idx]);
+						fine_digital_offset[result_idx]
+						    += (NPHY_RSSICAL_NPOLL / 2);
+						fine_digital_offset[result_idx]
+						    /= NPHY_RSSICAL_NPOLL;
+						fine_digital_offset[result_idx]
+						    =
+						    -fine_digital_offset
+						    [result_idx];
+					} else {
+						fine_digital_offset[result_idx]
+						    += (NPHY_RSSICAL_NPOLL / 2);
+						fine_digital_offset[result_idx]
+						    /= NPHY_RSSICAL_NPOLL;
+					}
+
+					wlc_phy_scale_offset_rssi_nphy(pi, 0x0,
+								       (int8)
+								       fine_digital_offset
+								       [core *
+									2],
+								       (core ==
+									PHY_CORE_0)
+								       ?
+								       RADIO_MIMO_CORESEL_CORE1
+								       :
+								       RADIO_MIMO_CORESEL_CORE2,
+								       (result_idx
+									% 2 ==
+									0) ?
+								       NPHY_RAIL_I
+								       :
+								       NPHY_RAIL_Q,
+								       rssi_type);
+				}
+			}
+
+		}
+	}
+
+	write_phy_reg(pi, 0x91, NPHY_Rfctrlintc1_save);
+	write_phy_reg(pi, 0x92, NPHY_Rfctrlintc2_save);
+
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+
+	mod_phy_reg(pi, 0xe7, (0x1 << 0), 1 << 0);
+	mod_phy_reg(pi, 0x78, (0x1 << 0), 1 << 0);
+	mod_phy_reg(pi, 0xe7, (0x1 << 0), 0);
+
+	mod_phy_reg(pi, 0xec, (0x1 << 0), 1 << 0);
+	mod_phy_reg(pi, 0x78, (0x1 << 1), 1 << 1);
+	mod_phy_reg(pi, 0xec, (0x1 << 0), 0);
+
+	write_phy_reg(pi, 0x8f, NPHY_AfectrlOverride1_save);
+	write_phy_reg(pi, 0xa5, NPHY_AfectrlOverride2_save);
+	write_phy_reg(pi, 0xa6, NPHY_AfectrlCore1_save);
+	write_phy_reg(pi, 0xa7, NPHY_AfectrlCore2_save);
+	write_phy_reg(pi, 0xe7, NPHY_RfctrlOverride0_save);
+	write_phy_reg(pi, 0xec, NPHY_RfctrlOverride1_save);
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		write_phy_reg(pi, 0x342, NPHY_REV7_RfctrlOverride3_save);
+		write_phy_reg(pi, 0x343, NPHY_REV7_RfctrlOverride4_save);
+		write_phy_reg(pi, 0x346, NPHY_REV7_RfctrlOverride5_save);
+		write_phy_reg(pi, 0x347, NPHY_REV7_RfctrlOverride6_save);
+	}
+	write_phy_reg(pi, 0xe5, NPHY_RfctrlOverrideAux0_save);
+	write_phy_reg(pi, 0xe6, NPHY_RfctrlOverrideAux1_save);
+	write_phy_reg(pi, 0x78, NPHY_RfctrlCmd_save);
+	write_phy_reg(pi, 0xf9, NPHY_RfctrlMiscReg1_save);
+	write_phy_reg(pi, 0xfb, NPHY_RfctrlMiscReg2_save);
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		write_phy_reg(pi, 0x340, NPHY_REV7_RfctrlMiscReg3_save);
+		write_phy_reg(pi, 0x341, NPHY_REV7_RfctrlMiscReg4_save);
+		write_phy_reg(pi, 0x344, NPHY_REV7_RfctrlMiscReg5_save);
+		write_phy_reg(pi, 0x345, NPHY_REV7_RfctrlMiscReg6_save);
+	}
+	write_phy_reg(pi, 0x7a, NPHY_RfctrlRSSIOTHERS1_save);
+	write_phy_reg(pi, 0x7d, NPHY_RfctrlRSSIOTHERS2_save);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			pi->rssical_cache.rssical_radio_regs_2G[0] =
+			    read_radio_reg(pi, RADIO_2057_NB_MASTER_CORE0);
+			pi->rssical_cache.rssical_radio_regs_2G[1] =
+			    read_radio_reg(pi, RADIO_2057_NB_MASTER_CORE1);
+		} else {
+			pi->rssical_cache.rssical_radio_regs_2G[0] =
+			    read_radio_reg(pi,
+					   RADIO_2056_RX_RSSI_MISC |
+					   RADIO_2056_RX0);
+			pi->rssical_cache.rssical_radio_regs_2G[1] =
+			    read_radio_reg(pi,
+					   RADIO_2056_RX_RSSI_MISC |
+					   RADIO_2056_RX1);
+		}
+
+		pi->rssical_cache.rssical_phyregs_2G[0] =
+		    read_phy_reg(pi, 0x1a6);
+		pi->rssical_cache.rssical_phyregs_2G[1] =
+		    read_phy_reg(pi, 0x1ac);
+		pi->rssical_cache.rssical_phyregs_2G[2] =
+		    read_phy_reg(pi, 0x1b2);
+		pi->rssical_cache.rssical_phyregs_2G[3] =
+		    read_phy_reg(pi, 0x1b8);
+		pi->rssical_cache.rssical_phyregs_2G[4] =
+		    read_phy_reg(pi, 0x1a4);
+		pi->rssical_cache.rssical_phyregs_2G[5] =
+		    read_phy_reg(pi, 0x1aa);
+		pi->rssical_cache.rssical_phyregs_2G[6] =
+		    read_phy_reg(pi, 0x1b0);
+		pi->rssical_cache.rssical_phyregs_2G[7] =
+		    read_phy_reg(pi, 0x1b6);
+		pi->rssical_cache.rssical_phyregs_2G[8] =
+		    read_phy_reg(pi, 0x1a5);
+		pi->rssical_cache.rssical_phyregs_2G[9] =
+		    read_phy_reg(pi, 0x1ab);
+		pi->rssical_cache.rssical_phyregs_2G[10] =
+		    read_phy_reg(pi, 0x1b1);
+		pi->rssical_cache.rssical_phyregs_2G[11] =
+		    read_phy_reg(pi, 0x1b7);
+
+		pi->nphy_rssical_chanspec_2G = pi->radio_chanspec;
+	} else {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			pi->rssical_cache.rssical_radio_regs_5G[0] =
+			    read_radio_reg(pi, RADIO_2057_NB_MASTER_CORE0);
+			pi->rssical_cache.rssical_radio_regs_5G[1] =
+			    read_radio_reg(pi, RADIO_2057_NB_MASTER_CORE1);
+		} else {
+			pi->rssical_cache.rssical_radio_regs_5G[0] =
+			    read_radio_reg(pi,
+					   RADIO_2056_RX_RSSI_MISC |
+					   RADIO_2056_RX0);
+			pi->rssical_cache.rssical_radio_regs_5G[1] =
+			    read_radio_reg(pi,
+					   RADIO_2056_RX_RSSI_MISC |
+					   RADIO_2056_RX1);
+		}
+
+		pi->rssical_cache.rssical_phyregs_5G[0] =
+		    read_phy_reg(pi, 0x1a6);
+		pi->rssical_cache.rssical_phyregs_5G[1] =
+		    read_phy_reg(pi, 0x1ac);
+		pi->rssical_cache.rssical_phyregs_5G[2] =
+		    read_phy_reg(pi, 0x1b2);
+		pi->rssical_cache.rssical_phyregs_5G[3] =
+		    read_phy_reg(pi, 0x1b8);
+		pi->rssical_cache.rssical_phyregs_5G[4] =
+		    read_phy_reg(pi, 0x1a4);
+		pi->rssical_cache.rssical_phyregs_5G[5] =
+		    read_phy_reg(pi, 0x1aa);
+		pi->rssical_cache.rssical_phyregs_5G[6] =
+		    read_phy_reg(pi, 0x1b0);
+		pi->rssical_cache.rssical_phyregs_5G[7] =
+		    read_phy_reg(pi, 0x1b6);
+		pi->rssical_cache.rssical_phyregs_5G[8] =
+		    read_phy_reg(pi, 0x1a5);
+		pi->rssical_cache.rssical_phyregs_5G[9] =
+		    read_phy_reg(pi, 0x1ab);
+		pi->rssical_cache.rssical_phyregs_5G[10] =
+		    read_phy_reg(pi, 0x1b1);
+		pi->rssical_cache.rssical_phyregs_5G[11] =
+		    read_phy_reg(pi, 0x1b7);
+
+		pi->nphy_rssical_chanspec_5G = pi->radio_chanspec;
+	}
+
+	wlc_phy_classifier_nphy(pi, (0x7 << 0), classif_state);
+	wlc_phy_clip_det_nphy(pi, 1, clip_state);
+}
+
+static void wlc_phy_restore_rssical_nphy(phy_info_t * pi)
+{
+	ASSERT(NREV_GE(pi->pubpi.phy_rev, 3));
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		if (pi->nphy_rssical_chanspec_2G == 0)
+			return;
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			mod_radio_reg(pi, RADIO_2057_NB_MASTER_CORE0,
+				      RADIO_2057_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_2G[0]);
+			mod_radio_reg(pi, RADIO_2057_NB_MASTER_CORE1,
+				      RADIO_2057_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_2G[1]);
+		} else {
+			mod_radio_reg(pi,
+				      RADIO_2056_RX_RSSI_MISC | RADIO_2056_RX0,
+				      RADIO_2056_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_2G[0]);
+			mod_radio_reg(pi,
+				      RADIO_2056_RX_RSSI_MISC | RADIO_2056_RX1,
+				      RADIO_2056_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_2G[1]);
+		}
+
+		write_phy_reg(pi, 0x1a6,
+			      pi->rssical_cache.rssical_phyregs_2G[0]);
+		write_phy_reg(pi, 0x1ac,
+			      pi->rssical_cache.rssical_phyregs_2G[1]);
+		write_phy_reg(pi, 0x1b2,
+			      pi->rssical_cache.rssical_phyregs_2G[2]);
+		write_phy_reg(pi, 0x1b8,
+			      pi->rssical_cache.rssical_phyregs_2G[3]);
+		write_phy_reg(pi, 0x1a4,
+			      pi->rssical_cache.rssical_phyregs_2G[4]);
+		write_phy_reg(pi, 0x1aa,
+			      pi->rssical_cache.rssical_phyregs_2G[5]);
+		write_phy_reg(pi, 0x1b0,
+			      pi->rssical_cache.rssical_phyregs_2G[6]);
+		write_phy_reg(pi, 0x1b6,
+			      pi->rssical_cache.rssical_phyregs_2G[7]);
+		write_phy_reg(pi, 0x1a5,
+			      pi->rssical_cache.rssical_phyregs_2G[8]);
+		write_phy_reg(pi, 0x1ab,
+			      pi->rssical_cache.rssical_phyregs_2G[9]);
+		write_phy_reg(pi, 0x1b1,
+			      pi->rssical_cache.rssical_phyregs_2G[10]);
+		write_phy_reg(pi, 0x1b7,
+			      pi->rssical_cache.rssical_phyregs_2G[11]);
+
+	} else {
+		if (pi->nphy_rssical_chanspec_5G == 0)
+			return;
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			mod_radio_reg(pi, RADIO_2057_NB_MASTER_CORE0,
+				      RADIO_2057_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_5G[0]);
+			mod_radio_reg(pi, RADIO_2057_NB_MASTER_CORE1,
+				      RADIO_2057_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_5G[1]);
+		} else {
+			mod_radio_reg(pi,
+				      RADIO_2056_RX_RSSI_MISC | RADIO_2056_RX0,
+				      RADIO_2056_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_5G[0]);
+			mod_radio_reg(pi,
+				      RADIO_2056_RX_RSSI_MISC | RADIO_2056_RX1,
+				      RADIO_2056_VCM_MASK,
+				      pi->rssical_cache.
+				      rssical_radio_regs_5G[1]);
+		}
+
+		write_phy_reg(pi, 0x1a6,
+			      pi->rssical_cache.rssical_phyregs_5G[0]);
+		write_phy_reg(pi, 0x1ac,
+			      pi->rssical_cache.rssical_phyregs_5G[1]);
+		write_phy_reg(pi, 0x1b2,
+			      pi->rssical_cache.rssical_phyregs_5G[2]);
+		write_phy_reg(pi, 0x1b8,
+			      pi->rssical_cache.rssical_phyregs_5G[3]);
+		write_phy_reg(pi, 0x1a4,
+			      pi->rssical_cache.rssical_phyregs_5G[4]);
+		write_phy_reg(pi, 0x1aa,
+			      pi->rssical_cache.rssical_phyregs_5G[5]);
+		write_phy_reg(pi, 0x1b0,
+			      pi->rssical_cache.rssical_phyregs_5G[6]);
+		write_phy_reg(pi, 0x1b6,
+			      pi->rssical_cache.rssical_phyregs_5G[7]);
+		write_phy_reg(pi, 0x1a5,
+			      pi->rssical_cache.rssical_phyregs_5G[8]);
+		write_phy_reg(pi, 0x1ab,
+			      pi->rssical_cache.rssical_phyregs_5G[9]);
+		write_phy_reg(pi, 0x1b1,
+			      pi->rssical_cache.rssical_phyregs_5G[10]);
+		write_phy_reg(pi, 0x1b7,
+			      pi->rssical_cache.rssical_phyregs_5G[11]);
+	}
+}
+
+static uint16
+wlc_phy_gen_load_samples_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
+			      uint8 dac_test_mode)
+{
+	uint8 phy_bw, is_phybw40;
+	uint16 num_samps, t, spur;
+	fixed theta = 0, rot = 0;
+	uint32 tbl_len;
+	cint32 *tone_buf = NULL;
+
+	is_phybw40 = CHSPEC_IS40(pi->radio_chanspec);
+	phy_bw = (is_phybw40 == 1) ? 40 : 20;
+	tbl_len = (phy_bw << 3);
+
+	if (dac_test_mode == 1) {
+		spur = read_phy_reg(pi, 0x01);
+		spur = (spur >> 15) & 1;
+		phy_bw = (spur == 1) ? 82 : 80;
+		phy_bw = (is_phybw40 == 1) ? (phy_bw << 1) : phy_bw;
+
+		tbl_len = (phy_bw << 1);
+	}
+
+	if ((tone_buf =
+	     (cint32 *) MALLOC(pi->sh->osh,
+			       sizeof(cint32) * tbl_len)) == NULL) {
+		return 0;
+	}
+
+	num_samps = (uint16) tbl_len;
+	rot = FIXED((f_kHz * 36) / phy_bw) / 100;
+	theta = 0;
+
+	for (t = 0; t < num_samps; t++) {
+
+		wlc_phy_cordic(theta, &tone_buf[t]);
+
+		theta += rot;
+
+		tone_buf[t].q = (int32) FLOAT(tone_buf[t].q * max_val);
+		tone_buf[t].i = (int32) FLOAT(tone_buf[t].i * max_val);
+	}
+
+	wlc_phy_loadsampletable_nphy(pi, tone_buf, num_samps);
+
+	if (tone_buf != NULL)
+		MFREE(pi->sh->osh, tone_buf, sizeof(cint32) * tbl_len);
+
+	return num_samps;
+}
+
+int
+wlc_phy_tx_tone_nphy(phy_info_t * pi, uint32 f_kHz, uint16 max_val,
+		     uint8 iqmode, uint8 dac_test_mode, bool modify_bbmult)
+{
+	uint16 num_samps;
+	uint16 loops = 0xffff;
+	uint16 wait = 0;
+
+	if ((num_samps =
+	     wlc_phy_gen_load_samples_nphy(pi, f_kHz, max_val,
+					   dac_test_mode)) == 0) {
+		return BCME_ERROR;
+	}
+
+	wlc_phy_runsamples_nphy(pi, num_samps, loops, wait, iqmode,
+				dac_test_mode, modify_bbmult);
+
+	return BCME_OK;
+}
+
+static void
+wlc_phy_loadsampletable_nphy(phy_info_t * pi, cint32 * tone_buf,
+			     uint16 num_samps)
+{
+	uint16 t;
+	uint32 *data_buf = NULL;
+
+	if ((data_buf =
+	     (uint32 *) MALLOC(pi->sh->osh,
+			       sizeof(uint32) * num_samps)) == NULL) {
+		return;
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	for (t = 0; t < num_samps; t++) {
+		data_buf[t] = ((((unsigned int)tone_buf[t].i) & 0x3ff) << 10) |
+		    (((unsigned int)tone_buf[t].q) & 0x3ff);
+	}
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_SAMPLEPLAY, num_samps, 0, 32,
+				 data_buf);
+
+	if (data_buf != NULL)
+		MFREE(pi->sh->osh, data_buf, sizeof(uint32) * num_samps);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static void
+wlc_phy_runsamples_nphy(phy_info_t * pi, uint16 num_samps, uint16 loops,
+			uint16 wait, uint8 iqmode, uint8 dac_test_mode,
+			bool modify_bbmult)
+{
+	uint16 bb_mult;
+	uint8 phy_bw, sample_cmd;
+	uint16 orig_RfseqCoreActv;
+	uint16 lpf_bw_ctl_override3, lpf_bw_ctl_override4, lpf_bw_ctl_miscreg3,
+	    lpf_bw_ctl_miscreg4;
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	phy_bw = 20;
+	if (CHSPEC_IS40(pi->radio_chanspec))
+		phy_bw = 40;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		lpf_bw_ctl_override3 = read_phy_reg(pi, 0x342) & (0x1 << 7);
+		lpf_bw_ctl_override4 = read_phy_reg(pi, 0x343) & (0x1 << 7);
+		if (lpf_bw_ctl_override3 | lpf_bw_ctl_override4) {
+			lpf_bw_ctl_miscreg3 = read_phy_reg(pi, 0x340) &
+			    (0x7 << 8);
+			lpf_bw_ctl_miscreg4 = read_phy_reg(pi, 0x341) &
+			    (0x7 << 8);
+		} else {
+			wlc_phy_rfctrl_override_nphy_rev7(pi,
+							  (0x1 << 7),
+							  wlc_phy_read_lpf_bw_ctl_nphy
+							  (pi, 0), 0, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+
+			pi->nphy_sample_play_lpf_bw_ctl_ovr = TRUE;
+
+			lpf_bw_ctl_miscreg3 = read_phy_reg(pi, 0x340) &
+			    (0x7 << 8);
+			lpf_bw_ctl_miscreg4 = read_phy_reg(pi, 0x341) &
+			    (0x7 << 8);
+		}
+	}
+
+	if ((pi->nphy_bb_mult_save & BB_MULT_VALID_MASK) == 0) {
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL, 1, 87, 16,
+					&bb_mult);
+		pi->nphy_bb_mult_save =
+		    BB_MULT_VALID_MASK | (bb_mult & BB_MULT_MASK);
+	}
+
+	if (modify_bbmult) {
+		bb_mult = (phy_bw == 20) ? 100 : 71;
+		bb_mult = (bb_mult << 8) + bb_mult;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 1, 87, 16,
+					 &bb_mult);
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+
+	write_phy_reg(pi, 0xc6, num_samps - 1);
+
+	if (loops != 0xffff) {
+		write_phy_reg(pi, 0xc4, loops - 1);
+	} else {
+		write_phy_reg(pi, 0xc4, loops);
+	}
+	write_phy_reg(pi, 0xc5, wait);
+
+	orig_RfseqCoreActv = read_phy_reg(pi, 0xa1);
+	or_phy_reg(pi, 0xa1, NPHY_RfseqMode_CoreActv_override);
+	if (iqmode) {
+
+		and_phy_reg(pi, 0xc2, 0x7FFF);
+
+		or_phy_reg(pi, 0xc2, 0x8000);
+	} else {
+
+		sample_cmd = (dac_test_mode == 1) ? 0x5 : 0x1;
+		write_phy_reg(pi, 0xc3, sample_cmd);
+	}
+
+	SPINWAIT(((read_phy_reg(pi, 0xa4) & 0x1) == 1), 1000);
+
+	write_phy_reg(pi, 0xa1, orig_RfseqCoreActv);
+}
+
+void wlc_phy_stopplayback_nphy(phy_info_t * pi)
+{
+	uint16 playback_status;
+	uint16 bb_mult;
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	playback_status = read_phy_reg(pi, 0xc7);
+	if (playback_status & 0x1) {
+		or_phy_reg(pi, 0xc3, NPHY_sampleCmd_STOP);
+	} else if (playback_status & 0x2) {
+
+		and_phy_reg(pi, 0xc2,
+			    (uint16) ~ NPHY_iqloCalCmdGctl_IQLO_CAL_EN);
+	}
+
+	and_phy_reg(pi, 0xc3, (uint16) ~ (0x1 << 2));
+
+	if ((pi->nphy_bb_mult_save & BB_MULT_VALID_MASK) != 0) {
+
+		bb_mult = pi->nphy_bb_mult_save & BB_MULT_MASK;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 1, 87, 16,
+					 &bb_mult);
+
+		pi->nphy_bb_mult_save = 0;
+	}
+
+	if (NREV_IS(pi->pubpi.phy_rev, 7) || NREV_GE(pi->pubpi.phy_rev, 8)) {
+		if (pi->nphy_sample_play_lpf_bw_ctl_ovr) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi,
+							  (0x1 << 7),
+							  0, 0, 1,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+			pi->nphy_sample_play_lpf_bw_ctl_ovr = FALSE;
+		}
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+nphy_txgains_t wlc_phy_get_tx_gain_nphy(phy_info_t * pi)
+{
+	uint16 base_idx[2], curr_gain[2];
+	uint8 core_no;
+	nphy_txgains_t target_gain;
+	uint32 *tx_pwrctrl_tbl = NULL;
+
+	if (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF) {
+		if (pi->phyhang_avoid)
+			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
+					curr_gain);
+
+		if (pi->phyhang_avoid)
+			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+
+		for (core_no = 0; core_no < 2; core_no++) {
+			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+				target_gain.ipa[core_no] =
+				    curr_gain[core_no] & 0x0007;
+				target_gain.pad[core_no] =
+				    ((curr_gain[core_no] & 0x00F8) >> 3);
+				target_gain.pga[core_no] =
+				    ((curr_gain[core_no] & 0x0F00) >> 8);
+				target_gain.txgm[core_no] =
+				    ((curr_gain[core_no] & 0x7000) >> 12);
+				target_gain.txlpf[core_no] =
+				    ((curr_gain[core_no] & 0x8000) >> 15);
+			} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				target_gain.ipa[core_no] =
+				    curr_gain[core_no] & 0x000F;
+				target_gain.pad[core_no] =
+				    ((curr_gain[core_no] & 0x00F0) >> 4);
+				target_gain.pga[core_no] =
+				    ((curr_gain[core_no] & 0x0F00) >> 8);
+				target_gain.txgm[core_no] =
+				    ((curr_gain[core_no] & 0x7000) >> 12);
+			} else {
+				target_gain.ipa[core_no] =
+				    curr_gain[core_no] & 0x0003;
+				target_gain.pad[core_no] =
+				    ((curr_gain[core_no] & 0x000C) >> 2);
+				target_gain.pga[core_no] =
+				    ((curr_gain[core_no] & 0x0070) >> 4);
+				target_gain.txgm[core_no] =
+				    ((curr_gain[core_no] & 0x0380) >> 7);
+			}
+		}
+	} else {
+		base_idx[0] = (read_phy_reg(pi, 0x1ed) >> 8) & 0x7f;
+		base_idx[1] = (read_phy_reg(pi, 0x1ee) >> 8) & 0x7f;
+		for (core_no = 0; core_no < 2; core_no++) {
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				if (PHY_IPA(pi)) {
+					tx_pwrctrl_tbl =
+					    wlc_phy_get_ipa_gaintbl_nphy(pi);
+				} else {
+					if (CHSPEC_IS5G(pi->radio_chanspec)) {
+						if NREV_IS
+							(pi->pubpi.phy_rev, 3) {
+							tx_pwrctrl_tbl =
+							    nphy_tpc_5GHz_txgain_rev3;
+						} else if NREV_IS
+							(pi->pubpi.phy_rev, 4) {
+							tx_pwrctrl_tbl =
+							    (pi->srom_fem5g.
+							     extpagain ==
+							     3) ?
+							    nphy_tpc_5GHz_txgain_HiPwrEPA
+							    :
+							    nphy_tpc_5GHz_txgain_rev4;
+						} else {
+							tx_pwrctrl_tbl =
+							    nphy_tpc_5GHz_txgain_rev5;
+						}
+					} else {
+						if (NREV_GE
+						    (pi->pubpi.phy_rev, 7)) {
+							if (pi->pubpi.
+							    radiorev == 3) {
+								tx_pwrctrl_tbl =
+								    nphy_tpc_txgain_epa_2057rev3;
+							} else if (pi->pubpi.
+								   radiorev ==
+								   5) {
+								tx_pwrctrl_tbl =
+								    nphy_tpc_txgain_epa_2057rev5;
+							}
+
+						} else {
+							if (NREV_GE
+							    (pi->pubpi.phy_rev,
+							     5)
+							    && (pi->srom_fem2g.
+								extpagain ==
+								3)) {
+								tx_pwrctrl_tbl =
+								    nphy_tpc_txgain_HiPwrEPA;
+							} else {
+								tx_pwrctrl_tbl =
+								    nphy_tpc_txgain_rev3;
+							}
+						}
+					}
+				}
+				if NREV_GE
+					(pi->pubpi.phy_rev, 7) {
+					target_gain.ipa[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 16) & 0x7;
+					target_gain.pad[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 19) & 0x1f;
+					target_gain.pga[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 24) & 0xf;
+					target_gain.txgm[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 28) & 0x7;
+					target_gain.txlpf[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 31) & 0x1;
+				} else {
+					target_gain.ipa[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 16) & 0xf;
+					target_gain.pad[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 20) & 0xf;
+					target_gain.pga[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 24) & 0xf;
+					target_gain.txgm[core_no] =
+					    (tx_pwrctrl_tbl[base_idx[core_no]]
+					     >> 28) & 0x7;
+				}
+			} else {
+				target_gain.ipa[core_no] =
+				    (nphy_tpc_txgain[base_idx[core_no]] >> 16) &
+				    0x3;
+				target_gain.pad[core_no] =
+				    (nphy_tpc_txgain[base_idx[core_no]] >> 18) &
+				    0x3;
+				target_gain.pga[core_no] =
+				    (nphy_tpc_txgain[base_idx[core_no]] >> 20) &
+				    0x7;
+				target_gain.txgm[core_no] =
+				    (nphy_tpc_txgain[base_idx[core_no]] >> 23) &
+				    0x7;
+			}
+		}
+	}
+
+	return (target_gain);
+}
+
+static void
+wlc_phy_iqcal_gainparams_nphy(phy_info_t * pi, uint16 core_no,
+			      nphy_txgains_t target_gain,
+			      nphy_iqcal_params_t * params)
+{
+	uint8 k;
+	int idx;
+	uint16 gain_index;
+	uint8 band_idx = (CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			params->txlpf = target_gain.txlpf[core_no];
+		}
+		params->txgm = target_gain.txgm[core_no];
+		params->pga = target_gain.pga[core_no];
+		params->pad = target_gain.pad[core_no];
+		params->ipa = target_gain.ipa[core_no];
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			params->cal_gain =
+			    ((params->txlpf << 15) | (params->
+						      txgm << 12) | (params->
+								     pga << 8) |
+			     (params->pad << 3) | (params->ipa));
+		} else {
+			params->cal_gain =
+			    ((params->txgm << 12) | (params->
+						     pga << 8) | (params->
+								  pad << 4) |
+			     (params->ipa));
+		}
+		params->ncorr[0] = 0x79;
+		params->ncorr[1] = 0x79;
+		params->ncorr[2] = 0x79;
+		params->ncorr[3] = 0x79;
+		params->ncorr[4] = 0x79;
+	} else {
+
+		gain_index = ((target_gain.pad[core_no] << 0) |
+			      (target_gain.pga[core_no] << 4) | (target_gain.
+								 txgm[core_no]
+								 << 8));
+
+		idx = -1;
+		for (k = 0; k < NPHY_IQCAL_NUMGAINS; k++) {
+			if (tbl_iqcal_gainparams_nphy[band_idx][k][0] ==
+			    gain_index) {
+				idx = k;
+				break;
+			}
+		}
+
+		ASSERT(idx != -1);
+
+		params->txgm = tbl_iqcal_gainparams_nphy[band_idx][k][1];
+		params->pga = tbl_iqcal_gainparams_nphy[band_idx][k][2];
+		params->pad = tbl_iqcal_gainparams_nphy[band_idx][k][3];
+		params->cal_gain = ((params->txgm << 7) | (params->pga << 4) |
+				    (params->pad << 2));
+		params->ncorr[0] = tbl_iqcal_gainparams_nphy[band_idx][k][4];
+		params->ncorr[1] = tbl_iqcal_gainparams_nphy[band_idx][k][5];
+		params->ncorr[2] = tbl_iqcal_gainparams_nphy[band_idx][k][6];
+		params->ncorr[3] = tbl_iqcal_gainparams_nphy[band_idx][k][7];
+	}
+}
+
+static void wlc_phy_txcal_radio_setup_nphy(phy_info_t * pi)
+{
+	uint16 jtag_core, core;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		for (core = 0; core <= 1; core++) {
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 0] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    TX_SSI_MASTER);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 1] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    IQCAL_VCM_HG);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 2] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    IQCAL_IDAC);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 3] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core, TSSI_VCM);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 4] = 0;
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 5] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    TX_SSI_MUX);
+
+			if (pi->pubpi.radiorev != 5)
+				pi->tx_rx_cal_radio_saveregs[(core * 11) + 6] =
+				    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+						    TSSIA);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 7] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core, TSSIG);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 8] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    TSSI_MISC1);
+
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TX_SSI_MASTER, 0x0a);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 IQCAL_VCM_HG, 0x43);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 IQCAL_IDAC, 0x55);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TSSI_VCM, 0x00);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TSSIG, 0x00);
+				if (pi->use_int_tx_iqlo_cal_nphy) {
+					WRITE_RADIO_REG3(pi, RADIO_2057, TX,
+							 core, TX_SSI_MUX, 0x4);
+					if (!
+					    (pi->
+					     internal_tx_iqlo_cal_tapoff_intpa_nphy))
+					{
+
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TSSIA, 0x31);
+					} else {
+
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TSSIA, 0x21);
+					}
+				}
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TSSI_MISC1, 0x00);
+			} else {
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TX_SSI_MASTER, 0x06);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 IQCAL_VCM_HG, 0x43);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 IQCAL_IDAC, 0x55);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TSSI_VCM, 0x00);
+
+				if (pi->pubpi.radiorev != 5)
+					WRITE_RADIO_REG3(pi, RADIO_2057, TX,
+							 core, TSSIA, 0x00);
+				if (pi->use_int_tx_iqlo_cal_nphy) {
+					WRITE_RADIO_REG3(pi, RADIO_2057, TX,
+							 core, TX_SSI_MUX,
+							 0x06);
+					if (!
+					    (pi->
+					     internal_tx_iqlo_cal_tapoff_intpa_nphy))
+					{
+
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TSSIG, 0x31);
+					} else {
+
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TSSIG, 0x21);
+					}
+				}
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TSSI_MISC1, 0x00);
+			}
+		}
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+		for (core = 0; core <= 1; core++) {
+			jtag_core =
+			    (core ==
+			     PHY_CORE_0) ? RADIO_2056_TX0 : RADIO_2056_TX1;
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 0] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_TX_SSI_MASTER |
+					   jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 1] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_IQCAL_VCM_HG |
+					   jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 2] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_IQCAL_IDAC |
+					   jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 3] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_TSSI_VCM | jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 4] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_TX_AMP_DET |
+					   jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 5] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_TX_SSI_MUX |
+					   jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 6] =
+			    read_radio_reg(pi, RADIO_2056_TX_TSSIA | jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 7] =
+			    read_radio_reg(pi, RADIO_2056_TX_TSSIG | jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 8] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_TSSI_MISC1 |
+					   jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 9] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_TSSI_MISC2 |
+					   jtag_core);
+
+			pi->tx_rx_cal_radio_saveregs[(core * 11) + 10] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_TSSI_MISC3 |
+					   jtag_core);
+
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				write_radio_reg(pi,
+						RADIO_2056_TX_TX_SSI_MASTER |
+						jtag_core, 0x0a);
+				write_radio_reg(pi,
+						RADIO_2056_TX_IQCAL_VCM_HG |
+						jtag_core, 0x40);
+				write_radio_reg(pi,
+						RADIO_2056_TX_IQCAL_IDAC |
+						jtag_core, 0x55);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_VCM |
+						jtag_core, 0x00);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TX_AMP_DET |
+						jtag_core, 0x00);
+
+				if (PHY_IPA(pi)) {
+					write_radio_reg(pi,
+							RADIO_2056_TX_TX_SSI_MUX
+							| jtag_core, 0x4);
+					write_radio_reg(pi,
+							RADIO_2056_TX_TSSIA |
+							jtag_core, 0x1);
+				} else {
+					write_radio_reg(pi,
+							RADIO_2056_TX_TX_SSI_MUX
+							| jtag_core, 0x00);
+					write_radio_reg(pi,
+							RADIO_2056_TX_TSSIA |
+							jtag_core, 0x2f);
+				}
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSIG | jtag_core,
+						0x00);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_MISC1 |
+						jtag_core, 0x00);
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_MISC2 |
+						jtag_core, 0x00);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_MISC3 |
+						jtag_core, 0x00);
+			} else {
+				write_radio_reg(pi,
+						RADIO_2056_TX_TX_SSI_MASTER |
+						jtag_core, 0x06);
+				write_radio_reg(pi,
+						RADIO_2056_TX_IQCAL_VCM_HG |
+						jtag_core, 0x40);
+				write_radio_reg(pi,
+						RADIO_2056_TX_IQCAL_IDAC |
+						jtag_core, 0x55);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_VCM |
+						jtag_core, 0x00);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TX_AMP_DET |
+						jtag_core, 0x00);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSIA | jtag_core,
+						0x00);
+
+				if (PHY_IPA(pi)) {
+
+					write_radio_reg(pi,
+							RADIO_2056_TX_TX_SSI_MUX
+							| jtag_core, 0x06);
+					if (NREV_LT(pi->pubpi.phy_rev, 5)) {
+
+						write_radio_reg(pi,
+								RADIO_2056_TX_TSSIG
+								| jtag_core,
+								0x11);
+					} else {
+
+						write_radio_reg(pi,
+								RADIO_2056_TX_TSSIG
+								| jtag_core,
+								0x1);
+					}
+				} else {
+					write_radio_reg(pi,
+							RADIO_2056_TX_TX_SSI_MUX
+							| jtag_core, 0x00);
+					write_radio_reg(pi,
+							RADIO_2056_TX_TSSIG |
+							jtag_core, 0x20);
+				}
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_MISC1 |
+						jtag_core, 0x00);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_MISC2 |
+						jtag_core, 0x00);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TSSI_MISC3 |
+						jtag_core, 0x00);
+			}
+		}
+	} else {
+
+		pi->tx_rx_cal_radio_saveregs[0] =
+		    read_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL1);
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL1, 0x29);
+		pi->tx_rx_cal_radio_saveregs[1] =
+		    read_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL2);
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL2, 0x54);
+
+		pi->tx_rx_cal_radio_saveregs[2] =
+		    read_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL1);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL1, 0x29);
+		pi->tx_rx_cal_radio_saveregs[3] =
+		    read_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL2);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL2, 0x54);
+
+		pi->tx_rx_cal_radio_saveregs[4] =
+		    read_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE1);
+		pi->tx_rx_cal_radio_saveregs[5] =
+		    read_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE2);
+
+		if ((read_phy_reg(pi, 0x09) & NPHY_BandControl_currentBand) ==
+		    0) {
+
+			write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE1, 0x04);
+			write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE2, 0x04);
+		} else {
+
+			write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE1, 0x20);
+			write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE2, 0x20);
+		}
+
+		if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+
+			or_radio_reg(pi, RADIO_2055_CORE1_TX_BB_MXGM, 0x20);
+			or_radio_reg(pi, RADIO_2055_CORE2_TX_BB_MXGM, 0x20);
+		} else {
+
+			and_radio_reg(pi, RADIO_2055_CORE1_TX_BB_MXGM, 0xdf);
+			and_radio_reg(pi, RADIO_2055_CORE2_TX_BB_MXGM, 0xdf);
+		}
+	}
+}
+
+static void wlc_phy_txcal_radio_cleanup_nphy(phy_info_t * pi)
+{
+	uint16 jtag_core, core;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		for (core = 0; core <= 1; core++) {
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+					 TX_SSI_MASTER,
+					 pi->
+					 tx_rx_cal_radio_saveregs[(core * 11) +
+								  0]);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, IQCAL_VCM_HG,
+					 pi->
+					 tx_rx_cal_radio_saveregs[(core * 11) +
+								  1]);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, IQCAL_IDAC,
+					 pi->
+					 tx_rx_cal_radio_saveregs[(core * 11) +
+								  2]);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, TSSI_VCM,
+					 pi->
+					 tx_rx_cal_radio_saveregs[(core * 11) +
+								  3]);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, TX_SSI_MUX,
+					 pi->
+					 tx_rx_cal_radio_saveregs[(core * 11) +
+								  5]);
+
+			if (pi->pubpi.radiorev != 5)
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TSSIA,
+						 pi->
+						 tx_rx_cal_radio_saveregs[(core
+									   *
+									   11) +
+									  6]);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, TSSIG,
+					 pi->
+					 tx_rx_cal_radio_saveregs[(core * 11) +
+								  7]);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, TSSI_MISC1,
+					 pi->
+					 tx_rx_cal_radio_saveregs[(core * 11) +
+								  8]);
+		}
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		for (core = 0; core <= 1; core++) {
+			jtag_core =
+			    (core ==
+			     PHY_CORE_0) ? RADIO_2056_TX0 : RADIO_2056_TX1;
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_TX_SSI_MASTER | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 0]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_IQCAL_VCM_HG | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 1]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_IQCAL_IDAC | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 2]);
+
+			write_radio_reg(pi, RADIO_2056_TX_TSSI_VCM | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 3]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_TX_AMP_DET | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 4]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_TX_SSI_MUX | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 5]);
+
+			write_radio_reg(pi, RADIO_2056_TX_TSSIA | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 6]);
+
+			write_radio_reg(pi, RADIO_2056_TX_TSSIG | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 7]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_TSSI_MISC1 | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 8]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_TSSI_MISC2 | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 9]);
+
+			write_radio_reg(pi,
+					RADIO_2056_TX_TSSI_MISC3 | jtag_core,
+					pi->
+					tx_rx_cal_radio_saveregs[(core * 11) +
+								 10]);
+		}
+	} else {
+
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL1,
+				pi->tx_rx_cal_radio_saveregs[0]);
+		write_radio_reg(pi, RADIO_2055_CORE1_TXRF_IQCAL2,
+				pi->tx_rx_cal_radio_saveregs[1]);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL1,
+				pi->tx_rx_cal_radio_saveregs[2]);
+		write_radio_reg(pi, RADIO_2055_CORE2_TXRF_IQCAL2,
+				pi->tx_rx_cal_radio_saveregs[3]);
+		write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE1,
+				pi->tx_rx_cal_radio_saveregs[4]);
+		write_radio_reg(pi, RADIO_2055_PWRDET_RXTX_CORE2,
+				pi->tx_rx_cal_radio_saveregs[5]);
+	}
+}
+
+static void wlc_phy_txcal_physetup_nphy(phy_info_t * pi)
+{
+	uint16 val, mask;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		pi->tx_rx_cal_phy_saveregs[0] = read_phy_reg(pi, 0xa6);
+		pi->tx_rx_cal_phy_saveregs[1] = read_phy_reg(pi, 0xa7);
+
+		mask = ((0x3 << 8) | (0x3 << 10));
+		val = (0x2 << 8);
+		val |= (0x2 << 10);
+		mod_phy_reg(pi, 0xa6, mask, val);
+		mod_phy_reg(pi, 0xa7, mask, val);
+
+		val = read_phy_reg(pi, 0x8f);
+		pi->tx_rx_cal_phy_saveregs[2] = val;
+		val |= ((0x1 << 9) | (0x1 << 10));
+		write_phy_reg(pi, 0x8f, val);
+
+		val = read_phy_reg(pi, 0xa5);
+		pi->tx_rx_cal_phy_saveregs[3] = val;
+		val |= ((0x1 << 9) | (0x1 << 10));
+		write_phy_reg(pi, 0xa5, val);
+
+		pi->tx_rx_cal_phy_saveregs[4] = read_phy_reg(pi, 0x01);
+		mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 3, 16,
+					&val);
+		pi->tx_rx_cal_phy_saveregs[5] = val;
+		val = 0;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 3, 16,
+					 &val);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 19, 16,
+					&val);
+		pi->tx_rx_cal_phy_saveregs[6] = val;
+		val = 0;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 19, 16,
+					 &val);
+
+		pi->tx_rx_cal_phy_saveregs[7] = read_phy_reg(pi, 0x91);
+		pi->tx_rx_cal_phy_saveregs[8] = read_phy_reg(pi, 0x92);
+
+		if (!(pi->use_int_tx_iqlo_cal_nphy)) {
+
+			wlc_phy_rfctrlintc_override_nphy(pi,
+							 NPHY_RfctrlIntc_override_PA,
+							 1,
+							 RADIO_MIMO_CORESEL_CORE1
+							 |
+							 RADIO_MIMO_CORESEL_CORE2);
+		} else {
+
+			wlc_phy_rfctrlintc_override_nphy(pi,
+							 NPHY_RfctrlIntc_override_PA,
+							 0,
+							 RADIO_MIMO_CORESEL_CORE1
+							 |
+							 RADIO_MIMO_CORESEL_CORE2);
+		}
+
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 0x2, RADIO_MIMO_CORESEL_CORE1);
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 0x8, RADIO_MIMO_CORESEL_CORE2);
+
+		pi->tx_rx_cal_phy_saveregs[9] = read_phy_reg(pi, 0x297);
+		pi->tx_rx_cal_phy_saveregs[10] = read_phy_reg(pi, 0x29b);
+		mod_phy_reg(pi, (0 == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (0) << 0);
+
+		mod_phy_reg(pi, (1 == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (0) << 0);
+
+		if (NREV_IS(pi->pubpi.phy_rev, 7)
+		    || NREV_GE(pi->pubpi.phy_rev, 8)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 7),
+							  wlc_phy_read_lpf_bw_ctl_nphy
+							  (pi, 0), 0, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		}
+
+		if (pi->use_int_tx_iqlo_cal_nphy
+		    && !(pi->internal_tx_iqlo_cal_tapoff_intpa_nphy)) {
+
+			if (NREV_IS(pi->pubpi.phy_rev, 7)) {
+
+				mod_radio_reg(pi, RADIO_2057_OVR_REG0, 1 << 4,
+					      1 << 4);
+
+				if (CHSPEC_IS2G(pi->radio_chanspec)) {
+					mod_radio_reg(pi,
+						      RADIO_2057_PAD2G_TUNE_PUS_CORE0,
+						      1, 0);
+					mod_radio_reg(pi,
+						      RADIO_2057_PAD2G_TUNE_PUS_CORE1,
+						      1, 0);
+				} else {
+					mod_radio_reg(pi,
+						      RADIO_2057_IPA5G_CASCOFFV_PU_CORE0,
+						      1, 0);
+					mod_radio_reg(pi,
+						      RADIO_2057_IPA5G_CASCOFFV_PU_CORE1,
+						      1, 0);
+				}
+			} else if (NREV_GE(pi->pubpi.phy_rev, 8)) {
+				wlc_phy_rfctrl_override_nphy_rev7(pi,
+								  (0x1 << 3), 0,
+								  0x3, 0,
+								  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			}
+		}
+	} else {
+		pi->tx_rx_cal_phy_saveregs[0] = read_phy_reg(pi, 0xa6);
+		pi->tx_rx_cal_phy_saveregs[1] = read_phy_reg(pi, 0xa7);
+
+		mask = ((0x3 << 12) | (0x3 << 14));
+		val = (0x2 << 12);
+		val |= (0x2 << 14);
+		mod_phy_reg(pi, 0xa6, mask, val);
+		mod_phy_reg(pi, 0xa7, mask, val);
+
+		val = read_phy_reg(pi, 0xa5);
+		pi->tx_rx_cal_phy_saveregs[2] = val;
+		val |= ((0x1 << 12) | (0x1 << 13));
+		write_phy_reg(pi, 0xa5, val);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 2, 16,
+					&val);
+		pi->tx_rx_cal_phy_saveregs[3] = val;
+		val |= 0x2000;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 2, 16,
+					 &val);
+
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 18, 16,
+					&val);
+		pi->tx_rx_cal_phy_saveregs[4] = val;
+		val |= 0x2000;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 18, 16,
+					 &val);
+
+		pi->tx_rx_cal_phy_saveregs[5] = read_phy_reg(pi, 0x91);
+		pi->tx_rx_cal_phy_saveregs[6] = read_phy_reg(pi, 0x92);
+		val = CHSPEC_IS5G(pi->radio_chanspec) ? 0x180 : 0x120;
+		write_phy_reg(pi, 0x91, val);
+		write_phy_reg(pi, 0x92, val);
+	}
+}
+
+static void wlc_phy_txcal_phycleanup_nphy(phy_info_t * pi)
+{
+	uint16 mask;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		write_phy_reg(pi, 0xa6, pi->tx_rx_cal_phy_saveregs[0]);
+		write_phy_reg(pi, 0xa7, pi->tx_rx_cal_phy_saveregs[1]);
+		write_phy_reg(pi, 0x8f, pi->tx_rx_cal_phy_saveregs[2]);
+		write_phy_reg(pi, 0xa5, pi->tx_rx_cal_phy_saveregs[3]);
+		write_phy_reg(pi, 0x01, pi->tx_rx_cal_phy_saveregs[4]);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 3, 16,
+					 &pi->tx_rx_cal_phy_saveregs[5]);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 19, 16,
+					 &pi->tx_rx_cal_phy_saveregs[6]);
+
+		write_phy_reg(pi, 0x91, pi->tx_rx_cal_phy_saveregs[7]);
+		write_phy_reg(pi, 0x92, pi->tx_rx_cal_phy_saveregs[8]);
+
+		write_phy_reg(pi, 0x297, pi->tx_rx_cal_phy_saveregs[9]);
+		write_phy_reg(pi, 0x29b, pi->tx_rx_cal_phy_saveregs[10]);
+
+		if (NREV_IS(pi->pubpi.phy_rev, 7)
+		    || NREV_GE(pi->pubpi.phy_rev, 8)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 7), 0, 0,
+							  1,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		}
+
+		wlc_phy_resetcca_nphy(pi);
+
+		if (pi->use_int_tx_iqlo_cal_nphy
+		    && !(pi->internal_tx_iqlo_cal_tapoff_intpa_nphy)) {
+
+			if (NREV_IS(pi->pubpi.phy_rev, 7)) {
+				if (CHSPEC_IS2G(pi->radio_chanspec)) {
+					mod_radio_reg(pi,
+						      RADIO_2057_PAD2G_TUNE_PUS_CORE0,
+						      1, 1);
+					mod_radio_reg(pi,
+						      RADIO_2057_PAD2G_TUNE_PUS_CORE1,
+						      1, 1);
+				} else {
+					mod_radio_reg(pi,
+						      RADIO_2057_IPA5G_CASCOFFV_PU_CORE0,
+						      1, 1);
+					mod_radio_reg(pi,
+						      RADIO_2057_IPA5G_CASCOFFV_PU_CORE1,
+						      1, 1);
+				}
+
+				mod_radio_reg(pi, RADIO_2057_OVR_REG0, 1 << 4,
+					      0);
+			} else if (NREV_GE(pi->pubpi.phy_rev, 8)) {
+				wlc_phy_rfctrl_override_nphy_rev7(pi,
+								  (0x1 << 3), 0,
+								  0x3, 1,
+								  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+			}
+		}
+	} else {
+		mask = ((0x3 << 12) | (0x3 << 14));
+		mod_phy_reg(pi, 0xa6, mask, pi->tx_rx_cal_phy_saveregs[0]);
+		mod_phy_reg(pi, 0xa7, mask, pi->tx_rx_cal_phy_saveregs[1]);
+		write_phy_reg(pi, 0xa5, pi->tx_rx_cal_phy_saveregs[2]);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 2, 16,
+					 &pi->tx_rx_cal_phy_saveregs[3]);
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_AFECTRL, 1, 18, 16,
+					 &pi->tx_rx_cal_phy_saveregs[4]);
+
+		write_phy_reg(pi, 0x91, pi->tx_rx_cal_phy_saveregs[5]);
+		write_phy_reg(pi, 0x92, pi->tx_rx_cal_phy_saveregs[6]);
+	}
+}
+
+#define NPHY_CAL_TSSISAMPS	64
+#define NPHY_TEST_TONE_FREQ_40MHz 4000
+#define NPHY_TEST_TONE_FREQ_20MHz 2500
+
+void
+wlc_phy_est_tonepwr_nphy(phy_info_t * pi, int32 * qdBm_pwrbuf, uint8 num_samps)
+{
+	uint16 tssi_reg;
+	int32 temp, pwrindex[2];
+	int32 idle_tssi[2];
+	int32 rssi_buf[4];
+	int32 tssival[2];
+	uint8 tssi_type;
+
+	tssi_reg = read_phy_reg(pi, 0x1e9);
+
+	temp = (int32) (tssi_reg & 0x3f);
+	idle_tssi[0] = (temp <= 31) ? temp : (temp - 64);
+
+	temp = (int32) ((tssi_reg >> 8) & 0x3f);
+	idle_tssi[1] = (temp <= 31) ? temp : (temp - 64);
+
+	tssi_type =
+	    CHSPEC_IS5G(pi->radio_chanspec) ?
+	    (uint8) NPHY_RSSI_SEL_TSSI_5G : (uint8) NPHY_RSSI_SEL_TSSI_2G;
+
+	wlc_phy_poll_rssi_nphy(pi, tssi_type, rssi_buf, num_samps);
+
+	tssival[0] = rssi_buf[0] / ((int32) num_samps);
+	tssival[1] = rssi_buf[2] / ((int32) num_samps);
+
+	pwrindex[0] = idle_tssi[0] - tssival[0] + 64;
+	pwrindex[1] = idle_tssi[1] - tssival[1] + 64;
+
+	if (pwrindex[0] < 0) {
+		pwrindex[0] = 0;
+	} else if (pwrindex[0] > 63) {
+		pwrindex[0] = 63;
+	}
+
+	if (pwrindex[1] < 0) {
+		pwrindex[1] = 0;
+	} else if (pwrindex[1] > 63) {
+		pwrindex[1] = 63;
+	}
+
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CORE1TXPWRCTL, 1,
+				(uint32) pwrindex[0], 32, &qdBm_pwrbuf[0]);
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 1,
+				(uint32) pwrindex[1], 32, &qdBm_pwrbuf[1]);
+}
+
+static void wlc_phy_internal_cal_txgain_nphy(phy_info_t * pi)
+{
+	uint16 txcal_gain[2];
+
+	pi->nphy_txcal_pwr_idx[0] = pi->nphy_cal_orig_pwr_idx[0];
+	pi->nphy_txcal_pwr_idx[1] = pi->nphy_cal_orig_pwr_idx[0];
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], TRUE);
+
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
+				txcal_gain);
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+		txcal_gain[0] = (txcal_gain[0] & 0xF000) | 0x0F40;
+		txcal_gain[1] = (txcal_gain[1] & 0xF000) | 0x0F40;
+	} else {
+		txcal_gain[0] = (txcal_gain[0] & 0xF000) | 0x0F60;
+		txcal_gain[1] = (txcal_gain[1] & 0xF000) | 0x0F60;
+	}
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
+				 txcal_gain);
+}
+
+static void wlc_phy_precal_txgain_nphy(phy_info_t * pi)
+{
+	bool save_bbmult = FALSE;
+	uint8 txcal_index_2057_rev5n7 = 0;
+	uint8 txcal_index_2057_rev3n4n6 = 10;
+
+	if (pi->use_int_tx_iqlo_cal_nphy) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			if ((pi->pubpi.radiorev == 3) ||
+			    (pi->pubpi.radiorev == 4) ||
+			    (pi->pubpi.radiorev == 6)) {
+
+				pi->nphy_txcal_pwr_idx[0] =
+				    txcal_index_2057_rev3n4n6;
+				pi->nphy_txcal_pwr_idx[1] =
+				    txcal_index_2057_rev3n4n6;
+				wlc_phy_txpwr_index_nphy(pi, 3,
+							 txcal_index_2057_rev3n4n6,
+							 FALSE);
+			} else {
+
+				pi->nphy_txcal_pwr_idx[0] =
+				    txcal_index_2057_rev5n7;
+				pi->nphy_txcal_pwr_idx[1] =
+				    txcal_index_2057_rev5n7;
+				wlc_phy_txpwr_index_nphy(pi, 3,
+							 txcal_index_2057_rev5n7,
+							 FALSE);
+			}
+			save_bbmult = TRUE;
+
+		} else if (NREV_LT(pi->pubpi.phy_rev, 5)) {
+			wlc_phy_cal_txgainctrl_nphy(pi, 11, FALSE);
+			if (pi->sh->hw_phytxchain != 3) {
+				pi->nphy_txcal_pwr_idx[1] =
+				    pi->nphy_txcal_pwr_idx[0];
+				wlc_phy_txpwr_index_nphy(pi, 3,
+							 pi->
+							 nphy_txcal_pwr_idx[0],
+							 TRUE);
+				save_bbmult = TRUE;
+			}
+
+		} else if (NREV_IS(pi->pubpi.phy_rev, 5)) {
+			if (PHY_IPA(pi)) {
+				if (CHSPEC_IS2G(pi->radio_chanspec)) {
+					wlc_phy_cal_txgainctrl_nphy(pi, 12,
+								    FALSE);
+				} else {
+					pi->nphy_txcal_pwr_idx[0] = 80;
+					pi->nphy_txcal_pwr_idx[1] = 80;
+					wlc_phy_txpwr_index_nphy(pi, 3, 80,
+								 FALSE);
+					save_bbmult = TRUE;
+				}
+			} else {
+
+				wlc_phy_internal_cal_txgain_nphy(pi);
+				save_bbmult = TRUE;
+			}
+
+		} else if (NREV_IS(pi->pubpi.phy_rev, 6)) {
+			if (PHY_IPA(pi)) {
+				if (CHSPEC_IS2G(pi->radio_chanspec)) {
+					wlc_phy_cal_txgainctrl_nphy(pi, 12,
+								    FALSE);
+				} else {
+					wlc_phy_cal_txgainctrl_nphy(pi, 14,
+								    FALSE);
+				}
+			} else {
+
+				wlc_phy_internal_cal_txgain_nphy(pi);
+				save_bbmult = TRUE;
+			}
+		}
+
+	} else {
+		wlc_phy_cal_txgainctrl_nphy(pi, 10, FALSE);
+	}
+
+	if (save_bbmult) {
+		wlc_phy_table_read_nphy(pi, 15, 1, 87, 16,
+					&pi->nphy_txcal_bbmult);
+	}
+}
+
+void
+wlc_phy_cal_txgainctrl_nphy(phy_info_t * pi, int32 dBm_targetpower, bool debug)
+{
+	int gainctrl_loopidx;
+	uint core;
+	uint16 m0m1, curr_m0m1;
+	int32 delta_power;
+	int32 txpwrindex;
+	int32 qdBm_power[2];
+	uint16 orig_BBConfig;
+	uint16 phy_saveregs[4];
+	uint32 freq_test;
+	uint16 ampl_test = 250;
+	uint stepsize;
+	bool phyhang_avoid_state = FALSE;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		stepsize = 2;
+	} else {
+
+		stepsize = 1;
+	}
+
+	if (CHSPEC_IS40(pi->radio_chanspec)) {
+		freq_test = 5000;
+	} else {
+		freq_test = 2500;
+	}
+
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_cal_orig_pwr_idx[0], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_cal_orig_pwr_idx[1], TRUE);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	phyhang_avoid_state = pi->phyhang_avoid;
+	pi->phyhang_avoid = FALSE;
+
+	phy_saveregs[0] = read_phy_reg(pi, 0x91);
+	phy_saveregs[1] = read_phy_reg(pi, 0x92);
+	phy_saveregs[2] = read_phy_reg(pi, 0xe7);
+	phy_saveregs[3] = read_phy_reg(pi, 0xec);
+	wlc_phy_rfctrlintc_override_nphy(pi, NPHY_RfctrlIntc_override_PA, 1,
+					 RADIO_MIMO_CORESEL_CORE1 |
+					 RADIO_MIMO_CORESEL_CORE2);
+
+	if (!debug) {
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 0x2, RADIO_MIMO_CORESEL_CORE1);
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 0x8, RADIO_MIMO_CORESEL_CORE2);
+	} else {
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 0x1, RADIO_MIMO_CORESEL_CORE1);
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 0x7, RADIO_MIMO_CORESEL_CORE2);
+	}
+
+	orig_BBConfig = read_phy_reg(pi, 0x01);
+	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
+
+	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+		txpwrindex = (int32) pi->nphy_cal_orig_pwr_idx[core];
+
+		for (gainctrl_loopidx = 0; gainctrl_loopidx < 2;
+		     gainctrl_loopidx++) {
+			wlc_phy_tx_tone_nphy(pi, freq_test, ampl_test, 0, 0,
+					     FALSE);
+
+			if (core == PHY_CORE_0) {
+				curr_m0m1 = m0m1 & 0xff00;
+			} else {
+				curr_m0m1 = m0m1 & 0x00ff;
+			}
+
+			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &curr_m0m1);
+			wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &curr_m0m1);
+
+			OSL_DELAY(50);
+
+			wlc_phy_est_tonepwr_nphy(pi, qdBm_power,
+						 NPHY_CAL_TSSISAMPS);
+
+			pi->nphy_bb_mult_save = 0;
+			wlc_phy_stopplayback_nphy(pi);
+
+			delta_power = (dBm_targetpower * 4) - qdBm_power[core];
+
+			txpwrindex -= stepsize * delta_power;
+			if (txpwrindex < 0) {
+				txpwrindex = 0;
+			} else if (txpwrindex > 127) {
+				txpwrindex = 127;
+			}
+
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				if (NREV_IS(pi->pubpi.phy_rev, 4) &&
+				    (pi->srom_fem5g.extpagain == 3)) {
+					if (txpwrindex < 30) {
+						txpwrindex = 30;
+					}
+				}
+			} else {
+				if (NREV_GE(pi->pubpi.phy_rev, 5) &&
+				    (pi->srom_fem2g.extpagain == 3)) {
+					if (txpwrindex < 50) {
+						txpwrindex = 50;
+					}
+				}
+			}
+
+			wlc_phy_txpwr_index_nphy(pi, (1 << core),
+						 (uint8) txpwrindex, TRUE);
+		}
+
+		pi->nphy_txcal_pwr_idx[core] = (uint8) txpwrindex;
+
+		if (debug) {
+			uint16 radio_gain;
+			uint16 dbg_m0m1;
+
+			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &dbg_m0m1);
+
+			wlc_phy_tx_tone_nphy(pi, freq_test, ampl_test, 0, 0,
+					     FALSE);
+
+			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &dbg_m0m1);
+			wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &dbg_m0m1);
+
+			OSL_DELAY(100);
+
+			wlc_phy_est_tonepwr_nphy(pi, qdBm_power,
+						 NPHY_CAL_TSSISAMPS);
+
+			wlc_phy_table_read_nphy(pi, 7, 1, (0x110 + core), 16,
+						&radio_gain);
+
+			OSL_DELAY(4000000);
+			pi->nphy_bb_mult_save = 0;
+			wlc_phy_stopplayback_nphy(pi);
+		}
+	}
+
+	wlc_phy_txpwr_index_nphy(pi, 1, pi->nphy_txcal_pwr_idx[0], TRUE);
+	wlc_phy_txpwr_index_nphy(pi, 2, pi->nphy_txcal_pwr_idx[1], TRUE);
+
+	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &pi->nphy_txcal_bbmult);
+
+	write_phy_reg(pi, 0x01, orig_BBConfig);
+
+	write_phy_reg(pi, 0x91, phy_saveregs[0]);
+	write_phy_reg(pi, 0x92, phy_saveregs[1]);
+	write_phy_reg(pi, 0xe7, phy_saveregs[2]);
+	write_phy_reg(pi, 0xec, phy_saveregs[3]);
+
+	pi->phyhang_avoid = phyhang_avoid_state;
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static void wlc_phy_update_txcal_ladder_nphy(phy_info_t * pi, uint16 core)
+{
+	int index;
+	uint32 bbmult_scale;
+	uint16 bbmult;
+	uint16 tblentry;
+
+	nphy_txiqcal_ladder_t ladder_lo[] = {
+		{3, 0}, {4, 0}, {6, 0}, {9, 0}, {13, 0}, {18, 0},
+		{25, 0}, {25, 1}, {25, 2}, {25, 3}, {25, 4}, {25, 5},
+		{25, 6}, {25, 7}, {35, 7}, {50, 7}, {71, 7}, {100, 7}
+	};
+
+	nphy_txiqcal_ladder_t ladder_iq[] = {
+		{3, 0}, {4, 0}, {6, 0}, {9, 0}, {13, 0}, {18, 0},
+		{25, 0}, {35, 0}, {50, 0}, {71, 0}, {100, 0}, {100, 1},
+		{100, 2}, {100, 3}, {100, 4}, {100, 5}, {100, 6}, {100, 7}
+	};
+
+	bbmult = (core == PHY_CORE_0) ?
+	    ((pi->nphy_txcal_bbmult >> 8) & 0xff) : (pi->
+						     nphy_txcal_bbmult & 0xff);
+
+	for (index = 0; index < 18; index++) {
+		bbmult_scale = ladder_lo[index].percent * bbmult;
+		bbmult_scale /= 100;
+
+		tblentry =
+		    ((bbmult_scale & 0xff) << 8) | ladder_lo[index].g_env;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 1, index, 16,
+					 &tblentry);
+
+		bbmult_scale = ladder_iq[index].percent * bbmult;
+		bbmult_scale /= 100;
+
+		tblentry =
+		    ((bbmult_scale & 0xff) << 8) | ladder_iq[index].g_env;
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 1, index + 32,
+					 16, &tblentry);
+	}
+}
+
+void wlc_phy_cal_perical_nphy_run(phy_info_t * pi, uint8 caltype)
+{
+	nphy_txgains_t target_gain;
+	uint8 tx_pwr_ctrl_state;
+	bool fullcal = TRUE;
+	bool restore_tx_gain = FALSE;
+	bool mphase;
+
+	if (NORADIO_ENAB(pi->pubpi)) {
+		wlc_phy_cal_perical_mphase_reset(pi);
+		return;
+	}
+
+	if (PHY_MUTED(pi))
+		return;
+
+	ASSERT(pi->nphy_perical != PHY_PERICAL_DISABLE);
+
+	if (caltype == PHY_PERICAL_AUTO)
+		fullcal = (pi->radio_chanspec != pi->nphy_txiqlocal_chanspec);
+	else if (caltype == PHY_PERICAL_PARTIAL)
+		fullcal = FALSE;
+
+	if (pi->cal_type_override != PHY_PERICAL_AUTO) {
+		fullcal =
+		    (pi->cal_type_override == PHY_PERICAL_FULL) ? TRUE : FALSE;
+	}
+
+	if ((pi->mphase_cal_phase_id > MPHASE_CAL_STATE_INIT)) {
+		if (pi->nphy_txiqlocal_chanspec != pi->radio_chanspec)
+			wlc_phy_cal_perical_mphase_restart(pi);
+	}
+
+	if ((pi->mphase_cal_phase_id == MPHASE_CAL_STATE_RXCAL)) {
+		wlapi_bmac_write_shm(pi->sh->physhim, M_CTS_DURATION, 10000);
+	}
+
+	wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+	wlc_phyreg_enter((wlc_phy_t *) pi);
+
+	if ((pi->mphase_cal_phase_id == MPHASE_CAL_STATE_IDLE) ||
+	    (pi->mphase_cal_phase_id == MPHASE_CAL_STATE_INIT)) {
+		pi->nphy_cal_orig_pwr_idx[0] =
+		    (uint8) ((read_phy_reg(pi, 0x1ed) >> 8) & 0x7f);
+		pi->nphy_cal_orig_pwr_idx[1] =
+		    (uint8) ((read_phy_reg(pi, 0x1ee) >> 8) & 0x7f);
+
+		if (pi->nphy_txpwrctrl != PHY_TPC_HW_OFF) {
+			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2,
+						0x110, 16,
+						pi->nphy_cal_orig_tx_gain);
+		} else {
+			pi->nphy_cal_orig_tx_gain[0] = 0;
+			pi->nphy_cal_orig_tx_gain[1] = 0;
+		}
+	}
+	target_gain = wlc_phy_get_tx_gain_nphy(pi);
+	tx_pwr_ctrl_state = pi->nphy_txpwrctrl;
+	wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
+
+	if (pi->antsel_type == ANTSEL_2x3)
+		wlc_phy_antsel_init((wlc_phy_t *) pi, TRUE);
+
+	mphase = (pi->mphase_cal_phase_id != MPHASE_CAL_STATE_IDLE);
+	if (!mphase) {
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			wlc_phy_precal_txgain_nphy(pi);
+			pi->nphy_cal_target_gain = wlc_phy_get_tx_gain_nphy(pi);
+			restore_tx_gain = TRUE;
+
+			target_gain = pi->nphy_cal_target_gain;
+		}
+		if (BCME_OK ==
+		    wlc_phy_cal_txiqlo_nphy(pi, target_gain, fullcal, mphase)) {
+			if (PHY_IPA(pi))
+				wlc_phy_a4(pi, TRUE);
+
+			wlc_phyreg_exit((wlc_phy_t *) pi);
+			wlapi_enable_mac(pi->sh->physhim);
+			wlapi_bmac_write_shm(pi->sh->physhim, M_CTS_DURATION,
+					     10000);
+			wlapi_suspend_mac_and_wait(pi->sh->physhim);
+			wlc_phyreg_enter((wlc_phy_t *) pi);
+
+			if (BCME_OK == wlc_phy_cal_rxiq_nphy(pi, target_gain,
+							     (pi->
+							      first_cal_after_assoc
+							      || (pi->
+								  cal_type_override
+								  ==
+								  PHY_PERICAL_FULL))
+							     ? 2 : 0, FALSE)) {
+				wlc_phy_savecal_nphy(pi);
+
+				wlc_phy_txpwrctrl_coeff_setup_nphy(pi);
+
+				pi->nphy_perical_last = pi->sh->now;
+			}
+		}
+		if (caltype != PHY_PERICAL_AUTO) {
+			wlc_phy_rssi_cal_nphy(pi);
+		}
+
+		if (pi->first_cal_after_assoc
+		    || (pi->cal_type_override == PHY_PERICAL_FULL)) {
+			pi->first_cal_after_assoc = FALSE;
+			wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
+			wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			wlc_phy_radio205x_vcocal_nphy(pi);
+		}
+	} else {
+		ASSERT(pi->nphy_perical >= PHY_PERICAL_MPHASE);
+
+		switch (pi->mphase_cal_phase_id) {
+		case MPHASE_CAL_STATE_INIT:
+			pi->nphy_perical_last = pi->sh->now;
+			pi->nphy_txiqlocal_chanspec = pi->radio_chanspec;
+
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				wlc_phy_precal_txgain_nphy(pi);
+			}
+			pi->nphy_cal_target_gain = wlc_phy_get_tx_gain_nphy(pi);
+			pi->mphase_cal_phase_id++;
+			break;
+
+		case MPHASE_CAL_STATE_TXPHASE0:
+		case MPHASE_CAL_STATE_TXPHASE1:
+		case MPHASE_CAL_STATE_TXPHASE2:
+		case MPHASE_CAL_STATE_TXPHASE3:
+		case MPHASE_CAL_STATE_TXPHASE4:
+		case MPHASE_CAL_STATE_TXPHASE5:
+			if ((pi->radar_percal_mask & 0x10) != 0)
+				pi->nphy_rxcal_active = TRUE;
+
+			if (wlc_phy_cal_txiqlo_nphy
+			    (pi, pi->nphy_cal_target_gain, fullcal,
+			     TRUE) != BCME_OK) {
+
+				wlc_phy_cal_perical_mphase_reset(pi);
+				break;
+			}
+
+			if (NREV_LE(pi->pubpi.phy_rev, 2) &&
+			    (pi->mphase_cal_phase_id ==
+			     MPHASE_CAL_STATE_TXPHASE4)) {
+				pi->mphase_cal_phase_id += 2;
+			} else {
+				pi->mphase_cal_phase_id++;
+			}
+			break;
+
+		case MPHASE_CAL_STATE_PAPDCAL:
+			if ((pi->radar_percal_mask & 0x2) != 0)
+				pi->nphy_rxcal_active = TRUE;
+
+			if (PHY_IPA(pi)) {
+				wlc_phy_a4(pi, TRUE);
+			}
+			pi->mphase_cal_phase_id++;
+			break;
+
+		case MPHASE_CAL_STATE_RXCAL:
+			if ((pi->radar_percal_mask & 0x1) != 0)
+				pi->nphy_rxcal_active = TRUE;
+			if (wlc_phy_cal_rxiq_nphy(pi, target_gain,
+						  (pi->first_cal_after_assoc ||
+						   (pi->cal_type_override ==
+						    PHY_PERICAL_FULL)) ? 2 : 0,
+						  FALSE) == BCME_OK) {
+				wlc_phy_savecal_nphy(pi);
+			}
+
+			pi->mphase_cal_phase_id++;
+			break;
+
+		case MPHASE_CAL_STATE_RSSICAL:
+			if ((pi->radar_percal_mask & 0x4) != 0)
+				pi->nphy_rxcal_active = TRUE;
+			wlc_phy_txpwrctrl_coeff_setup_nphy(pi);
+			wlc_phy_rssi_cal_nphy(pi);
+
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				wlc_phy_radio205x_vcocal_nphy(pi);
+			}
+			restore_tx_gain = TRUE;
+
+			if (pi->first_cal_after_assoc) {
+				pi->mphase_cal_phase_id++;
+			} else {
+				wlc_phy_cal_perical_mphase_reset(pi);
+			}
+
+			break;
+
+		case MPHASE_CAL_STATE_IDLETSSI:
+			if ((pi->radar_percal_mask & 0x8) != 0)
+				pi->nphy_rxcal_active = TRUE;
+
+			if (pi->first_cal_after_assoc) {
+				pi->first_cal_after_assoc = FALSE;
+				wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
+				wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
+			}
+
+			wlc_phy_cal_perical_mphase_reset(pi);
+			break;
+
+		default:
+			ASSERT(0);
+			wlc_phy_cal_perical_mphase_reset(pi);
+			break;
+		}
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if (restore_tx_gain) {
+			if (tx_pwr_ctrl_state != PHY_TPC_HW_OFF) {
+
+				wlc_phy_txpwr_index_nphy(pi, 1,
+							 pi->
+							 nphy_cal_orig_pwr_idx
+							 [0], FALSE);
+				wlc_phy_txpwr_index_nphy(pi, 2,
+							 pi->
+							 nphy_cal_orig_pwr_idx
+							 [1], FALSE);
+
+				pi->nphy_txpwrindex[0].index = -1;
+				pi->nphy_txpwrindex[1].index = -1;
+			} else {
+				wlc_phy_txpwr_index_nphy(pi, (1 << 0),
+							 (int8) (pi->
+								 nphy_txpwrindex
+								 [0].
+								 index_internal),
+							 FALSE);
+				wlc_phy_txpwr_index_nphy(pi, (1 << 1),
+							 (int8) (pi->
+								 nphy_txpwrindex
+								 [1].
+								 index_internal),
+							 FALSE);
+			}
+		}
+	}
+
+	wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
+	wlc_phyreg_exit((wlc_phy_t *) pi);
+	wlapi_enable_mac(pi->sh->physhim);
+}
+
+int
+wlc_phy_cal_txiqlo_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+			bool fullcal, bool mphase)
+{
+	uint16 val;
+	uint16 tbl_buf[11];
+	uint8 cal_cnt;
+	uint16 cal_cmd;
+	uint8 num_cals, max_cal_cmds;
+	uint16 core_no, cal_type;
+	uint16 diq_start = 0;
+	uint8 phy_bw;
+	uint16 max_val;
+	uint16 tone_freq;
+	uint16 gain_save[2];
+	uint16 cal_gain[2];
+	nphy_iqcal_params_t cal_params[2];
+	uint32 tbl_len;
+	void *tbl_ptr;
+	bool ladder_updated[2];
+	uint8 mphase_cal_lastphase = 0;
+	int bcmerror = BCME_OK;
+	bool phyhang_avoid_state = FALSE;
+
+	uint16 tbl_tx_iqlo_cal_loft_ladder_20[] = {
+		0x0300, 0x0500, 0x0700, 0x0900, 0x0d00, 0x1100, 0x1900, 0x1901,
+		    0x1902,
+		0x1903, 0x1904, 0x1905, 0x1906, 0x1907, 0x2407, 0x3207, 0x4607,
+		    0x6407
+	};
+
+	uint16 tbl_tx_iqlo_cal_iqimb_ladder_20[] = {
+		0x0200, 0x0300, 0x0600, 0x0900, 0x0d00, 0x1100, 0x1900, 0x2400,
+		    0x3200,
+		0x4600, 0x6400, 0x6401, 0x6402, 0x6403, 0x6404, 0x6405, 0x6406,
+		    0x6407
+	};
+
+	uint16 tbl_tx_iqlo_cal_loft_ladder_40[] = {
+		0x0200, 0x0300, 0x0400, 0x0700, 0x0900, 0x0c00, 0x1200, 0x1201,
+		    0x1202,
+		0x1203, 0x1204, 0x1205, 0x1206, 0x1207, 0x1907, 0x2307, 0x3207,
+		    0x4707
+	};
+
+	uint16 tbl_tx_iqlo_cal_iqimb_ladder_40[] = {
+		0x0100, 0x0200, 0x0400, 0x0700, 0x0900, 0x0c00, 0x1200, 0x1900,
+		    0x2300,
+		0x3200, 0x4700, 0x4701, 0x4702, 0x4703, 0x4704, 0x4705, 0x4706,
+		    0x4707
+	};
+
+	uint16 tbl_tx_iqlo_cal_startcoefs[] = {
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		    0x0000
+	};
+
+	uint16 tbl_tx_iqlo_cal_cmds_fullcal[] = {
+		0x8123, 0x8264, 0x8086, 0x8245, 0x8056,
+		0x9123, 0x9264, 0x9086, 0x9245, 0x9056
+	};
+
+	uint16 tbl_tx_iqlo_cal_cmds_recal[] = {
+		0x8101, 0x8253, 0x8053, 0x8234, 0x8034,
+		0x9101, 0x9253, 0x9053, 0x9234, 0x9034
+	};
+
+	uint16 tbl_tx_iqlo_cal_startcoefs_nphyrev3[] = {
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000
+	};
+
+	uint16 tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3[] = {
+		0x8434, 0x8334, 0x8084, 0x8267, 0x8056, 0x8234,
+		0x9434, 0x9334, 0x9084, 0x9267, 0x9056, 0x9234
+	};
+
+	uint16 tbl_tx_iqlo_cal_cmds_recal_nphyrev3[] = {
+		0x8423, 0x8323, 0x8073, 0x8256, 0x8045, 0x8223,
+		0x9423, 0x9323, 0x9073, 0x9256, 0x9045, 0x9223
+	};
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
+		phyhang_avoid_state = pi->phyhang_avoid;
+		pi->phyhang_avoid = FALSE;
+	}
+
+	if (CHSPEC_IS40(pi->radio_chanspec)) {
+		phy_bw = 40;
+	} else {
+		phy_bw = 20;
+	}
+
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, gain_save);
+
+	for (core_no = 0; core_no <= 1; core_no++) {
+		wlc_phy_iqcal_gainparams_nphy(pi, core_no, target_gain,
+					      &cal_params[core_no]);
+		cal_gain[core_no] = cal_params[core_no].cal_gain;
+	}
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, cal_gain);
+
+	wlc_phy_txcal_radio_setup_nphy(pi);
+
+	wlc_phy_txcal_physetup_nphy(pi);
+
+	ladder_updated[0] = ladder_updated[1] = FALSE;
+	if (!(NREV_GE(pi->pubpi.phy_rev, 6) ||
+	      (NREV_IS(pi->pubpi.phy_rev, 5) && PHY_IPA(pi)
+	       && (CHSPEC_IS2G(pi->radio_chanspec))))) {
+
+		if (phy_bw == 40) {
+			tbl_ptr = tbl_tx_iqlo_cal_loft_ladder_40;
+			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_loft_ladder_40);
+		} else {
+			tbl_ptr = tbl_tx_iqlo_cal_loft_ladder_20;
+			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_loft_ladder_20);
+		}
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, tbl_len, 0,
+					 16, tbl_ptr);
+
+		if (phy_bw == 40) {
+			tbl_ptr = tbl_tx_iqlo_cal_iqimb_ladder_40;
+			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_iqimb_ladder_40);
+		} else {
+			tbl_ptr = tbl_tx_iqlo_cal_iqimb_ladder_20;
+			tbl_len = ARRAYSIZE(tbl_tx_iqlo_cal_iqimb_ladder_20);
+		}
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, tbl_len, 32,
+					 16, tbl_ptr);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		write_phy_reg(pi, 0xc2, 0x8ad9);
+	} else {
+		write_phy_reg(pi, 0xc2, 0x8aa9);
+	}
+
+	max_val = 250;
+	tone_freq = (phy_bw == 20) ? 2500 : 5000;
+
+	if (pi->mphase_cal_phase_id > MPHASE_CAL_STATE_TXPHASE0) {
+		wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff, 0, 1, 0, FALSE);
+		bcmerror = BCME_OK;
+	} else {
+		bcmerror =
+		    wlc_phy_tx_tone_nphy(pi, tone_freq, max_val, 1, 0, FALSE);
+	}
+
+	if (bcmerror == BCME_OK) {
+
+		if (pi->mphase_cal_phase_id > MPHASE_CAL_STATE_TXPHASE0) {
+			tbl_ptr = pi->mphase_txcal_bestcoeffs;
+			tbl_len = ARRAYSIZE(pi->mphase_txcal_bestcoeffs);
+			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+
+				tbl_len -= 2;
+			}
+		} else {
+			if ((!fullcal) && (pi->nphy_txiqlocal_coeffsvalid)) {
+
+				tbl_ptr = pi->nphy_txiqlocal_bestc;
+				tbl_len = ARRAYSIZE(pi->nphy_txiqlocal_bestc);
+				if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+
+					tbl_len -= 2;
+				}
+			} else {
+
+				fullcal = TRUE;
+
+				if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+					tbl_ptr =
+					    tbl_tx_iqlo_cal_startcoefs_nphyrev3;
+					tbl_len =
+					    ARRAYSIZE
+					    (tbl_tx_iqlo_cal_startcoefs_nphyrev3);
+				} else {
+					tbl_ptr = tbl_tx_iqlo_cal_startcoefs;
+					tbl_len =
+					    ARRAYSIZE
+					    (tbl_tx_iqlo_cal_startcoefs);
+				}
+			}
+		}
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, tbl_len, 64,
+					 16, tbl_ptr);
+
+		if (fullcal) {
+			max_cal_cmds = (NREV_GE(pi->pubpi.phy_rev, 3)) ?
+			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3) :
+			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_fullcal);
+		} else {
+			max_cal_cmds = (NREV_GE(pi->pubpi.phy_rev, 3)) ?
+			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_recal_nphyrev3) :
+			    ARRAYSIZE(tbl_tx_iqlo_cal_cmds_recal);
+		}
+
+		if (mphase) {
+			cal_cnt = pi->mphase_txcal_cmdidx;
+			if ((cal_cnt + pi->mphase_txcal_numcmds) < max_cal_cmds) {
+				num_cals = cal_cnt + pi->mphase_txcal_numcmds;
+			} else {
+				num_cals = max_cal_cmds;
+			}
+		} else {
+			cal_cnt = 0;
+			num_cals = max_cal_cmds;
+		}
+
+		for (; cal_cnt < num_cals; cal_cnt++) {
+
+			if (fullcal) {
+				cal_cmd = (NREV_GE(pi->pubpi.phy_rev, 3)) ?
+				    tbl_tx_iqlo_cal_cmds_fullcal_nphyrev3
+				    [cal_cnt] :
+				    tbl_tx_iqlo_cal_cmds_fullcal[cal_cnt];
+			} else {
+				cal_cmd = (NREV_GE(pi->pubpi.phy_rev, 3)) ?
+				    tbl_tx_iqlo_cal_cmds_recal_nphyrev3[cal_cnt]
+				    : tbl_tx_iqlo_cal_cmds_recal[cal_cnt];
+			}
+
+			core_no = ((cal_cmd & 0x3000) >> 12);
+			cal_type = ((cal_cmd & 0x0F00) >> 8);
+
+			if (NREV_GE(pi->pubpi.phy_rev, 6) ||
+			    (NREV_IS(pi->pubpi.phy_rev, 5) &&
+			     PHY_IPA(pi)
+			     && (CHSPEC_IS2G(pi->radio_chanspec)))) {
+				if (!ladder_updated[core_no]) {
+					wlc_phy_update_txcal_ladder_nphy(pi,
+									 core_no);
+					ladder_updated[core_no] = TRUE;
+				}
+			}
+
+			val =
+			    (cal_params[core_no].
+			     ncorr[cal_type] << 8) | NPHY_N_GCTL;
+			write_phy_reg(pi, 0xc1, val);
+
+			if ((cal_type == 1) || (cal_type == 3)
+			    || (cal_type == 4)) {
+
+				wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL,
+							1, 69 + core_no, 16,
+							tbl_buf);
+
+				diq_start = tbl_buf[0];
+
+				tbl_buf[0] = 0;
+				wlc_phy_table_write_nphy(pi,
+							 NPHY_TBL_ID_IQLOCAL, 1,
+							 69 + core_no, 16,
+							 tbl_buf);
+			}
+
+			write_phy_reg(pi, 0xc0, cal_cmd);
+
+			SPINWAIT(((read_phy_reg(pi, 0xc0) & 0xc000) != 0),
+				 20000);
+			ASSERT((read_phy_reg(pi, 0xc0) & 0xc000) == 0);
+
+			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL,
+						tbl_len, 96, 16, tbl_buf);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL,
+						 tbl_len, 64, 16, tbl_buf);
+
+			if ((cal_type == 1) || (cal_type == 3)
+			    || (cal_type == 4)) {
+
+				tbl_buf[0] = diq_start;
+
+			}
+
+		}
+
+		if (mphase) {
+			pi->mphase_txcal_cmdidx = num_cals;
+			if (pi->mphase_txcal_cmdidx >= max_cal_cmds)
+				pi->mphase_txcal_cmdidx = 0;
+		}
+
+		mphase_cal_lastphase =
+		    (NREV_LE(pi->pubpi.phy_rev, 2)) ?
+		    MPHASE_CAL_STATE_TXPHASE4 : MPHASE_CAL_STATE_TXPHASE5;
+
+		if (!mphase
+		    || (pi->mphase_cal_phase_id == mphase_cal_lastphase)) {
+
+			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL, 4, 96,
+						16, tbl_buf);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 4, 80,
+						 16, tbl_buf);
+
+			if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+
+				tbl_buf[0] = 0;
+				tbl_buf[1] = 0;
+				tbl_buf[2] = 0;
+				tbl_buf[3] = 0;
+
+			}
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 4, 88,
+						 16, tbl_buf);
+
+			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 101,
+						16, tbl_buf);
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 85,
+						 16, tbl_buf);
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 93,
+						 16, tbl_buf);
+
+			tbl_len = ARRAYSIZE(pi->nphy_txiqlocal_bestc);
+			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+
+				tbl_len -= 2;
+			}
+			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL,
+						tbl_len, 96, 16,
+						pi->nphy_txiqlocal_bestc);
+
+			pi->nphy_txiqlocal_coeffsvalid = TRUE;
+			pi->nphy_txiqlocal_chanspec = pi->radio_chanspec;
+		} else {
+			tbl_len = ARRAYSIZE(pi->mphase_txcal_bestcoeffs);
+			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+
+				tbl_len -= 2;
+			}
+			wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL,
+						tbl_len, 96, 16,
+						pi->mphase_txcal_bestcoeffs);
+		}
+
+		wlc_phy_stopplayback_nphy(pi);
+
+		write_phy_reg(pi, 0xc2, 0x0000);
+
+	}
+
+	wlc_phy_txcal_phycleanup_nphy(pi);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
+				 gain_save);
+
+	wlc_phy_txcal_radio_cleanup_nphy(pi);
+
+	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+		if (!mphase
+		    || (pi->mphase_cal_phase_id == mphase_cal_lastphase))
+			wlc_phy_tx_iq_war_nphy(pi);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
+		pi->phyhang_avoid = phyhang_avoid_state;
+	}
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+
+	return bcmerror;
+}
+
+static void wlc_phy_reapply_txcal_coeffs_nphy(phy_info_t * pi)
+{
+	uint16 tbl_buf[7];
+
+	ASSERT(NREV_LT(pi->pubpi.phy_rev, 2));
+
+	if ((pi->nphy_txiqlocal_chanspec == pi->radio_chanspec) &&
+	    (pi->nphy_txiqlocal_coeffsvalid)) {
+		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_IQLOCAL,
+					ARRAYSIZE(tbl_buf), 80, 16, tbl_buf);
+
+		if ((pi->nphy_txiqlocal_bestc[0] != tbl_buf[0]) ||
+		    (pi->nphy_txiqlocal_bestc[1] != tbl_buf[1]) ||
+		    (pi->nphy_txiqlocal_bestc[2] != tbl_buf[2]) ||
+		    (pi->nphy_txiqlocal_bestc[3] != tbl_buf[3])) {
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 4, 80,
+						 16, pi->nphy_txiqlocal_bestc);
+
+			tbl_buf[0] = 0;
+			tbl_buf[1] = 0;
+			tbl_buf[2] = 0;
+			tbl_buf[3] = 0;
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 4, 88,
+						 16, tbl_buf);
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 85,
+						 16,
+						 &pi->nphy_txiqlocal_bestc[5]);
+
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_IQLOCAL, 2, 93,
+						 16,
+						 &pi->nphy_txiqlocal_bestc[5]);
+		}
+	}
+}
+
+static void wlc_phy_tx_iq_war_nphy(phy_info_t * pi)
+{
+	nphy_iq_comp_t tx_comp;
+
+	wlc_phy_table_read_nphy(pi, 15, 4, 0x50, 16, (void *)&tx_comp);
+
+	wlapi_bmac_write_shm(pi->sh->physhim, M_20IN40_IQ, tx_comp.a0);
+	wlapi_bmac_write_shm(pi->sh->physhim, M_20IN40_IQ + 2, tx_comp.b0);
+	wlapi_bmac_write_shm(pi->sh->physhim, M_20IN40_IQ + 4, tx_comp.a1);
+	wlapi_bmac_write_shm(pi->sh->physhim, M_20IN40_IQ + 6, tx_comp.b1);
+}
+
+void
+wlc_phy_rx_iq_coeffs_nphy(phy_info_t * pi, uint8 write, nphy_iq_comp_t * pcomp)
+{
+	if (write) {
+		write_phy_reg(pi, 0x9a, pcomp->a0);
+		write_phy_reg(pi, 0x9b, pcomp->b0);
+		write_phy_reg(pi, 0x9c, pcomp->a1);
+		write_phy_reg(pi, 0x9d, pcomp->b1);
+	} else {
+		pcomp->a0 = read_phy_reg(pi, 0x9a);
+		pcomp->b0 = read_phy_reg(pi, 0x9b);
+		pcomp->a1 = read_phy_reg(pi, 0x9c);
+		pcomp->b1 = read_phy_reg(pi, 0x9d);
+	}
+}
+
+void
+wlc_phy_rx_iq_est_nphy(phy_info_t * pi, phy_iq_est_t * est, uint16 num_samps,
+		       uint8 wait_time, uint8 wait_for_crs)
+{
+	uint8 core;
+
+	write_phy_reg(pi, 0x12b, num_samps);
+	mod_phy_reg(pi, 0x12a, (0xff << 0), (wait_time << 0));
+	mod_phy_reg(pi, 0x129, NPHY_IqestCmd_iqMode,
+		    (wait_for_crs) ? NPHY_IqestCmd_iqMode : 0);
+
+	mod_phy_reg(pi, 0x129, NPHY_IqestCmd_iqstart, NPHY_IqestCmd_iqstart);
+
+	SPINWAIT(((read_phy_reg(pi, 0x129) & NPHY_IqestCmd_iqstart) != 0),
+		 10000);
+	ASSERT((read_phy_reg(pi, 0x129) & NPHY_IqestCmd_iqstart) == 0);
+
+	if ((read_phy_reg(pi, 0x129) & NPHY_IqestCmd_iqstart) == 0) {
+		ASSERT(pi->pubpi.phy_corenum <= PHY_CORE_MAX);
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+			est[core].i_pwr =
+			    (read_phy_reg(pi, NPHY_IqestipwrAccHi(core)) << 16)
+			    | read_phy_reg(pi, NPHY_IqestipwrAccLo(core));
+			est[core].q_pwr =
+			    (read_phy_reg(pi, NPHY_IqestqpwrAccHi(core)) << 16)
+			    | read_phy_reg(pi, NPHY_IqestqpwrAccLo(core));
+			est[core].iq_prod =
+			    (read_phy_reg(pi, NPHY_IqestIqAccHi(core)) << 16) |
+			    read_phy_reg(pi, NPHY_IqestIqAccLo(core));
+		}
+	}
+}
+
+#define CAL_RETRY_CNT 2
+static void wlc_phy_calc_rx_iq_comp_nphy(phy_info_t * pi, uint8 core_mask)
+{
+	uint8 curr_core;
+	phy_iq_est_t est[PHY_CORE_MAX];
+	nphy_iq_comp_t old_comp, new_comp;
+	int32 iq = 0;
+	uint32 ii = 0, qq = 0;
+	int16 iq_nbits, qq_nbits, brsh, arsh;
+	int32 a, b, temp;
+	int bcmerror = BCME_OK;
+	uint cal_retry = 0;
+
+	if (core_mask == 0x0)
+		return;
+
+	wlc_phy_rx_iq_coeffs_nphy(pi, 0, &old_comp);
+	new_comp.a0 = new_comp.b0 = new_comp.a1 = new_comp.b1 = 0x0;
+	wlc_phy_rx_iq_coeffs_nphy(pi, 1, &new_comp);
+
+ cal_try:
+	wlc_phy_rx_iq_est_nphy(pi, est, 0x4000, 32, 0);
+
+	new_comp = old_comp;
+
+	for (curr_core = 0; curr_core < pi->pubpi.phy_corenum; curr_core++) {
+
+		if ((curr_core == PHY_CORE_0) && (core_mask & 0x1)) {
+			iq = est[curr_core].iq_prod;
+			ii = est[curr_core].i_pwr;
+			qq = est[curr_core].q_pwr;
+		} else if ((curr_core == PHY_CORE_1) && (core_mask & 0x2)) {
+			iq = est[curr_core].iq_prod;
+			ii = est[curr_core].i_pwr;
+			qq = est[curr_core].q_pwr;
+		} else {
+			continue;
+		}
+
+		if ((ii + qq) < NPHY_MIN_RXIQ_PWR) {
+			bcmerror = BCME_ERROR;
+			break;
+		}
+
+		iq_nbits = wlc_phy_nbits(iq);
+		qq_nbits = wlc_phy_nbits(qq);
+
+		arsh = 10 - (30 - iq_nbits);
+		if (arsh >= 0) {
+			a = (-(iq << (30 - iq_nbits)) + (ii >> (1 + arsh)));
+			temp = (int32) (ii >> arsh);
+			if (temp == 0) {
+				bcmerror = BCME_ERROR;
+				break;
+			}
+		} else {
+			a = (-(iq << (30 - iq_nbits)) + (ii << (-1 - arsh)));
+			temp = (int32) (ii << -arsh);
+			if (temp == 0) {
+				bcmerror = BCME_ERROR;
+				break;
+			}
+		}
+
+		a /= temp;
+
+		brsh = qq_nbits - 31 + 20;
+		if (brsh >= 0) {
+			b = (qq << (31 - qq_nbits));
+			temp = (int32) (ii >> brsh);
+			if (temp == 0) {
+				bcmerror = BCME_ERROR;
+				break;
+			}
+		} else {
+			b = (qq << (31 - qq_nbits));
+			temp = (int32) (ii << -brsh);
+			if (temp == 0) {
+				bcmerror = BCME_ERROR;
+				break;
+			}
+		}
+		b /= temp;
+		b -= a * a;
+		b = (int32) wlc_phy_sqrt_int((uint32) b);
+		b -= (1 << 10);
+
+		if ((curr_core == PHY_CORE_0) && (core_mask & 0x1)) {
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				new_comp.a0 = (int16) a & 0x3ff;
+				new_comp.b0 = (int16) b & 0x3ff;
+			} else {
+
+				new_comp.a0 = (int16) b & 0x3ff;
+				new_comp.b0 = (int16) a & 0x3ff;
+			}
+		}
+		if ((curr_core == PHY_CORE_1) && (core_mask & 0x2)) {
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				new_comp.a1 = (int16) a & 0x3ff;
+				new_comp.b1 = (int16) b & 0x3ff;
+			} else {
+
+				new_comp.a1 = (int16) b & 0x3ff;
+				new_comp.b1 = (int16) a & 0x3ff;
+			}
+		}
+	}
+
+	if (bcmerror != BCME_OK) {
+		printk("%s: Failed, cnt = %d\n", __func__, cal_retry);
+
+		if (cal_retry < CAL_RETRY_CNT) {
+			cal_retry++;
+			goto cal_try;
+		}
+
+		new_comp = old_comp;
+	} else if (cal_retry > 0) {
+	}
+
+	wlc_phy_rx_iq_coeffs_nphy(pi, 1, &new_comp);
+}
+
+static void wlc_phy_rxcal_radio_setup_nphy(phy_info_t * pi, uint8 rx_core)
+{
+	uint16 offtune_val;
+	uint16 bias_g = 0;
+	uint16 bias_a = 0;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		if (rx_core == PHY_CORE_0) {
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				pi->tx_rx_cal_radio_saveregs[0] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX0_TXRXCOUPLE_5G_PWRUP);
+				pi->tx_rx_cal_radio_saveregs[1] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX0_TXRXCOUPLE_5G_ATTEN);
+
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_5G_PWRUP,
+						0x3);
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_5G_ATTEN,
+						0xaf);
+
+			} else {
+				pi->tx_rx_cal_radio_saveregs[0] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX0_TXRXCOUPLE_2G_PWRUP);
+				pi->tx_rx_cal_radio_saveregs[1] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX0_TXRXCOUPLE_2G_ATTEN);
+
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_2G_PWRUP,
+						0x3);
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_2G_ATTEN,
+						0x7f);
+			}
+
+		} else {
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				pi->tx_rx_cal_radio_saveregs[0] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX1_TXRXCOUPLE_5G_PWRUP);
+				pi->tx_rx_cal_radio_saveregs[1] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX1_TXRXCOUPLE_5G_ATTEN);
+
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_5G_PWRUP,
+						0x3);
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_5G_ATTEN,
+						0xaf);
+
+			} else {
+				pi->tx_rx_cal_radio_saveregs[0] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX1_TXRXCOUPLE_2G_PWRUP);
+				pi->tx_rx_cal_radio_saveregs[1] =
+				    read_radio_reg(pi,
+						   RADIO_2057_TX1_TXRXCOUPLE_2G_ATTEN);
+
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_2G_PWRUP,
+						0x3);
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_2G_ATTEN,
+						0x7f);
+			}
+		}
+
+	} else {
+		if (rx_core == PHY_CORE_0) {
+			pi->tx_rx_cal_radio_saveregs[0] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_RXIQCAL_TXMUX |
+					   RADIO_2056_TX1);
+			pi->tx_rx_cal_radio_saveregs[1] =
+			    read_radio_reg(pi,
+					   RADIO_2056_RX_RXIQCAL_RXMUX |
+					   RADIO_2056_RX0);
+
+			if (pi->pubpi.radiorev >= 5) {
+				pi->tx_rx_cal_radio_saveregs[2] =
+				    read_radio_reg(pi,
+						   RADIO_2056_RX_RXSPARE2 |
+						   RADIO_2056_RX0);
+				pi->tx_rx_cal_radio_saveregs[3] =
+				    read_radio_reg(pi,
+						   RADIO_2056_TX_TXSPARE2 |
+						   RADIO_2056_TX1);
+			}
+
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+
+				if (pi->pubpi.radiorev >= 5) {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAA_MASTER
+							   | RADIO_2056_RX0);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAA_MASTER
+							| RADIO_2056_RX0, 0x40);
+
+					write_radio_reg(pi,
+							RADIO_2056_TX_TXSPARE2 |
+							RADIO_2056_TX1, bias_a);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_RXSPARE2 |
+							RADIO_2056_RX0, bias_a);
+				} else {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAA_TUNE
+							   | RADIO_2056_RX0);
+
+					offtune_val =
+					    (pi->
+					     tx_rx_cal_radio_saveregs[2] & 0xF0)
+					    >> 8;
+					offtune_val =
+					    (offtune_val <= 0x7) ? 0xF : 0;
+
+					mod_radio_reg(pi,
+						      RADIO_2056_RX_LNAA_TUNE |
+						      RADIO_2056_RX0, 0xF0,
+						      (offtune_val << 8));
+				}
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_RXIQCAL_TXMUX |
+						RADIO_2056_TX1, 0x9);
+				write_radio_reg(pi,
+						RADIO_2056_RX_RXIQCAL_RXMUX |
+						RADIO_2056_RX0, 0x9);
+			} else {
+				if (pi->pubpi.radiorev >= 5) {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAG_MASTER
+							   | RADIO_2056_RX0);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAG_MASTER
+							| RADIO_2056_RX0, 0x40);
+
+					write_radio_reg(pi,
+							RADIO_2056_TX_TXSPARE2 |
+							RADIO_2056_TX1, bias_g);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_RXSPARE2 |
+							RADIO_2056_RX0, bias_g);
+
+				} else {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAG_TUNE
+							   | RADIO_2056_RX0);
+
+					offtune_val =
+					    (pi->
+					     tx_rx_cal_radio_saveregs[2] & 0xF0)
+					    >> 8;
+					offtune_val =
+					    (offtune_val <= 0x7) ? 0xF : 0;
+
+					mod_radio_reg(pi,
+						      RADIO_2056_RX_LNAG_TUNE |
+						      RADIO_2056_RX0, 0xF0,
+						      (offtune_val << 8));
+				}
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_RXIQCAL_TXMUX |
+						RADIO_2056_TX1, 0x6);
+				write_radio_reg(pi,
+						RADIO_2056_RX_RXIQCAL_RXMUX |
+						RADIO_2056_RX0, 0x6);
+			}
+
+		} else {
+			pi->tx_rx_cal_radio_saveregs[0] =
+			    read_radio_reg(pi,
+					   RADIO_2056_TX_RXIQCAL_TXMUX |
+					   RADIO_2056_TX0);
+			pi->tx_rx_cal_radio_saveregs[1] =
+			    read_radio_reg(pi,
+					   RADIO_2056_RX_RXIQCAL_RXMUX |
+					   RADIO_2056_RX1);
+
+			if (pi->pubpi.radiorev >= 5) {
+				pi->tx_rx_cal_radio_saveregs[2] =
+				    read_radio_reg(pi,
+						   RADIO_2056_RX_RXSPARE2 |
+						   RADIO_2056_RX1);
+				pi->tx_rx_cal_radio_saveregs[3] =
+				    read_radio_reg(pi,
+						   RADIO_2056_TX_TXSPARE2 |
+						   RADIO_2056_TX0);
+			}
+
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+
+				if (pi->pubpi.radiorev >= 5) {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAA_MASTER
+							   | RADIO_2056_RX1);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAA_MASTER
+							| RADIO_2056_RX1, 0x40);
+
+					write_radio_reg(pi,
+							RADIO_2056_TX_TXSPARE2 |
+							RADIO_2056_TX0, bias_a);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_RXSPARE2 |
+							RADIO_2056_RX1, bias_a);
+				} else {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAA_TUNE
+							   | RADIO_2056_RX1);
+
+					offtune_val =
+					    (pi->
+					     tx_rx_cal_radio_saveregs[2] & 0xF0)
+					    >> 8;
+					offtune_val =
+					    (offtune_val <= 0x7) ? 0xF : 0;
+
+					mod_radio_reg(pi,
+						      RADIO_2056_RX_LNAA_TUNE |
+						      RADIO_2056_RX1, 0xF0,
+						      (offtune_val << 8));
+				}
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_RXIQCAL_TXMUX |
+						RADIO_2056_TX0, 0x9);
+				write_radio_reg(pi,
+						RADIO_2056_RX_RXIQCAL_RXMUX |
+						RADIO_2056_RX1, 0x9);
+			} else {
+				if (pi->pubpi.radiorev >= 5) {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAG_MASTER
+							   | RADIO_2056_RX1);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAG_MASTER
+							| RADIO_2056_RX1, 0x40);
+
+					write_radio_reg(pi,
+							RADIO_2056_TX_TXSPARE2 |
+							RADIO_2056_TX0, bias_g);
+
+					write_radio_reg(pi,
+							RADIO_2056_RX_RXSPARE2 |
+							RADIO_2056_RX1, bias_g);
+				} else {
+					pi->tx_rx_cal_radio_saveregs[4] =
+					    read_radio_reg(pi,
+							   RADIO_2056_RX_LNAG_TUNE
+							   | RADIO_2056_RX1);
+
+					offtune_val =
+					    (pi->
+					     tx_rx_cal_radio_saveregs[2] & 0xF0)
+					    >> 8;
+					offtune_val =
+					    (offtune_val <= 0x7) ? 0xF : 0;
+
+					mod_radio_reg(pi,
+						      RADIO_2056_RX_LNAG_TUNE |
+						      RADIO_2056_RX1, 0xF0,
+						      (offtune_val << 8));
+				}
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_RXIQCAL_TXMUX |
+						RADIO_2056_TX0, 0x6);
+				write_radio_reg(pi,
+						RADIO_2056_RX_RXIQCAL_RXMUX |
+						RADIO_2056_RX1, 0x6);
+			}
+		}
+	}
+}
+
+static void wlc_phy_rxcal_radio_cleanup_nphy(phy_info_t * pi, uint8 rx_core)
+{
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		if (rx_core == PHY_CORE_0) {
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_5G_PWRUP,
+						pi->
+						tx_rx_cal_radio_saveregs[0]);
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_5G_ATTEN,
+						pi->
+						tx_rx_cal_radio_saveregs[1]);
+
+			} else {
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_2G_PWRUP,
+						pi->
+						tx_rx_cal_radio_saveregs[0]);
+				write_radio_reg(pi,
+						RADIO_2057_TX0_TXRXCOUPLE_2G_ATTEN,
+						pi->
+						tx_rx_cal_radio_saveregs[1]);
+			}
+
+		} else {
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_5G_PWRUP,
+						pi->
+						tx_rx_cal_radio_saveregs[0]);
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_5G_ATTEN,
+						pi->
+						tx_rx_cal_radio_saveregs[1]);
+
+			} else {
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_2G_PWRUP,
+						pi->
+						tx_rx_cal_radio_saveregs[0]);
+				write_radio_reg(pi,
+						RADIO_2057_TX1_TXRXCOUPLE_2G_ATTEN,
+						pi->
+						tx_rx_cal_radio_saveregs[1]);
+			}
+		}
+
+	} else {
+		if (rx_core == PHY_CORE_0) {
+			write_radio_reg(pi,
+					RADIO_2056_TX_RXIQCAL_TXMUX |
+					RADIO_2056_TX1,
+					pi->tx_rx_cal_radio_saveregs[0]);
+
+			write_radio_reg(pi,
+					RADIO_2056_RX_RXIQCAL_RXMUX |
+					RADIO_2056_RX0,
+					pi->tx_rx_cal_radio_saveregs[1]);
+
+			if (pi->pubpi.radiorev >= 5) {
+				write_radio_reg(pi,
+						RADIO_2056_RX_RXSPARE2 |
+						RADIO_2056_RX0,
+						pi->
+						tx_rx_cal_radio_saveregs[2]);
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_TXSPARE2 |
+						RADIO_2056_TX1,
+						pi->
+						tx_rx_cal_radio_saveregs[3]);
+			}
+
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				if (pi->pubpi.radiorev >= 5) {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAA_MASTER
+							| RADIO_2056_RX0,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				} else {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAA_TUNE
+							| RADIO_2056_RX0,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				}
+			} else {
+				if (pi->pubpi.radiorev >= 5) {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAG_MASTER
+							| RADIO_2056_RX0,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				} else {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAG_TUNE
+							| RADIO_2056_RX0,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				}
+			}
+
+		} else {
+			write_radio_reg(pi,
+					RADIO_2056_TX_RXIQCAL_TXMUX |
+					RADIO_2056_TX0,
+					pi->tx_rx_cal_radio_saveregs[0]);
+
+			write_radio_reg(pi,
+					RADIO_2056_RX_RXIQCAL_RXMUX |
+					RADIO_2056_RX1,
+					pi->tx_rx_cal_radio_saveregs[1]);
+
+			if (pi->pubpi.radiorev >= 5) {
+				write_radio_reg(pi,
+						RADIO_2056_RX_RXSPARE2 |
+						RADIO_2056_RX1,
+						pi->
+						tx_rx_cal_radio_saveregs[2]);
+
+				write_radio_reg(pi,
+						RADIO_2056_TX_TXSPARE2 |
+						RADIO_2056_TX0,
+						pi->
+						tx_rx_cal_radio_saveregs[3]);
+			}
+
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				if (pi->pubpi.radiorev >= 5) {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAA_MASTER
+							| RADIO_2056_RX1,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				} else {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAA_TUNE
+							| RADIO_2056_RX1,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				}
+			} else {
+				if (pi->pubpi.radiorev >= 5) {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAG_MASTER
+							| RADIO_2056_RX1,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				} else {
+					write_radio_reg(pi,
+							RADIO_2056_RX_LNAG_TUNE
+							| RADIO_2056_RX1,
+							pi->
+							tx_rx_cal_radio_saveregs
+							[4]);
+				}
+			}
+		}
+	}
+}
+
+static void wlc_phy_rxcal_physetup_nphy(phy_info_t * pi, uint8 rx_core)
+{
+	uint8 tx_core;
+	uint16 rx_antval, tx_antval;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		tx_core = rx_core;
+	} else {
+		tx_core = (rx_core == PHY_CORE_0) ? 1 : 0;
+	}
+
+	pi->tx_rx_cal_phy_saveregs[0] = read_phy_reg(pi, 0xa2);
+	pi->tx_rx_cal_phy_saveregs[1] =
+	    read_phy_reg(pi, (rx_core == PHY_CORE_0) ? 0xa6 : 0xa7);
+	pi->tx_rx_cal_phy_saveregs[2] =
+	    read_phy_reg(pi, (rx_core == PHY_CORE_0) ? 0x8f : 0xa5);
+	pi->tx_rx_cal_phy_saveregs[3] = read_phy_reg(pi, 0x91);
+	pi->tx_rx_cal_phy_saveregs[4] = read_phy_reg(pi, 0x92);
+	pi->tx_rx_cal_phy_saveregs[5] = read_phy_reg(pi, 0x7a);
+	pi->tx_rx_cal_phy_saveregs[6] = read_phy_reg(pi, 0x7d);
+	pi->tx_rx_cal_phy_saveregs[7] = read_phy_reg(pi, 0xe7);
+	pi->tx_rx_cal_phy_saveregs[8] = read_phy_reg(pi, 0xec);
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		pi->tx_rx_cal_phy_saveregs[11] = read_phy_reg(pi, 0x342);
+		pi->tx_rx_cal_phy_saveregs[12] = read_phy_reg(pi, 0x343);
+		pi->tx_rx_cal_phy_saveregs[13] = read_phy_reg(pi, 0x346);
+		pi->tx_rx_cal_phy_saveregs[14] = read_phy_reg(pi, 0x347);
+	}
+
+	pi->tx_rx_cal_phy_saveregs[9] = read_phy_reg(pi, 0x297);
+	pi->tx_rx_cal_phy_saveregs[10] = read_phy_reg(pi, 0x29b);
+	mod_phy_reg(pi, (0 == PHY_CORE_0) ? 0x297 :
+		    0x29b, (0x1 << 0), (0) << 0);
+
+	mod_phy_reg(pi, (1 == PHY_CORE_0) ? 0x297 :
+		    0x29b, (0x1 << 0), (0) << 0);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		mod_phy_reg(pi, 0xa2, (0xf << 0), (1 << tx_core) << 0);
+
+		mod_phy_reg(pi, 0xa2, (0xf << 12), (1 << (1 - rx_core)) << 12);
+
+	} else {
+
+		mod_phy_reg(pi, 0xa2, (0xf << 12), (1 << tx_core) << 12);
+		mod_phy_reg(pi, 0xa2, (0xf << 0), (1 << tx_core) << 0);
+		mod_phy_reg(pi, 0xa2, (0xf << 4), (1 << rx_core) << 4);
+		mod_phy_reg(pi, 0xa2, (0xf << 8), (1 << rx_core) << 8);
+	}
+
+	mod_phy_reg(pi, ((rx_core == PHY_CORE_0) ? 0xa6 : 0xa7), (0x1 << 2), 0);
+	mod_phy_reg(pi, (rx_core == PHY_CORE_0) ? 0x8f : 0xa5,
+		    (0x1 << 2), (0x1 << 2));
+	if (NREV_LT(pi->pubpi.phy_rev, 7)) {
+		mod_phy_reg(pi, ((rx_core == PHY_CORE_0) ? 0xa6 : 0xa7),
+			    (0x1 << 0) | (0x1 << 1), 0);
+		mod_phy_reg(pi, (rx_core == PHY_CORE_0) ?
+			    0x8f : 0xa5,
+			    (0x1 << 0) | (0x1 << 1), (0x1 << 0) | (0x1 << 1));
+	}
+
+	wlc_phy_rfctrlintc_override_nphy(pi, NPHY_RfctrlIntc_override_PA, 0,
+					 RADIO_MIMO_CORESEL_CORE1 |
+					 RADIO_MIMO_CORESEL_CORE2);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3),
+						  0, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 9), 0, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 10), 1, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 0), 1, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1), 1, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 11), 0, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		if (CHSPEC_IS40(pi->radio_chanspec)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi,
+							  (0x1 << 7),
+							  2, 0, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		} else {
+			wlc_phy_rfctrl_override_nphy_rev7(pi,
+							  (0x1 << 7),
+							  0, 0, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		}
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 7),
+						  0, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 5), 0, 0, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+	} else {
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 3), 0, 3, 0);
+	}
+
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RX2TX);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 0x1, rx_core + 1);
+	} else {
+
+		if (rx_core == PHY_CORE_0) {
+			rx_antval = 0x1;
+			tx_antval = 0x8;
+		} else {
+			rx_antval = 0x4;
+			tx_antval = 0x2;
+		}
+
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 rx_antval, rx_core + 1);
+		wlc_phy_rfctrlintc_override_nphy(pi,
+						 NPHY_RfctrlIntc_override_TRSW,
+						 tx_antval, tx_core + 1);
+	}
+}
+
+static void wlc_phy_rxcal_phycleanup_nphy(phy_info_t * pi, uint8 rx_core)
+{
+
+	write_phy_reg(pi, 0xa2, pi->tx_rx_cal_phy_saveregs[0]);
+	write_phy_reg(pi, (rx_core == PHY_CORE_0) ? 0xa6 : 0xa7,
+		      pi->tx_rx_cal_phy_saveregs[1]);
+	write_phy_reg(pi, (rx_core == PHY_CORE_0) ? 0x8f : 0xa5,
+		      pi->tx_rx_cal_phy_saveregs[2]);
+	write_phy_reg(pi, 0x91, pi->tx_rx_cal_phy_saveregs[3]);
+	write_phy_reg(pi, 0x92, pi->tx_rx_cal_phy_saveregs[4]);
+
+	write_phy_reg(pi, 0x7a, pi->tx_rx_cal_phy_saveregs[5]);
+	write_phy_reg(pi, 0x7d, pi->tx_rx_cal_phy_saveregs[6]);
+	write_phy_reg(pi, 0xe7, pi->tx_rx_cal_phy_saveregs[7]);
+	write_phy_reg(pi, 0xec, pi->tx_rx_cal_phy_saveregs[8]);
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		write_phy_reg(pi, 0x342, pi->tx_rx_cal_phy_saveregs[11]);
+		write_phy_reg(pi, 0x343, pi->tx_rx_cal_phy_saveregs[12]);
+		write_phy_reg(pi, 0x346, pi->tx_rx_cal_phy_saveregs[13]);
+		write_phy_reg(pi, 0x347, pi->tx_rx_cal_phy_saveregs[14]);
+	}
+
+	write_phy_reg(pi, 0x297, pi->tx_rx_cal_phy_saveregs[9]);
+	write_phy_reg(pi, 0x29b, pi->tx_rx_cal_phy_saveregs[10]);
+}
+
+static void
+wlc_phy_rxcal_gainctrl_nphy_rev5(phy_info_t * pi, uint8 rx_core,
+				 uint16 * rxgain, uint8 cal_type)
+{
+
+	uint16 num_samps;
+	phy_iq_est_t est[PHY_CORE_MAX];
+	uint8 tx_core;
+	nphy_iq_comp_t save_comp, zero_comp;
+	uint32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0, prev_pwr = 0, thresh_pwr =
+	    10000;
+	int16 desired_log2_pwr, actual_log2_pwr, delta_pwr;
+	bool gainctrl_done = FALSE;
+	uint8 mix_tia_gain = 3;
+	int8 optim_gaintbl_index = 0, prev_gaintbl_index = 0;
+	int8 curr_gaintbl_index = 3;
+	uint8 gainctrl_dirn = NPHY_RXCAL_GAIN_INIT;
+	nphy_ipa_txrxgain_t *nphy_rxcal_gaintbl;
+	uint16 hpvga, lpf_biq1, lpf_biq0, lna2, lna1;
+	int16 fine_gain_idx;
+	int8 txpwrindex;
+	uint16 nphy_rxcal_txgain[2];
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		tx_core = rx_core;
+	} else {
+		tx_core = 1 - rx_core;
+	}
+
+	num_samps = 1024;
+	desired_log2_pwr = (cal_type == 0) ? 13 : 13;
+
+	wlc_phy_rx_iq_coeffs_nphy(pi, 0, &save_comp);
+	zero_comp.a0 = zero_comp.b0 = zero_comp.a1 = zero_comp.b1 = 0x0;
+	wlc_phy_rx_iq_coeffs_nphy(pi, 1, &zero_comp);
+
+	if (CHSPEC_IS5G(pi->radio_chanspec)) {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			mix_tia_gain = 3;
+		} else if (NREV_GE(pi->pubpi.phy_rev, 4)) {
+			mix_tia_gain = 4;
+		} else {
+			mix_tia_gain = 6;
+		}
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			nphy_rxcal_gaintbl = nphy_ipa_rxcal_gaintbl_5GHz_rev7;
+		} else {
+			nphy_rxcal_gaintbl = nphy_ipa_rxcal_gaintbl_5GHz;
+		}
+	} else {
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			nphy_rxcal_gaintbl = nphy_ipa_rxcal_gaintbl_2GHz_rev7;
+		} else {
+			nphy_rxcal_gaintbl = nphy_ipa_rxcal_gaintbl_2GHz;
+		}
+	}
+
+	do {
+
+		hpvga = (NREV_GE(pi->pubpi.phy_rev, 7)) ?
+		    0 : nphy_rxcal_gaintbl[curr_gaintbl_index].hpvga;
+		lpf_biq1 = nphy_rxcal_gaintbl[curr_gaintbl_index].lpf_biq1;
+		lpf_biq0 = nphy_rxcal_gaintbl[curr_gaintbl_index].lpf_biq0;
+		lna2 = nphy_rxcal_gaintbl[curr_gaintbl_index].lna2;
+		lna1 = nphy_rxcal_gaintbl[curr_gaintbl_index].lna1;
+		txpwrindex = nphy_rxcal_gaintbl[curr_gaintbl_index].txpwrindex;
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			wlc_phy_rfctrl_override_1tomany_nphy(pi,
+							     NPHY_REV7_RfctrlOverride_cmd_rxgain,
+							     ((lpf_biq1 << 12) |
+							      (lpf_biq0 << 8) |
+							      (mix_tia_gain <<
+							       4) | (lna2 << 2)
+							      | lna1), 0x3, 0);
+		} else {
+			wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12),
+						     ((hpvga << 12) |
+						      (lpf_biq1 << 10) |
+						      (lpf_biq0 << 8) |
+						      (mix_tia_gain << 4) |
+						      (lna2 << 2) | lna1), 0x3,
+						     0);
+		}
+
+		pi->nphy_rxcal_pwr_idx[tx_core] = txpwrindex;
+
+		if (txpwrindex == -1) {
+			nphy_rxcal_txgain[0] = 0x8ff0 | pi->nphy_gmval;
+			nphy_rxcal_txgain[1] = 0x8ff0 | pi->nphy_gmval;
+			wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ,
+						 2, 0x110, 16,
+						 nphy_rxcal_txgain);
+		} else {
+			wlc_phy_txpwr_index_nphy(pi, tx_core + 1, txpwrindex,
+						 FALSE);
+		}
+
+		wlc_phy_tx_tone_nphy(pi, (CHSPEC_IS40(pi->radio_chanspec)) ?
+				     NPHY_RXCAL_TONEFREQ_40MHz :
+				     NPHY_RXCAL_TONEFREQ_20MHz,
+				     NPHY_RXCAL_TONEAMP, 0, cal_type, FALSE);
+
+		wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
+		i_pwr = (est[rx_core].i_pwr + num_samps / 2) / num_samps;
+		q_pwr = (est[rx_core].q_pwr + num_samps / 2) / num_samps;
+		curr_pwr = i_pwr + q_pwr;
+
+		switch (gainctrl_dirn) {
+		case NPHY_RXCAL_GAIN_INIT:
+			if (curr_pwr > thresh_pwr) {
+				gainctrl_dirn = NPHY_RXCAL_GAIN_DOWN;
+				prev_gaintbl_index = curr_gaintbl_index;
+				curr_gaintbl_index--;
+			} else {
+				gainctrl_dirn = NPHY_RXCAL_GAIN_UP;
+				prev_gaintbl_index = curr_gaintbl_index;
+				curr_gaintbl_index++;
+			}
+			break;
+
+		case NPHY_RXCAL_GAIN_UP:
+			if (curr_pwr > thresh_pwr) {
+				gainctrl_done = TRUE;
+				optim_pwr = prev_pwr;
+				optim_gaintbl_index = prev_gaintbl_index;
+			} else {
+				prev_gaintbl_index = curr_gaintbl_index;
+				curr_gaintbl_index++;
+			}
+			break;
+
+		case NPHY_RXCAL_GAIN_DOWN:
+			if (curr_pwr > thresh_pwr) {
+				prev_gaintbl_index = curr_gaintbl_index;
+				curr_gaintbl_index--;
+			} else {
+				gainctrl_done = TRUE;
+				optim_pwr = curr_pwr;
+				optim_gaintbl_index = curr_gaintbl_index;
+			}
+			break;
+
+		default:
+			ASSERT(0);
+		}
+
+		if ((curr_gaintbl_index < 0) ||
+		    (curr_gaintbl_index > NPHY_IPA_RXCAL_MAXGAININDEX)) {
+			gainctrl_done = TRUE;
+			optim_pwr = curr_pwr;
+			optim_gaintbl_index = prev_gaintbl_index;
+		} else {
+			prev_pwr = curr_pwr;
+		}
+
+		wlc_phy_stopplayback_nphy(pi);
+	} while (!gainctrl_done);
+
+	hpvga = nphy_rxcal_gaintbl[optim_gaintbl_index].hpvga;
+	lpf_biq1 = nphy_rxcal_gaintbl[optim_gaintbl_index].lpf_biq1;
+	lpf_biq0 = nphy_rxcal_gaintbl[optim_gaintbl_index].lpf_biq0;
+	lna2 = nphy_rxcal_gaintbl[optim_gaintbl_index].lna2;
+	lna1 = nphy_rxcal_gaintbl[optim_gaintbl_index].lna1;
+	txpwrindex = nphy_rxcal_gaintbl[optim_gaintbl_index].txpwrindex;
+
+	actual_log2_pwr = wlc_phy_nbits(optim_pwr);
+	delta_pwr = desired_log2_pwr - actual_log2_pwr;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		fine_gain_idx = (int)lpf_biq1 + delta_pwr;
+
+		if (fine_gain_idx + (int)lpf_biq0 > 10) {
+			lpf_biq1 = 10 - lpf_biq0;
+		} else {
+			lpf_biq1 = (uint16) MAX(fine_gain_idx, 0);
+		}
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_rxgain,
+						     ((lpf_biq1 << 12) |
+						      (lpf_biq0 << 8) |
+						      (mix_tia_gain << 4) |
+						      (lna2 << 2) | lna1), 0x3,
+						     0);
+	} else {
+		hpvga = (uint16) MAX(MIN(((int)hpvga) + delta_pwr, 10), 0);
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12),
+					     ((hpvga << 12) | (lpf_biq1 << 10) |
+					      (lpf_biq0 << 8) | (mix_tia_gain <<
+								 4) | (lna2 <<
+								       2) |
+					      lna1), 0x3, 0);
+
+	}
+
+	if (rxgain != NULL) {
+		*rxgain++ = lna1;
+		*rxgain++ = lna2;
+		*rxgain++ = mix_tia_gain;
+		*rxgain++ = lpf_biq0;
+		*rxgain++ = lpf_biq1;
+		*rxgain = hpvga;
+	}
+
+	wlc_phy_rx_iq_coeffs_nphy(pi, 1, &save_comp);
+}
+
+static void
+wlc_phy_rxcal_gainctrl_nphy(phy_info_t * pi, uint8 rx_core, uint16 * rxgain,
+			    uint8 cal_type)
+{
+	wlc_phy_rxcal_gainctrl_nphy_rev5(pi, rx_core, rxgain, cal_type);
+}
+
+static uint8
+wlc_phy_rc_sweep_nphy(phy_info_t * pi, uint8 core_idx, uint8 loopback_type)
+{
+	uint32 target_bws[2] = { 9500, 21000 };
+	uint32 ref_tones[2] = { 3000, 6000 };
+	uint32 target_bw, ref_tone;
+
+	uint32 target_pwr_ratios[2] = { 28606, 18468 };
+	uint32 target_pwr_ratio, pwr_ratio, last_pwr_ratio = 0;
+
+	uint16 start_rccal_ovr_val = 128;
+	uint16 txlpf_rccal_lpc_ovr_val = 128;
+	uint16 rxlpf_rccal_hpc_ovr_val = 159;
+
+	uint16 orig_txlpf_rccal_lpc_ovr_val;
+	uint16 orig_rxlpf_rccal_hpc_ovr_val;
+	uint16 radio_addr_offset_rx;
+	uint16 radio_addr_offset_tx;
+	uint16 orig_dcBypass;
+	uint16 orig_RxStrnFilt40Num[6];
+	uint16 orig_RxStrnFilt40Den[4];
+	uint16 orig_rfctrloverride[2];
+	uint16 orig_rfctrlauxreg[2];
+	uint16 orig_rfctrlrssiothers;
+	uint16 tx_lpf_bw = 4;
+
+	uint16 rx_lpf_bw, rx_lpf_bws[2] = { 2, 4 };
+	uint16 lpf_hpc = 7, hpvga_hpc = 7;
+
+	int8 rccal_stepsize;
+	uint16 rccal_val, last_rccal_val = 0, best_rccal_val = 0;
+	uint32 ref_iq_vals = 0, target_iq_vals = 0;
+	uint16 num_samps, log_num_samps = 10;
+	phy_iq_est_t est[PHY_CORE_MAX];
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		return 0;
+	}
+
+	num_samps = (1 << log_num_samps);
+
+	if (CHSPEC_IS40(pi->radio_chanspec)) {
+		target_bw = target_bws[1];
+		target_pwr_ratio = target_pwr_ratios[1];
+		ref_tone = ref_tones[1];
+		rx_lpf_bw = rx_lpf_bws[1];
+	} else {
+		target_bw = target_bws[0];
+		target_pwr_ratio = target_pwr_ratios[0];
+		ref_tone = ref_tones[0];
+		rx_lpf_bw = rx_lpf_bws[0];
+	}
+
+	if (core_idx == 0) {
+		radio_addr_offset_rx = RADIO_2056_RX0;
+		radio_addr_offset_tx =
+		    (loopback_type == 0) ? RADIO_2056_TX0 : RADIO_2056_TX1;
+	} else {
+		radio_addr_offset_rx = RADIO_2056_RX1;
+		radio_addr_offset_tx =
+		    (loopback_type == 0) ? RADIO_2056_TX1 : RADIO_2056_TX0;
+	}
+
+	orig_txlpf_rccal_lpc_ovr_val =
+	    read_radio_reg(pi,
+			   (RADIO_2056_TX_TXLPF_RCCAL | radio_addr_offset_tx));
+	orig_rxlpf_rccal_hpc_ovr_val =
+	    read_radio_reg(pi,
+			   (RADIO_2056_RX_RXLPF_RCCAL_HPC |
+			    radio_addr_offset_rx));
+
+	orig_dcBypass = ((read_phy_reg(pi, 0x48) >> 8) & 1);
+
+	orig_RxStrnFilt40Num[0] = read_phy_reg(pi, 0x267);
+	orig_RxStrnFilt40Num[1] = read_phy_reg(pi, 0x268);
+	orig_RxStrnFilt40Num[2] = read_phy_reg(pi, 0x269);
+	orig_RxStrnFilt40Den[0] = read_phy_reg(pi, 0x26a);
+	orig_RxStrnFilt40Den[1] = read_phy_reg(pi, 0x26b);
+	orig_RxStrnFilt40Num[3] = read_phy_reg(pi, 0x26c);
+	orig_RxStrnFilt40Num[4] = read_phy_reg(pi, 0x26d);
+	orig_RxStrnFilt40Num[5] = read_phy_reg(pi, 0x26e);
+	orig_RxStrnFilt40Den[2] = read_phy_reg(pi, 0x26f);
+	orig_RxStrnFilt40Den[3] = read_phy_reg(pi, 0x270);
+
+	orig_rfctrloverride[0] = read_phy_reg(pi, 0xe7);
+	orig_rfctrloverride[1] = read_phy_reg(pi, 0xec);
+	orig_rfctrlauxreg[0] = read_phy_reg(pi, 0xf8);
+	orig_rfctrlauxreg[1] = read_phy_reg(pi, 0xfa);
+	orig_rfctrlrssiothers = read_phy_reg(pi, (core_idx == 0) ? 0x7a : 0x7d);
+
+	write_radio_reg(pi, (RADIO_2056_TX_TXLPF_RCCAL | radio_addr_offset_tx),
+			txlpf_rccal_lpc_ovr_val);
+
+	write_radio_reg(pi,
+			(RADIO_2056_RX_RXLPF_RCCAL_HPC | radio_addr_offset_rx),
+			rxlpf_rccal_hpc_ovr_val);
+
+	mod_phy_reg(pi, 0x48, (0x1 << 8), (0x1 << 8));
+
+	write_phy_reg(pi, 0x267, 0x02d4);
+	write_phy_reg(pi, 0x268, 0x0000);
+	write_phy_reg(pi, 0x269, 0x0000);
+	write_phy_reg(pi, 0x26a, 0x0000);
+	write_phy_reg(pi, 0x26b, 0x0000);
+	write_phy_reg(pi, 0x26c, 0x02d4);
+	write_phy_reg(pi, 0x26d, 0x0000);
+	write_phy_reg(pi, 0x26e, 0x0000);
+	write_phy_reg(pi, 0x26f, 0x0000);
+	write_phy_reg(pi, 0x270, 0x0000);
+
+	or_phy_reg(pi, (core_idx == 0) ? 0xe7 : 0xec, (0x1 << 8));
+	or_phy_reg(pi, (core_idx == 0) ? 0xec : 0xe7, (0x1 << 15));
+	or_phy_reg(pi, (core_idx == 0) ? 0xe7 : 0xec, (0x1 << 9));
+	or_phy_reg(pi, (core_idx == 0) ? 0xe7 : 0xec, (0x1 << 10));
+
+	mod_phy_reg(pi, (core_idx == 0) ? 0xfa : 0xf8,
+		    (0x7 << 10), (tx_lpf_bw << 10));
+	mod_phy_reg(pi, (core_idx == 0) ? 0xf8 : 0xfa,
+		    (0x7 << 0), (hpvga_hpc << 0));
+	mod_phy_reg(pi, (core_idx == 0) ? 0xf8 : 0xfa,
+		    (0x7 << 4), (lpf_hpc << 4));
+	mod_phy_reg(pi, (core_idx == 0) ? 0x7a : 0x7d,
+		    (0x7 << 8), (rx_lpf_bw << 8));
+
+	rccal_stepsize = 16;
+	rccal_val = start_rccal_ovr_val + rccal_stepsize;
+
+	while (rccal_stepsize >= 0) {
+		write_radio_reg(pi,
+				(RADIO_2056_RX_RXLPF_RCCAL_LPC |
+				 radio_addr_offset_rx), rccal_val);
+
+		if (rccal_stepsize == 16) {
+
+			wlc_phy_tx_tone_nphy(pi, ref_tone, NPHY_RXCAL_TONEAMP,
+					     0, 1, FALSE);
+			OSL_DELAY(2);
+
+			wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
+
+			if (core_idx == 0) {
+				ref_iq_vals =
+				    MAX((est[0].i_pwr +
+					 est[0].q_pwr) >> (log_num_samps + 1),
+					1);
+			} else {
+				ref_iq_vals =
+				    MAX((est[1].i_pwr +
+					 est[1].q_pwr) >> (log_num_samps + 1),
+					1);
+			}
+
+			wlc_phy_tx_tone_nphy(pi, target_bw, NPHY_RXCAL_TONEAMP,
+					     0, 1, FALSE);
+			OSL_DELAY(2);
+		}
+
+		wlc_phy_rx_iq_est_nphy(pi, est, num_samps, 32, 0);
+
+		if (core_idx == 0) {
+			target_iq_vals =
+			    (est[0].i_pwr + est[0].q_pwr) >> (log_num_samps +
+							      1);
+		} else {
+			target_iq_vals =
+			    (est[1].i_pwr + est[1].q_pwr) >> (log_num_samps +
+							      1);
+		}
+		pwr_ratio = (uint) ((target_iq_vals << 16) / ref_iq_vals);
+
+		if (rccal_stepsize == 0) {
+			rccal_stepsize--;
+		} else if (rccal_stepsize == 1) {
+			last_rccal_val = rccal_val;
+			rccal_val += (pwr_ratio > target_pwr_ratio) ? 1 : -1;
+			last_pwr_ratio = pwr_ratio;
+			rccal_stepsize--;
+		} else {
+			rccal_stepsize = (rccal_stepsize >> 1);
+			rccal_val += ((pwr_ratio > target_pwr_ratio) ?
+				      rccal_stepsize : (-rccal_stepsize));
+		}
+
+		if (rccal_stepsize == -1) {
+			best_rccal_val =
+			    (ABS((int)last_pwr_ratio - (int)target_pwr_ratio) <
+			     ABS((int)pwr_ratio -
+				 (int)target_pwr_ratio)) ? last_rccal_val :
+			    rccal_val;
+
+			if (CHSPEC_IS40(pi->radio_chanspec)) {
+				if ((best_rccal_val > 140)
+				    || (best_rccal_val < 135)) {
+					best_rccal_val = 138;
+				}
+			} else {
+				if ((best_rccal_val > 142)
+				    || (best_rccal_val < 137)) {
+					best_rccal_val = 140;
+				}
+			}
+
+			write_radio_reg(pi,
+					(RADIO_2056_RX_RXLPF_RCCAL_LPC |
+					 radio_addr_offset_rx), best_rccal_val);
+		}
+	}
+
+	wlc_phy_stopplayback_nphy(pi);
+
+	write_radio_reg(pi, (RADIO_2056_TX_TXLPF_RCCAL | radio_addr_offset_tx),
+			orig_txlpf_rccal_lpc_ovr_val);
+	write_radio_reg(pi,
+			(RADIO_2056_RX_RXLPF_RCCAL_HPC | radio_addr_offset_rx),
+			orig_rxlpf_rccal_hpc_ovr_val);
+
+	mod_phy_reg(pi, 0x48, (0x1 << 8), (orig_dcBypass << 8));
+
+	write_phy_reg(pi, 0x267, orig_RxStrnFilt40Num[0]);
+	write_phy_reg(pi, 0x268, orig_RxStrnFilt40Num[1]);
+	write_phy_reg(pi, 0x269, orig_RxStrnFilt40Num[2]);
+	write_phy_reg(pi, 0x26a, orig_RxStrnFilt40Den[0]);
+	write_phy_reg(pi, 0x26b, orig_RxStrnFilt40Den[1]);
+	write_phy_reg(pi, 0x26c, orig_RxStrnFilt40Num[3]);
+	write_phy_reg(pi, 0x26d, orig_RxStrnFilt40Num[4]);
+	write_phy_reg(pi, 0x26e, orig_RxStrnFilt40Num[5]);
+	write_phy_reg(pi, 0x26f, orig_RxStrnFilt40Den[2]);
+	write_phy_reg(pi, 0x270, orig_RxStrnFilt40Den[3]);
+
+	write_phy_reg(pi, 0xe7, orig_rfctrloverride[0]);
+	write_phy_reg(pi, 0xec, orig_rfctrloverride[1]);
+	write_phy_reg(pi, 0xf8, orig_rfctrlauxreg[0]);
+	write_phy_reg(pi, 0xfa, orig_rfctrlauxreg[1]);
+	write_phy_reg(pi, (core_idx == 0) ? 0x7a : 0x7d, orig_rfctrlrssiothers);
+
+	pi->nphy_anarxlpf_adjusted = FALSE;
+
+	return (best_rccal_val - 0x80);
+}
+
+#define WAIT_FOR_SCOPE	4000000
+static int
+wlc_phy_cal_rxiq_nphy_rev3(phy_info_t * pi, nphy_txgains_t target_gain,
+			   uint8 cal_type, bool debug)
+{
+	uint16 orig_BBConfig;
+	uint8 core_no, rx_core;
+	uint8 best_rccal[2];
+	uint16 gain_save[2];
+	uint16 cal_gain[2];
+	nphy_iqcal_params_t cal_params[2];
+	uint8 rxcore_state;
+	int8 rxlpf_rccal_hpc, txlpf_rccal_lpc;
+	int8 txlpf_idac;
+	bool phyhang_avoid_state = FALSE;
+	bool skip_rxiqcal = FALSE;
+
+	orig_BBConfig = read_phy_reg(pi, 0x01);
+	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
+		phyhang_avoid_state = pi->phyhang_avoid;
+		pi->phyhang_avoid = FALSE;
+	}
+
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, gain_save);
+
+	for (core_no = 0; core_no <= 1; core_no++) {
+		wlc_phy_iqcal_gainparams_nphy(pi, core_no, target_gain,
+					      &cal_params[core_no]);
+		cal_gain[core_no] = cal_params[core_no].cal_gain;
+	}
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, cal_gain);
+
+	rxcore_state = wlc_phy_rxcore_getstate_nphy((wlc_phy_t *) pi);
+
+	for (rx_core = 0; rx_core < pi->pubpi.phy_corenum; rx_core++) {
+
+		skip_rxiqcal =
+		    ((rxcore_state & (1 << rx_core)) == 0) ? TRUE : FALSE;
+
+		wlc_phy_rxcal_physetup_nphy(pi, rx_core);
+
+		wlc_phy_rxcal_radio_setup_nphy(pi, rx_core);
+
+		if ((!skip_rxiqcal) && ((cal_type == 0) || (cal_type == 2))) {
+
+			wlc_phy_rxcal_gainctrl_nphy(pi, rx_core, NULL, 0);
+
+			wlc_phy_tx_tone_nphy(pi,
+					     (CHSPEC_IS40(pi->radio_chanspec)) ?
+					     NPHY_RXCAL_TONEFREQ_40MHz :
+					     NPHY_RXCAL_TONEFREQ_20MHz,
+					     NPHY_RXCAL_TONEAMP, 0, cal_type,
+					     FALSE);
+
+			if (debug)
+				OSL_DELAY(WAIT_FOR_SCOPE);
+
+			wlc_phy_calc_rx_iq_comp_nphy(pi, rx_core + 1);
+			wlc_phy_stopplayback_nphy(pi);
+		}
+
+		if (((cal_type == 1) || (cal_type == 2))
+		    && NREV_LT(pi->pubpi.phy_rev, 7)) {
+
+			if (rx_core == PHY_CORE_1) {
+
+				if (rxcore_state == 1) {
+					wlc_phy_rxcore_setstate_nphy((wlc_phy_t
+								      *) pi, 3);
+				}
+
+				wlc_phy_rxcal_gainctrl_nphy(pi, rx_core, NULL,
+							    1);
+
+				best_rccal[rx_core] =
+				    wlc_phy_rc_sweep_nphy(pi, rx_core, 1);
+				pi->nphy_rccal_value = best_rccal[rx_core];
+
+				if (rxcore_state == 1) {
+					wlc_phy_rxcore_setstate_nphy((wlc_phy_t
+								      *) pi,
+								     rxcore_state);
+				}
+			}
+		}
+
+		wlc_phy_rxcal_radio_cleanup_nphy(pi, rx_core);
+
+		wlc_phy_rxcal_phycleanup_nphy(pi, rx_core);
+		wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+	}
+
+	if ((cal_type == 1) || (cal_type == 2)) {
+
+		best_rccal[0] = best_rccal[1];
+		write_radio_reg(pi,
+				(RADIO_2056_RX_RXLPF_RCCAL_LPC |
+				 RADIO_2056_RX0), (best_rccal[0] | 0x80));
+
+		for (rx_core = 0; rx_core < pi->pubpi.phy_corenum; rx_core++) {
+			rxlpf_rccal_hpc =
+			    (((int)best_rccal[rx_core] - 12) >> 1) + 10;
+			txlpf_rccal_lpc = ((int)best_rccal[rx_core] - 12) + 10;
+
+			if (PHY_IPA(pi)) {
+				txlpf_rccal_lpc += IS40MHZ(pi) ? 24 : 12;
+				txlpf_idac = IS40MHZ(pi) ? 0x0e : 0x13;
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, rx_core,
+						 TXLPF_IDAC_4, txlpf_idac);
+			}
+
+			rxlpf_rccal_hpc = MAX(MIN(rxlpf_rccal_hpc, 31), 0);
+			txlpf_rccal_lpc = MAX(MIN(txlpf_rccal_lpc, 31), 0);
+
+			write_radio_reg(pi, (RADIO_2056_RX_RXLPF_RCCAL_HPC |
+					     ((rx_core ==
+					       PHY_CORE_0) ? RADIO_2056_RX0 :
+					      RADIO_2056_RX1)),
+					(rxlpf_rccal_hpc | 0x80));
+
+			write_radio_reg(pi, (RADIO_2056_TX_TXLPF_RCCAL |
+					     ((rx_core ==
+					       PHY_CORE_0) ? RADIO_2056_TX0 :
+					      RADIO_2056_TX1)),
+					(txlpf_rccal_lpc | 0x80));
+		}
+	}
+
+	write_phy_reg(pi, 0x01, orig_BBConfig);
+
+	wlc_phy_resetcca_nphy(pi);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_rxgain,
+						     0, 0x3, 1);
+	} else {
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12), 0, 0x3, 1);
+	}
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
+				 gain_save);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 4)) {
+		pi->phyhang_avoid = phyhang_avoid_state;
+	}
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+
+	return BCME_OK;
+}
+
+static int
+wlc_phy_cal_rxiq_nphy_rev2(phy_info_t * pi, nphy_txgains_t target_gain,
+			   bool debug)
+{
+	phy_iq_est_t est[PHY_CORE_MAX];
+	uint8 core_num, rx_core, tx_core;
+	uint16 lna_vals[] = { 0x3, 0x3, 0x1 };
+	uint16 hpf1_vals[] = { 0x7, 0x2, 0x0 };
+	uint16 hpf2_vals[] = { 0x2, 0x0, 0x0 };
+	int16 curr_hpf1, curr_hpf2, curr_hpf, curr_lna;
+	int16 desired_log2_pwr, actual_log2_pwr, hpf_change;
+	uint16 orig_RfseqCoreActv, orig_AfectrlCore, orig_AfectrlOverride;
+	uint16 orig_RfctrlIntcRx, orig_RfctrlIntcTx;
+	uint16 num_samps;
+	uint32 i_pwr, q_pwr, tot_pwr[3];
+	uint8 gain_pass, use_hpf_num;
+	uint16 mask, val1, val2;
+	uint16 core_no;
+	uint16 gain_save[2];
+	uint16 cal_gain[2];
+	nphy_iqcal_params_t cal_params[2];
+	uint8 phy_bw;
+	int bcmerror = BCME_OK;
+	bool first_playtone = TRUE;
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+
+		wlc_phy_reapply_txcal_coeffs_nphy(pi);
+	}
+
+	wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, gain_save);
+
+	for (core_no = 0; core_no <= 1; core_no++) {
+		wlc_phy_iqcal_gainparams_nphy(pi, core_no, target_gain,
+					      &cal_params[core_no]);
+		cal_gain[core_no] = cal_params[core_no].cal_gain;
+	}
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, cal_gain);
+
+	num_samps = 1024;
+	desired_log2_pwr = 13;
+
+	for (core_num = 0; core_num < 2; core_num++) {
+
+		rx_core = core_num;
+		tx_core = 1 - core_num;
+
+		orig_RfseqCoreActv = read_phy_reg(pi, 0xa2);
+		orig_AfectrlCore = read_phy_reg(pi, (rx_core == PHY_CORE_0) ?
+						0xa6 : 0xa7);
+		orig_AfectrlOverride = read_phy_reg(pi, 0xa5);
+		orig_RfctrlIntcRx = read_phy_reg(pi, (rx_core == PHY_CORE_0) ?
+						 0x91 : 0x92);
+		orig_RfctrlIntcTx = read_phy_reg(pi, (tx_core == PHY_CORE_0) ?
+						 0x91 : 0x92);
+
+		mod_phy_reg(pi, 0xa2, (0xf << 12), (1 << tx_core) << 12);
+		mod_phy_reg(pi, 0xa2, (0xf << 0), (1 << tx_core) << 0);
+
+		or_phy_reg(pi, ((rx_core == PHY_CORE_0) ? 0xa6 : 0xa7),
+			   ((0x1 << 1) | (0x1 << 2)));
+		or_phy_reg(pi, 0xa5, ((0x1 << 1) | (0x1 << 2)));
+
+		if (((pi->nphy_rxcalparams) & 0xff000000)) {
+
+			write_phy_reg(pi,
+				      (rx_core == PHY_CORE_0) ? 0x91 : 0x92,
+				      (CHSPEC_IS5G(pi->radio_chanspec) ? 0x140 :
+				       0x110));
+		} else {
+
+			write_phy_reg(pi,
+				      (rx_core == PHY_CORE_0) ? 0x91 : 0x92,
+				      (CHSPEC_IS5G(pi->radio_chanspec) ? 0x180 :
+				       0x120));
+		}
+
+		write_phy_reg(pi, (tx_core == PHY_CORE_0) ? 0x91 : 0x92,
+			      (CHSPEC_IS5G(pi->radio_chanspec) ? 0x148 :
+			       0x114));
+
+		mask = RADIO_2055_COUPLE_RX_MASK | RADIO_2055_COUPLE_TX_MASK;
+		if (rx_core == PHY_CORE_0) {
+			val1 = RADIO_2055_COUPLE_RX_MASK;
+			val2 = RADIO_2055_COUPLE_TX_MASK;
+		} else {
+			val1 = RADIO_2055_COUPLE_TX_MASK;
+			val2 = RADIO_2055_COUPLE_RX_MASK;
+		}
+
+		if ((pi->nphy_rxcalparams & 0x10000)) {
+			mod_radio_reg(pi, RADIO_2055_CORE1_GEN_SPARE2, mask,
+				      val1);
+			mod_radio_reg(pi, RADIO_2055_CORE2_GEN_SPARE2, mask,
+				      val2);
+		}
+
+		for (gain_pass = 0; gain_pass < 4; gain_pass++) {
+
+			if (debug)
+				OSL_DELAY(WAIT_FOR_SCOPE);
+
+			if (gain_pass < 3) {
+				curr_lna = lna_vals[gain_pass];
+				curr_hpf1 = hpf1_vals[gain_pass];
+				curr_hpf2 = hpf2_vals[gain_pass];
+			} else {
+
+				if (tot_pwr[1] > 10000) {
+					curr_lna = lna_vals[2];
+					curr_hpf1 = hpf1_vals[2];
+					curr_hpf2 = hpf2_vals[2];
+					use_hpf_num = 1;
+					curr_hpf = curr_hpf1;
+					actual_log2_pwr =
+					    wlc_phy_nbits(tot_pwr[2]);
+				} else {
+					if (tot_pwr[0] > 10000) {
+						curr_lna = lna_vals[1];
+						curr_hpf1 = hpf1_vals[1];
+						curr_hpf2 = hpf2_vals[1];
+						use_hpf_num = 1;
+						curr_hpf = curr_hpf1;
+						actual_log2_pwr =
+						    wlc_phy_nbits(tot_pwr[1]);
+					} else {
+						curr_lna = lna_vals[0];
+						curr_hpf1 = hpf1_vals[0];
+						curr_hpf2 = hpf2_vals[0];
+						use_hpf_num = 2;
+						curr_hpf = curr_hpf2;
+						actual_log2_pwr =
+						    wlc_phy_nbits(tot_pwr[0]);
+					}
+				}
+
+				hpf_change = desired_log2_pwr - actual_log2_pwr;
+				curr_hpf += hpf_change;
+				curr_hpf = MAX(MIN(curr_hpf, 10), 0);
+				if (use_hpf_num == 1) {
+					curr_hpf1 = curr_hpf;
+				} else {
+					curr_hpf2 = curr_hpf;
+				}
+			}
+
+			wlc_phy_rfctrl_override_nphy(pi, (0x1 << 10),
+						     ((curr_hpf2 << 8) |
+						      (curr_hpf1 << 4) |
+						      (curr_lna << 2)), 0x3, 0);
+			wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+
+			wlc_phy_stopplayback_nphy(pi);
+
+			if (first_playtone) {
+				bcmerror = wlc_phy_tx_tone_nphy(pi, 4000,
+								(uint16) (pi->
+									  nphy_rxcalparams
+									  &
+									  0xffff),
+								0, 0, TRUE);
+				first_playtone = FALSE;
+			} else {
+				phy_bw =
+				    (CHSPEC_IS40(pi->radio_chanspec)) ? 40 : 20;
+				wlc_phy_runsamples_nphy(pi, phy_bw * 8, 0xffff,
+							0, 0, 0, TRUE);
+			}
+
+			if (bcmerror == BCME_OK) {
+				if (gain_pass < 3) {
+
+					wlc_phy_rx_iq_est_nphy(pi, est,
+							       num_samps, 32,
+							       0);
+					i_pwr =
+					    (est[rx_core].i_pwr +
+					     num_samps / 2) / num_samps;
+					q_pwr =
+					    (est[rx_core].q_pwr +
+					     num_samps / 2) / num_samps;
+					tot_pwr[gain_pass] = i_pwr + q_pwr;
+				} else {
+
+					wlc_phy_calc_rx_iq_comp_nphy(pi,
+								     (1 <<
+								      rx_core));
+				}
+
+				wlc_phy_stopplayback_nphy(pi);
+			}
+
+			if (bcmerror != BCME_OK)
+				break;
+		}
+
+		and_radio_reg(pi, RADIO_2055_CORE1_GEN_SPARE2, ~mask);
+		and_radio_reg(pi, RADIO_2055_CORE2_GEN_SPARE2, ~mask);
+
+		write_phy_reg(pi, (tx_core == PHY_CORE_0) ? 0x91 :
+			      0x92, orig_RfctrlIntcTx);
+		write_phy_reg(pi, (rx_core == PHY_CORE_0) ? 0x91 :
+			      0x92, orig_RfctrlIntcRx);
+		write_phy_reg(pi, 0xa5, orig_AfectrlOverride);
+		write_phy_reg(pi, (rx_core == PHY_CORE_0) ? 0xa6 :
+			      0xa7, orig_AfectrlCore);
+		write_phy_reg(pi, 0xa2, orig_RfseqCoreActv);
+
+		if (bcmerror != BCME_OK)
+			break;
+	}
+
+	wlc_phy_rfctrl_override_nphy(pi, (0x1 << 10), 0, 0x3, 1);
+	wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16,
+				 gain_save);
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+
+	return bcmerror;
+}
+
+int
+wlc_phy_cal_rxiq_nphy(phy_info_t * pi, nphy_txgains_t target_gain,
+		      uint8 cal_type, bool debug)
+{
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		cal_type = 0;
+	}
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		return wlc_phy_cal_rxiq_nphy_rev3(pi, target_gain, cal_type,
+						  debug);
+	} else {
+		return wlc_phy_cal_rxiq_nphy_rev2(pi, target_gain, debug);
+	}
+}
+
+static void wlc_phy_extpa_set_tx_digi_filts_nphy(phy_info_t * pi)
+{
+	int j, type = 2;
+	uint16 addr_offset = 0x2c5;
+
+	for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
+		write_phy_reg(pi, addr_offset + j,
+			      NPHY_IPA_REV4_txdigi_filtcoeffs[type][j]);
+	}
+}
+
+static void wlc_phy_ipa_set_tx_digi_filts_nphy(phy_info_t * pi)
+{
+	int j, type;
+	uint16 addr_offset[] = { 0x186, 0x195,
+		0x2c5
+	};
+
+	for (type = 0; type < 3; type++) {
+		for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
+			write_phy_reg(pi, addr_offset[type] + j,
+				      NPHY_IPA_REV4_txdigi_filtcoeffs[type][j]);
+		}
+	}
+
+	if (IS40MHZ(pi)) {
+		for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
+			write_phy_reg(pi, 0x186 + j,
+				      NPHY_IPA_REV4_txdigi_filtcoeffs[3][j]);
+		}
+	} else {
+		if (CHSPEC_IS5G(pi->radio_chanspec)) {
+			for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
+				write_phy_reg(pi, 0x186 + j,
+					      NPHY_IPA_REV4_txdigi_filtcoeffs[5]
+					      [j]);
+			}
+		}
+
+		if (CHSPEC_CHANNEL(pi->radio_chanspec) == 14) {
+			for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
+				write_phy_reg(pi, 0x2c5 + j,
+					      NPHY_IPA_REV4_txdigi_filtcoeffs[6]
+					      [j]);
+			}
+		}
+	}
+}
+
+static void wlc_phy_ipa_restore_tx_digi_filts_nphy(phy_info_t * pi)
+{
+	int j;
+
+	if (IS40MHZ(pi)) {
+		for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
+			write_phy_reg(pi, 0x195 + j,
+				      NPHY_IPA_REV4_txdigi_filtcoeffs[4][j]);
+		}
+	} else {
+		for (j = 0; j < NPHY_NUM_DIG_FILT_COEFFS; j++) {
+			write_phy_reg(pi, 0x186 + j,
+				      NPHY_IPA_REV4_txdigi_filtcoeffs[3][j]);
+		}
+	}
+}
+
+static uint16 wlc_phy_ipa_get_bbmult_nphy(phy_info_t * pi)
+{
+	uint16 m0m1;
+
+	wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);
+
+	return m0m1;
+}
+
+static void wlc_phy_ipa_set_bbmult_nphy(phy_info_t * pi, uint8 m0, uint8 m1)
+{
+	uint16 m0m1 = (uint16) ((m0 << 8) | m1);
+
+	wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m0m1);
+	wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &m0m1);
+}
+
+static uint32 *wlc_phy_get_ipa_gaintbl_nphy(phy_info_t * pi)
+{
+	uint32 *tx_pwrctrl_tbl = NULL;
+
+	if (CHSPEC_IS2G(pi->radio_chanspec)) {
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+			if ((pi->pubpi.radiorev == 4)
+			    || (pi->pubpi.radiorev == 6)) {
+
+				tx_pwrctrl_tbl =
+				    nphy_tpc_txgain_ipa_2g_2057rev4n6;
+			} else if (pi->pubpi.radiorev == 3) {
+
+				tx_pwrctrl_tbl =
+				    nphy_tpc_txgain_ipa_2g_2057rev3;
+			} else if (pi->pubpi.radiorev == 5) {
+
+				tx_pwrctrl_tbl =
+				    nphy_tpc_txgain_ipa_2g_2057rev5;
+			} else if ((pi->pubpi.radiorev == 7)
+				   || (pi->pubpi.radiorev == 8)) {
+
+				tx_pwrctrl_tbl =
+				    nphy_tpc_txgain_ipa_2g_2057rev7;
+			} else {
+				ASSERT(0);
+			}
+
+		} else if (NREV_IS(pi->pubpi.phy_rev, 6)) {
+
+			tx_pwrctrl_tbl = nphy_tpc_txgain_ipa_rev6;
+			if (CHIPID(pi->sh->chip) == BCM47162_CHIP_ID) {
+
+				tx_pwrctrl_tbl = nphy_tpc_txgain_ipa_rev5;
+			}
+
+		} else if (NREV_IS(pi->pubpi.phy_rev, 5)) {
+
+			tx_pwrctrl_tbl = nphy_tpc_txgain_ipa_rev5;
+		} else {
+
+			tx_pwrctrl_tbl = nphy_tpc_txgain_ipa;
+		}
+
+	} else {
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			if ((pi->pubpi.radiorev == 3) ||
+			    (pi->pubpi.radiorev == 4) ||
+			    (pi->pubpi.radiorev == 6)) {
+
+				tx_pwrctrl_tbl = nphy_tpc_txgain_ipa_5g_2057;
+			} else if ((pi->pubpi.radiorev == 7)
+				   || (pi->pubpi.radiorev == 8)) {
+
+				tx_pwrctrl_tbl =
+				    nphy_tpc_txgain_ipa_5g_2057rev7;
+			} else {
+				ASSERT(0);
+			}
+
+		} else {
+			tx_pwrctrl_tbl = nphy_tpc_txgain_ipa_5g;
+		}
+	}
+
+	return tx_pwrctrl_tbl;
+}
+
+static void
+wlc_phy_papd_cal_setup_nphy(phy_info_t * pi, nphy_papd_restore_state * state,
+			    uint8 core)
+{
+	int32 tone_freq;
+	uint8 off_core;
+	uint16 mixgain = 0;
+
+	off_core = core ^ 0x1;
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		if (NREV_IS(pi->pubpi.phy_rev, 7)
+		    || NREV_GE(pi->pubpi.phy_rev, 8)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 7),
+							  wlc_phy_read_lpf_bw_ctl_nphy
+							  (pi, 0), 0, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		}
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			if (pi->pubpi.radiorev == 5) {
+				mixgain = (core == 0) ? 0x20 : 0x00;
+
+			} else if ((pi->pubpi.radiorev == 7)
+				   || (pi->pubpi.radiorev == 8)) {
+
+				mixgain = 0x00;
+
+			} else if ((pi->pubpi.radiorev <= 4)
+				   || (pi->pubpi.radiorev == 6)) {
+
+				mixgain = 0x00;
+			} else {
+				ASSERT(0);
+			}
+
+		} else {
+			if ((pi->pubpi.radiorev == 4) ||
+			    (pi->pubpi.radiorev == 6)) {
+
+				mixgain = 0x50;
+			} else if ((pi->pubpi.radiorev == 3)
+				   || (pi->pubpi.radiorev == 7)
+				   || (pi->pubpi.radiorev == 8)) {
+
+				mixgain = 0x0;
+			} else {
+				ASSERT(0);
+			}
+		}
+
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 11),
+						  mixgain, (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_tx_pu,
+						     1, (1 << core), 0);
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_tx_pu,
+						     0, (1 << off_core), 0);
+
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3),
+						  0, 0x3, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2), 1,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 0), 0,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1), 1,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 8), 0,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 9), 1,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 10), 0,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3), 1,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 5),
+						  0, (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 4), 0,
+						  (1 << core), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+
+		state->afectrl[core] = read_phy_reg(pi, (core == PHY_CORE_0) ?
+						    0xa6 : 0xa7);
+		state->afeoverride[core] =
+		    read_phy_reg(pi, (core == PHY_CORE_0) ? 0x8f : 0xa5);
+		state->afectrl[off_core] =
+		    read_phy_reg(pi, (core == PHY_CORE_0) ? 0xa7 : 0xa6);
+		state->afeoverride[off_core] =
+		    read_phy_reg(pi, (core == PHY_CORE_0) ? 0xa5 : 0x8f);
+
+		mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0xa6 : 0xa7),
+			    (0x1 << 2), 0);
+		mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0x8f :
+				 0xa5), (0x1 << 2), (0x1 << 2));
+
+		mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0xa7 : 0xa6),
+			    (0x1 << 2), (0x1 << 2));
+		mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0xa5 :
+				 0x8f), (0x1 << 2), (0x1 << 2));
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			state->pwrup[core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    TXRXCOUPLE_2G_PWRUP);
+			state->atten[core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    TXRXCOUPLE_2G_ATTEN);
+			state->pwrup[off_core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					    TXRXCOUPLE_2G_PWRUP);
+			state->atten[off_core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					    TXRXCOUPLE_2G_ATTEN);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+					 TXRXCOUPLE_2G_PWRUP, 0xc);
+
+			if ((pi->pubpi.radiorev == 3) ||
+			    (pi->pubpi.radiorev == 4) ||
+			    (pi->pubpi.radiorev == 6)) {
+
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_2G_ATTEN, 0xf0);
+
+			} else if (pi->pubpi.radiorev == 5) {
+
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_2G_ATTEN,
+						 (core == 0) ? 0xf7 : 0xf2);
+
+			} else if ((pi->pubpi.radiorev == 7)
+				   || (pi->pubpi.radiorev == 8)) {
+
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_2G_ATTEN, 0xf0);
+
+			} else {
+				ASSERT(0);
+			}
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					 TXRXCOUPLE_2G_PWRUP, 0x0);
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					 TXRXCOUPLE_2G_ATTEN, 0xff);
+
+		} else {
+			state->pwrup[core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    TXRXCOUPLE_5G_PWRUP);
+			state->atten[core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, core,
+					    TXRXCOUPLE_5G_ATTEN);
+			state->pwrup[off_core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					    TXRXCOUPLE_5G_PWRUP);
+			state->atten[off_core] =
+			    READ_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					    TXRXCOUPLE_5G_ATTEN);
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+					 TXRXCOUPLE_5G_PWRUP, 0xc);
+
+			if ((pi->pubpi.radiorev == 7)
+			    || (pi->pubpi.radiorev == 8)) {
+
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_5G_ATTEN, 0xf4);
+
+			} else {
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_5G_ATTEN, 0xf0);
+			}
+
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					 TXRXCOUPLE_5G_PWRUP, 0x0);
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, off_core,
+					 TXRXCOUPLE_5G_ATTEN, 0xff);
+		}
+
+		tone_freq = 4000;
+
+		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, FALSE);
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (NPHY_PAPD_COMP_ON) << 0);
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 13), (1) << 13);
+
+		mod_phy_reg(pi, (off_core == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (NPHY_PAPD_COMP_OFF) << 0);
+
+		mod_phy_reg(pi, (off_core == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 13), (0) << 13);
+
+	} else {
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12), 0, 0x3, 0);
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 3), 1, 0, 0);
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 0), 0, 0x3, 0);
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 2), 1, 0x3, 0);
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 1), 1, 0x3, 0);
+
+		state->afectrl[core] = read_phy_reg(pi, (core == PHY_CORE_0) ?
+						    0xa6 : 0xa7);
+		state->afeoverride[core] =
+		    read_phy_reg(pi, (core == PHY_CORE_0) ? 0x8f : 0xa5);
+
+		mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0xa6 : 0xa7),
+			    (0x1 << 0) | (0x1 << 1) | (0x1 << 2), 0);
+		mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0x8f :
+				 0xa5),
+			    (0x1 << 0) |
+			    (0x1 << 1) |
+			    (0x1 << 2), (0x1 << 0) | (0x1 << 1) | (0x1 << 2));
+
+		state->vga_master[core] =
+		    READ_RADIO_REG2(pi, RADIO_2056, RX, core, VGA_MASTER);
+		WRITE_RADIO_REG2(pi, RADIO_2056, RX, core, VGA_MASTER, 0x2b);
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			state->fbmix[core] =
+			    READ_RADIO_REG2(pi, RADIO_2056, RX, core,
+					    TXFBMIX_G);
+			state->intpa_master[core] =
+			    READ_RADIO_REG2(pi, RADIO_2056, TX, core,
+					    INTPAG_MASTER);
+
+			WRITE_RADIO_REG2(pi, RADIO_2056, RX, core, TXFBMIX_G,
+					 0x03);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 INTPAG_MASTER, 0x04);
+		} else {
+			state->fbmix[core] =
+			    READ_RADIO_REG2(pi, RADIO_2056, RX, core,
+					    TXFBMIX_A);
+			state->intpa_master[core] =
+			    READ_RADIO_REG2(pi, RADIO_2056, TX, core,
+					    INTPAA_MASTER);
+
+			WRITE_RADIO_REG2(pi, RADIO_2056, RX, core, TXFBMIX_A,
+					 0x03);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+					 INTPAA_MASTER, 0x04);
+
+		}
+
+		tone_freq = 4000;
+
+		wlc_phy_tx_tone_nphy(pi, tone_freq, 181, 0, 0, FALSE);
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (1) << 0);
+
+		mod_phy_reg(pi, (off_core == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (0) << 0);
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 3), 0, 0x3, 0);
+	}
+}
+
+static void
+wlc_phy_papd_cal_cleanup_nphy(phy_info_t * pi, nphy_papd_restore_state * state)
+{
+	uint8 core;
+
+	wlc_phy_stopplayback_nphy(pi);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_2G_PWRUP, 0);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_2G_ATTEN,
+						 state->atten[core]);
+			} else {
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_5G_PWRUP, 0);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TXRXCOUPLE_5G_ATTEN,
+						 state->atten[core]);
+			}
+		}
+
+		if ((pi->pubpi.radiorev == 4) || (pi->pubpi.radiorev == 6)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2),
+							  1, 0x3, 0,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		} else {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2),
+							  0, 0x3, 1,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		}
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1),
+						  0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 0), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 11), 1, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 11), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 12), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 2), 1, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 0), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 1), 1, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID2);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 8), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 9), 1, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 10), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3), 1, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 5), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 4), 0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+			write_phy_reg(pi, (core == PHY_CORE_0) ?
+				      0xa6 : 0xa7, state->afectrl[core]);
+			write_phy_reg(pi, (core == PHY_CORE_0) ? 0x8f :
+				      0xa5, state->afeoverride[core]);
+		}
+
+		wlc_phy_ipa_set_bbmult_nphy(pi, (state->mm >> 8) & 0xff,
+					    (state->mm & 0xff));
+
+		if (NREV_IS(pi->pubpi.phy_rev, 7)
+		    || NREV_GE(pi->pubpi.phy_rev, 8)) {
+			wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 7), 0, 0,
+							  1,
+							  NPHY_REV7_RFCTRLOVERRIDE_ID1);
+		}
+	} else {
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 12), 0, 0x3, 1);
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 13), 0, 0x3, 1);
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 0), 0, 0x3, 1);
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 2), 0, 0x3, 1);
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 1), 0, 0x3, 1);
+
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+			WRITE_RADIO_REG2(pi, RADIO_2056, RX, core, VGA_MASTER,
+					 state->vga_master[core]);
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				WRITE_RADIO_REG2(pi, RADIO_2056, RX, core,
+						 TXFBMIX_G, state->fbmix[core]);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAG_MASTER,
+						 state->intpa_master[core]);
+			} else {
+				WRITE_RADIO_REG2(pi, RADIO_2056, RX, core,
+						 TXFBMIX_A, state->fbmix[core]);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 INTPAA_MASTER,
+						 state->intpa_master[core]);
+			}
+
+			write_phy_reg(pi, (core == PHY_CORE_0) ?
+				      0xa6 : 0xa7, state->afectrl[core]);
+			write_phy_reg(pi, (core == PHY_CORE_0) ? 0x8f :
+				      0xa5, state->afeoverride[core]);
+		}
+
+		wlc_phy_ipa_set_bbmult_nphy(pi, (state->mm >> 8) & 0xff,
+					    (state->mm & 0xff));
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 3), 0, 0x3, 1);
+	}
+}
+
+static void
+wlc_phy_a1_nphy(phy_info_t * pi, uint8 core, uint32 winsz, uint32 start,
+		uint32 end)
+{
+	uint32 *buf, *src, *dst, sz;
+
+	sz = end - start + 1;
+	ASSERT(end > start);
+	ASSERT(end < NPHY_PAPD_EPS_TBL_SIZE);
+
+	if (NULL ==
+	    (buf =
+	     MALLOC(pi->sh->osh,
+		    2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE))) {
+		return;
+	}
+
+	src = buf;
+	dst = buf + NPHY_PAPD_EPS_TBL_SIZE;
+
+	wlc_phy_table_read_nphy(pi,
+				(core ==
+				 PHY_CORE_0 ? NPHY_TBL_ID_EPSILONTBL0 :
+				 NPHY_TBL_ID_EPSILONTBL1),
+				NPHY_PAPD_EPS_TBL_SIZE, 0, 32, src);
+
+	do {
+		uint32 phy_a1, phy_a2;
+		int32 phy_a3, phy_a4, phy_a5, phy_a6, phy_a7;
+
+		phy_a1 = end - MIN(end, (winsz >> 1));
+		phy_a2 = MIN(NPHY_PAPD_EPS_TBL_SIZE - 1, end + (winsz >> 1));
+		phy_a3 = phy_a2 - phy_a1 + 1;
+		phy_a6 = 0;
+		phy_a7 = 0;
+
+		do {
+			wlc_phy_papd_decode_epsilon(src[phy_a2], &phy_a4,
+						    &phy_a5);
+			phy_a6 += phy_a4;
+			phy_a7 += phy_a5;
+		} while (phy_a2-- != phy_a1);
+
+		phy_a6 /= phy_a3;
+		phy_a7 /= phy_a3;
+		dst[end] = ((uint32) phy_a7 << 13) | ((uint32) phy_a6 & 0x1fff);
+	} while (end-- != start);
+
+	wlc_phy_table_write_nphy(pi,
+				 (core ==
+				  PHY_CORE_0) ? NPHY_TBL_ID_EPSILONTBL0 :
+				 NPHY_TBL_ID_EPSILONTBL1, sz, start, 32, dst);
+
+	MFREE(pi->sh->osh, buf, 2 * sizeof(uint32) * NPHY_PAPD_EPS_TBL_SIZE);
+}
+
+static void
+wlc_phy_a2_nphy(phy_info_t * pi, nphy_ipa_txcalgains_t * txgains,
+		phy_cal_mode_t cal_mode, uint8 core)
+{
+	uint16 phy_a1, phy_a2, phy_a3;
+	uint16 phy_a4, phy_a5;
+	bool phy_a6;
+	uint8 phy_a7, m[2];
+	uint32 phy_a8 = 0;
+	nphy_txgains_t phy_a9;
+
+	if (NREV_LT(pi->pubpi.phy_rev, 3))
+		return;
+
+	phy_a7 = (core == PHY_CORE_0) ? 1 : 0;
+
+	ASSERT((cal_mode == CAL_FULL) || (cal_mode == CAL_GCTRL)
+	       || (cal_mode == CAL_SOFT));
+	phy_a6 = ((cal_mode == CAL_GCTRL)
+		  || (cal_mode == CAL_SOFT)) ? TRUE : FALSE;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		phy_a9 = wlc_phy_get_tx_gain_nphy(pi);
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			phy_a5 = ((phy_a9.txlpf[core] << 15) |
+				  (phy_a9.txgm[core] << 12) |
+				  (phy_a9.pga[core] << 8) |
+				  (txgains->gains.pad[core] << 3) |
+				  (phy_a9.ipa[core]));
+		} else {
+			phy_a5 = ((phy_a9.txlpf[core] << 15) |
+				  (phy_a9.txgm[core] << 12) |
+				  (txgains->gains.pga[core] << 8) |
+				  (phy_a9.pad[core] << 3) | (phy_a9.ipa[core]));
+		}
+
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_txgain,
+						     phy_a5, (1 << core), 0);
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			if ((pi->pubpi.radiorev <= 4)
+			    || (pi->pubpi.radiorev == 6)) {
+
+				m[core] = IS40MHZ(pi) ? 60 : 79;
+			} else {
+
+				m[core] = IS40MHZ(pi) ? 45 : 64;
+			}
+
+		} else {
+			m[core] = IS40MHZ(pi) ? 75 : 107;
+		}
+
+		m[phy_a7] = 0;
+		wlc_phy_ipa_set_bbmult_nphy(pi, m[0], m[1]);
+
+		phy_a2 = 63;
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			if (CHIPID(pi->sh->chip) == BCM6362_CHIP_ID) {
+				phy_a1 = 35;
+				phy_a3 = 35;
+			} else if ((pi->pubpi.radiorev == 4)
+				   || (pi->pubpi.radiorev == 6)) {
+				phy_a1 = 30;
+				phy_a3 = 30;
+			} else {
+				phy_a1 = 25;
+				phy_a3 = 25;
+			}
+		} else {
+			if ((pi->pubpi.radiorev == 5)
+			    || (pi->pubpi.radiorev == 7)
+			    || (pi->pubpi.radiorev == 8)) {
+				phy_a1 = 25;
+				phy_a3 = 25;
+			} else {
+				phy_a1 = 35;
+				phy_a3 = 35;
+			}
+		}
+
+		if (cal_mode == CAL_GCTRL) {
+			if ((pi->pubpi.radiorev == 5)
+			    && (CHSPEC_IS2G(pi->radio_chanspec))) {
+				phy_a1 = 55;
+			} else if (((pi->pubpi.radiorev == 7) &&
+				    (CHSPEC_IS2G(pi->radio_chanspec))) ||
+				   ((pi->pubpi.radiorev == 8) &&
+				    (CHSPEC_IS2G(pi->radio_chanspec)))) {
+				phy_a1 = 60;
+			} else {
+				phy_a1 = 63;
+			}
+
+		} else if ((cal_mode != CAL_FULL) && (cal_mode != CAL_SOFT)) {
+
+			phy_a1 = 35;
+			phy_a3 = 35;
+		}
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (1) << 0);
+
+		mod_phy_reg(pi, (phy_a7 == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (0) << 0);
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 13), (1) << 13);
+
+		mod_phy_reg(pi, (phy_a7 == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 13), (0) << 13);
+
+		write_phy_reg(pi, 0x2a1, 0x80);
+		write_phy_reg(pi, 0x2a2, 0x100);
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x7 << 4), (11) << 4);
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x7 << 8), (11) << 8);
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x7 << 0), (0x3) << 0);
+
+		write_phy_reg(pi, 0x2e5, 0x20);
+
+		mod_phy_reg(pi, 0x2a0, (0x3f << 0), (phy_a3) << 0);
+
+		mod_phy_reg(pi, 0x29f, (0x3f << 0), (phy_a1) << 0);
+
+		mod_phy_reg(pi, 0x29f, (0x3f << 8), (phy_a2) << 8);
+
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3),
+						  1, ((core == 0) ? 1 : 2), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3),
+						  0, ((core == 0) ? 2 : 1), 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+
+		write_phy_reg(pi, 0x2be, 1);
+		SPINWAIT(read_phy_reg(pi, 0x2be), 10 * 1000 * 1000);
+
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 3),
+						  0, 0x3, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+
+		wlc_phy_table_write_nphy(pi,
+					 (core ==
+					  PHY_CORE_0) ? NPHY_TBL_ID_EPSILONTBL0
+					 : NPHY_TBL_ID_EPSILONTBL1, 1, phy_a3,
+					 32, &phy_a8);
+
+		if (cal_mode != CAL_GCTRL) {
+			if (CHSPEC_IS5G(pi->radio_chanspec)) {
+				wlc_phy_a1_nphy(pi, core, 5, 0, 35);
+			}
+		}
+
+		wlc_phy_rfctrl_override_1tomany_nphy(pi,
+						     NPHY_REV7_RfctrlOverride_cmd_txgain,
+						     phy_a5, (1 << core), 1);
+
+	} else {
+
+		if (txgains) {
+			if (txgains->useindex) {
+				phy_a4 = 15 - ((txgains->index) >> 3);
+				if (CHSPEC_IS2G(pi->radio_chanspec)) {
+					if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+						phy_a5 = 0x00f7 | (phy_a4 << 8);
+
+						if (CHIPID(pi->sh->chip) ==
+						    BCM47162_CHIP_ID) {
+							phy_a5 =
+							    0x10f7 | (phy_a4 <<
+								      8);
+						}
+					} else
+					    if (NREV_IS(pi->pubpi.phy_rev, 5))
+						phy_a5 = 0x10f7 | (phy_a4 << 8);
+					else
+						phy_a5 = 0x50f7 | (phy_a4 << 8);
+				} else {
+					phy_a5 = 0x70f7 | (phy_a4 << 8);
+				}
+				wlc_phy_rfctrl_override_nphy(pi,
+							     (0x1 << 13),
+							     phy_a5,
+							     (1 << core), 0);
+			} else {
+				wlc_phy_rfctrl_override_nphy(pi,
+							     (0x1 << 13),
+							     0x5bf7,
+							     (1 << core), 0);
+			}
+		}
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			m[core] = IS40MHZ(pi) ? 45 : 64;
+		} else {
+			m[core] = IS40MHZ(pi) ? 75 : 107;
+		}
+
+		m[phy_a7] = 0;
+		wlc_phy_ipa_set_bbmult_nphy(pi, m[0], m[1]);
+
+		phy_a2 = 63;
+
+		if (cal_mode == CAL_FULL) {
+			phy_a1 = 25;
+			phy_a3 = 25;
+		} else if (cal_mode == CAL_SOFT) {
+			phy_a1 = 25;
+			phy_a3 = 25;
+		} else if (cal_mode == CAL_GCTRL) {
+			phy_a1 = 63;
+			phy_a3 = 25;
+		} else {
+
+			phy_a1 = 25;
+			phy_a3 = 25;
+		}
+
+		mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (1) << 0);
+
+		mod_phy_reg(pi, (phy_a7 == PHY_CORE_0) ? 0x297 :
+			    0x29b, (0x1 << 0), (0) << 0);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0x1 << 13), (1) << 13);
+
+			mod_phy_reg(pi, (phy_a7 == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0x1 << 13), (0) << 13);
+
+			write_phy_reg(pi, 0x2a1, 0x20);
+			write_phy_reg(pi, 0x2a2, 0x60);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0xf << 4), (9) << 4);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0xf << 8), (9) << 8);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0xf << 0), (0x2) << 0);
+
+			write_phy_reg(pi, 0x2e5, 0x20);
+		} else {
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0x1 << 11), (1) << 11);
+
+			mod_phy_reg(pi, (phy_a7 == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0x1 << 11), (0) << 11);
+
+			write_phy_reg(pi, 0x2a1, 0x80);
+			write_phy_reg(pi, 0x2a2, 0x600);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0x7 << 4), (0) << 4);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0x7 << 8), (0) << 8);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x2a3 :
+				    0x2a4, (0x7 << 0), (0x3) << 0);
+
+			mod_phy_reg(pi, 0x2a0, (0x3f << 8), (0x20) << 8);
+
+		}
+
+		mod_phy_reg(pi, 0x2a0, (0x3f << 0), (phy_a3) << 0);
+
+		mod_phy_reg(pi, 0x29f, (0x3f << 0), (phy_a1) << 0);
+
+		mod_phy_reg(pi, 0x29f, (0x3f << 8), (phy_a2) << 8);
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 3), 1, 0x3, 0);
+
+		write_phy_reg(pi, 0x2be, 1);
+		SPINWAIT(read_phy_reg(pi, 0x2be), 10 * 1000 * 1000);
+
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 3), 0, 0x3, 0);
+
+		wlc_phy_table_write_nphy(pi,
+					 (core ==
+					  PHY_CORE_0) ? NPHY_TBL_ID_EPSILONTBL0
+					 : NPHY_TBL_ID_EPSILONTBL1, 1, phy_a3,
+					 32, &phy_a8);
+
+		if (cal_mode != CAL_GCTRL) {
+			wlc_phy_a1_nphy(pi, core, 5, 0, 40);
+		}
+	}
+}
+
+static uint8 wlc_phy_a3_nphy(phy_info_t * pi, uint8 start_gain, uint8 core)
+{
+	int phy_a1;
+	int phy_a2;
+	bool phy_a3;
+	nphy_ipa_txcalgains_t phy_a4;
+	bool phy_a5 = FALSE;
+	bool phy_a6 = TRUE;
+	int32 phy_a7, phy_a8;
+	uint32 phy_a9;
+	int phy_a10;
+	bool phy_a11 = FALSE;
+	int phy_a12;
+	uint8 phy_a13 = 0;
+	uint8 phy_a14;
+	uint8 *phy_a15 = NULL;
+
+	phy_a4.useindex = TRUE;
+	phy_a12 = start_gain;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+
+		phy_a2 = 20;
+		phy_a1 = 1;
+
+		if (CHSPEC_IS2G(pi->radio_chanspec)) {
+			if (pi->pubpi.radiorev == 5) {
+
+				phy_a15 = pad_gain_codes_used_2057rev5;
+				phy_a13 = sizeof(pad_gain_codes_used_2057rev5) /
+				    sizeof(pad_gain_codes_used_2057rev5[0]) - 1;
+
+			} else if ((pi->pubpi.radiorev == 7)
+				   || (pi->pubpi.radiorev == 8)) {
+
+				phy_a15 = pad_gain_codes_used_2057rev7;
+				phy_a13 = sizeof(pad_gain_codes_used_2057rev7) /
+				    sizeof(pad_gain_codes_used_2057rev7[0]) - 1;
+
+			} else {
+
+				phy_a15 = pad_all_gain_codes_2057;
+				phy_a13 = sizeof(pad_all_gain_codes_2057) /
+				    sizeof(pad_all_gain_codes_2057[0]) - 1;
+			}
+
+		} else {
+
+			phy_a15 = pga_all_gain_codes_2057;
+			phy_a13 = sizeof(pga_all_gain_codes_2057) /
+			    sizeof(pga_all_gain_codes_2057[0]) - 1;
+		}
+
+		phy_a14 = 0;
+
+		for (phy_a10 = 0; phy_a10 < phy_a2; phy_a10++) {
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				phy_a4.gains.pad[core] =
+				    (uint16) phy_a15[phy_a12];
+			} else {
+				phy_a4.gains.pga[core] =
+				    (uint16) phy_a15[phy_a12];
+			}
+
+			wlc_phy_a2_nphy(pi, &phy_a4, CAL_GCTRL, core);
+
+			wlc_phy_table_read_nphy(pi,
+						(core ==
+						 PHY_CORE_0 ?
+						 NPHY_TBL_ID_EPSILONTBL0 :
+						 NPHY_TBL_ID_EPSILONTBL1), 1,
+						63, 32, &phy_a9);
+
+			wlc_phy_papd_decode_epsilon(phy_a9, &phy_a7, &phy_a8);
+
+			phy_a3 = ((phy_a7 == 4095) || (phy_a7 == -4096) ||
+				  (phy_a8 == 4095) || (phy_a8 == -4096));
+
+			if (!phy_a6 && (phy_a3 != phy_a5)) {
+				if (!phy_a3) {
+					phy_a12 -= (uint8) phy_a1;
+				}
+				phy_a11 = TRUE;
+				break;
+			}
+
+			if (phy_a3)
+				phy_a12 += (uint8) phy_a1;
+			else
+				phy_a12 -= (uint8) phy_a1;
+
+			if ((phy_a12 < phy_a14) || (phy_a12 > phy_a13)) {
+				if (phy_a12 < phy_a14) {
+					phy_a12 = phy_a14;
+				} else {
+					phy_a12 = phy_a13;
+				}
+				phy_a11 = TRUE;
+				break;
+			}
+
+			phy_a6 = FALSE;
+			phy_a5 = phy_a3;
+		}
+
+	} else {
+		phy_a2 = 10;
+		phy_a1 = 8;
+		for (phy_a10 = 0; phy_a10 < phy_a2; phy_a10++) {
+			phy_a4.index = (uint8) phy_a12;
+			wlc_phy_a2_nphy(pi, &phy_a4, CAL_GCTRL, core);
+
+			wlc_phy_table_read_nphy(pi,
+						(core ==
+						 PHY_CORE_0 ?
+						 NPHY_TBL_ID_EPSILONTBL0 :
+						 NPHY_TBL_ID_EPSILONTBL1), 1,
+						63, 32, &phy_a9);
+
+			wlc_phy_papd_decode_epsilon(phy_a9, &phy_a7, &phy_a8);
+
+			phy_a3 = ((phy_a7 == 4095) || (phy_a7 == -4096) ||
+				  (phy_a8 == 4095) || (phy_a8 == -4096));
+
+			if (!phy_a6 && (phy_a3 != phy_a5)) {
+				if (!phy_a3) {
+					phy_a12 -= (uint8) phy_a1;
+				}
+				phy_a11 = TRUE;
+				break;
+			}
+
+			if (phy_a3)
+				phy_a12 += (uint8) phy_a1;
+			else
+				phy_a12 -= (uint8) phy_a1;
+
+			if ((phy_a12 < 0) || (phy_a12 > 127)) {
+				if (phy_a12 < 0) {
+					phy_a12 = 0;
+				} else {
+					phy_a12 = 127;
+				}
+				phy_a11 = TRUE;
+				break;
+			}
+
+			phy_a6 = FALSE;
+			phy_a5 = phy_a3;
+		}
+
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		return (uint8) phy_a15[phy_a12];
+	} else {
+		return (uint8) phy_a12;
+	}
+
+}
+
+static void wlc_phy_a4(phy_info_t * pi, bool full_cal)
+{
+	nphy_ipa_txcalgains_t phy_b1[2];
+	nphy_papd_restore_state phy_b2;
+	bool phy_b3;
+	uint8 phy_b4;
+	uint8 phy_b5;
+	int16 phy_b6, phy_b7, phy_b8;
+	uint16 phy_b9;
+	int16 phy_b10, phy_b11, phy_b12;
+
+	phy_b11 = 0;
+	phy_b12 = 0;
+	phy_b7 = 0;
+	phy_b8 = 0;
+	phy_b6 = 0;
+
+	if (pi->nphy_papd_skip == 1)
+		return;
+
+	phy_b3 =
+	    (0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+	if (!phy_b3) {
+		wlapi_suspend_mac_and_wait(pi->sh->physhim);
+	}
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	pi->nphy_force_papd_cal = FALSE;
+
+	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++)
+		pi->nphy_papd_tx_gain_at_last_cal[phy_b5] =
+		    wlc_phy_txpwr_idx_cur_get_nphy(pi, phy_b5);
+
+	pi->nphy_papd_last_cal = pi->sh->now;
+	pi->nphy_papd_recal_counter++;
+
+	if (NORADIO_ENAB(pi->pubpi))
+		return;
+
+	phy_b4 = pi->nphy_txpwrctrl;
+	wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
+
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_SCALARTBL0, 64, 0, 32,
+				 nphy_papd_scaltbl);
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_SCALARTBL1, 64, 0, 32,
+				 nphy_papd_scaltbl);
+
+	phy_b9 = read_phy_reg(pi, 0x01);
+	mod_phy_reg(pi, 0x01, (0x1 << 15), 0);
+
+	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++) {
+		int32 i, val = 0;
+		for (i = 0; i < 64; i++) {
+			wlc_phy_table_write_nphy(pi,
+						 ((phy_b5 ==
+						   PHY_CORE_0) ?
+						  NPHY_TBL_ID_EPSILONTBL0 :
+						  NPHY_TBL_ID_EPSILONTBL1), 1,
+						 i, 32, &val);
+		}
+	}
+
+	wlc_phy_ipa_restore_tx_digi_filts_nphy(pi);
+
+	phy_b2.mm = wlc_phy_ipa_get_bbmult_nphy(pi);
+	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++) {
+		wlc_phy_papd_cal_setup_nphy(pi, &phy_b2, phy_b5);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+
+				if ((pi->pubpi.radiorev == 3)
+				    || (pi->pubpi.radiorev == 4)
+				    || (pi->pubpi.radiorev == 6)) {
+
+					pi->nphy_papd_cal_gain_index[phy_b5] =
+					    23;
+
+				} else if (pi->pubpi.radiorev == 5) {
+
+					pi->nphy_papd_cal_gain_index[phy_b5] =
+					    0;
+					pi->nphy_papd_cal_gain_index[phy_b5] =
+					    wlc_phy_a3_nphy(pi,
+							    pi->
+							    nphy_papd_cal_gain_index
+							    [phy_b5], phy_b5);
+
+				} else if ((pi->pubpi.radiorev == 7)
+					   || (pi->pubpi.radiorev == 8)) {
+
+					pi->nphy_papd_cal_gain_index[phy_b5] =
+					    0;
+					pi->nphy_papd_cal_gain_index[phy_b5] =
+					    wlc_phy_a3_nphy(pi,
+							    pi->
+							    nphy_papd_cal_gain_index
+							    [phy_b5], phy_b5);
+
+				} else {
+					ASSERT(0);
+				}
+
+				phy_b1[phy_b5].gains.pad[phy_b5] =
+				    pi->nphy_papd_cal_gain_index[phy_b5];
+
+			} else {
+				pi->nphy_papd_cal_gain_index[phy_b5] = 0;
+				pi->nphy_papd_cal_gain_index[phy_b5] =
+				    wlc_phy_a3_nphy(pi,
+						    pi->
+						    nphy_papd_cal_gain_index
+						    [phy_b5], phy_b5);
+				phy_b1[phy_b5].gains.pga[phy_b5] =
+				    pi->nphy_papd_cal_gain_index[phy_b5];
+			}
+		} else {
+			phy_b1[phy_b5].useindex = TRUE;
+			phy_b1[phy_b5].index = 16;
+			phy_b1[phy_b5].index =
+			    wlc_phy_a3_nphy(pi, phy_b1[phy_b5].index, phy_b5);
+
+			pi->nphy_papd_cal_gain_index[phy_b5] =
+			    15 - ((phy_b1[phy_b5].index) >> 3);
+		}
+
+		switch (pi->nphy_papd_cal_type) {
+		case 0:
+			wlc_phy_a2_nphy(pi, &phy_b1[phy_b5], CAL_FULL, phy_b5);
+			break;
+		case 1:
+			wlc_phy_a2_nphy(pi, &phy_b1[phy_b5], CAL_SOFT, phy_b5);
+			break;
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			wlc_phy_papd_cal_cleanup_nphy(pi, &phy_b2);
+		}
+	}
+
+	if (NREV_LT(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_papd_cal_cleanup_nphy(pi, &phy_b2);
+	}
+
+	for (phy_b5 = 0; phy_b5 < pi->pubpi.phy_corenum; phy_b5++) {
+		int eps_offset = 0;
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				if (pi->pubpi.radiorev == 3) {
+					eps_offset = -2;
+				} else if (pi->pubpi.radiorev == 5) {
+					eps_offset = 3;
+				} else {
+					eps_offset = -1;
+				}
+			} else {
+				eps_offset = 2;
+			}
+
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				phy_b8 = phy_b1[phy_b5].gains.pad[phy_b5];
+				phy_b10 = 0;
+				if ((pi->pubpi.radiorev == 3) ||
+				    (pi->pubpi.radiorev == 4) ||
+				    (pi->pubpi.radiorev == 6)) {
+					phy_b12 =
+					    -
+					    (nphy_papd_padgain_dlt_2g_2057rev3n4
+					     [phy_b8]
+					     + 1) / 2;
+					phy_b10 = -1;
+				} else if (pi->pubpi.radiorev == 5) {
+					phy_b12 =
+					    -(nphy_papd_padgain_dlt_2g_2057rev5
+					      [phy_b8]
+					      + 1) / 2;
+				} else if ((pi->pubpi.radiorev == 7) ||
+					   (pi->pubpi.radiorev == 8)) {
+					phy_b12 =
+					    -(nphy_papd_padgain_dlt_2g_2057rev7
+					      [phy_b8]
+					      + 1) / 2;
+				} else {
+					ASSERT(0);
+				}
+			} else {
+				phy_b7 = phy_b1[phy_b5].gains.pga[phy_b5];
+				if ((pi->pubpi.radiorev == 3) ||
+				    (pi->pubpi.radiorev == 4) ||
+				    (pi->pubpi.radiorev == 6)) {
+					phy_b11 =
+					    -(nphy_papd_pgagain_dlt_5g_2057
+					      [phy_b7]
+					      + 1) / 2;
+				} else if ((pi->pubpi.radiorev == 7)
+					   || (pi->pubpi.radiorev == 8)) {
+					phy_b11 =
+					    -(nphy_papd_pgagain_dlt_5g_2057rev7
+					      [phy_b7]
+					      + 1) / 2;
+				} else {
+					ASSERT(0);
+				}
+
+				phy_b10 = -9;
+			}
+
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				phy_b6 =
+				    -60 + 27 + eps_offset + phy_b12 + phy_b10;
+			} else {
+				phy_b6 =
+				    -60 + 27 + eps_offset + phy_b11 + phy_b10;
+			}
+
+			mod_phy_reg(pi, (phy_b5 == PHY_CORE_0) ? 0x298 :
+				    0x29c, (0x1ff << 7), (phy_b6) << 7);
+
+			pi->nphy_papd_epsilon_offset[phy_b5] = phy_b6;
+		} else {
+			if (NREV_LT(pi->pubpi.phy_rev, 5)) {
+				eps_offset = 4;
+			} else {
+				eps_offset = 2;
+			}
+
+			phy_b7 = 15 - ((phy_b1[phy_b5].index) >> 3);
+
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				phy_b11 =
+				    -(nphy_papd_pga_gain_delta_ipa_2g[phy_b7] +
+				      1) / 2;
+				phy_b10 = 0;
+			} else {
+				phy_b11 =
+				    -(nphy_papd_pga_gain_delta_ipa_5g[phy_b7] +
+				      1) / 2;
+				phy_b10 = -9;
+			}
+
+			phy_b6 = -60 + 27 + eps_offset + phy_b11 + phy_b10;
+
+			mod_phy_reg(pi, (phy_b5 == PHY_CORE_0) ? 0x298 :
+				    0x29c, (0x1ff << 7), (phy_b6) << 7);
+
+			pi->nphy_papd_epsilon_offset[phy_b5] = phy_b6;
+		}
+	}
+
+	mod_phy_reg(pi, (0 == PHY_CORE_0) ? 0x297 :
+		    0x29b, (0x1 << 0), (NPHY_PAPD_COMP_ON) << 0);
+
+	mod_phy_reg(pi, (1 == PHY_CORE_0) ? 0x297 :
+		    0x29b, (0x1 << 0), (NPHY_PAPD_COMP_ON) << 0);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 6)) {
+		mod_phy_reg(pi, (0 == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 13), (0) << 13);
+
+		mod_phy_reg(pi, (1 == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 13), (0) << 13);
+
+	} else {
+		mod_phy_reg(pi, (0 == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 11), (0) << 11);
+
+		mod_phy_reg(pi, (1 == PHY_CORE_0) ? 0x2a3 :
+			    0x2a4, (0x1 << 11), (0) << 11);
+
+	}
+	pi->nphy_papdcomp = NPHY_PAPD_COMP_ON;
+
+	write_phy_reg(pi, 0x01, phy_b9);
+
+	wlc_phy_ipa_set_tx_digi_filts_nphy(pi);
+
+	wlc_phy_txpwrctrl_enable_nphy(pi, phy_b4);
+	if (phy_b4 == PHY_TPC_HW_OFF) {
+		wlc_phy_txpwr_index_nphy(pi, (1 << 0),
+					 (int8) (pi->nphy_txpwrindex[0].
+						 index_internal), FALSE);
+		wlc_phy_txpwr_index_nphy(pi, (1 << 1),
+					 (int8) (pi->nphy_txpwrindex[1].
+						 index_internal), FALSE);
+	}
+
+	wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+
+	if (!phy_b3) {
+		wlapi_enable_mac(pi->sh->physhim);
+	}
+}
+
+void wlc_phy_txpwr_fixpower_nphy(phy_info_t * pi)
+{
+	uint core;
+	uint32 txgain;
+	uint16 rad_gain, dac_gain, bbmult, m1m2;
+	uint8 txpi[2], chan_freq_range;
+	int32 rfpwr_offset;
+
+	ASSERT(pi->nphy_txpwrctrl == PHY_TPC_HW_OFF);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	if (pi->sh->sromrev < 4) {
+		txpi[0] = txpi[1] = 72;
+	} else {
+
+		chan_freq_range = wlc_phy_get_chan_freq_range_nphy(pi, 0);
+		switch (chan_freq_range) {
+		case WL_CHAN_FREQ_RANGE_2G:
+			txpi[0] = pi->nphy_txpid2g[0];
+			txpi[1] = pi->nphy_txpid2g[1];
+			break;
+		case WL_CHAN_FREQ_RANGE_5GL:
+			txpi[0] = pi->nphy_txpid5gl[0];
+			txpi[1] = pi->nphy_txpid5gl[1];
+			break;
+		case WL_CHAN_FREQ_RANGE_5GM:
+			txpi[0] = pi->nphy_txpid5g[0];
+			txpi[1] = pi->nphy_txpid5g[1];
+			break;
+		case WL_CHAN_FREQ_RANGE_5GH:
+			txpi[0] = pi->nphy_txpid5gh[0];
+			txpi[1] = pi->nphy_txpid5gh[1];
+			break;
+		default:
+			txpi[0] = txpi[1] = 91;
+			break;
+		}
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		txpi[0] = txpi[1] = 30;
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		txpi[0] = txpi[1] = 40;
+	}
+
+	if (NREV_LT(pi->pubpi.phy_rev, 7)) {
+
+		if ((txpi[0] < 40) || (txpi[0] > 100) ||
+		    (txpi[1] < 40) || (txpi[1] > 100))
+			txpi[0] = txpi[1] = 91;
+	}
+
+	pi->nphy_txpwrindex[PHY_CORE_0].index_internal = txpi[0];
+	pi->nphy_txpwrindex[PHY_CORE_1].index_internal = txpi[1];
+	pi->nphy_txpwrindex[PHY_CORE_0].index_internal_save = txpi[0];
+	pi->nphy_txpwrindex[PHY_CORE_1].index_internal_save = txpi[1];
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			if (PHY_IPA(pi)) {
+				uint32 *tx_gaintbl =
+				    wlc_phy_get_ipa_gaintbl_nphy(pi);
+				txgain = tx_gaintbl[txpi[core]];
+			} else {
+				if (CHSPEC_IS5G(pi->radio_chanspec)) {
+					if NREV_IS
+						(pi->pubpi.phy_rev, 3) {
+						txgain =
+						    nphy_tpc_5GHz_txgain_rev3
+						    [txpi[core]];
+					} else if NREV_IS
+						(pi->pubpi.phy_rev, 4) {
+						txgain =
+						    (pi->srom_fem5g.extpagain ==
+						     3) ?
+						    nphy_tpc_5GHz_txgain_HiPwrEPA
+						    [txpi[core]] :
+						    nphy_tpc_5GHz_txgain_rev4
+						    [txpi[core]];
+					} else {
+						txgain =
+						    nphy_tpc_5GHz_txgain_rev5
+						    [txpi[core]];
+					}
+				} else {
+					if (NREV_GE(pi->pubpi.phy_rev, 5) &&
+					    (pi->srom_fem2g.extpagain == 3)) {
+						txgain =
+						    nphy_tpc_txgain_HiPwrEPA
+						    [txpi[core]];
+					} else {
+						txgain =
+						    nphy_tpc_txgain_rev3[txpi
+									 [core]];
+					}
+				}
+			}
+		} else {
+			txgain = nphy_tpc_txgain[txpi[core]];
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			rad_gain = (txgain >> 16) & ((1 << (32 - 16 + 1)) - 1);
+		} else {
+			rad_gain = (txgain >> 16) & ((1 << (28 - 16 + 1)) - 1);
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			dac_gain = (txgain >> 8) & ((1 << (10 - 8 + 1)) - 1);
+		} else {
+			dac_gain = (txgain >> 8) & ((1 << (13 - 8 + 1)) - 1);
+		}
+		bbmult = (txgain >> 0) & ((1 << (7 - 0 + 1)) - 1);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0x8f :
+					 0xa5), (0x1 << 8), (0x1 << 8));
+		} else {
+			mod_phy_reg(pi, 0xa5, (0x1 << 14), (0x1 << 14));
+		}
+		write_phy_reg(pi, (core == PHY_CORE_0) ? 0xaa : 0xab, dac_gain);
+
+		wlc_phy_table_write_nphy(pi, 7, 1, (0x110 + core), 16,
+					 &rad_gain);
+
+		wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m1m2);
+		m1m2 &= ((core == PHY_CORE_0) ? 0x00ff : 0xff00);
+		m1m2 |= ((core == PHY_CORE_0) ? (bbmult << 8) : (bbmult << 0));
+		wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m1m2);
+
+		if (PHY_IPA(pi)) {
+			wlc_phy_table_read_nphy(pi,
+						(core ==
+						 PHY_CORE_0 ?
+						 NPHY_TBL_ID_CORE1TXPWRCTL :
+						 NPHY_TBL_ID_CORE2TXPWRCTL), 1,
+						576 + txpi[core], 32,
+						&rfpwr_offset);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+				    0x29b, (0x1ff << 4),
+				    ((int16) rfpwr_offset) << 4);
+
+			mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+				    0x29b, (0x1 << 2), (1) << 2);
+
+		}
+	}
+
+	and_phy_reg(pi, 0xbf, (uint16) (~(0x1f << 0)));
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static void
+wlc_phy_txpwr_nphy_srom_convert(uint8 * srom_max, uint16 * pwr_offset,
+				uint8 tmp_max_pwr, uint8 rate_start,
+				uint8 rate_end)
+{
+	uint8 rate;
+	uint8 word_num, nibble_num;
+	uint8 tmp_nibble;
+
+	for (rate = rate_start; rate <= rate_end; rate++) {
+		word_num = (rate - rate_start) >> 2;
+		nibble_num = (rate - rate_start) & 0x3;
+		tmp_nibble = (pwr_offset[word_num] >> 4 * nibble_num) & 0xf;
+
+		srom_max[rate] = tmp_max_pwr - 2 * tmp_nibble;
+	}
+}
+
+static void
+wlc_phy_txpwr_nphy_po_apply(uint8 * srom_max, uint8 pwr_offset,
+			    uint8 rate_start, uint8 rate_end)
+{
+	uint8 rate;
+
+	for (rate = rate_start; rate <= rate_end; rate++) {
+		srom_max[rate] -= 2 * pwr_offset;
+	}
+}
+
+void
+wlc_phy_ofdm_to_mcs_powers_nphy(uint8 * power, uint8 rate_mcs_start,
+				uint8 rate_mcs_end, uint8 rate_ofdm_start)
+{
+	uint8 rate1, rate2;
+
+	rate2 = rate_ofdm_start;
+	for (rate1 = rate_mcs_start; rate1 <= rate_mcs_end - 1; rate1++) {
+		power[rate1] = power[rate2];
+		rate2 += (rate1 == rate_mcs_start) ? 2 : 1;
+	}
+	power[rate_mcs_end] = power[rate_mcs_end - 1];
+}
+
+void
+wlc_phy_mcs_to_ofdm_powers_nphy(uint8 * power, uint8 rate_ofdm_start,
+				uint8 rate_ofdm_end, uint8 rate_mcs_start)
+{
+	uint8 rate1, rate2;
+
+	for (rate1 = rate_ofdm_start, rate2 = rate_mcs_start;
+	     rate1 <= rate_ofdm_end; rate1++, rate2++) {
+		power[rate1] = power[rate2];
+		if (rate1 == rate_ofdm_start)
+			power[++rate1] = power[rate2];
+	}
+}
+
+void BCMNMIATTACHFN(wlc_phy_txpwr_apply_nphy) (phy_info_t * pi) {
+	uint rate1, rate2, band_num;
+	uint8 tmp_bw40po = 0, tmp_cddpo = 0, tmp_stbcpo = 0;
+	uint8 tmp_max_pwr = 0;
+	uint16 pwr_offsets1[2], *pwr_offsets2 = NULL;
+	uint8 *tx_srom_max_rate = NULL;
+
+	for (band_num = 0; band_num < (CH_2G_GROUP + CH_5G_GROUP); band_num++) {
+		switch (band_num) {
+		case 0:
+
+			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_2g,
+					  pi->nphy_pwrctrl_info[1].max_pwr_2g);
+
+			pwr_offsets1[0] = pi->cck2gpo;
+			wlc_phy_txpwr_nphy_srom_convert(pi->tx_srom_max_rate_2g,
+							pwr_offsets1,
+							tmp_max_pwr,
+							TXP_FIRST_CCK,
+							TXP_LAST_CCK);
+
+			pwr_offsets1[0] = (uint16) (pi->ofdm2gpo & 0xffff);
+			pwr_offsets1[1] =
+			    (uint16) (pi->ofdm2gpo >> 16) & 0xffff;
+
+			pwr_offsets2 = pi->mcs2gpo;
+
+			tmp_cddpo = pi->cdd2gpo;
+			tmp_stbcpo = pi->stbc2gpo;
+			tmp_bw40po = pi->bw402gpo;
+
+			tx_srom_max_rate = pi->tx_srom_max_rate_2g;
+			break;
+		case 1:
+
+			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gm,
+					  pi->nphy_pwrctrl_info[1].max_pwr_5gm);
+
+			pwr_offsets1[0] = (uint16) (pi->ofdm5gpo & 0xffff);
+			pwr_offsets1[1] =
+			    (uint16) (pi->ofdm5gpo >> 16) & 0xffff;
+
+			pwr_offsets2 = pi->mcs5gpo;
+
+			tmp_cddpo = pi->cdd5gpo;
+			tmp_stbcpo = pi->stbc5gpo;
+			tmp_bw40po = pi->bw405gpo;
+
+			tx_srom_max_rate = pi->tx_srom_max_rate_5g_mid;
+			break;
+		case 2:
+
+			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gl,
+					  pi->nphy_pwrctrl_info[1].max_pwr_5gl);
+
+			pwr_offsets1[0] = (uint16) (pi->ofdm5glpo & 0xffff);
+			pwr_offsets1[1] =
+			    (uint16) (pi->ofdm5glpo >> 16) & 0xffff;
+
+			pwr_offsets2 = pi->mcs5glpo;
+
+			tmp_cddpo = pi->cdd5glpo;
+			tmp_stbcpo = pi->stbc5glpo;
+			tmp_bw40po = pi->bw405glpo;
+
+			tx_srom_max_rate = pi->tx_srom_max_rate_5g_low;
+			break;
+		case 3:
+
+			tmp_max_pwr = MIN(pi->nphy_pwrctrl_info[0].max_pwr_5gh,
+					  pi->nphy_pwrctrl_info[1].max_pwr_5gh);
+
+			pwr_offsets1[0] = (uint16) (pi->ofdm5ghpo & 0xffff);
+			pwr_offsets1[1] =
+			    (uint16) (pi->ofdm5ghpo >> 16) & 0xffff;
+
+			pwr_offsets2 = pi->mcs5ghpo;
+
+			tmp_cddpo = pi->cdd5ghpo;
+			tmp_stbcpo = pi->stbc5ghpo;
+			tmp_bw40po = pi->bw405ghpo;
+
+			tx_srom_max_rate = pi->tx_srom_max_rate_5g_hi;
+			break;
+		}
+
+		wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate, pwr_offsets1,
+						tmp_max_pwr, TXP_FIRST_OFDM,
+						TXP_LAST_OFDM);
+
+		wlc_phy_ofdm_to_mcs_powers_nphy(tx_srom_max_rate,
+						TXP_FIRST_MCS_20_SISO,
+						TXP_LAST_MCS_20_SISO,
+						TXP_FIRST_OFDM);
+
+		wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate, pwr_offsets2,
+						tmp_max_pwr,
+						TXP_FIRST_MCS_20_CDD,
+						TXP_LAST_MCS_20_CDD);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			wlc_phy_txpwr_nphy_po_apply(tx_srom_max_rate, tmp_cddpo,
+						    TXP_FIRST_MCS_20_CDD,
+						    TXP_LAST_MCS_20_CDD);
+		}
+
+		wlc_phy_mcs_to_ofdm_powers_nphy(tx_srom_max_rate,
+						TXP_FIRST_OFDM_20_CDD,
+						TXP_LAST_OFDM_20_CDD,
+						TXP_FIRST_MCS_20_CDD);
+
+		wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate, pwr_offsets2,
+						tmp_max_pwr,
+						TXP_FIRST_MCS_20_STBC,
+						TXP_LAST_MCS_20_STBC);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			wlc_phy_txpwr_nphy_po_apply(tx_srom_max_rate,
+						    tmp_stbcpo,
+						    TXP_FIRST_MCS_20_STBC,
+						    TXP_LAST_MCS_20_STBC);
+		}
+
+		wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate,
+						&pwr_offsets2[2], tmp_max_pwr,
+						TXP_FIRST_MCS_20_SDM,
+						TXP_LAST_MCS_20_SDM);
+
+		if (NPHY_IS_SROM_REINTERPRET) {
+
+			wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate,
+							&pwr_offsets2[4],
+							tmp_max_pwr,
+							TXP_FIRST_MCS_40_SISO,
+							TXP_LAST_MCS_40_SISO);
+
+			wlc_phy_mcs_to_ofdm_powers_nphy(tx_srom_max_rate,
+							TXP_FIRST_OFDM_40_SISO,
+							TXP_LAST_OFDM_40_SISO,
+							TXP_FIRST_MCS_40_SISO);
+
+			wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate,
+							&pwr_offsets2[4],
+							tmp_max_pwr,
+							TXP_FIRST_MCS_40_CDD,
+							TXP_LAST_MCS_40_CDD);
+
+			wlc_phy_txpwr_nphy_po_apply(tx_srom_max_rate, tmp_cddpo,
+						    TXP_FIRST_MCS_40_CDD,
+						    TXP_LAST_MCS_40_CDD);
+
+			wlc_phy_mcs_to_ofdm_powers_nphy(tx_srom_max_rate,
+							TXP_FIRST_OFDM_40_CDD,
+							TXP_LAST_OFDM_40_CDD,
+							TXP_FIRST_MCS_40_CDD);
+
+			wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate,
+							&pwr_offsets2[4],
+							tmp_max_pwr,
+							TXP_FIRST_MCS_40_STBC,
+							TXP_LAST_MCS_40_STBC);
+
+			wlc_phy_txpwr_nphy_po_apply(tx_srom_max_rate,
+						    tmp_stbcpo,
+						    TXP_FIRST_MCS_40_STBC,
+						    TXP_LAST_MCS_40_STBC);
+
+			wlc_phy_txpwr_nphy_srom_convert(tx_srom_max_rate,
+							&pwr_offsets2[6],
+							tmp_max_pwr,
+							TXP_FIRST_MCS_40_SDM,
+							TXP_LAST_MCS_40_SDM);
+		} else {
+
+			for (rate1 = TXP_FIRST_OFDM_40_SISO, rate2 =
+			     TXP_FIRST_OFDM; rate1 <= TXP_LAST_MCS_40_SDM;
+			     rate1++, rate2++)
+				tx_srom_max_rate[rate1] =
+				    tx_srom_max_rate[rate2];
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			wlc_phy_txpwr_nphy_po_apply(tx_srom_max_rate,
+						    tmp_bw40po,
+						    TXP_FIRST_OFDM_40_SISO,
+						    TXP_LAST_MCS_40_SDM);
+		}
+
+		tx_srom_max_rate[TXP_MCS_32] =
+		    tx_srom_max_rate[TXP_FIRST_MCS_40_CDD];
+	}
+
+	return;
+}
+
+static void BCMATTACHFN(wlc_phy_txpwr_srom_read_ppr_nphy) (phy_info_t * pi) {
+	uint16 bw40po, cddpo, stbcpo, bwduppo;
+	uint band_num;
+
+	if (pi->sh->sromrev >= 9) {
+
+		return;
+	}
+
+	bw40po = (uint16) PHY_GETINTVAR(pi, "bw40po");
+	pi->bw402gpo = bw40po & 0xf;
+	pi->bw405gpo = (bw40po & 0xf0) >> 4;
+	pi->bw405glpo = (bw40po & 0xf00) >> 8;
+	pi->bw405ghpo = (bw40po & 0xf000) >> 12;
+
+	cddpo = (uint16) PHY_GETINTVAR(pi, "cddpo");
+	pi->cdd2gpo = cddpo & 0xf;
+	pi->cdd5gpo = (cddpo & 0xf0) >> 4;
+	pi->cdd5glpo = (cddpo & 0xf00) >> 8;
+	pi->cdd5ghpo = (cddpo & 0xf000) >> 12;
+
+	stbcpo = (uint16) PHY_GETINTVAR(pi, "stbcpo");
+	pi->stbc2gpo = stbcpo & 0xf;
+	pi->stbc5gpo = (stbcpo & 0xf0) >> 4;
+	pi->stbc5glpo = (stbcpo & 0xf00) >> 8;
+	pi->stbc5ghpo = (stbcpo & 0xf000) >> 12;
+
+	bwduppo = (uint16) PHY_GETINTVAR(pi, "bwduppo");
+	pi->bwdup2gpo = bwduppo & 0xf;
+	pi->bwdup5gpo = (bwduppo & 0xf0) >> 4;
+	pi->bwdup5glpo = (bwduppo & 0xf00) >> 8;
+	pi->bwdup5ghpo = (bwduppo & 0xf000) >> 12;
+
+	for (band_num = 0; band_num < (CH_2G_GROUP + CH_5G_GROUP); band_num++) {
+		switch (band_num) {
+		case 0:
+
+			pi->nphy_txpid2g[PHY_CORE_0] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid2ga0");
+			pi->nphy_txpid2g[PHY_CORE_1] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid2ga1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].max_pwr_2g =
+			    (int8) PHY_GETINTVAR(pi, "maxp2ga0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_2g =
+			    (int8) PHY_GETINTVAR(pi, "maxp2ga1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa2gw0a0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa2gw0a1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa2gw1a0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa2gw1a1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_2g_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa2gw2a0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_2g_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa2gw2a1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_2g =
+			    (int8) PHY_GETINTVAR(pi, "itt2ga0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_2g =
+			    (int8) PHY_GETINTVAR(pi, "itt2ga1");
+
+			pi->cck2gpo = (uint16) PHY_GETINTVAR(pi, "cck2gpo");
+
+			pi->ofdm2gpo = (uint32) PHY_GETINTVAR(pi, "ofdm2gpo");
+
+			pi->mcs2gpo[0] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo0");
+			pi->mcs2gpo[1] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo1");
+			pi->mcs2gpo[2] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo2");
+			pi->mcs2gpo[3] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo3");
+			pi->mcs2gpo[4] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo4");
+			pi->mcs2gpo[5] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo5");
+			pi->mcs2gpo[6] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo6");
+			pi->mcs2gpo[7] = (uint16) PHY_GETINTVAR(pi, "mcs2gpo7");
+			break;
+		case 1:
+
+			pi->nphy_txpid5g[PHY_CORE_0] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid5ga0");
+			pi->nphy_txpid5g[PHY_CORE_1] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid5ga1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].max_pwr_5gm =
+			    (int8) PHY_GETINTVAR(pi, "maxp5ga0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].max_pwr_5gm =
+			    (int8) PHY_GETINTVAR(pi, "maxp5ga1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5gw0a0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5gw0a1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa5gw1a0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa5gw1a1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].pwrdet_5gm_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5gw2a0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].pwrdet_5gm_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5gw2a1");
+			pi->nphy_pwrctrl_info[PHY_CORE_0].idle_targ_5gm =
+			    (int8) PHY_GETINTVAR(pi, "itt5ga0");
+			pi->nphy_pwrctrl_info[PHY_CORE_1].idle_targ_5gm =
+			    (int8) PHY_GETINTVAR(pi, "itt5ga1");
+
+			pi->ofdm5gpo = (uint32) PHY_GETINTVAR(pi, "ofdm5gpo");
+
+			pi->mcs5gpo[0] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo0");
+			pi->mcs5gpo[1] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo1");
+			pi->mcs5gpo[2] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo2");
+			pi->mcs5gpo[3] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo3");
+			pi->mcs5gpo[4] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo4");
+			pi->mcs5gpo[5] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo5");
+			pi->mcs5gpo[6] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo6");
+			pi->mcs5gpo[7] = (uint16) PHY_GETINTVAR(pi, "mcs5gpo7");
+			break;
+		case 2:
+
+			pi->nphy_txpid5gl[0] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid5gla0");
+			pi->nphy_txpid5gl[1] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid5gla1");
+			pi->nphy_pwrctrl_info[0].max_pwr_5gl =
+			    (int8) PHY_GETINTVAR(pi, "maxp5gla0");
+			pi->nphy_pwrctrl_info[1].max_pwr_5gl =
+			    (int8) PHY_GETINTVAR(pi, "maxp5gla1");
+			pi->nphy_pwrctrl_info[0].pwrdet_5gl_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5glw0a0");
+			pi->nphy_pwrctrl_info[1].pwrdet_5gl_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5glw0a1");
+			pi->nphy_pwrctrl_info[0].pwrdet_5gl_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa5glw1a0");
+			pi->nphy_pwrctrl_info[1].pwrdet_5gl_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa5glw1a1");
+			pi->nphy_pwrctrl_info[0].pwrdet_5gl_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5glw2a0");
+			pi->nphy_pwrctrl_info[1].pwrdet_5gl_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5glw2a1");
+			pi->nphy_pwrctrl_info[0].idle_targ_5gl = 0;
+			pi->nphy_pwrctrl_info[1].idle_targ_5gl = 0;
+
+			pi->ofdm5glpo = (uint32) PHY_GETINTVAR(pi, "ofdm5glpo");
+
+			pi->mcs5glpo[0] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo0");
+			pi->mcs5glpo[1] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo1");
+			pi->mcs5glpo[2] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo2");
+			pi->mcs5glpo[3] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo3");
+			pi->mcs5glpo[4] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo4");
+			pi->mcs5glpo[5] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo5");
+			pi->mcs5glpo[6] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo6");
+			pi->mcs5glpo[7] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5glpo7");
+			break;
+		case 3:
+
+			pi->nphy_txpid5gh[0] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid5gha0");
+			pi->nphy_txpid5gh[1] =
+			    (uint8) PHY_GETINTVAR(pi, "txpid5gha1");
+			pi->nphy_pwrctrl_info[0].max_pwr_5gh =
+			    (int8) PHY_GETINTVAR(pi, "maxp5gha0");
+			pi->nphy_pwrctrl_info[1].max_pwr_5gh =
+			    (int8) PHY_GETINTVAR(pi, "maxp5gha1");
+			pi->nphy_pwrctrl_info[0].pwrdet_5gh_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5ghw0a0");
+			pi->nphy_pwrctrl_info[1].pwrdet_5gh_a1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5ghw0a1");
+			pi->nphy_pwrctrl_info[0].pwrdet_5gh_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa5ghw1a0");
+			pi->nphy_pwrctrl_info[1].pwrdet_5gh_b0 =
+			    (int16) PHY_GETINTVAR(pi, "pa5ghw1a1");
+			pi->nphy_pwrctrl_info[0].pwrdet_5gh_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5ghw2a0");
+			pi->nphy_pwrctrl_info[1].pwrdet_5gh_b1 =
+			    (int16) PHY_GETINTVAR(pi, "pa5ghw2a1");
+			pi->nphy_pwrctrl_info[0].idle_targ_5gh = 0;
+			pi->nphy_pwrctrl_info[1].idle_targ_5gh = 0;
+
+			pi->ofdm5ghpo = (uint32) PHY_GETINTVAR(pi, "ofdm5ghpo");
+
+			pi->mcs5ghpo[0] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo0");
+			pi->mcs5ghpo[1] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo1");
+			pi->mcs5ghpo[2] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo2");
+			pi->mcs5ghpo[3] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo3");
+			pi->mcs5ghpo[4] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo4");
+			pi->mcs5ghpo[5] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo5");
+			pi->mcs5ghpo[6] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo6");
+			pi->mcs5ghpo[7] =
+			    (uint16) PHY_GETINTVAR(pi, "mcs5ghpo7");
+			break;
+		}
+	}
+
+	wlc_phy_txpwr_apply_nphy(pi);
+}
+
+static bool BCMATTACHFN(wlc_phy_txpwr_srom_read_nphy) (phy_info_t * pi) {
+
+	pi->antswitch = (uint8) PHY_GETINTVAR(pi, "antswitch");
+	pi->aa2g = (uint8) PHY_GETINTVAR(pi, "aa2g");
+	pi->aa5g = (uint8) PHY_GETINTVAR(pi, "aa5g");
+
+	pi->srom_fem2g.tssipos = (uint8) PHY_GETINTVAR(pi, "tssipos2g");
+	pi->srom_fem2g.extpagain = (uint8) PHY_GETINTVAR(pi, "extpagain2g");
+	pi->srom_fem2g.pdetrange = (uint8) PHY_GETINTVAR(pi, "pdetrange2g");
+	pi->srom_fem2g.triso = (uint8) PHY_GETINTVAR(pi, "triso2g");
+	pi->srom_fem2g.antswctrllut = (uint8) PHY_GETINTVAR(pi, "antswctl2g");
+
+	pi->srom_fem5g.tssipos = (uint8) PHY_GETINTVAR(pi, "tssipos5g");
+	pi->srom_fem5g.extpagain = (uint8) PHY_GETINTVAR(pi, "extpagain5g");
+	pi->srom_fem5g.pdetrange = (uint8) PHY_GETINTVAR(pi, "pdetrange5g");
+	pi->srom_fem5g.triso = (uint8) PHY_GETINTVAR(pi, "triso5g");
+	if (PHY_GETVAR(pi, "antswctl5g")) {
+
+		pi->srom_fem5g.antswctrllut =
+		    (uint8) PHY_GETINTVAR(pi, "antswctl5g");
+	} else {
+
+		pi->srom_fem5g.antswctrllut =
+		    (uint8) PHY_GETINTVAR(pi, "antswctl2g");
+	}
+
+	wlc_phy_txpower_ipa_upd(pi);
+
+	pi->phy_txcore_disable_temp = (int16) PHY_GETINTVAR(pi, "tempthresh");
+	if (pi->phy_txcore_disable_temp == 0) {
+		pi->phy_txcore_disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;
+	}
+
+	pi->phy_tempsense_offset = (int8) PHY_GETINTVAR(pi, "tempoffset");
+	if (pi->phy_tempsense_offset != 0) {
+		if (pi->phy_tempsense_offset >
+		    (NPHY_SROM_TEMPSHIFT + NPHY_SROM_MAXTEMPOFFSET)) {
+			pi->phy_tempsense_offset = NPHY_SROM_MAXTEMPOFFSET;
+		} else if (pi->phy_tempsense_offset < (NPHY_SROM_TEMPSHIFT +
+						       NPHY_SROM_MINTEMPOFFSET))
+		{
+			pi->phy_tempsense_offset = NPHY_SROM_MINTEMPOFFSET;
+		} else {
+			pi->phy_tempsense_offset -= NPHY_SROM_TEMPSHIFT;
+		}
+	}
+
+	pi->phy_txcore_enable_temp =
+	    pi->phy_txcore_disable_temp - PHY_HYSTERESIS_DELTATEMP;
+
+	pi->phycal_tempdelta = (uint8) PHY_GETINTVAR(pi, "phycal_tempdelta");
+	if (pi->phycal_tempdelta > NPHY_CAL_MAXTEMPDELTA) {
+		pi->phycal_tempdelta = 0;
+	}
+
+	wlc_phy_txpwr_srom_read_ppr_nphy(pi);
+
+	return TRUE;
+}
+
+void wlc_phy_txpower_recalc_target_nphy(phy_info_t * pi)
+{
+	uint8 tx_pwr_ctrl_state;
+	wlc_phy_txpwr_limit_to_tbl_nphy(pi);
+	wlc_phy_txpwrctrl_pwr_setup_nphy(pi);
+
+	tx_pwr_ctrl_state = pi->nphy_txpwrctrl;
+
+	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
+		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, MCTL_PHYLOCK);
+		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
+		OSL_DELAY(1);
+	}
+
+	wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
+
+	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
+		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, 0);
+}
+
+static void wlc_phy_txpwrctrl_coeff_setup_nphy(phy_info_t * pi)
+{
+	uint32 idx;
+	uint16 iqloCalbuf[7];
+	uint32 iqcomp, locomp, curr_locomp;
+	int8 locomp_i, locomp_q;
+	int8 curr_locomp_i, curr_locomp_q;
+	uint32 tbl_id, tbl_len, tbl_offset;
+	uint32 regval[128];
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	wlc_phy_table_read_nphy(pi, 15, 7, 80, 16, iqloCalbuf);
+
+	tbl_len = 128;
+	tbl_offset = 320;
+	for (tbl_id = NPHY_TBL_ID_CORE1TXPWRCTL;
+	     tbl_id <= NPHY_TBL_ID_CORE2TXPWRCTL; tbl_id++) {
+		iqcomp =
+		    (tbl_id ==
+		     26) ? (((uint32) (iqloCalbuf[0] & 0x3ff)) << 10) |
+		    (iqloCalbuf[1] & 0x3ff)
+		    : (((uint32) (iqloCalbuf[2] & 0x3ff)) << 10) |
+		    (iqloCalbuf[3] & 0x3ff);
+
+		for (idx = 0; idx < tbl_len; idx++) {
+			regval[idx] = iqcomp;
+		}
+		wlc_phy_table_write_nphy(pi, tbl_id, tbl_len, tbl_offset, 32,
+					 regval);
+	}
+
+	tbl_offset = 448;
+	for (tbl_id = NPHY_TBL_ID_CORE1TXPWRCTL;
+	     tbl_id <= NPHY_TBL_ID_CORE2TXPWRCTL; tbl_id++) {
+
+		locomp =
+		    (uint32) ((tbl_id == 26) ? iqloCalbuf[5] : iqloCalbuf[6]);
+		locomp_i = (int8) ((locomp >> 8) & 0xff);
+		locomp_q = (int8) ((locomp) & 0xff);
+		for (idx = 0; idx < tbl_len; idx++) {
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				curr_locomp_i = locomp_i;
+				curr_locomp_q = locomp_q;
+			} else {
+				curr_locomp_i = (int8) ((locomp_i *
+							 nphy_tpc_loscale[idx] +
+							 128) >> 8);
+				curr_locomp_q =
+				    (int8) ((locomp_q * nphy_tpc_loscale[idx] +
+					     128) >> 8);
+			}
+			curr_locomp = (uint32) ((curr_locomp_i & 0xff) << 8);
+			curr_locomp |= (uint32) (curr_locomp_q & 0xff);
+			regval[idx] = curr_locomp;
+		}
+		wlc_phy_table_write_nphy(pi, tbl_id, tbl_len, tbl_offset, 32,
+					 regval);
+	}
+
+	if (NREV_LT(pi->pubpi.phy_rev, 2)) {
+
+		wlapi_bmac_write_shm(pi->sh->physhim, M_CURR_IDX1, 0xFFFF);
+		wlapi_bmac_write_shm(pi->sh->physhim, M_CURR_IDX2, 0xFFFF);
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static void wlc_phy_ipa_internal_tssi_setup_nphy(phy_info_t * pi)
+{
+	uint8 core;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TX_SSI_MASTER, 0x5);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TX_SSI_MUX, 0xe);
+
+				if (pi->pubpi.radiorev != 5)
+					WRITE_RADIO_REG3(pi, RADIO_2057, TX,
+							 core, TSSIA, 0);
+
+				if (!NREV_IS(pi->pubpi.phy_rev, 7)) {
+
+					WRITE_RADIO_REG3(pi, RADIO_2057, TX,
+							 core, TSSIG, 0x1);
+				} else {
+
+					WRITE_RADIO_REG3(pi, RADIO_2057, TX,
+							 core, TSSIG, 0x31);
+				}
+			} else {
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TX_SSI_MASTER, 0x9);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TX_SSI_MUX, 0xc);
+				WRITE_RADIO_REG3(pi, RADIO_2057, TX, core,
+						 TSSIG, 0);
+
+				if (pi->pubpi.radiorev != 5) {
+					if (!NREV_IS(pi->pubpi.phy_rev, 7)) {
+
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TSSIA, 0x1);
+					} else {
+
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TSSIA, 0x31);
+					}
+				}
+			}
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, IQCAL_VCM_HG,
+					 0);
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, IQCAL_IDAC,
+					 0);
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, TSSI_VCM,
+					 0x3);
+			WRITE_RADIO_REG3(pi, RADIO_2057, TX, core, TSSI_MISC1,
+					 0x0);
+		}
+	} else {
+		WRITE_RADIO_SYN(pi, RADIO_2056, RESERVED_ADDR31,
+				(CHSPEC_IS2G(pi->radio_chanspec)) ? 0x128 :
+				0x80);
+		WRITE_RADIO_SYN(pi, RADIO_2056, RESERVED_ADDR30, 0x0);
+		WRITE_RADIO_SYN(pi, RADIO_2056, GPIO_MASTER1, 0x29);
+
+		for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, IQCAL_VCM_HG,
+					 0x0);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, IQCAL_IDAC,
+					 0x0);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, TSSI_VCM,
+					 0x3);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, TX_AMP_DET,
+					 0x0);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, TSSI_MISC1,
+					 0x8);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, TSSI_MISC2,
+					 0x0);
+			WRITE_RADIO_REG2(pi, RADIO_2056, TX, core, TSSI_MISC3,
+					 0x0);
+
+			if (CHSPEC_IS2G(pi->radio_chanspec)) {
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 TX_SSI_MASTER, 0x5);
+
+				if (pi->pubpi.radiorev != 5)
+					WRITE_RADIO_REG2(pi, RADIO_2056, TX,
+							 core, TSSIA, 0x0);
+				if (NREV_GE(pi->pubpi.phy_rev, 5)) {
+
+					WRITE_RADIO_REG2(pi, RADIO_2056, TX,
+							 core, TSSIG, 0x31);
+				} else {
+					WRITE_RADIO_REG2(pi, RADIO_2056, TX,
+							 core, TSSIG, 0x11);
+				}
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 TX_SSI_MUX, 0xe);
+			} else {
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 TX_SSI_MASTER, 0x9);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 TSSIA, 0x31);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 TSSIG, 0x0);
+				WRITE_RADIO_REG2(pi, RADIO_2056, TX, core,
+						 TX_SSI_MUX, 0xc);
+			}
+		}
+	}
+}
+
+static void wlc_phy_txpwrctrl_idle_tssi_nphy(phy_info_t * pi)
+{
+	int32 rssi_buf[4];
+	int32 int_val;
+
+	if (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi) || PHY_MUTED(pi))
+
+		return;
+
+	if (PHY_IPA(pi)) {
+		wlc_phy_ipa_internal_tssi_setup_nphy(pi);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 12),
+						  0, 0x3, 0,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 13), 0, 3, 0);
+	}
+
+	wlc_phy_stopplayback_nphy(pi);
+
+	wlc_phy_tx_tone_nphy(pi, 4000, 0, 0, 0, FALSE);
+
+	OSL_DELAY(20);
+	int_val =
+	    wlc_phy_poll_rssi_nphy(pi, (uint8) NPHY_RSSI_SEL_TSSI_2G, rssi_buf,
+				   1);
+	wlc_phy_stopplayback_nphy(pi);
+	wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_OFF, 0);
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		wlc_phy_rfctrl_override_nphy_rev7(pi, (0x1 << 12),
+						  0, 0x3, 1,
+						  NPHY_REV7_RFCTRLOVERRIDE_ID0);
+	} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		wlc_phy_rfctrl_override_nphy(pi, (0x1 << 13), 0, 3, 1);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_2g =
+		    (uint8) ((int_val >> 24) & 0xff);
+		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_5g =
+		    (uint8) ((int_val >> 24) & 0xff);
+
+		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_2g =
+		    (uint8) ((int_val >> 8) & 0xff);
+		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_5g =
+		    (uint8) ((int_val >> 8) & 0xff);
+	} else {
+		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_2g =
+		    (uint8) ((int_val >> 24) & 0xff);
+
+		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_2g =
+		    (uint8) ((int_val >> 8) & 0xff);
+
+		pi->nphy_pwrctrl_info[PHY_CORE_0].idle_tssi_5g =
+		    (uint8) ((int_val >> 16) & 0xff);
+		pi->nphy_pwrctrl_info[PHY_CORE_1].idle_tssi_5g =
+		    (uint8) ((int_val) & 0xff);
+	}
+
+}
+
+static void wlc_phy_txpwrctrl_pwr_setup_nphy(phy_info_t * pi)
+{
+	uint32 idx;
+	int16 a1[2], b0[2], b1[2];
+	int8 target_pwr_qtrdbm[2];
+	int32 num, den, pwr_est;
+	uint8 chan_freq_range;
+	uint8 idle_tssi[2];
+	uint32 tbl_id, tbl_len, tbl_offset;
+	uint32 regval[64];
+	uint8 core;
+
+	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
+		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, MCTL_PHYLOCK);
+		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
+		OSL_DELAY(1);
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	or_phy_reg(pi, 0x122, (0x1 << 0));
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		and_phy_reg(pi, 0x1e7, (uint16) (~(0x1 << 15)));
+	} else {
+
+		or_phy_reg(pi, 0x1e7, (0x1 << 15));
+	}
+
+	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
+		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, 0);
+
+	if (pi->sh->sromrev < 4) {
+		idle_tssi[0] = pi->nphy_pwrctrl_info[0].idle_tssi_2g;
+		idle_tssi[1] = pi->nphy_pwrctrl_info[1].idle_tssi_2g;
+		target_pwr_qtrdbm[0] = 13 * 4;
+		target_pwr_qtrdbm[1] = 13 * 4;
+		a1[0] = -424;
+		a1[1] = -424;
+		b0[0] = 5612;
+		b0[1] = 5612;
+		b1[1] = -1393;
+		b1[0] = -1393;
+	} else {
+
+		chan_freq_range = wlc_phy_get_chan_freq_range_nphy(pi, 0);
+		switch (chan_freq_range) {
+		case WL_CHAN_FREQ_RANGE_2G:
+			idle_tssi[0] = pi->nphy_pwrctrl_info[0].idle_tssi_2g;
+			idle_tssi[1] = pi->nphy_pwrctrl_info[1].idle_tssi_2g;
+			target_pwr_qtrdbm[0] =
+			    pi->nphy_pwrctrl_info[0].max_pwr_2g;
+			target_pwr_qtrdbm[1] =
+			    pi->nphy_pwrctrl_info[1].max_pwr_2g;
+			a1[0] = pi->nphy_pwrctrl_info[0].pwrdet_2g_a1;
+			a1[1] = pi->nphy_pwrctrl_info[1].pwrdet_2g_a1;
+			b0[0] = pi->nphy_pwrctrl_info[0].pwrdet_2g_b0;
+			b0[1] = pi->nphy_pwrctrl_info[1].pwrdet_2g_b0;
+			b1[0] = pi->nphy_pwrctrl_info[0].pwrdet_2g_b1;
+			b1[1] = pi->nphy_pwrctrl_info[1].pwrdet_2g_b1;
+			break;
+		case WL_CHAN_FREQ_RANGE_5GL:
+			idle_tssi[0] = pi->nphy_pwrctrl_info[0].idle_tssi_5g;
+			idle_tssi[1] = pi->nphy_pwrctrl_info[1].idle_tssi_5g;
+			target_pwr_qtrdbm[0] =
+			    pi->nphy_pwrctrl_info[0].max_pwr_5gl;
+			target_pwr_qtrdbm[1] =
+			    pi->nphy_pwrctrl_info[1].max_pwr_5gl;
+			a1[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gl_a1;
+			a1[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gl_a1;
+			b0[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gl_b0;
+			b0[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gl_b0;
+			b1[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gl_b1;
+			b1[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gl_b1;
+			break;
+		case WL_CHAN_FREQ_RANGE_5GM:
+			idle_tssi[0] = pi->nphy_pwrctrl_info[0].idle_tssi_5g;
+			idle_tssi[1] = pi->nphy_pwrctrl_info[1].idle_tssi_5g;
+			target_pwr_qtrdbm[0] =
+			    pi->nphy_pwrctrl_info[0].max_pwr_5gm;
+			target_pwr_qtrdbm[1] =
+			    pi->nphy_pwrctrl_info[1].max_pwr_5gm;
+			a1[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gm_a1;
+			a1[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gm_a1;
+			b0[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gm_b0;
+			b0[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gm_b0;
+			b1[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gm_b1;
+			b1[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gm_b1;
+			break;
+		case WL_CHAN_FREQ_RANGE_5GH:
+			idle_tssi[0] = pi->nphy_pwrctrl_info[0].idle_tssi_5g;
+			idle_tssi[1] = pi->nphy_pwrctrl_info[1].idle_tssi_5g;
+			target_pwr_qtrdbm[0] =
+			    pi->nphy_pwrctrl_info[0].max_pwr_5gh;
+			target_pwr_qtrdbm[1] =
+			    pi->nphy_pwrctrl_info[1].max_pwr_5gh;
+			a1[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gh_a1;
+			a1[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gh_a1;
+			b0[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gh_b0;
+			b0[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gh_b0;
+			b1[0] = pi->nphy_pwrctrl_info[0].pwrdet_5gh_b1;
+			b1[1] = pi->nphy_pwrctrl_info[1].pwrdet_5gh_b1;
+			break;
+		default:
+			idle_tssi[0] = pi->nphy_pwrctrl_info[0].idle_tssi_2g;
+			idle_tssi[1] = pi->nphy_pwrctrl_info[1].idle_tssi_2g;
+			target_pwr_qtrdbm[0] = 13 * 4;
+			target_pwr_qtrdbm[1] = 13 * 4;
+			a1[0] = -424;
+			a1[1] = -424;
+			b0[0] = 5612;
+			b0[1] = 5612;
+			b1[1] = -1393;
+			b1[0] = -1393;
+			break;
+		}
+	}
+
+	target_pwr_qtrdbm[0] = (int8) pi->tx_power_max;
+	target_pwr_qtrdbm[1] = (int8) pi->tx_power_max;
+
+	if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+		if (pi->srom_fem2g.tssipos) {
+			or_phy_reg(pi, 0x1e9, (0x1 << 14));
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+			for (core = 0; core <= 1; core++) {
+				if (PHY_IPA(pi)) {
+
+					if (CHSPEC_IS2G(pi->radio_chanspec)) {
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TX_SSI_MUX,
+								 0xe);
+					} else {
+						WRITE_RADIO_REG3(pi, RADIO_2057,
+								 TX, core,
+								 TX_SSI_MUX,
+								 0xc);
+					}
+				} else {
+				}
+			}
+		} else {
+			if (PHY_IPA(pi)) {
+
+				write_radio_reg(pi, RADIO_2056_TX_TX_SSI_MUX |
+						RADIO_2056_TX0,
+						(CHSPEC_IS5G
+						 (pi->
+						  radio_chanspec)) ? 0xc : 0xe);
+				write_radio_reg(pi,
+						RADIO_2056_TX_TX_SSI_MUX |
+						RADIO_2056_TX1,
+						(CHSPEC_IS5G
+						 (pi->
+						  radio_chanspec)) ? 0xc : 0xe);
+			} else {
+
+				write_radio_reg(pi, RADIO_2056_TX_TX_SSI_MUX |
+						RADIO_2056_TX0, 0x11);
+				write_radio_reg(pi, RADIO_2056_TX_TX_SSI_MUX |
+						RADIO_2056_TX1, 0x11);
+			}
+		}
+	}
+
+	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
+		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, MCTL_PHYLOCK);
+		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
+		OSL_DELAY(1);
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		mod_phy_reg(pi, 0x1e7, (0x7f << 0),
+			    (NPHY_TxPwrCtrlCmd_pwrIndex_init_rev7 << 0));
+	} else {
+		mod_phy_reg(pi, 0x1e7, (0x7f << 0),
+			    (NPHY_TxPwrCtrlCmd_pwrIndex_init << 0));
+	}
+
+	if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+		mod_phy_reg(pi, 0x222, (0xff << 0),
+			    (NPHY_TxPwrCtrlCmd_pwrIndex_init_rev7 << 0));
+	} else if (NREV_GT(pi->pubpi.phy_rev, 1)) {
+		mod_phy_reg(pi, 0x222, (0xff << 0),
+			    (NPHY_TxPwrCtrlCmd_pwrIndex_init << 0));
+	}
+
+	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
+		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, 0);
+
+	write_phy_reg(pi, 0x1e8, (0x3 << 8) | (240 << 0));
+
+	write_phy_reg(pi, 0x1e9,
+		      (1 << 15) | (idle_tssi[0] << 0) | (idle_tssi[1] << 8));
+
+	write_phy_reg(pi, 0x1ea,
+		      (target_pwr_qtrdbm[0] << 0) |
+		      (target_pwr_qtrdbm[1] << 8));
+
+	tbl_len = 64;
+	tbl_offset = 0;
+	for (tbl_id = NPHY_TBL_ID_CORE1TXPWRCTL;
+	     tbl_id <= NPHY_TBL_ID_CORE2TXPWRCTL; tbl_id++) {
+
+		for (idx = 0; idx < tbl_len; idx++) {
+			num =
+			    8 * (16 * b0[tbl_id - 26] + b1[tbl_id - 26] * idx);
+			den = 32768 + a1[tbl_id - 26] * idx;
+			pwr_est = MAX(((4 * num + den / 2) / den), -8);
+			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
+				if (idx <=
+				    (uint) (31 - idle_tssi[tbl_id - 26] + 1))
+					pwr_est =
+					    MAX(pwr_est,
+						target_pwr_qtrdbm[tbl_id - 26] +
+						1);
+			}
+			regval[idx] = (uint32) pwr_est;
+		}
+		wlc_phy_table_write_nphy(pi, tbl_id, tbl_len, tbl_offset, 32,
+					 regval);
+	}
+
+	wlc_phy_txpwr_limit_to_tbl_nphy(pi);
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE1TXPWRCTL, 84, 64, 8,
+				 pi->adj_pwr_tbl_nphy);
+	wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 84, 64, 8,
+				 pi->adj_pwr_tbl_nphy);
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+static bool wlc_phy_txpwr_ison_nphy(phy_info_t * pi)
+{
+	return (read_phy_reg((pi), 0x1e7) & ((0x1 << 15) |
+					     (0x1 << 14) | (0x1 << 13)));
+}
+
+static uint8 wlc_phy_txpwr_idx_cur_get_nphy(phy_info_t * pi, uint8 core)
+{
+	uint16 tmp;
+	tmp = read_phy_reg(pi, ((core == PHY_CORE_0) ? 0x1ed : 0x1ee));
+
+	tmp = (tmp & (0x7f << 8)) >> 8;
+	return (uint8) tmp;
+}
+
+static void
+wlc_phy_txpwr_idx_cur_set_nphy(phy_info_t * pi, uint8 idx0, uint8 idx1)
+{
+	mod_phy_reg(pi, 0x1e7, (0x7f << 0), idx0);
+
+	if (NREV_GT(pi->pubpi.phy_rev, 1))
+		mod_phy_reg(pi, 0x222, (0xff << 0), idx1);
+}
+
+uint16 wlc_phy_txpwr_idx_get_nphy(phy_info_t * pi)
+{
+	uint16 tmp;
+	uint16 pwr_idx[2];
+
+	if (wlc_phy_txpwr_ison_nphy(pi)) {
+		pwr_idx[0] = wlc_phy_txpwr_idx_cur_get_nphy(pi, PHY_CORE_0);
+		pwr_idx[1] = wlc_phy_txpwr_idx_cur_get_nphy(pi, PHY_CORE_1);
+
+		tmp = (pwr_idx[0] << 8) | pwr_idx[1];
+	} else {
+		tmp =
+		    ((pi->nphy_txpwrindex[PHY_CORE_0].
+		      index_internal & 0xff) << 8) | (pi->
+						      nphy_txpwrindex
+						      [PHY_CORE_1].
+						      index_internal & 0xff);
+	}
+
+	return tmp;
+}
+
+void wlc_phy_txpwr_papd_cal_nphy(phy_info_t * pi)
+{
+	if (PHY_IPA(pi)
+	    && (pi->nphy_force_papd_cal
+		|| (wlc_phy_txpwr_ison_nphy(pi)
+		    &&
+		    (((uint32)
+		      ABS(wlc_phy_txpwr_idx_cur_get_nphy(pi, 0) -
+			  pi->nphy_papd_tx_gain_at_last_cal[0]) >= 4)
+		     || ((uint32)
+			 ABS(wlc_phy_txpwr_idx_cur_get_nphy(pi, 1) -
+			     pi->nphy_papd_tx_gain_at_last_cal[1]) >= 4))))) {
+		wlc_phy_a4(pi, TRUE);
+	}
+}
+
+void wlc_phy_txpwrctrl_enable_nphy(phy_info_t * pi, uint8 ctrl_type)
+{
+	uint16 mask = 0, val = 0, ishw = 0;
+	uint8 ctr;
+	uint core;
+	uint32 tbl_offset;
+	uint32 tbl_len;
+	uint16 regval[84];
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	switch (ctrl_type) {
+	case PHY_TPC_HW_OFF:
+	case PHY_TPC_HW_ON:
+		pi->nphy_txpwrctrl = ctrl_type;
+		break;
+	default:
+		break;
+	}
+
+	if (ctrl_type == PHY_TPC_HW_OFF) {
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			if (wlc_phy_txpwr_ison_nphy(pi)) {
+				for (core = 0; core < pi->pubpi.phy_corenum;
+				     core++)
+					pi->nphy_txpwr_idx[core] =
+					    wlc_phy_txpwr_idx_cur_get_nphy(pi,
+									   (uint8)
+									   core);
+			}
+
+		}
+
+		tbl_len = 84;
+		tbl_offset = 64;
+		for (ctr = 0; ctr < tbl_len; ctr++) {
+			regval[ctr] = 0;
+		}
+		wlc_phy_table_write_nphy(pi, 26, tbl_len, tbl_offset, 16,
+					 regval);
+		wlc_phy_table_write_nphy(pi, 27, tbl_len, tbl_offset, 16,
+					 regval);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+
+			and_phy_reg(pi, 0x1e7,
+				    (uint16) (~((0x1 << 15) |
+						(0x1 << 14) | (0x1 << 13))));
+		} else {
+			and_phy_reg(pi, 0x1e7,
+				    (uint16) (~((0x1 << 14) | (0x1 << 13))));
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			or_phy_reg(pi, 0x8f, (0x1 << 8));
+			or_phy_reg(pi, 0xa5, (0x1 << 8));
+		} else {
+			or_phy_reg(pi, 0xa5, (0x1 << 14));
+		}
+
+		if (NREV_IS(pi->pubpi.phy_rev, 2))
+			mod_phy_reg(pi, 0xdc, 0x00ff, 0x53);
+		else if (NREV_LT(pi->pubpi.phy_rev, 2))
+			mod_phy_reg(pi, 0xdc, 0x00ff, 0x5a);
+
+		if (NREV_LT(pi->pubpi.phy_rev, 2) && IS40MHZ(pi))
+			wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_IQSWAP_WAR,
+				       MHF1_IQSWAP_WAR, WLC_BAND_ALL);
+
+	} else {
+
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE1TXPWRCTL, 84, 64,
+					 8, pi->adj_pwr_tbl_nphy);
+		wlc_phy_table_write_nphy(pi, NPHY_TBL_ID_CORE2TXPWRCTL, 84, 64,
+					 8, pi->adj_pwr_tbl_nphy);
+
+		ishw = (ctrl_type == PHY_TPC_HW_ON) ? 0x1 : 0x0;
+		mask = (0x1 << 14) | (0x1 << 13);
+		val = (ishw << 14) | (ishw << 13);
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			mask |= (0x1 << 15);
+			val |= (ishw << 15);
+		}
+
+		mod_phy_reg(pi, 0x1e7, mask, val);
+
+		if (CHSPEC_IS5G(pi->radio_chanspec)) {
+			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
+				mod_phy_reg(pi, 0x1e7, (0x7f << 0), 0x32);
+				mod_phy_reg(pi, 0x222, (0xff << 0), 0x32);
+			} else {
+				mod_phy_reg(pi, 0x1e7, (0x7f << 0), 0x64);
+				if (NREV_GT(pi->pubpi.phy_rev, 1))
+					mod_phy_reg(pi, 0x222,
+						    (0xff << 0), 0x64);
+			}
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			if ((pi->nphy_txpwr_idx[0] != 128)
+			    && (pi->nphy_txpwr_idx[1] != 128)) {
+				wlc_phy_txpwr_idx_cur_set_nphy(pi,
+							       pi->
+							       nphy_txpwr_idx
+							       [0],
+							       pi->
+							       nphy_txpwr_idx
+							       [1]);
+			}
+		}
+
+		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+			and_phy_reg(pi, 0x8f, ~(0x1 << 8));
+			and_phy_reg(pi, 0xa5, ~(0x1 << 8));
+		} else {
+			and_phy_reg(pi, 0xa5, ~(0x1 << 14));
+		}
+
+		if (NREV_IS(pi->pubpi.phy_rev, 2))
+			mod_phy_reg(pi, 0xdc, 0x00ff, 0x3b);
+		else if (NREV_LT(pi->pubpi.phy_rev, 2))
+			mod_phy_reg(pi, 0xdc, 0x00ff, 0x40);
+
+		if (NREV_LT(pi->pubpi.phy_rev, 2) && IS40MHZ(pi))
+			wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_IQSWAP_WAR,
+				       0x0, WLC_BAND_ALL);
+
+		if (PHY_IPA(pi)) {
+			mod_phy_reg(pi, (0 == PHY_CORE_0) ? 0x297 :
+				    0x29b, (0x1 << 2), (0) << 2);
+
+			mod_phy_reg(pi, (1 == PHY_CORE_0) ? 0x297 :
+				    0x29b, (0x1 << 2), (0) << 2);
+
+		}
+
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+void
+wlc_phy_txpwr_index_nphy(phy_info_t * pi, uint8 core_mask, int8 txpwrindex,
+			 bool restore_cals)
+{
+	uint8 core, txpwrctl_tbl;
+	uint16 tx_ind0, iq_ind0, lo_ind0;
+	uint16 m1m2;
+	uint32 txgain;
+	uint16 rad_gain, dac_gain;
+	uint8 bbmult;
+	uint32 iqcomp;
+	uint16 iqcomp_a, iqcomp_b;
+	uint32 locomp;
+	uint16 tmpval;
+	uint8 tx_pwr_ctrl_state;
+	int32 rfpwr_offset;
+	uint16 regval[2];
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+
+	tx_ind0 = 192;
+	iq_ind0 = 320;
+	lo_ind0 = 448;
+
+	for (core = 0; core < pi->pubpi.phy_corenum; core++) {
+
+		if ((core_mask & (1 << core)) == 0) {
+			continue;
+		}
+
+		txpwrctl_tbl = (core == PHY_CORE_0) ? 26 : 27;
+
+		if (txpwrindex < 0) {
+			if (pi->nphy_txpwrindex[core].index < 0) {
+
+				continue;
+			}
+
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				mod_phy_reg(pi, 0x8f,
+					    (0x1 << 8),
+					    pi->nphy_txpwrindex[core].
+					    AfectrlOverride);
+				mod_phy_reg(pi, 0xa5, (0x1 << 8),
+					    pi->nphy_txpwrindex[core].
+					    AfectrlOverride);
+			} else {
+				mod_phy_reg(pi, 0xa5,
+					    (0x1 << 14),
+					    pi->nphy_txpwrindex[core].
+					    AfectrlOverride);
+			}
+
+			write_phy_reg(pi, (core == PHY_CORE_0) ?
+				      0xaa : 0xab,
+				      pi->nphy_txpwrindex[core].AfeCtrlDacGain);
+
+			wlc_phy_table_write_nphy(pi, 7, 1, (0x110 + core), 16,
+						 &pi->nphy_txpwrindex[core].
+						 rad_gain);
+
+			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m1m2);
+			m1m2 &= ((core == PHY_CORE_0) ? 0x00ff : 0xff00);
+			m1m2 |= ((core == PHY_CORE_0) ?
+				 (pi->nphy_txpwrindex[core].bbmult << 8) :
+				 (pi->nphy_txpwrindex[core].bbmult << 0));
+			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m1m2);
+
+			if (restore_cals) {
+
+				wlc_phy_table_write_nphy(pi, 15, 2,
+							 (80 + 2 * core), 16,
+							 (void *)&pi->
+							 nphy_txpwrindex[core].
+							 iqcomp_a);
+
+				wlc_phy_table_write_nphy(pi, 15, 1, (85 + core),
+							 16,
+							 &pi->
+							 nphy_txpwrindex[core].
+							 locomp);
+				wlc_phy_table_write_nphy(pi, 15, 1, (93 + core),
+							 16,
+							 (void *)&pi->
+							 nphy_txpwrindex[core].
+							 locomp);
+			}
+
+			wlc_phy_txpwrctrl_enable_nphy(pi, pi->nphy_txpwrctrl);
+
+			pi->nphy_txpwrindex[core].index_internal =
+			    pi->nphy_txpwrindex[core].index_internal_save;
+		} else {
+
+			if (pi->nphy_txpwrindex[core].index < 0) {
+
+				if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+					mod_phy_reg(pi, 0x8f,
+						    (0x1 << 8),
+						    pi->nphy_txpwrindex[core].
+						    AfectrlOverride);
+					mod_phy_reg(pi, 0xa5, (0x1 << 8),
+						    pi->nphy_txpwrindex[core].
+						    AfectrlOverride);
+				} else {
+					pi->nphy_txpwrindex[core].
+					    AfectrlOverride =
+					    read_phy_reg(pi, 0xa5);
+				}
+
+				pi->nphy_txpwrindex[core].AfeCtrlDacGain =
+				    read_phy_reg(pi,
+						 (core ==
+						  PHY_CORE_0) ? 0xaa : 0xab);
+
+				wlc_phy_table_read_nphy(pi, 7, 1,
+							(0x110 + core), 16,
+							&pi->
+							nphy_txpwrindex[core].
+							rad_gain);
+
+				wlc_phy_table_read_nphy(pi, 15, 1, 87, 16,
+							&tmpval);
+				tmpval >>= ((core == PHY_CORE_0) ? 8 : 0);
+				tmpval &= 0xff;
+				pi->nphy_txpwrindex[core].bbmult =
+				    (uint8) tmpval;
+
+				wlc_phy_table_read_nphy(pi, 15, 2,
+							(80 + 2 * core), 16,
+							(void *)&pi->
+							nphy_txpwrindex[core].
+							iqcomp_a);
+
+				wlc_phy_table_read_nphy(pi, 15, 1, (85 + core),
+							16,
+							(void *)&pi->
+							nphy_txpwrindex[core].
+							locomp);
+
+				pi->nphy_txpwrindex[core].index_internal_save =
+				    pi->nphy_txpwrindex[core].index_internal;
+			}
+
+			tx_pwr_ctrl_state = pi->nphy_txpwrctrl;
+			wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
+
+			if (NREV_IS(pi->pubpi.phy_rev, 1))
+				wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);
+
+			wlc_phy_table_read_nphy(pi, txpwrctl_tbl, 1,
+						(tx_ind0 + txpwrindex), 32,
+						&txgain);
+
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				rad_gain =
+				    (txgain >> 16) & ((1 << (32 - 16 + 1)) - 1);
+			} else {
+				rad_gain =
+				    (txgain >> 16) & ((1 << (28 - 16 + 1)) - 1);
+			}
+			dac_gain = (txgain >> 8) & ((1 << (13 - 8 + 1)) - 1);
+			bbmult = (txgain >> 0) & ((1 << (7 - 0 + 1)) - 1);
+
+			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
+				mod_phy_reg(pi, ((core == PHY_CORE_0) ? 0x8f :
+						 0xa5), (0x1 << 8), (0x1 << 8));
+			} else {
+				mod_phy_reg(pi, 0xa5, (0x1 << 14), (0x1 << 14));
+			}
+			write_phy_reg(pi, (core == PHY_CORE_0) ?
+				      0xaa : 0xab, dac_gain);
+
+			wlc_phy_table_write_nphy(pi, 7, 1, (0x110 + core), 16,
+						 &rad_gain);
+
+			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m1m2);
+			m1m2 &= ((core == PHY_CORE_0) ? 0x00ff : 0xff00);
+			m1m2 |=
+			    ((core ==
+			      PHY_CORE_0) ? (bbmult << 8) : (bbmult << 0));
+
+			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m1m2);
+
+			wlc_phy_table_read_nphy(pi, txpwrctl_tbl, 1,
+						(iq_ind0 + txpwrindex), 32,
+						&iqcomp);
+			iqcomp_a = (iqcomp >> 10) & ((1 << (19 - 10 + 1)) - 1);
+			iqcomp_b = (iqcomp >> 0) & ((1 << (9 - 0 + 1)) - 1);
+
+			if (restore_cals) {
+				regval[0] = (uint16) iqcomp_a;
+				regval[1] = (uint16) iqcomp_b;
+				wlc_phy_table_write_nphy(pi, 15, 2,
+							 (80 + 2 * core), 16,
+							 regval);
+			}
+
+			wlc_phy_table_read_nphy(pi, txpwrctl_tbl, 1,
+						(lo_ind0 + txpwrindex), 32,
+						&locomp);
+			if (restore_cals) {
+				wlc_phy_table_write_nphy(pi, 15, 1, (85 + core),
+							 16, &locomp);
+			}
+
+			if (NREV_IS(pi->pubpi.phy_rev, 1))
+				wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
+
+			if (PHY_IPA(pi)) {
+				wlc_phy_table_read_nphy(pi,
+							(core ==
+							 PHY_CORE_0 ?
+							 NPHY_TBL_ID_CORE1TXPWRCTL
+							 :
+							 NPHY_TBL_ID_CORE2TXPWRCTL),
+							1, 576 + txpwrindex, 32,
+							&rfpwr_offset);
+
+				mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+					    0x29b, (0x1ff << 4),
+					    ((int16) rfpwr_offset) << 4);
+
+				mod_phy_reg(pi, (core == PHY_CORE_0) ? 0x297 :
+					    0x29b, (0x1 << 2), (1) << 2);
+
+			}
+
+			wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
+		}
+
+		pi->nphy_txpwrindex[core].index = txpwrindex;
+	}
+
+	if (pi->phyhang_avoid)
+		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+}
+
+void
+wlc_phy_txpower_sromlimit_get_nphy(phy_info_t * pi, uint chan, uint8 * max_pwr,
+				   uint8 txp_rate_idx)
+{
+	uint8 chan_freq_range;
+
+	chan_freq_range = wlc_phy_get_chan_freq_range_nphy(pi, chan);
+	switch (chan_freq_range) {
+	case WL_CHAN_FREQ_RANGE_2G:
+		*max_pwr = pi->tx_srom_max_rate_2g[txp_rate_idx];
+		break;
+	case WL_CHAN_FREQ_RANGE_5GM:
+		*max_pwr = pi->tx_srom_max_rate_5g_mid[txp_rate_idx];
+		break;
+	case WL_CHAN_FREQ_RANGE_5GL:
+		*max_pwr = pi->tx_srom_max_rate_5g_low[txp_rate_idx];
+		break;
+	case WL_CHAN_FREQ_RANGE_5GH:
+		*max_pwr = pi->tx_srom_max_rate_5g_hi[txp_rate_idx];
+		break;
+	default:
+		ASSERT(0);
+		*max_pwr = pi->tx_srom_max_rate_2g[txp_rate_idx];
+		break;
+	}
+
+	return;
+}
+
+void wlc_phy_stay_in_carriersearch_nphy(phy_info_t * pi, bool enable)
+{
+	uint16 clip_off[] = { 0xffff, 0xffff };
+
+	ASSERT(0 == (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
+
+	if (enable) {
+		if (pi->nphy_deaf_count == 0) {
+			pi->classifier_state =
+			    wlc_phy_classifier_nphy(pi, 0, 0);
+			wlc_phy_classifier_nphy(pi, (0x7 << 0), 4);
+			wlc_phy_clip_det_nphy(pi, 0, pi->clip_state);
+			wlc_phy_clip_det_nphy(pi, 1, clip_off);
+		}
+
+		pi->nphy_deaf_count++;
+
+		wlc_phy_resetcca_nphy(pi);
+
+	} else {
+		ASSERT(pi->nphy_deaf_count > 0);
+
+		pi->nphy_deaf_count--;
+
+		if (pi->nphy_deaf_count == 0) {
+			wlc_phy_classifier_nphy(pi, (0x7 << 0),
+						pi->classifier_state);
+			wlc_phy_clip_det_nphy(pi, 1, pi->clip_state);
+		}
+	}
+}
+
+void wlc_nphy_deaf_mode(phy_info_t * pi, bool mode)
+{
+	wlapi_suspend_mac_and_wait(pi->sh->physhim);
+
+	if (mode) {
+		if (pi->nphy_deaf_count == 0)
+			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
+	} else {
+		if (pi->nphy_deaf_count > 0)
+			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
+	}
+	wlapi_enable_mac(pi->sh->physhim);
+}
diff --git a/drivers/staging/brcm80211/phy/wlc_phy_radio.h b/drivers/staging/brcm80211/phy/wlc_phy_radio.h
new file mode 100644
index 0000000..72176ae
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phy_radio.h
@@ -0,0 +1,1533 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_BCM20XX_H
+#define	_BCM20XX_H
+
+#define	RADIO_IDCODE			0x01
+
+#define RADIO_DEFAULT_CORE		0
+
+#define	RXC0_RSSI_RST			0x80
+#define	RXC0_MODE_RSSI			0x40
+#define	RXC0_MODE_OFF			0x20
+#define	RXC0_MODE_CM			0x10
+#define	RXC0_LAN_LOAD			0x08
+#define	RXC0_OFF_ADJ_MASK		0x07
+
+#define	TXC0_MODE_TXLPF			0x04
+#define	TXC0_PA_TSSI_EN			0x02
+#define	TXC0_TSSI_EN			0x01
+
+#define	TXC1_PA_GAIN_MASK		0x60
+#define	TXC1_PA_GAIN_3DB		0x40
+#define	TXC1_PA_GAIN_2DB		0x20
+#define	TXC1_TX_MIX_GAIN		0x10
+#define	TXC1_OFF_I_MASK			0x0c
+#define	TXC1_OFF_Q_MASK			0x03
+
+#define	RADIO_2055_READ_OFF		0x100
+#define	RADIO_2057_READ_OFF		0x200
+
+#define RADIO_2055_GEN_SPARE		0x00
+#define RADIO_2055_SP_PIN_PD		0x02
+#define RADIO_2055_SP_RSSI_CORE1	0x03
+#define RADIO_2055_SP_PD_MISC_CORE1	0x04
+#define RADIO_2055_SP_RSSI_CORE2	0x05
+#define RADIO_2055_SP_PD_MISC_CORE2	0x06
+#define RADIO_2055_SP_RX_GC1_CORE1	0x07
+#define RADIO_2055_SP_RX_GC2_CORE1	0x08
+#define RADIO_2055_SP_RX_GC1_CORE2	0x09
+#define RADIO_2055_SP_RX_GC2_CORE2	0x0a
+#define RADIO_2055_SP_LPF_BW_SELECT_CORE1 0x0b
+#define RADIO_2055_SP_LPF_BW_SELECT_CORE2 0x0c
+#define RADIO_2055_SP_TX_GC1_CORE1	0x0d
+#define RADIO_2055_SP_TX_GC2_CORE1	0x0e
+#define RADIO_2055_SP_TX_GC1_CORE2	0x0f
+#define RADIO_2055_SP_TX_GC2_CORE2	0x10
+#define RADIO_2055_MASTER_CNTRL1	0x11
+#define RADIO_2055_MASTER_CNTRL2	0x12
+#define RADIO_2055_PD_LGEN		0x13
+#define RADIO_2055_PD_PLL_TS		0x14
+#define RADIO_2055_PD_CORE1_LGBUF	0x15
+#define RADIO_2055_PD_CORE1_TX		0x16
+#define RADIO_2055_PD_CORE1_RXTX	0x17
+#define RADIO_2055_PD_CORE1_RSSI_MISC	0x18
+#define RADIO_2055_PD_CORE2_LGBUF	0x19
+#define RADIO_2055_PD_CORE2_TX		0x1a
+#define RADIO_2055_PD_CORE2_RXTX	0x1b
+#define RADIO_2055_PD_CORE2_RSSI_MISC	0x1c
+#define RADIO_2055_PWRDET_LGEN		0x1d
+#define RADIO_2055_PWRDET_LGBUF_CORE1	0x1e
+#define RADIO_2055_PWRDET_RXTX_CORE1	0x1f
+#define RADIO_2055_PWRDET_LGBUF_CORE2	0x20
+#define RADIO_2055_PWRDET_RXTX_CORE2	0x21
+#define RADIO_2055_RRCCAL_CNTRL_SPARE	0x22
+#define RADIO_2055_RRCCAL_N_OPT_SEL	0x23
+#define RADIO_2055_CAL_MISC		0x24
+#define RADIO_2055_CAL_COUNTER_OUT	0x25
+#define RADIO_2055_CAL_COUNTER_OUT2	0x26
+#define RADIO_2055_CAL_CVAR_CNTRL	0x27
+#define RADIO_2055_CAL_RVAR_CNTRL	0x28
+#define RADIO_2055_CAL_LPO_CNTRL	0x29
+#define RADIO_2055_CAL_TS		0x2a
+#define RADIO_2055_CAL_RCCAL_READ_TS	0x2b
+#define RADIO_2055_CAL_RCAL_READ_TS	0x2c
+#define RADIO_2055_PAD_DRIVER		0x2d
+#define RADIO_2055_XO_CNTRL1		0x2e
+#define RADIO_2055_XO_CNTRL2		0x2f
+#define RADIO_2055_XO_REGULATOR		0x30
+#define RADIO_2055_XO_MISC		0x31
+#define RADIO_2055_PLL_LF_C1		0x32
+#define RADIO_2055_PLL_CAL_VTH		0x33
+#define RADIO_2055_PLL_LF_C2		0x34
+#define RADIO_2055_PLL_REF		0x35
+#define RADIO_2055_PLL_LF_R1		0x36
+#define RADIO_2055_PLL_PFD_CP		0x37
+#define RADIO_2055_PLL_IDAC_CPOPAMP	0x38
+#define RADIO_2055_PLL_CP_REGULATOR	0x39
+#define RADIO_2055_PLL_RCAL		0x3a
+#define RADIO_2055_RF_PLL_MOD0		0x3b
+#define RADIO_2055_RF_PLL_MOD1		0x3c
+#define RADIO_2055_RF_MMD_IDAC1		0x3d
+#define RADIO_2055_RF_MMD_IDAC0		0x3e
+#define RADIO_2055_RF_MMD_SPARE		0x3f
+#define RADIO_2055_VCO_CAL1		0x40
+#define RADIO_2055_VCO_CAL2		0x41
+#define RADIO_2055_VCO_CAL3		0x42
+#define RADIO_2055_VCO_CAL4		0x43
+#define RADIO_2055_VCO_CAL5		0x44
+#define RADIO_2055_VCO_CAL6		0x45
+#define RADIO_2055_VCO_CAL7		0x46
+#define RADIO_2055_VCO_CAL8		0x47
+#define RADIO_2055_VCO_CAL9		0x48
+#define RADIO_2055_VCO_CAL10		0x49
+#define RADIO_2055_VCO_CAL11		0x4a
+#define RADIO_2055_VCO_CAL12		0x4b
+#define RADIO_2055_VCO_CAL13		0x4c
+#define RADIO_2055_VCO_CAL14		0x4d
+#define RADIO_2055_VCO_CAL15		0x4e
+#define RADIO_2055_VCO_CAL16		0x4f
+#define RADIO_2055_VCO_KVCO		0x50
+#define RADIO_2055_VCO_CAP_TAIL		0x51
+#define RADIO_2055_VCO_IDAC_VCO		0x52
+#define RADIO_2055_VCO_REGULATOR	0x53
+#define RADIO_2055_PLL_RF_VTH		0x54
+#define RADIO_2055_LGBUF_CEN_BUF	0x55
+#define RADIO_2055_LGEN_TUNE1		0x56
+#define RADIO_2055_LGEN_TUNE2		0x57
+#define RADIO_2055_LGEN_IDAC1		0x58
+#define RADIO_2055_LGEN_IDAC2		0x59
+#define RADIO_2055_LGEN_BIAS_CNT	0x5a
+#define RADIO_2055_LGEN_BIAS_IDAC	0x5b
+#define RADIO_2055_LGEN_RCAL		0x5c
+#define RADIO_2055_LGEN_DIV		0x5d
+#define RADIO_2055_LGEN_SPARE2		0x5e
+#define RADIO_2055_CORE1_LGBUF_A_TUNE	0x5f
+#define RADIO_2055_CORE1_LGBUF_G_TUNE	0x60
+#define RADIO_2055_CORE1_LGBUF_DIV	0x61
+#define RADIO_2055_CORE1_LGBUF_A_IDAC	0x62
+#define RADIO_2055_CORE1_LGBUF_G_IDAC	0x63
+#define RADIO_2055_CORE1_LGBUF_IDACFIL_OVR 0x64
+#define RADIO_2055_CORE1_LGBUF_SPARE	0x65
+#define RADIO_2055_CORE1_RXRF_SPC1	0x66
+#define RADIO_2055_CORE1_RXRF_REG1	0x67
+#define RADIO_2055_CORE1_RXRF_REG2	0x68
+#define RADIO_2055_CORE1_RXRF_RCAL	0x69
+#define RADIO_2055_CORE1_RXBB_BUFI_LPFCMP 0x6a
+#define RADIO_2055_CORE1_RXBB_LPF	0x6b
+#define RADIO_2055_CORE1_RXBB_MIDAC_HIPAS 0x6c
+#define RADIO_2055_CORE1_RXBB_VGA1_IDAC	0x6d
+#define RADIO_2055_CORE1_RXBB_VGA2_IDAC	0x6e
+#define RADIO_2055_CORE1_RXBB_VGA3_IDAC	0x6f
+#define RADIO_2055_CORE1_RXBB_BUFO_CTRL	0x70
+#define RADIO_2055_CORE1_RXBB_RCCAL_CTRL 0x71
+#define RADIO_2055_CORE1_RXBB_RSSI_CTRL1 0x72
+#define RADIO_2055_CORE1_RXBB_RSSI_CTRL2 0x73
+#define RADIO_2055_CORE1_RXBB_RSSI_CTRL3 0x74
+#define RADIO_2055_CORE1_RXBB_RSSI_CTRL4 0x75
+#define RADIO_2055_CORE1_RXBB_RSSI_CTRL5 0x76
+#define RADIO_2055_CORE1_RXBB_REGULATOR	0x77
+#define RADIO_2055_CORE1_RXBB_SPARE1	0x78
+#define RADIO_2055_CORE1_RXTXBB_RCAL	0x79
+#define RADIO_2055_CORE1_TXRF_SGM_PGA	0x7a
+#define RADIO_2055_CORE1_TXRF_SGM_PAD	0x7b
+#define RADIO_2055_CORE1_TXRF_CNTR_PGA1	0x7c
+#define RADIO_2055_CORE1_TXRF_CNTR_PAD1	0x7d
+#define RADIO_2055_CORE1_TX_RFPGA_IDAC	0x7e
+#define RADIO_2055_CORE1_TX_PGA_PAD_TN	0x7f
+#define RADIO_2055_CORE1_TX_PAD_IDAC1	0x80
+#define RADIO_2055_CORE1_TX_PAD_IDAC2	0x81
+#define RADIO_2055_CORE1_TX_MX_BGTRIM	0x82
+#define RADIO_2055_CORE1_TXRF_RCAL	0x83
+#define RADIO_2055_CORE1_TXRF_PAD_TSSI1	0x84
+#define RADIO_2055_CORE1_TXRF_PAD_TSSI2	0x85
+#define RADIO_2055_CORE1_TX_RF_SPARE	0x86
+#define RADIO_2055_CORE1_TXRF_IQCAL1	0x87
+#define RADIO_2055_CORE1_TXRF_IQCAL2	0x88
+#define RADIO_2055_CORE1_TXBB_RCCAL_CTRL 0x89
+#define RADIO_2055_CORE1_TXBB_LPF1	0x8a
+#define RADIO_2055_CORE1_TX_VOS_CNCL	0x8b
+#define RADIO_2055_CORE1_TX_LPF_MXGM_IDAC 0x8c
+#define RADIO_2055_CORE1_TX_BB_MXGM	0x8d
+#define RADIO_2055_CORE2_LGBUF_A_TUNE	0x8e
+#define RADIO_2055_CORE2_LGBUF_G_TUNE	0x8f
+#define RADIO_2055_CORE2_LGBUF_DIV	0x90
+#define RADIO_2055_CORE2_LGBUF_A_IDAC	0x91
+#define RADIO_2055_CORE2_LGBUF_G_IDAC	0x92
+#define RADIO_2055_CORE2_LGBUF_IDACFIL_OVR 0x93
+#define RADIO_2055_CORE2_LGBUF_SPARE	0x94
+#define RADIO_2055_CORE2_RXRF_SPC1	0x95
+#define RADIO_2055_CORE2_RXRF_REG1	0x96
+#define RADIO_2055_CORE2_RXRF_REG2	0x97
+#define RADIO_2055_CORE2_RXRF_RCAL	0x98
+#define RADIO_2055_CORE2_RXBB_BUFI_LPFCMP 0x99
+#define RADIO_2055_CORE2_RXBB_LPF	0x9a
+#define RADIO_2055_CORE2_RXBB_MIDAC_HIPAS 0x9b
+#define RADIO_2055_CORE2_RXBB_VGA1_IDAC	0x9c
+#define RADIO_2055_CORE2_RXBB_VGA2_IDAC	0x9d
+#define RADIO_2055_CORE2_RXBB_VGA3_IDAC	0x9e
+#define RADIO_2055_CORE2_RXBB_BUFO_CTRL	0x9f
+#define RADIO_2055_CORE2_RXBB_RCCAL_CTRL 0xa0
+#define RADIO_2055_CORE2_RXBB_RSSI_CTRL1 0xa1
+#define RADIO_2055_CORE2_RXBB_RSSI_CTRL2 0xa2
+#define RADIO_2055_CORE2_RXBB_RSSI_CTRL3 0xa3
+#define RADIO_2055_CORE2_RXBB_RSSI_CTRL4 0xa4
+#define RADIO_2055_CORE2_RXBB_RSSI_CTRL5 0xa5
+#define RADIO_2055_CORE2_RXBB_REGULATOR	0xa6
+#define RADIO_2055_CORE2_RXBB_SPARE1	0xa7
+#define RADIO_2055_CORE2_RXTXBB_RCAL	0xa8
+#define RADIO_2055_CORE2_TXRF_SGM_PGA	0xa9
+#define RADIO_2055_CORE2_TXRF_SGM_PAD	0xaa
+#define RADIO_2055_CORE2_TXRF_CNTR_PGA1	0xab
+#define RADIO_2055_CORE2_TXRF_CNTR_PAD1	0xac
+#define RADIO_2055_CORE2_TX_RFPGA_IDAC	0xad
+#define RADIO_2055_CORE2_TX_PGA_PAD_TN	0xae
+#define RADIO_2055_CORE2_TX_PAD_IDAC1	0xaf
+#define RADIO_2055_CORE2_TX_PAD_IDAC2	0xb0
+#define RADIO_2055_CORE2_TX_MX_BGTRIM	0xb1
+#define RADIO_2055_CORE2_TXRF_RCAL	0xb2
+#define RADIO_2055_CORE2_TXRF_PAD_TSSI1	0xb3
+#define RADIO_2055_CORE2_TXRF_PAD_TSSI2	0xb4
+#define RADIO_2055_CORE2_TX_RF_SPARE	0xb5
+#define RADIO_2055_CORE2_TXRF_IQCAL1	0xb6
+#define RADIO_2055_CORE2_TXRF_IQCAL2	0xb7
+#define RADIO_2055_CORE2_TXBB_RCCAL_CTRL 0xb8
+#define RADIO_2055_CORE2_TXBB_LPF1	0xb9
+#define RADIO_2055_CORE2_TX_VOS_CNCL	0xba
+#define RADIO_2055_CORE2_TX_LPF_MXGM_IDAC 0xbb
+#define RADIO_2055_CORE2_TX_BB_MXGM	0xbc
+#define RADIO_2055_PRG_GC_HPVGA23_21	0xbd
+#define RADIO_2055_PRG_GC_HPVGA23_22	0xbe
+#define RADIO_2055_PRG_GC_HPVGA23_23	0xbf
+#define RADIO_2055_PRG_GC_HPVGA23_24	0xc0
+#define RADIO_2055_PRG_GC_HPVGA23_25	0xc1
+#define RADIO_2055_PRG_GC_HPVGA23_26	0xc2
+#define RADIO_2055_PRG_GC_HPVGA23_27	0xc3
+#define RADIO_2055_PRG_GC_HPVGA23_28	0xc4
+#define RADIO_2055_PRG_GC_HPVGA23_29	0xc5
+#define RADIO_2055_PRG_GC_HPVGA23_30	0xc6
+#define RADIO_2055_CORE1_LNA_GAINBST	0xcd
+#define RADIO_2055_CORE1_B0_NBRSSI_VCM	0xd2
+#define RADIO_2055_CORE1_GEN_SPARE2		0xd6
+#define RADIO_2055_CORE2_LNA_GAINBST	0xd9
+#define RADIO_2055_CORE2_B0_NBRSSI_VCM	0xde
+#define RADIO_2055_CORE2_GEN_SPARE2		0xe2
+
+#define RADIO_2055_GAINBST_GAIN_DB	6
+#define RADIO_2055_GAINBST_CODE		0x6
+
+#define RADIO_2055_JTAGCTRL_MASK	0x04
+#define RADIO_2055_JTAGSYNC_MASK	0x08
+#define RADIO_2055_RRCAL_START		0x40
+#define RADIO_2055_RRCAL_RST_N		0x01
+#define RADIO_2055_CAL_LPO_ENABLE	0x80
+#define RADIO_2055_RCAL_DONE		0x80
+#define RADIO_2055_NBRSSI_VCM_I_MASK	0x03
+#define RADIO_2055_NBRSSI_VCM_I_SHIFT	0x00
+#define RADIO_2055_NBRSSI_VCM_Q_MASK	0x03
+#define RADIO_2055_NBRSSI_VCM_Q_SHIFT	0x00
+#define RADIO_2055_WBRSSI_VCM_IQ_MASK	0x0c
+#define RADIO_2055_WBRSSI_VCM_IQ_SHIFT	0x02
+#define RADIO_2055_NBRSSI_PD		0x01
+#define RADIO_2055_WBRSSI_G1_PD		0x04
+#define RADIO_2055_WBRSSI_G2_PD		0x02
+#define RADIO_2055_NBRSSI_SEL		0x01
+#define RADIO_2055_WBRSSI_G1_SEL	0x04
+#define RADIO_2055_WBRSSI_G2_SEL	0x02
+#define RADIO_2055_COUPLE_RX_MASK	0x01
+#define RADIO_2055_COUPLE_TX_MASK	0x02
+#define RADIO_2055_GAINBST_DISABLE	0x02
+#define RADIO_2055_GAINBST_VAL_MASK	0x07
+#define RADIO_2055_RXMX_GC_MASK		0x0c
+
+#define RADIO_MIMO_CORESEL_OFF		0x0
+#define RADIO_MIMO_CORESEL_CORE1	0x1
+#define RADIO_MIMO_CORESEL_CORE2	0x2
+#define RADIO_MIMO_CORESEL_CORE3	0x3
+#define RADIO_MIMO_CORESEL_CORE4	0x4
+#define RADIO_MIMO_CORESEL_ALLRX	0x5
+#define RADIO_MIMO_CORESEL_ALLTX	0x6
+#define RADIO_MIMO_CORESEL_ALLRXTX	0x7
+
+#define	RADIO_2064_READ_OFF		0x200
+
+#define RADIO_2064_REG000               0x0
+#define RADIO_2064_REG001               0x1
+#define RADIO_2064_REG002               0x2
+#define RADIO_2064_REG003               0x3
+#define RADIO_2064_REG004               0x4
+#define RADIO_2064_REG005               0x5
+#define RADIO_2064_REG006               0x6
+#define RADIO_2064_REG007               0x7
+#define RADIO_2064_REG008               0x8
+#define RADIO_2064_REG009               0x9
+#define RADIO_2064_REG00A               0xa
+#define RADIO_2064_REG00B               0xb
+#define RADIO_2064_REG00C               0xc
+#define RADIO_2064_REG00D               0xd
+#define RADIO_2064_REG00E               0xe
+#define RADIO_2064_REG00F               0xf
+#define RADIO_2064_REG010               0x10
+#define RADIO_2064_REG011               0x11
+#define RADIO_2064_REG012               0x12
+#define RADIO_2064_REG013               0x13
+#define RADIO_2064_REG014               0x14
+#define RADIO_2064_REG015               0x15
+#define RADIO_2064_REG016               0x16
+#define RADIO_2064_REG017               0x17
+#define RADIO_2064_REG018               0x18
+#define RADIO_2064_REG019               0x19
+#define RADIO_2064_REG01A               0x1a
+#define RADIO_2064_REG01B               0x1b
+#define RADIO_2064_REG01C               0x1c
+#define RADIO_2064_REG01D               0x1d
+#define RADIO_2064_REG01E               0x1e
+#define RADIO_2064_REG01F               0x1f
+#define RADIO_2064_REG020               0x20
+#define RADIO_2064_REG021               0x21
+#define RADIO_2064_REG022               0x22
+#define RADIO_2064_REG023               0x23
+#define RADIO_2064_REG024               0x24
+#define RADIO_2064_REG025               0x25
+#define RADIO_2064_REG026               0x26
+#define RADIO_2064_REG027               0x27
+#define RADIO_2064_REG028               0x28
+#define RADIO_2064_REG029               0x29
+#define RADIO_2064_REG02A               0x2a
+#define RADIO_2064_REG02B               0x2b
+#define RADIO_2064_REG02C               0x2c
+#define RADIO_2064_REG02D               0x2d
+#define RADIO_2064_REG02E               0x2e
+#define RADIO_2064_REG02F               0x2f
+#define RADIO_2064_REG030               0x30
+#define RADIO_2064_REG031               0x31
+#define RADIO_2064_REG032               0x32
+#define RADIO_2064_REG033               0x33
+#define RADIO_2064_REG034               0x34
+#define RADIO_2064_REG035               0x35
+#define RADIO_2064_REG036               0x36
+#define RADIO_2064_REG037               0x37
+#define RADIO_2064_REG038               0x38
+#define RADIO_2064_REG039               0x39
+#define RADIO_2064_REG03A               0x3a
+#define RADIO_2064_REG03B               0x3b
+#define RADIO_2064_REG03C               0x3c
+#define RADIO_2064_REG03D               0x3d
+#define RADIO_2064_REG03E               0x3e
+#define RADIO_2064_REG03F               0x3f
+#define RADIO_2064_REG040               0x40
+#define RADIO_2064_REG041               0x41
+#define RADIO_2064_REG042               0x42
+#define RADIO_2064_REG043               0x43
+#define RADIO_2064_REG044               0x44
+#define RADIO_2064_REG045               0x45
+#define RADIO_2064_REG046               0x46
+#define RADIO_2064_REG047               0x47
+#define RADIO_2064_REG048               0x48
+#define RADIO_2064_REG049               0x49
+#define RADIO_2064_REG04A               0x4a
+#define RADIO_2064_REG04B               0x4b
+#define RADIO_2064_REG04C               0x4c
+#define RADIO_2064_REG04D               0x4d
+#define RADIO_2064_REG04E               0x4e
+#define RADIO_2064_REG04F               0x4f
+#define RADIO_2064_REG050               0x50
+#define RADIO_2064_REG051               0x51
+#define RADIO_2064_REG052               0x52
+#define RADIO_2064_REG053               0x53
+#define RADIO_2064_REG054               0x54
+#define RADIO_2064_REG055               0x55
+#define RADIO_2064_REG056               0x56
+#define RADIO_2064_REG057               0x57
+#define RADIO_2064_REG058               0x58
+#define RADIO_2064_REG059               0x59
+#define RADIO_2064_REG05A               0x5a
+#define RADIO_2064_REG05B               0x5b
+#define RADIO_2064_REG05C               0x5c
+#define RADIO_2064_REG05D               0x5d
+#define RADIO_2064_REG05E               0x5e
+#define RADIO_2064_REG05F               0x5f
+#define RADIO_2064_REG060               0x60
+#define RADIO_2064_REG061               0x61
+#define RADIO_2064_REG062               0x62
+#define RADIO_2064_REG063               0x63
+#define RADIO_2064_REG064               0x64
+#define RADIO_2064_REG065               0x65
+#define RADIO_2064_REG066               0x66
+#define RADIO_2064_REG067               0x67
+#define RADIO_2064_REG068               0x68
+#define RADIO_2064_REG069               0x69
+#define RADIO_2064_REG06A               0x6a
+#define RADIO_2064_REG06B               0x6b
+#define RADIO_2064_REG06C               0x6c
+#define RADIO_2064_REG06D               0x6d
+#define RADIO_2064_REG06E               0x6e
+#define RADIO_2064_REG06F               0x6f
+#define RADIO_2064_REG070               0x70
+#define RADIO_2064_REG071               0x71
+#define RADIO_2064_REG072               0x72
+#define RADIO_2064_REG073               0x73
+#define RADIO_2064_REG074               0x74
+#define RADIO_2064_REG075               0x75
+#define RADIO_2064_REG076               0x76
+#define RADIO_2064_REG077               0x77
+#define RADIO_2064_REG078               0x78
+#define RADIO_2064_REG079               0x79
+#define RADIO_2064_REG07A               0x7a
+#define RADIO_2064_REG07B               0x7b
+#define RADIO_2064_REG07C               0x7c
+#define RADIO_2064_REG07D               0x7d
+#define RADIO_2064_REG07E               0x7e
+#define RADIO_2064_REG07F               0x7f
+#define RADIO_2064_REG080               0x80
+#define RADIO_2064_REG081               0x81
+#define RADIO_2064_REG082               0x82
+#define RADIO_2064_REG083               0x83
+#define RADIO_2064_REG084               0x84
+#define RADIO_2064_REG085               0x85
+#define RADIO_2064_REG086               0x86
+#define RADIO_2064_REG087               0x87
+#define RADIO_2064_REG088               0x88
+#define RADIO_2064_REG089               0x89
+#define RADIO_2064_REG08A               0x8a
+#define RADIO_2064_REG08B               0x8b
+#define RADIO_2064_REG08C               0x8c
+#define RADIO_2064_REG08D               0x8d
+#define RADIO_2064_REG08E               0x8e
+#define RADIO_2064_REG08F               0x8f
+#define RADIO_2064_REG090               0x90
+#define RADIO_2064_REG091               0x91
+#define RADIO_2064_REG092               0x92
+#define RADIO_2064_REG093               0x93
+#define RADIO_2064_REG094               0x94
+#define RADIO_2064_REG095               0x95
+#define RADIO_2064_REG096               0x96
+#define RADIO_2064_REG097               0x97
+#define RADIO_2064_REG098               0x98
+#define RADIO_2064_REG099               0x99
+#define RADIO_2064_REG09A               0x9a
+#define RADIO_2064_REG09B               0x9b
+#define RADIO_2064_REG09C               0x9c
+#define RADIO_2064_REG09D               0x9d
+#define RADIO_2064_REG09E               0x9e
+#define RADIO_2064_REG09F               0x9f
+#define RADIO_2064_REG0A0               0xa0
+#define RADIO_2064_REG0A1               0xa1
+#define RADIO_2064_REG0A2               0xa2
+#define RADIO_2064_REG0A3               0xa3
+#define RADIO_2064_REG0A4               0xa4
+#define RADIO_2064_REG0A5               0xa5
+#define RADIO_2064_REG0A6               0xa6
+#define RADIO_2064_REG0A7               0xa7
+#define RADIO_2064_REG0A8               0xa8
+#define RADIO_2064_REG0A9               0xa9
+#define RADIO_2064_REG0AA               0xaa
+#define RADIO_2064_REG0AB               0xab
+#define RADIO_2064_REG0AC               0xac
+#define RADIO_2064_REG0AD               0xad
+#define RADIO_2064_REG0AE               0xae
+#define RADIO_2064_REG0AF               0xaf
+#define RADIO_2064_REG0B0               0xb0
+#define RADIO_2064_REG0B1               0xb1
+#define RADIO_2064_REG0B2               0xb2
+#define RADIO_2064_REG0B3               0xb3
+#define RADIO_2064_REG0B4               0xb4
+#define RADIO_2064_REG0B5               0xb5
+#define RADIO_2064_REG0B6               0xb6
+#define RADIO_2064_REG0B7               0xb7
+#define RADIO_2064_REG0B8               0xb8
+#define RADIO_2064_REG0B9               0xb9
+#define RADIO_2064_REG0BA               0xba
+#define RADIO_2064_REG0BB               0xbb
+#define RADIO_2064_REG0BC               0xbc
+#define RADIO_2064_REG0BD               0xbd
+#define RADIO_2064_REG0BE               0xbe
+#define RADIO_2064_REG0BF               0xbf
+#define RADIO_2064_REG0C0               0xc0
+#define RADIO_2064_REG0C1               0xc1
+#define RADIO_2064_REG0C2               0xc2
+#define RADIO_2064_REG0C3               0xc3
+#define RADIO_2064_REG0C4               0xc4
+#define RADIO_2064_REG0C5               0xc5
+#define RADIO_2064_REG0C6               0xc6
+#define RADIO_2064_REG0C7               0xc7
+#define RADIO_2064_REG0C8               0xc8
+#define RADIO_2064_REG0C9               0xc9
+#define RADIO_2064_REG0CA               0xca
+#define RADIO_2064_REG0CB               0xcb
+#define RADIO_2064_REG0CC               0xcc
+#define RADIO_2064_REG0CD               0xcd
+#define RADIO_2064_REG0CE               0xce
+#define RADIO_2064_REG0CF               0xcf
+#define RADIO_2064_REG0D0               0xd0
+#define RADIO_2064_REG0D1               0xd1
+#define RADIO_2064_REG0D2               0xd2
+#define RADIO_2064_REG0D3               0xd3
+#define RADIO_2064_REG0D4               0xd4
+#define RADIO_2064_REG0D5               0xd5
+#define RADIO_2064_REG0D6               0xd6
+#define RADIO_2064_REG0D7               0xd7
+#define RADIO_2064_REG0D8               0xd8
+#define RADIO_2064_REG0D9               0xd9
+#define RADIO_2064_REG0DA               0xda
+#define RADIO_2064_REG0DB               0xdb
+#define RADIO_2064_REG0DC               0xdc
+#define RADIO_2064_REG0DD               0xdd
+#define RADIO_2064_REG0DE               0xde
+#define RADIO_2064_REG0DF               0xdf
+#define RADIO_2064_REG0E0               0xe0
+#define RADIO_2064_REG0E1               0xe1
+#define RADIO_2064_REG0E2               0xe2
+#define RADIO_2064_REG0E3               0xe3
+#define RADIO_2064_REG0E4               0xe4
+#define RADIO_2064_REG0E5               0xe5
+#define RADIO_2064_REG0E6               0xe6
+#define RADIO_2064_REG0E7               0xe7
+#define RADIO_2064_REG0E8               0xe8
+#define RADIO_2064_REG0E9               0xe9
+#define RADIO_2064_REG0EA               0xea
+#define RADIO_2064_REG0EB               0xeb
+#define RADIO_2064_REG0EC               0xec
+#define RADIO_2064_REG0ED               0xed
+#define RADIO_2064_REG0EE               0xee
+#define RADIO_2064_REG0EF               0xef
+#define RADIO_2064_REG0F0               0xf0
+#define RADIO_2064_REG0F1               0xf1
+#define RADIO_2064_REG0F2               0xf2
+#define RADIO_2064_REG0F3               0xf3
+#define RADIO_2064_REG0F4               0xf4
+#define RADIO_2064_REG0F5               0xf5
+#define RADIO_2064_REG0F6               0xf6
+#define RADIO_2064_REG0F7               0xf7
+#define RADIO_2064_REG0F8               0xf8
+#define RADIO_2064_REG0F9               0xf9
+#define RADIO_2064_REG0FA               0xfa
+#define RADIO_2064_REG0FB               0xfb
+#define RADIO_2064_REG0FC               0xfc
+#define RADIO_2064_REG0FD               0xfd
+#define RADIO_2064_REG0FE               0xfe
+#define RADIO_2064_REG0FF               0xff
+#define RADIO_2064_REG100               0x100
+#define RADIO_2064_REG101               0x101
+#define RADIO_2064_REG102               0x102
+#define RADIO_2064_REG103               0x103
+#define RADIO_2064_REG104               0x104
+#define RADIO_2064_REG105               0x105
+#define RADIO_2064_REG106               0x106
+#define RADIO_2064_REG107               0x107
+#define RADIO_2064_REG108               0x108
+#define RADIO_2064_REG109               0x109
+#define RADIO_2064_REG10A               0x10a
+#define RADIO_2064_REG10B               0x10b
+#define RADIO_2064_REG10C               0x10c
+#define RADIO_2064_REG10D               0x10d
+#define RADIO_2064_REG10E               0x10e
+#define RADIO_2064_REG10F               0x10f
+#define RADIO_2064_REG110               0x110
+#define RADIO_2064_REG111               0x111
+#define RADIO_2064_REG112               0x112
+#define RADIO_2064_REG113               0x113
+#define RADIO_2064_REG114               0x114
+#define RADIO_2064_REG115               0x115
+#define RADIO_2064_REG116               0x116
+#define RADIO_2064_REG117               0x117
+#define RADIO_2064_REG118               0x118
+#define RADIO_2064_REG119               0x119
+#define RADIO_2064_REG11A               0x11a
+#define RADIO_2064_REG11B               0x11b
+#define RADIO_2064_REG11C               0x11c
+#define RADIO_2064_REG11D               0x11d
+#define RADIO_2064_REG11E               0x11e
+#define RADIO_2064_REG11F               0x11f
+#define RADIO_2064_REG120               0x120
+#define RADIO_2064_REG121               0x121
+#define RADIO_2064_REG122               0x122
+#define RADIO_2064_REG123               0x123
+#define RADIO_2064_REG124               0x124
+#define RADIO_2064_REG125               0x125
+#define RADIO_2064_REG126               0x126
+#define RADIO_2064_REG127               0x127
+#define RADIO_2064_REG128               0x128
+#define RADIO_2064_REG129               0x129
+#define RADIO_2064_REG12A               0x12a
+#define RADIO_2064_REG12B               0x12b
+#define RADIO_2064_REG12C               0x12c
+#define RADIO_2064_REG12D               0x12d
+#define RADIO_2064_REG12E               0x12e
+#define RADIO_2064_REG12F               0x12f
+#define RADIO_2064_REG130               0x130
+
+#define RADIO_2056_SYN                           (0x0 << 12)
+#define RADIO_2056_TX0                           (0x2 << 12)
+#define RADIO_2056_TX1                           (0x3 << 12)
+#define RADIO_2056_RX0                           (0x6 << 12)
+#define RADIO_2056_RX1                           (0x7 << 12)
+#define RADIO_2056_ALLTX                         (0xe << 12)
+#define RADIO_2056_ALLRX                         (0xf << 12)
+
+#define RADIO_2056_SYN_RESERVED_ADDR0            0x0
+#define RADIO_2056_SYN_IDCODE                    0x1
+#define RADIO_2056_SYN_RESERVED_ADDR2            0x2
+#define RADIO_2056_SYN_RESERVED_ADDR3            0x3
+#define RADIO_2056_SYN_RESERVED_ADDR4            0x4
+#define RADIO_2056_SYN_RESERVED_ADDR5            0x5
+#define RADIO_2056_SYN_RESERVED_ADDR6            0x6
+#define RADIO_2056_SYN_RESERVED_ADDR7            0x7
+#define RADIO_2056_SYN_COM_CTRL                  0x8
+#define RADIO_2056_SYN_COM_PU                    0x9
+#define RADIO_2056_SYN_COM_OVR                   0xa
+#define RADIO_2056_SYN_COM_RESET                 0xb
+#define RADIO_2056_SYN_COM_RCAL                  0xc
+#define RADIO_2056_SYN_COM_RC_RXLPF              0xd
+#define RADIO_2056_SYN_COM_RC_TXLPF              0xe
+#define RADIO_2056_SYN_COM_RC_RXHPF              0xf
+#define RADIO_2056_SYN_RESERVED_ADDR16           0x10
+#define RADIO_2056_SYN_RESERVED_ADDR17           0x11
+#define RADIO_2056_SYN_RESERVED_ADDR18           0x12
+#define RADIO_2056_SYN_RESERVED_ADDR19           0x13
+#define RADIO_2056_SYN_RESERVED_ADDR20           0x14
+#define RADIO_2056_SYN_RESERVED_ADDR21           0x15
+#define RADIO_2056_SYN_RESERVED_ADDR22           0x16
+#define RADIO_2056_SYN_RESERVED_ADDR23           0x17
+#define RADIO_2056_SYN_RESERVED_ADDR24           0x18
+#define RADIO_2056_SYN_RESERVED_ADDR25           0x19
+#define RADIO_2056_SYN_RESERVED_ADDR26           0x1a
+#define RADIO_2056_SYN_RESERVED_ADDR27           0x1b
+#define RADIO_2056_SYN_RESERVED_ADDR28           0x1c
+#define RADIO_2056_SYN_RESERVED_ADDR29           0x1d
+#define RADIO_2056_SYN_RESERVED_ADDR30           0x1e
+#define RADIO_2056_SYN_RESERVED_ADDR31           0x1f
+#define RADIO_2056_SYN_GPIO_MASTER1              0x20
+#define RADIO_2056_SYN_GPIO_MASTER2              0x21
+#define RADIO_2056_SYN_TOPBIAS_MASTER            0x22
+#define RADIO_2056_SYN_TOPBIAS_RCAL              0x23
+#define RADIO_2056_SYN_AFEREG                    0x24
+#define RADIO_2056_SYN_TEMPPROCSENSE             0x25
+#define RADIO_2056_SYN_TEMPPROCSENSEIDAC         0x26
+#define RADIO_2056_SYN_TEMPPROCSENSERCAL         0x27
+#define RADIO_2056_SYN_LPO                       0x28
+#define RADIO_2056_SYN_VDDCAL_MASTER             0x29
+#define RADIO_2056_SYN_VDDCAL_IDAC               0x2a
+#define RADIO_2056_SYN_VDDCAL_STATUS             0x2b
+#define RADIO_2056_SYN_RCAL_MASTER               0x2c
+#define RADIO_2056_SYN_RCAL_CODE_OUT             0x2d
+#define RADIO_2056_SYN_RCCAL_CTRL0               0x2e
+#define RADIO_2056_SYN_RCCAL_CTRL1               0x2f
+#define RADIO_2056_SYN_RCCAL_CTRL2               0x30
+#define RADIO_2056_SYN_RCCAL_CTRL3               0x31
+#define RADIO_2056_SYN_RCCAL_CTRL4               0x32
+#define RADIO_2056_SYN_RCCAL_CTRL5               0x33
+#define RADIO_2056_SYN_RCCAL_CTRL6               0x34
+#define RADIO_2056_SYN_RCCAL_CTRL7               0x35
+#define RADIO_2056_SYN_RCCAL_CTRL8               0x36
+#define RADIO_2056_SYN_RCCAL_CTRL9               0x37
+#define RADIO_2056_SYN_RCCAL_CTRL10              0x38
+#define RADIO_2056_SYN_RCCAL_CTRL11              0x39
+#define RADIO_2056_SYN_ZCAL_SPARE1               0x3a
+#define RADIO_2056_SYN_ZCAL_SPARE2               0x3b
+#define RADIO_2056_SYN_PLL_MAST1                 0x3c
+#define RADIO_2056_SYN_PLL_MAST2                 0x3d
+#define RADIO_2056_SYN_PLL_MAST3                 0x3e
+#define RADIO_2056_SYN_PLL_BIAS_RESET            0x3f
+#define RADIO_2056_SYN_PLL_XTAL0                 0x40
+#define RADIO_2056_SYN_PLL_XTAL1                 0x41
+#define RADIO_2056_SYN_PLL_XTAL3                 0x42
+#define RADIO_2056_SYN_PLL_XTAL4                 0x43
+#define RADIO_2056_SYN_PLL_XTAL5                 0x44
+#define RADIO_2056_SYN_PLL_XTAL6                 0x45
+#define RADIO_2056_SYN_PLL_REFDIV                0x46
+#define RADIO_2056_SYN_PLL_PFD                   0x47
+#define RADIO_2056_SYN_PLL_CP1                   0x48
+#define RADIO_2056_SYN_PLL_CP2                   0x49
+#define RADIO_2056_SYN_PLL_CP3                   0x4a
+#define RADIO_2056_SYN_PLL_LOOPFILTER1           0x4b
+#define RADIO_2056_SYN_PLL_LOOPFILTER2           0x4c
+#define RADIO_2056_SYN_PLL_LOOPFILTER3           0x4d
+#define RADIO_2056_SYN_PLL_LOOPFILTER4           0x4e
+#define RADIO_2056_SYN_PLL_LOOPFILTER5           0x4f
+#define RADIO_2056_SYN_PLL_MMD1                  0x50
+#define RADIO_2056_SYN_PLL_MMD2                  0x51
+#define RADIO_2056_SYN_PLL_VCO1                  0x52
+#define RADIO_2056_SYN_PLL_VCO2                  0x53
+#define RADIO_2056_SYN_PLL_MONITOR1              0x54
+#define RADIO_2056_SYN_PLL_MONITOR2              0x55
+#define RADIO_2056_SYN_PLL_VCOCAL1               0x56
+#define RADIO_2056_SYN_PLL_VCOCAL2               0x57
+#define RADIO_2056_SYN_PLL_VCOCAL4               0x58
+#define RADIO_2056_SYN_PLL_VCOCAL5               0x59
+#define RADIO_2056_SYN_PLL_VCOCAL6               0x5a
+#define RADIO_2056_SYN_PLL_VCOCAL7               0x5b
+#define RADIO_2056_SYN_PLL_VCOCAL8               0x5c
+#define RADIO_2056_SYN_PLL_VCOCAL9               0x5d
+#define RADIO_2056_SYN_PLL_VCOCAL10              0x5e
+#define RADIO_2056_SYN_PLL_VCOCAL11              0x5f
+#define RADIO_2056_SYN_PLL_VCOCAL12              0x60
+#define RADIO_2056_SYN_PLL_VCOCAL13              0x61
+#define RADIO_2056_SYN_PLL_VREG                  0x62
+#define RADIO_2056_SYN_PLL_STATUS1               0x63
+#define RADIO_2056_SYN_PLL_STATUS2               0x64
+#define RADIO_2056_SYN_PLL_STATUS3               0x65
+#define RADIO_2056_SYN_LOGEN_PU0                 0x66
+#define RADIO_2056_SYN_LOGEN_PU1                 0x67
+#define RADIO_2056_SYN_LOGEN_PU2                 0x68
+#define RADIO_2056_SYN_LOGEN_PU3                 0x69
+#define RADIO_2056_SYN_LOGEN_PU5                 0x6a
+#define RADIO_2056_SYN_LOGEN_PU6                 0x6b
+#define RADIO_2056_SYN_LOGEN_PU7                 0x6c
+#define RADIO_2056_SYN_LOGEN_PU8                 0x6d
+#define RADIO_2056_SYN_LOGEN_BIAS_RESET          0x6e
+#define RADIO_2056_SYN_LOGEN_RCCR1               0x6f
+#define RADIO_2056_SYN_LOGEN_VCOBUF1             0x70
+#define RADIO_2056_SYN_LOGEN_MIXER1              0x71
+#define RADIO_2056_SYN_LOGEN_MIXER2              0x72
+#define RADIO_2056_SYN_LOGEN_BUF1                0x73
+#define RADIO_2056_SYN_LOGENBUF2                 0x74
+#define RADIO_2056_SYN_LOGEN_BUF3                0x75
+#define RADIO_2056_SYN_LOGEN_BUF4                0x76
+#define RADIO_2056_SYN_LOGEN_DIV1                0x77
+#define RADIO_2056_SYN_LOGEN_DIV2                0x78
+#define RADIO_2056_SYN_LOGEN_DIV3                0x79
+#define RADIO_2056_SYN_LOGEN_ACL1                0x7a
+#define RADIO_2056_SYN_LOGEN_ACL2                0x7b
+#define RADIO_2056_SYN_LOGEN_ACL3                0x7c
+#define RADIO_2056_SYN_LOGEN_ACL4                0x7d
+#define RADIO_2056_SYN_LOGEN_ACL5                0x7e
+#define RADIO_2056_SYN_LOGEN_ACL6                0x7f
+#define RADIO_2056_SYN_LOGEN_ACLOUT              0x80
+#define RADIO_2056_SYN_LOGEN_ACLCAL1             0x81
+#define RADIO_2056_SYN_LOGEN_ACLCAL2             0x82
+#define RADIO_2056_SYN_LOGEN_ACLCAL3             0x83
+#define RADIO_2056_SYN_CALEN                     0x84
+#define RADIO_2056_SYN_LOGEN_PEAKDET1            0x85
+#define RADIO_2056_SYN_LOGEN_CORE_ACL_OVR        0x86
+#define RADIO_2056_SYN_LOGEN_RX_DIFF_ACL_OVR     0x87
+#define RADIO_2056_SYN_LOGEN_TX_DIFF_ACL_OVR     0x88
+#define RADIO_2056_SYN_LOGEN_RX_CMOS_ACL_OVR     0x89
+#define RADIO_2056_SYN_LOGEN_TX_CMOS_ACL_OVR     0x8a
+#define RADIO_2056_SYN_LOGEN_VCOBUF2             0x8b
+#define RADIO_2056_SYN_LOGEN_MIXER3              0x8c
+#define RADIO_2056_SYN_LOGEN_BUF5                0x8d
+#define RADIO_2056_SYN_LOGEN_BUF6                0x8e
+#define RADIO_2056_SYN_LOGEN_CBUFRX1             0x8f
+#define RADIO_2056_SYN_LOGEN_CBUFRX2             0x90
+#define RADIO_2056_SYN_LOGEN_CBUFRX3             0x91
+#define RADIO_2056_SYN_LOGEN_CBUFRX4             0x92
+#define RADIO_2056_SYN_LOGEN_CBUFTX1             0x93
+#define RADIO_2056_SYN_LOGEN_CBUFTX2             0x94
+#define RADIO_2056_SYN_LOGEN_CBUFTX3             0x95
+#define RADIO_2056_SYN_LOGEN_CBUFTX4             0x96
+#define RADIO_2056_SYN_LOGEN_CMOSRX1             0x97
+#define RADIO_2056_SYN_LOGEN_CMOSRX2             0x98
+#define RADIO_2056_SYN_LOGEN_CMOSRX3             0x99
+#define RADIO_2056_SYN_LOGEN_CMOSRX4             0x9a
+#define RADIO_2056_SYN_LOGEN_CMOSTX1             0x9b
+#define RADIO_2056_SYN_LOGEN_CMOSTX2             0x9c
+#define RADIO_2056_SYN_LOGEN_CMOSTX3             0x9d
+#define RADIO_2056_SYN_LOGEN_CMOSTX4             0x9e
+#define RADIO_2056_SYN_LOGEN_VCOBUF2_OVRVAL      0x9f
+#define RADIO_2056_SYN_LOGEN_MIXER3_OVRVAL       0xa0
+#define RADIO_2056_SYN_LOGEN_BUF5_OVRVAL         0xa1
+#define RADIO_2056_SYN_LOGEN_BUF6_OVRVAL         0xa2
+#define RADIO_2056_SYN_LOGEN_CBUFRX1_OVRVAL      0xa3
+#define RADIO_2056_SYN_LOGEN_CBUFRX2_OVRVAL      0xa4
+#define RADIO_2056_SYN_LOGEN_CBUFRX3_OVRVAL      0xa5
+#define RADIO_2056_SYN_LOGEN_CBUFRX4_OVRVAL      0xa6
+#define RADIO_2056_SYN_LOGEN_CBUFTX1_OVRVAL      0xa7
+#define RADIO_2056_SYN_LOGEN_CBUFTX2_OVRVAL      0xa8
+#define RADIO_2056_SYN_LOGEN_CBUFTX3_OVRVAL      0xa9
+#define RADIO_2056_SYN_LOGEN_CBUFTX4_OVRVAL      0xaa
+#define RADIO_2056_SYN_LOGEN_CMOSRX1_OVRVAL      0xab
+#define RADIO_2056_SYN_LOGEN_CMOSRX2_OVRVAL      0xac
+#define RADIO_2056_SYN_LOGEN_CMOSRX3_OVRVAL      0xad
+#define RADIO_2056_SYN_LOGEN_CMOSRX4_OVRVAL      0xae
+#define RADIO_2056_SYN_LOGEN_CMOSTX1_OVRVAL      0xaf
+#define RADIO_2056_SYN_LOGEN_CMOSTX2_OVRVAL      0xb0
+#define RADIO_2056_SYN_LOGEN_CMOSTX3_OVRVAL      0xb1
+#define RADIO_2056_SYN_LOGEN_CMOSTX4_OVRVAL      0xb2
+#define RADIO_2056_SYN_LOGEN_ACL_WAITCNT         0xb3
+#define RADIO_2056_SYN_LOGEN_CORE_CALVALID       0xb4
+#define RADIO_2056_SYN_LOGEN_RX_CMOS_CALVALID    0xb5
+#define RADIO_2056_SYN_LOGEN_TX_CMOS_VALID       0xb6
+
+#define RADIO_2056_TX_RESERVED_ADDR0             0x0
+#define RADIO_2056_TX_IDCODE                     0x1
+#define RADIO_2056_TX_RESERVED_ADDR2             0x2
+#define RADIO_2056_TX_RESERVED_ADDR3             0x3
+#define RADIO_2056_TX_RESERVED_ADDR4             0x4
+#define RADIO_2056_TX_RESERVED_ADDR5             0x5
+#define RADIO_2056_TX_RESERVED_ADDR6             0x6
+#define RADIO_2056_TX_RESERVED_ADDR7             0x7
+#define RADIO_2056_TX_COM_CTRL                   0x8
+#define RADIO_2056_TX_COM_PU                     0x9
+#define RADIO_2056_TX_COM_OVR                    0xa
+#define RADIO_2056_TX_COM_RESET                  0xb
+#define RADIO_2056_TX_COM_RCAL                   0xc
+#define RADIO_2056_TX_COM_RC_RXLPF               0xd
+#define RADIO_2056_TX_COM_RC_TXLPF               0xe
+#define RADIO_2056_TX_COM_RC_RXHPF               0xf
+#define RADIO_2056_TX_RESERVED_ADDR16            0x10
+#define RADIO_2056_TX_RESERVED_ADDR17            0x11
+#define RADIO_2056_TX_RESERVED_ADDR18            0x12
+#define RADIO_2056_TX_RESERVED_ADDR19            0x13
+#define RADIO_2056_TX_RESERVED_ADDR20            0x14
+#define RADIO_2056_TX_RESERVED_ADDR21            0x15
+#define RADIO_2056_TX_RESERVED_ADDR22            0x16
+#define RADIO_2056_TX_RESERVED_ADDR23            0x17
+#define RADIO_2056_TX_RESERVED_ADDR24            0x18
+#define RADIO_2056_TX_RESERVED_ADDR25            0x19
+#define RADIO_2056_TX_RESERVED_ADDR26            0x1a
+#define RADIO_2056_TX_RESERVED_ADDR27            0x1b
+#define RADIO_2056_TX_RESERVED_ADDR28            0x1c
+#define RADIO_2056_TX_RESERVED_ADDR29            0x1d
+#define RADIO_2056_TX_RESERVED_ADDR30            0x1e
+#define RADIO_2056_TX_RESERVED_ADDR31            0x1f
+#define RADIO_2056_TX_IQCAL_GAIN_BW              0x20
+#define RADIO_2056_TX_LOFT_FINE_I                0x21
+#define RADIO_2056_TX_LOFT_FINE_Q                0x22
+#define RADIO_2056_TX_LOFT_COARSE_I              0x23
+#define RADIO_2056_TX_LOFT_COARSE_Q              0x24
+#define RADIO_2056_TX_TX_COM_MASTER1             0x25
+#define RADIO_2056_TX_TX_COM_MASTER2             0x26
+#define RADIO_2056_TX_RXIQCAL_TXMUX              0x27
+#define RADIO_2056_TX_TX_SSI_MASTER              0x28
+#define RADIO_2056_TX_IQCAL_VCM_HG               0x29
+#define RADIO_2056_TX_IQCAL_IDAC                 0x2a
+#define RADIO_2056_TX_TSSI_VCM                   0x2b
+#define RADIO_2056_TX_TX_AMP_DET                 0x2c
+#define RADIO_2056_TX_TX_SSI_MUX                 0x2d
+#define RADIO_2056_TX_TSSIA                      0x2e
+#define RADIO_2056_TX_TSSIG                      0x2f
+#define RADIO_2056_TX_TSSI_MISC1                 0x30
+#define RADIO_2056_TX_TSSI_MISC2                 0x31
+#define RADIO_2056_TX_TSSI_MISC3                 0x32
+#define RADIO_2056_TX_PA_SPARE1                  0x33
+#define RADIO_2056_TX_PA_SPARE2                  0x34
+#define RADIO_2056_TX_INTPAA_MASTER              0x35
+#define RADIO_2056_TX_INTPAA_GAIN                0x36
+#define RADIO_2056_TX_INTPAA_BOOST_TUNE          0x37
+#define RADIO_2056_TX_INTPAA_IAUX_STAT           0x38
+#define RADIO_2056_TX_INTPAA_IAUX_DYN            0x39
+#define RADIO_2056_TX_INTPAA_IMAIN_STAT          0x3a
+#define RADIO_2056_TX_INTPAA_IMAIN_DYN           0x3b
+#define RADIO_2056_TX_INTPAA_CASCBIAS            0x3c
+#define RADIO_2056_TX_INTPAA_PASLOPE             0x3d
+#define RADIO_2056_TX_INTPAA_PA_MISC             0x3e
+#define RADIO_2056_TX_INTPAG_MASTER              0x3f
+#define RADIO_2056_TX_INTPAG_GAIN                0x40
+#define RADIO_2056_TX_INTPAG_BOOST_TUNE          0x41
+#define RADIO_2056_TX_INTPAG_IAUX_STAT           0x42
+#define RADIO_2056_TX_INTPAG_IAUX_DYN            0x43
+#define RADIO_2056_TX_INTPAG_IMAIN_STAT          0x44
+#define RADIO_2056_TX_INTPAG_IMAIN_DYN           0x45
+#define RADIO_2056_TX_INTPAG_CASCBIAS            0x46
+#define RADIO_2056_TX_INTPAG_PASLOPE             0x47
+#define RADIO_2056_TX_INTPAG_PA_MISC             0x48
+#define RADIO_2056_TX_PADA_MASTER                0x49
+#define RADIO_2056_TX_PADA_IDAC                  0x4a
+#define RADIO_2056_TX_PADA_CASCBIAS              0x4b
+#define RADIO_2056_TX_PADA_GAIN                  0x4c
+#define RADIO_2056_TX_PADA_BOOST_TUNE            0x4d
+#define RADIO_2056_TX_PADA_SLOPE                 0x4e
+#define RADIO_2056_TX_PADG_MASTER                0x4f
+#define RADIO_2056_TX_PADG_IDAC                  0x50
+#define RADIO_2056_TX_PADG_CASCBIAS              0x51
+#define RADIO_2056_TX_PADG_GAIN                  0x52
+#define RADIO_2056_TX_PADG_BOOST_TUNE            0x53
+#define RADIO_2056_TX_PADG_SLOPE                 0x54
+#define RADIO_2056_TX_PGAA_MASTER                0x55
+#define RADIO_2056_TX_PGAA_IDAC                  0x56
+#define RADIO_2056_TX_PGAA_GAIN                  0x57
+#define RADIO_2056_TX_PGAA_BOOST_TUNE            0x58
+#define RADIO_2056_TX_PGAA_SLOPE                 0x59
+#define RADIO_2056_TX_PGAA_MISC                  0x5a
+#define RADIO_2056_TX_PGAG_MASTER                0x5b
+#define RADIO_2056_TX_PGAG_IDAC                  0x5c
+#define RADIO_2056_TX_PGAG_GAIN                  0x5d
+#define RADIO_2056_TX_PGAG_BOOST_TUNE            0x5e
+#define RADIO_2056_TX_PGAG_SLOPE                 0x5f
+#define RADIO_2056_TX_PGAG_MISC                  0x60
+#define RADIO_2056_TX_MIXA_MASTER                0x61
+#define RADIO_2056_TX_MIXA_BOOST_TUNE            0x62
+#define RADIO_2056_TX_MIXG                       0x63
+#define RADIO_2056_TX_MIXG_BOOST_TUNE            0x64
+#define RADIO_2056_TX_BB_GM_MASTER               0x65
+#define RADIO_2056_TX_GMBB_GM                    0x66
+#define RADIO_2056_TX_GMBB_IDAC                  0x67
+#define RADIO_2056_TX_TXLPF_MASTER               0x68
+#define RADIO_2056_TX_TXLPF_RCCAL                0x69
+#define RADIO_2056_TX_TXLPF_RCCAL_OFF0           0x6a
+#define RADIO_2056_TX_TXLPF_RCCAL_OFF1           0x6b
+#define RADIO_2056_TX_TXLPF_RCCAL_OFF2           0x6c
+#define RADIO_2056_TX_TXLPF_RCCAL_OFF3           0x6d
+#define RADIO_2056_TX_TXLPF_RCCAL_OFF4           0x6e
+#define RADIO_2056_TX_TXLPF_RCCAL_OFF5           0x6f
+#define RADIO_2056_TX_TXLPF_RCCAL_OFF6           0x70
+#define RADIO_2056_TX_TXLPF_BW                   0x71
+#define RADIO_2056_TX_TXLPF_GAIN                 0x72
+#define RADIO_2056_TX_TXLPF_IDAC                 0x73
+#define RADIO_2056_TX_TXLPF_IDAC_0               0x74
+#define RADIO_2056_TX_TXLPF_IDAC_1               0x75
+#define RADIO_2056_TX_TXLPF_IDAC_2               0x76
+#define RADIO_2056_TX_TXLPF_IDAC_3               0x77
+#define RADIO_2056_TX_TXLPF_IDAC_4               0x78
+#define RADIO_2056_TX_TXLPF_IDAC_5               0x79
+#define RADIO_2056_TX_TXLPF_IDAC_6               0x7a
+#define RADIO_2056_TX_TXLPF_OPAMP_IDAC           0x7b
+#define RADIO_2056_TX_TXLPF_MISC                 0x7c
+#define RADIO_2056_TX_TXSPARE1                   0x7d
+#define RADIO_2056_TX_TXSPARE2                   0x7e
+#define RADIO_2056_TX_TXSPARE3                   0x7f
+#define RADIO_2056_TX_TXSPARE4                   0x80
+#define RADIO_2056_TX_TXSPARE5                   0x81
+#define RADIO_2056_TX_TXSPARE6                   0x82
+#define RADIO_2056_TX_TXSPARE7                   0x83
+#define RADIO_2056_TX_TXSPARE8                   0x84
+#define RADIO_2056_TX_TXSPARE9                   0x85
+#define RADIO_2056_TX_TXSPARE10                  0x86
+#define RADIO_2056_TX_TXSPARE11                  0x87
+#define RADIO_2056_TX_TXSPARE12                  0x88
+#define RADIO_2056_TX_TXSPARE13                  0x89
+#define RADIO_2056_TX_TXSPARE14                  0x8a
+#define RADIO_2056_TX_TXSPARE15                  0x8b
+#define RADIO_2056_TX_TXSPARE16                  0x8c
+#define RADIO_2056_TX_STATUS_INTPA_GAIN          0x8d
+#define RADIO_2056_TX_STATUS_PAD_GAIN            0x8e
+#define RADIO_2056_TX_STATUS_PGA_GAIN            0x8f
+#define RADIO_2056_TX_STATUS_GM_TXLPF_GAIN       0x90
+#define RADIO_2056_TX_STATUS_TXLPF_BW            0x91
+#define RADIO_2056_TX_STATUS_TXLPF_RC            0x92
+#define RADIO_2056_TX_GMBB_IDAC0                 0x93
+#define RADIO_2056_TX_GMBB_IDAC1                 0x94
+#define RADIO_2056_TX_GMBB_IDAC2                 0x95
+#define RADIO_2056_TX_GMBB_IDAC3                 0x96
+#define RADIO_2056_TX_GMBB_IDAC4                 0x97
+#define RADIO_2056_TX_GMBB_IDAC5                 0x98
+#define RADIO_2056_TX_GMBB_IDAC6                 0x99
+#define RADIO_2056_TX_GMBB_IDAC7                 0x9a
+
+#define RADIO_2056_RX_RESERVED_ADDR0             0x0
+#define RADIO_2056_RX_IDCODE                     0x1
+#define RADIO_2056_RX_RESERVED_ADDR2             0x2
+#define RADIO_2056_RX_RESERVED_ADDR3             0x3
+#define RADIO_2056_RX_RESERVED_ADDR4             0x4
+#define RADIO_2056_RX_RESERVED_ADDR5             0x5
+#define RADIO_2056_RX_RESERVED_ADDR6             0x6
+#define RADIO_2056_RX_RESERVED_ADDR7             0x7
+#define RADIO_2056_RX_COM_CTRL                   0x8
+#define RADIO_2056_RX_COM_PU                     0x9
+#define RADIO_2056_RX_COM_OVR                    0xa
+#define RADIO_2056_RX_COM_RESET                  0xb
+#define RADIO_2056_RX_COM_RCAL                   0xc
+#define RADIO_2056_RX_COM_RC_RXLPF               0xd
+#define RADIO_2056_RX_COM_RC_TXLPF               0xe
+#define RADIO_2056_RX_COM_RC_RXHPF               0xf
+#define RADIO_2056_RX_RESERVED_ADDR16            0x10
+#define RADIO_2056_RX_RESERVED_ADDR17            0x11
+#define RADIO_2056_RX_RESERVED_ADDR18            0x12
+#define RADIO_2056_RX_RESERVED_ADDR19            0x13
+#define RADIO_2056_RX_RESERVED_ADDR20            0x14
+#define RADIO_2056_RX_RESERVED_ADDR21            0x15
+#define RADIO_2056_RX_RESERVED_ADDR22            0x16
+#define RADIO_2056_RX_RESERVED_ADDR23            0x17
+#define RADIO_2056_RX_RESERVED_ADDR24            0x18
+#define RADIO_2056_RX_RESERVED_ADDR25            0x19
+#define RADIO_2056_RX_RESERVED_ADDR26            0x1a
+#define RADIO_2056_RX_RESERVED_ADDR27            0x1b
+#define RADIO_2056_RX_RESERVED_ADDR28            0x1c
+#define RADIO_2056_RX_RESERVED_ADDR29            0x1d
+#define RADIO_2056_RX_RESERVED_ADDR30            0x1e
+#define RADIO_2056_RX_RESERVED_ADDR31            0x1f
+#define RADIO_2056_RX_RXIQCAL_RXMUX              0x20
+#define RADIO_2056_RX_RSSI_PU                    0x21
+#define RADIO_2056_RX_RSSI_SEL                   0x22
+#define RADIO_2056_RX_RSSI_GAIN                  0x23
+#define RADIO_2056_RX_RSSI_NB_IDAC               0x24
+#define RADIO_2056_RX_RSSI_WB2I_IDAC_1           0x25
+#define RADIO_2056_RX_RSSI_WB2I_IDAC_2           0x26
+#define RADIO_2056_RX_RSSI_WB2Q_IDAC_1           0x27
+#define RADIO_2056_RX_RSSI_WB2Q_IDAC_2           0x28
+#define RADIO_2056_RX_RSSI_POLE                  0x29
+#define RADIO_2056_RX_RSSI_WB1_IDAC              0x2a
+#define RADIO_2056_RX_RSSI_MISC                  0x2b
+#define RADIO_2056_RX_LNAA_MASTER                0x2c
+#define RADIO_2056_RX_LNAA_TUNE                  0x2d
+#define RADIO_2056_RX_LNAA_GAIN                  0x2e
+#define RADIO_2056_RX_LNA_A_SLOPE                0x2f
+#define RADIO_2056_RX_BIASPOLE_LNAA1_IDAC        0x30
+#define RADIO_2056_RX_LNAA2_IDAC                 0x31
+#define RADIO_2056_RX_LNA1A_MISC                 0x32
+#define RADIO_2056_RX_LNAG_MASTER                0x33
+#define RADIO_2056_RX_LNAG_TUNE                  0x34
+#define RADIO_2056_RX_LNAG_GAIN                  0x35
+#define RADIO_2056_RX_LNA_G_SLOPE                0x36
+#define RADIO_2056_RX_BIASPOLE_LNAG1_IDAC        0x37
+#define RADIO_2056_RX_LNAG2_IDAC                 0x38
+#define RADIO_2056_RX_LNA1G_MISC                 0x39
+#define RADIO_2056_RX_MIXA_MASTER                0x3a
+#define RADIO_2056_RX_MIXA_VCM                   0x3b
+#define RADIO_2056_RX_MIXA_CTRLPTAT              0x3c
+#define RADIO_2056_RX_MIXA_LOB_BIAS              0x3d
+#define RADIO_2056_RX_MIXA_CORE_IDAC             0x3e
+#define RADIO_2056_RX_MIXA_CMFB_IDAC             0x3f
+#define RADIO_2056_RX_MIXA_BIAS_AUX              0x40
+#define RADIO_2056_RX_MIXA_BIAS_MAIN             0x41
+#define RADIO_2056_RX_MIXA_BIAS_MISC             0x42
+#define RADIO_2056_RX_MIXA_MAST_BIAS             0x43
+#define RADIO_2056_RX_MIXG_MASTER                0x44
+#define RADIO_2056_RX_MIXG_VCM                   0x45
+#define RADIO_2056_RX_MIXG_CTRLPTAT              0x46
+#define RADIO_2056_RX_MIXG_LOB_BIAS              0x47
+#define RADIO_2056_RX_MIXG_CORE_IDAC             0x48
+#define RADIO_2056_RX_MIXG_CMFB_IDAC             0x49
+#define RADIO_2056_RX_MIXG_BIAS_AUX              0x4a
+#define RADIO_2056_RX_MIXG_BIAS_MAIN             0x4b
+#define RADIO_2056_RX_MIXG_BIAS_MISC             0x4c
+#define RADIO_2056_RX_MIXG_MAST_BIAS             0x4d
+#define RADIO_2056_RX_TIA_MASTER                 0x4e
+#define RADIO_2056_RX_TIA_IOPAMP                 0x4f
+#define RADIO_2056_RX_TIA_QOPAMP                 0x50
+#define RADIO_2056_RX_TIA_IMISC                  0x51
+#define RADIO_2056_RX_TIA_QMISC                  0x52
+#define RADIO_2056_RX_TIA_GAIN                   0x53
+#define RADIO_2056_RX_TIA_SPARE1                 0x54
+#define RADIO_2056_RX_TIA_SPARE2                 0x55
+#define RADIO_2056_RX_BB_LPF_MASTER              0x56
+#define RADIO_2056_RX_AACI_MASTER                0x57
+#define RADIO_2056_RX_RXLPF_IDAC                 0x58
+#define RADIO_2056_RX_RXLPF_OPAMPBIAS_LOWQ       0x59
+#define RADIO_2056_RX_RXLPF_OPAMPBIAS_HIGHQ      0x5a
+#define RADIO_2056_RX_RXLPF_BIAS_DCCANCEL        0x5b
+#define RADIO_2056_RX_RXLPF_OUTVCM               0x5c
+#define RADIO_2056_RX_RXLPF_INVCM_BODY           0x5d
+#define RADIO_2056_RX_RXLPF_CC_OP                0x5e
+#define RADIO_2056_RX_RXLPF_GAIN                 0x5f
+#define RADIO_2056_RX_RXLPF_Q_BW                 0x60
+#define RADIO_2056_RX_RXLPF_HP_CORNER_BW         0x61
+#define RADIO_2056_RX_RXLPF_RCCAL_HPC            0x62
+#define RADIO_2056_RX_RXHPF_OFF0                 0x63
+#define RADIO_2056_RX_RXHPF_OFF1                 0x64
+#define RADIO_2056_RX_RXHPF_OFF2                 0x65
+#define RADIO_2056_RX_RXHPF_OFF3                 0x66
+#define RADIO_2056_RX_RXHPF_OFF4                 0x67
+#define RADIO_2056_RX_RXHPF_OFF5                 0x68
+#define RADIO_2056_RX_RXHPF_OFF6                 0x69
+#define RADIO_2056_RX_RXHPF_OFF7                 0x6a
+#define RADIO_2056_RX_RXLPF_RCCAL_LPC            0x6b
+#define RADIO_2056_RX_RXLPF_OFF_0                0x6c
+#define RADIO_2056_RX_RXLPF_OFF_1                0x6d
+#define RADIO_2056_RX_RXLPF_OFF_2                0x6e
+#define RADIO_2056_RX_RXLPF_OFF_3                0x6f
+#define RADIO_2056_RX_RXLPF_OFF_4                0x70
+#define RADIO_2056_RX_UNUSED                     0x71
+#define RADIO_2056_RX_VGA_MASTER                 0x72
+#define RADIO_2056_RX_VGA_BIAS                   0x73
+#define RADIO_2056_RX_VGA_BIAS_DCCANCEL          0x74
+#define RADIO_2056_RX_VGA_GAIN                   0x75
+#define RADIO_2056_RX_VGA_HP_CORNER_BW           0x76
+#define RADIO_2056_RX_VGABUF_BIAS                0x77
+#define RADIO_2056_RX_VGABUF_GAIN_BW             0x78
+#define RADIO_2056_RX_TXFBMIX_A                  0x79
+#define RADIO_2056_RX_TXFBMIX_G                  0x7a
+#define RADIO_2056_RX_RXSPARE1                   0x7b
+#define RADIO_2056_RX_RXSPARE2                   0x7c
+#define RADIO_2056_RX_RXSPARE3                   0x7d
+#define RADIO_2056_RX_RXSPARE4                   0x7e
+#define RADIO_2056_RX_RXSPARE5                   0x7f
+#define RADIO_2056_RX_RXSPARE6                   0x80
+#define RADIO_2056_RX_RXSPARE7                   0x81
+#define RADIO_2056_RX_RXSPARE8                   0x82
+#define RADIO_2056_RX_RXSPARE9                   0x83
+#define RADIO_2056_RX_RXSPARE10                  0x84
+#define RADIO_2056_RX_RXSPARE11                  0x85
+#define RADIO_2056_RX_RXSPARE12                  0x86
+#define RADIO_2056_RX_RXSPARE13                  0x87
+#define RADIO_2056_RX_RXSPARE14                  0x88
+#define RADIO_2056_RX_RXSPARE15                  0x89
+#define RADIO_2056_RX_RXSPARE16                  0x8a
+#define RADIO_2056_RX_STATUS_LNAA_GAIN           0x8b
+#define RADIO_2056_RX_STATUS_LNAG_GAIN           0x8c
+#define RADIO_2056_RX_STATUS_MIXTIA_GAIN         0x8d
+#define RADIO_2056_RX_STATUS_RXLPF_GAIN          0x8e
+#define RADIO_2056_RX_STATUS_VGA_BUF_GAIN        0x8f
+#define RADIO_2056_RX_STATUS_RXLPF_Q             0x90
+#define RADIO_2056_RX_STATUS_RXLPF_BUF_BW        0x91
+#define RADIO_2056_RX_STATUS_RXLPF_VGA_HPC       0x92
+#define RADIO_2056_RX_STATUS_RXLPF_RC            0x93
+#define RADIO_2056_RX_STATUS_HPC_RC              0x94
+
+#define RADIO_2056_LNA1_A_PU		0x01
+#define RADIO_2056_LNA2_A_PU		0x02
+#define RADIO_2056_LNA1_G_PU		0x01
+#define RADIO_2056_LNA2_G_PU		0x02
+#define RADIO_2056_MIXA_PU_I		0x01
+#define RADIO_2056_MIXA_PU_Q		0x02
+#define RADIO_2056_MIXA_PU_GM		0x10
+#define RADIO_2056_MIXG_PU_I		0x01
+#define RADIO_2056_MIXG_PU_Q		0x02
+#define RADIO_2056_MIXG_PU_GM		0x10
+#define RADIO_2056_TIA_PU			0x01
+#define RADIO_2056_BB_LPF_PU		0x20
+#define RADIO_2056_W1_PU			0x02
+#define RADIO_2056_W2_PU			0x04
+#define RADIO_2056_NB_PU			0x08
+#define RADIO_2056_RSSI_W1_SEL		0x02
+#define RADIO_2056_RSSI_W2_SEL		0x04
+#define RADIO_2056_RSSI_NB_SEL		0x08
+#define RADIO_2056_VCM_MASK			0x1c
+#define RADIO_2056_RSSI_VCM_SHIFT	0x02
+
+#define RADIO_2057_DACBUF_VINCM_CORE0            0x0
+#define RADIO_2057_IDCODE                        0x1
+#define RADIO_2057_RCCAL_MASTER                  0x2
+#define RADIO_2057_RCCAL_CAP_SIZE                0x3
+#define RADIO_2057_RCAL_CONFIG                   0x4
+#define RADIO_2057_GPAIO_CONFIG                  0x5
+#define RADIO_2057_GPAIO_SEL1                    0x6
+#define RADIO_2057_GPAIO_SEL0                    0x7
+#define RADIO_2057_CLPO_CONFIG                   0x8
+#define RADIO_2057_BANDGAP_CONFIG                0x9
+#define RADIO_2057_BANDGAP_RCAL_TRIM             0xa
+#define RADIO_2057_AFEREG_CONFIG                 0xb
+#define RADIO_2057_TEMPSENSE_CONFIG              0xc
+#define RADIO_2057_XTAL_CONFIG1                  0xd
+#define RADIO_2057_XTAL_ICORE_SIZE               0xe
+#define RADIO_2057_XTAL_BUF_SIZE                 0xf
+#define RADIO_2057_XTAL_PULLCAP_SIZE             0x10
+#define RADIO_2057_RFPLL_MASTER                  0x11
+#define RADIO_2057_VCOMONITOR_VTH_L              0x12
+#define RADIO_2057_VCOMONITOR_VTH_H              0x13
+#define RADIO_2057_VCOCAL_BIASRESET_RFPLLREG_VOUT 0x14
+#define RADIO_2057_VCO_VARCSIZE_IDAC             0x15
+#define RADIO_2057_VCOCAL_COUNTVAL0              0x16
+#define RADIO_2057_VCOCAL_COUNTVAL1              0x17
+#define RADIO_2057_VCOCAL_INTCLK_COUNT           0x18
+#define RADIO_2057_VCOCAL_MASTER                 0x19
+#define RADIO_2057_VCOCAL_NUMCAPCHANGE           0x1a
+#define RADIO_2057_VCOCAL_WINSIZE                0x1b
+#define RADIO_2057_VCOCAL_DELAY_AFTER_REFRESH    0x1c
+#define RADIO_2057_VCOCAL_DELAY_AFTER_CLOSELOOP  0x1d
+#define RADIO_2057_VCOCAL_DELAY_AFTER_OPENLOOP   0x1e
+#define RADIO_2057_VCOCAL_DELAY_BEFORE_OPENLOOP  0x1f
+#define RADIO_2057_VCO_FORCECAPEN_FORCECAP1      0x20
+#define RADIO_2057_VCO_FORCECAP0                 0x21
+#define RADIO_2057_RFPLL_REFMASTER_SPAREXTALSIZE 0x22
+#define RADIO_2057_RFPLL_PFD_RESET_PW            0x23
+#define RADIO_2057_RFPLL_LOOPFILTER_R2           0x24
+#define RADIO_2057_RFPLL_LOOPFILTER_R1           0x25
+#define RADIO_2057_RFPLL_LOOPFILTER_C3           0x26
+#define RADIO_2057_RFPLL_LOOPFILTER_C2           0x27
+#define RADIO_2057_RFPLL_LOOPFILTER_C1           0x28
+#define RADIO_2057_CP_KPD_IDAC                   0x29
+#define RADIO_2057_RFPLL_IDACS                   0x2a
+#define RADIO_2057_RFPLL_MISC_EN                 0x2b
+#define RADIO_2057_RFPLL_MMD0                    0x2c
+#define RADIO_2057_RFPLL_MMD1                    0x2d
+#define RADIO_2057_RFPLL_MISC_CAL_RESETN         0x2e
+#define RADIO_2057_JTAGXTAL_SIZE_CPBIAS_FILTRES  0x2f
+#define RADIO_2057_VCO_ALCREF_BBPLLXTAL_SIZE     0x30
+#define RADIO_2057_VCOCAL_READCAP0               0x31
+#define RADIO_2057_VCOCAL_READCAP1               0x32
+#define RADIO_2057_VCOCAL_STATUS                 0x33
+#define RADIO_2057_LOGEN_PUS                     0x34
+#define RADIO_2057_LOGEN_PTAT_RESETS             0x35
+#define RADIO_2057_VCOBUF_IDACS                  0x36
+#define RADIO_2057_VCOBUF_TUNE                   0x37
+#define RADIO_2057_CMOSBUF_TX2GQ_IDACS           0x38
+#define RADIO_2057_CMOSBUF_TX2GI_IDACS           0x39
+#define RADIO_2057_CMOSBUF_TX5GQ_IDACS           0x3a
+#define RADIO_2057_CMOSBUF_TX5GI_IDACS           0x3b
+#define RADIO_2057_CMOSBUF_RX2GQ_IDACS           0x3c
+#define RADIO_2057_CMOSBUF_RX2GI_IDACS           0x3d
+#define RADIO_2057_CMOSBUF_RX5GQ_IDACS           0x3e
+#define RADIO_2057_CMOSBUF_RX5GI_IDACS           0x3f
+#define RADIO_2057_LOGEN_MX2G_IDACS              0x40
+#define RADIO_2057_LOGEN_MX2G_TUNE               0x41
+#define RADIO_2057_LOGEN_MX5G_IDACS              0x42
+#define RADIO_2057_LOGEN_MX5G_TUNE               0x43
+#define RADIO_2057_LOGEN_MX5G_RCCR               0x44
+#define RADIO_2057_LOGEN_INDBUF2G_IDAC           0x45
+#define RADIO_2057_LOGEN_INDBUF2G_IBOOST         0x46
+#define RADIO_2057_LOGEN_INDBUF2G_TUNE           0x47
+#define RADIO_2057_LOGEN_INDBUF5G_IDAC           0x48
+#define RADIO_2057_LOGEN_INDBUF5G_IBOOST         0x49
+#define RADIO_2057_LOGEN_INDBUF5G_TUNE           0x4a
+#define RADIO_2057_CMOSBUF_TX_RCCR               0x4b
+#define RADIO_2057_CMOSBUF_RX_RCCR               0x4c
+#define RADIO_2057_LOGEN_SEL_PKDET               0x4d
+#define RADIO_2057_CMOSBUF_SHAREIQ_PTAT          0x4e
+#define RADIO_2057_RXTXBIAS_CONFIG_CORE0         0x4f
+#define RADIO_2057_TXGM_TXRF_PUS_CORE0           0x50
+#define RADIO_2057_TXGM_IDAC_BLEED_CORE0         0x51
+#define RADIO_2057_TXGM_GAIN_CORE0               0x56
+#define RADIO_2057_TXGM2G_PKDET_PUS_CORE0        0x57
+#define RADIO_2057_PAD2G_PTATS_CORE0             0x58
+#define RADIO_2057_PAD2G_IDACS_CORE0             0x59
+#define RADIO_2057_PAD2G_BOOST_PU_CORE0          0x5a
+#define RADIO_2057_PAD2G_CASCV_GAIN_CORE0        0x5b
+#define RADIO_2057_TXMIX2G_TUNE_BOOST_PU_CORE0   0x5c
+#define RADIO_2057_TXMIX2G_LODC_CORE0            0x5d
+#define RADIO_2057_PAD2G_TUNE_PUS_CORE0          0x5e
+#define RADIO_2057_IPA2G_GAIN_CORE0              0x5f
+#define RADIO_2057_TSSI2G_SPARE1_CORE0           0x60
+#define RADIO_2057_TSSI2G_SPARE2_CORE0           0x61
+#define RADIO_2057_IPA2G_TUNEV_CASCV_PTAT_CORE0  0x62
+#define RADIO_2057_IPA2G_IMAIN_CORE0             0x63
+#define RADIO_2057_IPA2G_CASCONV_CORE0           0x64
+#define RADIO_2057_IPA2G_CASCOFFV_CORE0          0x65
+#define RADIO_2057_IPA2G_BIAS_FILTER_CORE0       0x66
+#define RADIO_2057_TX5G_PKDET_CORE0              0x69
+#define RADIO_2057_PGA_PTAT_TXGM5G_PU_CORE0      0x6a
+#define RADIO_2057_PAD5G_PTATS1_CORE0            0x6b
+#define RADIO_2057_PAD5G_CLASS_PTATS2_CORE0      0x6c
+#define RADIO_2057_PGA_BOOSTPTAT_IMAIN_CORE0     0x6d
+#define RADIO_2057_PAD5G_CASCV_IMAIN_CORE0       0x6e
+#define RADIO_2057_TXMIX5G_IBOOST_PAD_IAUX_CORE0 0x6f
+#define RADIO_2057_PGA_BOOST_TUNE_CORE0          0x70
+#define RADIO_2057_PGA_GAIN_CORE0                0x71
+#define RADIO_2057_PAD5G_CASCOFFV_GAIN_PUS_CORE0 0x72
+#define RADIO_2057_TXMIX5G_BOOST_TUNE_CORE0      0x73
+#define RADIO_2057_PAD5G_TUNE_MISC_PUS_CORE0     0x74
+#define RADIO_2057_IPA5G_IAUX_CORE0              0x75
+#define RADIO_2057_IPA5G_GAIN_CORE0              0x76
+#define RADIO_2057_TSSI5G_SPARE1_CORE0           0x77
+#define RADIO_2057_TSSI5G_SPARE2_CORE0           0x78
+#define RADIO_2057_IPA5G_CASCOFFV_PU_CORE0       0x79
+#define RADIO_2057_IPA5G_PTAT_CORE0              0x7a
+#define RADIO_2057_IPA5G_IMAIN_CORE0             0x7b
+#define RADIO_2057_IPA5G_CASCONV_CORE0           0x7c
+#define RADIO_2057_IPA5G_BIAS_FILTER_CORE0       0x7d
+#define RADIO_2057_PAD_BIAS_FILTER_BWS_CORE0     0x80
+#define RADIO_2057_TR2G_CONFIG1_CORE0_NU         0x81
+#define RADIO_2057_TR2G_CONFIG2_CORE0_NU         0x82
+#define RADIO_2057_LNA5G_RFEN_CORE0              0x83
+#define RADIO_2057_TR5G_CONFIG2_CORE0_NU         0x84
+#define RADIO_2057_RXRFBIAS_IBOOST_PU_CORE0      0x85
+#define RADIO_2057_RXRF_IABAND_RXGM_IMAIN_PTAT_CORE0 0x86
+#define RADIO_2057_RXGM_CMFBITAIL_AUXPTAT_CORE0  0x87
+#define RADIO_2057_RXMIX_ICORE_RXGM_IAUX_CORE0   0x88
+#define RADIO_2057_RXMIX_CMFBITAIL_PU_CORE0      0x89
+#define RADIO_2057_LNA2_IMAIN_PTAT_PU_CORE0      0x8a
+#define RADIO_2057_LNA2_IAUX_PTAT_CORE0          0x8b
+#define RADIO_2057_LNA1_IMAIN_PTAT_PU_CORE0      0x8c
+#define RADIO_2057_LNA15G_INPUT_MATCH_TUNE_CORE0 0x8d
+#define RADIO_2057_RXRFBIAS_BANDSEL_CORE0        0x8e
+#define RADIO_2057_TIA_CONFIG_CORE0              0x8f
+#define RADIO_2057_TIA_IQGAIN_CORE0              0x90
+#define RADIO_2057_TIA_IBIAS2_CORE0              0x91
+#define RADIO_2057_TIA_IBIAS1_CORE0              0x92
+#define RADIO_2057_TIA_SPARE_Q_CORE0             0x93
+#define RADIO_2057_TIA_SPARE_I_CORE0             0x94
+#define RADIO_2057_RXMIX2G_PUS_CORE0             0x95
+#define RADIO_2057_RXMIX2G_VCMREFS_CORE0         0x96
+#define RADIO_2057_RXMIX2G_LODC_QI_CORE0         0x97
+#define RADIO_2057_W12G_BW_LNA2G_PUS_CORE0       0x98
+#define RADIO_2057_LNA2G_GAIN_CORE0              0x99
+#define RADIO_2057_LNA2G_TUNE_CORE0              0x9a
+#define RADIO_2057_RXMIX5G_PUS_CORE0             0x9b
+#define RADIO_2057_RXMIX5G_VCMREFS_CORE0         0x9c
+#define RADIO_2057_RXMIX5G_LODC_QI_CORE0         0x9d
+#define RADIO_2057_W15G_BW_LNA5G_PUS_CORE0       0x9e
+#define RADIO_2057_LNA5G_GAIN_CORE0              0x9f
+#define RADIO_2057_LNA5G_TUNE_CORE0              0xa0
+#define RADIO_2057_LPFSEL_TXRX_RXBB_PUS_CORE0    0xa1
+#define RADIO_2057_RXBB_BIAS_MASTER_CORE0        0xa2
+#define RADIO_2057_RXBB_VGABUF_IDACS_CORE0       0xa3
+#define RADIO_2057_LPF_VCMREF_TXBUF_VCMREF_CORE0 0xa4
+#define RADIO_2057_TXBUF_VINCM_CORE0             0xa5
+#define RADIO_2057_TXBUF_IDACS_CORE0             0xa6
+#define RADIO_2057_LPF_RESP_RXBUF_BW_CORE0       0xa7
+#define RADIO_2057_RXBB_CC_CORE0                 0xa8
+#define RADIO_2057_RXBB_SPARE3_CORE0             0xa9
+#define RADIO_2057_RXBB_RCCAL_HPC_CORE0          0xaa
+#define RADIO_2057_LPF_IDACS_CORE0               0xab
+#define RADIO_2057_LPFBYP_DCLOOP_BYP_IDAC_CORE0  0xac
+#define RADIO_2057_TXBUF_GAIN_CORE0              0xad
+#define RADIO_2057_AFELOOPBACK_AACI_RESP_CORE0   0xae
+#define RADIO_2057_RXBUF_DEGEN_CORE0             0xaf
+#define RADIO_2057_RXBB_SPARE2_CORE0             0xb0
+#define RADIO_2057_RXBB_SPARE1_CORE0             0xb1
+#define RADIO_2057_RSSI_MASTER_CORE0             0xb2
+#define RADIO_2057_W2_MASTER_CORE0               0xb3
+#define RADIO_2057_NB_MASTER_CORE0               0xb4
+#define RADIO_2057_W2_IDACS0_Q_CORE0             0xb5
+#define RADIO_2057_W2_IDACS1_Q_CORE0             0xb6
+#define RADIO_2057_W2_IDACS0_I_CORE0             0xb7
+#define RADIO_2057_W2_IDACS1_I_CORE0             0xb8
+#define RADIO_2057_RSSI_GPAIOSEL_W1_IDACS_CORE0  0xb9
+#define RADIO_2057_NB_IDACS_Q_CORE0              0xba
+#define RADIO_2057_NB_IDACS_I_CORE0              0xbb
+#define RADIO_2057_BACKUP4_CORE0                 0xc1
+#define RADIO_2057_BACKUP3_CORE0                 0xc2
+#define RADIO_2057_BACKUP2_CORE0                 0xc3
+#define RADIO_2057_BACKUP1_CORE0                 0xc4
+#define RADIO_2057_SPARE16_CORE0                 0xc5
+#define RADIO_2057_SPARE15_CORE0                 0xc6
+#define RADIO_2057_SPARE14_CORE0                 0xc7
+#define RADIO_2057_SPARE13_CORE0                 0xc8
+#define RADIO_2057_SPARE12_CORE0                 0xc9
+#define RADIO_2057_SPARE11_CORE0                 0xca
+#define RADIO_2057_TX2G_BIAS_RESETS_CORE0        0xcb
+#define RADIO_2057_TX5G_BIAS_RESETS_CORE0        0xcc
+#define RADIO_2057_IQTEST_SEL_PU                 0xcd
+#define RADIO_2057_XTAL_CONFIG2                  0xce
+#define RADIO_2057_BUFS_MISC_LPFBW_CORE0         0xcf
+#define RADIO_2057_TXLPF_RCCAL_CORE0             0xd0
+#define RADIO_2057_RXBB_GPAIOSEL_RXLPF_RCCAL_CORE0 0xd1
+#define RADIO_2057_LPF_GAIN_CORE0                0xd2
+#define RADIO_2057_DACBUF_IDACS_BW_CORE0         0xd3
+#define RADIO_2057_RXTXBIAS_CONFIG_CORE1         0xd4
+#define RADIO_2057_TXGM_TXRF_PUS_CORE1           0xd5
+#define RADIO_2057_TXGM_IDAC_BLEED_CORE1         0xd6
+#define RADIO_2057_TXGM_GAIN_CORE1               0xdb
+#define RADIO_2057_TXGM2G_PKDET_PUS_CORE1        0xdc
+#define RADIO_2057_PAD2G_PTATS_CORE1             0xdd
+#define RADIO_2057_PAD2G_IDACS_CORE1             0xde
+#define RADIO_2057_PAD2G_BOOST_PU_CORE1          0xdf
+#define RADIO_2057_PAD2G_CASCV_GAIN_CORE1        0xe0
+#define RADIO_2057_TXMIX2G_TUNE_BOOST_PU_CORE1   0xe1
+#define RADIO_2057_TXMIX2G_LODC_CORE1            0xe2
+#define RADIO_2057_PAD2G_TUNE_PUS_CORE1          0xe3
+#define RADIO_2057_IPA2G_GAIN_CORE1              0xe4
+#define RADIO_2057_TSSI2G_SPARE1_CORE1           0xe5
+#define RADIO_2057_TSSI2G_SPARE2_CORE1           0xe6
+#define RADIO_2057_IPA2G_TUNEV_CASCV_PTAT_CORE1  0xe7
+#define RADIO_2057_IPA2G_IMAIN_CORE1             0xe8
+#define RADIO_2057_IPA2G_CASCONV_CORE1           0xe9
+#define RADIO_2057_IPA2G_CASCOFFV_CORE1          0xea
+#define RADIO_2057_IPA2G_BIAS_FILTER_CORE1       0xeb
+#define RADIO_2057_TX5G_PKDET_CORE1              0xee
+#define RADIO_2057_PGA_PTAT_TXGM5G_PU_CORE1      0xef
+#define RADIO_2057_PAD5G_PTATS1_CORE1            0xf0
+#define RADIO_2057_PAD5G_CLASS_PTATS2_CORE1      0xf1
+#define RADIO_2057_PGA_BOOSTPTAT_IMAIN_CORE1     0xf2
+#define RADIO_2057_PAD5G_CASCV_IMAIN_CORE1       0xf3
+#define RADIO_2057_TXMIX5G_IBOOST_PAD_IAUX_CORE1 0xf4
+#define RADIO_2057_PGA_BOOST_TUNE_CORE1          0xf5
+#define RADIO_2057_PGA_GAIN_CORE1                0xf6
+#define RADIO_2057_PAD5G_CASCOFFV_GAIN_PUS_CORE1 0xf7
+#define RADIO_2057_TXMIX5G_BOOST_TUNE_CORE1      0xf8
+#define RADIO_2057_PAD5G_TUNE_MISC_PUS_CORE1     0xf9
+#define RADIO_2057_IPA5G_IAUX_CORE1              0xfa
+#define RADIO_2057_IPA5G_GAIN_CORE1              0xfb
+#define RADIO_2057_TSSI5G_SPARE1_CORE1           0xfc
+#define RADIO_2057_TSSI5G_SPARE2_CORE1           0xfd
+#define RADIO_2057_IPA5G_CASCOFFV_PU_CORE1       0xfe
+#define RADIO_2057_IPA5G_PTAT_CORE1              0xff
+#define RADIO_2057_IPA5G_IMAIN_CORE1             0x100
+#define RADIO_2057_IPA5G_CASCONV_CORE1           0x101
+#define RADIO_2057_IPA5G_BIAS_FILTER_CORE1       0x102
+#define RADIO_2057_PAD_BIAS_FILTER_BWS_CORE1     0x105
+#define RADIO_2057_TR2G_CONFIG1_CORE1_NU         0x106
+#define RADIO_2057_TR2G_CONFIG2_CORE1_NU         0x107
+#define RADIO_2057_LNA5G_RFEN_CORE1              0x108
+#define RADIO_2057_TR5G_CONFIG2_CORE1_NU         0x109
+#define RADIO_2057_RXRFBIAS_IBOOST_PU_CORE1      0x10a
+#define RADIO_2057_RXRF_IABAND_RXGM_IMAIN_PTAT_CORE1 0x10b
+#define RADIO_2057_RXGM_CMFBITAIL_AUXPTAT_CORE1  0x10c
+#define RADIO_2057_RXMIX_ICORE_RXGM_IAUX_CORE1   0x10d
+#define RADIO_2057_RXMIX_CMFBITAIL_PU_CORE1      0x10e
+#define RADIO_2057_LNA2_IMAIN_PTAT_PU_CORE1      0x10f
+#define RADIO_2057_LNA2_IAUX_PTAT_CORE1          0x110
+#define RADIO_2057_LNA1_IMAIN_PTAT_PU_CORE1      0x111
+#define RADIO_2057_LNA15G_INPUT_MATCH_TUNE_CORE1 0x112
+#define RADIO_2057_RXRFBIAS_BANDSEL_CORE1        0x113
+#define RADIO_2057_TIA_CONFIG_CORE1              0x114
+#define RADIO_2057_TIA_IQGAIN_CORE1              0x115
+#define RADIO_2057_TIA_IBIAS2_CORE1              0x116
+#define RADIO_2057_TIA_IBIAS1_CORE1              0x117
+#define RADIO_2057_TIA_SPARE_Q_CORE1             0x118
+#define RADIO_2057_TIA_SPARE_I_CORE1             0x119
+#define RADIO_2057_RXMIX2G_PUS_CORE1             0x11a
+#define RADIO_2057_RXMIX2G_VCMREFS_CORE1         0x11b
+#define RADIO_2057_RXMIX2G_LODC_QI_CORE1         0x11c
+#define RADIO_2057_W12G_BW_LNA2G_PUS_CORE1       0x11d
+#define RADIO_2057_LNA2G_GAIN_CORE1              0x11e
+#define RADIO_2057_LNA2G_TUNE_CORE1              0x11f
+#define RADIO_2057_RXMIX5G_PUS_CORE1             0x120
+#define RADIO_2057_RXMIX5G_VCMREFS_CORE1         0x121
+#define RADIO_2057_RXMIX5G_LODC_QI_CORE1         0x122
+#define RADIO_2057_W15G_BW_LNA5G_PUS_CORE1       0x123
+#define RADIO_2057_LNA5G_GAIN_CORE1              0x124
+#define RADIO_2057_LNA5G_TUNE_CORE1              0x125
+#define RADIO_2057_LPFSEL_TXRX_RXBB_PUS_CORE1    0x126
+#define RADIO_2057_RXBB_BIAS_MASTER_CORE1        0x127
+#define RADIO_2057_RXBB_VGABUF_IDACS_CORE1       0x128
+#define RADIO_2057_LPF_VCMREF_TXBUF_VCMREF_CORE1 0x129
+#define RADIO_2057_TXBUF_VINCM_CORE1             0x12a
+#define RADIO_2057_TXBUF_IDACS_CORE1             0x12b
+#define RADIO_2057_LPF_RESP_RXBUF_BW_CORE1       0x12c
+#define RADIO_2057_RXBB_CC_CORE1                 0x12d
+#define RADIO_2057_RXBB_SPARE3_CORE1             0x12e
+#define RADIO_2057_RXBB_RCCAL_HPC_CORE1          0x12f
+#define RADIO_2057_LPF_IDACS_CORE1               0x130
+#define RADIO_2057_LPFBYP_DCLOOP_BYP_IDAC_CORE1  0x131
+#define RADIO_2057_TXBUF_GAIN_CORE1              0x132
+#define RADIO_2057_AFELOOPBACK_AACI_RESP_CORE1   0x133
+#define RADIO_2057_RXBUF_DEGEN_CORE1             0x134
+#define RADIO_2057_RXBB_SPARE2_CORE1             0x135
+#define RADIO_2057_RXBB_SPARE1_CORE1             0x136
+#define RADIO_2057_RSSI_MASTER_CORE1             0x137
+#define RADIO_2057_W2_MASTER_CORE1               0x138
+#define RADIO_2057_NB_MASTER_CORE1               0x139
+#define RADIO_2057_W2_IDACS0_Q_CORE1             0x13a
+#define RADIO_2057_W2_IDACS1_Q_CORE1             0x13b
+#define RADIO_2057_W2_IDACS0_I_CORE1             0x13c
+#define RADIO_2057_W2_IDACS1_I_CORE1             0x13d
+#define RADIO_2057_RSSI_GPAIOSEL_W1_IDACS_CORE1  0x13e
+#define RADIO_2057_NB_IDACS_Q_CORE1              0x13f
+#define RADIO_2057_NB_IDACS_I_CORE1              0x140
+#define RADIO_2057_BACKUP4_CORE1                 0x146
+#define RADIO_2057_BACKUP3_CORE1                 0x147
+#define RADIO_2057_BACKUP2_CORE1                 0x148
+#define RADIO_2057_BACKUP1_CORE1                 0x149
+#define RADIO_2057_SPARE16_CORE1                 0x14a
+#define RADIO_2057_SPARE15_CORE1                 0x14b
+#define RADIO_2057_SPARE14_CORE1                 0x14c
+#define RADIO_2057_SPARE13_CORE1                 0x14d
+#define RADIO_2057_SPARE12_CORE1                 0x14e
+#define RADIO_2057_SPARE11_CORE1                 0x14f
+#define RADIO_2057_TX2G_BIAS_RESETS_CORE1        0x150
+#define RADIO_2057_TX5G_BIAS_RESETS_CORE1        0x151
+#define RADIO_2057_SPARE8_CORE1                  0x152
+#define RADIO_2057_SPARE7_CORE1                  0x153
+#define RADIO_2057_BUFS_MISC_LPFBW_CORE1         0x154
+#define RADIO_2057_TXLPF_RCCAL_CORE1             0x155
+#define RADIO_2057_RXBB_GPAIOSEL_RXLPF_RCCAL_CORE1 0x156
+#define RADIO_2057_LPF_GAIN_CORE1                0x157
+#define RADIO_2057_DACBUF_IDACS_BW_CORE1         0x158
+#define RADIO_2057_DACBUF_VINCM_CORE1            0x159
+#define RADIO_2057_RCCAL_START_R1_Q1_P1          0x15a
+#define RADIO_2057_RCCAL_X1                      0x15b
+#define RADIO_2057_RCCAL_TRC0                    0x15c
+#define RADIO_2057_RCCAL_TRC1                    0x15d
+#define RADIO_2057_RCCAL_DONE_OSCCAP             0x15e
+#define RADIO_2057_RCCAL_N0_0                    0x15f
+#define RADIO_2057_RCCAL_N0_1                    0x160
+#define RADIO_2057_RCCAL_N1_0                    0x161
+#define RADIO_2057_RCCAL_N1_1                    0x162
+#define RADIO_2057_RCAL_STATUS                   0x163
+#define RADIO_2057_XTALPUOVR_PINCTRL             0x164
+#define RADIO_2057_OVR_REG0                      0x165
+#define RADIO_2057_OVR_REG1                      0x166
+#define RADIO_2057_OVR_REG2                      0x167
+#define RADIO_2057_OVR_REG3                      0x168
+#define RADIO_2057_OVR_REG4                      0x169
+#define RADIO_2057_RCCAL_SCAP_VAL                0x16a
+#define RADIO_2057_RCCAL_BCAP_VAL                0x16b
+#define RADIO_2057_RCCAL_HPC_VAL                 0x16c
+#define RADIO_2057_RCCAL_OVERRIDES               0x16d
+#define RADIO_2057_TX0_IQCAL_GAIN_BW             0x170
+#define RADIO_2057_TX0_LOFT_FINE_I               0x171
+#define RADIO_2057_TX0_LOFT_FINE_Q               0x172
+#define RADIO_2057_TX0_LOFT_COARSE_I             0x173
+#define RADIO_2057_TX0_LOFT_COARSE_Q             0x174
+#define RADIO_2057_TX0_TX_SSI_MASTER             0x175
+#define RADIO_2057_TX0_IQCAL_VCM_HG              0x176
+#define RADIO_2057_TX0_IQCAL_IDAC                0x177
+#define RADIO_2057_TX0_TSSI_VCM                  0x178
+#define RADIO_2057_TX0_TX_SSI_MUX                0x179
+#define RADIO_2057_TX0_TSSIA                     0x17a
+#define RADIO_2057_TX0_TSSIG                     0x17b
+#define RADIO_2057_TX0_TSSI_MISC1                0x17c
+#define RADIO_2057_TX0_TXRXCOUPLE_2G_ATTEN       0x17d
+#define RADIO_2057_TX0_TXRXCOUPLE_2G_PWRUP       0x17e
+#define RADIO_2057_TX0_TXRXCOUPLE_5G_ATTEN       0x17f
+#define RADIO_2057_TX0_TXRXCOUPLE_5G_PWRUP       0x180
+#define RADIO_2057_TX1_IQCAL_GAIN_BW             0x190
+#define RADIO_2057_TX1_LOFT_FINE_I               0x191
+#define RADIO_2057_TX1_LOFT_FINE_Q               0x192
+#define RADIO_2057_TX1_LOFT_COARSE_I             0x193
+#define RADIO_2057_TX1_LOFT_COARSE_Q             0x194
+#define RADIO_2057_TX1_TX_SSI_MASTER             0x195
+#define RADIO_2057_TX1_IQCAL_VCM_HG              0x196
+#define RADIO_2057_TX1_IQCAL_IDAC                0x197
+#define RADIO_2057_TX1_TSSI_VCM                  0x198
+#define RADIO_2057_TX1_TX_SSI_MUX                0x199
+#define RADIO_2057_TX1_TSSIA                     0x19a
+#define RADIO_2057_TX1_TSSIG                     0x19b
+#define RADIO_2057_TX1_TSSI_MISC1                0x19c
+#define RADIO_2057_TX1_TXRXCOUPLE_2G_ATTEN       0x19d
+#define RADIO_2057_TX1_TXRXCOUPLE_2G_PWRUP       0x19e
+#define RADIO_2057_TX1_TXRXCOUPLE_5G_ATTEN       0x19f
+#define RADIO_2057_TX1_TXRXCOUPLE_5G_PWRUP       0x1a0
+#define RADIO_2057_AFE_VCM_CAL_MASTER_CORE0      0x1a1
+#define RADIO_2057_AFE_SET_VCM_I_CORE0           0x1a2
+#define RADIO_2057_AFE_SET_VCM_Q_CORE0           0x1a3
+#define RADIO_2057_AFE_STATUS_VCM_IQADC_CORE0    0x1a4
+#define RADIO_2057_AFE_STATUS_VCM_I_CORE0        0x1a5
+#define RADIO_2057_AFE_STATUS_VCM_Q_CORE0        0x1a6
+#define RADIO_2057_AFE_VCM_CAL_MASTER_CORE1      0x1a7
+#define RADIO_2057_AFE_SET_VCM_I_CORE1           0x1a8
+#define RADIO_2057_AFE_SET_VCM_Q_CORE1           0x1a9
+#define RADIO_2057_AFE_STATUS_VCM_IQADC_CORE1    0x1aa
+#define RADIO_2057_AFE_STATUS_VCM_I_CORE1        0x1ab
+#define RADIO_2057_AFE_STATUS_VCM_Q_CORE1        0x1ac
+
+#define RADIO_2057v7_DACBUF_VINCM_CORE0          0x1ad
+#define RADIO_2057v7_RCCAL_MASTER                0x1ae
+#define RADIO_2057v7_TR2G_CONFIG3_CORE0_NU       0x1af
+#define RADIO_2057v7_TR2G_CONFIG3_CORE1_NU       0x1b0
+#define RADIO_2057v7_LOGEN_PUS1                  0x1b1
+#define RADIO_2057v7_OVR_REG5                    0x1b2
+#define RADIO_2057v7_OVR_REG6                    0x1b3
+#define RADIO_2057v7_OVR_REG7                    0x1b4
+#define RADIO_2057v7_OVR_REG8                    0x1b5
+#define RADIO_2057v7_OVR_REG9                    0x1b6
+#define RADIO_2057v7_OVR_REG10                   0x1b7
+#define RADIO_2057v7_OVR_REG11                   0x1b8
+#define RADIO_2057v7_OVR_REG12                   0x1b9
+#define RADIO_2057v7_OVR_REG13                   0x1ba
+#define RADIO_2057v7_OVR_REG14                   0x1bb
+#define RADIO_2057v7_OVR_REG15                   0x1bc
+#define RADIO_2057v7_OVR_REG16                   0x1bd
+#define RADIO_2057v7_OVR_REG1                    0x1be
+#define RADIO_2057v7_OVR_REG18                   0x1bf
+#define RADIO_2057v7_OVR_REG19                   0x1c0
+#define RADIO_2057v7_OVR_REG20                   0x1c1
+#define RADIO_2057v7_OVR_REG21                   0x1c2
+#define RADIO_2057v7_OVR_REG2                    0x1c3
+#define RADIO_2057v7_OVR_REG23                   0x1c4
+#define RADIO_2057v7_OVR_REG24                   0x1c5
+#define RADIO_2057v7_OVR_REG25                   0x1c6
+#define RADIO_2057v7_OVR_REG26                   0x1c7
+#define RADIO_2057v7_OVR_REG27                   0x1c8
+#define RADIO_2057v7_OVR_REG28                   0x1c9
+#define RADIO_2057v7_IQTEST_SEL_PU2              0x1ca
+
+#define RADIO_2057_VCM_MASK			 0x7
+
+#endif				/* _BCM20XX_H */
diff --git a/drivers/staging/brcm80211/phy/wlc_phyreg_n.h b/drivers/staging/brcm80211/phy/wlc_phyreg_n.h
new file mode 100644
index 0000000..211bc3a
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phyreg_n.h
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define NPHY_TBL_ID_GAIN1		0
+#define NPHY_TBL_ID_GAIN2		1
+#define NPHY_TBL_ID_GAINBITS1		2
+#define NPHY_TBL_ID_GAINBITS2		3
+#define NPHY_TBL_ID_GAINLIMIT		4
+#define NPHY_TBL_ID_WRSSIGainLimit	5
+#define NPHY_TBL_ID_RFSEQ		7
+#define NPHY_TBL_ID_AFECTRL		8
+#define NPHY_TBL_ID_ANTSWCTRLLUT	9
+#define NPHY_TBL_ID_IQLOCAL		15
+#define NPHY_TBL_ID_NOISEVAR		16
+#define NPHY_TBL_ID_SAMPLEPLAY		17
+#define NPHY_TBL_ID_CORE1TXPWRCTL	26
+#define NPHY_TBL_ID_CORE2TXPWRCTL	27
+#define NPHY_TBL_ID_CMPMETRICDATAWEIGHTTBL	30
+
+#define NPHY_TBL_ID_EPSILONTBL0   31
+#define NPHY_TBL_ID_SCALARTBL0    32
+#define NPHY_TBL_ID_EPSILONTBL1   33
+#define NPHY_TBL_ID_SCALARTBL1    34
+
+#define	NPHY_TO_BPHY_OFF	0xc00
+
+#define NPHY_BandControl_currentBand			0x0001
+#define RFCC_CHIP0_PU			0x0400
+#define RFCC_POR_FORCE			0x0040
+#define RFCC_OE_POR_FORCE		0x0080
+#define NPHY_RfctrlIntc_override_OFF			0
+#define NPHY_RfctrlIntc_override_TRSW			1
+#define NPHY_RfctrlIntc_override_PA				2
+#define NPHY_RfctrlIntc_override_EXT_LNA_PU		3
+#define NPHY_RfctrlIntc_override_EXT_LNA_GAIN	4
+#define RIFS_ENABLE			0x80
+#define BPHY_BAND_SEL_UP20		0x10
+#define NPHY_MLenable			0x02
+
+#define NPHY_RfseqMode_CoreActv_override 0x0001
+#define NPHY_RfseqMode_Trigger_override	0x0002
+#define NPHY_RfseqCoreActv_TxRxChain0	(0x11)
+#define NPHY_RfseqCoreActv_TxRxChain1	(0x22)
+
+#define NPHY_RfseqTrigger_rx2tx		0x0001
+#define NPHY_RfseqTrigger_tx2rx		0x0002
+#define NPHY_RfseqTrigger_updategainh	0x0004
+#define NPHY_RfseqTrigger_updategainl	0x0008
+#define NPHY_RfseqTrigger_updategainu	0x0010
+#define NPHY_RfseqTrigger_reset2rx	0x0020
+#define NPHY_RfseqStatus_rx2tx		0x0001
+#define NPHY_RfseqStatus_tx2rx		0x0002
+#define NPHY_RfseqStatus_updategainh	0x0004
+#define NPHY_RfseqStatus_updategainl	0x0008
+#define NPHY_RfseqStatus_updategainu	0x0010
+#define NPHY_RfseqStatus_reset2rx	0x0020
+#define NPHY_ClassifierCtrl_cck_en	0x1
+#define NPHY_ClassifierCtrl_ofdm_en	0x2
+#define NPHY_ClassifierCtrl_waited_en	0x4
+#define NPHY_IQFlip_ADC1		0x0001
+#define NPHY_IQFlip_ADC2		0x0010
+#define NPHY_sampleCmd_STOP		0x0002
+
+#define RX_GF_OR_MM			0x0004
+#define RX_GF_MM_AUTO			0x0100
+
+#define NPHY_iqloCalCmdGctl_IQLO_CAL_EN	0x8000
+
+#define NPHY_IqestCmd_iqstart		0x1
+#define NPHY_IqestCmd_iqMode		0x2
+
+#define NPHY_TxPwrCtrlCmd_pwrIndex_init		0x40
+#define NPHY_TxPwrCtrlCmd_pwrIndex_init_rev7	0x19
+
+#define PRIM_SEL_UP20		0x8000
+
+#define NPHY_RFSEQ_RX2TX		0x0
+#define NPHY_RFSEQ_TX2RX		0x1
+#define NPHY_RFSEQ_RESET2RX		0x2
+#define NPHY_RFSEQ_UPDATEGAINH		0x3
+#define NPHY_RFSEQ_UPDATEGAINL		0x4
+#define NPHY_RFSEQ_UPDATEGAINU		0x5
+
+#define NPHY_RFSEQ_CMD_NOP		0x0
+#define NPHY_RFSEQ_CMD_RXG_FBW		0x1
+#define NPHY_RFSEQ_CMD_TR_SWITCH	0x2
+#define NPHY_RFSEQ_CMD_EXT_PA		0x3
+#define NPHY_RFSEQ_CMD_RXPD_TXPD	0x4
+#define NPHY_RFSEQ_CMD_TX_GAIN		0x5
+#define NPHY_RFSEQ_CMD_RX_GAIN		0x6
+#define NPHY_RFSEQ_CMD_SET_HPF_BW	0x7
+#define NPHY_RFSEQ_CMD_CLR_HIQ_DIS	0x8
+#define NPHY_RFSEQ_CMD_END		0xf
+
+#define NPHY_REV3_RFSEQ_CMD_NOP		0x0
+#define NPHY_REV3_RFSEQ_CMD_RXG_FBW	0x1
+#define NPHY_REV3_RFSEQ_CMD_TR_SWITCH	0x2
+#define NPHY_REV3_RFSEQ_CMD_INT_PA_PU	0x3
+#define NPHY_REV3_RFSEQ_CMD_EXT_PA	0x4
+#define NPHY_REV3_RFSEQ_CMD_RXPD_TXPD	0x5
+#define NPHY_REV3_RFSEQ_CMD_TX_GAIN	0x6
+#define NPHY_REV3_RFSEQ_CMD_RX_GAIN	0x7
+#define NPHY_REV3_RFSEQ_CMD_CLR_HIQ_DIS	0x8
+#define NPHY_REV3_RFSEQ_CMD_SET_HPF_H_HPC	0x9
+#define NPHY_REV3_RFSEQ_CMD_SET_LPF_H_HPC	0xa
+#define NPHY_REV3_RFSEQ_CMD_SET_HPF_M_HPC	0xb
+#define NPHY_REV3_RFSEQ_CMD_SET_LPF_M_HPC	0xc
+#define NPHY_REV3_RFSEQ_CMD_SET_HPF_L_HPC	0xd
+#define NPHY_REV3_RFSEQ_CMD_SET_LPF_L_HPC	0xe
+#define NPHY_REV3_RFSEQ_CMD_CLR_RXRX_BIAS	0xf
+#define NPHY_REV3_RFSEQ_CMD_END		0x1f
+
+#define NPHY_RSSI_SEL_W1 		0x0
+#define NPHY_RSSI_SEL_W2 		0x1
+#define NPHY_RSSI_SEL_NB 		0x2
+#define NPHY_RSSI_SEL_IQ 		0x3
+#define NPHY_RSSI_SEL_TSSI_2G 		0x4
+#define NPHY_RSSI_SEL_TSSI_5G 		0x5
+#define NPHY_RSSI_SEL_TBD 		0x6
+
+#define NPHY_RAIL_I			0x0
+#define NPHY_RAIL_Q			0x1
+
+#define NPHY_FORCESIG_DECODEGATEDCLKS	0x8
+
+#define NPHY_REV7_RfctrlOverride_cmd_rxrf_pu 0x0
+#define NPHY_REV7_RfctrlOverride_cmd_rx_pu   0x1
+#define NPHY_REV7_RfctrlOverride_cmd_tx_pu   0x2
+#define NPHY_REV7_RfctrlOverride_cmd_rxgain  0x3
+#define NPHY_REV7_RfctrlOverride_cmd_txgain  0x4
+
+#define NPHY_REV7_RXGAINCODE_RFMXGAIN_MASK 0x000ff
+#define NPHY_REV7_RXGAINCODE_LPFGAIN_MASK  0x0ff00
+#define NPHY_REV7_RXGAINCODE_DVGAGAIN_MASK 0xf0000
+
+#define NPHY_REV7_TXGAINCODE_TGAIN_MASK     0x7fff
+#define NPHY_REV7_TXGAINCODE_LPFGAIN_MASK   0x8000
+#define NPHY_REV7_TXGAINCODE_BIQ0GAIN_SHIFT 14
+
+#define NPHY_REV7_RFCTRLOVERRIDE_ID0 0x0
+#define NPHY_REV7_RFCTRLOVERRIDE_ID1 0x1
+#define NPHY_REV7_RFCTRLOVERRIDE_ID2 0x2
+
+#define NPHY_IqestIqAccLo(core)  ((core == 0) ? 0x12c : 0x134)
+
+#define NPHY_IqestIqAccHi(core)  ((core == 0) ? 0x12d : 0x135)
+
+#define NPHY_IqestipwrAccLo(core)  ((core == 0) ? 0x12e : 0x136)
+
+#define NPHY_IqestipwrAccHi(core)  ((core == 0) ? 0x12f : 0x137)
+
+#define NPHY_IqestqpwrAccLo(core)  ((core == 0) ? 0x130 : 0x138)
+
+#define NPHY_IqestqpwrAccHi(core)  ((core == 0) ? 0x131 : 0x139)
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
new file mode 100644
index 0000000..adfb97b
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.c
@@ -0,0 +1,3639 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+
+#include <wlc_phy_int.h>
+#include <wlc_phytbl_lcn.h>
+
+CONST uint32 dot11lcn_gain_tbl_rev0[] = {
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000004,
+	0x00000000,
+	0x00000004,
+	0x00000008,
+	0x00000001,
+	0x00000005,
+	0x00000009,
+	0x0000000d,
+	0x0000004d,
+	0x0000008d,
+	0x0000000d,
+	0x0000004d,
+	0x0000008d,
+	0x000000cd,
+	0x0000004f,
+	0x0000008f,
+	0x000000cf,
+	0x000000d3,
+	0x00000113,
+	0x00000513,
+	0x00000913,
+	0x00000953,
+	0x00000d53,
+	0x00001153,
+	0x00001193,
+	0x00005193,
+	0x00009193,
+	0x0000d193,
+	0x00011193,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000004,
+	0x00000000,
+	0x00000004,
+	0x00000008,
+	0x00000001,
+	0x00000005,
+	0x00000009,
+	0x0000000d,
+	0x0000004d,
+	0x0000008d,
+	0x0000000d,
+	0x0000004d,
+	0x0000008d,
+	0x000000cd,
+	0x0000004f,
+	0x0000008f,
+	0x000000cf,
+	0x000000d3,
+	0x00000113,
+	0x00000513,
+	0x00000913,
+	0x00000953,
+	0x00000d53,
+	0x00001153,
+	0x00005153,
+	0x00009153,
+	0x0000d153,
+	0x00011153,
+	0x00015153,
+	0x00019153,
+	0x0001d153,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 dot11lcn_gain_tbl_rev1[] = {
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000008,
+	0x00000004,
+	0x00000008,
+	0x00000001,
+	0x00000005,
+	0x00000009,
+	0x0000000D,
+	0x00000011,
+	0x00000051,
+	0x00000091,
+	0x00000011,
+	0x00000051,
+	0x00000091,
+	0x000000d1,
+	0x00000053,
+	0x00000093,
+	0x000000d3,
+	0x000000d7,
+	0x00000117,
+	0x00000517,
+	0x00000917,
+	0x00000957,
+	0x00000d57,
+	0x00001157,
+	0x00001197,
+	0x00005197,
+	0x00009197,
+	0x0000d197,
+	0x00011197,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000008,
+	0x00000004,
+	0x00000008,
+	0x00000001,
+	0x00000005,
+	0x00000009,
+	0x0000000D,
+	0x00000011,
+	0x00000051,
+	0x00000091,
+	0x00000011,
+	0x00000051,
+	0x00000091,
+	0x000000d1,
+	0x00000053,
+	0x00000093,
+	0x000000d3,
+	0x000000d7,
+	0x00000117,
+	0x00000517,
+	0x00000917,
+	0x00000957,
+	0x00000d57,
+	0x00001157,
+	0x00005157,
+	0x00009157,
+	0x0000d157,
+	0x00011157,
+	0x00015157,
+	0x00019157,
+	0x0001d157,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint16 dot11lcn_aux_gain_idx_tbl_rev0[] = {
+	0x0401,
+	0x0402,
+	0x0403,
+	0x0404,
+	0x0405,
+	0x0406,
+	0x0407,
+	0x0408,
+	0x0409,
+	0x040a,
+	0x058b,
+	0x058c,
+	0x058d,
+	0x058e,
+	0x058f,
+	0x0090,
+	0x0091,
+	0x0092,
+	0x0193,
+	0x0194,
+	0x0195,
+	0x0196,
+	0x0197,
+	0x0198,
+	0x0199,
+	0x019a,
+	0x019b,
+	0x019c,
+	0x019d,
+	0x019e,
+	0x019f,
+	0x01a0,
+	0x01a1,
+	0x01a2,
+	0x01a3,
+	0x01a4,
+	0x01a5,
+	0x0000,
+};
+
+CONST uint32 dot11lcn_gain_idx_tbl_rev0[] = {
+	0x00000000,
+	0x00000000,
+	0x10000000,
+	0x00000000,
+	0x20000000,
+	0x00000000,
+	0x30000000,
+	0x00000000,
+	0x40000000,
+	0x00000000,
+	0x50000000,
+	0x00000000,
+	0x60000000,
+	0x00000000,
+	0x70000000,
+	0x00000000,
+	0x80000000,
+	0x00000000,
+	0x90000000,
+	0x00000008,
+	0xa0000000,
+	0x00000008,
+	0xb0000000,
+	0x00000008,
+	0xc0000000,
+	0x00000008,
+	0xd0000000,
+	0x00000008,
+	0xe0000000,
+	0x00000008,
+	0xf0000000,
+	0x00000008,
+	0x00000000,
+	0x00000009,
+	0x10000000,
+	0x00000009,
+	0x20000000,
+	0x00000019,
+	0x30000000,
+	0x00000019,
+	0x40000000,
+	0x00000019,
+	0x50000000,
+	0x00000019,
+	0x60000000,
+	0x00000019,
+	0x70000000,
+	0x00000019,
+	0x80000000,
+	0x00000019,
+	0x90000000,
+	0x00000019,
+	0xa0000000,
+	0x00000019,
+	0xb0000000,
+	0x00000019,
+	0xc0000000,
+	0x00000019,
+	0xd0000000,
+	0x00000019,
+	0xe0000000,
+	0x00000019,
+	0xf0000000,
+	0x00000019,
+	0x00000000,
+	0x0000001a,
+	0x10000000,
+	0x0000001a,
+	0x20000000,
+	0x0000001a,
+	0x30000000,
+	0x0000001a,
+	0x40000000,
+	0x0000001a,
+	0x50000000,
+	0x00000002,
+	0x60000000,
+	0x00000002,
+	0x70000000,
+	0x00000002,
+	0x80000000,
+	0x00000002,
+	0x90000000,
+	0x00000002,
+	0xa0000000,
+	0x00000002,
+	0xb0000000,
+	0x00000002,
+	0xc0000000,
+	0x0000000a,
+	0xd0000000,
+	0x0000000a,
+	0xe0000000,
+	0x0000000a,
+	0xf0000000,
+	0x0000000a,
+	0x00000000,
+	0x0000000b,
+	0x10000000,
+	0x0000000b,
+	0x20000000,
+	0x0000000b,
+	0x30000000,
+	0x0000000b,
+	0x40000000,
+	0x0000000b,
+	0x50000000,
+	0x0000001b,
+	0x60000000,
+	0x0000001b,
+	0x70000000,
+	0x0000001b,
+	0x80000000,
+	0x0000001b,
+	0x90000000,
+	0x0000001b,
+	0xa0000000,
+	0x0000001b,
+	0xb0000000,
+	0x0000001b,
+	0xc0000000,
+	0x0000001b,
+	0xd0000000,
+	0x0000001b,
+	0xe0000000,
+	0x0000001b,
+	0xf0000000,
+	0x0000001b,
+	0x00000000,
+	0x0000001c,
+	0x10000000,
+	0x0000001c,
+	0x20000000,
+	0x0000001c,
+	0x30000000,
+	0x0000001c,
+	0x40000000,
+	0x0000001c,
+	0x50000000,
+	0x0000001c,
+	0x60000000,
+	0x0000001c,
+	0x70000000,
+	0x0000001c,
+	0x80000000,
+	0x0000001c,
+	0x90000000,
+	0x0000001c,
+};
+
+CONST uint16 dot11lcn_aux_gain_idx_tbl_2G[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0001,
+	0x0080,
+	0x0081,
+	0x0100,
+	0x0101,
+	0x0180,
+	0x0181,
+	0x0182,
+	0x0183,
+	0x0184,
+	0x0185,
+	0x0186,
+	0x0187,
+	0x0188,
+	0x0285,
+	0x0289,
+	0x028a,
+	0x028b,
+	0x028c,
+	0x028d,
+	0x028e,
+	0x028f,
+	0x0290,
+	0x0291,
+	0x0292,
+	0x0293,
+	0x0294,
+	0x0295,
+	0x0296,
+	0x0297,
+	0x0298,
+	0x0299,
+	0x029a,
+	0x0000
+};
+
+CONST uint8 dot11lcn_gain_val_tbl_2G[] = {
+	0xfc,
+	0x02,
+	0x08,
+	0x0e,
+	0x13,
+	0x1b,
+	0xfc,
+	0x02,
+	0x08,
+	0x0e,
+	0x13,
+	0x1b,
+	0xfc,
+	0x00,
+	0x0c,
+	0x03,
+	0xeb,
+	0xfe,
+	0x07,
+	0x0b,
+	0x0f,
+	0xfb,
+	0xfe,
+	0x01,
+	0x05,
+	0x08,
+	0x0b,
+	0x0e,
+	0x11,
+	0x14,
+	0x17,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x15,
+	0x18,
+	0x1b,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00
+};
+
+CONST uint32 dot11lcn_gain_idx_tbl_2G[] = {
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x10000000,
+	0x00000000,
+	0x00000000,
+	0x00000008,
+	0x10000000,
+	0x00000008,
+	0x00000000,
+	0x00000010,
+	0x10000000,
+	0x00000010,
+	0x00000000,
+	0x00000018,
+	0x10000000,
+	0x00000018,
+	0x20000000,
+	0x00000018,
+	0x30000000,
+	0x00000018,
+	0x40000000,
+	0x00000018,
+	0x50000000,
+	0x00000018,
+	0x60000000,
+	0x00000018,
+	0x70000000,
+	0x00000018,
+	0x80000000,
+	0x00000018,
+	0x50000000,
+	0x00000028,
+	0x90000000,
+	0x00000028,
+	0xa0000000,
+	0x00000028,
+	0xb0000000,
+	0x00000028,
+	0xc0000000,
+	0x00000028,
+	0xd0000000,
+	0x00000028,
+	0xe0000000,
+	0x00000028,
+	0xf0000000,
+	0x00000028,
+	0x00000000,
+	0x00000029,
+	0x10000000,
+	0x00000029,
+	0x20000000,
+	0x00000029,
+	0x30000000,
+	0x00000029,
+	0x40000000,
+	0x00000029,
+	0x50000000,
+	0x00000029,
+	0x60000000,
+	0x00000029,
+	0x70000000,
+	0x00000029,
+	0x80000000,
+	0x00000029,
+	0x90000000,
+	0x00000029,
+	0xa0000000,
+	0x00000029,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x10000000,
+	0x00000000,
+	0x00000000,
+	0x00000008,
+	0x10000000,
+	0x00000008,
+	0x00000000,
+	0x00000010,
+	0x10000000,
+	0x00000010,
+	0x00000000,
+	0x00000018,
+	0x10000000,
+	0x00000018,
+	0x20000000,
+	0x00000018,
+	0x30000000,
+	0x00000018,
+	0x40000000,
+	0x00000018,
+	0x50000000,
+	0x00000018,
+	0x60000000,
+	0x00000018,
+	0x70000000,
+	0x00000018,
+	0x80000000,
+	0x00000018,
+	0x50000000,
+	0x00000028,
+	0x90000000,
+	0x00000028,
+	0xa0000000,
+	0x00000028,
+	0xb0000000,
+	0x00000028,
+	0xc0000000,
+	0x00000028,
+	0xd0000000,
+	0x00000028,
+	0xe0000000,
+	0x00000028,
+	0xf0000000,
+	0x00000028,
+	0x00000000,
+	0x00000029,
+	0x10000000,
+	0x00000029,
+	0x20000000,
+	0x00000029,
+	0x30000000,
+	0x00000029,
+	0x40000000,
+	0x00000029,
+	0x50000000,
+	0x00000029,
+	0x60000000,
+	0x00000029,
+	0x70000000,
+	0x00000029,
+	0x80000000,
+	0x00000029,
+	0x90000000,
+	0x00000029,
+	0xa0000000,
+	0x00000029,
+	0xb0000000,
+	0x00000029,
+	0xc0000000,
+	0x00000029,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+
+CONST uint32 dot11lcn_gain_tbl_2G[] = {
+	0x00000000,
+	0x00000004,
+	0x00000008,
+	0x00000001,
+	0x00000005,
+	0x00000009,
+	0x0000000d,
+	0x0000004d,
+	0x0000008d,
+	0x00000049,
+	0x00000089,
+	0x000000c9,
+	0x0000004b,
+	0x0000008b,
+	0x000000cb,
+	0x000000cf,
+	0x0000010f,
+	0x0000050f,
+	0x0000090f,
+	0x0000094f,
+	0x00000d4f,
+	0x0000114f,
+	0x0000118f,
+	0x0000518f,
+	0x0000918f,
+	0x0000d18f,
+	0x0001118f,
+	0x0001518f,
+	0x0001918f,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+
+CONST uint32 dot11lcn_gain_tbl_extlna_2G[] = {
+	0x00000000,
+	0x00000004,
+	0x00000008,
+	0x00000001,
+	0x00000005,
+	0x00000009,
+	0x0000000d,
+	0x00000003,
+	0x00000007,
+	0x0000000b,
+	0x0000000f,
+	0x0000004f,
+	0x0000008f,
+	0x000000cf,
+	0x0000010f,
+	0x0000014f,
+	0x0000018f,
+	0x0000058f,
+	0x0000098f,
+	0x00000d8f,
+	0x00008000,
+	0x00008004,
+	0x00008008,
+	0x00008001,
+	0x00008005,
+	0x00008009,
+	0x0000800d,
+	0x00008003,
+	0x00008007,
+	0x0000800b,
+	0x0000800f,
+	0x0000804f,
+	0x0000808f,
+	0x000080cf,
+	0x0000810f,
+	0x0000814f,
+	0x0000818f,
+	0x0000858f,
+	0x0000898f,
+	0x00008d8f,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+
+CONST uint16 dot11lcn_aux_gain_idx_tbl_extlna_2G[] = {
+	0x0400,
+	0x0400,
+	0x0400,
+	0x0400,
+	0x0400,
+	0x0400,
+	0x0400,
+	0x0400,
+	0x0400,
+	0x0401,
+	0x0402,
+	0x0403,
+	0x0404,
+	0x0483,
+	0x0484,
+	0x0485,
+	0x0486,
+	0x0583,
+	0x0584,
+	0x0585,
+	0x0587,
+	0x0588,
+	0x0589,
+	0x058a,
+	0x0687,
+	0x0688,
+	0x0689,
+	0x068a,
+	0x068b,
+	0x068c,
+	0x068d,
+	0x068e,
+	0x068f,
+	0x0690,
+	0x0691,
+	0x0692,
+	0x0693,
+	0x0000
+};
+
+CONST uint8 dot11lcn_gain_val_tbl_extlna_2G[] = {
+	0xfc,
+	0x02,
+	0x08,
+	0x0e,
+	0x13,
+	0x1b,
+	0xfc,
+	0x02,
+	0x08,
+	0x0e,
+	0x13,
+	0x1b,
+	0xfc,
+	0x00,
+	0x0f,
+	0x03,
+	0xeb,
+	0xfe,
+	0x07,
+	0x0b,
+	0x0f,
+	0xfb,
+	0xfe,
+	0x01,
+	0x05,
+	0x08,
+	0x0b,
+	0x0e,
+	0x11,
+	0x14,
+	0x17,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x15,
+	0x18,
+	0x1b,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00
+};
+
+CONST uint32 dot11lcn_gain_idx_tbl_extlna_2G[] = {
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x00000000,
+	0x00000040,
+	0x10000000,
+	0x00000040,
+	0x20000000,
+	0x00000040,
+	0x30000000,
+	0x00000040,
+	0x40000000,
+	0x00000040,
+	0x30000000,
+	0x00000048,
+	0x40000000,
+	0x00000048,
+	0x50000000,
+	0x00000048,
+	0x60000000,
+	0x00000048,
+	0x30000000,
+	0x00000058,
+	0x40000000,
+	0x00000058,
+	0x50000000,
+	0x00000058,
+	0x70000000,
+	0x00000058,
+	0x80000000,
+	0x00000058,
+	0x90000000,
+	0x00000058,
+	0xa0000000,
+	0x00000058,
+	0x70000000,
+	0x00000068,
+	0x80000000,
+	0x00000068,
+	0x90000000,
+	0x00000068,
+	0xa0000000,
+	0x00000068,
+	0xb0000000,
+	0x00000068,
+	0xc0000000,
+	0x00000068,
+	0xd0000000,
+	0x00000068,
+	0xe0000000,
+	0x00000068,
+	0xf0000000,
+	0x00000068,
+	0x00000000,
+	0x00000069,
+	0x10000000,
+	0x00000069,
+	0x20000000,
+	0x00000069,
+	0x30000000,
+	0x00000069,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x40000000,
+	0x00000041,
+	0x50000000,
+	0x00000041,
+	0x60000000,
+	0x00000041,
+	0x70000000,
+	0x00000041,
+	0x80000000,
+	0x00000041,
+	0x70000000,
+	0x00000049,
+	0x80000000,
+	0x00000049,
+	0x90000000,
+	0x00000049,
+	0xa0000000,
+	0x00000049,
+	0x70000000,
+	0x00000059,
+	0x80000000,
+	0x00000059,
+	0x90000000,
+	0x00000059,
+	0xb0000000,
+	0x00000059,
+	0xc0000000,
+	0x00000059,
+	0xd0000000,
+	0x00000059,
+	0xe0000000,
+	0x00000059,
+	0xb0000000,
+	0x00000069,
+	0xc0000000,
+	0x00000069,
+	0xd0000000,
+	0x00000069,
+	0xe0000000,
+	0x00000069,
+	0xf0000000,
+	0x00000069,
+	0x00000000,
+	0x0000006a,
+	0x10000000,
+	0x0000006a,
+	0x20000000,
+	0x0000006a,
+	0x30000000,
+	0x0000006a,
+	0x40000000,
+	0x0000006a,
+	0x50000000,
+	0x0000006a,
+	0x60000000,
+	0x0000006a,
+	0x70000000,
+	0x0000006a,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+
+CONST uint32 dot11lcn_aux_gain_idx_tbl_5G[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0001,
+	0x0002,
+	0x0003,
+	0x0004,
+	0x0083,
+	0x0084,
+	0x0085,
+	0x0086,
+	0x0087,
+	0x0186,
+	0x0187,
+	0x0188,
+	0x0189,
+	0x018a,
+	0x018b,
+	0x018c,
+	0x018d,
+	0x018e,
+	0x018f,
+	0x0190,
+	0x0191,
+	0x0192,
+	0x0193,
+	0x0194,
+	0x0195,
+	0x0196,
+	0x0197,
+	0x0198,
+	0x0199,
+	0x019a,
+	0x019b,
+	0x019c,
+	0x019d,
+	0x0000
+};
+
+CONST uint32 dot11lcn_gain_val_tbl_5G[] = {
+	0xf7,
+	0xfd,
+	0x00,
+	0x04,
+	0x04,
+	0x04,
+	0xf7,
+	0xfd,
+	0x00,
+	0x04,
+	0x04,
+	0x04,
+	0xf6,
+	0x00,
+	0x0c,
+	0x03,
+	0xeb,
+	0xfe,
+	0x06,
+	0x0a,
+	0x10,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x15,
+	0x18,
+	0x1b,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x15,
+	0x18,
+	0x1b,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00
+};
+
+CONST uint32 dot11lcn_gain_idx_tbl_5G[] = {
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x10000000,
+	0x00000000,
+	0x20000000,
+	0x00000000,
+	0x30000000,
+	0x00000000,
+	0x40000000,
+	0x00000000,
+	0x30000000,
+	0x00000008,
+	0x40000000,
+	0x00000008,
+	0x50000000,
+	0x00000008,
+	0x60000000,
+	0x00000008,
+	0x70000000,
+	0x00000008,
+	0x60000000,
+	0x00000018,
+	0x70000000,
+	0x00000018,
+	0x80000000,
+	0x00000018,
+	0x90000000,
+	0x00000018,
+	0xa0000000,
+	0x00000018,
+	0xb0000000,
+	0x00000018,
+	0xc0000000,
+	0x00000018,
+	0xd0000000,
+	0x00000018,
+	0xe0000000,
+	0x00000018,
+	0xf0000000,
+	0x00000018,
+	0x00000000,
+	0x00000019,
+	0x10000000,
+	0x00000019,
+	0x20000000,
+	0x00000019,
+	0x30000000,
+	0x00000019,
+	0x40000000,
+	0x00000019,
+	0x50000000,
+	0x00000019,
+	0x60000000,
+	0x00000019,
+	0x70000000,
+	0x00000019,
+	0x80000000,
+	0x00000019,
+	0x90000000,
+	0x00000019,
+	0xa0000000,
+	0x00000019,
+	0xb0000000,
+	0x00000019,
+	0xc0000000,
+	0x00000019,
+	0xd0000000,
+	0x00000019,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+
+CONST uint32 dot11lcn_gain_tbl_5G[] = {
+	0x00000000,
+	0x00000040,
+	0x00000080,
+	0x00000001,
+	0x00000005,
+	0x00000009,
+	0x0000000d,
+	0x00000011,
+	0x00000015,
+	0x00000055,
+	0x00000095,
+	0x00000017,
+	0x0000001b,
+	0x0000005b,
+	0x0000009b,
+	0x000000db,
+	0x0000011b,
+	0x0000015b,
+	0x0000019b,
+	0x0000059b,
+	0x0000099b,
+	0x00000d9b,
+	0x0000119b,
+	0x0000519b,
+	0x0000919b,
+	0x0000d19b,
+	0x0001119b,
+	0x0001519b,
+	0x0001919b,
+	0x0001d19b,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000
+};
+
+CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[] = {
+	{&dot11lcn_gain_tbl_rev0,
+	 sizeof(dot11lcn_gain_tbl_rev0) / sizeof(dot11lcn_gain_tbl_rev0[0]), 18,
+	 0, 32}
+	,
+	{&dot11lcn_aux_gain_idx_tbl_rev0,
+	 sizeof(dot11lcn_aux_gain_idx_tbl_rev0) /
+	 sizeof(dot11lcn_aux_gain_idx_tbl_rev0[0]), 14, 0, 16}
+	,
+	{&dot11lcn_gain_idx_tbl_rev0,
+	 sizeof(dot11lcn_gain_idx_tbl_rev0) /
+	 sizeof(dot11lcn_gain_idx_tbl_rev0[0]), 13, 0, 32}
+	,
+};
+
+CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev1[] = {
+	{&dot11lcn_gain_tbl_rev1,
+	 sizeof(dot11lcn_gain_tbl_rev1) / sizeof(dot11lcn_gain_tbl_rev1[0]), 18,
+	 0, 32}
+	,
+	{&dot11lcn_aux_gain_idx_tbl_rev0,
+	 sizeof(dot11lcn_aux_gain_idx_tbl_rev0) /
+	 sizeof(dot11lcn_aux_gain_idx_tbl_rev0[0]), 14, 0, 16}
+	,
+	{&dot11lcn_gain_idx_tbl_rev0,
+	 sizeof(dot11lcn_gain_idx_tbl_rev0) /
+	 sizeof(dot11lcn_gain_idx_tbl_rev0[0]), 13, 0, 32}
+	,
+};
+
+CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[] = {
+	{&dot11lcn_gain_tbl_2G,
+	 sizeof(dot11lcn_gain_tbl_2G) / sizeof(dot11lcn_gain_tbl_2G[0]), 18, 0,
+	 32}
+	,
+	{&dot11lcn_aux_gain_idx_tbl_2G,
+	 sizeof(dot11lcn_aux_gain_idx_tbl_2G) /
+	 sizeof(dot11lcn_aux_gain_idx_tbl_2G[0]), 14, 0, 16}
+	,
+	{&dot11lcn_gain_idx_tbl_2G,
+	 sizeof(dot11lcn_gain_idx_tbl_2G) / sizeof(dot11lcn_gain_idx_tbl_2G[0]),
+	 13, 0, 32}
+	,
+	{&dot11lcn_gain_val_tbl_2G,
+	 sizeof(dot11lcn_gain_val_tbl_2G) / sizeof(dot11lcn_gain_val_tbl_2G[0]),
+	 17, 0, 8}
+};
+
+CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[] = {
+	{&dot11lcn_gain_tbl_5G,
+	 sizeof(dot11lcn_gain_tbl_5G) / sizeof(dot11lcn_gain_tbl_5G[0]), 18, 0,
+	 32}
+	,
+	{&dot11lcn_aux_gain_idx_tbl_5G,
+	 sizeof(dot11lcn_aux_gain_idx_tbl_5G) /
+	 sizeof(dot11lcn_aux_gain_idx_tbl_5G[0]), 14, 0, 16}
+	,
+	{&dot11lcn_gain_idx_tbl_5G,
+	 sizeof(dot11lcn_gain_idx_tbl_5G) / sizeof(dot11lcn_gain_idx_tbl_5G[0]),
+	 13, 0, 32}
+	,
+	{&dot11lcn_gain_val_tbl_5G,
+	 sizeof(dot11lcn_gain_val_tbl_5G) / sizeof(dot11lcn_gain_val_tbl_5G[0]),
+	 17, 0, 8}
+};
+
+CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[] = {
+	{&dot11lcn_gain_tbl_extlna_2G,
+	 sizeof(dot11lcn_gain_tbl_extlna_2G) /
+	 sizeof(dot11lcn_gain_tbl_extlna_2G[0]), 18, 0, 32}
+	,
+	{&dot11lcn_aux_gain_idx_tbl_extlna_2G,
+	 sizeof(dot11lcn_aux_gain_idx_tbl_extlna_2G) /
+	 sizeof(dot11lcn_aux_gain_idx_tbl_extlna_2G[0]), 14, 0, 16}
+	,
+	{&dot11lcn_gain_idx_tbl_extlna_2G,
+	 sizeof(dot11lcn_gain_idx_tbl_extlna_2G) /
+	 sizeof(dot11lcn_gain_idx_tbl_extlna_2G[0]), 13, 0, 32}
+	,
+	{&dot11lcn_gain_val_tbl_extlna_2G,
+	 sizeof(dot11lcn_gain_val_tbl_extlna_2G) /
+	 sizeof(dot11lcn_gain_val_tbl_extlna_2G[0]), 17, 0, 8}
+};
+
+CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_5G_rev2[] = {
+	{&dot11lcn_gain_tbl_5G,
+	 sizeof(dot11lcn_gain_tbl_5G) / sizeof(dot11lcn_gain_tbl_5G[0]), 18, 0,
+	 32}
+	,
+	{&dot11lcn_aux_gain_idx_tbl_5G,
+	 sizeof(dot11lcn_aux_gain_idx_tbl_5G) /
+	 sizeof(dot11lcn_aux_gain_idx_tbl_5G[0]), 14, 0, 16}
+	,
+	{&dot11lcn_gain_idx_tbl_5G,
+	 sizeof(dot11lcn_gain_idx_tbl_5G) / sizeof(dot11lcn_gain_idx_tbl_5G[0]),
+	 13, 0, 32}
+	,
+	{&dot11lcn_gain_val_tbl_5G,
+	 sizeof(dot11lcn_gain_val_tbl_5G) / sizeof(dot11lcn_gain_val_tbl_5G[0]),
+	 17, 0, 8}
+};
+
+CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev0 =
+    sizeof(dot11lcnphytbl_rx_gain_info_rev0) /
+    sizeof(dot11lcnphytbl_rx_gain_info_rev0[0]);
+
+CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev1 =
+    sizeof(dot11lcnphytbl_rx_gain_info_rev1) /
+    sizeof(dot11lcnphytbl_rx_gain_info_rev1[0]);
+
+CONST uint32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz =
+    sizeof(dot11lcnphytbl_rx_gain_info_2G_rev2) /
+    sizeof(dot11lcnphytbl_rx_gain_info_2G_rev2[0]);
+
+CONST uint32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz =
+    sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2) /
+    sizeof(dot11lcnphytbl_rx_gain_info_5G_rev2[0]);
+
+CONST uint16 dot11lcn_min_sig_sq_tbl_rev0[] = {
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+	0x014d,
+};
+
+CONST uint16 dot11lcn_noise_scale_tbl_rev0[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+CONST uint32 dot11lcn_fltr_ctrl_tbl_rev0[] = {
+	0x000141f8,
+	0x000021f8,
+	0x000021fb,
+	0x000041fb,
+	0x0001fe4b,
+	0x0000217b,
+	0x00002133,
+	0x000040eb,
+	0x0001fea3,
+	0x0000024b,
+};
+
+CONST uint32 dot11lcn_ps_ctrl_tbl_rev0[] = {
+	0x00100001,
+	0x00200010,
+	0x00300001,
+	0x00400010,
+	0x00500022,
+	0x00600122,
+	0x00700222,
+	0x00800322,
+	0x00900422,
+	0x00a00522,
+	0x00b00622,
+	0x00c00722,
+	0x00d00822,
+	0x00f00922,
+	0x00100a22,
+	0x00200b22,
+	0x00300c22,
+	0x00400d22,
+	0x00500e22,
+	0x00600f22,
+};
+
+CONST uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[] = {
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x0007,
+	0x0005,
+	0x0006,
+	0x0004,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+	0x000b,
+	0x000b,
+	0x000a,
+	0x000a,
+
+};
+
+CONST uint16 dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[] = {
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0005,
+	0x0002,
+	0x0000,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+	0x0007,
+	0x0007,
+	0x0002,
+	0x0002,
+};
+
+CONST uint16 dot11lcn_sw_ctrl_tbl_4313_epa_rev0[] = {
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+	0x0002,
+	0x0008,
+	0x0004,
+	0x0001,
+};
+
+CONST uint16 dot11lcn_sw_ctrl_tbl_4313_rev0[] = {
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+	0x000a,
+	0x0009,
+	0x0006,
+	0x0005,
+};
+
+CONST uint16 dot11lcn_sw_ctrl_tbl_rev0[] = {
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+	0x0004,
+	0x0004,
+	0x0002,
+	0x0002,
+};
+
+CONST uint8 dot11lcn_nf_table_rev0[] = {
+	0x5f,
+	0x36,
+	0x29,
+	0x1f,
+	0x5f,
+	0x36,
+	0x29,
+	0x1f,
+	0x5f,
+	0x36,
+	0x29,
+	0x1f,
+	0x5f,
+	0x36,
+	0x29,
+	0x1f,
+};
+
+CONST uint8 dot11lcn_gain_val_tbl_rev0[] = {
+	0x09,
+	0x0f,
+	0x14,
+	0x18,
+	0xfe,
+	0x07,
+	0x0b,
+	0x0f,
+	0xfb,
+	0xfe,
+	0x01,
+	0x05,
+	0x08,
+	0x0b,
+	0x0e,
+	0x11,
+	0x14,
+	0x17,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0x06,
+	0x09,
+	0x0c,
+	0x0f,
+	0x12,
+	0x15,
+	0x18,
+	0x1b,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x03,
+	0xeb,
+	0x00,
+	0x00,
+};
+
+CONST uint8 dot11lcn_spur_tbl_rev0[] = {
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x02,
+	0x03,
+	0x01,
+	0x03,
+	0x02,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x02,
+	0x03,
+	0x01,
+	0x03,
+	0x02,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+	0x01,
+};
+
+CONST uint16 dot11lcn_unsup_mcs_tbl_rev0[] = {
+	0x001a,
+	0x0034,
+	0x004e,
+	0x0068,
+	0x009c,
+	0x00d0,
+	0x00ea,
+	0x0104,
+	0x0034,
+	0x0068,
+	0x009c,
+	0x00d0,
+	0x0138,
+	0x01a0,
+	0x01d4,
+	0x0208,
+	0x004e,
+	0x009c,
+	0x00ea,
+	0x0138,
+	0x01d4,
+	0x0270,
+	0x02be,
+	0x030c,
+	0x0068,
+	0x00d0,
+	0x0138,
+	0x01a0,
+	0x0270,
+	0x0340,
+	0x03a8,
+	0x0410,
+	0x0018,
+	0x009c,
+	0x00d0,
+	0x0104,
+	0x00ea,
+	0x0138,
+	0x0186,
+	0x00d0,
+	0x0104,
+	0x0104,
+	0x0138,
+	0x016c,
+	0x016c,
+	0x01a0,
+	0x0138,
+	0x0186,
+	0x0186,
+	0x01d4,
+	0x0222,
+	0x0222,
+	0x0270,
+	0x0104,
+	0x0138,
+	0x016c,
+	0x0138,
+	0x016c,
+	0x01a0,
+	0x01d4,
+	0x01a0,
+	0x01d4,
+	0x0208,
+	0x0208,
+	0x023c,
+	0x0186,
+	0x01d4,
+	0x0222,
+	0x01d4,
+	0x0222,
+	0x0270,
+	0x02be,
+	0x0270,
+	0x02be,
+	0x030c,
+	0x030c,
+	0x035a,
+	0x0036,
+	0x006c,
+	0x00a2,
+	0x00d8,
+	0x0144,
+	0x01b0,
+	0x01e6,
+	0x021c,
+	0x006c,
+	0x00d8,
+	0x0144,
+	0x01b0,
+	0x0288,
+	0x0360,
+	0x03cc,
+	0x0438,
+	0x00a2,
+	0x0144,
+	0x01e6,
+	0x0288,
+	0x03cc,
+	0x0510,
+	0x05b2,
+	0x0654,
+	0x00d8,
+	0x01b0,
+	0x0288,
+	0x0360,
+	0x0510,
+	0x06c0,
+	0x0798,
+	0x0870,
+	0x0018,
+	0x0144,
+	0x01b0,
+	0x021c,
+	0x01e6,
+	0x0288,
+	0x032a,
+	0x01b0,
+	0x021c,
+	0x021c,
+	0x0288,
+	0x02f4,
+	0x02f4,
+	0x0360,
+	0x0288,
+	0x032a,
+	0x032a,
+	0x03cc,
+	0x046e,
+	0x046e,
+	0x0510,
+	0x021c,
+	0x0288,
+	0x02f4,
+	0x0288,
+	0x02f4,
+	0x0360,
+	0x03cc,
+	0x0360,
+	0x03cc,
+	0x0438,
+	0x0438,
+	0x04a4,
+	0x032a,
+	0x03cc,
+	0x046e,
+	0x03cc,
+	0x046e,
+	0x0510,
+	0x05b2,
+	0x0510,
+	0x05b2,
+	0x0654,
+	0x0654,
+	0x06f6,
+};
+
+CONST uint16 dot11lcn_iq_local_tbl_rev0[] = {
+	0x0200,
+	0x0300,
+	0x0400,
+	0x0600,
+	0x0800,
+	0x0b00,
+	0x1000,
+	0x1001,
+	0x1002,
+	0x1003,
+	0x1004,
+	0x1005,
+	0x1006,
+	0x1007,
+	0x1707,
+	0x2007,
+	0x2d07,
+	0x4007,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0200,
+	0x0300,
+	0x0400,
+	0x0600,
+	0x0800,
+	0x0b00,
+	0x1000,
+	0x1001,
+	0x1002,
+	0x1003,
+	0x1004,
+	0x1005,
+	0x1006,
+	0x1007,
+	0x1707,
+	0x2007,
+	0x2d07,
+	0x4007,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x4000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+CONST uint32 dot11lcn_papd_compdelta_tbl_rev0[] = {
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+	0x00080000,
+};
+
+CONST dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[] = {
+	{&dot11lcn_min_sig_sq_tbl_rev0,
+	 sizeof(dot11lcn_min_sig_sq_tbl_rev0) /
+	 sizeof(dot11lcn_min_sig_sq_tbl_rev0[0]), 2, 0, 16}
+	,
+	{&dot11lcn_noise_scale_tbl_rev0,
+	 sizeof(dot11lcn_noise_scale_tbl_rev0) /
+	 sizeof(dot11lcn_noise_scale_tbl_rev0[0]), 1, 0, 16}
+	,
+	{&dot11lcn_fltr_ctrl_tbl_rev0,
+	 sizeof(dot11lcn_fltr_ctrl_tbl_rev0) /
+	 sizeof(dot11lcn_fltr_ctrl_tbl_rev0[0]), 11, 0, 32}
+	,
+	{&dot11lcn_ps_ctrl_tbl_rev0,
+	 sizeof(dot11lcn_ps_ctrl_tbl_rev0) /
+	 sizeof(dot11lcn_ps_ctrl_tbl_rev0[0]), 12, 0, 32}
+	,
+	{&dot11lcn_gain_idx_tbl_rev0,
+	 sizeof(dot11lcn_gain_idx_tbl_rev0) /
+	 sizeof(dot11lcn_gain_idx_tbl_rev0[0]), 13, 0, 32}
+	,
+	{&dot11lcn_aux_gain_idx_tbl_rev0,
+	 sizeof(dot11lcn_aux_gain_idx_tbl_rev0) /
+	 sizeof(dot11lcn_aux_gain_idx_tbl_rev0[0]), 14, 0, 16}
+	,
+	{&dot11lcn_sw_ctrl_tbl_rev0,
+	 sizeof(dot11lcn_sw_ctrl_tbl_rev0) /
+	 sizeof(dot11lcn_sw_ctrl_tbl_rev0[0]), 15, 0, 16}
+	,
+	{&dot11lcn_nf_table_rev0,
+	 sizeof(dot11lcn_nf_table_rev0) / sizeof(dot11lcn_nf_table_rev0[0]), 16,
+	 0, 8}
+	,
+	{&dot11lcn_gain_val_tbl_rev0,
+	 sizeof(dot11lcn_gain_val_tbl_rev0) /
+	 sizeof(dot11lcn_gain_val_tbl_rev0[0]), 17, 0, 8}
+	,
+	{&dot11lcn_gain_tbl_rev0,
+	 sizeof(dot11lcn_gain_tbl_rev0) / sizeof(dot11lcn_gain_tbl_rev0[0]), 18,
+	 0, 32}
+	,
+	{&dot11lcn_spur_tbl_rev0,
+	 sizeof(dot11lcn_spur_tbl_rev0) / sizeof(dot11lcn_spur_tbl_rev0[0]), 20,
+	 0, 8}
+	,
+	{&dot11lcn_unsup_mcs_tbl_rev0,
+	 sizeof(dot11lcn_unsup_mcs_tbl_rev0) /
+	 sizeof(dot11lcn_unsup_mcs_tbl_rev0[0]), 23, 0, 16}
+	,
+	{&dot11lcn_iq_local_tbl_rev0,
+	 sizeof(dot11lcn_iq_local_tbl_rev0) /
+	 sizeof(dot11lcn_iq_local_tbl_rev0[0]), 0, 0, 16}
+	,
+	{&dot11lcn_papd_compdelta_tbl_rev0,
+	 sizeof(dot11lcn_papd_compdelta_tbl_rev0) /
+	 sizeof(dot11lcn_papd_compdelta_tbl_rev0[0]), 24, 0, 32}
+	,
+};
+
+CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313 = {
+	&dot11lcn_sw_ctrl_tbl_4313_rev0,
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_rev0) /
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_rev0[0]), 15, 0, 16
+};
+
+CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa = {
+	&dot11lcn_sw_ctrl_tbl_4313_epa_rev0,
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0) /
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0[0]), 15, 0, 16
+};
+
+CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa = {
+	&dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo,
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo) /
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_epa_rev0_combo[0]), 15, 0, 16
+};
+
+CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_bt_epa_p250 = {
+	&dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0,
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0) /
+	    sizeof(dot11lcn_sw_ctrl_tbl_4313_bt_epa_p250_rev0[0]), 15, 0, 16
+};
+
+CONST uint32 dot11lcnphytbl_info_sz_rev0 =
+    sizeof(dot11lcnphytbl_info_rev0) / sizeof(dot11lcnphytbl_info_rev0[0]);
+
+CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[128] = {
+	{3, 0, 31, 0, 72,}
+	,
+	{3, 0, 31, 0, 70,}
+	,
+	{3, 0, 31, 0, 68,}
+	,
+	{3, 0, 30, 0, 67,}
+	,
+	{3, 0, 29, 0, 68,}
+	,
+	{3, 0, 28, 0, 68,}
+	,
+	{3, 0, 27, 0, 69,}
+	,
+	{3, 0, 26, 0, 70,}
+	,
+	{3, 0, 25, 0, 70,}
+	,
+	{3, 0, 24, 0, 71,}
+	,
+	{3, 0, 23, 0, 72,}
+	,
+	{3, 0, 23, 0, 70,}
+	,
+	{3, 0, 22, 0, 71,}
+	,
+	{3, 0, 21, 0, 72,}
+	,
+	{3, 0, 21, 0, 70,}
+	,
+	{3, 0, 21, 0, 68,}
+	,
+	{3, 0, 21, 0, 66,}
+	,
+	{3, 0, 21, 0, 64,}
+	,
+	{3, 0, 21, 0, 63,}
+	,
+	{3, 0, 20, 0, 64,}
+	,
+	{3, 0, 19, 0, 65,}
+	,
+	{3, 0, 19, 0, 64,}
+	,
+	{3, 0, 18, 0, 65,}
+	,
+	{3, 0, 18, 0, 64,}
+	,
+	{3, 0, 17, 0, 65,}
+	,
+	{3, 0, 17, 0, 64,}
+	,
+	{3, 0, 16, 0, 65,}
+	,
+	{3, 0, 16, 0, 64,}
+	,
+	{3, 0, 16, 0, 62,}
+	,
+	{3, 0, 16, 0, 60,}
+	,
+	{3, 0, 16, 0, 58,}
+	,
+	{3, 0, 15, 0, 61,}
+	,
+	{3, 0, 15, 0, 59,}
+	,
+	{3, 0, 14, 0, 61,}
+	,
+	{3, 0, 14, 0, 60,}
+	,
+	{3, 0, 14, 0, 58,}
+	,
+	{3, 0, 13, 0, 60,}
+	,
+	{3, 0, 13, 0, 59,}
+	,
+	{3, 0, 12, 0, 62,}
+	,
+	{3, 0, 12, 0, 60,}
+	,
+	{3, 0, 12, 0, 58,}
+	,
+	{3, 0, 11, 0, 62,}
+	,
+	{3, 0, 11, 0, 60,}
+	,
+	{3, 0, 11, 0, 59,}
+	,
+	{3, 0, 11, 0, 57,}
+	,
+	{3, 0, 10, 0, 61,}
+	,
+	{3, 0, 10, 0, 59,}
+	,
+	{3, 0, 10, 0, 57,}
+	,
+	{3, 0, 9, 0, 62,}
+	,
+	{3, 0, 9, 0, 60,}
+	,
+	{3, 0, 9, 0, 58,}
+	,
+	{3, 0, 9, 0, 57,}
+	,
+	{3, 0, 8, 0, 62,}
+	,
+	{3, 0, 8, 0, 60,}
+	,
+	{3, 0, 8, 0, 58,}
+	,
+	{3, 0, 8, 0, 57,}
+	,
+	{3, 0, 8, 0, 55,}
+	,
+	{3, 0, 7, 0, 61,}
+	,
+	{3, 0, 7, 0, 60,}
+	,
+	{3, 0, 7, 0, 58,}
+	,
+	{3, 0, 7, 0, 56,}
+	,
+	{3, 0, 7, 0, 55,}
+	,
+	{3, 0, 6, 0, 62,}
+	,
+	{3, 0, 6, 0, 60,}
+	,
+	{3, 0, 6, 0, 58,}
+	,
+	{3, 0, 6, 0, 57,}
+	,
+	{3, 0, 6, 0, 55,}
+	,
+	{3, 0, 6, 0, 54,}
+	,
+	{3, 0, 6, 0, 52,}
+	,
+	{3, 0, 5, 0, 61,}
+	,
+	{3, 0, 5, 0, 59,}
+	,
+	{3, 0, 5, 0, 57,}
+	,
+	{3, 0, 5, 0, 56,}
+	,
+	{3, 0, 5, 0, 54,}
+	,
+	{3, 0, 5, 0, 53,}
+	,
+	{3, 0, 5, 0, 51,}
+	,
+	{3, 0, 4, 0, 62,}
+	,
+	{3, 0, 4, 0, 60,}
+	,
+	{3, 0, 4, 0, 58,}
+	,
+	{3, 0, 4, 0, 57,}
+	,
+	{3, 0, 4, 0, 55,}
+	,
+	{3, 0, 4, 0, 54,}
+	,
+	{3, 0, 4, 0, 52,}
+	,
+	{3, 0, 4, 0, 51,}
+	,
+	{3, 0, 4, 0, 49,}
+	,
+	{3, 0, 4, 0, 48,}
+	,
+	{3, 0, 4, 0, 46,}
+	,
+	{3, 0, 3, 0, 60,}
+	,
+	{3, 0, 3, 0, 58,}
+	,
+	{3, 0, 3, 0, 57,}
+	,
+	{3, 0, 3, 0, 55,}
+	,
+	{3, 0, 3, 0, 54,}
+	,
+	{3, 0, 3, 0, 52,}
+	,
+	{3, 0, 3, 0, 51,}
+	,
+	{3, 0, 3, 0, 49,}
+	,
+	{3, 0, 3, 0, 48,}
+	,
+	{3, 0, 3, 0, 46,}
+	,
+	{3, 0, 3, 0, 45,}
+	,
+	{3, 0, 3, 0, 44,}
+	,
+	{3, 0, 3, 0, 43,}
+	,
+	{3, 0, 3, 0, 41,}
+	,
+	{3, 0, 2, 0, 61,}
+	,
+	{3, 0, 2, 0, 59,}
+	,
+	{3, 0, 2, 0, 57,}
+	,
+	{3, 0, 2, 0, 56,}
+	,
+	{3, 0, 2, 0, 54,}
+	,
+	{3, 0, 2, 0, 53,}
+	,
+	{3, 0, 2, 0, 51,}
+	,
+	{3, 0, 2, 0, 50,}
+	,
+	{3, 0, 2, 0, 48,}
+	,
+	{3, 0, 2, 0, 47,}
+	,
+	{3, 0, 2, 0, 46,}
+	,
+	{3, 0, 2, 0, 44,}
+	,
+	{3, 0, 2, 0, 43,}
+	,
+	{3, 0, 2, 0, 42,}
+	,
+	{3, 0, 2, 0, 41,}
+	,
+	{3, 0, 2, 0, 39,}
+	,
+	{3, 0, 2, 0, 38,}
+	,
+	{3, 0, 2, 0, 37,}
+	,
+	{3, 0, 2, 0, 36,}
+	,
+	{3, 0, 2, 0, 35,}
+	,
+	{3, 0, 2, 0, 34,}
+	,
+	{3, 0, 2, 0, 33,}
+	,
+	{3, 0, 2, 0, 32,}
+	,
+	{3, 0, 1, 0, 63,}
+	,
+	{3, 0, 1, 0, 61,}
+	,
+	{3, 0, 1, 0, 59,}
+	,
+	{3, 0, 1, 0, 57,}
+	,
+};
+
+CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_gaintable_rev0[128] = {
+	{7, 0, 31, 0, 72,}
+	,
+	{7, 0, 31, 0, 70,}
+	,
+	{7, 0, 31, 0, 68,}
+	,
+	{7, 0, 30, 0, 67,}
+	,
+	{7, 0, 29, 0, 68,}
+	,
+	{7, 0, 28, 0, 68,}
+	,
+	{7, 0, 27, 0, 69,}
+	,
+	{7, 0, 26, 0, 70,}
+	,
+	{7, 0, 25, 0, 70,}
+	,
+	{7, 0, 24, 0, 71,}
+	,
+	{7, 0, 23, 0, 72,}
+	,
+	{7, 0, 23, 0, 70,}
+	,
+	{7, 0, 22, 0, 71,}
+	,
+	{7, 0, 21, 0, 72,}
+	,
+	{7, 0, 21, 0, 70,}
+	,
+	{7, 0, 21, 0, 68,}
+	,
+	{7, 0, 21, 0, 66,}
+	,
+	{7, 0, 21, 0, 64,}
+	,
+	{7, 0, 21, 0, 63,}
+	,
+	{7, 0, 20, 0, 64,}
+	,
+	{7, 0, 19, 0, 65,}
+	,
+	{7, 0, 19, 0, 64,}
+	,
+	{7, 0, 18, 0, 65,}
+	,
+	{7, 0, 18, 0, 64,}
+	,
+	{7, 0, 17, 0, 65,}
+	,
+	{7, 0, 17, 0, 64,}
+	,
+	{7, 0, 16, 0, 65,}
+	,
+	{7, 0, 16, 0, 64,}
+	,
+	{7, 0, 16, 0, 62,}
+	,
+	{7, 0, 16, 0, 60,}
+	,
+	{7, 0, 16, 0, 58,}
+	,
+	{7, 0, 15, 0, 61,}
+	,
+	{7, 0, 15, 0, 59,}
+	,
+	{7, 0, 14, 0, 61,}
+	,
+	{7, 0, 14, 0, 60,}
+	,
+	{7, 0, 14, 0, 58,}
+	,
+	{7, 0, 13, 0, 60,}
+	,
+	{7, 0, 13, 0, 59,}
+	,
+	{7, 0, 12, 0, 62,}
+	,
+	{7, 0, 12, 0, 60,}
+	,
+	{7, 0, 12, 0, 58,}
+	,
+	{7, 0, 11, 0, 62,}
+	,
+	{7, 0, 11, 0, 60,}
+	,
+	{7, 0, 11, 0, 59,}
+	,
+	{7, 0, 11, 0, 57,}
+	,
+	{7, 0, 10, 0, 61,}
+	,
+	{7, 0, 10, 0, 59,}
+	,
+	{7, 0, 10, 0, 57,}
+	,
+	{7, 0, 9, 0, 62,}
+	,
+	{7, 0, 9, 0, 60,}
+	,
+	{7, 0, 9, 0, 58,}
+	,
+	{7, 0, 9, 0, 57,}
+	,
+	{7, 0, 8, 0, 62,}
+	,
+	{7, 0, 8, 0, 60,}
+	,
+	{7, 0, 8, 0, 58,}
+	,
+	{7, 0, 8, 0, 57,}
+	,
+	{7, 0, 8, 0, 55,}
+	,
+	{7, 0, 7, 0, 61,}
+	,
+	{7, 0, 7, 0, 60,}
+	,
+	{7, 0, 7, 0, 58,}
+	,
+	{7, 0, 7, 0, 56,}
+	,
+	{7, 0, 7, 0, 55,}
+	,
+	{7, 0, 6, 0, 62,}
+	,
+	{7, 0, 6, 0, 60,}
+	,
+	{7, 0, 6, 0, 58,}
+	,
+	{7, 0, 6, 0, 57,}
+	,
+	{7, 0, 6, 0, 55,}
+	,
+	{7, 0, 6, 0, 54,}
+	,
+	{7, 0, 6, 0, 52,}
+	,
+	{7, 0, 5, 0, 61,}
+	,
+	{7, 0, 5, 0, 59,}
+	,
+	{7, 0, 5, 0, 57,}
+	,
+	{7, 0, 5, 0, 56,}
+	,
+	{7, 0, 5, 0, 54,}
+	,
+	{7, 0, 5, 0, 53,}
+	,
+	{7, 0, 5, 0, 51,}
+	,
+	{7, 0, 4, 0, 62,}
+	,
+	{7, 0, 4, 0, 60,}
+	,
+	{7, 0, 4, 0, 58,}
+	,
+	{7, 0, 4, 0, 57,}
+	,
+	{7, 0, 4, 0, 55,}
+	,
+	{7, 0, 4, 0, 54,}
+	,
+	{7, 0, 4, 0, 52,}
+	,
+	{7, 0, 4, 0, 51,}
+	,
+	{7, 0, 4, 0, 49,}
+	,
+	{7, 0, 4, 0, 48,}
+	,
+	{7, 0, 4, 0, 46,}
+	,
+	{7, 0, 3, 0, 60,}
+	,
+	{7, 0, 3, 0, 58,}
+	,
+	{7, 0, 3, 0, 57,}
+	,
+	{7, 0, 3, 0, 55,}
+	,
+	{7, 0, 3, 0, 54,}
+	,
+	{7, 0, 3, 0, 52,}
+	,
+	{7, 0, 3, 0, 51,}
+	,
+	{7, 0, 3, 0, 49,}
+	,
+	{7, 0, 3, 0, 48,}
+	,
+	{7, 0, 3, 0, 46,}
+	,
+	{7, 0, 3, 0, 45,}
+	,
+	{7, 0, 3, 0, 44,}
+	,
+	{7, 0, 3, 0, 43,}
+	,
+	{7, 0, 3, 0, 41,}
+	,
+	{7, 0, 2, 0, 61,}
+	,
+	{7, 0, 2, 0, 59,}
+	,
+	{7, 0, 2, 0, 57,}
+	,
+	{7, 0, 2, 0, 56,}
+	,
+	{7, 0, 2, 0, 54,}
+	,
+	{7, 0, 2, 0, 53,}
+	,
+	{7, 0, 2, 0, 51,}
+	,
+	{7, 0, 2, 0, 50,}
+	,
+	{7, 0, 2, 0, 48,}
+	,
+	{7, 0, 2, 0, 47,}
+	,
+	{7, 0, 2, 0, 46,}
+	,
+	{7, 0, 2, 0, 44,}
+	,
+	{7, 0, 2, 0, 43,}
+	,
+	{7, 0, 2, 0, 42,}
+	,
+	{7, 0, 2, 0, 41,}
+	,
+	{7, 0, 2, 0, 39,}
+	,
+	{7, 0, 2, 0, 38,}
+	,
+	{7, 0, 2, 0, 37,}
+	,
+	{7, 0, 2, 0, 36,}
+	,
+	{7, 0, 2, 0, 35,}
+	,
+	{7, 0, 2, 0, 34,}
+	,
+	{7, 0, 2, 0, 33,}
+	,
+	{7, 0, 2, 0, 32,}
+	,
+	{7, 0, 1, 0, 63,}
+	,
+	{7, 0, 1, 0, 61,}
+	,
+	{7, 0, 1, 0, 59,}
+	,
+	{7, 0, 1, 0, 57,}
+	,
+};
+
+CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_5GHz_gaintable_rev0[128] = {
+	{255, 255, 0xf0, 0, 152,}
+	,
+	{255, 255, 0xf0, 0, 147,}
+	,
+	{255, 255, 0xf0, 0, 143,}
+	,
+	{255, 255, 0xf0, 0, 139,}
+	,
+	{255, 255, 0xf0, 0, 135,}
+	,
+	{255, 255, 0xf0, 0, 131,}
+	,
+	{255, 255, 0xf0, 0, 128,}
+	,
+	{255, 255, 0xf0, 0, 124,}
+	,
+	{255, 255, 0xf0, 0, 121,}
+	,
+	{255, 255, 0xf0, 0, 117,}
+	,
+	{255, 255, 0xf0, 0, 114,}
+	,
+	{255, 255, 0xf0, 0, 111,}
+	,
+	{255, 255, 0xf0, 0, 107,}
+	,
+	{255, 255, 0xf0, 0, 104,}
+	,
+	{255, 255, 0xf0, 0, 101,}
+	,
+	{255, 255, 0xf0, 0, 99,}
+	,
+	{255, 255, 0xf0, 0, 96,}
+	,
+	{255, 255, 0xf0, 0, 93,}
+	,
+	{255, 255, 0xf0, 0, 90,}
+	,
+	{255, 255, 0xf0, 0, 88,}
+	,
+	{255, 255, 0xf0, 0, 85,}
+	,
+	{255, 255, 0xf0, 0, 83,}
+	,
+	{255, 255, 0xf0, 0, 81,}
+	,
+	{255, 255, 0xf0, 0, 78,}
+	,
+	{255, 255, 0xf0, 0, 76,}
+	,
+	{255, 255, 0xf0, 0, 74,}
+	,
+	{255, 255, 0xf0, 0, 72,}
+	,
+	{255, 255, 0xf0, 0, 70,}
+	,
+	{255, 255, 0xf0, 0, 68,}
+	,
+	{255, 255, 0xf0, 0, 66,}
+	,
+	{255, 255, 0xf0, 0, 64,}
+	,
+	{255, 248, 0xf0, 0, 64,}
+	,
+	{255, 241, 0xf0, 0, 64,}
+	,
+	{255, 251, 0xe0, 0, 64,}
+	,
+	{255, 244, 0xe0, 0, 64,}
+	,
+	{255, 254, 0xd0, 0, 64,}
+	,
+	{255, 246, 0xd0, 0, 64,}
+	,
+	{255, 239, 0xd0, 0, 64,}
+	,
+	{255, 249, 0xc0, 0, 64,}
+	,
+	{255, 242, 0xc0, 0, 64,}
+	,
+	{255, 255, 0xb0, 0, 64,}
+	,
+	{255, 248, 0xb0, 0, 64,}
+	,
+	{255, 241, 0xb0, 0, 64,}
+	,
+	{255, 254, 0xa0, 0, 64,}
+	,
+	{255, 246, 0xa0, 0, 64,}
+	,
+	{255, 239, 0xa0, 0, 64,}
+	,
+	{255, 255, 0x90, 0, 64,}
+	,
+	{255, 248, 0x90, 0, 64,}
+	,
+	{255, 241, 0x90, 0, 64,}
+	,
+	{255, 234, 0x90, 0, 64,}
+	,
+	{255, 255, 0x80, 0, 64,}
+	,
+	{255, 248, 0x80, 0, 64,}
+	,
+	{255, 241, 0x80, 0, 64,}
+	,
+	{255, 234, 0x80, 0, 64,}
+	,
+	{255, 255, 0x70, 0, 64,}
+	,
+	{255, 248, 0x70, 0, 64,}
+	,
+	{255, 241, 0x70, 0, 64,}
+	,
+	{255, 234, 0x70, 0, 64,}
+	,
+	{255, 227, 0x70, 0, 64,}
+	,
+	{255, 221, 0x70, 0, 64,}
+	,
+	{255, 215, 0x70, 0, 64,}
+	,
+	{255, 208, 0x70, 0, 64,}
+	,
+	{255, 203, 0x70, 0, 64,}
+	,
+	{255, 197, 0x70, 0, 64,}
+	,
+	{255, 255, 0x60, 0, 64,}
+	,
+	{255, 248, 0x60, 0, 64,}
+	,
+	{255, 241, 0x60, 0, 64,}
+	,
+	{255, 234, 0x60, 0, 64,}
+	,
+	{255, 227, 0x60, 0, 64,}
+	,
+	{255, 221, 0x60, 0, 64,}
+	,
+	{255, 255, 0x50, 0, 64,}
+	,
+	{255, 248, 0x50, 0, 64,}
+	,
+	{255, 241, 0x50, 0, 64,}
+	,
+	{255, 234, 0x50, 0, 64,}
+	,
+	{255, 227, 0x50, 0, 64,}
+	,
+	{255, 221, 0x50, 0, 64,}
+	,
+	{255, 215, 0x50, 0, 64,}
+	,
+	{255, 208, 0x50, 0, 64,}
+	,
+	{255, 255, 0x40, 0, 64,}
+	,
+	{255, 248, 0x40, 0, 64,}
+	,
+	{255, 241, 0x40, 0, 64,}
+	,
+	{255, 234, 0x40, 0, 64,}
+	,
+	{255, 227, 0x40, 0, 64,}
+	,
+	{255, 221, 0x40, 0, 64,}
+	,
+	{255, 215, 0x40, 0, 64,}
+	,
+	{255, 208, 0x40, 0, 64,}
+	,
+	{255, 203, 0x40, 0, 64,}
+	,
+	{255, 197, 0x40, 0, 64,}
+	,
+	{255, 255, 0x30, 0, 64,}
+	,
+	{255, 248, 0x30, 0, 64,}
+	,
+	{255, 241, 0x30, 0, 64,}
+	,
+	{255, 234, 0x30, 0, 64,}
+	,
+	{255, 227, 0x30, 0, 64,}
+	,
+	{255, 221, 0x30, 0, 64,}
+	,
+	{255, 215, 0x30, 0, 64,}
+	,
+	{255, 208, 0x30, 0, 64,}
+	,
+	{255, 203, 0x30, 0, 64,}
+	,
+	{255, 197, 0x30, 0, 64,}
+	,
+	{255, 191, 0x30, 0, 64,}
+	,
+	{255, 186, 0x30, 0, 64,}
+	,
+	{255, 181, 0x30, 0, 64,}
+	,
+	{255, 175, 0x30, 0, 64,}
+	,
+	{255, 255, 0x20, 0, 64,}
+	,
+	{255, 248, 0x20, 0, 64,}
+	,
+	{255, 241, 0x20, 0, 64,}
+	,
+	{255, 234, 0x20, 0, 64,}
+	,
+	{255, 227, 0x20, 0, 64,}
+	,
+	{255, 221, 0x20, 0, 64,}
+	,
+	{255, 215, 0x20, 0, 64,}
+	,
+	{255, 208, 0x20, 0, 64,}
+	,
+	{255, 203, 0x20, 0, 64,}
+	,
+	{255, 197, 0x20, 0, 64,}
+	,
+	{255, 191, 0x20, 0, 64,}
+	,
+	{255, 186, 0x20, 0, 64,}
+	,
+	{255, 181, 0x20, 0, 64,}
+	,
+	{255, 175, 0x20, 0, 64,}
+	,
+	{255, 170, 0x20, 0, 64,}
+	,
+	{255, 166, 0x20, 0, 64,}
+	,
+	{255, 161, 0x20, 0, 64,}
+	,
+	{255, 156, 0x20, 0, 64,}
+	,
+	{255, 152, 0x20, 0, 64,}
+	,
+	{255, 148, 0x20, 0, 64,}
+	,
+	{255, 143, 0x20, 0, 64,}
+	,
+	{255, 139, 0x20, 0, 64,}
+	,
+	{255, 135, 0x20, 0, 64,}
+	,
+	{255, 132, 0x20, 0, 64,}
+	,
+	{255, 255, 0x10, 0, 64,}
+	,
+	{255, 248, 0x10, 0, 64,}
+	,
+};
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
new file mode 100644
index 0000000..8a8ef7b
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_lcn.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+typedef phytbl_info_t dot11lcnphytbl_info_t;
+
+extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_rev0[];
+extern CONST uint32 dot11lcnphytbl_rx_gain_info_sz_rev0;
+extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313;
+extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa;
+extern CONST dot11lcnphytbl_info_t dot11lcn_sw_ctrl_tbl_info_4313_epa_combo;
+
+extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_info_rev0[];
+extern CONST uint32 dot11lcnphytbl_info_sz_rev0;
+
+extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_2G_rev2[];
+extern CONST uint32 dot11lcnphytbl_rx_gain_info_2G_rev2_sz;
+
+extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_5G_rev2[];
+extern CONST uint32 dot11lcnphytbl_rx_gain_info_5G_rev2_sz;
+
+extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_2G_rev2[];
+
+extern CONST dot11lcnphytbl_info_t dot11lcnphytbl_rx_gain_info_extlna_5G_rev2[];
+
+typedef struct {
+	uchar gm;
+	uchar pga;
+	uchar pad;
+	uchar dac;
+	uchar bb_mult;
+} lcnphy_tx_gain_tbl_entry;
+
+extern CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_gaintable_rev0[];
+extern CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_2GHz_extPA_gaintable_rev0[];
+
+extern CONST lcnphy_tx_gain_tbl_entry dot11lcnphy_5GHz_gaintable_rev0[];
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_n.c b/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
new file mode 100644
index 0000000..e5f2e02
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_n.c
@@ -0,0 +1,10631 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+
+#include <wlc_phy_int.h>
+#include <wlc_phytbl_n.h>
+
+CONST uint32 frame_struct_rev0[] = {
+	0x08004a04,
+	0x00100000,
+	0x01000a05,
+	0x00100020,
+	0x09804506,
+	0x00100030,
+	0x09804507,
+	0x00100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a0c,
+	0x00100004,
+	0x01000a0d,
+	0x00100024,
+	0x0980450e,
+	0x00100034,
+	0x0980450f,
+	0x00100034,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a04,
+	0x00100000,
+	0x11008a05,
+	0x00100020,
+	0x1980c506,
+	0x00100030,
+	0x21810506,
+	0x00100030,
+	0x21810506,
+	0x00100030,
+	0x01800504,
+	0x00100030,
+	0x11808505,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000a04,
+	0x00100000,
+	0x11008a05,
+	0x00100020,
+	0x21810506,
+	0x00100030,
+	0x21810506,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a0c,
+	0x00100008,
+	0x11008a0d,
+	0x00100028,
+	0x1980c50e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x0180050c,
+	0x00100038,
+	0x1180850d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000a0c,
+	0x00100008,
+	0x11008a0d,
+	0x00100028,
+	0x2181050e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a04,
+	0x00100000,
+	0x01000a05,
+	0x00100020,
+	0x1980c506,
+	0x00100030,
+	0x1980c506,
+	0x00100030,
+	0x11808504,
+	0x00100030,
+	0x3981ca05,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x10008a04,
+	0x00100000,
+	0x3981ca05,
+	0x00100030,
+	0x1980c506,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a0c,
+	0x00100008,
+	0x01000a0d,
+	0x00100028,
+	0x1980c50e,
+	0x00100038,
+	0x1980c50e,
+	0x00100038,
+	0x1180850c,
+	0x00100038,
+	0x3981ca0d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x10008a0c,
+	0x00100008,
+	0x3981ca0d,
+	0x00100038,
+	0x1980c50e,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x00100000,
+	0x02001405,
+	0x00100040,
+	0x0b004a06,
+	0x01900060,
+	0x13008a06,
+	0x01900060,
+	0x13008a06,
+	0x01900060,
+	0x43020a04,
+	0x00100060,
+	0x1b00ca05,
+	0x00100060,
+	0x23010a07,
+	0x01500060,
+	0x40021404,
+	0x00100000,
+	0x1a00d405,
+	0x00100040,
+	0x13008a06,
+	0x01900060,
+	0x13008a06,
+	0x01900060,
+	0x23010a07,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x0200140d,
+	0x00100050,
+	0x0b004a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x43020a0c,
+	0x00100070,
+	0x1b00ca0d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x13008a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x50029404,
+	0x00100000,
+	0x32019405,
+	0x00100040,
+	0x0b004a06,
+	0x01900060,
+	0x0b004a06,
+	0x01900060,
+	0x5b02ca04,
+	0x00100060,
+	0x3b01d405,
+	0x00100060,
+	0x23010a07,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x5802d404,
+	0x00100000,
+	0x3b01d405,
+	0x00100060,
+	0x0b004a06,
+	0x01900060,
+	0x23010a07,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x5002940c,
+	0x00100010,
+	0x3201940d,
+	0x00100050,
+	0x0b004a0e,
+	0x01900070,
+	0x0b004a0e,
+	0x01900070,
+	0x5b02ca0c,
+	0x00100070,
+	0x3b01d40d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x5802d40c,
+	0x00100010,
+	0x3b01d40d,
+	0x00100070,
+	0x0b004a0e,
+	0x01900070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x000f4800,
+	0x62031405,
+	0x00100040,
+	0x53028a06,
+	0x01900060,
+	0x53028a07,
+	0x01900060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x000f4808,
+	0x6203140d,
+	0x00100048,
+	0x53028a0e,
+	0x01900068,
+	0x53028a0f,
+	0x01900068,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a0c,
+	0x00100004,
+	0x11008a0d,
+	0x00100024,
+	0x1980c50e,
+	0x00100034,
+	0x2181050e,
+	0x00100034,
+	0x2181050e,
+	0x00100034,
+	0x0180050c,
+	0x00100038,
+	0x1180850d,
+	0x00100038,
+	0x1181850d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a0c,
+	0x00100008,
+	0x11008a0d,
+	0x00100028,
+	0x2181050e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x1181850d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a04,
+	0x00100000,
+	0x01000a05,
+	0x00100020,
+	0x0180c506,
+	0x00100030,
+	0x0180c506,
+	0x00100030,
+	0x2180c50c,
+	0x00100030,
+	0x49820a0d,
+	0x0016a130,
+	0x41824a0d,
+	0x0016a130,
+	0x2981450f,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x2000ca0c,
+	0x00100000,
+	0x49820a0d,
+	0x0016a130,
+	0x1980c50e,
+	0x00100030,
+	0x41824a0d,
+	0x0016a130,
+	0x2981450f,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100008,
+	0x0200140d,
+	0x00100048,
+	0x0b004a0e,
+	0x01900068,
+	0x13008a0e,
+	0x01900068,
+	0x13008a0e,
+	0x01900068,
+	0x43020a0c,
+	0x00100070,
+	0x1b00ca0d,
+	0x00100070,
+	0x1b014a0d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x13008a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x1b014a0d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x50029404,
+	0x00100000,
+	0x32019405,
+	0x00100040,
+	0x03004a06,
+	0x01900060,
+	0x03004a06,
+	0x01900060,
+	0x6b030a0c,
+	0x00100060,
+	0x4b02140d,
+	0x0016a160,
+	0x4302540d,
+	0x0016a160,
+	0x23010a0f,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x6b03140c,
+	0x00100060,
+	0x4b02140d,
+	0x0016a160,
+	0x0b004a0e,
+	0x01900060,
+	0x4302540d,
+	0x0016a160,
+	0x23010a0f,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x00100000,
+	0x1a00d405,
+	0x00100040,
+	0x53028a06,
+	0x01900060,
+	0x5b02ca06,
+	0x01900060,
+	0x5b02ca06,
+	0x01900060,
+	0x43020a04,
+	0x00100060,
+	0x1b00ca05,
+	0x00100060,
+	0x53028a07,
+	0x0190c060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x53028a0e,
+	0x01900070,
+	0x5b02ca0e,
+	0x01900070,
+	0x5b02ca0e,
+	0x01900070,
+	0x43020a0c,
+	0x00100070,
+	0x1b00ca0d,
+	0x00100070,
+	0x53028a0f,
+	0x0190c070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x00100000,
+	0x1a00d405,
+	0x00100040,
+	0x5b02ca06,
+	0x01900060,
+	0x5b02ca06,
+	0x01900060,
+	0x53028a07,
+	0x0190c060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x5b02ca0e,
+	0x01900070,
+	0x5b02ca0e,
+	0x01900070,
+	0x53028a0f,
+	0x0190c070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint8 frame_lut_rev0[] = {
+	0x02,
+	0x04,
+	0x14,
+	0x14,
+	0x03,
+	0x05,
+	0x16,
+	0x16,
+	0x0a,
+	0x0c,
+	0x1c,
+	0x1c,
+	0x0b,
+	0x0d,
+	0x1e,
+	0x1e,
+	0x06,
+	0x08,
+	0x18,
+	0x18,
+	0x07,
+	0x09,
+	0x1a,
+	0x1a,
+	0x0e,
+	0x10,
+	0x20,
+	0x28,
+	0x0f,
+	0x11,
+	0x22,
+	0x2a,
+};
+
+CONST uint32 tmap_tbl_rev0[] = {
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00000111,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x000aa888,
+	0x88880000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa2222220,
+	0x22222222,
+	0x22c22222,
+	0x00000222,
+	0x22000000,
+	0x2222a222,
+	0x22222222,
+	0x222222a2,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00011111,
+	0x11110000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0xa8aa88a0,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x00088aaa,
+	0xaaaa0000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xaaa8aaa0,
+	0x8aaa8aaa,
+	0xaa8a8a8a,
+	0x000aaa88,
+	0x8aaa0000,
+	0xaaa8a888,
+	0x8aa88a8a,
+	0x8a88a888,
+	0x08080a00,
+	0x0a08080a,
+	0x080a0a08,
+	0x00080808,
+	0x080a0000,
+	0x080a0808,
+	0x080a0808,
+	0x0a0a0a08,
+	0xa0a0a0a0,
+	0x80a0a080,
+	0x8080a0a0,
+	0x00008080,
+	0x80a00000,
+	0x80a080a0,
+	0xa080a0a0,
+	0x8080a0a0,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x99999000,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb90,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00aaa888,
+	0x22000000,
+	0x2222b222,
+	0x22222222,
+	0x222222b2,
+	0xb2222220,
+	0x22222222,
+	0x22d22222,
+	0x00000222,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x33000000,
+	0x3333b333,
+	0x33333333,
+	0x333333b3,
+	0xb3333330,
+	0x33333333,
+	0x33d33333,
+	0x00000333,
+	0x22000000,
+	0x2222a222,
+	0x22222222,
+	0x222222a2,
+	0xa2222220,
+	0x22222222,
+	0x22c22222,
+	0x00000222,
+	0x99b99b00,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb99,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x08aaa888,
+	0x22222200,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0x22222222,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x11111111,
+	0xf1111111,
+	0x11111111,
+	0x11f11111,
+	0x01111111,
+	0xbb9bb900,
+	0xb9b9bb99,
+	0xb99bbbbb,
+	0xbbbb9b9b,
+	0xb9bb99bb,
+	0xb99999b9,
+	0xb9b9b99b,
+	0x00000bbb,
+	0xaa000000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xa8aa88aa,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x0a888aaa,
+	0xaa000000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xa8aa88a0,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x00000aaa,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0xbbbbbb00,
+	0x999bbbbb,
+	0x9bb99b9b,
+	0xb9b9b9bb,
+	0xb9b99bbb,
+	0xb9b9b9bb,
+	0xb9bb9b99,
+	0x00000999,
+	0x8a000000,
+	0xaa88a888,
+	0xa88888aa,
+	0xa88a8a88,
+	0xa88aa88a,
+	0x88a8aaaa,
+	0xa8aa8aaa,
+	0x0888a88a,
+	0x0b0b0b00,
+	0x090b0b0b,
+	0x0b090b0b,
+	0x0909090b,
+	0x09090b0b,
+	0x09090b0b,
+	0x09090b09,
+	0x00000909,
+	0x0a000000,
+	0x0a080808,
+	0x080a080a,
+	0x080a0a08,
+	0x080a080a,
+	0x0808080a,
+	0x0a0a0a08,
+	0x0808080a,
+	0xb0b0b000,
+	0x9090b0b0,
+	0x90b09090,
+	0xb0b0b090,
+	0xb0b090b0,
+	0x90b0b0b0,
+	0xb0b09090,
+	0x00000090,
+	0x80000000,
+	0xa080a080,
+	0xa08080a0,
+	0xa0808080,
+	0xa080a080,
+	0x80a0a0a0,
+	0xa0a080a0,
+	0x00a0a0a0,
+	0x22000000,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0xf2222220,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00000111,
+	0x33000000,
+	0x3333f333,
+	0x33333333,
+	0x333333f3,
+	0xf3333330,
+	0x33333333,
+	0x33f33333,
+	0x00000333,
+	0x22000000,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0xf2222220,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x99000000,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb90,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88888000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00aaa888,
+	0x88a88a00,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x08aaa888,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 tdtrn_tbl_rev0[] = {
+	0x061c061c,
+	0x0050ee68,
+	0xf592fe36,
+	0xfe5212f6,
+	0x00000c38,
+	0xfe5212f6,
+	0xf592fe36,
+	0x0050ee68,
+	0x061c061c,
+	0xee680050,
+	0xfe36f592,
+	0x12f6fe52,
+	0x0c380000,
+	0x12f6fe52,
+	0xfe36f592,
+	0xee680050,
+	0x061c061c,
+	0x0050ee68,
+	0xf592fe36,
+	0xfe5212f6,
+	0x00000c38,
+	0xfe5212f6,
+	0xf592fe36,
+	0x0050ee68,
+	0x061c061c,
+	0xee680050,
+	0xfe36f592,
+	0x12f6fe52,
+	0x0c380000,
+	0x12f6fe52,
+	0xfe36f592,
+	0xee680050,
+	0x05e305e3,
+	0x004def0c,
+	0xf5f3fe47,
+	0xfe611246,
+	0x00000bc7,
+	0xfe611246,
+	0xf5f3fe47,
+	0x004def0c,
+	0x05e305e3,
+	0xef0c004d,
+	0xfe47f5f3,
+	0x1246fe61,
+	0x0bc70000,
+	0x1246fe61,
+	0xfe47f5f3,
+	0xef0c004d,
+	0x05e305e3,
+	0x004def0c,
+	0xf5f3fe47,
+	0xfe611246,
+	0x00000bc7,
+	0xfe611246,
+	0xf5f3fe47,
+	0x004def0c,
+	0x05e305e3,
+	0xef0c004d,
+	0xfe47f5f3,
+	0x1246fe61,
+	0x0bc70000,
+	0x1246fe61,
+	0xfe47f5f3,
+	0xef0c004d,
+	0xfa58fa58,
+	0xf895043b,
+	0xff4c09c0,
+	0xfbc6ffa8,
+	0xfb84f384,
+	0x0798f6f9,
+	0x05760122,
+	0x058409f6,
+	0x0b500000,
+	0x05b7f542,
+	0x08860432,
+	0x06ddfee7,
+	0xfb84f384,
+	0xf9d90664,
+	0xf7e8025c,
+	0x00fff7bd,
+	0x05a805a8,
+	0xf7bd00ff,
+	0x025cf7e8,
+	0x0664f9d9,
+	0xf384fb84,
+	0xfee706dd,
+	0x04320886,
+	0xf54205b7,
+	0x00000b50,
+	0x09f60584,
+	0x01220576,
+	0xf6f90798,
+	0xf384fb84,
+	0xffa8fbc6,
+	0x09c0ff4c,
+	0x043bf895,
+	0x02d402d4,
+	0x07de0270,
+	0xfc96079c,
+	0xf90afe94,
+	0xfe00ff2c,
+	0x02d4065d,
+	0x092a0096,
+	0x0014fbb8,
+	0xfd2cfd2c,
+	0x076afb3c,
+	0x0096f752,
+	0xf991fd87,
+	0xfb2c0200,
+	0xfeb8f960,
+	0x08e0fc96,
+	0x049802a8,
+	0xfd2cfd2c,
+	0x02a80498,
+	0xfc9608e0,
+	0xf960feb8,
+	0x0200fb2c,
+	0xfd87f991,
+	0xf7520096,
+	0xfb3c076a,
+	0xfd2cfd2c,
+	0xfbb80014,
+	0x0096092a,
+	0x065d02d4,
+	0xff2cfe00,
+	0xfe94f90a,
+	0x079cfc96,
+	0x027007de,
+	0x02d402d4,
+	0x027007de,
+	0x079cfc96,
+	0xfe94f90a,
+	0xff2cfe00,
+	0x065d02d4,
+	0x0096092a,
+	0xfbb80014,
+	0xfd2cfd2c,
+	0xfb3c076a,
+	0xf7520096,
+	0xfd87f991,
+	0x0200fb2c,
+	0xf960feb8,
+	0xfc9608e0,
+	0x02a80498,
+	0xfd2cfd2c,
+	0x049802a8,
+	0x08e0fc96,
+	0xfeb8f960,
+	0xfb2c0200,
+	0xf991fd87,
+	0x0096f752,
+	0x076afb3c,
+	0xfd2cfd2c,
+	0x0014fbb8,
+	0x092a0096,
+	0x02d4065d,
+	0xfe00ff2c,
+	0xf90afe94,
+	0xfc96079c,
+	0x07de0270,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x062a0000,
+	0xfefa0759,
+	0x08b80908,
+	0xf396fc2d,
+	0xf9d6045c,
+	0xfc4ef608,
+	0xf748f596,
+	0x07b207bf,
+	0x062a062a,
+	0xf84ef841,
+	0xf748f596,
+	0x03b209f8,
+	0xf9d6045c,
+	0x0c6a03d3,
+	0x08b80908,
+	0x0106f8a7,
+	0x062a0000,
+	0xfefaf8a7,
+	0x08b8f6f8,
+	0xf39603d3,
+	0xf9d6fba4,
+	0xfc4e09f8,
+	0xf7480a6a,
+	0x07b2f841,
+	0x062af9d6,
+	0xf84e07bf,
+	0xf7480a6a,
+	0x03b2f608,
+	0xf9d6fba4,
+	0x0c6afc2d,
+	0x08b8f6f8,
+	0x01060759,
+	0x062a0000,
+	0xfefa0759,
+	0x08b80908,
+	0xf396fc2d,
+	0xf9d6045c,
+	0xfc4ef608,
+	0xf748f596,
+	0x07b207bf,
+	0x062a062a,
+	0xf84ef841,
+	0xf748f596,
+	0x03b209f8,
+	0xf9d6045c,
+	0x0c6a03d3,
+	0x08b80908,
+	0x0106f8a7,
+	0x062a0000,
+	0xfefaf8a7,
+	0x08b8f6f8,
+	0xf39603d3,
+	0xf9d6fba4,
+	0xfc4e09f8,
+	0xf7480a6a,
+	0x07b2f841,
+	0x062af9d6,
+	0xf84e07bf,
+	0xf7480a6a,
+	0x03b2f608,
+	0xf9d6fba4,
+	0x0c6afc2d,
+	0x08b8f6f8,
+	0x01060759,
+	0x061c061c,
+	0xff30009d,
+	0xffb21141,
+	0xfd87fb54,
+	0xf65dfe59,
+	0x02eef99e,
+	0x0166f03c,
+	0xfff809b6,
+	0x000008a4,
+	0x000af42b,
+	0x00eff577,
+	0xfa840bf2,
+	0xfc02ff51,
+	0x08260f67,
+	0xfff0036f,
+	0x0842f9c3,
+	0x00000000,
+	0x063df7be,
+	0xfc910010,
+	0xf099f7da,
+	0x00af03fe,
+	0xf40e057c,
+	0x0a89ff11,
+	0x0bd5fff6,
+	0xf75c0000,
+	0xf64a0008,
+	0x0fc4fe9a,
+	0x0662fd12,
+	0x01a709a3,
+	0x04ac0279,
+	0xeebf004e,
+	0xff6300d0,
+	0xf9e4f9e4,
+	0x00d0ff63,
+	0x004eeebf,
+	0x027904ac,
+	0x09a301a7,
+	0xfd120662,
+	0xfe9a0fc4,
+	0x0008f64a,
+	0x0000f75c,
+	0xfff60bd5,
+	0xff110a89,
+	0x057cf40e,
+	0x03fe00af,
+	0xf7daf099,
+	0x0010fc91,
+	0xf7be063d,
+	0x00000000,
+	0xf9c30842,
+	0x036ffff0,
+	0x0f670826,
+	0xff51fc02,
+	0x0bf2fa84,
+	0xf57700ef,
+	0xf42b000a,
+	0x08a40000,
+	0x09b6fff8,
+	0xf03c0166,
+	0xf99e02ee,
+	0xfe59f65d,
+	0xfb54fd87,
+	0x1141ffb2,
+	0x009dff30,
+	0x05e30000,
+	0xff060705,
+	0x085408a0,
+	0xf425fc59,
+	0xfa1d042a,
+	0xfc78f67a,
+	0xf7acf60e,
+	0x075a0766,
+	0x05e305e3,
+	0xf8a6f89a,
+	0xf7acf60e,
+	0x03880986,
+	0xfa1d042a,
+	0x0bdb03a7,
+	0x085408a0,
+	0x00faf8fb,
+	0x05e30000,
+	0xff06f8fb,
+	0x0854f760,
+	0xf42503a7,
+	0xfa1dfbd6,
+	0xfc780986,
+	0xf7ac09f2,
+	0x075af89a,
+	0x05e3fa1d,
+	0xf8a60766,
+	0xf7ac09f2,
+	0x0388f67a,
+	0xfa1dfbd6,
+	0x0bdbfc59,
+	0x0854f760,
+	0x00fa0705,
+	0x05e30000,
+	0xff060705,
+	0x085408a0,
+	0xf425fc59,
+	0xfa1d042a,
+	0xfc78f67a,
+	0xf7acf60e,
+	0x075a0766,
+	0x05e305e3,
+	0xf8a6f89a,
+	0xf7acf60e,
+	0x03880986,
+	0xfa1d042a,
+	0x0bdb03a7,
+	0x085408a0,
+	0x00faf8fb,
+	0x05e30000,
+	0xff06f8fb,
+	0x0854f760,
+	0xf42503a7,
+	0xfa1dfbd6,
+	0xfc780986,
+	0xf7ac09f2,
+	0x075af89a,
+	0x05e3fa1d,
+	0xf8a60766,
+	0xf7ac09f2,
+	0x0388f67a,
+	0xfa1dfbd6,
+	0x0bdbfc59,
+	0x0854f760,
+	0x00fa0705,
+	0xfa58fa58,
+	0xf8f0fe00,
+	0x0448073d,
+	0xfdc9fe46,
+	0xf9910258,
+	0x089d0407,
+	0xfd5cf71a,
+	0x02affde0,
+	0x083e0496,
+	0xff5a0740,
+	0xff7afd97,
+	0x00fe01f1,
+	0x0009082e,
+	0xfa94ff75,
+	0xfecdf8ea,
+	0xffb0f693,
+	0xfd2cfa58,
+	0x0433ff16,
+	0xfba405dd,
+	0xfa610341,
+	0x06a606cb,
+	0x0039fd2d,
+	0x0677fa97,
+	0x01fa05e0,
+	0xf896003e,
+	0x075a068b,
+	0x012cfc3e,
+	0xfa23f98d,
+	0xfc7cfd43,
+	0xff90fc0d,
+	0x01c10982,
+	0x00c601d6,
+	0xfd2cfd2c,
+	0x01d600c6,
+	0x098201c1,
+	0xfc0dff90,
+	0xfd43fc7c,
+	0xf98dfa23,
+	0xfc3e012c,
+	0x068b075a,
+	0x003ef896,
+	0x05e001fa,
+	0xfa970677,
+	0xfd2d0039,
+	0x06cb06a6,
+	0x0341fa61,
+	0x05ddfba4,
+	0xff160433,
+	0xfa58fd2c,
+	0xf693ffb0,
+	0xf8eafecd,
+	0xff75fa94,
+	0x082e0009,
+	0x01f100fe,
+	0xfd97ff7a,
+	0x0740ff5a,
+	0x0496083e,
+	0xfde002af,
+	0xf71afd5c,
+	0x0407089d,
+	0x0258f991,
+	0xfe46fdc9,
+	0x073d0448,
+	0xfe00f8f0,
+	0xfd2cfd2c,
+	0xfce00500,
+	0xfc09fddc,
+	0xfe680157,
+	0x04c70571,
+	0xfc3aff21,
+	0xfcd70228,
+	0x056d0277,
+	0x0200fe00,
+	0x0022f927,
+	0xfe3c032b,
+	0xfc44ff3c,
+	0x03e9fbdb,
+	0x04570313,
+	0x04c9ff5c,
+	0x000d03b8,
+	0xfa580000,
+	0xfbe900d2,
+	0xf9d0fe0b,
+	0x0125fdf9,
+	0x042501bf,
+	0x0328fa2b,
+	0xffa902f0,
+	0xfa250157,
+	0x0200fe00,
+	0x03740438,
+	0xff0405fd,
+	0x030cfe52,
+	0x0037fb39,
+	0xff6904c5,
+	0x04f8fd23,
+	0xfd31fc1b,
+	0xfd2cfd2c,
+	0xfc1bfd31,
+	0xfd2304f8,
+	0x04c5ff69,
+	0xfb390037,
+	0xfe52030c,
+	0x05fdff04,
+	0x04380374,
+	0xfe000200,
+	0x0157fa25,
+	0x02f0ffa9,
+	0xfa2b0328,
+	0x01bf0425,
+	0xfdf90125,
+	0xfe0bf9d0,
+	0x00d2fbe9,
+	0x0000fa58,
+	0x03b8000d,
+	0xff5c04c9,
+	0x03130457,
+	0xfbdb03e9,
+	0xff3cfc44,
+	0x032bfe3c,
+	0xf9270022,
+	0xfe000200,
+	0x0277056d,
+	0x0228fcd7,
+	0xff21fc3a,
+	0x057104c7,
+	0x0157fe68,
+	0xfddcfc09,
+	0x0500fce0,
+	0xfd2cfd2c,
+	0x0500fce0,
+	0xfddcfc09,
+	0x0157fe68,
+	0x057104c7,
+	0xff21fc3a,
+	0x0228fcd7,
+	0x0277056d,
+	0xfe000200,
+	0xf9270022,
+	0x032bfe3c,
+	0xff3cfc44,
+	0xfbdb03e9,
+	0x03130457,
+	0xff5c04c9,
+	0x03b8000d,
+	0x0000fa58,
+	0x00d2fbe9,
+	0xfe0bf9d0,
+	0xfdf90125,
+	0x01bf0425,
+	0xfa2b0328,
+	0x02f0ffa9,
+	0x0157fa25,
+	0xfe000200,
+	0x04380374,
+	0x05fdff04,
+	0xfe52030c,
+	0xfb390037,
+	0x04c5ff69,
+	0xfd2304f8,
+	0xfc1bfd31,
+	0xfd2cfd2c,
+	0xfd31fc1b,
+	0x04f8fd23,
+	0xff6904c5,
+	0x0037fb39,
+	0x030cfe52,
+	0xff0405fd,
+	0x03740438,
+	0x0200fe00,
+	0xfa250157,
+	0xffa902f0,
+	0x0328fa2b,
+	0x042501bf,
+	0x0125fdf9,
+	0xf9d0fe0b,
+	0xfbe900d2,
+	0xfa580000,
+	0x000d03b8,
+	0x04c9ff5c,
+	0x04570313,
+	0x03e9fbdb,
+	0xfc44ff3c,
+	0xfe3c032b,
+	0x0022f927,
+	0x0200fe00,
+	0x056d0277,
+	0xfcd70228,
+	0xfc3aff21,
+	0x04c70571,
+	0xfe680157,
+	0xfc09fddc,
+	0xfce00500,
+	0x05a80000,
+	0xff1006be,
+	0x0800084a,
+	0xf49cfc7e,
+	0xfa580400,
+	0xfc9cf6da,
+	0xf800f672,
+	0x0710071c,
+	0x05a805a8,
+	0xf8f0f8e4,
+	0xf800f672,
+	0x03640926,
+	0xfa580400,
+	0x0b640382,
+	0x0800084a,
+	0x00f0f942,
+	0x05a80000,
+	0xff10f942,
+	0x0800f7b6,
+	0xf49c0382,
+	0xfa58fc00,
+	0xfc9c0926,
+	0xf800098e,
+	0x0710f8e4,
+	0x05a8fa58,
+	0xf8f0071c,
+	0xf800098e,
+	0x0364f6da,
+	0xfa58fc00,
+	0x0b64fc7e,
+	0x0800f7b6,
+	0x00f006be,
+	0x05a80000,
+	0xff1006be,
+	0x0800084a,
+	0xf49cfc7e,
+	0xfa580400,
+	0xfc9cf6da,
+	0xf800f672,
+	0x0710071c,
+	0x05a805a8,
+	0xf8f0f8e4,
+	0xf800f672,
+	0x03640926,
+	0xfa580400,
+	0x0b640382,
+	0x0800084a,
+	0x00f0f942,
+	0x05a80000,
+	0xff10f942,
+	0x0800f7b6,
+	0xf49c0382,
+	0xfa58fc00,
+	0xfc9c0926,
+	0xf800098e,
+	0x0710f8e4,
+	0x05a8fa58,
+	0xf8f0071c,
+	0xf800098e,
+	0x0364f6da,
+	0xfa58fc00,
+	0x0b64fc7e,
+	0x0800f7b6,
+	0x00f006be,
+};
+
+CONST uint32 intlv_tbl_rev0[] = {
+	0x00802070,
+	0x0671188d,
+	0x0a60192c,
+	0x0a300e46,
+	0x00c1188d,
+	0x080024d2,
+	0x00000070,
+};
+
+CONST uint16 pilot_tbl_rev0[] = {
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0xff0a,
+	0xff82,
+	0xffa0,
+	0xff28,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xff82,
+	0xffa0,
+	0xff28,
+	0xff0a,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xf83f,
+	0xfa1f,
+	0xfa97,
+	0xfab5,
+	0xf2bd,
+	0xf0bf,
+	0xffff,
+	0xffff,
+	0xf017,
+	0xf815,
+	0xf215,
+	0xf095,
+	0xf035,
+	0xf01d,
+	0xffff,
+	0xffff,
+	0xff08,
+	0xff02,
+	0xff80,
+	0xff20,
+	0xff08,
+	0xff02,
+	0xff80,
+	0xff20,
+	0xf01f,
+	0xf817,
+	0xfa15,
+	0xf295,
+	0xf0b5,
+	0xf03d,
+	0xffff,
+	0xffff,
+	0xf82a,
+	0xfa0a,
+	0xfa82,
+	0xfaa0,
+	0xf2a8,
+	0xf0aa,
+	0xffff,
+	0xffff,
+	0xf002,
+	0xf800,
+	0xf200,
+	0xf080,
+	0xf020,
+	0xf008,
+	0xffff,
+	0xffff,
+	0xf00a,
+	0xf802,
+	0xfa00,
+	0xf280,
+	0xf0a0,
+	0xf028,
+	0xffff,
+	0xffff,
+};
+
+CONST uint32 pltlut_tbl_rev0[] = {
+	0x76540123,
+	0x62407351,
+	0x76543201,
+	0x76540213,
+	0x76540123,
+	0x76430521,
+};
+
+CONST uint32 tdi_tbl20_ant0_rev0[] = {
+	0x00091226,
+	0x000a1429,
+	0x000b56ad,
+	0x000c58b0,
+	0x000d5ab3,
+	0x000e9cb6,
+	0x000f9eba,
+	0x0000c13d,
+	0x00020301,
+	0x00030504,
+	0x00040708,
+	0x0005090b,
+	0x00064b8e,
+	0x00095291,
+	0x000a5494,
+	0x000b9718,
+	0x000c9927,
+	0x000d9b2a,
+	0x000edd2e,
+	0x000fdf31,
+	0x000101b4,
+	0x000243b7,
+	0x000345bb,
+	0x000447be,
+	0x00058982,
+	0x00068c05,
+	0x00099309,
+	0x000a950c,
+	0x000bd78f,
+	0x000cd992,
+	0x000ddb96,
+	0x000f1d99,
+	0x00005fa8,
+	0x0001422c,
+	0x0002842f,
+	0x00038632,
+	0x00048835,
+	0x0005ca38,
+	0x0006ccbc,
+	0x0009d3bf,
+	0x000b1603,
+	0x000c1806,
+	0x000d1a0a,
+	0x000e1c0d,
+	0x000f5e10,
+	0x00008093,
+	0x00018297,
+	0x0002c49a,
+	0x0003c680,
+	0x0004c880,
+	0x00060b00,
+	0x00070d00,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 tdi_tbl20_ant1_rev0[] = {
+	0x00014b26,
+	0x00028d29,
+	0x000393ad,
+	0x00049630,
+	0x0005d833,
+	0x0006da36,
+	0x00099c3a,
+	0x000a9e3d,
+	0x000bc081,
+	0x000cc284,
+	0x000dc488,
+	0x000f068b,
+	0x0000488e,
+	0x00018b91,
+	0x0002d214,
+	0x0003d418,
+	0x0004d6a7,
+	0x000618aa,
+	0x00071aae,
+	0x0009dcb1,
+	0x000b1eb4,
+	0x000c0137,
+	0x000d033b,
+	0x000e053e,
+	0x000f4702,
+	0x00008905,
+	0x00020c09,
+	0x0003128c,
+	0x0004148f,
+	0x00051712,
+	0x00065916,
+	0x00091b19,
+	0x000a1d28,
+	0x000b5f2c,
+	0x000c41af,
+	0x000d43b2,
+	0x000e85b5,
+	0x000f87b8,
+	0x0000c9bc,
+	0x00024cbf,
+	0x00035303,
+	0x00045506,
+	0x0005978a,
+	0x0006998d,
+	0x00095b90,
+	0x000a5d93,
+	0x000b9f97,
+	0x000c821a,
+	0x000d8400,
+	0x000ec600,
+	0x000fc800,
+	0x00010a00,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 tdi_tbl40_ant0_rev0[] = {
+	0x0011a346,
+	0x00136ccf,
+	0x0014f5d9,
+	0x001641e2,
+	0x0017cb6b,
+	0x00195475,
+	0x001b2383,
+	0x001cad0c,
+	0x001e7616,
+	0x0000821f,
+	0x00020ba8,
+	0x0003d4b2,
+	0x00056447,
+	0x00072dd0,
+	0x0008b6da,
+	0x000a02e3,
+	0x000b8c6c,
+	0x000d15f6,
+	0x0011e484,
+	0x0013ae0d,
+	0x00153717,
+	0x00168320,
+	0x00180ca9,
+	0x00199633,
+	0x001b6548,
+	0x001ceed1,
+	0x001eb7db,
+	0x0000c3e4,
+	0x00024d6d,
+	0x000416f7,
+	0x0005a585,
+	0x00076f0f,
+	0x0008f818,
+	0x000a4421,
+	0x000bcdab,
+	0x000d9734,
+	0x00122649,
+	0x0013efd2,
+	0x001578dc,
+	0x0016c4e5,
+	0x00184e6e,
+	0x001a17f8,
+	0x001ba686,
+	0x001d3010,
+	0x001ef999,
+	0x00010522,
+	0x00028eac,
+	0x00045835,
+	0x0005e74a,
+	0x0007b0d3,
+	0x00093a5d,
+	0x000a85e6,
+	0x000c0f6f,
+	0x000dd8f9,
+	0x00126787,
+	0x00143111,
+	0x0015ba9a,
+	0x00170623,
+	0x00188fad,
+	0x001a5936,
+	0x001be84b,
+	0x001db1d4,
+	0x001f3b5e,
+	0x000146e7,
+	0x00031070,
+	0x000499fa,
+	0x00062888,
+	0x0007f212,
+	0x00097b9b,
+	0x000ac7a4,
+	0x000c50ae,
+	0x000e1a37,
+	0x0012a94c,
+	0x001472d5,
+	0x0015fc5f,
+	0x00174868,
+	0x0018d171,
+	0x001a9afb,
+	0x001c2989,
+	0x001df313,
+	0x001f7c9c,
+	0x000188a5,
+	0x000351af,
+	0x0004db38,
+	0x0006aa4d,
+	0x000833d7,
+	0x0009bd60,
+	0x000b0969,
+	0x000c9273,
+	0x000e5bfc,
+	0x00132a8a,
+	0x0014b414,
+	0x00163d9d,
+	0x001789a6,
+	0x001912b0,
+	0x001adc39,
+	0x001c6bce,
+	0x001e34d8,
+	0x001fbe61,
+	0x0001ca6a,
+	0x00039374,
+	0x00051cfd,
+	0x0006ec0b,
+	0x00087515,
+	0x0009fe9e,
+	0x000b4aa7,
+	0x000cd3b1,
+	0x000e9d3a,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 tdi_tbl40_ant1_rev0[] = {
+	0x001edb36,
+	0x000129ca,
+	0x0002b353,
+	0x00047cdd,
+	0x0005c8e6,
+	0x000791ef,
+	0x00091bf9,
+	0x000aaa07,
+	0x000c3391,
+	0x000dfd1a,
+	0x00120923,
+	0x0013d22d,
+	0x00155c37,
+	0x0016eacb,
+	0x00187454,
+	0x001a3dde,
+	0x001b89e7,
+	0x001d12f0,
+	0x001f1cfa,
+	0x00016b88,
+	0x00033492,
+	0x0004be1b,
+	0x00060a24,
+	0x0007d32e,
+	0x00095d38,
+	0x000aec4c,
+	0x000c7555,
+	0x000e3edf,
+	0x00124ae8,
+	0x001413f1,
+	0x0015a37b,
+	0x00172c89,
+	0x0018b593,
+	0x001a419c,
+	0x001bcb25,
+	0x001d942f,
+	0x001f63b9,
+	0x0001ad4d,
+	0x00037657,
+	0x0004c260,
+	0x00068be9,
+	0x000814f3,
+	0x0009a47c,
+	0x000b2d8a,
+	0x000cb694,
+	0x000e429d,
+	0x00128c26,
+	0x001455b0,
+	0x0015e4ba,
+	0x00176e4e,
+	0x0018f758,
+	0x001a8361,
+	0x001c0cea,
+	0x001dd674,
+	0x001fa57d,
+	0x0001ee8b,
+	0x0003b795,
+	0x0005039e,
+	0x0006cd27,
+	0x000856b1,
+	0x0009e5c6,
+	0x000b6f4f,
+	0x000cf859,
+	0x000e8462,
+	0x00130deb,
+	0x00149775,
+	0x00162603,
+	0x0017af8c,
+	0x00193896,
+	0x001ac49f,
+	0x001c4e28,
+	0x001e17b2,
+	0x0000a6c7,
+	0x00023050,
+	0x0003f9da,
+	0x00054563,
+	0x00070eec,
+	0x00089876,
+	0x000a2704,
+	0x000bb08d,
+	0x000d3a17,
+	0x001185a0,
+	0x00134f29,
+	0x0014d8b3,
+	0x001667c8,
+	0x0017f151,
+	0x00197adb,
+	0x001b0664,
+	0x001c8fed,
+	0x001e5977,
+	0x0000e805,
+	0x0002718f,
+	0x00043b18,
+	0x000586a1,
+	0x0007502b,
+	0x0008d9b4,
+	0x000a68c9,
+	0x000bf252,
+	0x000dbbdc,
+	0x0011c7e5,
+	0x001390ee,
+	0x00151a78,
+	0x0016a906,
+	0x00183290,
+	0x0019bc19,
+	0x001b4822,
+	0x001cd12c,
+	0x001e9ab5,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint16 bdi_tbl_rev0[] = {
+	0x0070,
+	0x0126,
+	0x012c,
+	0x0246,
+	0x048d,
+	0x04d2,
+};
+
+CONST uint32 chanest_tbl_rev0[] = {
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+};
+
+CONST uint8 mcs_tbl_rev0[] = {
+	0x00,
+	0x08,
+	0x0a,
+	0x10,
+	0x12,
+	0x19,
+	0x1a,
+	0x1c,
+	0x40,
+	0x48,
+	0x4a,
+	0x50,
+	0x52,
+	0x59,
+	0x5a,
+	0x5c,
+	0x80,
+	0x88,
+	0x8a,
+	0x90,
+	0x92,
+	0x99,
+	0x9a,
+	0x9c,
+	0xc0,
+	0xc8,
+	0xca,
+	0xd0,
+	0xd2,
+	0xd9,
+	0xda,
+	0xdc,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x01,
+	0x02,
+	0x04,
+	0x08,
+	0x09,
+	0x0a,
+	0x0c,
+	0x10,
+	0x11,
+	0x12,
+	0x14,
+	0x18,
+	0x19,
+	0x1a,
+	0x1c,
+	0x20,
+	0x21,
+	0x22,
+	0x24,
+	0x40,
+	0x41,
+	0x42,
+	0x44,
+	0x48,
+	0x49,
+	0x4a,
+	0x4c,
+	0x50,
+	0x51,
+	0x52,
+	0x54,
+	0x58,
+	0x59,
+	0x5a,
+	0x5c,
+	0x60,
+	0x61,
+	0x62,
+	0x64,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+};
+
+CONST uint32 noise_var_tbl0_rev0[] = {
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+};
+
+CONST uint32 noise_var_tbl1_rev0[] = {
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+};
+
+CONST uint8 est_pwr_lut_core0_rev0[] = {
+	0x50,
+	0x4f,
+	0x4e,
+	0x4d,
+	0x4c,
+	0x4b,
+	0x4a,
+	0x49,
+	0x48,
+	0x47,
+	0x46,
+	0x45,
+	0x44,
+	0x43,
+	0x42,
+	0x41,
+	0x40,
+	0x3f,
+	0x3e,
+	0x3d,
+	0x3c,
+	0x3b,
+	0x3a,
+	0x39,
+	0x38,
+	0x37,
+	0x36,
+	0x35,
+	0x34,
+	0x33,
+	0x32,
+	0x31,
+	0x30,
+	0x2f,
+	0x2e,
+	0x2d,
+	0x2c,
+	0x2b,
+	0x2a,
+	0x29,
+	0x28,
+	0x27,
+	0x26,
+	0x25,
+	0x24,
+	0x23,
+	0x22,
+	0x21,
+	0x20,
+	0x1f,
+	0x1e,
+	0x1d,
+	0x1c,
+	0x1b,
+	0x1a,
+	0x19,
+	0x18,
+	0x17,
+	0x16,
+	0x15,
+	0x14,
+	0x13,
+	0x12,
+	0x11,
+};
+
+CONST uint8 est_pwr_lut_core1_rev0[] = {
+	0x50,
+	0x4f,
+	0x4e,
+	0x4d,
+	0x4c,
+	0x4b,
+	0x4a,
+	0x49,
+	0x48,
+	0x47,
+	0x46,
+	0x45,
+	0x44,
+	0x43,
+	0x42,
+	0x41,
+	0x40,
+	0x3f,
+	0x3e,
+	0x3d,
+	0x3c,
+	0x3b,
+	0x3a,
+	0x39,
+	0x38,
+	0x37,
+	0x36,
+	0x35,
+	0x34,
+	0x33,
+	0x32,
+	0x31,
+	0x30,
+	0x2f,
+	0x2e,
+	0x2d,
+	0x2c,
+	0x2b,
+	0x2a,
+	0x29,
+	0x28,
+	0x27,
+	0x26,
+	0x25,
+	0x24,
+	0x23,
+	0x22,
+	0x21,
+	0x20,
+	0x1f,
+	0x1e,
+	0x1d,
+	0x1c,
+	0x1b,
+	0x1a,
+	0x19,
+	0x18,
+	0x17,
+	0x16,
+	0x15,
+	0x14,
+	0x13,
+	0x12,
+	0x11,
+};
+
+CONST uint8 adj_pwr_lut_core0_rev0[] = {
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+};
+
+CONST uint8 adj_pwr_lut_core1_rev0[] = {
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+};
+
+CONST uint32 gainctrl_lut_core0_rev0[] = {
+	0x03cc2b44,
+	0x03cc2b42,
+	0x03cc2b40,
+	0x03cc2b3e,
+	0x03cc2b3d,
+	0x03cc2b3b,
+	0x03c82b44,
+	0x03c82b42,
+	0x03c82b40,
+	0x03c82b3e,
+	0x03c82b3d,
+	0x03c82b3b,
+	0x03c82b39,
+	0x03c82b38,
+	0x03c82b36,
+	0x03c82b34,
+	0x03c42b44,
+	0x03c42b42,
+	0x03c42b40,
+	0x03c42b3e,
+	0x03c42b3d,
+	0x03c42b3b,
+	0x03c42b39,
+	0x03c42b38,
+	0x03c42b36,
+	0x03c42b34,
+	0x03c42b33,
+	0x03c42b32,
+	0x03c42b30,
+	0x03c42b2f,
+	0x03c42b2d,
+	0x03c02b44,
+	0x03c02b42,
+	0x03c02b40,
+	0x03c02b3e,
+	0x03c02b3d,
+	0x03c02b3b,
+	0x03c02b39,
+	0x03c02b38,
+	0x03c02b36,
+	0x03c02b34,
+	0x03b02b44,
+	0x03b02b42,
+	0x03b02b40,
+	0x03b02b3e,
+	0x03b02b3d,
+	0x03b02b3b,
+	0x03b02b39,
+	0x03b02b38,
+	0x03b02b36,
+	0x03b02b34,
+	0x03b02b33,
+	0x03b02b32,
+	0x03b02b30,
+	0x03b02b2f,
+	0x03b02b2d,
+	0x03a02b44,
+	0x03a02b42,
+	0x03a02b40,
+	0x03a02b3e,
+	0x03a02b3d,
+	0x03a02b3b,
+	0x03a02b39,
+	0x03a02b38,
+	0x03a02b36,
+	0x03a02b34,
+	0x03902b44,
+	0x03902b42,
+	0x03902b40,
+	0x03902b3e,
+	0x03902b3d,
+	0x03902b3b,
+	0x03902b39,
+	0x03902b38,
+	0x03902b36,
+	0x03902b34,
+	0x03902b33,
+	0x03902b32,
+	0x03902b30,
+	0x03802b44,
+	0x03802b42,
+	0x03802b40,
+	0x03802b3e,
+	0x03802b3d,
+	0x03802b3b,
+	0x03802b39,
+	0x03802b38,
+	0x03802b36,
+	0x03802b34,
+	0x03802b33,
+	0x03802b32,
+	0x03802b30,
+	0x03802b2f,
+	0x03802b2d,
+	0x03802b2c,
+	0x03802b2b,
+	0x03802b2a,
+	0x03802b29,
+	0x03802b27,
+	0x03802b26,
+	0x03802b25,
+	0x03802b24,
+	0x03802b23,
+	0x03802b22,
+	0x03802b21,
+	0x03802b20,
+	0x03802b1f,
+	0x03802b1e,
+	0x03802b1e,
+	0x03802b1d,
+	0x03802b1c,
+	0x03802b1b,
+	0x03802b1a,
+	0x03802b1a,
+	0x03802b19,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x00002b00,
+};
+
+CONST uint32 gainctrl_lut_core1_rev0[] = {
+	0x03cc2b44,
+	0x03cc2b42,
+	0x03cc2b40,
+	0x03cc2b3e,
+	0x03cc2b3d,
+	0x03cc2b3b,
+	0x03c82b44,
+	0x03c82b42,
+	0x03c82b40,
+	0x03c82b3e,
+	0x03c82b3d,
+	0x03c82b3b,
+	0x03c82b39,
+	0x03c82b38,
+	0x03c82b36,
+	0x03c82b34,
+	0x03c42b44,
+	0x03c42b42,
+	0x03c42b40,
+	0x03c42b3e,
+	0x03c42b3d,
+	0x03c42b3b,
+	0x03c42b39,
+	0x03c42b38,
+	0x03c42b36,
+	0x03c42b34,
+	0x03c42b33,
+	0x03c42b32,
+	0x03c42b30,
+	0x03c42b2f,
+	0x03c42b2d,
+	0x03c02b44,
+	0x03c02b42,
+	0x03c02b40,
+	0x03c02b3e,
+	0x03c02b3d,
+	0x03c02b3b,
+	0x03c02b39,
+	0x03c02b38,
+	0x03c02b36,
+	0x03c02b34,
+	0x03b02b44,
+	0x03b02b42,
+	0x03b02b40,
+	0x03b02b3e,
+	0x03b02b3d,
+	0x03b02b3b,
+	0x03b02b39,
+	0x03b02b38,
+	0x03b02b36,
+	0x03b02b34,
+	0x03b02b33,
+	0x03b02b32,
+	0x03b02b30,
+	0x03b02b2f,
+	0x03b02b2d,
+	0x03a02b44,
+	0x03a02b42,
+	0x03a02b40,
+	0x03a02b3e,
+	0x03a02b3d,
+	0x03a02b3b,
+	0x03a02b39,
+	0x03a02b38,
+	0x03a02b36,
+	0x03a02b34,
+	0x03902b44,
+	0x03902b42,
+	0x03902b40,
+	0x03902b3e,
+	0x03902b3d,
+	0x03902b3b,
+	0x03902b39,
+	0x03902b38,
+	0x03902b36,
+	0x03902b34,
+	0x03902b33,
+	0x03902b32,
+	0x03902b30,
+	0x03802b44,
+	0x03802b42,
+	0x03802b40,
+	0x03802b3e,
+	0x03802b3d,
+	0x03802b3b,
+	0x03802b39,
+	0x03802b38,
+	0x03802b36,
+	0x03802b34,
+	0x03802b33,
+	0x03802b32,
+	0x03802b30,
+	0x03802b2f,
+	0x03802b2d,
+	0x03802b2c,
+	0x03802b2b,
+	0x03802b2a,
+	0x03802b29,
+	0x03802b27,
+	0x03802b26,
+	0x03802b25,
+	0x03802b24,
+	0x03802b23,
+	0x03802b22,
+	0x03802b21,
+	0x03802b20,
+	0x03802b1f,
+	0x03802b1e,
+	0x03802b1e,
+	0x03802b1d,
+	0x03802b1c,
+	0x03802b1b,
+	0x03802b1a,
+	0x03802b1a,
+	0x03802b19,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x03802b18,
+	0x00002b00,
+};
+
+CONST uint32 iq_lut_core0_rev0[] = {
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+};
+
+CONST uint32 iq_lut_core1_rev0[] = {
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+	0x0000007f,
+};
+
+CONST uint16 loft_lut_core0_rev0[] = {
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+};
+
+CONST uint16 loft_lut_core1_rev0[] = {
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+	0x0000,
+	0x0101,
+	0x0002,
+	0x0103,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev0_volatile[] = {
+	{&bdi_tbl_rev0, sizeof(bdi_tbl_rev0) / sizeof(bdi_tbl_rev0[0]), 21, 0,
+	 16}
+	,
+	{&pltlut_tbl_rev0, sizeof(pltlut_tbl_rev0) / sizeof(pltlut_tbl_rev0[0]),
+	 20, 0, 32}
+	,
+	{&gainctrl_lut_core0_rev0,
+	 sizeof(gainctrl_lut_core0_rev0) / sizeof(gainctrl_lut_core0_rev0[0]),
+	 26, 192, 32}
+	,
+	{&gainctrl_lut_core1_rev0,
+	 sizeof(gainctrl_lut_core1_rev0) / sizeof(gainctrl_lut_core1_rev0[0]),
+	 27, 192, 32}
+	,
+
+	{&est_pwr_lut_core0_rev0,
+	 sizeof(est_pwr_lut_core0_rev0) / sizeof(est_pwr_lut_core0_rev0[0]), 26,
+	 0, 8}
+	,
+	{&est_pwr_lut_core1_rev0,
+	 sizeof(est_pwr_lut_core1_rev0) / sizeof(est_pwr_lut_core1_rev0[0]), 27,
+	 0, 8}
+	,
+	{&adj_pwr_lut_core0_rev0,
+	 sizeof(adj_pwr_lut_core0_rev0) / sizeof(adj_pwr_lut_core0_rev0[0]), 26,
+	 64, 8}
+	,
+	{&adj_pwr_lut_core1_rev0,
+	 sizeof(adj_pwr_lut_core1_rev0) / sizeof(adj_pwr_lut_core1_rev0[0]), 27,
+	 64, 8}
+	,
+	{&iq_lut_core0_rev0,
+	 sizeof(iq_lut_core0_rev0) / sizeof(iq_lut_core0_rev0[0]), 26, 320, 32}
+	,
+	{&iq_lut_core1_rev0,
+	 sizeof(iq_lut_core1_rev0) / sizeof(iq_lut_core1_rev0[0]), 27, 320, 32}
+	,
+	{&loft_lut_core0_rev0,
+	 sizeof(loft_lut_core0_rev0) / sizeof(loft_lut_core0_rev0[0]), 26, 448,
+	 16}
+	,
+	{&loft_lut_core1_rev0,
+	 sizeof(loft_lut_core1_rev0) / sizeof(loft_lut_core1_rev0[0]), 27, 448,
+	 16}
+	,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev0[] = {
+	{&frame_struct_rev0,
+	 sizeof(frame_struct_rev0) / sizeof(frame_struct_rev0[0]), 10, 0, 32}
+	,
+	{&frame_lut_rev0, sizeof(frame_lut_rev0) / sizeof(frame_lut_rev0[0]),
+	 24, 0, 8}
+	,
+	{&tmap_tbl_rev0, sizeof(tmap_tbl_rev0) / sizeof(tmap_tbl_rev0[0]), 12,
+	 0, 32}
+	,
+	{&tdtrn_tbl_rev0, sizeof(tdtrn_tbl_rev0) / sizeof(tdtrn_tbl_rev0[0]),
+	 14, 0, 32}
+	,
+	{&intlv_tbl_rev0, sizeof(intlv_tbl_rev0) / sizeof(intlv_tbl_rev0[0]),
+	 13, 0, 32}
+	,
+	{&pilot_tbl_rev0, sizeof(pilot_tbl_rev0) / sizeof(pilot_tbl_rev0[0]),
+	 11, 0, 16}
+	,
+	{&tdi_tbl20_ant0_rev0,
+	 sizeof(tdi_tbl20_ant0_rev0) / sizeof(tdi_tbl20_ant0_rev0[0]), 19, 128,
+	 32}
+	,
+	{&tdi_tbl20_ant1_rev0,
+	 sizeof(tdi_tbl20_ant1_rev0) / sizeof(tdi_tbl20_ant1_rev0[0]), 19, 256,
+	 32}
+	,
+	{&tdi_tbl40_ant0_rev0,
+	 sizeof(tdi_tbl40_ant0_rev0) / sizeof(tdi_tbl40_ant0_rev0[0]), 19, 640,
+	 32}
+	,
+	{&tdi_tbl40_ant1_rev0,
+	 sizeof(tdi_tbl40_ant1_rev0) / sizeof(tdi_tbl40_ant1_rev0[0]), 19, 768,
+	 32}
+	,
+	{&chanest_tbl_rev0,
+	 sizeof(chanest_tbl_rev0) / sizeof(chanest_tbl_rev0[0]), 22, 0, 32}
+	,
+	{&mcs_tbl_rev0, sizeof(mcs_tbl_rev0) / sizeof(mcs_tbl_rev0[0]), 18, 0, 8}
+	,
+	{&noise_var_tbl0_rev0,
+	 sizeof(noise_var_tbl0_rev0) / sizeof(noise_var_tbl0_rev0[0]), 16, 0,
+	 32}
+	,
+	{&noise_var_tbl1_rev0,
+	 sizeof(noise_var_tbl1_rev0) / sizeof(noise_var_tbl1_rev0[0]), 16, 128,
+	 32}
+	,
+};
+
+CONST uint32 mimophytbl_info_sz_rev0 =
+    sizeof(mimophytbl_info_rev0) / sizeof(mimophytbl_info_rev0[0]);
+CONST uint32 mimophytbl_info_sz_rev0_volatile =
+    sizeof(mimophytbl_info_rev0_volatile) /
+    sizeof(mimophytbl_info_rev0_volatile[0]);
+
+CONST uint16 ant_swctrl_tbl_rev3[] = {
+	0x0082,
+	0x0082,
+	0x0211,
+	0x0222,
+	0x0328,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0144,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0188,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0082,
+	0x0082,
+	0x0211,
+	0x0222,
+	0x0328,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0144,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0188,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+CONST uint16 ant_swctrl_tbl_rev3_1[] = {
+	0x0022,
+	0x0022,
+	0x0011,
+	0x0022,
+	0x0022,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0011,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0022,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0022,
+	0x0022,
+	0x0011,
+	0x0022,
+	0x0022,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0011,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0022,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+CONST uint16 ant_swctrl_tbl_rev3_2[] = {
+	0x0088,
+	0x0088,
+	0x0044,
+	0x0088,
+	0x0088,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0044,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0088,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0088,
+	0x0088,
+	0x0044,
+	0x0088,
+	0x0088,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0044,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0088,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+CONST uint16 ant_swctrl_tbl_rev3_3[] = {
+	0x022,
+	0x022,
+	0x011,
+	0x022,
+	0x000,
+	0x000,
+	0x000,
+	0x000,
+	0x011,
+	0x000,
+	0x000,
+	0x000,
+	0x022,
+	0x000,
+	0x000,
+	0x3cc,
+	0x022,
+	0x022,
+	0x011,
+	0x022,
+	0x000,
+	0x000,
+	0x000,
+	0x000,
+	0x011,
+	0x000,
+	0x000,
+	0x000,
+	0x022,
+	0x000,
+	0x000,
+	0x3cc
+};
+
+CONST uint32 frame_struct_rev3[] = {
+	0x08004a04,
+	0x00100000,
+	0x01000a05,
+	0x00100020,
+	0x09804506,
+	0x00100030,
+	0x09804507,
+	0x00100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a0c,
+	0x00100004,
+	0x01000a0d,
+	0x00100024,
+	0x0980450e,
+	0x00100034,
+	0x0980450f,
+	0x00100034,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a04,
+	0x00100000,
+	0x11008a05,
+	0x00100020,
+	0x1980c506,
+	0x00100030,
+	0x21810506,
+	0x00100030,
+	0x21810506,
+	0x00100030,
+	0x01800504,
+	0x00100030,
+	0x11808505,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000a04,
+	0x00100000,
+	0x11008a05,
+	0x00100020,
+	0x21810506,
+	0x00100030,
+	0x21810506,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a0c,
+	0x00100008,
+	0x11008a0d,
+	0x00100028,
+	0x1980c50e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x0180050c,
+	0x00100038,
+	0x1180850d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000a0c,
+	0x00100008,
+	0x11008a0d,
+	0x00100028,
+	0x2181050e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a04,
+	0x00100000,
+	0x01000a05,
+	0x00100020,
+	0x1980c506,
+	0x00100030,
+	0x1980c506,
+	0x00100030,
+	0x11808504,
+	0x00100030,
+	0x3981ca05,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x10008a04,
+	0x00100000,
+	0x3981ca05,
+	0x00100030,
+	0x1980c506,
+	0x00100030,
+	0x29814507,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a0c,
+	0x00100008,
+	0x01000a0d,
+	0x00100028,
+	0x1980c50e,
+	0x00100038,
+	0x1980c50e,
+	0x00100038,
+	0x1180850c,
+	0x00100038,
+	0x3981ca0d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x10008a0c,
+	0x00100008,
+	0x3981ca0d,
+	0x00100038,
+	0x1980c50e,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x00100000,
+	0x02001405,
+	0x00100040,
+	0x0b004a06,
+	0x01900060,
+	0x13008a06,
+	0x01900060,
+	0x13008a06,
+	0x01900060,
+	0x43020a04,
+	0x00100060,
+	0x1b00ca05,
+	0x00100060,
+	0x23010a07,
+	0x01500060,
+	0x40021404,
+	0x00100000,
+	0x1a00d405,
+	0x00100040,
+	0x13008a06,
+	0x01900060,
+	0x13008a06,
+	0x01900060,
+	0x23010a07,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x0200140d,
+	0x00100050,
+	0x0b004a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x43020a0c,
+	0x00100070,
+	0x1b00ca0d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x13008a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x50029404,
+	0x00100000,
+	0x32019405,
+	0x00100040,
+	0x0b004a06,
+	0x01900060,
+	0x0b004a06,
+	0x01900060,
+	0x5b02ca04,
+	0x00100060,
+	0x3b01d405,
+	0x00100060,
+	0x23010a07,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x5802d404,
+	0x00100000,
+	0x3b01d405,
+	0x00100060,
+	0x0b004a06,
+	0x01900060,
+	0x23010a07,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x5002940c,
+	0x00100010,
+	0x3201940d,
+	0x00100050,
+	0x0b004a0e,
+	0x01900070,
+	0x0b004a0e,
+	0x01900070,
+	0x5b02ca0c,
+	0x00100070,
+	0x3b01d40d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x5802d40c,
+	0x00100010,
+	0x3b01d40d,
+	0x00100070,
+	0x0b004a0e,
+	0x01900070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x000f4800,
+	0x62031405,
+	0x00100040,
+	0x53028a06,
+	0x01900060,
+	0x53028a07,
+	0x01900060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x000f4808,
+	0x6203140d,
+	0x00100048,
+	0x53028a0e,
+	0x01900068,
+	0x53028a0f,
+	0x01900068,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a0c,
+	0x00100004,
+	0x11008a0d,
+	0x00100024,
+	0x1980c50e,
+	0x00100034,
+	0x2181050e,
+	0x00100034,
+	0x2181050e,
+	0x00100034,
+	0x0180050c,
+	0x00100038,
+	0x1180850d,
+	0x00100038,
+	0x1181850d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000a0c,
+	0x00100008,
+	0x11008a0d,
+	0x00100028,
+	0x2181050e,
+	0x00100038,
+	0x2181050e,
+	0x00100038,
+	0x1181850d,
+	0x00100038,
+	0x2981450f,
+	0x01100038,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x08004a04,
+	0x00100000,
+	0x01000a05,
+	0x00100020,
+	0x0180c506,
+	0x00100030,
+	0x0180c506,
+	0x00100030,
+	0x2180c50c,
+	0x00100030,
+	0x49820a0d,
+	0x0016a130,
+	0x41824a0d,
+	0x0016a130,
+	0x2981450f,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x2000ca0c,
+	0x00100000,
+	0x49820a0d,
+	0x0016a130,
+	0x1980c50e,
+	0x00100030,
+	0x41824a0d,
+	0x0016a130,
+	0x2981450f,
+	0x01100030,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100008,
+	0x0200140d,
+	0x00100048,
+	0x0b004a0e,
+	0x01900068,
+	0x13008a0e,
+	0x01900068,
+	0x13008a0e,
+	0x01900068,
+	0x43020a0c,
+	0x00100070,
+	0x1b00ca0d,
+	0x00100070,
+	0x1b014a0d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x13008a0e,
+	0x01900070,
+	0x13008a0e,
+	0x01900070,
+	0x1b014a0d,
+	0x00100070,
+	0x23010a0f,
+	0x01500070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x50029404,
+	0x00100000,
+	0x32019405,
+	0x00100040,
+	0x03004a06,
+	0x01900060,
+	0x03004a06,
+	0x01900060,
+	0x6b030a0c,
+	0x00100060,
+	0x4b02140d,
+	0x0016a160,
+	0x4302540d,
+	0x0016a160,
+	0x23010a0f,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x6b03140c,
+	0x00100060,
+	0x4b02140d,
+	0x0016a160,
+	0x0b004a0e,
+	0x01900060,
+	0x4302540d,
+	0x0016a160,
+	0x23010a0f,
+	0x01500060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x00100000,
+	0x1a00d405,
+	0x00100040,
+	0x53028a06,
+	0x01900060,
+	0x5b02ca06,
+	0x01900060,
+	0x5b02ca06,
+	0x01900060,
+	0x43020a04,
+	0x00100060,
+	0x1b00ca05,
+	0x00100060,
+	0x53028a07,
+	0x0190c060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x53028a0e,
+	0x01900070,
+	0x5b02ca0e,
+	0x01900070,
+	0x5b02ca0e,
+	0x01900070,
+	0x43020a0c,
+	0x00100070,
+	0x1b00ca0d,
+	0x00100070,
+	0x53028a0f,
+	0x0190c070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x40021404,
+	0x00100000,
+	0x1a00d405,
+	0x00100040,
+	0x5b02ca06,
+	0x01900060,
+	0x5b02ca06,
+	0x01900060,
+	0x53028a07,
+	0x0190c060,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x4002140c,
+	0x00100010,
+	0x1a00d40d,
+	0x00100050,
+	0x5b02ca0e,
+	0x01900070,
+	0x5b02ca0e,
+	0x01900070,
+	0x53028a0f,
+	0x0190c070,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint16 pilot_tbl_rev3[] = {
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0xff08,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0x80d5,
+	0xff0a,
+	0xff82,
+	0xffa0,
+	0xff28,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xff82,
+	0xffa0,
+	0xff28,
+	0xff0a,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xffff,
+	0xf83f,
+	0xfa1f,
+	0xfa97,
+	0xfab5,
+	0xf2bd,
+	0xf0bf,
+	0xffff,
+	0xffff,
+	0xf017,
+	0xf815,
+	0xf215,
+	0xf095,
+	0xf035,
+	0xf01d,
+	0xffff,
+	0xffff,
+	0xff08,
+	0xff02,
+	0xff80,
+	0xff20,
+	0xff08,
+	0xff02,
+	0xff80,
+	0xff20,
+	0xf01f,
+	0xf817,
+	0xfa15,
+	0xf295,
+	0xf0b5,
+	0xf03d,
+	0xffff,
+	0xffff,
+	0xf82a,
+	0xfa0a,
+	0xfa82,
+	0xfaa0,
+	0xf2a8,
+	0xf0aa,
+	0xffff,
+	0xffff,
+	0xf002,
+	0xf800,
+	0xf200,
+	0xf080,
+	0xf020,
+	0xf008,
+	0xffff,
+	0xffff,
+	0xf00a,
+	0xf802,
+	0xfa00,
+	0xf280,
+	0xf0a0,
+	0xf028,
+	0xffff,
+	0xffff,
+};
+
+CONST uint32 tmap_tbl_rev3[] = {
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00000111,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x000aa888,
+	0x88880000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa2222220,
+	0x22222222,
+	0x22c22222,
+	0x00000222,
+	0x22000000,
+	0x2222a222,
+	0x22222222,
+	0x222222a2,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00011111,
+	0x11110000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0xa8aa88a0,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x00088aaa,
+	0xaaaa0000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xaaa8aaa0,
+	0x8aaa8aaa,
+	0xaa8a8a8a,
+	0x000aaa88,
+	0x8aaa0000,
+	0xaaa8a888,
+	0x8aa88a8a,
+	0x8a88a888,
+	0x08080a00,
+	0x0a08080a,
+	0x080a0a08,
+	0x00080808,
+	0x080a0000,
+	0x080a0808,
+	0x080a0808,
+	0x0a0a0a08,
+	0xa0a0a0a0,
+	0x80a0a080,
+	0x8080a0a0,
+	0x00008080,
+	0x80a00000,
+	0x80a080a0,
+	0xa080a0a0,
+	0x8080a0a0,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x99999000,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb90,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00aaa888,
+	0x22000000,
+	0x2222b222,
+	0x22222222,
+	0x222222b2,
+	0xb2222220,
+	0x22222222,
+	0x22d22222,
+	0x00000222,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x33000000,
+	0x3333b333,
+	0x33333333,
+	0x333333b3,
+	0xb3333330,
+	0x33333333,
+	0x33d33333,
+	0x00000333,
+	0x22000000,
+	0x2222a222,
+	0x22222222,
+	0x222222a2,
+	0xa2222220,
+	0x22222222,
+	0x22c22222,
+	0x00000222,
+	0x99b99b00,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb99,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x08aaa888,
+	0x22222200,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0x22222222,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x11111111,
+	0xf1111111,
+	0x11111111,
+	0x11f11111,
+	0x01111111,
+	0xbb9bb900,
+	0xb9b9bb99,
+	0xb99bbbbb,
+	0xbbbb9b9b,
+	0xb9bb99bb,
+	0xb99999b9,
+	0xb9b9b99b,
+	0x00000bbb,
+	0xaa000000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xa8aa88aa,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x0a888aaa,
+	0xaa000000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xa8aa88a0,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x00000aaa,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0xbbbbbb00,
+	0x999bbbbb,
+	0x9bb99b9b,
+	0xb9b9b9bb,
+	0xb9b99bbb,
+	0xb9b9b9bb,
+	0xb9bb9b99,
+	0x00000999,
+	0x8a000000,
+	0xaa88a888,
+	0xa88888aa,
+	0xa88a8a88,
+	0xa88aa88a,
+	0x88a8aaaa,
+	0xa8aa8aaa,
+	0x0888a88a,
+	0x0b0b0b00,
+	0x090b0b0b,
+	0x0b090b0b,
+	0x0909090b,
+	0x09090b0b,
+	0x09090b0b,
+	0x09090b09,
+	0x00000909,
+	0x0a000000,
+	0x0a080808,
+	0x080a080a,
+	0x080a0a08,
+	0x080a080a,
+	0x0808080a,
+	0x0a0a0a08,
+	0x0808080a,
+	0xb0b0b000,
+	0x9090b0b0,
+	0x90b09090,
+	0xb0b0b090,
+	0xb0b090b0,
+	0x90b0b0b0,
+	0xb0b09090,
+	0x00000090,
+	0x80000000,
+	0xa080a080,
+	0xa08080a0,
+	0xa0808080,
+	0xa080a080,
+	0x80a0a0a0,
+	0xa0a080a0,
+	0x00a0a0a0,
+	0x22000000,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0xf2222220,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00000111,
+	0x33000000,
+	0x3333f333,
+	0x33333333,
+	0x333333f3,
+	0xf3333330,
+	0x33333333,
+	0x33f33333,
+	0x00000333,
+	0x22000000,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0xf2222220,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x99000000,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb90,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88888000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00aaa888,
+	0x88a88a00,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x08aaa888,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 intlv_tbl_rev3[] = {
+	0x00802070,
+	0x0671188d,
+	0x0a60192c,
+	0x0a300e46,
+	0x00c1188d,
+	0x080024d2,
+	0x00000070,
+};
+
+CONST uint32 tdtrn_tbl_rev3[] = {
+	0x061c061c,
+	0x0050ee68,
+	0xf592fe36,
+	0xfe5212f6,
+	0x00000c38,
+	0xfe5212f6,
+	0xf592fe36,
+	0x0050ee68,
+	0x061c061c,
+	0xee680050,
+	0xfe36f592,
+	0x12f6fe52,
+	0x0c380000,
+	0x12f6fe52,
+	0xfe36f592,
+	0xee680050,
+	0x061c061c,
+	0x0050ee68,
+	0xf592fe36,
+	0xfe5212f6,
+	0x00000c38,
+	0xfe5212f6,
+	0xf592fe36,
+	0x0050ee68,
+	0x061c061c,
+	0xee680050,
+	0xfe36f592,
+	0x12f6fe52,
+	0x0c380000,
+	0x12f6fe52,
+	0xfe36f592,
+	0xee680050,
+	0x05e305e3,
+	0x004def0c,
+	0xf5f3fe47,
+	0xfe611246,
+	0x00000bc7,
+	0xfe611246,
+	0xf5f3fe47,
+	0x004def0c,
+	0x05e305e3,
+	0xef0c004d,
+	0xfe47f5f3,
+	0x1246fe61,
+	0x0bc70000,
+	0x1246fe61,
+	0xfe47f5f3,
+	0xef0c004d,
+	0x05e305e3,
+	0x004def0c,
+	0xf5f3fe47,
+	0xfe611246,
+	0x00000bc7,
+	0xfe611246,
+	0xf5f3fe47,
+	0x004def0c,
+	0x05e305e3,
+	0xef0c004d,
+	0xfe47f5f3,
+	0x1246fe61,
+	0x0bc70000,
+	0x1246fe61,
+	0xfe47f5f3,
+	0xef0c004d,
+	0xfa58fa58,
+	0xf895043b,
+	0xff4c09c0,
+	0xfbc6ffa8,
+	0xfb84f384,
+	0x0798f6f9,
+	0x05760122,
+	0x058409f6,
+	0x0b500000,
+	0x05b7f542,
+	0x08860432,
+	0x06ddfee7,
+	0xfb84f384,
+	0xf9d90664,
+	0xf7e8025c,
+	0x00fff7bd,
+	0x05a805a8,
+	0xf7bd00ff,
+	0x025cf7e8,
+	0x0664f9d9,
+	0xf384fb84,
+	0xfee706dd,
+	0x04320886,
+	0xf54205b7,
+	0x00000b50,
+	0x09f60584,
+	0x01220576,
+	0xf6f90798,
+	0xf384fb84,
+	0xffa8fbc6,
+	0x09c0ff4c,
+	0x043bf895,
+	0x02d402d4,
+	0x07de0270,
+	0xfc96079c,
+	0xf90afe94,
+	0xfe00ff2c,
+	0x02d4065d,
+	0x092a0096,
+	0x0014fbb8,
+	0xfd2cfd2c,
+	0x076afb3c,
+	0x0096f752,
+	0xf991fd87,
+	0xfb2c0200,
+	0xfeb8f960,
+	0x08e0fc96,
+	0x049802a8,
+	0xfd2cfd2c,
+	0x02a80498,
+	0xfc9608e0,
+	0xf960feb8,
+	0x0200fb2c,
+	0xfd87f991,
+	0xf7520096,
+	0xfb3c076a,
+	0xfd2cfd2c,
+	0xfbb80014,
+	0x0096092a,
+	0x065d02d4,
+	0xff2cfe00,
+	0xfe94f90a,
+	0x079cfc96,
+	0x027007de,
+	0x02d402d4,
+	0x027007de,
+	0x079cfc96,
+	0xfe94f90a,
+	0xff2cfe00,
+	0x065d02d4,
+	0x0096092a,
+	0xfbb80014,
+	0xfd2cfd2c,
+	0xfb3c076a,
+	0xf7520096,
+	0xfd87f991,
+	0x0200fb2c,
+	0xf960feb8,
+	0xfc9608e0,
+	0x02a80498,
+	0xfd2cfd2c,
+	0x049802a8,
+	0x08e0fc96,
+	0xfeb8f960,
+	0xfb2c0200,
+	0xf991fd87,
+	0x0096f752,
+	0x076afb3c,
+	0xfd2cfd2c,
+	0x0014fbb8,
+	0x092a0096,
+	0x02d4065d,
+	0xfe00ff2c,
+	0xf90afe94,
+	0xfc96079c,
+	0x07de0270,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x062a0000,
+	0xfefa0759,
+	0x08b80908,
+	0xf396fc2d,
+	0xf9d6045c,
+	0xfc4ef608,
+	0xf748f596,
+	0x07b207bf,
+	0x062a062a,
+	0xf84ef841,
+	0xf748f596,
+	0x03b209f8,
+	0xf9d6045c,
+	0x0c6a03d3,
+	0x08b80908,
+	0x0106f8a7,
+	0x062a0000,
+	0xfefaf8a7,
+	0x08b8f6f8,
+	0xf39603d3,
+	0xf9d6fba4,
+	0xfc4e09f8,
+	0xf7480a6a,
+	0x07b2f841,
+	0x062af9d6,
+	0xf84e07bf,
+	0xf7480a6a,
+	0x03b2f608,
+	0xf9d6fba4,
+	0x0c6afc2d,
+	0x08b8f6f8,
+	0x01060759,
+	0x062a0000,
+	0xfefa0759,
+	0x08b80908,
+	0xf396fc2d,
+	0xf9d6045c,
+	0xfc4ef608,
+	0xf748f596,
+	0x07b207bf,
+	0x062a062a,
+	0xf84ef841,
+	0xf748f596,
+	0x03b209f8,
+	0xf9d6045c,
+	0x0c6a03d3,
+	0x08b80908,
+	0x0106f8a7,
+	0x062a0000,
+	0xfefaf8a7,
+	0x08b8f6f8,
+	0xf39603d3,
+	0xf9d6fba4,
+	0xfc4e09f8,
+	0xf7480a6a,
+	0x07b2f841,
+	0x062af9d6,
+	0xf84e07bf,
+	0xf7480a6a,
+	0x03b2f608,
+	0xf9d6fba4,
+	0x0c6afc2d,
+	0x08b8f6f8,
+	0x01060759,
+	0x061c061c,
+	0xff30009d,
+	0xffb21141,
+	0xfd87fb54,
+	0xf65dfe59,
+	0x02eef99e,
+	0x0166f03c,
+	0xfff809b6,
+	0x000008a4,
+	0x000af42b,
+	0x00eff577,
+	0xfa840bf2,
+	0xfc02ff51,
+	0x08260f67,
+	0xfff0036f,
+	0x0842f9c3,
+	0x00000000,
+	0x063df7be,
+	0xfc910010,
+	0xf099f7da,
+	0x00af03fe,
+	0xf40e057c,
+	0x0a89ff11,
+	0x0bd5fff6,
+	0xf75c0000,
+	0xf64a0008,
+	0x0fc4fe9a,
+	0x0662fd12,
+	0x01a709a3,
+	0x04ac0279,
+	0xeebf004e,
+	0xff6300d0,
+	0xf9e4f9e4,
+	0x00d0ff63,
+	0x004eeebf,
+	0x027904ac,
+	0x09a301a7,
+	0xfd120662,
+	0xfe9a0fc4,
+	0x0008f64a,
+	0x0000f75c,
+	0xfff60bd5,
+	0xff110a89,
+	0x057cf40e,
+	0x03fe00af,
+	0xf7daf099,
+	0x0010fc91,
+	0xf7be063d,
+	0x00000000,
+	0xf9c30842,
+	0x036ffff0,
+	0x0f670826,
+	0xff51fc02,
+	0x0bf2fa84,
+	0xf57700ef,
+	0xf42b000a,
+	0x08a40000,
+	0x09b6fff8,
+	0xf03c0166,
+	0xf99e02ee,
+	0xfe59f65d,
+	0xfb54fd87,
+	0x1141ffb2,
+	0x009dff30,
+	0x05e30000,
+	0xff060705,
+	0x085408a0,
+	0xf425fc59,
+	0xfa1d042a,
+	0xfc78f67a,
+	0xf7acf60e,
+	0x075a0766,
+	0x05e305e3,
+	0xf8a6f89a,
+	0xf7acf60e,
+	0x03880986,
+	0xfa1d042a,
+	0x0bdb03a7,
+	0x085408a0,
+	0x00faf8fb,
+	0x05e30000,
+	0xff06f8fb,
+	0x0854f760,
+	0xf42503a7,
+	0xfa1dfbd6,
+	0xfc780986,
+	0xf7ac09f2,
+	0x075af89a,
+	0x05e3fa1d,
+	0xf8a60766,
+	0xf7ac09f2,
+	0x0388f67a,
+	0xfa1dfbd6,
+	0x0bdbfc59,
+	0x0854f760,
+	0x00fa0705,
+	0x05e30000,
+	0xff060705,
+	0x085408a0,
+	0xf425fc59,
+	0xfa1d042a,
+	0xfc78f67a,
+	0xf7acf60e,
+	0x075a0766,
+	0x05e305e3,
+	0xf8a6f89a,
+	0xf7acf60e,
+	0x03880986,
+	0xfa1d042a,
+	0x0bdb03a7,
+	0x085408a0,
+	0x00faf8fb,
+	0x05e30000,
+	0xff06f8fb,
+	0x0854f760,
+	0xf42503a7,
+	0xfa1dfbd6,
+	0xfc780986,
+	0xf7ac09f2,
+	0x075af89a,
+	0x05e3fa1d,
+	0xf8a60766,
+	0xf7ac09f2,
+	0x0388f67a,
+	0xfa1dfbd6,
+	0x0bdbfc59,
+	0x0854f760,
+	0x00fa0705,
+	0xfa58fa58,
+	0xf8f0fe00,
+	0x0448073d,
+	0xfdc9fe46,
+	0xf9910258,
+	0x089d0407,
+	0xfd5cf71a,
+	0x02affde0,
+	0x083e0496,
+	0xff5a0740,
+	0xff7afd97,
+	0x00fe01f1,
+	0x0009082e,
+	0xfa94ff75,
+	0xfecdf8ea,
+	0xffb0f693,
+	0xfd2cfa58,
+	0x0433ff16,
+	0xfba405dd,
+	0xfa610341,
+	0x06a606cb,
+	0x0039fd2d,
+	0x0677fa97,
+	0x01fa05e0,
+	0xf896003e,
+	0x075a068b,
+	0x012cfc3e,
+	0xfa23f98d,
+	0xfc7cfd43,
+	0xff90fc0d,
+	0x01c10982,
+	0x00c601d6,
+	0xfd2cfd2c,
+	0x01d600c6,
+	0x098201c1,
+	0xfc0dff90,
+	0xfd43fc7c,
+	0xf98dfa23,
+	0xfc3e012c,
+	0x068b075a,
+	0x003ef896,
+	0x05e001fa,
+	0xfa970677,
+	0xfd2d0039,
+	0x06cb06a6,
+	0x0341fa61,
+	0x05ddfba4,
+	0xff160433,
+	0xfa58fd2c,
+	0xf693ffb0,
+	0xf8eafecd,
+	0xff75fa94,
+	0x082e0009,
+	0x01f100fe,
+	0xfd97ff7a,
+	0x0740ff5a,
+	0x0496083e,
+	0xfde002af,
+	0xf71afd5c,
+	0x0407089d,
+	0x0258f991,
+	0xfe46fdc9,
+	0x073d0448,
+	0xfe00f8f0,
+	0xfd2cfd2c,
+	0xfce00500,
+	0xfc09fddc,
+	0xfe680157,
+	0x04c70571,
+	0xfc3aff21,
+	0xfcd70228,
+	0x056d0277,
+	0x0200fe00,
+	0x0022f927,
+	0xfe3c032b,
+	0xfc44ff3c,
+	0x03e9fbdb,
+	0x04570313,
+	0x04c9ff5c,
+	0x000d03b8,
+	0xfa580000,
+	0xfbe900d2,
+	0xf9d0fe0b,
+	0x0125fdf9,
+	0x042501bf,
+	0x0328fa2b,
+	0xffa902f0,
+	0xfa250157,
+	0x0200fe00,
+	0x03740438,
+	0xff0405fd,
+	0x030cfe52,
+	0x0037fb39,
+	0xff6904c5,
+	0x04f8fd23,
+	0xfd31fc1b,
+	0xfd2cfd2c,
+	0xfc1bfd31,
+	0xfd2304f8,
+	0x04c5ff69,
+	0xfb390037,
+	0xfe52030c,
+	0x05fdff04,
+	0x04380374,
+	0xfe000200,
+	0x0157fa25,
+	0x02f0ffa9,
+	0xfa2b0328,
+	0x01bf0425,
+	0xfdf90125,
+	0xfe0bf9d0,
+	0x00d2fbe9,
+	0x0000fa58,
+	0x03b8000d,
+	0xff5c04c9,
+	0x03130457,
+	0xfbdb03e9,
+	0xff3cfc44,
+	0x032bfe3c,
+	0xf9270022,
+	0xfe000200,
+	0x0277056d,
+	0x0228fcd7,
+	0xff21fc3a,
+	0x057104c7,
+	0x0157fe68,
+	0xfddcfc09,
+	0x0500fce0,
+	0xfd2cfd2c,
+	0x0500fce0,
+	0xfddcfc09,
+	0x0157fe68,
+	0x057104c7,
+	0xff21fc3a,
+	0x0228fcd7,
+	0x0277056d,
+	0xfe000200,
+	0xf9270022,
+	0x032bfe3c,
+	0xff3cfc44,
+	0xfbdb03e9,
+	0x03130457,
+	0xff5c04c9,
+	0x03b8000d,
+	0x0000fa58,
+	0x00d2fbe9,
+	0xfe0bf9d0,
+	0xfdf90125,
+	0x01bf0425,
+	0xfa2b0328,
+	0x02f0ffa9,
+	0x0157fa25,
+	0xfe000200,
+	0x04380374,
+	0x05fdff04,
+	0xfe52030c,
+	0xfb390037,
+	0x04c5ff69,
+	0xfd2304f8,
+	0xfc1bfd31,
+	0xfd2cfd2c,
+	0xfd31fc1b,
+	0x04f8fd23,
+	0xff6904c5,
+	0x0037fb39,
+	0x030cfe52,
+	0xff0405fd,
+	0x03740438,
+	0x0200fe00,
+	0xfa250157,
+	0xffa902f0,
+	0x0328fa2b,
+	0x042501bf,
+	0x0125fdf9,
+	0xf9d0fe0b,
+	0xfbe900d2,
+	0xfa580000,
+	0x000d03b8,
+	0x04c9ff5c,
+	0x04570313,
+	0x03e9fbdb,
+	0xfc44ff3c,
+	0xfe3c032b,
+	0x0022f927,
+	0x0200fe00,
+	0x056d0277,
+	0xfcd70228,
+	0xfc3aff21,
+	0x04c70571,
+	0xfe680157,
+	0xfc09fddc,
+	0xfce00500,
+	0x05a80000,
+	0xff1006be,
+	0x0800084a,
+	0xf49cfc7e,
+	0xfa580400,
+	0xfc9cf6da,
+	0xf800f672,
+	0x0710071c,
+	0x05a805a8,
+	0xf8f0f8e4,
+	0xf800f672,
+	0x03640926,
+	0xfa580400,
+	0x0b640382,
+	0x0800084a,
+	0x00f0f942,
+	0x05a80000,
+	0xff10f942,
+	0x0800f7b6,
+	0xf49c0382,
+	0xfa58fc00,
+	0xfc9c0926,
+	0xf800098e,
+	0x0710f8e4,
+	0x05a8fa58,
+	0xf8f0071c,
+	0xf800098e,
+	0x0364f6da,
+	0xfa58fc00,
+	0x0b64fc7e,
+	0x0800f7b6,
+	0x00f006be,
+	0x05a80000,
+	0xff1006be,
+	0x0800084a,
+	0xf49cfc7e,
+	0xfa580400,
+	0xfc9cf6da,
+	0xf800f672,
+	0x0710071c,
+	0x05a805a8,
+	0xf8f0f8e4,
+	0xf800f672,
+	0x03640926,
+	0xfa580400,
+	0x0b640382,
+	0x0800084a,
+	0x00f0f942,
+	0x05a80000,
+	0xff10f942,
+	0x0800f7b6,
+	0xf49c0382,
+	0xfa58fc00,
+	0xfc9c0926,
+	0xf800098e,
+	0x0710f8e4,
+	0x05a8fa58,
+	0xf8f0071c,
+	0xf800098e,
+	0x0364f6da,
+	0xfa58fc00,
+	0x0b64fc7e,
+	0x0800f7b6,
+	0x00f006be,
+};
+
+CONST uint32 noise_var_tbl_rev3[] = {
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+	0x02110211,
+	0x0000014d,
+};
+
+CONST uint16 mcs_tbl_rev3[] = {
+	0x0000,
+	0x0008,
+	0x000a,
+	0x0010,
+	0x0012,
+	0x0019,
+	0x001a,
+	0x001c,
+	0x0080,
+	0x0088,
+	0x008a,
+	0x0090,
+	0x0092,
+	0x0099,
+	0x009a,
+	0x009c,
+	0x0100,
+	0x0108,
+	0x010a,
+	0x0110,
+	0x0112,
+	0x0119,
+	0x011a,
+	0x011c,
+	0x0180,
+	0x0188,
+	0x018a,
+	0x0190,
+	0x0192,
+	0x0199,
+	0x019a,
+	0x019c,
+	0x0000,
+	0x0098,
+	0x00a0,
+	0x00a8,
+	0x009a,
+	0x00a2,
+	0x00aa,
+	0x0120,
+	0x0128,
+	0x0128,
+	0x0130,
+	0x0138,
+	0x0138,
+	0x0140,
+	0x0122,
+	0x012a,
+	0x012a,
+	0x0132,
+	0x013a,
+	0x013a,
+	0x0142,
+	0x01a8,
+	0x01b0,
+	0x01b8,
+	0x01b0,
+	0x01b8,
+	0x01c0,
+	0x01c8,
+	0x01c0,
+	0x01c8,
+	0x01d0,
+	0x01d0,
+	0x01d8,
+	0x01aa,
+	0x01b2,
+	0x01ba,
+	0x01b2,
+	0x01ba,
+	0x01c2,
+	0x01ca,
+	0x01c2,
+	0x01ca,
+	0x01d2,
+	0x01d2,
+	0x01da,
+	0x0001,
+	0x0002,
+	0x0004,
+	0x0009,
+	0x000c,
+	0x0011,
+	0x0014,
+	0x0018,
+	0x0020,
+	0x0021,
+	0x0022,
+	0x0024,
+	0x0081,
+	0x0082,
+	0x0084,
+	0x0089,
+	0x008c,
+	0x0091,
+	0x0094,
+	0x0098,
+	0x00a0,
+	0x00a1,
+	0x00a2,
+	0x00a4,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+	0x0007,
+};
+
+CONST uint32 tdi_tbl20_ant0_rev3[] = {
+	0x00091226,
+	0x000a1429,
+	0x000b56ad,
+	0x000c58b0,
+	0x000d5ab3,
+	0x000e9cb6,
+	0x000f9eba,
+	0x0000c13d,
+	0x00020301,
+	0x00030504,
+	0x00040708,
+	0x0005090b,
+	0x00064b8e,
+	0x00095291,
+	0x000a5494,
+	0x000b9718,
+	0x000c9927,
+	0x000d9b2a,
+	0x000edd2e,
+	0x000fdf31,
+	0x000101b4,
+	0x000243b7,
+	0x000345bb,
+	0x000447be,
+	0x00058982,
+	0x00068c05,
+	0x00099309,
+	0x000a950c,
+	0x000bd78f,
+	0x000cd992,
+	0x000ddb96,
+	0x000f1d99,
+	0x00005fa8,
+	0x0001422c,
+	0x0002842f,
+	0x00038632,
+	0x00048835,
+	0x0005ca38,
+	0x0006ccbc,
+	0x0009d3bf,
+	0x000b1603,
+	0x000c1806,
+	0x000d1a0a,
+	0x000e1c0d,
+	0x000f5e10,
+	0x00008093,
+	0x00018297,
+	0x0002c49a,
+	0x0003c680,
+	0x0004c880,
+	0x00060b00,
+	0x00070d00,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 tdi_tbl20_ant1_rev3[] = {
+	0x00014b26,
+	0x00028d29,
+	0x000393ad,
+	0x00049630,
+	0x0005d833,
+	0x0006da36,
+	0x00099c3a,
+	0x000a9e3d,
+	0x000bc081,
+	0x000cc284,
+	0x000dc488,
+	0x000f068b,
+	0x0000488e,
+	0x00018b91,
+	0x0002d214,
+	0x0003d418,
+	0x0004d6a7,
+	0x000618aa,
+	0x00071aae,
+	0x0009dcb1,
+	0x000b1eb4,
+	0x000c0137,
+	0x000d033b,
+	0x000e053e,
+	0x000f4702,
+	0x00008905,
+	0x00020c09,
+	0x0003128c,
+	0x0004148f,
+	0x00051712,
+	0x00065916,
+	0x00091b19,
+	0x000a1d28,
+	0x000b5f2c,
+	0x000c41af,
+	0x000d43b2,
+	0x000e85b5,
+	0x000f87b8,
+	0x0000c9bc,
+	0x00024cbf,
+	0x00035303,
+	0x00045506,
+	0x0005978a,
+	0x0006998d,
+	0x00095b90,
+	0x000a5d93,
+	0x000b9f97,
+	0x000c821a,
+	0x000d8400,
+	0x000ec600,
+	0x000fc800,
+	0x00010a00,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 tdi_tbl40_ant0_rev3[] = {
+	0x0011a346,
+	0x00136ccf,
+	0x0014f5d9,
+	0x001641e2,
+	0x0017cb6b,
+	0x00195475,
+	0x001b2383,
+	0x001cad0c,
+	0x001e7616,
+	0x0000821f,
+	0x00020ba8,
+	0x0003d4b2,
+	0x00056447,
+	0x00072dd0,
+	0x0008b6da,
+	0x000a02e3,
+	0x000b8c6c,
+	0x000d15f6,
+	0x0011e484,
+	0x0013ae0d,
+	0x00153717,
+	0x00168320,
+	0x00180ca9,
+	0x00199633,
+	0x001b6548,
+	0x001ceed1,
+	0x001eb7db,
+	0x0000c3e4,
+	0x00024d6d,
+	0x000416f7,
+	0x0005a585,
+	0x00076f0f,
+	0x0008f818,
+	0x000a4421,
+	0x000bcdab,
+	0x000d9734,
+	0x00122649,
+	0x0013efd2,
+	0x001578dc,
+	0x0016c4e5,
+	0x00184e6e,
+	0x001a17f8,
+	0x001ba686,
+	0x001d3010,
+	0x001ef999,
+	0x00010522,
+	0x00028eac,
+	0x00045835,
+	0x0005e74a,
+	0x0007b0d3,
+	0x00093a5d,
+	0x000a85e6,
+	0x000c0f6f,
+	0x000dd8f9,
+	0x00126787,
+	0x00143111,
+	0x0015ba9a,
+	0x00170623,
+	0x00188fad,
+	0x001a5936,
+	0x001be84b,
+	0x001db1d4,
+	0x001f3b5e,
+	0x000146e7,
+	0x00031070,
+	0x000499fa,
+	0x00062888,
+	0x0007f212,
+	0x00097b9b,
+	0x000ac7a4,
+	0x000c50ae,
+	0x000e1a37,
+	0x0012a94c,
+	0x001472d5,
+	0x0015fc5f,
+	0x00174868,
+	0x0018d171,
+	0x001a9afb,
+	0x001c2989,
+	0x001df313,
+	0x001f7c9c,
+	0x000188a5,
+	0x000351af,
+	0x0004db38,
+	0x0006aa4d,
+	0x000833d7,
+	0x0009bd60,
+	0x000b0969,
+	0x000c9273,
+	0x000e5bfc,
+	0x00132a8a,
+	0x0014b414,
+	0x00163d9d,
+	0x001789a6,
+	0x001912b0,
+	0x001adc39,
+	0x001c6bce,
+	0x001e34d8,
+	0x001fbe61,
+	0x0001ca6a,
+	0x00039374,
+	0x00051cfd,
+	0x0006ec0b,
+	0x00087515,
+	0x0009fe9e,
+	0x000b4aa7,
+	0x000cd3b1,
+	0x000e9d3a,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 tdi_tbl40_ant1_rev3[] = {
+	0x001edb36,
+	0x000129ca,
+	0x0002b353,
+	0x00047cdd,
+	0x0005c8e6,
+	0x000791ef,
+	0x00091bf9,
+	0x000aaa07,
+	0x000c3391,
+	0x000dfd1a,
+	0x00120923,
+	0x0013d22d,
+	0x00155c37,
+	0x0016eacb,
+	0x00187454,
+	0x001a3dde,
+	0x001b89e7,
+	0x001d12f0,
+	0x001f1cfa,
+	0x00016b88,
+	0x00033492,
+	0x0004be1b,
+	0x00060a24,
+	0x0007d32e,
+	0x00095d38,
+	0x000aec4c,
+	0x000c7555,
+	0x000e3edf,
+	0x00124ae8,
+	0x001413f1,
+	0x0015a37b,
+	0x00172c89,
+	0x0018b593,
+	0x001a419c,
+	0x001bcb25,
+	0x001d942f,
+	0x001f63b9,
+	0x0001ad4d,
+	0x00037657,
+	0x0004c260,
+	0x00068be9,
+	0x000814f3,
+	0x0009a47c,
+	0x000b2d8a,
+	0x000cb694,
+	0x000e429d,
+	0x00128c26,
+	0x001455b0,
+	0x0015e4ba,
+	0x00176e4e,
+	0x0018f758,
+	0x001a8361,
+	0x001c0cea,
+	0x001dd674,
+	0x001fa57d,
+	0x0001ee8b,
+	0x0003b795,
+	0x0005039e,
+	0x0006cd27,
+	0x000856b1,
+	0x0009e5c6,
+	0x000b6f4f,
+	0x000cf859,
+	0x000e8462,
+	0x00130deb,
+	0x00149775,
+	0x00162603,
+	0x0017af8c,
+	0x00193896,
+	0x001ac49f,
+	0x001c4e28,
+	0x001e17b2,
+	0x0000a6c7,
+	0x00023050,
+	0x0003f9da,
+	0x00054563,
+	0x00070eec,
+	0x00089876,
+	0x000a2704,
+	0x000bb08d,
+	0x000d3a17,
+	0x001185a0,
+	0x00134f29,
+	0x0014d8b3,
+	0x001667c8,
+	0x0017f151,
+	0x00197adb,
+	0x001b0664,
+	0x001c8fed,
+	0x001e5977,
+	0x0000e805,
+	0x0002718f,
+	0x00043b18,
+	0x000586a1,
+	0x0007502b,
+	0x0008d9b4,
+	0x000a68c9,
+	0x000bf252,
+	0x000dbbdc,
+	0x0011c7e5,
+	0x001390ee,
+	0x00151a78,
+	0x0016a906,
+	0x00183290,
+	0x0019bc19,
+	0x001b4822,
+	0x001cd12c,
+	0x001e9ab5,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 pltlut_tbl_rev3[] = {
+	0x76540213,
+	0x62407351,
+	0x76543210,
+	0x76540213,
+	0x76540213,
+	0x76430521,
+};
+
+CONST uint32 chanest_tbl_rev3[] = {
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x44444444,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+	0x10101010,
+};
+
+CONST uint8 frame_lut_rev3[] = {
+	0x02,
+	0x04,
+	0x14,
+	0x14,
+	0x03,
+	0x05,
+	0x16,
+	0x16,
+	0x0a,
+	0x0c,
+	0x1c,
+	0x1c,
+	0x0b,
+	0x0d,
+	0x1e,
+	0x1e,
+	0x06,
+	0x08,
+	0x18,
+	0x18,
+	0x07,
+	0x09,
+	0x1a,
+	0x1a,
+	0x0e,
+	0x10,
+	0x20,
+	0x28,
+	0x0f,
+	0x11,
+	0x22,
+	0x2a,
+};
+
+CONST uint8 est_pwr_lut_core0_rev3[] = {
+	0x55,
+	0x54,
+	0x54,
+	0x53,
+	0x52,
+	0x52,
+	0x51,
+	0x51,
+	0x50,
+	0x4f,
+	0x4f,
+	0x4e,
+	0x4e,
+	0x4d,
+	0x4c,
+	0x4c,
+	0x4b,
+	0x4a,
+	0x49,
+	0x49,
+	0x48,
+	0x47,
+	0x46,
+	0x46,
+	0x45,
+	0x44,
+	0x43,
+	0x42,
+	0x41,
+	0x40,
+	0x40,
+	0x3f,
+	0x3e,
+	0x3d,
+	0x3c,
+	0x3a,
+	0x39,
+	0x38,
+	0x37,
+	0x36,
+	0x35,
+	0x33,
+	0x32,
+	0x31,
+	0x2f,
+	0x2e,
+	0x2c,
+	0x2b,
+	0x29,
+	0x27,
+	0x25,
+	0x23,
+	0x21,
+	0x1f,
+	0x1d,
+	0x1a,
+	0x18,
+	0x15,
+	0x12,
+	0x0e,
+	0x0b,
+	0x07,
+	0x02,
+	0xfd,
+};
+
+CONST uint8 est_pwr_lut_core1_rev3[] = {
+	0x55,
+	0x54,
+	0x54,
+	0x53,
+	0x52,
+	0x52,
+	0x51,
+	0x51,
+	0x50,
+	0x4f,
+	0x4f,
+	0x4e,
+	0x4e,
+	0x4d,
+	0x4c,
+	0x4c,
+	0x4b,
+	0x4a,
+	0x49,
+	0x49,
+	0x48,
+	0x47,
+	0x46,
+	0x46,
+	0x45,
+	0x44,
+	0x43,
+	0x42,
+	0x41,
+	0x40,
+	0x40,
+	0x3f,
+	0x3e,
+	0x3d,
+	0x3c,
+	0x3a,
+	0x39,
+	0x38,
+	0x37,
+	0x36,
+	0x35,
+	0x33,
+	0x32,
+	0x31,
+	0x2f,
+	0x2e,
+	0x2c,
+	0x2b,
+	0x29,
+	0x27,
+	0x25,
+	0x23,
+	0x21,
+	0x1f,
+	0x1d,
+	0x1a,
+	0x18,
+	0x15,
+	0x12,
+	0x0e,
+	0x0b,
+	0x07,
+	0x02,
+	0xfd,
+};
+
+CONST uint8 adj_pwr_lut_core0_rev3[] = {
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+};
+
+CONST uint8 adj_pwr_lut_core1_rev3[] = {
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+};
+
+CONST uint32 gainctrl_lut_core0_rev3[] = {
+	0x5bf70044,
+	0x5bf70042,
+	0x5bf70040,
+	0x5bf7003e,
+	0x5bf7003c,
+	0x5bf7003b,
+	0x5bf70039,
+	0x5bf70037,
+	0x5bf70036,
+	0x5bf70034,
+	0x5bf70033,
+	0x5bf70031,
+	0x5bf70030,
+	0x5ba70044,
+	0x5ba70042,
+	0x5ba70040,
+	0x5ba7003e,
+	0x5ba7003c,
+	0x5ba7003b,
+	0x5ba70039,
+	0x5ba70037,
+	0x5ba70036,
+	0x5ba70034,
+	0x5ba70033,
+	0x5b770044,
+	0x5b770042,
+	0x5b770040,
+	0x5b77003e,
+	0x5b77003c,
+	0x5b77003b,
+	0x5b770039,
+	0x5b770037,
+	0x5b770036,
+	0x5b770034,
+	0x5b770033,
+	0x5b770031,
+	0x5b770030,
+	0x5b77002f,
+	0x5b77002d,
+	0x5b77002c,
+	0x5b470044,
+	0x5b470042,
+	0x5b470040,
+	0x5b47003e,
+	0x5b47003c,
+	0x5b47003b,
+	0x5b470039,
+	0x5b470037,
+	0x5b470036,
+	0x5b470034,
+	0x5b470033,
+	0x5b470031,
+	0x5b470030,
+	0x5b47002f,
+	0x5b47002d,
+	0x5b47002c,
+	0x5b47002b,
+	0x5b47002a,
+	0x5b270044,
+	0x5b270042,
+	0x5b270040,
+	0x5b27003e,
+	0x5b27003c,
+	0x5b27003b,
+	0x5b270039,
+	0x5b270037,
+	0x5b270036,
+	0x5b270034,
+	0x5b270033,
+	0x5b270031,
+	0x5b270030,
+	0x5b27002f,
+	0x5b170044,
+	0x5b170042,
+	0x5b170040,
+	0x5b17003e,
+	0x5b17003c,
+	0x5b17003b,
+	0x5b170039,
+	0x5b170037,
+	0x5b170036,
+	0x5b170034,
+	0x5b170033,
+	0x5b170031,
+	0x5b170030,
+	0x5b17002f,
+	0x5b17002d,
+	0x5b17002c,
+	0x5b17002b,
+	0x5b17002a,
+	0x5b170028,
+	0x5b170027,
+	0x5b170026,
+	0x5b170025,
+	0x5b170024,
+	0x5b170023,
+	0x5b070044,
+	0x5b070042,
+	0x5b070040,
+	0x5b07003e,
+	0x5b07003c,
+	0x5b07003b,
+	0x5b070039,
+	0x5b070037,
+	0x5b070036,
+	0x5b070034,
+	0x5b070033,
+	0x5b070031,
+	0x5b070030,
+	0x5b07002f,
+	0x5b07002d,
+	0x5b07002c,
+	0x5b07002b,
+	0x5b07002a,
+	0x5b070028,
+	0x5b070027,
+	0x5b070026,
+	0x5b070025,
+	0x5b070024,
+	0x5b070023,
+	0x5b070022,
+	0x5b070021,
+	0x5b070020,
+	0x5b07001f,
+	0x5b07001e,
+	0x5b07001d,
+	0x5b07001d,
+	0x5b07001c,
+};
+
+CONST uint32 gainctrl_lut_core1_rev3[] = {
+	0x5bf70044,
+	0x5bf70042,
+	0x5bf70040,
+	0x5bf7003e,
+	0x5bf7003c,
+	0x5bf7003b,
+	0x5bf70039,
+	0x5bf70037,
+	0x5bf70036,
+	0x5bf70034,
+	0x5bf70033,
+	0x5bf70031,
+	0x5bf70030,
+	0x5ba70044,
+	0x5ba70042,
+	0x5ba70040,
+	0x5ba7003e,
+	0x5ba7003c,
+	0x5ba7003b,
+	0x5ba70039,
+	0x5ba70037,
+	0x5ba70036,
+	0x5ba70034,
+	0x5ba70033,
+	0x5b770044,
+	0x5b770042,
+	0x5b770040,
+	0x5b77003e,
+	0x5b77003c,
+	0x5b77003b,
+	0x5b770039,
+	0x5b770037,
+	0x5b770036,
+	0x5b770034,
+	0x5b770033,
+	0x5b770031,
+	0x5b770030,
+	0x5b77002f,
+	0x5b77002d,
+	0x5b77002c,
+	0x5b470044,
+	0x5b470042,
+	0x5b470040,
+	0x5b47003e,
+	0x5b47003c,
+	0x5b47003b,
+	0x5b470039,
+	0x5b470037,
+	0x5b470036,
+	0x5b470034,
+	0x5b470033,
+	0x5b470031,
+	0x5b470030,
+	0x5b47002f,
+	0x5b47002d,
+	0x5b47002c,
+	0x5b47002b,
+	0x5b47002a,
+	0x5b270044,
+	0x5b270042,
+	0x5b270040,
+	0x5b27003e,
+	0x5b27003c,
+	0x5b27003b,
+	0x5b270039,
+	0x5b270037,
+	0x5b270036,
+	0x5b270034,
+	0x5b270033,
+	0x5b270031,
+	0x5b270030,
+	0x5b27002f,
+	0x5b170044,
+	0x5b170042,
+	0x5b170040,
+	0x5b17003e,
+	0x5b17003c,
+	0x5b17003b,
+	0x5b170039,
+	0x5b170037,
+	0x5b170036,
+	0x5b170034,
+	0x5b170033,
+	0x5b170031,
+	0x5b170030,
+	0x5b17002f,
+	0x5b17002d,
+	0x5b17002c,
+	0x5b17002b,
+	0x5b17002a,
+	0x5b170028,
+	0x5b170027,
+	0x5b170026,
+	0x5b170025,
+	0x5b170024,
+	0x5b170023,
+	0x5b070044,
+	0x5b070042,
+	0x5b070040,
+	0x5b07003e,
+	0x5b07003c,
+	0x5b07003b,
+	0x5b070039,
+	0x5b070037,
+	0x5b070036,
+	0x5b070034,
+	0x5b070033,
+	0x5b070031,
+	0x5b070030,
+	0x5b07002f,
+	0x5b07002d,
+	0x5b07002c,
+	0x5b07002b,
+	0x5b07002a,
+	0x5b070028,
+	0x5b070027,
+	0x5b070026,
+	0x5b070025,
+	0x5b070024,
+	0x5b070023,
+	0x5b070022,
+	0x5b070021,
+	0x5b070020,
+	0x5b07001f,
+	0x5b07001e,
+	0x5b07001d,
+	0x5b07001d,
+	0x5b07001c,
+};
+
+CONST uint32 iq_lut_core0_rev3[] = {
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 iq_lut_core1_rev3[] = {
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint16 loft_lut_core0_rev3[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+CONST uint16 loft_lut_core1_rev3[] = {
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+	0x0000,
+};
+
+CONST uint16 papd_comp_rfpwr_tbl_core0_rev3[] = {
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+};
+
+CONST uint16 papd_comp_rfpwr_tbl_core1_rev3[] = {
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x0036,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x002a,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x001e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x000e,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01fc,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01ee,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+	0x01d6,
+};
+
+CONST uint32 papd_comp_epsilon_tbl_core0_rev3[] = {
+	0x00000000,
+	0x00001fa0,
+	0x00019f78,
+	0x0001df7e,
+	0x03fa9f86,
+	0x03fd1f90,
+	0x03fe5f8a,
+	0x03fb1f94,
+	0x03fd9fa0,
+	0x00009f98,
+	0x03fd1fac,
+	0x03ff9fa2,
+	0x03fe9fae,
+	0x00001fae,
+	0x03fddfb4,
+	0x03ff1fb8,
+	0x03ff9fbc,
+	0x03ffdfbe,
+	0x03fe9fc2,
+	0x03fedfc6,
+	0x03fedfc6,
+	0x03ff9fc8,
+	0x03ff5fc6,
+	0x03fedfc2,
+	0x03ff9fc0,
+	0x03ff5fac,
+	0x03ff5fac,
+	0x03ff9fa2,
+	0x03ff9fa6,
+	0x03ff9faa,
+	0x03ff5fb0,
+	0x03ff5fb4,
+	0x03ff1fca,
+	0x03ff5fce,
+	0x03fcdfdc,
+	0x03fb4006,
+	0x00000030,
+	0x03ff808a,
+	0x03ff80da,
+	0x0000016c,
+	0x03ff8318,
+	0x03ff063a,
+	0x03fd8bd6,
+	0x00014ffe,
+	0x00034ffe,
+	0x00034ffe,
+	0x0003cffe,
+	0x00040ffe,
+	0x00040ffe,
+	0x0003cffe,
+	0x0003cffe,
+	0x00020ffe,
+	0x03fe0ffe,
+	0x03fdcffe,
+	0x03f94ffe,
+	0x03f54ffe,
+	0x03f44ffe,
+	0x03ef8ffe,
+	0x03ee0ffe,
+	0x03ebcffe,
+	0x03e8cffe,
+	0x03e74ffe,
+	0x03e4cffe,
+	0x03e38ffe,
+};
+
+CONST uint32 papd_cal_scalars_tbl_core0_rev3[] = {
+	0x05af005a,
+	0x0571005e,
+	0x05040066,
+	0x04bd006c,
+	0x047d0072,
+	0x04430078,
+	0x03f70081,
+	0x03cb0087,
+	0x03870091,
+	0x035e0098,
+	0x032e00a1,
+	0x030300aa,
+	0x02d800b4,
+	0x02ae00bf,
+	0x028900ca,
+	0x026400d6,
+	0x024100e3,
+	0x022200f0,
+	0x020200ff,
+	0x01e5010e,
+	0x01ca011e,
+	0x01b0012f,
+	0x01990140,
+	0x01830153,
+	0x016c0168,
+	0x0158017d,
+	0x01450193,
+	0x013301ab,
+	0x012101c5,
+	0x011101e0,
+	0x010201fc,
+	0x00f4021a,
+	0x00e6011d,
+	0x00d9012e,
+	0x00cd0140,
+	0x00c20153,
+	0x00b70167,
+	0x00ac017c,
+	0x00a30193,
+	0x009a01ab,
+	0x009101c4,
+	0x008901df,
+	0x008101fb,
+	0x007a0219,
+	0x00730239,
+	0x006d025b,
+	0x0067027e,
+	0x006102a4,
+	0x005c02cc,
+	0x005602f6,
+	0x00520323,
+	0x004d0353,
+	0x00490385,
+	0x004503bb,
+	0x004103f3,
+	0x003d042f,
+	0x003a046f,
+	0x003704b2,
+	0x003404f9,
+	0x00310545,
+	0x002e0596,
+	0x002b05f5,
+	0x00290640,
+	0x002606a4,
+};
+
+CONST uint32 papd_comp_epsilon_tbl_core1_rev3[] = {
+	0x00000000,
+	0x00001fa0,
+	0x00019f78,
+	0x0001df7e,
+	0x03fa9f86,
+	0x03fd1f90,
+	0x03fe5f8a,
+	0x03fb1f94,
+	0x03fd9fa0,
+	0x00009f98,
+	0x03fd1fac,
+	0x03ff9fa2,
+	0x03fe9fae,
+	0x00001fae,
+	0x03fddfb4,
+	0x03ff1fb8,
+	0x03ff9fbc,
+	0x03ffdfbe,
+	0x03fe9fc2,
+	0x03fedfc6,
+	0x03fedfc6,
+	0x03ff9fc8,
+	0x03ff5fc6,
+	0x03fedfc2,
+	0x03ff9fc0,
+	0x03ff5fac,
+	0x03ff5fac,
+	0x03ff9fa2,
+	0x03ff9fa6,
+	0x03ff9faa,
+	0x03ff5fb0,
+	0x03ff5fb4,
+	0x03ff1fca,
+	0x03ff5fce,
+	0x03fcdfdc,
+	0x03fb4006,
+	0x00000030,
+	0x03ff808a,
+	0x03ff80da,
+	0x0000016c,
+	0x03ff8318,
+	0x03ff063a,
+	0x03fd8bd6,
+	0x00014ffe,
+	0x00034ffe,
+	0x00034ffe,
+	0x0003cffe,
+	0x00040ffe,
+	0x00040ffe,
+	0x0003cffe,
+	0x0003cffe,
+	0x00020ffe,
+	0x03fe0ffe,
+	0x03fdcffe,
+	0x03f94ffe,
+	0x03f54ffe,
+	0x03f44ffe,
+	0x03ef8ffe,
+	0x03ee0ffe,
+	0x03ebcffe,
+	0x03e8cffe,
+	0x03e74ffe,
+	0x03e4cffe,
+	0x03e38ffe,
+};
+
+CONST uint32 papd_cal_scalars_tbl_core1_rev3[] = {
+	0x05af005a,
+	0x0571005e,
+	0x05040066,
+	0x04bd006c,
+	0x047d0072,
+	0x04430078,
+	0x03f70081,
+	0x03cb0087,
+	0x03870091,
+	0x035e0098,
+	0x032e00a1,
+	0x030300aa,
+	0x02d800b4,
+	0x02ae00bf,
+	0x028900ca,
+	0x026400d6,
+	0x024100e3,
+	0x022200f0,
+	0x020200ff,
+	0x01e5010e,
+	0x01ca011e,
+	0x01b0012f,
+	0x01990140,
+	0x01830153,
+	0x016c0168,
+	0x0158017d,
+	0x01450193,
+	0x013301ab,
+	0x012101c5,
+	0x011101e0,
+	0x010201fc,
+	0x00f4021a,
+	0x00e6011d,
+	0x00d9012e,
+	0x00cd0140,
+	0x00c20153,
+	0x00b70167,
+	0x00ac017c,
+	0x00a30193,
+	0x009a01ab,
+	0x009101c4,
+	0x008901df,
+	0x008101fb,
+	0x007a0219,
+	0x00730239,
+	0x006d025b,
+	0x0067027e,
+	0x006102a4,
+	0x005c02cc,
+	0x005602f6,
+	0x00520323,
+	0x004d0353,
+	0x00490385,
+	0x004503bb,
+	0x004103f3,
+	0x003d042f,
+	0x003a046f,
+	0x003704b2,
+	0x003404f9,
+	0x00310545,
+	0x002e0596,
+	0x002b05f5,
+	0x00290640,
+	0x002606a4,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev3_volatile[] = {
+	{&ant_swctrl_tbl_rev3,
+	 sizeof(ant_swctrl_tbl_rev3) / sizeof(ant_swctrl_tbl_rev3[0]), 9, 0, 16}
+	,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev3_volatile1[] = {
+	{&ant_swctrl_tbl_rev3_1,
+	 sizeof(ant_swctrl_tbl_rev3_1) / sizeof(ant_swctrl_tbl_rev3_1[0]), 9, 0,
+	 16}
+	,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev3_volatile2[] = {
+	{&ant_swctrl_tbl_rev3_2,
+	 sizeof(ant_swctrl_tbl_rev3_2) / sizeof(ant_swctrl_tbl_rev3_2[0]), 9, 0,
+	 16}
+	,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev3_volatile3[] = {
+	{&ant_swctrl_tbl_rev3_3,
+	 sizeof(ant_swctrl_tbl_rev3_3) / sizeof(ant_swctrl_tbl_rev3_3[0]), 9, 0,
+	 16}
+	,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev3[] = {
+	{&frame_struct_rev3,
+	 sizeof(frame_struct_rev3) / sizeof(frame_struct_rev3[0]), 10, 0, 32}
+	,
+	{&pilot_tbl_rev3, sizeof(pilot_tbl_rev3) / sizeof(pilot_tbl_rev3[0]),
+	 11, 0, 16}
+	,
+	{&tmap_tbl_rev3, sizeof(tmap_tbl_rev3) / sizeof(tmap_tbl_rev3[0]), 12,
+	 0, 32}
+	,
+	{&intlv_tbl_rev3, sizeof(intlv_tbl_rev3) / sizeof(intlv_tbl_rev3[0]),
+	 13, 0, 32}
+	,
+	{&tdtrn_tbl_rev3, sizeof(tdtrn_tbl_rev3) / sizeof(tdtrn_tbl_rev3[0]),
+	 14, 0, 32}
+	,
+	{&noise_var_tbl_rev3,
+	 sizeof(noise_var_tbl_rev3) / sizeof(noise_var_tbl_rev3[0]), 16, 0, 32}
+	,
+	{&mcs_tbl_rev3, sizeof(mcs_tbl_rev3) / sizeof(mcs_tbl_rev3[0]), 18, 0,
+	 16}
+	,
+	{&tdi_tbl20_ant0_rev3,
+	 sizeof(tdi_tbl20_ant0_rev3) / sizeof(tdi_tbl20_ant0_rev3[0]), 19, 128,
+	 32}
+	,
+	{&tdi_tbl20_ant1_rev3,
+	 sizeof(tdi_tbl20_ant1_rev3) / sizeof(tdi_tbl20_ant1_rev3[0]), 19, 256,
+	 32}
+	,
+	{&tdi_tbl40_ant0_rev3,
+	 sizeof(tdi_tbl40_ant0_rev3) / sizeof(tdi_tbl40_ant0_rev3[0]), 19, 640,
+	 32}
+	,
+	{&tdi_tbl40_ant1_rev3,
+	 sizeof(tdi_tbl40_ant1_rev3) / sizeof(tdi_tbl40_ant1_rev3[0]), 19, 768,
+	 32}
+	,
+	{&pltlut_tbl_rev3, sizeof(pltlut_tbl_rev3) / sizeof(pltlut_tbl_rev3[0]),
+	 20, 0, 32}
+	,
+	{&chanest_tbl_rev3,
+	 sizeof(chanest_tbl_rev3) / sizeof(chanest_tbl_rev3[0]), 22, 0, 32}
+	,
+	{&frame_lut_rev3, sizeof(frame_lut_rev3) / sizeof(frame_lut_rev3[0]),
+	 24, 0, 8}
+	,
+	{&est_pwr_lut_core0_rev3,
+	 sizeof(est_pwr_lut_core0_rev3) / sizeof(est_pwr_lut_core0_rev3[0]), 26,
+	 0, 8}
+	,
+	{&est_pwr_lut_core1_rev3,
+	 sizeof(est_pwr_lut_core1_rev3) / sizeof(est_pwr_lut_core1_rev3[0]), 27,
+	 0, 8}
+	,
+	{&adj_pwr_lut_core0_rev3,
+	 sizeof(adj_pwr_lut_core0_rev3) / sizeof(adj_pwr_lut_core0_rev3[0]), 26,
+	 64, 8}
+	,
+	{&adj_pwr_lut_core1_rev3,
+	 sizeof(adj_pwr_lut_core1_rev3) / sizeof(adj_pwr_lut_core1_rev3[0]), 27,
+	 64, 8}
+	,
+	{&gainctrl_lut_core0_rev3,
+	 sizeof(gainctrl_lut_core0_rev3) / sizeof(gainctrl_lut_core0_rev3[0]),
+	 26, 192, 32}
+	,
+	{&gainctrl_lut_core1_rev3,
+	 sizeof(gainctrl_lut_core1_rev3) / sizeof(gainctrl_lut_core1_rev3[0]),
+	 27, 192, 32}
+	,
+	{&iq_lut_core0_rev3,
+	 sizeof(iq_lut_core0_rev3) / sizeof(iq_lut_core0_rev3[0]), 26, 320, 32}
+	,
+	{&iq_lut_core1_rev3,
+	 sizeof(iq_lut_core1_rev3) / sizeof(iq_lut_core1_rev3[0]), 27, 320, 32}
+	,
+	{&loft_lut_core0_rev3,
+	 sizeof(loft_lut_core0_rev3) / sizeof(loft_lut_core0_rev3[0]), 26, 448,
+	 16}
+	,
+	{&loft_lut_core1_rev3,
+	 sizeof(loft_lut_core1_rev3) / sizeof(loft_lut_core1_rev3[0]), 27, 448,
+	 16}
+};
+
+CONST uint32 mimophytbl_info_sz_rev3 =
+    sizeof(mimophytbl_info_rev3) / sizeof(mimophytbl_info_rev3[0]);
+CONST uint32 mimophytbl_info_sz_rev3_volatile =
+    sizeof(mimophytbl_info_rev3_volatile) /
+    sizeof(mimophytbl_info_rev3_volatile[0]);
+CONST uint32 mimophytbl_info_sz_rev3_volatile1 =
+    sizeof(mimophytbl_info_rev3_volatile1) /
+    sizeof(mimophytbl_info_rev3_volatile1[0]);
+CONST uint32 mimophytbl_info_sz_rev3_volatile2 =
+    sizeof(mimophytbl_info_rev3_volatile2) /
+    sizeof(mimophytbl_info_rev3_volatile2[0]);
+CONST uint32 mimophytbl_info_sz_rev3_volatile3 =
+    sizeof(mimophytbl_info_rev3_volatile3) /
+    sizeof(mimophytbl_info_rev3_volatile3[0]);
+
+CONST uint32 tmap_tbl_rev7[] = {
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00000111,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x000aa888,
+	0x88880000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa2222220,
+	0x22222222,
+	0x22c22222,
+	0x00000222,
+	0x22000000,
+	0x2222a222,
+	0x22222222,
+	0x222222a2,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00011111,
+	0x11110000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0xa8aa88a0,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x00088aaa,
+	0xaaaa0000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xaaa8aaa0,
+	0x8aaa8aaa,
+	0xaa8a8a8a,
+	0x000aaa88,
+	0x8aaa0000,
+	0xaaa8a888,
+	0x8aa88a8a,
+	0x8a88a888,
+	0x08080a00,
+	0x0a08080a,
+	0x080a0a08,
+	0x00080808,
+	0x080a0000,
+	0x080a0808,
+	0x080a0808,
+	0x0a0a0a08,
+	0xa0a0a0a0,
+	0x80a0a080,
+	0x8080a0a0,
+	0x00008080,
+	0x80a00000,
+	0x80a080a0,
+	0xa080a0a0,
+	0x8080a0a0,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x99999000,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb90,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00aaa888,
+	0x22000000,
+	0x2222b222,
+	0x22222222,
+	0x222222b2,
+	0xb2222220,
+	0x22222222,
+	0x22d22222,
+	0x00000222,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x33000000,
+	0x3333b333,
+	0x33333333,
+	0x333333b3,
+	0xb3333330,
+	0x33333333,
+	0x33d33333,
+	0x00000333,
+	0x22000000,
+	0x2222a222,
+	0x22222222,
+	0x222222a2,
+	0xa2222220,
+	0x22222222,
+	0x22c22222,
+	0x00000222,
+	0x99b99b00,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb99,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x08aaa888,
+	0x22222200,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0x22222222,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x11111111,
+	0xf1111111,
+	0x11111111,
+	0x11f11111,
+	0x01111111,
+	0xbb9bb900,
+	0xb9b9bb99,
+	0xb99bbbbb,
+	0xbbbb9b9b,
+	0xb9bb99bb,
+	0xb99999b9,
+	0xb9b9b99b,
+	0x00000bbb,
+	0xaa000000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xa8aa88aa,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x0a888aaa,
+	0xaa000000,
+	0xa8a8aa88,
+	0xa88aaaaa,
+	0xaaaa8a8a,
+	0xa8aa88a0,
+	0xa88888a8,
+	0xa8a8a88a,
+	0x00000aaa,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0xbbbbbb00,
+	0x999bbbbb,
+	0x9bb99b9b,
+	0xb9b9b9bb,
+	0xb9b99bbb,
+	0xb9b9b9bb,
+	0xb9bb9b99,
+	0x00000999,
+	0x8a000000,
+	0xaa88a888,
+	0xa88888aa,
+	0xa88a8a88,
+	0xa88aa88a,
+	0x88a8aaaa,
+	0xa8aa8aaa,
+	0x0888a88a,
+	0x0b0b0b00,
+	0x090b0b0b,
+	0x0b090b0b,
+	0x0909090b,
+	0x09090b0b,
+	0x09090b0b,
+	0x09090b09,
+	0x00000909,
+	0x0a000000,
+	0x0a080808,
+	0x080a080a,
+	0x080a0a08,
+	0x080a080a,
+	0x0808080a,
+	0x0a0a0a08,
+	0x0808080a,
+	0xb0b0b000,
+	0x9090b0b0,
+	0x90b09090,
+	0xb0b0b090,
+	0xb0b090b0,
+	0x90b0b0b0,
+	0xb0b09090,
+	0x00000090,
+	0x80000000,
+	0xa080a080,
+	0xa08080a0,
+	0xa0808080,
+	0xa080a080,
+	0x80a0a0a0,
+	0xa0a080a0,
+	0x00a0a0a0,
+	0x22000000,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0xf2222220,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x11000000,
+	0x1111f111,
+	0x11111111,
+	0x111111f1,
+	0xf1111110,
+	0x11111111,
+	0x11f11111,
+	0x00000111,
+	0x33000000,
+	0x3333f333,
+	0x33333333,
+	0x333333f3,
+	0xf3333330,
+	0x33333333,
+	0x33f33333,
+	0x00000333,
+	0x22000000,
+	0x2222f222,
+	0x22222222,
+	0x222222f2,
+	0xf2222220,
+	0x22222222,
+	0x22f22222,
+	0x00000222,
+	0x99000000,
+	0x9b9b99bb,
+	0x9bb99999,
+	0x9999b9b9,
+	0x9b99bb90,
+	0x9bbbbb9b,
+	0x9b9b9bb9,
+	0x00000999,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88888000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00aaa888,
+	0x88a88a00,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x000aa888,
+	0x88880000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa88,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x08aaa888,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x11000000,
+	0x1111a111,
+	0x11111111,
+	0x111111a1,
+	0xa1111110,
+	0x11111111,
+	0x11c11111,
+	0x00000111,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x88000000,
+	0x8a8a88aa,
+	0x8aa88888,
+	0x8888a8a8,
+	0x8a88aa80,
+	0x8aaaaa8a,
+	0x8a8a8aa8,
+	0x00000888,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+	0x00000000,
+};
+
+CONST uint32 noise_var_tbl_rev7[] = {
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+	0x020c020c,
+	0x0000014d,
+};
+
+CONST uint32 papd_comp_epsilon_tbl_core0_rev7[] = {
+	0x00000000,
+	0x00000000,
+	0x00016023,
+	0x00006028,
+	0x00034036,
+	0x0003402e,
+	0x0007203c,
+	0x0006e037,
+	0x00070030,
+	0x0009401f,
+	0x0009a00f,
+	0x000b600d,
+	0x000c8007,
+	0x000ce007,
+	0x00101fff,
+	0x00121ff9,
+	0x0012e004,
+	0x0014dffc,
+	0x0016dff6,
+	0x0018dfe9,
+	0x001b3fe5,
+	0x001c5fd0,
+	0x001ddfc2,
+	0x001f1fb6,
+	0x00207fa4,
+	0x00219f8f,
+	0x0022ff7d,
+	0x00247f6c,
+	0x0024df5b,
+	0x00267f4b,
+	0x0027df3b,
+	0x0029bf3b,
+	0x002b5f2f,
+	0x002d3f2e,
+	0x002f5f2a,
+	0x002fff15,
+	0x00315f0b,
+	0x0032defa,
+	0x0033beeb,
+	0x0034fed9,
+	0x00353ec5,
+	0x00361eb0,
+	0x00363e9b,
+	0x0036be87,
+	0x0036be70,
+	0x0038fe67,
+	0x0044beb2,
+	0x00513ef3,
+	0x00595f11,
+	0x00669f3d,
+	0x0078dfdf,
+	0x00a143aa,
+	0x01642fff,
+	0x0162afff,
+	0x01620fff,
+	0x0160cfff,
+	0x015f0fff,
+	0x015dafff,
+	0x015bcfff,
+	0x015bcfff,
+	0x015b4fff,
+	0x015acfff,
+	0x01590fff,
+	0x0156cfff,
+};
+
+CONST uint32 papd_cal_scalars_tbl_core0_rev7[] = {
+	0x0b5e002d,
+	0x0ae2002f,
+	0x0a3b0032,
+	0x09a70035,
+	0x09220038,
+	0x08ab003b,
+	0x081f003f,
+	0x07a20043,
+	0x07340047,
+	0x06d2004b,
+	0x067a004f,
+	0x06170054,
+	0x05bf0059,
+	0x0571005e,
+	0x051e0064,
+	0x04d3006a,
+	0x04910070,
+	0x044c0077,
+	0x040f007e,
+	0x03d90085,
+	0x03a1008d,
+	0x036f0095,
+	0x033d009e,
+	0x030b00a8,
+	0x02e000b2,
+	0x02b900bc,
+	0x029200c7,
+	0x026d00d3,
+	0x024900e0,
+	0x022900ed,
+	0x020a00fb,
+	0x01ec010a,
+	0x01d20119,
+	0x01b7012a,
+	0x019e013c,
+	0x0188014e,
+	0x01720162,
+	0x015d0177,
+	0x0149018e,
+	0x013701a5,
+	0x012601be,
+	0x011501d8,
+	0x010601f4,
+	0x00f70212,
+	0x00e90231,
+	0x00dc0253,
+	0x00d00276,
+	0x00c4029b,
+	0x00b902c3,
+	0x00af02ed,
+	0x00a50319,
+	0x009c0348,
+	0x0093037a,
+	0x008b03af,
+	0x008303e6,
+	0x007c0422,
+	0x00750460,
+	0x006e04a3,
+	0x006804e9,
+	0x00620533,
+	0x005d0582,
+	0x005805d6,
+	0x0053062e,
+	0x004e068c,
+};
+
+CONST uint32 papd_comp_epsilon_tbl_core1_rev7[] = {
+	0x00000000,
+	0x00000000,
+	0x00016023,
+	0x00006028,
+	0x00034036,
+	0x0003402e,
+	0x0007203c,
+	0x0006e037,
+	0x00070030,
+	0x0009401f,
+	0x0009a00f,
+	0x000b600d,
+	0x000c8007,
+	0x000ce007,
+	0x00101fff,
+	0x00121ff9,
+	0x0012e004,
+	0x0014dffc,
+	0x0016dff6,
+	0x0018dfe9,
+	0x001b3fe5,
+	0x001c5fd0,
+	0x001ddfc2,
+	0x001f1fb6,
+	0x00207fa4,
+	0x00219f8f,
+	0x0022ff7d,
+	0x00247f6c,
+	0x0024df5b,
+	0x00267f4b,
+	0x0027df3b,
+	0x0029bf3b,
+	0x002b5f2f,
+	0x002d3f2e,
+	0x002f5f2a,
+	0x002fff15,
+	0x00315f0b,
+	0x0032defa,
+	0x0033beeb,
+	0x0034fed9,
+	0x00353ec5,
+	0x00361eb0,
+	0x00363e9b,
+	0x0036be87,
+	0x0036be70,
+	0x0038fe67,
+	0x0044beb2,
+	0x00513ef3,
+	0x00595f11,
+	0x00669f3d,
+	0x0078dfdf,
+	0x00a143aa,
+	0x01642fff,
+	0x0162afff,
+	0x01620fff,
+	0x0160cfff,
+	0x015f0fff,
+	0x015dafff,
+	0x015bcfff,
+	0x015bcfff,
+	0x015b4fff,
+	0x015acfff,
+	0x01590fff,
+	0x0156cfff,
+};
+
+CONST uint32 papd_cal_scalars_tbl_core1_rev7[] = {
+	0x0b5e002d,
+	0x0ae2002f,
+	0x0a3b0032,
+	0x09a70035,
+	0x09220038,
+	0x08ab003b,
+	0x081f003f,
+	0x07a20043,
+	0x07340047,
+	0x06d2004b,
+	0x067a004f,
+	0x06170054,
+	0x05bf0059,
+	0x0571005e,
+	0x051e0064,
+	0x04d3006a,
+	0x04910070,
+	0x044c0077,
+	0x040f007e,
+	0x03d90085,
+	0x03a1008d,
+	0x036f0095,
+	0x033d009e,
+	0x030b00a8,
+	0x02e000b2,
+	0x02b900bc,
+	0x029200c7,
+	0x026d00d3,
+	0x024900e0,
+	0x022900ed,
+	0x020a00fb,
+	0x01ec010a,
+	0x01d20119,
+	0x01b7012a,
+	0x019e013c,
+	0x0188014e,
+	0x01720162,
+	0x015d0177,
+	0x0149018e,
+	0x013701a5,
+	0x012601be,
+	0x011501d8,
+	0x010601f4,
+	0x00f70212,
+	0x00e90231,
+	0x00dc0253,
+	0x00d00276,
+	0x00c4029b,
+	0x00b902c3,
+	0x00af02ed,
+	0x00a50319,
+	0x009c0348,
+	0x0093037a,
+	0x008b03af,
+	0x008303e6,
+	0x007c0422,
+	0x00750460,
+	0x006e04a3,
+	0x006804e9,
+	0x00620533,
+	0x005d0582,
+	0x005805d6,
+	0x0053062e,
+	0x004e068c,
+};
+
+CONST mimophytbl_info_t mimophytbl_info_rev7[] = {
+	{&frame_struct_rev3,
+	 sizeof(frame_struct_rev3) / sizeof(frame_struct_rev3[0]), 10, 0, 32}
+	,
+	{&pilot_tbl_rev3, sizeof(pilot_tbl_rev3) / sizeof(pilot_tbl_rev3[0]),
+	 11, 0, 16}
+	,
+	{&tmap_tbl_rev7, sizeof(tmap_tbl_rev7) / sizeof(tmap_tbl_rev7[0]), 12,
+	 0, 32}
+	,
+	{&intlv_tbl_rev3, sizeof(intlv_tbl_rev3) / sizeof(intlv_tbl_rev3[0]),
+	 13, 0, 32}
+	,
+	{&tdtrn_tbl_rev3, sizeof(tdtrn_tbl_rev3) / sizeof(tdtrn_tbl_rev3[0]),
+	 14, 0, 32}
+	,
+	{&noise_var_tbl_rev7,
+	 sizeof(noise_var_tbl_rev7) / sizeof(noise_var_tbl_rev7[0]), 16, 0, 32}
+	,
+	{&mcs_tbl_rev3, sizeof(mcs_tbl_rev3) / sizeof(mcs_tbl_rev3[0]), 18, 0,
+	 16}
+	,
+	{&tdi_tbl20_ant0_rev3,
+	 sizeof(tdi_tbl20_ant0_rev3) / sizeof(tdi_tbl20_ant0_rev3[0]), 19, 128,
+	 32}
+	,
+	{&tdi_tbl20_ant1_rev3,
+	 sizeof(tdi_tbl20_ant1_rev3) / sizeof(tdi_tbl20_ant1_rev3[0]), 19, 256,
+	 32}
+	,
+	{&tdi_tbl40_ant0_rev3,
+	 sizeof(tdi_tbl40_ant0_rev3) / sizeof(tdi_tbl40_ant0_rev3[0]), 19, 640,
+	 32}
+	,
+	{&tdi_tbl40_ant1_rev3,
+	 sizeof(tdi_tbl40_ant1_rev3) / sizeof(tdi_tbl40_ant1_rev3[0]), 19, 768,
+	 32}
+	,
+	{&pltlut_tbl_rev3, sizeof(pltlut_tbl_rev3) / sizeof(pltlut_tbl_rev3[0]),
+	 20, 0, 32}
+	,
+	{&chanest_tbl_rev3,
+	 sizeof(chanest_tbl_rev3) / sizeof(chanest_tbl_rev3[0]), 22, 0, 32}
+	,
+	{&frame_lut_rev3, sizeof(frame_lut_rev3) / sizeof(frame_lut_rev3[0]),
+	 24, 0, 8}
+	,
+	{&est_pwr_lut_core0_rev3,
+	 sizeof(est_pwr_lut_core0_rev3) / sizeof(est_pwr_lut_core0_rev3[0]), 26,
+	 0, 8}
+	,
+	{&est_pwr_lut_core1_rev3,
+	 sizeof(est_pwr_lut_core1_rev3) / sizeof(est_pwr_lut_core1_rev3[0]), 27,
+	 0, 8}
+	,
+	{&adj_pwr_lut_core0_rev3,
+	 sizeof(adj_pwr_lut_core0_rev3) / sizeof(adj_pwr_lut_core0_rev3[0]), 26,
+	 64, 8}
+	,
+	{&adj_pwr_lut_core1_rev3,
+	 sizeof(adj_pwr_lut_core1_rev3) / sizeof(adj_pwr_lut_core1_rev3[0]), 27,
+	 64, 8}
+	,
+	{&gainctrl_lut_core0_rev3,
+	 sizeof(gainctrl_lut_core0_rev3) / sizeof(gainctrl_lut_core0_rev3[0]),
+	 26, 192, 32}
+	,
+	{&gainctrl_lut_core1_rev3,
+	 sizeof(gainctrl_lut_core1_rev3) / sizeof(gainctrl_lut_core1_rev3[0]),
+	 27, 192, 32}
+	,
+	{&iq_lut_core0_rev3,
+	 sizeof(iq_lut_core0_rev3) / sizeof(iq_lut_core0_rev3[0]), 26, 320, 32}
+	,
+	{&iq_lut_core1_rev3,
+	 sizeof(iq_lut_core1_rev3) / sizeof(iq_lut_core1_rev3[0]), 27, 320, 32}
+	,
+	{&loft_lut_core0_rev3,
+	 sizeof(loft_lut_core0_rev3) / sizeof(loft_lut_core0_rev3[0]), 26, 448,
+	 16}
+	,
+	{&loft_lut_core1_rev3,
+	 sizeof(loft_lut_core1_rev3) / sizeof(loft_lut_core1_rev3[0]), 27, 448,
+	 16}
+	,
+	{&papd_comp_rfpwr_tbl_core0_rev3,
+	 sizeof(papd_comp_rfpwr_tbl_core0_rev3) /
+	 sizeof(papd_comp_rfpwr_tbl_core0_rev3[0]), 26, 576, 16}
+	,
+	{&papd_comp_rfpwr_tbl_core1_rev3,
+	 sizeof(papd_comp_rfpwr_tbl_core1_rev3) /
+	 sizeof(papd_comp_rfpwr_tbl_core1_rev3[0]), 27, 576, 16}
+	,
+	{&papd_comp_epsilon_tbl_core0_rev7,
+	 sizeof(papd_comp_epsilon_tbl_core0_rev7) /
+	 sizeof(papd_comp_epsilon_tbl_core0_rev7[0]), 31, 0, 32}
+	,
+	{&papd_cal_scalars_tbl_core0_rev7,
+	 sizeof(papd_cal_scalars_tbl_core0_rev7) /
+	 sizeof(papd_cal_scalars_tbl_core0_rev7[0]), 32, 0, 32}
+	,
+	{&papd_comp_epsilon_tbl_core1_rev7,
+	 sizeof(papd_comp_epsilon_tbl_core1_rev7) /
+	 sizeof(papd_comp_epsilon_tbl_core1_rev7[0]), 33, 0, 32}
+	,
+	{&papd_cal_scalars_tbl_core1_rev7,
+	 sizeof(papd_cal_scalars_tbl_core1_rev7) /
+	 sizeof(papd_cal_scalars_tbl_core1_rev7[0]), 34, 0, 32}
+	,
+};
+
+CONST uint32 mimophytbl_info_sz_rev7 =
+    sizeof(mimophytbl_info_rev7) / sizeof(mimophytbl_info_rev7[0]);
+
+CONST mimophytbl_info_t mimophytbl_info_rev16[] = {
+	{&noise_var_tbl_rev7,
+	 sizeof(noise_var_tbl_rev7) / sizeof(noise_var_tbl_rev7[0]), 16, 0, 32}
+	,
+	{&est_pwr_lut_core0_rev3,
+	 sizeof(est_pwr_lut_core0_rev3) / sizeof(est_pwr_lut_core0_rev3[0]), 26,
+	 0, 8}
+	,
+	{&est_pwr_lut_core1_rev3,
+	 sizeof(est_pwr_lut_core1_rev3) / sizeof(est_pwr_lut_core1_rev3[0]), 27,
+	 0, 8}
+	,
+	{&adj_pwr_lut_core0_rev3,
+	 sizeof(adj_pwr_lut_core0_rev3) / sizeof(adj_pwr_lut_core0_rev3[0]), 26,
+	 64, 8}
+	,
+	{&adj_pwr_lut_core1_rev3,
+	 sizeof(adj_pwr_lut_core1_rev3) / sizeof(adj_pwr_lut_core1_rev3[0]), 27,
+	 64, 8}
+	,
+	{&gainctrl_lut_core0_rev3,
+	 sizeof(gainctrl_lut_core0_rev3) / sizeof(gainctrl_lut_core0_rev3[0]),
+	 26, 192, 32}
+	,
+	{&gainctrl_lut_core1_rev3,
+	 sizeof(gainctrl_lut_core1_rev3) / sizeof(gainctrl_lut_core1_rev3[0]),
+	 27, 192, 32}
+	,
+	{&iq_lut_core0_rev3,
+	 sizeof(iq_lut_core0_rev3) / sizeof(iq_lut_core0_rev3[0]), 26, 320, 32}
+	,
+	{&iq_lut_core1_rev3,
+	 sizeof(iq_lut_core1_rev3) / sizeof(iq_lut_core1_rev3[0]), 27, 320, 32}
+	,
+	{&loft_lut_core0_rev3,
+	 sizeof(loft_lut_core0_rev3) / sizeof(loft_lut_core0_rev3[0]), 26, 448,
+	 16}
+	,
+	{&loft_lut_core1_rev3,
+	 sizeof(loft_lut_core1_rev3) / sizeof(loft_lut_core1_rev3[0]), 27, 448,
+	 16}
+	,
+};
+
+CONST uint32 mimophytbl_info_sz_rev16 =
+    sizeof(mimophytbl_info_rev16) / sizeof(mimophytbl_info_rev16[0]);
diff --git a/drivers/staging/brcm80211/phy/wlc_phytbl_n.h b/drivers/staging/brcm80211/phy/wlc_phytbl_n.h
new file mode 100644
index 0000000..108197c
--- /dev/null
+++ b/drivers/staging/brcm80211/phy/wlc_phytbl_n.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define ANT_SWCTRL_TBL_REV3_IDX (0)
+
+typedef phytbl_info_t mimophytbl_info_t;
+
+extern CONST mimophytbl_info_t mimophytbl_info_rev0[],
+    mimophytbl_info_rev0_volatile[];
+extern CONST uint32 mimophytbl_info_sz_rev0, mimophytbl_info_sz_rev0_volatile;
+
+extern CONST mimophytbl_info_t mimophytbl_info_rev3[],
+    mimophytbl_info_rev3_volatile[], mimophytbl_info_rev3_volatile1[],
+    mimophytbl_info_rev3_volatile2[], mimophytbl_info_rev3_volatile3[];
+extern CONST uint32 mimophytbl_info_sz_rev3, mimophytbl_info_sz_rev3_volatile,
+    mimophytbl_info_sz_rev3_volatile1, mimophytbl_info_sz_rev3_volatile2,
+    mimophytbl_info_sz_rev3_volatile3;
+
+extern CONST uint32 noise_var_tbl_rev3[];
+
+extern CONST mimophytbl_info_t mimophytbl_info_rev7[];
+extern CONST uint32 mimophytbl_info_sz_rev7;
+extern CONST uint32 noise_var_tbl_rev7[];
+
+extern CONST mimophytbl_info_t mimophytbl_info_rev16[];
+extern CONST uint32 mimophytbl_info_sz_rev16;
diff --git a/drivers/staging/brcm80211/sys/d11ucode_ext.h b/drivers/staging/brcm80211/sys/d11ucode_ext.h
new file mode 100644
index 0000000..c0c0d66
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/d11ucode_ext.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+enum {
+	D11UCODE_NAMETAG_START = 0,
+	D11LCN0BSINITVALS24,
+	D11LCN0INITVALS24,
+	D11LCN1BSINITVALS24,
+	D11LCN1INITVALS24,
+	D11LCN2BSINITVALS24,
+	D11LCN2INITVALS24,
+	D11N0ABSINITVALS16,
+	D11N0BSINITVALS16,
+	D11N0INITVALS16,
+	D11UCODE_OVERSIGHT16_MIMO,
+	D11UCODE_OVERSIGHT16_MIMOSZ,
+	D11UCODE_OVERSIGHT24_LCN,
+	D11UCODE_OVERSIGHT24_LCNSZ,
+	D11UCODE_OVERSIGHT_BOMMAJOR,
+	D11UCODE_OVERSIGHT_BOMMINOR
+};
+#define UCODE_LOADER_API_VER 0
diff --git a/drivers/staging/brcm80211/sys/wl_dbg.h b/drivers/staging/brcm80211/sys/wl_dbg.h
new file mode 100644
index 0000000..a2dd359
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wl_dbg.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wl_dbg_h_
+#define _wl_dbg_h_
+
+/* wl_msg_level is a bit vector with defs in wlioctl.h */
+extern uint32 wl_msg_level;
+
+#define WL_PRINT(args)		printf args
+#define WL_NONE(args)
+
+#ifdef BCMDBG
+
+#define	WL_ERROR(args)		do {if ((wl_msg_level & WL_ERROR_VAL)) WL_PRINT(args);} while (0)
+#define	WL_TRACE(args)		do {if (wl_msg_level & WL_TRACE_VAL) WL_PRINT(args);} while (0)
+#define WL_AMPDU(args)		do {if (wl_msg_level & WL_AMPDU_VAL) WL_PRINT(args);} while (0)
+#define WL_FFPLD(args)		do {if (wl_msg_level & WL_FFPLD_VAL) WL_PRINT(args);} while (0)
+
+#define WL_ERROR_ON()		(wl_msg_level & WL_ERROR_VAL)
+
+/* Extra message control for AMPDU debugging */
+#define   WL_AMPDU_UPDN_VAL	0x00000001	/* Config up/down related  */
+#define   WL_AMPDU_ERR_VAL	0x00000002	/* Calls to beaocn update  */
+#define   WL_AMPDU_TX_VAL	0x00000004	/* Transmit data path */
+#define   WL_AMPDU_RX_VAL	0x00000008	/* Receive data path  */
+#define   WL_AMPDU_CTL_VAL	0x00000010	/* TSF-related items  */
+#define   WL_AMPDU_HW_VAL       0x00000020	/* AMPDU_HW */
+#define   WL_AMPDU_HWTXS_VAL    0x00000040	/* AMPDU_HWTXS */
+#define   WL_AMPDU_HWDBG_VAL    0x00000080	/* AMPDU_DBG */
+
+extern uint32 wl_ampdu_dbg;
+
+#define WL_AMPDU_UPDN(args) do {if (wl_ampdu_dbg & WL_AMPDU_UPDN_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_RX(args) do {if (wl_ampdu_dbg & WL_AMPDU_RX_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_ERR(args) do {if (wl_ampdu_dbg & WL_AMPDU_ERR_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_TX(args) do {if (wl_ampdu_dbg & WL_AMPDU_TX_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_CTL(args) do {if (wl_ampdu_dbg & WL_AMPDU_CTL_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_HW(args) do {if (wl_ampdu_dbg & WL_AMPDU_HW_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_HWTXS(args) do {if (wl_ampdu_dbg & WL_AMPDU_HWTXS_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_HWDBG(args) do {if (wl_ampdu_dbg & WL_AMPDU_HWDBG_VAL) {WL_AMPDU(args);}} while (0)
+#define WL_AMPDU_ERR_ON() (wl_ampdu_dbg & WL_AMPDU_ERR_VAL)
+#define WL_AMPDU_HW_ON() (wl_ampdu_dbg & WL_AMPDU_HW_VAL)
+#define WL_AMPDU_HWTXS_ON() (wl_ampdu_dbg & WL_AMPDU_HWTXS_VAL)
+
+#else				/* BCMDBG */
+
+#define	WL_ERROR(args)
+#define	WL_TRACE(args)
+#define WL_AMPDU(args)
+#define WL_FFPLD(args)
+
+#define WL_ERROR_ON()		0
+
+#define WL_AMPDU_UPDN(args)
+#define WL_AMPDU_RX(args)
+#define WL_AMPDU_ERR(args)
+#define WL_AMPDU_TX(args)
+#define WL_AMPDU_CTL(args)
+#define WL_AMPDU_HW(args)
+#define WL_AMPDU_HWTXS(args)
+#define WL_AMPDU_HWDBG(args)
+#define WL_AMPDU_ERR_ON()       0
+#define WL_AMPDU_HW_ON()        0
+#define WL_AMPDU_HWTXS_ON()     0
+
+#endif				/* BCMDBG */
+
+#endif				/* _wl_dbg_h_ */
diff --git a/drivers/staging/brcm80211/sys/wl_export.h b/drivers/staging/brcm80211/sys/wl_export.h
new file mode 100644
index 0000000..3bf493a
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wl_export.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wl_export_h_
+#define _wl_export_h_
+
+/* misc callbacks */
+struct wl_info;
+struct wl_if;
+struct wlc_if;
+extern void wl_init(struct wl_info *wl);
+extern uint wl_reset(struct wl_info *wl);
+extern void wl_intrson(struct wl_info *wl);
+extern uint32 wl_intrsoff(struct wl_info *wl);
+extern void wl_intrsrestore(struct wl_info *wl, uint32 macintmask);
+extern void wl_event(struct wl_info *wl, char *ifname, wlc_event_t * e);
+extern void wl_event_sendup(struct wl_info *wl, const wlc_event_t * e,
+			    uint8 * data, uint32 len);
+extern int wl_up(struct wl_info *wl);
+extern void wl_down(struct wl_info *wl);
+extern void wl_txflowcontrol(struct wl_info *wl, struct wl_if *wlif, bool state,
+			     int prio);
+extern bool wl_alloc_dma_resources(struct wl_info *wl, uint dmaddrwidth);
+
+/* timer functions */
+struct wl_timer;
+extern struct wl_timer *wl_init_timer(struct wl_info *wl,
+				      void (*fn) (void *arg), void *arg,
+				      const char *name);
+extern void wl_free_timer(struct wl_info *wl, struct wl_timer *timer);
+extern void wl_add_timer(struct wl_info *wl, struct wl_timer *timer, uint ms,
+			 int periodic);
+extern bool wl_del_timer(struct wl_info *wl, struct wl_timer *timer);
+
+extern uint wl_buf_to_pktcopy(osl_t * osh, void *p, uchar * buf, int len,
+			      uint offset);
+extern void *wl_get_pktbuffer(osl_t * osh, int len);
+extern int wl_set_pktlen(osl_t * osh, void *p, int len);
+
+#define wl_sort_bsslist(a, b) FALSE
+
+extern int wl_tkip_miccheck(struct wl_info *wl, void *p, int hdr_len,
+			    bool group_key, int id);
+extern int wl_tkip_micadd(struct wl_info *wl, void *p, int hdr_len);
+extern int wl_tkip_encrypt(struct wl_info *wl, void *p, int hdr_len);
+extern int wl_tkip_decrypt(struct wl_info *wl, void *p, int hdr_len,
+			   bool group_key);
+extern void wl_tkip_printstats(struct wl_info *wl, bool group_key);
+extern int wl_tkip_keyset(struct wl_info *wl, wsec_key_t * key);
+#endif				/* _wl_export_h_ */
diff --git a/drivers/staging/brcm80211/sys/wl_mac80211.c b/drivers/staging/brcm80211/sys/wl_mac80211.c
new file mode 100644
index 0000000..d73ec44
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.c
@@ -0,0 +1,2547 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define __UNDEF_NO_VERSION__
+
+#include <typedefs.h>
+#include <linuxver.h>
+#include <osl.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/ethtool.h>
+#include <linux/completion.h>
+#include <linux/pci_ids.h>
+#define WLC_MAXBSSCFG		1	/* single BSS configs */
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
+#include <wlc_cfg.h>
+#include <net/mac80211.h>
+#include <epivers.h>
+#ifndef WLC_HIGH_ONLY
+#include <phy_version.h>
+#endif
+#include <bcmendian.h>
+#include <bcmutils.h>
+#include <pcicfg.h>
+#include <wlioctl.h>
+#include <wlc_key.h>
+#include <proto/802.1d.h>	/* NUMPRIO & BE */
+#include <linux/proc_fs.h>
+#include <linux/vmalloc.h>
+#include <wlc_channel.h>
+#include <wlc_pub.h>
+#include <wlc_scb.h>
+#include <wl_dbg.h>
+#ifdef BCMSDIO
+#include <bcmsdh.h>
+#endif
+#include <wl_export.h>
+#ifdef WLC_HIGH_ONLY
+#include "dbus.h"
+#include "bcm_rpc_tp.h"
+#include "bcm_rpc.h"
+#include "bcm_xdr.h"
+#include "wlc_rpc.h"
+#endif
+
+#include <wl_mac80211.h>
+#include <linux/firmware.h>
+#ifndef WLC_HIGH_ONLY
+#include <wl_ucode.h>
+#include <d11ucode_ext.h>
+#endif
+
+#ifdef BCMSDIO
+extern struct device *sdiommc_dev;
+#endif
+
+extern void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg,
+			      bool suspend);
+bool wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw);
+void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc);
+void wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+		       const struct ether_addr *addr);
+
+static void wl_timer(ulong data);
+static void _wl_timer(wl_timer_t * t);
+
+/* proc fs */
+static int wl_proc_read(char *buffer, char **start, off_t offset, int length,
+			int *eof, void *data);
+static int wl_proc_write(struct file *filp, const char __user * buff,
+			 unsigned long len, void *data);
+
+#ifdef WLC_HIGH_ONLY
+#define RPCQ_LOCK(_wl, _flags) spin_lock_irqsave(&(_wl)->rpcq_lock, (_flags))
+#define RPCQ_UNLOCK(_wl, _flags)  spin_unlock_irqrestore(&(_wl)->rpcq_lock, (_flags))
+#define TXQ_LOCK(_wl, _flags) spin_lock_irqsave(&(_wl)->txq_lock, (_flags))
+#define TXQ_UNLOCK(_wl, _flags)  spin_unlock_irqrestore(&(_wl)->txq_lock, (_flags))
+static void wl_rpc_down(void *wlh);
+static void wl_rpcq_free(wl_info_t * wl);
+static void wl_rpcq_dispatch(struct wl_task *task);
+static void wl_rpc_dispatch_schedule(void *ctx, struct rpc_buf *buf);
+static void wl_start_txqwork(struct wl_task *task);
+static void wl_txq_free(wl_info_t * wl);
+static void wl_timer_task(wl_task_t * task);
+static int wl_schedule_task(wl_info_t * wl, void (*fn) (struct wl_task *),
+			    void *context);
+#endif				/* WLC_HIGH_ONLY */
+
+static int ieee_hw_init(struct ieee80211_hw *hw);
+static int ieee_hw_rate_init(struct ieee80211_hw *hw);
+
+static int wl_linux_watchdog(void *ctx);
+
+/* Flags we support */
+#define MAC_FILTERS (FIF_PROMISC_IN_BSS | \
+	FIF_ALLMULTI | \
+	FIF_FCSFAIL | \
+	FIF_PLCPFAIL | \
+	FIF_CONTROL | \
+	FIF_OTHER_BSS | \
+	FIF_BCN_PRBRESP_PROMISC)
+
+static int wl_found = 0;
+
+struct ieee80211_tkip_data {
+#define TKIP_KEY_LEN 32
+	u8 key[TKIP_KEY_LEN];
+	int key_set;
+
+	u32 tx_iv32;
+	u16 tx_iv16;
+	u16 tx_ttak[5];
+	int tx_phase1_done;
+
+	u32 rx_iv32;
+	u16 rx_iv16;
+	u16 rx_ttak[5];
+	int rx_phase1_done;
+	u32 rx_iv32_new;
+	u16 rx_iv16_new;
+
+	u32 dot11RSNAStatsTKIPReplays;
+	u32 dot11RSNAStatsTKIPICVErrors;
+	u32 dot11RSNAStatsTKIPLocalMICFailures;
+
+	int key_idx;
+
+	struct crypto_tfm *tfm_arc4;
+	struct crypto_tfm *tfm_michael;
+
+	/* scratch buffers for virt_to_page() (crypto API) */
+	u8 rx_hdr[16], tx_hdr[16];
+};
+
+#ifndef WLC_HIGH_ONLY
+#define	WL_INFO(dev)		((wl_info_t*)(WL_DEV_IF(dev)->wl))	/* points to wl */
+static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev);
+static void wl_release_fw(wl_info_t * wl);
+#endif
+
+/* local prototypes */
+static int wl_start(struct sk_buff *skb, wl_info_t * wl);
+static int wl_start_int(wl_info_t * wl, struct ieee80211_hw *hw,
+			struct sk_buff *skb);
+static void wl_dpc(ulong data);
+
+MODULE_AUTHOR("Broadcom Corporation");
+MODULE_DESCRIPTION("Broadcom 802.11n wireless LAN driver.");
+MODULE_SUPPORTED_DEVICE("Broadcom 802.11n WLAN cards");
+MODULE_LICENSE("Dual BSD/GPL");
+
+#ifndef BCMSDIO
+/* recognized PCI IDs */
+static struct pci_device_id wl_id_table[] = {
+	{PCI_VENDOR_ID_BROADCOM, 0x4357, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},	/* 43225 2G */
+	{PCI_VENDOR_ID_BROADCOM, 0x4353, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},	/* 43224 DUAL */
+	{PCI_VENDOR_ID_BROADCOM, 0x4727, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},	/* 4313 DUAL */
+	{0}
+};
+
+MODULE_DEVICE_TABLE(pci, wl_id_table);
+#endif				/* !BCMSDIO */
+
+#ifdef BCMSDIO
+static uint sd_drivestrength = 6;
+module_param(sd_drivestrength, uint, 0);
+#endif
+
+#ifdef BCMDBG
+static int msglevel = 0xdeadbeef;
+module_param(msglevel, int, 0);
+#ifndef WLC_HIGH_ONLY
+static int phymsglevel = 0xdeadbeef;
+module_param(phymsglevel, int, 0);
+#endif				/* WLC_HIGH_ONLY */
+#endif				/* BCMDBG */
+
+static int oneonly = 0;
+module_param(oneonly, int, 0);
+
+static int piomode = 0;
+module_param(piomode, int, 0);
+
+static int instance_base = 0;	/* Starting instance number */
+module_param(instance_base, int, 0);
+
+#if defined(BCMDBG)
+static char *macaddr = NULL;
+module_param(macaddr, charp, S_IRUGO);
+#endif
+
+static int nompc = 1;
+module_param(nompc, int, 0);
+
+static char name[IFNAMSIZ] = "eth%d";
+module_param_string(name, name, IFNAMSIZ, 0);
+
+#ifndef	SRCBASE
+#define	SRCBASE "."
+#endif
+
+#define WL_MAGIC 	0xdeadbeef
+
+#define HW_TO_WL(hw)	 hw->priv
+#define WL_TO_HW(wl)	  wl->pub->ieee_hw
+#ifdef WLC_HIGH_ONLY
+static int wl_ops_tx_nl(struct ieee80211_hw *hw, struct sk_buff *skb);
+#else
+static int wl_ops_tx(struct ieee80211_hw *hw, struct sk_buff *skb);
+#endif
+static int wl_ops_start(struct ieee80211_hw *hw);
+static void wl_ops_stop(struct ieee80211_hw *hw);
+static int wl_ops_add_interface(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif);
+static void wl_ops_remove_interface(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif);
+static int wl_ops_config(struct ieee80211_hw *hw, u32 changed);
+static void wl_ops_bss_info_changed(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif,
+				    struct ieee80211_bss_conf *info,
+				    u32 changed);
+static void wl_ops_configure_filter(struct ieee80211_hw *hw,
+				    unsigned int changed_flags,
+				    unsigned int *total_flags, u64 multicast);
+static int wl_ops_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,
+			  bool set);
+static void wl_ops_sw_scan_start(struct ieee80211_hw *hw);
+static void wl_ops_sw_scan_complete(struct ieee80211_hw *hw);
+static void wl_ops_set_tsf(struct ieee80211_hw *hw, u64 tsf);
+static int wl_ops_get_stats(struct ieee80211_hw *hw,
+			    struct ieee80211_low_level_stats *stats);
+static int wl_ops_set_rts_threshold(struct ieee80211_hw *hw, u32 value);
+static void wl_ops_sta_notify(struct ieee80211_hw *hw,
+			      struct ieee80211_vif *vif,
+			      enum sta_notify_cmd cmd,
+			      struct ieee80211_sta *sta);
+static int wl_ops_conf_tx(struct ieee80211_hw *hw, u16 queue,
+			  const struct ieee80211_tx_queue_params *params);
+static u64 wl_ops_get_tsf(struct ieee80211_hw *hw);
+static int wl_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      struct ieee80211_sta *sta);
+static int wl_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			 struct ieee80211_sta *sta);
+static int wl_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			   enum ieee80211_ampdu_mlme_action action,
+			   struct ieee80211_sta *sta, u16 tid, u16 * ssn);
+
+#ifdef WLC_HIGH_ONLY
+static int wl_ops_tx_nl(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	int status;
+	wl_info_t *wl = hw->priv;
+	if (!wl->pub->up) {
+		WL_ERROR(("ops->tx called while down\n"));
+		status = -ENETDOWN;
+		goto done;
+	}
+	status = wl_start(skb, wl);
+ done:
+	return status;
+}
+#else
+static int wl_ops_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+	int status;
+	wl_info_t *wl = hw->priv;
+	WL_LOCK(wl);
+	if (!wl->pub->up) {
+		WL_ERROR(("ops->tx called while down\n"));
+		status = -ENETDOWN;
+		goto done;
+	}
+	status = wl_start(skb, wl);
+ done:
+	WL_UNLOCK(wl);
+	return status;
+}
+#endif				/* WLC_HIGH_ONLY */
+
+static int wl_ops_start(struct ieee80211_hw *hw)
+{
+	wl_info_t *wl = hw->priv;
+	/* struct ieee80211_channel *curchan = hw->conf.channel; */
+	WL_NONE(("%s : Initial channel: %d\n", __func__, curchan->hw_value));
+
+	WL_LOCK(wl);
+	ieee80211_wake_queues(hw);
+	WL_UNLOCK(wl);
+
+	return 0;
+}
+
+static void wl_ops_stop(struct ieee80211_hw *hw)
+{
+	wl_info_t *wl = hw->priv;
+	ASSERT(wl);
+	WL_LOCK(wl);
+	wl_down(wl);
+	ieee80211_stop_queues(hw);
+	WL_UNLOCK(wl);
+
+	return;
+}
+
+static int
+wl_ops_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	wl_info_t *wl;
+	int err;
+
+	/* Just STA for now */
+	if (vif->type != NL80211_IFTYPE_AP &&
+	    vif->type != NL80211_IFTYPE_MESH_POINT &&
+	    vif->type != NL80211_IFTYPE_STATION &&
+	    vif->type != NL80211_IFTYPE_WDS &&
+	    vif->type != NL80211_IFTYPE_ADHOC) {
+		WL_ERROR(("%s: Attempt to add type %d, only STA for now\n",
+			  __func__, vif->type));
+		return -EOPNOTSUPP;
+	}
+
+	wl = HW_TO_WL(hw);
+	WL_LOCK(wl);
+	err = wl_up(wl);
+	WL_UNLOCK(wl);
+
+	if (err != 0)
+		WL_ERROR(("%s: wl_up() returned %d\n", __func__, err));
+	return err;
+}
+
+static void
+wl_ops_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	return;
+}
+
+static int
+ieee_set_channel(struct ieee80211_hw *hw, struct ieee80211_channel *chan,
+		 enum nl80211_channel_type type)
+{
+	wl_info_t *wl = HW_TO_WL(hw);
+	int err = 0;
+
+	switch (type) {
+	case NL80211_CHAN_HT20:
+	case NL80211_CHAN_NO_HT:
+		WL_LOCK(wl);
+		err = wlc_set(wl->wlc, WLC_SET_CHANNEL, chan->hw_value);
+		WL_UNLOCK(wl);
+		break;
+	case NL80211_CHAN_HT40MINUS:
+	case NL80211_CHAN_HT40PLUS:
+		WL_ERROR(("%s: Need to implement 40 Mhz Channels!\n",
+			  __func__));
+		break;
+	}
+
+	if (err)
+		return -EIO;
+	return err;
+}
+
+static int wl_ops_config(struct ieee80211_hw *hw, u32 changed)
+{
+	struct ieee80211_conf *conf = &hw->conf;
+	wl_info_t *wl = HW_TO_WL(hw);
+	int err = 0;
+	int new_int;
+
+	if (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {
+		WL_NONE(("%s: Setting listen interval to %d\n",
+			 __func__, conf->listen_interval));
+		if (wlc_iovar_setint
+		    (wl->wlc, "bcn_li_bcn", conf->listen_interval)) {
+			WL_ERROR(("%s: Error setting listen_interval\n",
+				  __func__));
+			err = -EIO;
+			goto config_out;
+		}
+		wlc_iovar_getint(wl->wlc, "bcn_li_bcn", &new_int);
+		ASSERT(new_int == conf->listen_interval);
+	}
+	if (changed & IEEE80211_CONF_CHANGE_MONITOR)
+		WL_NONE(("Need to set monitor mode\n"));
+	if (changed & IEEE80211_CONF_CHANGE_PS)
+		WL_NONE(("Need to set Power-save mode\n"));
+
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		WL_NONE(("%s: Setting tx power to %d dbm\n", __func__,
+			 conf->power_level));
+		if (wlc_iovar_setint
+		    (wl->wlc, "qtxpower", conf->power_level * 4)) {
+			WL_ERROR(("%s: Error setting power_level\n", __func__));
+			err = -EIO;
+			goto config_out;
+		}
+		wlc_iovar_getint(wl->wlc, "qtxpower", &new_int);
+		if (new_int != (conf->power_level * 4))
+			WL_ERROR(("%s: Power level req != actual, %d %d\n",
+				  __func__, conf->power_level * 4, new_int));
+	}
+	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+		err = ieee_set_channel(hw, conf->channel, conf->channel_type);
+	}
+	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {
+		WL_NONE(("%s: srl %d, lrl %d\n", __func__,
+			 conf->short_frame_max_tx_count,
+			 conf->long_frame_max_tx_count));
+		if (wlc_set
+		    (wl->wlc, WLC_SET_SRL,
+		     conf->short_frame_max_tx_count) < 0) {
+			WL_ERROR(("%s: Error setting srl\n", __func__));
+			err = -EIO;
+			goto config_out;
+		}
+		if (wlc_set(wl->wlc, WLC_SET_LRL, conf->long_frame_max_tx_count)
+		    < 0) {
+			WL_ERROR(("%s: Error setting lrl\n", __func__));
+			err = -EIO;
+			goto config_out;
+		}
+	}
+
+ config_out:
+	return err;
+}
+
+static void
+wl_ops_bss_info_changed(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif,
+			struct ieee80211_bss_conf *info, u32 changed)
+{
+	wl_info_t *wl = HW_TO_WL(hw);
+	int val;
+
+#ifdef WLC_HIGH_ONLY
+	WL_LOCK(wl);
+#endif
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		WL_ERROR(("Associated:\t%s\n", info->assoc ? "True" : "False"));
+		/* association status changed (associated/disassociated)
+		 * also implies a change in the AID.
+		 */
+	}
+	if (changed & BSS_CHANGED_ERP_CTS_PROT) {
+		WL_NONE(("Use_cts_prot:\t%s Implement me\n",
+			 info->use_cts_prot ? "True" : "False"));
+		/* CTS protection changed */
+	}
+	if (changed & BSS_CHANGED_ERP_PREAMBLE) {
+		WL_NONE(("Short preamble:\t%s Implement me\n",
+			 info->use_short_preamble ? "True" : "False"));
+		/* preamble changed */
+	}
+	if (changed & BSS_CHANGED_ERP_SLOT) {
+		WL_NONE(("Changing short slot:\t%s\n",
+			 info->use_short_slot ? "True" : "False"));
+		if (info->use_short_slot)
+			val = 1;
+		else
+			val = 0;
+		wlc_set(wl->wlc, WLC_SET_SHORTSLOT_OVERRIDE, val);
+		/* slot timing changed */
+	}
+
+	if (changed & BSS_CHANGED_HT) {
+		WL_NONE(("%s: HT mode - Implement me\n", __func__));
+		/* 802.11n parameters changed */
+	}
+	if (changed & BSS_CHANGED_BASIC_RATES) {
+		WL_NONE(("Need to change Basic Rates:\t0x%x! Implement me\n",
+			 (uint32) info->basic_rates));
+		/* Basic rateset changed */
+	}
+	if (changed & BSS_CHANGED_BEACON_INT) {
+		WL_NONE(("Beacon Interval:\t%d Implement me\n",
+			 info->beacon_int));
+		/* Beacon interval changed */
+	}
+	if (changed & BSS_CHANGED_BSSID) {
+		/* char eabuf[ETHER_ADDR_STR_LEN]; */
+		WL_NONE(("new BSSID:\taid %d  bss:%s\n",
+			 info->aid,
+			 bcm_ether_ntoa((struct ether_addr *)info->bssid,
+					eabuf)));
+		/* BSSID changed, for whatever reason (IBSS and managed mode) */
+		/* FIXME: need to store bssid in bsscfg */
+		wlc_set_addrmatch(wl->wlc, RCM_BSSID_OFFSET,
+				  (struct ether_addr *)info->bssid);
+	}
+	if (changed & BSS_CHANGED_BEACON) {
+		WL_ERROR(("BSS_CHANGED_BEACON\n"));
+		/* Beacon data changed, retrieve new beacon (beaconing modes) */
+	}
+	if (changed & BSS_CHANGED_BEACON_ENABLED) {
+		WL_ERROR(("Beacon enabled:\t%s\n",
+			  info->enable_beacon ? "True" : "False"));
+		/* Beaconing should be enabled/disabled (beaconing modes) */
+	}
+#ifdef WLC_HIGH_ONLY
+	WL_UNLOCK(wl);
+#endif
+	return;
+}
+
+static void
+wl_ops_configure_filter(struct ieee80211_hw *hw,
+			unsigned int changed_flags,
+			unsigned int *total_flags, u64 multicast)
+{
+#ifndef WLC_HIGH_ONLY
+	wl_info_t *wl = hw->priv;
+#endif
+
+	changed_flags &= MAC_FILTERS;
+	*total_flags &= MAC_FILTERS;
+	if (changed_flags & FIF_PROMISC_IN_BSS)
+		WL_ERROR(("FIF_PROMISC_IN_BSS\n"));
+	if (changed_flags & FIF_ALLMULTI)
+		WL_ERROR(("FIF_ALLMULTI\n"));
+	if (changed_flags & FIF_FCSFAIL)
+		WL_ERROR(("FIF_FCSFAIL\n"));
+	if (changed_flags & FIF_PLCPFAIL)
+		WL_ERROR(("FIF_PLCPFAIL\n"));
+	if (changed_flags & FIF_CONTROL)
+		WL_ERROR(("FIF_CONTROL\n"));
+	if (changed_flags & FIF_OTHER_BSS)
+		WL_ERROR(("FIF_OTHER_BSS\n"));
+	if (changed_flags & FIF_BCN_PRBRESP_PROMISC) {
+		WL_NONE(("FIF_BCN_PRBRESP_PROMISC\n"));
+#ifndef WLC_HIGH_ONLY
+		WL_LOCK(wl);
+		if (*total_flags & FIF_BCN_PRBRESP_PROMISC) {
+			wl->pub->mac80211_state |= MAC80211_PROMISC_BCNS;
+			wlc_mac_bcn_promisc_change(wl->wlc, 1);
+		} else {
+			wlc_mac_bcn_promisc_change(wl->wlc, 0);
+			wl->pub->mac80211_state &= ~MAC80211_PROMISC_BCNS;
+		}
+		WL_UNLOCK(wl);
+#endif
+	}
+	return;
+}
+
+static int
+wl_ops_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)
+{
+	WL_ERROR(("%s: Enter\n", __func__));
+	return 0;
+}
+
+static void wl_ops_sw_scan_start(struct ieee80211_hw *hw)
+{
+	WL_NONE(("Scan Start\n"));
+	return;
+}
+
+static void wl_ops_sw_scan_complete(struct ieee80211_hw *hw)
+{
+	WL_NONE(("Scan Complete\n"));
+	return;
+}
+
+static void wl_ops_set_tsf(struct ieee80211_hw *hw, u64 tsf)
+{
+	WL_ERROR(("%s: Enter\n", __func__));
+	return;
+}
+
+static int
+wl_ops_get_stats(struct ieee80211_hw *hw,
+		 struct ieee80211_low_level_stats *stats)
+{
+	WL_ERROR(("%s: Enter\n", __func__));
+	return 0;
+}
+
+static int wl_ops_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
+{
+	WL_ERROR(("%s: Enter\n", __func__));
+	return 0;
+}
+
+static void
+wl_ops_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		  enum sta_notify_cmd cmd, struct ieee80211_sta *sta)
+{
+	WL_NONE(("%s: Enter\n", __func__));
+	switch (cmd) {
+	default:
+		WL_ERROR(("%s: Uknown cmd = %d\n", __func__, cmd));
+		break;
+	}
+	return;
+}
+
+static int
+wl_ops_conf_tx(struct ieee80211_hw *hw, u16 queue,
+	       const struct ieee80211_tx_queue_params *params)
+{
+	wl_info_t *wl = hw->priv;
+
+	WL_NONE(("%s: Enter (WME config)\n", __func__));
+	WL_NONE(("queue %d, txop %d, cwmin %d, cwmax %d, aifs %d\n", queue,
+		 params->txop, params->cw_min, params->cw_max, params->aifs));
+
+	WL_LOCK(wl);
+	wlc_wme_setparams(wl->wlc, queue, (void *)params, TRUE);
+	WL_UNLOCK(wl);
+
+	return 0;
+}
+
+static u64 wl_ops_get_tsf(struct ieee80211_hw *hw)
+{
+	WL_ERROR(("%s: Enter\n", __func__));
+	return 0;
+}
+
+static int
+wl_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+	   struct ieee80211_sta *sta)
+{
+	struct scb *scb;
+
+	int i;
+	wl_info_t *wl = hw->priv;
+
+	/* Init the scb */
+	scb = (struct scb *)sta->drv_priv;
+	bzero(scb, sizeof(struct scb));
+	for (i = 0; i < NUMPRIO; i++)
+		scb->seqctl[i] = 0xFFFF;
+	scb->seqctl_nonqos = 0xFFFF;
+	scb->magic = SCB_MAGIC;
+
+	wl->pub->global_scb = scb;
+	wl->pub->global_ampdu = &(scb->scb_ampdu);
+	wl->pub->global_ampdu->scb = scb;
+#ifdef WLC_HIGH_ONLY
+	wl->pub->global_ampdu->max_pdu = AMPDU_NUM_MPDU;
+#else
+	wl->pub->global_ampdu->max_pdu = 16;
+#endif
+	pktq_init(&scb->scb_ampdu.txq, AMPDU_MAX_SCB_TID,
+		  AMPDU_MAX_SCB_TID * PKTQ_LEN_DEFAULT);
+
+	sta->ht_cap.ht_supported = TRUE;
+#ifdef WLC_HIGH_ONLY
+	sta->ht_cap.ampdu_factor = AMPDU_RX_FACTOR_16K;
+#else
+	sta->ht_cap.ampdu_factor = AMPDU_RX_FACTOR_64K;
+#endif
+	sta->ht_cap.ampdu_density = AMPDU_DEF_MPDU_DENSITY;
+	sta->ht_cap.cap = IEEE80211_HT_CAP_GRN_FLD |
+	    IEEE80211_HT_CAP_SGI_20 |
+	    IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_40MHZ_INTOLERANT;
+
+	/* minstrel_ht initiates addBA on our behalf by calling ieee80211_start_tx_ba_session() */
+	return 0;
+}
+
+static int
+wl_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+	      struct ieee80211_sta *sta)
+{
+	WL_NONE(("%s: Enter\n", __func__));
+	return 0;
+}
+
+static int
+wl_ampdu_action(struct ieee80211_hw *hw,
+		struct ieee80211_vif *vif,
+		enum ieee80211_ampdu_mlme_action action,
+		struct ieee80211_sta *sta, u16 tid, u16 * ssn)
+{
+#if defined(BCMDBG)
+	struct scb *scb = (struct scb *)sta->drv_priv;
+#endif
+	wl_info_t *wl = hw->priv;
+
+	ASSERT(scb->magic == SCB_MAGIC);
+	switch (action) {
+	case IEEE80211_AMPDU_RX_START:
+		WL_NONE(("%s: action = IEEE80211_AMPDU_RX_START\n", __func__));
+		break;
+	case IEEE80211_AMPDU_RX_STOP:
+		WL_NONE(("%s: action = IEEE80211_AMPDU_RX_STOP\n", __func__));
+		break;
+	case IEEE80211_AMPDU_TX_START:
+		if (!wlc_aggregatable(wl->wlc, tid)) {
+			/* WL_ERROR(("START: tid %d is not agg' able, return FAILURE to stack\n", tid)); */
+			return -1;
+		}
+		/* XXX: Use the starting sequence number provided ... */
+		*ssn = 0;
+		ieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		break;
+
+	case IEEE80211_AMPDU_TX_STOP:
+		ieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);
+		break;
+	case IEEE80211_AMPDU_TX_OPERATIONAL:
+		/* Not sure what to do here */
+		/* Power save wakeup */
+		WL_NONE(("%s: action = IEEE80211_AMPDU_TX_OPERATIONAL\n",
+			 __func__));
+		break;
+	default:
+		WL_ERROR(("%s: Invalid command, ignoring\n", __func__));
+	}
+
+	return 0;
+}
+
+static const struct ieee80211_ops wl_ops = {
+#ifdef WLC_HIGH_ONLY
+	.tx = wl_ops_tx_nl,
+#else
+	.tx = wl_ops_tx,
+#endif
+	.start = wl_ops_start,
+	.stop = wl_ops_stop,
+	.add_interface = wl_ops_add_interface,
+	.remove_interface = wl_ops_remove_interface,
+	.config = wl_ops_config,
+	.bss_info_changed = wl_ops_bss_info_changed,
+	.configure_filter = wl_ops_configure_filter,
+	.set_tim = wl_ops_set_tim,
+	.sw_scan_start = wl_ops_sw_scan_start,
+	.sw_scan_complete = wl_ops_sw_scan_complete,
+	.set_tsf = wl_ops_set_tsf,
+	.get_stats = wl_ops_get_stats,
+	.set_rts_threshold = wl_ops_set_rts_threshold,
+	.sta_notify = wl_ops_sta_notify,
+	.conf_tx = wl_ops_conf_tx,
+	.get_tsf = wl_ops_get_tsf,
+	.sta_add = wl_sta_add,
+	.sta_remove = wl_sta_remove,
+	.ampdu_action = wl_ampdu_action,
+};
+
+static int wl_set_hint(wl_info_t * wl, char *abbrev)
+{
+	WL_ERROR(("%s: Sending country code %c%c to MAC80211\n", __func__,
+		  abbrev[0], abbrev[1]));
+	return (regulatory_hint(wl->pub->ieee_hw->wiphy, abbrev));
+}
+
+/**
+ * attach to the WL device.
+ *
+ * Attach to the WL device identified by vendor and device parameters.
+ * regs is a host accessible memory address pointing to WL device registers.
+ *
+ * wl_attach is not defined as static because in the case where no bus
+ * is defined, wl_attach will never be called, and thus, gcc will issue
+ * a warning that this function is defined but not used if we declare
+ * it as static.
+ */
+static wl_info_t *wl_attach(uint16 vendor, uint16 device, ulong regs,
+			    uint bustype, void *btparam, uint irq)
+{
+	wl_info_t *wl;
+	osl_t *osh;
+	int unit, err;
+
+	ulong base_addr;
+	struct ieee80211_hw *hw;
+	uint8 perm[ETH_ALEN];
+
+	unit = wl_found + instance_base;
+	err = 0;
+
+	if (unit < 0) {
+		WL_ERROR(("wl%d: unit number overflow, exiting\n", unit));
+		return NULL;
+	}
+
+	if (oneonly && (unit != instance_base)) {
+		WL_ERROR(("wl%d: wl_attach: oneonly is set, exiting\n", unit));
+		return NULL;
+	}
+
+	/* Requires pkttag feature */
+	osh = osl_attach(btparam, bustype, TRUE);
+	ASSERT(osh);
+
+#ifdef WLC_HIGH_ONLY
+	hw = ieee80211_alloc_hw(sizeof(wl_info_t), &wl_ops);
+	if (!hw) {
+		WL_ERROR(("%s: ieee80211_alloc_hw failed\n", __func__));
+		ASSERT(0);
+	}
+
+	bzero(hw->priv, sizeof(*wl));
+	wl = hw->priv;
+#else
+	/* allocate private info */
+	hw = pci_get_drvdata(btparam);	/* btparam == pdev */
+	wl = hw->priv;
+#endif
+	ASSERT(wl);
+
+	wl->magic = WL_MAGIC;
+	wl->osh = osh;
+	atomic_set(&wl->callbacks, 0);
+
+#ifdef WLC_HIGH_ONLY
+	wl->rpc_th = bcm_rpc_tp_attach(osh, NULL);
+	if (wl->rpc_th == NULL) {
+		WL_ERROR(("wl%d: %s: bcm_rpc_tp_attach failed!\n", unit,
+			  __func__));
+		goto fail;
+	}
+
+	wl->rpc = bcm_rpc_attach(NULL, osh, wl->rpc_th);
+	if (wl->rpc == NULL) {
+		WL_ERROR(("wl%d: %s: bcm_rpc_attach failed!\n", unit,
+			  __func__));
+		goto fail;
+	}
+
+	/* init tx work queue for wl_start/send pkt; no need to destroy workitem  */
+	MY_INIT_WORK(&wl->txq_task.work, (work_func_t) wl_start_txqwork);
+	wl->txq_task.context = wl;
+#endif				/* WLC_HIGH_ONLY */
+
+#ifdef BCMSDIO
+	SET_IEEE80211_DEV(hw, sdiommc_dev);
+#endif
+
+	base_addr = regs;
+
+	if (bustype == PCI_BUS) {
+		/* piomode can be overwritten by command argument */
+		wl->piomode = piomode;
+		WL_TRACE(("PCI/%s\n", wl->piomode ? "PIO" : "DMA"));
+	} else if (bustype == RPC_BUS) {
+		/* Do nothing */
+	} else {
+		bustype = PCI_BUS;
+		WL_TRACE(("force to PCI\n"));
+	}
+	wl->bcm_bustype = bustype;
+
+#ifdef WLC_HIGH_ONLY
+	if (wl->bcm_bustype == RPC_BUS) {
+		wl->regsva = (void *)0;
+		btparam = wl->rpc;
+	} else
+#endif
+	if ((wl->regsva = ioremap_nocache(base_addr, PCI_BAR0_WINSZ)) == NULL) {
+		WL_ERROR(("wl%d: ioremap() failed\n", unit));
+		goto fail;
+	}
+#ifdef WLC_HIGH_ONLY
+	spin_lock_init(&wl->rpcq_lock);
+	spin_lock_init(&wl->txq_lock);
+
+	init_MUTEX(&wl->sem);
+#else
+	spin_lock_init(&wl->lock);
+	spin_lock_init(&wl->isr_lock);
+#endif
+
+#ifndef WLC_HIGH_ONLY
+	/* prepare ucode */
+	if (wl_request_fw(wl, (struct pci_dev *)btparam)) {
+		printf("%s: %s driver failed\n", KBUILD_MODNAME,
+		       EPI_VERSION_STR);
+		goto fail;
+	}
+#endif
+
+	/* common load-time initialization */
+	if (!
+	    (wl->wlc =
+	     wlc_attach((void *)wl, vendor, device, unit, wl->piomode, osh,
+			wl->regsva, wl->bcm_bustype, btparam, &err))) {
+		printf("%s: %s driver failed with code %d\n", KBUILD_MODNAME,
+		       EPI_VERSION_STR, err);
+		goto fail;
+	}
+#ifndef WLC_HIGH_ONLY
+	wl_release_fw(wl);
+#endif
+	wl->pub = wlc_pub(wl->wlc);
+
+	wl->pub->ieee_hw = hw;
+	ASSERT(wl->pub->ieee_hw);
+	ASSERT(wl->pub->ieee_hw->priv == wl);
+
+#ifdef WLC_HIGH_ONLY
+	REGOPSSET(osh, (osl_rreg_fn_t) wlc_reg_read,
+		  (osl_wreg_fn_t) wlc_reg_write, wl->wlc);
+	wl->rpc_dispatch_ctx.rpc = wl->rpc;
+	wl->rpc_dispatch_ctx.wlc = wl->wlc;
+	bcm_rpc_rxcb_init(wl->rpc, wl, wl_rpc_dispatch_schedule, wl,
+			  wl_rpc_down, NULL, NULL);
+#endif				/* WLC_HIGH_ONLY */
+
+	if (nompc) {
+		if (wlc_iovar_setint(wl->wlc, "mpc", 0)) {
+			WL_ERROR(("wl%d: Error setting MPC variable to 0\n",
+				  unit));
+		}
+	}
+#ifdef BCMSDIO
+	/* Set SDIO drive strength */
+	wlc_iovar_setint(wl->wlc, "sd_drivestrength", sd_drivestrength);
+#endif
+
+	/* setup the bottom half handler */
+	tasklet_init(&wl->tasklet, wl_dpc, (ulong) wl);
+
+#ifdef WLC_LOW
+	/* register our interrupt handler */
+	if (request_irq(irq, wl_isr, IRQF_SHARED, KBUILD_MODNAME, wl)) {
+		WL_ERROR(("wl%d: request_irq() failed\n", unit));
+		goto fail;
+	}
+	wl->irq = irq;
+#endif				/* WLC_LOW */
+
+	/* register module */
+	wlc_module_register(wl->pub, NULL, "linux", wl, NULL, wl_linux_watchdog,
+			    NULL);
+
+	if (ieee_hw_init(hw)) {
+		WL_ERROR(("wl%d: %s: ieee_hw_init failed!\n", unit, __func__));
+		goto fail;
+	}
+
+	bcopy(&wl->pub->cur_etheraddr, perm, ETHER_ADDR_LEN);
+	ASSERT(is_valid_ether_addr(perm));
+	SET_IEEE80211_PERM_ADDR(hw, perm);
+
+	err = ieee80211_register_hw(hw);
+	if (err) {
+		WL_ERROR(("%s: ieee80211_register_hw failed, status %d\n",
+			  __func__, err));
+	}
+
+	if (wl->pub->srom_ccode[0])
+		err = wl_set_hint(wl, wl->pub->srom_ccode);
+	else
+		err = wl_set_hint(wl, "US");
+	if (err) {
+		WL_ERROR(("%s: regulatory_hint failed, status %d\n", __func__,
+			  err));
+	}
+#ifndef WLC_HIGH_ONLY
+	WL_ERROR(("wl%d: Broadcom BCM43xx 802.11 MAC80211 Driver "
+		  EPI_VERSION_STR " (" PHY_VERSION_STR ")", unit));
+#else
+	WL_ERROR(("wl%d: Broadcom BCM43xx 802.11 MAC80211 Driver "
+		  EPI_VERSION_STR, unit));
+#endif
+
+#ifdef BCMDBG
+	printf(" (Compiled in " SRCBASE " at " __TIME__ " on " __DATE__ ")");
+#endif				/* BCMDBG */
+	printf("\n");
+
+	if ((wl->proc_entry =
+	     create_proc_entry(PROC_ENTRY_NAME, 0644, NULL)) == NULL) {
+		WL_ERROR(("create_proc_entry failed *******\n"));
+		ASSERT(0);
+	} else {
+		wl->proc_entry->read_proc = wl_proc_read;
+		wl->proc_entry->write_proc = wl_proc_write;
+		wl->proc_entry->data = wl;
+		/* wl->proc_entry->owner = THIS_MODULE; */
+
+		if ((wl->ioctlbuf = (char *)vmalloc(PAGE_SIZE)) == NULL) {
+			WL_ERROR(("%s: Vmalloc failed\n", __func__));
+		}
+		wl->ioctlbuf_sz = PAGE_SIZE;
+		memset(wl->ioctlbuf, 0, PAGE_SIZE);
+		wl->ioctlbuf[0] = '!';
+	}
+
+	wl_found++;
+	return wl;
+
+ fail:
+	wl_free(wl);
+	return NULL;
+}
+
+#define PROC_MESSAGE  "Broadcom driver debugger access only.  Requires matching 'wl' app\n"
+
+/* OS Entry point when app attempts to read */
+static int
+wl_proc_read(char *buffer, char **start, off_t offset, int length, int *eof,
+	     void *data)
+{
+	wl_info_t *wl = (wl_info_t *) data;
+
+	switch (wl->proc_state) {
+
+	case WL_PROC_IDLE:
+		return 0;
+
+	case WL_PROC_HAVE_IOC:
+		/* Give the processed buffer back to userland */
+		if (!wl->ioctl_in_progress) {
+			WL_ERROR(("%s: No ioctl in progress nothing to read, 2\n", __func__));
+			return 0;
+		}
+
+		if (wl->ioc.len > wl->ioctlbuf_sz) {
+		}
+		bcopy(wl->ioctlbuf, buffer + offset, wl->ioc.len);
+		wl->proc_state--;
+		wl->ioctl_in_progress = 0;
+		return wl->ioc.len + offset;
+
+	case WL_PROC_HAVE_BUF:
+		/* Give the processed IOC back to userland */
+		if (!wl->ioctl_in_progress) {
+			WL_ERROR(("%s: No ioctl in progress nothing to read, 1\n", __func__));
+			return 0;
+		}
+		if (length != sizeof(wl_ioctl_t)) {
+			WL_ERROR(("%s: Reading ioc but len != sizeof(wl_ioctl_t)\n", __func__));
+			return 0;
+		}
+		bcopy(&wl->ioc, buffer + offset, length);
+		wl->proc_state--;
+		return length + offset;
+
+	default:
+		WL_ERROR(("%s: Proc read out of sync. proc_state %d, ioctl_in_progress %d\n", __func__, wl->proc_state, wl->ioctl_in_progress));
+	}
+
+	WL_ERROR(("%s: Invalid ioctl!!!\n", __func__));
+	return 0;
+}
+
+/* OS Entry point when app attempts to write */
+static int
+wl_proc_write(struct file *filp, const char __user * buff, unsigned long length,
+	      void *data)
+{
+	wl_info_t *wl = (wl_info_t *) data;
+	int bcmerror;
+
+	switch (wl->proc_state) {
+
+	case WL_PROC_IDLE:
+		if (wl->ioctl_in_progress) {
+			WL_ERROR(("%s: ioctl still in progress\n", __func__));
+			return -EIO;
+		}
+		if (length != sizeof(wl_ioctl_t)) {
+			WL_ERROR(("%s: Expecting ioctl sized buf\n", __func__));
+			return -EIO;
+		}
+		if (copy_from_user(&wl->ioc, buff, sizeof(wl_ioctl_t))) {
+			WL_ERROR(("%s: copy from user failed\n", __func__));
+			return -EIO;
+		}
+		wl->proc_state++;
+		wl->ioctl_in_progress++;
+		return sizeof(wl_ioctl_t);
+
+	case WL_PROC_HAVE_IOC:
+		if (!wl->ioctl_in_progress) {
+			WL_ERROR(("%s: Ioctl not ready yet 1\n", __func__));
+			return -EIO;
+		}
+		if (wl->ioctlbuf_sz < length) {
+			WL_ERROR(("%s: Buf write, ioctl buf %d not big enough too hold buffer %d\n", __func__, (int)sizeof(wl->ioctlbuf), (int)length));
+			WL_ERROR(("Shortening input\n"));
+			length = wl->ioctlbuf_sz;
+		}
+		if (length != wl->ioc.len) {
+			WL_ERROR(("%s: ioc.len %d != length param %d\n",
+				  __func__, wl->ioc.len, (int)length));
+			return -EIO;
+		}
+		if (copy_from_user(wl->ioctlbuf, buff, length)) {
+			WL_ERROR(("%s: copy from user of %d bytes failed\n",
+				  __func__, (int)length));
+			return -EIO;
+		}
+		wl->proc_state++;
+
+		WL_LOCK(wl);
+		bcmerror =
+		    wlc_ioctl(wl->wlc, wl->ioc.cmd, wl->ioctlbuf, wl->ioc.len,
+			      NULL);
+		WL_UNLOCK(wl);
+
+		if (bcmerror < 0)
+			return bcmerror;
+
+		return length;
+
+	case WL_PROC_HAVE_BUF:
+		WL_ERROR(("%s: Illegal write.  Rejecting.\n", __func__));
+		return 0;
+	default:
+		WL_ERROR(("%s: Proc write out of sync. proc_state %d, ioctl_in_progress %d\n", __func__, wl->proc_state, wl->ioctl_in_progress));
+	}
+	return 0;
+}
+
+#ifdef WLC_HIGH_ONLY
+static void *wl_dbus_probe_cb(void *arg, const char *desc, uint32 bustype,
+			      uint32 hdrlen)
+{
+	wl_info_t *wl;
+	WL_ERROR(("%s:\n", __func__));
+
+	if (!
+	    (wl =
+	     wl_attach(BCM_DNGL_VID, BCM_DNGL_BDC_PID, (ulong) NULL, RPC_BUS,
+		       NULL, 0))) {
+		WL_ERROR(("%s: wl_attach failed\n", __func__));
+	}
+
+	/* This is later passed to wl_dbus_disconnect_cb */
+	return wl;
+}
+
+static void wl_dbus_disconnect_cb(void *arg)
+{
+	wl_info_t *wl = arg;
+
+	WL_ERROR(("%s:\n", __func__));
+
+	if (wl) {
+#ifdef WLC_HIGH_ONLY
+		if (wl->pub->ieee_hw) {
+			ieee80211_unregister_hw(wl->pub->ieee_hw);
+			WL_ERROR(("%s: Back from down\n", __func__));
+		}
+		wlc_device_removed(wl->wlc);
+		wlc_bmac_dngl_reboot(wl->rpc);
+		bcm_rpc_down(wl->rpc);
+#endif
+		WL_LOCK(wl);
+		wl_down(wl);
+		WL_UNLOCK(wl);
+#ifdef WLC_HIGH_ONLY
+		if (wl->pub->ieee_hw) {
+			ieee80211_free_hw(wl->pub->ieee_hw);
+			WL_ERROR(("%s: Back from ieee80211_free_hw\n",
+				  __func__));
+			wl->pub->ieee_hw = NULL;
+		}
+#endif
+		wl_free(wl);
+	}
+}
+#endif				/* WLC_HIGH_ONLY */
+
+#ifndef BCMSDIO
+static void __devexit wl_remove(struct pci_dev *pdev);
+#endif
+
+#define CHAN2GHZ(channel, freqency, chflags)  { \
+	.band = IEEE80211_BAND_2GHZ, \
+	.center_freq = (freqency), \
+	.hw_value = (channel), \
+	.flags = chflags, \
+	.max_antenna_gain = 0, \
+	.max_power = 19, \
+}
+
+static struct ieee80211_channel wl_2ghz_chantable[] = {
+	CHAN2GHZ(1, 2412, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN2GHZ(2, 2417, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN2GHZ(3, 2422, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN2GHZ(4, 2427, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN2GHZ(5, 2432, 0),
+	CHAN2GHZ(6, 2437, 0),
+	CHAN2GHZ(7, 2442, 0),
+	CHAN2GHZ(8, 2447, IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN2GHZ(9, 2452, IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN2GHZ(10, 2457, IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN2GHZ(11, 2462, IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN2GHZ(12, 2467,
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN2GHZ(13, 2472,
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN2GHZ(14, 2484,
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)
+};
+
+#define CHAN5GHZ(channel, chflags)  { \
+	.band = IEEE80211_BAND_5GHZ, \
+	.center_freq = 5000 + 5*(channel), \
+	.hw_value = (channel), \
+	.flags = chflags, \
+	.max_antenna_gain = 0, \
+	.max_power = 21, \
+}
+
+static struct ieee80211_channel wl_5ghz_nphy_chantable[] = {
+	/* UNII-1 */
+	CHAN5GHZ(36, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(40, IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(44, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(48, IEEE80211_CHAN_NO_HT40PLUS),
+	/* UNII-2 */
+	CHAN5GHZ(52,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(56,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(60,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(64,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS),
+	/* MID */
+	CHAN5GHZ(100,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(104,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(108,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(112,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(116,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(120,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(124,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(128,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(132,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(136,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(140,
+		 IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IBSS |
+		 IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_NO_HT40PLUS |
+		 IEEE80211_CHAN_NO_HT40MINUS),
+	/* UNII-3 */
+	CHAN5GHZ(149, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(153, IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(157, IEEE80211_CHAN_NO_HT40MINUS),
+	CHAN5GHZ(161, IEEE80211_CHAN_NO_HT40PLUS),
+	CHAN5GHZ(165, IEEE80211_CHAN_NO_HT40PLUS | IEEE80211_CHAN_NO_HT40MINUS)
+};
+
+#define RATE(rate100m, _flags) { \
+	.bitrate = (rate100m), \
+	.flags = (_flags), \
+	.hw_value = (rate100m / 5), \
+}
+
+static struct ieee80211_rate wl_legacy_ratetable[] = {
+	RATE(10, 0),
+	RATE(20, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(55, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(110, IEEE80211_RATE_SHORT_PREAMBLE),
+	RATE(60, 0),
+	RATE(90, 0),
+	RATE(120, 0),
+	RATE(180, 0),
+	RATE(240, 0),
+	RATE(360, 0),
+	RATE(480, 0),
+	RATE(540, 0),
+};
+
+static struct ieee80211_supported_band wl_band_2GHz_nphy = {
+	.band = IEEE80211_BAND_2GHZ,
+	.channels = wl_2ghz_chantable,
+	.n_channels = ARRAY_SIZE(wl_2ghz_chantable),
+	.bitrates = wl_legacy_ratetable,
+	.n_bitrates = ARRAY_SIZE(wl_legacy_ratetable),
+	.ht_cap = {
+		   /* from include/linux/ieee80211.h */
+		   .cap = IEEE80211_HT_CAP_GRN_FLD |
+		   IEEE80211_HT_CAP_SGI_20 |
+		   IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_40MHZ_INTOLERANT,
+#ifdef WLC_HIGH_ONLY
+		   .ht_supported = true,
+		   .ampdu_factor = AMPDU_RX_FACTOR_16K,
+#else
+		   .ht_supported = true,
+		   .ampdu_factor = AMPDU_RX_FACTOR_64K,
+#endif
+		   .ampdu_density = AMPDU_DEF_MPDU_DENSITY,
+		   .mcs = {
+			   /* placeholders for now */
+#ifdef WLC_HIGH_ONLY
+			   /*
+			    * rx_mask[0] = 0xff by default
+			    * rx_mask[1] = 0xff if number of rx chain >=2
+			    * rx_mask[2] = 0xff if number of rx chain >=3
+			    * rx_mask[4] = 1 if 40Mhz is supported
+			    */
+			   .rx_mask = {0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+			   .rx_highest = 72,	/* max rate of single stream */
+#else
+			   .rx_mask = {0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0},
+			   .rx_highest = 500,
+#endif
+			   .tx_params = IEEE80211_HT_MCS_TX_DEFINED}
+		   }
+};
+
+static struct ieee80211_supported_band wl_band_5GHz_nphy = {
+	.band = IEEE80211_BAND_5GHZ,
+	.channels = wl_5ghz_nphy_chantable,
+	.n_channels = ARRAY_SIZE(wl_5ghz_nphy_chantable),
+	.bitrates = wl_legacy_ratetable + 4,
+	.n_bitrates = ARRAY_SIZE(wl_legacy_ratetable) - 4,
+	.ht_cap = {
+		   /* use IEEE80211_HT_CAP_* from include/linux/ieee80211.h */
+		   .cap = IEEE80211_HT_CAP_GRN_FLD | IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_40MHZ_INTOLERANT,	/* No 40 mhz yet */
+		   .ht_supported = true,
+		   .ampdu_factor = AMPDU_RX_FACTOR_64K,
+		   .ampdu_density = AMPDU_DEF_MPDU_DENSITY,
+		   .mcs = {
+			   /* placeholders for now */
+			   .rx_mask = {0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0},
+			   .rx_highest = 500,
+			   .tx_params = IEEE80211_HT_MCS_TX_DEFINED}
+		   }
+};
+
+static int ieee_hw_rate_init(struct ieee80211_hw *hw)
+{
+	wl_info_t *wl = HW_TO_WL(hw);
+	int has_5g;
+	char phy_list[4];
+
+	has_5g = 0;
+
+	hw->wiphy->bands[IEEE80211_BAND_2GHZ] = NULL;
+	hw->wiphy->bands[IEEE80211_BAND_5GHZ] = NULL;
+
+	if (wlc_get(wl->wlc, WLC_GET_PHYLIST, (int *)&phy_list) < 0) {
+		WL_ERROR(("Phy list failed\n"));
+	}
+	WL_NONE(("%s: phylist = %c\n", __func__, phy_list[0]));
+
+#ifndef WLC_HIGH_ONLY
+	if (phy_list[0] == 'n' || phy_list[0] == 'c') {
+		if (phy_list[0] == 'c') {
+			/* Single stream */
+			wl_band_2GHz_nphy.ht_cap.mcs.rx_mask[1] = 0;
+			wl_band_2GHz_nphy.ht_cap.mcs.rx_highest = 72;
+		}
+#else
+	if (phy_list[0] == 's') {
+#endif
+		hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &wl_band_2GHz_nphy;
+	} else {
+		BUG();
+		return (-1);
+	}
+
+	/* Assume all bands use the same phy.  True for 11n devices. */
+	if (NBANDS_PUB(wl->pub) > 1) {
+		has_5g++;
+#ifndef WLC_HIGH_ONLY
+		if (phy_list[0] == 'n' || phy_list[0] == 'c') {
+#else
+		if (phy_list[0] == 's') {
+#endif
+			hw->wiphy->bands[IEEE80211_BAND_5GHZ] =
+			    &wl_band_5GHz_nphy;
+		} else {
+			return (-1);
+		}
+	}
+
+	WL_NONE(("%s: 2ghz = %d, 5ghz = %d\n", __func__, 1, has_5g));
+
+	return (0);
+}
+
+static int ieee_hw_init(struct ieee80211_hw *hw)
+{
+	hw->flags = IEEE80211_HW_SIGNAL_DBM
+	    /* | IEEE80211_HW_CONNECTION_MONITOR  What is this? */
+	    | IEEE80211_HW_REPORTS_TX_ACK_STATUS
+	    | IEEE80211_HW_AMPDU_AGGREGATION;
+
+	hw->extra_tx_headroom = wlc_get_header_len();
+	/* FIXME: should get this from wlc->machwcap */
+	hw->queues = 4;
+	/* FIXME: this doesn't seem to be used properly in minstrel_ht.
+	 * mac80211/status.c:ieee80211_tx_status() checks this value,
+	 * but mac80211/rc80211_minstrel_ht.c:minstrel_ht_get_rate()
+	 * appears to always set 3 rates
+	 */
+	hw->max_rates = 2;	/* Primary rate and 1 fallback rate */
+
+	hw->channel_change_time = 7 * 1000;	/* channel change time is dependant on chip and band  */
+	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);
+
+	hw->rate_control_algorithm = "minstrel_ht";
+
+	hw->sta_data_size = sizeof(struct scb);
+	return (ieee_hw_rate_init(hw));
+}
+
+#ifndef BCMSDIO
+/**
+ * determines if a device is a WL device, and if so, attaches it.
+ *
+ * This function determines if a device pointed to by pdev is a WL device,
+ * and if so, performs a wl_attach() on it.
+ *
+ */
+int __devinit
+wl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	int rc;
+	wl_info_t *wl;
+	struct ieee80211_hw *hw;
+	uint32 val;
+
+	ASSERT(pdev);
+
+	WL_TRACE(("%s: bus %d slot %d func %d irq %d\n", __func__,
+		  pdev->bus->number, PCI_SLOT(pdev->devfn),
+		  PCI_FUNC(pdev->devfn), pdev->irq));
+
+	if ((pdev->vendor != PCI_VENDOR_ID_BROADCOM) ||
+	    (((pdev->device & 0xff00) != 0x4300) &&
+	     ((pdev->device & 0xff00) != 0x4700) &&
+	     ((pdev->device < 43000) || (pdev->device > 43999))))
+		return (-ENODEV);
+
+	rc = pci_enable_device(pdev);
+	if (rc) {
+		WL_ERROR(("%s: Cannot enable device %d-%d_%d\n", __func__,
+			  pdev->bus->number, PCI_SLOT(pdev->devfn),
+			  PCI_FUNC(pdev->devfn)));
+		return (-ENODEV);
+	}
+	pci_set_master(pdev);
+
+	pci_read_config_dword(pdev, 0x40, &val);
+	if ((val & 0x0000ff00) != 0)
+		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
+
+	hw = ieee80211_alloc_hw(sizeof(wl_info_t), &wl_ops);
+	if (!hw) {
+		WL_ERROR(("%s: ieee80211_alloc_hw failed\n", __func__));
+		rc = -ENOMEM;
+		goto err_1;
+	}
+
+	SET_IEEE80211_DEV(hw, &pdev->dev);
+
+	pci_set_drvdata(pdev, hw);
+
+	bzero(hw->priv, sizeof(*wl));
+
+	wl = wl_attach(pdev->vendor, pdev->device, pci_resource_start(pdev, 0),
+		       PCI_BUS, pdev, pdev->irq);
+
+	return 0;
+ err_1:
+	WL_ERROR(("%s: err_1: Major hoarkage\n", __func__));
+	return 0;
+}
+
+#ifdef LINUXSTA_PS
+static int wl_suspend(struct pci_dev *pdev, DRV_SUSPEND_STATE_TYPE state)
+{
+	wl_info_t *wl;
+	struct ieee80211_hw *hw;
+
+	WL_TRACE(("wl: wl_suspend\n"));
+
+	hw = pci_get_drvdata(pdev);
+	wl = HW_TO_WL(hw);
+	if (!wl) {
+		WL_ERROR(("wl: wl_suspend: pci_get_drvdata failed\n"));
+		return -ENODEV;
+	}
+
+	WL_LOCK(wl);
+	wl_down(wl);
+	wl->pub->hw_up = FALSE;
+	WL_UNLOCK(wl);
+	PCI_SAVE_STATE(pdev, wl->pci_psstate);
+	pci_disable_device(pdev);
+	return pci_set_power_state(pdev, PCI_D3hot);
+}
+
+static int wl_resume(struct pci_dev *pdev)
+{
+	wl_info_t *wl;
+	struct ieee80211_hw *hw;
+	int err = 0;
+	uint32 val;
+
+	WL_TRACE(("wl: wl_resume\n"));
+	hw = pci_get_drvdata(pdev);
+	wl = HW_TO_WL(hw);
+	if (!wl) {
+		WL_ERROR(("wl: wl_resume: pci_get_drvdata failed\n"));
+		return -ENODEV;
+	}
+
+	err = pci_set_power_state(pdev, PCI_D0);
+	if (err)
+		return err;
+
+	PCI_RESTORE_STATE(pdev, wl->pci_psstate);
+
+	err = pci_enable_device(pdev);
+	if (err)
+		return err;
+
+	pci_set_master(pdev);
+
+	pci_read_config_dword(pdev, 0x40, &val);
+	if ((val & 0x0000ff00) != 0)
+		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
+
+	WL_LOCK(wl);
+	err = wl_up(wl);
+	WL_UNLOCK(wl);
+
+	return (err);
+}
+#endif				/* LINUXSTA_PS */
+
+static void __devexit wl_remove(struct pci_dev *pdev)
+{
+	wl_info_t *wl;
+	struct ieee80211_hw *hw;
+
+	hw = pci_get_drvdata(pdev);
+	wl = HW_TO_WL(hw);
+	if (!wl) {
+		WL_ERROR(("wl: wl_remove: pci_get_drvdata failed\n"));
+		return;
+	}
+	if (!wlc_chipmatch(pdev->vendor, pdev->device)) {
+		WL_ERROR(("wl: wl_remove: wlc_chipmatch failed\n"));
+		return;
+	}
+
+	ieee80211_unregister_hw(hw);
+
+	WL_LOCK(wl);
+	wl_down(wl);
+	WL_UNLOCK(wl);
+	WL_NONE(("%s: Down\n", __func__));
+
+	pci_disable_device(pdev);
+
+	wl_free(wl);
+
+	pci_set_drvdata(pdev, NULL);
+	ieee80211_free_hw(hw);
+}
+
+static struct pci_driver wl_pci_driver = {
+ name:	"brcm80211",
+ probe:wl_pci_probe,
+#ifdef LINUXSTA_PS
+ suspend:wl_suspend,
+ resume:wl_resume,
+#endif				/* LINUXSTA_PS */
+ remove:__devexit_p(wl_remove),
+ id_table:wl_id_table,
+};
+#endif				/* !BCMSDIO */
+
+/**
+ * This is the main entry point for the WL driver.
+ *
+ * This function determines if a device pointed to by pdev is a WL device,
+ * and if so, performs a wl_attach() on it.
+ *
+ */
+static int __init wl_module_init(void)
+{
+	int error = -ENODEV;
+
+#ifdef BCMDBG
+	if (msglevel != 0xdeadbeef)
+		wl_msg_level = msglevel;
+	else {
+		char *var = getvar(NULL, "wl_msglevel");
+		if (var)
+			wl_msg_level = bcm_strtoul(var, NULL, 0);
+	}
+#ifndef WLC_HIGH_ONLY
+	{
+		extern uint32 phyhal_msg_level;
+
+		if (phymsglevel != 0xdeadbeef)
+			phyhal_msg_level = phymsglevel;
+		else {
+			char *var = getvar(NULL, "phy_msglevel");
+			if (var)
+				phyhal_msg_level = bcm_strtoul(var, NULL, 0);
+		}
+	}
+#endif				/* WLC_HIGH_ONLY */
+#endif				/* BCMDBG */
+
+#ifndef BCMSDIO
+	if (!(error = pci_module_init(&wl_pci_driver)))
+		return (0);
+
+#endif				/* !BCMSDIO */
+
+#ifdef WLC_HIGH_ONLY
+	/* BMAC_NOTE: define hardcode number, why NODEVICE is ok ? */
+	error =
+	    dbus_register(BCM_DNGL_VID, 0, wl_dbus_probe_cb,
+			  wl_dbus_disconnect_cb, NULL, NULL, NULL);
+	if (error == DBUS_ERR_NODEVICE) {
+		error = DBUS_OK;
+	}
+#endif				/* WLC_HIGH_ONLY */
+
+	return (error);
+}
+
+/**
+ * This function unloads the WL driver from the system.
+ *
+ * This function unconditionally unloads the WL driver module from the
+ * system.
+ *
+ */
+static void __exit wl_module_exit(void)
+{
+#ifndef BCMSDIO
+	pci_unregister_driver(&wl_pci_driver);
+#endif				/* !BCMSDIO */
+
+#ifdef WLC_HIGH_ONLY
+	dbus_deregister();
+#endif				/* WLC_HIGH_ONLY */
+}
+
+module_init(wl_module_init);
+module_exit(wl_module_exit);
+
+/**
+ * This function frees the WL per-device resources.
+ *
+ * This function frees resources owned by the WL device pointed to
+ * by the wl parameter.
+ *
+ */
+void wl_free(wl_info_t * wl)
+{
+	wl_timer_t *t, *next;
+	osl_t *osh;
+
+	ASSERT(wl);
+#ifndef WLC_HIGH_ONLY
+	ASSERT(wl->irq);	/* bmac does not use direct interrupt */
+	/* free ucode data */
+	if (wl->fw.fw_cnt)
+		wl_ucode_data_free();
+	ASSERT(wl->wlc);
+	if (wl->irq)
+		free_irq(wl->irq, wl);
+#endif
+
+	/* kill dpc */
+	tasklet_kill(&wl->tasklet);
+
+	if (wl->pub) {
+		wlc_module_unregister(wl->pub, "linux", wl);
+	}
+
+	/* free common resources */
+	if (wl->wlc) {
+		wlc_detach(wl->wlc);
+		wl->wlc = NULL;
+		wl->pub = NULL;
+	}
+
+	/* virtual interface deletion is deferred so we cannot spinwait */
+
+	/* wait for all pending callbacks to complete */
+	while (atomic_read(&wl->callbacks) > 0)
+		schedule();
+
+	/* free timers */
+	for (t = wl->timers; t; t = next) {
+		next = t->next;
+#ifdef BCMDBG
+		if (t->name)
+			MFREE(wl->osh, t->name, strlen(t->name) + 1);
+#endif
+		MFREE(wl->osh, t, sizeof(wl_timer_t));
+	}
+
+	if (wl->ioctlbuf_sz) {
+		remove_proc_entry(PROC_ENTRY_NAME, NULL);
+		vfree(wl->ioctlbuf);
+		wl->ioctlbuf_sz = 0;
+	}
+
+	osh = wl->osh;
+
+	/*
+	 * unregister_netdev() calls get_stats() which may read chip registers
+	 * so we cannot unmap the chip registers until after calling unregister_netdev() .
+	 */
+	if (wl->regsva && BUSTYPE(wl->bcm_bustype) != SDIO_BUS &&
+	    BUSTYPE(wl->bcm_bustype) != JTAG_BUS) {
+		iounmap((void *)wl->regsva);
+	}
+	wl->regsva = NULL;
+
+#ifdef WLC_HIGH_ONLY
+	wl_rpcq_free(wl);
+
+	wl_txq_free(wl);
+
+	if (wl->rpc) {
+		bcm_rpc_detach(wl->rpc);
+		wl->rpc = NULL;
+	}
+
+	if (wl->rpc_th) {
+		bcm_rpc_tp_detach(wl->rpc_th);
+		wl->rpc_th = NULL;
+	}
+#endif				/* WLC_HIGH_ONLY */
+
+	if (osl_malloced(osh)) {
+		printf("****   Memory leak of bytes %d\n", osl_malloced(osh));
+		ASSERT(0 && "Memory Leak");
+	}
+
+	osl_detach(osh);
+}
+
+#ifdef WLC_LOW
+/* transmit a packet */
+static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
+{
+	if (!wl)
+		return -ENETDOWN;
+
+	return wl_start_int(wl, WL_TO_HW(wl), skb);
+}
+#endif				/* WLC_LOW */
+
+static int BCMFASTPATH
+wl_start_int(wl_info_t * wl, struct ieee80211_hw *hw, struct sk_buff *skb)
+{
+#ifdef WLC_HIGH_ONLY
+	WL_LOCK(wl);
+#endif
+	wlc_sendpkt_mac80211(wl->wlc, skb, hw);
+#ifdef WLC_HIGH_ONLY
+	WL_UNLOCK(wl);
+#endif
+	return (NETDEV_TX_OK);
+}
+
+void wl_txflowcontrol(wl_info_t * wl, struct wl_if *wlif, bool state, int prio)
+{
+	WL_ERROR(("Shouldn't be here %s\n", __func__));
+}
+
+#if defined(WLC_HIGH_ONLY)
+/* Schedule a completion handler to run at safe time */
+static int
+wl_schedule_task(wl_info_t * wl, void (*fn) (struct wl_task * task),
+		 void *context)
+{
+	wl_task_t *task;
+
+	WL_TRACE(("wl%d: wl_schedule_task\n", wl->pub->unit));
+
+	if (!(task = osl_malloc(wl->osh, sizeof(wl_task_t)))) {
+		WL_ERROR(("wl%d: wl_schedule_task: out of memory, malloced %d bytes\n", wl->pub->unit, osl_malloced(wl->osh)));
+		return -ENOMEM;
+	}
+
+	MY_INIT_WORK(&task->work, (work_func_t) fn);
+	task->context = context;
+
+	if (!schedule_work(&task->work)) {
+		WL_ERROR(("wl%d: schedule_work() failed\n", wl->pub->unit));
+		MFREE(wl->osh, task, sizeof(wl_task_t));
+		return -ENOMEM;
+	}
+
+	atomic_inc(&wl->callbacks);
+
+	return 0;
+}
+#endif				/* defined(WLC_HIGH_ONLY) */
+
+void wl_init(wl_info_t * wl)
+{
+	WL_TRACE(("wl%d: wl_init\n", wl->pub->unit));
+
+	wl_reset(wl);
+
+	wlc_init(wl->wlc);
+}
+
+uint wl_reset(wl_info_t * wl)
+{
+	WL_TRACE(("wl%d: wl_reset\n", wl->pub->unit));
+
+	wlc_reset(wl->wlc);
+
+	/* dpc will not be rescheduled */
+	wl->resched = 0;
+
+	return (0);
+}
+
+/*
+ * These are interrupt on/off entry points. Disable interrupts
+ * during interrupt state transition.
+ */
+void BCMFASTPATH wl_intrson(wl_info_t * wl)
+{
+#if defined(WLC_LOW)
+	unsigned long flags;
+
+	INT_LOCK(wl, flags);
+	wlc_intrson(wl->wlc);
+	INT_UNLOCK(wl, flags);
+#endif				/* WLC_LOW */
+}
+
+bool wl_alloc_dma_resources(wl_info_t * wl, uint addrwidth)
+{
+	return TRUE;
+}
+
+uint32 BCMFASTPATH wl_intrsoff(wl_info_t * wl)
+{
+#if defined(WLC_LOW)
+	unsigned long flags;
+	uint32 status;
+
+	INT_LOCK(wl, flags);
+	status = wlc_intrsoff(wl->wlc);
+	INT_UNLOCK(wl, flags);
+	return status;
+#else
+	return 0;
+#endif				/* WLC_LOW */
+}
+
+void wl_intrsrestore(wl_info_t * wl, uint32 macintmask)
+{
+#if defined(WLC_LOW)
+	unsigned long flags;
+
+	INT_LOCK(wl, flags);
+	wlc_intrsrestore(wl->wlc, macintmask);
+	INT_UNLOCK(wl, flags);
+#endif				/* WLC_LOW */
+}
+
+int wl_up(wl_info_t * wl)
+{
+	int error = 0;
+
+	if (wl->pub->up)
+		return (0);
+
+	error = wlc_up(wl->wlc);
+
+	return (error);
+}
+
+void wl_down(wl_info_t * wl)
+{
+	uint callbacks, ret_val = 0;
+
+	/* call common down function */
+	ret_val = wlc_down(wl->wlc);
+	callbacks = atomic_read(&wl->callbacks) - ret_val;
+
+	/* wait for down callbacks to complete */
+	WL_UNLOCK(wl);
+
+#ifndef WLC_HIGH_ONLY
+	/* For HIGH_only driver, it's important to actually schedule other work,
+	 * not just spin wait since everything runs at schedule level
+	 */
+	SPINWAIT((atomic_read(&wl->callbacks) > callbacks), 100 * 1000);
+#endif				/* WLC_HIGH_ONLY */
+
+	WL_LOCK(wl);
+}
+
+irqreturn_t BCMFASTPATH wl_isr(int irq, void *dev_id)
+{
+#if defined(WLC_LOW)
+	wl_info_t *wl;
+	bool ours, wantdpc;
+	unsigned long flags;
+
+	wl = (wl_info_t *) dev_id;
+
+	WL_ISRLOCK(wl, flags);
+
+	/* call common first level interrupt handler */
+	if ((ours = wlc_isr(wl->wlc, &wantdpc))) {
+		/* if more to do... */
+		if (wantdpc) {
+
+			/* ...and call the second level interrupt handler */
+			/* schedule dpc */
+			ASSERT(wl->resched == FALSE);
+			tasklet_schedule(&wl->tasklet);
+		}
+	}
+
+	WL_ISRUNLOCK(wl, flags);
+
+	return IRQ_RETVAL(ours);
+#else
+	return IRQ_RETVAL(0);
+#endif				/* WLC_LOW */
+}
+
+static void BCMFASTPATH wl_dpc(ulong data)
+{
+#ifdef WLC_LOW
+	wl_info_t *wl;
+
+	wl = (wl_info_t *) data;
+
+	WL_LOCK(wl);
+
+	/* call the common second level interrupt handler */
+	if (wl->pub->up) {
+		if (wl->resched) {
+			unsigned long flags;
+
+			INT_LOCK(wl, flags);
+			wlc_intrsupd(wl->wlc);
+			INT_UNLOCK(wl, flags);
+		}
+
+		wl->resched = wlc_dpc(wl->wlc, TRUE);
+	}
+
+	/* wlc_dpc() may bring the driver down */
+	if (!wl->pub->up)
+		goto done;
+
+	/* re-schedule dpc */
+	if (wl->resched)
+		tasklet_schedule(&wl->tasklet);
+	else {
+		/* re-enable interrupts */
+		wl_intrson(wl);
+	}
+
+ done:
+	WL_UNLOCK(wl);
+#endif				/* WLC_LOW */
+}
+
+static void wl_link_up(wl_info_t * wl, char *ifname)
+{
+	WL_ERROR(("wl%d: link up (%s)\n", wl->pub->unit, ifname));
+}
+
+static void wl_link_down(wl_info_t * wl, char *ifname)
+{
+	WL_ERROR(("wl%d: link down (%s)\n", wl->pub->unit, ifname));
+}
+
+void wl_event(wl_info_t * wl, char *ifname, wlc_event_t * e)
+{
+
+	switch (e->event.event_type) {
+	case WLC_E_LINK:
+	case WLC_E_NDIS_LINK:
+		if (e->event.flags & WLC_EVENT_MSG_LINK)
+			wl_link_up(wl, ifname);
+		else
+			wl_link_down(wl, ifname);
+		break;
+	case WLC_E_RADIO:
+		break;
+	}
+}
+
+static void wl_timer(ulong data)
+{
+#ifndef WLC_HIGH_ONLY
+	_wl_timer((wl_timer_t *) data);
+#else
+	wl_timer_t *t = (wl_timer_t *) data;
+	wl_schedule_task(t->wl, wl_timer_task, t);
+#endif				/* WLC_HIGH_ONLY */
+}
+
+static void _wl_timer(wl_timer_t * t)
+{
+	WL_LOCK(t->wl);
+
+	if (t->set) {
+		if (t->periodic) {
+			t->timer.expires = jiffies + t->ms * HZ / 1000;
+			atomic_inc(&t->wl->callbacks);
+			add_timer(&t->timer);
+			t->set = TRUE;
+		} else
+			t->set = FALSE;
+
+		t->fn(t->arg);
+	}
+
+	atomic_dec(&t->wl->callbacks);
+
+	WL_UNLOCK(t->wl);
+}
+
+wl_timer_t *wl_init_timer(wl_info_t * wl, void (*fn) (void *arg), void *arg,
+			  const char *name)
+{
+	wl_timer_t *t;
+
+	if (!(t = osl_malloc(wl->osh, sizeof(wl_timer_t)))) {
+		WL_ERROR(("wl%d: wl_init_timer: out of memory, malloced %d bytes\n", wl->pub->unit, osl_malloced(wl->osh)));
+		return 0;
+	}
+
+	bzero(t, sizeof(wl_timer_t));
+
+	init_timer(&t->timer);
+	t->timer.data = (ulong) t;
+	t->timer.function = wl_timer;
+	t->wl = wl;
+	t->fn = fn;
+	t->arg = arg;
+	t->next = wl->timers;
+	wl->timers = t;
+
+#ifdef BCMDBG
+	if ((t->name = osl_malloc(wl->osh, strlen(name) + 1)))
+		strcpy(t->name, name);
+#endif
+
+	return t;
+}
+
+/* BMAC_NOTE: Add timer adds only the kernel timer since it's going to be more accurate
+ * as well as it's easier to make it periodic
+ */
+void wl_add_timer(wl_info_t * wl, wl_timer_t * t, uint ms, int periodic)
+{
+#ifdef BCMDBG
+	if (t->set) {
+		WL_ERROR(("%s: Already set. Name: %s, per %d\n",
+			  __func__, t->name, periodic));
+	}
+#endif
+	ASSERT(!t->set);
+
+	t->ms = ms;
+	t->periodic = (bool) periodic;
+	t->set = TRUE;
+	t->timer.expires = jiffies + ms * HZ / 1000;
+
+	atomic_inc(&wl->callbacks);
+	add_timer(&t->timer);
+}
+
+/* return TRUE if timer successfully deleted, FALSE if still pending */
+bool wl_del_timer(wl_info_t * wl, wl_timer_t * t)
+{
+	if (t->set) {
+		t->set = FALSE;
+		if (!del_timer(&t->timer)) {
+			return FALSE;
+		}
+		atomic_dec(&wl->callbacks);
+	}
+
+	return TRUE;
+}
+
+void wl_free_timer(wl_info_t * wl, wl_timer_t * t)
+{
+	wl_timer_t *tmp;
+
+	/* delete the timer in case it is active */
+	wl_del_timer(wl, t);
+
+	if (wl->timers == t) {
+		wl->timers = wl->timers->next;
+#ifdef BCMDBG
+		if (t->name)
+			MFREE(wl->osh, t->name, strlen(t->name) + 1);
+#endif
+		MFREE(wl->osh, t, sizeof(wl_timer_t));
+		return;
+
+	}
+
+	tmp = wl->timers;
+	while (tmp) {
+		if (tmp->next == t) {
+			tmp->next = t->next;
+#ifdef BCMDBG
+			if (t->name)
+				MFREE(wl->osh, t->name, strlen(t->name) + 1);
+#endif
+			MFREE(wl->osh, t, sizeof(wl_timer_t));
+			return;
+		}
+		tmp = tmp->next;
+	}
+
+}
+
+static int wl_linux_watchdog(void *ctx)
+{
+	wl_info_t *wl = (wl_info_t *) ctx;
+	struct net_device_stats *stats = NULL;
+	uint id;
+	/* refresh stats */
+	if (wl->pub->up) {
+		ASSERT(wl->stats_id < 2);
+
+		id = 1 - wl->stats_id;
+
+		stats = &wl->stats_watchdog[id];
+		stats->rx_packets = WLCNTVAL(wl->pub->_cnt->rxframe);
+		stats->tx_packets = WLCNTVAL(wl->pub->_cnt->txframe);
+		stats->rx_bytes = WLCNTVAL(wl->pub->_cnt->rxbyte);
+		stats->tx_bytes = WLCNTVAL(wl->pub->_cnt->txbyte);
+		stats->rx_errors = WLCNTVAL(wl->pub->_cnt->rxerror);
+		stats->tx_errors = WLCNTVAL(wl->pub->_cnt->txerror);
+		stats->collisions = 0;
+
+		stats->rx_length_errors = 0;
+		stats->rx_over_errors = WLCNTVAL(wl->pub->_cnt->rxoflo);
+		stats->rx_crc_errors = WLCNTVAL(wl->pub->_cnt->rxcrc);
+		stats->rx_frame_errors = 0;
+		stats->rx_fifo_errors = WLCNTVAL(wl->pub->_cnt->rxoflo);
+		stats->rx_missed_errors = 0;
+
+		stats->tx_fifo_errors = WLCNTVAL(wl->pub->_cnt->txuflo);
+
+		wl->stats_id = id;
+
+	}
+
+	return 0;
+}
+
+struct wl_fw_hdr {
+	uint32 offset;
+	uint32 len;
+	uint32 idx;
+};
+
+#ifdef WLC_HIGH_ONLY
+static void wl_rpc_down(void *wlh)
+{
+	wl_info_t *wl = (wl_info_t *) (wlh);
+
+	wlc_device_removed(wl->wlc);
+
+	wl_rpcq_free(wl);
+}
+
+static int BCMFASTPATH wl_start(struct sk_buff *skb, wl_info_t * wl)
+{
+
+	ulong flags;
+
+	skb->prev = NULL;
+
+	/* Lock the queue as tasklet could be running at this time */
+	TXQ_LOCK(wl, flags);
+	if (wl->txq_head == NULL)
+		wl->txq_head = skb;
+	else {
+		wl->txq_tail->prev = skb;
+	}
+	wl->txq_tail = skb;
+
+	if (wl->txq_dispatched == FALSE) {
+		wl->txq_dispatched = TRUE;
+
+		if (schedule_work(&wl->txq_task.work)) {
+			atomic_inc(&wl->callbacks);
+		} else {
+			WL_ERROR(("wl%d: wl_start/schedule_work failed\n",
+				  wl->pub->unit));
+		}
+	}
+
+	TXQ_UNLOCK(wl, flags);
+
+	return (0);
+
+}
+
+static void wl_start_txqwork(struct wl_task *task)
+{
+	wl_info_t *wl = (wl_info_t *) task->context;
+	struct sk_buff *skb;
+	ulong flags;
+	uint count = 0;
+
+	WL_TRACE(("wl%d: wl_start_txqwork\n", wl->pub->unit));
+
+	/* First remove an entry then go for execution */
+	TXQ_LOCK(wl, flags);
+	while (wl->txq_head) {
+		skb = wl->txq_head;
+		wl->txq_head = skb->prev;
+		skb->prev = NULL;
+		if (wl->txq_head == NULL)
+			wl->txq_tail = NULL;
+		TXQ_UNLOCK(wl, flags);
+
+		/* it has WL_LOCK/WL_UNLOCK inside */
+		wl_start_int(wl, WL_TO_HW(wl), skb);
+
+		/* bounded our execution, reshedule ourself next */
+		if (++count >= 10)
+			break;
+
+		TXQ_LOCK(wl, flags);
+	}
+
+	if (count >= 10) {
+		if (!schedule_work(&wl->txq_task.work)) {
+			WL_ERROR(("wl%d: wl_start/schedule_work failed\n",
+				  wl->pub->unit));
+			atomic_dec(&wl->callbacks);
+		}
+	} else {
+		wl->txq_dispatched = FALSE;
+		TXQ_UNLOCK(wl, flags);
+		atomic_dec(&wl->callbacks);
+	}
+
+	return;
+}
+
+static void wl_txq_free(wl_info_t * wl)
+{
+	struct sk_buff *skb;
+
+	if (wl->txq_head == NULL) {
+		ASSERT(wl->txq_tail == NULL);
+		return;
+	}
+
+	while (wl->txq_head) {
+		skb = wl->txq_head;
+		wl->txq_head = skb->prev;
+		PKTFREE(wl->osh, skb, TRUE);
+	}
+
+	wl->txq_tail = NULL;
+}
+
+static void wl_rpcq_free(wl_info_t * wl)
+{
+	rpc_buf_t *buf;
+
+	if (wl->rpcq_head == NULL) {
+		ASSERT(wl->rpcq_tail == NULL);
+		return;
+	}
+
+	while (wl->rpcq_head) {
+		buf = wl->rpcq_head;
+		wl->rpcq_head = bcm_rpc_buf_next_get(wl->rpc_th, buf);
+		bcm_rpc_buf_free(wl->rpc_dispatch_ctx.rpc, buf);
+	}
+
+	wl->rpcq_tail = NULL;
+}
+
+static void wl_rpcq_dispatch(struct wl_task *task)
+{
+	wl_info_t *wl = (wl_info_t *) task->context;
+	rpc_buf_t *buf;
+	ulong flags;
+
+	/* First remove an entry then go for execution */
+	RPCQ_LOCK(wl, flags);
+	while (wl->rpcq_head) {
+		buf = wl->rpcq_head;
+		wl->rpcq_head = bcm_rpc_buf_next_get(wl->rpc_th, buf);
+
+		if (wl->rpcq_head == NULL)
+			wl->rpcq_tail = NULL;
+		RPCQ_UNLOCK(wl, flags);
+
+		WL_LOCK(wl);
+		wlc_rpc_high_dispatch(&wl->rpc_dispatch_ctx, buf);
+		WL_UNLOCK(wl);
+
+		RPCQ_LOCK(wl, flags);
+	}
+
+	wl->rpcq_dispatched = FALSE;
+
+	RPCQ_UNLOCK(wl, flags);
+
+	MFREE(wl->osh, task, sizeof(wl_task_t));
+	atomic_dec(&wl->callbacks);
+}
+
+static void wl_rpcq_add(wl_info_t * wl, rpc_buf_t * buf)
+{
+	ulong flags;
+
+	bcm_rpc_buf_next_set(wl->rpc_th, buf, NULL);
+
+	/* Lock the queue as tasklet could be running at this time */
+	RPCQ_LOCK(wl, flags);
+	if (wl->rpcq_head == NULL)
+		wl->rpcq_head = buf;
+	else
+		bcm_rpc_buf_next_set(wl->rpc_th, wl->rpcq_tail, buf);
+
+	wl->rpcq_tail = buf;
+
+	if (wl->rpcq_dispatched == FALSE) {
+		wl->rpcq_dispatched = TRUE;
+		wl_schedule_task(wl, wl_rpcq_dispatch, wl);
+	}
+
+	RPCQ_UNLOCK(wl, flags);
+}
+
+#if defined(BCMDBG)
+static const struct name_entry rpc_name_tbl[] = RPC_ID_TABLE;
+#endif				/* BCMDBG */
+
+/* dongle-side rpc dispatch routine */
+static void wl_rpc_dispatch_schedule(void *ctx, struct rpc_buf *buf)
+{
+	bcm_xdr_buf_t b;
+	wl_info_t *wl = (wl_info_t *) ctx;
+	wlc_rpc_id_t rpc_id;
+	int err;
+
+	bcm_xdr_buf_init(&b, bcm_rpc_buf_data(wl->rpc_th, buf),
+			 bcm_rpc_buf_len_get(wl->rpc_th, buf));
+
+	err = bcm_xdr_unpack_uint32(&b, &rpc_id);
+	ASSERT(!err);
+	WL_TRACE(("%s: Dispatch id %s\n", __func__,
+		  WLC_RPC_ID_LOOKUP(rpc_name_tbl, rpc_id)));
+
+	/* Handle few emergency ones */
+	switch (rpc_id) {
+	default:
+		wl_rpcq_add(wl, buf);
+		break;
+	}
+}
+
+static void wl_timer_task(wl_task_t * task)
+{
+	wl_timer_t *t = (wl_timer_t *) task->context;
+
+	_wl_timer(t);
+	MFREE(t->wl->osh, task, sizeof(wl_task_t));
+
+	/* This dec is for the task_schedule. The timer related
+	 * callback is decremented in _wl_timer
+	 */
+	atomic_dec(&t->wl->callbacks);
+}
+#endif				/* WLC_HIGH_ONLY */
+
+#ifndef WLC_HIGH_ONLY
+char *wl_firmwares[WL_MAX_FW] = {
+	"brcm/bcm43xx",
+	NULL
+};
+
+#ifdef WLC_LOW
+int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, uint32 idx)
+{
+	int i, entry;
+	const uint8 *pdata;
+	struct wl_fw_hdr *hdr;
+	for (i = 0; i < wl->fw.fw_cnt; i++) {
+		hdr = (struct wl_fw_hdr *)wl->fw.fw_hdr[i]->data;
+		for (entry = 0; entry < wl->fw.hdr_num_entries[i];
+		     entry++, hdr++) {
+			if (hdr->idx == idx) {
+				pdata = wl->fw.fw_bin[i]->data + hdr->offset;
+				*pbuf = kmalloc(hdr->len, GFP_ATOMIC);
+				if (*pbuf == NULL) {
+					printf("fail to alloc %d bytes\n",
+					       hdr->len);
+				}
+				bcopy(pdata, *pbuf, hdr->len);
+				return 0;
+			}
+		}
+	}
+	printf("ERROR: ucode buf tag:%d can not be found!\n", idx);
+	*pbuf = NULL;
+	return -1;
+}
+
+int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx)
+{
+	int i, entry;
+	const uint8 *pdata;
+	struct wl_fw_hdr *hdr;
+	for (i = 0; i < wl->fw.fw_cnt; i++) {
+		hdr = (struct wl_fw_hdr *)wl->fw.fw_hdr[i]->data;
+		for (entry = 0; entry < wl->fw.hdr_num_entries[i];
+		     entry++, hdr++) {
+			if (hdr->idx == idx) {
+				pdata = wl->fw.fw_bin[i]->data + hdr->offset;
+				ASSERT(hdr->len == 4);
+				*data = *((uint32 *) pdata);
+				return 0;
+			}
+		}
+	}
+	printf("ERROR: ucode tag:%d can not be found!\n", idx);
+	return -1;
+}
+#endif				/* WLC_LOW */
+
+static int wl_request_fw(wl_info_t * wl, struct pci_dev *pdev)
+{
+	int status;
+	struct device *device = &pdev->dev;
+	char fw_name[100];
+	int i;
+
+	bzero((void *)&wl->fw, sizeof(struct wl_firmware));
+	for (i = 0; i < WL_MAX_FW; i++) {
+		if (wl_firmwares[i] == NULL)
+			break;
+		sprintf(fw_name, "%s-%d.fw", wl_firmwares[i],
+			UCODE_LOADER_API_VER);
+		WL_NONE(("request fw %s\n", fw_name));
+		status = request_firmware(&wl->fw.fw_bin[i], fw_name, device);
+		if (status) {
+			printf("fail to request firmware %s\n", fw_name);
+			return status;
+		}
+		WL_NONE(("request fw %s\n", fw_name));
+		sprintf(fw_name, "%s_hdr-%d.fw", wl_firmwares[i],
+			UCODE_LOADER_API_VER);
+		status = request_firmware(&wl->fw.fw_hdr[i], fw_name, device);
+		if (status) {
+			printf("fail to request firmware %s\n", fw_name);
+			return status;
+		}
+		wl->fw.hdr_num_entries[i] =
+		    wl->fw.fw_hdr[i]->size / (sizeof(struct wl_fw_hdr));
+		WL_NONE(("request fw %s find: %d entries\n", fw_name,
+			 wl->fw.hdr_num_entries[i]));
+	}
+	wl->fw.fw_cnt = i;
+	wl_ucode_data_init(wl);
+	return 0;
+}
+
+#ifdef WLC_LOW
+void wl_ucode_free_buf(void *p)
+{
+	kfree(p);
+}
+#endif				/* WLC_LOW */
+
+static void wl_release_fw(wl_info_t * wl)
+{
+	int i;
+	for (i = 0; i < wl->fw.fw_cnt; i++) {
+		release_firmware(wl->fw.fw_bin[i]);
+		release_firmware(wl->fw.fw_hdr[i]);
+	}
+}
+#endif				/* WLC_HIGH_ONLY */
diff --git a/drivers/staging/brcm80211/sys/wl_mac80211.h b/drivers/staging/brcm80211/sys/wl_mac80211.h
new file mode 100644
index 0000000..a7c89a9
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wl_mac80211.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wl_mac80211_h_
+#define _wl_mac80211_h_
+
+#include <wlc_types.h>
+
+/* BMAC Note: High-only driver is no longer working in softirq context as it needs to block and
+ * sleep so perimeter lock has to be a semaphore instead of spinlock. This requires timers to be
+ * submitted to workqueue instead of being on kernel timer
+ */
+typedef struct wl_timer {
+	struct timer_list timer;
+	struct wl_info *wl;
+	void (*fn) (void *);
+	void *arg;		/* argument to fn */
+	uint ms;
+	bool periodic;
+	bool set;
+	struct wl_timer *next;
+#ifdef BCMDBG
+	char *name;		/* Description of the timer */
+#endif
+} wl_timer_t;
+
+/* contortion to call functions at safe time */
+/* In 2.6.20 kernels work functions get passed a pointer to the struct work, so things
+ * will continue to work as long as the work structure is the first component of the task structure.
+ */
+typedef struct wl_task {
+	struct work_struct work;
+	void *context;
+} wl_task_t;
+
+struct wl_if {
+	uint subunit;		/* WDS/BSS unit */
+	struct pci_dev *pci_dev;
+};
+
+#define WL_MAX_FW		4
+struct wl_firmware {
+	uint32 fw_cnt;
+	const struct firmware *fw_bin[WL_MAX_FW];
+	const struct firmware *fw_hdr[WL_MAX_FW];
+	uint32 hdr_num_entries[WL_MAX_FW];
+};
+
+struct wl_info {
+	wlc_pub_t *pub;		/* pointer to public wlc state */
+	void *wlc;		/* pointer to private common os-independent data */
+	osl_t *osh;		/* pointer to os handler */
+	uint32 magic;
+
+	int irq;
+
+#ifdef WLC_HIGH_ONLY
+	struct semaphore sem;	/* use semaphore to allow sleep */
+#else
+	spinlock_t lock;	/* per-device perimeter lock */
+	spinlock_t isr_lock;	/* per-device ISR synchronization lock */
+#endif
+	uint bcm_bustype;	/* bus type */
+	bool piomode;		/* set from insmod argument */
+	void *regsva;		/* opaque chip registers virtual address */
+	atomic_t callbacks;	/* # outstanding callback functions */
+	struct wl_timer *timers;	/* timer cleanup queue */
+	struct tasklet_struct tasklet;	/* dpc tasklet */
+#ifdef BCMSDIO
+	bcmsdh_info_t *sdh;	/* pointer to sdio bus handler */
+	ulong flags;		/* current irq flags */
+#endif				/* BCMSDIO */
+	bool resched;		/* dpc needs to be and is rescheduled */
+#ifdef LINUXSTA_PS
+	uint32 pci_psstate[16];	/* pci ps-state save/restore */
+#endif
+	/* RPC, handle, lock, txq, workitem */
+#ifdef WLC_HIGH_ONLY
+	rpc_info_t *rpc;	/* RPC handle */
+	rpc_tp_info_t *rpc_th;	/* RPC transport handle */
+	wlc_rpc_ctx_t rpc_dispatch_ctx;
+
+	bool rpcq_dispatched;	/* Avoid scheduling multiple tasks */
+	spinlock_t rpcq_lock;	/* Lock for the queue */
+	rpc_buf_t *rpcq_head;	/* RPC Q */
+	rpc_buf_t *rpcq_tail;	/* Points to the last buf */
+
+	bool txq_dispatched;	/* Avoid scheduling multiple tasks */
+	spinlock_t txq_lock;	/* Lock for the queue */
+	struct sk_buff *txq_head;	/* TX Q */
+	struct sk_buff *txq_tail;	/* Points to the last buf */
+
+	wl_task_t txq_task;	/* work queue for wl_start() */
+#endif				/* WLC_HIGH_ONLY */
+	uint stats_id;		/* the current set of stats */
+	/* ping-pong stats counters updated by Linux watchdog */
+	struct net_device_stats stats_watchdog[2];
+
+	struct proc_dir_entry *proc_entry;
+	char *ioctlbuf;
+	unsigned int ioctlbuf_sz;
+	wl_ioctl_t ioc;
+	int proc_state;
+	bool ioctl_in_progress;
+	struct wl_firmware fw;
+};
+#define WL_PROC_IDLE		(0)
+#define WL_PROC_HAVE_IOC	(1)
+#define WL_PROC_HAVE_BUF 	(2)
+
+#ifndef WLC_HIGH_ONLY
+#define WL_LOCK(wl)	spin_lock_bh(&(wl)->lock)
+#define WL_UNLOCK(wl)	spin_unlock_bh(&(wl)->lock)
+
+/* locking from inside wl_isr */
+#define WL_ISRLOCK(wl, flags) do {spin_lock(&(wl)->isr_lock); (void)(flags);} while (0)
+#define WL_ISRUNLOCK(wl, flags) do {spin_unlock(&(wl)->isr_lock); (void)(flags);} while (0)
+
+/* locking under WL_LOCK() to synchronize with wl_isr */
+#define INT_LOCK(wl, flags)	spin_lock_irqsave(&(wl)->isr_lock, flags)
+#define INT_UNLOCK(wl, flags)	spin_unlock_irqrestore(&(wl)->isr_lock, flags)
+#else				/* BCMSDIO */
+
+#define WL_LOCK(wl)	down(&(wl)->sem)
+#define WL_UNLOCK(wl)	up(&(wl)->sem)
+
+#define WL_ISRLOCK(wl)
+#define WL_ISRUNLOCK(wl)
+#endif				/* WLC_HIGH_ONLY */
+
+/* handle forward declaration */
+typedef struct wl_info wl_info_t;
+
+#ifndef PCI_D0
+#define PCI_D0		0
+#endif
+
+#ifndef PCI_D3hot
+#define PCI_D3hot	3
+#endif
+
+/* exported functions */
+
+extern irqreturn_t wl_isr(int irq, void *dev_id);
+
+extern int __devinit wl_pci_probe(struct pci_dev *pdev,
+				  const struct pci_device_id *ent);
+extern void wl_free(wl_info_t * wl);
+extern int wl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+extern int wl_ucode_data_init(wl_info_t * wl);
+extern void wl_ucode_data_free(void);
+#ifdef WLC_LOW
+extern void wl_ucode_free_buf(void *);
+extern int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, uint32 idx);
+extern int wl_ucode_init_uint(wl_info_t * wl, uint32 * data, uint32 idx);
+#endif				/* WLC_LOW */
+
+#endif				/* _wl_mac80211_h_ */
diff --git a/drivers/staging/brcm80211/sys/wl_ucode.h b/drivers/staging/brcm80211/sys/wl_ucode.h
new file mode 100644
index 0000000..2763b7c
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wl_ucode.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+typedef struct d11init {
+	uint16 addr;
+	uint16 size;
+	uint32 value;
+} d11init_t;
+
+extern d11init_t *d11lcn0bsinitvals24;
+extern d11init_t *d11lcn0initvals24;
+extern d11init_t *d11lcn1bsinitvals24;
+extern d11init_t *d11lcn1initvals24;
+extern d11init_t *d11lcn2bsinitvals24;
+extern d11init_t *d11lcn2initvals24;
+extern d11init_t *d11n0absinitvals16;
+extern d11init_t *d11n0bsinitvals16;
+extern d11init_t *d11n0initvals16;
+extern uint32 *bcm43xx_16_mimo;
+extern uint32 bcm43xx_16_mimosz;
+extern uint32 *bcm43xx_24_lcn;
+extern uint32 bcm43xx_24_lcnsz;
+extern uint32 *bcm43xx_bommajor;
+extern uint32 *bcm43xx_bomminor;
diff --git a/drivers/staging/brcm80211/sys/wl_ucode_loader.c b/drivers/staging/brcm80211/sys/wl_ucode_loader.c
new file mode 100644
index 0000000..7eef308
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wl_ucode_loader.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+typedef struct wl_info wl_info_t;
+#include <typedefs.h>
+#include <d11ucode_ext.h>
+#include <wl_ucode.h>
+
+extern int wl_ucode_init_buf(wl_info_t * wl, void **pbuf, unsigned int idx);
+extern int wl_ucode_init_uint(wl_info_t * wl, unsigned *data, unsigned int idx);
+extern int wl_ucode_data_init(wl_info_t * wl);
+extern void wl_ucode_data_free(void);
+extern void wl_ucode_free_buf(void *);
+
+d11init_t *d11lcn0bsinitvals24;
+d11init_t *d11lcn0initvals24;
+d11init_t *d11lcn1bsinitvals24;
+d11init_t *d11lcn1initvals24;
+d11init_t *d11lcn2bsinitvals24;
+d11init_t *d11lcn2initvals24;
+d11init_t *d11n0absinitvals16;
+d11init_t *d11n0bsinitvals16;
+d11init_t *d11n0initvals16;
+uint32 *bcm43xx_16_mimo;
+uint32 bcm43xx_16_mimosz;
+uint32 *bcm43xx_24_lcn;
+uint32 bcm43xx_24_lcnsz;
+uint32 *bcm43xx_bommajor;
+uint32 *bcm43xx_bomminor;
+
+int wl_ucode_data_init(wl_info_t * wl)
+{
+	wl_ucode_init_buf(wl, (void **)&d11lcn0bsinitvals24,
+			  D11LCN0BSINITVALS24);
+	wl_ucode_init_buf(wl, (void **)&d11lcn0initvals24, D11LCN0INITVALS24);
+	wl_ucode_init_buf(wl, (void **)&d11lcn1bsinitvals24,
+			  D11LCN1BSINITVALS24);
+	wl_ucode_init_buf(wl, (void **)&d11lcn1initvals24, D11LCN1INITVALS24);
+	wl_ucode_init_buf(wl, (void **)&d11lcn2bsinitvals24,
+			  D11LCN2BSINITVALS24);
+	wl_ucode_init_buf(wl, (void **)&d11lcn2initvals24, D11LCN2INITVALS24);
+	wl_ucode_init_buf(wl, (void **)&d11n0absinitvals16, D11N0ABSINITVALS16);
+	wl_ucode_init_buf(wl, (void **)&d11n0bsinitvals16, D11N0BSINITVALS16);
+	wl_ucode_init_buf(wl, (void **)&d11n0initvals16, D11N0INITVALS16);
+	wl_ucode_init_buf(wl, (void **)&bcm43xx_16_mimo,
+			  D11UCODE_OVERSIGHT16_MIMO);
+	wl_ucode_init_uint(wl, &bcm43xx_16_mimosz, D11UCODE_OVERSIGHT16_MIMOSZ);
+	wl_ucode_init_buf(wl, (void **)&bcm43xx_24_lcn,
+			  D11UCODE_OVERSIGHT24_LCN);
+	wl_ucode_init_uint(wl, &bcm43xx_24_lcnsz, D11UCODE_OVERSIGHT24_LCNSZ);
+	wl_ucode_init_buf(wl, (void **)&bcm43xx_bommajor,
+			  D11UCODE_OVERSIGHT_BOMMAJOR);
+	wl_ucode_init_buf(wl, (void **)&bcm43xx_bomminor,
+			  D11UCODE_OVERSIGHT_BOMMINOR);
+
+	return 0;
+}
+
+void wl_ucode_data_free(void)
+{
+	wl_ucode_free_buf((void *)d11lcn0bsinitvals24);
+	wl_ucode_free_buf((void *)d11lcn0initvals24);
+	wl_ucode_free_buf((void *)d11lcn1bsinitvals24);
+	wl_ucode_free_buf((void *)d11lcn1initvals24);
+	wl_ucode_free_buf((void *)d11lcn2bsinitvals24);
+	wl_ucode_free_buf((void *)d11lcn2initvals24);
+	wl_ucode_free_buf((void *)d11n0absinitvals16);
+	wl_ucode_free_buf((void *)d11n0bsinitvals16);
+	wl_ucode_free_buf((void *)d11n0initvals16);
+	wl_ucode_free_buf((void *)bcm43xx_16_mimo);
+	wl_ucode_free_buf((void *)bcm43xx_24_lcn);
+	wl_ucode_free_buf((void *)bcm43xx_bommajor);
+	wl_ucode_free_buf((void *)bcm43xx_bomminor);
+
+	return;
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_alloc.c b/drivers/staging/brcm80211/sys/wlc_alloc.c
new file mode 100644
index 0000000..4f3f831
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <proto/802.11.h>
+#include <proto/802.11e.h>
+#include <proto/wpa.h>
+#include <wlioctl.h>
+#include <bcmwpa.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_pub.h>
+#include <wlc_key.h>
+#include <wlc_bsscfg.h>
+#include <wlc_mac80211.h>
+#include <wlc_alloc.h>
+
+static wlc_pub_t *wlc_pub_malloc(osl_t * osh, uint unit, uint * err,
+				 uint devid);
+static void wlc_pub_mfree(osl_t * osh, wlc_pub_t * pub);
+static void wlc_tunables_init(wlc_tunables_t * tunables, uint devid);
+
+void *wlc_calloc(osl_t * osh, uint unit, uint size)
+{
+	void *item;
+
+	if ((item = MALLOC(osh, size)) == NULL)
+		WL_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
+			  unit, __func__, MALLOCED(osh)));
+	else
+		bzero((char *)item, size);
+	return item;
+}
+
+void BCMATTACHFN(wlc_tunables_init) (wlc_tunables_t * tunables, uint devid) {
+	tunables->ntxd = NTXD;
+	tunables->nrxd = NRXD;
+	tunables->rxbufsz = RXBUFSZ;
+	tunables->nrxbufpost = NRXBUFPOST;
+	tunables->maxscb = MAXSCB;
+	tunables->ampdunummpdu = AMPDU_NUM_MPDU;
+	tunables->maxpktcb = MAXPKTCB;
+	tunables->maxucodebss = WLC_MAX_UCODE_BSS;
+	tunables->maxucodebss4 = WLC_MAX_UCODE_BSS4;
+	tunables->maxbss = MAXBSS;
+	tunables->datahiwat = WLC_DATAHIWAT;
+	tunables->ampdudatahiwat = WLC_AMPDUDATAHIWAT;
+	tunables->rxbnd = RXBND;
+	tunables->txsbnd = TXSBND;
+#if defined(WLC_HIGH_ONLY) && defined(NTXD_USB_4319)
+	if (devid == BCM4319_CHIP_ID) {
+		tunables->ntxd = NTXD_USB_4319;
+	}
+#endif				/* WLC_HIGH_ONLY */
+}
+
+static wlc_pub_t *BCMATTACHFN(wlc_pub_malloc) (osl_t * osh, uint unit,
+					       uint * err, uint devid) {
+	wlc_pub_t *pub;
+
+	if ((pub =
+	     (wlc_pub_t *) wlc_calloc(osh, unit, sizeof(wlc_pub_t))) == NULL) {
+		*err = 1001;
+		goto fail;
+	}
+
+	if ((pub->tunables = (wlc_tunables_t *)
+	     wlc_calloc(osh, unit, sizeof(wlc_tunables_t))) == NULL) {
+		*err = 1028;
+		goto fail;
+	}
+
+	/* need to init the tunables now */
+	wlc_tunables_init(pub->tunables, devid);
+
+	if ((pub->multicast = (struct ether_addr *)
+	     wlc_calloc(osh, unit,
+			(sizeof(struct ether_addr) * MAXMULTILIST))) == NULL) {
+		*err = 1003;
+		goto fail;
+	}
+
+	return pub;
+
+ fail:
+	wlc_pub_mfree(osh, pub);
+	return NULL;
+}
+
+static void BCMATTACHFN(wlc_pub_mfree) (osl_t * osh, wlc_pub_t * pub) {
+	if (pub == NULL)
+		return;
+
+	if (pub->multicast)
+		MFREE(osh, pub->multicast,
+		      (sizeof(struct ether_addr) * MAXMULTILIST));
+
+	if (pub->tunables) {
+		MFREE(osh, pub->tunables, sizeof(wlc_tunables_t));
+		pub->tunables = NULL;
+	}
+
+	MFREE(osh, pub, sizeof(wlc_pub_t));
+}
+
+wlc_bsscfg_t *wlc_bsscfg_malloc(osl_t * osh, uint unit)
+{
+	wlc_bsscfg_t *cfg;
+
+	if ((cfg =
+	     (wlc_bsscfg_t *) wlc_calloc(osh, unit,
+					 sizeof(wlc_bsscfg_t))) == NULL)
+		goto fail;
+
+	if ((cfg->current_bss = (wlc_bss_info_t *)
+	     wlc_calloc(osh, unit, sizeof(wlc_bss_info_t))) == NULL)
+		goto fail;
+
+	return cfg;
+
+ fail:
+	wlc_bsscfg_mfree(osh, cfg);
+	return NULL;
+}
+
+void wlc_bsscfg_mfree(osl_t * osh, wlc_bsscfg_t * cfg)
+{
+	if (cfg == NULL)
+		return;
+
+	if (cfg->maclist) {
+		MFREE(osh, cfg->maclist,
+		      (int)(OFFSETOF(struct maclist, ea) +
+			    cfg->nmac * ETHER_ADDR_LEN));
+		cfg->maclist = NULL;
+	}
+
+	if (cfg->current_bss != NULL) {
+		wlc_bss_info_t *current_bss = cfg->current_bss;
+		if (current_bss->bcn_prb != NULL)
+			MFREE(osh, current_bss->bcn_prb,
+			      current_bss->bcn_prb_len);
+		MFREE(osh, current_bss, sizeof(wlc_bss_info_t));
+		cfg->current_bss = NULL;
+	}
+
+	MFREE(osh, cfg, sizeof(wlc_bsscfg_t));
+}
+
+void wlc_bsscfg_ID_assign(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg)
+{
+	bsscfg->ID = wlc->next_bsscfg_ID;
+	wlc->next_bsscfg_ID++;
+}
+
+/*
+ * The common driver entry routine. Error codes should be unique
+ */
+wlc_info_t *BCMATTACHFN(wlc_attach_malloc) (osl_t * osh, uint unit, uint * err,
+					    uint devid) {
+	wlc_info_t *wlc;
+
+	if ((wlc =
+	     (wlc_info_t *) wlc_calloc(osh, unit,
+				       sizeof(wlc_info_t))) == NULL) {
+		*err = 1002;
+		goto fail;
+	}
+
+	wlc->hwrxoff = WL_HWRXOFF;
+
+	/* allocate wlc_pub_t state structure */
+	if ((wlc->pub = wlc_pub_malloc(osh, unit, err, devid)) == NULL) {
+		*err = 1003;
+		goto fail;
+	}
+	wlc->pub->wlc = wlc;
+
+	/* allocate wlc_hw_info_t state structure */
+
+	if ((wlc->hw = (wlc_hw_info_t *)
+	     wlc_calloc(osh, unit, sizeof(wlc_hw_info_t))) == NULL) {
+		*err = 1005;
+		goto fail;
+	}
+	wlc->hw->wlc = wlc;
+
+#ifdef WLC_LOW
+	if ((wlc->hw->bandstate[0] = (wlc_hwband_t *)
+	     wlc_calloc(osh, unit, (sizeof(wlc_hwband_t) * MAXBANDS))) == NULL) {
+		*err = 1006;
+		goto fail;
+	} else {
+		int i;
+
+		for (i = 1; i < MAXBANDS; i++) {
+			wlc->hw->bandstate[i] = (wlc_hwband_t *)
+			    ((uintptr) wlc->hw->bandstate[0] +
+			     (sizeof(wlc_hwband_t) * i));
+		}
+	}
+#endif				/* WLC_LOW */
+
+	if ((wlc->modulecb = (modulecb_t *)
+	     wlc_calloc(osh, unit,
+			sizeof(modulecb_t) * WLC_MAXMODULES)) == NULL) {
+		*err = 1009;
+		goto fail;
+	}
+
+	if ((wlc->default_bss = (wlc_bss_info_t *)
+	     wlc_calloc(osh, unit, sizeof(wlc_bss_info_t))) == NULL) {
+		*err = 1010;
+		goto fail;
+	}
+
+	if ((wlc->cfg = wlc_bsscfg_malloc(osh, unit)) == NULL) {
+		*err = 1011;
+		goto fail;
+	}
+	wlc_bsscfg_ID_assign(wlc, wlc->cfg);
+
+	if ((wlc->pkt_callback = (pkt_cb_t *)
+	     wlc_calloc(osh, unit,
+			(sizeof(pkt_cb_t) *
+			 (wlc->pub->tunables->maxpktcb + 1)))) == NULL) {
+		*err = 1013;
+		goto fail;
+	}
+
+	if ((wlc->wsec_def_keys[0] = (wsec_key_t *)
+	     wlc_calloc(osh, unit,
+			(sizeof(wsec_key_t) * WLC_DEFAULT_KEYS))) == NULL) {
+		*err = 1015;
+		goto fail;
+	} else {
+		int i;
+		for (i = 1; i < WLC_DEFAULT_KEYS; i++) {
+			wlc->wsec_def_keys[i] = (wsec_key_t *)
+			    ((uintptr) wlc->wsec_def_keys[0] +
+			     (sizeof(wsec_key_t) * i));
+		}
+	}
+
+	if ((wlc->protection = (wlc_protection_t *)
+	     wlc_calloc(osh, unit, sizeof(wlc_protection_t))) == NULL) {
+		*err = 1016;
+		goto fail;
+	}
+
+	if ((wlc->stf = (wlc_stf_t *)
+	     wlc_calloc(osh, unit, sizeof(wlc_stf_t))) == NULL) {
+		*err = 1017;
+		goto fail;
+	}
+
+	if ((wlc->bandstate[0] = (wlcband_t *)
+	     wlc_calloc(osh, unit, (sizeof(wlcband_t) * MAXBANDS))) == NULL) {
+		*err = 1025;
+		goto fail;
+	} else {
+		int i;
+
+		for (i = 1; i < MAXBANDS; i++) {
+			wlc->bandstate[i] =
+			    (wlcband_t *) ((uintptr) wlc->bandstate[0] +
+					   (sizeof(wlcband_t) * i));
+		}
+	}
+
+	if ((wlc->corestate = (wlccore_t *)
+	     wlc_calloc(osh, unit, sizeof(wlccore_t))) == NULL) {
+		*err = 1026;
+		goto fail;
+	}
+
+	if ((wlc->corestate->macstat_snapshot = (macstat_t *)
+	     wlc_calloc(osh, unit, sizeof(macstat_t))) == NULL) {
+		*err = 1027;
+		goto fail;
+	}
+
+	return wlc;
+
+ fail:
+	wlc_detach_mfree(wlc, osh);
+	return NULL;
+}
+
+void BCMATTACHFN(wlc_detach_mfree) (wlc_info_t * wlc, osl_t * osh) {
+	if (wlc == NULL)
+		return;
+
+	if (wlc->modulecb) {
+		MFREE(osh, wlc->modulecb, sizeof(modulecb_t) * WLC_MAXMODULES);
+		wlc->modulecb = NULL;
+	}
+
+	if (wlc->default_bss) {
+		MFREE(osh, wlc->default_bss, sizeof(wlc_bss_info_t));
+		wlc->default_bss = NULL;
+	}
+	if (wlc->cfg) {
+		wlc_bsscfg_mfree(osh, wlc->cfg);
+		wlc->cfg = NULL;
+	}
+
+	if (wlc->pkt_callback && wlc->pub && wlc->pub->tunables) {
+		MFREE(osh,
+		      wlc->pkt_callback,
+		      sizeof(pkt_cb_t) * (wlc->pub->tunables->maxpktcb + 1));
+		wlc->pkt_callback = NULL;
+	}
+
+	if (wlc->wsec_def_keys[0])
+		MFREE(osh, wlc->wsec_def_keys[0],
+		      (sizeof(wsec_key_t) * WLC_DEFAULT_KEYS));
+
+	if (wlc->protection) {
+		MFREE(osh, wlc->protection, sizeof(wlc_protection_t));
+		wlc->protection = NULL;
+	}
+
+	if (wlc->stf) {
+		MFREE(osh, wlc->stf, sizeof(wlc_stf_t));
+		wlc->stf = NULL;
+	}
+
+	if (wlc->bandstate[0])
+		MFREE(osh, wlc->bandstate[0], (sizeof(wlcband_t) * MAXBANDS));
+
+	if (wlc->corestate) {
+		if (wlc->corestate->macstat_snapshot) {
+			MFREE(osh, wlc->corestate->macstat_snapshot,
+			      sizeof(macstat_t));
+			wlc->corestate->macstat_snapshot = NULL;
+		}
+		MFREE(osh, wlc->corestate, sizeof(wlccore_t));
+		wlc->corestate = NULL;
+	}
+
+	if (wlc->pub) {
+		/* free pub struct */
+		wlc_pub_mfree(osh, wlc->pub);
+		wlc->pub = NULL;
+	}
+
+	if (wlc->hw) {
+#ifdef WLC_LOW
+		if (wlc->hw->bandstate[0]) {
+			MFREE(osh, wlc->hw->bandstate[0],
+			      (sizeof(wlc_hwband_t) * MAXBANDS));
+			wlc->hw->bandstate[0] = NULL;
+		}
+#endif
+
+		/* free hw struct */
+		MFREE(osh, wlc->hw, sizeof(wlc_hw_info_t));
+		wlc->hw = NULL;
+	}
+
+	/* free the wlc */
+	MFREE(osh, wlc, sizeof(wlc_info_t));
+	wlc = NULL;
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_alloc.h b/drivers/staging/brcm80211/sys/wlc_alloc.h
new file mode 100644
index 0000000..fc923de
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_alloc.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+extern void *wlc_calloc(osl_t * osh, uint unit, uint size);
+
+extern wlc_info_t *wlc_attach_malloc(osl_t * osh, uint unit, uint * err,
+				     uint devid);
+extern void wlc_detach_mfree(wlc_info_t * wlc, osl_t * osh);
+
+struct wlc_bsscfg;
+extern struct wlc_bsscfg *wlc_bsscfg_malloc(osl_t * osh, uint unit);
+extern void wlc_bsscfg_mfree(osl_t * osh, struct wlc_bsscfg *cfg);
diff --git a/drivers/staging/brcm80211/sys/wlc_ampdu.c b/drivers/staging/brcm80211/sys/wlc_ampdu.c
new file mode 100644
index 0000000..d7071e5
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.c
@@ -0,0 +1,1417 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <proto/802.11.h>
+#include <wlioctl.h>
+#include <sbhndpio.h>
+#include <sbhnddma.h>
+#include <hnddma.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_pub.h>
+#include <wlc_key.h>
+#include <wlc_bsscfg.h>
+#include <wlc_mac80211.h>
+#include <wlc_phy_hal.h>
+#include <wlc_antsel.h>
+#include <wlc_scb.h>
+#include <net/mac80211.h>
+#include <wlc_ampdu.h>
+#include <wl_export.h>
+
+#ifdef WLC_HIGH_ONLY
+#include <bcm_rpc_tp.h>
+#include <wlc_rpctx.h>
+#endif
+
+#define AMPDU_MAX_MPDU		32	/* max number of mpdus in an ampdu */
+#define AMPDU_NUM_MPDU_LEGACY	16	/* max number of mpdus in an ampdu to a legacy */
+#define AMPDU_TX_BA_MAX_WSIZE	64	/* max Tx ba window size (in pdu) */
+#define AMPDU_TX_BA_DEF_WSIZE	64	/* default Tx ba window size (in pdu) */
+#define AMPDU_RX_BA_DEF_WSIZE   64	/* max Rx ba window size (in pdu) */
+#define AMPDU_RX_BA_MAX_WSIZE   64	/* default Rx ba window size (in pdu) */
+#define	AMPDU_MAX_DUR		5	/* max dur of tx ampdu (in msec) */
+#define AMPDU_DEF_RETRY_LIMIT	5	/* default tx retry limit */
+#define AMPDU_DEF_RR_RETRY_LIMIT	2	/* default tx retry limit at reg rate */
+#define AMPDU_DEF_TXPKT_WEIGHT	2	/* default weight of ampdu in txfifo */
+#define AMPDU_DEF_FFPLD_RSVD	2048	/* default ffpld reserved bytes */
+#define AMPDU_INI_FREE		10	/* # of inis to be freed on detach */
+#define	AMPDU_SCB_MAX_RELEASE	20	/* max # of mpdus released at a time */
+
+#define NUM_FFPLD_FIFO 4	/* number of fifo concerned by pre-loading */
+#define FFPLD_TX_MAX_UNFL   200	/* default value of the average number of ampdu
+				 * without underflows
+				 */
+#define FFPLD_MPDU_SIZE 1800	/* estimate of maximum mpdu size */
+#define FFPLD_MAX_MCS 23	/* we don't deal with mcs 32 */
+#define FFPLD_PLD_INCR 1000	/* increments in bytes */
+#define FFPLD_MAX_AMPDU_CNT 5000	/* maximum number of ampdu we
+					 * accumulate between resets.
+					 */
+
+#define TX_SEQ_TO_INDEX(seq) (seq) % AMPDU_TX_BA_MAX_WSIZE
+
+/* max possible overhead per mpdu in the ampdu; 3 is for roundup if needed */
+#define AMPDU_MAX_MPDU_OVERHEAD (DOT11_FCS_LEN + DOT11_ICV_AES_LEN + AMPDU_DELIMITER_LEN + 3 \
+	+ DOT11_A4_HDR_LEN + DOT11_QOS_LEN + DOT11_IV_MAX_LEN)
+
+#ifdef BCMDBG
+uint32 wl_ampdu_dbg =
+    WL_AMPDU_UPDN_VAL |
+    WL_AMPDU_ERR_VAL |
+    WL_AMPDU_TX_VAL |
+    WL_AMPDU_RX_VAL |
+    WL_AMPDU_CTL_VAL |
+    WL_AMPDU_HW_VAL | WL_AMPDU_HWTXS_VAL | WL_AMPDU_HWDBG_VAL;
+#endif
+
+/* structure to hold tx fifo information and pre-loading state
+ * counters specific to tx underflows of ampdus
+ * some counters might be redundant with the ones in wlc or ampdu structures.
+ * This allows to maintain a specific state independantly of
+ * how often and/or when the wlc counters are updated.
+ */
+typedef struct wlc_fifo_info {
+	uint16 ampdu_pld_size;	/* number of bytes to be pre-loaded */
+	uint8 mcs2ampdu_table[FFPLD_MAX_MCS + 1];	/* per-mcs max # of mpdus in an ampdu */
+	uint16 prev_txfunfl;	/* num of underflows last read from the HW macstats counter */
+	uint32 accum_txfunfl;	/* num of underflows since we modified pld params */
+	uint32 accum_txampdu;	/* num of tx ampdu since we modified pld params  */
+	uint32 prev_txampdu;	/* previous reading of tx ampdu */
+	uint32 dmaxferrate;	/* estimated dma avg xfer rate in kbits/sec */
+} wlc_fifo_info_t;
+
+/* AMPDU module specific state */
+struct ampdu_info {
+	wlc_info_t *wlc;	/* pointer to main wlc structure */
+	int scb_handle;		/* scb cubby handle to retrieve data from scb */
+	uint8 ini_enable[AMPDU_MAX_SCB_TID];	/* per-tid initiator enable/disable of ampdu */
+	uint8 ba_tx_wsize;	/* Tx ba window size (in pdu) */
+	uint8 ba_rx_wsize;	/* Rx ba window size (in pdu) */
+	uint8 retry_limit;	/* mpdu transmit retry limit */
+	uint8 rr_retry_limit;	/* mpdu transmit retry limit at regular rate */
+	uint8 retry_limit_tid[AMPDU_MAX_SCB_TID];	/* per-tid mpdu transmit retry limit */
+	/* per-tid mpdu transmit retry limit at regular rate */
+	uint8 rr_retry_limit_tid[AMPDU_MAX_SCB_TID];
+	uint8 mpdu_density;	/* min mpdu spacing (0-7) ==> 2^(x-1)/8 usec */
+	int8 max_pdu;		/* max pdus allowed in ampdu */
+	uint8 dur;		/* max duration of an ampdu (in msec) */
+	uint8 txpkt_weight;	/* weight of ampdu in txfifo; reduces rate lag */
+	uint8 rx_factor;	/* maximum rx ampdu factor (0-3) ==> 2^(13+x) bytes */
+	uint32 ffpld_rsvd;	/* number of bytes to reserve for preload */
+	uint32 max_txlen[MCS_TABLE_SIZE][2][2];	/* max size of ampdu per mcs, bw and sgi */
+	void *ini_free[AMPDU_INI_FREE];	/* array of ini's to be freed on detach */
+	bool mfbr;		/* enable multiple fallback rate */
+	uint32 tx_max_funl;	/* underflows should be kept such that
+				 * (tx_max_funfl*underflows) < tx frames
+				 */
+	wlc_fifo_info_t fifo_tb[NUM_FFPLD_FIFO];	/* table of fifo infos  */
+
+#ifdef WLC_HIGH_ONLY
+	void *p;
+	tx_status_t txs;
+	bool waiting_status;	/* To help sanity checks */
+#endif
+};
+
+#define AMPDU_CLEANUPFLAG_RX   (0x1)
+#define AMPDU_CLEANUPFLAG_TX   (0x2)
+
+#define SCB_AMPDU_CUBBY(ampdu, scb) (&(scb->scb_ampdu))
+#define SCB_AMPDU_INI(scb_ampdu, tid) (&(scb_ampdu->ini[tid]))
+
+static void wlc_ffpld_init(ampdu_info_t * ampdu);
+static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int f);
+static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t * ampdu, int f);
+
+static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t * ampdu,
+						   scb_ampdu_t * scb_ampdu,
+						   uint8 tid, bool override);
+static void ampdu_cleanup_tid_ini(ampdu_info_t * ampdu, scb_ampdu_t * scb_ampdu,
+				  uint8 tid, bool force);
+static void ampdu_update_max_txlen(ampdu_info_t * ampdu, uint8 dur);
+static void scb_ampdu_update_config(ampdu_info_t * ampdu, struct scb *scb);
+static void scb_ampdu_update_config_all(ampdu_info_t * ampdu);
+
+#define wlc_ampdu_txflowcontrol(a, b, c)	do {} while (0)
+
+static void wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb,
+					  void *p, tx_status_t * txs,
+					  uint32 frmtxstatus,
+					  uint32 frmtxstatus2);
+
+static INLINE uint16 pkt_txh_seqnum(wlc_info_t * wlc, void *p)
+{
+	d11txh_t *txh;
+	struct dot11_header *h;
+	txh = (d11txh_t *) PKTDATA(p);
+	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	return (ltoh16(h->seq) >> SEQNUM_SHIFT);
+}
+
+ampdu_info_t *BCMATTACHFN(wlc_ampdu_attach) (wlc_info_t * wlc) {
+	ampdu_info_t *ampdu;
+	int i;
+
+	/* some code depends on packed structures */
+	ASSERT(sizeof(struct dot11_bar) == DOT11_BAR_LEN);
+	ASSERT(sizeof(struct dot11_ba) == DOT11_BA_LEN + DOT11_BA_BITMAP_LEN);
+	ASSERT(sizeof(struct dot11_ctl_header) == DOT11_CTL_HDR_LEN);
+	ASSERT(sizeof(struct dot11_addba_req) == DOT11_ADDBA_REQ_LEN);
+	ASSERT(sizeof(struct dot11_addba_resp) == DOT11_ADDBA_RESP_LEN);
+	ASSERT(sizeof(struct dot11_delba) == DOT11_DELBA_LEN);
+	ASSERT(DOT11_MAXNUMFRAGS == NBITS(uint16));
+	ASSERT(ISPOWEROF2(AMPDU_TX_BA_MAX_WSIZE));
+	ASSERT(ISPOWEROF2(AMPDU_RX_BA_MAX_WSIZE));
+	ASSERT(wlc->pub->tunables->ampdunummpdu <= AMPDU_MAX_MPDU);
+	ASSERT(wlc->pub->tunables->ampdunummpdu > 0);
+
+	if (!(ampdu = (ampdu_info_t *) MALLOC(wlc->osh, sizeof(ampdu_info_t)))) {
+		WL_ERROR(("wl%d: wlc_ampdu_attach: out of mem, malloced %d bytes\n", wlc->pub->unit, MALLOCED(wlc->osh)));
+		return NULL;
+	}
+	bzero((char *)ampdu, sizeof(ampdu_info_t));
+	ampdu->wlc = wlc;
+
+	for (i = 0; i < AMPDU_MAX_SCB_TID; i++)
+		ampdu->ini_enable[i] = TRUE;
+	/* Disable ampdu for VO by default */
+	ampdu->ini_enable[PRIO_8021D_VO] = FALSE;
+	ampdu->ini_enable[PRIO_8021D_NC] = FALSE;
+
+	/* Disable ampdu for BK by default since not enough fifo space */
+	ampdu->ini_enable[PRIO_8021D_NONE] = FALSE;
+	ampdu->ini_enable[PRIO_8021D_BK] = FALSE;
+
+	ampdu->ba_tx_wsize = AMPDU_TX_BA_DEF_WSIZE;
+	ampdu->ba_rx_wsize = AMPDU_RX_BA_DEF_WSIZE;
+	ampdu->mpdu_density = AMPDU_DEF_MPDU_DENSITY;
+	ampdu->max_pdu = AUTO;
+	ampdu->dur = AMPDU_MAX_DUR;
+	ampdu->txpkt_weight = AMPDU_DEF_TXPKT_WEIGHT;
+
+	ampdu->ffpld_rsvd = AMPDU_DEF_FFPLD_RSVD;
+	/* bump max ampdu rcv size to 64k for all 11n devices except 4321A0 and 4321A1 */
+	if (WLCISNPHY(wlc->band) && NREV_LT(wlc->band->phyrev, 2))
+		ampdu->rx_factor = AMPDU_RX_FACTOR_32K;
+	else
+		ampdu->rx_factor = AMPDU_RX_FACTOR_64K;
+#ifdef WLC_HIGH_ONLY
+	/* Restrict to smaller rcv size for BMAC dongle */
+	ampdu->rx_factor = AMPDU_RX_FACTOR_32K;
+#endif
+	ampdu->retry_limit = AMPDU_DEF_RETRY_LIMIT;
+	ampdu->rr_retry_limit = AMPDU_DEF_RR_RETRY_LIMIT;
+
+	for (i = 0; i < AMPDU_MAX_SCB_TID; i++) {
+		ampdu->retry_limit_tid[i] = ampdu->retry_limit;
+		ampdu->rr_retry_limit_tid[i] = ampdu->rr_retry_limit;
+	}
+
+	ampdu_update_max_txlen(ampdu, ampdu->dur);
+	ampdu->mfbr = FALSE;
+	/* try to set ampdu to the default value */
+	wlc_ampdu_set(ampdu, wlc->pub->_ampdu);
+
+	ampdu->tx_max_funl = FFPLD_TX_MAX_UNFL;
+	wlc_ffpld_init(ampdu);
+
+	return ampdu;
+}
+
+void BCMATTACHFN(wlc_ampdu_detach) (ampdu_info_t * ampdu) {
+	int i;
+
+	if (!ampdu)
+		return;
+
+	/* free all ini's which were to be freed on callbacks which were never called */
+	for (i = 0; i < AMPDU_INI_FREE; i++) {
+		if (ampdu->ini_free[i]) {
+			MFREE(ampdu->wlc->osh, ampdu->ini_free[i],
+			      sizeof(scb_ampdu_tid_ini_t));
+		}
+	}
+
+	wlc_module_unregister(ampdu->wlc->pub, "ampdu", ampdu);
+	MFREE(ampdu->wlc->osh, ampdu, sizeof(ampdu_info_t));
+}
+
+void scb_ampdu_cleanup(ampdu_info_t * ampdu, struct scb *scb)
+{
+	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
+	uint8 tid;
+
+	WL_AMPDU_UPDN(("scb_ampdu_cleanup: enter\n"));
+	ASSERT(scb_ampdu);
+
+	for (tid = 0; tid < AMPDU_MAX_SCB_TID; tid++) {
+		ampdu_cleanup_tid_ini(ampdu, scb_ampdu, tid, FALSE);
+	}
+}
+
+/* reset the ampdu state machine so that it can gracefully handle packets that were
+ * freed from the dma and tx queues during reinit
+ */
+void wlc_ampdu_reset(ampdu_info_t * ampdu)
+{
+	WL_NONE(("%s: Entering\n", __func__));
+}
+
+static void scb_ampdu_update_config(ampdu_info_t * ampdu, struct scb *scb)
+{
+	scb_ampdu_t *scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
+	int i;
+
+	scb_ampdu->max_pdu = (uint8) ampdu->wlc->pub->tunables->ampdunummpdu;
+
+	/* go back to legacy size if some preloading is occuring */
+	for (i = 0; i < NUM_FFPLD_FIFO; i++) {
+		if (ampdu->fifo_tb[i].ampdu_pld_size > FFPLD_PLD_INCR)
+			scb_ampdu->max_pdu = AMPDU_NUM_MPDU_LEGACY;
+	}
+
+	/* apply user override */
+	if (ampdu->max_pdu != AUTO)
+		scb_ampdu->max_pdu = (uint8) ampdu->max_pdu;
+
+	scb_ampdu->release = MIN(scb_ampdu->max_pdu, AMPDU_SCB_MAX_RELEASE);
+
+	if (scb_ampdu->max_rxlen)
+		scb_ampdu->release =
+		    MIN(scb_ampdu->release, scb_ampdu->max_rxlen / 1600);
+
+	scb_ampdu->release = MIN(scb_ampdu->release,
+				 ampdu->fifo_tb[TX_AC_BE_FIFO].
+				 mcs2ampdu_table[FFPLD_MAX_MCS]);
+
+	ASSERT(scb_ampdu->release);
+}
+
+void scb_ampdu_update_config_all(ampdu_info_t * ampdu)
+{
+	scb_ampdu_update_config(ampdu, ampdu->wlc->pub->global_scb);
+}
+
+static void wlc_ffpld_init(ampdu_info_t * ampdu)
+{
+	int i, j;
+	wlc_fifo_info_t *fifo;
+
+	for (j = 0; j < NUM_FFPLD_FIFO; j++) {
+		fifo = (ampdu->fifo_tb + j);
+		fifo->ampdu_pld_size = 0;
+		for (i = 0; i <= FFPLD_MAX_MCS; i++)
+			fifo->mcs2ampdu_table[i] = 255;
+		fifo->dmaxferrate = 0;
+		fifo->accum_txampdu = 0;
+		fifo->prev_txfunfl = 0;
+		fifo->accum_txfunfl = 0;
+
+	}
+}
+
+/* evaluate the dma transfer rate using the tx underflows as feedback.
+ * If necessary, increase tx fifo preloading. If not enough,
+ * decrease maximum ampdu size for each mcs till underflows stop
+ * Return 1 if pre-loading not active, -1 if not an underflow event,
+ * 0 if pre-loading module took care of the event.
+ */
+static int wlc_ffpld_check_txfunfl(wlc_info_t * wlc, int fid)
+{
+	ampdu_info_t *ampdu = wlc->ampdu;
+	uint32 phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
+	uint32 txunfl_ratio;
+	uint8 max_mpdu;
+	uint32 current_ampdu_cnt = 0;
+	uint16 max_pld_size;
+	uint32 new_txunfl;
+	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + fid);
+	uint xmtfifo_sz;
+	uint16 cur_txunfl;
+
+	/* return if we got here for a different reason than underflows */
+	cur_txunfl =
+	    wlc_read_shm(wlc,
+			 M_UCODE_MACSTAT + OFFSETOF(macstat_t, txfunfl[fid]));
+	new_txunfl = (uint16) (cur_txunfl - fifo->prev_txfunfl);
+	if (new_txunfl == 0) {
+		WL_FFPLD(("check_txunfl : TX status FRAG set but no tx underflows\n"));
+		return -1;
+	}
+	fifo->prev_txfunfl = cur_txunfl;
+
+	if (!ampdu->tx_max_funl)
+		return 1;
+
+	/* check if fifo is big enough */
+	if (wlc_xmtfifo_sz_get(wlc, fid, &xmtfifo_sz)) {
+		WL_FFPLD(("check_txunfl : get xmtfifo_sz failed.\n"));
+		return -1;
+	}
+
+	if ((TXFIFO_SIZE_UNIT * (uint32) xmtfifo_sz) <= ampdu->ffpld_rsvd)
+		return 1;
+
+	max_pld_size = TXFIFO_SIZE_UNIT * xmtfifo_sz - ampdu->ffpld_rsvd;
+	fifo->accum_txfunfl += new_txunfl;
+
+	/* we need to wait for at least 10 underflows */
+	if (fifo->accum_txfunfl < 10)
+		return 0;
+
+	WL_FFPLD(("ampdu_count %d  tx_underflows %d\n",
+		  current_ampdu_cnt, fifo->accum_txfunfl));
+
+	/*
+	   compute the current ratio of tx unfl per ampdu.
+	   When the current ampdu count becomes too
+	   big while the ratio remains small, we reset
+	   the current count in order to not
+	   introduce too big of a latency in detecting a
+	   large amount of tx underflows later.
+	 */
+
+	txunfl_ratio = current_ampdu_cnt / fifo->accum_txfunfl;
+
+	if (txunfl_ratio > ampdu->tx_max_funl) {
+		if (current_ampdu_cnt >= FFPLD_MAX_AMPDU_CNT) {
+			fifo->accum_txfunfl = 0;
+		}
+		return 0;
+	}
+	max_mpdu =
+	    MIN(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
+
+	/* In case max value max_pdu is already lower than
+	   the fifo depth, there is nothing more we can do.
+	 */
+
+	if (fifo->ampdu_pld_size >= max_mpdu * FFPLD_MPDU_SIZE) {
+		WL_FFPLD(("tx fifo pld : max ampdu fits in fifo\n)"));
+		fifo->accum_txfunfl = 0;
+		return 0;
+	}
+
+	if (fifo->ampdu_pld_size < max_pld_size) {
+
+		/* increment by TX_FIFO_PLD_INC bytes */
+		fifo->ampdu_pld_size += FFPLD_PLD_INCR;
+		if (fifo->ampdu_pld_size > max_pld_size)
+			fifo->ampdu_pld_size = max_pld_size;
+
+		/* update scb release size */
+		scb_ampdu_update_config_all(ampdu);
+
+		/*
+		   compute a new dma xfer rate for max_mpdu @ max mcs.
+		   This is the minimum dma rate that
+		   can acheive no unferflow condition for the current mpdu size.
+		 */
+		/* note : we divide/multiply by 100 to avoid integer overflows */
+		fifo->dmaxferrate =
+		    (((phy_rate / 100) *
+		      (max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))
+		     / (max_mpdu * FFPLD_MPDU_SIZE)) * 100;
+
+		WL_FFPLD(("DMA estimated transfer rate %d; pre-load size %d\n",
+			  fifo->dmaxferrate, fifo->ampdu_pld_size));
+	} else {
+
+		/* decrease ampdu size */
+		if (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] > 1) {
+			if (fifo->mcs2ampdu_table[FFPLD_MAX_MCS] == 255)
+				fifo->mcs2ampdu_table[FFPLD_MAX_MCS] =
+				    AMPDU_NUM_MPDU_LEGACY - 1;
+			else
+				fifo->mcs2ampdu_table[FFPLD_MAX_MCS] -= 1;
+
+			/* recompute the table */
+			wlc_ffpld_calc_mcs2ampdu_table(ampdu, fid);
+
+			/* update scb release size */
+			scb_ampdu_update_config_all(ampdu);
+		}
+	}
+	fifo->accum_txfunfl = 0;
+	return 0;
+}
+
+static void wlc_ffpld_calc_mcs2ampdu_table(ampdu_info_t * ampdu, int f)
+{
+	int i;
+	uint32 phy_rate, dma_rate, tmp;
+	uint8 max_mpdu;
+	wlc_fifo_info_t *fifo = (ampdu->fifo_tb + f);
+
+	/* recompute the dma rate */
+	/* note : we divide/multiply by 100 to avoid integer overflows */
+	max_mpdu =
+	    MIN(fifo->mcs2ampdu_table[FFPLD_MAX_MCS], AMPDU_NUM_MPDU_LEGACY);
+	phy_rate = MCS_RATE(FFPLD_MAX_MCS, TRUE, FALSE);
+	dma_rate =
+	    (((phy_rate / 100) *
+	      (max_mpdu * FFPLD_MPDU_SIZE - fifo->ampdu_pld_size))
+	     / (max_mpdu * FFPLD_MPDU_SIZE)) * 100;
+	fifo->dmaxferrate = dma_rate;
+
+	/* fill up the mcs2ampdu table; do not recalc the last mcs */
+	dma_rate = dma_rate >> 7;
+	for (i = 0; i < FFPLD_MAX_MCS; i++) {
+		/* shifting to keep it within integer range */
+		phy_rate = MCS_RATE(i, TRUE, FALSE) >> 7;
+		if (phy_rate > dma_rate) {
+			tmp = ((fifo->ampdu_pld_size * phy_rate) /
+			       ((phy_rate - dma_rate) * FFPLD_MPDU_SIZE)) + 1;
+			tmp = MIN(tmp, 255);
+			fifo->mcs2ampdu_table[i] = (uint8) tmp;
+		}
+	}
+}
+
+static void BCMFASTPATH
+wlc_ampdu_agg(ampdu_info_t * ampdu, struct scb *scb, void *p, uint prec)
+{
+	scb_ampdu_t *scb_ampdu;
+	scb_ampdu_tid_ini_t *ini;
+	uint8 tid = (uint8) PKTPRIO(p);
+
+	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
+
+	/* initialize initiator on first packet; sends addba req */
+	ini = SCB_AMPDU_INI(scb_ampdu, tid);
+	if (ini->magic != INI_MAGIC) {
+		ini = wlc_ampdu_init_tid_ini(ampdu, scb_ampdu, tid, FALSE);
+	}
+	return;
+}
+
+int BCMFASTPATH
+wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **pdu, int prec)
+{
+	wlc_info_t *wlc;
+	osl_t *osh;
+	void *p, *pkt[AMPDU_MAX_MPDU];
+	uint8 tid, ndelim;
+	int err = 0;
+	uint8 preamble_type = WLC_GF_PREAMBLE;
+	uint8 fbr_preamble_type = WLC_GF_PREAMBLE;
+	uint8 rts_preamble_type = WLC_LONG_PREAMBLE;
+	uint8 rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
+
+	bool rr = TRUE, fbr = FALSE;
+	uint i, count = 0, fifo, seg_cnt = 0;
+	uint16 plen, len, seq = 0, mcl, mch, index, frameid, dma_len = 0;
+	uint32 ampdu_len, maxlen = 0;
+	d11txh_t *txh = NULL;
+	uint8 *plcp;
+	struct dot11_header *h;
+	struct scb *scb;
+	scb_ampdu_t *scb_ampdu;
+	scb_ampdu_tid_ini_t *ini;
+	uint8 mcs = 0;
+	bool use_rts = FALSE, use_cts = FALSE;
+	ratespec_t rspec = 0, rspec_fallback = 0;
+	ratespec_t rts_rspec = 0, rts_rspec_fallback = 0;
+	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
+	struct dot11_rts_frame *rts;
+	uint8 rr_retry_limit;
+	wlc_fifo_info_t *f;
+	bool fbr_iscck;
+	struct ieee80211_tx_info *tx_info;
+	uint16 qlen;
+
+	wlc = ampdu->wlc;
+	osh = wlc->osh;
+	p = *pdu;
+
+	ASSERT(p);
+
+	tid = (uint8) PKTPRIO(p);
+	ASSERT(tid < AMPDU_MAX_SCB_TID);
+
+	f = ampdu->fifo_tb + prio2fifo[tid];
+
+	scb = wlc->pub->global_scb;
+	ASSERT(scb->magic == SCB_MAGIC);
+
+	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
+	ASSERT(scb_ampdu);
+	ini = &scb_ampdu->ini[tid];
+
+	/* Let pressure continue to build ... */
+	qlen = pktq_plen(&qi->q, prec);
+	if (ini->tx_in_transit > 0 && qlen < scb_ampdu->max_pdu) {
+		return BCME_BUSY;
+	}
+
+	wlc_ampdu_agg(ampdu, scb, p, tid);
+
+	if (wlc->block_datafifo) {
+		WL_ERROR(("%s: Fifo blocked\n", __func__));
+		return BCME_BUSY;
+	}
+	rr_retry_limit = ampdu->rr_retry_limit_tid[tid];
+	ampdu_len = 0;
+	dma_len = 0;
+	while (p) {
+		struct ieee80211_tx_rate *txrate;
+
+		tx_info = IEEE80211_SKB_CB(p);
+		txrate = tx_info->status.rates;
+
+		if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {
+			err = wlc_prep_pdu(wlc, p, &fifo);
+		} else {
+			WL_ERROR(("%s: AMPDU flag is off!\n", __func__));
+			*pdu = NULL;
+			err = 0;
+			break;
+		}
+
+		if (err) {
+			if (err == BCME_BUSY) {
+				WL_ERROR(("wl%d: wlc_sendampdu: prep_xdu retry; seq 0x%x\n", wlc->pub->unit, seq));
+				WLCNTINCR(ampdu->cnt->sduretry);
+				*pdu = p;
+				break;
+			}
+
+			/* error in the packet; reject it */
+			WL_AMPDU_ERR(("wl%d: wlc_sendampdu: prep_xdu rejected; seq 0x%x\n", wlc->pub->unit, seq));
+			WLCNTINCR(ampdu->cnt->sdurejected);
+
+			*pdu = NULL;
+			break;
+		}
+
+		/* pkt is good to be aggregated */
+		ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
+		txh = (d11txh_t *) PKTDATA(p);
+		plcp = (uint8 *) (txh + 1);
+		h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
+		seq = ltoh16(h->seq) >> SEQNUM_SHIFT;
+		index = TX_SEQ_TO_INDEX(seq);
+
+		/* check mcl fields and test whether it can be agg'd */
+		mcl = ltoh16(txh->MacTxControlLow);
+		mcl &= ~TXC_AMPDU_MASK;
+		fbr_iscck = !(ltoh16(txh->XtraFrameTypes) & 0x3);
+		ASSERT(!fbr_iscck);
+		txh->PreloadSize = 0;	/* always default to 0 */
+
+		/*  Handle retry limits */
+		if (txrate[0].count <= rr_retry_limit) {
+			txrate[0].count++;
+			rr = TRUE;
+			fbr = FALSE;
+			ASSERT(!fbr);
+		} else {
+			fbr = TRUE;
+			rr = FALSE;
+			txrate[1].count++;
+		}
+
+		/* extract the length info */
+		len = fbr_iscck ? WLC_GET_CCK_PLCP_LEN(txh->FragPLCPFallback)
+		    : WLC_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);
+
+		/* retrieve null delimiter count */
+		ndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];
+		seg_cnt += 1;
+
+		WL_AMPDU_TX(("wl%d: wlc_sendampdu: mpdu %d plcp_len %d\n",
+			     wlc->pub->unit, count, len));
+
+		/*
+		 * aggregateable mpdu. For ucode/hw agg,
+		 * test whether need to break or change the epoch
+		 */
+		if (count == 0) {
+			uint16 fc;
+			mcl |= (TXC_AMPDU_FIRST << TXC_AMPDU_SHIFT);
+			/* refill the bits since might be a retx mpdu */
+			mcl |= TXC_STARTMSDU;
+			rts = (struct dot11_rts_frame *)&txh->rts_frame;
+			fc = ltoh16(rts->fc);
+			if ((fc & FC_KIND_MASK) == FC_RTS) {
+				mcl |= TXC_SENDRTS;
+				use_rts = TRUE;
+			}
+			if ((fc & FC_KIND_MASK) == FC_CTS) {
+				mcl |= TXC_SENDCTS;
+				use_cts = TRUE;
+			}
+		} else {
+			mcl |= (TXC_AMPDU_MIDDLE << TXC_AMPDU_SHIFT);
+			mcl &= ~(TXC_STARTMSDU | TXC_SENDRTS | TXC_SENDCTS);
+		}
+
+		len = ROUNDUP(len, 4);
+		ampdu_len += (len + (ndelim + 1) * AMPDU_DELIMITER_LEN);
+
+		dma_len += (uint16) pkttotlen(osh, p);
+
+		WL_AMPDU_TX(("wl%d: wlc_sendampdu: ampdu_len %d seg_cnt %d null delim %d\n", wlc->pub->unit, ampdu_len, seg_cnt, ndelim));
+
+		txh->MacTxControlLow = htol16(mcl);
+
+		/* this packet is added */
+		pkt[count++] = p;
+
+		/* patch the first MPDU */
+		if (count == 1) {
+			uint8 plcp0, plcp3, is40, sgi;
+			struct ieee80211_sta *sta;
+
+			sta = tx_info->control.sta;
+
+			if (rr) {
+				plcp0 = plcp[0];
+				plcp3 = plcp[3];
+			} else {
+				plcp0 = txh->FragPLCPFallback[0];
+				plcp3 = txh->FragPLCPFallback[3];
+
+			}
+			is40 = (plcp0 & MIMO_PLCP_40MHZ) ? 1 : 0;
+			sgi = PLCP3_ISSGI(plcp3) ? 1 : 0;
+			mcs = plcp0 & ~MIMO_PLCP_40MHZ;
+			ASSERT(mcs < MCS_TABLE_SIZE);
+			maxlen =
+			    MIN(scb_ampdu->max_rxlen,
+				ampdu->max_txlen[mcs][is40][sgi]);
+
+			WL_NONE(("sendampdu: sgi %d, is40 %d, mcs %d\n", sgi,
+				 is40, mcs));
+
+			maxlen = 64 * 1024;	/* XXX Fix me to honor real max_rxlen */
+
+			if (is40)
+				mimo_ctlchbw =
+				    CHSPEC_SB_UPPER(WLC_BAND_PI_RADIO_CHANSPEC)
+				    ? PHY_TXC1_BW_20MHZ_UP : PHY_TXC1_BW_20MHZ;
+
+			/* rebuild the rspec and rspec_fallback */
+			rspec = RSPEC_MIMORATE;
+			rspec |= plcp[0] & ~MIMO_PLCP_40MHZ;
+			if (plcp[0] & MIMO_PLCP_40MHZ)
+				rspec |= (PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT);
+
+			if (fbr_iscck)	/* CCK */
+				rspec_fallback =
+				    CCK_RSPEC(CCK_PHY2MAC_RATE
+					      (txh->FragPLCPFallback[0]));
+			else {	/* MIMO */
+				rspec_fallback = RSPEC_MIMORATE;
+				rspec_fallback |=
+				    txh->FragPLCPFallback[0] & ~MIMO_PLCP_40MHZ;
+				if (txh->FragPLCPFallback[0] & MIMO_PLCP_40MHZ)
+					rspec_fallback |=
+					    (PHY_TXC1_BW_40MHZ <<
+					     RSPEC_BW_SHIFT);
+			}
+
+			if (use_rts || use_cts) {
+				rts_rspec =
+				    wlc_rspec_to_rts_rspec(wlc, rspec, FALSE,
+							   mimo_ctlchbw);
+				rts_rspec_fallback =
+				    wlc_rspec_to_rts_rspec(wlc, rspec_fallback,
+							   FALSE, mimo_ctlchbw);
+			}
+		}
+
+		/* if (first mpdu for host agg) */
+		/* test whether to add more */
+		if ((MCS_RATE(mcs, TRUE, FALSE) >= f->dmaxferrate) &&
+		    (count == f->mcs2ampdu_table[mcs])) {
+			WL_AMPDU_ERR(("wl%d: PR 37644: stopping ampdu at %d for mcs %d", wlc->pub->unit, count, mcs));
+			break;
+		}
+
+		if (count == scb_ampdu->max_pdu) {
+			WL_NONE(("Stop taking from q, reached %d deep\n",
+				 scb_ampdu->max_pdu));
+			break;
+		}
+
+		/* check to see if the next pkt is a candidate for aggregation */
+		p = pktq_ppeek(&qi->q, prec);
+		tx_info = IEEE80211_SKB_CB(p);	/* tx_info must be checked with current p */
+
+		if (p) {
+			if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) &&
+			    ((uint8) PKTPRIO(p) == tid)) {
+
+				plen =
+				    pkttotlen(osh, p) + AMPDU_MAX_MPDU_OVERHEAD;
+				plen = MAX(scb_ampdu->min_len, plen);
+
+				if ((plen + ampdu_len) > maxlen) {
+					p = NULL;
+					WL_ERROR(("%s: Bogus plen #1\n",
+						  __func__));
+					ASSERT(3 == 4);
+					continue;
+				}
+
+				/* check if there are enough descriptors available */
+				if (TXAVAIL(wlc, fifo) <= (seg_cnt + 1)) {
+					WL_ERROR(("%s: No fifo space   !!!!!!\n", __func__));
+					p = NULL;
+					continue;
+				}
+				p = pktq_pdeq(&qi->q, prec);
+				ASSERT(p);
+			} else {
+				p = NULL;
+			}
+		}
+	}			/* end while(p) */
+
+	ini->tx_in_transit += count;
+
+	if (count) {
+		WLCNTADD(ampdu->cnt->txmpdu, count);
+
+		/* patch up the last txh */
+		txh = (d11txh_t *) PKTDATA(pkt[count - 1]);
+		mcl = ltoh16(txh->MacTxControlLow);
+		mcl &= ~TXC_AMPDU_MASK;
+		mcl |= (TXC_AMPDU_LAST << TXC_AMPDU_SHIFT);
+		txh->MacTxControlLow = htol16(mcl);
+
+		/* remove the null delimiter after last mpdu */
+		ndelim = txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM];
+		txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM] = 0;
+		ampdu_len -= ndelim * AMPDU_DELIMITER_LEN;
+
+		/* remove the pad len from last mpdu */
+		fbr_iscck = ((ltoh16(txh->XtraFrameTypes) & 0x3) == 0);
+		len = fbr_iscck ? WLC_GET_CCK_PLCP_LEN(txh->FragPLCPFallback)
+		    : WLC_GET_MIMO_PLCP_LEN(txh->FragPLCPFallback);
+		ampdu_len -= ROUNDUP(len, 4) - len;
+
+		/* patch up the first txh & plcp */
+		txh = (d11txh_t *) PKTDATA(pkt[0]);
+		plcp = (uint8 *) (txh + 1);
+
+		WLC_SET_MIMO_PLCP_LEN(plcp, ampdu_len);
+		/* mark plcp to indicate ampdu */
+		WLC_SET_MIMO_PLCP_AMPDU(plcp);
+
+		/* reset the mixed mode header durations */
+		if (txh->MModeLen) {
+			uint16 mmodelen =
+			    wlc_calc_lsig_len(wlc, rspec, ampdu_len);
+			txh->MModeLen = htol16(mmodelen);
+			preamble_type = WLC_MM_PREAMBLE;
+		}
+		if (txh->MModeFbrLen) {
+			uint16 mmfbrlen =
+			    wlc_calc_lsig_len(wlc, rspec_fallback, ampdu_len);
+			txh->MModeFbrLen = htol16(mmfbrlen);
+			fbr_preamble_type = WLC_MM_PREAMBLE;
+		}
+
+		/* set the preload length */
+		if (MCS_RATE(mcs, TRUE, FALSE) >= f->dmaxferrate) {
+			dma_len = MIN(dma_len, f->ampdu_pld_size);
+			txh->PreloadSize = htol16(dma_len);
+		} else
+			txh->PreloadSize = 0;
+
+		mch = ltoh16(txh->MacTxControlHigh);
+
+		/* update RTS dur fields */
+		if (use_rts || use_cts) {
+			uint16 durid;
+			rts = (struct dot11_rts_frame *)&txh->rts_frame;
+			if ((mch & TXC_PREAMBLE_RTS_MAIN_SHORT) ==
+			    TXC_PREAMBLE_RTS_MAIN_SHORT)
+				rts_preamble_type = WLC_SHORT_PREAMBLE;
+
+			if ((mch & TXC_PREAMBLE_RTS_FB_SHORT) ==
+			    TXC_PREAMBLE_RTS_FB_SHORT)
+				rts_fbr_preamble_type = WLC_SHORT_PREAMBLE;
+
+			durid =
+			    wlc_compute_rtscts_dur(wlc, use_cts, rts_rspec,
+						   rspec, rts_preamble_type,
+						   preamble_type, ampdu_len,
+						   TRUE);
+			rts->durid = htol16(durid);
+			durid = wlc_compute_rtscts_dur(wlc, use_cts,
+						       rts_rspec_fallback,
+						       rspec_fallback,
+						       rts_fbr_preamble_type,
+						       fbr_preamble_type,
+						       ampdu_len, TRUE);
+			txh->RTSDurFallback = htol16(durid);
+			/* set TxFesTimeNormal */
+			txh->TxFesTimeNormal = rts->durid;
+			/* set fallback rate version of TxFesTimeNormal */
+			txh->TxFesTimeFallback = txh->RTSDurFallback;
+		}
+
+		/* set flag and plcp for fallback rate */
+		if (fbr) {
+			WLCNTADD(ampdu->cnt->txfbr_mpdu, count);
+			WLCNTINCR(ampdu->cnt->txfbr_ampdu);
+			mch |= TXC_AMPDU_FBR;
+			txh->MacTxControlHigh = htol16(mch);
+			WLC_SET_MIMO_PLCP_AMPDU(plcp);
+			WLC_SET_MIMO_PLCP_AMPDU(txh->FragPLCPFallback);
+		}
+
+		WL_AMPDU_TX(("wl%d: wlc_sendampdu: count %d ampdu_len %d\n",
+			     wlc->pub->unit, count, ampdu_len));
+
+		/* inform rate_sel if it this is a rate probe pkt */
+		frameid = ltoh16(txh->TxFrameID);
+		if (frameid & TXFID_RATE_PROBE_MASK) {
+			WL_ERROR(("%s: XXX what to do with TXFID_RATE_PROBE_MASK!?\n", __func__));
+		}
+#ifdef WLC_HIGH_ONLY
+		if (wlc->rpc_agg & BCM_RPC_TP_HOST_AGG_AMPDU)
+			bcm_rpc_tp_agg_set(bcm_rpc_tp_get(wlc->rpc),
+					   BCM_RPC_TP_HOST_AGG_AMPDU, TRUE);
+#endif
+		for (i = 0; i < count; i++)
+			wlc_txfifo(wlc, fifo, pkt[i], i == (count - 1),
+				   ampdu->txpkt_weight);
+#ifdef WLC_HIGH_ONLY
+		if (wlc->rpc_agg & BCM_RPC_TP_HOST_AGG_AMPDU)
+			bcm_rpc_tp_agg_set(bcm_rpc_tp_get(wlc->rpc),
+					   BCM_RPC_TP_HOST_AGG_AMPDU, FALSE);
+#endif
+
+	}
+	/* endif (count) */
+	return err;
+}
+
+void BCMFASTPATH
+wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
+		     tx_status_t * txs)
+{
+	scb_ampdu_t *scb_ampdu;
+	wlc_info_t *wlc = ampdu->wlc;
+	scb_ampdu_tid_ini_t *ini;
+	uint32 s1 = 0, s2 = 0;
+	struct ieee80211_tx_info *tx_info;
+
+	tx_info = IEEE80211_SKB_CB(p);
+	ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
+	ASSERT(scb);
+	ASSERT(scb->magic == SCB_MAGIC);
+	ASSERT(txs->status & TX_STATUS_AMPDU);
+	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
+	ASSERT(scb_ampdu);
+	ini = SCB_AMPDU_INI(scb_ampdu, PKTPRIO(p));
+	ASSERT(ini->scb == scb);
+
+	/* BMAC_NOTE: For the split driver, second level txstatus comes later
+	 * So if the ACK was received then wait for the second level else just
+	 * call the first one
+	 */
+	if (txs->status & TX_STATUS_ACK_RCV) {
+#ifdef WLC_LOW
+		uint8 status_delay = 0;
+
+		/* wait till the next 8 bytes of txstatus is available */
+		while (((s1 =
+			 R_REG(wlc->osh,
+			       &wlc->regs->frmtxstatus)) & TXS_V) == 0) {
+			OSL_DELAY(1);
+			status_delay++;
+			if (status_delay > 10) {
+				ASSERT(status_delay <= 10);
+				return;
+			}
+		}
+
+		ASSERT(!(s1 & TX_STATUS_INTERMEDIATE));
+		ASSERT(s1 & TX_STATUS_AMPDU);
+		s2 = R_REG(wlc->osh, &wlc->regs->frmtxstatus2);
+#else				/* WLC_LOW */
+
+		/* Store the relevant information in ampdu structure */
+		WL_AMPDU_TX(("wl%d: wlc_ampdu_dotxstatus: High Recvd\n",
+			     wlc->pub->unit));
+
+		ASSERT(!ampdu->p);
+		ampdu->p = p;
+		bcopy(txs, &ampdu->txs, sizeof(tx_status_t));
+		ampdu->waiting_status = TRUE;
+		return;
+#endif				/* WLC_LOW */
+	}
+
+	wlc_ampdu_dotxstatus_complete(ampdu, scb, p, txs, s1, s2);
+	wlc_ampdu_txflowcontrol(wlc, scb_ampdu, ini);
+}
+
+#ifdef WLC_HIGH_ONLY
+void wlc_ampdu_txstatus_complete(ampdu_info_t * ampdu, uint32 s1, uint32 s2)
+{
+	WL_AMPDU_TX(("wl%d: wlc_ampdu_txstatus_complete: High Recvd 0x%x 0x%x p:%p\n", ampdu->wlc->pub->unit, s1, s2, ampdu->p));
+
+	ASSERT(ampdu->waiting_status);
+
+	/* The packet may have been freed if the SCB went away, if so, then still free the
+	 * DMA chain
+	 */
+	if (ampdu->p) {
+		struct ieee80211_tx_info *tx_info;
+		struct scb *scb;
+
+		tx_info = IEEE80211_SKB_CB(ampdu->p);
+		scb = (struct scb *)tx_info->control.sta->drv_priv;
+
+		wlc_ampdu_dotxstatus_complete(ampdu, scb, ampdu->p, &ampdu->txs,
+					      s1, s2);
+		ampdu->p = NULL;
+	}
+
+	ampdu->waiting_status = FALSE;
+}
+#endif				/* WLC_HIGH_ONLY */
+void rate_status(wlc_info_t * wlc, struct ieee80211_tx_info *tx_info,
+		 tx_status_t * txs, uint8 mcs);
+
+void
+rate_status(wlc_info_t * wlc, struct ieee80211_tx_info *tx_info,
+	    tx_status_t * txs, uint8 mcs)
+{
+	struct ieee80211_tx_rate *txrate = tx_info->status.rates;
+	int i;
+
+	/* clear the rest of the rates */
+	for (i = 2; i < IEEE80211_TX_MAX_RATES; i++) {
+		txrate[i].idx = -1;
+		txrate[i].count = 0;
+	}
+}
+
+extern void wlc_txq_enq(wlc_info_t * wlc, struct scb *scb, void *sdu,
+			uint prec);
+
+#define SHORTNAME "AMPDU status"
+
+static void BCMFASTPATH
+wlc_ampdu_dotxstatus_complete(ampdu_info_t * ampdu, struct scb *scb, void *p,
+			      tx_status_t * txs, uint32 s1, uint32 s2)
+{
+	scb_ampdu_t *scb_ampdu;
+	wlc_info_t *wlc = ampdu->wlc;
+	scb_ampdu_tid_ini_t *ini;
+	uint8 bitmap[8], queue, tid;
+	d11txh_t *txh;
+	uint8 *plcp;
+	struct dot11_header *h;
+	uint16 seq, start_seq = 0, bindex, index, mcl;
+	uint8 mcs = 0;
+	bool ba_recd = FALSE, ack_recd = FALSE;
+	uint8 suc_mpdu = 0, tot_mpdu = 0;
+	uint supr_status;
+	bool update_rate = TRUE, retry = TRUE, tx_error = FALSE;
+	uint16 mimoantsel = 0;
+	uint8 antselid = 0;
+	uint8 retry_limit, rr_retry_limit;
+	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(p);
+
+#ifdef BCMDBG
+	uint8 hole[AMPDU_MAX_MPDU];
+	bzero(hole, sizeof(hole));
+#endif
+
+	ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
+	ASSERT(txs->status & TX_STATUS_AMPDU);
+
+	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
+	ASSERT(scb_ampdu);
+
+	tid = (uint8) PKTPRIO(p);
+
+	ini = SCB_AMPDU_INI(scb_ampdu, tid);
+	retry_limit = ampdu->retry_limit_tid[tid];
+	rr_retry_limit = ampdu->rr_retry_limit_tid[tid];
+
+	ASSERT(ini->scb == scb);
+
+	bzero(bitmap, sizeof(bitmap));
+	queue = txs->frameid & TXFID_QUEUE_MASK;
+	ASSERT(queue < AC_COUNT);
+
+	supr_status = txs->status & TX_STATUS_SUPR_MASK;
+
+	if (txs->status & TX_STATUS_ACK_RCV) {
+		if (TX_STATUS_SUPR_UF == supr_status) {
+			update_rate = FALSE;
+		}
+
+		ASSERT(txs->status & TX_STATUS_INTERMEDIATE);
+		start_seq = txs->sequence >> SEQNUM_SHIFT;
+		bitmap[0] = (txs->status & TX_STATUS_BA_BMAP03_MASK) >>
+		    TX_STATUS_BA_BMAP03_SHIFT;
+
+		ASSERT(!(s1 & TX_STATUS_INTERMEDIATE));
+		ASSERT(s1 & TX_STATUS_AMPDU);
+
+		bitmap[0] |=
+		    (s1 & TX_STATUS_BA_BMAP47_MASK) <<
+		    TX_STATUS_BA_BMAP47_SHIFT;
+		bitmap[1] = (s1 >> 8) & 0xff;
+		bitmap[2] = (s1 >> 16) & 0xff;
+		bitmap[3] = (s1 >> 24) & 0xff;
+
+		bitmap[4] = s2 & 0xff;
+		bitmap[5] = (s2 >> 8) & 0xff;
+		bitmap[6] = (s2 >> 16) & 0xff;
+		bitmap[7] = (s2 >> 24) & 0xff;
+
+		ba_recd = TRUE;
+	} else {
+		WLCNTINCR(ampdu->cnt->noba);
+		if (supr_status) {
+			update_rate = FALSE;
+			if (supr_status == TX_STATUS_SUPR_BADCH) {
+				WL_ERROR(("%s: Pkt tx suppressed, illegal channel possibly %d\n", __func__, CHSPEC_CHANNEL(wlc->default_bss->chanspec)));
+			} else {
+				if (supr_status == TX_STATUS_SUPR_FRAG)
+					WL_NONE(("%s: AMPDU frag err\n",
+						 __func__));
+				else
+					WL_ERROR(("%s: wlc_ampdu_dotxstatus: supr_status 0x%x\n", __func__, supr_status));
+			}
+			/* no need to retry for badch; will fail again */
+			if (supr_status == TX_STATUS_SUPR_BADCH ||
+			    supr_status == TX_STATUS_SUPR_EXPTIME) {
+				retry = FALSE;
+				WLCNTINCR(wlc->pub->_cnt->txchanrej);
+			} else if (supr_status == TX_STATUS_SUPR_EXPTIME) {
+
+				WLCNTINCR(wlc->pub->_cnt->txexptime);
+
+				/* TX underflow : try tuning pre-loading or ampdu size */
+			} else if (supr_status == TX_STATUS_SUPR_FRAG) {
+				/* if there were underflows, but pre-loading is not active,
+				   notify rate adaptation.
+				 */
+				if (wlc_ffpld_check_txfunfl(wlc, prio2fifo[tid])
+				    > 0) {
+					tx_error = TRUE;
+#ifdef WLC_HIGH_ONLY
+					/* With BMAC, TX Underflows should not happen */
+					WL_ERROR(("wl%d: BMAC TX Underflow?",
+						  wlc->pub->unit));
+#endif
+				}
+			}
+		} else if (txs->phyerr) {
+			update_rate = FALSE;
+			WLCNTINCR(wlc->pub->_cnt->txphyerr);
+			WL_ERROR(("wl%d: wlc_ampdu_dotxstatus: tx phy error (0x%x)\n", wlc->pub->unit, txs->phyerr));
+
+#ifdef BCMDBG
+			if (WL_ERROR_ON()) {
+				prpkt("txpkt (AMPDU)", wlc->osh, p);
+				wlc_print_txdesc((d11txh_t *) PKTDATA(p));
+				wlc_print_txstatus(txs);
+			}
+#endif				/* BCMDBG */
+		}
+	}
+
+	/* loop through all pkts and retry if not acked */
+	while (p) {
+		tx_info = IEEE80211_SKB_CB(p);
+		ASSERT(tx_info->flags & IEEE80211_TX_CTL_AMPDU);
+		txh = (d11txh_t *) PKTDATA(p);
+		mcl = ltoh16(txh->MacTxControlLow);
+		plcp = (uint8 *) (txh + 1);
+		h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
+		seq = ltoh16(h->seq) >> SEQNUM_SHIFT;
+
+		if (tot_mpdu == 0) {
+			mcs = plcp[0] & MIMO_PLCP_MCS_MASK;
+			mimoantsel = ltoh16(txh->ABI_MimoAntSel);
+		}
+
+		index = TX_SEQ_TO_INDEX(seq);
+		ack_recd = FALSE;
+		if (ba_recd) {
+			bindex = MODSUB_POW2(seq, start_seq, SEQNUM_MAX);
+
+			WL_AMPDU_TX(("%s: tid %d seq is %d, start_seq is %d, "
+				     "bindex is %d set %d, index %d\n",
+				     __func__, tid, seq, start_seq, bindex,
+				     isset(bitmap, bindex), index));
+
+			/* if acked then clear bit and free packet */
+			if ((bindex < AMPDU_TX_BA_MAX_WSIZE)
+			    && isset(bitmap, bindex)) {
+				ini->tx_in_transit--;
+				ini->txretry[index] = 0;
+
+				/* ampdu_ack_len: number of acked aggregated frames */
+				/* ampdu_ack_map: block ack bit map for the aggregation */
+				/* ampdu_len: number of aggregated frames */
+				rate_status(wlc, tx_info, txs, mcs);
+				tx_info->flags |= IEEE80211_TX_STAT_ACK;
+				tx_info->flags |= IEEE80211_TX_STAT_AMPDU;
+
+				/* XXX TODO: Make these accurate. */
+				tx_info->status.ampdu_ack_len =
+				    (txs->
+				     status & TX_STATUS_FRM_RTX_MASK) >>
+				    TX_STATUS_FRM_RTX_SHIFT;
+				tx_info->status.ampdu_len =
+				    (txs->
+				     status & TX_STATUS_FRM_RTX_MASK) >>
+				    TX_STATUS_FRM_RTX_SHIFT;
+
+				PKTPULL(p, D11_PHY_HDR_LEN);
+				PKTPULL(p, D11_TXH_LEN);
+
+				ieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,
+							    p);
+				ack_recd = TRUE;
+				suc_mpdu++;
+			}
+		}
+		/* either retransmit or send bar if ack not recd */
+		if (!ack_recd) {
+			struct ieee80211_tx_rate *txrate =
+			    tx_info->status.rates;
+			if (retry && (txrate[0].count < (int)retry_limit)) {
+				ini->txretry[index]++;
+				ini->tx_in_transit--;
+				/* Use high prededence for retransmit to give some punch */
+				/* wlc_txq_enq(wlc, scb, p, WLC_PRIO_TO_PREC(tid)); */
+				wlc_txq_enq(wlc, scb, p,
+					    WLC_PRIO_TO_HI_PREC(tid));
+			} else {
+				/* Retry timeout */
+				ini->tx_in_transit--;
+				ieee80211_tx_info_clear_status(tx_info);
+				tx_info->flags |=
+				    IEEE80211_TX_STAT_AMPDU_NO_BACK;
+				PKTPULL(p, D11_PHY_HDR_LEN);
+				PKTPULL(p, D11_TXH_LEN);
+				WL_ERROR(("%s: BA Timeout, seq %d, in_transit %d\n", SHORTNAME, seq, ini->tx_in_transit));
+				ieee80211_tx_status_irqsafe(wlc->pub->ieee_hw,
+							    p);
+			}
+		}
+		tot_mpdu++;
+
+		/* break out if last packet of ampdu */
+		if (((mcl & TXC_AMPDU_MASK) >> TXC_AMPDU_SHIFT) ==
+		    TXC_AMPDU_LAST)
+			break;
+
+		p = GETNEXTTXP(wlc, queue);
+		if (p == NULL) {
+			ASSERT(p);
+			break;
+		}
+	}
+	wlc_send_q(wlc, wlc->active_queue);
+
+	/* update rate state */
+	if (WLANTSEL_ENAB(wlc))
+		antselid = wlc_antsel_antsel2id(wlc->asi, mimoantsel);
+
+	wlc_txfifo_complete(wlc, queue, ampdu->txpkt_weight);
+}
+
+static void
+ampdu_cleanup_tid_ini(ampdu_info_t * ampdu, scb_ampdu_t * scb_ampdu, uint8 tid,
+		      bool force)
+{
+	scb_ampdu_tid_ini_t *ini;
+	if (!(ini = SCB_AMPDU_INI(scb_ampdu, tid)))
+		return;
+
+	WL_AMPDU_CTL(("wl%d: ampdu_cleanup_tid_ini: tid %d\n",
+		      ampdu->wlc->pub->unit, tid));
+
+	if (ini->tx_in_transit && !force)
+		return;
+
+	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, ini->scb);
+	ASSERT(ini == &scb_ampdu->ini[ini->tid]);
+
+	/* free all buffered tx packets */
+	pktq_pflush(ampdu->wlc->osh, &scb_ampdu->txq, ini->tid, TRUE, NULL, 0);
+}
+
+/* initialize the initiator code for tid */
+static scb_ampdu_tid_ini_t *wlc_ampdu_init_tid_ini(ampdu_info_t * ampdu,
+						   scb_ampdu_t * scb_ampdu,
+						   uint8 tid, bool override)
+{
+	scb_ampdu_tid_ini_t *ini;
+
+	ASSERT(scb_ampdu);
+	ASSERT(scb_ampdu->scb);
+	ASSERT(SCB_AMPDU(scb_ampdu->scb));
+	ASSERT(tid < AMPDU_MAX_SCB_TID);
+
+	/* check for per-tid control of ampdu */
+	if (!ampdu->ini_enable[tid]) {
+		WL_ERROR(("%s: Rejecting tid %d\n", __func__, tid));
+		return NULL;
+	}
+
+	ini = SCB_AMPDU_INI(scb_ampdu, tid);
+	ini->tid = tid;
+	ini->scb = scb_ampdu->scb;
+	ini->magic = INI_MAGIC;
+	WLCNTINCR(ampdu->cnt->txaddbareq);
+
+	return ini;
+}
+
+int wlc_ampdu_set(ampdu_info_t * ampdu, bool on)
+{
+	wlc_info_t *wlc = ampdu->wlc;
+
+	wlc->pub->_ampdu = FALSE;
+
+	if (on) {
+		if (!N_ENAB(wlc->pub)) {
+			WL_AMPDU_ERR(("wl%d: driver not nmode enabled\n",
+				      wlc->pub->unit));
+			return BCME_UNSUPPORTED;
+		}
+		if (!wlc_ampdu_cap(ampdu)) {
+			WL_AMPDU_ERR(("wl%d: device not ampdu capable\n",
+				      wlc->pub->unit));
+			return BCME_UNSUPPORTED;
+		}
+		wlc->pub->_ampdu = on;
+	}
+
+	return 0;
+}
+
+bool wlc_ampdu_cap(ampdu_info_t * ampdu)
+{
+	if (WLC_PHY_11N_CAP(ampdu->wlc->band))
+		return TRUE;
+	else
+		return FALSE;
+}
+
+static void ampdu_update_max_txlen(ampdu_info_t * ampdu, uint8 dur)
+{
+	uint32 rate, mcs;
+
+	for (mcs = 0; mcs < MCS_TABLE_SIZE; mcs++) {
+		/* rate is in Kbps; dur is in msec ==> len = (rate * dur) / 8 */
+		/* 20MHz, No SGI */
+		rate = MCS_RATE(mcs, FALSE, FALSE);
+		ampdu->max_txlen[mcs][0][0] = (rate * dur) >> 3;
+		/* 40 MHz, No SGI */
+		rate = MCS_RATE(mcs, TRUE, FALSE);
+		ampdu->max_txlen[mcs][1][0] = (rate * dur) >> 3;
+		/* 20MHz, SGI */
+		rate = MCS_RATE(mcs, FALSE, TRUE);
+		ampdu->max_txlen[mcs][0][1] = (rate * dur) >> 3;
+		/* 40 MHz, SGI */
+		rate = MCS_RATE(mcs, TRUE, TRUE);
+		ampdu->max_txlen[mcs][1][1] = (rate * dur) >> 3;
+	}
+}
+
+uint8 BCMFASTPATH
+wlc_ampdu_null_delim_cnt(ampdu_info_t * ampdu, struct scb *scb,
+			 ratespec_t rspec, int phylen)
+{
+	scb_ampdu_t *scb_ampdu;
+	int bytes, cnt, tmp;
+	uint8 tx_density;
+
+	ASSERT(scb);
+	ASSERT(SCB_AMPDU(scb));
+
+	scb_ampdu = SCB_AMPDU_CUBBY(ampdu, scb);
+	ASSERT(scb_ampdu);
+
+	if (scb_ampdu->mpdu_density == 0)
+		return 0;
+
+	/* RSPEC2RATE is in kbps units ==> ~RSPEC2RATE/2^13 is in bytes/usec
+	   density x is in 2^(x-4) usec
+	   ==> # of bytes needed for req density = rate/2^(17-x)
+	   ==> # of null delimiters = ceil(ceil(rate/2^(17-x)) - phylen)/4)
+	 */
+
+	tx_density = scb_ampdu->mpdu_density;
+
+	ASSERT(tx_density <= AMPDU_MAX_MPDU_DENSITY);
+	tmp = 1 << (17 - tx_density);
+	bytes = CEIL(RSPEC2RATE(rspec), tmp);
+
+	if (bytes > phylen) {
+		cnt = CEIL(bytes - phylen, AMPDU_DELIMITER_LEN);
+		ASSERT(cnt <= 255);
+		return (uint8) cnt;
+	} else
+		return 0;
+}
+
+void wlc_ampdu_macaddr_upd(wlc_info_t * wlc)
+{
+	char template[T_RAM_ACCESS_SZ * 2];
+
+	/* driver needs to write the ta in the template; ta is at offset 16 */
+	bzero(template, sizeof(template));
+	bcopy((char *)wlc->pub->cur_etheraddr.octet, template, ETHER_ADDR_LEN);
+	wlc_write_template_ram(wlc, (T_BA_TPL_BASE + 16), (T_RAM_ACCESS_SZ * 2),
+			       template);
+}
+
+bool wlc_aggregatable(wlc_info_t * wlc, uint8 tid)
+{
+	return (wlc->ampdu->ini_enable[tid]);
+}
+
+void wlc_ampdu_shm_upd(ampdu_info_t * ampdu)
+{
+	wlc_info_t *wlc = ampdu->wlc;
+
+	/* Extend ucode internal watchdog timer to match larger received frames */
+	if ((ampdu->rx_factor & HT_PARAMS_RX_FACTOR_MASK) ==
+	    AMPDU_RX_FACTOR_64K) {
+		wlc_write_shm(wlc, M_MIMO_MAXSYM, MIMO_MAXSYM_MAX);
+		wlc_write_shm(wlc, M_WATCHDOG_8TU, WATCHDOG_8TU_MAX);
+	} else {
+		wlc_write_shm(wlc, M_MIMO_MAXSYM, MIMO_MAXSYM_DEF);
+		wlc_write_shm(wlc, M_WATCHDOG_8TU, WATCHDOG_8TU_DEF);
+	}
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_ampdu.h b/drivers/staging/brcm80211/sys/wlc_ampdu.h
new file mode 100644
index 0000000..775faf6
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_ampdu.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_ampdu_h_
+#define _wlc_ampdu_h_
+
+extern ampdu_info_t *wlc_ampdu_attach(wlc_info_t * wlc);
+extern void wlc_ampdu_detach(ampdu_info_t * ampdu);
+extern bool wlc_ampdu_cap(ampdu_info_t * ampdu);
+extern int wlc_ampdu_set(ampdu_info_t * ampdu, bool on);
+extern int wlc_sendampdu(ampdu_info_t * ampdu, wlc_txq_info_t * qi, void **aggp,
+			 int prec);
+extern void wlc_ampdu_dotxstatus(ampdu_info_t * ampdu, struct scb *scb, void *p,
+				 tx_status_t * txs);
+extern void wlc_ampdu_reset(ampdu_info_t * ampdu);
+extern void wlc_ampdu_macaddr_upd(wlc_info_t * wlc);
+extern void wlc_ampdu_shm_upd(ampdu_info_t * ampdu);
+
+extern uint8 wlc_ampdu_null_delim_cnt(ampdu_info_t * ampdu, struct scb *scb,
+				      ratespec_t rspec, int phylen);
+extern void scb_ampdu_cleanup(ampdu_info_t * ampdu, struct scb *scb);
+#ifdef WLC_HIGH_ONLY
+extern void wlc_ampdu_txstatus_complete(ampdu_info_t * ampdu, uint32 s1,
+					uint32 s2);
+#endif
+
+#endif				/* _wlc_ampdu_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_antsel.c b/drivers/staging/brcm80211/sys/wlc_antsel.c
new file mode 100644
index 0000000..a7ad9bb
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.c
@@ -0,0 +1,327 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+
+#ifdef WLANTSEL
+
+#include <typedefs.h>
+#include <qmath.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <wlioctl.h>
+#include <wlc_phy_radio.h>
+#include <bitfuncs.h>
+
+#include <proto/802.11.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_key.h>
+#include <wlc_pub.h>
+#include <wlc_bsscfg.h>
+#include <wl_dbg.h>
+#include <wlc_mac80211.h>
+#include <wlc_bmac.h>
+#include <wlc_phy_hal.h>
+#include <wl_export.h>
+#include <wlc_antsel.h>
+#include <wlc_phy_shim.h>
+
+/* useful macros */
+#define WLC_ANTSEL_11N_0(ant)	((((ant) & ANT_SELCFG_MASK) >> 4) & 0xf)
+#define WLC_ANTSEL_11N_1(ant)	(((ant) & ANT_SELCFG_MASK) & 0xf)
+#define WLC_ANTIDX_11N(ant)	(((WLC_ANTSEL_11N_0(ant)) << 2) + (WLC_ANTSEL_11N_1(ant)))
+#define WLC_ANT_ISAUTO_11N(ant)	(((ant) & ANT_SELCFG_AUTO) == ANT_SELCFG_AUTO)
+#define WLC_ANTSEL_11N(ant)	((ant) & ANT_SELCFG_MASK)
+
+/* antenna switch */
+/* defines for no boardlevel antenna diversity */
+#define ANT_SELCFG_DEF_2x2	0x01	/* default antenna configuration */
+
+/* 2x3 antdiv defines and tables for GPIO communication */
+#define ANT_SELCFG_NUM_2x3	3
+#define ANT_SELCFG_DEF_2x3	0x01	/* default antenna configuration */
+
+/* 2x4 antdiv rev4 defines and tables for GPIO communication */
+#define ANT_SELCFG_NUM_2x4	4
+#define ANT_SELCFG_DEF_2x4	0x02	/* default antenna configuration */
+
+/* static functions */
+static int wlc_antsel_cfgupd(antsel_info_t * asi, wlc_antselcfg_t * antsel);
+static uint8 wlc_antsel_id2antcfg(antsel_info_t * asi, uint8 id);
+static uint16 wlc_antsel_antcfg2antsel(antsel_info_t * asi, uint8 ant_cfg);
+static void wlc_antsel_init_cfg(antsel_info_t * asi, wlc_antselcfg_t * antsel,
+				bool auto_sel);
+
+const uint16 mimo_2x4_div_antselpat_tbl[] = {
+	0, 0, 0x9, 0xa,		/* ant0: 0 ant1: 2,3 */
+	0, 0, 0x5, 0x6,		/* ant0: 1 ant1: 2,3 */
+	0, 0, 0, 0,		/* n.a.              */
+	0, 0, 0, 0		/* n.a.              */
+};
+
+const uint8 mimo_2x4_div_antselid_tbl[16] = {
+	0, 0, 0, 0, 0, 2, 3, 0,
+	0, 0, 1, 0, 0, 0, 0, 0	/* pat to antselid */
+};
+
+const uint16 mimo_2x3_div_antselpat_tbl[] = {
+	16, 0, 1, 16,		/* ant0: 0 ant1: 1,2 */
+	16, 16, 16, 16,		/* n.a.              */
+	16, 2, 16, 16,		/* ant0: 2 ant1: 1   */
+	16, 16, 16, 16		/* n.a.              */
+};
+
+const uint8 mimo_2x3_div_antselid_tbl[16] = {
+	0, 1, 2, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0	/* pat to antselid */
+};
+
+antsel_info_t *BCMNMIATTACHFN(wlc_antsel_attach) (wlc_info_t * wlc, osl_t * osh,
+						  wlc_pub_t * pub,
+						  wlc_hw_info_t * wlc_hw) {
+	antsel_info_t *asi;
+
+	if (!(asi = (antsel_info_t *) MALLOC(osh, sizeof(antsel_info_t)))) {
+		WL_ERROR(("wl%d: wlc_antsel_attach: out of mem, malloced %d bytes\n", pub->unit, MALLOCED(osh)));
+		return NULL;
+	}
+
+	bzero((char *)asi, sizeof(antsel_info_t));
+
+	asi->wlc = wlc;
+	asi->pub = pub;
+	asi->antsel_type = ANTSEL_NA;
+	asi->antsel_avail = FALSE;
+	asi->antsel_antswitch = (uint8) getintvar(asi->pub->vars, "antswitch");
+
+	if ((asi->pub->sromrev >= 4) && (asi->antsel_antswitch != 0)) {
+		switch (asi->antsel_antswitch) {
+		case ANTSWITCH_TYPE_1:
+		case ANTSWITCH_TYPE_2:
+		case ANTSWITCH_TYPE_3:
+			/* 4321/2 board with 2x3 switch logic */
+			asi->antsel_type = ANTSEL_2x3;
+			/* Antenna selection availability */
+			if (((uint16) getintvar(asi->pub->vars, "aa2g") == 7) ||
+			    ((uint16) getintvar(asi->pub->vars, "aa5g") == 7)) {
+				asi->antsel_avail = TRUE;
+			} else
+			    if (((uint16) getintvar(asi->pub->vars, "aa2g") ==
+				 3)
+				|| ((uint16) getintvar(asi->pub->vars, "aa5g")
+				    == 3)) {
+				asi->antsel_avail = FALSE;
+			} else {
+				asi->antsel_avail = FALSE;
+				WL_ERROR(("wlc_antsel_attach: 2o3 board cfg invalid\n"));
+				ASSERT(0);
+			}
+			break;
+		default:
+			break;
+		}
+	} else if ((asi->pub->sromrev == 4) &&
+		   ((uint16) getintvar(asi->pub->vars, "aa2g") == 7) &&
+		   ((uint16) getintvar(asi->pub->vars, "aa5g") == 0)) {
+		/* hack to match old 4321CB2 cards with 2of3 antenna switch */
+		asi->antsel_type = ANTSEL_2x3;
+		asi->antsel_avail = TRUE;
+	} else if (asi->pub->boardflags2 & BFL2_2X4_DIV) {
+		asi->antsel_type = ANTSEL_2x4;
+		asi->antsel_avail = TRUE;
+	}
+
+	/* Set the antenna selection type for the low driver */
+	wlc_bmac_antsel_type_set(wlc_hw, asi->antsel_type);
+
+	/* Init (auto/manual) antenna selection */
+	wlc_antsel_init_cfg(asi, &asi->antcfg_11n, TRUE);
+	wlc_antsel_init_cfg(asi, &asi->antcfg_cur, TRUE);
+
+	return asi;
+}
+
+void BCMATTACHFN(wlc_antsel_detach) (antsel_info_t * asi) {
+	if (!asi)
+		return;
+
+	MFREE(asi->pub->osh, asi, sizeof(antsel_info_t));
+}
+
+void wlc_antsel_init(antsel_info_t * asi)
+{
+	if ((asi->antsel_type == ANTSEL_2x3) ||
+	    (asi->antsel_type == ANTSEL_2x4))
+		wlc_antsel_cfgupd(asi, &asi->antcfg_11n);
+}
+
+/* boardlevel antenna selection: init antenna selection structure */
+static void
+wlc_antsel_init_cfg(antsel_info_t * asi, wlc_antselcfg_t * antsel,
+		    bool auto_sel)
+{
+	if (asi->antsel_type == ANTSEL_2x3) {
+		uint8 antcfg_def = ANT_SELCFG_DEF_2x3 |
+		    ((asi->antsel_avail && auto_sel) ? ANT_SELCFG_AUTO : 0);
+		antsel->ant_config[ANT_SELCFG_TX_DEF] = antcfg_def;
+		antsel->ant_config[ANT_SELCFG_TX_UNICAST] = antcfg_def;
+		antsel->ant_config[ANT_SELCFG_RX_DEF] = antcfg_def;
+		antsel->ant_config[ANT_SELCFG_RX_UNICAST] = antcfg_def;
+		antsel->num_antcfg = ANT_SELCFG_NUM_2x3;
+
+	} else if (asi->antsel_type == ANTSEL_2x4) {
+
+		antsel->ant_config[ANT_SELCFG_TX_DEF] = ANT_SELCFG_DEF_2x4;
+		antsel->ant_config[ANT_SELCFG_TX_UNICAST] = ANT_SELCFG_DEF_2x4;
+		antsel->ant_config[ANT_SELCFG_RX_DEF] = ANT_SELCFG_DEF_2x4;
+		antsel->ant_config[ANT_SELCFG_RX_UNICAST] = ANT_SELCFG_DEF_2x4;
+		antsel->num_antcfg = ANT_SELCFG_NUM_2x4;
+
+	} else {		/* no antenna selection available */
+
+		antsel->ant_config[ANT_SELCFG_TX_DEF] = ANT_SELCFG_DEF_2x2;
+		antsel->ant_config[ANT_SELCFG_TX_UNICAST] = ANT_SELCFG_DEF_2x2;
+		antsel->ant_config[ANT_SELCFG_RX_DEF] = ANT_SELCFG_DEF_2x2;
+		antsel->ant_config[ANT_SELCFG_RX_UNICAST] = ANT_SELCFG_DEF_2x2;
+		antsel->num_antcfg = 0;
+	}
+}
+
+void BCMFASTPATH
+wlc_antsel_antcfg_get(antsel_info_t * asi, bool usedef, bool sel,
+		      uint8 antselid, uint8 fbantselid, uint8 * antcfg,
+		      uint8 * fbantcfg)
+{
+	uint8 ant;
+
+	/* if use default, assign it and return */
+	if (usedef) {
+		*antcfg = asi->antcfg_11n.ant_config[ANT_SELCFG_TX_DEF];
+		*fbantcfg = *antcfg;
+		return;
+	}
+
+	if (!sel) {
+		*antcfg = asi->antcfg_11n.ant_config[ANT_SELCFG_TX_UNICAST];
+		*fbantcfg = *antcfg;
+
+	} else {
+		ant = asi->antcfg_11n.ant_config[ANT_SELCFG_TX_UNICAST];
+		if ((ant & ANT_SELCFG_AUTO) == ANT_SELCFG_AUTO) {
+			*antcfg = wlc_antsel_id2antcfg(asi, antselid);
+			*fbantcfg = wlc_antsel_id2antcfg(asi, fbantselid);
+		} else {
+			*antcfg =
+			    asi->antcfg_11n.ant_config[ANT_SELCFG_TX_UNICAST];
+			*fbantcfg = *antcfg;
+		}
+	}
+	return;
+}
+
+/* boardlevel antenna selection: convert mimo_antsel (ucode interface) to id */
+uint8 wlc_antsel_antsel2id(antsel_info_t * asi, uint16 antsel)
+{
+	uint8 antselid = 0;
+
+	if (asi->antsel_type == ANTSEL_2x4) {
+		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
+		antselid = mimo_2x4_div_antselid_tbl[(antsel & 0xf)];
+		return antselid;
+
+	} else if (asi->antsel_type == ANTSEL_2x3) {
+		/* 2x3 antenna selection, 3 cfgs: 0-1 0-2 2-1 */
+		antselid = mimo_2x3_div_antselid_tbl[(antsel & 0xf)];
+		return antselid;
+	}
+
+	return antselid;
+}
+
+/* boardlevel antenna selection: convert id to ant_cfg */
+static uint8 wlc_antsel_id2antcfg(antsel_info_t * asi, uint8 id)
+{
+	uint8 antcfg = ANT_SELCFG_DEF_2x2;
+
+	if (asi->antsel_type == ANTSEL_2x4) {
+		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
+		antcfg = (((id & 0x2) << 3) | ((id & 0x1) + 2));
+		return antcfg;
+
+	} else if (asi->antsel_type == ANTSEL_2x3) {
+		/* 2x3 antenna selection, 3 cfgs: 0-1 0-2 2-1 */
+		antcfg = (((id & 0x02) << 4) | ((id & 0x1) + 1));
+		return antcfg;
+	}
+
+	return antcfg;
+}
+
+/* boardlevel antenna selection: convert ant_cfg to mimo_antsel (ucode interface) */
+static uint16 wlc_antsel_antcfg2antsel(antsel_info_t * asi, uint8 ant_cfg)
+{
+	uint8 idx = WLC_ANTIDX_11N(WLC_ANTSEL_11N(ant_cfg));
+	uint16 mimo_antsel = 0;
+
+	if (asi->antsel_type == ANTSEL_2x4) {
+		/* 2x4 antenna diversity board, 4 cfgs: 0-2 0-3 1-2 1-3 */
+		mimo_antsel = (mimo_2x4_div_antselpat_tbl[idx] & 0xf);
+		return mimo_antsel;
+
+	} else if (asi->antsel_type == ANTSEL_2x3) {
+		/* 2x3 antenna selection, 3 cfgs: 0-1 0-2 2-1 */
+		mimo_antsel = (mimo_2x3_div_antselpat_tbl[idx] & 0xf);
+		return mimo_antsel;
+	}
+
+	return mimo_antsel;
+}
+
+/* boardlevel antenna selection: ucode interface control */
+static int wlc_antsel_cfgupd(antsel_info_t * asi, wlc_antselcfg_t * antsel)
+{
+	wlc_info_t *wlc = asi->wlc;
+	uint8 ant_cfg;
+	uint16 mimo_antsel;
+
+	ASSERT(asi->antsel_type != ANTSEL_NA);
+
+	/* 1) Update TX antconfig for all frames that are not unicast data
+	 *    (aka default TX)
+	 */
+	ant_cfg = antsel->ant_config[ANT_SELCFG_TX_DEF];
+	mimo_antsel = wlc_antsel_antcfg2antsel(asi, ant_cfg);
+	wlc_write_shm(wlc, M_MIMO_ANTSEL_TXDFLT, mimo_antsel);
+	/* Update driver stats for currently selected default tx/rx antenna config */
+	asi->antcfg_cur.ant_config[ANT_SELCFG_TX_DEF] = ant_cfg;
+
+	/* 2) Update RX antconfig for all frames that are not unicast data
+	 *    (aka default RX)
+	 */
+	ant_cfg = antsel->ant_config[ANT_SELCFG_RX_DEF];
+	mimo_antsel = wlc_antsel_antcfg2antsel(asi, ant_cfg);
+	wlc_write_shm(wlc, M_MIMO_ANTSEL_RXDFLT, mimo_antsel);
+	/* Update driver stats for currently selected default tx/rx antenna config */
+	asi->antcfg_cur.ant_config[ANT_SELCFG_RX_DEF] = ant_cfg;
+
+	return 0;
+}
+
+#endif				/* WLANTSEL */
diff --git a/drivers/staging/brcm80211/sys/wlc_antsel.h b/drivers/staging/brcm80211/sys/wlc_antsel.h
new file mode 100644
index 0000000..1e51bfd
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_antsel.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_antsel_h_
+#define _wlc_antsel_h_
+extern antsel_info_t *wlc_antsel_attach(wlc_info_t * wlc, osl_t * osh,
+					wlc_pub_t * pub,
+					wlc_hw_info_t * wlc_hw);
+extern void wlc_antsel_detach(antsel_info_t * asi);
+extern void wlc_antsel_init(antsel_info_t * asi);
+extern void wlc_antsel_antcfg_get(antsel_info_t * asi, bool usedef, bool sel,
+				  uint8 id, uint8 fbid, uint8 * antcfg,
+				  uint8 * fbantcfg);
+extern uint8 wlc_antsel_antsel2id(antsel_info_t * asi, uint16 antsel);
+#endif				/* _wlc_antsel_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_bmac.c b/drivers/staging/brcm80211/sys/wlc_bmac.c
new file mode 100644
index 0000000..70aa98b
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.c
@@ -0,0 +1,4178 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef WLC_LOW
+#error "This file needs WLC_LOW"
+#endif
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <proto/802.11.h>
+#include <bcmwifi.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <wlioctl.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <pcicfg.h>
+#include <sbhndpio.h>
+#include <sbhnddma.h>
+#include <hnddma.h>
+#include <hndpmu.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_pub.h>
+#include <wlc_channel.h>
+#include <bcmsrom.h>
+#include <wlc_key.h>
+/* BMAC_NOTE: a WLC_HIGH compile include of wlc.h adds in more structures and type
+ * dependencies. Need to include these to files to allow a clean include of wlc.h
+ * with WLC_HIGH defined.
+ * At some point we may be able to skip the include of wlc.h and instead just
+ * define a stub wlc_info and band struct to allow rpc calls to get the rpc handle.
+ */
+#include <wlc_mac80211.h>
+#include <wlc_bmac.h>
+#include <wlc_phy_shim.h>
+#include <wlc_phy_hal.h>
+#include <wl_export.h>
+#include "wl_ucode.h"
+#include "d11ucode_ext.h"
+#ifdef BCMSDIO
+#include <bcmsdh.h>
+#endif
+#include <bcmotp.h>
+
+/* BMAC_NOTE: With WLC_HIGH defined, some fns in this file make calls to high level
+ * functions defined in the headers below. We should be eliminating those calls and
+ * will be able to delete these include lines.
+ */
+#include <wlc_antsel.h>
+
+#include <pcie_core.h>
+
+#include <wlc_alloc.h>
+
+#define	TIMER_INTERVAL_WATCHDOG_BMAC	1000	/* watchdog timer, in unit of ms */
+
+#define	SYNTHPU_DLY_APHY_US	3700	/* a phy synthpu_dly time in us */
+#define	SYNTHPU_DLY_BPHY_US	1050	/* b/g phy synthpu_dly time in us, default */
+#define	SYNTHPU_DLY_NPHY_US	2048	/* n phy REV3 synthpu_dly time in us, default */
+#define	SYNTHPU_DLY_LPPHY_US	300	/* lpphy synthpu_dly time in us */
+
+#define	SYNTHPU_DLY_PHY_US_QT	100	/* QT synthpu_dly time in us */
+
+#ifndef BMAC_DUP_TO_REMOVE
+#define WLC_RM_WAIT_TX_SUSPEND		4	/* Wait Tx Suspend */
+
+#define	ANTCNT			10	/* vanilla M_MAX_ANTCNT value */
+
+#endif				/* BMAC_DUP_TO_REMOVE */
+
+#define DMAREG(wlc_hw, direction, fifonum)	(D11REV_LT(wlc_hw->corerev, 11) ? \
+	((direction == DMA_TX) ? \
+		(void*)(uintptr)&(wlc_hw->regs->fifo.f32regs.dmaregs[fifonum].xmt) : \
+		(void*)(uintptr)&(wlc_hw->regs->fifo.f32regs.dmaregs[fifonum].rcv)) : \
+	((direction == DMA_TX) ? \
+		(void*)(uintptr)&(wlc_hw->regs->fifo.f64regs[fifonum].dmaxmt) : \
+		(void*)(uintptr)&(wlc_hw->regs->fifo.f64regs[fifonum].dmarcv)))
+
+/*
+ * The following table lists the buffer memory allocated to xmt fifos in HW.
+ * the size is in units of 256bytes(one block), total size is HW dependent
+ * ucode has default fifo partition, sw can overwrite if necessary
+ *
+ * This is documented in twiki under the topic UcodeTxFifo. Please ensure
+ * the twiki is updated before making changes.
+ */
+
+#define XMTFIFOTBL_STARTREV	20	/* Starting corerev for the fifo size table */
+
+static uint16 xmtfifo_sz[][NFIFO] = {
+	{20, 192, 192, 21, 17, 5},	/* corerev 20: 5120, 49152, 49152, 5376, 4352, 1280 */
+	{9, 58, 22, 14, 14, 5},	/* corerev 21: 2304, 14848, 5632, 3584, 3584, 1280 */
+	{20, 192, 192, 21, 17, 5},	/* corerev 22: 5120, 49152, 49152, 5376, 4352, 1280 */
+	{20, 192, 192, 21, 17, 5},	/* corerev 23: 5120, 49152, 49152, 5376, 4352, 1280 */
+	{9, 58, 22, 14, 14, 5},	/* corerev 24: 2304, 14848, 5632, 3584, 3584, 1280 */
+};
+
+static void wlc_clkctl_clk(wlc_hw_info_t * wlc, uint mode);
+static void wlc_coreinit(wlc_info_t * wlc);
+
+/* used by wlc_wakeucode_init() */
+static void wlc_write_inits(wlc_hw_info_t * wlc_hw, const d11init_t * inits);
+static void wlc_ucode_write(wlc_hw_info_t * wlc_hw, const uint32 ucode[],
+			    const uint nbytes);
+static void wlc_ucode_download(wlc_hw_info_t * wlc);
+static void wlc_ucode_txant_set(wlc_hw_info_t * wlc_hw);
+
+/* used by wlc_dpc() */
+static bool wlc_bmac_dotxstatus(wlc_hw_info_t * wlc, tx_status_t * txs,
+				uint32 s2);
+static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t * wlc);
+static bool wlc_bmac_txstatus(wlc_hw_info_t * wlc, bool bound, bool * fatal);
+static bool wlc_bmac_recv(wlc_hw_info_t * wlc_hw, uint fifo, bool bound);
+
+/* used by wlc_down() */
+static void wlc_flushqueues(wlc_info_t * wlc);
+
+static void wlc_write_mhf(wlc_hw_info_t * wlc_hw, uint16 * mhfs);
+static void wlc_mctrl_reset(wlc_hw_info_t * wlc_hw);
+static void wlc_corerev_fifofixup(wlc_hw_info_t * wlc_hw);
+
+/* Low Level Prototypes */
+static uint16 wlc_bmac_read_objmem(wlc_hw_info_t * wlc_hw, uint offset,
+				   uint32 sel);
+static void wlc_bmac_write_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint16 v,
+				  uint32 sel);
+static bool wlc_bmac_attach_dmapio(wlc_info_t * wlc, uint j, bool wme);
+static void wlc_bmac_detach_dmapio(wlc_hw_info_t * wlc_hw);
+static void wlc_ucode_bsinit(wlc_hw_info_t * wlc_hw);
+static bool wlc_validboardtype(wlc_hw_info_t * wlc);
+static bool wlc_isgoodchip(wlc_hw_info_t * wlc_hw);
+static char *wlc_get_macaddr(wlc_hw_info_t * wlc_hw);
+static void wlc_mhfdef(wlc_info_t * wlc, uint16 * mhfs, uint16 mhf2_init);
+static void wlc_mctrl_write(wlc_hw_info_t * wlc_hw);
+static void wlc_ucode_mute_override_set(wlc_hw_info_t * wlc_hw);
+static void wlc_ucode_mute_override_clear(wlc_hw_info_t * wlc_hw);
+static uint32 wlc_wlintrsoff(wlc_info_t * wlc);
+static void wlc_wlintrsrestore(wlc_info_t * wlc, uint32 macintmask);
+static void wlc_gpio_init(wlc_info_t * wlc);
+static void wlc_write_hw_bcntemplate0(wlc_hw_info_t * wlc_hw, void *bcn,
+				      int len);
+static void wlc_write_hw_bcntemplate1(wlc_hw_info_t * wlc_hw, void *bcn,
+				      int len);
+static void wlc_bmac_bsinit(wlc_info_t * wlc, chanspec_t chanspec);
+static uint32 wlc_setband_inact(wlc_info_t * wlc, uint bandunit);
+static void wlc_bmac_setband(wlc_hw_info_t * wlc_hw, uint bandunit,
+			     chanspec_t chanspec);
+static void wlc_bmac_update_slot_timing(wlc_hw_info_t * wlc_hw, bool shortslot);
+static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t * wlc_hw);
+static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw,
+					     uint8 rate);
+
+/* === Low Level functions === */
+
+void wlc_bmac_set_shortslot(wlc_hw_info_t * wlc_hw, bool shortslot)
+{
+	wlc_hw->shortslot = shortslot;
+
+	if (BAND_2G(wlc_hw->band->bandtype) && wlc_hw->up) {
+		wlc_suspend_mac_and_wait(wlc_hw->wlc);
+		wlc_bmac_update_slot_timing(wlc_hw, shortslot);
+		wlc_enable_mac(wlc_hw->wlc);
+	}
+}
+
+/*
+ * Update the slot timing for standard 11b/g (20us slots)
+ * or shortslot 11g (9us slots)
+ * The PSM needs to be suspended for this call.
+ */
+static void wlc_bmac_update_slot_timing(wlc_hw_info_t * wlc_hw, bool shortslot)
+{
+	osl_t *osh;
+	d11regs_t *regs;
+
+	osh = wlc_hw->osh;
+	regs = wlc_hw->regs;
+
+	if (shortslot) {
+		/* 11g short slot: 11a timing */
+		W_REG(osh, &regs->ifs_slot, 0x0207);	/* APHY_SLOT_TIME */
+		wlc_bmac_write_shm(wlc_hw, M_DOT11_SLOT, APHY_SLOT_TIME);
+	} else {
+		/* 11g long slot: 11b timing */
+		W_REG(osh, &regs->ifs_slot, 0x0212);	/* BPHY_SLOT_TIME */
+		wlc_bmac_write_shm(wlc_hw, M_DOT11_SLOT, BPHY_SLOT_TIME);
+	}
+}
+
+static void WLBANDINITFN(wlc_ucode_bsinit) (wlc_hw_info_t * wlc_hw) {
+	/* init microcode host flags */
+	wlc_write_mhf(wlc_hw, wlc_hw->band->mhfs);
+
+	/* do band-specific ucode IHR, SHM, and SCR inits */
+	if (D11REV_IS(wlc_hw->corerev, 23)) {
+		if (WLCISNPHY(wlc_hw->band)) {
+			wlc_write_inits(wlc_hw, d11n0bsinitvals16);
+		} else {
+			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
+				  __func__, wlc_hw->unit, wlc_hw->corerev));
+		}
+	} else {
+		if (D11REV_IS(wlc_hw->corerev, 24)) {
+			if (WLCISLCNPHY(wlc_hw->band)) {
+				wlc_write_inits(wlc_hw, d11lcn0bsinitvals24);
+			} else
+				WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n", __func__, wlc_hw->unit, wlc_hw->corerev));
+		} else {
+			WL_ERROR(("%s: wl%d: unsupported corerev %d\n",
+				  __func__, wlc_hw->unit, wlc_hw->corerev));
+		}
+	}
+}
+
+/* switch to new band but leave it inactive */
+static uint32 WLBANDINITFN(wlc_setband_inact) (wlc_info_t * wlc, uint bandunit) {
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	uint32 macintmask;
+	uint32 tmp;
+
+	WL_TRACE(("wl%d: wlc_setband_inact\n", wlc_hw->unit));
+
+	ASSERT(bandunit != wlc_hw->band->bandunit);
+	ASSERT(si_iscoreup(wlc_hw->sih));
+	ASSERT((R_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol) & MCTL_EN_MAC) ==
+	       0);
+
+	/* disable interrupts */
+	macintmask = wl_intrsoff(wlc->wl);
+
+	/* radio off */
+	wlc_phy_switch_radio(wlc_hw->band->pi, OFF);
+
+	ASSERT(wlc_hw->clk);
+
+	if (D11REV_LT(wlc_hw->corerev, 17))
+		tmp = R_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol);
+
+	wlc_bmac_core_phy_clk(wlc_hw, OFF);
+
+	wlc_setxband(wlc_hw, bandunit);
+
+	return (macintmask);
+}
+
+/* Process received frames */
+/*
+ * Return TRUE if more frames need to be processed. FALSE otherwise.
+ * Param 'bound' indicates max. # frames to process before break out.
+ */
+static bool BCMFASTPATH
+wlc_bmac_recv(wlc_hw_info_t * wlc_hw, uint fifo, bool bound)
+{
+	void *p;
+	void *head = NULL;
+	void *tail = NULL;
+	uint n = 0;
+	uint bound_limit = bound ? wlc_hw->wlc->pub->tunables->rxbnd : -1;
+	uint32 tsf_h, tsf_l;
+	wlc_d11rxhdr_t *wlc_rxhdr = NULL;
+
+	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
+	/* gather received frames */
+	while ((p = dma_rx(wlc_hw->di[fifo]))) {
+
+		if (!tail)
+			head = tail = p;
+		else {
+			PKTSETLINK(tail, p);
+			tail = p;
+		}
+
+		/* !give others some time to run! */
+		if (++n >= bound_limit)
+			break;
+	}
+
+	/* get the TSF REG reading */
+	wlc_bmac_read_tsf(wlc_hw, &tsf_l, &tsf_h);
+
+	/* post more rbufs */
+	dma_rxfill(wlc_hw->di[fifo]);
+
+	/* process each frame */
+	while ((p = head) != NULL) {
+		head = PKTLINK(head);
+		PKTSETLINK(p, NULL);
+
+		/* record the tsf_l in wlc_rxd11hdr */
+		wlc_rxhdr = (wlc_d11rxhdr_t *) PKTDATA(p);
+		wlc_rxhdr->tsf_l = htol32(tsf_l);
+
+		/* compute the RSSI from d11rxhdr and record it in wlc_rxd11hr */
+		wlc_phy_rssi_compute(wlc_hw->band->pi, wlc_rxhdr);
+
+		wlc_recv(wlc_hw->wlc, p);
+	}
+
+	return (n >= bound_limit);
+}
+
+/* second-level interrupt processing
+ *   Return TRUE if another dpc needs to be re-scheduled. FALSE otherwise.
+ *   Param 'bounded' indicates if applicable loops should be bounded.
+ */
+bool BCMFASTPATH wlc_dpc(wlc_info_t * wlc, bool bounded)
+{
+	uint32 macintstatus;
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	d11regs_t *regs = wlc_hw->regs;
+	bool fatal = FALSE;
+
+	if (DEVICEREMOVED(wlc)) {
+		WL_ERROR(("wl%d: %s: dead chip\n", wlc_hw->unit, __func__));
+		wl_down(wlc->wl);
+		return FALSE;
+	}
+
+	/* grab and clear the saved software intstatus bits */
+	macintstatus = wlc->macintstatus;
+	wlc->macintstatus = 0;
+
+	WL_TRACE(("wl%d: wlc_dpc: macintstatus 0x%x\n", wlc_hw->unit,
+		  macintstatus));
+
+	if (macintstatus & MI_PRQ) {
+		/* Process probe request FIFO */
+		ASSERT(0 && "PRQ Interrupt in non-MBSS");
+	}
+
+	/* BCN template is available */
+	/* ZZZ: Use AP_ACTIVE ? */
+	if (AP_ENAB(wlc->pub) && (!APSTA_ENAB(wlc->pub) || wlc->aps_associated)
+	    && (macintstatus & MI_BCNTPL)) {
+		wlc_update_beacon(wlc);
+	}
+
+	/* PMQ entry addition */
+	if (macintstatus & MI_PMQ) {
+	}
+
+	/* tx status */
+	if (macintstatus & MI_TFS) {
+		if (wlc_bmac_txstatus(wlc->hw, bounded, &fatal))
+			wlc->macintstatus |= MI_TFS;
+		if (fatal) {
+			WL_ERROR(("MI_TFS: fatal\n"));
+			goto fatal;
+		}
+	}
+
+	if (macintstatus & (MI_TBTT | MI_DTIM_TBTT))
+		wlc_tbtt(wlc, regs);
+
+	/* ATIM window end */
+	if (macintstatus & MI_ATIMWINEND) {
+		WL_TRACE(("wlc_isr: end of ATIM window\n"));
+
+		OR_REG(wlc_hw->osh, &regs->maccommand, wlc->qvalid);
+		wlc->qvalid = 0;
+	}
+
+	/* phy tx error */
+	if (macintstatus & MI_PHYTXERR) {
+		WLCNTINCR(wlc->pub->_cnt->txphyerr);
+	}
+
+	/* received data or control frame, MI_DMAINT is indication of RX_FIFO interrupt */
+	if (macintstatus & MI_DMAINT) {
+		if (wlc_bmac_recv(wlc_hw, RX_FIFO, bounded)) {
+			wlc->macintstatus |= MI_DMAINT;
+		}
+	}
+
+	/* TX FIFO suspend/flush completion */
+	if (macintstatus & MI_TXSTOP) {
+		if (wlc_bmac_tx_fifo_suspended(wlc_hw, TX_DATA_FIFO)) {
+			/*      WL_ERROR(("dpc: fifo_suspend_comlete\n")); */
+		}
+	}
+
+	/* noise sample collected */
+	if (macintstatus & MI_BG_NOISE) {
+		wlc_phy_noise_sample_intr(wlc_hw->band->pi);
+	}
+
+	if (macintstatus & MI_GP0) {
+		WL_ERROR(("wl%d: PSM microcode watchdog fired at %d (seconds). Resetting.\n", wlc_hw->unit, wlc_hw->now));
+
+		printk_once("%s : PSM Watchdog, chipid 0x%x, chiprev 0x%x\n",
+			    __func__, CHIPID(wlc_hw->sih->chip),
+			    CHIPREV(wlc_hw->sih->chiprev));
+
+		WLCNTINCR(wlc->pub->_cnt->psmwds);
+
+		/* big hammer */
+		wl_init(wlc->wl);
+	}
+
+	/* gptimer timeout */
+	if (macintstatus & MI_TO) {
+		W_REG(wlc_hw->osh, &regs->gptimer, 0);
+	}
+
+	if (macintstatus & MI_RFDISABLE) {
+#if defined(BCMDBG)
+		uint32 rfd = R_REG(wlc_hw->osh, &regs->phydebug) & PDBG_RFD;
+#endif
+
+		WL_ERROR(("wl%d: MAC Detected a change on the RF Disable Input 0x%x\n", wlc_hw->unit, rfd));
+
+		WLCNTINCR(wlc->pub->_cnt->rfdisable);
+	}
+
+	/* send any enq'd tx packets. Just makes sure to jump start tx */
+	if (!pktq_empty(&wlc->active_queue->q))
+		wlc_send_q(wlc, wlc->active_queue);
+
+	ASSERT(wlc_ps_check(wlc));
+
+	/* make sure the bound indication and the implementation are in sync */
+	ASSERT(bounded == TRUE || wlc->macintstatus == 0);
+
+	/* it isn't done and needs to be resched if macintstatus is non-zero */
+	return (wlc->macintstatus != 0);
+
+ fatal:
+	wl_init(wlc->wl);
+	return (wlc->macintstatus != 0);
+}
+
+/* common low-level watchdog code */
+void wlc_bmac_watchdog(void *arg)
+{
+	wlc_info_t *wlc = (wlc_info_t *) arg;
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+
+	WL_TRACE(("wl%d: wlc_bmac_watchdog\n", wlc_hw->unit));
+
+	if (!wlc_hw->up)
+		return;
+
+	/* increment second count */
+	wlc_hw->now++;
+
+	/* Check for FIFO error interrupts */
+	wlc_bmac_fifoerrors(wlc_hw);
+
+	/* make sure RX dma has buffers */
+	dma_rxfill(wlc->hw->di[RX_FIFO]);
+	if (D11REV_IS(wlc_hw->corerev, 4)) {
+		dma_rxfill(wlc->hw->di[RX_TXSTATUS_FIFO]);
+	}
+
+	wlc_phy_watchdog(wlc_hw->band->pi);
+}
+
+void
+wlc_bmac_set_chanspec(wlc_hw_info_t * wlc_hw, chanspec_t chanspec, bool mute,
+		      struct txpwr_limits *txpwr)
+{
+	uint bandunit;
+
+	WL_TRACE(("wl%d: wlc_bmac_set_chanspec 0x%x\n", wlc_hw->unit,
+		  chanspec));
+
+	wlc_hw->chanspec = chanspec;
+
+	/* Switch bands if necessary */
+	if (NBANDS_HW(wlc_hw) > 1) {
+		bandunit = CHSPEC_WLCBANDUNIT(chanspec);
+		if (wlc_hw->band->bandunit != bandunit) {
+			/* wlc_bmac_setband disables other bandunit,
+			 *  use light band switch if not up yet
+			 */
+			if (wlc_hw->up) {
+				wlc_phy_chanspec_radio_set(wlc_hw->
+							   bandstate[bandunit]->
+							   pi, chanspec);
+				wlc_bmac_setband(wlc_hw, bandunit, chanspec);
+			} else {
+				wlc_setxband(wlc_hw, bandunit);
+			}
+		}
+	}
+
+	wlc_phy_initcal_enable(wlc_hw->band->pi, !mute);
+
+	if (!wlc_hw->up) {
+		if (wlc_hw->clk)
+			wlc_phy_txpower_limit_set(wlc_hw->band->pi, txpwr,
+						  chanspec);
+		wlc_phy_chanspec_radio_set(wlc_hw->band->pi, chanspec);
+	} else {
+		wlc_phy_chanspec_set(wlc_hw->band->pi, chanspec);
+		wlc_phy_txpower_limit_set(wlc_hw->band->pi, txpwr, chanspec);
+
+		/* Update muting of the channel */
+		wlc_bmac_mute(wlc_hw, mute, 0);
+	}
+}
+
+int wlc_bmac_revinfo_get(wlc_hw_info_t * wlc_hw, wlc_bmac_revinfo_t * revinfo)
+{
+	si_t *sih = wlc_hw->sih;
+	uint idx;
+
+	revinfo->vendorid = wlc_hw->vendorid;
+	revinfo->deviceid = wlc_hw->deviceid;
+
+	revinfo->boardrev = wlc_hw->boardrev;
+	revinfo->corerev = wlc_hw->corerev;
+	revinfo->sromrev = wlc_hw->sromrev;
+	revinfo->chiprev = sih->chiprev;
+	revinfo->chip = sih->chip;
+	revinfo->chippkg = sih->chippkg;
+	revinfo->boardtype = sih->boardtype;
+	revinfo->boardvendor = sih->boardvendor;
+	revinfo->bustype = sih->bustype;
+	revinfo->buscoretype = sih->buscoretype;
+	revinfo->buscorerev = sih->buscorerev;
+	revinfo->issim = sih->issim;
+
+	revinfo->nbands = NBANDS_HW(wlc_hw);
+
+	for (idx = 0; idx < NBANDS_HW(wlc_hw); idx++) {
+		wlc_hwband_t *band = wlc_hw->bandstate[idx];
+		revinfo->band[idx].bandunit = band->bandunit;
+		revinfo->band[idx].bandtype = band->bandtype;
+		revinfo->band[idx].phytype = band->phytype;
+		revinfo->band[idx].phyrev = band->phyrev;
+		revinfo->band[idx].radioid = band->radioid;
+		revinfo->band[idx].radiorev = band->radiorev;
+		revinfo->band[idx].abgphy_encore = band->abgphy_encore;
+		revinfo->band[idx].anarev = 0;
+
+	}
+	return 0;
+}
+
+int wlc_bmac_state_get(wlc_hw_info_t * wlc_hw, wlc_bmac_state_t * state)
+{
+	state->machwcap = wlc_hw->machwcap;
+
+	return 0;
+}
+
+static bool
+BCMATTACHFN(wlc_bmac_attach_dmapio) (wlc_info_t * wlc, uint j, bool wme) {
+	uint i;
+	char name[8];
+	/* ucode host flag 2 needed for pio mode, independent of band and fifo */
+	uint16 pio_mhf2 = 0;
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	uint unit = wlc_hw->unit;
+	wlc_tunables_t *tune = wlc->pub->tunables;
+
+	/* name and offsets for dma_attach */
+	snprintf(name, sizeof(name), "wl%d", unit);
+
+	if (wlc_hw->di[0] == 0) {	/* Init FIFOs */
+		uint addrwidth;
+		int dma_attach_err = 0;
+		osl_t *osh = wlc_hw->osh;
+
+		/* Find out the DMA addressing capability and let OS know
+		 * All the channels within one DMA core have 'common-minimum' same
+		 * capability
+		 */
+		addrwidth =
+		    dma_addrwidth(wlc_hw->sih, DMAREG(wlc_hw, DMA_TX, 0));
+		OSL_DMADDRWIDTH(osh, addrwidth);
+
+		if (!wl_alloc_dma_resources(wlc_hw->wlc->wl, addrwidth)) {
+			WL_ERROR(("wl%d: wlc_attach: alloc_dma_resources failed\n", unit));
+			return FALSE;
+		}
+
+		/*
+		 * FIFO 0
+		 * TX: TX_AC_BK_FIFO (TX AC Background data packets)
+		 * RX: RX_FIFO (RX data packets)
+		 */
+		ASSERT(TX_AC_BK_FIFO == 0);
+		ASSERT(RX_FIFO == 0);
+		wlc_hw->di[0] = dma_attach(osh, name, wlc_hw->sih,
+					   (wme ? DMAREG(wlc_hw, DMA_TX, 0) :
+					    NULL), DMAREG(wlc_hw, DMA_RX, 0),
+					   (wme ? tune->ntxd : 0), tune->nrxd,
+					   tune->rxbufsz, -1, tune->nrxbufpost,
+					   WL_HWRXOFF, &wl_msg_level);
+		dma_attach_err |= (NULL == wlc_hw->di[0]);
+
+		/*
+		 * FIFO 1
+		 * TX: TX_AC_BE_FIFO (TX AC Best-Effort data packets)
+		 *   (legacy) TX_DATA_FIFO (TX data packets)
+		 * RX: UNUSED
+		 */
+		ASSERT(TX_AC_BE_FIFO == 1);
+		ASSERT(TX_DATA_FIFO == 1);
+		wlc_hw->di[1] = dma_attach(osh, name, wlc_hw->sih,
+					   DMAREG(wlc_hw, DMA_TX, 1), NULL,
+					   tune->ntxd, 0, 0, -1, 0, 0,
+					   &wl_msg_level);
+		dma_attach_err |= (NULL == wlc_hw->di[1]);
+
+		/*
+		 * FIFO 2
+		 * TX: TX_AC_VI_FIFO (TX AC Video data packets)
+		 * RX: UNUSED
+		 */
+		ASSERT(TX_AC_VI_FIFO == 2);
+		wlc_hw->di[2] = dma_attach(osh, name, wlc_hw->sih,
+					   DMAREG(wlc_hw, DMA_TX, 2), NULL,
+					   tune->ntxd, 0, 0, -1, 0, 0,
+					   &wl_msg_level);
+		dma_attach_err |= (NULL == wlc_hw->di[2]);
+		/*
+		 * FIFO 3
+		 * TX: TX_AC_VO_FIFO (TX AC Voice data packets)
+		 *   (legacy) TX_CTL_FIFO (TX control & mgmt packets)
+		 * RX: RX_TXSTATUS_FIFO (transmit-status packets)
+		 *      for corerev < 5 only
+		 */
+		ASSERT(TX_AC_VO_FIFO == 3);
+		ASSERT(TX_CTL_FIFO == 3);
+		if (D11REV_IS(wlc_hw->corerev, 4)) {
+			ASSERT(RX_TXSTATUS_FIFO == 3);
+			wlc_hw->di[3] = dma_attach(osh, name, wlc_hw->sih,
+						   DMAREG(wlc_hw, DMA_TX, 3),
+						   DMAREG(wlc_hw, DMA_RX, 3),
+						   tune->ntxd, tune->nrxd,
+						   sizeof(tx_status_t), -1,
+						   tune->nrxbufpost, 0,
+						   &wl_msg_level);
+			dma_attach_err |= (NULL == wlc_hw->di[3]);
+		} else {
+			wlc_hw->di[3] = dma_attach(osh, name, wlc_hw->sih,
+						   DMAREG(wlc_hw, DMA_TX, 3),
+						   NULL, tune->ntxd, 0, 0, -1,
+						   0, 0, &wl_msg_level);
+			dma_attach_err |= (NULL == wlc_hw->di[3]);
+		}
+/* Cleaner to leave this as if with AP defined */
+
+		if (dma_attach_err) {
+			WL_ERROR(("wl%d: wlc_attach: dma_attach failed\n",
+				  unit));
+			return FALSE;
+		}
+
+		/* get pointer to dma engine tx flow control variable */
+		for (i = 0; i < NFIFO; i++)
+			if (wlc_hw->di[i])
+				wlc_hw->txavail[i] =
+				    (uint *) dma_getvar(wlc_hw->di[i],
+							"&txavail");
+	}
+
+	/* initial ucode host flags */
+	wlc_mhfdef(wlc, wlc_hw->band->mhfs, pio_mhf2);
+
+	return TRUE;
+}
+
+static void BCMATTACHFN(wlc_bmac_detach_dmapio) (wlc_hw_info_t * wlc_hw) {
+	uint j;
+
+	for (j = 0; j < NFIFO; j++) {
+		if (wlc_hw->di[j]) {
+			dma_detach(wlc_hw->di[j]);
+			wlc_hw->di[j] = NULL;
+		}
+	}
+}
+
+/* low level attach
+ *    run backplane attach, init nvram
+ *    run phy attach
+ *    initialize software state for each core and band
+ *    put the whole chip in reset(driver down state), no clock
+ */
+
+int
+BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
+			      uint unit, bool piomode, osl_t * osh,
+			      void *regsva, uint bustype, void *btparam) {
+	wlc_hw_info_t *wlc_hw;
+	d11regs_t *regs;
+	char *macaddr = NULL;
+	char *vars;
+	uint err = 0;
+	uint j;
+	bool wme = FALSE;
+	shared_phy_params_t sha_params;
+
+	WL_TRACE(("wl%d: wlc_bmac_attach: vendor 0x%x device 0x%x\n", unit,
+		  vendor, device));
+
+	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);
+
+	wme = TRUE;
+
+	wlc_hw = wlc->hw;
+	wlc_hw->wlc = wlc;
+	wlc_hw->unit = unit;
+	wlc_hw->osh = osh;
+	wlc_hw->band = wlc_hw->bandstate[0];
+	wlc_hw->_piomode = piomode;
+
+	/* populate wlc_hw_info_t with default values  */
+	wlc_bmac_info_init(wlc_hw);
+
+	/*
+	 * Do the hardware portion of the attach.
+	 * Also initialize software state that depends on the particular hardware
+	 * we are running.
+	 */
+	wlc_hw->sih = si_attach((uint) device, osh, regsva, bustype, btparam,
+				&wlc_hw->vars, &wlc_hw->vars_size);
+	if (wlc_hw->sih == NULL) {
+		WL_ERROR(("wl%d: wlc_bmac_attach: si_attach failed\n", unit));
+		err = 11;
+		goto fail;
+	}
+	vars = wlc_hw->vars;
+
+	/*
+	 * Get vendid/devid nvram overwrites, which could be different
+	 * than those the BIOS recognizes for devices on PCMCIA_BUS,
+	 * SDIO_BUS, and SROMless devices on PCI_BUS.
+	 */
+#ifdef BCMBUSTYPE
+	bustype = BCMBUSTYPE;
+#endif
+	if (bustype != SI_BUS) {
+		char *var;
+
+		if ((var = getvar(vars, "vendid"))) {
+			vendor = (uint16) bcm_strtoul(var, NULL, 0);
+			WL_ERROR(("Overriding vendor id = 0x%x\n", vendor));
+		}
+		if ((var = getvar(vars, "devid"))) {
+			uint16 devid = (uint16) bcm_strtoul(var, NULL, 0);
+			if (devid != 0xffff) {
+				device = devid;
+				WL_ERROR(("Overriding device id = 0x%x\n",
+					  device));
+			}
+		}
+
+		/* verify again the device is supported */
+		if (!wlc_chipmatch(vendor, device)) {
+			WL_ERROR(("wl%d: wlc_bmac_attach: Unsupported vendor/device (0x%x/0x%x)\n", unit, vendor, device));
+			err = 12;
+			goto fail;
+		}
+	}
+
+	wlc_hw->vendorid = vendor;
+	wlc_hw->deviceid = device;
+
+	/* set bar0 window to point at D11 core */
+	wlc_hw->regs = (d11regs_t *) si_setcore(wlc_hw->sih, D11_CORE_ID, 0);
+	wlc_hw->corerev = si_corerev(wlc_hw->sih);
+
+	regs = wlc_hw->regs;
+
+	wlc->regs = wlc_hw->regs;
+
+	/* validate chip, chiprev and corerev */
+	if (!wlc_isgoodchip(wlc_hw)) {
+		err = 13;
+		goto fail;
+	}
+
+	/* initialize power control registers */
+	si_clkctl_init(wlc_hw->sih);
+
+	/* request fastclock and force fastclock for the rest of attach
+	 * bring the d11 core out of reset.
+	 *   For PMU chips, the first wlc_clkctl_clk is no-op since core-clk is still FALSE;
+	 *   But it will be called again inside wlc_corereset, after d11 is out of reset.
+	 */
+	wlc_clkctl_clk(wlc_hw, CLK_FAST);
+	wlc_bmac_corereset(wlc_hw, WLC_USE_COREFLAGS);
+
+	if (!wlc_bmac_validate_chip_access(wlc_hw)) {
+		WL_ERROR(("wl%d: wlc_bmac_attach: validate_chip_access failed\n", unit));
+		err = 14;
+		goto fail;
+	}
+
+	/* get the board rev, used just below */
+	j = getintvar(vars, "boardrev");
+	/* promote srom boardrev of 0xFF to 1 */
+	if (j == BOARDREV_PROMOTABLE)
+		j = BOARDREV_PROMOTED;
+	wlc_hw->boardrev = (uint16) j;
+	if (!wlc_validboardtype(wlc_hw)) {
+		WL_ERROR(("wl%d: wlc_bmac_attach: Unsupported Broadcom board type (0x%x)" " or revision level (0x%x)\n", unit, wlc_hw->sih->boardtype, wlc_hw->boardrev));
+		err = 15;
+		goto fail;
+	}
+	wlc_hw->sromrev = (uint8) getintvar(vars, "sromrev");
+	wlc_hw->boardflags = (uint32) getintvar(vars, "boardflags");
+	wlc_hw->boardflags2 = (uint32) getintvar(vars, "boardflags2");
+
+	if (D11REV_LE(wlc_hw->corerev, 4)
+	    || (wlc_hw->boardflags & BFL_NOPLLDOWN))
+		wlc_bmac_pllreq(wlc_hw, TRUE, WLC_PLLREQ_SHARED);
+
+	if ((BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
+	    && (si_pci_war16165(wlc_hw->sih)))
+		wlc->war16165 = TRUE;
+
+	/* check device id(srom, nvram etc.) to set bands */
+	if (wlc_hw->deviceid == BCM43224_D11N_ID) {
+		/* Dualband boards */
+		wlc_hw->_nbands = 2;
+	} else
+		wlc_hw->_nbands = 1;
+
+	if ((CHIPID(wlc_hw->sih->chip) == BCM43225_CHIP_ID))
+		wlc_hw->_nbands = 1;
+
+	/* BMAC_NOTE: remove init of pub values when wlc_attach() unconditionally does the
+	 * init of these values
+	 */
+	wlc->vendorid = wlc_hw->vendorid;
+	wlc->deviceid = wlc_hw->deviceid;
+	wlc->pub->sih = wlc_hw->sih;
+	wlc->pub->corerev = wlc_hw->corerev;
+	wlc->pub->sromrev = wlc_hw->sromrev;
+	wlc->pub->boardrev = wlc_hw->boardrev;
+	wlc->pub->boardflags = wlc_hw->boardflags;
+	wlc->pub->boardflags2 = wlc_hw->boardflags2;
+	wlc->pub->_nbands = wlc_hw->_nbands;
+
+	wlc_hw->physhim = wlc_phy_shim_attach(wlc_hw, wlc->wl, wlc);
+
+	if (wlc_hw->physhim == NULL) {
+		WL_ERROR(("wl%d: wlc_bmac_attach: wlc_phy_shim_attach failed\n",
+			  unit));
+		err = 25;
+		goto fail;
+	}
+
+	/* pass all the parameters to wlc_phy_shared_attach in one struct */
+	sha_params.osh = osh;
+	sha_params.sih = wlc_hw->sih;
+	sha_params.physhim = wlc_hw->physhim;
+	sha_params.unit = unit;
+	sha_params.corerev = wlc_hw->corerev;
+	sha_params.vars = vars;
+	sha_params.vid = wlc_hw->vendorid;
+	sha_params.did = wlc_hw->deviceid;
+	sha_params.chip = wlc_hw->sih->chip;
+	sha_params.chiprev = wlc_hw->sih->chiprev;
+	sha_params.chippkg = wlc_hw->sih->chippkg;
+	sha_params.sromrev = wlc_hw->sromrev;
+	sha_params.boardtype = wlc_hw->sih->boardtype;
+	sha_params.boardrev = wlc_hw->boardrev;
+	sha_params.boardvendor = wlc_hw->sih->boardvendor;
+	sha_params.boardflags = wlc_hw->boardflags;
+	sha_params.boardflags2 = wlc_hw->boardflags2;
+	sha_params.bustype = wlc_hw->sih->bustype;
+	sha_params.buscorerev = wlc_hw->sih->buscorerev;
+
+	/* alloc and save pointer to shared phy state area */
+	wlc_hw->phy_sh = wlc_phy_shared_attach(&sha_params);
+	if (!wlc_hw->phy_sh) {
+		err = 16;
+		goto fail;
+	}
+
+	/* initialize software state for each core and band */
+	for (j = 0; j < NBANDS_HW(wlc_hw); j++) {
+		/*
+		 * band0 is always 2.4Ghz
+		 * band1, if present, is 5Ghz
+		 */
+
+		/* So if this is a single band 11a card, use band 1 */
+		if (IS_SINGLEBAND_5G(wlc_hw->deviceid))
+			j = BAND_5G_INDEX;
+
+		wlc_setxband(wlc_hw, j);
+
+		wlc_hw->band->bandunit = j;
+		wlc_hw->band->bandtype = j ? WLC_BAND_5G : WLC_BAND_2G;
+		wlc->band->bandunit = j;
+		wlc->band->bandtype = j ? WLC_BAND_5G : WLC_BAND_2G;
+		wlc->core->coreidx = si_coreidx(wlc_hw->sih);
+
+		if (D11REV_GE(wlc_hw->corerev, 13)) {
+			wlc_hw->machwcap = R_REG(wlc_hw->osh, &regs->machwcap);
+			wlc_hw->machwcap_backup = wlc_hw->machwcap;
+		}
+
+		/* init tx fifo size */
+		ASSERT((wlc_hw->corerev - XMTFIFOTBL_STARTREV) <
+		       ARRAYSIZE(xmtfifo_sz));
+		wlc_hw->xmtfifo_sz =
+		    xmtfifo_sz[(wlc_hw->corerev - XMTFIFOTBL_STARTREV)];
+
+		/* Get a phy for this band */
+		if ((wlc_hw->band->pi =
+		     wlc_phy_attach(wlc_hw->phy_sh, (void *)(uintptr) regs,
+				    wlc_hw->band->bandtype, vars)) == NULL) {
+			WL_ERROR(("wl%d: wlc_bmac_attach: wlc_phy_attach failed\n", unit));
+			err = 17;
+			goto fail;
+		}
+
+		wlc_phy_machwcap_set(wlc_hw->band->pi, wlc_hw->machwcap);
+
+		wlc_phy_get_phyversion(wlc_hw->band->pi, &wlc_hw->band->phytype,
+				       &wlc_hw->band->phyrev,
+				       &wlc_hw->band->radioid,
+				       &wlc_hw->band->radiorev);
+		wlc_hw->band->abgphy_encore =
+		    wlc_phy_get_encore(wlc_hw->band->pi);
+		wlc->band->abgphy_encore = wlc_phy_get_encore(wlc_hw->band->pi);
+		wlc_hw->band->core_flags =
+		    wlc_phy_get_coreflags(wlc_hw->band->pi);
+
+		/* verify good phy_type & supported phy revision */
+		if (WLCISNPHY(wlc_hw->band)) {
+			if (NCONF_HAS(wlc_hw->band->phyrev))
+				goto good_phy;
+			else
+				goto bad_phy;
+		} else if (WLCISLCNPHY(wlc_hw->band)) {
+			if (LCNCONF_HAS(wlc_hw->band->phyrev))
+				goto good_phy;
+			else
+				goto bad_phy;
+		} else {
+ bad_phy:
+			WL_ERROR(("wl%d: wlc_bmac_attach: unsupported phy type/rev (%d/%d)\n", unit, wlc_hw->band->phytype, wlc_hw->band->phyrev));
+			err = 18;
+			goto fail;
+		}
+
+ good_phy:
+		/* BMAC_NOTE: wlc->band->pi should not be set below and should be done in the
+		 * high level attach. However we can not make that change until all low level access
+		 * is changed to wlc_hw->band->pi. Instead do the wlc->band->pi init below, keeping
+		 * wlc_hw->band->pi as well for incremental update of low level fns, and cut over
+		 * low only init when all fns updated.
+		 */
+		wlc->band->pi = wlc_hw->band->pi;
+		wlc->band->phytype = wlc_hw->band->phytype;
+		wlc->band->phyrev = wlc_hw->band->phyrev;
+		wlc->band->radioid = wlc_hw->band->radioid;
+		wlc->band->radiorev = wlc_hw->band->radiorev;
+
+		/* default contention windows size limits */
+		wlc_hw->band->CWmin = APHY_CWMIN;
+		wlc_hw->band->CWmax = PHY_CWMAX;
+
+		if (!wlc_bmac_attach_dmapio(wlc, j, wme)) {
+			err = 19;
+			goto fail;
+		}
+	}
+
+	/* disable core to match driver "down" state */
+	wlc_coredisable(wlc_hw);
+
+	/* Match driver "down" state */
+	if (BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
+		si_pci_down(wlc_hw->sih);
+
+	/* register sb interrupt callback functions */
+	si_register_intr_callback(wlc_hw->sih, (void *)wlc_wlintrsoff,
+				  (void *)wlc_wlintrsrestore, NULL, wlc);
+
+	/* turn off pll and xtal to match driver "down" state */
+	wlc_bmac_xtal(wlc_hw, OFF);
+
+	/* *********************************************************************
+	 * The hardware is in the DOWN state at this point. D11 core
+	 * or cores are in reset with clocks off, and the board PLLs
+	 * are off if possible.
+	 *
+	 * Beyond this point, wlc->sbclk == FALSE and chip registers
+	 * should not be touched.
+	 *********************************************************************
+	 */
+
+	/* init etheraddr state variables */
+	if ((macaddr = wlc_get_macaddr(wlc_hw)) == NULL) {
+		WL_ERROR(("wl%d: wlc_bmac_attach: macaddr not found\n", unit));
+		err = 21;
+		goto fail;
+	}
+	bcm_ether_atoe(macaddr, &wlc_hw->etheraddr);
+	if (ETHER_ISBCAST((char *)&wlc_hw->etheraddr) ||
+	    ETHER_ISNULLADDR((char *)&wlc_hw->etheraddr)) {
+		WL_ERROR(("wl%d: wlc_bmac_attach: bad macaddr %s\n", unit,
+			  macaddr));
+		err = 22;
+		goto fail;
+	}
+
+	WL_ERROR(("%s:: deviceid 0x%x nbands %d board 0x%x macaddr: %s\n",
+		  __func__, wlc_hw->deviceid, wlc_hw->_nbands,
+		  wlc_hw->sih->boardtype, macaddr));
+
+	return err;
+
+ fail:
+	WL_ERROR(("wl%d: wlc_bmac_attach: failed with err %d\n", unit, err));
+	return err;
+}
+
+/*
+ * Initialize wlc_info default values ...
+ * may get overrides later in this function
+ *  BMAC_NOTES, move low out and resolve the dangling ones
+ */
+void BCMATTACHFN(wlc_bmac_info_init) (wlc_hw_info_t * wlc_hw) {
+	wlc_info_t *wlc = wlc_hw->wlc;
+
+	/* set default sw macintmask value */
+	wlc->defmacintmask = DEF_MACINTMASK;
+
+	/* various 802.11g modes */
+	wlc_hw->shortslot = FALSE;
+
+	wlc_hw->SFBL = RETRY_SHORT_FB;
+	wlc_hw->LFBL = RETRY_LONG_FB;
+
+	/* default mac retry limits */
+	wlc_hw->SRL = RETRY_SHORT_DEF;
+	wlc_hw->LRL = RETRY_LONG_DEF;
+	wlc_hw->chanspec = CH20MHZ_CHSPEC(1);
+}
+
+/*
+ * low level detach
+ */
+int BCMATTACHFN(wlc_bmac_detach) (wlc_info_t * wlc) {
+	uint i;
+	wlc_hwband_t *band;
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	int callbacks;
+
+	callbacks = 0;
+
+	if (wlc_hw->sih) {
+		/* detach interrupt sync mechanism since interrupt is disabled and per-port
+		 * interrupt object may has been freed. this must be done before sb core switch
+		 */
+		si_deregister_intr_callback(wlc_hw->sih);
+
+		if (BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
+			si_pci_sleep(wlc_hw->sih);
+	}
+
+	wlc_bmac_detach_dmapio(wlc_hw);
+
+	band = wlc_hw->band;
+	for (i = 0; i < NBANDS_HW(wlc_hw); i++) {
+		if (band->pi) {
+			/* Detach this band's phy */
+			wlc_phy_detach(band->pi);
+			band->pi = NULL;
+		}
+		band = wlc_hw->bandstate[OTHERBANDUNIT(wlc)];
+	}
+
+	/* Free shared phy state */
+	wlc_phy_shared_detach(wlc_hw->phy_sh);
+
+	wlc_phy_shim_detach(wlc_hw->physhim);
+
+	/* free vars */
+	if (wlc_hw->vars) {
+		MFREE(wlc_hw->osh, wlc_hw->vars, wlc_hw->vars_size);
+		wlc_hw->vars = NULL;
+	}
+
+	if (wlc_hw->sih) {
+		si_detach(wlc_hw->sih);
+		wlc_hw->sih = NULL;
+	}
+
+	return callbacks;
+
+}
+
+void BCMINITFN(wlc_bmac_reset) (wlc_hw_info_t * wlc_hw) {
+	WL_TRACE(("wl%d: wlc_bmac_reset\n", wlc_hw->unit));
+
+	WLCNTINCR(wlc_hw->wlc->pub->_cnt->reset);
+
+	/* reset the core */
+	if (!DEVICEREMOVED(wlc_hw->wlc))
+		wlc_bmac_corereset(wlc_hw, WLC_USE_COREFLAGS);
+
+	/* purge the dma rings */
+	wlc_flushqueues(wlc_hw->wlc);
+
+	wlc_reset_bmac_done(wlc_hw->wlc);
+}
+
+void
+BCMINITFN(wlc_bmac_init) (wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+			  bool mute) {
+	uint32 macintmask;
+	bool fastclk;
+	wlc_info_t *wlc = wlc_hw->wlc;
+
+	WL_TRACE(("wl%d: wlc_bmac_init\n", wlc_hw->unit));
+
+	/* request FAST clock if not on */
+	if (!(fastclk = wlc_hw->forcefastclk))
+		wlc_clkctl_clk(wlc_hw, CLK_FAST);
+
+	/* disable interrupts */
+	macintmask = wl_intrsoff(wlc->wl);
+
+	/* set up the specified band and chanspec */
+	wlc_setxband(wlc_hw, CHSPEC_WLCBANDUNIT(chanspec));
+	wlc_phy_chanspec_radio_set(wlc_hw->band->pi, chanspec);
+
+	/* do one-time phy inits and calibration */
+	wlc_phy_cal_init(wlc_hw->band->pi);
+
+	/* core-specific initialization */
+	wlc_coreinit(wlc);
+
+	/* suspend the tx fifos and mute the phy for preism cac time */
+	if (mute)
+		wlc_bmac_mute(wlc_hw, ON, PHY_MUTE_FOR_PREISM);
+
+	/* band-specific inits */
+	wlc_bmac_bsinit(wlc, chanspec);
+
+	/* restore macintmask */
+	wl_intrsrestore(wlc->wl, macintmask);
+
+	/* seed wake_override with WLC_WAKE_OVERRIDE_MACSUSPEND since the mac is suspended
+	 * and wlc_enable_mac() will clear this override bit.
+	 */
+	mboolset(wlc_hw->wake_override, WLC_WAKE_OVERRIDE_MACSUSPEND);
+
+	/*
+	 * initialize mac_suspend_depth to 1 to match ucode initial suspended state
+	 */
+	wlc_hw->mac_suspend_depth = 1;
+
+	/* restore the clk */
+	if (!fastclk)
+		wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
+}
+
+int BCMINITFN(wlc_bmac_up_prep) (wlc_hw_info_t * wlc_hw) {
+	uint coremask;
+
+	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
+
+	ASSERT(wlc_hw->wlc->pub->hw_up && wlc_hw->wlc->macintmask == 0);
+
+	/*
+	 * Enable pll and xtal, initialize the power control registers,
+	 * and force fastclock for the remainder of wlc_up().
+	 */
+	wlc_bmac_xtal(wlc_hw, ON);
+	si_clkctl_init(wlc_hw->sih);
+	wlc_clkctl_clk(wlc_hw, CLK_FAST);
+
+	/*
+	 * Configure pci/pcmcia here instead of in wlc_attach()
+	 * to allow mfg hotswap:  down, hotswap (chip power cycle), up.
+	 */
+	coremask = (1 << wlc_hw->wlc->core->coreidx);
+
+	if (BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
+		si_pci_setup(wlc_hw->sih, coremask);
+
+	ASSERT(si_coreid(wlc_hw->sih) == D11_CORE_ID);
+
+	/*
+	 * Need to read the hwradio status here to cover the case where the system
+	 * is loaded with the hw radio disabled. We do not want to bring the driver up in this case.
+	 */
+	if (wlc_bmac_radio_read_hwdisabled(wlc_hw)) {
+		/* put SB PCI in down state again */
+		if (BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
+			si_pci_down(wlc_hw->sih);
+		wlc_bmac_xtal(wlc_hw, OFF);
+		return BCME_RADIOOFF;
+	}
+
+	if (BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
+		si_pci_up(wlc_hw->sih);
+
+	/* reset the d11 core */
+	wlc_bmac_corereset(wlc_hw, WLC_USE_COREFLAGS);
+
+	return 0;
+}
+
+int BCMINITFN(wlc_bmac_up_finish) (wlc_hw_info_t * wlc_hw) {
+	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
+
+	wlc_hw->up = TRUE;
+	wlc_phy_hw_state_upd(wlc_hw->band->pi, TRUE);
+
+	/* FULLY enable dynamic power control and d11 core interrupt */
+	wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
+	ASSERT(wlc_hw->wlc->macintmask == 0);
+	wl_intrson(wlc_hw->wlc->wl);
+	return 0;
+}
+
+int BCMUNINITFN(wlc_bmac_down_prep) (wlc_hw_info_t * wlc_hw) {
+	bool dev_gone;
+	uint callbacks = 0;
+
+	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
+
+	if (!wlc_hw->up)
+		return callbacks;
+
+	dev_gone = DEVICEREMOVED(wlc_hw->wlc);
+
+	/* disable interrupts */
+	if (dev_gone)
+		wlc_hw->wlc->macintmask = 0;
+	else {
+		/* now disable interrupts */
+		wl_intrsoff(wlc_hw->wlc->wl);
+
+		/* ensure we're running on the pll clock again */
+		wlc_clkctl_clk(wlc_hw, CLK_FAST);
+	}
+	/* down phy at the last of this stage */
+	callbacks += wlc_phy_down(wlc_hw->band->pi);
+
+	return callbacks;
+}
+
+int BCMUNINITFN(wlc_bmac_down_finish) (wlc_hw_info_t * wlc_hw) {
+	uint callbacks = 0;
+	bool dev_gone;
+
+	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
+
+	if (!wlc_hw->up)
+		return callbacks;
+
+	wlc_hw->up = FALSE;
+	wlc_phy_hw_state_upd(wlc_hw->band->pi, FALSE);
+
+	dev_gone = DEVICEREMOVED(wlc_hw->wlc);
+
+	if (dev_gone) {
+		wlc_hw->sbclk = FALSE;
+		wlc_hw->clk = FALSE;
+		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+
+		/* reclaim any posted packets */
+		wlc_flushqueues(wlc_hw->wlc);
+	} else {
+
+		/* Reset and disable the core */
+		if (si_iscoreup(wlc_hw->sih)) {
+			if (R_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol) &
+			    MCTL_EN_MAC)
+				wlc_suspend_mac_and_wait(wlc_hw->wlc);
+			callbacks += wl_reset(wlc_hw->wlc->wl);
+			wlc_coredisable(wlc_hw);
+		}
+
+		/* turn off primary xtal and pll */
+		if (!wlc_hw->noreset) {
+			if (BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS)
+				si_pci_down(wlc_hw->sih);
+			wlc_bmac_xtal(wlc_hw, OFF);
+		}
+	}
+
+	return callbacks;
+}
+
+void wlc_bmac_wait_for_wake(wlc_hw_info_t * wlc_hw)
+{
+	if (D11REV_IS(wlc_hw->corerev, 4))	/* no slowclock */
+		OSL_DELAY(5);
+	else {
+		/* delay before first read of ucode state */
+		OSL_DELAY(40);
+
+		/* wait until ucode is no longer asleep */
+		SPINWAIT((wlc_bmac_read_shm(wlc_hw, M_UCODE_DBGST) ==
+			  DBGST_ASLEEP), wlc_hw->wlc->fastpwrup_dly);
+	}
+
+	ASSERT(wlc_bmac_read_shm(wlc_hw, M_UCODE_DBGST) != DBGST_ASLEEP);
+}
+
+void wlc_bmac_hw_etheraddr(wlc_hw_info_t * wlc_hw, struct ether_addr *ea)
+{
+	bcopy(&wlc_hw->etheraddr, ea, ETHER_ADDR_LEN);
+}
+
+void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t * wlc_hw, struct ether_addr *ea)
+{
+	bcopy(ea, &wlc_hw->etheraddr, ETHER_ADDR_LEN);
+}
+
+int wlc_bmac_bandtype(wlc_hw_info_t * wlc_hw)
+{
+	return (wlc_hw->band->bandtype);
+}
+
+void *wlc_cur_phy(wlc_info_t * wlc)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	return ((void *)wlc_hw->band->pi);
+}
+
+/* control chip clock to save power, enable dynamic clock or force fast clock */
+static void wlc_clkctl_clk(wlc_hw_info_t * wlc_hw, uint mode)
+{
+	if (PMUCTL_ENAB(wlc_hw->sih)) {
+		/* new chips with PMU, CCS_FORCEHT will distribute the HT clock on backplane,
+		 *  but mac core will still run on ALP(not HT) when it enters powersave mode,
+		 *      which means the FCA bit may not be set.
+		 *      should wakeup mac if driver wants it to run on HT.
+		 */
+
+		if (wlc_hw->clk) {
+			if (mode == CLK_FAST) {
+				OR_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
+				       CCS_FORCEHT);
+
+				OSL_DELAY(64);
+
+				SPINWAIT(((R_REG
+					   (wlc_hw->osh,
+					    &wlc_hw->regs->
+					    clk_ctl_st) & CCS_HTAVAIL) == 0),
+					 PMU_MAX_TRANSITION_DLY);
+				ASSERT(R_REG
+				       (wlc_hw->osh,
+					&wlc_hw->regs->
+					clk_ctl_st) & CCS_HTAVAIL);
+			} else {
+				if ((wlc_hw->sih->pmurev == 0) &&
+				    (R_REG
+				     (wlc_hw->osh,
+				      &wlc_hw->regs->
+				      clk_ctl_st) & (CCS_FORCEHT | CCS_HTAREQ)))
+					SPINWAIT(((R_REG
+						   (wlc_hw->osh,
+						    &wlc_hw->regs->
+						    clk_ctl_st) & CCS_HTAVAIL)
+						  == 0),
+						 PMU_MAX_TRANSITION_DLY);
+				AND_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
+					~CCS_FORCEHT);
+			}
+		}
+		wlc_hw->forcefastclk = (mode == CLK_FAST);
+	} else {
+		bool wakeup_ucode;
+
+		/* old chips w/o PMU, force HT through cc,
+		 * then use FCA to verify mac is running fast clock
+		 */
+
+		wakeup_ucode = D11REV_LT(wlc_hw->corerev, 9);
+
+		if (wlc_hw->up && wakeup_ucode)
+			wlc_ucode_wake_override_set(wlc_hw,
+						    WLC_WAKE_OVERRIDE_CLKCTL);
+
+		wlc_hw->forcefastclk = si_clkctl_cc(wlc_hw->sih, mode);
+
+		if (D11REV_LT(wlc_hw->corerev, 11)) {
+			/* ucode WAR for old chips */
+			if (wlc_hw->forcefastclk)
+				wlc_bmac_mhf(wlc_hw, MHF1, MHF1_FORCEFASTCLK,
+					     MHF1_FORCEFASTCLK, WLC_BAND_ALL);
+			else
+				wlc_bmac_mhf(wlc_hw, MHF1, MHF1_FORCEFASTCLK, 0,
+					     WLC_BAND_ALL);
+		}
+
+		/* check fast clock is available (if core is not in reset) */
+		if (D11REV_GT(wlc_hw->corerev, 4) && wlc_hw->forcefastclk
+		    && wlc_hw->clk)
+			ASSERT(si_core_sflags(wlc_hw->sih, 0, 0) & SISF_FCLKA);
+
+		/* keep the ucode wake bit on if forcefastclk is on
+		 * since we do not want ucode to put us back to slow clock
+		 * when it dozes for PM mode.
+		 * Code below matches the wake override bit with current forcefastclk state
+		 * Only setting bit in wake_override instead of waking ucode immediately
+		 * since old code (wlc.c 1.4499) had this behavior. Older code set
+		 * wlc->forcefastclk but only had the wake happen if the wakup_ucode work
+		 * (protected by an up check) was executed just below.
+		 */
+		if (wlc_hw->forcefastclk)
+			mboolset(wlc_hw->wake_override,
+				 WLC_WAKE_OVERRIDE_FORCEFAST);
+		else
+			mboolclr(wlc_hw->wake_override,
+				 WLC_WAKE_OVERRIDE_FORCEFAST);
+
+		/* ok to clear the wakeup now */
+		if (wlc_hw->up && wakeup_ucode)
+			wlc_ucode_wake_override_clear(wlc_hw,
+						      WLC_WAKE_OVERRIDE_CLKCTL);
+	}
+}
+
+/* set initial host flags value */
+static void
+BCMINITFN(wlc_mhfdef) (wlc_info_t * wlc, uint16 * mhfs, uint16 mhf2_init) {
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+
+	bzero(mhfs, sizeof(uint16) * MHFMAX);
+
+	mhfs[MHF2] |= mhf2_init;
+
+	/* prohibit use of slowclock on multifunction boards */
+	if (wlc_hw->boardflags & BFL_NOPLLDOWN)
+		mhfs[MHF1] |= MHF1_FORCEFASTCLK;
+
+	if (WLCISNPHY(wlc_hw->band) && NREV_LT(wlc_hw->band->phyrev, 2)) {
+		mhfs[MHF2] |= MHF2_NPHY40MHZ_WAR;
+		mhfs[MHF1] |= MHF1_IQSWAP_WAR;
+	}
+}
+
+/* set or clear ucode host flag bits
+ * it has an optimization for no-change write
+ * it only writes through shared memory when the core has clock;
+ * pre-CLK changes should use wlc_write_mhf to get around the optimization
+ *
+ *
+ * bands values are: WLC_BAND_AUTO <--- Current band only
+ *                   WLC_BAND_5G   <--- 5G band only
+ *                   WLC_BAND_2G   <--- 2G band only
+ *                   WLC_BAND_ALL  <--- All bands
+ */
+void
+wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask, uint16 val,
+	     int bands)
+{
+	uint16 save;
+	uint16 addr[MHFMAX] =
+	    { M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
+		M_HOST_FLAGS5
+	};
+	wlc_hwband_t *band;
+
+	ASSERT((val & ~mask) == 0);
+	ASSERT(idx < MHFMAX);
+	ASSERT(ARRAYSIZE(addr) == MHFMAX);
+
+	switch (bands) {
+		/* Current band only or all bands,
+		 * then set the band to current band
+		 */
+	case WLC_BAND_AUTO:
+	case WLC_BAND_ALL:
+		band = wlc_hw->band;
+		break;
+	case WLC_BAND_5G:
+		band = wlc_hw->bandstate[BAND_5G_INDEX];
+		break;
+	case WLC_BAND_2G:
+		band = wlc_hw->bandstate[BAND_2G_INDEX];
+		break;
+	default:
+		ASSERT(0);
+		band = NULL;
+	}
+
+	if (band) {
+		save = band->mhfs[idx];
+		band->mhfs[idx] = (band->mhfs[idx] & ~mask) | val;
+
+		/* optimization: only write through if changed, and
+		 * changed band is the current band
+		 */
+		if (wlc_hw->clk && (band->mhfs[idx] != save)
+		    && (band == wlc_hw->band))
+			wlc_bmac_write_shm(wlc_hw, addr[idx],
+					   (uint16) band->mhfs[idx]);
+	}
+
+	if (bands == WLC_BAND_ALL) {
+		wlc_hw->bandstate[0]->mhfs[idx] =
+		    (wlc_hw->bandstate[0]->mhfs[idx] & ~mask) | val;
+		wlc_hw->bandstate[1]->mhfs[idx] =
+		    (wlc_hw->bandstate[1]->mhfs[idx] & ~mask) | val;
+	}
+}
+
+uint16 wlc_bmac_mhf_get(wlc_hw_info_t * wlc_hw, uint8 idx, int bands)
+{
+	wlc_hwband_t *band;
+	ASSERT(idx < MHFMAX);
+
+	switch (bands) {
+	case WLC_BAND_AUTO:
+		band = wlc_hw->band;
+		break;
+	case WLC_BAND_5G:
+		band = wlc_hw->bandstate[BAND_5G_INDEX];
+		break;
+	case WLC_BAND_2G:
+		band = wlc_hw->bandstate[BAND_2G_INDEX];
+		break;
+	default:
+		ASSERT(0);
+		band = NULL;
+	}
+
+	if (!band)
+		return 0;
+
+	return band->mhfs[idx];
+}
+
+static void wlc_write_mhf(wlc_hw_info_t * wlc_hw, uint16 * mhfs)
+{
+	uint8 idx;
+	uint16 addr[] =
+	    { M_HOST_FLAGS1, M_HOST_FLAGS2, M_HOST_FLAGS3, M_HOST_FLAGS4,
+		M_HOST_FLAGS5
+	};
+
+	ASSERT(ARRAYSIZE(addr) == MHFMAX);
+
+	for (idx = 0; idx < MHFMAX; idx++) {
+		wlc_bmac_write_shm(wlc_hw, addr[idx], mhfs[idx]);
+	}
+}
+
+/* set the maccontrol register to desired reset state and
+ * initialize the sw cache of the register
+ */
+static void wlc_mctrl_reset(wlc_hw_info_t * wlc_hw)
+{
+	/* IHR accesses are always enabled, PSM disabled, HPS off and WAKE on */
+	wlc_hw->maccontrol = 0;
+	wlc_hw->suspended_fifos = 0;
+	wlc_hw->wake_override = 0;
+	wlc_hw->mute_override = 0;
+	wlc_bmac_mctrl(wlc_hw, ~0, MCTL_IHR_EN | MCTL_WAKE);
+}
+
+/* set or clear maccontrol bits */
+void wlc_bmac_mctrl(wlc_hw_info_t * wlc_hw, uint32 mask, uint32 val)
+{
+	uint32 maccontrol;
+	uint32 new_maccontrol;
+
+	ASSERT((val & ~mask) == 0);
+
+	maccontrol = wlc_hw->maccontrol;
+	new_maccontrol = (maccontrol & ~mask) | val;
+
+	/* if the new maccontrol value is the same as the old, nothing to do */
+	if (new_maccontrol == maccontrol)
+		return;
+
+	/* something changed, cache the new value */
+	wlc_hw->maccontrol = new_maccontrol;
+
+	/* write the new values with overrides applied */
+	wlc_mctrl_write(wlc_hw);
+}
+
+/* write the software state of maccontrol and overrides to the maccontrol register */
+static void wlc_mctrl_write(wlc_hw_info_t * wlc_hw)
+{
+	uint32 maccontrol = wlc_hw->maccontrol;
+
+	/* OR in the wake bit if overridden */
+	if (wlc_hw->wake_override)
+		maccontrol |= MCTL_WAKE;
+
+	/* set AP and INFRA bits for mute if needed */
+	if (wlc_hw->mute_override) {
+		maccontrol &= ~(MCTL_AP);
+		maccontrol |= MCTL_INFRA;
+	}
+
+	W_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol, maccontrol);
+}
+
+void wlc_ucode_wake_override_set(wlc_hw_info_t * wlc_hw, uint32 override_bit)
+{
+	ASSERT((wlc_hw->wake_override & override_bit) == 0);
+
+	if (wlc_hw->wake_override || (wlc_hw->maccontrol & MCTL_WAKE)) {
+		mboolset(wlc_hw->wake_override, override_bit);
+		return;
+	}
+
+	mboolset(wlc_hw->wake_override, override_bit);
+
+	wlc_mctrl_write(wlc_hw);
+	wlc_bmac_wait_for_wake(wlc_hw);
+
+	return;
+}
+
+void wlc_ucode_wake_override_clear(wlc_hw_info_t * wlc_hw, uint32 override_bit)
+{
+	ASSERT(wlc_hw->wake_override & override_bit);
+
+	mboolclr(wlc_hw->wake_override, override_bit);
+
+	if (wlc_hw->wake_override || (wlc_hw->maccontrol & MCTL_WAKE))
+		return;
+
+	wlc_mctrl_write(wlc_hw);
+
+	return;
+}
+
+/* When driver needs ucode to stop beaconing, it has to make sure that
+ * MCTL_AP is clear and MCTL_INFRA is set
+ * Mode           MCTL_AP        MCTL_INFRA
+ * AP                1              1
+ * STA               0              1 <--- This will ensure no beacons
+ * IBSS              0              0
+ */
+static void wlc_ucode_mute_override_set(wlc_hw_info_t * wlc_hw)
+{
+	wlc_hw->mute_override = 1;
+
+	/* if maccontrol already has AP == 0 and INFRA == 1 without this
+	 * override, then there is no change to write
+	 */
+	if ((wlc_hw->maccontrol & (MCTL_AP | MCTL_INFRA)) == MCTL_INFRA)
+		return;
+
+	wlc_mctrl_write(wlc_hw);
+
+	return;
+}
+
+/* Clear the override on AP and INFRA bits */
+static void wlc_ucode_mute_override_clear(wlc_hw_info_t * wlc_hw)
+{
+	if (wlc_hw->mute_override == 0)
+		return;
+
+	wlc_hw->mute_override = 0;
+
+	/* if maccontrol already has AP == 0 and INFRA == 1 without this
+	 * override, then there is no change to write
+	 */
+	if ((wlc_hw->maccontrol & (MCTL_AP | MCTL_INFRA)) == MCTL_INFRA)
+		return;
+
+	wlc_mctrl_write(wlc_hw);
+}
+
+/*
+ * Write a MAC address to the rcmta structure
+ */
+void
+wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_hw, int idx,
+		   const struct ether_addr *addr)
+{
+	d11regs_t *regs = wlc_hw->regs;
+	volatile uint16 *objdata16 =
+	    (volatile uint16 *)(uintptr) & regs->objdata;
+	uint32 mac_hm;
+	uint16 mac_l;
+	osl_t *osh;
+
+	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
+
+	ASSERT(wlc_hw->corerev > 4);
+
+	mac_hm =
+	    (addr->octet[3] << 24) | (addr->octet[2] << 16) | (addr->
+							       octet[1] << 8) |
+	    addr->octet[0];
+	mac_l = (addr->octet[5] << 8) | addr->octet[4];
+
+	osh = wlc_hw->osh;
+
+	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | (idx * 2)));
+	(void)R_REG(osh, &regs->objaddr);
+	W_REG(osh, &regs->objdata, mac_hm);
+	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | ((idx * 2) + 1)));
+	(void)R_REG(osh, &regs->objaddr);
+	W_REG(osh, objdata16, mac_l);
+}
+
+/*
+ * Write a MAC address to the given match reg offset in the RXE match engine.
+ */
+void
+wlc_bmac_set_addrmatch(wlc_hw_info_t * wlc_hw, int match_reg_offset,
+		       const struct ether_addr *addr)
+{
+	d11regs_t *regs;
+	uint16 mac_l;
+	uint16 mac_m;
+	uint16 mac_h;
+	osl_t *osh;
+
+	WL_TRACE(("wl%d: wlc_bmac_set_addrmatch\n", wlc_hw->unit));
+
+	ASSERT((match_reg_offset < RCM_SIZE) || (wlc_hw->corerev == 4));
+
+	regs = wlc_hw->regs;
+	mac_l = addr->octet[0] | (addr->octet[1] << 8);
+	mac_m = addr->octet[2] | (addr->octet[3] << 8);
+	mac_h = addr->octet[4] | (addr->octet[5] << 8);
+
+	osh = wlc_hw->osh;
+
+	/* enter the MAC addr into the RXE match registers */
+	W_REG(osh, &regs->rcm_ctl, RCM_INC_DATA | match_reg_offset);
+	W_REG(osh, &regs->rcm_mat_data, mac_l);
+	W_REG(osh, &regs->rcm_mat_data, mac_m);
+	W_REG(osh, &regs->rcm_mat_data, mac_h);
+
+}
+
+void
+wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset, int len,
+			    void *buf)
+{
+	d11regs_t *regs;
+	uint32 word;
+	bool be_bit;
+#ifdef IL_BIGENDIAN
+	volatile uint16 *dptr = NULL;
+#endif				/* IL_BIGENDIAN */
+	osl_t *osh;
+
+	WL_TRACE(("wl%d: wlc_bmac_write_template_ram\n", wlc_hw->unit));
+
+	regs = wlc_hw->regs;
+	osh = wlc_hw->osh;
+
+	ASSERT(ISALIGNED(offset, sizeof(uint32)));
+	ASSERT(ISALIGNED(len, sizeof(uint32)));
+	ASSERT((offset & ~0xffff) == 0);
+
+	W_REG(osh, &regs->tplatewrptr, offset);
+
+	/* if MCTL_BIGEND bit set in mac control register,
+	 * the chip swaps data in fifo, as well as data in
+	 * template ram
+	 */
+	be_bit = (R_REG(osh, &regs->maccontrol) & MCTL_BIGEND) != 0;
+
+	while (len > 0) {
+		bcopy((uint8 *) buf, &word, sizeof(uint32));
+
+		if (be_bit)
+			word = hton32(word);
+		else
+			word = htol32(word);
+
+		W_REG(osh, &regs->tplatewrdata, word);
+
+		buf = (uint8 *) buf + sizeof(uint32);
+		len -= sizeof(uint32);
+	}
+}
+
+void wlc_bmac_set_cwmin(wlc_hw_info_t * wlc_hw, uint16 newmin)
+{
+	osl_t *osh;
+
+	osh = wlc_hw->osh;
+	wlc_hw->band->CWmin = newmin;
+
+	W_REG(osh, &wlc_hw->regs->objaddr, OBJADDR_SCR_SEL | S_DOT11_CWMIN);
+	(void)R_REG(osh, &wlc_hw->regs->objaddr);
+	W_REG(osh, &wlc_hw->regs->objdata, newmin);
+}
+
+void wlc_bmac_set_cwmax(wlc_hw_info_t * wlc_hw, uint16 newmax)
+{
+	osl_t *osh;
+
+	osh = wlc_hw->osh;
+	wlc_hw->band->CWmax = newmax;
+
+	W_REG(osh, &wlc_hw->regs->objaddr, OBJADDR_SCR_SEL | S_DOT11_CWMAX);
+	(void)R_REG(osh, &wlc_hw->regs->objaddr);
+	W_REG(osh, &wlc_hw->regs->objdata, newmax);
+}
+
+void wlc_bmac_bw_set(wlc_hw_info_t * wlc_hw, uint16 bw)
+{
+	bool fastclk;
+	uint32 tmp;
+
+	/* request FAST clock if not on */
+	if (!(fastclk = wlc_hw->forcefastclk))
+		wlc_clkctl_clk(wlc_hw, CLK_FAST);
+
+	wlc_phy_bw_state_set(wlc_hw->band->pi, bw);
+
+	ASSERT(wlc_hw->clk);
+	if (D11REV_LT(wlc_hw->corerev, 17))
+		tmp = R_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol);
+
+	wlc_bmac_phy_reset(wlc_hw);
+	wlc_phy_init(wlc_hw->band->pi, wlc_phy_chanspec_get(wlc_hw->band->pi));
+
+	/* restore the clk */
+	if (!fastclk)
+		wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
+}
+
+static void
+wlc_write_hw_bcntemplate0(wlc_hw_info_t * wlc_hw, void *bcn, int len)
+{
+	d11regs_t *regs = wlc_hw->regs;
+
+	wlc_bmac_write_template_ram(wlc_hw, T_BCN0_TPL_BASE, (len + 3) & ~3,
+				    bcn);
+	/* write beacon length to SCR */
+	ASSERT(len < 65536);
+	wlc_bmac_write_shm(wlc_hw, M_BCN0_FRM_BYTESZ, (uint16) len);
+	/* mark beacon0 valid */
+	OR_REG(wlc_hw->osh, &regs->maccommand, MCMD_BCN0VLD);
+}
+
+static void
+wlc_write_hw_bcntemplate1(wlc_hw_info_t * wlc_hw, void *bcn, int len)
+{
+	d11regs_t *regs = wlc_hw->regs;
+
+	wlc_bmac_write_template_ram(wlc_hw, T_BCN1_TPL_BASE, (len + 3) & ~3,
+				    bcn);
+	/* write beacon length to SCR */
+	ASSERT(len < 65536);
+	wlc_bmac_write_shm(wlc_hw, M_BCN1_FRM_BYTESZ, (uint16) len);
+	/* mark beacon1 valid */
+	OR_REG(wlc_hw->osh, &regs->maccommand, MCMD_BCN1VLD);
+}
+
+/* mac is assumed to be suspended at this point */
+void
+wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t * wlc_hw, void *bcn, int len,
+			       bool both)
+{
+	d11regs_t *regs = wlc_hw->regs;
+
+	if (both) {
+		wlc_write_hw_bcntemplate0(wlc_hw, bcn, len);
+		wlc_write_hw_bcntemplate1(wlc_hw, bcn, len);
+	} else {
+		/* bcn 0 */
+		if (!(R_REG(wlc_hw->osh, &regs->maccommand) & MCMD_BCN0VLD))
+			wlc_write_hw_bcntemplate0(wlc_hw, bcn, len);
+		/* bcn 1 */
+		else if (!
+			 (R_REG(wlc_hw->osh, &regs->maccommand) & MCMD_BCN1VLD))
+			wlc_write_hw_bcntemplate1(wlc_hw, bcn, len);
+		else		/* one template should always have been available */
+			ASSERT(0);
+	}
+}
+
+static void WLBANDINITFN(wlc_bmac_upd_synthpu) (wlc_hw_info_t * wlc_hw) {
+	uint16 v;
+	wlc_info_t *wlc = wlc_hw->wlc;
+	/* update SYNTHPU_DLY */
+
+	if (WLCISLCNPHY(wlc->band)) {
+		v = SYNTHPU_DLY_LPPHY_US;
+	} else if (WLCISNPHY(wlc->band) && (NREV_GE(wlc->band->phyrev, 3))) {
+		v = SYNTHPU_DLY_NPHY_US;
+	} else {
+		v = SYNTHPU_DLY_BPHY_US;
+	}
+
+	wlc_bmac_write_shm(wlc_hw, M_SYNTHPU_DLY, v);
+}
+
+/* band-specific init */
+static void
+WLBANDINITFN(wlc_bmac_bsinit) (wlc_info_t * wlc, chanspec_t chanspec) {
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+
+	WL_TRACE(("wl%d: wlc_bmac_bsinit: bandunit %d\n", wlc_hw->unit,
+		  wlc_hw->band->bandunit));
+
+	/* sanity check */
+	if (PHY_TYPE(R_REG(wlc_hw->osh, &wlc_hw->regs->phyversion)) !=
+	    PHY_TYPE_LCNXN)
+		ASSERT((uint)
+		       PHY_TYPE(R_REG(wlc_hw->osh, &wlc_hw->regs->phyversion))
+		       == wlc_hw->band->phytype);
+
+	wlc_ucode_bsinit(wlc_hw);
+
+	wlc_phy_init(wlc_hw->band->pi, chanspec);
+
+	wlc_ucode_txant_set(wlc_hw);
+
+	/* cwmin is band-specific, update hardware with value for current band */
+	wlc_bmac_set_cwmin(wlc_hw, wlc_hw->band->CWmin);
+	wlc_bmac_set_cwmax(wlc_hw, wlc_hw->band->CWmax);
+
+	wlc_bmac_update_slot_timing(wlc_hw,
+				    BAND_5G(wlc_hw->band->
+					    bandtype) ? TRUE : wlc_hw->
+				    shortslot);
+
+	/* write phytype and phyvers */
+	wlc_bmac_write_shm(wlc_hw, M_PHYTYPE, (uint16) wlc_hw->band->phytype);
+	wlc_bmac_write_shm(wlc_hw, M_PHYVER, (uint16) wlc_hw->band->phyrev);
+
+	/* initialize the txphyctl1 rate table since shmem is shared between bands */
+	wlc_upd_ofdm_pctl1_table(wlc_hw);
+
+	wlc_bmac_upd_synthpu(wlc_hw);
+}
+
+void wlc_bmac_core_phy_clk(wlc_hw_info_t * wlc_hw, bool clk)
+{
+	WL_TRACE(("wl%d: wlc_bmac_core_phy_clk: clk %d\n", wlc_hw->unit, clk));
+
+	wlc_hw->phyclk = clk;
+
+	if (OFF == clk) {	/* clear gmode bit, put phy into reset */
+
+		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_FGC | SICF_GMODE),
+			       (SICF_PRST | SICF_FGC));
+		OSL_DELAY(1);
+		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_FGC), SICF_PRST);
+		OSL_DELAY(1);
+
+	} else {		/* take phy out of reset */
+
+		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_FGC), SICF_FGC);
+		OSL_DELAY(1);
+		si_core_cflags(wlc_hw->sih, (SICF_FGC), 0);
+		OSL_DELAY(1);
+
+	}
+}
+
+/* Perform a soft reset of the PHY PLL */
+void wlc_bmac_core_phypll_reset(wlc_hw_info_t * wlc_hw)
+{
+	WL_TRACE(("wl%d: wlc_bmac_core_phypll_reset\n", wlc_hw->unit));
+
+	si_corereg(wlc_hw->sih, SI_CC_IDX,
+		   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0, 0);
+	OSL_DELAY(1);
+	si_corereg(wlc_hw->sih, SI_CC_IDX,
+		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 0);
+	OSL_DELAY(1);
+	si_corereg(wlc_hw->sih, SI_CC_IDX,
+		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 4);
+	OSL_DELAY(1);
+	si_corereg(wlc_hw->sih, SI_CC_IDX,
+		   OFFSETOF(chipcregs_t, chipcontrol_data), 0x4, 0);
+	OSL_DELAY(1);
+}
+
+/* light way to turn on phy clock without reset for NPHY only
+ *  refer to wlc_bmac_core_phy_clk for full version
+ */
+void wlc_bmac_phyclk_fgc(wlc_hw_info_t * wlc_hw, bool clk)
+{
+	/* support(necessary for NPHY and HYPHY) only */
+	if (!WLCISNPHY(wlc_hw->band))
+		return;
+
+	if (ON == clk)
+		si_core_cflags(wlc_hw->sih, SICF_FGC, SICF_FGC);
+	else
+		si_core_cflags(wlc_hw->sih, SICF_FGC, 0);
+
+}
+
+void wlc_bmac_macphyclk_set(wlc_hw_info_t * wlc_hw, bool clk)
+{
+	if (ON == clk)
+		si_core_cflags(wlc_hw->sih, SICF_MPCLKE, SICF_MPCLKE);
+	else
+		si_core_cflags(wlc_hw->sih, SICF_MPCLKE, 0);
+}
+
+void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw)
+{
+	wlc_phy_t *pih = wlc_hw->band->pi;
+	uint32 phy_bw_clkbits;
+	bool phy_in_reset = FALSE;
+
+	WL_TRACE(("wl%d: wlc_bmac_phy_reset\n", wlc_hw->unit));
+
+	if (pih == NULL)
+		return;
+
+	phy_bw_clkbits = wlc_phy_clk_bwbits(wlc_hw->band->pi);
+
+	/* Specfic reset sequence required for NPHY rev 3 and 4 */
+	if (WLCISNPHY(wlc_hw->band) && NREV_GE(wlc_hw->band->phyrev, 3) &&
+	    NREV_LE(wlc_hw->band->phyrev, 4)) {
+		/* Set the PHY bandwidth */
+		si_core_cflags(wlc_hw->sih, SICF_BWMASK, phy_bw_clkbits);
+
+		OSL_DELAY(1);
+
+		/* Perform a soft reset of the PHY PLL */
+		wlc_bmac_core_phypll_reset(wlc_hw);
+
+		/* reset the PHY */
+		si_core_cflags(wlc_hw->sih, (SICF_PRST | SICF_PCLKE),
+			       (SICF_PRST | SICF_PCLKE));
+		phy_in_reset = TRUE;
+	} else {
+
+		si_core_cflags(wlc_hw->sih,
+			       (SICF_PRST | SICF_PCLKE | SICF_BWMASK),
+			       (SICF_PRST | SICF_PCLKE | phy_bw_clkbits));
+	}
+
+	OSL_DELAY(2);
+	wlc_bmac_core_phy_clk(wlc_hw, ON);
+
+	if (pih)
+		wlc_phy_anacore(pih, ON);
+}
+
+/* switch to and initialize new band */
+static void
+WLBANDINITFN(wlc_bmac_setband) (wlc_hw_info_t * wlc_hw, uint bandunit,
+				chanspec_t chanspec) {
+	wlc_info_t *wlc = wlc_hw->wlc;
+	uint32 macintmask;
+
+	ASSERT(NBANDS_HW(wlc_hw) > 1);
+	ASSERT(bandunit != wlc_hw->band->bandunit);
+
+	/* Enable the d11 core before accessing it */
+	if (!si_iscoreup(wlc_hw->sih)) {
+		si_core_reset(wlc_hw->sih, 0, 0);
+		ASSERT(si_iscoreup(wlc_hw->sih));
+		wlc_mctrl_reset(wlc_hw);
+	}
+
+	macintmask = wlc_setband_inact(wlc, bandunit);
+
+	if (!wlc_hw->up)
+		return;
+
+	wlc_bmac_core_phy_clk(wlc_hw, ON);
+
+	/* band-specific initializations */
+	wlc_bmac_bsinit(wlc, chanspec);
+
+	/*
+	 * If there are any pending software interrupt bits,
+	 * then replace these with a harmless nonzero value
+	 * so wlc_dpc() will re-enable interrupts when done.
+	 */
+	if (wlc->macintstatus)
+		wlc->macintstatus = MI_DMAINT;
+
+	/* restore macintmask */
+	wl_intrsrestore(wlc->wl, macintmask);
+
+	/* ucode should still be suspended.. */
+	ASSERT((R_REG(wlc_hw->osh, &wlc_hw->regs->maccontrol) & MCTL_EN_MAC) ==
+	       0);
+}
+
+/* low-level band switch utility routine */
+void WLBANDINITFN(wlc_setxband) (wlc_hw_info_t * wlc_hw, uint bandunit) {
+	WL_TRACE(("wl%d: wlc_setxband: bandunit %d\n", wlc_hw->unit, bandunit));
+
+	wlc_hw->band = wlc_hw->bandstate[bandunit];
+
+	/* BMAC_NOTE: until we eliminate need for wlc->band refs in low level code */
+	wlc_hw->wlc->band = wlc_hw->wlc->bandstate[bandunit];
+
+	/* set gmode core flag */
+	if (wlc_hw->sbclk && !wlc_hw->noreset) {
+		si_core_cflags(wlc_hw->sih, SICF_GMODE,
+			       ((bandunit == 0) ? SICF_GMODE : 0));
+	}
+}
+
+static bool BCMATTACHFN(wlc_isgoodchip) (wlc_hw_info_t * wlc_hw) {
+
+	/* reject unsupported corerev */
+	if (!VALID_COREREV(wlc_hw->corerev)) {
+		WL_ERROR(("unsupported core rev %d\n", wlc_hw->corerev));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static bool BCMATTACHFN(wlc_validboardtype) (wlc_hw_info_t * wlc_hw) {
+	bool goodboard = TRUE;
+	uint boardrev = wlc_hw->boardrev;
+
+	if (boardrev == 0)
+		goodboard = FALSE;
+	else if (boardrev > 0xff) {
+		uint brt = (boardrev & 0xf000) >> 12;
+		uint b0 = (boardrev & 0xf00) >> 8;
+		uint b1 = (boardrev & 0xf0) >> 4;
+		uint b2 = boardrev & 0xf;
+
+		if ((brt > 2) || (brt == 0) || (b0 > 9) || (b0 == 0) || (b1 > 9)
+		    || (b2 > 9))
+			goodboard = FALSE;
+	}
+
+	if (wlc_hw->sih->boardvendor != VENDOR_BROADCOM)
+		return goodboard;
+
+	return goodboard;
+}
+
+static char *BCMINITFN(wlc_get_macaddr) (wlc_hw_info_t * wlc_hw) {
+	const char *varname = "macaddr";
+	char *macaddr;
+
+	/* If macaddr exists, use it (Sromrev4, CIS, ...). */
+	if ((macaddr = getvar(wlc_hw->vars, varname)) != NULL)
+		return macaddr;
+
+	if (NBANDS_HW(wlc_hw) > 1)
+		varname = "et1macaddr";
+	else
+		varname = "il0macaddr";
+
+	if ((macaddr = getvar(wlc_hw->vars, varname)) == NULL) {
+		WL_ERROR(("wl%d: wlc_get_macaddr: macaddr getvar(%s) not found\n", wlc_hw->unit, varname));
+	}
+
+	return macaddr;
+}
+
+/*
+ * Return TRUE if radio is disabled, otherwise FALSE.
+ * hw radio disable signal is an external pin, users activate it asynchronously
+ * this function could be called when driver is down and w/o clock
+ * it operates on different registers depending on corerev and boardflag.
+ */
+bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t * wlc_hw)
+{
+	bool v, clk, xtal;
+	uint32 resetbits = 0, flags = 0;
+
+	xtal = wlc_hw->sbclk;
+	if (!xtal)
+		wlc_bmac_xtal(wlc_hw, ON);
+
+	/* may need to take core out of reset first */
+	clk = wlc_hw->clk;
+	if (!clk) {
+		if (D11REV_LE(wlc_hw->corerev, 11))
+			resetbits |= SICF_PCLKE;
+
+		/*
+		 * corerev >= 18, mac no longer enables phyclk automatically when driver accesses
+		 * phyreg throughput mac. This can be skipped since only mac reg is accessed below
+		 */
+		if (D11REV_GE(wlc_hw->corerev, 18))
+			flags |= SICF_PCLKE;
+
+		/* AI chip doesn't restore bar0win2 on hibernation/resume, need sw fixup */
+		if ((CHIPID(wlc_hw->sih->chip) == BCM43224_CHIP_ID) ||
+		    (CHIPID(wlc_hw->sih->chip) == BCM43225_CHIP_ID) ||
+		    (CHIPID(wlc_hw->sih->chip) == BCM43421_CHIP_ID))
+			wlc_hw->regs =
+			    (d11regs_t *) si_setcore(wlc_hw->sih, D11_CORE_ID,
+						     0);
+		si_core_reset(wlc_hw->sih, flags, resetbits);
+		wlc_mctrl_reset(wlc_hw);
+	}
+
+	v = ((R_REG(wlc_hw->osh, &wlc_hw->regs->phydebug) & PDBG_RFD) != 0);
+
+	/* put core back into reset */
+	if (!clk)
+		si_core_disable(wlc_hw->sih, 0);
+
+	if (!xtal)
+		wlc_bmac_xtal(wlc_hw, OFF);
+
+	return (v);
+}
+
+/* Initialize just the hardware when coming out of POR or S3/S5 system states */
+void BCMINITFN(wlc_bmac_hw_up) (wlc_hw_info_t * wlc_hw) {
+	if (wlc_hw->wlc->pub->hw_up)
+		return;
+
+	WL_TRACE(("wl%d: %s:\n", wlc_hw->unit, __func__));
+
+	/*
+	 * Enable pll and xtal, initialize the power control registers,
+	 * and force fastclock for the remainder of wlc_up().
+	 */
+	wlc_bmac_xtal(wlc_hw, ON);
+	si_clkctl_init(wlc_hw->sih);
+	wlc_clkctl_clk(wlc_hw, CLK_FAST);
+
+	if (BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS) {
+		si_pci_fixcfg(wlc_hw->sih);
+
+		/* AI chip doesn't restore bar0win2 on hibernation/resume, need sw fixup */
+		if ((CHIPID(wlc_hw->sih->chip) == BCM43224_CHIP_ID) ||
+		    (CHIPID(wlc_hw->sih->chip) == BCM43225_CHIP_ID) ||
+		    (CHIPID(wlc_hw->sih->chip) == BCM43421_CHIP_ID))
+			wlc_hw->regs =
+			    (d11regs_t *) si_setcore(wlc_hw->sih, D11_CORE_ID,
+						     0);
+	}
+
+	/* Inform phy that a POR reset has occurred so it does a complete phy init */
+	wlc_phy_por_inform(wlc_hw->band->pi);
+
+	wlc_hw->ucode_loaded = FALSE;
+	wlc_hw->wlc->pub->hw_up = TRUE;
+
+	if ((wlc_hw->boardflags & BFL_FEM)
+	    && (CHIPID(wlc_hw->sih->chip) == BCM4313_CHIP_ID)) {
+		if (!
+		    (wlc_hw->boardrev >= 0x1250
+		     && (wlc_hw->boardflags & BFL_FEM_BT)))
+			si_epa_4313war(wlc_hw->sih);
+	}
+}
+
+static bool wlc_dma_rxreset(wlc_hw_info_t * wlc_hw, uint fifo)
+{
+	hnddma_t *di = wlc_hw->di[fifo];
+	osl_t *osh;
+
+	if (D11REV_LT(wlc_hw->corerev, 12)) {
+		bool rxidle = TRUE;
+		uint16 rcv_frm_cnt = 0;
+
+		osh = wlc_hw->osh;
+
+		W_REG(osh, &wlc_hw->regs->rcv_fifo_ctl, fifo << 8);
+		SPINWAIT((!(rxidle = dma_rxidle(di))) &&
+			 ((rcv_frm_cnt =
+			   R_REG(osh, &wlc_hw->regs->rcv_frm_cnt)) != 0),
+			 50000);
+
+		if (!rxidle && (rcv_frm_cnt != 0))
+			WL_ERROR(("wl%d: %s: rxdma[%d] not idle && rcv_frm_cnt(%d) not zero\n", wlc_hw->unit, __func__, fifo, rcv_frm_cnt));
+		OSL_DELAY(2000);
+	}
+
+	return (dma_rxreset(di));
+}
+
+/* d11 core reset
+ *   ensure fask clock during reset
+ *   reset dma
+ *   reset d11(out of reset)
+ *   reset phy(out of reset)
+ *   clear software macintstatus for fresh new start
+ * one testing hack wlc_hw->noreset will bypass the d11/phy reset
+ */
+void BCMINITFN(wlc_bmac_corereset) (wlc_hw_info_t * wlc_hw, uint32 flags) {
+	d11regs_t *regs;
+	uint i;
+	bool fastclk;
+	uint32 resetbits = 0;
+
+	if (flags == WLC_USE_COREFLAGS)
+		flags = (wlc_hw->band->pi ? wlc_hw->band->core_flags : 0);
+
+	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
+
+	regs = wlc_hw->regs;
+
+	/* request FAST clock if not on  */
+	if (!(fastclk = wlc_hw->forcefastclk))
+		wlc_clkctl_clk(wlc_hw, CLK_FAST);
+
+	/* reset the dma engines except first time thru */
+	if (si_iscoreup(wlc_hw->sih)) {
+		for (i = 0; i < NFIFO; i++)
+			if ((wlc_hw->di[i]) && (!dma_txreset(wlc_hw->di[i]))) {
+				WL_ERROR(("wl%d: %s: dma_txreset[%d]: cannot stop dma\n", wlc_hw->unit, __func__, i));
+			}
+
+		if ((wlc_hw->di[RX_FIFO])
+		    && (!wlc_dma_rxreset(wlc_hw, RX_FIFO))) {
+			WL_ERROR(("wl%d: %s: dma_rxreset[%d]: cannot stop dma\n", wlc_hw->unit, __func__, RX_FIFO));
+		}
+		if (D11REV_IS(wlc_hw->corerev, 4)
+		    && wlc_hw->di[RX_TXSTATUS_FIFO]
+		    && (!wlc_dma_rxreset(wlc_hw, RX_TXSTATUS_FIFO))) {
+			WL_ERROR(("wl%d: %s: dma_rxreset[%d]: cannot stop dma\n", wlc_hw->unit, __func__, RX_TXSTATUS_FIFO));
+		}
+	}
+	/* if noreset, just stop the psm and return */
+	if (wlc_hw->noreset) {
+		wlc_hw->wlc->macintstatus = 0;	/* skip wl_dpc after down */
+		wlc_bmac_mctrl(wlc_hw, MCTL_PSM_RUN | MCTL_EN_MAC, 0);
+		return;
+	}
+
+	if (D11REV_LE(wlc_hw->corerev, 11))
+		resetbits |= SICF_PCLKE;
+
+	/*
+	 * corerev >= 18, mac no longer enables phyclk automatically when driver accesses phyreg
+	 * throughput mac, AND phy_reset is skipped at early stage when band->pi is invalid
+	 * need to enable PHY CLK
+	 */
+	if (D11REV_GE(wlc_hw->corerev, 18))
+		flags |= SICF_PCLKE;
+
+	/* reset the core
+	 * In chips with PMU, the fastclk request goes through d11 core reg 0x1e0, which
+	 *  is cleared by the core_reset. have to re-request it.
+	 *  This adds some delay and we can optimize it by also requesting fastclk through
+	 *  chipcommon during this period if necessary. But that has to work coordinate
+	 *  with other driver like mips/arm since they may touch chipcommon as well.
+	 */
+	wlc_hw->clk = FALSE;
+	si_core_reset(wlc_hw->sih, flags, resetbits);
+	wlc_hw->clk = TRUE;
+	if (wlc_hw->band && wlc_hw->band->pi)
+		wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, TRUE);
+
+	wlc_mctrl_reset(wlc_hw);
+
+	if (PMUCTL_ENAB(wlc_hw->sih))
+		wlc_clkctl_clk(wlc_hw, CLK_FAST);
+
+	wlc_bmac_phy_reset(wlc_hw);
+
+	/* turn on PHY_PLL */
+	wlc_bmac_core_phypll_ctl(wlc_hw, TRUE);
+
+	/* clear sw intstatus */
+	wlc_hw->wlc->macintstatus = 0;
+
+	/* restore the clk setting */
+	if (!fastclk)
+		wlc_clkctl_clk(wlc_hw, CLK_DYNAMIC);
+}
+
+/* If the ucode that supports corerev 5 is used for corerev 9 and above,
+ * txfifo sizes needs to be modified(increased) since the newer cores
+ * have more memory.
+ */
+static void BCMINITFN(wlc_corerev_fifofixup) (wlc_hw_info_t * wlc_hw) {
+	d11regs_t *regs = wlc_hw->regs;
+	uint16 fifo_nu;
+	uint16 txfifo_startblk = TXFIFO_START_BLK, txfifo_endblk;
+	uint16 txfifo_def, txfifo_def1;
+	uint16 txfifo_cmd;
+	osl_t *osh;
+
+	if (D11REV_LT(wlc_hw->corerev, 9))
+		goto exit;
+
+	/* tx fifos start at TXFIFO_START_BLK from the Base address */
+	txfifo_startblk = TXFIFO_START_BLK;
+
+	osh = wlc_hw->osh;
+
+	/* sequence of operations:  reset fifo, set fifo size, reset fifo */
+	for (fifo_nu = 0; fifo_nu < NFIFO; fifo_nu++) {
+
+		txfifo_endblk = txfifo_startblk + wlc_hw->xmtfifo_sz[fifo_nu];
+		txfifo_def = (txfifo_startblk & 0xff) |
+		    (((txfifo_endblk - 1) & 0xff) << TXFIFO_FIFOTOP_SHIFT);
+		txfifo_def1 = ((txfifo_startblk >> 8) & 0x1) |
+		    ((((txfifo_endblk -
+			1) >> 8) & 0x1) << TXFIFO_FIFOTOP_SHIFT);
+		txfifo_cmd =
+		    TXFIFOCMD_RESET_MASK | (fifo_nu << TXFIFOCMD_FIFOSEL_SHIFT);
+
+		W_REG(osh, &regs->xmtfifocmd, txfifo_cmd);
+		W_REG(osh, &regs->xmtfifodef, txfifo_def);
+		if (D11REV_GE(wlc_hw->corerev, 16))
+			W_REG(osh, &regs->xmtfifodef1, txfifo_def1);
+
+		W_REG(osh, &regs->xmtfifocmd, txfifo_cmd);
+
+		txfifo_startblk += wlc_hw->xmtfifo_sz[fifo_nu];
+	}
+ exit:
+	/* need to propagate to shm location to be in sync since ucode/hw won't do this */
+	wlc_bmac_write_shm(wlc_hw, M_FIFOSIZE0,
+			   wlc_hw->xmtfifo_sz[TX_AC_BE_FIFO]);
+	wlc_bmac_write_shm(wlc_hw, M_FIFOSIZE1,
+			   wlc_hw->xmtfifo_sz[TX_AC_VI_FIFO]);
+	wlc_bmac_write_shm(wlc_hw, M_FIFOSIZE2,
+			   ((wlc_hw->xmtfifo_sz[TX_AC_VO_FIFO] << 8) | wlc_hw->
+			    xmtfifo_sz[TX_AC_BK_FIFO]));
+	wlc_bmac_write_shm(wlc_hw, M_FIFOSIZE3,
+			   ((wlc_hw->xmtfifo_sz[TX_ATIM_FIFO] << 8) | wlc_hw->
+			    xmtfifo_sz[TX_BCMC_FIFO]));
+}
+
+/* d11 core init
+ *   reset PSM
+ *   download ucode/PCM
+ *   let ucode run to suspended
+ *   download ucode inits
+ *   config other core registers
+ *   init dma
+ */
+static void BCMINITFN(wlc_coreinit) (wlc_info_t * wlc) {
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	d11regs_t *regs;
+	uint32 sflags;
+	uint bcnint_us;
+	uint i = 0;
+	bool fifosz_fixup = FALSE;
+	osl_t *osh;
+	int err = 0;
+	uint16 buf[NFIFO];
+
+	regs = wlc_hw->regs;
+	osh = wlc_hw->osh;
+
+	WL_TRACE(("wl%d: wlc_coreinit\n", wlc_hw->unit));
+
+	/* reset PSM */
+	wlc_bmac_mctrl(wlc_hw, ~0, (MCTL_IHR_EN | MCTL_PSM_JMP_0 | MCTL_WAKE));
+
+	wlc_ucode_download(wlc_hw);
+	/*
+	 * FIFOSZ fixup
+	 * 1) core5-9 use ucode 5 to save space since the PSM is the same
+	 * 2) newer chips, driver wants to controls the fifo allocation
+	 */
+	if (D11REV_GE(wlc_hw->corerev, 4))
+		fifosz_fixup = TRUE;
+
+	/* let the PSM run to the suspended state, set mode to BSS STA */
+	W_REG(osh, &regs->macintstatus, -1);
+	wlc_bmac_mctrl(wlc_hw, ~0,
+		       (MCTL_IHR_EN | MCTL_INFRA | MCTL_PSM_RUN | MCTL_WAKE));
+
+	/* wait for ucode to self-suspend after auto-init */
+	SPINWAIT(((R_REG(osh, &regs->macintstatus) & MI_MACSSPNDD) == 0),
+		 1000 * 1000);
+	if ((R_REG(osh, &regs->macintstatus) & MI_MACSSPNDD) == 0)
+		WL_ERROR(("wl%d: wlc_coreinit: ucode did not self-suspend!\n",
+			  wlc_hw->unit));
+
+	wlc_gpio_init(wlc);
+
+	sflags = si_core_sflags(wlc_hw->sih, 0, 0);
+
+	if (D11REV_IS(wlc_hw->corerev, 23)) {
+		if (WLCISNPHY(wlc_hw->band))
+			wlc_write_inits(wlc_hw, d11n0initvals16);
+		else
+			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
+				  __func__, wlc_hw->unit, wlc_hw->corerev));
+	} else if (D11REV_IS(wlc_hw->corerev, 24)) {
+		if (WLCISLCNPHY(wlc_hw->band)) {
+			wlc_write_inits(wlc_hw, d11lcn0initvals24);
+		} else {
+			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
+				  __func__, wlc_hw->unit, wlc_hw->corerev));
+		}
+	} else {
+		WL_ERROR(("%s: wl%d: unsupported corerev %d\n",
+			  __func__, wlc_hw->unit, wlc_hw->corerev));
+	}
+
+	/* For old ucode, txfifo sizes needs to be modified(increased) for Corerev >= 9 */
+	if (fifosz_fixup == TRUE) {
+		wlc_corerev_fifofixup(wlc_hw);
+	}
+
+	/* check txfifo allocations match between ucode and driver */
+	buf[TX_AC_BE_FIFO] = wlc_bmac_read_shm(wlc_hw, M_FIFOSIZE0);
+	if (buf[TX_AC_BE_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_BE_FIFO]) {
+		i = TX_AC_BE_FIFO;
+		err = -1;
+	}
+	buf[TX_AC_VI_FIFO] = wlc_bmac_read_shm(wlc_hw, M_FIFOSIZE1);
+	if (buf[TX_AC_VI_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_VI_FIFO]) {
+		i = TX_AC_VI_FIFO;
+		err = -1;
+	}
+	buf[TX_AC_BK_FIFO] = wlc_bmac_read_shm(wlc_hw, M_FIFOSIZE2);
+	buf[TX_AC_VO_FIFO] = (buf[TX_AC_BK_FIFO] >> 8) & 0xff;
+	buf[TX_AC_BK_FIFO] &= 0xff;
+	if (buf[TX_AC_BK_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_BK_FIFO]) {
+		i = TX_AC_BK_FIFO;
+		err = -1;
+	}
+	if (buf[TX_AC_VO_FIFO] != wlc_hw->xmtfifo_sz[TX_AC_VO_FIFO]) {
+		i = TX_AC_VO_FIFO;
+		err = -1;
+	}
+	buf[TX_BCMC_FIFO] = wlc_bmac_read_shm(wlc_hw, M_FIFOSIZE3);
+	buf[TX_ATIM_FIFO] = (buf[TX_BCMC_FIFO] >> 8) & 0xff;
+	buf[TX_BCMC_FIFO] &= 0xff;
+	if (buf[TX_BCMC_FIFO] != wlc_hw->xmtfifo_sz[TX_BCMC_FIFO]) {
+		i = TX_BCMC_FIFO;
+		err = -1;
+	}
+	if (buf[TX_ATIM_FIFO] != wlc_hw->xmtfifo_sz[TX_ATIM_FIFO]) {
+		i = TX_ATIM_FIFO;
+		err = -1;
+	}
+	if (err != 0) {
+		WL_ERROR(("wlc_coreinit: txfifo mismatch: ucode size %d driver size %d index %d\n", buf[i], wlc_hw->xmtfifo_sz[i], i));
+		/* DO NOT ASSERT corerev < 4 even there is a mismatch
+		 * shmem, since driver don't overwrite those chip and
+		 * ucode initialize data will be used.
+		 */
+		if (D11REV_GE(wlc_hw->corerev, 4))
+			ASSERT(0);
+	}
+
+	/* make sure we can still talk to the mac */
+	ASSERT(R_REG(osh, &regs->maccontrol) != 0xffffffff);
+
+	/* band-specific inits done by wlc_bsinit() */
+
+	/* Set up frame burst size and antenna swap threshold init values */
+	wlc_bmac_write_shm(wlc_hw, M_MBURST_SIZE, MAXTXFRAMEBURST);
+	wlc_bmac_write_shm(wlc_hw, M_MAX_ANTCNT, ANTCNT);
+
+	/* enable one rx interrupt per received frame */
+	W_REG(osh, &regs->intrcvlazy[0], (1 << IRL_FC_SHIFT));
+	if (D11REV_IS(wlc_hw->corerev, 4))
+		W_REG(osh, &regs->intrcvlazy[3], (1 << IRL_FC_SHIFT));
+
+	/* set the station mode (BSS STA) */
+	wlc_bmac_mctrl(wlc_hw,
+		       (MCTL_INFRA | MCTL_DISCARD_PMQ | MCTL_AP),
+		       (MCTL_INFRA | MCTL_DISCARD_PMQ));
+
+	/* set up Beacon interval */
+	bcnint_us = 0x8000 << 10;
+	W_REG(osh, &regs->tsf_cfprep, (bcnint_us << CFPREP_CBI_SHIFT));
+	W_REG(osh, &regs->tsf_cfpstart, bcnint_us);
+	W_REG(osh, &regs->macintstatus, MI_GP1);
+
+	/* write interrupt mask */
+	W_REG(osh, &regs->intctrlregs[RX_FIFO].intmask, DEF_RXINTMASK);
+	if (D11REV_IS(wlc_hw->corerev, 4))
+		W_REG(osh, &regs->intctrlregs[RX_TXSTATUS_FIFO].intmask,
+		      DEF_RXINTMASK);
+
+	/* allow the MAC to control the PHY clock (dynamic on/off) */
+	wlc_bmac_macphyclk_set(wlc_hw, ON);
+
+	/* program dynamic clock control fast powerup delay register */
+	if (D11REV_GT(wlc_hw->corerev, 4)) {
+		wlc->fastpwrup_dly = si_clkctl_fast_pwrup_delay(wlc_hw->sih);
+		W_REG(osh, &regs->scc_fastpwrup_dly, wlc->fastpwrup_dly);
+	}
+
+	/* tell the ucode the corerev */
+	wlc_bmac_write_shm(wlc_hw, M_MACHW_VER, (uint16) wlc_hw->corerev);
+
+	/* tell the ucode MAC capabilities */
+	if (D11REV_GE(wlc_hw->corerev, 13)) {
+		wlc_bmac_write_shm(wlc_hw, M_MACHW_CAP_L,
+				   (uint16) (wlc_hw->machwcap & 0xffff));
+		wlc_bmac_write_shm(wlc_hw, M_MACHW_CAP_H,
+				   (uint16) ((wlc_hw->
+					      machwcap >> 16) & 0xffff));
+	}
+
+	/* write retry limits to SCR, this done after PSM init */
+	W_REG(osh, &regs->objaddr, OBJADDR_SCR_SEL | S_DOT11_SRC_LMT);
+	(void)R_REG(osh, &regs->objaddr);
+	W_REG(osh, &regs->objdata, wlc_hw->SRL);
+	W_REG(osh, &regs->objaddr, OBJADDR_SCR_SEL | S_DOT11_LRC_LMT);
+	(void)R_REG(osh, &regs->objaddr);
+	W_REG(osh, &regs->objdata, wlc_hw->LRL);
+
+	/* write rate fallback retry limits */
+	wlc_bmac_write_shm(wlc_hw, M_SFRMTXCNTFBRTHSD, wlc_hw->SFBL);
+	wlc_bmac_write_shm(wlc_hw, M_LFRMTXCNTFBRTHSD, wlc_hw->LFBL);
+
+	if (D11REV_GE(wlc_hw->corerev, 16)) {
+		AND_REG(osh, &regs->ifs_ctl, 0x0FFF);
+		W_REG(osh, &regs->ifs_aifsn, EDCF_AIFSN_MIN);
+	}
+
+	/* dma initializations */
+	wlc->txpend16165war = 0;
+
+	/* init the tx dma engines */
+	for (i = 0; i < NFIFO; i++) {
+		if (wlc_hw->di[i])
+			dma_txinit(wlc_hw->di[i]);
+	}
+
+	/* init the rx dma engine(s) and post receive buffers */
+	dma_rxinit(wlc_hw->di[RX_FIFO]);
+	dma_rxfill(wlc_hw->di[RX_FIFO]);
+	if (D11REV_IS(wlc_hw->corerev, 4)) {
+		dma_rxinit(wlc_hw->di[RX_TXSTATUS_FIFO]);
+		dma_rxfill(wlc_hw->di[RX_TXSTATUS_FIFO]);
+	}
+}
+
+/* This function is used for changing the tsf frac register
+ * If spur avoidance mode is off, the mac freq will be 80/120/160Mhz
+ * If spur avoidance mode is on1, the mac freq will be 82/123/164Mhz
+ * If spur avoidance mode is on2, the mac freq will be 84/126/168Mhz
+ * HTPHY Formula is 2^26/freq(MHz) e.g.
+ * For spuron2 - 126MHz -> 2^26/126 = 532610.0
+ *  - 532610 = 0x82082 => tsf_clk_frac_h = 0x8, tsf_clk_frac_l = 0x2082
+ * For spuron: 123MHz -> 2^26/123    = 545600.5
+ *  - 545601 = 0x85341 => tsf_clk_frac_h = 0x8, tsf_clk_frac_l = 0x5341
+ * For spur off: 120MHz -> 2^26/120    = 559240.5
+ *  - 559241 = 0x88889 => tsf_clk_frac_h = 0x8, tsf_clk_frac_l = 0x8889
+ */
+
+void wlc_bmac_switch_macfreq(wlc_hw_info_t * wlc_hw, uint8 spurmode)
+{
+	d11regs_t *regs;
+	osl_t *osh;
+	regs = wlc_hw->regs;
+	osh = wlc_hw->osh;
+
+	if ((CHIPID(wlc_hw->sih->chip) == BCM43224_CHIP_ID) ||
+	    (CHIPID(wlc_hw->sih->chip) == BCM43225_CHIP_ID)) {
+		if (spurmode == WL_SPURAVOID_ON2) {	/* 126Mhz */
+			W_REG(osh, &regs->tsf_clk_frac_l, 0x2082);
+			W_REG(osh, &regs->tsf_clk_frac_h, 0x8);
+		} else if (spurmode == WL_SPURAVOID_ON1) {	/* 123Mhz */
+			W_REG(osh, &regs->tsf_clk_frac_l, 0x5341);
+			W_REG(osh, &regs->tsf_clk_frac_h, 0x8);
+		} else {	/* 120Mhz */
+			W_REG(osh, &regs->tsf_clk_frac_l, 0x8889);
+			W_REG(osh, &regs->tsf_clk_frac_h, 0x8);
+		}
+	} else if (WLCISLCNPHY(wlc_hw->band)) {
+		if (spurmode == WL_SPURAVOID_ON1) {	/* 82Mhz */
+			W_REG(osh, &regs->tsf_clk_frac_l, 0x7CE0);
+			W_REG(osh, &regs->tsf_clk_frac_h, 0xC);
+		} else {	/* 80Mhz */
+			W_REG(osh, &regs->tsf_clk_frac_l, 0xCCCD);
+			W_REG(osh, &regs->tsf_clk_frac_h, 0xC);
+		}
+	}
+}
+
+/* Initialize GPIOs that are controlled by D11 core */
+static void BCMINITFN(wlc_gpio_init) (wlc_info_t * wlc) {
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	d11regs_t *regs;
+	uint32 gc, gm;
+	osl_t *osh;
+
+	regs = wlc_hw->regs;
+	osh = wlc_hw->osh;
+
+	/* use GPIO select 0 to get all gpio signals from the gpio out reg */
+	wlc_bmac_mctrl(wlc_hw, MCTL_GPOUT_SEL_MASK, 0);
+
+	/*
+	 * Common GPIO setup:
+	 *      G0 = LED 0 = WLAN Activity
+	 *      G1 = LED 1 = WLAN 2.4 GHz Radio State
+	 *      G2 = LED 2 = WLAN 5 GHz Radio State
+	 *      G4 = radio disable input (HI enabled, LO disabled)
+	 */
+
+	gc = gm = 0;
+
+	/* Allocate GPIOs for mimo antenna diversity feature */
+	if (WLANTSEL_ENAB(wlc)) {
+		if (wlc_hw->antsel_type == ANTSEL_2x3) {
+			/* Enable antenna diversity, use 2x3 mode */
+			wlc_bmac_mhf(wlc_hw, MHF3, MHF3_ANTSEL_EN,
+				     MHF3_ANTSEL_EN, WLC_BAND_ALL);
+			wlc_bmac_mhf(wlc_hw, MHF3, MHF3_ANTSEL_MODE,
+				     MHF3_ANTSEL_MODE, WLC_BAND_ALL);
+
+			/* init superswitch control */
+			wlc_phy_antsel_init(wlc_hw->band->pi, FALSE);
+
+		} else if (wlc_hw->antsel_type == ANTSEL_2x4) {
+			ASSERT((gm & BOARD_GPIO_12) == 0);
+			gm |= gc |= (BOARD_GPIO_12 | BOARD_GPIO_13);
+			/* The board itself is powered by these GPIOs (when not sending pattern)
+			 * So set them high
+			 */
+			OR_REG(osh, &regs->psm_gpio_oe,
+			       (BOARD_GPIO_12 | BOARD_GPIO_13));
+			OR_REG(osh, &regs->psm_gpio_out,
+			       (BOARD_GPIO_12 | BOARD_GPIO_13));
+
+			/* Enable antenna diversity, use 2x4 mode */
+			wlc_bmac_mhf(wlc_hw, MHF3, MHF3_ANTSEL_EN,
+				     MHF3_ANTSEL_EN, WLC_BAND_ALL);
+			wlc_bmac_mhf(wlc_hw, MHF3, MHF3_ANTSEL_MODE, 0,
+				     WLC_BAND_ALL);
+
+			/* Configure the desired clock to be 4Mhz */
+			wlc_bmac_write_shm(wlc_hw, M_ANTSEL_CLKDIV,
+					   ANTSEL_CLKDIV_4MHZ);
+		}
+	}
+	/* gpio 9 controls the PA.  ucode is responsible for wiggling out and oe */
+	if (wlc_hw->boardflags & BFL_PACTRL)
+		gm |= gc |= BOARD_GPIO_PACTRL;
+
+	/* apply to gpiocontrol register */
+	si_gpiocontrol(wlc_hw->sih, gm, gc, GPIO_DRV_PRIORITY);
+}
+
+static void BCMATTACHFN(wlc_ucode_download) (wlc_hw_info_t * wlc_hw) {
+	wlc_info_t *wlc;
+	wlc = wlc_hw->wlc;
+
+	if (wlc_hw->ucode_loaded)
+		return;
+
+	if (D11REV_IS(wlc_hw->corerev, 23)) {
+		if (WLCISNPHY(wlc_hw->band)) {
+			wlc_ucode_write(wlc_hw, bcm43xx_16_mimo,
+					bcm43xx_16_mimosz);
+			wlc_hw->ucode_loaded = TRUE;
+		} else
+			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
+				  __func__, wlc_hw->unit, wlc_hw->corerev));
+	} else if (D11REV_IS(wlc_hw->corerev, 24)) {
+		if (WLCISLCNPHY(wlc_hw->band)) {
+			wlc_ucode_write(wlc_hw, bcm43xx_24_lcn,
+					bcm43xx_24_lcnsz);
+			wlc_hw->ucode_loaded = TRUE;
+		} else {
+			WL_ERROR(("%s: wl%d: unsupported phy in corerev %d\n",
+				  __func__, wlc_hw->unit, wlc_hw->corerev));
+		}
+	}
+}
+
+static void
+BCMATTACHFN(wlc_ucode_write) (wlc_hw_info_t * wlc_hw, const uint32 ucode[],
+			      const uint nbytes) {
+	osl_t *osh;
+	d11regs_t *regs = wlc_hw->regs;
+	uint i;
+	uint count;
+
+	osh = wlc_hw->osh;
+
+	WL_TRACE(("wl%d: wlc_ucode_write\n", wlc_hw->unit));
+
+	ASSERT(ISALIGNED(nbytes, sizeof(uint32)));
+
+	count = (nbytes / sizeof(uint32));
+
+	W_REG(osh, &regs->objaddr, (OBJADDR_AUTO_INC | OBJADDR_UCM_SEL));
+	(void)R_REG(osh, &regs->objaddr);
+	for (i = 0; i < count; i++)
+		W_REG(osh, &regs->objdata, ucode[i]);
+}
+
+static void wlc_write_inits(wlc_hw_info_t * wlc_hw, const d11init_t * inits)
+{
+	int i;
+	osl_t *osh;
+	volatile uint8 *base;
+
+	WL_TRACE(("wl%d: wlc_write_inits\n", wlc_hw->unit));
+
+	osh = wlc_hw->osh;
+	base = (volatile uint8 *)wlc_hw->regs;
+
+	for (i = 0; inits[i].addr != 0xffff; i++) {
+		ASSERT((inits[i].size == 2) || (inits[i].size == 4));
+
+		if (inits[i].size == 2)
+			W_REG(osh, (uint16 *) (uintptr) (base + inits[i].addr),
+			      inits[i].value);
+		else if (inits[i].size == 4)
+			W_REG(osh, (uint32 *) (uintptr) (base + inits[i].addr),
+			      inits[i].value);
+	}
+}
+
+static void wlc_ucode_txant_set(wlc_hw_info_t * wlc_hw)
+{
+	uint16 phyctl;
+	uint16 phytxant = wlc_hw->bmac_phytxant;
+	uint16 mask = PHY_TXC_ANT_MASK;
+
+	/* set the Probe Response frame phy control word */
+	phyctl = wlc_bmac_read_shm(wlc_hw, M_CTXPRS_BLK + C_CTX_PCTLWD_POS);
+	phyctl = (phyctl & ~mask) | phytxant;
+	wlc_bmac_write_shm(wlc_hw, M_CTXPRS_BLK + C_CTX_PCTLWD_POS, phyctl);
+
+	/* set the Response (ACK/CTS) frame phy control word */
+	phyctl = wlc_bmac_read_shm(wlc_hw, M_RSP_PCTLWD);
+	phyctl = (phyctl & ~mask) | phytxant;
+	wlc_bmac_write_shm(wlc_hw, M_RSP_PCTLWD, phyctl);
+}
+
+void wlc_bmac_txant_set(wlc_hw_info_t * wlc_hw, uint16 phytxant)
+{
+	/* update sw state */
+	wlc_hw->bmac_phytxant = phytxant;
+
+	/* push to ucode if up */
+	if (!wlc_hw->up)
+		return;
+	wlc_ucode_txant_set(wlc_hw);
+
+}
+
+uint16 wlc_bmac_get_txant(wlc_hw_info_t * wlc_hw)
+{
+	return (uint16) wlc_hw->wlc->stf->txant;
+}
+
+void wlc_bmac_antsel_type_set(wlc_hw_info_t * wlc_hw, uint8 antsel_type)
+{
+	wlc_hw->antsel_type = antsel_type;
+
+	/* Update the antsel type for phy module to use */
+	wlc_phy_antsel_type_set(wlc_hw->band->pi, antsel_type);
+}
+
+void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw)
+{
+	bool fatal = FALSE;
+	uint unit;
+	uint intstatus, idx;
+	d11regs_t *regs = wlc_hw->regs;
+
+	unit = wlc_hw->unit;
+
+	for (idx = 0; idx < NFIFO; idx++) {
+		/* read intstatus register and ignore any non-error bits */
+		intstatus =
+		    R_REG(wlc_hw->osh,
+			  &regs->intctrlregs[idx].intstatus) & I_ERRORS;
+		if (!intstatus)
+			continue;
+
+		WL_TRACE(("wl%d: wlc_bmac_fifoerrors: intstatus%d 0x%x\n", unit,
+			  idx, intstatus));
+
+		if (intstatus & I_RO) {
+			WL_ERROR(("wl%d: fifo %d: receive fifo overflow\n",
+				  unit, idx));
+			WLCNTINCR(wlc_hw->wlc->pub->_cnt->rxoflo);
+			fatal = TRUE;
+		}
+
+		if (intstatus & I_PC) {
+			WL_ERROR(("wl%d: fifo %d: descriptor error\n", unit,
+				  idx));
+			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmade);
+			fatal = TRUE;
+		}
+
+		if (intstatus & I_PD) {
+			WL_ERROR(("wl%d: fifo %d: data error\n", unit, idx));
+			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmada);
+			fatal = TRUE;
+		}
+
+		if (intstatus & I_DE) {
+			WL_ERROR(("wl%d: fifo %d: descriptor protocol error\n",
+				  unit, idx));
+			WLCNTINCR(wlc_hw->wlc->pub->_cnt->dmape);
+			fatal = TRUE;
+		}
+
+		if (intstatus & I_RU) {
+			WL_ERROR(("wl%d: fifo %d: receive descriptor underflow\n", unit, idx));
+			WLCNTINCR(wlc_hw->wlc->pub->_cnt->rxuflo[idx]);
+		}
+
+		if (intstatus & I_XU) {
+			WL_ERROR(("wl%d: fifo %d: transmit fifo underflow\n",
+				  idx, unit));
+			WLCNTINCR(wlc_hw->wlc->pub->_cnt->txuflo);
+			fatal = TRUE;
+		}
+
+		if (fatal) {
+			wlc_fatal_error(wlc_hw->wlc);	/* big hammer */
+			break;
+		} else
+			W_REG(wlc_hw->osh, &regs->intctrlregs[idx].intstatus,
+			      intstatus);
+	}
+}
+
+void wlc_intrson(wlc_info_t * wlc)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	ASSERT(wlc->defmacintmask);
+	wlc->macintmask = wlc->defmacintmask;
+	W_REG(wlc_hw->osh, &wlc_hw->regs->macintmask, wlc->macintmask);
+}
+
+/* callback for siutils.c, which has only wlc handler, no wl
+ * they both check up, not only because there is no need to off/restore d11 interrupt
+ *  but also because per-port code may require sync with valid interrupt.
+ */
+
+static uint32 wlc_wlintrsoff(wlc_info_t * wlc)
+{
+	if (!wlc->hw->up)
+		return 0;
+
+	return wl_intrsoff(wlc->wl);
+}
+
+static void wlc_wlintrsrestore(wlc_info_t * wlc, uint32 macintmask)
+{
+	if (!wlc->hw->up)
+		return;
+
+	wl_intrsrestore(wlc->wl, macintmask);
+}
+
+uint32 wlc_intrsoff(wlc_info_t * wlc)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	uint32 macintmask;
+
+	if (!wlc_hw->clk)
+		return 0;
+
+	macintmask = wlc->macintmask;	/* isr can still happen */
+
+	W_REG(wlc_hw->osh, &wlc_hw->regs->macintmask, 0);
+	(void)R_REG(wlc_hw->osh, &wlc_hw->regs->macintmask);	/* sync readback */
+	OSL_DELAY(1);		/* ensure int line is no longer driven */
+	wlc->macintmask = 0;
+
+	/* return previous macintmask; resolve race between us and our isr */
+	return (wlc->macintstatus ? 0 : macintmask);
+}
+
+void wlc_intrsrestore(wlc_info_t * wlc, uint32 macintmask)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	if (!wlc_hw->clk)
+		return;
+
+	wlc->macintmask = macintmask;
+	W_REG(wlc_hw->osh, &wlc_hw->regs->macintmask, wlc->macintmask);
+}
+
+void wlc_bmac_mute(wlc_hw_info_t * wlc_hw, bool on, mbool flags)
+{
+	struct ether_addr null_ether_addr = { {0, 0, 0, 0, 0, 0} };
+
+	if (on) {
+		/* suspend tx fifos */
+		wlc_bmac_tx_fifo_suspend(wlc_hw, TX_DATA_FIFO);
+		wlc_bmac_tx_fifo_suspend(wlc_hw, TX_CTL_FIFO);
+		wlc_bmac_tx_fifo_suspend(wlc_hw, TX_AC_BK_FIFO);
+		wlc_bmac_tx_fifo_suspend(wlc_hw, TX_AC_VI_FIFO);
+
+		/* zero the address match register so we do not send ACKs */
+		wlc_bmac_set_addrmatch(wlc_hw, RCM_MAC_OFFSET,
+				       &null_ether_addr);
+	} else {
+		/* resume tx fifos */
+		if (!wlc_hw->wlc->tx_suspended) {
+			wlc_bmac_tx_fifo_resume(wlc_hw, TX_DATA_FIFO);
+		}
+		wlc_bmac_tx_fifo_resume(wlc_hw, TX_CTL_FIFO);
+		wlc_bmac_tx_fifo_resume(wlc_hw, TX_AC_BK_FIFO);
+		wlc_bmac_tx_fifo_resume(wlc_hw, TX_AC_VI_FIFO);
+
+		/* Restore address */
+		wlc_bmac_set_addrmatch(wlc_hw, RCM_MAC_OFFSET,
+				       &wlc_hw->etheraddr);
+	}
+
+	wlc_phy_mute_upd(wlc_hw->band->pi, on, flags);
+
+	if (on)
+		wlc_ucode_mute_override_set(wlc_hw);
+	else
+		wlc_ucode_mute_override_clear(wlc_hw);
+}
+
+void wlc_bmac_set_deaf(wlc_hw_info_t * wlc_hw, bool user_flag)
+{
+	wlc_phy_set_deaf(wlc_hw->band->pi, user_flag);
+}
+
+int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t * wlc_hw, uint fifo, uint * blocks)
+{
+	if (fifo >= NFIFO)
+		return BCME_RANGE;
+
+	*blocks = wlc_hw->xmtfifo_sz[fifo];
+
+	return 0;
+}
+
+int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t * wlc_hw, uint fifo, uint blocks)
+{
+	if (fifo >= NFIFO || blocks > 299)
+		return BCME_RANGE;
+
+	/* BMAC_NOTE, change blocks to uint16 */
+	wlc_hw->xmtfifo_sz[fifo] = (uint16) blocks;
+
+	return 0;
+}
+
+/* wlc_bmac_tx_fifo_suspended:
+ * Check the MAC's tx suspend status for a tx fifo.
+ *
+ * When the MAC acknowledges a tx suspend, it indicates that no more
+ * packets will be transmitted out the radio. This is independent of
+ * DMA channel suspension---the DMA may have finished suspending, or may still
+ * be pulling data into a tx fifo, by the time the MAC acks the suspend
+ * request.
+ */
+bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+{
+	/* check that a suspend has been requested and is no longer pending */
+
+	/*
+	 * for DMA mode, the suspend request is set in xmtcontrol of the DMA engine,
+	 * and the tx fifo suspend at the lower end of the MAC is acknowledged in the
+	 * chnstatus register.
+	 * The tx fifo suspend completion is independent of the DMA suspend completion and
+	 *   may be acked before or after the DMA is suspended.
+	 */
+	if (dma_txsuspended(wlc_hw->di[tx_fifo]) &&
+	    (R_REG(wlc_hw->osh, &wlc_hw->regs->chnstatus) &
+	     (1 << tx_fifo)) == 0)
+		return TRUE;
+
+	return FALSE;
+}
+
+void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+{
+	uint8 fifo = 1 << tx_fifo;
+
+	/* Two clients of this code, 11h Quiet period and scanning. */
+
+	/* only suspend if not already suspended */
+	if ((wlc_hw->suspended_fifos & fifo) == fifo)
+		return;
+
+	/* force the core awake only if not already */
+	if (wlc_hw->suspended_fifos == 0)
+		wlc_ucode_wake_override_set(wlc_hw, WLC_WAKE_OVERRIDE_TXFIFO);
+
+	wlc_hw->suspended_fifos |= fifo;
+
+	if (wlc_hw->di[tx_fifo]) {
+		/* Suspending AMPDU transmissions in the middle can cause underflow
+		 * which may result in mismatch between ucode and driver
+		 * so suspend the mac before suspending the FIFO
+		 */
+		if (WLC_PHY_11N_CAP(wlc_hw->band))
+			wlc_suspend_mac_and_wait(wlc_hw->wlc);
+
+		dma_txsuspend(wlc_hw->di[tx_fifo]);
+
+		if (WLC_PHY_11N_CAP(wlc_hw->band))
+			wlc_enable_mac(wlc_hw->wlc);
+	}
+}
+
+void wlc_bmac_tx_fifo_resume(wlc_hw_info_t * wlc_hw, uint tx_fifo)
+{
+	/* BMAC_NOTE: WLC_TX_FIFO_ENAB is done in wlc_dpc() for DMA case but need to be done
+	 * here for PIO otherwise the watchdog will catch the inconsistency and fire
+	 */
+	/* Two clients of this code, 11h Quiet period and scanning. */
+	if (wlc_hw->di[tx_fifo])
+		dma_txresume(wlc_hw->di[tx_fifo]);
+
+	/* allow core to sleep again */
+	if (wlc_hw->suspended_fifos == 0)
+		return;
+	else {
+		wlc_hw->suspended_fifos &= ~(1 << tx_fifo);
+		if (wlc_hw->suspended_fifos == 0)
+			wlc_ucode_wake_override_clear(wlc_hw,
+						      WLC_WAKE_OVERRIDE_TXFIFO);
+	}
+}
+
+/*
+ * Read and clear macintmask and macintstatus and intstatus registers.
+ * This routine should be called with interrupts off
+ * Return:
+ *   -1 if DEVICEREMOVED(wlc) evaluates to TRUE;
+ *   0 if the interrupt is not for us, or we are in some special cases;
+ *   device interrupt status bits otherwise.
+ */
+static INLINE uint32 wlc_intstatus(wlc_info_t * wlc, bool in_isr)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	d11regs_t *regs = wlc_hw->regs;
+	uint32 macintstatus;
+	uint32 intstatus_rxfifo, intstatus_txsfifo;
+	osl_t *osh;
+
+	osh = wlc_hw->osh;
+
+	/* macintstatus includes a DMA interrupt summary bit */
+	macintstatus = R_REG(osh, &regs->macintstatus);
+
+	WL_TRACE(("wl%d: macintstatus: 0x%x\n", wlc_hw->unit, macintstatus));
+
+	/* detect cardbus removed, in power down(suspend) and in reset */
+	if (DEVICEREMOVED(wlc))
+		return -1;
+
+	/* DEVICEREMOVED succeeds even when the core is still resetting,
+	 * handle that case here.
+	 */
+	if (macintstatus == 0xffffffff)
+		return 0;
+
+	/* defer unsolicited interrupts */
+	macintstatus &= (in_isr ? wlc->macintmask : wlc->defmacintmask);
+
+	/* if not for us */
+	if (macintstatus == 0)
+		return 0;
+
+	/* interrupts are already turned off for CFE build
+	 * Caution: For CFE Turning off the interrupts again has some undesired
+	 * consequences
+	 */
+	/* turn off the interrupts */
+	W_REG(osh, &regs->macintmask, 0);
+#ifndef BCMSDIO
+	(void)R_REG(osh, &regs->macintmask);	/* sync readback */
+#endif
+	wlc->macintmask = 0;
+
+	/* clear device interrupts */
+	W_REG(osh, &regs->macintstatus, macintstatus);
+
+	/* MI_DMAINT is indication of non-zero intstatus */
+	if (macintstatus & MI_DMAINT) {
+		if (D11REV_IS(wlc_hw->corerev, 4)) {
+			intstatus_rxfifo =
+			    R_REG(osh, &regs->intctrlregs[RX_FIFO].intstatus);
+			intstatus_txsfifo =
+			    R_REG(osh,
+				  &regs->intctrlregs[RX_TXSTATUS_FIFO].
+				  intstatus);
+			WL_TRACE(("wl%d: intstatus_rxfifo 0x%x, intstatus_txsfifo 0x%x\n", wlc_hw->unit, intstatus_rxfifo, intstatus_txsfifo));
+
+			/* defer unsolicited interrupt hints */
+			intstatus_rxfifo &= DEF_RXINTMASK;
+			intstatus_txsfifo &= DEF_RXINTMASK;
+
+			/* MI_DMAINT bit in macintstatus is indication of RX_FIFO interrupt */
+			/* clear interrupt hints */
+			if (intstatus_rxfifo)
+				W_REG(osh,
+				      &regs->intctrlregs[RX_FIFO].intstatus,
+				      intstatus_rxfifo);
+			else
+				macintstatus &= ~MI_DMAINT;
+
+			/* MI_TFS bit in macintstatus is encoding of RX_TXSTATUS_FIFO interrupt */
+			if (intstatus_txsfifo) {
+				W_REG(osh,
+				      &regs->intctrlregs[RX_TXSTATUS_FIFO].
+				      intstatus, intstatus_txsfifo);
+				macintstatus |= MI_TFS;
+			}
+		} else {
+			/*
+			 * For corerevs >= 5, only fifo interrupt enabled is I_RI in RX_FIFO.
+			 * If MI_DMAINT is set, assume it is set and clear the interrupt.
+			 */
+			W_REG(osh, &regs->intctrlregs[RX_FIFO].intstatus,
+			      DEF_RXINTMASK);
+		}
+	}
+
+	return macintstatus;
+}
+
+/* Update wlc->macintstatus and wlc->intstatus[]. */
+/* Return TRUE if they are updated successfully. FALSE otherwise */
+bool wlc_intrsupd(wlc_info_t * wlc)
+{
+	uint32 macintstatus;
+
+	ASSERT(wlc->macintstatus != 0);
+
+	/* read and clear macintstatus and intstatus registers */
+	macintstatus = wlc_intstatus(wlc, FALSE);
+
+	/* device is removed */
+	if (macintstatus == 0xffffffff)
+		return FALSE;
+
+	/* update interrupt status in software */
+	wlc->macintstatus |= macintstatus;
+
+	return TRUE;
+}
+
+/*
+ * First-level interrupt processing.
+ * Return TRUE if this was our interrupt, FALSE otherwise.
+ * *wantdpc will be set to TRUE if further wlc_dpc() processing is required,
+ * FALSE otherwise.
+ */
+bool BCMFASTPATH wlc_isr(wlc_info_t * wlc, bool * wantdpc)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	uint32 macintstatus;
+
+	*wantdpc = FALSE;
+
+	if (!wlc_hw->up || !wlc->macintmask)
+		return (FALSE);
+
+	/* read and clear macintstatus and intstatus registers */
+	macintstatus = wlc_intstatus(wlc, TRUE);
+
+	if (macintstatus == 0xffffffff)
+		WL_ERROR(("DEVICEREMOVED detected in the ISR code path.\n"));
+
+	/* it is not for us */
+	if (macintstatus == 0)
+		return (FALSE);
+
+	*wantdpc = TRUE;
+
+	/* save interrupt status bits */
+	ASSERT(wlc->macintstatus == 0);
+	wlc->macintstatus = macintstatus;
+
+	return (TRUE);
+
+}
+
+/* process tx completion events for corerev < 5 */
+static bool wlc_bmac_txstatus_corerev4(wlc_hw_info_t * wlc_hw)
+{
+	void *status_p;
+	tx_status_t *txs;
+	osl_t *osh;
+	bool fatal = FALSE;
+
+	WL_TRACE(("wl%d: wlc_txstatusrecv\n", wlc_hw->unit));
+
+	osh = wlc_hw->osh;
+
+	while (!fatal && (status_p = dma_rx(wlc_hw->di[RX_TXSTATUS_FIFO]))) {
+
+		txs = (tx_status_t *) PKTDATA(status_p);
+		/* MAC uses little endian only */
+		ltoh16_buf((void *)txs, sizeof(tx_status_t));
+
+		/* shift low bits for tx_status_t status compatibility */
+		txs->status = (txs->status & ~TXS_COMPAT_MASK)
+		    | (((txs->status & TXS_COMPAT_MASK) << TXS_COMPAT_SHIFT));
+
+		fatal = wlc_bmac_dotxstatus(wlc_hw, txs, 0);
+
+		PKTFREE(osh, status_p, FALSE);
+	}
+
+	if (fatal)
+		return TRUE;
+
+	/* post more rbufs */
+	dma_rxfill(wlc_hw->di[RX_TXSTATUS_FIFO]);
+
+	return FALSE;
+}
+
+static bool BCMFASTPATH
+wlc_bmac_dotxstatus(wlc_hw_info_t * wlc_hw, tx_status_t * txs, uint32 s2)
+{
+	/* discard intermediate indications for ucode with one legitimate case:
+	 *   e.g. if "useRTS" is set. ucode did a successful rts/cts exchange, but the subsequent
+	 *   tx of DATA failed. so it will start rts/cts from the beginning (resetting the rts
+	 *   transmission count)
+	 */
+	if (!(txs->status & TX_STATUS_AMPDU)
+	    && (txs->status & TX_STATUS_INTERMEDIATE)) {
+		return FALSE;
+	}
+
+	return wlc_dotxstatus(wlc_hw->wlc, txs, s2);
+}
+
+/* process tx completion events in BMAC
+ * Return TRUE if more tx status need to be processed. FALSE otherwise.
+ */
+static bool BCMFASTPATH
+wlc_bmac_txstatus(wlc_hw_info_t * wlc_hw, bool bound, bool * fatal)
+{
+	bool morepending = FALSE;
+	wlc_info_t *wlc = wlc_hw->wlc;
+
+	WL_TRACE(("wl%d: wlc_bmac_txstatus\n", wlc_hw->unit));
+
+	if (D11REV_IS(wlc_hw->corerev, 4)) {
+		/* to retire soon */
+		*fatal = wlc_bmac_txstatus_corerev4(wlc->hw);
+
+		if (*fatal)
+			return 0;
+	} else {
+		/* corerev >= 5 */
+		d11regs_t *regs;
+		osl_t *osh;
+		tx_status_t txstatus, *txs;
+		uint32 s1, s2;
+		uint n = 0;
+		/* Param 'max_tx_num' indicates max. # tx status to process before break out. */
+		uint max_tx_num = bound ? wlc->pub->tunables->txsbnd : -1;
+
+		txs = &txstatus;
+		regs = wlc_hw->regs;
+		osh = wlc_hw->osh;
+		while (!(*fatal)
+		       && (s1 = R_REG(osh, &regs->frmtxstatus)) & TXS_V) {
+
+			if (s1 == 0xffffffff) {
+				WL_ERROR(("wl%d: %s: dead chip\n",
+					  wlc_hw->unit, __func__));
+				ASSERT(s1 != 0xffffffff);
+				return morepending;
+			}
+
+			s2 = R_REG(osh, &regs->frmtxstatus2);
+
+			txs->status = s1 & TXS_STATUS_MASK;
+			txs->frameid = (s1 & TXS_FID_MASK) >> TXS_FID_SHIFT;
+			txs->sequence = s2 & TXS_SEQ_MASK;
+			txs->phyerr = (s2 & TXS_PTX_MASK) >> TXS_PTX_SHIFT;
+			txs->lasttxtime = 0;
+
+			*fatal = wlc_bmac_dotxstatus(wlc_hw, txs, s2);
+
+			/* !give others some time to run! */
+			if (++n >= max_tx_num)
+				break;
+		}
+
+		if (*fatal)
+			return 0;
+
+		if (n >= max_tx_num)
+			morepending = TRUE;
+	}
+
+	if (!pktq_empty(&wlc->active_queue->q))
+		wlc_send_q(wlc, wlc->active_queue);
+
+	return morepending;
+}
+
+void wlc_suspend_mac_and_wait(wlc_info_t * wlc)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	d11regs_t *regs = wlc_hw->regs;
+	uint32 mc, mi;
+	osl_t *osh;
+
+	WL_TRACE(("wl%d: wlc_suspend_mac_and_wait: bandunit %d\n", wlc_hw->unit,
+		  wlc_hw->band->bandunit));
+
+	/*
+	 * Track overlapping suspend requests
+	 */
+	wlc_hw->mac_suspend_depth++;
+	if (wlc_hw->mac_suspend_depth > 1)
+		return;
+
+	osh = wlc_hw->osh;
+
+	/* force the core awake */
+	wlc_ucode_wake_override_set(wlc_hw, WLC_WAKE_OVERRIDE_MACSUSPEND);
+
+	mc = R_REG(osh, &regs->maccontrol);
+
+	if (mc == 0xffffffff) {
+		WL_ERROR(("wl%d: %s: dead chip\n", wlc_hw->unit, __func__));
+		wl_down(wlc->wl);
+		return;
+	}
+	ASSERT(!(mc & MCTL_PSM_JMP_0));
+	ASSERT(mc & MCTL_PSM_RUN);
+	ASSERT(mc & MCTL_EN_MAC);
+
+	mi = R_REG(osh, &regs->macintstatus);
+	if (mi == 0xffffffff) {
+		WL_ERROR(("wl%d: %s: dead chip\n", wlc_hw->unit, __func__));
+		wl_down(wlc->wl);
+		return;
+	}
+	ASSERT(!(mi & MI_MACSSPNDD));
+
+	wlc_bmac_mctrl(wlc_hw, MCTL_EN_MAC, 0);
+
+	SPINWAIT(!(R_REG(osh, &regs->macintstatus) & MI_MACSSPNDD),
+		 WLC_MAX_MAC_SUSPEND);
+
+	if (!(R_REG(osh, &regs->macintstatus) & MI_MACSSPNDD)) {
+		WL_ERROR(("wl%d: wlc_suspend_mac_and_wait: waited %d uS and "
+			  "MI_MACSSPNDD is still not on.\n",
+			  wlc_hw->unit, WLC_MAX_MAC_SUSPEND));
+		WL_ERROR(("wl%d: psmdebug 0x%08x, phydebug 0x%08x, psm_brc 0x%04x\n", wlc_hw->unit, R_REG(osh, &regs->psmdebug), R_REG(osh, &regs->phydebug), R_REG(osh, &regs->psm_brc)));
+	}
+
+	mc = R_REG(osh, &regs->maccontrol);
+	if (mc == 0xffffffff) {
+		WL_ERROR(("wl%d: %s: dead chip\n", wlc_hw->unit, __func__));
+		wl_down(wlc->wl);
+		return;
+	}
+	ASSERT(!(mc & MCTL_PSM_JMP_0));
+	ASSERT(mc & MCTL_PSM_RUN);
+	ASSERT(!(mc & MCTL_EN_MAC));
+}
+
+void wlc_enable_mac(wlc_info_t * wlc)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	d11regs_t *regs = wlc_hw->regs;
+	uint32 mc, mi;
+	osl_t *osh;
+
+	WL_TRACE(("wl%d: wlc_enable_mac: bandunit %d\n", wlc_hw->unit,
+		  wlc->band->bandunit));
+
+	/*
+	 * Track overlapping suspend requests
+	 */
+	ASSERT(wlc_hw->mac_suspend_depth > 0);
+	wlc_hw->mac_suspend_depth--;
+	if (wlc_hw->mac_suspend_depth > 0)
+		return;
+
+	osh = wlc_hw->osh;
+
+	mc = R_REG(osh, &regs->maccontrol);
+	ASSERT(!(mc & MCTL_PSM_JMP_0));
+	ASSERT(!(mc & MCTL_EN_MAC));
+	ASSERT(mc & MCTL_PSM_RUN);
+
+	wlc_bmac_mctrl(wlc_hw, MCTL_EN_MAC, MCTL_EN_MAC);
+	W_REG(osh, &regs->macintstatus, MI_MACSSPNDD);
+
+	mc = R_REG(osh, &regs->maccontrol);
+	ASSERT(!(mc & MCTL_PSM_JMP_0));
+	ASSERT(mc & MCTL_EN_MAC);
+	ASSERT(mc & MCTL_PSM_RUN);
+
+	mi = R_REG(osh, &regs->macintstatus);
+	ASSERT(!(mi & MI_MACSSPNDD));
+
+	wlc_ucode_wake_override_clear(wlc_hw, WLC_WAKE_OVERRIDE_MACSUSPEND);
+}
+
+void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t * wlc_hw, bool abie, bool isht)
+{
+	if (!(WLCISNPHY(wlc_hw->band) && (D11REV_GE(wlc_hw->corerev, 16))))
+		return;
+
+	if (isht) {
+		if (WLCISNPHY(wlc_hw->band) && NREV_LT(wlc_hw->band->phyrev, 3)) {
+			AND_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1,
+				~IFS_CTL1_EDCRS);
+		}
+	} else {
+		/* enable EDCRS for non-11n association */
+		OR_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1, IFS_CTL1_EDCRS);
+	}
+
+	if (WLCISNPHY(wlc_hw->band) && NREV_GE(wlc_hw->band->phyrev, 3)) {
+		if (CHSPEC_IS20(wlc_hw->chanspec)) {
+			/* 20 mhz, use 20U ED only */
+			OR_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1,
+			       IFS_CTL1_EDCRS);
+			AND_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1,
+				~IFS_CTL1_EDCRS_20L);
+			AND_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1,
+				~IFS_CTL1_EDCRS_40);
+		} else {
+			/* 40 mhz, use 20U 20L and 40 ED */
+			OR_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1,
+			       IFS_CTL1_EDCRS);
+			OR_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1,
+			       IFS_CTL1_EDCRS_20L);
+			OR_REG(wlc_hw->osh, &wlc_hw->regs->ifs_ctl1,
+			       IFS_CTL1_EDCRS_40);
+		}
+	}
+}
+
+static void wlc_upd_ofdm_pctl1_table(wlc_hw_info_t * wlc_hw)
+{
+	uint8 rate;
+	uint8 rates[8] = {
+		WLC_RATE_6M, WLC_RATE_9M, WLC_RATE_12M, WLC_RATE_18M,
+		WLC_RATE_24M, WLC_RATE_36M, WLC_RATE_48M, WLC_RATE_54M
+	};
+	uint16 entry_ptr;
+	uint16 pctl1;
+	uint i;
+
+	if (!WLC_PHY_11N_CAP(wlc_hw->band))
+		return;
+
+	/* walk the phy rate table and update the entries */
+	for (i = 0; i < ARRAYSIZE(rates); i++) {
+		rate = rates[i];
+
+		entry_ptr = wlc_bmac_ofdm_ratetable_offset(wlc_hw, rate);
+
+		/* read the SHM Rate Table entry OFDM PCTL1 values */
+		pctl1 =
+		    wlc_bmac_read_shm(wlc_hw, entry_ptr + M_RT_OFDM_PCTL1_POS);
+
+		/* modify the value */
+		pctl1 &= ~PHY_TXC1_MODE_MASK;
+		pctl1 |= (wlc_hw->hw_stf_ss_opmode << PHY_TXC1_MODE_SHIFT);
+
+		/* Update the SHM Rate Table entry OFDM PCTL1 values */
+		wlc_bmac_write_shm(wlc_hw, entry_ptr + M_RT_OFDM_PCTL1_POS,
+				   pctl1);
+	}
+}
+
+static uint16 wlc_bmac_ofdm_ratetable_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
+{
+	uint i;
+	uint8 plcp_rate = 0;
+	struct plcp_signal_rate_lookup {
+		uint8 rate;
+		uint8 signal_rate;
+	};
+	/* OFDM RATE sub-field of PLCP SIGNAL field, per 802.11 sec 17.3.4.1 */
+	const struct plcp_signal_rate_lookup rate_lookup[] = {
+		{WLC_RATE_6M, 0xB},
+		{WLC_RATE_9M, 0xF},
+		{WLC_RATE_12M, 0xA},
+		{WLC_RATE_18M, 0xE},
+		{WLC_RATE_24M, 0x9},
+		{WLC_RATE_36M, 0xD},
+		{WLC_RATE_48M, 0x8},
+		{WLC_RATE_54M, 0xC}
+	};
+
+	for (i = 0; i < ARRAYSIZE(rate_lookup); i++) {
+		if (rate == rate_lookup[i].rate) {
+			plcp_rate = rate_lookup[i].signal_rate;
+			break;
+		}
+	}
+
+	/* Find the SHM pointer to the rate table entry by looking in the
+	 * Direct-map Table
+	 */
+	return (2 * wlc_bmac_read_shm(wlc_hw, M_RT_DIRMAP_A + (plcp_rate * 2)));
+}
+
+void wlc_bmac_band_stf_ss_set(wlc_hw_info_t * wlc_hw, uint8 stf_mode)
+{
+	wlc_hw->hw_stf_ss_opmode = stf_mode;
+
+	if (wlc_hw->clk)
+		wlc_upd_ofdm_pctl1_table(wlc_hw);
+}
+
+void BCMFASTPATH
+wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw, uint32 * tsf_l_ptr,
+		  uint32 * tsf_h_ptr)
+{
+	d11regs_t *regs = wlc_hw->regs;
+
+	/* read the tsf timer low, then high to get an atomic read */
+	*tsf_l_ptr = R_REG(wlc_hw->osh, &regs->tsf_timerlow);
+	*tsf_h_ptr = R_REG(wlc_hw->osh, &regs->tsf_timerhigh);
+
+	return;
+}
+
+bool BCMATTACHFN(wlc_bmac_validate_chip_access) (wlc_hw_info_t * wlc_hw) {
+	d11regs_t *regs;
+	uint32 w, val;
+	volatile uint16 *reg16;
+	osl_t *osh;
+
+	WL_TRACE(("wl%d: validate_chip_access\n", wlc_hw->unit));
+
+	regs = wlc_hw->regs;
+	osh = wlc_hw->osh;
+
+	/* Validate dchip register access */
+
+	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
+	(void)R_REG(osh, &regs->objaddr);
+	w = R_REG(osh, &regs->objdata);
+
+	/* Can we write and read back a 32bit register? */
+	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
+	(void)R_REG(osh, &regs->objaddr);
+	W_REG(osh, &regs->objdata, (uint32) 0xaa5555aa);
+
+	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
+	(void)R_REG(osh, &regs->objaddr);
+	val = R_REG(osh, &regs->objdata);
+	if (val != (uint32) 0xaa5555aa) {
+		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0xaa5555aa\n", wlc_hw->unit, val));
+		return (FALSE);
+	}
+
+	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
+	(void)R_REG(osh, &regs->objaddr);
+	W_REG(osh, &regs->objdata, (uint32) 0x55aaaa55);
+
+	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
+	(void)R_REG(osh, &regs->objaddr);
+	val = R_REG(osh, &regs->objdata);
+	if (val != (uint32) 0x55aaaa55) {
+		WL_ERROR(("wl%d: validate_chip_access: SHM = 0x%x, expected 0x55aaaa55\n", wlc_hw->unit, val));
+		return (FALSE);
+	}
+
+	W_REG(osh, &regs->objaddr, OBJADDR_SHM_SEL | 0);
+	(void)R_REG(osh, &regs->objaddr);
+	W_REG(osh, &regs->objdata, w);
+
+	if (D11REV_LT(wlc_hw->corerev, 11)) {
+		/* if 32 bit writes are split into 16 bit writes, are they in the correct order
+		 * for our interface, low to high
+		 */
+		reg16 = (volatile uint16 *)(uintptr) & regs->tsf_cfpstart;
+
+		/* write the CFPStart register low half explicitly, starting a buffered write */
+		W_REG(osh, reg16, 0xAAAA);
+
+		/* Write a 32 bit value to CFPStart to test the 16 bit split order.
+		 * If the low 16 bits are written first, followed by the high 16 bits then the
+		 * 32 bit value 0xCCCCBBBB should end up in the register.
+		 * If the order is reversed, then the write to the high half will trigger a buffered
+		 * write of 0xCCCCAAAA.
+		 * If the bus is 32 bits, then this is not much of a test, and the reg should
+		 * have the correct value 0xCCCCBBBB.
+		 */
+		W_REG(osh, &regs->tsf_cfpstart, 0xCCCCBBBB);
+
+		/* verify with the 16 bit registers that have no side effects */
+		val = R_REG(osh, &regs->tsf_cfpstrt_l);
+		if (val != (uint) 0xBBBB) {
+			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_l = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xBBBB));
+			return (FALSE);
+		}
+		val = R_REG(osh, &regs->tsf_cfpstrt_h);
+		if (val != (uint) 0xCCCC) {
+			WL_ERROR(("wl%d: validate_chip_access: tsf_cfpstrt_h = 0x%x, expected" " 0x%x\n", wlc_hw->unit, val, 0xCCCC));
+			return (FALSE);
+		}
+
+	}
+
+	/* clear CFPStart */
+	W_REG(osh, &regs->tsf_cfpstart, 0);
+
+	w = R_REG(osh, &regs->maccontrol);
+	if ((w != (MCTL_IHR_EN | MCTL_WAKE)) &&
+	    (w != (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE))) {
+		WL_ERROR(("wl%d: validate_chip_access: maccontrol = 0x%x, expected 0x%x or 0x%x\n", wlc_hw->unit, w, (MCTL_IHR_EN | MCTL_WAKE), (MCTL_IHR_EN | MCTL_GMODE | MCTL_WAKE)));
+		return (FALSE);
+	}
+
+	return (TRUE);
+}
+
+#define PHYPLL_WAIT_US	100000
+
+void wlc_bmac_core_phypll_ctl(wlc_hw_info_t * wlc_hw, bool on)
+{
+	d11regs_t *regs;
+	osl_t *osh;
+	uint32 tmp;
+
+	WL_TRACE(("wl%d: wlc_bmac_core_phypll_ctl\n", wlc_hw->unit));
+
+	tmp = 0;
+	regs = wlc_hw->regs;
+	osh = wlc_hw->osh;
+
+	if (D11REV_LE(wlc_hw->corerev, 16) || D11REV_IS(wlc_hw->corerev, 20))
+		return;
+
+	if (on) {
+		if ((wlc_hw->sih->chip == BCM4313_CHIP_ID)) {
+			OR_REG(osh, &regs->clk_ctl_st,
+			       (CCS_ERSRC_REQ_HT | CCS_ERSRC_REQ_D11PLL |
+				CCS_ERSRC_REQ_PHYPLL));
+			SPINWAIT((R_REG(osh, &regs->clk_ctl_st) &
+				  (CCS_ERSRC_AVAIL_HT)) != (CCS_ERSRC_AVAIL_HT),
+				 PHYPLL_WAIT_US);
+
+			tmp = R_REG(osh, &regs->clk_ctl_st);
+			if ((tmp & (CCS_ERSRC_AVAIL_HT)) !=
+			    (CCS_ERSRC_AVAIL_HT)) {
+				WL_ERROR(("%s: turn on PHY PLL failed\n",
+					  __func__));
+				ASSERT(0);
+			}
+		} else {
+			OR_REG(osh, &regs->clk_ctl_st,
+			       (CCS_ERSRC_REQ_D11PLL | CCS_ERSRC_REQ_PHYPLL));
+			SPINWAIT((R_REG(osh, &regs->clk_ctl_st) &
+				  (CCS_ERSRC_AVAIL_D11PLL |
+				   CCS_ERSRC_AVAIL_PHYPLL)) !=
+				 (CCS_ERSRC_AVAIL_D11PLL |
+				  CCS_ERSRC_AVAIL_PHYPLL), PHYPLL_WAIT_US);
+
+			tmp = R_REG(osh, &regs->clk_ctl_st);
+			if ((tmp &
+			     (CCS_ERSRC_AVAIL_D11PLL | CCS_ERSRC_AVAIL_PHYPLL))
+			    !=
+			    (CCS_ERSRC_AVAIL_D11PLL | CCS_ERSRC_AVAIL_PHYPLL)) {
+				WL_ERROR(("%s: turn on PHY PLL failed\n",
+					  __func__));
+				ASSERT(0);
+			}
+		}
+	} else {
+		/* Since the PLL may be shared, other cores can still be requesting it;
+		 * so we'll deassert the request but not wait for status to comply.
+		 */
+		AND_REG(osh, &regs->clk_ctl_st, ~CCS_ERSRC_REQ_PHYPLL);
+		tmp = R_REG(osh, &regs->clk_ctl_st);
+	}
+}
+
+void wlc_coredisable(wlc_hw_info_t * wlc_hw)
+{
+	bool dev_gone;
+
+	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
+
+	ASSERT(!wlc_hw->up);
+
+	dev_gone = DEVICEREMOVED(wlc_hw->wlc);
+
+	if (dev_gone)
+		return;
+
+	if (wlc_hw->noreset)
+		return;
+
+	/* radio off */
+	wlc_phy_switch_radio(wlc_hw->band->pi, OFF);
+
+	/* turn off analog core */
+	wlc_phy_anacore(wlc_hw->band->pi, OFF);
+
+	/* turn off PHYPLL to save power */
+	wlc_bmac_core_phypll_ctl(wlc_hw, FALSE);
+
+	/* No need to set wlc->pub->radio_active = OFF
+	 * because this function needs down capability and
+	 * radio_active is designed for BCMNODOWN.
+	 */
+
+	/* remove gpio controls */
+	if (wlc_hw->ucode_dbgsel)
+		si_gpiocontrol(wlc_hw->sih, ~0, 0, GPIO_DRV_PRIORITY);
+
+	wlc_hw->clk = FALSE;
+	si_core_disable(wlc_hw->sih, 0);
+	wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+}
+
+/* power both the pll and external oscillator on/off */
+void wlc_bmac_xtal(wlc_hw_info_t * wlc_hw, bool want)
+{
+	WL_TRACE(("wl%d: wlc_bmac_xtal: want %d\n", wlc_hw->unit, want));
+
+	/* dont power down if plldown is false or we must poll hw radio disable */
+	if (!want && wlc_hw->pllreq)
+		return;
+
+	if (wlc_hw->sih)
+		si_clkctl_xtal(wlc_hw->sih, XTAL | PLL, want);
+
+	wlc_hw->sbclk = want;
+	if (!wlc_hw->sbclk) {
+		wlc_hw->clk = FALSE;
+		if (wlc_hw->band && wlc_hw->band->pi)
+			wlc_phy_hw_clk_state_upd(wlc_hw->band->pi, FALSE);
+	}
+}
+
+static void wlc_flushqueues(wlc_info_t * wlc)
+{
+	wlc_hw_info_t *wlc_hw = wlc->hw;
+	uint i;
+
+	wlc->txpend16165war = 0;
+
+	/* free any posted tx packets */
+	for (i = 0; i < NFIFO; i++)
+		if (wlc_hw->di[i]) {
+			dma_txreclaim(wlc_hw->di[i], HNDDMA_RANGE_ALL);
+			TXPKTPENDCLR(wlc, i);
+			WL_TRACE(("wlc_flushqueues: pktpend fifo %d cleared\n",
+				  i));
+		}
+
+	/* free any posted rx packets */
+	dma_rxreclaim(wlc_hw->di[RX_FIFO]);
+	if (D11REV_IS(wlc_hw->corerev, 4))
+		dma_rxreclaim(wlc_hw->di[RX_TXSTATUS_FIFO]);
+}
+
+uint16 wlc_bmac_read_shm(wlc_hw_info_t * wlc_hw, uint offset)
+{
+	return wlc_bmac_read_objmem(wlc_hw, offset, OBJADDR_SHM_SEL);
+}
+
+void wlc_bmac_write_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v)
+{
+	wlc_bmac_write_objmem(wlc_hw, offset, v, OBJADDR_SHM_SEL);
+}
+
+/* Set a range of shared memory to a value.
+ * SHM 'offset' needs to be an even address and
+ * Buffer length 'len' must be an even number of bytes
+ */
+void wlc_bmac_set_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, int len)
+{
+	int i;
+
+	/* offset and len need to be even */
+	ASSERT((offset & 1) == 0);
+	ASSERT((len & 1) == 0);
+
+	if (len <= 0)
+		return;
+
+	for (i = 0; i < len; i += 2) {
+		wlc_bmac_write_objmem(wlc_hw, offset + i, v, OBJADDR_SHM_SEL);
+	}
+}
+
+static uint16
+wlc_bmac_read_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint32 sel)
+{
+	d11regs_t *regs = wlc_hw->regs;
+	volatile uint16 *objdata_lo =
+	    (volatile uint16 *)(uintptr) & regs->objdata;
+	volatile uint16 *objdata_hi = objdata_lo + 1;
+	uint16 v;
+
+	ASSERT((offset & 1) == 0);
+
+	W_REG(wlc_hw->osh, &regs->objaddr, sel | (offset >> 2));
+	(void)R_REG(wlc_hw->osh, &regs->objaddr);
+	if (offset & 2) {
+		v = R_REG(wlc_hw->osh, objdata_hi);
+	} else {
+		v = R_REG(wlc_hw->osh, objdata_lo);
+	}
+
+	return v;
+}
+
+static void
+wlc_bmac_write_objmem(wlc_hw_info_t * wlc_hw, uint offset, uint16 v, uint32 sel)
+{
+	d11regs_t *regs = wlc_hw->regs;
+	volatile uint16 *objdata_lo =
+	    (volatile uint16 *)(uintptr) & regs->objdata;
+	volatile uint16 *objdata_hi = objdata_lo + 1;
+
+	ASSERT((offset & 1) == 0);
+
+	W_REG(wlc_hw->osh, &regs->objaddr, sel | (offset >> 2));
+	(void)R_REG(wlc_hw->osh, &regs->objaddr);
+	if (offset & 2) {
+		W_REG(wlc_hw->osh, objdata_hi, v);
+	} else {
+		W_REG(wlc_hw->osh, objdata_lo, v);
+	}
+}
+
+/* Copy a buffer to shared memory of specified type .
+ * SHM 'offset' needs to be an even address and
+ * Buffer length 'len' must be an even number of bytes
+ * 'sel' selects the type of memory
+ */
+void
+wlc_bmac_copyto_objmem(wlc_hw_info_t * wlc_hw, uint offset, const void *buf,
+		       int len, uint32 sel)
+{
+	uint16 v;
+	const uint8 *p = (const uint8 *)buf;
+	int i;
+
+	/* offset and len need to be even */
+	ASSERT((offset & 1) == 0);
+	ASSERT((len & 1) == 0);
+
+	if (len <= 0)
+		return;
+
+	for (i = 0; i < len; i += 2) {
+		v = p[i] | (p[i + 1] << 8);
+		wlc_bmac_write_objmem(wlc_hw, offset + i, v, sel);
+	}
+}
+
+/* Copy a piece of shared memory of specified type to a buffer .
+ * SHM 'offset' needs to be an even address and
+ * Buffer length 'len' must be an even number of bytes
+ * 'sel' selects the type of memory
+ */
+void
+wlc_bmac_copyfrom_objmem(wlc_hw_info_t * wlc_hw, uint offset, void *buf,
+			 int len, uint32 sel)
+{
+	uint16 v;
+	uint8 *p = (uint8 *) buf;
+	int i;
+
+	/* offset and len need to be even */
+	ASSERT((offset & 1) == 0);
+	ASSERT((len & 1) == 0);
+
+	if (len <= 0)
+		return;
+
+	for (i = 0; i < len; i += 2) {
+		v = wlc_bmac_read_objmem(wlc_hw, offset + i, sel);
+		p[i] = v & 0xFF;
+		p[i + 1] = (v >> 8) & 0xFF;
+	}
+}
+
+void wlc_bmac_copyfrom_vars(wlc_hw_info_t * wlc_hw, char **buf, uint * len)
+{
+	WL_TRACE(("wlc_bmac_copyfrom_vars, nvram vars totlen=%d\n",
+		  wlc_hw->vars_size));
+
+	*buf = wlc_hw->vars;
+	*len = wlc_hw->vars_size;
+}
+
+void wlc_bmac_retrylimit_upd(wlc_hw_info_t * wlc_hw, uint16 SRL, uint16 LRL)
+{
+	wlc_hw->SRL = SRL;
+	wlc_hw->LRL = LRL;
+
+	/* write retry limit to SCR, shouldn't need to suspend */
+	if (wlc_hw->up) {
+		W_REG(wlc_hw->osh, &wlc_hw->regs->objaddr,
+		      OBJADDR_SCR_SEL | S_DOT11_SRC_LMT);
+		(void)R_REG(wlc_hw->osh, &wlc_hw->regs->objaddr);
+		W_REG(wlc_hw->osh, &wlc_hw->regs->objdata, wlc_hw->SRL);
+		W_REG(wlc_hw->osh, &wlc_hw->regs->objaddr,
+		      OBJADDR_SCR_SEL | S_DOT11_LRC_LMT);
+		(void)R_REG(wlc_hw->osh, &wlc_hw->regs->objaddr);
+		W_REG(wlc_hw->osh, &wlc_hw->regs->objdata, wlc_hw->LRL);
+	}
+}
+
+void wlc_bmac_set_noreset(wlc_hw_info_t * wlc_hw, bool noreset_flag)
+{
+	wlc_hw->noreset = noreset_flag;
+}
+
+void wlc_bmac_set_ucode_loaded(wlc_hw_info_t * wlc_hw, bool ucode_loaded)
+{
+	wlc_hw->ucode_loaded = ucode_loaded;
+}
+
+void wlc_bmac_pllreq(wlc_hw_info_t * wlc_hw, bool set, mbool req_bit)
+{
+	ASSERT(req_bit);
+
+	if (set) {
+		if (mboolisset(wlc_hw->pllreq, req_bit))
+			return;
+
+		mboolset(wlc_hw->pllreq, req_bit);
+
+		if (mboolisset(wlc_hw->pllreq, WLC_PLLREQ_FLIP)) {
+			if (!wlc_hw->sbclk) {
+				wlc_bmac_xtal(wlc_hw, ON);
+			}
+		}
+	} else {
+		if (!mboolisset(wlc_hw->pllreq, req_bit))
+			return;
+
+		mboolclr(wlc_hw->pllreq, req_bit);
+
+		if (mboolisset(wlc_hw->pllreq, WLC_PLLREQ_FLIP)) {
+			if (wlc_hw->sbclk) {
+				wlc_bmac_xtal(wlc_hw, OFF);
+			}
+		}
+	}
+
+	return;
+}
+
+void wlc_bmac_set_clk(wlc_hw_info_t * wlc_hw, bool on)
+{
+	if (on) {
+		/* power up pll and oscillator */
+		wlc_bmac_xtal(wlc_hw, ON);
+
+		/* enable core(s), ignore bandlocked
+		 * Leave with the same band selected as we entered
+		 */
+		wlc_bmac_corereset(wlc_hw, WLC_USE_COREFLAGS);
+	} else {
+		/* if already down, must skip the core disable */
+		if (wlc_hw->clk) {
+			/* disable core(s), ignore bandlocked */
+			wlc_coredisable(wlc_hw);
+		}
+		/* power down pll and oscillator */
+		wlc_bmac_xtal(wlc_hw, OFF);
+	}
+}
+
+/* this will be true for all ai chips */
+bool wlc_bmac_taclear(wlc_hw_info_t * wlc_hw, bool ta_ok)
+{
+	return TRUE;
+}
+
+/* Lower down relevant GPIOs like LED when going down w/o
+ * doing PCI config cycles or touching interrupts
+ */
+void wlc_gpio_fast_deinit(wlc_hw_info_t * wlc_hw)
+{
+	if ((wlc_hw == NULL) || (wlc_hw->sih == NULL))
+		return;
+
+	/* Only chips with internal bus or PCIE cores or certain PCI cores
+	 * are able to switch cores w/o disabling interrupts
+	 */
+	if (!((BUSTYPE(wlc_hw->sih->bustype) == SI_BUS) ||
+	      ((BUSTYPE(wlc_hw->sih->bustype) == PCI_BUS) &&
+	       ((wlc_hw->sih->buscoretype == PCIE_CORE_ID) ||
+		(wlc_hw->sih->buscorerev >= 13)))))
+		return;
+
+	WL_TRACE(("wl%d: %s\n", wlc_hw->unit, __func__));
+	return;
+}
+
+bool wlc_bmac_radio_hw(wlc_hw_info_t * wlc_hw, bool enable)
+{
+	/* Do not access Phy registers if core is not up */
+	if (si_iscoreup(wlc_hw->sih) == FALSE)
+		return FALSE;
+
+	if (enable) {
+		if (PMUCTL_ENAB(wlc_hw->sih)) {
+			AND_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
+				~CCS_FORCEHWREQOFF);
+			si_pmu_radio_enable(wlc_hw->sih, TRUE);
+		}
+
+		wlc_phy_anacore(wlc_hw->band->pi, ON);
+		wlc_phy_switch_radio(wlc_hw->band->pi, ON);
+
+		/* resume d11 core */
+		wlc_enable_mac(wlc_hw->wlc);
+	} else {
+		/* suspend d11 core */
+		wlc_suspend_mac_and_wait(wlc_hw->wlc);
+
+		wlc_phy_switch_radio(wlc_hw->band->pi, OFF);
+		wlc_phy_anacore(wlc_hw->band->pi, OFF);
+
+		if (PMUCTL_ENAB(wlc_hw->sih)) {
+			si_pmu_radio_enable(wlc_hw->sih, FALSE);
+			OR_REG(wlc_hw->osh, &wlc_hw->regs->clk_ctl_st,
+			       CCS_FORCEHWREQOFF);
+		}
+	}
+
+	return TRUE;
+}
+
+uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t * wlc_hw, uint8 rate)
+{
+	uint16 table_ptr;
+	uint8 phy_rate, index;
+
+	/* get the phy specific rate encoding for the PLCP SIGNAL field */
+	/* XXX4321 fixup needed ? */
+	if (IS_OFDM(rate))
+		table_ptr = M_RT_DIRMAP_A;
+	else
+		table_ptr = M_RT_DIRMAP_B;
+
+	/* for a given rate, the LS-nibble of the PLCP SIGNAL field is
+	 * the index into the rate table.
+	 */
+	phy_rate = rate_info[rate] & RATE_MASK;
+	index = phy_rate & 0xf;
+
+	/* Find the SHM pointer to the rate table entry by looking in the
+	 * Direct-map Table
+	 */
+	return (2 * wlc_bmac_read_shm(wlc_hw, table_ptr + (index * 2)));
+}
+
+void wlc_bmac_set_txpwr_percent(wlc_hw_info_t * wlc_hw, uint8 val)
+{
+	wlc_phy_txpwr_percent_set(wlc_hw->band->pi, val);
+}
+
+void wlc_bmac_antsel_set(wlc_hw_info_t * wlc_hw, uint32 antsel_avail)
+{
+	wlc_hw->antsel_avail = antsel_avail;
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_bmac.h b/drivers/staging/brcm80211/sys/wlc_bmac.h
new file mode 100644
index 0000000..d4f69a0
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_bmac.h
@@ -0,0 +1,277 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/* XXXXX this interface is under wlc.c by design
+ * http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/WlBmacDesign
+ *
+ *        high driver files(e.g. wlc_ampdu.c etc)
+ *             wlc.h/wlc.c
+ *         wlc_bmac.h/wlc_bmac.c
+ *
+ *  So don't include this in files other than wlc.c, wlc_bmac* wl_rte.c(dongle port) and wl_phy.c
+ *  create wrappers in wlc.c if needed
+ */
+
+/* Revision and other info required from BMAC driver for functioning of high ONLY driver */
+typedef struct wlc_bmac_revinfo {
+	uint vendorid;		/* PCI vendor id */
+	uint deviceid;		/* device id of chip */
+
+	uint boardrev;		/* version # of particular board */
+	uint corerev;		/* core revision */
+	uint sromrev;		/* srom revision */
+	uint chiprev;		/* chip revision */
+	uint chip;		/* chip number */
+	uint chippkg;		/* chip package */
+	uint boardtype;		/* board type */
+	uint boardvendor;	/* board vendor */
+	uint bustype;		/* SB_BUS, PCI_BUS  */
+	uint buscoretype;	/* PCI_CORE_ID, PCIE_CORE_ID, PCMCIA_CORE_ID */
+	uint buscorerev;	/* buscore rev */
+	uint32 issim;		/* chip is in simulation or emulation */
+
+	uint nbands;
+
+	struct band_info {
+		uint bandunit;	/* To match on both sides */
+		uint bandtype;	/* To match on both sides */
+		uint radiorev;
+		uint phytype;
+		uint phyrev;
+		uint anarev;
+		uint radioid;
+		bool abgphy_encore;
+	} band[MAXBANDS];
+} wlc_bmac_revinfo_t;
+
+/* dup state between BMAC(wlc_hw_info_t) and HIGH(wlc_info_t) driver */
+typedef struct wlc_bmac_state {
+	uint32 machwcap;	/* mac hw capibility */
+	uint32 preamble_ovr;	/* preamble override */
+} wlc_bmac_state_t;
+
+enum {
+	IOV_BMAC_DIAG,
+	IOV_BMAC_SBGPIOTIMERVAL,
+	IOV_BMAC_SBGPIOOUT,
+	IOV_BMAC_CCGPIOCTRL,	/* CC GPIOCTRL REG */
+	IOV_BMAC_CCGPIOOUT,	/* CC GPIOOUT REG */
+	IOV_BMAC_CCGPIOOUTEN,	/* CC GPIOOUTEN REG */
+	IOV_BMAC_CCGPIOIN,	/* CC GPIOIN REG */
+	IOV_BMAC_WPSGPIO,	/* WPS push button GPIO pin */
+	IOV_BMAC_OTPDUMP,
+	IOV_BMAC_OTPSTAT,
+	IOV_BMAC_PCIEASPM,	/* obfuscation clkreq/aspm control */
+	IOV_BMAC_PCIEADVCORRMASK,	/* advanced correctable error mask */
+	IOV_BMAC_PCIECLKREQ,	/* PCIE 1.1 clockreq enab support */
+	IOV_BMAC_PCIELCREG,	/* PCIE LCREG */
+	IOV_BMAC_SBGPIOTIMERMASK,
+	IOV_BMAC_RFDISABLEDLY,
+	IOV_BMAC_PCIEREG,	/* PCIE REG */
+	IOV_BMAC_PCICFGREG,	/* PCI Config register */
+	IOV_BMAC_PCIESERDESREG,	/* PCIE SERDES REG (dev, 0}offset) */
+	IOV_BMAC_PCIEGPIOOUT,	/* PCIEOUT REG */
+	IOV_BMAC_PCIEGPIOOUTEN,	/* PCIEOUTEN REG */
+	IOV_BMAC_PCIECLKREQENCTRL,	/* clkreqenctrl REG (PCIE REV > 6.0 */
+	IOV_BMAC_DMALPBK,
+	IOV_BMAC_CCREG,
+	IOV_BMAC_COREREG,
+	IOV_BMAC_SDCIS,
+	IOV_BMAC_SDIO_DRIVE,
+	IOV_BMAC_OTPW,
+	IOV_BMAC_NVOTPW,
+	IOV_BMAC_SROM,
+	IOV_BMAC_SRCRC,
+	IOV_BMAC_CIS_SOURCE,
+	IOV_BMAC_CISVAR,
+	IOV_BMAC_OTPLOCK,
+	IOV_BMAC_OTP_CHIPID,
+	IOV_BMAC_CUSTOMVAR1,
+	IOV_BMAC_BOARDFLAGS,
+	IOV_BMAC_BOARDFLAGS2,
+	IOV_BMAC_WPSLED,
+	IOV_BMAC_NVRAM_SOURCE,
+	IOV_BMAC_OTP_RAW_READ,
+	IOV_BMAC_LAST
+};
+
+typedef enum {
+	BMAC_DUMP_GPIO_ID,
+	BMAC_DUMP_SI_ID,
+	BMAC_DUMP_SIREG_ID,
+	BMAC_DUMP_SICLK_ID,
+	BMAC_DUMP_CCREG_ID,
+	BMAC_DUMP_PCIEREG_ID,
+	BMAC_DUMP_PHYREG_ID,
+	BMAC_DUMP_PHYTBL_ID,
+	BMAC_DUMP_PHYTBL2_ID,
+	BMAC_DUMP_PHY_RADIOREG_ID,
+	BMAC_DUMP_LAST
+} wlc_bmac_dump_id_t;
+
+typedef enum {
+	WLCHW_STATE_ATTACH,
+	WLCHW_STATE_CLK,
+	WLCHW_STATE_UP,
+	WLCHW_STATE_ASSOC,
+	WLCHW_STATE_LAST
+} wlc_bmac_state_id_t;
+
+extern int wlc_bmac_attach(wlc_info_t * wlc, uint16 vendor, uint16 device,
+			   uint unit, bool piomode, osl_t * osh, void *regsva,
+			   uint bustype, void *btparam);
+extern int wlc_bmac_detach(wlc_info_t * wlc);
+extern void wlc_bmac_watchdog(void *arg);
+extern void wlc_bmac_info_init(wlc_hw_info_t * wlc_hw);
+
+/* up/down, reset, clk */
+#ifdef WLC_LOW
+extern void wlc_bmac_xtal(wlc_hw_info_t * wlc_hw, bool want);
+#endif
+
+extern void wlc_bmac_copyto_objmem(wlc_hw_info_t * wlc_hw,
+				   uint offset, const void *buf, int len,
+				   uint32 sel);
+extern void wlc_bmac_copyfrom_objmem(wlc_hw_info_t * wlc_hw, uint offset,
+				     void *buf, int len, uint32 sel);
+#define wlc_bmac_copyfrom_shm(wlc_hw, offset, buf, len)                 \
+	wlc_bmac_copyfrom_objmem(wlc_hw, offset, buf, len, OBJADDR_SHM_SEL)
+#define wlc_bmac_copyto_shm(wlc_hw, offset, buf, len)                   \
+	wlc_bmac_copyto_objmem(wlc_hw, offset, buf, len, OBJADDR_SHM_SEL)
+
+extern void wlc_bmac_core_phy_clk(wlc_hw_info_t * wlc_hw, bool clk);
+extern void wlc_bmac_core_phypll_reset(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_core_phypll_ctl(wlc_hw_info_t * wlc_hw, bool on);
+extern void wlc_bmac_phyclk_fgc(wlc_hw_info_t * wlc_hw, bool clk);
+extern void wlc_bmac_macphyclk_set(wlc_hw_info_t * wlc_hw, bool clk);
+extern void wlc_bmac_phy_reset(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_corereset(wlc_hw_info_t * wlc_hw, uint32 flags);
+extern void wlc_bmac_reset(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_init(wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+			  bool mute);
+extern int wlc_bmac_up_prep(wlc_hw_info_t * wlc_hw);
+extern int wlc_bmac_up_finish(wlc_hw_info_t * wlc_hw);
+extern int wlc_bmac_down_prep(wlc_hw_info_t * wlc_hw);
+extern int wlc_bmac_down_finish(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_corereset(wlc_hw_info_t * wlc_hw, uint32 flags);
+extern void wlc_bmac_switch_macfreq(wlc_hw_info_t * wlc_hw, uint8 spurmode);
+
+/* chanspec, ucode interface */
+extern int wlc_bmac_bandtype(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_set_chanspec(wlc_hw_info_t * wlc_hw, chanspec_t chanspec,
+				  bool mute, struct txpwr_limits *txpwr);
+
+extern void wlc_bmac_txfifo(wlc_hw_info_t * wlc_hw, uint fifo, void *p,
+			    bool commit, uint16 frameid, uint8 txpktpend);
+extern int wlc_bmac_xmtfifo_sz_get(wlc_hw_info_t * wlc_hw, uint fifo,
+				   uint * blocks);
+extern void wlc_bmac_mhf(wlc_hw_info_t * wlc_hw, uint8 idx, uint16 mask,
+			 uint16 val, int bands);
+extern void wlc_bmac_mctrl(wlc_hw_info_t * wlc_hw, uint32 mask, uint32 val);
+extern uint16 wlc_bmac_mhf_get(wlc_hw_info_t * wlc_hw, uint8 idx, int bands);
+extern int wlc_bmac_xmtfifo_sz_set(wlc_hw_info_t * wlc_hw, uint fifo,
+				   uint blocks);
+extern void wlc_bmac_txant_set(wlc_hw_info_t * wlc_hw, uint16 phytxant);
+extern uint16 wlc_bmac_get_txant(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_antsel_type_set(wlc_hw_info_t * wlc_hw, uint8 antsel_type);
+extern int wlc_bmac_revinfo_get(wlc_hw_info_t * wlc_hw,
+				wlc_bmac_revinfo_t * revinfo);
+extern int wlc_bmac_state_get(wlc_hw_info_t * wlc_hw, wlc_bmac_state_t * state);
+extern void wlc_bmac_write_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v);
+extern uint16 wlc_bmac_read_shm(wlc_hw_info_t * wlc_hw, uint offset);
+extern void wlc_bmac_set_shm(wlc_hw_info_t * wlc_hw, uint offset, uint16 v,
+			     int len);
+extern void wlc_bmac_write_template_ram(wlc_hw_info_t * wlc_hw, int offset,
+					int len, void *buf);
+extern void wlc_bmac_copyfrom_vars(wlc_hw_info_t * wlc_hw, char **buf,
+				   uint * len);
+
+extern void wlc_bmac_process_ps_switch(wlc_hw_info_t * wlc,
+				       struct ether_addr *ea, int8 ps_on);
+extern void wlc_bmac_hw_etheraddr(wlc_hw_info_t * wlc_hw,
+				  struct ether_addr *ea);
+extern void wlc_bmac_set_hw_etheraddr(wlc_hw_info_t * wlc_hw,
+				      struct ether_addr *ea);
+extern bool wlc_bmac_validate_chip_access(wlc_hw_info_t * wlc_hw);
+
+extern bool wlc_bmac_radio_read_hwdisabled(wlc_hw_info_t * wlc_hw);
+extern void wlc_bmac_set_shortslot(wlc_hw_info_t * wlc_hw, bool shortslot);
+extern void wlc_bmac_mute(wlc_hw_info_t * wlc_hw, bool want, mbool flags);
+extern void wlc_bmac_set_deaf(wlc_hw_info_t * wlc_hw, bool user_flag);
+extern void wlc_bmac_band_stf_ss_set(wlc_hw_info_t * wlc_hw, uint8 stf_mode);
+
+extern void wlc_bmac_wait_for_wake(wlc_hw_info_t * wlc_hw);
+extern bool wlc_bmac_tx_fifo_suspended(wlc_hw_info_t * wlc_hw, uint tx_fifo);
+extern void wlc_bmac_tx_fifo_suspend(wlc_hw_info_t * wlc_hw, uint tx_fifo);
+extern void wlc_bmac_tx_fifo_resume(wlc_hw_info_t * wlc_hw, uint tx_fifo);
+
+extern void wlc_ucode_wake_override_set(wlc_hw_info_t * wlc_hw,
+					uint32 override_bit);
+extern void wlc_ucode_wake_override_clear(wlc_hw_info_t * wlc_hw,
+					  uint32 override_bit);
+
+extern void wlc_bmac_set_rcmta(wlc_hw_info_t * wlc_hw, int idx,
+			       const struct ether_addr *addr);
+extern void wlc_bmac_set_addrmatch(wlc_hw_info_t * wlc_hw, int match_reg_offset,
+				   const struct ether_addr *addr);
+extern void wlc_bmac_write_hw_bcntemplates(wlc_hw_info_t * wlc_hw, void *bcn,
+					   int len, bool both);
+
+extern void wlc_bmac_read_tsf(wlc_hw_info_t * wlc_hw, uint32 * tsf_l_ptr,
+			      uint32 * tsf_h_ptr);
+extern void wlc_bmac_set_cwmin(wlc_hw_info_t * wlc_hw, uint16 newmin);
+extern void wlc_bmac_set_cwmax(wlc_hw_info_t * wlc_hw, uint16 newmax);
+extern void wlc_bmac_set_noreset(wlc_hw_info_t * wlc, bool noreset_flag);
+extern void wlc_bmac_set_ucode_loaded(wlc_hw_info_t * wlc, bool ucode_loaded);
+
+extern void wlc_bmac_retrylimit_upd(wlc_hw_info_t * wlc_hw, uint16 SRL,
+				    uint16 LRL);
+
+extern void wlc_bmac_fifoerrors(wlc_hw_info_t * wlc_hw);
+
+#ifdef WLC_HIGH_ONLY
+extern void wlc_bmac_dngl_reboot(rpc_info_t *);
+extern void wlc_bmac_dngl_rpc_agg(rpc_info_t *, uint16 agg);
+extern void wlc_bmac_dngl_rpc_msglevel(rpc_info_t *, uint16 level);
+extern void wlc_bmac_dngl_rpc_txq_wm_set(rpc_info_t * rpc, uint32 wm);
+extern void wlc_bmac_dngl_rpc_txq_wm_get(rpc_info_t * rpc, uint32 * wm);
+extern void wlc_bmac_dngl_rpc_agg_limit_set(rpc_info_t * rpc, uint32 val);
+extern void wlc_bmac_dngl_rpc_agg_limit_get(rpc_info_t * rpc, uint32 * pval);
+extern int wlc_bmac_debug_template(wlc_hw_info_t * wlc_hw);
+#endif
+
+/* API for BMAC driver (e.g. wlc_phy.c etc) */
+
+extern void wlc_bmac_bw_set(wlc_hw_info_t * wlc_hw, uint16 bw);
+extern void wlc_bmac_pllreq(wlc_hw_info_t * wlc_hw, bool set, mbool req_bit);
+extern void wlc_bmac_set_clk(wlc_hw_info_t * wlc_hw, bool on);
+extern bool wlc_bmac_taclear(wlc_hw_info_t * wlc_hw, bool ta_ok);
+extern void wlc_bmac_hw_up(struct wlc_hw_info *wlc_hw);
+
+extern void wlc_bmac_dump(wlc_hw_info_t * wlc_hw, struct bcmstrbuf *b,
+			  wlc_bmac_dump_id_t dump_id);
+extern void wlc_gpio_fast_deinit(wlc_hw_info_t * wlc_hw);
+
+extern bool wlc_bmac_radio_hw(wlc_hw_info_t * wlc_hw, bool enable);
+extern uint16 wlc_bmac_rate_shm_offset(wlc_hw_info_t * wlc_hw, uint8 rate);
+
+extern void wlc_bmac_assert_type_set(wlc_hw_info_t * wlc_hw, uint32 type);
+extern void wlc_bmac_set_txpwr_percent(wlc_hw_info_t * wlc_hw, uint8 val);
+extern void wlc_bmac_blink_sync(wlc_hw_info_t * wlc_hw, uint32 led_pins);
+extern void wlc_bmac_ifsctl_edcrs_set(wlc_hw_info_t * wlc_hw, bool abie,
+				      bool isht);
+
+extern void wlc_bmac_antsel_set(wlc_hw_info_t * wlc_hw, uint32 antsel_avail);
diff --git a/drivers/staging/brcm80211/sys/wlc_bsscfg.h b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
new file mode 100644
index 0000000..af0886d
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_bsscfg.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLC_BSSCFG_H_
+#define _WLC_BSSCFG_H_
+
+#include <wlc_types.h>
+
+/* Check if a particular BSS config is AP or STA */
+#define BSSCFG_AP(cfg)		(0)
+#define BSSCFG_STA(cfg)		(1)
+
+#define BSSCFG_IBSS(cfg)	(!(cfg)->BSS)
+
+/* forward declarations */
+typedef struct wlc_bsscfg wlc_bsscfg_t;
+
+#include <wlc_rate.h>
+
+#define NTXRATE			64	/* # tx MPDUs rate is reported for */
+#define MAXMACLIST		64	/* max # source MAC matches */
+#define BCN_TEMPLATE_COUNT 	2
+
+/* Iterator for "associated" STA bss configs:  (wlc_info_t *wlc, int idx, wlc_bsscfg_t *cfg) */
+#define FOREACH_AS_STA(wlc, idx, cfg) \
+	for (idx = 0; (int) idx < WLC_MAXBSSCFG; idx++) \
+		if ((cfg = (wlc)->bsscfg[idx]) && BSSCFG_STA(cfg) && cfg->associated)
+
+/* As above for all non-NULL BSS configs */
+#define FOREACH_BSS(wlc, idx, cfg) \
+	for (idx = 0; (int) idx < WLC_MAXBSSCFG; idx++) \
+		if ((cfg = (wlc)->bsscfg[idx]))
+
+/* BSS configuration state */
+struct wlc_bsscfg {
+	struct wlc_info *wlc;	/* wlc to which this bsscfg belongs to. */
+	bool up;		/* is this configuration up operational */
+	bool enable;		/* is this configuration enabled */
+	bool associated;	/* is BSS in ASSOCIATED state */
+	bool BSS;		/* infraustructure or adhac */
+	bool dtim_programmed;
+#ifdef LATER
+	bool _ap;		/* is this configuration an AP */
+	struct wlc_if *wlcif;	/* virtual interface, NULL for primary bsscfg */
+	void *sup;		/* pointer to supplicant state */
+	int8 sup_type;		/* type of supplicant */
+	bool sup_enable_wpa;	/* supplicant WPA on/off */
+	void *authenticator;	/* pointer to authenticator state */
+	bool sup_auth_pending;	/* flag for auth timeout */
+#endif
+	uint8 SSID_len;		/* the length of SSID */
+	uint8 SSID[DOT11_MAX_SSID_LEN];	/* SSID string */
+	struct scb *bcmc_scb[MAXBANDS];	/* one bcmc_scb per band */
+	int8 _idx;		/* the index of this bsscfg,
+				 * assigned at wlc_bsscfg_alloc()
+				 */
+	/* MAC filter */
+	uint nmac;		/* # of entries on maclist array */
+	int macmode;		/* allow/deny stations on maclist array */
+	struct ether_addr *maclist;	/* list of source MAC addrs to match */
+
+	/* security */
+	uint32 wsec;		/* wireless security bitvec */
+	int16 auth;		/* 802.11 authentication: Open, Shared Key, WPA */
+	int16 openshared;	/* try Open auth first, then Shared Key */
+	bool wsec_restrict;	/* drop unencrypted packets if wsec is enabled */
+	bool eap_restrict;	/* restrict data until 802.1X auth succeeds */
+	uint16 WPA_auth;	/* WPA: authenticated key management */
+	bool wpa2_preauth;	/* default is TRUE, wpa_cap sets value */
+	bool wsec_portopen;	/* indicates keys are plumbed */
+	wsec_iv_t wpa_none_txiv;	/* global txiv for WPA_NONE, tkip and aes */
+	int wsec_index;		/* 0-3: default tx key, -1: not set */
+	wsec_key_t *bss_def_keys[WLC_DEFAULT_KEYS];	/* default key storage */
+
+	/* TKIP countermeasures */
+	bool tkip_countermeasures;	/* flags TKIP no-assoc period */
+	uint32 tk_cm_dt;	/* detect timer */
+	uint32 tk_cm_bt;	/* blocking timer */
+	uint32 tk_cm_bt_tmstmp;	/* Timestamp when TKIP BT is activated */
+	bool tk_cm_activate;	/* activate countermeasures after EAPOL-Key sent */
+
+	struct ether_addr BSSID;	/* BSSID (associated) */
+	struct ether_addr cur_etheraddr;	/* h/w address */
+	uint16 bcmc_fid;	/* the last BCMC FID queued to TX_BCMC_FIFO */
+	uint16 bcmc_fid_shm;	/* the last BCMC FID written to shared mem */
+
+	uint32 flags;		/* WLC_BSSCFG flags; see below */
+
+	uint8 *bcn;		/* AP beacon */
+	uint bcn_len;		/* AP beacon length */
+	bool ar_disassoc;	/* disassociated in associated recreation */
+
+	int auth_atmptd;	/* auth type (open/shared) attempted */
+
+	pmkid_cand_t pmkid_cand[MAXPMKID];	/* PMKID candidate list */
+	uint npmkid_cand;	/* num PMKID candidates */
+	pmkid_t pmkid[MAXPMKID];	/* PMKID cache */
+	uint npmkid;		/* num cached PMKIDs */
+
+	wlc_bss_info_t *target_bss;	/* BSS parms during tran. to ASSOCIATED state */
+	wlc_bss_info_t *current_bss;	/* BSS parms in ASSOCIATED state */
+
+	/* PM states */
+	bool PMawakebcn;	/* bcn recvd during current waking state */
+	bool PMpending;		/* waiting for tx status with PM indicated set */
+	bool priorPMstate;	/* Detecting PM state transitions */
+	bool PSpoll;		/* whether there is an outstanding PS-Poll frame */
+
+	/* BSSID entry in RCMTA, use the wsec key management infrastructure to
+	 * manage the RCMTA entries.
+	 */
+	wsec_key_t *rcmta;
+
+	/* 'unique' ID of this bsscfg, assigned at bsscfg allocation */
+	uint16 ID;
+
+	uint txrspecidx;	/* index into tx rate circular buffer */
+	ratespec_t txrspec[NTXRATE][2];	/* circular buffer of prev MPDUs tx rates */
+};
+
+#define WLC_BSSCFG_11N_DISABLE	0x1000	/* Do not advertise .11n IEs for this BSS */
+#define WLC_BSSCFG_HW_BCN	0x20	/* The BSS is generating beacons in HW */
+
+#define HWBCN_ENAB(cfg)		(((cfg)->flags & WLC_BSSCFG_HW_BCN) != 0)
+#define HWPRB_ENAB(cfg)		(((cfg)->flags & WLC_BSSCFG_HW_PRB) != 0)
+
+extern void wlc_bsscfg_ID_assign(struct wlc_info *wlc, wlc_bsscfg_t * bsscfg);
+
+/* Extend N_ENAB to per-BSS */
+#define BSS_N_ENAB(wlc, cfg) \
+	(N_ENAB((wlc)->pub) && !((cfg)->flags & WLC_BSSCFG_11N_DISABLE))
+
+#define MBSS_BCN_ENAB(cfg)       0
+#define MBSS_PRB_ENAB(cfg)       0
+#define SOFTBCN_ENAB(pub)    (0)
+#define SOFTPRB_ENAB(pub)    (0)
+#define wlc_bsscfg_tx_check(a) do { } while (0);
+
+#endif				/* _WLC_BSSCFG_H_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_cfg.h b/drivers/staging/brcm80211/sys/wlc_cfg.h
new file mode 100644
index 0000000..a415e1f
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_cfg.h
@@ -0,0 +1,310 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_cfg_h_
+#define _wlc_cfg_h_
+
+#define NBANDS(wlc) ((wlc)->pub->_nbands)
+#define NBANDS_PUB(pub) ((pub)->_nbands)
+#define NBANDS_HW(hw) ((hw)->_nbands)
+
+#define IS_SINGLEBAND_5G(device)	0
+
+/* Keep WLC_HIGH_ONLY, WLC_SPLIT for USB extension later on */
+#if !defined(WLC_LOW)
+#define WLC_HIGH_ONLY
+#endif
+#if !defined(WLC_LOW)
+#define WLC_SPLIT
+#endif
+
+/* **** Core type/rev defaults **** */
+#define D11_DEFAULT	0x0fffffb0	/* Supported  D11 revs: 4, 5, 7-27
+					 * also need to update wlc.h MAXCOREREV
+					 */
+
+#define NPHY_DEFAULT	0x000001ff	/* Supported nphy revs:
+					 *      0       4321a0
+					 *      1       4321a1
+					 *      2       4321b0/b1/c0/c1
+					 *      3       4322a0
+					 *      4       4322a1
+					 *      5       4716a0
+					 *      6       43222a0, 43224a0
+					 *      7       43226a0
+					 *      8       5357a0, 43236a0
+					 */
+
+#define LCNPHY_DEFAULT	0x00000007	/* Supported lcnphy revs:
+					 *      0       4313a0, 4336a0, 4330a0
+					 *      1
+					 *      2       4330a0
+					 */
+
+#define SSLPNPHY_DEFAULT 0x0000000f	/* Supported sslpnphy revs:
+					 *      0       4329a0/k0
+					 *      1       4329b0/4329C0
+					 *      2       4319a0
+					 *      3       5356a0
+					 */
+
+#ifdef BCMSDIO
+#define D11CONF 0x100000
+#define SSLPNCONF 2
+#define GCCONF	0
+#define ACCONF	0
+#define NCONF	0
+#define LPCONF	0
+#define LCNCONF	0
+#define NTXD 32
+#define NRXD 16
+#define NRXBUFPOST 8
+#define WLC_DATAHIWAT 32
+#define RXBND 8
+#define MAXPKTCB 64
+#define AMPDU_NUM_MPDU 8
+#endif
+
+/* For undefined values, use defaults */
+#ifndef D11CONF
+#define D11CONF	D11_DEFAULT
+#endif
+#ifndef NCONF
+#define NCONF	NPHY_DEFAULT
+#endif
+#ifndef LCNCONF
+#define LCNCONF	LCNPHY_DEFAULT
+#endif
+
+#ifndef SSLPNCONF
+#define SSLPNCONF	SSLPNPHY_DEFAULT
+#endif
+
+#define BAND2G
+#define BAND5G
+#define WLANTSEL	1
+
+/********************************************************************
+ * Phy/Core Configuration.  Defines macros to to check core phy/rev *
+ * compile-time configuration.  Defines default core support.       *
+ * ******************************************************************
+ */
+
+/* Basic macros to check a configuration bitmask */
+
+#define CONF_HAS(config, val)	((config) & (1 << (val)))
+#define CONF_MSK(config, mask)	((config) & (mask))
+#define MSK_RANGE(low, hi)	((1 << ((hi)+1)) - (1 << (low)))
+#define CONF_RANGE(config, low, hi) (CONF_MSK(config, MSK_RANGE(low, high)))
+
+#define CONF_IS(config, val)	((config) == (1 << (val)))
+#define CONF_GE(config, val)	((config) & (0-(1 << (val))))
+#define CONF_GT(config, val)	((config) & (0-2*(1 << (val))))
+#define CONF_LT(config, val)	((config) & ((1 << (val))-1))
+#define CONF_LE(config, val)	((config) & (2*(1 << (val))-1))
+
+/* Wrappers for some of the above, specific to config constants */
+
+#define NCONF_HAS(val)	CONF_HAS(NCONF, val)
+#define NCONF_MSK(mask)	CONF_MSK(NCONF, mask)
+#define NCONF_IS(val)	CONF_IS(NCONF, val)
+#define NCONF_GE(val)	CONF_GE(NCONF, val)
+#define NCONF_GT(val)	CONF_GT(NCONF, val)
+#define NCONF_LT(val)	CONF_LT(NCONF, val)
+#define NCONF_LE(val)	CONF_LE(NCONF, val)
+
+#define LCNCONF_HAS(val)	CONF_HAS(LCNCONF, val)
+#define LCNCONF_MSK(mask)	CONF_MSK(LCNCONF, mask)
+#define LCNCONF_IS(val)		CONF_IS(LCNCONF, val)
+#define LCNCONF_GE(val)		CONF_GE(LCNCONF, val)
+#define LCNCONF_GT(val)		CONF_GT(LCNCONF, val)
+#define LCNCONF_LT(val)		CONF_LT(LCNCONF, val)
+#define LCNCONF_LE(val)		CONF_LE(LCNCONF, val)
+
+#define D11CONF_HAS(val) CONF_HAS(D11CONF, val)
+#define D11CONF_MSK(mask) CONF_MSK(D11CONF, mask)
+#define D11CONF_IS(val)	CONF_IS(D11CONF, val)
+#define D11CONF_GE(val)	CONF_GE(D11CONF, val)
+#define D11CONF_GT(val)	CONF_GT(D11CONF, val)
+#define D11CONF_LT(val)	CONF_LT(D11CONF, val)
+#define D11CONF_LE(val)	CONF_LE(D11CONF, val)
+
+#define PHYCONF_HAS(val) CONF_HAS(PHYTYPE, val)
+#define PHYCONF_IS(val)	CONF_IS(PHYTYPE, val)
+
+#define NREV_IS(var, val)	(NCONF_HAS(val) && (NCONF_IS(val) || ((var) == (val))))
+#define NREV_GE(var, val)	(NCONF_GE(val) && (!NCONF_LT(val) || ((var) >= (val))))
+#define NREV_GT(var, val)	(NCONF_GT(val) && (!NCONF_LE(val) || ((var) > (val))))
+#define NREV_LT(var, val)	(NCONF_LT(val) && (!NCONF_GE(val) || ((var) < (val))))
+#define NREV_LE(var, val)	(NCONF_LE(val) && (!NCONF_GT(val) || ((var) <= (val))))
+
+#define LCNREV_IS(var, val)	(LCNCONF_HAS(val) && (LCNCONF_IS(val) || ((var) == (val))))
+#define LCNREV_GE(var, val)	(LCNCONF_GE(val) && (!LCNCONF_LT(val) || ((var) >= (val))))
+#define LCNREV_GT(var, val)	(LCNCONF_GT(val) && (!LCNCONF_LE(val) || ((var) > (val))))
+#define LCNREV_LT(var, val)	(LCNCONF_LT(val) && (!LCNCONF_GE(val) || ((var) < (val))))
+#define LCNREV_LE(var, val)	(LCNCONF_LE(val) && (!LCNCONF_GT(val) || ((var) <= (val))))
+
+#define D11REV_IS(var, val)	(D11CONF_HAS(val) && (D11CONF_IS(val) || ((var) == (val))))
+#define D11REV_GE(var, val)	(D11CONF_GE(val) && (!D11CONF_LT(val) || ((var) >= (val))))
+#define D11REV_GT(var, val)	(D11CONF_GT(val) && (!D11CONF_LE(val) || ((var) > (val))))
+#define D11REV_LT(var, val)	(D11CONF_LT(val) && (!D11CONF_GE(val) || ((var) < (val))))
+#define D11REV_LE(var, val)	(D11CONF_LE(val) && (!D11CONF_GT(val) || ((var) <= (val))))
+
+#define PHYTYPE_IS(var, val)	(PHYCONF_HAS(val) && (PHYCONF_IS(val) || ((var) == (val))))
+
+/* Finally, early-exit from switch case if anyone wants it... */
+
+#define CASECHECK(config, val)	if (!(CONF_HAS(config, val))) break
+#define CASEMSK(config, mask)	if (!(CONF_MSK(config, mask))) break
+
+#if (D11CONF ^ (D11CONF & D11_DEFAULT))
+#error "Unsupported MAC revision configured"
+#endif
+#if (NCONF ^ (NCONF & NPHY_DEFAULT))
+#error "Unsupported NPHY revision configured"
+#endif
+#if (LCNCONF ^ (LCNCONF & LCNPHY_DEFAULT))
+#error "Unsupported LPPHY revision configured"
+#endif
+
+/* *** Consistency checks *** */
+#if !D11CONF
+#error "No MAC revisions configured!"
+#endif
+
+#if !NCONF && !LCNCONF && !SSLPNCONF
+#error "No PHY configured!"
+#endif
+
+/* Set up PHYTYPE automatically: (depends on PHY_TYPE_X, from d11.h) */
+
+#define _PHYCONF_N (1 << PHY_TYPE_N)
+
+#if LCNCONF
+#define _PHYCONF_LCN (1 << PHY_TYPE_LCN)
+#else
+#define _PHYCONF_LCN 0
+#endif				/* LCNCONF */
+
+#if SSLPNCONF
+#define _PHYCONF_SSLPN (1 << PHY_TYPE_SSN)
+#else
+#define _PHYCONF_SSLPN 0
+#endif				/* SSLPNCONF */
+
+#define PHYTYPE (_PHYCONF_N | _PHYCONF_LCN | _PHYCONF_SSLPN)
+
+/* Utility macro to identify 802.11n (HT) capable PHYs */
+#define PHYTYPE_11N_CAP(phytype) \
+	(PHYTYPE_IS(phytype, PHY_TYPE_N) ||	\
+	 PHYTYPE_IS(phytype, PHY_TYPE_LCN) || \
+	 PHYTYPE_IS(phytype, PHY_TYPE_SSN))
+
+/* Last but not least: shorter wlc-specific var checks */
+#define WLCISNPHY(band)		PHYTYPE_IS((band)->phytype, PHY_TYPE_N)
+#define WLCISLCNPHY(band)	PHYTYPE_IS((band)->phytype, PHY_TYPE_LCN)
+#define WLCISSSLPNPHY(band)	PHYTYPE_IS((band)->phytype, PHY_TYPE_SSN)
+
+#define WLC_PHY_11N_CAP(band)	PHYTYPE_11N_CAP((band)->phytype)
+
+/**********************************************************************
+ * ------------- End of Core phy/rev configuration. ----------------- *
+ * ********************************************************************
+ */
+
+/*************************************************
+ * Defaults for tunables (e.g. sizing constants)
+ *
+ * For each new tunable, add a member to the end
+ * of wlc_tunables_t in wlc_pub.h to enable
+ * runtime checks of tunable values. (Directly
+ * using the macros in code invalidates ROM code)
+ *
+ * ***********************************************
+ */
+#ifndef NTXD
+#define NTXD		256	/* Max # of entries in Tx FIFO based on 4kb page size */
+#endif				/* NTXD */
+#ifndef NRXD
+#define NRXD		256	/* Max # of entries in Rx FIFO based on 4kb page size */
+#endif				/* NRXD */
+
+#ifndef NRXBUFPOST
+#define	NRXBUFPOST	32	/* try to keep this # rbufs posted to the chip */
+#endif				/* NRXBUFPOST */
+
+#ifndef MAXSCB			/* station control blocks in cache */
+#define MAXSCB		32	/* Maximum SCBs in cache for STA */
+#endif				/* MAXSCB */
+
+#ifndef AMPDU_NUM_MPDU
+#define AMPDU_NUM_MPDU		16	/* max allowed number of mpdus in an ampdu (2 streams) */
+#endif				/* AMPDU_NUM_MPDU */
+
+#ifndef AMPDU_NUM_MPDU_3STREAMS
+#define AMPDU_NUM_MPDU_3STREAMS	32	/* max allowed number of mpdus in an ampdu for 3+ streams */
+#endif				/* AMPDU_NUM_MPDU_3STREAMS */
+
+/* Count of packet callback structures. either of following
+ * 1. Set to the number of SCBs since a STA
+ * can queue up a rate callback for each IBSS STA it knows about, and an AP can
+ * queue up an "are you there?" Null Data callback for each associated STA
+ * 2. controlled by tunable config file
+ */
+#ifndef MAXPKTCB
+#define MAXPKTCB	MAXSCB	/* Max number of packet callbacks */
+#endif				/* MAXPKTCB */
+
+#ifndef CTFPOOLSZ
+#define CTFPOOLSZ       128
+#endif				/* CTFPOOLSZ */
+
+/* NetBSD also needs to keep track of this */
+#define WLC_MAX_UCODE_BSS	(16)	/* Number of BSS handled in ucode bcn/prb */
+#define WLC_MAX_UCODE_BSS4	(4)	/* Number of BSS handled in sw bcn/prb */
+#ifndef WLC_MAXBSSCFG
+#define WLC_MAXBSSCFG		(1)	/* max # BSS configs */
+#endif				/* WLC_MAXBSSCFG */
+
+#ifndef MAXBSS
+#define MAXBSS		64	/* max # available networks */
+#endif				/* MAXBSS */
+
+#ifndef WLC_DATAHIWAT
+#define WLC_DATAHIWAT		50	/* data msg txq hiwat mark */
+#endif				/* WLC_DATAHIWAT */
+
+#ifndef WLC_AMPDUDATAHIWAT
+#define WLC_AMPDUDATAHIWAT 255
+#endif				/* WLC_AMPDUDATAHIWAT */
+
+/* bounded rx loops */
+#ifndef RXBND
+#define RXBND		8	/* max # frames to process in wlc_recv() */
+#endif				/* RXBND */
+#ifndef TXSBND
+#define TXSBND		8	/* max # tx status to process in wlc_txstatus() */
+#endif				/* TXSBND */
+
+#define BAND_5G(bt)	((bt) == WLC_BAND_5G)
+#define BAND_2G(bt)	((bt) == WLC_BAND_2G)
+
+#define WLBANDINITDATA(_data)	_data
+#define WLBANDINITFN(_fn)	_fn
+
+#define WLANTSEL_ENAB(wlc)	1
+
+#endif				/* _wlc_cfg_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_channel.c b/drivers/staging/brcm80211/sys/wlc_channel.c
new file mode 100644
index 0000000..271c246
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_channel.c
@@ -0,0 +1,1598 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <wlioctl.h>
+#include <wlc_pub.h>
+#include <wlc_key.h>
+#include <wlc_mac80211.h>
+#include <wlc_bmac.h>
+#include <wlc_stf.h>
+#include <wlc_channel.h>
+
+typedef struct wlc_cm_band {
+	uint8 locale_flags;	/* locale_info_t flags */
+	chanvec_t valid_channels;	/* List of valid channels in the country */
+	const chanvec_t *restricted_channels;	/* List of restricted use channels */
+	const chanvec_t *radar_channels;	/* List of radar sensitive channels */
+	uint8 PAD[8];
+} wlc_cm_band_t;
+
+struct wlc_cm_info {
+	wlc_pub_t *pub;
+	wlc_info_t *wlc;
+	char srom_ccode[WLC_CNTRY_BUF_SZ];	/* Country Code in SROM */
+	uint srom_regrev;	/* Regulatory Rev for the SROM ccode */
+	const country_info_t *country;	/* current country def */
+	char ccode[WLC_CNTRY_BUF_SZ];	/* current internal Country Code */
+	uint regrev;		/* current Regulatory Revision */
+	char country_abbrev[WLC_CNTRY_BUF_SZ];	/* current advertised ccode */
+	wlc_cm_band_t bandstate[MAXBANDS];	/* per-band state (one per phy/radio) */
+	/* quiet channels currently for radar sensitivity or 11h support */
+	chanvec_t quiet_channels;	/* channels on which we cannot transmit */
+};
+
+static int wlc_channels_init(wlc_cm_info_t * wlc_cm,
+			     const country_info_t * country);
+static void wlc_set_country_common(wlc_cm_info_t * wlc_cm,
+				   const char *country_abbrev,
+				   const char *ccode, uint regrev,
+				   const country_info_t * country);
+static int wlc_country_aggregate_map(wlc_cm_info_t * wlc_cm, const char *ccode,
+				     char *mapped_ccode, uint * mapped_regrev);
+static const country_info_t *wlc_country_lookup_direct(const char *ccode,
+						       uint regrev);
+static const country_info_t *wlc_countrycode_map(wlc_cm_info_t * wlc_cm,
+						 const char *ccode,
+						 char *mapped_ccode,
+						 uint * mapped_regrev);
+static void wlc_channels_commit(wlc_cm_info_t * wlc_cm);
+static bool wlc_japan_ccode(const char *ccode);
+static void wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t *
+								 wlc_cm,
+								 struct
+								 txpwr_limits
+								 *txpwr,
+								 uint8
+								 local_constraint_qdbm);
+void wlc_locale_add_channels(chanvec_t * target, const chanvec_t * channels);
+static const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx);
+static const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx);
+
+/* QDB() macro takes a dB value and converts to a quarter dB value */
+#ifdef QDB
+#undef QDB
+#endif
+#define QDB(n) ((n) * WLC_TXPWR_DB_FACTOR)
+
+/* Regulatory Matrix Spreadsheet (CLM) MIMO v3.7.9 */
+
+/*
+ * Some common channel sets
+ */
+
+/* No channels */
+static const chanvec_t chanvec_none = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/* All 2.4 GHz HW channels */
+const chanvec_t chanvec_all_2G = {
+	{0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/* All 5 GHz HW channels */
+const chanvec_t chanvec_all_5G = {
+	{0x00, 0x00, 0x00, 0x00, 0x54, 0x55, 0x11, 0x11,
+	 0x01, 0x00, 0x00, 0x00, 0x10, 0x11, 0x11, 0x11,
+	 0x11, 0x11, 0x20, 0x22, 0x22, 0x00, 0x00, 0x11,
+	 0x11, 0x11, 0x11, 0x01}
+};
+
+/*
+ * Radar channel sets
+ */
+
+/* No radar */
+#define radar_set_none chanvec_none
+
+static const chanvec_t radar_set1 = {	/* Channels 52 - 64, 100 - 140 */
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,	/* 52 - 60 */
+	 0x01, 0x00, 0x00, 0x00, 0x10, 0x11, 0x11, 0x11,	/* 64, 100 - 124 */
+	 0x11, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	/* 128 - 140 */
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/*
+ * Restricted channel sets
+ */
+
+#define restricted_set_none chanvec_none
+
+/* Channels 34, 38, 42, 46 */
+static const chanvec_t restricted_set_japan_legacy = {
+	{0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/* Channels 12, 13 */
+static const chanvec_t restricted_set_2g_short = {
+	{0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/* Channel 165 */
+static const chanvec_t restricted_chan_165 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/* Channels 36 - 48 & 149 - 165 */
+static const chanvec_t restricted_low_hi = {
+	{0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x01, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x20, 0x22, 0x22, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/* Channels 12 - 14 */
+static const chanvec_t restricted_set_12_13_14 = {
+	{0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+#define  LOCALE_CHAN_01_11	 (1<<0)
+#define  LOCALE_CHAN_12_13	 (1<<1)
+#define  LOCALE_CHAN_14		 (1<<2)
+#define  LOCALE_SET_5G_LOW_JP1   (1<<3)	/* 34-48, step 2 */
+#define  LOCALE_SET_5G_LOW_JP2   (1<<4)	/* 34-46, step 4 */
+#define  LOCALE_SET_5G_LOW1      (1<<5)	/* 36-48, step 4 */
+#define  LOCALE_SET_5G_LOW2      (1<<6)	/* 52 */
+#define  LOCALE_SET_5G_LOW3      (1<<7)	/* 56-64, step 4 */
+#define  LOCALE_SET_5G_MID1      (1<<8)	/* 100-116, step 4 */
+#define  LOCALE_SET_5G_MID2	 (1<<9)	/* 120-124, step 4 */
+#define  LOCALE_SET_5G_MID3      (1<<10)	/* 128 */
+#define  LOCALE_SET_5G_HIGH1     (1<<11)	/* 132-140, step 4 */
+#define  LOCALE_SET_5G_HIGH2     (1<<12)	/* 149-161, step 4 */
+#define  LOCALE_SET_5G_HIGH3     (1<<13)	/* 165 */
+#define  LOCALE_CHAN_52_140_ALL  (1<<14)
+#define  LOCALE_SET_5G_HIGH4     (1<<15)	/* 184-216 */
+
+#define  LOCALE_CHAN_36_64       LOCALE_SET_5G_LOW1 | LOCALE_SET_5G_LOW2 | LOCALE_SET_5G_LOW3
+#define  LOCALE_CHAN_52_64       LOCALE_SET_5G_LOW2 | LOCALE_SET_5G_LOW3
+#define  LOCALE_CHAN_100_124	 LOCALE_SET_5G_MID1 | LOCALE_SET_5G_MID2
+#define  LOCALE_CHAN_100_140     \
+	LOCALE_SET_5G_MID1 | LOCALE_SET_5G_MID2 | LOCALE_SET_5G_MID3 | LOCALE_SET_5G_HIGH1
+#define  LOCALE_CHAN_149_165     LOCALE_SET_5G_HIGH2 | LOCALE_SET_5G_HIGH3
+#define  LOCALE_CHAN_184_216     LOCALE_SET_5G_HIGH4
+
+#define  LOCALE_CHAN_01_14	(LOCALE_CHAN_01_11 | LOCALE_CHAN_12_13 | LOCALE_CHAN_14)
+
+#define  LOCALE_RADAR_SET_NONE		  0
+#define  LOCALE_RADAR_SET_1		  1
+
+#define  LOCALE_RESTRICTED_NONE		  0
+#define  LOCALE_RESTRICTED_SET_2G_SHORT   1
+#define  LOCALE_RESTRICTED_CHAN_165       2
+#define  LOCALE_CHAN_ALL_5G		  3
+#define  LOCALE_RESTRICTED_JAPAN_LEGACY   4
+#define  LOCALE_RESTRICTED_11D_2G	  5
+#define  LOCALE_RESTRICTED_11D_5G	  6
+#define  LOCALE_RESTRICTED_LOW_HI	  7
+#define  LOCALE_RESTRICTED_12_13_14	  8
+
+/* global memory to provide working buffer for expanded locale */
+
+static const chanvec_t *g_table_radar_set[] = {
+	&chanvec_none,
+	&radar_set1
+};
+
+static const chanvec_t *g_table_restricted_chan[] = {
+	&chanvec_none,		/* restricted_set_none */
+	&restricted_set_2g_short,
+	&restricted_chan_165,
+	&chanvec_all_5G,
+	&restricted_set_japan_legacy,
+	&chanvec_all_2G,	/* restricted_set_11d_2G */
+	&chanvec_all_5G,	/* restricted_set_11d_5G */
+	&restricted_low_hi,
+	&restricted_set_12_13_14
+};
+
+static const chanvec_t locale_2g_01_11 = {
+	{0xfe, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_2g_12_13 = {
+	{0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_2g_14 = {
+	{0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_LOW_JP1 = {
+	{0x00, 0x00, 0x00, 0x00, 0x54, 0x55, 0x01, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_LOW_JP2 = {
+	{0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_LOW1 = {
+	{0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x01, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_LOW2 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_LOW3 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
+	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_MID1 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x11, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_MID2 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_MID3 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_HIGH1 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x10, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_HIGH2 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x20, 0x22, 0x02, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_HIGH3 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_52_140_ALL = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
+	 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
+	 0x11, 0x11, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static const chanvec_t locale_5g_HIGH4 = {
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,
+	 0x11, 0x11, 0x11, 0x11}
+};
+
+static const chanvec_t *g_table_locale_base[] = {
+	&locale_2g_01_11,
+	&locale_2g_12_13,
+	&locale_2g_14,
+	&locale_5g_LOW_JP1,
+	&locale_5g_LOW_JP2,
+	&locale_5g_LOW1,
+	&locale_5g_LOW2,
+	&locale_5g_LOW3,
+	&locale_5g_MID1,
+	&locale_5g_MID2,
+	&locale_5g_MID3,
+	&locale_5g_HIGH1,
+	&locale_5g_HIGH2,
+	&locale_5g_HIGH3,
+	&locale_5g_52_140_ALL,
+	&locale_5g_HIGH4
+};
+
+void wlc_locale_add_channels(chanvec_t * target, const chanvec_t * channels)
+{
+	uint8 i;
+	for (i = 0; i < sizeof(chanvec_t); i++) {
+		target->vec[i] |= channels->vec[i];
+	}
+}
+
+void wlc_locale_get_channels(const locale_info_t * locale, chanvec_t * channels)
+{
+	uint8 i;
+
+	bzero(channels, sizeof(chanvec_t));
+
+	for (i = 0; i < ARRAYSIZE(g_table_locale_base); i++) {
+		if (locale->valid_channels & (1 << i)) {
+			wlc_locale_add_channels(channels,
+						g_table_locale_base[i]);
+		}
+	}
+}
+
+/*
+ * Locale Definitions - 2.4 GHz
+ */
+static const locale_info_t locale_i = {	/* locale i. channel 1 - 13 */
+	LOCALE_CHAN_01_11 | LOCALE_CHAN_12_13,
+	LOCALE_RADAR_SET_NONE,
+	LOCALE_RESTRICTED_SET_2G_SHORT,
+	{QDB(19), QDB(19), QDB(19),
+	 QDB(19), QDB(19), QDB(19)},
+	{20, 20, 20, 0},
+	WLC_EIRP
+};
+
+/*
+ * Locale Definitions - 5 GHz
+ */
+static const locale_info_t locale_11 = {
+	/* locale 11. channel 36 - 48, 52 - 64, 100 - 140, 149 - 165 */
+	LOCALE_CHAN_36_64 | LOCALE_CHAN_100_140 | LOCALE_CHAN_149_165,
+	LOCALE_RADAR_SET_1,
+	LOCALE_RESTRICTED_NONE,
+	{QDB(21), QDB(21), QDB(21), QDB(21), QDB(21)},
+	{23, 23, 23, 30, 30},
+	WLC_EIRP | WLC_DFS_EU
+};
+
+#define LOCALE_2G_IDX_i			0
+static const locale_info_t *g_locale_2g_table[] = {
+	&locale_i
+};
+
+#define LOCALE_5G_IDX_11	0
+static const locale_info_t *g_locale_5g_table[] = {
+	&locale_11
+};
+
+/*
+ * MIMO Locale Definitions - 2.4 GHz
+ */
+static const locale_mimo_info_t locale_bn = {
+	{QDB(13), QDB(13), QDB(13), QDB(13), QDB(13),
+	 QDB(13), QDB(13), QDB(13), QDB(13), QDB(13),
+	 QDB(13), QDB(13), QDB(13)},
+	{0, 0, QDB(13), QDB(13), QDB(13),
+	 QDB(13), QDB(13), QDB(13), QDB(13), QDB(13),
+	 QDB(13), 0, 0},
+	0
+};
+
+/* locale mimo 2g indexes */
+#define LOCALE_MIMO_IDX_bn			0
+
+static const locale_mimo_info_t *g_mimo_2g_table[] = {
+	&locale_bn
+};
+
+/*
+ * MIMO Locale Definitions - 5 GHz
+ */
+static const locale_mimo_info_t locale_11n = {
+	{ /* 12.5 dBm */ 50, 50, 50, QDB(15), QDB(15)},
+	{QDB(14), QDB(15), QDB(15), QDB(15), QDB(15)},
+	0
+};
+
+#define LOCALE_MIMO_IDX_11n			0
+static const locale_mimo_info_t *g_mimo_5g_table[] = {
+	&locale_11n
+};
+
+#ifdef LC
+#undef LC
+#endif
+#define LC(id)	LOCALE_MIMO_IDX_ ## id
+
+#ifdef LC_2G
+#undef LC_2G
+#endif
+#define LC_2G(id)	LOCALE_2G_IDX_ ## id
+
+#ifdef LC_5G
+#undef LC_5G
+#endif
+#define LC_5G(id)	LOCALE_5G_IDX_ ## id
+
+#define LOCALES(band2, band5, mimo2, mimo5)     {LC_2G(band2), LC_5G(band5), LC(mimo2), LC(mimo5)}
+
+static const struct {
+	char abbrev[WLC_CNTRY_BUF_SZ];	/* country abbreviation */
+	country_info_t country;
+} cntry_locales[] = {
+	{
+	"X2", LOCALES(i, 11, bn, 11n)},	/* Worldwide RoW 2 */
+};
+
+#ifdef SUPPORT_40MHZ
+/* 20MHz channel info for 40MHz pairing support */
+struct chan20_info {
+	uint8 sb;
+	uint8 adj_sbs;
+};
+
+/* indicates adjacent channels that are allowed for a 40 Mhz channel and
+ * those that permitted by the HT
+ */
+struct chan20_info chan20_info[] = {
+	/* 11b/11g */
+/* 0 */ {1, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 1 */ {2, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 2 */ {3, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 3 */ {4, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 4 */ {5, (CH_UPPER_SB | CH_LOWER_SB | CH_EWA_VALID)},
+/* 5 */ {6, (CH_UPPER_SB | CH_LOWER_SB | CH_EWA_VALID)},
+/* 6 */ {7, (CH_UPPER_SB | CH_LOWER_SB | CH_EWA_VALID)},
+/* 7 */ {8, (CH_UPPER_SB | CH_LOWER_SB | CH_EWA_VALID)},
+/* 8 */ {9, (CH_UPPER_SB | CH_LOWER_SB | CH_EWA_VALID)},
+/* 9 */ {10, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 10 */ {11, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 11 */ {12, (CH_LOWER_SB)},
+/* 12 */ {13, (CH_LOWER_SB)},
+/* 13 */ {14, (CH_LOWER_SB)},
+
+/* 11a japan high */
+/* 14 */ {34, (CH_UPPER_SB)},
+/* 15 */ {38, (CH_LOWER_SB)},
+/* 16 */ {42, (CH_LOWER_SB)},
+/* 17 */ {46, (CH_LOWER_SB)},
+
+/* 11a usa low */
+/* 18 */ {36, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 19 */ {40, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 20 */ {44, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 21 */ {48, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 22 */ {52, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 23 */ {56, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 24 */ {60, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 25 */ {64, (CH_LOWER_SB | CH_EWA_VALID)},
+
+/* 11a Europe */
+/* 26 */ {100, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 27 */ {104, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 28 */ {108, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 29 */ {112, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 30 */ {116, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 31 */ {120, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 32 */ {124, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 33 */ {128, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 34 */ {132, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 35 */ {136, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 36 */ {140, (CH_LOWER_SB)},
+
+/* 11a usa high, ref5 only */
+/* The 0x80 bit in pdiv means these are REF5, other entries are REF20 */
+/* 37 */ {149, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 38 */ {153, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 39 */ {157, (CH_UPPER_SB | CH_EWA_VALID)},
+/* 40 */ {161, (CH_LOWER_SB | CH_EWA_VALID)},
+/* 41 */ {165, (CH_LOWER_SB)},
+
+/* 11a japan */
+/* 42 */ {184, (CH_UPPER_SB)},
+/* 43 */ {188, (CH_LOWER_SB)},
+/* 44 */ {192, (CH_UPPER_SB)},
+/* 45 */ {196, (CH_LOWER_SB)},
+/* 46 */ {200, (CH_UPPER_SB)},
+/* 47 */ {204, (CH_LOWER_SB)},
+/* 48 */ {208, (CH_UPPER_SB)},
+/* 49 */ {212, (CH_LOWER_SB)},
+/* 50 */ {216, (CH_LOWER_SB)}
+};
+#endif				/* SUPPORT_40MHZ */
+
+const locale_info_t *wlc_get_locale_2g(uint8 locale_idx)
+{
+	if (locale_idx >= ARRAYSIZE(g_locale_2g_table)) {
+		WL_ERROR(("%s: locale 2g index size out of range %d\n",
+			  __func__, locale_idx));
+		ASSERT(locale_idx < ARRAYSIZE(g_locale_2g_table));
+		return NULL;
+	}
+	return g_locale_2g_table[locale_idx];
+}
+
+const locale_info_t *wlc_get_locale_5g(uint8 locale_idx)
+{
+	if (locale_idx >= ARRAYSIZE(g_locale_5g_table)) {
+		WL_ERROR(("%s: locale 5g index size out of range %d\n",
+			  __func__, locale_idx));
+		ASSERT(locale_idx < ARRAYSIZE(g_locale_5g_table));
+		return NULL;
+	}
+	return g_locale_5g_table[locale_idx];
+}
+
+const locale_mimo_info_t *wlc_get_mimo_2g(uint8 locale_idx)
+{
+	if (locale_idx >= ARRAYSIZE(g_mimo_2g_table)) {
+		WL_ERROR(("%s: mimo 2g index size out of range %d\n", __func__,
+			  locale_idx));
+		return NULL;
+	}
+	return g_mimo_2g_table[locale_idx];
+}
+
+const locale_mimo_info_t *wlc_get_mimo_5g(uint8 locale_idx)
+{
+	if (locale_idx >= ARRAYSIZE(g_mimo_5g_table)) {
+		WL_ERROR(("%s: mimo 5g index size out of range %d\n", __func__,
+			  locale_idx));
+		return NULL;
+	}
+	return g_mimo_5g_table[locale_idx];
+}
+
+wlc_cm_info_t *BCMATTACHFN(wlc_channel_mgr_attach) (wlc_info_t * wlc) {
+	wlc_cm_info_t *wlc_cm;
+	char country_abbrev[WLC_CNTRY_BUF_SZ];
+	const country_info_t *country;
+	wlc_pub_t *pub = wlc->pub;
+	char *ccode;
+
+	WL_TRACE(("wl%d: wlc_channel_mgr_attach\n", wlc->pub->unit));
+
+	if ((wlc_cm =
+	     (wlc_cm_info_t *) MALLOC(pub->osh,
+				      sizeof(wlc_cm_info_t))) == NULL) {
+		WL_ERROR(("wl%d: %s: out of memory, malloced %d bytes",
+			  pub->unit, __func__, MALLOCED(pub->osh)));
+		return NULL;
+	}
+	bzero((char *)wlc_cm, sizeof(wlc_cm_info_t));
+	wlc_cm->pub = pub;
+	wlc_cm->wlc = wlc;
+	wlc->cmi = wlc_cm;
+
+	/* store the country code for passing up as a regulatory hint */
+	ccode = getvar(wlc->pub->vars, "ccode");
+	if (ccode) {
+		strncpy(wlc->pub->srom_ccode, ccode, WLC_CNTRY_BUF_SZ - 1);
+		WL_NONE(("%s: SROM country code is %c%c\n", __func__,
+			 wlc->pub->srom_ccode[0], wlc->pub->srom_ccode[1]));
+	}
+
+	/* internal country information which must match regulatory constraints in firmware */
+	bzero(country_abbrev, WLC_CNTRY_BUF_SZ);
+	strncpy(country_abbrev, "X2", sizeof(country_abbrev) - 1);
+	country = wlc_country_lookup(wlc, country_abbrev);
+
+	ASSERT(country != NULL);
+
+	/* save default country for exiting 11d regulatory mode */
+	strncpy(wlc->country_default, country_abbrev, WLC_CNTRY_BUF_SZ - 1);
+
+	/* initialize autocountry_default to driver default */
+	strncpy(wlc->autocountry_default, "X2", WLC_CNTRY_BUF_SZ - 1);
+
+	wlc_set_countrycode(wlc_cm, country_abbrev);
+
+	return wlc_cm;
+}
+
+void BCMATTACHFN(wlc_channel_mgr_detach) (wlc_cm_info_t * wlc_cm) {
+	if (wlc_cm)
+		MFREE(wlc_cm->pub->osh, wlc_cm, sizeof(wlc_cm_info_t));
+}
+
+const char *wlc_channel_country_abbrev(wlc_cm_info_t * wlc_cm)
+{
+	return wlc_cm->country_abbrev;
+}
+
+uint8 wlc_channel_locale_flags(wlc_cm_info_t * wlc_cm)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+
+	return wlc_cm->bandstate[wlc->band->bandunit].locale_flags;
+}
+
+uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t * wlc_cm, uint bandunit)
+{
+	return wlc_cm->bandstate[bandunit].locale_flags;
+}
+
+/* return chanvec for a given country code and band */
+bool
+wlc_channel_get_chanvec(struct wlc_info * wlc, const char *country_abbrev,
+			int bandtype, chanvec_t * channels)
+{
+	const country_info_t *country;
+	const locale_info_t *locale = NULL;
+
+	country = wlc_country_lookup(wlc, country_abbrev);
+	if (country == NULL)
+		return FALSE;
+
+	if (bandtype == WLC_BAND_2G)
+		locale = wlc_get_locale_2g(country->locale_2G);
+	else if (bandtype == WLC_BAND_5G)
+		locale = wlc_get_locale_5g(country->locale_5G);
+	if (locale == NULL)
+		return FALSE;
+
+	wlc_locale_get_channels(locale, channels);
+	return TRUE;
+}
+
+/* set the driver's current country and regulatory information using a country code
+ * as the source. Lookup built in country information found with the country code.
+ */
+int wlc_set_countrycode(wlc_cm_info_t * wlc_cm, const char *ccode)
+{
+	char country_abbrev[WLC_CNTRY_BUF_SZ];
+	strncpy(country_abbrev, ccode, WLC_CNTRY_BUF_SZ);
+	return wlc_set_countrycode_rev(wlc_cm, country_abbrev, ccode, -1);
+}
+
+int
+wlc_set_countrycode_rev(wlc_cm_info_t * wlc_cm,
+			const char *country_abbrev,
+			const char *ccode, int regrev)
+{
+	const country_info_t *country;
+	char mapped_ccode[WLC_CNTRY_BUF_SZ];
+	uint mapped_regrev;
+
+	WL_NONE(("%s: (country_abbrev \"%s\", ccode \"%s\", regrev %d) SPROM \"%s\"/%u\n", __func__, country_abbrev, ccode, regrev, wlc_cm->srom_ccode, wlc_cm->srom_regrev));
+
+	/* if regrev is -1, lookup the mapped country code,
+	 * otherwise use the ccode and regrev directly
+	 */
+	if (regrev == -1) {
+		/* map the country code to a built-in country code, regrev, and country_info */
+		country =
+		    wlc_countrycode_map(wlc_cm, ccode, mapped_ccode,
+					&mapped_regrev);
+	} else {
+		/* find the matching built-in country definition */
+		ASSERT(0);
+		country = wlc_country_lookup_direct(ccode, regrev);
+		strncpy(mapped_ccode, ccode, WLC_CNTRY_BUF_SZ);
+		mapped_regrev = regrev;
+	}
+
+	if (country == NULL)
+		return BCME_BADARG;
+
+	/* set the driver state for the country */
+	wlc_set_country_common(wlc_cm, country_abbrev, mapped_ccode,
+			       mapped_regrev, country);
+
+	return 0;
+}
+
+/* set the driver's current country and regulatory information using a country code
+ * as the source. Look up built in country information found with the country code.
+ */
+static void
+wlc_set_country_common(wlc_cm_info_t * wlc_cm,
+		       const char *country_abbrev,
+		       const char *ccode, uint regrev,
+		       const country_info_t * country)
+{
+	const locale_mimo_info_t *li_mimo;
+	const locale_info_t *locale;
+	wlc_info_t *wlc = wlc_cm->wlc;
+	char prev_country_abbrev[WLC_CNTRY_BUF_SZ];
+
+	ASSERT(country != NULL);
+
+	/* save current country state */
+	wlc_cm->country = country;
+
+	bzero(&prev_country_abbrev, WLC_CNTRY_BUF_SZ);
+	strncpy(prev_country_abbrev, wlc_cm->country_abbrev,
+		WLC_CNTRY_BUF_SZ - 1);
+
+	strncpy(wlc_cm->country_abbrev, country_abbrev, WLC_CNTRY_BUF_SZ - 1);
+	strncpy(wlc_cm->ccode, ccode, WLC_CNTRY_BUF_SZ - 1);
+	wlc_cm->regrev = regrev;
+
+	/* disable/restore nmode based on country regulations */
+	li_mimo = wlc_get_mimo_2g(country->locale_mimo_2G);
+	if (li_mimo && (li_mimo->flags & WLC_NO_MIMO)) {
+		wlc_set_nmode(wlc, OFF);
+		wlc->stf->no_cddstbc = TRUE;
+	} else {
+		wlc->stf->no_cddstbc = FALSE;
+		if (N_ENAB(wlc->pub) != wlc->protection->nmode_user)
+			wlc_set_nmode(wlc, wlc->protection->nmode_user);
+	}
+
+	wlc_stf_ss_update(wlc, wlc->bandstate[BAND_2G_INDEX]);
+	wlc_stf_ss_update(wlc, wlc->bandstate[BAND_5G_INDEX]);
+	/* set or restore gmode as required by regulatory */
+	locale = wlc_get_locale_2g(country->locale_2G);
+	if (locale && (locale->flags & WLC_NO_OFDM)) {
+		wlc_set_gmode(wlc, GMODE_LEGACY_B, FALSE);
+	} else {
+		wlc_set_gmode(wlc, wlc->protection->gmode_user, FALSE);
+	}
+
+	wlc_channels_init(wlc_cm, country);
+
+	return;
+}
+
+/* Lookup a country info structure from a null terminated country code
+ * The lookup is case sensitive.
+ */
+const country_info_t *wlc_country_lookup(struct wlc_info *wlc,
+					 const char *ccode)
+{
+	const country_info_t *country;
+	char mapped_ccode[WLC_CNTRY_BUF_SZ];
+	uint mapped_regrev;
+
+	/* map the country code to a built-in country code, regrev, and country_info struct */
+	country =
+	    wlc_countrycode_map(wlc->cmi, ccode, mapped_ccode, &mapped_regrev);
+
+	return country;
+}
+
+static const country_info_t *wlc_countrycode_map(wlc_cm_info_t * wlc_cm,
+						 const char *ccode,
+						 char *mapped_ccode,
+						 uint * mapped_regrev)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	const country_info_t *country;
+	uint srom_regrev = wlc_cm->srom_regrev;
+	const char *srom_ccode = wlc_cm->srom_ccode;
+	int mapped;
+
+	/* check for currently supported ccode size */
+	if (strlen(ccode) > (WLC_CNTRY_BUF_SZ - 1)) {
+		WL_ERROR(("wl%d: %s: ccode \"%s\" too long for match\n",
+			  wlc->pub->unit, __func__, ccode));
+		return NULL;
+	}
+
+	/* default mapping is the given ccode and regrev 0 */
+	strncpy(mapped_ccode, ccode, WLC_CNTRY_BUF_SZ);
+	*mapped_regrev = 0;
+
+	/* If the desired country code matches the srom country code,
+	 * then the mapped country is the srom regulatory rev.
+	 * Otherwise look for an aggregate mapping.
+	 */
+	if (!strcmp(srom_ccode, ccode)) {
+		*mapped_regrev = srom_regrev;
+		mapped = 0;
+		WL_ERROR(("srom_code == ccode %s\n", __func__));
+		ASSERT(0);
+	} else {
+		mapped =
+		    wlc_country_aggregate_map(wlc_cm, ccode, mapped_ccode,
+					      mapped_regrev);
+	}
+
+	/* find the matching built-in country definition */
+	country = wlc_country_lookup_direct(mapped_ccode, *mapped_regrev);
+
+	/* if there is not an exact rev match, default to rev zero */
+	if (country == NULL && *mapped_regrev != 0) {
+		*mapped_regrev = 0;
+		ASSERT(0);
+		country =
+		    wlc_country_lookup_direct(mapped_ccode, *mapped_regrev);
+	}
+
+	return country;
+}
+
+static int
+wlc_country_aggregate_map(wlc_cm_info_t * wlc_cm, const char *ccode,
+			  char *mapped_ccode, uint * mapped_regrev)
+{
+	return FALSE;
+}
+
+/* Lookup a country info structure from a null terminated country
+ * abbreviation and regrev directly with no translation.
+ */
+static const country_info_t *wlc_country_lookup_direct(const char *ccode,
+						       uint regrev)
+{
+	uint size, i;
+
+	/* Should just return 0 for single locale driver. */
+	/* Keep it this way in case we add more locales. (for now anyway) */
+
+	/* all other country def arrays are for regrev == 0, so if regrev is non-zero, fail */
+	if (regrev > 0)
+		return NULL;
+
+	/* find matched table entry from country code */
+	size = ARRAYSIZE(cntry_locales);
+	for (i = 0; i < size; i++) {
+		if (strcmp(ccode, cntry_locales[i].abbrev) == 0) {
+			return &cntry_locales[i].country;
+		}
+	}
+
+	WL_ERROR(("%s: Returning NULL\n", __func__));
+	ASSERT(0);
+	return NULL;
+}
+
+static int
+wlc_channels_init(wlc_cm_info_t * wlc_cm, const country_info_t * country)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	uint i, j;
+	wlcband_t *band;
+	const locale_info_t *li;
+	chanvec_t sup_chan;
+	const locale_mimo_info_t *li_mimo;
+
+	band = wlc->band;
+	for (i = 0; i < NBANDS(wlc);
+	     i++, band = wlc->bandstate[OTHERBANDUNIT(wlc)]) {
+
+		li = BAND_5G(band->bandtype) ?
+		    wlc_get_locale_5g(country->locale_5G) :
+		    wlc_get_locale_2g(country->locale_2G);
+		ASSERT(li);
+		wlc_cm->bandstate[band->bandunit].locale_flags = li->flags;
+		li_mimo = BAND_5G(band->bandtype) ?
+		    wlc_get_mimo_5g(country->locale_mimo_5G) :
+		    wlc_get_mimo_2g(country->locale_mimo_2G);
+		ASSERT(li_mimo);
+
+		/* merge the mimo non-mimo locale flags */
+		wlc_cm->bandstate[band->bandunit].locale_flags |=
+		    li_mimo->flags;
+
+		wlc_cm->bandstate[band->bandunit].restricted_channels =
+		    g_table_restricted_chan[li->restricted_channels];
+		wlc_cm->bandstate[band->bandunit].radar_channels =
+		    g_table_radar_set[li->radar_channels];
+
+		/* set the channel availability,
+		 * masking out the channels that may not be supported on this phy
+		 */
+		wlc_phy_chanspec_band_validch(band->pi, band->bandtype,
+					      &sup_chan);
+		wlc_locale_get_channels(li,
+					&wlc_cm->bandstate[band->bandunit].
+					valid_channels);
+		for (j = 0; j < sizeof(chanvec_t); j++)
+			wlc_cm->bandstate[band->bandunit].valid_channels.
+			    vec[j] &= sup_chan.vec[j];
+	}
+
+	wlc_quiet_channels_reset(wlc_cm);
+	wlc_channels_commit(wlc_cm);
+
+	return (0);
+}
+
+/* Update the radio state (enable/disable) and tx power targets
+ * based on a new set of channel/regulatory information
+ */
+static void wlc_channels_commit(wlc_cm_info_t * wlc_cm)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	uint chan;
+	struct txpwr_limits txpwr;
+
+	/* search for the existence of any valid channel */
+	for (chan = 0; chan < MAXCHANNEL; chan++) {
+		if (VALID_CHANNEL20_DB(wlc, chan)) {
+			break;
+		}
+	}
+	if (chan == MAXCHANNEL)
+		chan = INVCHANNEL;
+
+	/* based on the channel search above, set or clear WL_RADIO_COUNTRY_DISABLE */
+	if (chan == INVCHANNEL) {
+		/* country/locale with no valid channels, set the radio disable bit */
+		mboolset(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE);
+		WL_ERROR(("wl%d: %s: no valid channel for \"%s\" nbands %d bandlocked %d\n", wlc->pub->unit, __func__, wlc_cm->country_abbrev, NBANDS(wlc), wlc->bandlocked));
+	} else
+	    if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE))
+	{
+		/* country/locale with valid channel, clear the radio disable bit */
+		mboolclr(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE);
+	}
+
+	/* Now that the country abbreviation is set, if the radio supports 2G, then
+	 * set channel 14 restrictions based on the new locale.
+	 */
+	if (NBANDS(wlc) > 1 || BAND_2G(wlc->band->bandtype)) {
+		wlc_phy_chanspec_ch14_widefilter_set(wlc->band->pi,
+						     wlc_japan(wlc) ? TRUE :
+						     FALSE);
+	}
+
+	if (wlc->pub->up && chan != INVCHANNEL) {
+		wlc_channel_reg_limits(wlc_cm, wlc->chanspec, &txpwr);
+		wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm,
+								     &txpwr,
+								     WLC_TXPWR_MAX);
+		wlc_phy_txpower_limit_set(wlc->band->pi, &txpwr, wlc->chanspec);
+	}
+}
+
+/* reset the quiet channels vector to the union of the restricted and radar channel sets */
+void wlc_quiet_channels_reset(wlc_cm_info_t * wlc_cm)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	uint i, j;
+	wlcband_t *band;
+	const chanvec_t *chanvec;
+
+	bzero(&wlc_cm->quiet_channels, sizeof(chanvec_t));
+
+	band = wlc->band;
+	for (i = 0; i < NBANDS(wlc);
+	     i++, band = wlc->bandstate[OTHERBANDUNIT(wlc)]) {
+
+		/* initialize quiet channels for restricted channels */
+		chanvec = wlc_cm->bandstate[band->bandunit].restricted_channels;
+		for (j = 0; j < sizeof(chanvec_t); j++)
+			wlc_cm->quiet_channels.vec[j] |= chanvec->vec[j];
+
+	}
+}
+
+bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+{
+	return (N_ENAB(wlc_cm->wlc->pub) && CHSPEC_IS40(chspec) ?
+		(isset
+		 (wlc_cm->quiet_channels.vec,
+		  LOWER_20_SB(CHSPEC_CHANNEL(chspec)))
+		 || isset(wlc_cm->quiet_channels.vec,
+			  UPPER_20_SB(CHSPEC_CHANNEL(chspec)))) : isset(wlc_cm->
+									quiet_channels.
+									vec,
+									CHSPEC_CHANNEL
+									(chspec)));
+}
+
+/* Is the channel valid for the current locale? (but don't consider channels not
+ *   available due to bandlocking)
+ */
+bool wlc_valid_channel20_db(wlc_cm_info_t * wlc_cm, uint val)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+
+	return (VALID_CHANNEL20(wlc, val) ||
+		(!wlc->bandlocked
+		 && VALID_CHANNEL20_IN_BAND(wlc, OTHERBANDUNIT(wlc), val)));
+}
+
+/* Is the channel valid for the current locale and specified band? */
+bool
+wlc_valid_channel20_in_band(wlc_cm_info_t * wlc_cm, uint bandunit, uint val)
+{
+	return ((val < MAXCHANNEL)
+		&& isset(wlc_cm->bandstate[bandunit].valid_channels.vec, val));
+}
+
+/* Is the channel valid for the current locale and current band? */
+bool wlc_valid_channel20(wlc_cm_info_t * wlc_cm, uint val)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+
+	return ((val < MAXCHANNEL) &&
+		isset(wlc_cm->bandstate[wlc->band->bandunit].valid_channels.vec,
+		      val));
+}
+
+/* Is the 40 MHz allowed for the current locale and specified band? */
+bool wlc_valid_40chanspec_in_band(wlc_cm_info_t * wlc_cm, uint bandunit)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+
+	return (((wlc_cm->bandstate[bandunit].
+		  locale_flags & (WLC_NO_MIMO | WLC_NO_40MHZ)) == 0)
+		&& wlc->bandstate[bandunit]->mimo_cap_40);
+}
+
+static void
+wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm_info_t * wlc_cm,
+						     struct txpwr_limits *txpwr,
+						     uint8
+						     local_constraint_qdbm)
+{
+	int j;
+
+	/* CCK Rates */
+	for (j = 0; j < WL_TX_POWER_CCK_NUM; j++) {
+		txpwr->cck[j] = MIN(txpwr->cck[j], local_constraint_qdbm);
+	}
+
+	/* 20 MHz Legacy OFDM SISO */
+	for (j = 0; j < WL_TX_POWER_OFDM_NUM; j++) {
+		txpwr->ofdm[j] = MIN(txpwr->ofdm[j], local_constraint_qdbm);
+	}
+
+	/* 20 MHz Legacy OFDM CDD */
+	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
+		txpwr->ofdm_cdd[j] =
+		    MIN(txpwr->ofdm_cdd[j], local_constraint_qdbm);
+	}
+
+	/* 40 MHz Legacy OFDM SISO */
+	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
+		txpwr->ofdm_40_siso[j] =
+		    MIN(txpwr->ofdm_40_siso[j], local_constraint_qdbm);
+	}
+
+	/* 40 MHz Legacy OFDM CDD */
+	for (j = 0; j < WLC_NUM_RATES_OFDM; j++) {
+		txpwr->ofdm_40_cdd[j] =
+		    MIN(txpwr->ofdm_40_cdd[j], local_constraint_qdbm);
+	}
+
+	/* 20MHz MCS 0-7 SISO */
+	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
+		txpwr->mcs_20_siso[j] =
+		    MIN(txpwr->mcs_20_siso[j], local_constraint_qdbm);
+	}
+
+	/* 20MHz MCS 0-7 CDD */
+	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
+		txpwr->mcs_20_cdd[j] =
+		    MIN(txpwr->mcs_20_cdd[j], local_constraint_qdbm);
+	}
+
+	/* 20MHz MCS 0-7 STBC */
+	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
+		txpwr->mcs_20_stbc[j] =
+		    MIN(txpwr->mcs_20_stbc[j], local_constraint_qdbm);
+	}
+
+	/* 20MHz MCS 8-15 MIMO */
+	for (j = 0; j < WLC_NUM_RATES_MCS_2_STREAM; j++)
+		txpwr->mcs_20_mimo[j] =
+		    MIN(txpwr->mcs_20_mimo[j], local_constraint_qdbm);
+
+	/* 40MHz MCS 0-7 SISO */
+	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
+		txpwr->mcs_40_siso[j] =
+		    MIN(txpwr->mcs_40_siso[j], local_constraint_qdbm);
+	}
+
+	/* 40MHz MCS 0-7 CDD */
+	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
+		txpwr->mcs_40_cdd[j] =
+		    MIN(txpwr->mcs_40_cdd[j], local_constraint_qdbm);
+	}
+
+	/* 40MHz MCS 0-7 STBC */
+	for (j = 0; j < WLC_NUM_RATES_MCS_1_STREAM; j++) {
+		txpwr->mcs_40_stbc[j] =
+		    MIN(txpwr->mcs_40_stbc[j], local_constraint_qdbm);
+	}
+
+	/* 40MHz MCS 8-15 MIMO */
+	for (j = 0; j < WLC_NUM_RATES_MCS_2_STREAM; j++)
+		txpwr->mcs_40_mimo[j] =
+		    MIN(txpwr->mcs_40_mimo[j], local_constraint_qdbm);
+
+	/* 40MHz MCS 32 */
+	txpwr->mcs32 = MIN(txpwr->mcs32, local_constraint_qdbm);
+
+}
+
+void
+wlc_channel_set_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
+			 uint8 local_constraint_qdbm)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	struct txpwr_limits txpwr;
+
+	wlc_channel_reg_limits(wlc_cm, chanspec, &txpwr);
+
+	wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm, &txpwr,
+							     local_constraint_qdbm);
+
+	wlc_bmac_set_chanspec(wlc->hw, chanspec,
+			      (wlc_quiet_chanspec(wlc_cm, chanspec) != 0),
+			      &txpwr);
+}
+
+int
+wlc_channel_set_txpower_limit(wlc_cm_info_t * wlc_cm,
+			      uint8 local_constraint_qdbm)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	struct txpwr_limits txpwr;
+
+	wlc_channel_reg_limits(wlc_cm, wlc->chanspec, &txpwr);
+
+	wlc_channel_min_txpower_limits_with_local_constraint(wlc_cm, &txpwr,
+							     local_constraint_qdbm);
+
+	wlc_phy_txpower_limit_set(wlc->band->pi, &txpwr, wlc->chanspec);
+
+	return 0;
+}
+
+#ifdef POWER_DBG
+static void wlc_phy_txpower_limits_dump(txpwr_limits_t * txpwr)
+{
+	int i;
+	char fraction[4][4] = { "   ", ".25", ".5 ", ".75" };
+
+	printf("CCK                ");
+	for (i = 0; i < WLC_NUM_RATES_CCK; i++) {
+		printf(" %2d%s", txpwr->cck[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->cck[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("20 MHz OFDM SISO   ");
+	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
+		printf(" %2d%s", txpwr->ofdm[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->ofdm[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("20 MHz OFDM CDD    ");
+	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
+		printf(" %2d%s", txpwr->ofdm_cdd[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->ofdm_cdd[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("40 MHz OFDM SISO   ");
+	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
+		printf(" %2d%s", txpwr->ofdm_40_siso[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->ofdm_40_siso[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("40 MHz OFDM CDD    ");
+	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
+		printf(" %2d%s", txpwr->ofdm_40_cdd[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->ofdm_40_cdd[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("20 MHz MCS0-7 SISO ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_20_siso[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_20_siso[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("20 MHz MCS0-7 CDD  ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_20_cdd[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_20_cdd[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("20 MHz MCS0-7 STBC ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_20_stbc[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_20_stbc[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("20 MHz MCS8-15 SDM ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_2_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_20_mimo[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_20_mimo[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("40 MHz MCS0-7 SISO ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_40_siso[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_40_siso[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("40 MHz MCS0-7 CDD  ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_40_cdd[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_40_cdd[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("40 MHz MCS0-7 STBC ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_40_stbc[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_40_stbc[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("40 MHz MCS8-15 SDM ");
+	for (i = 0; i < WLC_NUM_RATES_MCS_2_STREAM; i++) {
+		printf(" %2d%s", txpwr->mcs_40_mimo[i] / WLC_TXPWR_DB_FACTOR,
+		       fraction[txpwr->mcs_40_mimo[i] % WLC_TXPWR_DB_FACTOR]);
+	}
+	printf("\n");
+
+	printf("MCS32               %2d%s\n",
+	       txpwr->mcs32 / WLC_TXPWR_DB_FACTOR,
+	       fraction[txpwr->mcs32 % WLC_TXPWR_DB_FACTOR]);
+}
+#endif				/* POWER_DBG */
+
+void
+wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm, chanspec_t chanspec,
+		       txpwr_limits_t * txpwr)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	uint i;
+	uint chan;
+	int maxpwr;
+	int delta;
+	const country_info_t *country;
+	wlcband_t *band;
+	const locale_info_t *li;
+	int conducted_max;
+	int conducted_ofdm_max;
+	const locale_mimo_info_t *li_mimo;
+	int maxpwr20, maxpwr40;
+	int maxpwr_idx;
+	uint j;
+
+	bzero(txpwr, sizeof(txpwr_limits_t));
+
+	if (!wlc_valid_chanspec_db(wlc_cm, chanspec)) {
+		country = wlc_country_lookup(wlc, wlc->autocountry_default);
+		if (country == NULL)
+			return;
+	} else {
+		country = wlc_cm->country;
+	}
+
+	chan = CHSPEC_CHANNEL(chanspec);
+	band = wlc->bandstate[CHSPEC_WLCBANDUNIT(chanspec)];
+	li = BAND_5G(band->bandtype) ?
+	    wlc_get_locale_5g(country->locale_5G) :
+	    wlc_get_locale_2g(country->locale_2G);
+
+	li_mimo = BAND_5G(band->bandtype) ?
+	    wlc_get_mimo_5g(country->locale_mimo_5G) :
+	    wlc_get_mimo_2g(country->locale_mimo_2G);
+
+	if (li->flags & WLC_EIRP) {
+		delta = band->antgain;
+	} else {
+		delta = 0;
+		if (band->antgain > QDB(6))
+			delta = band->antgain - QDB(6);	/* Excess over 6 dB */
+	}
+
+	if (li == &locale_i) {
+		conducted_max = QDB(22);
+		conducted_ofdm_max = QDB(22);
+	}
+
+	/* CCK txpwr limits for 2.4G band */
+	if (BAND_2G(band->bandtype)) {
+		maxpwr = li->maxpwr[CHANNEL_POWER_IDX_2G_CCK(chan)];
+
+		maxpwr = maxpwr - delta;
+		maxpwr = MAX(maxpwr, 0);
+		maxpwr = MIN(maxpwr, conducted_max);
+
+		for (i = 0; i < WLC_NUM_RATES_CCK; i++)
+			txpwr->cck[i] = (uint8) maxpwr;
+	}
+
+	/* OFDM txpwr limits for 2.4G or 5G bands */
+	if (BAND_2G(band->bandtype)) {
+		maxpwr = li->maxpwr[CHANNEL_POWER_IDX_2G_OFDM(chan)];
+
+	} else {
+		maxpwr = li->maxpwr[CHANNEL_POWER_IDX_5G(chan)];
+	}
+
+	maxpwr = maxpwr - delta;
+	maxpwr = MAX(maxpwr, 0);
+	maxpwr = MIN(maxpwr, conducted_ofdm_max);
+
+	/* Keep OFDM lmit below CCK limit */
+	if (BAND_2G(band->bandtype))
+		maxpwr = MIN(maxpwr, txpwr->cck[0]);
+
+	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
+		txpwr->ofdm[i] = (uint8) maxpwr;
+	}
+
+	for (i = 0; i < WLC_NUM_RATES_OFDM; i++) {
+		/* OFDM 40 MHz SISO has the same power as the corresponding MCS0-7 rate unless
+		 * overriden by the locale specific code. We set this value to 0 as a
+		 * flag (presumably 0 dBm isn't a possibility) and then copy the MCS0-7 value
+		 * to the 40 MHz value if it wasn't explicitly set.
+		 */
+		txpwr->ofdm_40_siso[i] = 0;
+
+		txpwr->ofdm_cdd[i] = (uint8) maxpwr;
+
+		txpwr->ofdm_40_cdd[i] = 0;
+	}
+
+	/* MIMO/HT specific limits */
+	if (li_mimo->flags & WLC_EIRP) {
+		delta = band->antgain;
+	} else {
+		delta = 0;
+		if (band->antgain > QDB(6))
+			delta = band->antgain - QDB(6);	/* Excess over 6 dB */
+	}
+
+	if (BAND_2G(band->bandtype))
+		maxpwr_idx = (chan - 1);
+	else
+		maxpwr_idx = CHANNEL_POWER_IDX_5G(chan);
+
+	maxpwr20 = li_mimo->maxpwr20[maxpwr_idx];
+	maxpwr40 = li_mimo->maxpwr40[maxpwr_idx];
+
+	maxpwr20 = maxpwr20 - delta;
+	maxpwr20 = MAX(maxpwr20, 0);
+	maxpwr40 = maxpwr40 - delta;
+	maxpwr40 = MAX(maxpwr40, 0);
+
+	/* Fill in the MCS 0-7 (SISO) rates */
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+
+		/* 20 MHz has the same power as the corresponding OFDM rate unless
+		 * overriden by the locale specific code.
+		 */
+		txpwr->mcs_20_siso[i] = txpwr->ofdm[i];
+		txpwr->mcs_40_siso[i] = 0;
+	}
+
+	/* Fill in the MCS 0-7 CDD rates */
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		txpwr->mcs_20_cdd[i] = (uint8) maxpwr20;
+		txpwr->mcs_40_cdd[i] = (uint8) maxpwr40;
+	}
+
+	/* These locales have SISO expressed in the table and override CDD later */
+	if (li_mimo == &locale_bn) {
+		if (li_mimo == &locale_bn) {
+			maxpwr20 = QDB(16);
+			maxpwr40 = 0;
+
+			if (chan >= 3 && chan <= 11) {
+				maxpwr40 = QDB(16);
+			}
+		}
+
+		for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+			txpwr->mcs_20_siso[i] = (uint8) maxpwr20;
+			txpwr->mcs_40_siso[i] = (uint8) maxpwr40;
+		}
+	}
+
+	/* Fill in the MCS 0-7 STBC rates */
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		txpwr->mcs_20_stbc[i] = 0;
+		txpwr->mcs_40_stbc[i] = 0;
+	}
+
+	/* Fill in the MCS 8-15 SDM rates */
+	for (i = 0; i < WLC_NUM_RATES_MCS_2_STREAM; i++) {
+		txpwr->mcs_20_mimo[i] = (uint8) maxpwr20;
+		txpwr->mcs_40_mimo[i] = (uint8) maxpwr40;
+	}
+
+	/* Fill in MCS32 */
+	txpwr->mcs32 = (uint8) maxpwr40;
+
+	for (i = 0, j = 0; i < WLC_NUM_RATES_OFDM; i++, j++) {
+		if (txpwr->ofdm_40_cdd[i] == 0)
+			txpwr->ofdm_40_cdd[i] = txpwr->mcs_40_cdd[j];
+		if (i == 0) {
+			i = i + 1;
+			if (txpwr->ofdm_40_cdd[i] == 0)
+				txpwr->ofdm_40_cdd[i] = txpwr->mcs_40_cdd[j];
+		}
+	}
+
+	/* Copy the 40 MHZ MCS 0-7 CDD value to the 40 MHZ MCS 0-7 SISO value if it wasn't
+	 * provided explicitly. 
+	 */
+
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		if (txpwr->mcs_40_siso[i] == 0)
+			txpwr->mcs_40_siso[i] = txpwr->mcs_40_cdd[i];
+	}
+
+	for (i = 0, j = 0; i < WLC_NUM_RATES_OFDM; i++, j++) {
+		if (txpwr->ofdm_40_siso[i] == 0)
+			txpwr->ofdm_40_siso[i] = txpwr->mcs_40_siso[j];
+		if (i == 0) {
+			i = i + 1;
+			if (txpwr->ofdm_40_siso[i] == 0)
+				txpwr->ofdm_40_siso[i] = txpwr->mcs_40_siso[j];
+		}
+	}
+
+	/* Copy the 20 and 40 MHz MCS0-7 CDD values to the corresponding STBC values if they weren't
+	 * provided explicitly.
+	 */
+	for (i = 0; i < WLC_NUM_RATES_MCS_1_STREAM; i++) {
+		if (txpwr->mcs_20_stbc[i] == 0)
+			txpwr->mcs_20_stbc[i] = txpwr->mcs_20_cdd[i];
+
+		if (txpwr->mcs_40_stbc[i] == 0)
+			txpwr->mcs_40_stbc[i] = txpwr->mcs_40_cdd[i];
+	}
+
+#ifdef POWER_DBG
+	wlc_phy_txpower_limits_dump(txpwr);
+#endif
+	return;
+}
+
+/* Returns TRUE if currently set country is Japan or variant */
+bool wlc_japan(struct wlc_info * wlc)
+{
+	return wlc_japan_ccode(wlc->cmi->country_abbrev);
+}
+
+/* JP, J1 - J10 are Japan ccodes */
+static bool wlc_japan_ccode(const char *ccode)
+{
+	return (ccode[0] == 'J' &&
+		(ccode[1] == 'P' || (ccode[1] >= '1' && ccode[1] <= '9')));
+}
+
+/*
+ * Validate the chanspec for this locale, for 40MHZ we need to also check that the sidebands
+ * are valid 20MZH channels in this locale and they are also a legal HT combination
+ */
+static bool
+wlc_valid_chanspec_ext(wlc_cm_info_t * wlc_cm, chanspec_t chspec, bool dualband)
+{
+	wlc_info_t *wlc = wlc_cm->wlc;
+	uint8 channel = CHSPEC_CHANNEL(chspec);
+
+	/* check the chanspec */
+	if (wf_chspec_malformed(chspec)) {
+		WL_ERROR(("wl%d: malformed chanspec 0x%x\n", wlc->pub->unit,
+			  chspec));
+		ASSERT(0);
+		return FALSE;
+	}
+
+	if (CHANNEL_BANDUNIT(wlc_cm->wlc, channel) !=
+	    CHSPEC_WLCBANDUNIT(chspec))
+		return FALSE;
+
+	/* Check a 20Mhz channel */
+	if (CHSPEC_IS20(chspec)) {
+		if (dualband)
+			return (VALID_CHANNEL20_DB(wlc_cm->wlc, channel));
+		else
+			return (VALID_CHANNEL20(wlc_cm->wlc, channel));
+	}
+#ifdef SUPPORT_40MHZ
+	/* We know we are now checking a 40MHZ channel, so we should only be here
+	 * for NPHYS
+	 */
+	if (WLCISNPHY(wlc->band) || WLCISSSLPNPHY(wlc->band)) {
+		uint8 upper_sideband = 0, idx;
+		uint8 num_ch20_entries =
+		    sizeof(chan20_info) / sizeof(struct chan20_info);
+
+		if (!VALID_40CHANSPEC_IN_BAND(wlc, CHSPEC_WLCBANDUNIT(chspec)))
+			return FALSE;
+
+		if (dualband) {
+			if (!VALID_CHANNEL20_DB(wlc, LOWER_20_SB(channel)) ||
+			    !VALID_CHANNEL20_DB(wlc, UPPER_20_SB(channel)))
+				return FALSE;
+		} else {
+			if (!VALID_CHANNEL20(wlc, LOWER_20_SB(channel)) ||
+			    !VALID_CHANNEL20(wlc, UPPER_20_SB(channel)))
+				return FALSE;
+		}
+
+		/* find the lower sideband info in the sideband array */
+		for (idx = 0; idx < num_ch20_entries; idx++) {
+			if (chan20_info[idx].sb == LOWER_20_SB(channel))
+				upper_sideband = chan20_info[idx].adj_sbs;
+		}
+		/* check that the lower sideband allows an upper sideband */
+		if ((upper_sideband & (CH_UPPER_SB | CH_EWA_VALID)) ==
+		    (CH_UPPER_SB | CH_EWA_VALID))
+			return TRUE;
+		return FALSE;
+	}
+#endif				/* 40 MHZ */
+
+	return FALSE;
+}
+
+bool wlc_valid_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+{
+	return wlc_valid_chanspec_ext(wlc_cm, chspec, FALSE);
+}
+
+bool wlc_valid_chanspec_db(wlc_cm_info_t * wlc_cm, chanspec_t chspec)
+{
+	return wlc_valid_chanspec_ext(wlc_cm, chspec, TRUE);
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_channel.h b/drivers/staging/brcm80211/sys/wlc_channel.h
new file mode 100644
index 0000000..9bc708d
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_channel.h
@@ -0,0 +1,159 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLC_CHANNEL_H_
+#define _WLC_CHANNEL_H_
+
+#include <wlc_phy_hal.h>
+
+#define WLC_TXPWR_DB_FACTOR 4	/* conversion for phy txpwr cacluations that use .25 dB units */
+
+struct wlc_info;
+
+/* maxpwr mapping to 5GHz band channels:
+ * maxpwr[0] - channels [34-48]
+ * maxpwr[1] - channels [52-60]
+ * maxpwr[2] - channels [62-64]
+ * maxpwr[3] - channels [100-140]
+ * maxpwr[4] - channels [149-165]
+ */
+#define BAND_5G_PWR_LVLS	5	/* 5 power levels for 5G */
+
+/* power level in group of 2.4GHz band channels:
+ * maxpwr[0] - CCK  channels [1]
+ * maxpwr[1] - CCK  channels [2-10]
+ * maxpwr[2] - CCK  channels [11-14]
+ * maxpwr[3] - OFDM channels [1]
+ * maxpwr[4] - OFDM channels [2-10]
+ * maxpwr[5] - OFDM channels [11-14]
+ */
+
+/* macro to get 2.4 GHz channel group index for tx power */
+#define CHANNEL_POWER_IDX_2G_CCK(c) (((c) < 2) ? 0 : (((c) < 11) ? 1 : 2))	/* cck index */
+#define CHANNEL_POWER_IDX_2G_OFDM(c) (((c) < 2) ? 3 : (((c) < 11) ? 4 : 5))	/* ofdm index */
+
+/* macro to get 5 GHz channel group index for tx power */
+#define CHANNEL_POWER_IDX_5G(c) \
+	(((c) < 52) ? 0 : (((c) < 62) ? 1 :(((c) < 100) ? 2 : (((c) < 149) ? 3 : 4))))
+
+#define WLC_MAXPWR_TBL_SIZE		6	/* max of BAND_5G_PWR_LVLS and 6 for 2.4 GHz */
+#define WLC_MAXPWR_MIMO_TBL_SIZE	14	/* max of BAND_5G_PWR_LVLS and 14 for 2.4 GHz */
+
+/* locale channel and power info. */
+typedef struct {
+	uint32 valid_channels;
+	uint8 radar_channels;	/* List of radar sensitive channels */
+	uint8 restricted_channels;	/* List of channels used only if APs are detected */
+	int8 maxpwr[WLC_MAXPWR_TBL_SIZE];	/* Max tx pwr in qdBm for each sub-band */
+	int8 pub_maxpwr[BAND_5G_PWR_LVLS];	/* Country IE advertised max tx pwr in dBm
+						 * per sub-band
+						 */
+	uint8 flags;
+} locale_info_t;
+
+/* bits for locale_info flags */
+#define WLC_PEAK_CONDUCTED	0x00	/* Peak for locals */
+#define WLC_EIRP		0x01	/* Flag for EIRP */
+#define WLC_DFS_TPC		0x02	/* Flag for DFS TPC */
+#define WLC_NO_OFDM		0x04	/* Flag for No OFDM */
+#define WLC_NO_40MHZ		0x08	/* Flag for No MIMO 40MHz */
+#define WLC_NO_MIMO		0x10	/* Flag for No MIMO, 20 or 40 MHz */
+#define WLC_RADAR_TYPE_EU       0x20	/* Flag for EU */
+#define WLC_DFS_FCC             WLC_DFS_TPC	/* Flag for DFS FCC */
+#define WLC_DFS_EU              (WLC_DFS_TPC | WLC_RADAR_TYPE_EU)	/* Flag for DFS EU */
+
+#define ISDFS_EU(fl)		(((fl) & WLC_DFS_EU) == WLC_DFS_EU)
+
+/* locale per-channel tx power limits for MIMO frames
+ * maxpwr arrays are index by channel for 2.4 GHz limits, and
+ * by sub-band for 5 GHz limits using CHANNEL_POWER_IDX_5G(channel)
+ */
+typedef struct {
+	int8 maxpwr20[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 20 MHz power limits, qdBm units */
+	int8 maxpwr40[WLC_MAXPWR_MIMO_TBL_SIZE];	/* tx 40 MHz power limits, qdBm units */
+	uint8 flags;
+} locale_mimo_info_t;
+
+extern const chanvec_t chanvec_all_2G;
+extern const chanvec_t chanvec_all_5G;
+
+/*
+ * Country names and abbreviations with locale defined from ISO 3166
+ */
+struct country_info {
+	const uint8 locale_2G;	/* 2.4G band locale */
+	const uint8 locale_5G;	/* 5G band locale */
+	const uint8 locale_mimo_2G;	/* 2.4G mimo info */
+	const uint8 locale_mimo_5G;	/* 5G mimo info */
+};
+
+typedef struct country_info country_info_t;
+
+typedef struct wlc_cm_info wlc_cm_info_t;
+
+extern wlc_cm_info_t *wlc_channel_mgr_attach(struct wlc_info *wlc);
+extern void wlc_channel_mgr_detach(wlc_cm_info_t * wlc_cm);
+
+extern int wlc_set_countrycode(wlc_cm_info_t * wlc_cm, const char *ccode);
+extern int wlc_set_countrycode_rev(wlc_cm_info_t * wlc_cm,
+				   const char *country_abbrev,
+				   const char *ccode, int regrev);
+
+extern const char *wlc_channel_country_abbrev(wlc_cm_info_t * wlc_cm);
+extern uint8 wlc_channel_locale_flags(wlc_cm_info_t * wlc_cm);
+extern uint8 wlc_channel_locale_flags_in_band(wlc_cm_info_t * wlc_cm,
+					      uint bandunit);
+
+extern void wlc_quiet_channels_reset(wlc_cm_info_t * wlc_cm);
+extern bool wlc_quiet_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
+
+#define	VALID_CHANNEL20_DB(wlc, val) wlc_valid_channel20_db((wlc)->cmi, val)
+#define	VALID_CHANNEL20_IN_BAND(wlc, bandunit, val) \
+	wlc_valid_channel20_in_band((wlc)->cmi, bandunit, val)
+#define	VALID_CHANNEL20(wlc, val) wlc_valid_channel20((wlc)->cmi, val)
+#define VALID_40CHANSPEC_IN_BAND(wlc, bandunit) wlc_valid_40chanspec_in_band((wlc)->cmi, bandunit)
+
+extern bool wlc_valid_chanspec(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
+extern bool wlc_valid_chanspec_db(wlc_cm_info_t * wlc_cm, chanspec_t chspec);
+extern bool wlc_valid_channel20_db(wlc_cm_info_t * wlc_cm, uint val);
+extern bool wlc_valid_channel20_in_band(wlc_cm_info_t * wlc_cm, uint bandunit,
+					uint val);
+extern bool wlc_valid_channel20(wlc_cm_info_t * wlc_cm, uint val);
+extern bool wlc_valid_40chanspec_in_band(wlc_cm_info_t * wlc_cm, uint bandunit);
+
+extern void wlc_channel_reg_limits(wlc_cm_info_t * wlc_cm,
+				   chanspec_t chanspec,
+				   struct txpwr_limits *txpwr);
+extern void wlc_channel_set_chanspec(wlc_cm_info_t * wlc_cm,
+				     chanspec_t chanspec,
+				     uint8 local_constraint_qdbm);
+extern int wlc_channel_set_txpower_limit(wlc_cm_info_t * wlc_cm,
+					 uint8 local_constraint_qdbm);
+
+extern const country_info_t *wlc_country_lookup(struct wlc_info *wlc,
+						const char *ccode);
+extern void wlc_locale_get_channels(const locale_info_t * locale,
+				    chanvec_t * valid_channels);
+extern const locale_info_t *wlc_get_locale_2g(uint8 locale_idx);
+extern const locale_info_t *wlc_get_locale_5g(uint8 locale_idx);
+extern bool wlc_japan(struct wlc_info *wlc);
+
+extern uint8 wlc_get_regclass(wlc_cm_info_t * wlc_cm, chanspec_t chanspec);
+extern bool wlc_channel_get_chanvec(struct wlc_info *wlc,
+				    const char *country_abbrev, int bandtype,
+				    chanvec_t * channels);
+
+#endif				/* _WLC_CHANNEL_H */
diff --git a/drivers/staging/brcm80211/sys/wlc_event.c b/drivers/staging/brcm80211/sys/wlc_event.c
new file mode 100644
index 0000000..74aae63
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_event.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <wlioctl.h>
+#include <wl_dbg.h>
+#include <wlc_cfg.h>
+#include <wlc_pub.h>
+#include <wlc_key.h>
+#include <wl_export.h>
+#include <wlc_event.h>
+
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_mac80211.h>
+#ifdef MSGTRACE
+#include <msgtrace.h>
+#endif
+
+/* Local prototypes */
+static void wlc_timer_cb(void *arg);
+
+/* Private data structures */
+struct wlc_eventq {
+	wlc_event_t *head;
+	wlc_event_t *tail;
+	struct wlc_info *wlc;
+	void *wl;
+	wlc_pub_t *pub;
+	bool tpending;
+	bool workpending;
+	struct wl_timer *timer;
+	wlc_eventq_cb_t cb;
+	uint8 event_inds_mask[ROUNDUP(WLC_E_LAST, NBBY) / NBBY];
+};
+
+/*
+ * Export functions
+ */
+wlc_eventq_t *BCMATTACHFN(wlc_eventq_attach) (wlc_pub_t * pub,
+					      struct wlc_info * wlc, void *wl,
+					      wlc_eventq_cb_t cb) {
+	wlc_eventq_t *eq;
+
+	eq = (wlc_eventq_t *) MALLOC(pub->osh, sizeof(wlc_eventq_t));
+	if (eq == NULL)
+		return NULL;
+
+	bzero(eq, sizeof(wlc_eventq_t));
+
+	eq->cb = cb;
+	eq->wlc = wlc;
+	eq->wl = wl;
+	eq->pub = pub;
+
+	if (!(eq->timer = wl_init_timer(eq->wl, wlc_timer_cb, eq, "eventq"))) {
+		WL_ERROR(("wl%d: wlc_eventq_attach: timer failed\n",
+			  pub->unit));
+		MFREE(eq->pub->osh, eq, sizeof(wlc_eventq_t));
+		return NULL;
+	}
+
+	return eq;
+}
+
+int BCMATTACHFN(wlc_eventq_detach) (wlc_eventq_t * eq) {
+	/* Clean up pending events */
+	wlc_eventq_down(eq);
+
+	if (eq->timer) {
+		if (eq->tpending) {
+			wl_del_timer(eq->wl, eq->timer);
+			eq->tpending = FALSE;
+		}
+		wl_free_timer(eq->wl, eq->timer);
+		eq->timer = NULL;
+	}
+
+	ASSERT(wlc_eventq_avail(eq) == FALSE);
+	MFREE(eq->pub->osh, eq, sizeof(wlc_eventq_t));
+	return 0;
+}
+
+int BCMUNINITFN(wlc_eventq_down) (wlc_eventq_t * eq) {
+	int callbacks = 0;
+	if (eq->tpending && !eq->workpending) {
+		if (!wl_del_timer(eq->wl, eq->timer))
+			callbacks++;
+
+		ASSERT(wlc_eventq_avail(eq) == TRUE);
+		ASSERT(eq->workpending == FALSE);
+		eq->workpending = TRUE;
+		if (eq->cb)
+			eq->cb(eq->wlc);
+
+		ASSERT(eq->workpending == TRUE);
+		eq->workpending = FALSE;
+		eq->tpending = FALSE;
+	} else {
+		ASSERT(eq->workpending || wlc_eventq_avail(eq) == FALSE);
+	}
+	return callbacks;
+}
+
+wlc_event_t *wlc_event_alloc(wlc_eventq_t * eq)
+{
+	wlc_event_t *e;
+
+	e = MALLOC(eq->pub->osh, sizeof(wlc_event_t));
+
+	if (e == NULL)
+		return NULL;
+
+	bzero(e, sizeof(wlc_event_t));
+	return e;
+}
+
+void wlc_event_free(wlc_eventq_t * eq, wlc_event_t * e)
+{
+	ASSERT(e->data == NULL);
+	ASSERT(e->next == NULL);
+	MFREE(eq->pub->osh, e, sizeof(wlc_event_t));
+}
+
+void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e)
+{
+	ASSERT(e->next == NULL);
+	e->next = NULL;
+
+	if (eq->tail) {
+		eq->tail->next = e;
+		eq->tail = e;
+	} else
+		eq->head = eq->tail = e;
+
+	if (!eq->tpending) {
+		eq->tpending = TRUE;
+		/* Use a zero-delay timer to trigger
+		 * delayed processing of the event.
+		 */
+		wl_add_timer(eq->wl, eq->timer, 0, 0);
+	}
+}
+
+wlc_event_t *wlc_eventq_deq(wlc_eventq_t * eq)
+{
+	wlc_event_t *e;
+
+	e = eq->head;
+	if (e) {
+		eq->head = e->next;
+		e->next = NULL;
+
+		if (eq->head == NULL)
+			eq->tail = eq->head;
+	}
+	return e;
+}
+
+wlc_event_t *wlc_eventq_next(wlc_eventq_t * eq, wlc_event_t * e)
+{
+#ifdef BCMDBG
+	wlc_event_t *etmp;
+
+	for (etmp = eq->head; etmp; etmp = etmp->next) {
+		if (etmp == e)
+			break;
+	}
+	ASSERT(etmp != NULL);
+#endif
+
+	return e->next;
+}
+
+int wlc_eventq_cnt(wlc_eventq_t * eq)
+{
+	wlc_event_t *etmp;
+	int cnt = 0;
+
+	for (etmp = eq->head; etmp; etmp = etmp->next)
+		cnt++;
+
+	return cnt;
+}
+
+bool wlc_eventq_avail(wlc_eventq_t * eq)
+{
+	return (eq->head != NULL);
+}
+
+/*
+ * Local Functions
+ */
+static void wlc_timer_cb(void *arg)
+{
+	struct wlc_eventq *eq = (struct wlc_eventq *)arg;
+
+	ASSERT(eq->tpending == TRUE);
+	ASSERT(wlc_eventq_avail(eq) == TRUE);
+	ASSERT(eq->workpending == FALSE);
+	eq->workpending = TRUE;
+
+	if (eq->cb)
+		eq->cb(eq->wlc);
+
+	ASSERT(wlc_eventq_avail(eq) == FALSE);
+	ASSERT(eq->tpending == TRUE);
+	eq->workpending = FALSE;
+	eq->tpending = FALSE;
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_event.h b/drivers/staging/brcm80211/sys/wlc_event.h
new file mode 100644
index 0000000..48efdbc
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_event.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLC_EVENT_H_
+#define _WLC_EVENT_H_
+
+typedef struct wlc_eventq wlc_eventq_t;
+
+typedef void (*wlc_eventq_cb_t) (void *arg);
+
+extern wlc_eventq_t *wlc_eventq_attach(wlc_pub_t * pub, struct wlc_info *wlc,
+				       void *wl, wlc_eventq_cb_t cb);
+extern int wlc_eventq_detach(wlc_eventq_t * eq);
+extern int wlc_eventq_down(wlc_eventq_t * eq);
+extern void wlc_event_free(wlc_eventq_t * eq, wlc_event_t * e);
+extern wlc_event_t *wlc_eventq_next(wlc_eventq_t * eq, wlc_event_t * e);
+extern int wlc_eventq_cnt(wlc_eventq_t * eq);
+extern bool wlc_eventq_avail(wlc_eventq_t * eq);
+extern wlc_event_t *wlc_eventq_deq(wlc_eventq_t * eq);
+extern void wlc_eventq_enq(wlc_eventq_t * eq, wlc_event_t * e);
+extern wlc_event_t *wlc_event_alloc(wlc_eventq_t * eq);
+
+extern int wlc_eventq_register_ind(wlc_eventq_t * eq, void *bitvect);
+extern int wlc_eventq_query_ind(wlc_eventq_t * eq, void *bitvect);
+extern int wlc_eventq_test_ind(wlc_eventq_t * eq, int et);
+extern int wlc_eventq_set_ind(wlc_eventq_t * eq, uint et, bool on);
+extern void wlc_eventq_flush(wlc_eventq_t * eq);
+extern void wlc_assign_event_msg(wlc_info_t * wlc, wl_event_msg_t * msg,
+				 const wlc_event_t * e, uint8 * data,
+				 uint32 len);
+
+#ifdef MSGTRACE
+extern void wlc_event_sendup_trace(struct wlc_info *wlc, hndrte_dev_t * bus,
+				   uint8 * hdr, uint16 hdrlen, uint8 * buf,
+				   uint16 buflen);
+#endif
+
+#endif				/* _WLC_EVENT_H_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_key.h b/drivers/staging/brcm80211/sys/wlc_key.h
new file mode 100644
index 0000000..9d2ea4e
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_key.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_key_h_
+#define _wlc_key_h_
+
+struct scb;
+struct wlc_info;
+struct wlc_bsscfg;
+/* Maximum # of keys that wl driver supports in S/W.
+ * Keys supported in H/W is less than or equal to WSEC_MAX_KEYS.
+ */
+#define WSEC_MAX_KEYS		54	/* Max # of keys (50 + 4 default keys) */
+#define WLC_DEFAULT_KEYS	4	/* Default # of keys */
+
+#define WSEC_MAX_WOWL_KEYS 5	/* Max keys in WOWL mode (1 + 4 default keys) */
+
+#define WPA2_GTK_MAX	3
+
+/*
+* Max # of keys currently supported:
+*
+*     s/w keys if WSEC_SW(wlc->wsec).
+*     h/w keys otherwise.
+*/
+#define WLC_MAX_WSEC_KEYS(wlc) WSEC_MAX_KEYS
+
+/* number of 802.11 default (non-paired, group keys) */
+#define WSEC_MAX_DEFAULT_KEYS	4	/* # of default keys */
+
+/* Max # of hardware keys supported */
+#define WLC_MAX_WSEC_HW_KEYS(wlc) WSEC_MAX_RCMTA_KEYS
+
+/* Max # of hardware TKIP MIC keys supported */
+#define WLC_MAX_TKMIC_HW_KEYS(wlc) ((D11REV_GE((wlc)->pub->corerev, 13)) ? \
+		WSEC_MAX_TKMIC_ENGINE_KEYS : 0)
+
+#define WSEC_HW_TKMIC_KEY(wlc, key, bsscfg) \
+	(((D11REV_GE((wlc)->pub->corerev, 13)) && ((wlc)->machwcap & MCAP_TKIPMIC)) && \
+	 (key) && ((key)->algo == CRYPTO_ALGO_TKIP) && \
+	 !WSEC_SOFTKEY(wlc, key, bsscfg) && \
+	WSEC_KEY_INDEX(wlc, key) >= WLC_DEFAULT_KEYS && \
+	(WSEC_KEY_INDEX(wlc, key) < WSEC_MAX_TKMIC_ENGINE_KEYS))
+
+/* index of key in key table */
+#define WSEC_KEY_INDEX(wlc, key)	((key)->idx)
+
+#define WSEC_SOFTKEY(wlc, key, bsscfg) (WLC_SW_KEYS(wlc, bsscfg) || \
+	WSEC_KEY_INDEX(wlc, key) >= WLC_MAX_WSEC_HW_KEYS(wlc))
+
+/* get a key, non-NULL only if key allocated and not clear */
+#define WSEC_KEY(wlc, i)	(((wlc)->wsec_keys[i] && (wlc)->wsec_keys[i]->len) ? \
+	(wlc)->wsec_keys[i] : NULL)
+
+#define WSEC_SCB_KEY_VALID(scb)	(((scb)->key && (scb)->key->len) ? TRUE : FALSE)
+
+/* default key */
+#define WSEC_BSS_DEFAULT_KEY(bsscfg) (((bsscfg)->wsec_index == -1) ? \
+	(struct wsec_key*)NULL : (bsscfg)->bss_def_keys[(bsscfg)->wsec_index])
+
+/* Macros for key management in IBSS mode */
+#define WSEC_IBSS_MAX_PEERS	16	/* Max # of IBSS Peers */
+#define WSEC_IBSS_RCMTA_INDEX(idx) \
+	(((idx - WSEC_MAX_DEFAULT_KEYS) % WSEC_IBSS_MAX_PEERS) + WSEC_MAX_DEFAULT_KEYS)
+
+/* contiguous # key slots for infrastructure mode STA */
+#define WSEC_BSS_STA_KEY_GROUP_SIZE	5
+
+typedef struct wsec_iv {
+	uint32 hi;		/* upper 32 bits of IV */
+	uint16 lo;		/* lower 16 bits of IV */
+} wsec_iv_t;
+
+#define WLC_NUMRXIVS	16	/* # rx IVs (one per 802.11e TID) */
+
+typedef struct wsec_key {
+	struct ether_addr ea;	/* per station */
+	uint8 idx;		/* key index in wsec_keys array */
+	uint8 id;		/* key ID [0-3] */
+	uint8 algo;		/* CRYPTO_ALGO_AES_CCM, CRYPTO_ALGO_WEP128, etc */
+	uint8 rcmta;		/* rcmta entry index, same as idx by default */
+	uint16 flags;		/* misc flags */
+	uint8 algo_hw;		/* cache for hw register */
+	uint8 aes_mode;		/* cache for hw register */
+	int8 iv_len;		/* IV length */
+	int8 icv_len;		/* ICV length */
+	uint32 len;		/* key length..don't move this var */
+	/* data is 4byte aligned */
+	uint8 data[DOT11_MAX_KEY_SIZE];	/* key data */
+	wsec_iv_t rxiv[WLC_NUMRXIVS];	/* Rx IV (one per TID) */
+	wsec_iv_t txiv;		/* Tx IV */
+
+} wsec_key_t;
+
+typedef struct {
+	uint8 vec[ROUNDUP(WSEC_MAX_KEYS, NBBY) / NBBY];	/* bitvec of wsec_key indexes */
+} wsec_key_vec_t;
+
+/* For use with wsec_key_t.flags */
+
+#define WSEC_BS_UPDATE		(1 << 0)	/* Indicates hw needs key update on BS switch */
+#define WSEC_PRIMARY_KEY	(1 << 1)	/* Indicates this key is the primary (ie tx) key */
+#define WSEC_TKIP_ERROR		(1 << 2)	/* Provoke deliberate MIC error */
+#define WSEC_REPLAY_ERROR	(1 << 3)	/* Provoke deliberate replay */
+#define WSEC_IBSS_PEER_GROUP_KEY	(1 << 7)	/* Flag: group key for a IBSS PEER */
+#define WSEC_ICV_ERROR		(1 << 8)	/* Provoke deliberate ICV error */
+
+#define wlc_key_insert(a, b, c, d, e, f, g, h, i, j) (BCME_ERROR)
+#define wlc_key_update(a, b, c) do {} while (0)
+#define wlc_key_remove(a, b, c) do {} while (0)
+#define wlc_key_remove_all(a, b) do {} while (0)
+#define wlc_key_delete(a, b, c) do {} while (0)
+#define wlc_scb_key_delete(a, b) do {} while (0)
+#define wlc_key_lookup(a, b, c, d, e) (NULL)
+#define wlc_key_hw_init_all(a) do {} while (0)
+#define wlc_key_hw_init(a, b, c)  do {} while (0)
+#define wlc_key_hw_wowl_init(a, b, c, d) do {} while (0)
+#define wlc_key_sw_wowl_update(a, b, c, d, e) do {} while (0)
+#define wlc_key_sw_wowl_create(a, b, c) (BCME_ERROR)
+#define wlc_key_iv_update(a, b, c, d, e) do {(void)e;} while (0)
+#define wlc_key_iv_init(a, b, c) do {} while (0)
+#define wlc_key_set_error(a, b, c) (BCME_ERROR)
+#define wlc_key_dump_hw(a, b) (BCME_ERROR)
+#define wlc_key_dump_sw(a, b) (BCME_ERROR)
+#define wlc_key_defkeyflag(a) (0)
+#define wlc_rcmta_add_bssid(a, b) do {} while (0)
+#define wlc_rcmta_del_bssid(a, b) do {} while (0)
+#define wlc_key_scb_delete(a, b) do {} while (0)
+
+#endif				/* _wlc_key_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_mac80211.c b/drivers/staging/brcm80211/sys/wlc_mac80211.c
new file mode 100644
index 0000000..414ba49
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.c
@@ -0,0 +1,9111 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <bcmwifi.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <proto/802.1d.h>
+#include <proto/802.11.h>
+#include <proto/802.11e.h>
+#include <proto/wpa.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <pcicfg.h>
+#include <bcmsrom.h>
+#include <wlioctl.h>
+#include <epivers.h>
+#include <bcmwpa.h>
+#include <sbhndpio.h>
+#include <sbhnddma.h>
+#include <hnddma.h>
+#include <hndpmu.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_pub.h>
+#include <wlc_key.h>
+#include <wlc_bsscfg.h>
+#include <wlc_channel.h>
+#include <wlc_mac80211.h>
+#include <wlc_bmac.h>
+#include <wlc_scb.h>
+#include <wlc_phy_hal.h>
+#include <wlc_phy_shim.h>
+#include <wlc_antsel.h>
+#include <wlc_stf.h>
+#include <wlc_ampdu.h>
+#include <wlc_event.h>
+#include <wl_export.h>
+#ifdef BCMSDIO
+#include <bcmsdh.h>
+#else
+#include "d11ucode_ext.h"
+#endif
+#ifdef WLC_HIGH_ONLY
+#include <bcm_rpc_tp.h>
+#include <bcm_rpc.h>
+#include <bcm_xdr.h>
+#include <wlc_rpc.h>
+#include <wlc_rpctx.h>
+#endif				/* WLC_HIGH_ONLY */
+#include <wlc_alloc.h>
+#include <net/mac80211.h>
+
+#ifdef WLC_HIGH_ONLY
+#undef R_REG
+#undef W_REG
+#define R_REG(osh, r) RPC_READ_REG(osh, r)
+#define W_REG(osh, r, v) RPC_WRITE_REG(osh, r, v)
+#endif
+
+/*
+ * buffer length needed for wlc_format_ssid
+ * 32 SSID chars, max of 4 chars for each SSID char "\xFF", plus NULL.
+ */
+#define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)
+
+#define	TIMER_INTERVAL_WATCHDOG	1000	/* watchdog timer, in unit of ms */
+#define	TIMER_INTERVAL_RADIOCHK	800	/* radio monitor timer, in unit of ms */
+
+#ifndef WLC_MPC_MAX_DELAYCNT
+#define	WLC_MPC_MAX_DELAYCNT	10	/* Max MPC timeout, in unit of watchdog */
+#endif
+#define	WLC_MPC_MIN_DELAYCNT	1	/* Min MPC timeout, in unit of watchdog */
+#define	WLC_MPC_THRESHOLD	3	/* MPC count threshold level */
+
+#define	BEACON_INTERVAL_DEFAULT	100	/* beacon interval, in unit of 1024TU */
+#define	DTIM_INTERVAL_DEFAULT	3	/* DTIM interval, in unit of beacon interval */
+
+/* Scale down delays to accommodate QT slow speed */
+#define	BEACON_INTERVAL_DEF_QT	20	/* beacon interval, in unit of 1024TU */
+#define	DTIM_INTERVAL_DEF_QT	1	/* DTIM interval, in unit of beacon interval */
+
+#define	TBTT_ALIGN_LEEWAY_US	100	/* min leeway before first TBTT in us */
+
+/*
+ * driver maintains internal 'tick'(wlc->pub->now) which increments in 1s OS timer(soft
+ * watchdog) it is not a wall clock and won't increment when driver is in "down" state
+ * this low resolution driver tick can be used for maintenance tasks such as phy
+ * calibration and scb update
+ */
+
+/* watchdog trigger mode: OSL timer or TBTT */
+#define WLC_WATCHDOG_TBTT(wlc) \
+	(wlc->stas_associated > 0 && wlc->PM != PM_OFF && wlc->pub->align_wd_tbtt)
+
+/* To inform the ucode of the last mcast frame posted so that it can clear moredata bit */
+#define BCMCFID(wlc, fid) wlc_bmac_write_shm((wlc)->hw, M_BCMC_FID, (fid))
+
+#ifndef WLC_HIGH_ONLY
+#define WLC_WAR16165(wlc) (BUSTYPE(wlc->pub->sih->bustype) == PCI_BUS && \
+				(!AP_ENAB(wlc->pub)) && (wlc->war16165))
+#else
+#define WLC_WAR16165(wlc) (FALSE)
+#endif				/* WLC_HIGH_ONLY */
+
+/* debug/trace */
+uint wl_msg_level =
+#if defined(BCMDBG)
+    WL_ERROR_VAL;
+#else
+    0;
+#endif				/* BCMDBG */
+
+/* Find basic rate for a given rate */
+#define WLC_BASIC_RATE(wlc, rspec)	(IS_MCS(rspec) ? \
+			(wlc)->band->basic_rate[mcs_table[rspec & RSPEC_RATE_MASK].leg_ofdm] : \
+			(wlc)->band->basic_rate[rspec & RSPEC_RATE_MASK])
+
+#define FRAMETYPE(r, mimoframe)	(IS_MCS(r) ? mimoframe	: (IS_CCK(r) ? FT_CCK : FT_OFDM))
+
+#define RFDISABLE_DEFAULT	10000000	/* rfdisable delay timer 500 ms, runs of ALP clock */
+
+#define WLC_TEMPSENSE_PERIOD		10	/* 10 second timeout */
+
+#define SCAN_IN_PROGRESS(x)	0
+
+#ifdef BCMDBG
+/* pointer to most recently allocated wl/wlc */
+static wlc_info_t *wlc_info_dbg = (wlc_info_t *) (NULL);
+#endif
+
+#if defined(BCMDBG)
+struct wlc_id_name_entry {
+	int id;
+	const char *name;
+};
+typedef struct wlc_id_name_entry wlc_id_name_table_t[];
+#endif
+
+/* IOVar table */
+
+/* Parameter IDs, for use only internally to wlc -- in the wlc_iovars
+ * table and by the wlc_doiovar() function.  No ordering is imposed:
+ * the table is keyed by name, and the function uses a switch.
+ */
+enum {
+	IOV_MPC = 1,
+	IOV_QTXPOWER,
+	IOV_BCN_LI_BCN,		/* Beacon listen interval in # of beacons */
+	IOV_LAST		/* In case of a need to check max ID number */
+};
+
+const bcm_iovar_t wlc_iovars[] = {
+	{"mpc", IOV_MPC, (IOVF_OPEN_ALLOW), IOVT_BOOL, 0},
+	{"qtxpower", IOV_QTXPOWER, (IOVF_WHL | IOVF_OPEN_ALLOW), IOVT_UINT32,
+	 0},
+	{"bcn_li_bcn", IOV_BCN_LI_BCN, 0, IOVT_UINT8, 0},
+	{NULL, 0, 0, 0, 0}
+};
+
+const uint8 prio2fifo[NUMPRIO] = {
+	TX_AC_BE_FIFO,		/* 0    BE      AC_BE   Best Effort */
+	TX_AC_BK_FIFO,		/* 1    BK      AC_BK   Background */
+	TX_AC_BK_FIFO,		/* 2    --      AC_BK   Background */
+	TX_AC_BE_FIFO,		/* 3    EE      AC_BE   Best Effort */
+	TX_AC_VI_FIFO,		/* 4    CL      AC_VI   Video */
+	TX_AC_VI_FIFO,		/* 5    VI      AC_VI   Video */
+	TX_AC_VO_FIFO,		/* 6    VO      AC_VO   Voice */
+	TX_AC_VO_FIFO		/* 7    NC      AC_VO   Voice */
+};
+
+/* precedences numbers for wlc queues. These are twice as may levels as
+ * 802.1D priorities.
+ * Odd numbers are used for HI priority traffic at same precedence levels
+ * These constants are used ONLY by wlc_prio2prec_map.  Do not use them elsewhere.
+ */
+#define	_WLC_PREC_NONE		0	/* None = - */
+#define	_WLC_PREC_BK		2	/* BK - Background */
+#define	_WLC_PREC_BE		4	/* BE - Best-effort */
+#define	_WLC_PREC_EE		6	/* EE - Excellent-effort */
+#define	_WLC_PREC_CL		8	/* CL - Controlled Load */
+#define	_WLC_PREC_VI		10	/* Vi - Video */
+#define	_WLC_PREC_VO		12	/* Vo - Voice */
+#define	_WLC_PREC_NC		14	/* NC - Network Control */
+
+/* 802.1D Priority to precedence queue mapping */
+const uint8 wlc_prio2prec_map[] = {
+	_WLC_PREC_BE,		/* 0 BE - Best-effort */
+	_WLC_PREC_BK,		/* 1 BK - Background */
+	_WLC_PREC_NONE,		/* 2 None = - */
+	_WLC_PREC_EE,		/* 3 EE - Excellent-effort */
+	_WLC_PREC_CL,		/* 4 CL - Controlled Load */
+	_WLC_PREC_VI,		/* 5 Vi - Video */
+	_WLC_PREC_VO,		/* 6 Vo - Voice */
+	_WLC_PREC_NC,		/* 7 NC - Network Control */
+};
+
+/* Sanity check for tx_prec_map and fifo synchup
+ * Either there are some packets pending for the fifo, else if fifo is empty then
+ * all the corresponding precmap bits should be set
+ */
+#define WLC_TX_FIFO_CHECK(wlc, fifo) (TXPKTPENDGET((wlc), (fifo)) ||	\
+	(TXPKTPENDGET((wlc), (fifo)) == 0 && \
+	((wlc)->tx_prec_map & (wlc)->fifo2prec_map[(fifo)]) == \
+	(wlc)->fifo2prec_map[(fifo)]))
+
+/* TX FIFO number to WME/802.1E Access Category */
+const uint8 wme_fifo2ac[] = { AC_BK, AC_BE, AC_VI, AC_VO, AC_BE, AC_BE };
+
+/* WME/802.1E Access Category to TX FIFO number */
+static const uint8 wme_ac2fifo[] = { 1, 0, 2, 3 };
+
+static bool in_send_q = FALSE;
+
+/* Shared memory location index for various AC params */
+#define wme_shmemacindex(ac)	wme_ac2fifo[ac]
+
+#ifdef BCMDBG
+static const char *fifo_names[] =
+    { "AC_BK", "AC_BE", "AC_VI", "AC_VO", "BCMC", "ATIM" };
+const char *aci_names[] = { "AC_BE", "AC_BK", "AC_VI", "AC_VO" };
+#endif
+
+static const uint8 acbitmap2maxprio[] = {
+	PRIO_8021D_BE, PRIO_8021D_BE, PRIO_8021D_BK, PRIO_8021D_BK,
+	PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI,
+	PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO,
+	PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO
+};
+
+/* currently the best mechanism for determining SIFS is the band in use */
+#define SIFS(band) ((band)->bandtype == WLC_BAND_5G ? APHY_SIFS_TIME : BPHY_SIFS_TIME);
+
+/* value for # replay counters currently supported */
+#define WLC_REPLAY_CNTRS_VALUE	WPA_CAP_16_REPLAY_CNTRS
+
+/* local prototypes */
+extern void wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec);
+static uint16 BCMFASTPATH wlc_d11hdrs_mac80211(wlc_info_t * wlc,
+					       struct ieee80211_hw *hw, void *p,
+					       struct scb *scb, uint frag,
+					       uint nfrags, uint queue,
+					       uint next_frag_len,
+					       wsec_key_t * key,
+					       ratespec_t rspec_override);
+bool wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw);
+void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend);
+static void wlc_bss_default_init(wlc_info_t * wlc);
+static void wlc_ucode_mac_upd(wlc_info_t * wlc);
+static ratespec_t mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band,
+					 uint32 int_val);
+static void wlc_tx_prec_map_init(wlc_info_t * wlc);
+static void wlc_watchdog(void *arg);
+static void wlc_watchdog_by_timer(void *arg);
+static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg);
+static int wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val,
+				const bcm_iovar_t * vi);
+static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc);
+
+#if defined(BCMDBG)
+static void wlc_print_dot11hdr(uint8 * buf, int len);
+#endif
+
+/* send and receive */
+static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t * wlc, osl_t * osh);
+static void wlc_txq_free(wlc_info_t * wlc, osl_t * osh, wlc_txq_info_t * qi);
+static void wlc_txflowcontrol_signal(wlc_info_t * wlc, wlc_txq_info_t * qi,
+				     bool on, int prio);
+static void wlc_txflowcontrol_reset(wlc_info_t * wlc);
+static uint16 wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec,
+				  uint length);
+static void wlc_compute_cck_plcp(ratespec_t rate, uint length, uint8 * plcp);
+static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, uint8 * plcp);
+static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, uint8 * plcp);
+static uint16 wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate,
+				    uint8 preamble_type, uint next_frag_len);
+static void wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh,
+			void *p);
+static uint wlc_calc_frame_len(wlc_info_t * wlc, ratespec_t rate,
+			       uint8 preamble_type, uint dur);
+static uint wlc_calc_ack_time(wlc_info_t * wlc, ratespec_t rate,
+			      uint8 preamble_type);
+static uint wlc_calc_cts_time(wlc_info_t * wlc, ratespec_t rate,
+			      uint8 preamble_type);
+/* interrupt, up/down, band */
+static void wlc_setband(wlc_info_t * wlc, uint bandunit);
+static chanspec_t wlc_init_chanspec(wlc_info_t * wlc);
+static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec);
+static void wlc_bsinit(wlc_info_t * wlc);
+static int wlc_duty_cycle_set(wlc_info_t * wlc, int duty_cycle, bool isOFDM,
+			      bool writeToShm);
+static void wlc_radio_hwdisable_upd(wlc_info_t * wlc);
+static bool wlc_radio_monitor_start(wlc_info_t * wlc);
+static void wlc_radio_timer(void *arg);
+static void wlc_radio_enable(wlc_info_t * wlc);
+static void wlc_radio_upd(wlc_info_t * wlc);
+
+/* scan, association, BSS */
+static uint wlc_calc_ba_time(wlc_info_t * wlc, ratespec_t rate,
+			     uint8 preamble_type);
+static void wlc_update_mimo_band_bwcap(wlc_info_t * wlc, uint8 bwcap);
+static void wlc_ht_update_sgi_rx(wlc_info_t * wlc, int val);
+void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode);
+static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val);
+static void wlc_war16165(wlc_info_t * wlc, bool tx);
+
+static void wlc_process_eventq(void *arg);
+static void wlc_wme_retries_write(wlc_info_t * wlc);
+static bool wlc_attach_stf_ant_init(wlc_info_t * wlc);
+static uint wlc_attach_module(wlc_info_t * wlc);
+static void wlc_detach_module(wlc_info_t * wlc);
+static void wlc_timers_deinit(wlc_info_t * wlc);
+static void wlc_down_led_upd(wlc_info_t * wlc);
+static uint wlc_down_del_timer(wlc_info_t * wlc);
+static void wlc_ofdm_rateset_war(wlc_info_t * wlc);
+static int _wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len,
+		      struct wlc_if *wlcif);
+char *print_fk(uint16 fk);
+
+#if defined(BCMDBG)
+void wlc_get_rcmta(wlc_info_t * wlc, int idx, struct ether_addr *addr)
+{
+	d11regs_t *regs = wlc->regs;
+	uint32 v32;
+	osl_t *osh;
+
+	WL_TRACE(("wl%d: %s\n", WLCWLUNIT(wlc), __func__));
+
+	ASSERT(wlc->pub->corerev > 4);
+
+	osh = wlc->osh;
+
+	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | (idx * 2)));
+	(void)R_REG(osh, &regs->objaddr);
+	v32 = R_REG(osh, &regs->objdata);
+	addr->octet[0] = (uint8) v32;
+	addr->octet[1] = (uint8) (v32 >> 8);
+	addr->octet[2] = (uint8) (v32 >> 16);
+	addr->octet[3] = (uint8) (v32 >> 24);
+	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | ((idx * 2) + 1)));
+	(void)R_REG(osh, &regs->objaddr);
+	v32 = R_REG(osh, (volatile uint16 *)(uintptr) & regs->objdata);
+	addr->octet[4] = (uint8) v32;
+	addr->octet[5] = (uint8) (v32 >> 8);
+}
+#endif				/* defined(BCMDBG) */
+
+/* keep the chip awake if needed */
+bool wlc_stay_awake(wlc_info_t * wlc)
+{
+	return TRUE;
+}
+
+/* conditions under which the PM bit should be set in outgoing frames and STAY_AWAKE is meaningful
+ */
+bool wlc_ps_allowed(wlc_info_t * wlc)
+{
+	int idx;
+	wlc_bsscfg_t *cfg;
+
+	/* disallow PS when one of the following global conditions meets */
+	if (!wlc->pub->associated || !wlc->PMenabled || wlc->PM_override)
+		return FALSE;
+
+	/* disallow PS when one of these meets when not scanning */
+	if (!wlc->PMblocked) {
+		if (AP_ACTIVE(wlc) || wlc->monitor)
+			return FALSE;
+	}
+
+	FOREACH_AS_STA(wlc, idx, cfg) {
+		/* disallow PS when one of the following bsscfg specific conditions meets */
+		if (!cfg->BSS || !WLC_PORTOPEN(cfg))
+			return FALSE;
+
+		if (!cfg->dtim_programmed)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+void BCMINITFN(wlc_reset) (wlc_info_t * wlc) {
+	WL_TRACE(("wl%d: wlc_reset\n", wlc->pub->unit));
+
+	wlc->check_for_unaligned_tbtt = FALSE;
+
+	/* slurp up hw mac counters before core reset */
+	if (WLC_UPDATE_STATS(wlc)) {
+		wlc_statsupd(wlc);
+
+		/* reset our snapshot of macstat counters */
+		bzero((char *)wlc->core->macstat_snapshot, sizeof(macstat_t));
+	}
+
+	wlc_bmac_reset(wlc->hw);
+	wlc_ampdu_reset(wlc->ampdu);
+	wlc->txretried = 0;
+
+#ifdef WLC_HIGH_ONLY
+	/* Need to set a flag(to be cleared asynchronously by BMAC driver with high call)
+	 *  in order to prevent wlc_rpctx_txreclaim() from screwing wlc_rpctx_getnexttxp(),
+	 *  which could be invoked by already QUEUED high call(s) from BMAC driver before
+	 *  wlc_bmac_reset() finishes.
+	 * It's not needed before in monolithic driver model because d11core interrupts would
+	 *  have been cleared instantly in wlc_bmac_reset() and no txstatus interrupt
+	 *  will come to driver to fetch those flushed dma pkt pointers.
+	 */
+	wlc->reset_bmac_pending = TRUE;
+
+	wlc_rpctx_txreclaim(wlc->rpctx);
+
+	wlc_stf_phy_txant_upd(wlc);
+	wlc_phy_ant_rxdiv_set(wlc->band->pi, wlc->stf->ant_rx_ovr);
+#endif
+}
+
+void wlc_fatal_error(wlc_info_t * wlc)
+{
+	WL_ERROR(("wl%d: fatal error, reinitializing\n", wlc->pub->unit));
+	wl_init(wlc->wl);
+}
+
+/* Return the channel the driver should initialize during wlc_init.
+ * the channel may have to be changed from the currently configured channel
+ * if other configurations are in conflict (bandlocked, 11n mode disabled,
+ * invalid channel for current country, etc.)
+ */
+static chanspec_t BCMINITFN(wlc_init_chanspec) (wlc_info_t * wlc) {
+	chanspec_t chanspec =
+	    1 | WL_CHANSPEC_BW_20 | WL_CHANSPEC_CTL_SB_NONE |
+	    WL_CHANSPEC_BAND_2G;
+
+	/* make sure the channel is on the supported band if we are band-restricted */
+	if (wlc->bandlocked || NBANDS(wlc) == 1) {
+		ASSERT(CHSPEC_WLCBANDUNIT(chanspec) == wlc->band->bandunit);
+	}
+	ASSERT(wlc_valid_chanspec_db(wlc->cmi, chanspec));
+	return chanspec;
+}
+
+struct scb global_scb;
+
+static void wlc_init_scb(wlc_info_t * wlc, struct scb *scb)
+{
+	int i;
+	scb->flags = SCB_WMECAP | SCB_HTCAP;
+	for (i = 0; i < NUMPRIO; i++)
+		scb->seqnum[i] = 0;
+}
+
+void BCMINITFN(wlc_init) (wlc_info_t * wlc) {
+	d11regs_t *regs;
+	chanspec_t chanspec;
+	int i;
+	wlc_bsscfg_t *bsscfg;
+	bool mute = FALSE;
+
+	WL_TRACE(("wl%d: wlc_init\n", wlc->pub->unit));
+
+	regs = wlc->regs;
+
+	/* This will happen if a big-hammer was executed. In that case, we want to go back
+	 * to the channel that we were on and not new channel
+	 */
+	if (wlc->pub->associated)
+		chanspec = wlc->home_chanspec;
+	else
+		chanspec = wlc_init_chanspec(wlc);
+
+	wlc_bmac_init(wlc->hw, chanspec, mute);
+
+	wlc->seckeys = wlc_bmac_read_shm(wlc->hw, M_SECRXKEYS_PTR) * 2;
+	if (D11REV_GE(wlc->pub->corerev, 15) && (wlc->machwcap & MCAP_TKIPMIC))
+		wlc->tkmickeys =
+		    wlc_bmac_read_shm(wlc->hw, M_TKMICKEYS_PTR) * 2;
+
+	/* update beacon listen interval */
+	wlc_bcn_li_upd(wlc);
+	wlc->bcn_wait_prd =
+	    (uint8) (wlc_bmac_read_shm(wlc->hw, M_NOSLPZNATDTIM) >> 10);
+	ASSERT(wlc->bcn_wait_prd > 0);
+
+	/* the world is new again, so is our reported rate */
+	wlc_reprate_init(wlc);
+
+	/* write ethernet address to core */
+	FOREACH_BSS(wlc, i, bsscfg) {
+		wlc_set_mac(bsscfg);
+		wlc_set_bssid(bsscfg);
+	}
+
+	/* Update tsf_cfprep if associated and up */
+	if (wlc->pub->associated) {
+		FOREACH_BSS(wlc, i, bsscfg) {
+			if (bsscfg->up) {
+				uint32 bi;
+
+				/* get beacon period from bsscfg and convert to uS */
+				bi = bsscfg->current_bss->beacon_period << 10;
+				/* update the tsf_cfprep register */
+				/* since init path would reset to default value */
+				W_REG(wlc->osh, &regs->tsf_cfprep,
+				      (bi << CFPREP_CBI_SHIFT));
+
+				/* Update maccontrol PM related bits */
+				wlc_set_ps_ctrl(wlc);
+
+				break;
+			}
+		}
+	}
+
+	wlc_key_hw_init_all(wlc);
+
+	wlc_bandinit_ordered(wlc, chanspec);
+
+	wlc_init_scb(wlc, &global_scb);
+
+	/* init probe response timeout */
+	wlc_write_shm(wlc, M_PRS_MAXTIME, wlc->prb_resp_timeout);
+
+	/* init max burst txop (framebursting) */
+	wlc_write_shm(wlc, M_MBURST_TXOP,
+		      (wlc->
+		       _rifs ? (EDCF_AC_VO_TXOP_AP << 5) : MAXFRAMEBURST_TXOP));
+
+	/* initialize maximum allowed duty cycle */
+	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, TRUE, TRUE);
+	wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, FALSE, TRUE);
+
+	/* Update some shared memory locations related to max AMPDU size allowed to received */
+	wlc_ampdu_shm_upd(wlc->ampdu);
+
+	/* band-specific inits */
+	wlc_bsinit(wlc);
+
+	/* Enable EDCF mode (while the MAC is suspended) */
+	if (EDCF_ENAB(wlc->pub)) {
+		OR_REG(wlc->osh, &regs->ifs_ctl, IFS_USEEDCF);
+		wlc_edcf_setparams(wlc->cfg, FALSE);
+	}
+
+	/* Init precedence maps for empty FIFOs */
+	wlc_tx_prec_map_init(wlc);
+
+	/* read the ucode version if we have not yet done so */
+	if (wlc->ucode_rev == 0) {
+		wlc->ucode_rev =
+		    wlc_read_shm(wlc, M_BOM_REV_MAJOR) << NBITS(uint16);
+		wlc->ucode_rev |= wlc_read_shm(wlc, M_BOM_REV_MINOR);
+	}
+
+	/* ..now really unleash hell (allow the MAC out of suspend) */
+	wlc_enable_mac(wlc);
+
+	/* clear tx flow control */
+	wlc_txflowcontrol_reset(wlc);
+
+	/* clear tx data fifo suspends */
+	wlc->tx_suspended = FALSE;
+
+	/* enable the RF Disable Delay timer */
+	if (D11REV_GE(wlc->pub->corerev, 10))
+		W_REG(wlc->osh, &wlc->regs->rfdisabledly, RFDISABLE_DEFAULT);
+
+	/* initialize mpc delay */
+	wlc->mpc_delay_off = wlc->mpc_dlycnt = WLC_MPC_MIN_DELAYCNT;
+
+	/*
+	 * Initialize WME parameters; if they haven't been set by some other
+	 * mechanism (IOVar, etc) then read them from the hardware.
+	 */
+	if (WLC_WME_RETRY_SHORT_GET(wlc, 0) == 0) {	/* Unintialized; read from HW */
+		int ac;
+
+		ASSERT(wlc->clk);
+		for (ac = 0; ac < AC_COUNT; ac++) {
+			wlc->wme_retries[ac] =
+			    wlc_read_shm(wlc, M_AC_TXLMT_ADDR(ac));
+		}
+	}
+}
+
+void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc)
+{
+	wlc->bcnmisc_monitor = promisc;
+	wlc_mac_bcn_promisc(wlc);
+}
+
+void wlc_mac_bcn_promisc(wlc_info_t * wlc)
+{
+	if ((AP_ENAB(wlc->pub) && (N_ENAB(wlc->pub) || wlc->band->gmode)) ||
+	    wlc->bcnmisc_ibss || wlc->bcnmisc_scan || wlc->bcnmisc_monitor)
+		wlc_mctrl(wlc, MCTL_BCNS_PROMISC, MCTL_BCNS_PROMISC);
+	else
+		wlc_mctrl(wlc, MCTL_BCNS_PROMISC, 0);
+}
+
+/* set or clear maccontrol bits MCTL_PROMISC and MCTL_KEEPCONTROL */
+void wlc_mac_promisc(wlc_info_t * wlc)
+{
+	uint32 promisc_bits = 0;
+
+	/* promiscuous mode just sets MCTL_PROMISC
+	 * Note: APs get all BSS traffic without the need to set the MCTL_PROMISC bit
+	 * since all BSS data traffic is directed at the AP
+	 */
+	if (PROMISC_ENAB(wlc->pub) && !AP_ENAB(wlc->pub) && !wlc->wet)
+		promisc_bits |= MCTL_PROMISC;
+
+	/* monitor mode needs both MCTL_PROMISC and MCTL_KEEPCONTROL
+	 * Note: monitor mode also needs MCTL_BCNS_PROMISC, but that is
+	 * handled in wlc_mac_bcn_promisc()
+	 */
+	if (MONITOR_ENAB(wlc))
+		promisc_bits |= MCTL_PROMISC | MCTL_KEEPCONTROL;
+
+	wlc_mctrl(wlc, MCTL_PROMISC | MCTL_KEEPCONTROL, promisc_bits);
+}
+
+/* check if hps and wake states of sw and hw are in sync */
+bool wlc_ps_check(wlc_info_t * wlc)
+{
+	bool res = TRUE;
+	bool hps, wake;
+	bool wake_ok;
+
+	if (!AP_ACTIVE(wlc)) {
+		volatile uint32 tmp;
+		tmp = R_REG(wlc->osh, &wlc->regs->maccontrol);
+
+		/* If deviceremoved is detected, then don't take any action as this can be called
+		 * in any context. Assume that caller will take care of the condition. This is just
+		 * to avoid assert
+		 */
+		if (tmp == 0xffffffff) {
+			WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit,
+				  __func__));
+			return DEVICEREMOVED(wlc);
+		}
+
+		hps = PS_ALLOWED(wlc);
+
+		if (hps != ((tmp & MCTL_HPS) != 0)) {
+			int idx;
+			wlc_bsscfg_t *cfg;
+			WL_ERROR(("wl%d: hps not sync, sw %d, maccontrol 0x%x\n", wlc->pub->unit, hps, tmp));
+			FOREACH_BSS(wlc, idx, cfg) {
+				if (!BSSCFG_STA(cfg))
+					continue;
+			}
+
+			res = FALSE;
+		}
+#ifdef WLC_LOW
+		/* For a monolithic build the wake check can be exact since it looks at wake
+		 * override bits. The MCTL_WAKE bit should match the 'wake' value.
+		 */
+		wake = STAY_AWAKE(wlc) || wlc->hw->wake_override;
+		wake_ok = (wake == ((tmp & MCTL_WAKE) != 0));
+#else
+		/* For a split build we will not have access to any wake overrides from the low
+		 * level. The check can only make sure the MCTL_WAKE bit is on if the high
+		 * level 'wake' value is true. If the high level 'wake' is false, the MCTL_WAKE
+		 * may be either true or false due to the low level override.
+		 */
+		wake = STAY_AWAKE(wlc);
+		wake_ok = (wake && ((tmp & MCTL_WAKE) != 0)) || !wake;
+#endif
+		if (hps && !wake_ok) {
+			WL_ERROR(("wl%d: wake not sync, sw %d maccontrol 0x%x\n", wlc->pub->unit, wake, tmp));
+			res = FALSE;
+		}
+	}
+	ASSERT(res);
+	return res;
+}
+
+/* push sw hps and wake state through hardware */
+void wlc_set_ps_ctrl(wlc_info_t * wlc)
+{
+	uint32 v1, v2;
+	bool hps, wake;
+	bool awake_before;
+
+	hps = PS_ALLOWED(wlc);
+	wake = hps ? (STAY_AWAKE(wlc)) : TRUE;
+
+	WL_TRACE(("wl%d: wlc_set_ps_ctrl: hps %d wake %d\n", wlc->pub->unit,
+		  hps, wake));
+
+	v1 = R_REG(wlc->osh, &wlc->regs->maccontrol);
+	v2 = 0;
+	if (hps)
+		v2 |= MCTL_HPS;
+	if (wake)
+		v2 |= MCTL_WAKE;
+
+	wlc_mctrl(wlc, MCTL_WAKE | MCTL_HPS, v2);
+
+	awake_before = ((v1 & MCTL_WAKE) || ((v1 & MCTL_HPS) == 0));
+
+	if (wake && !awake_before)
+		wlc_bmac_wait_for_wake(wlc->hw);
+
+}
+
+/*
+ * Write this BSS config's MAC address to core.
+ * Updates RXE match engine.
+ */
+int wlc_set_mac(wlc_bsscfg_t * cfg)
+{
+	int err = 0;
+	wlc_info_t *wlc = cfg->wlc;
+
+	if (cfg == wlc->cfg) {
+		/* enter the MAC addr into the RXE match registers */
+		wlc_set_addrmatch(wlc, RCM_MAC_OFFSET, &cfg->cur_etheraddr);
+	}
+
+	wlc_ampdu_macaddr_upd(wlc);
+
+	return err;
+}
+
+/* Write the BSS config's BSSID address to core (set_bssid in d11procs.tcl).
+ * Updates RXE match engine.
+ */
+void wlc_set_bssid(wlc_bsscfg_t * cfg)
+{
+	wlc_info_t *wlc = cfg->wlc;
+
+	/* if primary config, we need to update BSSID in RXE match registers */
+	if (cfg == wlc->cfg) {
+		wlc_set_addrmatch(wlc, RCM_BSSID_OFFSET, &cfg->BSSID);
+	}
+#ifdef SUPPORT_HWKEYS
+	else if (BSSCFG_STA(cfg) && cfg->BSS) {
+		wlc_rcmta_add_bssid(wlc, cfg);
+	}
+#endif
+}
+
+/*
+ * Suspend the the MAC and update the slot timing
+ * for standard 11b/g (20us slots) or shortslot 11g (9us slots).
+ */
+void wlc_switch_shortslot(wlc_info_t * wlc, bool shortslot)
+{
+	int idx;
+	wlc_bsscfg_t *cfg;
+
+	ASSERT(wlc->band->gmode);
+
+	/* use the override if it is set */
+	if (wlc->shortslot_override != WLC_SHORTSLOT_AUTO)
+		shortslot = (wlc->shortslot_override == WLC_SHORTSLOT_ON);
+
+	if (wlc->shortslot == shortslot)
+		return;
+
+	wlc->shortslot = shortslot;
+
+	/* update the capability based on current shortslot mode */
+	FOREACH_BSS(wlc, idx, cfg) {
+		if (!cfg->associated)
+			continue;
+		cfg->current_bss->capability &= ~DOT11_CAP_SHORTSLOT;
+		if (wlc->shortslot)
+			cfg->current_bss->capability |= DOT11_CAP_SHORTSLOT;
+	}
+
+	wlc_bmac_set_shortslot(wlc->hw, shortslot);
+}
+
+static uint8 wlc_local_constraint_qdbm(wlc_info_t * wlc)
+{
+	uint8 local;
+	int16 local_max;
+
+	local = WLC_TXPWR_MAX;
+	if (wlc->pub->associated &&
+	    (wf_chspec_ctlchan(wlc->chanspec) ==
+	     wf_chspec_ctlchan(wlc->home_chanspec))) {
+
+		/* get the local power constraint if we are on the AP's
+		 * channel [802.11h, 7.3.2.13]
+		 */
+		/* Clamp the value between 0 and WLC_TXPWR_MAX w/o overflowing the target */
+		local_max =
+		    (wlc->txpwr_local_max -
+		     wlc->txpwr_local_constraint) * WLC_TXPWR_DB_FACTOR;
+		if (local_max > 0 && local_max < WLC_TXPWR_MAX)
+			return (uint8) local_max;
+		if (local_max < 0)
+			return 0;
+	}
+
+	return local;
+}
+
+/* propagate home chanspec to all bsscfgs in case bsscfg->current_bss->chanspec is referenced */
+void wlc_set_home_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+{
+	if (wlc->home_chanspec != chanspec) {
+		int idx;
+		wlc_bsscfg_t *cfg;
+
+		wlc->home_chanspec = chanspec;
+
+		FOREACH_BSS(wlc, idx, cfg) {
+			if (!cfg->associated)
+				continue;
+			cfg->target_bss->chanspec = chanspec;
+			cfg->current_bss->chanspec = chanspec;
+		}
+
+	}
+}
+
+static void wlc_set_phy_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+{
+	/* Save our copy of the chanspec */
+	wlc->chanspec = chanspec;
+
+	/* Set the chanspec and power limits for this locale after computing
+	 * any 11h local tx power constraints.
+	 */
+	wlc_channel_set_chanspec(wlc->cmi, chanspec,
+				 wlc_local_constraint_qdbm(wlc));
+
+	if (wlc->stf->ss_algosel_auto)
+		wlc_stf_ss_algo_channel_get(wlc, &wlc->stf->ss_algo_channel,
+					    chanspec);
+
+	wlc_stf_ss_update(wlc, wlc->band);
+
+}
+
+void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec)
+{
+	uint bandunit;
+	bool switchband = FALSE;
+	chanspec_t old_chanspec = wlc->chanspec;
+
+	if (!wlc_valid_chanspec_db(wlc->cmi, chanspec)) {
+		WL_ERROR(("wl%d: %s: Bad channel %d\n",
+			  wlc->pub->unit, __func__, CHSPEC_CHANNEL(chanspec)));
+		ASSERT(wlc_valid_chanspec_db(wlc->cmi, chanspec));
+		return;
+	}
+
+	/* Switch bands if necessary */
+	if (NBANDS(wlc) > 1) {
+		bandunit = CHSPEC_WLCBANDUNIT(chanspec);
+		if (wlc->band->bandunit != bandunit || wlc->bandinit_pending) {
+			switchband = TRUE;
+			if (wlc->bandlocked) {
+				WL_ERROR(("wl%d: %s: chspec %d band is locked!\n", wlc->pub->unit, __func__, CHSPEC_CHANNEL(chanspec)));
+				return;
+			}
+			/* BMAC_NOTE: should the setband call come after the wlc_bmac_chanspec() ?
+			 * if the setband updates (wlc_bsinit) use low level calls to inspect and
+			 * set state, the state inspected may be from the wrong band, or the
+			 * following wlc_bmac_set_chanspec() may undo the work.
+			 */
+			wlc_setband(wlc, bandunit);
+		}
+	}
+
+	ASSERT(N_ENAB(wlc->pub) || !CHSPEC_IS40(chanspec));
+
+	/* sync up phy/radio chanspec */
+	wlc_set_phy_chanspec(wlc, chanspec);
+
+	/* init antenna selection */
+	if (CHSPEC_WLC_BW(old_chanspec) != CHSPEC_WLC_BW(chanspec)) {
+		if (WLANTSEL_ENAB(wlc))
+			wlc_antsel_init(wlc->asi);
+
+		/* Fix the hardware rateset based on bw.
+		 * Mainly add MCS32 for 40Mhz, remove MCS 32 for 20Mhz
+		 */
+		wlc_rateset_bw_mcs_filter(&wlc->band->hw_rateset,
+					  wlc->band->
+					  mimo_cap_40 ? CHSPEC_WLC_BW(chanspec)
+					  : 0);
+	}
+
+	/* update some mac configuration since chanspec changed */
+	wlc_ucode_mac_upd(wlc);
+}
+
+#if defined(BCMDBG)
+static int wlc_get_current_txpwr(wlc_info_t * wlc, void *pwr, uint len)
+{
+	txpwr_limits_t txpwr;
+	tx_power_t power;
+	tx_power_legacy_t *old_power = NULL;
+	int r, c;
+	uint qdbm;
+	bool override;
+
+	if (len == sizeof(tx_power_legacy_t))
+		old_power = (tx_power_legacy_t *) pwr;
+	else if (len < sizeof(tx_power_t))
+		return BCME_BUFTOOSHORT;
+
+	bzero(&power, sizeof(tx_power_t));
+
+	power.chanspec = WLC_BAND_PI_RADIO_CHANSPEC;
+	if (wlc->pub->associated)
+		power.local_chanspec = wlc->home_chanspec;
+
+	/* Return the user target tx power limits for the various rates.  Note  wlc_phy.c's
+	 * public interface only implements getting and setting a single value for all of
+	 * rates, so we need to fill the array ourselves.
+	 */
+	wlc_phy_txpower_get(wlc->band->pi, &qdbm, &override);
+	for (r = 0; r < WL_TX_POWER_RATES; r++) {
+		power.user_limit[r] = (uint8) qdbm;
+	}
+
+	power.local_max = wlc->txpwr_local_max * WLC_TXPWR_DB_FACTOR;
+	power.local_constraint =
+	    wlc->txpwr_local_constraint * WLC_TXPWR_DB_FACTOR;
+
+	power.antgain[0] = wlc->bandstate[BAND_2G_INDEX]->antgain;
+	power.antgain[1] = wlc->bandstate[BAND_5G_INDEX]->antgain;
+
+	wlc_channel_reg_limits(wlc->cmi, power.chanspec, &txpwr);
+
+#if WL_TX_POWER_CCK_NUM != WLC_NUM_RATES_CCK
+#error "WL_TX_POWER_CCK_NUM != WLC_NUM_RATES_CCK"
+#endif
+
+	/* CCK tx power limits */
+	for (c = 0, r = WL_TX_POWER_CCK_FIRST; c < WL_TX_POWER_CCK_NUM;
+	     c++, r++)
+		power.reg_limit[r] = txpwr.cck[c];
+
+#if WL_TX_POWER_OFDM_NUM != WLC_NUM_RATES_OFDM
+#error "WL_TX_POWER_OFDM_NUM != WLC_NUM_RATES_OFDM"
+#endif
+
+	/* 20 MHz OFDM SISO tx power limits */
+	for (c = 0, r = WL_TX_POWER_OFDM_FIRST; c < WL_TX_POWER_OFDM_NUM;
+	     c++, r++)
+		power.reg_limit[r] = txpwr.ofdm[c];
+
+	if (WLC_PHY_11N_CAP(wlc->band)) {
+
+		/* 20 MHz OFDM CDD tx power limits */
+		for (c = 0, r = WL_TX_POWER_OFDM20_CDD_FIRST;
+		     c < WL_TX_POWER_OFDM_NUM; c++, r++)
+			power.reg_limit[r] = txpwr.ofdm_cdd[c];
+
+		/* 40 MHz OFDM SISO tx power limits */
+		for (c = 0, r = WL_TX_POWER_OFDM40_SISO_FIRST;
+		     c < WL_TX_POWER_OFDM_NUM; c++, r++)
+			power.reg_limit[r] = txpwr.ofdm_40_siso[c];
+
+		/* 40 MHz OFDM CDD tx power limits */
+		for (c = 0, r = WL_TX_POWER_OFDM40_CDD_FIRST;
+		     c < WL_TX_POWER_OFDM_NUM; c++, r++)
+			power.reg_limit[r] = txpwr.ofdm_40_cdd[c];
+
+#if WL_TX_POWER_MCS_1_STREAM_NUM != WLC_NUM_RATES_MCS_1_STREAM
+#error "WL_TX_POWER_MCS_1_STREAM_NUM != WLC_NUM_RATES_MCS_1_STREAM"
+#endif
+
+		/* 20MHz MCS0-7 SISO tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS20_SISO_FIRST;
+		     c < WLC_NUM_RATES_MCS_1_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_20_siso[c];
+
+		/* 20MHz MCS0-7 CDD tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS20_CDD_FIRST;
+		     c < WLC_NUM_RATES_MCS_1_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_20_cdd[c];
+
+		/* 20MHz MCS0-7 STBC tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS20_STBC_FIRST;
+		     c < WLC_NUM_RATES_MCS_1_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_20_stbc[c];
+
+		/* 40MHz MCS0-7 SISO tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS40_SISO_FIRST;
+		     c < WLC_NUM_RATES_MCS_1_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_40_siso[c];
+
+		/* 40MHz MCS0-7 CDD tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS40_CDD_FIRST;
+		     c < WLC_NUM_RATES_MCS_1_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_40_cdd[c];
+
+		/* 40MHz MCS0-7 STBC tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS40_STBC_FIRST;
+		     c < WLC_NUM_RATES_MCS_1_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_40_stbc[c];
+
+#if WL_TX_POWER_MCS_2_STREAM_NUM != WLC_NUM_RATES_MCS_2_STREAM
+#error "WL_TX_POWER_MCS_2_STREAM_NUM != WLC_NUM_RATES_MCS_2_STREAM"
+#endif
+
+		/* 20MHz MCS8-15 SDM tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS20_SDM_FIRST;
+		     c < WLC_NUM_RATES_MCS_2_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_20_mimo[c];
+
+		/* 40MHz MCS8-15 SDM tx power limits */
+		for (c = 0, r = WL_TX_POWER_MCS40_SDM_FIRST;
+		     c < WLC_NUM_RATES_MCS_2_STREAM; c++, r++)
+			power.reg_limit[r] = txpwr.mcs_40_mimo[c];
+
+		/* MCS 32 */
+		power.reg_limit[WL_TX_POWER_MCS_32] = txpwr.mcs32;
+	}
+
+	wlc_phy_txpower_get_current(wlc->band->pi, &power,
+				    CHSPEC_CHANNEL(power.chanspec));
+
+	/* copy the tx_power_t struct to the return buffer,
+	 * or convert to a tx_power_legacy_t struct
+	 */
+	if (!old_power) {
+		bcopy(&power, pwr, sizeof(tx_power_t));
+	} else {
+		int band_idx = CHSPEC_IS2G(power.chanspec) ? 0 : 1;
+
+		bzero(old_power, sizeof(tx_power_legacy_t));
+
+		old_power->txpwr_local_max = power.local_max;
+		old_power->txpwr_local_constraint = power.local_constraint;
+		if (CHSPEC_IS2G(power.chanspec)) {
+			old_power->txpwr_chan_reg_max = txpwr.cck[0];
+			old_power->txpwr_est_Pout[band_idx] =
+			    power.est_Pout_cck;
+			old_power->txpwr_est_Pout_gofdm = power.est_Pout[0];
+		} else {
+			old_power->txpwr_chan_reg_max = txpwr.ofdm[0];
+			old_power->txpwr_est_Pout[band_idx] = power.est_Pout[0];
+		}
+		old_power->txpwr_antgain[0] = power.antgain[0];
+		old_power->txpwr_antgain[1] = power.antgain[1];
+
+		for (r = 0; r < NUM_PWRCTRL_RATES; r++) {
+			old_power->txpwr_band_max[r] = power.user_limit[r];
+			old_power->txpwr_limit[r] = power.reg_limit[r];
+			old_power->txpwr_target[band_idx][r] = power.target[r];
+			if (CHSPEC_IS2G(power.chanspec))
+				old_power->txpwr_bphy_cck_max[r] =
+				    power.board_limit[r];
+			else
+				old_power->txpwr_aphy_max[r] =
+				    power.board_limit[r];
+		}
+	}
+
+	return 0;
+}
+#endif				/* defined(BCMDBG) */
+
+static uint32 wlc_watchdog_backup_bi(wlc_info_t * wlc)
+{
+	uint32 bi;
+	bi = 2 * wlc->cfg->current_bss->dtim_period *
+	    wlc->cfg->current_bss->beacon_period;
+	if (wlc->bcn_li_dtim)
+		bi *= wlc->bcn_li_dtim;
+	else if (wlc->bcn_li_bcn)
+		/* recalculate bi based on bcn_li_bcn */
+		bi = 2 * wlc->bcn_li_bcn * wlc->cfg->current_bss->beacon_period;
+
+	if (bi < 2 * TIMER_INTERVAL_WATCHDOG)
+		bi = 2 * TIMER_INTERVAL_WATCHDOG;
+	return bi;
+}
+
+/* Change to run the watchdog either from a periodic timer or from tbtt handler.
+ * Call watchdog from tbtt handler if tbtt is TRUE, watchdog timer otherwise.
+ */
+void wlc_watchdog_upd(wlc_info_t * wlc, bool tbtt)
+{
+	/* make sure changing watchdog driver is allowed */
+	if (!wlc->pub->up || !wlc->pub->align_wd_tbtt)
+		return;
+	if (!tbtt && wlc->WDarmed) {
+		wl_del_timer(wlc->wl, wlc->wdtimer);
+		wlc->WDarmed = FALSE;
+	}
+
+	/* stop watchdog timer and use tbtt interrupt to drive watchdog */
+	if (tbtt && wlc->WDarmed) {
+		wl_del_timer(wlc->wl, wlc->wdtimer);
+		wlc->WDarmed = FALSE;
+		wlc->WDlast = OSL_SYSUPTIME();
+	}
+	/* arm watchdog timer and drive the watchdog there */
+	else if (!tbtt && !wlc->WDarmed) {
+		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG,
+			     TRUE);
+		wlc->WDarmed = TRUE;
+	}
+	if (tbtt && !wlc->WDarmed) {
+		wl_add_timer(wlc->wl, wlc->wdtimer, wlc_watchdog_backup_bi(wlc),
+			     TRUE);
+		wlc->WDarmed = TRUE;
+	}
+}
+
+ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs)
+{
+	ratespec_t lowest_basic_rspec;
+	uint i;
+
+	/* Use the lowest basic rate */
+	lowest_basic_rspec = rs->rates[0] & RATE_MASK;
+	for (i = 0; i < rs->count; i++) {
+		if (rs->rates[i] & WLC_RATE_FLAG) {
+			lowest_basic_rspec = rs->rates[i] & RATE_MASK;
+			break;
+		}
+	}
+#if NCONF
+	/* pick siso/cdd as default for OFDM (note no basic rate MCSs are supported yet) */
+	if (IS_OFDM(lowest_basic_rspec)) {
+		lowest_basic_rspec |= (wlc->stf->ss_opmode << RSPEC_STF_SHIFT);
+	}
+#endif
+
+	return (lowest_basic_rspec);
+}
+
+/* This function changes the phytxctl for beacon based on current beacon ratespec AND txant
+ * setting as per this table:
+ *  ratespec     CCK		ant = wlc->stf->txant
+ *  		OFDM		ant = 3
+ */
+void wlc_beacon_phytxctl_txant_upd(wlc_info_t * wlc, ratespec_t bcn_rspec)
+{
+	uint16 phyctl;
+	uint16 phytxant = wlc->stf->phytxant;
+	uint16 mask = PHY_TXC_ANT_MASK;
+
+	/* for non-siso rates or default setting, use the available chains */
+	if (WLC_PHY_11N_CAP(wlc->band)) {
+		phytxant = wlc_stf_phytxchain_sel(wlc, bcn_rspec);
+	}
+
+	phyctl = wlc_read_shm(wlc, M_BCN_PCTLWD);
+	phyctl = (phyctl & ~mask) | phytxant;
+	wlc_write_shm(wlc, M_BCN_PCTLWD, phyctl);
+}
+
+/* centralized protection config change function to simplify debugging, no consistency checking
+ * this should be called only on changes to avoid overhead in periodic function
+*/
+void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val)
+{
+	WL_TRACE(("wlc_protection_upd: idx %d, val %d\n", idx, val));
+
+	switch (idx) {
+	case WLC_PROT_G_SPEC:
+		wlc->protection->_g = (bool) val;
+		break;
+	case WLC_PROT_G_OVR:
+		wlc->protection->g_override = (int8) val;
+		break;
+	case WLC_PROT_G_USER:
+		wlc->protection->gmode_user = (uint8) val;
+		break;
+	case WLC_PROT_OVERLAP:
+		wlc->protection->overlap = (int8) val;
+		break;
+	case WLC_PROT_N_USER:
+		wlc->protection->nmode_user = (int8) val;
+		break;
+	case WLC_PROT_N_CFG:
+		wlc->protection->n_cfg = (int8) val;
+		break;
+	case WLC_PROT_N_CFG_OVR:
+		wlc->protection->n_cfg_override = (int8) val;
+		break;
+	case WLC_PROT_N_NONGF:
+		wlc->protection->nongf = (bool) val;
+		break;
+	case WLC_PROT_N_NONGF_OVR:
+		wlc->protection->nongf_override = (int8) val;
+		break;
+	case WLC_PROT_N_PAM_OVR:
+		wlc->protection->n_pam_override = (int8) val;
+		break;
+	case WLC_PROT_N_OBSS:
+		wlc->protection->n_obss = (bool) val;
+		break;
+
+	default:
+		ASSERT(0);
+		break;
+	}
+
+}
+
+static void wlc_ht_update_sgi_rx(wlc_info_t * wlc, int val)
+{
+	wlc->ht_cap.cap &= ~(HT_CAP_SHORT_GI_20 | HT_CAP_SHORT_GI_40);
+	wlc->ht_cap.cap |= (val & WLC_N_SGI_20) ? HT_CAP_SHORT_GI_20 : 0;
+	wlc->ht_cap.cap |= (val & WLC_N_SGI_40) ? HT_CAP_SHORT_GI_40 : 0;
+
+	if (wlc->pub->up) {
+		wlc_update_beacon(wlc);
+		wlc_update_probe_resp(wlc, TRUE);
+	}
+}
+
+static void wlc_ht_update_ldpc(wlc_info_t * wlc, int8 val)
+{
+	wlc->stf->ldpc = val;
+
+	wlc->ht_cap.cap &= ~HT_CAP_LDPC_CODING;
+	if (wlc->stf->ldpc != OFF)
+		wlc->ht_cap.cap |= HT_CAP_LDPC_CODING;
+
+	if (wlc->pub->up) {
+		wlc_update_beacon(wlc);
+		wlc_update_probe_resp(wlc, TRUE);
+		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? TRUE : FALSE));
+	}
+}
+
+/*
+ * ucode, hwmac update
+ *    Channel dependent updates for ucode and hw
+ */
+static void wlc_ucode_mac_upd(wlc_info_t * wlc)
+{
+	/* enable or disable any active IBSSs depending on whether or not
+	 * we are on the home channel
+	 */
+	if (wlc->home_chanspec == WLC_BAND_PI_RADIO_CHANSPEC) {
+		if (wlc->pub->associated) {
+			/* BMAC_NOTE: This is something that should be fixed in ucode inits.
+			 * I think that the ucode inits set up the bcn templates and shm values
+			 * with a bogus beacon. This should not be done in the inits. If ucode needs
+			 * to set up a beacon for testing, the test routines should write it down,
+			 * not expect the inits to populate a bogus beacon.
+			 */
+			if (WLC_PHY_11N_CAP(wlc->band)) {
+				wlc_write_shm(wlc, M_BCN_TXTSF_OFFSET,
+					      wlc->band->bcntsfoff);
+			}
+		}
+	} else {
+		/* disable an active IBSS if we are not on the home channel */
+	}
+
+	/* update the various promisc bits */
+	wlc_mac_bcn_promisc(wlc);
+	wlc_mac_promisc(wlc);
+}
+
+static void wlc_bandinit_ordered(wlc_info_t * wlc, chanspec_t chanspec)
+{
+	wlc_rateset_t default_rateset;
+	uint parkband;
+	uint i, band_order[2];
+
+	WL_TRACE(("wl%d: wlc_bandinit_ordered\n", wlc->pub->unit));
+	/*
+	 * We might have been bandlocked during down and the chip power-cycled (hibernate).
+	 * figure out the right band to park on
+	 */
+	if (wlc->bandlocked || NBANDS(wlc) == 1) {
+		ASSERT(CHSPEC_WLCBANDUNIT(chanspec) == wlc->band->bandunit);
+
+		parkband = wlc->band->bandunit;	/* updated in wlc_bandlock() */
+		band_order[0] = band_order[1] = parkband;
+	} else {
+		/* park on the band of the specified chanspec */
+		parkband = CHSPEC_WLCBANDUNIT(chanspec);
+
+		/* order so that parkband initialize last */
+		band_order[0] = parkband ^ 1;
+		band_order[1] = parkband;
+	}
+
+	/* make each band operational, software state init */
+	for (i = 0; i < NBANDS(wlc); i++) {
+		uint j = band_order[i];
+
+		wlc->band = wlc->bandstate[j];
+
+		wlc_default_rateset(wlc, &default_rateset);
+
+		/* fill in hw_rate */
+		wlc_rateset_filter(&default_rateset, &wlc->band->hw_rateset,
+				   FALSE, WLC_RATES_CCK_OFDM, RATE_MASK,
+				   (bool) N_ENAB(wlc->pub));
+
+		/* init basic rate lookup */
+		wlc_rate_lookup_init(wlc, &default_rateset);
+	}
+
+	/* sync up phy/radio chanspec */
+	wlc_set_phy_chanspec(wlc, chanspec);
+}
+
+/* band-specific init */
+static void WLBANDINITFN(wlc_bsinit) (wlc_info_t * wlc) {
+	WL_TRACE(("wl%d: wlc_bsinit: bandunit %d\n", wlc->pub->unit,
+		  wlc->band->bandunit));
+
+	/* write ucode ACK/CTS rate table */
+	wlc_set_ratetable(wlc);
+
+	/* update some band specific mac configuration */
+	wlc_ucode_mac_upd(wlc);
+
+	/* init antenna selection */
+	if (WLANTSEL_ENAB(wlc))
+		wlc_antsel_init(wlc->asi);
+
+}
+
+/* switch to and initialize new band */
+static void WLBANDINITFN(wlc_setband) (wlc_info_t * wlc, uint bandunit) {
+	int idx;
+	wlc_bsscfg_t *cfg;
+
+	ASSERT(NBANDS(wlc) > 1);
+	ASSERT(!wlc->bandlocked);
+	ASSERT(bandunit != wlc->band->bandunit || wlc->bandinit_pending);
+
+	wlc->band = wlc->bandstate[bandunit];
+
+	if (!wlc->pub->up)
+		return;
+
+	/* wait for at least one beacon before entering sleeping state */
+	wlc->PMawakebcn = TRUE;
+	FOREACH_AS_STA(wlc, idx, cfg)
+	    cfg->PMawakebcn = TRUE;
+	wlc_set_ps_ctrl(wlc);
+
+	/* band-specific initializations */
+	wlc_bsinit(wlc);
+}
+
+/* Initialize a WME Parameter Info Element with default STA parameters from WMM Spec, Table 12 */
+void wlc_wme_initparams_sta(wlc_info_t * wlc, wme_param_ie_t * pe)
+{
+	static const wme_param_ie_t stadef = {
+		WME_OUI,
+		WME_TYPE,
+		WME_SUBTYPE_PARAM_IE,
+		WME_VER,
+		0,
+		0,
+		{
+		 {EDCF_AC_BE_ACI_STA, EDCF_AC_BE_ECW_STA,
+		  HTOL16(EDCF_AC_BE_TXOP_STA)},
+		 {EDCF_AC_BK_ACI_STA, EDCF_AC_BK_ECW_STA,
+		  HTOL16(EDCF_AC_BK_TXOP_STA)},
+		 {EDCF_AC_VI_ACI_STA, EDCF_AC_VI_ECW_STA,
+		  HTOL16(EDCF_AC_VI_TXOP_STA)},
+		 {EDCF_AC_VO_ACI_STA, EDCF_AC_VO_ECW_STA,
+		  HTOL16(EDCF_AC_VO_TXOP_STA)}
+		 }
+	};
+
+	ASSERT(sizeof(*pe) == WME_PARAM_IE_LEN);
+	memcpy(pe, &stadef, sizeof(*pe));
+}
+
+void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg, bool suspend)
+{
+	int i;
+	shm_acparams_t acp_shm;
+	uint16 *shm_entry;
+	struct ieee80211_tx_queue_params *params = arg;
+
+	ASSERT(wlc);
+
+	/* Only apply params if the core is out of reset and has clocks */
+	if (!wlc->clk) {
+		WL_ERROR(("wl%d: %s : no-clock\n", wlc->pub->unit, __func__));
+		return;
+	}
+
+	/*
+	 * AP uses AC params from wme_param_ie_ap.
+	 * AP advertises AC params from wme_param_ie.
+	 * STA uses AC params from wme_param_ie.
+	 */
+
+	wlc->wme_admctl = 0;
+
+	do {
+		bzero((char *)&acp_shm, sizeof(shm_acparams_t));
+		/* find out which ac this set of params applies to */
+		ASSERT(aci < AC_COUNT);
+		/* set the admission control policy for this AC */
+		/* wlc->wme_admctl |= 1 << aci; *//* should be set ??  seems like off by default */
+
+		/* fill in shm ac params struct */
+		acp_shm.txop = ltoh16(params->txop);
+		/* convert from units of 32us to us for ucode */
+		wlc->edcf_txop[aci & 0x3] = acp_shm.txop =
+		    EDCF_TXOP2USEC(acp_shm.txop);
+		acp_shm.aifs = (params->aifs & EDCF_AIFSN_MASK);
+
+		if (aci == AC_VI && acp_shm.txop == 0
+		    && acp_shm.aifs < EDCF_AIFSN_MAX)
+			acp_shm.aifs++;
+
+		if (acp_shm.aifs < EDCF_AIFSN_MIN
+		    || acp_shm.aifs > EDCF_AIFSN_MAX) {
+			WL_ERROR(("wl%d: wlc_edcf_setparams: bad aifs %d\n",
+				  wlc->pub->unit, acp_shm.aifs));
+			continue;
+		}
+
+		acp_shm.cwmin = params->cw_min;
+		acp_shm.cwmax = params->cw_max;
+		acp_shm.cwcur = acp_shm.cwmin;
+		acp_shm.bslots =
+		    R_REG(wlc->osh, &wlc->regs->tsf_random) & acp_shm.cwcur;
+		acp_shm.reggap = acp_shm.bslots + acp_shm.aifs;
+		/* Indicate the new params to the ucode */
+		acp_shm.status = wlc_read_shm(wlc, (M_EDCF_QINFO +
+						    wme_shmemacindex(aci) *
+						    M_EDCF_QLEN +
+						    M_EDCF_STATUS_OFF));
+		acp_shm.status |= WME_STATUS_NEWAC;
+
+		/* Fill in shm acparam table */
+		shm_entry = (uint16 *) & acp_shm;
+		for (i = 0; i < (int)sizeof(shm_acparams_t); i += 2)
+			wlc_write_shm(wlc,
+				      M_EDCF_QINFO +
+				      wme_shmemacindex(aci) * M_EDCF_QLEN + i,
+				      *shm_entry++);
+
+	} while (0);
+
+	if (suspend)
+		wlc_suspend_mac_and_wait(wlc);
+
+	if (suspend)
+		wlc_enable_mac(wlc);
+
+}
+
+void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend)
+{
+	wlc_info_t *wlc = cfg->wlc;
+	uint aci, i, j;
+	edcf_acparam_t *edcf_acp;
+	shm_acparams_t acp_shm;
+	uint16 *shm_entry;
+
+	ASSERT(cfg);
+	ASSERT(wlc);
+
+	/* Only apply params if the core is out of reset and has clocks */
+	if (!wlc->clk)
+		return;
+
+	/*
+	 * AP uses AC params from wme_param_ie_ap.
+	 * AP advertises AC params from wme_param_ie.
+	 * STA uses AC params from wme_param_ie.
+	 */
+
+	edcf_acp = (edcf_acparam_t *) & wlc->wme_param_ie.acparam[0];
+
+	wlc->wme_admctl = 0;
+
+	for (i = 0; i < AC_COUNT; i++, edcf_acp++) {
+		bzero((char *)&acp_shm, sizeof(shm_acparams_t));
+		/* find out which ac this set of params applies to */
+		aci = (edcf_acp->ACI & EDCF_ACI_MASK) >> EDCF_ACI_SHIFT;
+		ASSERT(aci < AC_COUNT);
+		/* set the admission control policy for this AC */
+		if (edcf_acp->ACI & EDCF_ACM_MASK) {
+			wlc->wme_admctl |= 1 << aci;
+		}
+
+		/* fill in shm ac params struct */
+		acp_shm.txop = ltoh16(edcf_acp->TXOP);
+		/* convert from units of 32us to us for ucode */
+		wlc->edcf_txop[aci] = acp_shm.txop =
+		    EDCF_TXOP2USEC(acp_shm.txop);
+		acp_shm.aifs = (edcf_acp->ACI & EDCF_AIFSN_MASK);
+
+		if (aci == AC_VI && acp_shm.txop == 0
+		    && acp_shm.aifs < EDCF_AIFSN_MAX)
+			acp_shm.aifs++;
+
+		if (acp_shm.aifs < EDCF_AIFSN_MIN
+		    || acp_shm.aifs > EDCF_AIFSN_MAX) {
+			WL_ERROR(("wl%d: wlc_edcf_setparams: bad aifs %d\n",
+				  wlc->pub->unit, acp_shm.aifs));
+			continue;
+		}
+
+		/* CWmin = 2^(ECWmin) - 1 */
+		acp_shm.cwmin = EDCF_ECW2CW(edcf_acp->ECW & EDCF_ECWMIN_MASK);
+		/* CWmax = 2^(ECWmax) - 1 */
+		acp_shm.cwmax = EDCF_ECW2CW((edcf_acp->ECW & EDCF_ECWMAX_MASK)
+					    >> EDCF_ECWMAX_SHIFT);
+		acp_shm.cwcur = acp_shm.cwmin;
+		acp_shm.bslots =
+		    R_REG(wlc->osh, &wlc->regs->tsf_random) & acp_shm.cwcur;
+		acp_shm.reggap = acp_shm.bslots + acp_shm.aifs;
+		/* Indicate the new params to the ucode */
+		acp_shm.status = wlc_read_shm(wlc, (M_EDCF_QINFO +
+						    wme_shmemacindex(aci) *
+						    M_EDCF_QLEN +
+						    M_EDCF_STATUS_OFF));
+		acp_shm.status |= WME_STATUS_NEWAC;
+
+		/* Fill in shm acparam table */
+		shm_entry = (uint16 *) & acp_shm;
+		for (j = 0; j < (int)sizeof(shm_acparams_t); j += 2)
+			wlc_write_shm(wlc,
+				      M_EDCF_QINFO +
+				      wme_shmemacindex(aci) * M_EDCF_QLEN + j,
+				      *shm_entry++);
+	}
+
+	if (suspend)
+		wlc_suspend_mac_and_wait(wlc);
+
+	if (AP_ENAB(wlc->pub) && WME_ENAB(wlc->pub)) {
+		wlc_update_beacon(wlc);
+		wlc_update_probe_resp(wlc, FALSE);
+	}
+
+	if (suspend)
+		wlc_enable_mac(wlc);
+
+}
+
+bool BCMATTACHFN(wlc_timers_init) (wlc_info_t * wlc, int unit) {
+	if (!
+	    (wlc->wdtimer =
+	     wl_init_timer(wlc->wl, wlc_watchdog_by_timer, wlc, "watchdog"))) {
+		WL_ERROR(("wl%d:  wl_init_timer for wdtimer failed\n", unit));
+		goto fail;
+	}
+
+	if (!
+	    (wlc->radio_timer =
+	     wl_init_timer(wlc->wl, wlc_radio_timer, wlc, "radio"))) {
+		WL_ERROR(("wl%d:  wl_init_timer for radio_timer failed\n",
+			  unit));
+		goto fail;
+	}
+
+	return TRUE;
+
+ fail:
+	return FALSE;
+}
+
+/*
+ * Initialize wlc_info default values ...
+ * may get overrides later in this function
+ */
+void BCMATTACHFN(wlc_info_init) (wlc_info_t * wlc, int unit) {
+	int i;
+	/* Assume the device is there until proven otherwise */
+	wlc->device_present = TRUE;
+
+	/* set default power output percentage to 100 percent */
+	wlc->txpwr_percent = 100;
+
+	/* Save our copy of the chanspec */
+	wlc->chanspec = CH20MHZ_CHSPEC(1);
+
+	/* initialize CCK preamble mode to unassociated state */
+	wlc->shortpreamble = FALSE;
+
+	wlc->legacy_probe = TRUE;
+
+	/* various 802.11g modes */
+	wlc->shortslot = FALSE;
+	wlc->shortslot_override = WLC_SHORTSLOT_AUTO;
+
+	wlc->barker_overlap_control = TRUE;
+	wlc->barker_preamble = WLC_BARKER_SHORT_ALLOWED;
+	wlc->txburst_limit_override = AUTO;
+
+	wlc_protection_upd(wlc, WLC_PROT_G_OVR, WLC_PROTECTION_AUTO);
+	wlc_protection_upd(wlc, WLC_PROT_G_SPEC, FALSE);
+
+	wlc_protection_upd(wlc, WLC_PROT_N_CFG_OVR, WLC_PROTECTION_AUTO);
+	wlc_protection_upd(wlc, WLC_PROT_N_CFG, WLC_N_PROTECTION_OFF);
+	wlc_protection_upd(wlc, WLC_PROT_N_NONGF_OVR, WLC_PROTECTION_AUTO);
+	wlc_protection_upd(wlc, WLC_PROT_N_NONGF, FALSE);
+	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR, AUTO);
+
+	wlc_protection_upd(wlc, WLC_PROT_OVERLAP, WLC_PROTECTION_CTL_OVERLAP);
+
+	/* 802.11g draft 4.0 NonERP elt advertisement */
+	wlc->include_legacy_erp = TRUE;
+
+	wlc->stf->ant_rx_ovr = ANT_RX_DIV_DEF;
+	wlc->stf->txant = ANT_TX_DEF;
+
+	wlc->prb_resp_timeout = WLC_PRB_RESP_TIMEOUT;
+
+	wlc->usr_fragthresh = DOT11_DEFAULT_FRAG_LEN;
+	for (i = 0; i < NFIFO; i++)
+		wlc->fragthresh[i] = DOT11_DEFAULT_FRAG_LEN;
+	wlc->RTSThresh = DOT11_DEFAULT_RTS_LEN;
+
+	/* default rate fallback retry limits */
+	wlc->SFBL = RETRY_SHORT_FB;
+	wlc->LFBL = RETRY_LONG_FB;
+
+	/* default mac retry limits */
+	wlc->SRL = RETRY_SHORT_DEF;
+	wlc->LRL = RETRY_LONG_DEF;
+
+	/* init PM state */
+	wlc->PM = PM_OFF;	/* User's setting of PM mode through IOCTL */
+	wlc->PM_override = FALSE;	/* Prevents from going to PM if our AP is 'ill' */
+	wlc->PMenabled = FALSE;	/* Current PM state */
+	wlc->PMpending = FALSE;	/* Tracks whether STA indicated PM in the last attempt */
+	wlc->PMblocked = FALSE;	/* To allow blocking going into PM during RM and scans */
+
+	/* In WMM Auto mode, PM is allowed if association is a UAPSD association */
+	wlc->WME_PM_blocked = FALSE;
+
+	/* Init wme queuing method */
+	wlc->wme_prec_queuing = FALSE;
+
+	/* Overrides for the core to stay awake under zillion conditions Look for STAY_AWAKE */
+	wlc->wake = FALSE;
+	/* Are we waiting for a response to PS-Poll that we sent */
+	wlc->PSpoll = FALSE;
+
+	/* APSD defaults */
+	wlc->wme_apsd = TRUE;
+	wlc->apsd_sta_usp = FALSE;
+	wlc->apsd_trigger_timeout = 0;	/* disable the trigger timer */
+	wlc->apsd_trigger_ac = AC_BITMAP_ALL;
+
+	/* Set flag to indicate that hw keys should be used when available. */
+	wlc->wsec_swkeys = FALSE;
+
+	/* init the 4 static WEP default keys */
+	for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
+		wlc->wsec_keys[i] = wlc->wsec_def_keys[i];
+		wlc->wsec_keys[i]->idx = (uint8) i;
+	}
+
+	wlc->_regulatory_domain = FALSE;	/* 802.11d */
+
+	/* WME QoS mode is Auto by default */
+	wlc->pub->_wme = AUTO;
+
+#ifdef BCMSDIODEV_ENABLED
+	wlc->pub->_priofc = TRUE;	/* enable priority flow control for sdio dongle */
+#endif
+
+	wlc->pub->_ampdu = AMPDU_AGG_HOST;
+	wlc->pub->bcmerror = 0;
+	wlc->ibss_allowed = TRUE;
+	wlc->ibss_coalesce_allowed = TRUE;
+	wlc->pub->_coex = ON;
+
+	/* intialize mpc delay */
+	wlc->mpc_delay_off = wlc->mpc_dlycnt = WLC_MPC_MIN_DELAYCNT;
+
+	wlc->pr80838_war = TRUE;
+}
+
+static bool wlc_state_bmac_sync(wlc_info_t * wlc)
+{
+	wlc_bmac_state_t state_bmac;
+
+	if (wlc_bmac_state_get(wlc->hw, &state_bmac) != 0)
+		return FALSE;
+
+	wlc->machwcap = state_bmac.machwcap;
+	wlc_protection_upd(wlc, WLC_PROT_N_PAM_OVR,
+			   (int8) state_bmac.preamble_ovr);
+
+	return TRUE;
+}
+
+static uint BCMATTACHFN(wlc_attach_module) (wlc_info_t * wlc) {
+	uint err = 0;
+	uint unit;
+	unit = wlc->pub->unit;
+
+	if ((wlc->asi =
+	     wlc_antsel_attach(wlc, wlc->osh, wlc->pub, wlc->hw)) == NULL) {
+		WL_ERROR(("wl%d: wlc_attach: wlc_antsel_attach failed\n",
+			  unit));
+		err = 44;
+		goto fail;
+	}
+
+	if ((wlc->ampdu = wlc_ampdu_attach(wlc)) == NULL) {
+		WL_ERROR(("wl%d: wlc_attach: wlc_ampdu_attach failed\n", unit));
+		err = 50;
+		goto fail;
+	}
+
+	/* Initialize event queue; needed before following calls */
+	wlc->eventq =
+	    wlc_eventq_attach(wlc->pub, wlc, wlc->wl, wlc_process_eventq);
+	if (wlc->eventq == NULL) {
+		WL_ERROR(("wl%d: wlc_attach: wlc_eventq_attachfailed\n", unit));
+		err = 57;
+		goto fail;
+	}
+
+	if ((wlc_stf_attach(wlc) != 0)) {
+		WL_ERROR(("wl%d: wlc_attach: wlc_stf_attach failed\n", unit));
+		err = 68;
+		goto fail;
+	}
+ fail:
+	return err;
+}
+
+wlc_pub_t *wlc_pub(void *wlc)
+{
+	return ((wlc_info_t *) wlc)->pub;
+}
+
+#define CHIP_SUPPORTS_11N(wlc) 	1
+
+/*
+ * The common driver entry routine. Error codes should be unique
+ */
+void *BCMATTACHFN(wlc_attach) (void *wl, uint16 vendor, uint16 device,
+			       uint unit, bool piomode, osl_t * osh,
+			       void *regsva, uint bustype, void *btparam,
+			       uint * perr) {
+	wlc_info_t *wlc;
+	uint err = 0;
+	uint j;
+	wlc_pub_t *pub;
+	wlc_txq_info_t *qi;
+	uint n_disabled;
+
+	WL_NONE(("wl%d: %s: vendor 0x%x device 0x%x\n", unit, __func__, vendor,
+		 device));
+
+	ASSERT(WSEC_MAX_RCMTA_KEYS <= WSEC_MAX_KEYS);
+	ASSERT(WSEC_MAX_DEFAULT_KEYS == WLC_DEFAULT_KEYS);
+
+	/* some code depends on packed structures */
+	ASSERT(sizeof(struct ether_addr) == ETHER_ADDR_LEN);
+	ASSERT(sizeof(struct ether_header) == ETHER_HDR_LEN);
+	ASSERT(sizeof(d11regs_t) == SI_CORE_SIZE);
+	ASSERT(sizeof(ofdm_phy_hdr_t) == D11_PHY_HDR_LEN);
+	ASSERT(sizeof(cck_phy_hdr_t) == D11_PHY_HDR_LEN);
+	ASSERT(sizeof(d11txh_t) == D11_TXH_LEN);
+	ASSERT(sizeof(d11rxhdr_t) == RXHDR_LEN);
+	ASSERT(sizeof(struct dot11_llc_snap_header) == DOT11_LLC_SNAP_HDR_LEN);
+	ASSERT(sizeof(struct dot11_header) == DOT11_A4_HDR_LEN);
+	ASSERT(sizeof(struct dot11_rts_frame) == DOT11_RTS_LEN);
+	ASSERT(sizeof(struct dot11_cts_frame) == DOT11_CTS_LEN);
+	ASSERT(sizeof(struct dot11_ack_frame) == DOT11_ACK_LEN);
+	ASSERT(sizeof(struct dot11_ps_poll_frame) == DOT11_PS_POLL_LEN);
+	ASSERT(sizeof(struct dot11_cf_end_frame) == DOT11_CS_END_LEN);
+	ASSERT(sizeof(struct dot11_management_header) == DOT11_MGMT_HDR_LEN);
+	ASSERT(sizeof(struct dot11_auth) == DOT11_AUTH_FIXED_LEN);
+	ASSERT(sizeof(struct dot11_bcn_prb) == DOT11_BCN_PRB_LEN);
+	ASSERT(sizeof(tx_status_t) == TXSTATUS_LEN);
+	ASSERT(sizeof(ht_add_ie_t) == HT_ADD_IE_LEN);
+	ASSERT(sizeof(ht_cap_ie_t) == HT_CAP_IE_LEN);
+	ASSERT(OFFSETOF(wl_scan_params_t, channel_list) ==
+	       WL_SCAN_PARAMS_FIXED_SIZE);
+	ASSERT(TKIP_MIC_SIZE == (2 * sizeof(uint32)));
+	ASSERT(ISALIGNED(OFFSETOF(wsec_key_t, data), sizeof(uint32)));
+	ASSERT(ISPOWEROF2(MA_WINDOW_SZ));
+
+	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);
+
+	/*
+	 * Number of replay counters value used in WPA IE must match # rxivs
+	 * supported in wsec_key_t struct. See 802.11i/D3.0 sect. 7.3.2.17
+	 * 'RSN Information Element' figure 8 for this mapping.
+	 */
+	ASSERT((WPA_CAP_16_REPLAY_CNTRS == WLC_REPLAY_CNTRS_VALUE
+		&& 16 == WLC_NUMRXIVS)
+	       || (WPA_CAP_4_REPLAY_CNTRS == WLC_REPLAY_CNTRS_VALUE
+		   && 4 == WLC_NUMRXIVS));
+
+	/* allocate wlc_info_t state and its substructures */
+	if ((wlc =
+	     (wlc_info_t *) wlc_attach_malloc(osh, unit, &err, device)) == NULL)
+		goto fail;
+	wlc->osh = osh;
+	pub = wlc->pub;
+
+#if defined(BCMDBG)
+	wlc_info_dbg = wlc;
+#endif
+
+	wlc->band = wlc->bandstate[0];
+	wlc->core = wlc->corestate;
+	wlc->wl = wl;
+	pub->unit = unit;
+	pub->osh = osh;
+	wlc->btparam = btparam;
+	pub->_piomode = piomode;
+	wlc->bandinit_pending = FALSE;
+	/* By default restrict TKIP associations from 11n STA's */
+	wlc->ht_wsec_restriction = WLC_HT_TKIP_RESTRICT;
+
+	/* populate wlc_info_t with default values  */
+	wlc_info_init(wlc, unit);
+
+	/* update sta/ap related parameters */
+	wlc_ap_upd(wlc);
+
+	/* 11n_disable nvram */
+	n_disabled = getintvar(pub->vars, "11n_disable");
+
+	/* register a module (to handle iovars) */
+	wlc_module_register(wlc->pub, wlc_iovars, "wlc_iovars", wlc,
+			    wlc_doiovar, NULL, NULL);
+
+	/* low level attach steps(all hw accesses go inside, no more in rest of the attach) */
+	err = wlc_bmac_attach(wlc, vendor, device, unit, piomode, osh, regsva,
+			      bustype, btparam);
+	if (err)
+		goto fail;
+
+	/* for some states, due to different info pointer(e,g, wlc, wlc_hw) or master/slave split,
+	 * HIGH driver(both monolithic and HIGH_ONLY) needs to sync states FROM BMAC portion driver
+	 */
+	if (!wlc_state_bmac_sync(wlc)) {
+		err = 20;
+		goto fail;
+	}
+
+	pub->phy_11ncapable = WLC_PHY_11N_CAP(wlc->band);
+
+	/* propagate *vars* from BMAC driver to high driver */
+	wlc_bmac_copyfrom_vars(wlc->hw, &pub->vars, &wlc->vars_size);
+
+#ifdef WLC_HIGH_ONLY
+	WL_TRACE(("nvram : vars %p , vars_size %d\n", pub->vars,
+		  wlc->vars_size));
+#endif
+
+	/* set maximum allowed duty cycle */
+	wlc->tx_duty_cycle_ofdm =
+	    (uint16) getintvar(pub->vars, "tx_duty_cycle_ofdm");
+	wlc->tx_duty_cycle_cck =
+	    (uint16) getintvar(pub->vars, "tx_duty_cycle_cck");
+
+	wlc_stf_phy_chain_calc(wlc);
+
+	/* txchain 1: txant 0, txchain 2: txant 1 */
+	if (WLCISNPHY(wlc->band) && (wlc->stf->txstreams == 1))
+		wlc->stf->txant = wlc->stf->hw_txchain - 1;
+
+	/* push to BMAC driver */
+	wlc_phy_stf_chain_init(wlc->band->pi, wlc->stf->hw_txchain,
+			       wlc->stf->hw_rxchain);
+
+#ifdef WLC_LOW
+	/* pull up some info resulting from the low attach */
+	{
+		int i;
+		for (i = 0; i < NFIFO; i++)
+			wlc->core->txavail[i] = wlc->hw->txavail[i];
+	}
+#endif				/* WLC_LOW */
+
+	wlc_bmac_hw_etheraddr(wlc->hw, &wlc->perm_etheraddr);
+
+	bcopy((char *)&wlc->perm_etheraddr, (char *)&pub->cur_etheraddr,
+	      ETHER_ADDR_LEN);
+
+	for (j = 0; j < NBANDS(wlc); j++) {
+		/* Use band 1 for single band 11a */
+		if (IS_SINGLEBAND_5G(wlc->deviceid))
+			j = BAND_5G_INDEX;
+
+		wlc->band = wlc->bandstate[j];
+
+		if (!wlc_attach_stf_ant_init(wlc)) {
+			err = 24;
+			goto fail;
+		}
+
+		/* default contention windows size limits */
+		wlc->band->CWmin = APHY_CWMIN;
+		wlc->band->CWmax = PHY_CWMAX;
+
+		/* init gmode value */
+		if (BAND_2G(wlc->band->bandtype)) {
+			wlc->band->gmode = GMODE_AUTO;
+			wlc_protection_upd(wlc, WLC_PROT_G_USER,
+					   wlc->band->gmode);
+		}
+
+		/* init _n_enab supported mode */
+		if (WLC_PHY_11N_CAP(wlc->band) && CHIP_SUPPORTS_11N(wlc)) {
+			if (n_disabled & WLFEATURE_DISABLE_11N) {
+				pub->_n_enab = OFF;
+				wlc_protection_upd(wlc, WLC_PROT_N_USER, OFF);
+			} else {
+				pub->_n_enab = SUPPORT_11N;
+				wlc_protection_upd(wlc, WLC_PROT_N_USER,
+						   ((pub->_n_enab ==
+						     SUPPORT_11N) ? WL_11N_2x2 :
+						    WL_11N_3x3));
+			}
+		}
+
+		/* init per-band default rateset, depend on band->gmode */
+		wlc_default_rateset(wlc, &wlc->band->defrateset);
+
+		/* fill in hw_rateset (used early by WLC_SET_RATESET) */
+		wlc_rateset_filter(&wlc->band->defrateset,
+				   &wlc->band->hw_rateset, FALSE,
+				   WLC_RATES_CCK_OFDM, RATE_MASK,
+				   (bool) N_ENAB(wlc->pub));
+	}
+
+	/* update antenna config due to wlc->stf->txant/txchain/ant_rx_ovr change */
+	wlc_stf_phy_txant_upd(wlc);
+
+	/* attach each modules */
+	err = wlc_attach_module(wlc);
+	if (err != 0)
+		goto fail;
+
+	if (!wlc_timers_init(wlc, unit)) {
+		WL_ERROR(("wl%d: %s: wlc_init_timer failed\n", unit, __func__));
+		err = 32;
+		goto fail;
+	}
+
+	/* depend on rateset, gmode */
+	wlc->cmi = wlc_channel_mgr_attach(wlc);
+	if (!wlc->cmi) {
+		WL_ERROR(("wl%d: %s: wlc_channel_mgr_attach failed\n", unit,
+			  __func__));
+		err = 33;
+		goto fail;
+	}
+
+	/* init default when all parameters are ready, i.e. ->rateset */
+	wlc_bss_default_init(wlc);
+
+	/*
+	 * Complete the wlc default state initializations..
+	 */
+
+	/* allocate our initial queue */
+	qi = wlc_txq_alloc(wlc, osh);
+	if (qi == NULL) {
+		WL_ERROR(("wl%d: %s: failed to malloc tx queue\n", unit,
+			  __func__));
+		err = 100;
+		goto fail;
+	}
+	wlc->active_queue = qi;
+
+	wlc->bsscfg[0] = wlc->cfg;
+	wlc->cfg->_idx = 0;
+	wlc->cfg->wlc = wlc;
+	pub->txmaxpkts = MAXTXPKTS;
+
+	WLCNTSET(pub->_cnt->version, WL_CNT_T_VERSION);
+	WLCNTSET(pub->_cnt->length, sizeof(wl_cnt_t));
+
+	WLCNTSET(pub->_wme_cnt->version, WL_WME_CNT_VERSION);
+	WLCNTSET(pub->_wme_cnt->length, sizeof(wl_wme_cnt_t));
+
+	wlc_wme_initparams_sta(wlc, &wlc->wme_param_ie);
+
+	wlc->mimoft = FT_HT;
+	wlc->ht_cap.cap = HT_CAP;
+	if (HT_ENAB(wlc->pub))
+		wlc->stf->ldpc = AUTO;
+
+	wlc->mimo_40txbw = AUTO;
+	wlc->ofdm_40txbw = AUTO;
+	wlc->cck_40txbw = AUTO;
+	wlc_update_mimo_band_bwcap(wlc, WLC_N_BW_20IN2G_40IN5G);
+
+	/* Enable setting the RIFS Mode bit by default in HT Info IE */
+	wlc->rifs_advert = AUTO;
+
+	/* Set default values of SGI */
+	if (WLC_SGI_CAP_PHY(wlc)) {
+		wlc_ht_update_sgi_rx(wlc, (WLC_N_SGI_20 | WLC_N_SGI_40));
+		wlc->sgi_tx = AUTO;
+	} else if (WLCISSSLPNPHY(wlc->band)) {
+		wlc_ht_update_sgi_rx(wlc, (WLC_N_SGI_20 | WLC_N_SGI_40));
+		wlc->sgi_tx = AUTO;
+	} else {
+		wlc_ht_update_sgi_rx(wlc, 0);
+		wlc->sgi_tx = OFF;
+	}
+
+	/* *******nvram 11n config overrides Start ********* */
+
+	/* apply the sgi override from nvram conf */
+	if (n_disabled & WLFEATURE_DISABLE_11N_SGI_TX)
+		wlc->sgi_tx = OFF;
+
+	if (n_disabled & WLFEATURE_DISABLE_11N_SGI_RX)
+		wlc_ht_update_sgi_rx(wlc, 0);
+
+	/* apply the stbc override from nvram conf */
+	if (n_disabled & WLFEATURE_DISABLE_11N_STBC_TX) {
+		wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = OFF;
+		wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = OFF;
+		wlc->ht_cap.cap &= ~HT_CAP_TX_STBC;
+	}
+	if (n_disabled & WLFEATURE_DISABLE_11N_STBC_RX)
+		wlc_stf_stbc_rx_set(wlc, HT_CAP_RX_STBC_NO);
+
+	/* apply the GF override from nvram conf */
+	if (n_disabled & WLFEATURE_DISABLE_11N_GF)
+		wlc->ht_cap.cap &= ~HT_CAP_GF;
+
+	/* initialize radio_mpc_disable according to wlc->mpc */
+	wlc_radio_mpc_upd(wlc);
+
+	if (WLANTSEL_ENAB(wlc)) {
+		if ((CHIPID(wlc->pub->sih->chip)) == BCM43235_CHIP_ID) {
+			if ((getintvar(wlc->pub->vars, "aa2g") == 7) ||
+			    (getintvar(wlc->pub->vars, "aa5g") == 7)) {
+				wlc_bmac_antsel_set(wlc->hw, 1);
+			}
+		} else {
+			wlc_bmac_antsel_set(wlc->hw, wlc->asi->antsel_avail);
+		}
+	}
+
+	if (perr)
+		*perr = 0;
+
+	return ((void *)wlc);
+
+ fail:
+	WL_ERROR(("wl%d: %s: failed with err %d\n", unit, __func__, err));
+	if (wlc)
+		wlc_detach(wlc);
+
+	if (perr)
+		*perr = err;
+	return (NULL);
+}
+
+static void BCMNMIATTACHFN(wlc_attach_antgain_init) (wlc_info_t * wlc) {
+	uint unit;
+	unit = wlc->pub->unit;
+
+	if ((wlc->band->antgain == -1) && (wlc->pub->sromrev == 1)) {
+		/* default antenna gain for srom rev 1 is 2 dBm (8 qdbm) */
+		wlc->band->antgain = 8;
+	} else if (wlc->band->antgain == -1) {
+		WL_ERROR(("wl%d: %s: Invalid antennas available in srom, using 2dB\n", unit, __func__));
+		wlc->band->antgain = 8;
+	} else {
+		int8 gain, fract;
+		/* Older sroms specified gain in whole dbm only.  In order
+		 * be able to specify qdbm granularity and remain backward compatible
+		 * the whole dbms are now encoded in only low 6 bits and remaining qdbms
+		 * are encoded in the hi 2 bits. 6 bit signed number ranges from
+		 * -32 - 31. Examples: 0x1 = 1 db,
+		 * 0xc1 = 1.75 db (1 + 3 quarters),
+		 * 0x3f = -1 (-1 + 0 quarters),
+		 * 0x7f = -.75 (-1 in low 6 bits + 1 quarters in hi 2 bits) = -3 qdbm.
+		 * 0xbf = -.50 (-1 in low 6 bits + 2 quarters in hi 2 bits) = -2 qdbm.
+		 */
+		gain = wlc->band->antgain & 0x3f;
+		gain <<= 2;	/* Sign extend */
+		gain >>= 2;
+		fract = (wlc->band->antgain & 0xc0) >> 6;
+		wlc->band->antgain = 4 * gain + fract;
+	}
+}
+
+static bool BCMATTACHFN(wlc_attach_stf_ant_init) (wlc_info_t * wlc) {
+	int aa;
+	uint unit;
+	char *vars;
+	int bandtype;
+
+	unit = wlc->pub->unit;
+	vars = wlc->pub->vars;
+	bandtype = wlc->band->bandtype;
+
+	/* get antennas available */
+	aa = (int8) getintvar(vars, (BAND_5G(bandtype) ? "aa5g" : "aa2g"));
+	if (aa == 0)
+		aa = (int8) getintvar(vars,
+				      (BAND_5G(bandtype) ? "aa1" : "aa0"));
+	if ((aa < 1) || (aa > 15)) {
+		WL_ERROR(("wl%d: %s: Invalid antennas available in srom (0x%x), using 3.\n", unit, __func__, aa));
+		aa = 3;
+	}
+
+	/* reset the defaults if we have a single antenna */
+	if (aa == 1) {
+		wlc->stf->ant_rx_ovr = ANT_RX_DIV_FORCE_0;
+		wlc->stf->txant = ANT_TX_FORCE_0;
+	} else if (aa == 2) {
+		wlc->stf->ant_rx_ovr = ANT_RX_DIV_FORCE_1;
+		wlc->stf->txant = ANT_TX_FORCE_1;
+	} else {
+	}
+
+	/* Compute Antenna Gain */
+	wlc->band->antgain =
+	    (int8) getintvar(vars, (BAND_5G(bandtype) ? "ag1" : "ag0"));
+	wlc_attach_antgain_init(wlc);
+
+	return TRUE;
+}
+
+#ifdef WLC_HIGH_ONLY
+/* HIGH_ONLY bmac_attach, which sync over LOW_ONLY bmac_attach states */
+int
+BCMATTACHFN(wlc_bmac_attach) (wlc_info_t * wlc, uint16 vendor, uint16 device,
+			      uint unit, bool piomode, osl_t * osh,
+			      void *regsva, uint bustype, void *btparam) {
+	wlc_bmac_revinfo_t revinfo;
+	uint idx = 0;
+	rpc_info_t *rpc = (rpc_info_t *) btparam;
+
+	ASSERT(bustype == RPC_BUS);
+
+	/* install the rpc handle in the various state structures used by stub RPC functions */
+	wlc->rpc = rpc;
+	wlc->hw->rpc = rpc;
+	wlc->hw->osh = osh;
+
+	wlc->regs = 0;
+
+	if ((wlc->rpctx = wlc_rpctx_attach(wlc->pub, wlc)) == NULL)
+		return -1;
+
+	/*
+	 * FIFO 0
+	 * TX: TX_AC_BK_FIFO (TX AC Background data packets)
+	 */
+	/* Always initialized */
+	ASSERT(NRPCTXBUFPOST <= NTXD);
+	wlc_rpctx_fifoinit(wlc->rpctx, TX_DATA_FIFO, NRPCTXBUFPOST);
+	wlc_rpctx_fifoinit(wlc->rpctx, TX_CTL_FIFO, NRPCTXBUFPOST);
+	wlc_rpctx_fifoinit(wlc->rpctx, TX_BCMC_FIFO, NRPCTXBUFPOST);
+
+	/* VI and BK inited only if WME */
+	if (WME_ENAB(wlc->pub)) {
+		wlc_rpctx_fifoinit(wlc->rpctx, TX_AC_BK_FIFO, NRPCTXBUFPOST);
+		wlc_rpctx_fifoinit(wlc->rpctx, TX_AC_VI_FIFO, NRPCTXBUFPOST);
+	}
+
+	/* Allocate SB handle */
+	wlc->pub->sih = osl_malloc(wlc->osh, sizeof(si_t));
+	if (!wlc->pub->sih)
+		return -1;
+	bzero(wlc->pub->sih, sizeof(si_t));
+
+	/* sync up revinfo with BMAC */
+	bzero(&revinfo, sizeof(wlc_bmac_revinfo_t));
+	if (wlc_bmac_revinfo_get(wlc->hw, &revinfo) != 0)
+		return -1;
+	wlc->vendorid = (uint16) revinfo.vendorid;
+	wlc->deviceid = (uint16) revinfo.deviceid;
+
+	wlc->pub->boardrev = (uint16) revinfo.boardrev;
+	wlc->pub->corerev = revinfo.corerev;
+	wlc->pub->sromrev = (uint8) revinfo.sromrev;
+	wlc->pub->sih->chiprev = revinfo.chiprev;
+	wlc->pub->sih->chip = revinfo.chip;
+	wlc->pub->sih->chippkg = revinfo.chippkg;
+	wlc->pub->sih->boardtype = revinfo.boardtype;
+	wlc->pub->sih->boardvendor = revinfo.boardvendor;
+	wlc->pub->sih->bustype = revinfo.bustype;
+	wlc->pub->sih->buscoretype = revinfo.buscoretype;
+	wlc->pub->sih->buscorerev = revinfo.buscorerev;
+	wlc->pub->sih->issim = (bool) revinfo.issim;
+	wlc->pub->sih->rpc = rpc;
+
+	if (revinfo.nbands == 0 || revinfo.nbands > 2)
+		return -1;
+	wlc->pub->_nbands = revinfo.nbands;
+
+	for (idx = 0; idx < wlc->pub->_nbands; idx++) {
+		uint bandunit, bandtype;	/* To access bandstate */
+		wlc_phy_t *pi = osl_malloc(wlc->osh, sizeof(wlc_phy_t));
+
+		if (!pi)
+			return -1;
+		bzero(pi, sizeof(wlc_phy_t));
+		pi->rpc = rpc;
+
+		bandunit = revinfo.band[idx].bandunit;
+		bandtype = revinfo.band[idx].bandtype;
+		wlc->bandstate[bandunit]->radiorev =
+		    (uint8) revinfo.band[idx].radiorev;
+		wlc->bandstate[bandunit]->phytype =
+		    (uint16) revinfo.band[idx].phytype;
+		wlc->bandstate[bandunit]->phyrev =
+		    (uint16) revinfo.band[idx].phyrev;
+		wlc->bandstate[bandunit]->radioid =
+		    (uint16) revinfo.band[idx].radioid;
+		wlc->bandstate[bandunit]->abgphy_encore =
+		    revinfo.band[idx].abgphy_encore;
+
+		wlc->bandstate[bandunit]->pi = pi;
+		wlc->bandstate[bandunit]->bandunit = bandunit;
+		wlc->bandstate[bandunit]->bandtype = bandtype;
+	}
+
+	/* misc stuff */
+
+	return 0;
+}
+
+/* Free the convenience handles */
+int wlc_bmac_detach(wlc_info_t * wlc)
+{
+	uint idx;
+
+	if (wlc->pub->sih) {
+		osl_mfree(wlc->osh, (void *)wlc->pub->sih, sizeof(si_t));
+		wlc->pub->sih = NULL;
+	}
+
+	for (idx = 0; idx < MAXBANDS; idx++)
+		if (wlc->bandstate[idx]->pi) {
+			osl_mfree(wlc->osh, wlc->bandstate[idx]->pi,
+				  sizeof(wlc_phy_t));
+			wlc->bandstate[idx]->pi = NULL;
+		}
+
+	if (wlc->rpctx) {
+		wlc_rpctx_detach(wlc->rpctx);
+		wlc->rpctx = NULL;
+	}
+
+	return 0;
+
+}
+
+#endif				/* WLC_HIGH_ONLY */
+
+static void BCMATTACHFN(wlc_timers_deinit) (wlc_info_t * wlc) {
+	/* free timer state */
+	if (wlc->wdtimer) {
+		wl_free_timer(wlc->wl, wlc->wdtimer);
+		wlc->wdtimer = NULL;
+	}
+	if (wlc->radio_timer) {
+		wl_free_timer(wlc->wl, wlc->radio_timer);
+		wlc->radio_timer = NULL;
+	}
+}
+
+static void BCMATTACHFN(wlc_detach_module) (wlc_info_t * wlc) {
+	if (wlc->asi) {
+		wlc_antsel_detach(wlc->asi);
+		wlc->asi = NULL;
+	}
+
+	if (wlc->ampdu) {
+		wlc_ampdu_detach(wlc->ampdu);
+		wlc->ampdu = NULL;
+	}
+
+	wlc_stf_detach(wlc);
+}
+
+/*
+ * Return a count of the number of driver callbacks still pending.
+ *
+ * General policy is that wlc_detach can only dealloc/free software states. It can NOT
+ *  touch hardware registers since the d11core may be in reset and clock may not be available.
+ *    One exception is sb register access, which is possible if crystal is turned on
+ * After "down" state, driver should avoid software timer with the exception of radio_monitor.
+ */
+uint BCMATTACHFN(wlc_detach) (wlc_info_t * wlc) {
+	uint i;
+	uint callbacks = 0;
+
+	if (wlc == NULL)
+		return 0;
+
+	WL_TRACE(("wl%d: %s\n", wlc->pub->unit, __func__));
+
+	ASSERT(!wlc->pub->up);
+
+	callbacks += wlc_bmac_detach(wlc);
+
+	/* delete software timers */
+	if (!wlc_radio_monitor_stop(wlc))
+		callbacks++;
+
+	if (wlc->eventq) {
+		wlc_eventq_detach(wlc->eventq);
+		wlc->eventq = NULL;
+	}
+
+	wlc_channel_mgr_detach(wlc->cmi);
+
+	wlc_timers_deinit(wlc);
+
+	wlc_detach_module(wlc);
+
+	/* free other state */
+
+#ifdef WLC_HIGH_ONLY
+	/* High-Only driver has an allocated copy of vars, monolithic just
+	 * references the wlc->hw->vars which is freed in wlc_bmac_detach()
+	 */
+	if (wlc->pub->vars) {
+		osl_mfree(wlc->osh, wlc->pub->vars, wlc->vars_size);
+		wlc->pub->vars = NULL;
+	}
+#endif
+
+#ifdef BCMDBG
+	if (wlc->country_ie_override) {
+		osl_mfree(wlc->osh, wlc->country_ie_override,
+			  wlc->country_ie_override->len + TLV_HDR_LEN);
+		wlc->country_ie_override = NULL;
+	}
+#endif				/* BCMDBG */
+
+	{
+		/* free dumpcb list */
+		dumpcb_t *prev, *ptr;
+		prev = ptr = wlc->dumpcb_head;
+		while (ptr) {
+			ptr = prev->next;
+			osl_mfree(wlc->osh, prev, sizeof(dumpcb_t));
+			prev = ptr;
+		}
+		wlc->dumpcb_head = NULL;
+	}
+
+	/* Detach from iovar manager */
+	wlc_module_unregister(wlc->pub, "wlc_iovars", wlc);
+
+	/*
+	   if (wlc->ap) {
+	   wlc_ap_detach(wlc->ap);
+	   wlc->ap = NULL;
+	   }
+	 */
+
+	while (wlc->tx_queues != NULL) {
+		wlc_txq_free(wlc, wlc->osh, wlc->tx_queues);
+	}
+
+	/*
+	 * consistency check: wlc_module_register/wlc_module_unregister calls
+	 * should match therefore nothing should be left here.
+	 */
+	for (i = 0; i < WLC_MAXMODULES; i++)
+		ASSERT(wlc->modulecb[i].name[0] == '\0');
+
+	wlc_detach_mfree(wlc, wlc->osh);
+	return (callbacks);
+}
+
+/* update state that depends on the current value of "ap" */
+void wlc_ap_upd(wlc_info_t * wlc)
+{
+	if (AP_ENAB(wlc->pub))
+		wlc->PLCPHdr_override = WLC_PLCP_AUTO;	/* AP: short not allowed, but not enforced */
+	else
+		wlc->PLCPHdr_override = WLC_PLCP_SHORT;	/* STA-BSS; short capable */
+
+	/* disable vlan_mode on AP since some legacy STAs cannot rx tagged pkts */
+	wlc->vlan_mode = AP_ENAB(wlc->pub) ? OFF : AUTO;
+
+	/* fixup mpc */
+	wlc->mpc = TRUE;
+}
+
+/* read hwdisable state and propagate to wlc flag */
+static void wlc_radio_hwdisable_upd(wlc_info_t * wlc)
+{
+	if (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO || wlc->pub->hw_off)
+		return;
+
+	if (wlc_bmac_radio_read_hwdisabled(wlc->hw)) {
+		mboolset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE);
+	} else {
+		mboolclr(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE);
+	}
+}
+
+/* return TRUE if Minimum Power Consumption should be entered, FALSE otherwise */
+bool wlc_is_non_delay_mpc(wlc_info_t * wlc)
+{
+	return (FALSE);
+}
+
+bool wlc_ismpc(wlc_info_t * wlc)
+{
+	return ((wlc->mpc_delay_off == 0) && (wlc_is_non_delay_mpc(wlc)));
+}
+
+void wlc_radio_mpc_upd(wlc_info_t * wlc)
+{
+	bool mpc_radio, radio_state;
+
+	/*
+	 * Clear the WL_RADIO_MPC_DISABLE bit when mpc feature is disabled
+	 * in case the WL_RADIO_MPC_DISABLE bit was set. Stop the radio
+	 * monitor also when WL_RADIO_MPC_DISABLE is the only reason that
+	 * the radio is going down.
+	 */
+	if (!wlc->mpc) {
+		if (!wlc->pub->radio_disabled)
+			return;
+		mboolclr(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE);
+		wlc_radio_upd(wlc);
+		if (!wlc->pub->radio_disabled)
+			wlc_radio_monitor_stop(wlc);
+		return;
+	}
+
+	/*
+	 * sync ismpc logic with WL_RADIO_MPC_DISABLE bit in wlc->pub->radio_disabled
+	 * to go ON, always call radio_upd synchronously
+	 * to go OFF, postpone radio_upd to later when context is safe(e.g. watchdog)
+	 */
+	radio_state =
+	    (mboolisset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE) ? OFF :
+	     ON);
+	mpc_radio = (wlc_ismpc(wlc) == TRUE) ? OFF : ON;
+
+	if (radio_state == ON && mpc_radio == OFF)
+		wlc->mpc_delay_off = wlc->mpc_dlycnt;
+	else if (radio_state == OFF && mpc_radio == ON) {
+		mboolclr(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE);
+		wlc_radio_upd(wlc);
+		if (wlc->mpc_offcnt < WLC_MPC_THRESHOLD) {
+			wlc->mpc_dlycnt = WLC_MPC_MAX_DELAYCNT;
+		} else
+			wlc->mpc_dlycnt = WLC_MPC_MIN_DELAYCNT;
+		wlc->mpc_dur += OSL_SYSUPTIME() - wlc->mpc_laston_ts;
+	}
+	/* Below logic is meant to capture the transition from mpc off to mpc on for reasons
+	 * other than wlc->mpc_delay_off keeping the mpc off. In that case reset
+	 * wlc->mpc_delay_off to wlc->mpc_dlycnt, so that we restart the countdown of mpc_delay_off
+	 */
+	if ((wlc->prev_non_delay_mpc == FALSE) &&
+	    (wlc_is_non_delay_mpc(wlc) == TRUE) && wlc->mpc_delay_off) {
+		wlc->mpc_delay_off = wlc->mpc_dlycnt;
+	}
+	wlc->prev_non_delay_mpc = wlc_is_non_delay_mpc(wlc);
+}
+
+/*
+ * centralized radio disable/enable function,
+ * invoke radio enable/disable after updating hwradio status
+ */
+static void wlc_radio_upd(wlc_info_t * wlc)
+{
+	if (wlc->pub->radio_disabled)
+		wlc_radio_disable(wlc);
+	else
+		wlc_radio_enable(wlc);
+}
+
+/* maintain LED behavior in down state */
+static void wlc_down_led_upd(wlc_info_t * wlc)
+{
+	ASSERT(!wlc->pub->up);
+
+	/* maintain LEDs while in down state, turn on sbclk if not available yet */
+	/* turn on sbclk if necessary */
+	if (!AP_ENAB(wlc->pub)) {
+		wlc_pllreq(wlc, TRUE, WLC_PLLREQ_FLIP);
+
+		wlc_pllreq(wlc, FALSE, WLC_PLLREQ_FLIP);
+	}
+}
+
+void wlc_radio_disable(wlc_info_t * wlc)
+{
+	if (!wlc->pub->up) {
+		wlc_down_led_upd(wlc);
+		return;
+	}
+
+	wlc_radio_monitor_start(wlc);
+	wl_down(wlc->wl);
+}
+
+static void wlc_radio_enable(wlc_info_t * wlc)
+{
+	if (wlc->pub->up)
+		return;
+
+	if (DEVICEREMOVED(wlc))
+		return;
+
+	if (!wlc->down_override) {	/* imposed by wl down/out ioctl */
+		wl_up(wlc->wl);
+	}
+}
+
+/* periodical query hw radio button while driver is "down" */
+static void wlc_radio_timer(void *arg)
+{
+	wlc_info_t *wlc = (wlc_info_t *) arg;
+
+	if (DEVICEREMOVED(wlc)) {
+		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __func__));
+		wl_down(wlc->wl);
+		return;
+	}
+
+	/* cap mpc off count */
+	if (wlc->mpc_offcnt < WLC_MPC_MAX_DELAYCNT)
+		wlc->mpc_offcnt++;
+
+	/* validate all the reasons driver could be down and running this radio_timer */
+	ASSERT(wlc->pub->radio_disabled || wlc->down_override);
+	wlc_radio_hwdisable_upd(wlc);
+	wlc_radio_upd(wlc);
+}
+
+static bool wlc_radio_monitor_start(wlc_info_t * wlc)
+{
+	/* Don't start the timer if HWRADIO feature is disabled */
+	if (wlc->radio_monitor || (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO))
+		return TRUE;
+
+	wlc->radio_monitor = TRUE;
+	wlc_pllreq(wlc, TRUE, WLC_PLLREQ_RADIO_MON);
+	wl_add_timer(wlc->wl, wlc->radio_timer, TIMER_INTERVAL_RADIOCHK, TRUE);
+	return TRUE;
+}
+
+bool wlc_radio_monitor_stop(wlc_info_t * wlc)
+{
+	if (!wlc->radio_monitor)
+		return TRUE;
+
+	ASSERT((wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO) !=
+	       WL_SWFL_NOHWRADIO);
+
+	wlc->radio_monitor = FALSE;
+	wlc_pllreq(wlc, FALSE, WLC_PLLREQ_RADIO_MON);
+	return (wl_del_timer(wlc->wl, wlc->radio_timer));
+}
+
+/* bring the driver down, but don't reset hardware */
+void wlc_out(wlc_info_t * wlc)
+{
+	wlc_bmac_set_noreset(wlc->hw, TRUE);
+	wlc_radio_upd(wlc);
+	wl_down(wlc->wl);
+	wlc_bmac_set_noreset(wlc->hw, FALSE);
+
+	/* core clk is TRUE in BMAC driver due to noreset, need to mirror it in HIGH */
+	wlc->clk = TRUE;
+
+	/* This will make sure that when 'up' is done
+	 * after 'out' it'll restore hardware (especially gpios)
+	 */
+	wlc->pub->hw_up = FALSE;
+}
+
+#if defined(BCMDBG)
+/* Verify the sanity of wlc->tx_prec_map. This can be done only by making sure that
+ * if there is no packet pending for the FIFO, then the corresponding prec bits should be set
+ * in prec_map. Of course, ignore this rule when block_datafifo is set
+ */
+static bool wlc_tx_prec_map_verify(wlc_info_t * wlc)
+{
+	/* For non-WME, both fifos have overlapping prec_map. So it's an error only if both
+	 * fail the check.
+	 */
+	if (!EDCF_ENAB(wlc->pub)) {
+		if (!(WLC_TX_FIFO_CHECK(wlc, TX_DATA_FIFO) ||
+		      WLC_TX_FIFO_CHECK(wlc, TX_CTL_FIFO)))
+			return FALSE;
+		else
+			return TRUE;
+	}
+
+	return (WLC_TX_FIFO_CHECK(wlc, TX_AC_BK_FIFO)
+		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_BE_FIFO)
+		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VI_FIFO)
+		&& WLC_TX_FIFO_CHECK(wlc, TX_AC_VO_FIFO));
+}
+#endif				/* BCMDBG */
+
+static void wlc_watchdog_by_timer(void *arg)
+{
+	wlc_info_t *wlc = (wlc_info_t *) arg;
+	wlc_watchdog(arg);
+	if (WLC_WATCHDOG_TBTT(wlc)) {
+		/* set to normal osl watchdog period */
+		wl_del_timer(wlc->wl, wlc->wdtimer);
+		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG,
+			     TRUE);
+	}
+}
+
+/* common watchdog code */
+static void wlc_watchdog(void *arg)
+{
+	wlc_info_t *wlc = (wlc_info_t *) arg;
+	int i;
+	wlc_bsscfg_t *cfg;
+
+	WL_TRACE(("wl%d: wlc_watchdog\n", wlc->pub->unit));
+
+	if (!wlc->pub->up)
+		return;
+
+	if (DEVICEREMOVED(wlc)) {
+		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __func__));
+		wl_down(wlc->wl);
+		return;
+	}
+
+	/* increment second count */
+	wlc->pub->now++;
+
+	/* delay radio disable */
+	if (wlc->mpc_delay_off) {
+		if (--wlc->mpc_delay_off == 0) {
+			mboolset(wlc->pub->radio_disabled,
+				 WL_RADIO_MPC_DISABLE);
+			if (wlc->mpc && wlc_ismpc(wlc))
+				wlc->mpc_offcnt = 0;
+			wlc->mpc_laston_ts = OSL_SYSUPTIME();
+		}
+	}
+
+	/* mpc sync */
+	wlc_radio_mpc_upd(wlc);
+	/* radio sync: sw/hw/mpc --> radio_disable/radio_enable */
+	wlc_radio_hwdisable_upd(wlc);
+	wlc_radio_upd(wlc);
+	/* if ismpc, driver should be in down state if up/down is allowed */
+	if (wlc->mpc && wlc_ismpc(wlc))
+		ASSERT(!wlc->pub->up);
+	/* if radio is disable, driver may be down, quit here */
+	if (wlc->pub->radio_disabled)
+		return;
+
+#ifdef WLC_LOW
+	wlc_bmac_watchdog(wlc);
+#endif
+#ifdef WLC_HIGH_ONLY
+	/* maintenance */
+	wlc_bmac_rpc_watchdog(wlc);
+#endif
+
+	/* occasionally sample mac stat counters to detect 16-bit counter wrap */
+	if ((WLC_UPDATE_STATS(wlc))
+	    && (!(wlc->pub->now % SW_TIMER_MAC_STAT_UPD)))
+		wlc_statsupd(wlc);
+
+	/* Manage TKIP countermeasures timers */
+	FOREACH_BSS(wlc, i, cfg) {
+		if (cfg->tk_cm_dt) {
+			cfg->tk_cm_dt--;
+		}
+		if (cfg->tk_cm_bt) {
+			cfg->tk_cm_bt--;
+		}
+	}
+
+	/* Call any registered watchdog handlers */
+	for (i = 0; i < WLC_MAXMODULES; i++) {
+		if (wlc->modulecb[i].watchdog_fn)
+			wlc->modulecb[i].watchdog_fn(wlc->modulecb[i].hdl);
+	}
+
+	if (WLCISNPHY(wlc->band) && !wlc->pub->tempsense_disable &&
+	    ((wlc->pub->now - wlc->tempsense_lasttime) >=
+	     WLC_TEMPSENSE_PERIOD)) {
+		wlc->tempsense_lasttime = wlc->pub->now;
+		wlc_tempsense_upd(wlc);
+	}
+#ifdef WLC_LOW
+	/* BMAC_NOTE: for HIGH_ONLY driver, this seems being called after RPC bus failed */
+	ASSERT(wlc_bmac_taclear(wlc->hw, TRUE));
+#endif
+
+	/* Verify that tx_prec_map and fifos are in sync to avoid lock ups */
+	ASSERT(wlc_tx_prec_map_verify(wlc));
+
+	ASSERT(wlc_ps_check(wlc));
+}
+
+/* make interface operational */
+int BCMINITFN(wlc_up) (wlc_info_t * wlc) {
+	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
+
+	/* HW is turned off so don't try to access it */
+	if (wlc->pub->hw_off || DEVICEREMOVED(wlc))
+		return BCME_RADIOOFF;
+
+	if (!wlc->pub->hw_up) {
+		wlc_bmac_hw_up(wlc->hw);
+		wlc->pub->hw_up = TRUE;
+	}
+
+	if ((wlc->pub->boardflags & BFL_FEM)
+	    && (CHIPID(wlc->pub->sih->chip) == BCM4313_CHIP_ID)) {
+		if (wlc->pub->boardrev >= 0x1250
+		    && (wlc->pub->boardflags & BFL_FEM_BT)) {
+			wlc_mhf(wlc, MHF5, MHF5_4313_GPIOCTRL,
+				MHF5_4313_GPIOCTRL, WLC_BAND_ALL);
+		} else {
+			wlc_mhf(wlc, MHF4, MHF4_EXTPA_ENABLE, MHF4_EXTPA_ENABLE,
+				WLC_BAND_ALL);
+		}
+	}
+
+	/*
+	 * Need to read the hwradio status here to cover the case where the system
+	 * is loaded with the hw radio disabled. We do not want to bring the driver up in this case.
+	 * if radio is disabled, abort up, lower power, start radio timer and return 0(for NDIS)
+	 * don't call radio_update to avoid looping wlc_up.
+	 *
+	 * wlc_bmac_up_prep() returns either 0 or BCME_RADIOOFF only
+	 */
+	if (!wlc->pub->radio_disabled) {
+		int status = wlc_bmac_up_prep(wlc->hw);
+		if (status == BCME_RADIOOFF) {
+			if (!mboolisset
+			    (wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE)) {
+				int idx;
+				wlc_bsscfg_t *bsscfg;
+				mboolset(wlc->pub->radio_disabled,
+					 WL_RADIO_HW_DISABLE);
+
+				FOREACH_BSS(wlc, idx, bsscfg) {
+					if (!BSSCFG_STA(bsscfg)
+					    || !bsscfg->enable || !bsscfg->BSS)
+						continue;
+					WL_ERROR(("wl%d.%d: wlc_up: rfdisable -> " "wlc_bsscfg_disable()\n", wlc->pub->unit, idx));
+				}
+			}
+		} else
+			ASSERT(!status);
+	}
+
+	if (wlc->pub->radio_disabled) {
+		wlc_radio_monitor_start(wlc);
+		return 0;
+	}
+
+	/* wlc_bmac_up_prep has done wlc_corereset(). so clk is on, set it */
+	wlc->clk = TRUE;
+
+	wlc_radio_monitor_stop(wlc);
+
+	/* Set EDCF hostflags */
+	if (EDCF_ENAB(wlc->pub)) {
+		wlc_mhf(wlc, MHF1, MHF1_EDCF, MHF1_EDCF, WLC_BAND_ALL);
+	} else {
+		wlc_mhf(wlc, MHF1, MHF1_EDCF, 0, WLC_BAND_ALL);
+	}
+
+	if (WLC_WAR16165(wlc))
+		wlc_mhf(wlc, MHF2, MHF2_PCISLOWCLKWAR, MHF2_PCISLOWCLKWAR,
+			WLC_BAND_ALL);
+
+	wl_init(wlc->wl);
+	wlc->pub->up = TRUE;
+
+	if (wlc->bandinit_pending) {
+		wlc_suspend_mac_and_wait(wlc);
+		wlc_set_chanspec(wlc, wlc->default_bss->chanspec);
+		wlc->bandinit_pending = FALSE;
+		wlc_enable_mac(wlc);
+	}
+
+	wlc_bmac_up_finish(wlc->hw);
+
+	/* other software states up after ISR is running */
+	/* start APs that were to be brought up but are not up  yet */
+	/* if (AP_ENAB(wlc->pub)) wlc_restart_ap(wlc->ap); */
+
+	/* Program the TX wme params with the current settings */
+	wlc_wme_retries_write(wlc);
+
+	/* start one second watchdog timer */
+	ASSERT(!wlc->WDarmed);
+	wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, TRUE);
+	wlc->WDarmed = TRUE;
+
+	/* ensure antenna config is up to date */
+	wlc_stf_phy_txant_upd(wlc);
+	/* ensure LDPC config is in sync */
+	wlc_ht_update_ldpc(wlc, wlc->stf->ldpc);
+
+	return (0);
+}
+
+/* Initialize the base precedence map for dequeueing from txq based on WME settings */
+static void BCMINITFN(wlc_tx_prec_map_init) (wlc_info_t * wlc) {
+	wlc->tx_prec_map = WLC_PREC_BMP_ALL;
+	bzero(wlc->fifo2prec_map, sizeof(uint16) * NFIFO);
+
+	/* For non-WME, both fifos have overlapping MAXPRIO. So just disable all precedences
+	 * if either is full.
+	 */
+	if (!EDCF_ENAB(wlc->pub)) {
+		wlc->fifo2prec_map[TX_DATA_FIFO] = WLC_PREC_BMP_ALL;
+		wlc->fifo2prec_map[TX_CTL_FIFO] = WLC_PREC_BMP_ALL;
+	} else {
+		wlc->fifo2prec_map[TX_AC_BK_FIFO] = WLC_PREC_BMP_AC_BK;
+		wlc->fifo2prec_map[TX_AC_BE_FIFO] = WLC_PREC_BMP_AC_BE;
+		wlc->fifo2prec_map[TX_AC_VI_FIFO] = WLC_PREC_BMP_AC_VI;
+		wlc->fifo2prec_map[TX_AC_VO_FIFO] = WLC_PREC_BMP_AC_VO;
+	}
+}
+
+static uint BCMUNINITFN(wlc_down_del_timer) (wlc_info_t * wlc) {
+	uint callbacks = 0;
+
+	return callbacks;
+}
+
+/*
+ * Mark the interface nonoperational, stop the software mechanisms,
+ * disable the hardware, free any transient buffer state.
+ * Return a count of the number of driver callbacks still pending.
+ */
+uint BCMUNINITFN(wlc_down) (wlc_info_t * wlc) {
+
+	uint callbacks = 0;
+	int i;
+	bool dev_gone = FALSE;
+	wlc_txq_info_t *qi;
+
+	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __func__));
+
+	/* check if we are already in the going down path */
+	if (wlc->going_down) {
+		WL_ERROR(("wl%d: %s: Driver going down so return\n",
+			  wlc->pub->unit, __func__));
+		return 0;
+	}
+	if (!wlc->pub->up)
+		return (callbacks);
+
+	/* in between, mpc could try to bring down again.. */
+	wlc->going_down = TRUE;
+
+	callbacks += wlc_bmac_down_prep(wlc->hw);
+
+	dev_gone = DEVICEREMOVED(wlc);
+
+	/* Call any registered down handlers */
+	for (i = 0; i < WLC_MAXMODULES; i++) {
+		if (wlc->modulecb[i].down_fn)
+			callbacks +=
+			    wlc->modulecb[i].down_fn(wlc->modulecb[i].hdl);
+	}
+
+	/* cancel the watchdog timer */
+	if (wlc->WDarmed) {
+		if (!wl_del_timer(wlc->wl, wlc->wdtimer))
+			callbacks++;
+		wlc->WDarmed = FALSE;
+	}
+	/* cancel all other timers */
+	callbacks += wlc_down_del_timer(wlc);
+
+	/* interrupt must have been blocked */
+	ASSERT((wlc->macintmask == 0) || !wlc->pub->up);
+
+	wlc->pub->up = FALSE;
+
+	wlc_phy_mute_upd(wlc->band->pi, FALSE, PHY_MUTE_ALL);
+
+	/* clear txq flow control */
+	wlc_txflowcontrol_reset(wlc);
+
+	/* flush tx queues */
+	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
+		pktq_flush(wlc->osh, &qi->q, TRUE, NULL, 0);
+		ASSERT(pktq_empty(&qi->q));
+	}
+
+	/* flush event queue.
+	 * Should be the last thing done after all the events are generated
+	 * Just delivers the events synchronously instead of waiting for a timer
+	 */
+	callbacks += wlc_eventq_down(wlc->eventq);
+
+	callbacks += wlc_bmac_down_finish(wlc->hw);
+
+	/* wlc_bmac_down_finish has done wlc_coredisable(). so clk is off */
+	wlc->clk = FALSE;
+
+#ifdef WLC_HIGH_ONLY
+	wlc_rpctx_txreclaim(wlc->rpctx);
+#endif
+
+	/* Verify all packets are flushed from the driver */
+	if (PKTALLOCED(wlc->osh) != 0) {
+		WL_ERROR(("%d packets not freed at wlc_down!!!!!!\n",
+			  PKTALLOCED(wlc->osh)));
+	}
+#ifdef BCMDBG
+	/* Since all the packets should have been freed,
+	 * all callbacks should have been called
+	 */
+	for (i = 1; i <= wlc->pub->tunables->maxpktcb; i++)
+		ASSERT(wlc->pkt_callback[i].fn == NULL);
+#endif
+	wlc->going_down = FALSE;
+	return (callbacks);
+}
+
+/* Set the current gmode configuration */
+int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config)
+{
+	int ret = 0;
+	uint i;
+	wlc_rateset_t rs;
+	/* Default to 54g Auto */
+	int8 shortslot = WLC_SHORTSLOT_AUTO;	/* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
+	bool shortslot_restrict = FALSE;	/* Restrict association to stations that support shortslot
+						 */
+	bool ignore_bcns = TRUE;	/* Ignore legacy beacons on the same channel */
+	bool ofdm_basic = FALSE;	/* Make 6, 12, and 24 basic rates */
+	int preamble = WLC_PLCP_LONG;	/* Advertise and use short preambles (-1/0/1 Auto/Off/On) */
+	bool preamble_restrict = FALSE;	/* Restrict association to stations that support short
+					 * preambles
+					 */
+	wlcband_t *band;
+
+	/* if N-support is enabled, allow Gmode set as long as requested
+	 * Gmode is not GMODE_LEGACY_B
+	 */
+	if (N_ENAB(wlc->pub) && gmode == GMODE_LEGACY_B)
+		return BCME_UNSUPPORTED;
+
+	/* verify that we are dealing with 2G band and grab the band pointer */
+	if (wlc->band->bandtype == WLC_BAND_2G)
+		band = wlc->band;
+	else if ((NBANDS(wlc) > 1) &&
+		 (wlc->bandstate[OTHERBANDUNIT(wlc)]->bandtype == WLC_BAND_2G))
+		band = wlc->bandstate[OTHERBANDUNIT(wlc)];
+	else
+		return BCME_BADBAND;
+
+	/* Legacy or bust when no OFDM is supported by regulatory */
+	if ((wlc_channel_locale_flags_in_band(wlc->cmi, band->bandunit) &
+	     WLC_NO_OFDM) && (gmode != GMODE_LEGACY_B))
+		return BCME_RANGE;
+
+	/* update configuration value */
+	if (config == TRUE)
+		wlc_protection_upd(wlc, WLC_PROT_G_USER, gmode);
+
+	/* Clear supported rates filter */
+	bzero(&wlc->sup_rates_override, sizeof(wlc_rateset_t));
+
+	/* Clear rateset override */
+	bzero(&rs, sizeof(wlc_rateset_t));
+
+	switch (gmode) {
+	case GMODE_LEGACY_B:
+		shortslot = WLC_SHORTSLOT_OFF;
+		wlc_rateset_copy(&gphy_legacy_rates, &rs);
+
+		break;
+
+	case GMODE_LRS:
+		if (AP_ENAB(wlc->pub))
+			wlc_rateset_copy(&cck_rates, &wlc->sup_rates_override);
+		break;
+
+	case GMODE_AUTO:
+		/* Accept defaults */
+		break;
+
+	case GMODE_ONLY:
+		ofdm_basic = TRUE;
+		preamble = WLC_PLCP_SHORT;
+		preamble_restrict = TRUE;
+		break;
+
+	case GMODE_PERFORMANCE:
+		if (AP_ENAB(wlc->pub))	/* Put all rates into the Supported Rates element */
+			wlc_rateset_copy(&cck_ofdm_rates,
+					 &wlc->sup_rates_override);
+
+		shortslot = WLC_SHORTSLOT_ON;
+		shortslot_restrict = TRUE;
+		ofdm_basic = TRUE;
+		preamble = WLC_PLCP_SHORT;
+		preamble_restrict = TRUE;
+		break;
+
+	default:
+		/* Error */
+		WL_ERROR(("wl%d: %s: invalid gmode %d\n", wlc->pub->unit,
+			  __func__, gmode));
+		return BCME_UNSUPPORTED;
+	}
+
+	/*
+	 * If we are switching to gmode == GMODE_LEGACY_B,
+	 * clean up rate info that may refer to OFDM rates.
+	 */
+	if ((gmode == GMODE_LEGACY_B) && (band->gmode != GMODE_LEGACY_B)) {
+		band->gmode = gmode;
+		if (band->rspec_override && !IS_CCK(band->rspec_override)) {
+			band->rspec_override = 0;
+			wlc_reprate_init(wlc);
+		}
+		if (band->mrspec_override && !IS_CCK(band->mrspec_override)) {
+			band->mrspec_override = 0;
+		}
+	}
+
+	band->gmode = gmode;
+
+	wlc->ignore_bcns = ignore_bcns;
+
+	wlc->shortslot_override = shortslot;
+
+	if (AP_ENAB(wlc->pub)) {
+		/* wlc->ap->shortslot_restrict = shortslot_restrict; */
+		wlc->PLCPHdr_override =
+		    (preamble !=
+		     WLC_PLCP_LONG) ? WLC_PLCP_SHORT : WLC_PLCP_AUTO;
+	}
+
+	if ((AP_ENAB(wlc->pub) && preamble != WLC_PLCP_LONG)
+	    || preamble == WLC_PLCP_SHORT)
+		wlc->default_bss->capability |= DOT11_CAP_SHORT;
+	else
+		wlc->default_bss->capability &= ~DOT11_CAP_SHORT;
+
+	/* Update shortslot capability bit for AP and IBSS */
+	if ((AP_ENAB(wlc->pub) && shortslot == WLC_SHORTSLOT_AUTO) ||
+	    shortslot == WLC_SHORTSLOT_ON)
+		wlc->default_bss->capability |= DOT11_CAP_SHORTSLOT;
+	else
+		wlc->default_bss->capability &= ~DOT11_CAP_SHORTSLOT;
+
+	/* Use the default 11g rateset */
+	if (!rs.count)
+		wlc_rateset_copy(&cck_ofdm_rates, &rs);
+
+	if (ofdm_basic) {
+		for (i = 0; i < rs.count; i++) {
+			if (rs.rates[i] == WLC_RATE_6M
+			    || rs.rates[i] == WLC_RATE_12M
+			    || rs.rates[i] == WLC_RATE_24M)
+				rs.rates[i] |= WLC_RATE_FLAG;
+		}
+	}
+
+	/* Set default bss rateset */
+	wlc->default_bss->rateset.count = rs.count;
+	bcopy((char *)rs.rates, (char *)wlc->default_bss->rateset.rates,
+	      sizeof(wlc->default_bss->rateset.rates));
+
+	return ret;
+}
+
+static int wlc_nmode_validate(wlc_info_t * wlc, int32 nmode)
+{
+	int err = 0;
+
+	switch (nmode) {
+
+	case OFF:
+		break;
+
+	case AUTO:
+	case WL_11N_2x2:
+	case WL_11N_3x3:
+		if (!(WLC_PHY_11N_CAP(wlc->band)))
+			err = BCME_BADBAND;
+		break;
+
+	default:
+		err = BCME_RANGE;
+		break;
+	}
+
+	return err;
+}
+
+int wlc_set_nmode(wlc_info_t * wlc, int32 nmode)
+{
+	uint i;
+	int err;
+
+	err = wlc_nmode_validate(wlc, nmode);
+	ASSERT(err == 0);
+	if (err)
+		return err;
+
+	switch (nmode) {
+	case OFF:
+		wlc->pub->_n_enab = OFF;
+		wlc->default_bss->flags &= ~WLC_BSS_HT;
+		/* delete the mcs rates from the default and hw ratesets */
+		wlc_rateset_mcs_clear(&wlc->default_bss->rateset);
+		for (i = 0; i < NBANDS(wlc); i++) {
+			memset(wlc->bandstate[i]->hw_rateset.mcs, 0,
+			       MCSSET_LEN);
+			if (IS_MCS(wlc->band->rspec_override)) {
+				wlc->bandstate[i]->rspec_override = 0;
+				wlc_reprate_init(wlc);
+			}
+			if (IS_MCS(wlc->band->mrspec_override))
+				wlc->bandstate[i]->mrspec_override = 0;
+		}
+		break;
+
+	case AUTO:
+		if (wlc->stf->txstreams == WL_11N_3x3)
+			nmode = WL_11N_3x3;
+		else
+			nmode = WL_11N_2x2;
+	case WL_11N_2x2:
+	case WL_11N_3x3:
+		ASSERT(WLC_PHY_11N_CAP(wlc->band));
+		/* force GMODE_AUTO if NMODE is ON */
+		wlc_set_gmode(wlc, GMODE_AUTO, TRUE);
+		if (nmode == WL_11N_3x3)
+			wlc->pub->_n_enab = SUPPORT_HT;
+		else
+			wlc->pub->_n_enab = SUPPORT_11N;
+		wlc->default_bss->flags |= WLC_BSS_HT;
+		/* add the mcs rates to the default and hw ratesets */
+		wlc_rateset_mcs_build(&wlc->default_bss->rateset,
+				      wlc->stf->txstreams);
+		for (i = 0; i < NBANDS(wlc); i++)
+			memcpy(wlc->bandstate[i]->hw_rateset.mcs,
+			       wlc->default_bss->rateset.mcs, MCSSET_LEN);
+		break;
+
+	default:
+		ASSERT(0);
+		break;
+	}
+
+	return err;
+}
+
+static int wlc_set_rateset(wlc_info_t * wlc, wlc_rateset_t * rs_arg)
+{
+	wlc_rateset_t rs, new;
+	uint bandunit;
+
+	bcopy((char *)rs_arg, (char *)&rs, sizeof(wlc_rateset_t));
+
+	/* check for bad count value */
+	if ((rs.count == 0) || (rs.count > WLC_NUMRATES))
+		return BCME_BADRATESET;
+
+	/* try the current band */
+	bandunit = wlc->band->bandunit;
+	bcopy((char *)&rs, (char *)&new, sizeof(wlc_rateset_t));
+	if (wlc_rate_hwrs_filter_sort_validate
+	    (&new, &wlc->bandstate[bandunit]->hw_rateset, TRUE,
+	     wlc->stf->txstreams))
+		goto good;
+
+	/* try the other band */
+	if (IS_MBAND_UNLOCKED(wlc)) {
+		bandunit = OTHERBANDUNIT(wlc);
+		bcopy((char *)&rs, (char *)&new, sizeof(wlc_rateset_t));
+		if (wlc_rate_hwrs_filter_sort_validate(&new,
+						       &wlc->
+						       bandstate[bandunit]->
+						       hw_rateset, TRUE,
+						       wlc->stf->txstreams))
+			goto good;
+	}
+
+	return BCME_ERROR;
+
+ good:
+	/* apply new rateset */
+	bcopy((char *)&new, (char *)&wlc->default_bss->rateset,
+	      sizeof(wlc_rateset_t));
+	bcopy((char *)&new, (char *)&wlc->bandstate[bandunit]->defrateset,
+	      sizeof(wlc_rateset_t));
+	return (0);
+}
+
+/* simplified integer set interface for common ioctl handler */
+int wlc_set(wlc_info_t * wlc, int cmd, int arg)
+{
+	return wlc_ioctl(wlc, cmd, (void *)&arg, sizeof(arg), NULL);
+}
+
+/* simplified integer get interface for common ioctl handler */
+int wlc_get(wlc_info_t * wlc, int cmd, int *arg)
+{
+	return wlc_ioctl(wlc, cmd, arg, sizeof(int), NULL);
+}
+
+static void wlc_ofdm_rateset_war(wlc_info_t * wlc)
+{
+	uint8 r;
+	bool war = FALSE;
+
+	if (wlc->cfg->associated)
+		r = wlc->cfg->current_bss->rateset.rates[0];
+	else
+		r = wlc->default_bss->rateset.rates[0];
+
+	wlc_phy_ofdm_rateset_war(wlc->band->pi, war);
+
+	return;
+}
+
+int
+wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
+{
+	return (_wlc_ioctl(wlc, cmd, arg, len, wlcif));
+}
+
+/* common ioctl handler. return: 0=ok, -1=error, positive=particular error */
+static int
+_wlc_ioctl(wlc_info_t * wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
+{
+	int val, *pval;
+	bool bool_val;
+	int bcmerror;
+	d11regs_t *regs;
+	uint i;
+	struct scb *nextscb;
+	bool ta_ok;
+	uint band;
+	rw_reg_t *r;
+	wlc_bsscfg_t *bsscfg;
+	osl_t *osh;
+	wlc_bss_info_t *current_bss;
+
+	/* update bsscfg pointer */
+	bsscfg = NULL;		/* XXX: Hack bsscfg to be size one and use this globally */
+	current_bss = NULL;
+
+	/* initialize the following to get rid of compiler warning */
+	nextscb = NULL;
+	ta_ok = FALSE;
+	band = 0;
+	r = NULL;
+
+	/* If the device is turned off, then it's not "removed" */
+	if (!wlc->pub->hw_off && DEVICEREMOVED(wlc)) {
+		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __func__));
+		wl_down(wlc->wl);
+		return BCME_ERROR;
+	}
+
+	ASSERT(!(wlc->pub->hw_off && wlc->pub->up));
+
+	/* default argument is generic integer */
+	pval = arg ? (int *)arg : NULL;
+
+	/* This will prevent the misaligned access */
+	if (pval && (uint32) len >= sizeof(val))
+		bcopy(pval, &val, sizeof(val));
+	else
+		val = 0;
+
+	/* bool conversion to avoid duplication below */
+	bool_val = val != 0;
+
+	if (cmd != WLC_SET_CHANNEL)
+		WL_NONE(("WLC_IOCTL: cmd %d val 0x%x (%d) len %d\n", cmd,
+			 (uint) val, val, len));
+
+	bcmerror = 0;
+	regs = wlc->regs;
+	osh = wlc->osh;
+
+	/* A few commands don't need any arguments; all the others do. */
+	switch (cmd) {
+	case WLC_UP:
+	case WLC_OUT:
+	case WLC_DOWN:
+	case WLC_DISASSOC:
+	case WLC_RESTART:
+	case WLC_REBOOT:
+	case WLC_START_CHANNEL_QA:
+	case WLC_INIT:
+		break;
+
+	default:
+		if ((arg == NULL) || (len <= 0)) {
+			WL_ERROR(("wl%d: %s: Command %d needs arguments\n",
+				  wlc->pub->unit, __func__, cmd));
+			bcmerror = BCME_BADARG;
+			goto done;
+		}
+	}
+
+	switch (cmd) {
+
+#if defined(BCMDBG)
+	case WLC_GET_MSGLEVEL:
+		*pval = wl_msg_level;
+		break;
+
+	case WLC_SET_MSGLEVEL:
+		wl_msg_level = val;
+		break;
+#endif
+
+	case WLC_GET_INSTANCE:
+		*pval = wlc->pub->unit;
+		break;
+
+	case WLC_GET_CHANNEL:{
+			channel_info_t *ci = (channel_info_t *) arg;
+
+			ASSERT(len > (int)sizeof(ci));
+
+			ci->hw_channel =
+			    CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC);
+			ci->target_channel =
+			    CHSPEC_CHANNEL(wlc->default_bss->chanspec);
+			ci->scan_channel = 0;
+
+			break;
+		}
+
+	case WLC_SET_CHANNEL:{
+			chanspec_t chspec = CH20MHZ_CHSPEC(val);
+
+			if (val < 0 || val > MAXCHANNEL) {
+				bcmerror = BCME_OUTOFRANGECHAN;
+				break;
+			}
+
+			if (!wlc_valid_chanspec_db(wlc->cmi, chspec)) {
+				bcmerror = BCME_BADCHAN;
+				break;
+			}
+
+			if (!wlc->pub->up && IS_MBAND_UNLOCKED(wlc)) {
+				if (wlc->band->bandunit !=
+				    CHSPEC_WLCBANDUNIT(chspec))
+					wlc->bandinit_pending = TRUE;
+				else
+					wlc->bandinit_pending = FALSE;
+			}
+
+			wlc->default_bss->chanspec = chspec;
+			/* wlc_BSSinit() will sanitize the rateset before using it.. */
+			if (wlc->pub->up && !wlc->pub->associated &&
+			    (WLC_BAND_PI_RADIO_CHANSPEC != chspec)) {
+				wlc_set_home_chanspec(wlc, chspec);
+				wlc_suspend_mac_and_wait(wlc);
+				wlc_set_chanspec(wlc, chspec);
+				wlc_enable_mac(wlc);
+			}
+#ifdef WLC_HIGH_ONLY
+			/* delay for channel change */
+			msleep(50);
+#endif
+			break;
+		}
+
+#if defined(BCMDBG)
+	case WLC_GET_UCFLAGS:
+		if (!wlc->pub->up) {
+			bcmerror = BCME_NOTUP;
+			break;
+		}
+
+		/* optional band is stored in the second integer of incoming buffer */
+		band =
+		    (len <
+		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
+
+		/* bcmerror checking */
+		if ((bcmerror = wlc_iocregchk(wlc, band)))
+			break;
+
+		if (val >= MHFMAX) {
+			bcmerror = BCME_RANGE;
+			break;
+		}
+
+		*pval = wlc_bmac_mhf_get(wlc->hw, (uint8) val, WLC_BAND_AUTO);
+		break;
+
+	case WLC_SET_UCFLAGS:
+		if (!wlc->pub->up) {
+			bcmerror = BCME_NOTUP;
+			break;
+		}
+
+		/* optional band is stored in the second integer of incoming buffer */
+		band =
+		    (len <
+		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
+
+		/* bcmerror checking */
+		if ((bcmerror = wlc_iocregchk(wlc, band)))
+			break;
+
+		i = (uint16) val;
+		if (i >= MHFMAX) {
+			bcmerror = BCME_RANGE;
+			break;
+		}
+
+		wlc_mhf(wlc, (uint8) i, 0xffff, (uint16) (val >> NBITS(uint16)),
+			WLC_BAND_AUTO);
+		break;
+
+	case WLC_GET_SHMEM:
+		ta_ok = TRUE;
+
+		/* optional band is stored in the second integer of incoming buffer */
+		band =
+		    (len <
+		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
+
+		/* bcmerror checking */
+		if ((bcmerror = wlc_iocregchk(wlc, band)))
+			break;
+
+		if (val & 1) {
+			bcmerror = BCME_BADADDR;
+			break;
+		}
+
+		*pval = wlc_read_shm(wlc, (uint16) val);
+		break;
+
+	case WLC_SET_SHMEM:
+		ta_ok = TRUE;
+
+		/* optional band is stored in the second integer of incoming buffer */
+		band =
+		    (len <
+		     (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];
+
+		/* bcmerror checking */
+		if ((bcmerror = wlc_iocregchk(wlc, band)))
+			break;
+
+		if (val & 1) {
+			bcmerror = BCME_BADADDR;
+			break;
+		}
+
+		wlc_write_shm(wlc, (uint16) val,
+			      (uint16) (val >> NBITS(uint16)));
+		break;
+
+	case WLC_R_REG:	/* MAC registers */
+		ta_ok = TRUE;
+		r = (rw_reg_t *) arg;
+		band = WLC_BAND_AUTO;
+
+		if (len < (int)(sizeof(rw_reg_t) - sizeof(uint))) {
+			bcmerror = BCME_BUFTOOSHORT;
+			break;
+		}
+
+		if (len >= (int)sizeof(rw_reg_t))
+			band = r->band;
+
+		/* bcmerror checking */
+		if ((bcmerror = wlc_iocregchk(wlc, band)))
+			break;
+
+		if ((r->byteoff + r->size) > sizeof(d11regs_t)) {
+			bcmerror = BCME_BADADDR;
+			break;
+		}
+		if (r->size == sizeof(uint32))
+			r->val =
+			    R_REG(osh,
+				  (uint32 *) ((uchar *) (uintptr) regs +
+					      r->byteoff));
+		else if (r->size == sizeof(uint16))
+			r->val =
+			    R_REG(osh,
+				  (uint16 *) ((uchar *) (uintptr) regs +
+					      r->byteoff));
+		else
+			bcmerror = BCME_BADADDR;
+		break;
+
+	case WLC_W_REG:
+		ta_ok = TRUE;
+		r = (rw_reg_t *) arg;
+		band = WLC_BAND_AUTO;
+
+		if (len < (int)(sizeof(rw_reg_t) - sizeof(uint))) {
+			bcmerror = BCME_BUFTOOSHORT;
+			break;
+		}
+
+		if (len >= (int)sizeof(rw_reg_t))
+			band = r->band;
+
+		/* bcmerror checking */
+		if ((bcmerror = wlc_iocregchk(wlc, band)))
+			break;
+
+		if (r->byteoff + r->size > sizeof(d11regs_t)) {
+			bcmerror = BCME_BADADDR;
+			break;
+		}
+		if (r->size == sizeof(uint32))
+			W_REG(osh,
+			      (uint32 *) ((uchar *) (uintptr) regs +
+					  r->byteoff), r->val);
+		else if (r->size == sizeof(uint16))
+			W_REG(osh,
+			      (uint16 *) ((uchar *) (uintptr) regs +
+					  r->byteoff), r->val);
+		else
+			bcmerror = BCME_BADADDR;
+		break;
+#endif				/* BCMDBG */
+
+	case WLC_GET_TXANT:
+		*pval = wlc->stf->txant;
+		break;
+
+	case WLC_SET_TXANT:
+		bcmerror = wlc_stf_ant_txant_validate(wlc, (int8) val);
+		if (bcmerror < 0)
+			break;
+
+		wlc->stf->txant = (int8) val;
+
+		/* if down, we are done */
+		if (!wlc->pub->up)
+			break;
+
+		wlc_suspend_mac_and_wait(wlc);
+
+		wlc_stf_phy_txant_upd(wlc);
+		wlc_beacon_phytxctl_txant_upd(wlc, wlc->bcn_rspec);
+
+		wlc_enable_mac(wlc);
+
+		break;
+
+	case WLC_GET_ANTDIV:{
+			uint8 phy_antdiv;
+
+			/* return configured value if core is down */
+			if (!wlc->pub->up) {
+				*pval = wlc->stf->ant_rx_ovr;
+
+			} else {
+				if (wlc_phy_ant_rxdiv_get
+				    (wlc->band->pi, &phy_antdiv))
+					*pval = (int)phy_antdiv;
+				else
+					*pval = (int)wlc->stf->ant_rx_ovr;
+			}
+
+			break;
+		}
+	case WLC_SET_ANTDIV:
+		/* values are -1=driver default, 0=force0, 1=force1, 2=start1, 3=start0 */
+		if ((val < -1) || (val > 3)) {
+			bcmerror = BCME_RANGE;
+			break;
+		}
+
+		if (val == -1)
+			val = ANT_RX_DIV_DEF;
+
+		wlc->stf->ant_rx_ovr = (uint8) val;
+		wlc_phy_ant_rxdiv_set(wlc->band->pi, (uint8) val);
+		break;
+
+	case WLC_GET_RX_ANT:{	/* get latest used rx antenna */
+			uint16 rxstatus;
+
+			if (!wlc->pub->up) {
+				bcmerror = BCME_NOTUP;
+				break;
+			}
+
+			rxstatus = R_REG(wlc->osh, &wlc->regs->phyrxstatus0);
+			if (rxstatus == 0xdead || rxstatus == (uint16) - 1) {
+				bcmerror = BCME_ERROR;
+				break;
+			}
+			*pval = (rxstatus & PRXS0_RXANT_UPSUBBAND) ? 1 : 0;
+			break;
+		}
+
+#if defined(BCMDBG)
+	case WLC_GET_UCANTDIV:
+		if (!wlc->clk) {
+			bcmerror = BCME_NOCLK;
+			break;
+		}
+
+		*pval =
+		    (wlc_bmac_mhf_get(wlc->hw, MHF1, WLC_BAND_AUTO) &
+		     MHF1_ANTDIV);
+		break;
+
+	case WLC_SET_UCANTDIV:{
+			if (!wlc->pub->up) {
+				bcmerror = BCME_NOTUP;
+				break;
+			}
+
+			/* if multiband, band must be locked */
+			if (IS_MBAND_UNLOCKED(wlc)) {
+				bcmerror = BCME_NOTBANDLOCKED;
+				break;
+			}
+
+			/* 4322 supports antdiv in phy, no need to set it to ucode */
+			if (WLCISNPHY(wlc->band)
+			    && D11REV_IS(wlc->pub->corerev, 16)) {
+				WL_ERROR(("wl%d: can't set ucantdiv for 4322\n",
+					  wlc->pub->unit));
+				bcmerror = BCME_UNSUPPORTED;
+			} else
+				wlc_mhf(wlc, MHF1, MHF1_ANTDIV,
+					(val ? MHF1_ANTDIV : 0), WLC_BAND_AUTO);
+			break;
+		}
+#endif				/* defined(BCMDBG) */
+
+	case WLC_GET_SRL:
+		*pval = wlc->SRL;
+		break;
+
+	case WLC_SET_SRL:
+		if (val >= 1 && val <= RETRY_SHORT_MAX) {
+			int ac;
+			wlc->SRL = (uint16) val;
+
+			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);
+
+			for (ac = 0; ac < AC_COUNT; ac++) {
+				WLC_WME_RETRY_SHORT_SET(wlc, ac, wlc->SRL);
+			}
+			wlc_wme_retries_write(wlc);
+		} else
+			bcmerror = BCME_RANGE;
+		break;
+
+	case WLC_GET_LRL:
+		*pval = wlc->LRL;
+		break;
+
+	case WLC_SET_LRL:
+		if (val >= 1 && val <= 255) {
+			int ac;
+			wlc->LRL = (uint16) val;
+
+			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);
+
+			for (ac = 0; ac < AC_COUNT; ac++) {
+				WLC_WME_RETRY_LONG_SET(wlc, ac, wlc->LRL);
+			}
+			wlc_wme_retries_write(wlc);
+		} else
+			bcmerror = BCME_RANGE;
+		break;
+
+	case WLC_GET_CWMIN:
+		*pval = wlc->band->CWmin;
+		break;
+
+	case WLC_SET_CWMIN:
+		if (!wlc->clk) {
+			bcmerror = BCME_NOCLK;
+			break;
+		}
+
+		if (val >= 1 && val <= 255) {
+			wlc_set_cwmin(wlc, (uint16) val);
+		} else
+			bcmerror = BCME_RANGE;
+		break;
+
+	case WLC_GET_CWMAX:
+		*pval = wlc->band->CWmax;
+		break;
+
+	case WLC_SET_CWMAX:
+		if (!wlc->clk) {
+			bcmerror = BCME_NOCLK;
+			break;
+		}
+
+		if (val >= 255 && val <= 2047) {
+			wlc_set_cwmax(wlc, (uint16) val);
+		} else
+			bcmerror = BCME_RANGE;
+		break;
+
+	case WLC_GET_RADIO:	/* use mask if don't want to expose some internal bits */
+		*pval = wlc->pub->radio_disabled;
+		break;
+
+	case WLC_SET_RADIO:{	/* 32 bits input, higher 16 bits are mask, lower 16 bits are value to
+				 * set
+				 */
+			uint16 radiomask, radioval;
+			uint validbits =
+			    WL_RADIO_SW_DISABLE | WL_RADIO_HW_DISABLE;
+			mbool new = 0;
+
+			radiomask = (val & 0xffff0000) >> 16;
+			radioval = val & 0x0000ffff;
+
+			if ((radiomask == 0) || (radiomask & ~validbits)
+			    || (radioval & ~validbits)
+			    || ((radioval & ~radiomask) != 0)) {
+				WL_ERROR(("SET_RADIO with wrong bits 0x%x\n",
+					  val));
+				bcmerror = BCME_RANGE;
+				break;
+			}
+
+			new =
+			    (wlc->pub->radio_disabled & ~radiomask) | radioval;
+			wlc->pub->radio_disabled = new;
+
+			wlc_radio_hwdisable_upd(wlc);
+			wlc_radio_upd(wlc);
+			break;
+		}
+
+	case WLC_GET_PHYTYPE:
+		*pval = WLC_PHYTYPE(wlc->band->phytype);
+		break;
+
+#if defined(BCMDBG)
+	case WLC_GET_KEY:
+		if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc))) {
+			wl_wsec_key_t key;
+
+			wsec_key_t *src_key = wlc->wsec_keys[val];
+
+			if (len < (int)sizeof(key)) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+
+			bzero((char *)&key, sizeof(key));
+			if (src_key) {
+				key.index = src_key->id;
+				key.len = src_key->len;
+				bcopy(src_key->data, key.data, key.len);
+				key.algo = src_key->algo;
+				if (WSEC_SOFTKEY(wlc, src_key, bsscfg))
+					key.flags |= WL_SOFT_KEY;
+				if (src_key->flags & WSEC_PRIMARY_KEY)
+					key.flags |= WL_PRIMARY_KEY;
+
+				bcopy(src_key->ea.octet, key.ea.octet,
+				      ETHER_ADDR_LEN);
+			}
+
+			bcopy((char *)&key, arg, sizeof(key));
+		} else
+			bcmerror = BCME_BADKEYIDX;
+		break;
+#endif				/* defined(BCMDBG) */
+
+	case WLC_SET_KEY:
+		bcmerror =
+		    wlc_iovar_op(wlc, "wsec_key", NULL, 0, arg, len, IOV_SET,
+				 wlcif);
+		break;
+
+	case WLC_GET_KEY_SEQ:{
+			wsec_key_t *key;
+
+			if (len < DOT11_WPA_KEY_RSC_LEN) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+
+			/* Return the key's tx iv as an EAPOL sequence counter.
+			 * This will be used to supply the RSC value to a supplicant.
+			 * The format is 8 bytes, with least significant in seq[0].
+			 */
+
+			if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc)) &&
+			    (key = WSEC_KEY(wlc, val)) != NULL) {
+				uint8 seq[DOT11_WPA_KEY_RSC_LEN];
+				uint16 lo;
+				uint32 hi;
+				/* group keys in WPA-NONE (IBSS only, AES and TKIP) use a global TXIV */
+				if ((bsscfg->WPA_auth & WPA_AUTH_NONE)
+				    && ETHER_ISNULLADDR(&key->ea)) {
+					lo = bsscfg->wpa_none_txiv.lo;
+					hi = bsscfg->wpa_none_txiv.hi;
+				} else {
+					lo = key->txiv.lo;
+					hi = key->txiv.hi;
+				}
+
+				/* format the buffer, low to high */
+				seq[0] = lo & 0xff;
+				seq[1] = (lo >> 8) & 0xff;
+				seq[2] = hi & 0xff;
+				seq[3] = (hi >> 8) & 0xff;
+				seq[4] = (hi >> 16) & 0xff;
+				seq[5] = (hi >> 24) & 0xff;
+				seq[6] = 0;
+				seq[7] = 0;
+
+				bcopy((char *)seq, arg, sizeof(seq));
+			} else {
+				bcmerror = BCME_BADKEYIDX;
+			}
+			break;
+		}
+
+	case WLC_GET_CURR_RATESET:{
+			wl_rateset_t *ret_rs = (wl_rateset_t *) arg;
+			wlc_rateset_t *rs;
+
+			if (bsscfg->associated)
+				rs = &current_bss->rateset;
+			else
+				rs = &wlc->default_bss->rateset;
+
+			if (len < (int)(rs->count + sizeof(rs->count))) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+
+			/* Copy only legacy rateset section */
+			ret_rs->count = rs->count;
+			bcopy(&rs->rates, &ret_rs->rates, rs->count);
+			break;
+		}
+
+	case WLC_GET_RATESET:{
+			wlc_rateset_t rs;
+			wl_rateset_t *ret_rs = (wl_rateset_t *) arg;
+
+			bzero(&rs, sizeof(wlc_rateset_t));
+			wlc_default_rateset(wlc, (wlc_rateset_t *) & rs);
+
+			if (len < (int)(rs.count + sizeof(rs.count))) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+
+			/* Copy only legacy rateset section */
+			ret_rs->count = rs.count;
+			bcopy(&rs.rates, &ret_rs->rates, rs.count);
+			break;
+		}
+
+	case WLC_SET_RATESET:{
+			wlc_rateset_t rs;
+			wl_rateset_t *in_rs = (wl_rateset_t *) arg;
+
+			if (len < (int)(in_rs->count + sizeof(in_rs->count))) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+
+			if (in_rs->count > WLC_NUMRATES) {
+				bcmerror = BCME_BUFTOOLONG;
+				break;
+			}
+
+			bzero(&rs, sizeof(wlc_rateset_t));
+
+			/* Copy only legacy rateset section */
+			rs.count = in_rs->count;
+			bcopy(&in_rs->rates, &rs.rates, rs.count);
+
+			/* merge rateset coming in with the current mcsset */
+			if (N_ENAB(wlc->pub)) {
+				if (bsscfg->associated)
+					bcopy(&current_bss->rateset.mcs[0],
+					      rs.mcs, MCSSET_LEN);
+				else
+					bcopy(&wlc->default_bss->rateset.mcs[0],
+					      rs.mcs, MCSSET_LEN);
+			}
+
+			bcmerror = wlc_set_rateset(wlc, &rs);
+
+			if (!bcmerror)
+				wlc_ofdm_rateset_war(wlc);
+
+			break;
+		}
+
+	case WLC_GET_BCNPRD:
+		if (BSSCFG_STA(bsscfg) && bsscfg->BSS && bsscfg->associated)
+			*pval = current_bss->beacon_period;
+		else
+			*pval = wlc->default_bss->beacon_period;
+		break;
+
+	case WLC_SET_BCNPRD:
+		/* range [1, 0xffff] */
+		if (val >= DOT11_MIN_BEACON_PERIOD
+		    && val <= DOT11_MAX_BEACON_PERIOD) {
+			wlc->default_bss->beacon_period = (uint16) val;
+		} else
+			bcmerror = BCME_RANGE;
+		break;
+
+	case WLC_GET_DTIMPRD:
+		if (BSSCFG_STA(bsscfg) && bsscfg->BSS && bsscfg->associated)
+			*pval = current_bss->dtim_period;
+		else
+			*pval = wlc->default_bss->dtim_period;
+		break;
+
+	case WLC_SET_DTIMPRD:
+		/* range [1, 0xff] */
+		if (val >= DOT11_MIN_DTIM_PERIOD
+		    && val <= DOT11_MAX_DTIM_PERIOD) {
+			wlc->default_bss->dtim_period = (uint8) val;
+		} else
+			bcmerror = BCME_RANGE;
+		break;
+
+#ifdef SUPPORT_PS
+	case WLC_GET_PM:
+		*pval = wlc->PM;
+		break;
+
+	case WLC_SET_PM:
+		if ((val >= PM_OFF) && (val <= PM_MAX)) {
+			wlc->PM = (uint8) val;
+			if (wlc->pub->up) {
+			}
+			/* Change watchdog driver to align watchdog with tbtt if possible */
+			wlc_watchdog_upd(wlc, PS_ALLOWED(wlc));
+		} else
+			bcmerror = BCME_ERROR;
+		break;
+#endif				/* SUPPORT_PS */
+
+#ifdef SUPPORT_PS
+#ifdef BCMDBG
+	case WLC_GET_WAKE:
+		if (AP_ENAB(wlc->pub)) {
+			bcmerror = BCME_NOTSTA;
+			break;
+		}
+		*pval = wlc->wake;
+		break;
+
+	case WLC_SET_WAKE:
+		if (AP_ENAB(wlc->pub)) {
+			bcmerror = BCME_NOTSTA;
+			break;
+		}
+
+		wlc->wake = val ? TRUE : FALSE;
+
+		/* if down, we're done */
+		if (!wlc->pub->up)
+			break;
+
+		/* apply to the mac */
+		wlc_set_ps_ctrl(wlc);
+		break;
+#endif				/* BCMDBG */
+#endif				/* SUPPORT_PS */
+
+	case WLC_GET_REVINFO:
+		bcmerror = wlc_get_revision_info(wlc, arg, (uint) len);
+		break;
+
+	case WLC_GET_AP:
+		*pval = (int)AP_ENAB(wlc->pub);
+		break;
+
+	case WLC_GET_ATIM:
+		if (bsscfg->associated)
+			*pval = (int)current_bss->atim_window;
+		else
+			*pval = (int)wlc->default_bss->atim_window;
+		break;
+
+	case WLC_SET_ATIM:
+		wlc->default_bss->atim_window = (uint32) val;
+		break;
+
+	case WLC_GET_PKTCNTS:{
+			get_pktcnt_t *pktcnt = (get_pktcnt_t *) pval;
+			if (WLC_UPDATE_STATS(wlc))
+				wlc_statsupd(wlc);
+			pktcnt->rx_good_pkt = WLCNTVAL(wlc->pub->_cnt->rxframe);
+			pktcnt->rx_bad_pkt = WLCNTVAL(wlc->pub->_cnt->rxerror);
+			pktcnt->tx_good_pkt =
+			    WLCNTVAL(wlc->pub->_cnt->txfrmsnt);
+			pktcnt->tx_bad_pkt =
+			    WLCNTVAL(wlc->pub->_cnt->txerror) +
+			    WLCNTVAL(wlc->pub->_cnt->txfail);
+			if (len >= (int)sizeof(get_pktcnt_t)) {
+				/* Be backward compatible - only if buffer is large enough  */
+				pktcnt->rx_ocast_good_pkt =
+				    WLCNTVAL(wlc->pub->_cnt->rxmfrmocast);
+			}
+			break;
+		}
+
+#ifdef SUPPORT_HWKEY
+	case WLC_GET_WSEC:
+		bcmerror =
+		    wlc_iovar_op(wlc, "wsec", NULL, 0, arg, len, IOV_GET,
+				 wlcif);
+		break;
+
+	case WLC_SET_WSEC:
+		bcmerror =
+		    wlc_iovar_op(wlc, "wsec", NULL, 0, arg, len, IOV_SET,
+				 wlcif);
+		break;
+
+	case WLC_GET_WPA_AUTH:
+		*pval = (int)bsscfg->WPA_auth;
+		break;
+
+	case WLC_SET_WPA_AUTH:
+		/* change of WPA_Auth modifies the PS_ALLOWED state */
+		if (BSSCFG_STA(bsscfg)) {
+			bsscfg->WPA_auth = (uint16) val;
+		} else
+			bsscfg->WPA_auth = (uint16) val;
+		break;
+#endif				/* SUPPORT_HWKEY */
+
+	case WLC_GET_BANDLIST:
+		/* count of number of bands, followed by each band type */
+		*pval++ = NBANDS(wlc);
+		*pval++ = wlc->band->bandtype;
+		if (NBANDS(wlc) > 1)
+			*pval++ = wlc->bandstate[OTHERBANDUNIT(wlc)]->bandtype;
+		break;
+
+	case WLC_GET_BAND:
+		*pval = wlc->bandlocked ? wlc->band->bandtype : WLC_BAND_AUTO;
+		break;
+
+	case WLC_GET_PHYLIST:
+		{
+			uchar *cp = arg;
+			if (len < 3) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+
+			if (WLCISNPHY(wlc->band)) {
+				*cp++ = 'n';
+			} else if (WLCISLCNPHY(wlc->band)) {
+				*cp++ = 'c';
+			} else if (WLCISSSLPNPHY(wlc->band)) {
+				*cp++ = 's';
+			}
+			*cp = '\0';
+			break;
+		}
+
+	case WLC_GET_SHORTSLOT:
+		*pval = wlc->shortslot;
+		break;
+
+	case WLC_GET_SHORTSLOT_OVERRIDE:
+		*pval = wlc->shortslot_override;
+		break;
+
+	case WLC_SET_SHORTSLOT_OVERRIDE:
+		if ((val != WLC_SHORTSLOT_AUTO) &&
+		    (val != WLC_SHORTSLOT_OFF) && (val != WLC_SHORTSLOT_ON)) {
+			bcmerror = BCME_RANGE;
+			break;
+		}
+
+		wlc->shortslot_override = (int8) val;
+
+		/* shortslot is an 11g feature, so no more work if we are
+		 * currently on the 5G band
+		 */
+		if (BAND_5G(wlc->band->bandtype))
+			break;
+
+		if (wlc->pub->up && wlc->pub->associated) {
+			/* let watchdog or beacon processing update shortslot */
+		} else if (wlc->pub->up) {
+			/* unassociated shortslot is off */
+			wlc_switch_shortslot(wlc, FALSE);
+		} else {
+			/* driver is down, so just update the wlc_info value */
+			if (wlc->shortslot_override == WLC_SHORTSLOT_AUTO) {
+				wlc->shortslot = FALSE;
+			} else {
+				wlc->shortslot =
+				    (wlc->shortslot_override ==
+				     WLC_SHORTSLOT_ON);
+			}
+		}
+
+		break;
+
+	case WLC_GET_LEGACY_ERP:
+		*pval = wlc->include_legacy_erp;
+		break;
+
+	case WLC_SET_LEGACY_ERP:
+		if (wlc->include_legacy_erp == bool_val)
+			break;
+
+		wlc->include_legacy_erp = bool_val;
+
+		if (AP_ENAB(wlc->pub) && wlc->clk) {
+			wlc_update_beacon(wlc);
+			wlc_update_probe_resp(wlc, TRUE);
+		}
+		break;
+
+	case WLC_GET_GMODE:
+		if (wlc->band->bandtype == WLC_BAND_2G)
+			*pval = wlc->band->gmode;
+		else if (NBANDS(wlc) > 1)
+			*pval = wlc->bandstate[OTHERBANDUNIT(wlc)]->gmode;
+		break;
+
+	case WLC_SET_GMODE:
+		if (!wlc->pub->associated)
+			bcmerror = wlc_set_gmode(wlc, (uint8) val, TRUE);
+		else {
+			bcmerror = BCME_ASSOCIATED;
+			break;
+		}
+		break;
+
+	case WLC_GET_GMODE_PROTECTION:
+		*pval = wlc->protection->_g;
+		break;
+
+	case WLC_GET_PROTECTION_CONTROL:
+		*pval = wlc->protection->overlap;
+		break;
+
+	case WLC_SET_PROTECTION_CONTROL:
+		if ((val != WLC_PROTECTION_CTL_OFF) &&
+		    (val != WLC_PROTECTION_CTL_LOCAL) &&
+		    (val != WLC_PROTECTION_CTL_OVERLAP)) {
+			bcmerror = BCME_RANGE;
+			break;
+		}
+
+		wlc_protection_upd(wlc, WLC_PROT_OVERLAP, (int8) val);
+
+		/* Current g_protection will sync up to the specified control alg in watchdog
+		 * if the driver is up and associated.
+		 * If the driver is down or not associated, the control setting has no effect.
+		 */
+		break;
+
+	case WLC_GET_GMODE_PROTECTION_OVERRIDE:
+		*pval = wlc->protection->g_override;
+		break;
+
+	case WLC_SET_GMODE_PROTECTION_OVERRIDE:
+		if ((val != WLC_PROTECTION_AUTO) &&
+		    (val != WLC_PROTECTION_OFF) && (val != WLC_PROTECTION_ON)) {
+			bcmerror = BCME_RANGE;
+			break;
+		}
+
+		wlc_protection_upd(wlc, WLC_PROT_G_OVR, (int8) val);
+
+		break;
+
+	case WLC_SET_SUP_RATESET_OVERRIDE:{
+			wlc_rateset_t rs, new;
+
+			/* copyin */
+			if (len < (int)sizeof(wlc_rateset_t)) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+			bcopy((char *)arg, (char *)&rs, sizeof(wlc_rateset_t));
+
+			/* check for bad count value */
+			if (rs.count > WLC_NUMRATES) {
+				bcmerror = BCME_BADRATESET;	/* invalid rateset */
+				break;
+			}
+
+			/* this command is only appropriate for gmode operation */
+			if (!(wlc->band->gmode ||
+			      ((NBANDS(wlc) > 1)
+			       && wlc->bandstate[OTHERBANDUNIT(wlc)]->gmode))) {
+				bcmerror = BCME_BADBAND;	/* gmode only command when not in gmode */
+				break;
+			}
+
+			/* check for an empty rateset to clear the override */
+			if (rs.count == 0) {
+				bzero(&wlc->sup_rates_override,
+				      sizeof(wlc_rateset_t));
+				break;
+			}
+
+			/* validate rateset by comparing pre and post sorted against 11g hw rates */
+			wlc_rateset_filter(&rs, &new, FALSE, WLC_RATES_CCK_OFDM,
+					   RATE_MASK, BSS_N_ENAB(wlc, bsscfg));
+			wlc_rate_hwrs_filter_sort_validate(&new,
+							   &cck_ofdm_rates,
+							   FALSE,
+							   wlc->stf->txstreams);
+			if (rs.count != new.count) {
+				bcmerror = BCME_BADRATESET;	/* invalid rateset */
+				break;
+			}
+
+			/* apply new rateset to the override */
+			bcopy((char *)&new, (char *)&wlc->sup_rates_override,
+			      sizeof(wlc_rateset_t));
+
+			/* update bcn and probe resp if needed */
+			if (wlc->pub->up && AP_ENAB(wlc->pub)
+			    && wlc->pub->associated) {
+				wlc_update_beacon(wlc);
+				wlc_update_probe_resp(wlc, TRUE);
+			}
+			break;
+		}
+
+	case WLC_GET_SUP_RATESET_OVERRIDE:
+		/* this command is only appropriate for gmode operation */
+		if (!(wlc->band->gmode ||
+		      ((NBANDS(wlc) > 1)
+		       && wlc->bandstate[OTHERBANDUNIT(wlc)]->gmode))) {
+			bcmerror = BCME_BADBAND;	/* gmode only command when not in gmode */
+			break;
+		}
+		if (len < (int)sizeof(wlc_rateset_t)) {
+			bcmerror = BCME_BUFTOOSHORT;
+			break;
+		}
+		bcopy((char *)&wlc->sup_rates_override, (char *)arg,
+		      sizeof(wlc_rateset_t));
+
+		break;
+
+	case WLC_GET_PRB_RESP_TIMEOUT:
+		*pval = wlc->prb_resp_timeout;
+		break;
+
+	case WLC_SET_PRB_RESP_TIMEOUT:
+		if (wlc->pub->up) {
+			bcmerror = BCME_NOTDOWN;
+			break;
+		}
+		if (val < 0 || val >= 0xFFFF) {
+			bcmerror = BCME_RANGE;	/* bad value */
+			break;
+		}
+		wlc->prb_resp_timeout = (uint16) val;
+		break;
+
+	case WLC_GET_KEY_PRIMARY:{
+			wsec_key_t *key;
+
+			/* treat the 'val' parm as the key id */
+			if ((key = WSEC_BSS_DEFAULT_KEY(bsscfg)) != NULL) {
+				*pval = key->id == val ? TRUE : FALSE;
+			} else {
+				bcmerror = BCME_BADKEYIDX;
+			}
+			break;
+		}
+
+	case WLC_SET_KEY_PRIMARY:{
+			wsec_key_t *key, *old_key;
+
+			bcmerror = BCME_BADKEYIDX;
+
+			/* treat the 'val' parm as the key id */
+			for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
+				if ((key = bsscfg->bss_def_keys[i]) != NULL &&
+				    key->id == val) {
+					if ((old_key =
+					     WSEC_BSS_DEFAULT_KEY(bsscfg)) !=
+					    NULL)
+						old_key->flags &=
+						    ~WSEC_PRIMARY_KEY;
+					key->flags |= WSEC_PRIMARY_KEY;
+					bsscfg->wsec_index = i;
+					bcmerror = BCME_OK;
+				}
+			}
+			break;
+		}
+
+#ifdef BCMDBG
+	case WLC_INIT:
+		wl_init(wlc->wl);
+		break;
+#endif
+
+	case WLC_SET_VAR:
+	case WLC_GET_VAR:{
+			char *name;
+			/* validate the name value */
+			name = (char *)arg;
+			for (i = 0; i < (uint) len && *name != '\0';
+			     i++, name++) ;
+
+			if (i == (uint) len) {
+				bcmerror = BCME_BUFTOOSHORT;
+				break;
+			}
+			i++;	/* include the null in the string length */
+
+			if (cmd == WLC_GET_VAR) {
+				bcmerror =
+				    wlc_iovar_op(wlc, arg,
+						 (void *)((int8 *) arg + i),
+						 len - i, arg, len, IOV_GET,
+						 wlcif);
+			} else
+				bcmerror =
+				    wlc_iovar_op(wlc, arg, NULL, 0,
+						 (void *)((int8 *) arg + i),
+						 len - i, IOV_SET, wlcif);
+
+			break;
+		}
+
+	case WLC_SET_WSEC_PMK:
+		bcmerror = BCME_UNSUPPORTED;
+		break;
+
+#if defined(BCMDBG)
+	case WLC_CURRENT_PWR:
+		if (!wlc->pub->up)
+			bcmerror = BCME_NOTUP;
+		else
+			bcmerror = wlc_get_current_txpwr(wlc, arg, len);
+		break;
+#endif
+
+	case WLC_LAST:
+		WL_ERROR(("%s: WLC_LAST\n", __func__));
+	}
+ done:
+
+	if (bcmerror) {
+		if (VALID_BCMERROR(bcmerror))
+			wlc->pub->bcmerror = bcmerror;
+		else {
+			bcmerror = 0;
+		}
+
+	}
+#ifdef WLC_LOW
+	/* BMAC_NOTE: for HIGH_ONLY driver, this seems being called after RPC bus failed */
+	/* In hw_off condition, IOCTLs that reach here are deemed safe but taclear would
+	 * certainly result in getting -1 for register reads. So skip ta_clear altogether
+	 */
+	if (!(wlc->pub->hw_off))
+		ASSERT(wlc_bmac_taclear(wlc->hw, ta_ok) || !ta_ok);
+#endif
+
+	return (bcmerror);
+}
+
+#if defined(BCMDBG)
+/* consolidated register access ioctl error checking */
+int wlc_iocregchk(wlc_info_t * wlc, uint band)
+{
+	/* if band is specified, it must be the current band */
+	if ((band != WLC_BAND_AUTO) && (band != (uint) wlc->band->bandtype))
+		return (BCME_BADBAND);
+
+	/* if multiband and band is not specified, band must be locked */
+	if ((band == WLC_BAND_AUTO) && IS_MBAND_UNLOCKED(wlc))
+		return (BCME_NOTBANDLOCKED);
+
+	/* must have core clocks */
+	if (!wlc->clk)
+		return (BCME_NOCLK);
+
+	return (0);
+}
+#endif				/* defined(BCMDBG) */
+
+#if defined(BCMDBG)
+/* For some ioctls, make sure that the pi pointer matches the current phy */
+int wlc_iocpichk(wlc_info_t * wlc, uint phytype)
+{
+	if (wlc->band->phytype != phytype)
+		return BCME_BADBAND;
+	return 0;
+}
+#endif
+
+/* Look up the given var name in the given table */
+static const bcm_iovar_t *wlc_iovar_lookup(const bcm_iovar_t * table,
+					   const char *name)
+{
+	const bcm_iovar_t *vi;
+	const char *lookup_name;
+
+	/* skip any ':' delimited option prefixes */
+	lookup_name = strrchr(name, ':');
+	if (lookup_name != NULL)
+		lookup_name++;
+	else
+		lookup_name = name;
+
+	ASSERT(table != NULL);
+
+	for (vi = table; vi->name; vi++) {
+		if (!strcmp(vi->name, lookup_name))
+			return vi;
+	}
+	/* ran to end of table */
+
+	return NULL;		/* var name not found */
+}
+
+/* simplified integer get interface for common WLC_GET_VAR ioctl handler */
+int wlc_iovar_getint(wlc_info_t * wlc, const char *name, int *arg)
+{
+	return wlc_iovar_op(wlc, name, NULL, 0, arg, sizeof(int32), IOV_GET,
+			    NULL);
+}
+
+/* simplified integer set interface for common WLC_SET_VAR ioctl handler */
+int wlc_iovar_setint(wlc_info_t * wlc, const char *name, int arg)
+{
+	return wlc_iovar_op(wlc, name, NULL, 0, (void *)&arg, sizeof(arg),
+			    IOV_SET, NULL);
+}
+
+/* simplified int8 get interface for common WLC_GET_VAR ioctl handler */
+int wlc_iovar_getint8(wlc_info_t * wlc, const char *name, int8 * arg)
+{
+	int iovar_int;
+	int err;
+
+	err =
+	    wlc_iovar_op(wlc, name, NULL, 0, &iovar_int, sizeof(iovar_int),
+			 IOV_GET, NULL);
+	if (!err)
+		*arg = (int8) iovar_int;
+
+	return err;
+}
+
+/*
+ * register iovar table, watchdog and down handlers.
+ * calling function must keep 'iovars' until wlc_module_unregister is called.
+ * 'iovar' must have the last entry's name field being NULL as terminator.
+ */
+int
+BCMATTACHFN(wlc_module_register) (wlc_pub_t * pub, const bcm_iovar_t * iovars,
+				  const char *name, void *hdl, iovar_fn_t i_fn,
+				  watchdog_fn_t w_fn, down_fn_t d_fn) {
+	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
+	int i;
+
+	ASSERT(name != NULL);
+	ASSERT(i_fn != NULL || w_fn != NULL || d_fn != NULL);
+
+	/* find an empty entry and just add, no duplication check! */
+	for (i = 0; i < WLC_MAXMODULES; i++) {
+		if (wlc->modulecb[i].name[0] == '\0') {
+			strncpy(wlc->modulecb[i].name, name,
+				sizeof(wlc->modulecb[i].name) - 1);
+			wlc->modulecb[i].iovars = iovars;
+			wlc->modulecb[i].hdl = hdl;
+			wlc->modulecb[i].iovar_fn = i_fn;
+			wlc->modulecb[i].watchdog_fn = w_fn;
+			wlc->modulecb[i].down_fn = d_fn;
+			return 0;
+		}
+	}
+
+	/* it is time to increase the capacity */
+	ASSERT(i < WLC_MAXMODULES);
+	return BCME_NORESOURCE;
+}
+
+/* unregister module callbacks */
+int
+BCMATTACHFN(wlc_module_unregister) (wlc_pub_t * pub, const char *name,
+				    void *hdl) {
+	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
+	int i;
+
+	if (wlc == NULL)
+		return BCME_NOTFOUND;
+
+	ASSERT(name != NULL);
+
+	for (i = 0; i < WLC_MAXMODULES; i++) {
+		if (!strcmp(wlc->modulecb[i].name, name) &&
+		    (wlc->modulecb[i].hdl == hdl)) {
+			bzero(&wlc->modulecb[i], sizeof(modulecb_t));
+			return 0;
+		}
+	}
+
+	/* table not found! */
+	return BCME_NOTFOUND;
+}
+
+/* Write WME tunable parameters for retransmit/max rate from wlc struct to ucode */
+static void wlc_wme_retries_write(wlc_info_t * wlc)
+{
+	int ac;
+
+	/* Need clock to do this */
+	if (!wlc->clk)
+		return;
+
+	for (ac = 0; ac < AC_COUNT; ac++) {
+		wlc_write_shm(wlc, M_AC_TXLMT_ADDR(ac), wlc->wme_retries[ac]);
+	}
+}
+
+/* Get or set an iovar.  The params/p_len pair specifies any additional
+ * qualifying parameters (e.g. an "element index") for a get, while the
+ * arg/len pair is the buffer for the value to be set or retrieved.
+ * Operation (get/set) is specified by the last argument.
+ * interface context provided by wlcif
+ *
+ * All pointers may point into the same buffer.
+ */
+int
+wlc_iovar_op(wlc_info_t * wlc, const char *name,
+	     void *params, int p_len, void *arg, int len,
+	     bool set, struct wlc_if *wlcif)
+{
+	int err = 0;
+	int val_size;
+	const bcm_iovar_t *vi = NULL;
+	uint32 actionid;
+	int i;
+
+	ASSERT(name != NULL);
+
+	ASSERT(len >= 0);
+
+	/* Get MUST have return space */
+	ASSERT(set || (arg && len));
+
+	ASSERT(!(wlc->pub->hw_off && wlc->pub->up));
+
+	/* Set does NOT take qualifiers */
+	ASSERT(!set || (!params && !p_len));
+
+	if (!set && (len == sizeof(int)) &&
+	    !(ISALIGNED((uintptr) (arg), (uint) sizeof(int)))) {
+		WL_ERROR(("wl%d: %s unaligned get ptr for %s\n",
+			  wlc->pub->unit, __func__, name));
+		ASSERT(0);
+	}
+
+	/* find the given iovar name */
+	for (i = 0; i < WLC_MAXMODULES; i++) {
+		if (!wlc->modulecb[i].iovars)
+			continue;
+		if ((vi = wlc_iovar_lookup(wlc->modulecb[i].iovars, name)))
+			break;
+	}
+	/* iovar name not found */
+	if (i >= WLC_MAXMODULES) {
+		err = BCME_UNSUPPORTED;
+#ifdef WLC_HIGH_ONLY
+		err =
+		    bcmsdh_iovar_op(wlc->btparam, name, params, p_len, arg, len,
+				    set);
+#endif
+		goto exit;
+	}
+
+	/* set up 'params' pointer in case this is a set command so that
+	 * the convenience int and bool code can be common to set and get
+	 */
+	if (params == NULL) {
+		params = arg;
+		p_len = len;
+	}
+
+	if (vi->type == IOVT_VOID)
+		val_size = 0;
+	else if (vi->type == IOVT_BUFFER)
+		val_size = len;
+	else
+		/* all other types are integer sized */
+		val_size = sizeof(int);
+
+	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);
+
+	/* Do the actual parameter implementation */
+	err = wlc->modulecb[i].iovar_fn(wlc->modulecb[i].hdl, vi, actionid,
+					name, params, p_len, arg, len, val_size,
+					wlcif);
+
+ exit:
+	return err;
+}
+
+int
+wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg, int len,
+		bool set)
+{
+	wlc_info_t *wlc = (wlc_info_t *) pub->wlc;
+	int err = 0;
+	int32 int_val = 0;
+
+	/* check generic condition flags */
+	if (set) {
+		if (((vi->flags & IOVF_SET_DOWN) && wlc->pub->up) ||
+		    ((vi->flags & IOVF_SET_UP) && !wlc->pub->up)) {
+			err = (wlc->pub->up ? BCME_NOTDOWN : BCME_NOTUP);
+		} else if ((vi->flags & IOVF_SET_BAND)
+			   && IS_MBAND_UNLOCKED(wlc)) {
+			err = BCME_NOTBANDLOCKED;
+		} else if ((vi->flags & IOVF_SET_CLK) && !wlc->clk) {
+			err = BCME_NOCLK;
+		}
+	} else {
+		if (((vi->flags & IOVF_GET_DOWN) && wlc->pub->up) ||
+		    ((vi->flags & IOVF_GET_UP) && !wlc->pub->up)) {
+			err = (wlc->pub->up ? BCME_NOTDOWN : BCME_NOTUP);
+		} else if ((vi->flags & IOVF_GET_BAND)
+			   && IS_MBAND_UNLOCKED(wlc)) {
+			err = BCME_NOTBANDLOCKED;
+		} else if ((vi->flags & IOVF_GET_CLK) && !wlc->clk) {
+			err = BCME_NOCLK;
+		}
+	}
+
+	if (err)
+		goto exit;
+
+	/* length check on io buf */
+	if ((err = bcm_iovar_lencheck(vi, arg, len, set)))
+		goto exit;
+
+	/* On set, check value ranges for integer types */
+	if (set) {
+		switch (vi->type) {
+		case IOVT_BOOL:
+		case IOVT_INT8:
+		case IOVT_INT16:
+		case IOVT_INT32:
+		case IOVT_UINT8:
+		case IOVT_UINT16:
+		case IOVT_UINT32:
+			bcopy(arg, &int_val, sizeof(int));
+			err = wlc_iovar_rangecheck(wlc, int_val, vi);
+			break;
+		}
+	}
+ exit:
+	return err;
+}
+
+/* handler for iovar table wlc_iovars */
+/*
+ * IMPLEMENTATION NOTE: In order to avoid checking for get/set in each
+ * iovar case, the switch statement maps the iovar id into separate get
+ * and set values.  If you add a new iovar to the switch you MUST use
+ * IOV_GVAL and/or IOV_SVAL in the case labels to avoid conflict with
+ * another case.
+ * Please use params for additional qualifying parameters.
+ */
+int
+wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
+	    const char *name, void *params, uint p_len, void *arg, int len,
+	    int val_size, struct wlc_if *wlcif)
+{
+	wlc_info_t *wlc = hdl;
+	wlc_bsscfg_t *bsscfg;
+	int err = 0;
+	int32 int_val = 0;
+	int32 int_val2 = 0;
+	int32 *ret_int_ptr;
+	bool bool_val;
+	bool bool_val2;
+	wlc_bss_info_t *current_bss;
+
+	WL_TRACE(("wl%d: %s\n", wlc->pub->unit, __func__));
+
+	bsscfg = NULL;
+	current_bss = NULL;
+
+	if ((err =
+	     wlc_iovar_check(wlc->pub, vi, arg, len, IOV_ISSET(actionid))) != 0)
+		return err;
+
+	/* convenience int and bool vals for first 8 bytes of buffer */
+	if (p_len >= (int)sizeof(int_val))
+		bcopy(params, &int_val, sizeof(int_val));
+
+	if (p_len >= (int)sizeof(int_val) * 2)
+		bcopy((void *)((uintptr) params + sizeof(int_val)), &int_val2,
+		      sizeof(int_val));
+
+	/* convenience int ptr for 4-byte gets (requires int aligned arg) */
+	ret_int_ptr = (int32 *) arg;
+
+	bool_val = (int_val != 0) ? TRUE : FALSE;
+	bool_val2 = (int_val2 != 0) ? TRUE : FALSE;
+
+	WL_TRACE(("wl%d: %s: id %d\n", wlc->pub->unit, __func__,
+		  IOV_ID(actionid)));
+	/* Do the actual parameter implementation */
+	switch (actionid) {
+
+	case IOV_GVAL(IOV_QTXPOWER):{
+			uint qdbm;
+			bool override;
+
+			if ((err =
+			     wlc_phy_txpower_get(wlc->band->pi, &qdbm,
+						 &override)) != BCME_OK)
+				return err;
+
+			/* Return qdbm units */
+			*ret_int_ptr =
+			    qdbm | (override ? WL_TXPWR_OVERRIDE : 0);
+			break;
+		}
+
+		/* As long as override is false, this only sets the *user* targets.
+		   User can twiddle this all he wants with no harm.
+		   wlc_phy_txpower_set() explicitly sets override to false if
+		   not internal or test.
+		 */
+	case IOV_SVAL(IOV_QTXPOWER):{
+			uint8 qdbm;
+			bool override;
+
+			/* Remove override bit and clip to max qdbm value */
+			qdbm =
+			    (uint8) MIN((int_val & ~WL_TXPWR_OVERRIDE), 0xff);
+			/* Extract override setting */
+			override = (int_val & WL_TXPWR_OVERRIDE) ? TRUE : FALSE;
+			err =
+			    wlc_phy_txpower_set(wlc->band->pi, qdbm, override);
+			break;
+		}
+
+	case IOV_GVAL(IOV_MPC):
+		*ret_int_ptr = (int32) wlc->mpc;
+		break;
+
+	case IOV_SVAL(IOV_MPC):
+		wlc->mpc = bool_val;
+		wlc_radio_mpc_upd(wlc);
+
+		break;
+
+	case IOV_GVAL(IOV_BCN_LI_BCN):
+		*ret_int_ptr = wlc->bcn_li_bcn;
+		break;
+
+	case IOV_SVAL(IOV_BCN_LI_BCN):
+		wlc->bcn_li_bcn = (uint8) int_val;
+		if (wlc->pub->up)
+			wlc_bcn_li_upd(wlc);
+		break;
+
+	default:
+		WL_ERROR(("wl%d: %s: unsupported\n", wlc->pub->unit, __func__));
+		err = BCME_UNSUPPORTED;
+		break;
+	}
+
+	goto exit;		/* avoid unused label warning */
+
+ exit:
+	return err;
+}
+
+static int
+wlc_iovar_rangecheck(wlc_info_t * wlc, uint32 val, const bcm_iovar_t * vi)
+{
+	int err = 0;
+	uint32 min_val = 0;
+	uint32 max_val = 0;
+
+	/* Only ranged integers are checked */
+	switch (vi->type) {
+	case IOVT_INT32:
+		max_val |= 0x7fffffff;
+		/* fall through */
+	case IOVT_INT16:
+		max_val |= 0x00007fff;
+		/* fall through */
+	case IOVT_INT8:
+		max_val |= 0x0000007f;
+		min_val = ~max_val;
+		if (vi->flags & IOVF_NTRL)
+			min_val = 1;
+		else if (vi->flags & IOVF_WHL)
+			min_val = 0;
+		/* Signed values are checked against max_val and min_val */
+		if ((int32) val < (int32) min_val
+		    || (int32) val > (int32) max_val)
+			err = BCME_RANGE;
+		break;
+
+	case IOVT_UINT32:
+		max_val |= 0xffffffff;
+		/* fall through */
+	case IOVT_UINT16:
+		max_val |= 0x0000ffff;
+		/* fall through */
+	case IOVT_UINT8:
+		max_val |= 0x000000ff;
+		if (vi->flags & IOVF_NTRL)
+			min_val = 1;
+		if ((val < min_val) || (val > max_val))
+			err = BCME_RANGE;
+		break;
+	}
+
+	return err;
+}
+
+#if defined(BCMDBG)
+static const struct wlc_id_name_entry dot11_ie_names[] = {
+	{DOT11_MNG_SSID_ID, "SSID"},
+	{DOT11_MNG_RATES_ID, "Rates"},
+	{DOT11_MNG_FH_PARMS_ID, "FH Parms"},
+	{DOT11_MNG_DS_PARMS_ID, "DS Parms"},
+	{DOT11_MNG_CF_PARMS_ID, "CF Parms"},
+	{DOT11_MNG_TIM_ID, "TIM"},
+	{DOT11_MNG_IBSS_PARMS_ID, "IBSS Parms"},
+	{DOT11_MNG_COUNTRY_ID, "Country"},
+	{DOT11_MNG_HOPPING_PARMS_ID, "Hopping Parms"},
+	{DOT11_MNG_HOPPING_TABLE_ID, "Hopping Table"},
+	{DOT11_MNG_REQUEST_ID, "Request"},
+	{DOT11_MNG_QBSS_LOAD_ID, "QBSS LOAD"},
+	{DOT11_MNG_CHALLENGE_ID, "Challenge"},
+	{DOT11_MNG_PWR_CONSTRAINT_ID, "Pwr Constraint"},
+	{DOT11_MNG_PWR_CAP_ID, "Pwr Capability"},
+	{DOT11_MNG_TPC_REQUEST_ID, "TPC Request"},
+	{DOT11_MNG_TPC_REPORT_ID, "TPC Report"},
+	{DOT11_MNG_SUPP_CHANNELS_ID, "Supported Channels"},
+	{DOT11_MNG_CHANNEL_SWITCH_ID, "Channel Switch"},
+	{DOT11_MNG_MEASURE_REQUEST_ID, "Measure Request"},
+	{DOT11_MNG_MEASURE_REPORT_ID, "Measure Report"},
+	{DOT11_MNG_QUIET_ID, "Quiet"},
+	{DOT11_MNG_IBSS_DFS_ID, "IBSS DFS"},
+	{DOT11_MNG_ERP_ID, "ERP Info"},
+	{DOT11_MNG_TS_DELAY_ID, "TS Delay"},
+	{DOT11_MNG_HT_CAP, "HT Capability"},
+	{DOT11_MNG_NONERP_ID, "Legacy ERP Info"},
+	{DOT11_MNG_RSN_ID, "RSN"},
+	{DOT11_MNG_EXT_RATES_ID, "Ext Rates"},
+	{DOT11_MNG_HT_ADD, "HT Additional"},
+	{DOT11_MNG_EXT_CHANNEL_OFFSET, "Ext Channel Offset"},
+	{DOT11_MNG_VS_ID, "Vendor Specific"},
+	{0, NULL}
+};
+#endif				/* defined(BCMDBG) */
+
+#ifdef BCMDBG
+static const char *supr_reason[] = {
+	"None", "PMQ Entry", "Flush request",
+	"Previous frag failure", "Channel mismatch",
+	"Lifetime Expiry", "Underflow"
+};
+
+static void wlc_print_txs_status(uint16 s)
+{
+	printf("[15:12]  %d  frame attempts\n", (s & TX_STATUS_FRM_RTX_MASK) >>
+	       TX_STATUS_FRM_RTX_SHIFT);
+	printf(" [11:8]  %d  rts attempts\n", (s & TX_STATUS_RTS_RTX_MASK) >>
+	       TX_STATUS_RTS_RTX_SHIFT);
+	printf("    [7]  %d  PM mode indicated\n",
+	       ((s & TX_STATUS_PMINDCTD) ? 1 : 0));
+	printf("    [6]  %d  intermediate status\n",
+	       ((s & TX_STATUS_INTERMEDIATE) ? 1 : 0));
+	printf("    [5]  %d  AMPDU\n", (s & TX_STATUS_AMPDU) ? 1 : 0);
+	printf("  [4:2]  %d  Frame Suppressed Reason (%s)\n",
+	       ((s & TX_STATUS_SUPR_MASK) >> TX_STATUS_SUPR_SHIFT),
+	       supr_reason[(s & TX_STATUS_SUPR_MASK) >> TX_STATUS_SUPR_SHIFT]);
+	printf("    [1]  %d  acked\n", ((s & TX_STATUS_ACK_RCV) ? 1 : 0));
+}
+#endif				/* BCMDBG */
+
+void wlc_print_txstatus(tx_status_t * txs)
+{
+#if defined(BCMDBG)
+	uint16 s = txs->status;
+	uint16 ackphyrxsh = txs->ackphyrxsh;
+
+	printf("\ntxpkt (MPDU) Complete\n");
+
+	printf("FrameID: %04x   ", txs->frameid);
+	printf("TxStatus: %04x", s);
+	printf("\n");
+#ifdef BCMDBG
+	wlc_print_txs_status(s);
+#endif
+	printf("LastTxTime: %04x ", txs->lasttxtime);
+	printf("Seq: %04x ", txs->sequence);
+	printf("PHYTxStatus: %04x ", txs->phyerr);
+	printf("RxAckRSSI: %04x ",
+	       (ackphyrxsh & PRXS1_JSSI_MASK) >> PRXS1_JSSI_SHIFT);
+	printf("RxAckSQ: %04x", (ackphyrxsh & PRXS1_SQ_MASK) >> PRXS1_SQ_SHIFT);
+	printf("\n");
+#endif				/* defined(BCMDBG) */
+}
+
+#define MACSTATUPD(name) \
+	wlc_ctrupd_cache(macstats.name, &wlc->core->macstat_snapshot->name, &wlc->pub->_cnt->name)
+
+void wlc_statsupd(wlc_info_t * wlc)
+{
+	int i;
+#ifdef BCMDBG
+	uint16 delta;
+	uint16 rxf0ovfl;
+	uint16 txfunfl[NFIFO];
+#endif				/* BCMDBG */
+
+	/* if driver down, make no sense to update stats */
+	if (!wlc->pub->up)
+		return;
+
+#ifdef BCMDBG
+	/* save last rx fifo 0 overflow count */
+	rxf0ovfl = wlc->core->macstat_snapshot->rxf0ovfl;
+
+	/* save last tx fifo  underflow count */
+	for (i = 0; i < NFIFO; i++)
+		txfunfl[i] = wlc->core->macstat_snapshot->txfunfl[i];
+#endif				/* BCMDBG */
+
+#ifdef BCMDBG
+	/* check for rx fifo 0 overflow */
+	delta = (uint16) (wlc->core->macstat_snapshot->rxf0ovfl - rxf0ovfl);
+	if (delta)
+		WL_ERROR(("wl%d: %u rx fifo 0 overflows!\n", wlc->pub->unit,
+			  delta));
+
+	/* check for tx fifo underflows */
+	for (i = 0; i < NFIFO; i++) {
+		delta =
+		    (uint16) (wlc->core->macstat_snapshot->txfunfl[i] -
+			      txfunfl[i]);
+		if (delta)
+			WL_ERROR(("wl%d: %u tx fifo %d underflows!\n",
+				  wlc->pub->unit, delta, i));
+	}
+#endif				/* BCMDBG */
+
+	/* dot11 counter update */
+
+	WLCNTSET(wlc->pub->_cnt->txrts,
+		 (wlc->pub->_cnt->rxctsucast -
+		  wlc->pub->_cnt->d11cnt_txrts_off));
+	WLCNTSET(wlc->pub->_cnt->rxcrc,
+		 (wlc->pub->_cnt->rxbadfcs - wlc->pub->_cnt->d11cnt_rxcrc_off));
+	WLCNTSET(wlc->pub->_cnt->txnocts,
+		 ((wlc->pub->_cnt->txrtsfrm - wlc->pub->_cnt->rxctsucast) -
+		  wlc->pub->_cnt->d11cnt_txnocts_off));
+
+	/* merge counters from dma module */
+	for (i = 0; i < NFIFO; i++) {
+		if (wlc->hw->di[i]) {
+			WLCNTADD(wlc->pub->_cnt->txnobuf,
+				 (wlc->hw->di[i])->txnobuf);
+			WLCNTADD(wlc->pub->_cnt->rxnobuf,
+				 (wlc->hw->di[i])->rxnobuf);
+			WLCNTADD(wlc->pub->_cnt->rxgiant,
+				 (wlc->hw->di[i])->rxgiants);
+			dma_counterreset(wlc->hw->di[i]);
+		}
+	}
+
+	/*
+	 * Aggregate transmit and receive errors that probably resulted
+	 * in the loss of a frame are computed on the fly.
+	 */
+	WLCNTSET(wlc->pub->_cnt->txerror,
+		 wlc->pub->_cnt->txnobuf + wlc->pub->_cnt->txnoassoc +
+		 wlc->pub->_cnt->txuflo + wlc->pub->_cnt->txrunt +
+		 wlc->pub->_cnt->dmade + wlc->pub->_cnt->dmada +
+		 wlc->pub->_cnt->dmape);
+	WLCNTSET(wlc->pub->_cnt->rxerror,
+		 wlc->pub->_cnt->rxoflo + wlc->pub->_cnt->rxnobuf +
+		 wlc->pub->_cnt->rxfragerr + wlc->pub->_cnt->rxrunt +
+		 wlc->pub->_cnt->rxgiant + wlc->pub->_cnt->rxnoscb +
+		 wlc->pub->_cnt->rxbadsrcmac);
+	for (i = 0; i < NFIFO; i++)
+		WLCNTADD(wlc->pub->_cnt->rxerror, wlc->pub->_cnt->rxuflo[i]);
+}
+
+bool wlc_chipmatch(uint16 vendor, uint16 device)
+{
+	if (vendor != VENDOR_BROADCOM) {
+		WL_ERROR(("wlc_chipmatch: unknown vendor id %04x\n", vendor));
+		return (FALSE);
+	}
+
+	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))
+		return (TRUE);
+
+	if (device == BCM4313_D11N2G_ID)
+		return (TRUE);
+	if ((device == BCM43236_D11N_ID) || (device == BCM43236_D11N2G_ID))
+		return (TRUE);
+
+	WL_ERROR(("wlc_chipmatch: unknown device id %04x\n", device));
+	return (FALSE);
+}
+
+#if defined(BCMDBG)
+static const char *errstr = "802.11 Header INCOMPLETE\n";
+static const char *fillstr = "------------";
+static void wlc_print_dot11hdr(uint8 * buf, int len)
+{
+	char hexbuf[(2 * D11B_PHY_HDR_LEN) + 1];
+
+	if (len == 0) {
+		printf("802.11 Header MISSING\n");
+		return;
+	}
+
+	if (len < D11B_PHY_HDR_LEN) {
+		bcm_format_hex(hexbuf, buf, len);
+		strncpy(hexbuf + (2 * len), fillstr,
+			2 * (D11B_PHY_HDR_LEN - len));
+		hexbuf[sizeof(hexbuf) - 1] = '\0';
+	} else {
+		bcm_format_hex(hexbuf, buf, D11B_PHY_HDR_LEN);
+	}
+
+	printf("PLCPHdr: %s ", hexbuf);
+	if (len < D11B_PHY_HDR_LEN) {
+		printf("%s\n", errstr);
+		return;
+	}
+
+	len -= D11B_PHY_HDR_LEN;
+	buf += D11B_PHY_HDR_LEN;
+
+	wlc_print_dot11_mac_hdr(buf, len);
+}
+
+void wlc_print_dot11_mac_hdr(uint8 * buf, int len)
+{
+	char hexbuf[(2 * D11B_PHY_HDR_LEN) + 1];
+	char a1[(2 * ETHER_ADDR_LEN) + 1], a2[(2 * ETHER_ADDR_LEN) + 1];
+	char a3[(2 * ETHER_ADDR_LEN) + 1];
+	char flagstr[64];
+	uint16 fc, kind, toDS, fromDS;
+	uint16 v;
+	int fill_len = 0;
+	static const bcm_bit_desc_t fc_flags[] = {
+		{FC_TODS, "ToDS"},
+		{FC_FROMDS, "FromDS"},
+		{FC_MOREFRAG, "MoreFrag"},
+		{FC_RETRY, "Retry"},
+		{FC_PM, "PM"},
+		{FC_MOREDATA, "MoreData"},
+		{FC_WEP, "WEP"},
+		{FC_ORDER, "Order"},
+		{0, NULL}
+	};
+
+	if (len < 2) {
+		printf("FC: ------ ");
+		printf("%s\n", errstr);
+		return;
+	}
+
+	fc = buf[0] | (buf[1] << 8);
+	kind = fc & FC_KIND_MASK;
+	toDS = (fc & FC_TODS) != 0;
+	fromDS = (fc & FC_FROMDS) != 0;
+
+	bcm_format_flags(fc_flags, fc, flagstr, 64);
+
+	printf("FC: 0x%04x ", fc);
+	if (flagstr[0] != '\0')
+		printf("(%s) ", flagstr);
+
+	len -= 2;
+	buf += 2;
+
+	if (len < 2) {
+		printf("Dur/AID: ----- ");
+		printf("%s\n", errstr);
+		return;
+	}
+
+	v = buf[0] | (buf[1] << 8);
+	if (kind == FC_PS_POLL) {
+		printf("AID: 0x%04x", v);
+	} else {
+		printf("Dur: 0x%04x", v);
+	}
+	printf("\n");
+	len -= 2;
+	buf += 2;
+
+	strncpy(a1, fillstr, sizeof(a1));
+	strncpy(a2, fillstr, sizeof(a2));
+	strncpy(a3, fillstr, sizeof(a3));
+
+	if (len < ETHER_ADDR_LEN) {
+		bcm_format_hex(a1, buf, len);
+		strncpy(a1 + (2 * len), fillstr, 2 * (ETHER_ADDR_LEN - len));
+	} else if (len < 2 * ETHER_ADDR_LEN) {
+		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
+		bcm_format_hex(a2, buf + ETHER_ADDR_LEN, len - ETHER_ADDR_LEN);
+		fill_len = len - ETHER_ADDR_LEN;
+		strncpy(a2 + (2 * fill_len), fillstr,
+			2 * (ETHER_ADDR_LEN - fill_len));
+	} else if (len < 3 * ETHER_ADDR_LEN) {
+		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
+		bcm_format_hex(a2, buf + ETHER_ADDR_LEN, ETHER_ADDR_LEN);
+		bcm_format_hex(a3, buf + (2 * ETHER_ADDR_LEN),
+			       len - (2 * ETHER_ADDR_LEN));
+		fill_len = len - (2 * ETHER_ADDR_LEN);
+		strncpy(a3 + (2 * fill_len), fillstr,
+			2 * (ETHER_ADDR_LEN - fill_len));
+	} else {
+		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
+		bcm_format_hex(a2, buf + ETHER_ADDR_LEN, ETHER_ADDR_LEN);
+		bcm_format_hex(a3, buf + (2 * ETHER_ADDR_LEN), ETHER_ADDR_LEN);
+	}
+
+	if (kind == FC_RTS) {
+		printf("RA: %s ", a1);
+		printf("TA: %s ", a2);
+		if (len < 2 * ETHER_ADDR_LEN)
+			printf("%s ", errstr);
+	} else if (kind == FC_CTS || kind == FC_ACK) {
+		printf("RA: %s ", a1);
+		if (len < ETHER_ADDR_LEN)
+			printf("%s ", errstr);
+	} else if (kind == FC_PS_POLL) {
+		printf("BSSID: %s", a1);
+		printf("TA: %s ", a2);
+		if (len < 2 * ETHER_ADDR_LEN)
+			printf("%s ", errstr);
+	} else if (kind == FC_CF_END || kind == FC_CF_END_ACK) {
+		printf("RA: %s ", a1);
+		printf("BSSID: %s ", a2);
+		if (len < 2 * ETHER_ADDR_LEN)
+			printf("%s ", errstr);
+	} else if (FC_TYPE(fc) == FC_TYPE_DATA) {
+		if (!toDS) {
+			printf("DA: %s ", a1);
+			if (!fromDS) {
+				printf("SA: %s ", a2);
+				printf("BSSID: %s ", a3);
+			} else {
+				printf("BSSID: %s ", a2);
+				printf("SA: %s ", a3);
+			}
+		} else if (!fromDS) {
+			printf("BSSID: %s ", a1);
+			printf("SA: %s ", a2);
+			printf("DA: %s ", a3);
+		} else {
+			printf("RA: %s ", a1);
+			printf("TA: %s ", a2);
+			printf("DA: %s ", a3);
+		}
+		if (len < 3 * ETHER_ADDR_LEN) {
+			printf("%s ", errstr);
+		} else if (len < 20) {
+			printf("SeqCtl: ------ ");
+			printf("%s ", errstr);
+		} else {
+			len -= 3 * ETHER_ADDR_LEN;
+			buf += 3 * ETHER_ADDR_LEN;
+			v = buf[0] | (buf[1] << 8);
+			printf("SeqCtl: 0x%04x ", v);
+			len -= 2;
+			buf += 2;
+		}
+	} else if (FC_TYPE(fc) == FC_TYPE_MNG) {
+		printf("DA: %s ", a1);
+		printf("SA: %s ", a2);
+		printf("BSSID: %s ", a3);
+		if (len < 3 * ETHER_ADDR_LEN) {
+			printf("%s ", errstr);
+		} else if (len < 20) {
+			printf("SeqCtl: ------ ");
+			printf("%s ", errstr);
+		} else {
+			len -= 3 * ETHER_ADDR_LEN;
+			buf += 3 * ETHER_ADDR_LEN;
+			v = buf[0] | (buf[1] << 8);
+			printf("SeqCtl: 0x%04x ", v);
+			len -= 2;
+			buf += 2;
+		}
+	}
+
+	if ((FC_TYPE(fc) == FC_TYPE_DATA) && toDS && fromDS) {
+
+		if (len < ETHER_ADDR_LEN) {
+			bcm_format_hex(hexbuf, buf, len);
+			strncpy(hexbuf + (2 * len), fillstr,
+				2 * (ETHER_ADDR_LEN - len));
+		} else {
+			bcm_format_hex(hexbuf, buf, ETHER_ADDR_LEN);
+		}
+
+		printf("SA: %s ", hexbuf);
+
+		if (len < ETHER_ADDR_LEN) {
+			printf("%s ", errstr);
+		} else {
+			len -= ETHER_ADDR_LEN;
+			buf += ETHER_ADDR_LEN;
+		}
+	}
+
+	if ((FC_TYPE(fc) == FC_TYPE_DATA) && (kind == FC_QOS_DATA)) {
+		if (len < 2) {
+			printf("QoS: ------");
+			printf("%s ", errstr);
+		} else {
+			v = buf[0] | (buf[1] << 8);
+			printf("QoS: 0x%04x ", v);
+			len -= 2;
+			buf += 2;
+		}
+	}
+
+	printf("\n");
+	return;
+}
+#endif				/* defined(BCMDBG) */
+
+#if defined(BCMDBG)
+void wlc_print_txdesc(d11txh_t * txh)
+{
+	uint16 mtcl = ltoh16(txh->MacTxControlLow);
+	uint16 mtch = ltoh16(txh->MacTxControlHigh);
+	uint16 mfc = ltoh16(txh->MacFrameControl);
+	uint16 tfest = ltoh16(txh->TxFesTimeNormal);
+	uint16 ptcw = ltoh16(txh->PhyTxControlWord);
+	uint16 ptcw_1 = ltoh16(txh->PhyTxControlWord_1);
+	uint16 ptcw_1_Fbr = ltoh16(txh->PhyTxControlWord_1_Fbr);
+	uint16 ptcw_1_Rts = ltoh16(txh->PhyTxControlWord_1_Rts);
+	uint16 ptcw_1_FbrRts = ltoh16(txh->PhyTxControlWord_1_FbrRts);
+	uint16 mainrates = ltoh16(txh->MainRates);
+	uint16 xtraft = ltoh16(txh->XtraFrameTypes);
+	uint8 *iv = txh->IV;
+	uint8 *ra = txh->TxFrameRA;
+	uint16 tfestfb = ltoh16(txh->TxFesTimeFallback);
+	uint8 *rtspfb = txh->RTSPLCPFallback;
+	uint16 rtsdfb = ltoh16(txh->RTSDurFallback);
+	uint8 *fragpfb = txh->FragPLCPFallback;
+	uint16 fragdfb = ltoh16(txh->FragDurFallback);
+	uint16 mmodelen = ltoh16(txh->MModeLen);
+	uint16 mmodefbrlen = ltoh16(txh->MModeFbrLen);
+	uint16 tfid = ltoh16(txh->TxFrameID);
+	uint16 txs = ltoh16(txh->TxStatus);
+	uint16 mnmpdu = ltoh16(txh->MaxNMpdus);
+	uint16 mabyte = ltoh16(txh->MaxABytes_MRT);
+	uint16 mabyte_f = ltoh16(txh->MaxABytes_FBR);
+	uint16 mmbyte = ltoh16(txh->MinMBytes);
+
+	uint8 *rtsph = txh->RTSPhyHeader;
+	struct dot11_rts_frame rts = txh->rts_frame;
+	char hexbuf[256];
+
+	/* add plcp header along with txh descriptor */
+	prhex("Raw TxDesc + plcp header", (uchar *) txh, sizeof(d11txh_t) + 48);
+
+	printf("TxCtlLow: %04x ", mtcl);
+	printf("TxCtlHigh: %04x ", mtch);
+	printf("FC: %04x ", mfc);
+	printf("FES Time: %04x\n", tfest);
+	printf("PhyCtl: %04x%s ", ptcw,
+	       (ptcw & PHY_TXC_SHORT_HDR) ? " short" : "");
+	printf("PhyCtl_1: %04x ", ptcw_1);
+	printf("PhyCtl_1_Fbr: %04x\n", ptcw_1_Fbr);
+	printf("PhyCtl_1_Rts: %04x ", ptcw_1_Rts);
+	printf("PhyCtl_1_Fbr_Rts: %04x\n", ptcw_1_FbrRts);
+	printf("MainRates: %04x ", mainrates);
+	printf("XtraFrameTypes: %04x ", xtraft);
+	printf("\n");
+
+	bcm_format_hex(hexbuf, iv, sizeof(txh->IV));
+	printf("SecIV:       %s\n", hexbuf);
+	bcm_format_hex(hexbuf, ra, sizeof(txh->TxFrameRA));
+	printf("RA:          %s\n", hexbuf);
+
+	printf("Fb FES Time: %04x ", tfestfb);
+	bcm_format_hex(hexbuf, rtspfb, sizeof(txh->RTSPLCPFallback));
+	printf("RTS PLCP: %s ", hexbuf);
+	printf("RTS DUR: %04x ", rtsdfb);
+	bcm_format_hex(hexbuf, fragpfb, sizeof(txh->FragPLCPFallback));
+	printf("PLCP: %s ", hexbuf);
+	printf("DUR: %04x", fragdfb);
+	printf("\n");
+
+	printf("MModeLen: %04x ", mmodelen);
+	printf("MModeFbrLen: %04x\n", mmodefbrlen);
+
+	printf("FrameID:     %04x\n", tfid);
+	printf("TxStatus:    %04x\n", txs);
+
+	printf("MaxNumMpdu:  %04x\n", mnmpdu);
+	printf("MaxAggbyte:  %04x\n", mabyte);
+	printf("MaxAggbyte_fb:  %04x\n", mabyte_f);
+	printf("MinByte:     %04x\n", mmbyte);
+
+	bcm_format_hex(hexbuf, rtsph, sizeof(txh->RTSPhyHeader));
+	printf("RTS PLCP: %s ", hexbuf);
+	bcm_format_hex(hexbuf, (uint8 *) & rts, sizeof(txh->rts_frame));
+	printf("RTS Frame: %s", hexbuf);
+	printf("\n");
+
+	if (mtcl & TXC_SENDRTS) {
+		wlc_print_dot11_mac_hdr((uint8 *) & rts,
+					sizeof(txh->rts_frame));
+	}
+}
+#endif				/* defined(BCMDBG) */
+
+#if defined(BCMDBG)
+void wlc_print_rxh(d11rxhdr_t * rxh)
+{
+	uint16 len = rxh->RxFrameSize;
+	uint16 phystatus_0 = rxh->PhyRxStatus_0;
+	uint16 phystatus_1 = rxh->PhyRxStatus_1;
+	uint16 phystatus_2 = rxh->PhyRxStatus_2;
+	uint16 phystatus_3 = rxh->PhyRxStatus_3;
+	uint16 macstatus1 = rxh->RxStatus1;
+	uint16 macstatus2 = rxh->RxStatus2;
+	char flagstr[64];
+	char lenbuf[20];
+	static const bcm_bit_desc_t macstat_flags[] = {
+		{RXS_FCSERR, "FCSErr"},
+		{RXS_RESPFRAMETX, "Reply"},
+		{RXS_PBPRES, "PADDING"},
+		{RXS_DECATMPT, "DeCr"},
+		{RXS_DECERR, "DeCrErr"},
+		{RXS_BCNSENT, "Bcn"},
+		{0, NULL}
+	};
+
+	prhex("Raw RxDesc", (uchar *) rxh, sizeof(d11rxhdr_t));
+
+	bcm_format_flags(macstat_flags, macstatus1, flagstr, 64);
+
+	snprintf(lenbuf, sizeof(lenbuf), "0x%x", len);
+
+	printf("RxFrameSize:     %6s (%d)%s\n", lenbuf, len,
+	       (rxh->PhyRxStatus_0 & PRXS0_SHORTH) ? " short preamble" : "");
+	printf("RxPHYStatus:     %04x %04x %04x %04x\n",
+	       phystatus_0, phystatus_1, phystatus_2, phystatus_3);
+	printf("RxMACStatus:     %x %s\n", macstatus1, flagstr);
+	printf("RXMACaggtype: %x\n", (macstatus2 & RXS_AGGTYPE_MASK));
+	printf("RxTSFTime:       %04x\n", rxh->RxTSFTime);
+}
+
+void
+wlc_print_hdrs(wlc_info_t * wlc, const char *prefix, uint8 * frame,
+	       d11txh_t * txh, d11rxhdr_t * rxh, uint len)
+{
+	ASSERT(!(txh && rxh));
+
+	printf("\nwl%d: %s:\n", wlc->pub->unit, prefix);
+
+	if (txh) {
+		wlc_print_txdesc(txh);
+	} else if (rxh) {
+		wlc_print_rxh(rxh);
+	}
+
+	if (len > 0) {
+		ASSERT(frame != NULL);
+		wlc_print_dot11hdr(frame, len);
+	}
+}
+#endif				/* defined(BCMDBG) */
+
+#if defined(BCMDBG)
+int wlc_format_ssid(char *buf, const uchar ssid[], uint ssid_len)
+{
+	uint i, c;
+	char *p = buf;
+	char *endp = buf + SSID_FMT_BUF_LEN;
+
+	if (ssid_len > DOT11_MAX_SSID_LEN)
+		ssid_len = DOT11_MAX_SSID_LEN;
+
+	for (i = 0; i < ssid_len; i++) {
+		c = (uint) ssid[i];
+		if (c == '\\') {
+			*p++ = '\\';
+			*p++ = '\\';
+		} else if (bcm_isprint((uchar) c)) {
+			*p++ = (char)c;
+		} else {
+			p += snprintf(p, (endp - p), "\\x%02X", c);
+		}
+	}
+	*p = '\0';
+	ASSERT(p < endp);
+
+	return (int)(p - buf);
+}
+#endif				/* defined(BCMDBG) */
+
+uint16 wlc_rate_shm_offset(wlc_info_t * wlc, uint8 rate)
+{
+	return (wlc_bmac_rate_shm_offset(wlc->hw, rate));
+}
+
+/* Callback for device removed */
+#if defined(WLC_HIGH_ONLY)
+void wlc_device_removed(void *arg)
+{
+	wlc_info_t *wlc = (wlc_info_t *) arg;
+
+	wlc->device_present = FALSE;
+}
+#endif				/* WLC_HIGH_ONLY */
+
+/*
+ * Attempts to queue a packet onto a multiple-precedence queue,
+ * if necessary evicting a lower precedence packet from the queue.
+ *
+ * 'prec' is the precedence number that has already been mapped
+ * from the packet priority.
+ *
+ * Returns TRUE if packet consumed (queued), FALSE if not.
+ */
+bool BCMFASTPATH
+wlc_prec_enq(wlc_info_t * wlc, struct pktq *q, void *pkt, int prec)
+{
+	return wlc_prec_enq_head(wlc, q, pkt, prec, FALSE);
+}
+
+bool BCMFASTPATH
+wlc_prec_enq_head(wlc_info_t * wlc, struct pktq * q, void *pkt, int prec,
+		  bool head)
+{
+	void *p;
+	int eprec = -1;		/* precedence to evict from */
+
+	/* Determine precedence from which to evict packet, if any */
+	if (pktq_pfull(q, prec))
+		eprec = prec;
+	else if (pktq_full(q)) {
+		p = pktq_peek_tail(q, &eprec);
+		ASSERT(p != NULL);
+		if (eprec > prec) {
+			WL_ERROR(("%s: Failing: eprec %d > prec %d\n", __func__,
+				  eprec, prec));
+			return FALSE;
+		}
+	}
+
+	/* Evict if needed */
+	if (eprec >= 0) {
+		bool discard_oldest;
+
+		/* Detect queueing to unconfigured precedence */
+		ASSERT(!pktq_pempty(q, eprec));
+
+		discard_oldest = AC_BITMAP_TST(wlc->wme_dp, eprec);
+
+		/* Refuse newer packet unless configured to discard oldest */
+		if (eprec == prec && !discard_oldest) {
+			WL_ERROR(("%s: No where to go, prec == %d\n", __func__,
+				  prec));
+			return FALSE;
+		}
+
+		/* Evict packet according to discard policy */
+		p = discard_oldest ? pktq_pdeq(q, eprec) : pktq_pdeq_tail(q,
+									  eprec);
+		ASSERT(p != NULL);
+
+		/* Increment wme stats */
+		if (WME_ENAB(wlc->pub)) {
+			WLCNTINCR(wlc->pub->_wme_cnt->
+				  tx_failed[WME_PRIO2AC(PKTPRIO(p))].packets);
+			WLCNTADD(wlc->pub->_wme_cnt->
+				 tx_failed[WME_PRIO2AC(PKTPRIO(p))].bytes,
+				 pkttotlen(wlc->osh, p));
+		}
+
+		ASSERT(0);
+		PKTFREE(wlc->osh, p, TRUE);
+		WLCNTINCR(wlc->pub->_cnt->txnobuf);
+	}
+
+	/* Enqueue */
+	if (head)
+		p = pktq_penq_head(q, prec, pkt);
+	else
+		p = pktq_penq(q, prec, pkt);
+	ASSERT(p != NULL);
+
+	return TRUE;
+}
+
+void BCMFASTPATH wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec)
+{
+	wlc_info_t *wlc = (wlc_info_t *) ctx;
+	wlc_txq_info_t *qi = wlc->active_queue;	/* Check me */
+	struct pktq *q = &qi->q;
+	int prio;
+
+	prio = PKTPRIO(sdu);
+
+	ASSERT(pktq_max(q) >= wlc->pub->tunables->datahiwat);
+
+	if (!wlc_prec_enq(wlc, q, sdu, prec)) {
+		if (!EDCF_ENAB(wlc->pub)
+		    || (wlc->pub->wlfeatureflag & WL_SWFL_FLOWCONTROL))
+			WL_ERROR(("wl%d: wlc_txq_enq: txq overflow\n",
+				  wlc->pub->unit));
+
+		/* ASSERT(9 == 8); *//* XXX we might hit this condtion in case packet flooding from mac80211 stack */
+		PKTFREE(wlc->osh, sdu, TRUE);
+		WLCNTINCR(wlc->pub->_cnt->txnobuf);
+	}
+
+	/* Check if flow control needs to be turned on after enqueuing the packet
+	 *   Don't turn on flow control if EDCF is enabled. Driver would make the decision on what
+	 *   to drop instead of relying on stack to make the right decision
+	 */
+	if (!EDCF_ENAB(wlc->pub)
+	    || (wlc->pub->wlfeatureflag & WL_SWFL_FLOWCONTROL)) {
+		if (pktq_len(q) >= wlc->pub->tunables->datahiwat) {
+			wlc_txflowcontrol(wlc, qi, ON, ALLPRIO);
+		}
+	} else if (wlc->pub->_priofc) {
+		if (pktq_plen(q, wlc_prio2prec_map[prio]) >=
+		    wlc->pub->tunables->datahiwat) {
+			wlc_txflowcontrol(wlc, qi, ON, prio);
+		}
+	}
+}
+
+bool BCMFASTPATH
+wlc_sendpkt_mac80211(wlc_info_t * wlc, void *sdu, struct ieee80211_hw *hw)
+{
+	uint8 prio;
+	uint fifo;
+	void *pkt;
+	struct scb *scb = &global_scb;
+	struct dot11_header *d11_header = (struct dot11_header *)PKTDATA(sdu);
+	uint16 type, fc;
+
+	ASSERT(sdu);
+
+	fc = ltoh16(d11_header->fc);
+	type = FC_TYPE(fc);
+
+	/* 802.11 standard requires management traffic to go at highest priority */
+	prio = (type == FC_TYPE_DATA ? PKTPRIO(sdu) : MAXPRIO);
+	fifo = prio2fifo[prio];
+
+	ASSERT((uint) PKTHEADROOM(sdu) >= TXOFF);
+	ASSERT(!PKTSHARED(sdu));
+	ASSERT(!PKTNEXT(sdu));
+	ASSERT(!PKTLINK(sdu));
+	ASSERT(fifo < NFIFO);
+
+	pkt = sdu;
+	if (unlikely
+	    (wlc_d11hdrs_mac80211(wlc, hw, pkt, scb, 0, 1, fifo, 0, NULL, 0)))
+		return -EINVAL;
+	wlc_txq_enq(wlc, scb, pkt, WLC_PRIO_TO_PREC(prio));
+	wlc_send_q(wlc, wlc->active_queue);
+
+	WLCNTINCR(wlc->pub->_cnt->ieee_tx);
+	return 0;
+}
+
+void BCMFASTPATH wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi)
+{
+	void *pkt[DOT11_MAXNUMFRAGS];
+	int prec;
+	uint16 prec_map;
+	int err = 0, i, count;
+	uint fifo;
+	struct pktq *q = &qi->q;
+	struct ieee80211_tx_info *tx_info;
+
+	/* only do work for the active queue */
+	if (qi != wlc->active_queue)
+		return;
+
+	if (in_send_q)
+		return;
+	else
+		in_send_q = TRUE;
+
+	prec_map = wlc->tx_prec_map;
+
+	/* Send all the enq'd pkts that we can.
+	 * Dequeue packets with precedence with empty HW fifo only
+	 */
+	while (prec_map && (pkt[0] = pktq_mdeq(q, prec_map, &prec))) {
+		tx_info = IEEE80211_SKB_CB(pkt[0]);
+		if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {
+			err = wlc_sendampdu(wlc->ampdu, qi, pkt, prec);
+		} else {
+			count = 1;
+			err = wlc_prep_pdu(wlc, pkt[0], &fifo);
+			if (!err) {
+				for (i = 0; i < count; i++) {
+					wlc_txfifo(wlc, fifo, pkt[i], TRUE, 1);
+				}
+			}
+		}
+
+		if (err == BCME_BUSY) {
+			pktq_penq_head(q, prec, pkt[0]);
+			/* If send failed due to any other reason than a change in
+			 * HW FIFO condition, quit. Otherwise, read the new prec_map!
+			 */
+			if (prec_map == wlc->tx_prec_map)
+				break;
+			prec_map = wlc->tx_prec_map;
+		}
+	}
+
+	/* Check if flow control needs to be turned off after sending the packet */
+	if (!EDCF_ENAB(wlc->pub)
+	    || (wlc->pub->wlfeatureflag & WL_SWFL_FLOWCONTROL)) {
+		if (wlc_txflowcontrol_prio_isset(wlc, qi, ALLPRIO)
+		    && (pktq_len(q) < wlc->pub->tunables->datahiwat / 2)) {
+			wlc_txflowcontrol(wlc, qi, OFF, ALLPRIO);
+		}
+	} else if (wlc->pub->_priofc) {
+		int prio;
+		for (prio = MAXPRIO; prio >= 0; prio--) {
+			if (wlc_txflowcontrol_prio_isset(wlc, qi, prio) &&
+			    (pktq_plen(q, wlc_prio2prec_map[prio]) <
+			     wlc->pub->tunables->datahiwat / 2)) {
+				wlc_txflowcontrol(wlc, qi, OFF, prio);
+			}
+		}
+	}
+	in_send_q = FALSE;
+}
+
+/*
+ * bcmc_fid_generate:
+ * Generate frame ID for a BCMC packet.  The frag field is not used
+ * for MC frames so is used as part of the sequence number.
+ */
+static INLINE uint16
+bcmc_fid_generate(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg, d11txh_t * txh)
+{
+	uint16 frameid;
+
+	frameid = ltoh16(txh->TxFrameID) & ~(TXFID_SEQ_MASK | TXFID_QUEUE_MASK);
+	frameid |=
+	    (((wlc->
+	       mc_fid_counter++) << TXFID_SEQ_SHIFT) & TXFID_SEQ_MASK) |
+	    TX_BCMC_FIFO;
+
+	return frameid;
+}
+
+void BCMFASTPATH
+wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit, int8 txpktpend)
+{
+	uint16 frameid = INVALIDFID;
+	d11txh_t *txh;
+
+	ASSERT(fifo < NFIFO);
+	txh = (d11txh_t *) PKTDATA(p);
+
+	/* When a BC/MC frame is being committed to the BCMC fifo via DMA (NOT PIO), update
+	 * ucode or BSS info as appropriate.
+	 */
+	if (fifo == TX_BCMC_FIFO) {
+		frameid = ltoh16(txh->TxFrameID);
+
+	}
+
+	if (WLC_WAR16165(wlc))
+		wlc_war16165(wlc, TRUE);
+
+#ifdef WLC_HIGH_ONLY
+	if (RPCTX_ENAB(wlc->pub)) {
+		(void)wlc_rpctx_tx(wlc->rpctx, fifo, p, commit, frameid,
+				   txpktpend);
+		return;
+	}
+#else
+
+	/* Bump up pending count for if not using rpc. If rpc is used, this will be handled
+	 * in wlc_bmac_txfifo()
+	 */
+	if (commit) {
+		TXPKTPENDINC(wlc, fifo, txpktpend);
+		WL_TRACE(("wlc_txfifo, pktpend inc %d to %d\n", txpktpend,
+			  TXPKTPENDGET(wlc, fifo)));
+	}
+
+	/* Commit BCMC sequence number in the SHM frame ID location */
+	if (frameid != INVALIDFID)
+		BCMCFID(wlc, frameid);
+
+	if (dma_txfast(wlc->hw->di[fifo], p, commit) < 0) {
+		WL_ERROR(("wlc_txfifo: fatal, toss frames !!!\n"));
+	}
+#endif				/* WLC_HIGH_ONLY */
+}
+
+static uint16
+wlc_compute_airtime(wlc_info_t * wlc, ratespec_t rspec, uint length)
+{
+	uint16 usec = 0;
+	uint mac_rate = RSPEC2RATE(rspec);
+	uint nsyms;
+
+	if (IS_MCS(rspec)) {
+		/* not supported yet */
+		ASSERT(0);
+	} else if (IS_OFDM(rspec)) {
+		/* nsyms = Ceiling(Nbits / (Nbits/sym))
+		 *
+		 * Nbits = length * 8
+		 * Nbits/sym = Mbps * 4 = mac_rate * 2
+		 */
+		nsyms = CEIL((length * 8), (mac_rate * 2));
+
+		/* usec = symbols * usec/symbol */
+		usec = (uint16) (nsyms * APHY_SYMBOL_TIME);
+		return (usec);
+	} else {
+		switch (mac_rate) {
+		case WLC_RATE_1M:
+			usec = length << 3;
+			break;
+		case WLC_RATE_2M:
+			usec = length << 2;
+			break;
+		case WLC_RATE_5M5:
+			usec = (length << 4) / 11;
+			break;
+		case WLC_RATE_11M:
+			usec = (length << 3) / 11;
+			break;
+		default:
+			WL_ERROR(("wl%d: wlc_compute_airtime: unsupported rspec 0x%x\n", wlc->pub->unit, rspec));
+			ASSERT((const char *)"Bad phy_rate" == NULL);
+			break;
+		}
+	}
+
+	return (usec);
+}
+
+void BCMFASTPATH
+wlc_compute_plcp(wlc_info_t * wlc, ratespec_t rspec, uint length, uint8 * plcp)
+{
+	if (IS_MCS(rspec)) {
+		wlc_compute_mimo_plcp(rspec, length, plcp);
+	} else if (IS_OFDM(rspec)) {
+		wlc_compute_ofdm_plcp(rspec, length, plcp);
+	} else {
+		wlc_compute_cck_plcp(rspec, length, plcp);
+	}
+	return;
+}
+
+/* Rate: 802.11 rate code, length: PSDU length in octets */
+static void wlc_compute_mimo_plcp(ratespec_t rspec, uint length, uint8 * plcp)
+{
+	uint8 mcs = (uint8) (rspec & RSPEC_RATE_MASK);
+	ASSERT(IS_MCS(rspec));
+	plcp[0] = mcs;
+	if (RSPEC_IS40MHZ(rspec) || (mcs == 32))
+		plcp[0] |= MIMO_PLCP_40MHZ;
+	WLC_SET_MIMO_PLCP_LEN(plcp, length);
+	plcp[3] = RSPEC_MIMOPLCP3(rspec);	/* rspec already holds this byte */
+	plcp[3] |= 0x7;		/* set smoothing, not sounding ppdu & reserved */
+	plcp[4] = 0;		/* number of extension spatial streams bit 0 & 1 */
+	plcp[5] = 0;
+}
+
+/* Rate: 802.11 rate code, length: PSDU length in octets */
+static void BCMFASTPATH
+wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, uint8 * plcp)
+{
+	uint8 rate_signal;
+	uint32 tmp = 0;
+	int rate = RSPEC2RATE(rspec);
+
+	ASSERT(IS_OFDM(rspec));
+
+	/* encode rate per 802.11a-1999 sec 17.3.4.1, with lsb transmitted first */
+	rate_signal = rate_info[rate] & RATE_MASK;
+	ASSERT(rate_signal != 0);
+
+	bzero(plcp, D11_PHY_HDR_LEN);
+	D11A_PHY_HDR_SRATE((ofdm_phy_hdr_t *) plcp, rate_signal);
+
+	tmp = (length & 0xfff) << 5;
+	plcp[2] |= (tmp >> 16) & 0xff;
+	plcp[1] |= (tmp >> 8) & 0xff;
+	plcp[0] |= tmp & 0xff;
+
+	return;
+}
+
+/*
+ * Compute PLCP, but only requires actual rate and length of pkt.
+ * Rate is given in the driver standard multiple of 500 kbps.
+ * le is set for 11 Mbps rate if necessary.
+ * Broken out for PRQ.
+ */
+
+static void wlc_cck_plcp_set(int rate_500, uint length, uint8 * plcp)
+{
+	uint16 usec = 0;
+	uint8 le = 0;
+
+	switch (rate_500) {
+	case WLC_RATE_1M:
+		usec = length << 3;
+		break;
+	case WLC_RATE_2M:
+		usec = length << 2;
+		break;
+	case WLC_RATE_5M5:
+		usec = (length << 4) / 11;
+		if ((length << 4) - (usec * 11) > 0)
+			usec++;
+		break;
+	case WLC_RATE_11M:
+		usec = (length << 3) / 11;
+		if ((length << 3) - (usec * 11) > 0) {
+			usec++;
+			if ((usec * 11) - (length << 3) >= 8)
+				le = D11B_PLCP_SIGNAL_LE;
+		}
+		break;
+
+	default:
+		WL_ERROR(("wlc_cck_plcp_set: unsupported rate %d\n", rate_500));
+		rate_500 = WLC_RATE_1M;
+		usec = length << 3;
+		break;
+	}
+	/* PLCP signal byte */
+	plcp[0] = rate_500 * 5;	/* r (500kbps) * 5 == r (100kbps) */
+	/* PLCP service byte */
+	plcp[1] = (uint8) (le | D11B_PLCP_SIGNAL_LOCKED);
+	/* PLCP length uint16, little endian */
+	plcp[2] = usec & 0xff;
+	plcp[3] = (usec >> 8) & 0xff;
+	/* PLCP CRC16 */
+	plcp[4] = 0;
+	plcp[5] = 0;
+}
+
+/* Rate: 802.11 rate code, length: PSDU length in octets */
+static void wlc_compute_cck_plcp(ratespec_t rspec, uint length, uint8 * plcp)
+{
+	int rate = RSPEC2RATE(rspec);
+
+	ASSERT(IS_CCK(rspec));
+
+	wlc_cck_plcp_set(rate, length, plcp);
+}
+
+/* wlc_compute_frame_dur()
+ *
+ * Calculate the 802.11 MAC header DUR field for MPDU
+ * DUR for a single frame = 1 SIFS + 1 ACK
+ * DUR for a frame with following frags = 3 SIFS + 2 ACK + next frag time
+ *
+ * rate			MPDU rate in unit of 500kbps
+ * next_frag_len	next MPDU length in bytes
+ * preamble_type	use short/GF or long/MM PLCP header
+ */
+static uint16 BCMFASTPATH
+wlc_compute_frame_dur(wlc_info_t * wlc, ratespec_t rate, uint8 preamble_type,
+		      uint next_frag_len)
+{
+	uint16 dur, sifs;
+
+	sifs = SIFS(wlc->band);
+
+	dur = sifs;
+	dur += (uint16) wlc_calc_ack_time(wlc, rate, preamble_type);
+
+	if (next_frag_len) {
+		/* Double the current DUR to get 2 SIFS + 2 ACKs */
+		dur *= 2;
+		/* add another SIFS and the frag time */
+		dur += sifs;
+		dur +=
+		    (uint16) wlc_calc_frame_time(wlc, rate, preamble_type,
+						 next_frag_len);
+	}
+	return (dur);
+}
+
+/* wlc_compute_rtscts_dur()
+ *
+ * Calculate the 802.11 MAC header DUR field for an RTS or CTS frame
+ * DUR for normal RTS/CTS w/ frame = 3 SIFS + 1 CTS + next frame time + 1 ACK
+ * DUR for CTS-TO-SELF w/ frame    = 2 SIFS         + next frame time + 1 ACK
+ *
+ * cts			cts-to-self or rts/cts
+ * rts_rate		rts or cts rate in unit of 500kbps
+ * rate			next MPDU rate in unit of 500kbps
+ * frame_len		next MPDU frame length in bytes
+ */
+uint16 BCMFASTPATH
+wlc_compute_rtscts_dur(wlc_info_t * wlc, bool cts_only, ratespec_t rts_rate,
+		       ratespec_t frame_rate, uint8 rts_preamble_type,
+		       uint8 frame_preamble_type, uint frame_len, bool ba)
+{
+	uint16 dur, sifs;
+
+	sifs = SIFS(wlc->band);
+
+	if (!cts_only) {	/* RTS/CTS */
+		dur = 3 * sifs;
+		dur +=
+		    (uint16) wlc_calc_cts_time(wlc, rts_rate,
+					       rts_preamble_type);
+	} else {		/* CTS-TO-SELF */
+		dur = 2 * sifs;
+	}
+
+	dur +=
+	    (uint16) wlc_calc_frame_time(wlc, frame_rate, frame_preamble_type,
+					 frame_len);
+	if (ba)
+		dur +=
+		    (uint16) wlc_calc_ba_time(wlc, frame_rate,
+					      WLC_SHORT_PREAMBLE);
+	else
+		dur +=
+		    (uint16) wlc_calc_ack_time(wlc, frame_rate,
+					       frame_preamble_type);
+	return (dur);
+}
+
+static bool wlc_phy_rspec_check(wlc_info_t * wlc, uint16 bw, ratespec_t rspec)
+{
+	if (IS_MCS(rspec)) {
+		uint mcs = rspec & RSPEC_RATE_MASK;
+
+		if (mcs < 8) {
+			ASSERT(RSPEC_STF(rspec) < PHY_TXC1_MODE_SDM);
+		} else if ((mcs >= 8) && (mcs <= 23)) {
+			ASSERT(RSPEC_STF(rspec) == PHY_TXC1_MODE_SDM);
+		} else if (mcs == 32) {
+			ASSERT(RSPEC_STF(rspec) < PHY_TXC1_MODE_SDM);
+			ASSERT(bw == PHY_TXC1_BW_40MHZ_DUP);
+		}
+	} else if (IS_OFDM(rspec)) {
+		ASSERT(RSPEC_STF(rspec) < PHY_TXC1_MODE_STBC);
+	} else {
+		ASSERT(IS_CCK(rspec));
+
+		ASSERT((bw == PHY_TXC1_BW_20MHZ)
+		       || (bw == PHY_TXC1_BW_20MHZ_UP));
+		ASSERT(RSPEC_STF(rspec) == PHY_TXC1_MODE_SISO);
+	}
+
+	return TRUE;
+}
+
+uint16 BCMFASTPATH wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec)
+{
+	uint16 phyctl1 = 0;
+	uint16 bw;
+
+	if (WLCISLCNPHY(wlc->band)) {
+		bw = PHY_TXC1_BW_20MHZ;
+	} else {
+		bw = RSPEC_GET_BW(rspec);
+		/* 10Mhz is not supported yet */
+		if (bw < PHY_TXC1_BW_20MHZ) {
+			WL_ERROR(("wlc_phytxctl1_calc: bw %d is not supported yet, set to 20L\n", bw));
+			bw = PHY_TXC1_BW_20MHZ;
+		}
+
+		wlc_phy_rspec_check(wlc, bw, rspec);
+	}
+
+	if (IS_MCS(rspec)) {
+		uint mcs = rspec & RSPEC_RATE_MASK;
+
+		/* bw, stf, coding-type is part of RSPEC_PHYTXBYTE2 returns */
+		phyctl1 = RSPEC_PHYTXBYTE2(rspec);
+		/* set the upper byte of phyctl1 */
+		phyctl1 |= (mcs_table[mcs].tx_phy_ctl3 << 8);
+	} else if (IS_CCK(rspec) && !WLCISLCNPHY(wlc->band)
+		   && !WLCISSSLPNPHY(wlc->band)) {
+		/* In CCK mode LPPHY overloads OFDM Modulation bits with CCK Data Rate */
+		/* Eventually MIMOPHY would also be converted to this format */
+		/* 0 = 1Mbps; 1 = 2Mbps; 2 = 5.5Mbps; 3 = 11Mbps */
+		phyctl1 = (bw | (RSPEC_STF(rspec) << PHY_TXC1_MODE_SHIFT));
+	} else {		/* legacy OFDM/CCK */
+		int16 phycfg;
+		/* get the phyctl byte from rate phycfg table */
+		if ((phycfg = wlc_rate_legacy_phyctl(RSPEC2RATE(rspec))) == -1) {
+			WL_ERROR(("wlc_phytxctl1_calc: wrong legacy OFDM/CCK rate\n"));
+			ASSERT(0);
+			phycfg = 0;
+		}
+		/* set the upper byte of phyctl1 */
+		phyctl1 =
+		    (bw | (phycfg << 8) |
+		     (RSPEC_STF(rspec) << PHY_TXC1_MODE_SHIFT));
+	}
+
+#ifdef BCMDBG
+	/* phy clock must support 40Mhz if tx descriptor uses it */
+	if ((phyctl1 & PHY_TXC1_BW_MASK) >= PHY_TXC1_BW_40MHZ) {
+		ASSERT(CHSPEC_WLC_BW(wlc->chanspec) == WLC_40_MHZ);
+#ifndef WLC_HIGH_ONLY
+		ASSERT(wlc->chanspec == wlc_phy_chanspec_get(wlc->band->pi));
+#endif
+	}
+#endif				/* BCMDBG */
+	return phyctl1;
+}
+
+ratespec_t BCMFASTPATH
+wlc_rspec_to_rts_rspec(wlc_info_t * wlc, ratespec_t rspec, bool use_rspec,
+		       uint16 mimo_ctlchbw)
+{
+	ratespec_t rts_rspec = 0;
+
+	if (use_rspec) {
+		/* use frame rate as rts rate */
+		rts_rspec = rspec;
+
+	} else if (wlc->band->gmode && wlc->protection->_g && !IS_CCK(rspec)) {
+		/* Use 11Mbps as the g protection RTS target rate and fallback.
+		 * Use the WLC_BASIC_RATE() lookup to find the best basic rate under the
+		 * target in case 11 Mbps is not Basic.
+		 * 6 and 9 Mbps are not usually selected by rate selection, but even
+		 * if the OFDM rate we are protecting is 6 or 9 Mbps, 11 is more robust.
+		 */
+		rts_rspec = WLC_BASIC_RATE(wlc, WLC_RATE_11M);
+	} else {
+		/* calculate RTS rate and fallback rate based on the frame rate
+		 * RTS must be sent at a basic rate since it is a
+		 * control frame, sec 9.6 of 802.11 spec
+		 */
+		rts_rspec = WLC_BASIC_RATE(wlc, rspec);
+	}
+
+	if (WLC_PHY_11N_CAP(wlc->band)) {
+		/* set rts txbw to correct side band */
+		rts_rspec &= ~RSPEC_BW_MASK;
+
+		/* if rspec/rspec_fallback is 40MHz, then send RTS on both 20MHz channel
+		 * (DUP), otherwise send RTS on control channel
+		 */
+		if (RSPEC_IS40MHZ(rspec) && !IS_CCK(rts_rspec))
+			rts_rspec |= (PHY_TXC1_BW_40MHZ_DUP << RSPEC_BW_SHIFT);
+		else
+			rts_rspec |= (mimo_ctlchbw << RSPEC_BW_SHIFT);
+
+		/* pick siso/cdd as default for ofdm */
+		if (IS_OFDM(rts_rspec)) {
+			rts_rspec &= ~RSPEC_STF_MASK;
+			rts_rspec |= (wlc->stf->ss_opmode << RSPEC_STF_SHIFT);
+		}
+	}
+	return rts_rspec;
+}
+
+/*
+ * Add d11txh_t, cck_phy_hdr_t.
+ *
+ * 'p' data must start with 802.11 MAC header
+ * 'p' must allow enough bytes of local headers to be "pushed" onto the packet
+ *
+ * headroom == D11_PHY_HDR_LEN + D11_TXH_LEN (D11_TXH_LEN is now 104 bytes)
+ *
+ */
+static uint16 BCMFASTPATH
+wlc_d11hdrs_mac80211(wlc_info_t * wlc, struct ieee80211_hw *hw,
+		     void *p, struct scb *scb, uint frag,
+		     uint nfrags, uint queue, uint next_frag_len,
+		     wsec_key_t * key, ratespec_t rspec_override)
+{
+	struct dot11_header *h;
+	d11txh_t *txh;
+	uint8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];
+	osl_t *osh;
+	int len, phylen, rts_phylen;
+	uint16 fc, type, frameid, mch, phyctl, xfts, mainrates;
+	uint16 seq = 0, mcl = 0, status = 0;
+	ratespec_t rspec[2] = { WLC_RATE_1M, WLC_RATE_1M }, rts_rspec[2] = {
+	WLC_RATE_1M, WLC_RATE_1M};
+	bool use_rts = FALSE;
+	bool use_cts = FALSE;
+	bool use_rifs = FALSE;
+	bool short_preamble[2] = { FALSE, FALSE };
+	uint8 preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
+	uint8 rts_preamble_type[2] = { WLC_LONG_PREAMBLE, WLC_LONG_PREAMBLE };
+	uint8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];
+	struct dot11_rts_frame *rts = NULL;
+	bool qos;
+	uint ac;
+	uint32 rate_val[2];
+	bool hwtkmic = FALSE;
+	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
+#ifdef WLANTSEL
+#define ANTCFG_NONE 0xFF
+	uint8 antcfg = ANTCFG_NONE;
+	uint8 fbantcfg = ANTCFG_NONE;
+#endif
+	uint phyctl1_stf = 0;
+	uint16 durid = 0;
+	struct ieee80211_tx_rate *txrate[2];
+	int k;
+	struct ieee80211_tx_info *tx_info;
+	bool is_mcs[2];
+	uint16 mimo_txbw;
+	uint8 mimo_preamble_type;
+
+	frameid = 0;
+
+	ASSERT(queue < NFIFO);
+
+	osh = wlc->osh;
+
+	/* locate 802.11 MAC header */
+	h = (struct dot11_header *)PKTDATA(p);
+	fc = ltoh16(h->fc);
+	type = FC_TYPE(fc);
+
+	qos = (type == FC_TYPE_DATA && FC_SUBTYPE_ANY_QOS(FC_SUBTYPE(fc)));
+
+	/* compute length of frame in bytes for use in PLCP computations */
+	len = pkttotlen(osh, p);
+	phylen = len + DOT11_FCS_LEN;
+
+	/* If WEP enabled, add room in phylen for the additional bytes of
+	 * ICV which MAC generates.  We do NOT add the additional bytes to
+	 * the packet itself, thus phylen = packet length + ICV_LEN + FCS_LEN
+	 * in this case
+	 */
+	if (key) {
+		phylen += key->icv_len;
+	}
+
+	/* Get tx_info */
+	tx_info = IEEE80211_SKB_CB(p);
+	ASSERT(tx_info);
+
+	/* add PLCP */
+	plcp = PKTPUSH(p, D11_PHY_HDR_LEN);
+
+	/* add Broadcom tx descriptor header */
+	txh = (d11txh_t *) PKTPUSH(p, D11_TXH_LEN);
+	bzero((char *)txh, D11_TXH_LEN);
+
+	/* setup frameid */
+	if (tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {
+		/* non-AP STA should never use BCMC queue */
+		ASSERT(queue != TX_BCMC_FIFO);
+		if (queue == TX_BCMC_FIFO) {
+			WL_ERROR(("wl%d: %s: ASSERT queue == TX_BCMC!\n",
+				  WLCWLUNIT(wlc), __func__));
+			frameid = bcmc_fid_generate(wlc, NULL, txh);
+		} else {
+			/* Increment the counter for first fragment */
+			if (tx_info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT) {
+				SCB_SEQNUM(scb, PKTPRIO(p))++;
+			}
+
+			/* extract fragment number from frame first */
+			seq = ltoh16(seq) & FRAGNUM_MASK;
+			seq |= (SCB_SEQNUM(scb, PKTPRIO(p)) << SEQNUM_SHIFT);
+			h->seq = htol16(seq);
+
+			frameid = ((seq << TXFID_SEQ_SHIFT) & TXFID_SEQ_MASK) |
+			    (queue & TXFID_QUEUE_MASK);
+		}
+	}
+	frameid |= queue & TXFID_QUEUE_MASK;
+
+	/* set the ignpmq bit for all pkts tx'd in PS mode and for beacons */
+	if (SCB_PS(scb) || ((fc & FC_KIND_MASK) == FC_BEACON))
+		mcl |= TXC_IGNOREPMQ;
+
+	ASSERT(hw->max_rates <= IEEE80211_TX_MAX_RATES);
+	ASSERT(hw->max_rates == 2);
+
+	txrate[0] = tx_info->control.rates;
+	txrate[1] = txrate[0] + 1;
+
+	ASSERT(txrate[0]->idx >= 0);
+	/* if rate control algorithm didn't give us a fallback rate, use the primary rate */
+	if (txrate[1]->idx < 0) {
+		txrate[1] = txrate[0];
+	}
+#ifdef WLC_HIGH_ONLY
+	/* Double protection , just in case */
+	if (txrate[0]->idx > HIGHEST_SINGLE_STREAM_MCS)
+		txrate[0]->idx = HIGHEST_SINGLE_STREAM_MCS;
+	if (txrate[1]->idx > HIGHEST_SINGLE_STREAM_MCS)
+		txrate[1]->idx = HIGHEST_SINGLE_STREAM_MCS;
+#endif
+
+	for (k = 0; k < hw->max_rates; k++) {
+		is_mcs[k] =
+		    txrate[k]->flags & IEEE80211_TX_RC_MCS ? TRUE : FALSE;
+		if (!is_mcs[k]) {
+			ASSERT(!(tx_info->flags & IEEE80211_TX_CTL_AMPDU));
+			if ((txrate[k]->idx >= 0)
+			    && (txrate[k]->idx <
+				hw->wiphy->bands[tx_info->band]->n_bitrates)) {
+				rate_val[k] =
+				    hw->wiphy->bands[tx_info->band]->
+				    bitrates[txrate[k]->idx].hw_value;
+				short_preamble[k] =
+				    txrate[k]->
+				    flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE ?
+				    TRUE : FALSE;
+			} else {
+				ASSERT((txrate[k]->idx >= 0) &&
+				       (txrate[k]->idx <
+					hw->wiphy->bands[tx_info->band]->
+					n_bitrates));
+				rate_val[k] = WLC_RATE_1M;
+			}
+		} else {
+			rate_val[k] = txrate[k]->idx;
+		}
+		/* Currently only support same setting for primay and fallback rates.
+		 * Unify flags for each rate into a single value for the frame
+		 */
+		use_rts |=
+		    txrate[k]->
+		    flags & IEEE80211_TX_RC_USE_RTS_CTS ? TRUE : FALSE;
+		use_cts |=
+		    txrate[k]->
+		    flags & IEEE80211_TX_RC_USE_CTS_PROTECT ? TRUE : FALSE;
+
+		if (is_mcs[k])
+			rate_val[k] |= NRATE_MCS_INUSE;
+
+		rspec[k] = mac80211_wlc_set_nrate(wlc, wlc->band, rate_val[k]);
+
+		/* (1) RATE: determine and validate primary rate and fallback rates */
+		if (!RSPEC_ACTIVE(rspec[k])) {
+			ASSERT(RSPEC_ACTIVE(rspec[k]));
+			rspec[k] = WLC_RATE_1M;
+		} else {
+			if (WLANTSEL_ENAB(wlc) && !ETHER_ISMULTI(&h->a1)) {
+				/* set tx antenna config */
+				wlc_antsel_antcfg_get(wlc->asi, FALSE, FALSE, 0,
+						      0, &antcfg, &fbantcfg);
+			}
+		}
+	}
+
+	phyctl1_stf = wlc->stf->ss_opmode;
+
+	if (N_ENAB(wlc->pub)) {
+		for (k = 0; k < hw->max_rates; k++) {
+			/* apply siso/cdd to single stream mcs's or ofdm if rspec is auto selected */
+			if (((IS_MCS(rspec[k]) &&
+			      IS_SINGLE_STREAM(rspec[k] & RSPEC_RATE_MASK)) ||
+			     IS_OFDM(rspec[k]))
+			    && ((rspec[k] & RSPEC_OVERRIDE_MCS_ONLY)
+				|| !(rspec[k] & RSPEC_OVERRIDE))) {
+				rspec[k] &= ~(RSPEC_STF_MASK | RSPEC_STC_MASK);
+
+				/* For SISO MCS use STBC if possible */
+				if (IS_MCS(rspec[k])
+				    && WLC_STF_SS_STBC_TX(wlc, scb)) {
+					uint8 stc;
+
+					ASSERT(WLC_STBC_CAP_PHY(wlc));
+					stc = 1;	/* Nss for single stream is always 1 */
+					rspec[k] |=
+					    (PHY_TXC1_MODE_STBC <<
+					     RSPEC_STF_SHIFT) | (stc <<
+								 RSPEC_STC_SHIFT);
+				} else
+					rspec[k] |=
+					    (phyctl1_stf << RSPEC_STF_SHIFT);
+			}
+
+			/* Is the phy configured to use 40MHZ frames? If so then pick the desired txbw */
+			if (CHSPEC_WLC_BW(wlc->chanspec) == WLC_40_MHZ) {
+				/* default txbw is 20in40 SB */
+				mimo_ctlchbw = mimo_txbw =
+				    CHSPEC_SB_UPPER(WLC_BAND_PI_RADIO_CHANSPEC)
+				    ? PHY_TXC1_BW_20MHZ_UP : PHY_TXC1_BW_20MHZ;
+
+				if (IS_MCS(rspec[k])) {
+					/* mcs 32 must be 40b/w DUP */
+					if ((rspec[k] & RSPEC_RATE_MASK) == 32) {
+						mimo_txbw =
+						    PHY_TXC1_BW_40MHZ_DUP;
+						/* use override */
+					} else if (wlc->mimo_40txbw != AUTO)
+						mimo_txbw = wlc->mimo_40txbw;
+					/* else check if dst is using 40 Mhz */
+					else if (scb->flags & SCB_IS40)
+						mimo_txbw = PHY_TXC1_BW_40MHZ;
+				} else if (IS_OFDM(rspec[k])) {
+					if (wlc->ofdm_40txbw != AUTO)
+						mimo_txbw = wlc->ofdm_40txbw;
+				} else {
+					ASSERT(IS_CCK(rspec[k]));
+					if (wlc->cck_40txbw != AUTO)
+						mimo_txbw = wlc->cck_40txbw;
+				}
+			} else {
+				/* mcs32 is 40 b/w only.
+				 * This is possible for probe packets on a STA during SCAN
+				 */
+				if ((rspec[k] & RSPEC_RATE_MASK) == 32) {
+					/* mcs 0 */
+					rspec[k] = RSPEC_MIMORATE;
+				}
+				mimo_txbw = PHY_TXC1_BW_20MHZ;
+			}
+
+			/* Set channel width */
+			rspec[k] &= ~RSPEC_BW_MASK;
+			if ((k == 0) || ((k > 0) && IS_MCS(rspec[k])))
+				rspec[k] |= (mimo_txbw << RSPEC_BW_SHIFT);
+			else
+				rspec[k] |= (mimo_ctlchbw << RSPEC_BW_SHIFT);
+
+			/* Set Short GI */
+#ifdef NOSGIYET
+			if (IS_MCS(rspec[k])
+			    && (txrate[k]->flags & IEEE80211_TX_RC_SHORT_GI))
+				rspec[k] |= RSPEC_SHORT_GI;
+			else if (!(txrate[k]->flags & IEEE80211_TX_RC_SHORT_GI))
+				rspec[k] &= ~RSPEC_SHORT_GI;
+#else
+			rspec[k] &= ~RSPEC_SHORT_GI;
+#endif
+
+			mimo_preamble_type = WLC_MM_PREAMBLE;
+			if (txrate[k]->flags & IEEE80211_TX_RC_GREEN_FIELD)
+				mimo_preamble_type = WLC_GF_PREAMBLE;
+
+			if ((txrate[k]->flags & IEEE80211_TX_RC_MCS)
+			    && (!IS_MCS(rspec[k]))) {
+				WL_ERROR(("wl%d: %s: IEEE80211_TX_RC_MCS != IS_MCS(rspec)\n", WLCWLUNIT(wlc), __func__));
+				ASSERT(0 && "Rate mismatch");
+			}
+
+			if (IS_MCS(rspec[k])) {
+				preamble_type[k] = mimo_preamble_type;
+
+				/* if SGI is selected, then forced mm for single stream */
+				if ((rspec[k] & RSPEC_SHORT_GI)
+				    && IS_SINGLE_STREAM(rspec[k] &
+							RSPEC_RATE_MASK)) {
+					preamble_type[k] = WLC_MM_PREAMBLE;
+				}
+			}
+
+			/* mimo bw field MUST now be valid in the rspec (it affects duration calculations) */
+			ASSERT(VALID_RATE_DBG(wlc, rspec[0]));
+
+			/* should be better conditionalized */
+			if (!IS_MCS(rspec[0])
+			    && (tx_info->control.rates[0].
+				flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE))
+				preamble_type[k] = WLC_SHORT_PREAMBLE;
+
+			ASSERT(!IS_MCS(rspec[0])
+			       || WLC_IS_MIMO_PREAMBLE(preamble_type[k]));
+		}
+	} else {
+		for (k = 0; k < hw->max_rates; k++) {
+			/* Set ctrlchbw as 20Mhz */
+			ASSERT(!IS_MCS(rspec[k]));
+			rspec[k] &= ~RSPEC_BW_MASK;
+			rspec[k] |= (PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT);
+
+			/* for nphy, stf of ofdm frames must follow policies */
+			if (WLCISNPHY(wlc->band) && IS_OFDM(rspec[k])) {
+				rspec[k] &= ~RSPEC_STF_MASK;
+				rspec[k] |= phyctl1_stf << RSPEC_STF_SHIFT;
+			}
+		}
+	}
+
+	/* Reset these for use with AMPDU's */
+	txrate[0]->count = 0;
+	txrate[1]->count = 0;
+
+	/* (3) PLCP: determine PLCP header and MAC duration, fill d11txh_t */
+	wlc_compute_plcp(wlc, rspec[0], phylen, plcp);
+	wlc_compute_plcp(wlc, rspec[1], phylen, plcp_fallback);
+	bcopy(plcp_fallback, (char *)&txh->FragPLCPFallback,
+	      sizeof(txh->FragPLCPFallback));
+
+	/* Length field now put in CCK FBR CRC field */
+	if (IS_CCK(rspec[1])) {
+		txh->FragPLCPFallback[4] = phylen & 0xff;
+		txh->FragPLCPFallback[5] = (phylen & 0xff00) >> 8;
+	}
+
+	/* MIMO-RATE: need validation ?? */
+	mainrates =
+	    IS_OFDM(rspec[0]) ? D11A_PHY_HDR_GRATE((ofdm_phy_hdr_t *) plcp) :
+	    plcp[0];
+
+	/* DUR field for main rate */
+	if ((fc != FC_PS_POLL) && !ETHER_ISMULTI(&h->a1) && !use_rifs) {
+		durid =
+		    wlc_compute_frame_dur(wlc, rspec[0], preamble_type[0],
+					  next_frag_len);
+		h->durid = htol16(durid);
+	} else if (use_rifs) {
+		/* NAV protect to end of next max packet size */
+		durid =
+		    (uint16) wlc_calc_frame_time(wlc, rspec[0],
+						 preamble_type[0],
+						 DOT11_MAX_FRAG_LEN);
+		durid += RIFS_11N_TIME;
+		h->durid = htol16(durid);
+	}
+
+	/* DUR field for fallback rate */
+	if (fc == FC_PS_POLL)
+		txh->FragDurFallback = h->durid;
+	else if (ETHER_ISMULTI(&h->a1) || use_rifs)
+		txh->FragDurFallback = 0;
+	else {
+		durid = wlc_compute_frame_dur(wlc, rspec[1],
+					      preamble_type[1], next_frag_len);
+		txh->FragDurFallback = htol16(durid);
+	}
+
+	/* (4) MAC-HDR: MacTxControlLow */
+	if (frag == 0)
+		mcl |= TXC_STARTMSDU;
+
+	if (!ETHER_ISMULTI(&h->a1))
+		mcl |= TXC_IMMEDACK;
+
+	if (BAND_5G(wlc->band->bandtype))
+		mcl |= TXC_FREQBAND_5G;
+
+	if (CHSPEC_IS40(WLC_BAND_PI_RADIO_CHANSPEC))
+		mcl |= TXC_BW_40;
+
+	/* set AMIC bit if using hardware TKIP MIC */
+	if (hwtkmic)
+		mcl |= TXC_AMIC;
+
+	txh->MacTxControlLow = htol16(mcl);
+
+	/* MacTxControlHigh */
+	mch = 0;
+
+	/* Set fallback rate preamble type */
+	if ((preamble_type[1] == WLC_SHORT_PREAMBLE) ||
+	    (preamble_type[1] == WLC_GF_PREAMBLE)) {
+		ASSERT((preamble_type[1] == WLC_GF_PREAMBLE) ||
+		       (!IS_MCS(rspec[1])));
+		if (RSPEC2RATE(rspec[1]) != WLC_RATE_1M)
+			mch |= TXC_PREAMBLE_DATA_FB_SHORT;
+	}
+
+	/* MacFrameControl */
+	bcopy((char *)&h->fc, (char *)&txh->MacFrameControl, sizeof(uint16));
+
+	txh->TxFesTimeNormal = htol16(0);
+
+	txh->TxFesTimeFallback = htol16(0);
+
+	/* TxFrameRA */
+	bcopy((char *)&h->a1, (char *)&txh->TxFrameRA, ETHER_ADDR_LEN);
+
+	/* TxFrameID */
+	txh->TxFrameID = htol16(frameid);
+
+	/* TxStatus, Note the case of recreating the first frag of a suppressed frame
+	 * then we may need to reset the retry cnt's via the status reg
+	 */
+	txh->TxStatus = htol16(status);
+
+	if (D11REV_GE(wlc->pub->corerev, 16)) {
+		/* extra fields for ucode AMPDU aggregation, the new fields are added to
+		 * the END of previous structure so that it's compatible in driver.
+		 * In old rev ucode, these fields should be ignored
+		 */
+		txh->MaxNMpdus = htol16(0);
+		txh->MaxABytes_MRT = htol16(0);
+		txh->MaxABytes_FBR = htol16(0);
+		txh->MinMBytes = htol16(0);
+	}
+
+	/* (5) RTS/CTS: determine RTS/CTS PLCP header and MAC duration, furnish d11txh_t */
+	/* RTS PLCP header and RTS frame */
+	if (use_rts || use_cts) {
+		if (use_rts && use_cts)
+			use_cts = FALSE;
+
+		for (k = 0; k < 2; k++) {
+			rts_rspec[k] = wlc_rspec_to_rts_rspec(wlc, rspec[k],
+							      FALSE,
+							      mimo_ctlchbw);
+		}
+
+		if (!IS_OFDM(rts_rspec[0]) &&
+		    !((RSPEC2RATE(rts_rspec[0]) == WLC_RATE_1M) ||
+		      (wlc->PLCPHdr_override == WLC_PLCP_LONG))) {
+			rts_preamble_type[0] = WLC_SHORT_PREAMBLE;
+			mch |= TXC_PREAMBLE_RTS_MAIN_SHORT;
+		}
+
+		if (!IS_OFDM(rts_rspec[1]) &&
+		    !((RSPEC2RATE(rts_rspec[1]) == WLC_RATE_1M) ||
+		      (wlc->PLCPHdr_override == WLC_PLCP_LONG))) {
+			rts_preamble_type[1] = WLC_SHORT_PREAMBLE;
+			mch |= TXC_PREAMBLE_RTS_FB_SHORT;
+		}
+
+		/* RTS/CTS additions to MacTxControlLow */
+		if (use_cts) {
+			txh->MacTxControlLow |= htol16(TXC_SENDCTS);
+		} else {
+			txh->MacTxControlLow |= htol16(TXC_SENDRTS);
+			txh->MacTxControlLow |= htol16(TXC_LONGFRAME);
+		}
+
+		/* RTS PLCP header */
+		ASSERT(ISALIGNED((uintptr) txh->RTSPhyHeader, sizeof(uint16)));
+		rts_plcp = txh->RTSPhyHeader;
+		if (use_cts)
+			rts_phylen = DOT11_CTS_LEN + DOT11_FCS_LEN;
+		else
+			rts_phylen = DOT11_RTS_LEN + DOT11_FCS_LEN;
+
+		wlc_compute_plcp(wlc, rts_rspec[0], rts_phylen, rts_plcp);
+
+		/* fallback rate version of RTS PLCP header */
+		wlc_compute_plcp(wlc, rts_rspec[1], rts_phylen,
+				 rts_plcp_fallback);
+		bcopy(rts_plcp_fallback, (char *)&txh->RTSPLCPFallback,
+		      sizeof(txh->RTSPLCPFallback));
+
+		/* RTS frame fields... */
+		rts = (struct dot11_rts_frame *)&txh->rts_frame;
+
+		durid = wlc_compute_rtscts_dur(wlc, use_cts, rts_rspec[0],
+					       rspec[0], rts_preamble_type[0],
+					       preamble_type[0], phylen, FALSE);
+		rts->durid = htol16(durid);
+		/* fallback rate version of RTS DUR field */
+		durid = wlc_compute_rtscts_dur(wlc, use_cts,
+					       rts_rspec[1], rspec[1],
+					       rts_preamble_type[1],
+					       preamble_type[1], phylen, FALSE);
+		txh->RTSDurFallback = htol16(durid);
+
+		if (use_cts) {
+			rts->fc = htol16(FC_CTS);
+			bcopy((char *)&h->a2, (char *)&rts->ra, ETHER_ADDR_LEN);
+		} else {
+			rts->fc = htol16((uint16) FC_RTS);
+			bcopy((char *)&h->a1, (char *)&rts->ra,
+			      2 * ETHER_ADDR_LEN);
+		}
+
+		/* mainrate
+		 *    low 8 bits: main frag rate/mcs,
+		 *    high 8 bits: rts/cts rate/mcs
+		 */
+		mainrates |= (IS_OFDM(rts_rspec[0]) ?
+			      D11A_PHY_HDR_GRATE((ofdm_phy_hdr_t *) rts_plcp) :
+			      rts_plcp[0]) << 8;
+	} else {
+		bzero((char *)txh->RTSPhyHeader, D11_PHY_HDR_LEN);
+		bzero((char *)&txh->rts_frame, sizeof(struct dot11_rts_frame));
+		bzero((char *)txh->RTSPLCPFallback,
+		      sizeof(txh->RTSPLCPFallback));
+		txh->RTSDurFallback = 0;
+	}
+
+#ifdef SUPPORT_40MHZ
+	/* add null delimiter count */
+	if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) && IS_MCS(rspec)) {
+		txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM] =
+		    wlc_ampdu_null_delim_cnt(wlc->ampdu, scb, rspec, phylen);
+	}
+#endif
+
+	/* Now that RTS/RTS FB preamble types are updated, write the final value */
+	txh->MacTxControlHigh = htol16(mch);
+
+	/* MainRates (both the rts and frag plcp rates have been calculated now) */
+	txh->MainRates = htol16(mainrates);
+
+	/* XtraFrameTypes */
+	xfts = FRAMETYPE(rspec[1], wlc->mimoft);
+	xfts |= (FRAMETYPE(rts_rspec[0], wlc->mimoft) << XFTS_RTS_FT_SHIFT);
+	xfts |= (FRAMETYPE(rts_rspec[1], wlc->mimoft) << XFTS_FBRRTS_FT_SHIFT);
+	xfts |=
+	    CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC) << XFTS_CHANNEL_SHIFT;
+	txh->XtraFrameTypes = htol16(xfts);
+
+	/* PhyTxControlWord */
+	phyctl = FRAMETYPE(rspec[0], wlc->mimoft);
+	if ((preamble_type[0] == WLC_SHORT_PREAMBLE) ||
+	    (preamble_type[0] == WLC_GF_PREAMBLE)) {
+		ASSERT((preamble_type[0] == WLC_GF_PREAMBLE)
+		       || !IS_MCS(rspec[0]));
+		if (RSPEC2RATE(rspec[0]) != WLC_RATE_1M)
+			phyctl |= PHY_TXC_SHORT_HDR;
+		WLCNTINCR(wlc->pub->_cnt->txprshort);
+	}
+
+	/* phytxant is properly bit shifted */
+	phyctl |= wlc_stf_d11hdrs_phyctl_txant(wlc, rspec[0]);
+	txh->PhyTxControlWord = htol16(phyctl);
+
+	/* PhyTxControlWord_1 */
+	if (WLC_PHY_11N_CAP(wlc->band)) {
+		uint16 phyctl1 = 0;
+
+		phyctl1 = wlc_phytxctl1_calc(wlc, rspec[0]);
+		txh->PhyTxControlWord_1 = htol16(phyctl1);
+		phyctl1 = wlc_phytxctl1_calc(wlc, rspec[1]);
+		txh->PhyTxControlWord_1_Fbr = htol16(phyctl1);
+
+		if (use_rts || use_cts) {
+			phyctl1 = wlc_phytxctl1_calc(wlc, rts_rspec[0]);
+			txh->PhyTxControlWord_1_Rts = htol16(phyctl1);
+			phyctl1 = wlc_phytxctl1_calc(wlc, rts_rspec[1]);
+			txh->PhyTxControlWord_1_FbrRts = htol16(phyctl1);
+		}
+
+		/*
+		 * For mcs frames, if mixedmode(overloaded with long preamble) is going to be set,
+		 * fill in non-zero MModeLen and/or MModeFbrLen
+		 *  it will be unnecessary if they are separated
+		 */
+		if (IS_MCS(rspec[0]) && (preamble_type[0] == WLC_MM_PREAMBLE)) {
+			uint16 mmodelen =
+			    wlc_calc_lsig_len(wlc, rspec[0], phylen);
+			txh->MModeLen = htol16(mmodelen);
+		}
+
+		if (IS_MCS(rspec[1]) && (preamble_type[1] == WLC_MM_PREAMBLE)) {
+			uint16 mmodefbrlen =
+			    wlc_calc_lsig_len(wlc, rspec[1], phylen);
+			txh->MModeFbrLen = htol16(mmodefbrlen);
+		}
+	}
+
+	if (IS_MCS(rspec[0]))
+		ASSERT(IS_MCS(rspec[1]));
+
+	ASSERT(!IS_MCS(rspec[0]) ||
+	       ((preamble_type[0] == WLC_MM_PREAMBLE) == (txh->MModeLen != 0)));
+	ASSERT(!IS_MCS(rspec[1]) ||
+	       ((preamble_type[1] == WLC_MM_PREAMBLE) ==
+		(txh->MModeFbrLen != 0)));
+
+	if (SCB_WME(scb) && qos && wlc->edcf_txop[(ac = wme_fifo2ac[queue])]) {
+		uint frag_dur, dur, dur_fallback;
+
+		ASSERT(!ETHER_ISMULTI(&h->a1));
+
+		/* WME: Update TXOP threshold */
+		if ((!(tx_info->flags & IEEE80211_TX_CTL_AMPDU)) && (frag == 0)) {
+			frag_dur =
+			    wlc_calc_frame_time(wlc, rspec[0], preamble_type[0],
+						phylen);
+
+			if (rts) {
+				/* 1 RTS or CTS-to-self frame */
+				dur =
+				    wlc_calc_cts_time(wlc, rts_rspec[0],
+						      rts_preamble_type[0]);
+				dur_fallback =
+				    wlc_calc_cts_time(wlc, rts_rspec[1],
+						      rts_preamble_type[1]);
+				/* (SIFS + CTS) + SIFS + frame + SIFS + ACK */
+				dur += ltoh16(rts->durid);
+				dur_fallback += ltoh16(txh->RTSDurFallback);
+			} else if (use_rifs) {
+				dur = frag_dur;
+				dur_fallback = 0;
+			} else {
+				/* frame + SIFS + ACK */
+				dur = frag_dur;
+				dur +=
+				    wlc_compute_frame_dur(wlc, rspec[0],
+							  preamble_type[0], 0);
+
+				dur_fallback =
+				    wlc_calc_frame_time(wlc, rspec[1],
+							preamble_type[1],
+							phylen);
+				dur_fallback +=
+				    wlc_compute_frame_dur(wlc, rspec[1],
+							  preamble_type[1], 0);
+			}
+			/* NEED to set TxFesTimeNormal (hard) */
+			txh->TxFesTimeNormal = htol16((uint16) dur);
+			/* NEED to set fallback rate version of TxFesTimeNormal (hard) */
+			txh->TxFesTimeFallback = htol16((uint16) dur_fallback);
+
+			/* update txop byte threshold (txop minus intraframe overhead) */
+			if (wlc->edcf_txop[ac] >= (dur - frag_dur)) {
+				{
+					uint newfragthresh;
+
+					newfragthresh =
+					    wlc_calc_frame_len(wlc, rspec[0],
+							       preamble_type[0],
+							       (wlc->
+								edcf_txop[ac] -
+								(dur -
+								 frag_dur)));
+					/* range bound the fragthreshold */
+					if (newfragthresh < DOT11_MIN_FRAG_LEN)
+						newfragthresh =
+						    DOT11_MIN_FRAG_LEN;
+					else if (newfragthresh >
+						 wlc->usr_fragthresh)
+						newfragthresh =
+						    wlc->usr_fragthresh;
+					/* update the fragthresh and do txc update */
+					if (wlc->fragthresh[queue] !=
+					    (uint16) newfragthresh) {
+						wlc->fragthresh[queue] =
+						    (uint16) newfragthresh;
+					}
+				}
+			} else
+				WL_ERROR(("wl%d: %s txop invalid for rate %d\n",
+					  wlc->pub->unit, fifo_names[queue],
+					  RSPEC2RATE(rspec[0])));
+
+			if (dur > wlc->edcf_txop[ac])
+				WL_ERROR(("wl%d: %s: %s txop exceeded phylen %d/%d dur %d/%d\n", wlc->pub->unit, __func__, fifo_names[queue], phylen, wlc->fragthresh[queue], dur, wlc->edcf_txop[ac]));
+		}
+	}
+
+	return 0;
+}
+
+void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs)
+{
+	wlc_bsscfg_t *cfg = wlc->cfg;
+
+	WLCNTINCR(wlc->pub->_cnt->tbtt);
+
+	if (BSSCFG_STA(cfg)) {
+		/* run watchdog here if the watchdog timer is not armed */
+		if (WLC_WATCHDOG_TBTT(wlc)) {
+			uint32 cur, delta;
+			if (wlc->WDarmed) {
+				wl_del_timer(wlc->wl, wlc->wdtimer);
+				wlc->WDarmed = FALSE;
+			}
+
+			cur = OSL_SYSUPTIME();
+			delta = cur > wlc->WDlast ? cur - wlc->WDlast :
+			    (uint32) ~ 0 - wlc->WDlast + cur + 1;
+			if (delta >= TIMER_INTERVAL_WATCHDOG) {
+				wlc_watchdog((void *)wlc);
+				wlc->WDlast = cur;
+			}
+
+			wl_add_timer(wlc->wl, wlc->wdtimer,
+				     wlc_watchdog_backup_bi(wlc), TRUE);
+			wlc->WDarmed = TRUE;
+		}
+	}
+
+	if (!cfg->BSS) {
+		/* DirFrmQ is now valid...defer setting until end of ATIM window */
+		wlc->qvalid |= MCMD_DIRFRMQVAL;
+	}
+}
+
+/* GP timer is a freerunning 32 bit counter, decrements at 1 us rate */
+void wlc_hwtimer_gptimer_set(wlc_info_t * wlc, uint us)
+{
+	ASSERT(wlc->pub->corerev >= 3);	/* no gptimer in earlier revs */
+	W_REG(wlc->osh, &wlc->regs->gptimer, us);
+}
+
+void wlc_hwtimer_gptimer_abort(wlc_info_t * wlc)
+{
+	ASSERT(wlc->pub->corerev >= 3);
+	W_REG(wlc->osh, &wlc->regs->gptimer, 0);
+}
+
+static void wlc_hwtimer_gptimer_cb(wlc_info_t * wlc)
+{
+	/* when interrupt is generated, the counter is loaded with last value
+	 * written and continue to decrement. So it has to be cleaned first
+	 */
+	W_REG(wlc->osh, &wlc->regs->gptimer, 0);
+}
+
+/*
+ * This fn has all the high level dpc processing from wlc_dpc.
+ * POLICY: no macinstatus change, no bounding loop.
+ *         All dpc bounding should be handled in BMAC dpc, like txstatus and rxint
+ */
+void wlc_high_dpc(wlc_info_t * wlc, uint32 macintstatus)
+{
+	d11regs_t *regs = wlc->regs;
+#ifdef BCMDBG
+	char flagstr[128];
+	static const bcm_bit_desc_t int_flags[] = {
+		{MI_MACSSPNDD, "MACSSPNDD"},
+		{MI_BCNTPL, "BCNTPL"},
+		{MI_TBTT, "TBTT"},
+		{MI_BCNSUCCESS, "BCNSUCCESS"},
+		{MI_BCNCANCLD, "BCNCANCLD"},
+		{MI_ATIMWINEND, "ATIMWINEND"},
+		{MI_PMQ, "PMQ"},
+		{MI_NSPECGEN_0, "NSPECGEN_0"},
+		{MI_NSPECGEN_1, "NSPECGEN_1"},
+		{MI_MACTXERR, "MACTXERR"},
+		{MI_NSPECGEN_3, "NSPECGEN_3"},
+		{MI_PHYTXERR, "PHYTXERR"},
+		{MI_PME, "PME"},
+		{MI_GP0, "GP0"},
+		{MI_GP1, "GP1"},
+		{MI_DMAINT, "DMAINT"},
+		{MI_TXSTOP, "TXSTOP"},
+		{MI_CCA, "CCA"},
+		{MI_BG_NOISE, "BG_NOISE"},
+		{MI_DTIM_TBTT, "DTIM_TBTT"},
+		{MI_PRQ, "PRQ"},
+		{MI_PWRUP, "PWRUP"},
+		{MI_RFDISABLE, "RFDISABLE"},
+		{MI_TFS, "TFS"},
+		{MI_PHYCHANGED, "PHYCHANGED"},
+		{MI_TO, "TO"},
+		{0, NULL}
+	};
+
+	if (macintstatus & ~(MI_TBTT | MI_TXSTOP)) {
+		bcm_format_flags(int_flags, macintstatus, flagstr,
+				 sizeof(flagstr));
+		WL_TRACE(("wl%d: macintstatus 0x%x %s\n", wlc->pub->unit,
+			  macintstatus, flagstr));
+	}
+#endif				/* BCMDBG */
+
+	if (macintstatus & MI_PRQ) {
+		/* Process probe request FIFO */
+		ASSERT(0 && "PRQ Interrupt in non-MBSS");
+	}
+
+	/* TBTT indication */
+	/* ucode only gives either TBTT or DTIM_TBTT, not both */
+	if (macintstatus & (MI_TBTT | MI_DTIM_TBTT))
+		wlc_tbtt(wlc, regs);
+
+	if (macintstatus & MI_GP0) {
+		WL_ERROR(("wl%d: PSM microcode watchdog fired at %d (seconds). Resetting.\n", wlc->pub->unit, wlc->pub->now));
+
+		printk_once("%s : PSM Watchdog, chipid 0x%x, chiprev 0x%x\n",
+			    __func__, CHIPID(wlc->pub->sih->chip),
+			    CHIPREV(wlc->pub->sih->chiprev));
+
+		WLCNTINCR(wlc->pub->_cnt->psmwds);
+
+		/* big hammer */
+		wl_init(wlc->wl);
+	}
+
+	/* gptimer timeout */
+	if (macintstatus & MI_TO) {
+		wlc_hwtimer_gptimer_cb(wlc);
+	}
+
+	if (macintstatus & MI_RFDISABLE) {
+		WL_ERROR(("wl%d: MAC Detected a change on the RF Disable Input 0x%x\n", wlc->pub->unit, R_REG(wlc->osh, &regs->phydebug) & PDBG_RFD));
+		/* delay the cleanup to wl_down in IBSS case */
+		if ((R_REG(wlc->osh, &regs->phydebug) & PDBG_RFD)) {
+			int idx;
+			wlc_bsscfg_t *bsscfg;
+			FOREACH_BSS(wlc, idx, bsscfg) {
+				if (!BSSCFG_STA(bsscfg) || !bsscfg->enable
+				    || !bsscfg->BSS)
+					continue;
+				WL_ERROR(("wl%d: wlc_dpc: rfdisable -> wlc_bsscfg_disable()\n", wlc->pub->unit));
+			}
+		}
+	}
+
+	/* send any enq'd tx packets. Just makes sure to jump start tx */
+	if (!pktq_empty(&wlc->active_queue->q))
+		wlc_send_q(wlc, wlc->active_queue);
+
+#ifndef WLC_HIGH_ONLY
+	ASSERT(wlc_ps_check(wlc));
+#endif
+}
+
+static void *wlc_15420war(wlc_info_t * wlc, uint queue)
+{
+	hnddma_t *di;
+	void *p;
+
+	ASSERT(queue < NFIFO);
+
+	if ((D11REV_IS(wlc->pub->corerev, 4))
+	    || (D11REV_GT(wlc->pub->corerev, 6)))
+		return (NULL);
+
+	di = wlc->hw->di[queue];
+	ASSERT(di != NULL);
+
+	/* get next packet, ignoring XmtStatus.Curr */
+	p = dma_getnexttxp(di, HNDDMA_RANGE_ALL);
+
+	/* sw block tx dma */
+	dma_txblock(di);
+
+	/* if tx ring is now empty, reset and re-init the tx dma channel */
+	if (dma_txactive(wlc->hw->di[queue]) == 0) {
+		WLCNTINCR(wlc->pub->_cnt->txdmawar);
+		if (!dma_txreset(di))
+			WL_ERROR(("wl%d: %s: dma_txreset[%d]: cannot stop dma\n", wlc->pub->unit, __func__, queue));
+		dma_txinit(di);
+	}
+	return (p);
+}
+
+static void wlc_war16165(wlc_info_t * wlc, bool tx)
+{
+	if (tx) {
+		/* the post-increment is used in STAY_AWAKE macro */
+		if (wlc->txpend16165war++ == 0)
+			wlc_set_ps_ctrl(wlc);
+	} else {
+		wlc->txpend16165war--;
+		if (wlc->txpend16165war == 0)
+			wlc_set_ps_ctrl(wlc);
+	}
+}
+
+/* process an individual tx_status_t */
+/* WLC_HIGH_API */
+bool BCMFASTPATH
+wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2)
+{
+	void *p;
+	uint queue;
+	d11txh_t *txh;
+	struct scb *scb = NULL;
+	bool free_pdu;
+	osl_t *osh;
+	int tx_rts, tx_frame_count, tx_rts_count;
+	uint totlen, supr_status;
+	bool lastframe;
+	struct dot11_header *h;
+	uint16 fc;
+	uint16 mcl;
+	struct ieee80211_tx_info *tx_info;
+	struct ieee80211_tx_rate *txrate;
+	int i;
+
+	(void)(frm_tx2);	/* Compiler reference to avoid unused variable warning */
+
+	/* discard intermediate indications for ucode with one legitimate case:
+	 *   e.g. if "useRTS" is set. ucode did a successful rts/cts exchange, but the subsequent
+	 *   tx of DATA failed. so it will start rts/cts from the beginning (resetting the rts
+	 *   transmission count)
+	 */
+	if (!(txs->status & TX_STATUS_AMPDU)
+	    && (txs->status & TX_STATUS_INTERMEDIATE)) {
+		WLCNTADD(wlc->pub->_cnt->txnoack,
+			 ((txs->
+			   status & TX_STATUS_FRM_RTX_MASK) >>
+			  TX_STATUS_FRM_RTX_SHIFT));
+		WL_ERROR(("%s: INTERMEDIATE but not AMPDU\n", __func__));
+		return FALSE;
+	}
+
+	osh = wlc->osh;
+	queue = txs->frameid & TXFID_QUEUE_MASK;
+	ASSERT(queue < NFIFO);
+	if (queue >= NFIFO) {
+		p = NULL;
+		goto fatal;
+	}
+
+	p = GETNEXTTXP(wlc, queue);
+	if (WLC_WAR16165(wlc))
+		wlc_war16165(wlc, FALSE);
+	if (p == NULL)
+		p = wlc_15420war(wlc, queue);
+	ASSERT(p != NULL);
+	if (p == NULL)
+		goto fatal;
+
+	txh = (d11txh_t *) PKTDATA(p);
+	mcl = ltoh16(txh->MacTxControlLow);
+
+	if (txs->phyerr) {
+		WL_ERROR(("phyerr 0x%x, rate 0x%x\n", txs->phyerr,
+			  txh->MainRates));
+		wlc_print_txdesc(txh);
+		wlc_print_txstatus(txs);
+	}
+
+	ASSERT(txs->frameid == htol16(txh->TxFrameID));
+	if (txs->frameid != htol16(txh->TxFrameID))
+		goto fatal;
+
+	tx_info = IEEE80211_SKB_CB(p);
+	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	fc = ltoh16(h->fc);
+
+	scb = (struct scb *)tx_info->control.sta->drv_priv;
+
+	if (N_ENAB(wlc->pub)) {
+		uint8 *plcp = (uint8 *) (txh + 1);
+		if (PLCP3_ISSGI(plcp[3]))
+			WLCNTINCR(wlc->pub->_cnt->txmpdu_sgi);
+		if (PLCP3_ISSTBC(plcp[3]))
+			WLCNTINCR(wlc->pub->_cnt->txmpdu_stbc);
+	}
+
+	if (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {
+		ASSERT((mcl & TXC_AMPDU_MASK) != TXC_AMPDU_NONE);
+		wlc_ampdu_dotxstatus(wlc->ampdu, scb, p, txs);
+		return FALSE;
+	}
+
+	supr_status = txs->status & TX_STATUS_SUPR_MASK;
+	if (supr_status == TX_STATUS_SUPR_BADCH)
+		WL_NONE(("%s: Pkt tx suppressed, possibly channel %d\n",
+			 __func__, CHSPEC_CHANNEL(wlc->default_bss->chanspec)));
+
+	tx_rts = htol16(txh->MacTxControlLow) & TXC_SENDRTS;
+	tx_frame_count =
+	    (txs->status & TX_STATUS_FRM_RTX_MASK) >> TX_STATUS_FRM_RTX_SHIFT;
+	tx_rts_count =
+	    (txs->status & TX_STATUS_RTS_RTX_MASK) >> TX_STATUS_RTS_RTX_SHIFT;
+
+	lastframe = (fc & FC_MOREFRAG) == 0;
+
+	if (!lastframe) {
+		WL_ERROR(("Not last frame!\n"));
+	} else {
+		uint16 sfbl, lfbl;
+		ieee80211_tx_info_clear_status(tx_info);
+		if (queue < AC_COUNT) {
+			sfbl = WLC_WME_RETRY_SFB_GET(wlc, wme_fifo2ac[queue]);
+			lfbl = WLC_WME_RETRY_LFB_GET(wlc, wme_fifo2ac[queue]);
+		} else {
+			sfbl = wlc->SFBL;
+			lfbl = wlc->LFBL;
+		}
+
+		txrate = tx_info->status.rates;
+		/* FIXME: this should use a combination of sfbl, lfbl depending on frame length and RTS setting */
+		if ((tx_frame_count > sfbl) && (txrate[1].idx >= 0)) {
+			/* rate selection requested a fallback rate and we used it */
+			txrate->count = lfbl;
+			txrate[1].count = tx_frame_count - lfbl;
+		} else {
+			/* rate selection did not request fallback rate, or we didn't need it */
+			txrate->count = tx_frame_count;
+			/* rc80211_minstrel.c:minstrel_tx_status() expects unused rates to be marked with idx = -1 */
+			txrate[1].idx = -1;
+			txrate[1].count = 0;
+		}
+
+		/* clear the rest of the rates */
+		for (i = 2; i < IEEE80211_TX_MAX_RATES; i++) {
+			txrate[i].idx = -1;
+			txrate[i].count = 0;
+		}
+
+		if (txs->status & TX_STATUS_ACK_RCV)
+			tx_info->flags |= IEEE80211_TX_STAT_ACK;
+	}
+
+	totlen = pkttotlen(osh, p);
+	free_pdu = TRUE;
+
+	wlc_txfifo_complete(wlc, queue, 1);
+
+	if (lastframe) {
+		PKTSETNEXT(p, NULL);
+		PKTSETLINK(p, NULL);
+		wlc->txretried = 0;
+		/* remove PLCP & Broadcom tx descriptor header */
+		PKTPULL(p, D11_PHY_HDR_LEN);
+		PKTPULL(p, D11_TXH_LEN);
+		ieee80211_tx_status_irqsafe(wlc->pub->ieee_hw, p);
+		WLCNTINCR(wlc->pub->_cnt->ieee_tx_status);
+	} else {
+		WL_ERROR(("%s: Not last frame => not calling tx_status\n",
+			  __func__));
+	}
+
+	return FALSE;
+
+ fatal:
+	ASSERT(0);
+	if (p)
+		PKTFREE(osh, p, TRUE);
+
+#ifdef WLC_HIGH_ONLY
+	/* If this is a split driver, do the big-hammer here.
+	 * If this is a monolithic driver, wlc_bmac.c:wlc_dpc() will do the big-hammer.
+	 */
+	wl_init(wlc->wl);
+#endif
+	return TRUE;
+
+}
+
+void BCMFASTPATH
+wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend)
+{
+	TXPKTPENDDEC(wlc, fifo, txpktpend);
+	WL_TRACE(("wlc_txfifo_complete, pktpend dec %d to %d\n", txpktpend,
+		  TXPKTPENDGET(wlc, fifo)));
+
+	/* There is more room; mark precedences related to this FIFO sendable */
+	WLC_TX_FIFO_ENAB(wlc, fifo);
+	ASSERT(TXPKTPENDGET(wlc, fifo) >= 0);
+
+	if (!TXPKTPENDTOT(wlc)) {
+		if (wlc->block_datafifo & DATA_BLOCK_TX_SUPR)
+			wlc_bsscfg_tx_check(wlc);
+	}
+
+	/* Clear MHF2_TXBCMC_NOW flag if BCMC fifo has drained */
+	if (AP_ENAB(wlc->pub) &&
+	    wlc->bcmcfifo_drain && !TXPKTPENDGET(wlc, TX_BCMC_FIFO)) {
+		wlc->bcmcfifo_drain = FALSE;
+		wlc_mhf(wlc, MHF2, MHF2_TXBCMC_NOW, 0, WLC_BAND_AUTO);
+	}
+
+	/* figure out which bsscfg is being worked on... */
+}
+
+/* Given the beacon interval in kus, and a 64 bit TSF in us,
+ * return the offset (in us) of the TSF from the last TBTT
+ */
+uint32 wlc_calc_tbtt_offset(uint32 bp, uint32 tsf_h, uint32 tsf_l)
+{
+	uint32 k, btklo, btkhi, offset;
+
+	/* TBTT is always an even multiple of the beacon_interval,
+	 * so the TBTT less than or equal to the beacon timestamp is
+	 * the beacon timestamp minus the beacon timestamp modulo
+	 * the beacon interval.
+	 *
+	 * TBTT = BT - (BT % BIu)
+	 *      = (BTk - (BTk % BP)) * 2^10
+	 *
+	 * BT = beacon timestamp (usec, 64bits)
+	 * BTk = beacon timestamp (Kusec, 54bits)
+	 * BP = beacon interval (Kusec, 16bits)
+	 * BIu = BP * 2^10 = beacon interval (usec, 26bits)
+	 *
+	 * To keep the calculations in uint32s, the modulo operation
+	 * on the high part of BT needs to be done in parts using the
+	 * relations:
+	 * X*Y mod Z = ((X mod Z) * (Y mod Z)) mod Z
+	 * and
+	 * (X + Y) mod Z = ((X mod Z) + (Y mod Z)) mod Z
+	 *
+	 * So, if BTk[n] = uint16 n [0,3] of BTk.
+	 * BTk % BP = SUM((BTk[n] * 2^16n) % BP , 0<=n<4) % BP
+	 * and the SUM term can be broken down:
+	 * (BTk[n] *     2^16n)    % BP
+	 * (BTk[n] * (2^16n % BP)) % BP
+	 *
+	 * Create a set of power of 2 mod BP constants:
+	 * K[n] = 2^(16n) % BP
+	 *      = (K[n-1] * 2^16) % BP
+	 * K[2] = 2^32 % BP = ((2^16 % BP) * 2^16) % BP
+	 *
+	 * BTk % BP = BTk[0-1] % BP +
+	 *            (BTk[2] * K[2]) % BP +
+	 *            (BTk[3] * K[3]) % BP
+	 *
+	 * Since K[n] < 2^16 and BTk[n] is < 2^16, then BTk[n] * K[n] < 2^32
+	 */
+
+	/* BTk = BT >> 10, btklo = BTk[0-3], bkthi = BTk[4-6] */
+	btklo = (tsf_h << 22) | (tsf_l >> 10);
+	btkhi = tsf_h >> 10;
+
+	/* offset = BTk % BP */
+	offset = btklo % bp;
+
+	/* K[2] = ((2^16 % BP) * 2^16) % BP */
+	k = (uint32) (1 << 16) % bp;
+	k = (uint32) (k * 1 << 16) % (uint32) bp;
+
+	/* offset += (BTk[2] * K[2]) % BP */
+	offset += ((btkhi & 0xffff) * k) % bp;
+
+	/* BTk[3] */
+	btkhi = btkhi >> 16;
+
+	/* k[3] = (K[2] * 2^16) % BP */
+	k = (k << 16) % bp;
+
+	/* offset += (BTk[3] * K[3]) % BP */
+	offset += ((btkhi & 0xffff) * k) % bp;
+
+	offset = offset % bp;
+
+	/* convert offset from kus to us by shifting up 10 bits and
+	 * add in the low 10 bits of tsf that we ignored
+	 */
+	offset = (offset << 10) + (tsf_l & 0x3FF);
+
+	return offset;
+}
+
+/* Update beacon listen interval in shared memory */
+void wlc_bcn_li_upd(wlc_info_t * wlc)
+{
+	if (AP_ENAB(wlc->pub))
+		return;
+
+	/* wake up every DTIM is the default */
+	if (wlc->bcn_li_dtim == 1)
+		wlc_write_shm(wlc, M_BCN_LI, 0);
+	else
+		wlc_write_shm(wlc, M_BCN_LI,
+			      (wlc->bcn_li_dtim << 8) | wlc->bcn_li_bcn);
+}
+
+static void
+prep_mac80211_status(wlc_info_t * wlc, d11rxhdr_t * rxh, void *p,
+		     struct ieee80211_rx_status *rx_status)
+{
+	uint32 tsf_l, tsf_h;
+	wlc_d11rxhdr_t *wlc_rxh = (wlc_d11rxhdr_t *) rxh;
+	int preamble;
+	int channel;
+	ratespec_t rspec;
+	uchar *plcp;
+
+	wlc_read_tsf(wlc, &tsf_l, &tsf_h);	/* mactime */
+	rx_status->mactime = tsf_h;
+	rx_status->mactime <<= 32;
+	rx_status->mactime |= tsf_l;
+	rx_status->flag |= RX_FLAG_TSFT;
+
+	channel = WLC_CHAN_CHANNEL(rxh->RxChan);
+
+	/* XXX  Channel/badn needs to be filtered against whether we are single/dual band card */
+	if (channel > 14) {
+		rx_status->band = IEEE80211_BAND_5GHZ;
+		rx_status->freq = wf_channel2mhz(channel, WF_CHAN_FACTOR_5_G);
+	} else {
+		rx_status->band = IEEE80211_BAND_2GHZ;
+		rx_status->freq = wf_channel2mhz(channel, WF_CHAN_FACTOR_2_4_G);
+	}
+
+	rx_status->signal = wlc_rxh->rssi;	/* signal */
+
+	/* noise */
+	/* qual */
+	rx_status->antenna = (rxh->PhyRxStatus_0 & PRXS0_RXANT_UPSUBBAND) ? 1 : 0;	/* ant */
+
+	plcp = PKTDATA(p);
+
+	rspec = wlc_compute_rspec(rxh, plcp);
+	if (IS_MCS(rspec)) {
+		rx_status->rate_idx = rspec & RSPEC_RATE_MASK;
+		rx_status->flag |= RX_FLAG_HT;
+		if (RSPEC_IS40MHZ(rspec))
+			rx_status->flag |= RX_FLAG_40MHZ;
+	} else {
+		switch (RSPEC2RATE(rspec)) {
+		case WLC_RATE_1M:
+			rx_status->rate_idx = 0;
+			break;
+		case WLC_RATE_2M:
+			rx_status->rate_idx = 1;
+			break;
+		case WLC_RATE_5M5:
+			rx_status->rate_idx = 2;
+			break;
+		case WLC_RATE_11M:
+			rx_status->rate_idx = 3;
+			break;
+		case WLC_RATE_6M:
+			rx_status->rate_idx = 4;
+			break;
+		case WLC_RATE_9M:
+			rx_status->rate_idx = 5;
+			break;
+		case WLC_RATE_12M:
+			rx_status->rate_idx = 6;
+			break;
+		case WLC_RATE_18M:
+			rx_status->rate_idx = 7;
+			break;
+		case WLC_RATE_24M:
+			rx_status->rate_idx = 8;
+			break;
+		case WLC_RATE_36M:
+			rx_status->rate_idx = 9;
+			break;
+		case WLC_RATE_48M:
+			rx_status->rate_idx = 10;
+			break;
+		case WLC_RATE_54M:
+			rx_status->rate_idx = 11;
+			break;
+		default:
+			WL_ERROR(("%s: Unknown rate\n", __func__));
+		}
+
+		/* Determine short preamble and rate_idx */
+		preamble = 0;
+		if (IS_CCK(rspec)) {
+			if (rxh->PhyRxStatus_0 & PRXS0_SHORTH)
+				WL_ERROR(("Short CCK\n"));
+			rx_status->flag |= RX_FLAG_SHORTPRE;
+		} else if (IS_OFDM(rspec)) {
+			rx_status->flag |= RX_FLAG_SHORTPRE;
+		} else {
+			WL_ERROR(("%s: Unknown modulation\n", __func__));
+		}
+	}
+
+	if (PLCP3_ISSGI(plcp[3]))
+		rx_status->flag |= RX_FLAG_SHORT_GI;
+
+	if (rxh->RxStatus1 & RXS_DECERR) {
+		rx_status->flag |= RX_FLAG_FAILED_PLCP_CRC;
+		WL_ERROR(("%s:  RX_FLAG_FAILED_PLCP_CRC\n", __func__));
+	}
+	if (rxh->RxStatus1 & RXS_FCSERR) {
+		rx_status->flag |= RX_FLAG_FAILED_FCS_CRC;
+		WL_ERROR(("%s:  RX_FLAG_FAILED_FCS_CRC\n", __func__));
+	}
+}
+
+char *print_fk(uint16 fk)
+{
+	char *str;
+	switch (fk) {
+	case FC_ASSOC_REQ:
+		str = "FC_ASSOC_REQ";
+		break;
+	case FC_ASSOC_RESP:
+		str = "FC_ASSOC_RESP";
+		break;
+	case FC_REASSOC_REQ:
+		str = "FC_REASSOC_REQ";
+		break;
+	case FC_REASSOC_RESP:
+		str = "FC_REASSOC_RESP";
+		break;
+	case FC_PROBE_REQ:
+		str = "FC_PROBE_REQ";
+		break;
+	case FC_PROBE_RESP:
+		str = "FC_PROBE_RESP";
+		break;
+	case FC_BEACON:
+		str = "FC_BEACON";
+		break;
+	case FC_DISASSOC:
+		str = "FC_DISASSOC";
+		break;
+	case FC_AUTH:
+		str = "FC_AUTH";
+		break;
+	case FC_DEAUTH:
+		str = "FC_DEAUTH";
+		break;
+	case FC_ACTION:
+		str = "FC_ACTION";
+		break;
+	case FC_ACTION_NOACK:
+		str = "FC_ACTION_NOACK";
+		break;
+	case FC_CTL_WRAPPER:
+		str = "FC_CTL_WRAPPER";
+		break;
+	case FC_BLOCKACK_REQ:
+		str = "FC_BLOCKACK_REQ";
+		break;
+	case FC_BLOCKACK:
+		str = "FC_BLOCKACK";
+		break;
+	case FC_PS_POLL:
+		str = "FC_PS_POLL";
+		break;
+	case FC_RTS:
+		str = "FC_RTS";
+		break;
+	case FC_CTS:
+		str = "FC_CTS";
+		break;
+	case FC_ACK:
+		str = "FC_ACK";
+		break;
+	case FC_CF_END:
+		str = "FC_CF_END";
+		break;
+	case FC_CF_END_ACK:
+		str = "FC_CF_END_ACK";
+		break;
+	case FC_DATA:
+		str = "FC_DATA";
+		break;
+	case FC_NULL_DATA:
+		str = "FC_NULL_DATA";
+		break;
+	case FC_DATA_CF_ACK:
+		str = "FC_DATA_CF_ACK";
+		break;
+	case FC_QOS_DATA:
+		str = "FC_QOS_DATA";
+		break;
+	case FC_QOS_NULL:
+		str = "FC_QOS_NULL";
+		break;
+	default:
+		str = "Unknown!!";
+		break;
+	}
+	return (str);
+}
+
+static void
+wlc_recvctl(wlc_info_t * wlc, osl_t * osh, d11rxhdr_t * rxh, void *p)
+{
+	int len_mpdu;
+	struct ieee80211_rx_status rx_status;
+#if defined(BCMDBG)
+	struct sk_buff *skb = p;
+#endif				/* BCMDBG */
+	/* Todo:
+	 * Cache plcp for first MPDU of AMPD and use chacched version for INTERMEDIATE.
+	 * Test for INTERMEDIATE  like so:
+	 * if (!(plcp[0] | plcp[1] | plcp[2]))
+	 */
+
+	memset(&rx_status, 0, sizeof(rx_status));
+	prep_mac80211_status(wlc, rxh, p, &rx_status);
+
+	/* mac header+body length, exclude CRC and plcp header */
+	len_mpdu = PKTLEN(p) - D11_PHY_HDR_LEN - DOT11_FCS_LEN;
+	PKTPULL(p, D11_PHY_HDR_LEN);
+	PKTSETLEN(p, len_mpdu);
+
+	ASSERT(!PKTNEXT(p));
+	ASSERT(!PKTLINK(p));
+
+	ASSERT(ISALIGNED((uintptr) skb->data, 2));
+
+	memcpy(IEEE80211_SKB_RXCB(p), &rx_status, sizeof(rx_status));
+	ieee80211_rx_irqsafe(wlc->pub->ieee_hw, p);
+
+	WLCNTINCR(wlc->pub->_cnt->ieee_rx);
+	PKTUNALLOC(osh);
+	return;
+}
+
+void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list)
+{
+	uint index;
+	wlc_bss_info_t *bi;
+
+	if (!bss_list) {
+		WL_ERROR(("%s: Attempting to free NULL list\n", __func__));
+		return;
+	}
+	/* inspect all BSS descriptor */
+	for (index = 0; index < bss_list->count; index++) {
+		bi = bss_list->ptrs[index];
+		if (bi) {
+			if (bi->bcn_prb) {
+				osl_mfree(wlc->osh, bi->bcn_prb,
+					  bi->bcn_prb_len);
+			}
+			osl_mfree(wlc->osh, bi, sizeof(wlc_bss_info_t));
+			bss_list->ptrs[index] = NULL;
+		}
+	}
+	bss_list->count = 0;
+}
+
+/* Process received frames */
+/*
+ * Return TRUE if more frames need to be processed. FALSE otherwise.
+ * Param 'bound' indicates max. # frames to process before break out.
+ */
+/* WLC_HIGH_API */
+void BCMFASTPATH wlc_recv(wlc_info_t * wlc, void *p)
+{
+	d11rxhdr_t *rxh;
+	struct dot11_header *h;
+	osl_t *osh;
+	uint16 fc;
+	uint len;
+	bool is_amsdu;
+#ifdef BCMDBG
+	char eabuf[ETHER_ADDR_STR_LEN];
+#endif
+
+	WL_TRACE(("wl%d: wlc_recv\n", wlc->pub->unit));
+
+	osh = wlc->osh;
+
+	/* frame starts with rxhdr */
+	rxh = (d11rxhdr_t *) PKTDATA(p);
+
+	/* strip off rxhdr */
+	PKTPULL(p, wlc->hwrxoff);
+
+	/* fixup rx header endianness */
+	ltoh16_buf((void *)rxh, sizeof(d11rxhdr_t));
+
+	/* MAC inserts 2 pad bytes for a4 headers or QoS or A-MSDU subframes */
+	if (rxh->RxStatus1 & RXS_PBPRES) {
+		if (PKTLEN(p) < 2) {
+			WLCNTINCR(wlc->pub->_cnt->rxrunt);
+			WL_ERROR(("wl%d: wlc_recv: rcvd runt of len %d\n",
+				  wlc->pub->unit, PKTLEN(p)));
+			goto toss;
+		}
+		PKTPULL(p, 2);
+	}
+
+	h = (struct dot11_header *)(PKTDATA(p) + D11_PHY_HDR_LEN);
+	len = PKTLEN(p);
+
+	if (rxh->RxStatus1 & RXS_FCSERR) {
+		if (wlc->pub->mac80211_state & MAC80211_PROMISC_BCNS) {
+			WL_ERROR(("FCSERR while scanning******* - tossing\n"));
+			goto toss;
+		} else {
+			WL_ERROR(("RCSERR!!!\n"));
+			goto toss;
+		}
+	}
+
+	/* check received pkt has at least frame control field */
+	if (len >= D11_PHY_HDR_LEN + sizeof(h->fc)) {
+		fc = ltoh16(h->fc);
+	} else {
+		WLCNTINCR(wlc->pub->_cnt->rxrunt);
+		goto toss;
+	}
+
+	is_amsdu = rxh->RxStatus2 & RXS_AMSDU_MASK;
+
+	/* explicitly test bad src address to avoid sending bad deauth */
+	if (!is_amsdu) {
+		/* CTS and ACK CTL frames are w/o a2 */
+		if (FC_TYPE(fc) == FC_TYPE_DATA || FC_TYPE(fc) == FC_TYPE_MNG) {
+			if ((ETHER_ISNULLADDR(&h->a2) || ETHER_ISMULTI(&h->a2))) {
+				WL_ERROR(("wl%d: %s: dropping a frame with invalid" " src mac address, a2: %s\n", wlc->pub->unit, __func__, bcm_ether_ntoa(&h->a2, eabuf)));
+				WLCNTINCR(wlc->pub->_cnt->rxbadsrcmac);
+				goto toss;
+			}
+			WLCNTINCR(wlc->pub->_cnt->rxfrag);
+		}
+	}
+
+	/* due to sheer numbers, toss out probe reqs for now */
+	if (FC_TYPE(fc) == FC_TYPE_MNG) {
+		if ((fc & FC_KIND_MASK) == FC_PROBE_REQ)
+			goto toss;
+	}
+
+	if (is_amsdu) {
+		WL_ERROR(("%s: is_amsdu causing toss\n", __func__));
+		goto toss;
+	}
+
+	wlc_recvctl(wlc, osh, rxh, p);
+	return;
+
+ toss:
+	PKTFREE(osh, p, FALSE);
+}
+
+/* calculate frame duration for Mixed-mode L-SIG spoofing, return
+ * number of bytes goes in the length field
+ *
+ * Formula given by HT PHY Spec v 1.13
+ *   len = 3(nsyms + nstream + 3) - 3
+ */
+uint16 BCMFASTPATH
+wlc_calc_lsig_len(wlc_info_t * wlc, ratespec_t ratespec, uint mac_len)
+{
+	uint nsyms, len = 0, kNdps;
+
+	WL_TRACE(("wl%d: wlc_calc_lsig_len: rate %d, len%d\n", wlc->pub->unit,
+		  RSPEC2RATE(ratespec), mac_len));
+
+	if (IS_MCS(ratespec)) {
+		uint mcs = ratespec & RSPEC_RATE_MASK;
+		/* MCS_TXS(mcs) returns num tx streams - 1 */
+		int tot_streams = (MCS_TXS(mcs) + 1) + RSPEC_STC(ratespec);
+
+		ASSERT(WLC_PHY_11N_CAP(wlc->band));
+		/* the payload duration calculation matches that of regular ofdm */
+		/* 1000Ndbps = kbps * 4 */
+		kNdps =
+		    MCS_RATE(mcs, RSPEC_IS40MHZ(ratespec),
+			     RSPEC_ISSGI(ratespec)) * 4;
+
+		if (RSPEC_STC(ratespec) == 0)
+			/* NSyms = CEILING((SERVICE + 8*NBytes + TAIL) / Ndbps) */
+			nsyms =
+			    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +
+				  APHY_TAIL_NBITS) * 1000, kNdps);
+		else
+			/* STBC needs to have even number of symbols */
+			nsyms =
+			    2 *
+			    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +
+				  APHY_TAIL_NBITS) * 1000, 2 * kNdps);
+
+		nsyms += (tot_streams + 3);	/* (+3) account for HT-SIG(2) and HT-STF(1) */
+		/* 3 bytes/symbol @ legacy 6Mbps rate */
+		len = (3 * nsyms) - 3;	/* (-3) excluding service bits and tail bits */
+	}
+
+	return (uint16) len;
+}
+
+/* calculate frame duration of a given rate and length, return time in usec unit */
+uint BCMFASTPATH
+wlc_calc_frame_time(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
+		    uint mac_len)
+{
+	uint nsyms, dur = 0, Ndps, kNdps;
+	uint rate = RSPEC2RATE(ratespec);
+
+	if (rate == 0) {
+		ASSERT(0);
+		WL_ERROR(("wl%d: WAR: using rate of 1 mbps\n", wlc->pub->unit));
+		rate = WLC_RATE_1M;
+	}
+
+	WL_TRACE(("wl%d: wlc_calc_frame_time: rspec 0x%x, preamble_type %d, len%d\n", wlc->pub->unit, ratespec, preamble_type, mac_len));
+
+	if (IS_MCS(ratespec)) {
+		uint mcs = ratespec & RSPEC_RATE_MASK;
+		int tot_streams = MCS_TXS(mcs) + RSPEC_STC(ratespec);
+		ASSERT(WLC_PHY_11N_CAP(wlc->band));
+		ASSERT(WLC_IS_MIMO_PREAMBLE(preamble_type));
+
+		dur = PREN_PREAMBLE + (tot_streams * PREN_PREAMBLE_EXT);
+		if (preamble_type == WLC_MM_PREAMBLE)
+			dur += PREN_MM_EXT;
+		/* 1000Ndbps = kbps * 4 */
+		kNdps =
+		    MCS_RATE(mcs, RSPEC_IS40MHZ(ratespec),
+			     RSPEC_ISSGI(ratespec)) * 4;
+
+		if (RSPEC_STC(ratespec) == 0)
+			/* NSyms = CEILING((SERVICE + 8*NBytes + TAIL) / Ndbps) */
+			nsyms =
+			    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +
+				  APHY_TAIL_NBITS) * 1000, kNdps);
+		else
+			/* STBC needs to have even number of symbols */
+			nsyms =
+			    2 *
+			    CEIL((APHY_SERVICE_NBITS + 8 * mac_len +
+				  APHY_TAIL_NBITS) * 1000, 2 * kNdps);
+
+		dur += APHY_SYMBOL_TIME * nsyms;
+		if (BAND_2G(wlc->band->bandtype))
+			dur += DOT11_OFDM_SIGNAL_EXTENSION;
+	} else if (IS_OFDM(rate)) {
+		dur = APHY_PREAMBLE_TIME;
+		dur += APHY_SIGNAL_TIME;
+		/* Ndbps = Mbps * 4 = rate(500Kbps) * 2 */
+		Ndps = rate * 2;
+		/* NSyms = CEILING((SERVICE + 8*NBytes + TAIL) / Ndbps) */
+		nsyms =
+		    CEIL((APHY_SERVICE_NBITS + 8 * mac_len + APHY_TAIL_NBITS),
+			 Ndps);
+		dur += APHY_SYMBOL_TIME * nsyms;
+		if (BAND_2G(wlc->band->bandtype))
+			dur += DOT11_OFDM_SIGNAL_EXTENSION;
+	} else {
+		/* calc # bits * 2 so factor of 2 in rate (1/2 mbps) will divide out */
+		mac_len = mac_len * 8 * 2;
+		/* calc ceiling of bits/rate = microseconds of air time */
+		dur = (mac_len + rate - 1) / rate;
+		if (preamble_type & WLC_SHORT_PREAMBLE)
+			dur += BPHY_PLCP_SHORT_TIME;
+		else
+			dur += BPHY_PLCP_TIME;
+	}
+	return dur;
+}
+
+/* The opposite of wlc_calc_frame_time */
+static uint
+wlc_calc_frame_len(wlc_info_t * wlc, ratespec_t ratespec, uint8 preamble_type,
+		   uint dur)
+{
+	uint nsyms, mac_len, Ndps, kNdps;
+	uint rate = RSPEC2RATE(ratespec);
+
+	WL_TRACE(("wl%d: wlc_calc_frame_len: rspec 0x%x, preamble_type %d, dur %d\n", wlc->pub->unit, ratespec, preamble_type, dur));
+
+	if (IS_MCS(ratespec)) {
+		uint mcs = ratespec & RSPEC_RATE_MASK;
+		int tot_streams = MCS_TXS(mcs) + RSPEC_STC(ratespec);
+		ASSERT(WLC_PHY_11N_CAP(wlc->band));
+		dur -= PREN_PREAMBLE + (tot_streams * PREN_PREAMBLE_EXT);
+		/* payload calculation matches that of regular ofdm */
+		if (BAND_2G(wlc->band->bandtype))
+			dur -= DOT11_OFDM_SIGNAL_EXTENSION;
+		/* kNdbps = kbps * 4 */
+		kNdps =
+		    MCS_RATE(mcs, RSPEC_IS40MHZ(ratespec),
+			     RSPEC_ISSGI(ratespec)) * 4;
+		nsyms = dur / APHY_SYMBOL_TIME;
+		mac_len =
+		    ((nsyms * kNdps) -
+		     ((APHY_SERVICE_NBITS + APHY_TAIL_NBITS) * 1000)) / 8000;
+	} else if (IS_OFDM(ratespec)) {
+		dur -= APHY_PREAMBLE_TIME;
+		dur -= APHY_SIGNAL_TIME;
+		/* Ndbps = Mbps * 4 = rate(500Kbps) * 2 */
+		Ndps = rate * 2;
+		nsyms = dur / APHY_SYMBOL_TIME;
+		mac_len =
+		    ((nsyms * Ndps) -
+		     (APHY_SERVICE_NBITS + APHY_TAIL_NBITS)) / 8;
+	} else {
+		if (preamble_type & WLC_SHORT_PREAMBLE)
+			dur -= BPHY_PLCP_SHORT_TIME;
+		else
+			dur -= BPHY_PLCP_TIME;
+		mac_len = dur * rate;
+		/* divide out factor of 2 in rate (1/2 mbps) */
+		mac_len = mac_len / 8 / 2;
+	}
+	return mac_len;
+}
+
+static uint
+wlc_calc_ba_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+{
+	WL_TRACE(("wl%d: wlc_calc_ba_time: rspec 0x%x, preamble_type %d\n",
+		  wlc->pub->unit, rspec, preamble_type));
+	/* Spec 9.6: ack rate is the highest rate in BSSBasicRateSet that is less than
+	 * or equal to the rate of the immediately previous frame in the FES
+	 */
+	rspec = WLC_BASIC_RATE(wlc, rspec);
+	ASSERT(VALID_RATE_DBG(wlc, rspec));
+
+	/* BA len == 32 == 16(ctl hdr) + 4(ba len) + 8(bitmap) + 4(fcs) */
+	return wlc_calc_frame_time(wlc, rspec, preamble_type,
+				   (DOT11_BA_LEN + DOT11_BA_BITMAP_LEN +
+				    DOT11_FCS_LEN));
+}
+
+static uint BCMFASTPATH
+wlc_calc_ack_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+{
+	uint dur = 0;
+
+	WL_TRACE(("wl%d: wlc_calc_ack_time: rspec 0x%x, preamble_type %d\n",
+		  wlc->pub->unit, rspec, preamble_type));
+	/* Spec 9.6: ack rate is the highest rate in BSSBasicRateSet that is less than
+	 * or equal to the rate of the immediately previous frame in the FES
+	 */
+	rspec = WLC_BASIC_RATE(wlc, rspec);
+	ASSERT(VALID_RATE_DBG(wlc, rspec));
+
+	/* ACK frame len == 14 == 2(fc) + 2(dur) + 6(ra) + 4(fcs) */
+	dur =
+	    wlc_calc_frame_time(wlc, rspec, preamble_type,
+				(DOT11_ACK_LEN + DOT11_FCS_LEN));
+	return dur;
+}
+
+static uint
+wlc_calc_cts_time(wlc_info_t * wlc, ratespec_t rspec, uint8 preamble_type)
+{
+	WL_TRACE(("wl%d: wlc_calc_cts_time: ratespec 0x%x, preamble_type %d\n",
+		  wlc->pub->unit, rspec, preamble_type));
+	return wlc_calc_ack_time(wlc, rspec, preamble_type);
+}
+
+/* derive wlc->band->basic_rate[] table from 'rateset' */
+void wlc_rate_lookup_init(wlc_info_t * wlc, wlc_rateset_t * rateset)
+{
+	uint8 rate;
+	uint8 mandatory;
+	uint8 cck_basic = 0;
+	uint8 ofdm_basic = 0;
+	uint8 *br = wlc->band->basic_rate;
+	uint i;
+
+	/* incoming rates are in 500kbps units as in 802.11 Supported Rates */
+	bzero(br, WLC_MAXRATE + 1);
+
+	/* For each basic rate in the rates list, make an entry in the
+	 * best basic lookup.
+	 */
+	for (i = 0; i < rateset->count; i++) {
+		/* only make an entry for a basic rate */
+		if (!(rateset->rates[i] & WLC_RATE_FLAG))
+			continue;
+
+		/* mask off basic bit */
+		rate = (rateset->rates[i] & RATE_MASK);
+
+		if (rate > WLC_MAXRATE) {
+			WL_ERROR(("wlc_rate_lookup_init: invalid rate 0x%X in rate set\n", rateset->rates[i]));
+			continue;
+		}
+
+		br[rate] = rate;
+	}
+
+	/* The rate lookup table now has non-zero entries for each
+	 * basic rate, equal to the basic rate: br[basicN] = basicN
+	 *
+	 * To look up the best basic rate corresponding to any
+	 * particular rate, code can use the basic_rate table
+	 * like this
+	 *
+	 * basic_rate = wlc->band->basic_rate[tx_rate]
+	 *
+	 * Make sure there is a best basic rate entry for
+	 * every rate by walking up the table from low rates
+	 * to high, filling in holes in the lookup table
+	 */
+
+	for (i = 0; i < wlc->band->hw_rateset.count; i++) {
+		rate = wlc->band->hw_rateset.rates[i];
+		ASSERT(rate <= WLC_MAXRATE);
+
+		if (br[rate] != 0) {
+			/* This rate is a basic rate.
+			 * Keep track of the best basic rate so far by
+			 * modulation type.
+			 */
+			if (IS_OFDM(rate))
+				ofdm_basic = rate;
+			else
+				cck_basic = rate;
+
+			continue;
+		}
+
+		/* This rate is not a basic rate so figure out the
+		 * best basic rate less than this rate and fill in
+		 * the hole in the table
+		 */
+
+		br[rate] = IS_OFDM(rate) ? ofdm_basic : cck_basic;
+
+		if (br[rate] != 0)
+			continue;
+
+		if (IS_OFDM(rate)) {
+			/* In 11g and 11a, the OFDM mandatory rates are 6, 12, and 24 Mbps */
+			if (rate >= WLC_RATE_24M)
+				mandatory = WLC_RATE_24M;
+			else if (rate >= WLC_RATE_12M)
+				mandatory = WLC_RATE_12M;
+			else
+				mandatory = WLC_RATE_6M;
+		} else {
+			/* In 11b, all the CCK rates are mandatory 1 - 11 Mbps */
+			mandatory = rate;
+		}
+
+		br[rate] = mandatory;
+	}
+}
+
+static void wlc_write_rate_shm(wlc_info_t * wlc, uint8 rate, uint8 basic_rate)
+{
+	uint8 phy_rate, index;
+	uint8 basic_phy_rate, basic_index;
+	uint16 dir_table, basic_table;
+	uint16 basic_ptr;
+
+	/* Shared memory address for the table we are reading */
+	dir_table = IS_OFDM(basic_rate) ? M_RT_DIRMAP_A : M_RT_DIRMAP_B;
+
+	/* Shared memory address for the table we are writing */
+	basic_table = IS_OFDM(rate) ? M_RT_BBRSMAP_A : M_RT_BBRSMAP_B;
+
+	/*
+	 * for a given rate, the LS-nibble of the PLCP SIGNAL field is
+	 * the index into the rate table.
+	 */
+	phy_rate = rate_info[rate] & RATE_MASK;
+	basic_phy_rate = rate_info[basic_rate] & RATE_MASK;
+	index = phy_rate & 0xf;
+	basic_index = basic_phy_rate & 0xf;
+
+	/* Find the SHM pointer to the ACK rate entry by looking in the
+	 * Direct-map Table
+	 */
+	basic_ptr = wlc_read_shm(wlc, (dir_table + basic_index * 2));
+
+	/* Update the SHM BSS-basic-rate-set mapping table with the pointer
+	 * to the correct basic rate for the given incoming rate
+	 */
+	wlc_write_shm(wlc, (basic_table + index * 2), basic_ptr);
+}
+
+static const wlc_rateset_t *wlc_rateset_get_hwrs(wlc_info_t * wlc)
+{
+	const wlc_rateset_t *rs_dflt;
+
+	if (WLC_PHY_11N_CAP(wlc->band)) {
+		if (BAND_5G(wlc->band->bandtype))
+			rs_dflt = &ofdm_mimo_rates;
+		else
+			rs_dflt = &cck_ofdm_mimo_rates;
+	} else if (wlc->band->gmode)
+		rs_dflt = &cck_ofdm_rates;
+	else
+		rs_dflt = &cck_rates;
+
+	return rs_dflt;
+}
+
+void wlc_set_ratetable(wlc_info_t * wlc)
+{
+	const wlc_rateset_t *rs_dflt;
+	wlc_rateset_t rs;
+	uint8 rate, basic_rate;
+	uint i;
+
+	rs_dflt = wlc_rateset_get_hwrs(wlc);
+	ASSERT(rs_dflt != NULL);
+
+	wlc_rateset_copy(rs_dflt, &rs);
+	wlc_rateset_mcs_upd(&rs, wlc->stf->txstreams);
+
+	/* walk the phy rate table and update SHM basic rate lookup table */
+	for (i = 0; i < rs.count; i++) {
+		rate = rs.rates[i] & RATE_MASK;
+
+		/* for a given rate WLC_BASIC_RATE returns the rate at
+		 * which a response ACK/CTS should be sent.
+		 */
+		basic_rate = WLC_BASIC_RATE(wlc, rate);
+		if (basic_rate == 0) {
+			/* This should only happen if we are using a
+			 * restricted rateset.
+			 */
+			basic_rate = rs.rates[0] & RATE_MASK;
+		}
+
+		wlc_write_rate_shm(wlc, rate, basic_rate);
+	}
+}
+
+/*
+ * Return true if the specified rate is supported by the specified band.
+ * WLC_BAND_AUTO indicates the current band.
+ */
+bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rspec, int band, bool verbose)
+{
+	wlc_rateset_t *hw_rateset;
+	uint i;
+
+	if ((band == WLC_BAND_AUTO) || (band == wlc->band->bandtype)) {
+		hw_rateset = &wlc->band->hw_rateset;
+	} else if (NBANDS(wlc) > 1) {
+		hw_rateset = &wlc->bandstate[OTHERBANDUNIT(wlc)]->hw_rateset;
+	} else {
+		/* other band specified and we are a single band device */
+		return (FALSE);
+	}
+
+	/* check if this is a mimo rate */
+	if (IS_MCS(rspec)) {
+		if (!VALID_MCS((rspec & RSPEC_RATE_MASK)))
+			goto error;
+
+		return isset(hw_rateset->mcs, (rspec & RSPEC_RATE_MASK));
+	}
+
+	for (i = 0; i < hw_rateset->count; i++)
+		if (hw_rateset->rates[i] == RSPEC2RATE(rspec))
+			return (TRUE);
+ error:
+	if (verbose) {
+		WL_ERROR(("wl%d: wlc_valid_rate: rate spec 0x%x not in hw_rateset\n", wlc->pub->unit, rspec));
+	}
+
+	return (FALSE);
+}
+
+static void wlc_update_mimo_band_bwcap(wlc_info_t * wlc, uint8 bwcap)
+{
+	uint i;
+	wlcband_t *band;
+
+	for (i = 0; i < NBANDS(wlc); i++) {
+		if (IS_SINGLEBAND_5G(wlc->deviceid))
+			i = BAND_5G_INDEX;
+		band = wlc->bandstate[i];
+		if (band->bandtype == WLC_BAND_5G) {
+			if ((bwcap == WLC_N_BW_40ALL)
+			    || (bwcap == WLC_N_BW_20IN2G_40IN5G))
+				band->mimo_cap_40 = TRUE;
+			else
+				band->mimo_cap_40 = FALSE;
+		} else {
+			ASSERT(band->bandtype == WLC_BAND_2G);
+			if (bwcap == WLC_N_BW_40ALL)
+				band->mimo_cap_40 = TRUE;
+			else
+				band->mimo_cap_40 = FALSE;
+		}
+	}
+
+	wlc->mimo_band_bwcap = bwcap;
+}
+
+void wlc_mod_prb_rsp_rate_table(wlc_info_t * wlc, uint frame_len)
+{
+	const wlc_rateset_t *rs_dflt;
+	wlc_rateset_t rs;
+	uint8 rate;
+	uint16 entry_ptr;
+	uint8 plcp[D11_PHY_HDR_LEN];
+	uint16 dur, sifs;
+	uint i;
+
+	sifs = SIFS(wlc->band);
+
+	rs_dflt = wlc_rateset_get_hwrs(wlc);
+	ASSERT(rs_dflt != NULL);
+
+	wlc_rateset_copy(rs_dflt, &rs);
+	wlc_rateset_mcs_upd(&rs, wlc->stf->txstreams);
+
+	/* walk the phy rate table and update MAC core SHM basic rate table entries */
+	for (i = 0; i < rs.count; i++) {
+		rate = rs.rates[i] & RATE_MASK;
+
+		entry_ptr = wlc_rate_shm_offset(wlc, rate);
+
+		/* Calculate the Probe Response PLCP for the given rate */
+		wlc_compute_plcp(wlc, rate, frame_len, plcp);
+
+		/* Calculate the duration of the Probe Response frame plus SIFS for the MAC */
+		dur =
+		    (uint16) wlc_calc_frame_time(wlc, rate, WLC_LONG_PREAMBLE,
+						 frame_len);
+		dur += sifs;
+
+		/* Update the SHM Rate Table entry Probe Response values */
+		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS,
+			      (uint16) (plcp[0] + (plcp[1] << 8)));
+		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS + 2,
+			      (uint16) (plcp[2] + (plcp[3] << 8)));
+		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_DUR_POS, dur);
+	}
+}
+
+uint16
+wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec, bool short_preamble,
+		      bool phydelay)
+{
+	uint bcntsfoff = 0;
+
+	if (IS_MCS(rspec)) {
+		WL_ERROR(("wl%d: recd beacon with mcs rate; rspec 0x%x\n",
+			  wlc->pub->unit, rspec));
+	} else if (IS_OFDM(rspec)) {
+		/* tx delay from MAC through phy to air (2.1 usec) +
+		 * phy header time (preamble + PLCP SIGNAL == 20 usec) +
+		 * PLCP SERVICE + MAC header time (SERVICE + FC + DUR + A1 + A2 + A3 + SEQ == 26
+		 * bytes at beacon rate)
+		 */
+		bcntsfoff += phydelay ? D11A_PHY_TX_DELAY : 0;
+		bcntsfoff += APHY_PREAMBLE_TIME + APHY_SIGNAL_TIME;
+		bcntsfoff +=
+		    wlc_compute_airtime(wlc, rspec,
+					APHY_SERVICE_NBITS / 8 +
+					DOT11_MAC_HDR_LEN);
+	} else {
+		/* tx delay from MAC through phy to air (3.4 usec) +
+		 * phy header time (long preamble + PLCP == 192 usec) +
+		 * MAC header time (FC + DUR + A1 + A2 + A3 + SEQ == 24 bytes at beacon rate)
+		 */
+		bcntsfoff += phydelay ? D11B_PHY_TX_DELAY : 0;
+		bcntsfoff +=
+		    short_preamble ? D11B_PHY_SPREHDR_TIME :
+		    D11B_PHY_LPREHDR_TIME;
+		bcntsfoff += wlc_compute_airtime(wlc, rspec, DOT11_MAC_HDR_LEN);
+	}
+	return (uint16) (bcntsfoff);
+}
+
+/*	Max buffering needed for beacon template/prb resp template is 142 bytes.
+ *
+ *	PLCP header is 6 bytes.
+ *	802.11 A3 header is 24 bytes.
+ *	Max beacon frame body template length is 112 bytes.
+ *	Max probe resp frame body template length is 110 bytes.
+ *
+ *      *len on input contains the max length of the packet available.
+ *
+ *	The *len value is set to the number of bytes in buf used, and starts with the PLCP
+ *	and included up to, but not including, the 4 byte FCS.
+ */
+static void
+wlc_bcn_prb_template(wlc_info_t * wlc, uint type, ratespec_t bcn_rspec,
+		     wlc_bsscfg_t * cfg, uint16 * buf, int *len)
+{
+	cck_phy_hdr_t *plcp;
+	struct dot11_management_header *h;
+	int hdr_len, body_len;
+
+	ASSERT(*len >= 142);
+	ASSERT(type == FC_BEACON || type == FC_PROBE_RESP);
+
+	if (MBSS_BCN_ENAB(cfg) && type == FC_BEACON)
+		hdr_len = DOT11_MAC_HDR_LEN;
+	else
+		hdr_len = D11_PHY_HDR_LEN + DOT11_MAC_HDR_LEN;
+	body_len = *len - hdr_len;	/* calc buffer size provided for frame body */
+
+	*len = hdr_len + body_len;	/* return actual size */
+
+	/* format PHY and MAC headers */
+	bzero((char *)buf, hdr_len);
+
+	plcp = (cck_phy_hdr_t *) buf;
+
+	/* PLCP for Probe Response frames are filled in from core's rate table */
+	if (type == FC_BEACON && !MBSS_BCN_ENAB(cfg)) {
+		/* fill in PLCP */
+		wlc_compute_plcp(wlc, bcn_rspec,
+				 (DOT11_MAC_HDR_LEN + body_len + DOT11_FCS_LEN),
+				 (uint8 *) plcp);
+
+	}
+	/* "Regular" and 16 MBSS but not for 4 MBSS */
+	/* Update the phytxctl for the beacon based on the rspec */
+	if (!SOFTBCN_ENAB(cfg))
+		wlc_beacon_phytxctl_txant_upd(wlc, bcn_rspec);
+
+	if (MBSS_BCN_ENAB(cfg) && type == FC_BEACON)
+		h = (struct dot11_management_header *)&plcp[0];
+	else
+		h = (struct dot11_management_header *)&plcp[1];
+
+	/* fill in 802.11 header */
+	h->fc = htol16((uint16) type);
+
+	/* DUR is 0 for multicast bcn, or filled in by MAC for prb resp */
+	/* A1 filled in by MAC for prb resp, broadcast for bcn */
+	if (type == FC_BEACON)
+		bcopy((const char *)&ether_bcast, (char *)&h->da,
+		      ETHER_ADDR_LEN);
+	bcopy((char *)&cfg->cur_etheraddr, (char *)&h->sa, ETHER_ADDR_LEN);
+	bcopy((char *)&cfg->BSSID, (char *)&h->bssid, ETHER_ADDR_LEN);
+
+	/* SEQ filled in by MAC */
+
+	return;
+}
+
+int wlc_get_header_len()
+{
+	return TXOFF;
+}
+
+/* Update a beacon for a particular BSS
+ * For MBSS, this updates the software template and sets "latest" to the index of the
+ * template updated.
+ * Otherwise, it updates the hardware template.
+ */
+void wlc_bss_update_beacon(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
+{
+	int len = BCN_TMPL_LEN;
+
+	/* Clear the soft intmask */
+	wlc->defmacintmask &= ~MI_BCNTPL;
+
+	if (!cfg->up) {		/* Only allow updates on an UP bss */
+		return;
+	}
+
+	if (MBSS_BCN_ENAB(cfg)) {	/* Optimize:  Some of if/else could be combined */
+	} else if (HWBCN_ENAB(cfg)) {	/* Hardware beaconing for this config */
+		uint16 bcn[BCN_TMPL_LEN / 2];
+		uint32 both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;
+		d11regs_t *regs = wlc->regs;
+		osl_t *osh = NULL;
+
+		osh = wlc->osh;
+
+		/* Check if both templates are in use, if so sched. an interrupt
+		 *      that will call back into this routine
+		 */
+		if ((R_REG(osh, &regs->maccommand) & both_valid) == both_valid) {
+			/* clear any previous status */
+			W_REG(osh, &regs->macintstatus, MI_BCNTPL);
+		}
+		/* Check that after scheduling the interrupt both of the
+		 *      templates are still busy. if not clear the int. & remask
+		 */
+		if ((R_REG(osh, &regs->maccommand) & both_valid) == both_valid) {
+			wlc->defmacintmask |= MI_BCNTPL;
+			return;
+		}
+
+		wlc->bcn_rspec =
+		    wlc_lowest_basic_rspec(wlc, &cfg->current_bss->rateset);
+		ASSERT(wlc_valid_rate
+		       (wlc, wlc->bcn_rspec,
+			CHSPEC_IS2G(cfg->current_bss->
+				    chanspec) ? WLC_BAND_2G : WLC_BAND_5G,
+			TRUE));
+
+		/* update the template and ucode shm */
+		wlc_bcn_prb_template(wlc, FC_BEACON, wlc->bcn_rspec, cfg, bcn,
+				     &len);
+		wlc_write_hw_bcntemplates(wlc, bcn, len, FALSE);
+	}
+}
+
+/*
+ * Update all beacons for the system.
+ */
+void wlc_update_beacon(wlc_info_t * wlc)
+{
+	int idx;
+	wlc_bsscfg_t *bsscfg;
+
+	/* update AP or IBSS beacons */
+	FOREACH_BSS(wlc, idx, bsscfg) {
+		if (bsscfg->up && (BSSCFG_AP(bsscfg) || !bsscfg->BSS))
+			wlc_bss_update_beacon(wlc, bsscfg);
+	}
+}
+
+/* Write ssid into shared memory */
+void wlc_shm_ssid_upd(wlc_info_t * wlc, wlc_bsscfg_t * cfg)
+{
+	uint8 *ssidptr = cfg->SSID;
+	uint16 base = M_SSID;
+	uint8 ssidbuf[DOT11_MAX_SSID_LEN];
+
+	/* padding the ssid with zero and copy it into shm */
+	bzero(ssidbuf, DOT11_MAX_SSID_LEN);
+	bcopy(ssidptr, ssidbuf, cfg->SSID_len);
+
+	wlc_copyto_shm(wlc, base, ssidbuf, DOT11_MAX_SSID_LEN);
+
+	if (!MBSS_BCN_ENAB(cfg))
+		wlc_write_shm(wlc, M_SSIDLEN, (uint16) cfg->SSID_len);
+}
+
+void wlc_update_probe_resp(wlc_info_t * wlc, bool suspend)
+{
+	int idx;
+	wlc_bsscfg_t *bsscfg;
+
+	/* update AP or IBSS probe responses */
+	FOREACH_BSS(wlc, idx, bsscfg) {
+		if (bsscfg->up && (BSSCFG_AP(bsscfg) || !bsscfg->BSS))
+			wlc_bss_update_probe_resp(wlc, bsscfg, suspend);
+	}
+}
+
+void
+wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg, bool suspend)
+{
+	uint16 prb_resp[BCN_TMPL_LEN / 2];
+	int len = BCN_TMPL_LEN;
+
+	/* write the probe response to hardware, or save in the config structure */
+	if (!MBSS_PRB_ENAB(cfg)) {
+
+		/* create the probe response template */
+		wlc_bcn_prb_template(wlc, FC_PROBE_RESP, 0, cfg, prb_resp,
+				     &len);
+
+		if (suspend)
+			wlc_suspend_mac_and_wait(wlc);
+
+		/* write the probe response into the template region */
+		wlc_bmac_write_template_ram(wlc->hw, T_PRS_TPL_BASE,
+					    (len + 3) & ~3, prb_resp);
+
+		/* write the length of the probe response frame (+PLCP/-FCS) */
+		wlc_write_shm(wlc, M_PRB_RESP_FRM_LEN, (uint16) len);
+
+		/* write the SSID and SSID length */
+		wlc_shm_ssid_upd(wlc, cfg);
+
+		/*
+		 * Write PLCP headers and durations for probe response frames at all rates.
+		 * Use the actual frame length covered by the PLCP header for the call to
+		 * wlc_mod_prb_rsp_rate_table() by subtracting the PLCP len and adding the FCS.
+		 */
+		len += (-D11_PHY_HDR_LEN + DOT11_FCS_LEN);
+		wlc_mod_prb_rsp_rate_table(wlc, (uint16) len);
+
+		if (suspend)
+			wlc_enable_mac(wlc);
+	} else {		/* Generating probe resp in sw; update local template */
+		ASSERT(0 && "No software probe response support without MBSS");
+	}
+}
+
+/* prepares pdu for transmission. returns BCM error codes */
+int wlc_prep_pdu(wlc_info_t * wlc, void *pdu, uint * fifop)
+{
+	osl_t *osh;
+	uint fifo;
+	d11txh_t *txh;
+	struct dot11_header *h;
+	struct scb *scb;
+	uint16 fc;
+
+	osh = wlc->osh;
+
+	ASSERT(pdu);
+	txh = (d11txh_t *) PKTDATA(pdu);
+	ASSERT(txh);
+	h = (struct dot11_header *)((uint8 *) (txh + 1) + D11_PHY_HDR_LEN);
+	ASSERT(h);
+	fc = ltoh16(h->fc);
+
+	/* get the pkt queue info. This was put at wlc_sendctl or wlc_send for PDU */
+	fifo = ltoh16(txh->TxFrameID) & TXFID_QUEUE_MASK;
+
+	scb = NULL;
+
+	*fifop = fifo;
+
+	/* return if insufficient dma resources */
+	if (TXAVAIL(wlc, fifo) < MAX_DMA_SEGS) {
+		/* Mark precedences related to this FIFO, unsendable */
+		WLC_TX_FIFO_CLEAR(wlc, fifo);
+		return BCME_BUSY;
+	}
+
+	if (FC_TYPE(ltoh16(txh->MacFrameControl)) != FC_TYPE_DATA)
+		WLCNTINCR(wlc->pub->_cnt->txctl);
+
+	return 0;
+}
+
+/* init tx reported rate mechanism */
+void wlc_reprate_init(wlc_info_t * wlc)
+{
+	int i;
+	wlc_bsscfg_t *bsscfg;
+
+	FOREACH_BSS(wlc, i, bsscfg) {
+		wlc_bsscfg_reprate_init(bsscfg);
+	}
+}
+
+/* per bsscfg init tx reported rate mechanism */
+void wlc_bsscfg_reprate_init(wlc_bsscfg_t * bsscfg)
+{
+	bsscfg->txrspecidx = 0;
+	bzero((char *)bsscfg->txrspec, sizeof(bsscfg->txrspec));
+}
+
+/* Retrieve a consolidated set of revision information,
+ * typically for the WLC_GET_REVINFO ioctl
+ */
+int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len)
+{
+	wlc_rev_info_t *rinfo = (wlc_rev_info_t *) buf;
+
+	if (len < WL_REV_INFO_LEGACY_LENGTH)
+		return BCME_BUFTOOSHORT;
+
+	rinfo->vendorid = wlc->vendorid;
+	rinfo->deviceid = wlc->deviceid;
+	rinfo->radiorev = (wlc->band->radiorev << IDCODE_REV_SHIFT) |
+	    (wlc->band->radioid << IDCODE_ID_SHIFT);
+	rinfo->chiprev = wlc->pub->sih->chiprev;
+	rinfo->corerev = wlc->pub->corerev;
+	rinfo->boardid = wlc->pub->sih->boardtype;
+	rinfo->boardvendor = wlc->pub->sih->boardvendor;
+	rinfo->boardrev = wlc->pub->boardrev;
+	rinfo->ucoderev = wlc->ucode_rev;
+	rinfo->driverrev = EPI_VERSION_NUM;
+	rinfo->bus = wlc->pub->sih->bustype;
+	rinfo->chipnum = wlc->pub->sih->chip;
+
+	if (len >= (OFFSETOF(wlc_rev_info_t, chippkg))) {
+		rinfo->phytype = wlc->band->phytype;
+		rinfo->phyrev = wlc->band->phyrev;
+		rinfo->anarev = 0;	/* obsolete stuff, suppress */
+	}
+
+	if (len >= sizeof(*rinfo)) {
+		rinfo->chippkg = wlc->pub->sih->chippkg;
+	}
+
+	return BCME_OK;
+}
+
+void wlc_default_rateset(wlc_info_t * wlc, wlc_rateset_t * rs)
+{
+	wlc_rateset_default(rs, NULL, wlc->band->phytype, wlc->band->bandtype,
+			    FALSE, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
+			    CHSPEC_WLC_BW(wlc->default_bss->chanspec),
+			    wlc->stf->txstreams);
+}
+
+static void BCMATTACHFN(wlc_bss_default_init) (wlc_info_t * wlc) {
+	chanspec_t chanspec;
+	wlcband_t *band;
+	wlc_bss_info_t *bi = wlc->default_bss;
+
+	/* init default and target BSS with some sane initial values */
+	bzero((char *)(bi), sizeof(wlc_bss_info_t));
+	bi->beacon_period = ISSIM_ENAB(wlc->pub->sih) ? BEACON_INTERVAL_DEF_QT :
+	    BEACON_INTERVAL_DEFAULT;
+	bi->dtim_period = ISSIM_ENAB(wlc->pub->sih) ? DTIM_INTERVAL_DEF_QT :
+	    DTIM_INTERVAL_DEFAULT;
+
+	/* fill the default channel as the first valid channel
+	 * starting from the 2G channels
+	 */
+	chanspec = CH20MHZ_CHSPEC(1);
+	ASSERT(chanspec != INVCHANSPEC);
+
+	wlc->home_chanspec = bi->chanspec = chanspec;
+
+	/* find the band of our default channel */
+	band = wlc->band;
+	if (NBANDS(wlc) > 1 && band->bandunit != CHSPEC_WLCBANDUNIT(chanspec))
+		band = wlc->bandstate[OTHERBANDUNIT(wlc)];
+
+	/* init bss rates to the band specific default rate set */
+	wlc_rateset_default(&bi->rateset, NULL, band->phytype, band->bandtype,
+			    FALSE, RATE_MASK_FULL, (bool) N_ENAB(wlc->pub),
+			    CHSPEC_WLC_BW(chanspec), wlc->stf->txstreams);
+
+	if (N_ENAB(wlc->pub))
+		bi->flags |= WLC_BSS_HT;
+}
+
+/* Deferred event processing */
+static void wlc_process_eventq(void *arg)
+{
+	wlc_info_t *wlc = (wlc_info_t *) arg;
+	wlc_event_t *etmp;
+
+	while ((etmp = wlc_eventq_deq(wlc->eventq))) {
+		/* Perform OS specific event processing */
+		wl_event(wlc->wl, etmp->event.ifname, etmp);
+		if (etmp->data) {
+			osl_mfree(wlc->osh, etmp->data, etmp->event.datalen);
+			etmp->data = NULL;
+		}
+		wlc_event_free(wlc->eventq, etmp);
+	}
+}
+
+void
+wlc_uint64_sub(uint32 * a_high, uint32 * a_low, uint32 b_high, uint32 b_low)
+{
+	if (b_low > *a_low) {
+		/* low half needs a carry */
+		b_high += 1;
+	}
+	*a_low -= b_low;
+	*a_high -= b_high;
+}
+
+static ratespec_t
+mac80211_wlc_set_nrate(wlc_info_t * wlc, wlcband_t * cur_band, uint32 int_val)
+{
+	uint8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
+	uint8 rate = int_val & NRATE_RATE_MASK;
+	ratespec_t rspec;
+	bool ismcs = ((int_val & NRATE_MCS_INUSE) == NRATE_MCS_INUSE);
+	bool issgi = ((int_val & NRATE_SGI_MASK) >> NRATE_SGI_SHIFT);
+	bool override_mcs_only = ((int_val & NRATE_OVERRIDE_MCS_ONLY)
+				  == NRATE_OVERRIDE_MCS_ONLY);
+	int bcmerror = 0;
+
+	if (!ismcs) {
+		return (ratespec_t) rate;
+	}
+
+	/* validate the combination of rate/mcs/stf is allowed */
+	if (N_ENAB(wlc->pub) && ismcs) {
+		/* mcs only allowed when nmode */
+		if (stf > PHY_TXC1_MODE_SDM) {
+			WL_ERROR(("wl%d: %s: Invalid stf\n", WLCWLUNIT(wlc),
+				  __func__));
+			bcmerror = BCME_RANGE;
+			goto done;
+		}
+
+		/* mcs 32 is a special case, DUP mode 40 only */
+		if (rate == 32) {
+			if (!CHSPEC_IS40(wlc->home_chanspec) ||
+			    ((stf != PHY_TXC1_MODE_SISO)
+			     && (stf != PHY_TXC1_MODE_CDD))) {
+				WL_ERROR(("wl%d: %s: Invalid mcs 32\n",
+					  WLCWLUNIT(wlc), __func__));
+				bcmerror = BCME_RANGE;
+				goto done;
+			}
+			/* mcs > 7 must use stf SDM */
+		} else if (rate > HIGHEST_SINGLE_STREAM_MCS) {
+			/* mcs > 7 must use stf SDM */
+			if (stf != PHY_TXC1_MODE_SDM) {
+				WL_TRACE(("wl%d: %s: enabling SDM mode for mcs %d\n", WLCWLUNIT(wlc), __func__, rate));
+				stf = PHY_TXC1_MODE_SDM;
+			}
+		} else {
+			/* MCS 0-7 may use SISO, CDD, and for phy_rev >= 3 STBC */
+			if ((stf > PHY_TXC1_MODE_STBC) ||
+			    (!WLC_STBC_CAP_PHY(wlc)
+			     && (stf == PHY_TXC1_MODE_STBC))) {
+				WL_ERROR(("wl%d: %s: Invalid STBC\n",
+					  WLCWLUNIT(wlc), __func__));
+				bcmerror = BCME_RANGE;
+				goto done;
+			}
+		}
+	} else if (IS_OFDM(rate)) {
+		if ((stf != PHY_TXC1_MODE_CDD) && (stf != PHY_TXC1_MODE_SISO)) {
+			WL_ERROR(("wl%d: %s: Invalid OFDM\n", WLCWLUNIT(wlc),
+				  __func__));
+			bcmerror = BCME_RANGE;
+			goto done;
+		}
+	} else if (IS_CCK(rate)) {
+		if ((cur_band->bandtype != WLC_BAND_2G)
+		    || (stf != PHY_TXC1_MODE_SISO)) {
+			WL_ERROR(("wl%d: %s: Invalid CCK\n", WLCWLUNIT(wlc),
+				  __func__));
+			bcmerror = BCME_RANGE;
+			goto done;
+		}
+	} else {
+		WL_ERROR(("wl%d: %s: Unknown rate type\n", WLCWLUNIT(wlc),
+			  __func__));
+		bcmerror = BCME_RANGE;
+		goto done;
+	}
+	/* make sure multiple antennae are available for non-siso rates */
+	if ((stf != PHY_TXC1_MODE_SISO) && (wlc->stf->txstreams == 1)) {
+		WL_ERROR(("wl%d: %s: SISO antenna but !SISO request\n",
+			  WLCWLUNIT(wlc), __func__));
+		bcmerror = BCME_RANGE;
+		goto done;
+	}
+
+	rspec = rate;
+	if (ismcs) {
+		rspec |= RSPEC_MIMORATE;
+		/* For STBC populate the STC field of the ratespec */
+		if (stf == PHY_TXC1_MODE_STBC) {
+			uint8 stc;
+			stc = 1;	/* Nss for single stream is always 1 */
+			rspec |= (stc << RSPEC_STC_SHIFT);
+		}
+	}
+
+	rspec |= (stf << RSPEC_STF_SHIFT);
+
+	if (override_mcs_only)
+		rspec |= RSPEC_OVERRIDE_MCS_ONLY;
+
+	if (issgi)
+		rspec |= RSPEC_SHORT_GI;
+
+	if ((rate != 0)
+	    && !wlc_valid_rate(wlc, rspec, cur_band->bandtype, TRUE)) {
+		return rate;
+	}
+
+	return rspec;
+ done:
+	WL_ERROR(("Hoark\n"));
+	return rate;
+}
+
+/* formula:  IDLE_BUSY_RATIO_X_16 = (100-duty_cycle)/duty_cycle*16 */
+static int
+wlc_duty_cycle_set(wlc_info_t * wlc, int duty_cycle, bool isOFDM,
+		   bool writeToShm)
+{
+	int idle_busy_ratio_x_16 = 0;
+	uint offset =
+	    isOFDM ? M_TX_IDLE_BUSY_RATIO_X_16_OFDM :
+	    M_TX_IDLE_BUSY_RATIO_X_16_CCK;
+	if (duty_cycle > 100 || duty_cycle < 0) {
+		WL_ERROR(("wl%d:  duty cycle value off limit\n",
+			  wlc->pub->unit));
+		return BCME_RANGE;
+	}
+	if (duty_cycle)
+		idle_busy_ratio_x_16 = (100 - duty_cycle) * 16 / duty_cycle;
+	/* Only write to shared memory  when wl is up */
+	if (writeToShm)
+		wlc_write_shm(wlc, offset, (uint16) idle_busy_ratio_x_16);
+
+	if (isOFDM)
+		wlc->tx_duty_cycle_ofdm = (uint16) duty_cycle;
+	else
+		wlc->tx_duty_cycle_cck = (uint16) duty_cycle;
+
+	return BCME_OK;
+}
+
+void
+wlc_pktengtx(wlc_info_t * wlc, wl_pkteng_t * pkteng, uint8 rate,
+	     struct ether_addr *sa, uint32 wait_delay)
+{
+	bool suspend;
+	uint16 val = M_PKTENG_MODE_TX;
+	volatile uint16 frame_cnt_check;
+	uint8 counter = 0;
+
+	wlc_bmac_set_deaf(wlc->hw, TRUE);
+
+	suspend =
+	    (0 == (R_REG(wlc->hw->osh, &wlc->regs->maccontrol) & MCTL_EN_MAC));
+	if (suspend)
+		wlc_enable_mac(wlc);
+
+	/* set nframes */
+	if (pkteng->nframes) {
+		/* retry counter is used to replay the packet */
+		wlc_bmac_write_shm(wlc->hw, M_PKTENG_FRMCNT_LO,
+				   (pkteng->nframes & 0xffff));
+		wlc_bmac_write_shm(wlc->hw, M_PKTENG_FRMCNT_HI,
+				   ((pkteng->nframes >> 16) & 0xffff));
+		val |= M_PKTENG_FRMCNT_VLD;
+	}
+
+	if (pkteng->length) {
+		/* DATA frame */
+		wlc_bmac_write_shm(wlc->hw, M_PKTENG_CTRL, val);
+		/* we write to M_MFGTEST_IFS the IFS required in 1/8us factor */
+		/* 10 : for factoring difference b/w Tx.crs and energy in air */
+		/* 44 : amount of time spent after TX_RRSP to frame start */
+		/* IFS */
+		wlc_bmac_write_shm(wlc->hw, M_PKTENG_IFS,
+				   (pkteng->delay - 10) * 8 - 44);
+	} else {
+		/* CTS frame */
+		val |= M_PKTENG_MODE_TX_CTS;
+		wlc_bmac_write_shm(wlc->hw, M_PKTENG_IFS,
+				   (uint16) pkteng->delay);
+		wlc_bmac_write_shm(wlc->hw, M_PKTENG_CTRL, val);
+	}
+
+	/* Wait for packets to finish */
+	frame_cnt_check = wlc_bmac_read_shm(wlc->hw, M_PKTENG_FRMCNT_LO);
+	while ((counter < 100) && (frame_cnt_check != 0)) {
+		OSL_DELAY(100);
+		frame_cnt_check =
+		    wlc_bmac_read_shm(wlc->hw, M_PKTENG_FRMCNT_LO);
+		counter++;
+	}
+
+	wlc_bmac_write_shm(wlc->hw, M_PKTENG_CTRL, 0);
+
+	if (suspend)
+		wlc_suspend_mac_and_wait(wlc);
+
+	wlc_bmac_set_deaf(wlc->hw, FALSE);
+}
+
+/* Read a single uint16 from shared memory.
+ * SHM 'offset' needs to be an even address
+ */
+uint16 wlc_read_shm(wlc_info_t * wlc, uint offset)
+{
+	return wlc_bmac_read_shm(wlc->hw, offset);
+}
+
+/* Write a single uint16 to shared memory.
+ * SHM 'offset' needs to be an even address
+ */
+void wlc_write_shm(wlc_info_t * wlc, uint offset, uint16 v)
+{
+	wlc_bmac_write_shm(wlc->hw, offset, v);
+}
+
+/* Set a range of shared memory to a value.
+ * SHM 'offset' needs to be an even address and
+ * Range length 'len' must be an even number of bytes
+ */
+void wlc_set_shm(wlc_info_t * wlc, uint offset, uint16 v, int len)
+{
+	/* offset and len need to be even */
+	ASSERT((offset & 1) == 0);
+	ASSERT((len & 1) == 0);
+
+	if (len <= 0)
+		return;
+
+	wlc_bmac_set_shm(wlc->hw, offset, v, len);
+}
+
+/* Copy a buffer to shared memory.
+ * SHM 'offset' needs to be an even address and
+ * Buffer length 'len' must be an even number of bytes
+ */
+void wlc_copyto_shm(wlc_info_t * wlc, uint offset, const void *buf, int len)
+{
+	/* offset and len need to be even */
+	ASSERT((offset & 1) == 0);
+	ASSERT((len & 1) == 0);
+
+	if (len <= 0)
+		return;
+	wlc_bmac_copyto_objmem(wlc->hw, offset, buf, len, OBJADDR_SHM_SEL);
+
+}
+
+/* Copy from shared memory to a buffer.
+ * SHM 'offset' needs to be an even address and
+ * Buffer length 'len' must be an even number of bytes
+ */
+void wlc_copyfrom_shm(wlc_info_t * wlc, uint offset, void *buf, int len)
+{
+	/* offset and len need to be even */
+	ASSERT((offset & 1) == 0);
+	ASSERT((len & 1) == 0);
+
+	if (len <= 0)
+		return;
+
+	wlc_bmac_copyfrom_objmem(wlc->hw, offset, buf, len, OBJADDR_SHM_SEL);
+}
+
+/* wrapper BMAC functions to for HIGH driver access */
+void wlc_mctrl(wlc_info_t * wlc, uint32 mask, uint32 val)
+{
+	wlc_bmac_mctrl(wlc->hw, mask, val);
+}
+
+void wlc_corereset(wlc_info_t * wlc, uint32 flags)
+{
+	wlc_bmac_corereset(wlc->hw, flags);
+}
+
+void wlc_mhf(wlc_info_t * wlc, uint8 idx, uint16 mask, uint16 val, int bands)
+{
+	wlc_bmac_mhf(wlc->hw, idx, mask, val, bands);
+}
+
+uint16 wlc_mhf_get(wlc_info_t * wlc, uint8 idx, int bands)
+{
+	return wlc_bmac_mhf_get(wlc->hw, idx, bands);
+}
+
+int wlc_xmtfifo_sz_get(wlc_info_t * wlc, uint fifo, uint * blocks)
+{
+	return wlc_bmac_xmtfifo_sz_get(wlc->hw, fifo, blocks);
+}
+
+void wlc_write_template_ram(wlc_info_t * wlc, int offset, int len, void *buf)
+{
+	wlc_bmac_write_template_ram(wlc->hw, offset, len, buf);
+}
+
+void wlc_write_hw_bcntemplates(wlc_info_t * wlc, void *bcn, int len, bool both)
+{
+	wlc_bmac_write_hw_bcntemplates(wlc->hw, bcn, len, both);
+}
+
+void
+wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+		  const struct ether_addr *addr)
+{
+	wlc_bmac_set_addrmatch(wlc->hw, match_reg_offset, addr);
+}
+
+void wlc_set_rcmta(wlc_info_t * wlc, int idx, const struct ether_addr *addr)
+{
+	wlc_bmac_set_rcmta(wlc->hw, idx, addr);
+}
+
+void wlc_read_tsf(wlc_info_t * wlc, uint32 * tsf_l_ptr, uint32 * tsf_h_ptr)
+{
+	wlc_bmac_read_tsf(wlc->hw, tsf_l_ptr, tsf_h_ptr);
+}
+
+void wlc_set_cwmin(wlc_info_t * wlc, uint16 newmin)
+{
+	wlc->band->CWmin = newmin;
+	wlc_bmac_set_cwmin(wlc->hw, newmin);
+}
+
+void wlc_set_cwmax(wlc_info_t * wlc, uint16 newmax)
+{
+	wlc->band->CWmax = newmax;
+	wlc_bmac_set_cwmax(wlc->hw, newmax);
+}
+
+void wlc_fifoerrors(wlc_info_t * wlc)
+{
+
+	wlc_bmac_fifoerrors(wlc->hw);
+}
+
+/* Search mem rw utilities */
+
+void wlc_pllreq(wlc_info_t * wlc, bool set, mbool req_bit)
+{
+	wlc_bmac_pllreq(wlc->hw, set, req_bit);
+}
+
+void wlc_reset_bmac_done(wlc_info_t * wlc)
+{
+#ifdef WLC_HIGH_ONLY
+	wlc->reset_bmac_pending = FALSE;
+#endif
+}
+
+void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode)
+{
+	wlc->ht_cap.cap &= ~HT_CAP_MIMO_PS_MASK;
+	wlc->ht_cap.cap |= (mimops_mode << HT_CAP_MIMO_PS_SHIFT);
+
+	if (AP_ENAB(wlc->pub) && wlc->clk) {
+		wlc_update_beacon(wlc);
+		wlc_update_probe_resp(wlc, TRUE);
+	}
+}
+
+/* check for the particular priority flow control bit being set */
+bool
+wlc_txflowcontrol_prio_isset(wlc_info_t * wlc, wlc_txq_info_t * q, int prio)
+{
+	uint prio_mask;
+
+	if (prio == ALLPRIO) {
+		prio_mask = TXQ_STOP_FOR_PRIOFC_MASK;
+	} else {
+		ASSERT(prio >= 0 && prio <= MAXPRIO);
+		prio_mask = NBITVAL(prio);
+	}
+
+	return (q->stopped & prio_mask) == prio_mask;
+}
+
+/* propogate the flow control to all interfaces using the given tx queue */
+void wlc_txflowcontrol(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on, int prio)
+{
+	uint prio_bits;
+	uint cur_bits;
+
+	WL_ERROR(("%s: flow contro kicks in\n", __func__));
+
+	if (prio == ALLPRIO) {
+		prio_bits = TXQ_STOP_FOR_PRIOFC_MASK;
+	} else {
+		ASSERT(prio >= 0 && prio <= MAXPRIO);
+		prio_bits = NBITVAL(prio);
+	}
+
+	cur_bits = qi->stopped & prio_bits;
+
+	/* Check for the case of no change and return early
+	 * Otherwise update the bit and continue
+	 */
+	if (on) {
+		if (cur_bits == prio_bits) {
+			return;
+		}
+		mboolset(qi->stopped, prio_bits);
+	} else {
+		if (cur_bits == 0) {
+			return;
+		}
+		mboolclr(qi->stopped, prio_bits);
+	}
+
+	/* If there is a flow control override we will not change the external
+	 * flow control state.
+	 */
+	if (qi->stopped & ~TXQ_STOP_FOR_PRIOFC_MASK) {
+		return;
+	}
+
+	wlc_txflowcontrol_signal(wlc, qi, on, prio);
+}
+
+void
+wlc_txflowcontrol_override(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+			   uint override)
+{
+	uint prev_override;
+
+	ASSERT(override != 0);
+	ASSERT((override & TXQ_STOP_FOR_PRIOFC_MASK) == 0);
+
+	prev_override = (qi->stopped & ~TXQ_STOP_FOR_PRIOFC_MASK);
+
+	/* Update the flow control bits and do an early return if there is
+	 * no change in the external flow control state.
+	 */
+	if (on) {
+		mboolset(qi->stopped, override);
+		/* if there was a previous override bit on, then setting this
+		 * makes no difference.
+		 */
+		if (prev_override) {
+			return;
+		}
+
+		wlc_txflowcontrol_signal(wlc, qi, ON, ALLPRIO);
+	} else {
+		mboolclr(qi->stopped, override);
+		/* clearing an override bit will only make a difference for
+		 * flow control if it was the only bit set. For any other
+		 * override setting, just return
+		 */
+		if (prev_override != override) {
+			return;
+		}
+
+		if (qi->stopped == 0) {
+			wlc_txflowcontrol_signal(wlc, qi, OFF, ALLPRIO);
+		} else {
+			int prio;
+
+			for (prio = MAXPRIO; prio >= 0; prio--) {
+				if (!mboolisset(qi->stopped, NBITVAL(prio)))
+					wlc_txflowcontrol_signal(wlc, qi, OFF,
+								 prio);
+			}
+		}
+	}
+}
+
+static void wlc_txflowcontrol_reset(wlc_info_t * wlc)
+{
+	wlc_txq_info_t *qi;
+
+	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
+		if (qi->stopped) {
+			wlc_txflowcontrol_signal(wlc, qi, OFF, ALLPRIO);
+			qi->stopped = 0;
+		}
+	}
+}
+
+static void
+wlc_txflowcontrol_signal(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+			 int prio)
+{
+	wlc_if_t *wlcif;
+
+	for (wlcif = wlc->wlcif_list; wlcif != NULL; wlcif = wlcif->next) {
+		if (wlcif->qi == qi && wlcif->flags & WLC_IF_LINKED)
+			wl_txflowcontrol(wlc->wl, wlcif->wlif, on, prio);
+	}
+}
+
+static wlc_txq_info_t *wlc_txq_alloc(wlc_info_t * wlc, osl_t * osh)
+{
+	wlc_txq_info_t *qi, *p;
+
+	qi = (wlc_txq_info_t *) wlc_calloc(osh, wlc->pub->unit,
+					   sizeof(wlc_txq_info_t));
+	if (qi == NULL) {
+		return NULL;
+	}
+
+	/* Have enough room for control packets along with HI watermark */
+	/* Also, add room to txq for total psq packets if all the SCBs leave PS mode */
+	/* The watermark for flowcontrol to OS packets will remain the same */
+	pktq_init(&qi->q, WLC_PREC_COUNT,
+		  (2 * wlc->pub->tunables->datahiwat) + PKTQ_LEN_DEFAULT +
+		  wlc->pub->psq_pkts_total);
+
+	/* add this queue to the the global list */
+	p = wlc->tx_queues;
+	if (p == NULL) {
+		wlc->tx_queues = qi;
+	} else {
+		while (p->next != NULL)
+			p = p->next;
+		p->next = qi;
+	}
+
+	return qi;
+}
+
+static void wlc_txq_free(wlc_info_t * wlc, osl_t * osh, wlc_txq_info_t * qi)
+{
+	wlc_txq_info_t *p;
+
+	if (qi == NULL)
+		return;
+
+	/* remove the queue from the linked list */
+	p = wlc->tx_queues;
+	if (p == qi)
+		wlc->tx_queues = p->next;
+	else {
+		while (p != NULL && p->next != qi)
+			p = p->next;
+		ASSERT(p->next == qi);
+		if (p != NULL)
+			p->next = p->next->next;
+	}
+
+	osl_mfree(osh, qi, sizeof(wlc_txq_info_t));
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_mac80211.h b/drivers/staging/brcm80211/sys/wlc_mac80211.h
new file mode 100644
index 0000000..2d03272
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_mac80211.h
@@ -0,0 +1,1039 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_h_
+#define _wlc_h_
+
+#include <wlc_types.h>
+
+#include <wl_dbg.h>
+#include <wlioctl.h>
+#include <wlc_event.h>
+#include <wlc_phy_hal.h>
+#include <wlc_channel.h>
+#ifdef WLC_SPLIT
+#include <bcm_rpc.h>
+#endif
+
+#include <wlc_bsscfg.h>
+
+#include <wlc_scb.h>
+
+#define MA_WINDOW_SZ		8	/* moving average window size */
+#define	WL_HWRXOFF		38	/* chip rx buffer offset */
+#define	INVCHANNEL		255	/* invalid channel */
+#define	MAXCOREREV		28	/* max # supported core revisions (0 .. MAXCOREREV - 1) */
+#define WLC_MAXMODULES		22	/* max #  wlc_module_register() calls */
+
+/* network protection config */
+#define	WLC_PROT_G_SPEC		1	/* SPEC g protection */
+#define	WLC_PROT_G_OVR		2	/* SPEC g prot override */
+#define	WLC_PROT_G_USER		3	/* gmode specified by user */
+#define	WLC_PROT_OVERLAP	4	/* overlap */
+#define	WLC_PROT_N_USER		10	/* nmode specified by user */
+#define	WLC_PROT_N_CFG		11	/* n protection */
+#define	WLC_PROT_N_CFG_OVR	12	/* n protection override */
+#define	WLC_PROT_N_NONGF	13	/* non-GF protection */
+#define	WLC_PROT_N_NONGF_OVR	14	/* non-GF protection override */
+#define	WLC_PROT_N_PAM_OVR	15	/* n preamble override */
+#define	WLC_PROT_N_OBSS		16	/* non-HT OBSS present */
+
+#define WLC_BITSCNT(x)	bcm_bitcount((uint8 *)&(x), sizeof(uint8))
+
+/* Maximum wait time for a MAC suspend */
+#define	WLC_MAX_MAC_SUSPEND	83000	/* uS: 83mS is max packet time (64KB ampdu @ 6Mbps) */
+
+/* Probe Response timeout - responses for probe requests older that this are tossed, zero to disable
+ */
+#define WLC_PRB_RESP_TIMEOUT	0	/* Disable probe response timeout */
+
+/* transmit buffer max headroom for protocol headers */
+#define TXOFF (D11_TXH_LEN + D11_PHY_HDR_LEN)
+
+/* For managing scan result lists */
+typedef struct wlc_bss_list {
+	uint count;
+	bool beacon;		/* set for beacon, cleared for probe response */
+	wlc_bss_info_t *ptrs[MAXBSS];
+} wlc_bss_list_t;
+
+#define	SW_TIMER_MAC_STAT_UPD		30	/* periodic MAC stats update */
+
+/* Double check that unsupported cores are not enabled */
+#if CONF_MSK(D11CONF, 0x4f) || CONF_GE(D11CONF, MAXCOREREV)
+#error "Configuration for D11CONF includes unsupported versions."
+#endif				/* Bad versions */
+
+#define	VALID_COREREV(corerev)	CONF_HAS(D11CONF, corerev)
+
+/* values for shortslot_override */
+#define WLC_SHORTSLOT_AUTO	-1	/* Driver will manage Shortslot setting */
+#define WLC_SHORTSLOT_OFF	0	/* Turn off short slot */
+#define WLC_SHORTSLOT_ON	1	/* Turn on short slot */
+
+/* value for short/long and mixmode/greenfield preamble */
+
+#define WLC_LONG_PREAMBLE	(0)
+#define WLC_SHORT_PREAMBLE	(1 << 0)
+#define WLC_GF_PREAMBLE		(1 << 1)
+#define WLC_MM_PREAMBLE		(1 << 2)
+#define WLC_IS_MIMO_PREAMBLE(_pre) (((_pre) == WLC_GF_PREAMBLE) || ((_pre) == WLC_MM_PREAMBLE))
+
+/* values for barker_preamble */
+#define WLC_BARKER_SHORT_ALLOWED	0	/* Short pre-amble allowed */
+
+/* A fifo is full. Clear precedences related to that FIFO */
+#define WLC_TX_FIFO_CLEAR(wlc, fifo) ((wlc)->tx_prec_map &= ~(wlc)->fifo2prec_map[fifo])
+
+/* Fifo is NOT full. Enable precedences for that FIFO */
+#define WLC_TX_FIFO_ENAB(wlc, fifo)  ((wlc)->tx_prec_map |= (wlc)->fifo2prec_map[fifo])
+
+/* TxFrameID */
+/* seq and frag bits: SEQNUM_SHIFT, FRAGNUM_MASK (802.11.h) */
+/* rate epoch bits: TXFID_RATE_SHIFT, TXFID_RATE_MASK ((wlc_rate.c) */
+#define TXFID_QUEUE_MASK	0x0007	/* Bits 0-2 */
+#define TXFID_SEQ_MASK		0x7FE0	/* Bits 5-15 */
+#define TXFID_SEQ_SHIFT		5	/* Number of bit shifts */
+#define	TXFID_RATE_PROBE_MASK	0x8000	/* Bit 15 for rate probe */
+#define TXFID_RATE_MASK		0x0018	/* Mask for bits 3 and 4 */
+#define TXFID_RATE_SHIFT	3	/* Shift 3 bits for rate mask */
+
+/* promote boardrev */
+#define BOARDREV_PROMOTABLE	0xFF	/* from */
+#define BOARDREV_PROMOTED	1	/* to */
+
+/* if wpa is in use then portopen is true when the group key is plumbed otherwise it is always true
+ */
+#define WLC_PORTOPEN(cfg) \
+	(((cfg)->WPA_auth != WPA_AUTH_DISABLED && WSEC_ENABLED((cfg)->wsec)) ? \
+	(cfg)->wsec_portopen : TRUE)
+
+#define PS_ALLOWED(wlc)	wlc_ps_allowed(wlc)
+#define STAY_AWAKE(wlc) wlc_stay_awake(wlc)
+
+#define DATA_BLOCK_TX_SUPR	(1 << 4)
+
+/* 802.1D Priority to TX FIFO number for wme */
+extern const uint8 prio2fifo[];
+
+/* Ucode MCTL_WAKE override bits */
+#define WLC_WAKE_OVERRIDE_CLKCTL	0x01
+#define WLC_WAKE_OVERRIDE_PHYREG	0x02
+#define WLC_WAKE_OVERRIDE_MACSUSPEND	0x04
+#define WLC_WAKE_OVERRIDE_TXFIFO	0x08
+#define WLC_WAKE_OVERRIDE_FORCEFAST	0x10
+
+/* stuff pulled in from wlc.c */
+
+/* Interrupt bit error summary.  Don't include I_RU: we refill DMA at other
+ * times; and if we run out, constant I_RU interrupts may cause lockup.  We
+ * will still get error counts from rx0ovfl.
+ */
+#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RO | I_XU)
+/* default software intmasks */
+#define	DEF_RXINTMASK	(I_RI)	/* enable rx int on rxfifo only */
+#define	DEF_MACINTMASK	(MI_TXSTOP | MI_TBTT | MI_ATIMWINEND | MI_PMQ | \
+			 MI_PHYTXERR | MI_DMAINT | MI_TFS | MI_BG_NOISE | \
+			 MI_CCA | MI_TO | MI_GP0 | MI_RFDISABLE | MI_PWRUP)
+
+#define	RETRY_SHORT_DEF			7	/* Default Short retry Limit */
+#define	RETRY_SHORT_MAX			255	/* Maximum Short retry Limit */
+#define	RETRY_LONG_DEF			4	/* Default Long retry count */
+#define	RETRY_SHORT_FB			3	/* Short retry count for fallback rate */
+#define	RETRY_LONG_FB			2	/* Long retry count for fallback rate */
+
+#define	MAXTXPKTS		6	/* max # pkts pending */
+
+/* frameburst */
+#define	MAXTXFRAMEBURST		8	/* vanilla xpress mode: max frames/burst */
+#define	MAXFRAMEBURST_TXOP	10000	/* Frameburst TXOP in usec */
+
+/* Per-AC retry limit register definitions; uses bcmdefs.h bitfield macros */
+#define EDCF_SHORT_S            0
+#define EDCF_SFB_S              4
+#define EDCF_LONG_S             8
+#define EDCF_LFB_S              12
+#define EDCF_SHORT_M            BITFIELD_MASK(4)
+#define EDCF_SFB_M              BITFIELD_MASK(4)
+#define EDCF_LONG_M             BITFIELD_MASK(4)
+#define EDCF_LFB_M              BITFIELD_MASK(4)
+
+#define WLC_WME_RETRY_SHORT_GET(wlc, ac)    GFIELD(wlc->wme_retries[ac], EDCF_SHORT)
+#define WLC_WME_RETRY_SFB_GET(wlc, ac)      GFIELD(wlc->wme_retries[ac], EDCF_SFB)
+#define WLC_WME_RETRY_LONG_GET(wlc, ac)     GFIELD(wlc->wme_retries[ac], EDCF_LONG)
+#define WLC_WME_RETRY_LFB_GET(wlc, ac)      GFIELD(wlc->wme_retries[ac], EDCF_LFB)
+
+#define WLC_WME_RETRY_SHORT_SET(wlc, ac, val) \
+	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_SHORT, val)
+#define WLC_WME_RETRY_SFB_SET(wlc, ac, val) \
+	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_SFB, val)
+#define WLC_WME_RETRY_LONG_SET(wlc, ac, val) \
+	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_LONG, val)
+#define WLC_WME_RETRY_LFB_SET(wlc, ac, val) \
+	wlc->wme_retries[ac] = SFIELD(wlc->wme_retries[ac], EDCF_LFB, val)
+
+/* PLL requests */
+#define WLC_PLLREQ_SHARED	0x1	/* pll is shared on old chips */
+#define WLC_PLLREQ_RADIO_MON	0x2	/* hold pll for radio monitor register checking */
+#define WLC_PLLREQ_FLIP		0x4	/* hold/release pll for some short operation */
+
+/* Do we support this rate? */
+#define VALID_RATE_DBG(wlc, rspec) wlc_valid_rate(wlc, rspec, WLC_BAND_AUTO, TRUE)
+
+/*
+ * Macros to check if AP or STA is active.
+ * AP Active means more than just configured: driver and BSS are "up";
+ * that is, we are beaconing/responding as an AP (aps_associated).
+ * STA Active similarly means the driver is up and a configured STA BSS
+ * is up: either associated (stas_associated) or trying.
+ *
+ * Macro definitions vary as per AP/STA ifdefs, allowing references to
+ * ifdef'd structure fields and constant values (0) for optimization.
+ * Make sure to enclose blocks of code such that any routines they
+ * reference can also be unused and optimized out by the linker.
+ */
+/* NOTE: References structure fields defined in wlc.h */
+#define AP_ACTIVE(wlc)	(0)
+
+/*
+ * Detect Card removed.
+ * Even checking an sbconfig register read will not false trigger when the core is in reset.
+ * it breaks CF address mechanism. Accessing gphy phyversion will cause SB error if aphy
+ * is in reset on 4306B0-DB. Need a simple accessible reg with fixed 0/1 pattern
+ * (some platforms return all 0).
+ * If clocks are present, call the sb routine which will figure out if the device is removed.
+ */
+#ifdef WLC_HIGH_ONLY
+#define DEVICEREMOVED(wlc)	(!wlc->device_present)
+#else
+#define DEVICEREMOVED(wlc)      \
+	((wlc->hw->clk) ?   \
+	((R_REG(wlc->hw->osh, &wlc->hw->regs->maccontrol) & \
+	(MCTL_PSM_JMP_0 | MCTL_IHR_EN)) != MCTL_IHR_EN) : \
+	(si_deviceremoved(wlc->hw->sih)))
+#endif				/* WLC_HIGH_ONLY */
+
+#define WLCWLUNIT(wlc)		((wlc)->pub->unit)
+
+typedef struct wlc_protection {
+	bool _g;		/* use g spec protection, driver internal */
+	int8 g_override;	/* override for use of g spec protection */
+	uint8 gmode_user;	/* user config gmode, operating band->gmode is different */
+	int8 overlap;		/* Overlap BSS/IBSS protection for both 11g and 11n */
+	int8 nmode_user;	/* user config nmode, operating pub->nmode is different */
+	int8 n_cfg;		/* use OFDM protection on MIMO frames */
+	int8 n_cfg_override;	/* override for use of N protection */
+	bool nongf;		/* non-GF present protection */
+	int8 nongf_override;	/* override for use of GF protection */
+	int8 n_pam_override;	/* override for preamble: MM or GF */
+	bool n_obss;		/* indicated OBSS Non-HT STA present */
+
+	uint longpre_detect_timeout;	/* #sec until long preamble bcns gone */
+	uint barker_detect_timeout;	/* #sec until bcns signaling Barker long preamble */
+	/* only is gone */
+	uint ofdm_ibss_timeout;	/* #sec until ofdm IBSS beacons gone */
+	uint ofdm_ovlp_timeout;	/* #sec until ofdm overlapping BSS bcns gone */
+	uint nonerp_ibss_timeout;	/* #sec until nonerp IBSS beacons gone */
+	uint nonerp_ovlp_timeout;	/* #sec until nonerp overlapping BSS bcns gone */
+	uint g_ibss_timeout;	/* #sec until bcns signaling Use_Protection gone */
+	uint n_ibss_timeout;	/* #sec until bcns signaling Use_OFDM_Protection gone */
+	uint ht20in40_ovlp_timeout;	/* #sec until 20MHz overlapping OPMODE gone */
+	uint ht20in40_ibss_timeout;	/* #sec until 20MHz-only HT station bcns gone */
+	uint non_gf_ibss_timeout;	/* #sec until non-GF bcns gone */
+} wlc_protection_t;
+
+/* anything affects the single/dual streams/antenna operation */
+typedef struct wlc_stf {
+	uint8 hw_txchain;	/* HW txchain bitmap cfg */
+	uint8 txchain;		/* txchain bitmap being used */
+	uint8 txstreams;	/* number of txchains being used */
+
+	uint8 hw_rxchain;	/* HW rxchain bitmap cfg */
+	uint8 rxchain;		/* rxchain bitmap being used */
+	uint8 rxstreams;	/* number of rxchains being used */
+
+	uint8 ant_rx_ovr;	/* rx antenna override */
+	int8 txant;		/* userTx antenna setting */
+	uint16 phytxant;	/* phyTx antenna setting in txheader */
+
+	uint8 ss_opmode;	/* singlestream Operational mode, 0:siso; 1:cdd */
+	bool ss_algosel_auto;	/* if TRUE, use wlc->stf->ss_algo_channel; */
+	/* else use wlc->band->stf->ss_mode_band; */
+	uint16 ss_algo_channel;	/* ss based on per-channel algo: 0: SISO, 1: CDD 2: STBC */
+	uint8 no_cddstbc;	/* stf override, 1: no CDD (or STBC) allowed */
+
+	uint8 rxchain_restore_delay;	/* delay time to restore default rxchain */
+
+	int8 ldpc;		/* AUTO/ON/OFF ldpc cap supported */
+	uint8 txcore[MAX_STREAMS_SUPPORTED + 1];	/* bitmap of selected core for each Nsts */
+	int8 spatial_policy;
+} wlc_stf_t;
+
+#define WLC_STF_SS_STBC_TX(wlc, scb) \
+	(((wlc)->stf->txstreams > 1) && (((wlc)->band->band_stf_stbc_tx == ON) || \
+	 (SCB_STBC_CAP((scb)) &&					\
+	  (wlc)->band->band_stf_stbc_tx == AUTO &&			\
+	  isset(&((wlc)->stf->ss_algo_channel), PHY_TXC1_MODE_STBC))))
+
+#define WLC_STBC_CAP_PHY(wlc) (WLCISNPHY(wlc->band) && NREV_GE(wlc->band->phyrev, 3))
+
+#define WLC_SGI_CAP_PHY(wlc) ((WLCISNPHY(wlc->band) && NREV_GE(wlc->band->phyrev, 3)) || \
+	WLCISLCNPHY(wlc->band))
+
+#define WLC_CHAN_PHYTYPE(x)     (((x) & RXS_CHAN_PHYTYPE_MASK) >> RXS_CHAN_PHYTYPE_SHIFT)
+#define WLC_CHAN_CHANNEL(x)     (((x) & RXS_CHAN_ID_MASK) >> RXS_CHAN_ID_SHIFT)
+#define WLC_RX_CHANNEL(rxh)	(WLC_CHAN_CHANNEL((rxh)->RxChan))
+
+/* wlc_bss_info flag bit values */
+#define WLC_BSS_HT		0x0020	/* BSS is HT (MIMO) capable */
+
+/* Flags used in wlc_txq_info.stopped */
+#define TXQ_STOP_FOR_PRIOFC_MASK	0x000000FF	/* per prio flow control bits */
+#define TXQ_STOP_FOR_PKT_DRAIN		0x00000100	/* stop txq enqueue for packet drain */
+#define TXQ_STOP_FOR_AMPDU_FLOW_CNTRL	0x00000200	/* stop txq enqueue for ampdu flow control */
+
+#define WLC_HT_WEP_RESTRICT	0x01	/* restrict HT with WEP */
+#define WLC_HT_TKIP_RESTRICT	0x02	/* restrict HT with TKIP */
+
+/*
+ * core state (mac)
+ */
+typedef struct wlccore {
+#ifdef WLC_LOW
+	uint coreidx;		/* # sb enumerated core */
+
+	/* fifo */
+	uint *txavail[NFIFO];	/* # tx descriptors available */
+	int16 txpktpend[NFIFO];	/* tx admission control */
+#endif				/* WLC_LOW */
+
+	macstat_t *macstat_snapshot;	/* mac hw prev read values */
+} wlccore_t;
+
+/*
+ * band state (phy+ana+radio)
+ */
+typedef struct wlcband {
+	int bandtype;		/* WLC_BAND_2G, WLC_BAND_5G */
+	uint bandunit;		/* bandstate[] index */
+
+	uint16 phytype;		/* phytype */
+	uint16 phyrev;
+	uint16 radioid;
+	uint16 radiorev;
+	wlc_phy_t *pi;		/* pointer to phy specific information */
+	bool abgphy_encore;
+
+	uint8 gmode;		/* currently active gmode (see wlioctl.h) */
+
+	struct scb *hwrs_scb;	/* permanent scb for hw rateset */
+
+	wlc_rateset_t defrateset;	/* band-specific copy of default_bss.rateset */
+
+	ratespec_t rspec_override;	/* 802.11 rate override */
+	ratespec_t mrspec_override;	/* multicast rate override */
+	uint8 band_stf_ss_mode;	/* Configured STF type, 0:siso; 1:cdd */
+	int8 band_stf_stbc_tx;	/* STBC TX 0:off; 1:force on; -1:auto */
+	wlc_rateset_t hw_rateset;	/* rates supported by chip (phy-specific) */
+	uint8 basic_rate[WLC_MAXRATE + 1];	/* basic rates indexed by rate */
+	bool mimo_cap_40;	/* 40 MHz cap enabled on this band */
+	int8 antgain;		/* antenna gain from srom */
+
+	uint16 CWmin;		/* The minimum size of contention window, in unit of aSlotTime */
+	uint16 CWmax;		/* The maximum size of contention window, in unit of aSlotTime */
+	uint16 bcntsfoff;	/* beacon tsf offset */
+} wlcband_t;
+
+/* generic function callback takes just one arg */
+typedef void (*cb_fn_t) (void *);
+
+/* tx completion callback takes 3 args */
+typedef void (*pkcb_fn_t) (wlc_info_t * wlc, uint txstatus, void *arg);
+
+typedef struct pkt_cb {
+	pkcb_fn_t fn;		/* function to call when tx frame completes */
+	void *arg;		/* void arg for fn */
+	uint8 nextidx;		/* index of next call back if threading */
+	bool entered;		/* recursion check */
+} pkt_cb_t;
+
+	/* module control blocks */
+typedef struct modulecb {
+	char name[32];		/* module name : NULL indicates empty array member */
+	const bcm_iovar_t *iovars;	/* iovar table */
+	void *hdl;		/* handle passed when handler 'doiovar' is called */
+	watchdog_fn_t watchdog_fn;	/* watchdog handler */
+	iovar_fn_t iovar_fn;	/* iovar handler */
+	down_fn_t down_fn;	/* down handler. Note: the int returned
+				 * by the down function is a count of the
+				 * number of timers that could not be
+				 * freed.
+				 */
+} modulecb_t;
+
+	/* dump control blocks */
+typedef struct dumpcb_s {
+	const char *name;	/* dump name */
+	dump_fn_t dump_fn;	/* 'wl dump' handler */
+	void *dump_fn_arg;
+	struct dumpcb_s *next;
+} dumpcb_t;
+
+/* virtual interface */
+struct wlc_if {
+	wlc_if_t *next;
+	uint8 type;		/* WLC_IFTYPE_BSS or WLC_IFTYPE_WDS */
+	uint8 index;		/* assigned in wl_add_if(), index of the wlif if any,
+				 * not necessarily corresponding to bsscfg._idx or
+				 * AID2PVBMAP(scb).
+				 */
+	uint8 flags;		/* flags for the interface */
+	wl_if_t *wlif;		/* pointer to wlif */
+	struct wlc_txq_info *qi;	/* pointer to associated tx queue */
+	union {
+		struct scb *scb;	/* pointer to scb if WLC_IFTYPE_WDS */
+		struct wlc_bsscfg *bsscfg;	/* pointer to bsscfg if WLC_IFTYPE_BSS */
+	} u;
+};
+
+/* flags for the interface */
+#define WLC_IF_LINKED		0x02	/* this interface is linked to a wl_if */
+
+#ifdef WLC_LOW
+typedef struct wlc_hwband {
+	int bandtype;		/* WLC_BAND_2G, WLC_BAND_5G */
+	uint bandunit;		/* bandstate[] index */
+	uint16 mhfs[MHFMAX];	/* MHF array shadow */
+	uint8 bandhw_stf_ss_mode;	/* HW configured STF type, 0:siso; 1:cdd */
+	uint16 CWmin;
+	uint16 CWmax;
+	uint32 core_flags;
+
+	uint16 phytype;		/* phytype */
+	uint16 phyrev;
+	uint16 radioid;
+	uint16 radiorev;
+	wlc_phy_t *pi;		/* pointer to phy specific information */
+	bool abgphy_encore;
+} wlc_hwband_t;
+#endif				/* WLC_LOW */
+
+struct wlc_hw_info {
+#ifdef WLC_SPLIT
+	rpc_info_t *rpc;	/* Handle to RPC module */
+#endif
+	osl_t *osh;		/* pointer to os handle */
+	bool _piomode;		/* true if pio mode */
+	wlc_info_t *wlc;
+
+	/* fifo */
+	hnddma_t *di[NFIFO];	/* hnddma handles, per fifo */
+
+#ifdef WLC_LOW
+	uint unit;		/* device instance number */
+
+	/* version info */
+	uint16 vendorid;	/* PCI vendor id */
+	uint16 deviceid;	/* PCI device id */
+	uint corerev;		/* core revision */
+	uint8 sromrev;		/* version # of the srom */
+	uint16 boardrev;	/* version # of particular board */
+	uint32 boardflags;	/* Board specific flags from srom */
+	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
+	uint32 machwcap;	/* MAC capabilities (corerev >= 13) */
+	uint32 machwcap_backup;	/* backup of machwcap (corerev >= 13) */
+	uint16 ucode_dbgsel;	/* dbgsel for ucode debug(config gpio) */
+
+	si_t *sih;		/* SB handle (cookie for siutils calls) */
+	char *vars;		/* "environment" name=value */
+	uint vars_size;		/* size of vars, free vars on detach */
+	d11regs_t *regs;	/* pointer to device registers */
+	void *physhim;		/* phy shim layer handler */
+	void *phy_sh;		/* pointer to shared phy state */
+	wlc_hwband_t *band;	/* pointer to active per-band state */
+	wlc_hwband_t *bandstate[MAXBANDS];	/* per-band state (one per phy/radio) */
+	uint16 bmac_phytxant;	/* cache of high phytxant state */
+	bool shortslot;		/* currently using 11g ShortSlot timing */
+	uint16 SRL;		/* 802.11 dot11ShortRetryLimit */
+	uint16 LRL;		/* 802.11 dot11LongRetryLimit */
+	uint16 SFBL;		/* Short Frame Rate Fallback Limit */
+	uint16 LFBL;		/* Long Frame Rate Fallback Limit */
+
+	bool up;		/* d11 hardware up and running */
+	uint now;		/* # elapsed seconds */
+	uint _nbands;		/* # bands supported */
+	chanspec_t chanspec;	/* bmac chanspec shadow */
+
+	uint *txavail[NFIFO];	/* # tx descriptors available */
+	uint16 *xmtfifo_sz;	/* fifo size in 256B for each xmt fifo */
+
+	mbool pllreq;		/* pll requests to keep PLL on */
+
+	uint8 suspended_fifos;	/* Which TX fifo to remain awake for */
+	uint32 maccontrol;	/* Cached value of maccontrol */
+	uint mac_suspend_depth;	/* current depth of mac_suspend levels */
+	uint32 wake_override;	/* Various conditions to force MAC to WAKE mode */
+	uint32 mute_override;	/* Prevent ucode from sending beacons */
+	struct ether_addr etheraddr;	/* currently configured ethernet address */
+	uint32 led_gpio_mask;	/* LED GPIO Mask */
+	bool noreset;		/* true= do not reset hw, used by WLC_OUT */
+	bool forcefastclk;	/* true if the h/w is forcing the use of fast clk */
+	bool clk;		/* core is out of reset and has clock */
+	bool sbclk;		/* sb has clock */
+	bmac_pmq_t *bmac_pmq;	/*  bmac PM states derived from ucode PMQ */
+	bool phyclk;		/* phy is out of reset and has clock */
+	bool dma_lpbk;		/* core is in DMA loopback */
+
+#ifdef BCMSDIO
+	void *sdh;
+#endif
+	bool ucode_loaded;	/* TRUE after ucode downloaded */
+
+#ifdef WLC_LOW_ONLY
+	struct wl_timer *wdtimer;	/* timer for watchdog routine */
+	struct ether_addr orig_etheraddr;	/* original hw ethernet address */
+	uint16 rpc_dngl_agg;	/* rpc agg control for dongle */
+	uint32 mem_required_def;	/* memory required to replenish RX DMA ring */
+	uint32 mem_required_lower;	/* memory required with lower RX bound */
+	uint32 mem_required_least;	/* minimum memory requirement to handle RX */
+
+#endif				/* WLC_LOW_ONLY */
+
+	uint8 hw_stf_ss_opmode;	/* STF single stream operation mode */
+	uint8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
+				 * 0 = N/A, 1 = 2x4 board, 2 = 2x3 CB2 board
+				 */
+	uint32 antsel_avail;	/* put antsel_info_t here if more info is needed */
+#endif				/* WLC_LOW */
+};
+
+/* TX Queue information
+ *
+ * Each flow of traffic out of the device has a TX Queue with independent
+ * flow control. Several interfaces may be associated with a single TX Queue
+ * if they belong to the same flow of traffic from the device. For multi-channel
+ * operation there are independent TX Queues for each channel.
+ */
+typedef struct wlc_txq_info {
+	struct wlc_txq_info *next;
+	struct pktq q;
+	uint stopped;		/* tx flow control bits */
+} wlc_txq_info_t;
+
+/*
+ * Principal common (os-independent) software data structure.
+ */
+struct wlc_info {
+	wlc_pub_t *pub;		/* pointer to wlc public state */
+	osl_t *osh;		/* pointer to os handle */
+	struct wl_info *wl;	/* pointer to os-specific private state */
+	d11regs_t *regs;	/* pointer to device registers */
+
+	wlc_hw_info_t *hw;	/* HW related state used primarily by BMAC */
+#ifdef WLC_SPLIT
+	rpc_info_t *rpc;	/* Handle to RPC module */
+#endif
+
+	/* clock */
+	int clkreq_override;	/* setting for clkreq for PCIE : Auto, 0, 1 */
+	uint16 fastpwrup_dly;	/* time in us needed to bring up d11 fast clock */
+
+	/* interrupt */
+	uint32 macintstatus;	/* bit channel between isr and dpc */
+	uint32 macintmask;	/* sw runtime master macintmask value */
+	uint32 defmacintmask;	/* default "on" macintmask value */
+
+	/* up and down */
+	bool device_present;	/* (removable) device is present */
+
+	bool clk;		/* core is out of reset and has clock */
+
+	/* multiband */
+	wlccore_t *core;	/* pointer to active io core */
+	wlcband_t *band;	/* pointer to active per-band state */
+	wlccore_t *corestate;	/* per-core state (one per hw core) */
+	wlcband_t *bandstate[MAXBANDS];	/* per-band state (one per phy/radio) */
+
+	bool war16165;		/* PCI slow clock 16165 war flag */
+
+	bool tx_suspended;	/* data fifos need to remain suspended */
+
+	uint txpend16165war;
+
+	/* packet queue */
+	uint qvalid;		/* DirFrmQValid and BcMcFrmQValid */
+
+	/* Regulatory power limits */
+	int8 txpwr_local_max;	/* regulatory local txpwr max */
+	uint8 txpwr_local_constraint;	/* local power contraint in dB */
+
+#ifdef WLC_HIGH_ONLY
+	rpctx_info_t *rpctx;	/* RPC TX module */
+	bool reset_bmac_pending;	/* bmac reset is in progressing */
+	uint32 rpc_agg;		/* host agg: bit 16-31, bmac agg: bit 0-15 */
+	uint32 rpc_msglevel;	/* host rpc: bit 16-31, bmac rpc: bit 0-15 */
+#endif
+
+	ampdu_info_t *ampdu;	/* ampdu module handler */
+	antsel_info_t *asi;	/* antsel module handler */
+	wlc_cm_info_t *cmi;	/* channel manager module handler */
+
+	void *btparam;		/* bus type specific cookie */
+
+	uint vars_size;		/* size of vars, free vars on detach */
+
+	uint16 vendorid;	/* PCI vendor id */
+	uint16 deviceid;	/* PCI device id */
+	uint ucode_rev;		/* microcode revision */
+
+	uint32 machwcap;	/* MAC capabilities, BMAC shadow */
+
+	struct ether_addr perm_etheraddr;	/* original sprom local ethernet address */
+
+	bool bandlocked;	/* disable auto multi-band switching */
+	bool bandinit_pending;	/* track band init in auto band */
+
+	bool radio_monitor;	/* radio timer is running */
+	bool down_override;	/* true=down */
+	bool going_down;	/* down path intermediate variable */
+
+	bool mpc;		/* enable minimum power consumption */
+	uint8 mpc_dlycnt;	/* # of watchdog cnt before turn disable radio */
+	uint8 mpc_offcnt;	/* # of watchdog cnt that radio is disabled */
+	uint8 mpc_delay_off;	/* delay radio disable by # of watchdog cnt */
+	uint8 prev_non_delay_mpc;	/* prev state wlc_is_non_delay_mpc */
+
+	/* timer */
+	struct wl_timer *wdtimer;	/* timer for watchdog routine */
+	uint fast_timer;	/* Periodic timeout for 'fast' timer */
+	uint slow_timer;	/* Periodic timeout for 'slow' timer */
+	uint glacial_timer;	/* Periodic timeout for 'glacial' timer */
+	uint phycal_mlo;	/* last time measurelow calibration was done */
+	uint phycal_txpower;	/* last time txpower calibration was done */
+
+	struct wl_timer *radio_timer;	/* timer for hw radio button monitor routine */
+	struct wl_timer *pspoll_timer;	/* periodic pspoll timer */
+
+	/* promiscuous */
+	bool monitor;		/* monitor (MPDU sniffing) mode */
+	bool bcnmisc_ibss;	/* bcns promisc mode override for IBSS */
+	bool bcnmisc_scan;	/* bcns promisc mode override for scan */
+	bool bcnmisc_monitor;	/* bcns promisc mode override for monitor */
+
+	uint8 bcn_wait_prd;	/* max waiting period (for beacon) in 1024TU */
+
+	/* driver feature */
+	bool _rifs;		/* enable per-packet rifs */
+	int32 rifs_advert;	/* RIFS mode advertisement */
+	int8 sgi_tx;		/* sgi tx */
+	bool wet;		/* true if wireless ethernet bridging mode */
+
+	/* AP-STA synchronization, power save */
+	bool check_for_unaligned_tbtt;	/* check unaligned tbtt flag */
+	bool PM_override;	/* no power-save flag, override PM(user input) */
+	bool PMenabled;		/* current power-management state (CAM or PS) */
+	bool PMpending;		/* waiting for tx status with PM indicated set */
+	bool PMblocked;		/* block any PSPolling in PS mode, used to buffer
+				 * AP traffic, also used to indicate in progress
+				 * of scan, rm, etc. off home channel activity.
+				 */
+	bool PSpoll;		/* whether there is an outstanding PS-Poll frame */
+	uint8 PM;		/* power-management mode (CAM, PS or FASTPS) */
+	bool PMawakebcn;	/* bcn recvd during current waking state */
+
+	bool WME_PM_blocked;	/* Can STA go to PM when in WME Auto mode */
+	bool wake;		/* host-specified PS-mode sleep state */
+	uint8 pspoll_prd;	/* pspoll interval in milliseconds */
+	uint8 bcn_li_bcn;	/* beacon listen interval in # beacons */
+	uint8 bcn_li_dtim;	/* beacon listen interval in # dtims */
+
+	bool WDarmed;		/* watchdog timer is armed */
+	uint32 WDlast;		/* last time wlc_watchdog() was called */
+
+	/* WME */
+	ac_bitmap_t wme_dp;	/* Discard (oldest first) policy per AC */
+	bool wme_apsd;		/* enable Advanced Power Save Delivery */
+	ac_bitmap_t wme_admctl;	/* bit i set if AC i under admission control */
+	uint16 edcf_txop[AC_COUNT];	/* current txop for each ac */
+	wme_param_ie_t wme_param_ie;	/* WME parameter info element, which on STA
+					 * contains parameters in use locally, and on
+					 * AP contains parameters advertised to STA
+					 * in beacons and assoc responses.
+					 */
+	bool wme_prec_queuing;	/* enable/disable non-wme STA prec queuing */
+	uint16 wme_retries[AC_COUNT];	/* per-AC retry limits */
+
+	int vlan_mode;		/* OK to use 802.1Q Tags (ON, OFF, AUTO) */
+	uint16 tx_prec_map;	/* Precedence map based on HW FIFO space */
+	uint16 fifo2prec_map[NFIFO];	/* pointer to fifo2_prec map based on WME */
+
+	/* BSS Configurations */
+	wlc_bsscfg_t *bsscfg[WLC_MAXBSSCFG];	/* set of BSS configurations, idx 0 is default and
+						 * always valid
+						 */
+	wlc_bsscfg_t *cfg;	/* the primary bsscfg (can be AP or STA) */
+	uint8 stas_associated;	/* count of ASSOCIATED STA bsscfgs */
+	uint8 aps_associated;	/* count of UP AP bsscfgs */
+	uint8 block_datafifo;	/* prohibit posting frames to data fifos */
+	bool bcmcfifo_drain;	/* TX_BCMC_FIFO is set to drain */
+
+	/* tx queue */
+	wlc_txq_info_t *tx_queues;	/* common TX Queue list */
+
+	/* event */
+	wlc_eventq_t *eventq;	/* event queue for deferred processing */
+
+	/* security */
+	wsec_key_t *wsec_keys[WSEC_MAX_KEYS];	/* dynamic key storage */
+	wsec_key_t *wsec_def_keys[WLC_DEFAULT_KEYS];	/* default key storage */
+	bool wsec_swkeys;	/* indicates that all keys should be
+				 * treated as sw keys (used for debugging)
+				 */
+	modulecb_t *modulecb;
+	dumpcb_t *dumpcb_head;
+
+	uint8 mimoft;		/* SIGN or 11N */
+	uint8 mimo_band_bwcap;	/* bw cap per band type */
+	int8 txburst_limit_override;	/* tx burst limit override */
+	uint16 txburst_limit;	/* tx burst limit value */
+	int8 cck_40txbw;	/* 11N, cck tx b/w override when in 40MHZ mode */
+	int8 ofdm_40txbw;	/* 11N, ofdm tx b/w override when in 40MHZ mode */
+	int8 mimo_40txbw;	/* 11N, mimo tx b/w override when in 40MHZ mode */
+	ht_cap_ie_t ht_cap;	/* HT CAP IE being advertised by this node */
+	ht_add_ie_t ht_add;	/* HT ADD IE being used by this node */
+
+	uint seckeys;		/* 54 key table shm address */
+	uint tkmickeys;		/* 12 TKIP MIC key table shm address */
+
+	wlc_bss_info_t *default_bss;	/* configured BSS parameters */
+
+	uint16 AID;		/* association ID */
+	uint16 counter;		/* per-sdu monotonically increasing counter */
+	uint16 mc_fid_counter;	/* BC/MC FIFO frame ID counter */
+
+	bool ibss_allowed;	/* FALSE, all IBSS will be ignored during a scan
+				 * and the driver will not allow the creation of
+				 * an IBSS network
+				 */
+	bool ibss_coalesce_allowed;
+
+	char country_default[WLC_CNTRY_BUF_SZ];	/* saved country for leaving 802.11d
+						 * auto-country mode
+						 */
+	char autocountry_default[WLC_CNTRY_BUF_SZ];	/* initial country for 802.11d
+							 * auto-country mode
+							 */
+#ifdef BCMDBG
+	bcm_tlv_t *country_ie_override;	/* debug override of announced Country IE */
+#endif
+
+	uint16 prb_resp_timeout;	/* do not send prb resp if request older than this,
+					 * 0 = disable
+					 */
+
+	wlc_rateset_t sup_rates_override;	/* use only these rates in 11g supported rates if
+						 * specifed
+						 */
+
+	chanspec_t home_chanspec;	/* shared home chanspec */
+
+	/* PHY parameters */
+	chanspec_t chanspec;	/* target operational channel */
+	uint16 usr_fragthresh;	/* user configured fragmentation threshold */
+	uint16 fragthresh[NFIFO];	/* per-fifo fragmentation thresholds */
+	uint16 RTSThresh;	/* 802.11 dot11RTSThreshold */
+	uint16 SRL;		/* 802.11 dot11ShortRetryLimit */
+	uint16 LRL;		/* 802.11 dot11LongRetryLimit */
+	uint16 SFBL;		/* Short Frame Rate Fallback Limit */
+	uint16 LFBL;		/* Long Frame Rate Fallback Limit */
+
+	/* network config */
+	bool shortpreamble;	/* currently operating with CCK ShortPreambles */
+	bool shortslot;		/* currently using 11g ShortSlot timing */
+	int8 barker_preamble;	/* current Barker Preamble Mode */
+	int8 shortslot_override;	/* 11g ShortSlot override */
+	bool include_legacy_erp;	/* include Legacy ERP info elt ID 47 as well as g ID 42 */
+	bool barker_overlap_control;	/* TRUE: be aware of overlapping BSSs for barker */
+	bool ignore_bcns;	/* override: ignore non shortslot bcns in a 11g network */
+	bool legacy_probe;	/* restricts probe requests to CCK rates */
+
+	wlc_protection_t *protection;
+	int8 PLCPHdr_override;	/* 802.11b Preamble Type override */
+
+	wlc_stf_t *stf;
+
+	pkt_cb_t *pkt_callback;	/* tx completion callback handlers */
+
+	uint32 txretried;	/* tx retried number in one msdu */
+
+	ratespec_t bcn_rspec;	/* save bcn ratespec purpose */
+
+	bool apsd_sta_usp;	/* Unscheduled Service Period in progress on STA */
+	struct wl_timer *apsd_trigger_timer;	/* timer for wme apsd trigger frames */
+	uint32 apsd_trigger_timeout;	/* timeout value for apsd_trigger_timer (in ms)
+					 * 0 == disable
+					 */
+	ac_bitmap_t apsd_trigger_ac;	/* Permissible Acess Category in which APSD Null
+					 * Trigger frames can be send
+					 */
+	wlc_ap_info_t *ap;
+
+	uint8 htphy_membership;	/* HT PHY membership */
+
+	bool _regulatory_domain;	/* 802.11d enabled? */
+
+	uint8 mimops_PM;
+
+	uint8 txpwr_percent;	/* power output percentage */
+
+	uint8 ht_wsec_restriction;	/* the restriction of HT with TKIP or WEP */
+
+	uint tempsense_lasttime;
+
+	uint16 tx_duty_cycle_ofdm;	/* maximum allowed duty cycle for OFDM */
+	uint16 tx_duty_cycle_cck;	/* maximum allowed duty cycle for CCK */
+
+	uint16 next_bsscfg_ID;
+
+	wlc_if_t *wlcif_list;	/* linked list of wlc_if structs */
+	wlc_txq_info_t *active_queue;	/* txq for the currently active transmit context */
+	uint32 mpc_dur;		/* total time (ms) in mpc mode except for the
+				 * portion since radio is turned off last time
+				 */
+	uint32 mpc_laston_ts;	/* timestamp (ms) when radio is turned off last
+				 * time
+				 */
+	bool pr80838_war;
+	uint hwrxoff;
+};
+
+/* antsel module specific state */
+struct antsel_info {
+	wlc_info_t *wlc;	/* pointer to main wlc structure */
+	wlc_pub_t *pub;		/* pointer to public fn */
+	uint8 antsel_type;	/* Type of boardlevel mimo antenna switch-logic
+				 * 0 = N/A, 1 = 2x4 board, 2 = 2x3 CB2 board
+				 */
+	uint8 antsel_antswitch;	/* board level antenna switch type */
+	bool antsel_avail;	/* Ant selection availability (SROM based) */
+	wlc_antselcfg_t antcfg_11n;	/* antenna configuration */
+	wlc_antselcfg_t antcfg_cur;	/* current antenna config (auto) */
+};
+
+#define	CHANNEL_BANDUNIT(wlc, ch) (((ch) <= CH_MAX_2G_CHANNEL) ? BAND_2G_INDEX : BAND_5G_INDEX)
+#define	OTHERBANDUNIT(wlc)	((uint)((wlc)->band->bandunit? BAND_2G_INDEX : BAND_5G_INDEX))
+
+#define IS_MBAND_UNLOCKED(wlc) \
+	((NBANDS(wlc) > 1) && !(wlc)->bandlocked)
+
+#ifdef WLC_LOW
+#define WLC_BAND_PI_RADIO_CHANSPEC wlc_phy_chanspec_get(wlc->band->pi)
+#else
+#define WLC_BAND_PI_RADIO_CHANSPEC (wlc->chanspec)
+#endif
+
+/* sum the individual fifo tx pending packet counts */
+#if defined(WLC_HIGH_ONLY)
+#define TXPKTPENDTOT(wlc)		(wlc_rpctx_txpktpend((wlc)->rpctx, 0, TRUE))
+#define TXPKTPENDGET(wlc, fifo)		(wlc_rpctx_txpktpend((wlc)->rpctx, (fifo), FALSE))
+#define TXPKTPENDINC(wlc, fifo, val)	(wlc_rpctx_txpktpendinc((wlc)->rpctx, (fifo), (val)))
+#define TXPKTPENDDEC(wlc, fifo, val)	(wlc_rpctx_txpktpenddec((wlc)->rpctx, (fifo), (val)))
+#define TXPKTPENDCLR(wlc, fifo)		(wlc_rpctx_txpktpendclr((wlc)->rpctx, (fifo)))
+#define TXAVAIL(wlc, fifo)		(wlc_rpctx_txavail((wlc)->rpctx, (fifo)))
+#define GETNEXTTXP(wlc, _queue)		(wlc_rpctx_getnexttxp((wlc)->rpctx, (_queue)))
+
+#else
+#define	TXPKTPENDTOT(wlc) ((wlc)->core->txpktpend[0] + (wlc)->core->txpktpend[1] + \
+	(wlc)->core->txpktpend[2] + (wlc)->core->txpktpend[3])
+#define TXPKTPENDGET(wlc, fifo)		((wlc)->core->txpktpend[(fifo)])
+#define TXPKTPENDINC(wlc, fifo, val)	((wlc)->core->txpktpend[(fifo)] += (val))
+#define TXPKTPENDDEC(wlc, fifo, val)	((wlc)->core->txpktpend[(fifo)] -= (val))
+#define TXPKTPENDCLR(wlc, fifo)		((wlc)->core->txpktpend[(fifo)] = 0)
+#define TXAVAIL(wlc, fifo)		(*(wlc)->core->txavail[(fifo)])
+#define GETNEXTTXP(wlc, _queue)								\
+		dma_getnexttxp((wlc)->hw->di[(_queue)], HNDDMA_RANGE_TRANSMITTED)
+#endif				/* WLC_HIGH_ONLY */
+
+#define WLC_IS_MATCH_SSID(wlc, ssid1, ssid2, len1, len2) \
+	((len1 == len2) && !bcmp(ssid1, ssid2, len1))
+
+/* API shared by both WLC_HIGH and WLC_LOW driver */
+extern void wlc_high_dpc(wlc_info_t * wlc, uint32 macintstatus);
+extern void wlc_fatal_error(wlc_info_t * wlc);
+extern void wlc_bmac_rpc_watchdog(wlc_info_t * wlc);
+extern void wlc_recv(wlc_info_t * wlc, void *p);
+extern bool wlc_dotxstatus(wlc_info_t * wlc, tx_status_t * txs, uint32 frm_tx2);
+extern void wlc_txfifo(wlc_info_t * wlc, uint fifo, void *p, bool commit,
+		       int8 txpktpend);
+extern void wlc_txfifo_complete(wlc_info_t * wlc, uint fifo, int8 txpktpend);
+extern void wlc_info_init(wlc_info_t * wlc, int unit);
+extern void wlc_print_txstatus(tx_status_t * txs);
+extern int wlc_xmtfifo_sz_get(wlc_info_t * wlc, uint fifo, uint * blocks);
+extern void wlc_write_template_ram(wlc_info_t * wlc, int offset, int len,
+				   void *buf);
+extern void wlc_write_hw_bcntemplates(wlc_info_t * wlc, void *bcn, int len,
+				      bool both);
+#if defined(BCMDBG)
+extern void wlc_get_rcmta(wlc_info_t * wlc, int idx, struct ether_addr *addr);
+#endif
+extern void wlc_set_rcmta(wlc_info_t * wlc, int idx,
+			  const struct ether_addr *addr);
+extern void wlc_set_addrmatch(wlc_info_t * wlc, int match_reg_offset,
+			      const struct ether_addr *addr);
+extern void wlc_read_tsf(wlc_info_t * wlc, uint32 * tsf_l_ptr,
+			 uint32 * tsf_h_ptr);
+extern void wlc_set_cwmin(wlc_info_t * wlc, uint16 newmin);
+extern void wlc_set_cwmax(wlc_info_t * wlc, uint16 newmax);
+extern void wlc_fifoerrors(wlc_info_t * wlc);
+extern void wlc_pllreq(wlc_info_t * wlc, bool set, mbool req_bit);
+extern void wlc_reset_bmac_done(wlc_info_t * wlc);
+extern void wlc_protection_upd(wlc_info_t * wlc, uint idx, int val);
+extern void wlc_hwtimer_gptimer_set(wlc_info_t * wlc, uint us);
+extern void wlc_hwtimer_gptimer_abort(wlc_info_t * wlc);
+extern void wlc_pktengtx(wlc_info_t * wlc, wl_pkteng_t * pkteng, uint8 rate,
+			 struct ether_addr *sa, uint32 wait_delay);
+
+#if defined(BCMDBG)
+extern void wlc_print_rxh(d11rxhdr_t * rxh);
+extern void wlc_print_hdrs(wlc_info_t * wlc, const char *prefix, uint8 * frame,
+			   d11txh_t * txh, d11rxhdr_t * rxh, uint len);
+extern void wlc_print_txdesc(d11txh_t * txh);
+#endif
+#if defined(BCMDBG)
+extern void wlc_print_dot11_mac_hdr(uint8 * buf, int len);
+#endif
+
+#ifdef WLC_LOW
+extern void wlc_setxband(wlc_hw_info_t * wlc_hw, uint bandunit);
+extern void wlc_coredisable(wlc_hw_info_t * wlc_hw);
+#endif
+
+extern bool wlc_valid_rate(wlc_info_t * wlc, ratespec_t rate, int band,
+			   bool verbose);
+extern void wlc_ap_upd(wlc_info_t * wlc);
+
+/* helper functions */
+extern void wlc_shm_ssid_upd(wlc_info_t * wlc, wlc_bsscfg_t * cfg);
+extern int wlc_set_gmode(wlc_info_t * wlc, uint8 gmode, bool config);
+
+extern void wlc_mac_bcn_promisc_change(wlc_info_t * wlc, bool promisc);
+extern void wlc_mac_bcn_promisc(wlc_info_t * wlc);
+extern void wlc_mac_promisc(wlc_info_t * wlc);
+extern void wlc_txflowcontrol(wlc_info_t * wlc, wlc_txq_info_t * qi, bool on,
+			      int prio);
+extern void wlc_txflowcontrol_override(wlc_info_t * wlc, wlc_txq_info_t * qi,
+				       bool on, uint override);
+extern bool wlc_txflowcontrol_prio_isset(wlc_info_t * wlc, wlc_txq_info_t * qi,
+					 int prio);
+extern void wlc_send_q(wlc_info_t * wlc, wlc_txq_info_t * qi);
+extern int wlc_prep_pdu(wlc_info_t * wlc, void *pdu, uint * fifo);
+
+extern uint16 wlc_calc_lsig_len(wlc_info_t * wlc, ratespec_t ratespec,
+				uint mac_len);
+extern ratespec_t wlc_rspec_to_rts_rspec(wlc_info_t * wlc, ratespec_t rspec,
+					 bool use_rspec, uint16 mimo_ctlchbw);
+extern uint16 wlc_compute_rtscts_dur(wlc_info_t * wlc, bool cts_only,
+				     ratespec_t rts_rate, ratespec_t frame_rate,
+				     uint8 rts_preamble_type,
+				     uint8 frame_preamble_type, uint frame_len,
+				     bool ba);
+
+extern void wlc_tbtt(wlc_info_t * wlc, d11regs_t * regs);
+
+#if defined(BCMDBG)
+extern void wlc_dump_ie(wlc_info_t * wlc, bcm_tlv_t * ie, struct bcmstrbuf *b);
+#endif
+
+extern bool wlc_ps_check(wlc_info_t * wlc);
+extern void wlc_reprate_init(wlc_info_t * wlc);
+extern void wlc_bsscfg_reprate_init(wlc_bsscfg_t * bsscfg);
+extern void wlc_uint64_sub(uint32 * a_high, uint32 * a_low, uint32 b_high,
+			   uint32 b_low);
+extern uint32 wlc_calc_tbtt_offset(uint32 bi, uint32 tsf_h, uint32 tsf_l);
+
+/* Shared memory access */
+extern void wlc_write_shm(wlc_info_t * wlc, uint offset, uint16 v);
+extern uint16 wlc_read_shm(wlc_info_t * wlc, uint offset);
+extern void wlc_set_shm(wlc_info_t * wlc, uint offset, uint16 v, int len);
+extern void wlc_copyto_shm(wlc_info_t * wlc, uint offset, const void *buf,
+			   int len);
+extern void wlc_copyfrom_shm(wlc_info_t * wlc, uint offset, void *buf, int len);
+
+extern void wlc_update_beacon(wlc_info_t * wlc);
+extern void wlc_bss_update_beacon(wlc_info_t * wlc, struct wlc_bsscfg *bsscfg);
+
+extern void wlc_update_probe_resp(wlc_info_t * wlc, bool suspend);
+extern void wlc_bss_update_probe_resp(wlc_info_t * wlc, wlc_bsscfg_t * cfg,
+				      bool suspend);
+
+extern bool wlc_ismpc(wlc_info_t * wlc);
+extern bool wlc_is_non_delay_mpc(wlc_info_t * wlc);
+extern void wlc_radio_mpc_upd(wlc_info_t * wlc);
+extern bool wlc_prec_enq(wlc_info_t * wlc, struct pktq *q, void *pkt, int prec);
+extern bool wlc_prec_enq_head(wlc_info_t * wlc, struct pktq *q, void *pkt,
+			      int prec, bool head);
+extern uint16 wlc_phytxctl1_calc(wlc_info_t * wlc, ratespec_t rspec);
+extern void wlc_compute_plcp(wlc_info_t * wlc, ratespec_t rate, uint length,
+			     uint8 * plcp);
+extern uint wlc_calc_frame_time(wlc_info_t * wlc, ratespec_t ratespec,
+				uint8 preamble_type, uint mac_len);
+
+extern void wlc_set_chanspec(wlc_info_t * wlc, chanspec_t chanspec);
+
+extern bool wlc_timers_init(wlc_info_t * wlc, int unit);
+
+extern const bcm_iovar_t wlc_iovars[];
+
+extern int wlc_doiovar(void *hdl, const bcm_iovar_t * vi, uint32 actionid,
+		       const char *name, void *params, uint p_len, void *arg,
+		       int len, int val_size, wlc_if_t * wlcif);
+
+#if defined(BCMDBG)
+extern void wlc_print_ies(wlc_info_t * wlc, uint8 * ies, uint ies_len);
+#endif
+
+extern int wlc_set_nmode(wlc_info_t * wlc, int32 nmode);
+extern void wlc_ht_mimops_cap_update(wlc_info_t * wlc, uint8 mimops_mode);
+extern void wlc_mimops_action_ht_send(wlc_info_t * wlc, wlc_bsscfg_t * bsscfg,
+				      uint8 mimops_mode);
+
+extern void wlc_switch_shortslot(wlc_info_t * wlc, bool shortslot);
+extern void wlc_set_bssid(wlc_bsscfg_t * cfg);
+extern void wlc_edcf_setparams(wlc_bsscfg_t * cfg, bool suspend);
+extern void wlc_wme_setparams(wlc_info_t * wlc, u16 aci, void *arg,
+			      bool suspend);
+
+extern void wlc_set_ratetable(wlc_info_t * wlc);
+extern int wlc_set_mac(wlc_bsscfg_t * cfg);
+extern void wlc_beacon_phytxctl_txant_upd(wlc_info_t * wlc,
+					  ratespec_t bcn_rate);
+extern void wlc_mod_prb_rsp_rate_table(wlc_info_t * wlc, uint frame_len);
+extern ratespec_t wlc_lowest_basic_rspec(wlc_info_t * wlc, wlc_rateset_t * rs);
+extern uint16 wlc_compute_bcntsfoff(wlc_info_t * wlc, ratespec_t rspec,
+				    bool short_preamble, bool phydelay);
+extern void wlc_radio_disable(wlc_info_t * wlc);
+extern void wlc_bcn_li_upd(wlc_info_t * wlc);
+
+extern int wlc_get_revision_info(wlc_info_t * wlc, void *buf, uint len);
+extern void wlc_out(wlc_info_t * wlc);
+extern void wlc_set_home_chanspec(wlc_info_t * wlc, chanspec_t chanspec);
+extern void wlc_watchdog_upd(wlc_info_t * wlc, bool tbtt);
+extern bool wlc_ps_allowed(wlc_info_t * wlc);
+extern bool wlc_stay_awake(wlc_info_t * wlc);
+extern void wlc_wme_initparams_sta(wlc_info_t * wlc, wme_param_ie_t * pe);
+
+extern void wlc_bss_list_free(wlc_info_t * wlc, wlc_bss_list_t * bss_list);
+#endif				/* _wlc_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_phy_shim.c b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
new file mode 100644
index 0000000..535ba8c
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.c
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * This is "two-way" interface, acting as the SHIM layer between WL and PHY layer.
+ *   WL driver can optinally call this translation layer to do some preprocessing, then reach PHY.
+ *   On the PHY->WL driver direction, all calls go through this layer since PHY doesn't have the
+ *   access to wlc_hw pointer.
+ */
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <bcmutils.h>
+#include <bcmdefs.h>
+#include <osl.h>
+
+#include <proto/802.11.h>
+#include <bcmwifi.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <wlioctl.h>
+#include <sbconfig.h>
+#include <sbchipc.h>
+#include <pcicfg.h>
+#include <sbhndpio.h>
+#include <sbhnddma.h>
+#include <hnddma.h>
+#include <hndpmu.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_pub.h>
+#include <wlc_channel.h>
+#include <bcmsrom.h>
+#include <wlc_key.h>
+
+#include <wlc_mac80211.h>
+
+#include <wlc_bmac.h>
+#include <wlc_phy_shim.h>
+#include <wlc_phy_hal.h>
+#include <wl_export.h>
+
+/* PHY SHIM module specific state */
+struct wlc_phy_shim_info {
+	wlc_hw_info_t *wlc_hw;	/* pointer to main wlc_hw structure */
+	void *wlc;		/* pointer to main wlc structure */
+	void *wl;		/* pointer to os-specific private state */
+};
+
+wlc_phy_shim_info_t *BCMATTACHFN(wlc_phy_shim_attach) (wlc_hw_info_t * wlc_hw,
+						       void *wl, void *wlc) {
+	wlc_phy_shim_info_t *physhim = NULL;
+
+	if (!
+	    (physhim =
+	     (wlc_phy_shim_info_t *) MALLOC(wlc_hw->osh,
+					    sizeof(wlc_phy_shim_info_t)))) {
+		WL_ERROR(("wl%d: wlc_phy_shim_attach: out of mem, malloced %d bytes\n", wlc_hw->unit, MALLOCED(wlc_hw->osh)));
+		return NULL;
+	}
+	bzero((char *)physhim, sizeof(wlc_phy_shim_info_t));
+	physhim->wlc_hw = wlc_hw;
+	physhim->wlc = wlc;
+	physhim->wl = wl;
+
+	return physhim;
+}
+
+void BCMATTACHFN(wlc_phy_shim_detach) (wlc_phy_shim_info_t * physhim) {
+	if (!physhim)
+		return;
+
+	MFREE(physhim->wlc_hw->osh, physhim, sizeof(wlc_phy_shim_info_t));
+}
+
+struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t * physhim,
+				     void (*fn) (void *arg), void *arg,
+				     const char *name)
+{
+	return (struct wlapi_timer *)wl_init_timer(physhim->wl, fn, arg, name);
+}
+
+void wlapi_free_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t)
+{
+	wl_free_timer(physhim->wl, (struct wl_timer *)t);
+}
+
+void
+wlapi_add_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t, uint ms,
+		int periodic)
+{
+	wl_add_timer(physhim->wl, (struct wl_timer *)t, ms, periodic);
+}
+
+bool wlapi_del_timer(wlc_phy_shim_info_t * physhim, struct wlapi_timer *t)
+{
+	return wl_del_timer(physhim->wl, (struct wl_timer *)t);
+}
+
+void wlapi_intrson(wlc_phy_shim_info_t * physhim)
+{
+	wl_intrson(physhim->wl);
+}
+
+uint32 wlapi_intrsoff(wlc_phy_shim_info_t * physhim)
+{
+	return wl_intrsoff(physhim->wl);
+}
+
+void wlapi_intrsrestore(wlc_phy_shim_info_t * physhim, uint32 macintmask)
+{
+	wl_intrsrestore(physhim->wl, macintmask);
+}
+
+void wlapi_bmac_write_shm(wlc_phy_shim_info_t * physhim, uint offset, uint16 v)
+{
+	wlc_bmac_write_shm(physhim->wlc_hw, offset, v);
+}
+
+uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t * physhim, uint offset)
+{
+	return wlc_bmac_read_shm(physhim->wlc_hw, offset);
+}
+
+void
+wlapi_bmac_mhf(wlc_phy_shim_info_t * physhim, uint8 idx, uint16 mask,
+	       uint16 val, int bands)
+{
+	wlc_bmac_mhf(physhim->wlc_hw, idx, mask, val, bands);
+}
+
+void wlapi_bmac_corereset(wlc_phy_shim_info_t * physhim, uint32 flags)
+{
+	wlc_bmac_corereset(physhim->wlc_hw, flags);
+}
+
+void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t * physhim)
+{
+	wlc_suspend_mac_and_wait(physhim->wlc);
+}
+
+void wlapi_switch_macfreq(wlc_phy_shim_info_t * physhim, uint8 spurmode)
+{
+	wlc_bmac_switch_macfreq(physhim->wlc_hw, spurmode);
+}
+
+void wlapi_enable_mac(wlc_phy_shim_info_t * physhim)
+{
+	wlc_enable_mac(physhim->wlc);
+}
+
+void wlapi_bmac_mctrl(wlc_phy_shim_info_t * physhim, uint32 mask, uint32 val)
+{
+	wlc_bmac_mctrl(physhim->wlc_hw, mask, val);
+}
+
+void wlapi_bmac_phy_reset(wlc_phy_shim_info_t * physhim)
+{
+	wlc_bmac_phy_reset(physhim->wlc_hw);
+}
+
+void wlapi_bmac_bw_set(wlc_phy_shim_info_t * physhim, uint16 bw)
+{
+	wlc_bmac_bw_set(physhim->wlc_hw, bw);
+}
+
+uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t * physhim)
+{
+	return wlc_bmac_get_txant(physhim->wlc_hw);
+}
+
+void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t * physhim, bool clk)
+{
+	wlc_bmac_phyclk_fgc(physhim->wlc_hw, clk);
+}
+
+void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t * physhim, bool clk)
+{
+	wlc_bmac_macphyclk_set(physhim->wlc_hw, clk);
+}
+
+void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t * physhim, bool on)
+{
+	wlc_bmac_core_phypll_ctl(physhim->wlc_hw, on);
+}
+
+void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t * physhim)
+{
+	wlc_bmac_core_phypll_reset(physhim->wlc_hw);
+}
+
+void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t * physhim)
+{
+	wlc_ucode_wake_override_set(physhim->wlc_hw, WLC_WAKE_OVERRIDE_PHYREG);
+}
+
+void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t * physhim)
+{
+	wlc_ucode_wake_override_clear(physhim->wlc_hw,
+				      WLC_WAKE_OVERRIDE_PHYREG);
+}
+
+void
+wlapi_bmac_write_template_ram(wlc_phy_shim_info_t * physhim, int offset,
+			      int len, void *buf)
+{
+	wlc_bmac_write_template_ram(physhim->wlc_hw, offset, len, buf);
+}
+
+uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t * physhim, uint8 rate)
+{
+	return wlc_bmac_rate_shm_offset(physhim->wlc_hw, rate);
+}
+
+void wlapi_ucode_sample_init(wlc_phy_shim_info_t * physhim)
+{
+}
+
+void
+wlapi_copyfrom_objmem(wlc_phy_shim_info_t * physhim, uint offset, void *buf,
+		      int len, uint32 sel)
+{
+	wlc_bmac_copyfrom_objmem(physhim->wlc_hw, offset, buf, len, sel);
+}
+
+void
+wlapi_copyto_objmem(wlc_phy_shim_info_t * physhim, uint offset, const void *buf,
+		    int l, uint32 sel)
+{
+	wlc_bmac_copyto_objmem(physhim->wlc_hw, offset, buf, l, sel);
+}
+
+void
+wlapi_bmac_pktengtx(wlc_phy_shim_info_t * physhim, wl_pkteng_t * pkteng,
+		    uint8 rate, struct ether_addr *sa, uint32 wait_delay)
+{
+	wlc_pktengtx(physhim->wlc, pkteng, rate, sa, wait_delay);
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_phy_shim.h b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
new file mode 100644
index 0000000..73c83a4
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_phy_shim.h
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_phy_shim_h_
+#define _wlc_phy_shim_h_
+
+#define RADAR_TYPE_NONE		0	/* Radar type None */
+#define RADAR_TYPE_ETSI_1	1	/* ETSI 1 Radar type */
+#define RADAR_TYPE_ETSI_2	2	/* ETSI 2 Radar type */
+#define RADAR_TYPE_ETSI_3	3	/* ETSI 3 Radar type */
+#define RADAR_TYPE_ITU_E	4	/* ITU E Radar type */
+#define RADAR_TYPE_ITU_K	5	/* ITU K Radar type */
+#define RADAR_TYPE_UNCLASSIFIED	6	/* Unclassified Radar type  */
+#define RADAR_TYPE_BIN5		7	/* long pulse radar type */
+#define RADAR_TYPE_STG2 	8	/* staggered-2 radar */
+#define RADAR_TYPE_STG3 	9	/* staggered-3 radar */
+#define RADAR_TYPE_FRA		10	/* French radar */
+
+/* French radar pulse widths */
+#define FRA_T1_20MHZ	52770
+#define FRA_T2_20MHZ	61538
+#define FRA_T3_20MHZ	66002
+#define FRA_T1_40MHZ	105541
+#define FRA_T2_40MHZ	123077
+#define FRA_T3_40MHZ	132004
+#define FRA_ERR_20MHZ	60
+#define FRA_ERR_40MHZ	120
+
+#define ANTSEL_NA		0	/* No boardlevel selection available */
+#define ANTSEL_2x4		1	/* 2x4 boardlevel selection available */
+#define ANTSEL_2x3		2	/* 2x3 CB2 boardlevel selection available */
+
+/* Rx Antenna diversity control values */
+#define	ANT_RX_DIV_FORCE_0		0	/* Use antenna 0 */
+#define	ANT_RX_DIV_FORCE_1		1	/* Use antenna 1 */
+#define	ANT_RX_DIV_START_1		2	/* Choose starting with 1 */
+#define	ANT_RX_DIV_START_0		3	/* Choose starting with 0 */
+#define	ANT_RX_DIV_ENABLE		3	/* APHY bbConfig Enable RX Diversity */
+#define ANT_RX_DIV_DEF		ANT_RX_DIV_START_0	/* default antdiv setting */
+
+/* Forward declarations */
+struct wlc_hw_info;
+typedef struct wlc_phy_shim_info wlc_phy_shim_info_t;
+
+extern wlc_phy_shim_info_t *wlc_phy_shim_attach(struct wlc_hw_info *wlc_hw,
+						void *wl, void *wlc);
+extern void wlc_phy_shim_detach(wlc_phy_shim_info_t * physhim);
+
+/* PHY to WL utility functions */
+struct wlapi_timer;
+extern struct wlapi_timer *wlapi_init_timer(wlc_phy_shim_info_t * physhim,
+					    void (*fn) (void *arg), void *arg,
+					    const char *name);
+extern void wlapi_free_timer(wlc_phy_shim_info_t * physhim,
+			     struct wlapi_timer *t);
+extern void wlapi_add_timer(wlc_phy_shim_info_t * physhim,
+			    struct wlapi_timer *t, uint ms, int periodic);
+extern bool wlapi_del_timer(wlc_phy_shim_info_t * physhim,
+			    struct wlapi_timer *t);
+extern void wlapi_intrson(wlc_phy_shim_info_t * physhim);
+extern uint32 wlapi_intrsoff(wlc_phy_shim_info_t * physhim);
+extern void wlapi_intrsrestore(wlc_phy_shim_info_t * physhim,
+			       uint32 macintmask);
+
+extern void wlapi_bmac_write_shm(wlc_phy_shim_info_t * physhim, uint offset,
+				 uint16 v);
+extern uint16 wlapi_bmac_read_shm(wlc_phy_shim_info_t * physhim, uint offset);
+extern void wlapi_bmac_mhf(wlc_phy_shim_info_t * physhim, uint8 idx,
+			   uint16 mask, uint16 val, int bands);
+extern void wlapi_bmac_corereset(wlc_phy_shim_info_t * physhim, uint32 flags);
+extern void wlapi_suspend_mac_and_wait(wlc_phy_shim_info_t * physhim);
+extern void wlapi_switch_macfreq(wlc_phy_shim_info_t * physhim, uint8 spurmode);
+extern void wlapi_enable_mac(wlc_phy_shim_info_t * physhim);
+extern void wlapi_bmac_mctrl(wlc_phy_shim_info_t * physhim, uint32 mask,
+			     uint32 val);
+extern void wlapi_bmac_phy_reset(wlc_phy_shim_info_t * physhim);
+extern void wlapi_bmac_bw_set(wlc_phy_shim_info_t * physhim, uint16 bw);
+extern void wlapi_bmac_phyclk_fgc(wlc_phy_shim_info_t * physhim, bool clk);
+extern void wlapi_bmac_macphyclk_set(wlc_phy_shim_info_t * physhim, bool clk);
+extern void wlapi_bmac_core_phypll_ctl(wlc_phy_shim_info_t * physhim, bool on);
+extern void wlapi_bmac_core_phypll_reset(wlc_phy_shim_info_t * physhim);
+extern void wlapi_bmac_ucode_wake_override_phyreg_set(wlc_phy_shim_info_t *
+						      physhim);
+extern void wlapi_bmac_ucode_wake_override_phyreg_clear(wlc_phy_shim_info_t *
+							physhim);
+extern void wlapi_bmac_write_template_ram(wlc_phy_shim_info_t * physhim, int o,
+					  int len, void *buf);
+extern uint16 wlapi_bmac_rate_shm_offset(wlc_phy_shim_info_t * physhim,
+					 uint8 rate);
+extern void wlapi_ucode_sample_init(wlc_phy_shim_info_t * physhim);
+extern void wlapi_copyfrom_objmem(wlc_phy_shim_info_t * physhim, uint,
+				  void *buf, int, uint32 sel);
+extern void wlapi_copyto_objmem(wlc_phy_shim_info_t * physhim, uint,
+				const void *buf, int, uint32);
+
+extern void wlapi_high_update_phy_mode(wlc_phy_shim_info_t * physhim,
+				       uint32 phy_mode);
+extern void wlapi_bmac_pktengtx(wlc_phy_shim_info_t * physhim,
+				wl_pkteng_t * pkteng, uint8 rate,
+				struct ether_addr *sa, uint32 wait_delay);
+extern uint16 wlapi_bmac_get_txant(wlc_phy_shim_info_t * physhim);
+#endif				/* _wlc_phy_shim_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_pub.h b/drivers/staging/brcm80211/sys/wlc_pub.h
new file mode 100644
index 0000000..fe02081
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_pub.h
@@ -0,0 +1,714 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_pub_h_
+#define _wlc_pub_h_
+
+#include <wlc_types.h>
+#include <wlc_scb.h>
+
+#define	WLC_NUMRATES	16	/* max # of rates in a rateset */
+#define	MAXMULTILIST	32	/* max # multicast addresses */
+#define	D11_PHY_HDR_LEN	6	/* Phy header length - 6 bytes */
+
+/* phy types */
+#define	PHY_TYPE_A	0	/* Phy type A */
+#define	PHY_TYPE_G	2	/* Phy type G */
+#define	PHY_TYPE_N	4	/* Phy type N */
+#define	PHY_TYPE_LP	5	/* Phy type Low Power A/B/G */
+#define	PHY_TYPE_SSN	6	/* Phy type Single Stream N */
+#define	PHY_TYPE_LCN	8	/* Phy type Single Stream N */
+#define	PHY_TYPE_LCNXN	9	/* Phy type 2-stream N */
+#define	PHY_TYPE_HT	7	/* Phy type 3-Stream N */
+
+/* bw */
+#define WLC_10_MHZ	10	/* 10Mhz nphy channel bandwidth */
+#define WLC_20_MHZ	20	/* 20Mhz nphy channel bandwidth */
+#define WLC_40_MHZ	40	/* 40Mhz nphy channel bandwidth */
+
+#define CHSPEC_WLC_BW(chanspec)	(CHSPEC_IS40(chanspec) ? WLC_40_MHZ : \
+				 CHSPEC_IS20(chanspec) ? WLC_20_MHZ : \
+							 WLC_10_MHZ)
+
+#define	WLC_RSSI_MINVAL		-200	/* Low value, e.g. for forcing roam */
+#define	WLC_RSSI_NO_SIGNAL	-91	/* NDIS RSSI link quality cutoffs */
+#define	WLC_RSSI_VERY_LOW	-80	/* Very low quality cutoffs */
+#define	WLC_RSSI_LOW		-70	/* Low quality cutoffs */
+#define	WLC_RSSI_GOOD		-68	/* Good quality cutoffs */
+#define	WLC_RSSI_VERY_GOOD	-58	/* Very good quality cutoffs */
+#define	WLC_RSSI_EXCELLENT	-57	/* Excellent quality cutoffs */
+
+#define WLC_PHYTYPE(_x) (_x)	/* macro to perform WLC PHY -> D11 PHY TYPE, currently 1:1 */
+
+#define MA_WINDOW_SZ		8	/* moving average window size */
+
+#define WLC_SNR_INVALID		0	/* invalid SNR value */
+
+/* a large TX Power as an init value to factor out of MIN() calculations,
+ * keep low enough to fit in an int8, units are .25 dBm
+ */
+#define WLC_TXPWR_MAX		(127)	/* ~32 dBm = 1,500 mW */
+
+/* legacy rx Antenna diversity for SISO rates */
+#define	ANT_RX_DIV_FORCE_0		0	/* Use antenna 0 */
+#define	ANT_RX_DIV_FORCE_1		1	/* Use antenna 1 */
+#define	ANT_RX_DIV_START_1		2	/* Choose starting with 1 */
+#define	ANT_RX_DIV_START_0		3	/* Choose starting with 0 */
+#define	ANT_RX_DIV_ENABLE		3	/* APHY bbConfig Enable RX Diversity */
+#define ANT_RX_DIV_DEF		ANT_RX_DIV_START_0	/* default antdiv setting */
+
+/* legacy rx Antenna diversity for SISO rates */
+#define ANT_TX_FORCE_0		0	/* Tx on antenna 0, "legacy term Main" */
+#define ANT_TX_FORCE_1		1	/* Tx on antenna 1, "legacy term Aux" */
+#define ANT_TX_LAST_RX		3	/* Tx on phy's last good Rx antenna */
+#define ANT_TX_DEF			3	/* driver's default tx antenna setting */
+
+#define TXCORE_POLICY_ALL	0x1	/* use all available core for transmit */
+
+/* Tx Chain values */
+#define TXCHAIN_DEF		0x1	/* def bitmap of txchain */
+#define TXCHAIN_DEF_NPHY	0x3	/* default bitmap of tx chains for nphy */
+#define TXCHAIN_DEF_HTPHY	0x7	/* default bitmap of tx chains for nphy */
+#define RXCHAIN_DEF		0x1	/* def bitmap of rxchain */
+#define RXCHAIN_DEF_NPHY	0x3	/* default bitmap of rx chains for nphy */
+#define RXCHAIN_DEF_HTPHY	0x7	/* default bitmap of rx chains for nphy */
+#define ANTSWITCH_NONE		0	/* no antenna switch */
+#define ANTSWITCH_TYPE_1	1	/* antenna switch on 4321CB2, 2of3 */
+#define ANTSWITCH_TYPE_2	2	/* antenna switch on 4321MPCI, 2of3 */
+#define ANTSWITCH_TYPE_3	3	/* antenna switch on 4322, 2of3 */
+
+#define RXBUFSZ		PKTBUFSZ
+#ifndef AIDMAPSZ
+#define AIDMAPSZ	(ROUNDUP(MAXSCB, NBBY)/NBBY)	/* aid bitmap size in bytes */
+#endif				/* AIDMAPSZ */
+
+typedef struct wlc_tunables {
+	int ntxd;		/* size of tx descriptor table */
+	int nrxd;		/* size of rx descriptor table */
+	int rxbufsz;		/* size of rx buffers to post */
+	int nrxbufpost;		/* # of rx buffers to post */
+	int maxscb;		/* # of SCBs supported */
+	int ampdunummpdu;	/* max number of mpdu in an ampdu */
+	int maxpktcb;		/* max # of packet callbacks */
+	int maxucodebss;	/* max # of BSS handled in ucode bcn/prb */
+	int maxucodebss4;	/* max # of BSS handled in sw bcn/prb */
+	int maxbss;		/* max # of bss info elements in scan list */
+	int datahiwat;		/* data msg txq hiwat mark */
+	int ampdudatahiwat;	/* AMPDU msg txq hiwat mark */
+	int rxbnd;		/* max # of rx bufs to process before deferring to dpc */
+	int txsbnd;		/* max # tx status to process in wlc_txstatus() */
+	int memreserved;	/* memory reserved for BMAC's USB dma rx */
+} wlc_tunables_t;
+
+typedef struct wlc_rateset {
+	uint count;		/* number of rates in rates[] */
+	uint8 rates[WLC_NUMRATES];	/* rates in 500kbps units w/hi bit set if basic */
+	uint8 htphy_membership;	/* HT PHY Membership */
+	uint8 mcs[MCSSET_LEN];	/* supported mcs index bit map */
+} wlc_rateset_t;
+
+struct rsn_parms {
+	uint8 flags;		/* misc booleans (e.g., supported) */
+	uint8 multicast;	/* multicast cipher */
+	uint8 ucount;		/* count of unicast ciphers */
+	uint8 unicast[4];	/* unicast ciphers */
+	uint8 acount;		/* count of auth modes */
+	uint8 auth[4];		/* Authentication modes */
+	uint8 PAD[4];		/* padding for future growth */
+};
+
+/*
+ * buffer length needed for wlc_format_ssid
+ * 32 SSID chars, max of 4 chars for each SSID char "\xFF", plus NULL.
+ */
+#define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)
+
+#define RSN_FLAGS_SUPPORTED		0x1	/* Flag for rsn_params */
+#define RSN_FLAGS_PREAUTH		0x2	/* Flag for WPA2 rsn_params */
+
+/* All the HT-specific default advertised capabilities (including AMPDU)
+ * should be grouped here at one place
+ */
+#define AMPDU_DEF_MPDU_DENSITY	6	/* default mpdu density (110 ==> 4us) */
+
+/* defaults for the HT (MIMO) bss */
+#define HT_CAP	((HT_CAP_MIMO_PS_OFF << HT_CAP_MIMO_PS_SHIFT) | HT_CAP_40MHZ | \
+	HT_CAP_GF | HT_CAP_MAX_AMSDU | HT_CAP_DSSS_CCK)
+
+/* WLC packet type is a void * */
+typedef void *wlc_pkt_t;
+
+/* Event data type */
+typedef struct wlc_event {
+	wl_event_msg_t event;	/* encapsulated event */
+	struct ether_addr *addr;	/* used to keep a trace of the potential present of
+					 * an address in wlc_event_msg_t
+					 */
+	int bsscfgidx;		/* BSS config when needed */
+	struct wl_if *wlif;	/* pointer to wlif */
+	void *data;		/* used to hang additional data on an event */
+	struct wlc_event *next;	/* enables ordered list of pending events */
+} wlc_event_t;
+
+/* wlc internal bss_info, wl external one is in wlioctl.h */
+typedef struct wlc_bss_info {
+	struct ether_addr BSSID;	/* network BSSID */
+	uint16 flags;		/* flags for internal attributes */
+	uint8 SSID_len;		/* the length of SSID */
+	uint8 SSID[32];		/* SSID string */
+	int16 RSSI;		/* receive signal strength (in dBm) */
+	int16 SNR;		/* receive signal SNR in dB */
+	uint16 beacon_period;	/* units are Kusec */
+	uint16 atim_window;	/* units are Kusec */
+	chanspec_t chanspec;	/* Channel num, bw, ctrl_sb and band */
+	int8 infra;		/* 0=IBSS, 1=infrastructure, 2=unknown */
+	wlc_rateset_t rateset;	/* supported rates */
+	uint8 dtim_period;	/* DTIM period */
+	int8 phy_noise;		/* noise right after tx (in dBm) */
+	uint16 capability;	/* Capability information */
+	struct dot11_bcn_prb *bcn_prb;	/* beacon/probe response frame (ioctl na) */
+	uint16 bcn_prb_len;	/* beacon/probe response frame length (ioctl na) */
+	uint8 wme_qosinfo;	/* QoS Info from WME IE; valid if WLC_BSS_WME flag set */
+	struct rsn_parms wpa;
+	struct rsn_parms wpa2;
+	uint16 qbss_load_aac;	/* qbss load available admission capacity */
+	/* qbss_load_chan_free <- (0xff - channel_utilization of qbss_load_ie_t) */
+	uint8 qbss_load_chan_free;	/* indicates how free the channel is */
+	uint8 mcipher;		/* multicast cipher */
+	uint8 wpacfg;		/* wpa config index */
+} wlc_bss_info_t;
+
+/* forward declarations */
+struct wlc_if;
+
+/* wlc_ioctl error codes */
+#define WLC_ENOIOCTL	1	/* No such Ioctl */
+#define WLC_EINVAL	2	/* Invalid value */
+#define WLC_ETOOSMALL	3	/* Value too small */
+#define WLC_ETOOBIG	4	/* Value too big */
+#define WLC_ERANGE	5	/* Out of range */
+#define WLC_EDOWN	6	/* Down */
+#define WLC_EUP		7	/* Up */
+#define WLC_ENOMEM	8	/* No Memory */
+#define WLC_EBUSY	9	/* Busy */
+
+/* IOVar flags for common error checks */
+#define IOVF_MFG	(1<<3)	/* flag for mfgtest iovars */
+#define IOVF_WHL	(1<<4)	/* value must be whole (0-max) */
+#define IOVF_NTRL	(1<<5)	/* value must be natural (1-max) */
+
+#define IOVF_SET_UP	(1<<6)	/* set requires driver be up */
+#define IOVF_SET_DOWN	(1<<7)	/* set requires driver be down */
+#define IOVF_SET_CLK	(1<<8)	/* set requires core clock */
+#define IOVF_SET_BAND	(1<<9)	/* set requires fixed band */
+
+#define IOVF_GET_UP	(1<<10)	/* get requires driver be up */
+#define IOVF_GET_DOWN	(1<<11)	/* get requires driver be down */
+#define IOVF_GET_CLK	(1<<12)	/* get requires core clock */
+#define IOVF_GET_BAND	(1<<13)	/* get requires fixed band */
+#define IOVF_OPEN_ALLOW	(1<<14)	/* set allowed iovar for opensrc */
+
+/* watchdog down and dump callback function proto's */
+typedef int (*watchdog_fn_t) (void *handle);
+typedef int (*down_fn_t) (void *handle);
+typedef int (*dump_fn_t) (void *handle, struct bcmstrbuf * b);
+
+/* IOVar handler
+ *
+ * handle - a pointer value registered with the function
+ * vi - iovar_info that was looked up
+ * actionid - action ID, calculated by IOV_GVAL() and IOV_SVAL() based on varid.
+ * name - the actual iovar name
+ * params/plen - parameters and length for a get, input only.
+ * arg/len - buffer and length for value to be set or retrieved, input or output.
+ * vsize - value size, valid for integer type only.
+ * wlcif - interface context (wlc_if pointer)
+ *
+ * All pointers may point into the same buffer.
+ */
+typedef int (*iovar_fn_t) (void *handle, const bcm_iovar_t * vi,
+			   uint32 actionid, const char *name, void *params,
+			   uint plen, void *arg, int alen, int vsize,
+			   struct wlc_if * wlcif);
+
+#define MAC80211_PROMISC_BCNS	(1 << 0)
+#define MAC80211_SCAN		(1 << 1)
+
+/*
+ * Public portion of "common" os-independent state structure.
+ * The wlc handle points at this.
+ */
+typedef struct wlc_pub {
+	void *wlc;
+
+	struct ieee80211_hw *ieee_hw;
+	struct scb *global_scb;
+	scb_ampdu_t *global_ampdu;
+	uint mac80211_state;
+	uint unit;		/* device instance number */
+	uint corerev;		/* core revision */
+	osl_t *osh;		/* pointer to os handle */
+	si_t *sih;		/* SB handle (cookie for siutils calls) */
+	char *vars;		/* "environment" name=value */
+	bool up;		/* interface up and running */
+	bool hw_off;		/* HW is off */
+	wlc_tunables_t *tunables;	/* tunables: ntxd, nrxd, maxscb, etc. */
+	bool hw_up;		/* one time hw up/down(from boot or hibernation) */
+	bool _piomode;		/* true if pio mode *//* BMAC_NOTE: NEED In both */
+	uint _nbands;		/* # bands supported */
+	uint now;		/* # elapsed seconds */
+
+	bool promisc;		/* promiscuous destination address */
+	bool delayed_down;	/* down delayed */
+	bool _ap;		/* AP mode enabled */
+	bool _apsta;		/* simultaneous AP/STA mode enabled */
+	bool _assoc_recreate;	/* association recreation on up transitions */
+	int _wme;		/* WME QoS mode */
+	uint8 _mbss;		/* MBSS mode on */
+	bool allmulti;		/* enable all multicasts */
+	bool associated;	/* true:part of [I]BSS, false: not */
+	/* (union of stas_associated, aps_associated) */
+	bool phytest_on;	/* whether a PHY test is running */
+	bool bf_preempt_4306;	/* True to enable 'darwin' mode */
+	bool _ampdu;		/* ampdu enabled or not */
+	bool _cac;		/* 802.11e CAC enabled */
+	uint8 _n_enab;		/* bitmap of 11N + HT support */
+	bool _n_reqd;		/* N support required for clients */
+
+	int8 _coex;		/* 20/40 MHz BSS Management AUTO, ENAB, DISABLE */
+	bool _priofc;		/* Priority-based flowcontrol */
+
+	struct ether_addr cur_etheraddr;	/* our local ethernet address */
+
+	struct ether_addr *multicast;	/* ptr to list of multicast addresses */
+	uint nmulticast;	/* # enabled multicast addresses */
+
+	uint32 wlfeatureflag;	/* Flags to control sw features from registry */
+	int psq_pkts_total;	/* total num of ps pkts */
+
+	uint16 txmaxpkts;	/* max number of large pkts allowed to be pending */
+
+	/* s/w decryption counters */
+	uint32 swdecrypt;	/* s/w decrypt attempts */
+
+	int bcmerror;		/* last bcm error */
+
+	mbool radio_disabled;	/* bit vector for radio disabled reasons */
+	bool radio_active;	/* radio on/off state */
+	uint16 roam_time_thresh;	/* Max. # secs. of not hearing beacons
+					 * before roaming.
+					 */
+	bool align_wd_tbtt;	/* Align watchdog with tbtt indication
+				 * handling. This flag is cleared by default
+				 * and is set by per port code explicitly and
+				 * you need to make sure the OSL_SYSUPTIME()
+				 * is implemented properly in osl of that port
+				 * when it enables this Power Save feature.
+				 */
+#ifdef BCMSDIO
+	uint sdiod_drive_strength;	/* SDIO drive strength */
+#endif				/* BCMSDIO */
+
+	uint16 boardrev;	/* version # of particular board */
+	uint8 sromrev;		/* version # of the srom */
+	char srom_ccode[WLC_CNTRY_BUF_SZ];	/* Country Code in SROM */
+	uint32 boardflags;	/* Board specific flags from srom */
+	uint32 boardflags2;	/* More board flags if sromrev >= 4 */
+	bool tempsense_disable;	/* disable periodic tempsense check */
+
+	bool _lmac;		/* lmac module included and enabled */
+	bool _lmacproto;	/* lmac protocol module included and enabled */
+	bool phy_11ncapable;	/* the PHY/HW is capable of 802.11N */
+	bool _ampdumac;		/* mac assist ampdu enabled or not */
+} wlc_pub_t;
+
+/* wl_monitor rx status per packet */
+typedef struct wl_rxsts {
+	uint pkterror;		/* error flags per pkt */
+	uint phytype;		/* 802.11 A/B/G ... */
+	uint channel;		/* channel */
+	uint datarate;		/* rate in 500kbps */
+	uint antenna;		/* antenna pkts received on */
+	uint pktlength;		/* pkt length minus bcm phy hdr */
+	uint32 mactime;		/* time stamp from mac, count per 1us */
+	uint sq;		/* signal quality */
+	int32 signal;		/* in dbm */
+	int32 noise;		/* in dbm */
+	uint preamble;		/* Unknown, short, long */
+	uint encoding;		/* Unknown, CCK, PBCC, OFDM */
+	uint nfrmtype;		/* special 802.11n frames(AMPDU, AMSDU) */
+	struct wl_if *wlif;	/* wl interface */
+} wl_rxsts_t;
+
+/* status per error RX pkt */
+#define WL_RXS_CRC_ERROR		0x00000001	/* CRC Error in packet */
+#define WL_RXS_RUNT_ERROR		0x00000002	/* Runt packet */
+#define WL_RXS_ALIGN_ERROR		0x00000004	/* Misaligned packet */
+#define WL_RXS_OVERSIZE_ERROR		0x00000008	/* packet bigger than RX_LENGTH (usually 1518) */
+#define WL_RXS_WEP_ICV_ERROR		0x00000010	/* Integrity Check Value error */
+#define WL_RXS_WEP_ENCRYPTED		0x00000020	/* Encrypted with WEP */
+#define WL_RXS_PLCP_SHORT		0x00000040	/* Short PLCP error */
+#define WL_RXS_DECRYPT_ERR		0x00000080	/* Decryption error */
+#define WL_RXS_OTHER_ERR		0x80000000	/* Other errors */
+
+/* phy type */
+#define WL_RXS_PHY_A			0x00000000	/* A phy type */
+#define WL_RXS_PHY_B			0x00000001	/* B phy type */
+#define WL_RXS_PHY_G			0x00000002	/* G phy type */
+#define WL_RXS_PHY_N			0x00000004	/* N phy type */
+
+/* encoding */
+#define WL_RXS_ENCODING_CCK		0x00000000	/* CCK encoding */
+#define WL_RXS_ENCODING_OFDM		0x00000001	/* OFDM encoding */
+
+/* preamble */
+#define WL_RXS_UNUSED_STUB		0x0	/* stub to match with wlc_ethereal.h */
+#define WL_RXS_PREAMBLE_SHORT		0x00000001	/* Short preamble */
+#define WL_RXS_PREAMBLE_LONG		0x00000002	/* Long preamble */
+#define WL_RXS_PREAMBLE_MIMO_MM		0x00000003	/* MIMO mixed mode preamble */
+#define WL_RXS_PREAMBLE_MIMO_GF		0x00000004	/* MIMO green field preamble */
+
+#define WL_RXS_NFRM_AMPDU_FIRST		0x00000001	/* first MPDU in A-MPDU */
+#define WL_RXS_NFRM_AMPDU_SUB		0x00000002	/* subsequent MPDU(s) in A-MPDU */
+#define WL_RXS_NFRM_AMSDU_FIRST		0x00000004	/* first MSDU in A-MSDU */
+#define WL_RXS_NFRM_AMSDU_SUB		0x00000008	/* subsequent MSDU(s) in A-MSDU */
+
+/* forward declare and use the struct notation so we don't have to
+ * have it defined if not necessary.
+ */
+struct wlc_info;
+struct wlc_hw_info;
+struct wlc_bsscfg;
+struct wlc_if;
+
+/* Structure for Pkttag area in a packet.
+ * CAUTION: Please carefully consider your design before adding any new fields to the pkttag
+ * The size is limited to 32 bytes which on 64-bit machine allows only 4 fields.
+ * If adding a member, be sure to check if wlc_pkttag_info_move should transfer it.
+ */
+typedef struct {
+	uint32 flags;		/* Describe various packet properties */
+	uint16 seq;		/* preassigned seqnum for AMPDU */
+#ifdef BCMDBG
+	uint16 _scb_dbgid;	/* Uniqe debug id for the scb pointed by scb pointer */
+#endif
+	uint8 callbackidx;	/* Index into pkt_callback tables for callback function */
+	int8 _bsscfgidx;	/* Index of bsscfg for this frame */
+	int8 ac_override;	/* fifo on which this frame should go */
+	int8 rssi;		/* RSSI for the recvd. packet */
+	uint32 exptime;		/* Time of expiry for the packet */
+	struct scb *_scb;	/* Pointer to SCB for associated ea */
+	uint32 rspec;		/* Phy rate for received packet */
+	union {
+		uint32 packetid;
+	} shared;
+} wlc_pkttag_t;
+
+#define WLPKTTAG(p) ((wlc_pkttag_t*)PKTTAG(p))
+
+/* Flags used in wlc_pkttag_t.
+ * If adding a flag, be sure to check if WLPKTTAG_FLAG_MOVE should transfer it.
+ */
+#define WLF_PSMARK		0x00000001	/* PKT marking for PSQ aging */
+#define WLF_PSDONTQ		0x00000002	/* PS-Poll response don't queue flag */
+#define WLF_MPDU		0x00000004	/* Set if pkt is a PDU as opposed to MSDU */
+#define WLF_NON8023		0x00000008	/* original pkt is not 8023 */
+#define WLF_8021X		0x00000010	/* original pkt is 802.1x */
+#define WLF_APSD		0x00000020	/* APSD delivery frame */
+#define WLF_AMSDU		0x00000040	/* pkt is aggregated msdu */
+#define WLF_HWAMSDU		0x00000080	/* Rx: HW/ucode has deaggregated this A-MSDU */
+#define WLF_TXHDR		0x00000080	/* Tx: pkt is 802.11 MPDU with plcp and txhdr */
+#define WLF_BA			0x00000100	/* Used by BA module if pkt is not to be acked */
+#define WLF_EXPTIME		0x00000200	/* pkttag has a valid expiration time for the pkt */
+#define WLF_AMPDU_MPDU		0x00000400	/* mpdu in a ampdu */
+#define WLF_MIMO		0x00000800	/* mpdu has a mimo rate */
+#define WLF_RIFS		0x00001000	/* frameburst with RIFS separated */
+#define WLF_VRATE_PROBE		0x00002000	/* vertical rate probe mpdu */
+#define WLF_BSS_DOWN		0x00004000	/* The BSS associated with the pkt has gone down */
+#define WLF_UMAC_PKT		0x00008000	/* UMAC Packet */
+#define WLF_EXEMPT_MASK		0x00030000	/* mask for encryption exemption (Vista) */
+#define WLF_WME_NOACK		0x00040000	/* pkt use WME No ACK policy */
+#define WLF_USERTS		0x04000000	/* protect the packet with RTS/CTS */
+#define WLF_RATE_AUTO		0x08000000	/* pkt uses rates from the rate selection module */
+
+#define WLF_DATA		0x40000000	/* pkt is pure data */
+
+#define WLPKTFLAG_BA(pkttag)	FALSE
+
+#define WLPKTFLAG_AMPDU(pkttag)	((pkttag)->flags & WLF_AMPDU_MPDU)
+#define WLPKTFLAG_RIFS(pkttag)	((pkttag)->flags & WLF_RIFS)
+
+/* API for accessing BSSCFG index in WLPKTTAG */
+#define BSSCFGIDX_ISVALID(bsscfgidx) (((bsscfgidx >= 0)&&(bsscfgidx < WLC_MAXBSSCFG)) ? 1 : 0)
+
+static INLINE int8 wlc_pkttag_bsscfg_get(void *p)
+{
+	int8 idx = WLPKTTAG(p)->_bsscfgidx;
+#ifdef BCMDBG
+	ASSERT(BSSCFGIDX_ISVALID(idx));
+#endif
+	return idx;
+}
+
+#define WLPKTTAGBSSCFGGET(p) (wlc_pkttag_bsscfg_get(p))
+#define WLPKTTAGBSSCFGSET(p, bsscfgidx) (WLPKTTAG(p)->_bsscfgidx = bsscfgidx)
+
+/* Raw get of bss idx from pkt tag without error checking */
+#define WLPKTTAG_BSSIDX_GET(pkttag) ((pkttag)->_bsscfgidx)
+
+/***********************************************
+ * Feature-related macros to optimize out code *
+ * *********************************************
+ */
+
+/* AP Support (versus STA) */
+#define	AP_ENAB(pub)	(0)
+
+/* Macro to check if APSTA mode enabled */
+#define APSTA_ENAB(pub)	(0)
+
+/* Some useful combinations */
+#define STA_ONLY(pub)	(!AP_ENAB(pub))
+#define AP_ONLY(pub)	(AP_ENAB(pub) && !APSTA_ENAB(pub))
+
+#define ENAB_1x1	0x01
+#define ENAB_2x2	0x02
+#define ENAB_3x3	0x04
+#define ENAB_4x4	0x08
+#define SUPPORT_11N	(ENAB_1x1|ENAB_2x2)
+#define SUPPORT_HT	(ENAB_1x1|ENAB_2x2|ENAB_3x3)
+/* WL11N Support */
+#if ((defined(NCONF) && (NCONF != 0)) || (defined(LCNCONF) && (LCNCONF != 0)) || \
+	(defined(HTCONF) && (HTCONF != 0)) || (defined(SSLPNCONF) && (SSLPNCONF != 0)))
+#define N_ENAB(pub) ((pub)->_n_enab & SUPPORT_11N)
+#define N_REQD(pub) ((pub)->_n_reqd)
+#else
+#define N_ENAB(pub)	0
+#define N_REQD(pub)	0
+#endif
+
+#if (defined(HTCONF) && (HTCONF != 0))
+#define HT_ENAB(pub) (((pub)->_n_enab & SUPPORT_HT) == SUPPORT_HT)
+#else
+#define HT_ENAB(pub) 0
+#endif
+
+#define AMPDU_AGG_HOST	1
+#define AMPDU_ENAB(pub) ((pub)->_ampdu)
+
+#define EDCF_ENAB(pub) (WME_ENAB(pub))
+#define QOS_ENAB(pub) (WME_ENAB(pub) || N_ENAB(pub))
+
+#define MONITOR_ENAB(wlc)	(bcmspace && (wlc)->monitor)
+
+#define PROMISC_ENAB(wlc)	(bcmspace && (wlc)->promisc)
+
+extern void wlc_pkttag_info_move(wlc_pub_t * pub, void *pkt_from, void *pkt_to);
+
+#define WLPKTTAGSCB(p) (WLPKTTAG(p)->_scb)
+
+#define	WLC_PREC_COUNT		16	/* Max precedence level implemented */
+
+/* pri is PKTPRIO encoded in the packet. This maps the Packet priority to
+ * enqueue precedence as defined in wlc_prec_map
+ */
+extern const uint8 wlc_prio2prec_map[];
+#define WLC_PRIO_TO_PREC(pri)	wlc_prio2prec_map[(pri) & 7]
+
+/* This maps priority to one precedence higher - Used by PS-Poll response packets to
+ * simulate enqueue-at-head operation, but still maintain the order on the queue
+ */
+#define WLC_PRIO_TO_HI_PREC(pri)	MIN(WLC_PRIO_TO_PREC(pri) + 1, WLC_PREC_COUNT - 1)
+
+extern const uint8 wme_fifo2ac[];
+#define WME_PRIO2AC(prio)	wme_fifo2ac[prio2fifo[(prio)]]
+
+/* Mask to describe all precedence levels */
+#define WLC_PREC_BMP_ALL		MAXBITVAL(WLC_PREC_COUNT)
+
+/* Define a bitmap of precedences comprised by each AC */
+#define WLC_PREC_BMP_AC_BE	(NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_BE)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_BE)) |	\
+				NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_EE)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_EE)))
+#define WLC_PREC_BMP_AC_BK	(NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_BK)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_BK)) |	\
+				NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_NONE)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_NONE)))
+#define WLC_PREC_BMP_AC_VI	(NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_CL)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_CL)) |	\
+				NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_VI)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_VI)))
+#define WLC_PREC_BMP_AC_VO	(NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_VO)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_VO)) |	\
+				NBITVAL(WLC_PRIO_TO_PREC(PRIO_8021D_NC)) |	\
+				NBITVAL(WLC_PRIO_TO_HI_PREC(PRIO_8021D_NC)))
+
+/* WME Support */
+#define WME_ENAB(pub) ((pub)->_wme != OFF)
+#define WME_AUTO(wlc) ((wlc)->pub->_wme == AUTO)
+
+#define WLC_USE_COREFLAGS	0xffffffff	/* invalid core flags, use the saved coreflags */
+
+#define WLC_UPDATE_STATS(wlc)	0	/* No stats support */
+#define WLCNTINCR(a)		/* No stats support */
+#define WLCNTDECR(a)		/* No stats support */
+#define WLCNTADD(a,delta)	/* No stats support */
+#define WLCNTSET(a,value)	/* No stats support */
+#define WLCNTVAL(a)		0	/* No stats support */
+
+/* common functions for every port */
+extern void *wlc_attach(void *wl, uint16 vendor, uint16 device, uint unit,
+			bool piomode, osl_t * osh, void *regsva, uint bustype,
+			void *btparam, uint * perr);
+extern uint wlc_detach(struct wlc_info *wlc);
+extern int wlc_up(struct wlc_info *wlc);
+extern uint wlc_down(struct wlc_info *wlc);
+
+extern int wlc_set(struct wlc_info *wlc, int cmd, int arg);
+extern int wlc_get(struct wlc_info *wlc, int cmd, int *arg);
+extern int wlc_iovar_getint(struct wlc_info *wlc, const char *name, int *arg);
+extern int wlc_iovar_setint(struct wlc_info *wlc, const char *name, int arg);
+extern bool wlc_chipmatch(uint16 vendor, uint16 device);
+extern void wlc_init(struct wlc_info *wlc);
+extern void wlc_reset(struct wlc_info *wlc);
+
+extern void wlc_intrson(struct wlc_info *wlc);
+extern uint32 wlc_intrsoff(struct wlc_info *wlc);
+extern void wlc_intrsrestore(struct wlc_info *wlc, uint32 macintmask);
+extern bool wlc_intrsupd(struct wlc_info *wlc);
+extern bool wlc_isr(struct wlc_info *wlc, bool * wantdpc);
+extern bool wlc_dpc(struct wlc_info *wlc, bool bounded);
+extern bool wlc_send80211_raw(struct wlc_info *wlc, wlc_if_t * wlcif, void *p,
+			      uint ac);
+extern int wlc_iovar_op(struct wlc_info *wlc, const char *name, void *params,
+			int p_len, void *arg, int len, bool set,
+			struct wlc_if *wlcif);
+extern int wlc_ioctl(struct wlc_info *wlc, int cmd, void *arg, int len,
+		     struct wlc_if *wlcif);
+/* helper functions */
+extern void wlc_statsupd(struct wlc_info *wlc);
+extern int wlc_get_header_len(void);
+
+extern wlc_pub_t *wlc_pub(void *wlc);
+
+/* common functions for every port */
+extern int wlc_bmac_up_prep(struct wlc_hw_info *wlc_hw);
+extern int wlc_bmac_up_finish(struct wlc_hw_info *wlc_hw);
+extern int wlc_bmac_down_prep(struct wlc_hw_info *wlc_hw);
+extern int wlc_bmac_down_finish(struct wlc_hw_info *wlc_hw);
+
+extern int wlc_nin_ioctl(struct wlc_info *wlc, int cmd, void *arg, int len,
+			 struct wlc_if *wlcif);
+extern bool wlc_nin_process_sendup(struct wlc_info *wlc, void *p);
+void wlc_nin_create_iapp_ind(struct wlc_info *wlc, void *p, int len);
+
+extern uint32 wlc_reg_read(struct wlc_info *wlc, void *r, uint size);
+extern void wlc_reg_write(struct wlc_info *wlc, void *r, uint32 v, uint size);
+extern void wlc_corereset(struct wlc_info *wlc, uint32 flags);
+extern void wlc_mhf(struct wlc_info *wlc, uint8 idx, uint16 mask, uint16 val,
+		    int bands);
+extern uint16 wlc_mhf_get(struct wlc_info *wlc, uint8 idx, int bands);
+extern uint32 wlc_delta_txfunfl(struct wlc_info *wlc, int fifo);
+extern void wlc_rate_lookup_init(struct wlc_info *wlc, wlc_rateset_t * rateset);
+extern void wlc_default_rateset(struct wlc_info *wlc, wlc_rateset_t * rs);
+extern void wlc_join_attempt(struct wlc_bsscfg *cfg);
+extern void wlc_join_bss_start(struct wlc_bsscfg *cfg);
+extern void wlc_join_BSS(struct wlc_bsscfg *cfg, wlc_bss_info_t * bi);
+
+/* wlc_phy.c helper functions */
+extern bool wlc_scan_inprog(struct wlc_info *wlc);
+extern bool wlc_associnprog(struct wlc_info *wlc);
+extern bool wlc_scan_inprog(struct wlc_info *wlc);
+extern void *wlc_cur_phy(struct wlc_info *wlc);
+extern void wlc_set_ps_ctrl(struct wlc_info *wlc);
+extern void wlc_mctrl(struct wlc_info *wlc, uint32 mask, uint32 val);
+extern void wlc_scb_ratesel_init_all(struct wlc_info *wlc);
+
+/* ioctl */
+extern int wlc_iovar_getint8(struct wlc_info *wlc, const char *name,
+			     int8 * arg);
+extern int wlc_iovar_check(wlc_pub_t * pub, const bcm_iovar_t * vi, void *arg,
+			   int len, bool set);
+
+extern int wlc_module_register(wlc_pub_t * pub, const bcm_iovar_t * iovars,
+			       const char *name, void *hdl, iovar_fn_t iovar_fn,
+			       watchdog_fn_t watchdog_fn, down_fn_t down_fn);
+extern int wlc_module_unregister(wlc_pub_t * pub, const char *name, void *hdl);
+extern void wlc_event_if(struct wlc_info *wlc, struct wlc_bsscfg *cfg,
+			 wlc_event_t * e, const struct ether_addr *addr);
+extern void wlc_suspend_mac_and_wait(struct wlc_info *wlc);
+extern void wlc_enable_mac(struct wlc_info *wlc);
+extern uint16 wlc_rate_shm_offset(struct wlc_info *wlc, uint8 rate);
+extern uint32 wlc_get_rspec_history(struct wlc_bsscfg *cfg);
+extern uint32 wlc_get_current_highest_rate(struct wlc_bsscfg *cfg);
+
+static INLINE int wlc_iovar_getuint(struct wlc_info *wlc, const char *name,
+				    uint * arg)
+{
+	return wlc_iovar_getint(wlc, name, (int *)arg);
+}
+
+static INLINE int wlc_iovar_getuint8(struct wlc_info *wlc, const char *name,
+				     uint8 * arg)
+{
+	return wlc_iovar_getint8(wlc, name, (int8 *) arg);
+}
+
+static INLINE int wlc_iovar_setuint(struct wlc_info *wlc, const char *name,
+				    uint arg)
+{
+	return wlc_iovar_setint(wlc, name, (int)arg);
+}
+
+#if defined(BCMDBG)
+extern int wlc_iocregchk(struct wlc_info *wlc, uint band);
+#endif
+#if defined(BCMDBG)
+extern int wlc_iocpichk(struct wlc_info *wlc, uint phytype);
+#endif
+
+/* helper functions */
+extern void wlc_getrand(struct wlc_info *wlc, uint8 * buf, int len);
+
+struct scb;
+extern void wlc_ps_on(struct wlc_info *wlc, struct scb *scb);
+extern void wlc_ps_off(struct wlc_info *wlc, struct scb *scb, bool discard);
+extern bool wlc_radio_monitor_stop(struct wlc_info *wlc);
+
+#if defined(BCMDBG)
+extern int wlc_format_ssid(char *buf, const uchar ssid[], uint ssid_len);
+#endif
+
+extern void wlc_pmkid_build_cand_list(struct wlc_bsscfg *cfg, bool check_SSID);
+extern void wlc_pmkid_event(struct wlc_bsscfg *cfg);
+
+#define	MAXBANDS		2	/* Maximum #of bands */
+/* bandstate array indices */
+#define BAND_2G_INDEX		0	/* wlc->bandstate[x] index */
+#define BAND_5G_INDEX		1	/* wlc->bandstate[x] index */
+
+#define BAND_2G_NAME		"2.4G"
+#define BAND_5G_NAME		"5G"
+
+#if defined(BCMSDIO) || defined(WLC_HIGH_ONLY)
+void wlc_device_removed(void *arg);
+#endif
+
+/* BMAC RPC: 7 uint32 params: pkttotlen, fifo, commit, fid, txpktpend, pktflag, rpc_id */
+#define WLC_RPCTX_PARAMS		32
+
+#endif				/* _wlc_pub_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_rate.c b/drivers/staging/brcm80211/sys/wlc_rate.c
new file mode 100644
index 0000000..a71e4a5
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_rate.c
@@ -0,0 +1,498 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <wlioctl.h>
+
+#include <proto/802.11.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wl_dbg.h>
+#include <wlc_pub.h>
+
+/* Rate info per rate: It tells whether a rate is ofdm or not and its phy_rate value */
+const uint8 rate_info[WLC_MAXRATE + 1] = {
+	/*  0     1     2     3     4     5     6     7     8     9 */
+/*   0 */ 0x00, 0x00, 0x0a, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
+/*  10 */ 0x00, 0x37, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x00,
+/*  20 */ 0x00, 0x00, 0x6e, 0x00, 0x8a, 0x00, 0x00, 0x00, 0x00, 0x00,
+/*  30 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x00, 0x00, 0x00,
+/*  40 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x00,
+/*  50 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+/*  60 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+/*  70 */ 0x00, 0x00, 0x8d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+/*  80 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+/*  90 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00,
+/* 100 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8c
+};
+
+/* rates are in units of Kbps */
+const mcs_info_t mcs_table[MCS_TABLE_SIZE] = {
+	/* MCS  0: SS 1, MOD: BPSK,  CR 1/2 */
+	{6500, 13500, CEIL(6500 * 10, 9), CEIL(13500 * 10, 9), 0x00,
+	 WLC_RATE_6M},
+	/* MCS  1: SS 1, MOD: QPSK,  CR 1/2 */
+	{13000, 27000, CEIL(13000 * 10, 9), CEIL(27000 * 10, 9), 0x08,
+	 WLC_RATE_12M},
+	/* MCS  2: SS 1, MOD: QPSK,  CR 3/4 */
+	{19500, 40500, CEIL(19500 * 10, 9), CEIL(40500 * 10, 9), 0x0A,
+	 WLC_RATE_18M},
+	/* MCS  3: SS 1, MOD: 16QAM, CR 1/2 */
+	{26000, 54000, CEIL(26000 * 10, 9), CEIL(54000 * 10, 9), 0x10,
+	 WLC_RATE_24M},
+	/* MCS  4: SS 1, MOD: 16QAM, CR 3/4 */
+	{39000, 81000, CEIL(39000 * 10, 9), CEIL(81000 * 10, 9), 0x12,
+	 WLC_RATE_36M},
+	/* MCS  5: SS 1, MOD: 64QAM, CR 2/3 */
+	{52000, 108000, CEIL(52000 * 10, 9), CEIL(108000 * 10, 9), 0x19,
+	 WLC_RATE_48M},
+	/* MCS  6: SS 1, MOD: 64QAM, CR 3/4 */
+	{58500, 121500, CEIL(58500 * 10, 9), CEIL(121500 * 10, 9), 0x1A,
+	 WLC_RATE_54M},
+	/* MCS  7: SS 1, MOD: 64QAM, CR 5/6 */
+	{65000, 135000, CEIL(65000 * 10, 9), CEIL(135000 * 10, 9), 0x1C,
+	 WLC_RATE_54M},
+	/* MCS  8: SS 2, MOD: BPSK,  CR 1/2 */
+	{13000, 27000, CEIL(13000 * 10, 9), CEIL(27000 * 10, 9), 0x40,
+	 WLC_RATE_6M},
+	/* MCS  9: SS 2, MOD: QPSK,  CR 1/2 */
+	{26000, 54000, CEIL(26000 * 10, 9), CEIL(54000 * 10, 9), 0x48,
+	 WLC_RATE_12M},
+	/* MCS 10: SS 2, MOD: QPSK,  CR 3/4 */
+	{39000, 81000, CEIL(39000 * 10, 9), CEIL(81000 * 10, 9), 0x4A,
+	 WLC_RATE_18M},
+	/* MCS 11: SS 2, MOD: 16QAM, CR 1/2 */
+	{52000, 108000, CEIL(52000 * 10, 9), CEIL(108000 * 10, 9), 0x50,
+	 WLC_RATE_24M},
+	/* MCS 12: SS 2, MOD: 16QAM, CR 3/4 */
+	{78000, 162000, CEIL(78000 * 10, 9), CEIL(162000 * 10, 9), 0x52,
+	 WLC_RATE_36M},
+	/* MCS 13: SS 2, MOD: 64QAM, CR 2/3 */
+	{104000, 216000, CEIL(104000 * 10, 9), CEIL(216000 * 10, 9), 0x59,
+	 WLC_RATE_48M},
+	/* MCS 14: SS 2, MOD: 64QAM, CR 3/4 */
+	{117000, 243000, CEIL(117000 * 10, 9), CEIL(243000 * 10, 9), 0x5A,
+	 WLC_RATE_54M},
+	/* MCS 15: SS 2, MOD: 64QAM, CR 5/6 */
+	{130000, 270000, CEIL(130000 * 10, 9), CEIL(270000 * 10, 9), 0x5C,
+	 WLC_RATE_54M},
+	/* MCS 16: SS 3, MOD: BPSK,  CR 1/2 */
+	{19500, 40500, CEIL(19500 * 10, 9), CEIL(40500 * 10, 9), 0x80,
+	 WLC_RATE_6M},
+	/* MCS 17: SS 3, MOD: QPSK,  CR 1/2 */
+	{39000, 81000, CEIL(39000 * 10, 9), CEIL(81000 * 10, 9), 0x88,
+	 WLC_RATE_12M},
+	/* MCS 18: SS 3, MOD: QPSK,  CR 3/4 */
+	{58500, 121500, CEIL(58500 * 10, 9), CEIL(121500 * 10, 9), 0x8A,
+	 WLC_RATE_18M},
+	/* MCS 19: SS 3, MOD: 16QAM, CR 1/2 */
+	{78000, 162000, CEIL(78000 * 10, 9), CEIL(162000 * 10, 9), 0x90,
+	 WLC_RATE_24M},
+	/* MCS 20: SS 3, MOD: 16QAM, CR 3/4 */
+	{117000, 243000, CEIL(117000 * 10, 9), CEIL(243000 * 10, 9), 0x92,
+	 WLC_RATE_36M},
+	/* MCS 21: SS 3, MOD: 64QAM, CR 2/3 */
+	{156000, 324000, CEIL(156000 * 10, 9), CEIL(324000 * 10, 9), 0x99,
+	 WLC_RATE_48M},
+	/* MCS 22: SS 3, MOD: 64QAM, CR 3/4 */
+	{175500, 364500, CEIL(175500 * 10, 9), CEIL(364500 * 10, 9), 0x9A,
+	 WLC_RATE_54M},
+	/* MCS 23: SS 3, MOD: 64QAM, CR 5/6 */
+	{195000, 405000, CEIL(195000 * 10, 9), CEIL(405000 * 10, 9), 0x9B,
+	 WLC_RATE_54M},
+	/* MCS 24: SS 4, MOD: BPSK,  CR 1/2 */
+	{26000, 54000, CEIL(26000 * 10, 9), CEIL(54000 * 10, 9), 0xC0,
+	 WLC_RATE_6M},
+	/* MCS 25: SS 4, MOD: QPSK,  CR 1/2 */
+	{52000, 108000, CEIL(52000 * 10, 9), CEIL(108000 * 10, 9), 0xC8,
+	 WLC_RATE_12M},
+	/* MCS 26: SS 4, MOD: QPSK,  CR 3/4 */
+	{78000, 162000, CEIL(78000 * 10, 9), CEIL(162000 * 10, 9), 0xCA,
+	 WLC_RATE_18M},
+	/* MCS 27: SS 4, MOD: 16QAM, CR 1/2 */
+	{104000, 216000, CEIL(104000 * 10, 9), CEIL(216000 * 10, 9), 0xD0,
+	 WLC_RATE_24M},
+	/* MCS 28: SS 4, MOD: 16QAM, CR 3/4 */
+	{156000, 324000, CEIL(156000 * 10, 9), CEIL(324000 * 10, 9), 0xD2,
+	 WLC_RATE_36M},
+	/* MCS 29: SS 4, MOD: 64QAM, CR 2/3 */
+	{208000, 432000, CEIL(208000 * 10, 9), CEIL(432000 * 10, 9), 0xD9,
+	 WLC_RATE_48M},
+	/* MCS 30: SS 4, MOD: 64QAM, CR 3/4 */
+	{234000, 486000, CEIL(234000 * 10, 9), CEIL(486000 * 10, 9), 0xDA,
+	 WLC_RATE_54M},
+	/* MCS 31: SS 4, MOD: 64QAM, CR 5/6 */
+	{260000, 540000, CEIL(260000 * 10, 9), CEIL(540000 * 10, 9), 0xDB,
+	 WLC_RATE_54M},
+	/* MCS 32: SS 1, MOD: BPSK,  CR 1/2 */
+	{0, 6000, 0, CEIL(6000 * 10, 9), 0x00, WLC_RATE_6M},
+};
+
+/* phycfg for legacy OFDM frames: code rate, modulation scheme, spatial streams
+ *   Number of spatial streams: always 1
+ *   other fields: refer to table 78 of section 17.3.2.2 of the original .11a standard
+ */
+typedef struct legacy_phycfg {
+	uint32 rate_ofdm;	/* ofdm mac rate */
+	uint8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
+} legacy_phycfg_t;
+
+#define LEGACY_PHYCFG_TABLE_SIZE	12	/* Number of legacy_rate_cfg entries in the table */
+
+/* In CCK mode LPPHY overloads OFDM Modulation bits with CCK Data Rate */
+/* Eventually MIMOPHY would also be converted to this format */
+/* 0 = 1Mbps; 1 = 2Mbps; 2 = 5.5Mbps; 3 = 11Mbps */
+static const legacy_phycfg_t legacy_phycfg_table[LEGACY_PHYCFG_TABLE_SIZE] = {
+	{WLC_RATE_1M, 0x00},	/* CCK  1Mbps,  data rate  0 */
+	{WLC_RATE_2M, 0x08},	/* CCK  2Mbps,  data rate  1 */
+	{WLC_RATE_5M5, 0x10},	/* CCK  5.5Mbps,  data rate  2 */
+	{WLC_RATE_11M, 0x18},	/* CCK  11Mbps,  data rate   3 */
+	{WLC_RATE_6M, 0x00},	/* OFDM  6Mbps,  code rate 1/2, BPSK,   1 spatial stream */
+	{WLC_RATE_9M, 0x02},	/* OFDM  9Mbps,  code rate 3/4, BPSK,   1 spatial stream */
+	{WLC_RATE_12M, 0x08},	/* OFDM  12Mbps, code rate 1/2, QPSK,   1 spatial stream */
+	{WLC_RATE_18M, 0x0A},	/* OFDM  18Mbps, code rate 3/4, QPSK,   1 spatial stream */
+	{WLC_RATE_24M, 0x10},	/* OFDM  24Mbps, code rate 1/2, 16-QAM, 1 spatial stream */
+	{WLC_RATE_36M, 0x12},	/* OFDM  36Mbps, code rate 3/4, 16-QAM, 1 spatial stream */
+	{WLC_RATE_48M, 0x19},	/* OFDM  48Mbps, code rate 2/3, 64-QAM, 1 spatial stream */
+	{WLC_RATE_54M, 0x1A},	/* OFDM  54Mbps, code rate 3/4, 64-QAM, 1 spatial stream */
+};
+
+/* Hardware rates (also encodes default basic rates) */
+
+const wlc_rateset_t cck_ofdm_mimo_rates = {
+	12,
+	{			/*    1b,   2b,   5.5b, 6,    9,    11b,  12,   18,   24,   36,   48,   54 Mbps */
+	 0x82, 0x84, 0x8b, 0x0c, 0x12, 0x96, 0x18, 0x24, 0x30, 0x48, 0x60,
+	 0x6c},
+	0x00,
+	{0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+const wlc_rateset_t ofdm_mimo_rates = {
+	8,
+	{			/*    6b,   9,    12b,  18,   24b,  36,   48,   54 Mbps */
+	 0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c},
+	0x00,
+	{0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+/* Default ratesets that include MCS32 for 40BW channels */
+const wlc_rateset_t cck_ofdm_40bw_mimo_rates = {
+	12,
+	{			/*    1b,   2b,   5.5b, 6,    9,    11b,  12,   18,   24,   36,   48,   54 Mbps */
+	 0x82, 0x84, 0x8b, 0x0c, 0x12, 0x96, 0x18, 0x24, 0x30, 0x48, 0x60,
+	 0x6c},
+	0x00,
+	{0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+const wlc_rateset_t ofdm_40bw_mimo_rates = {
+	8,
+	{			/*    6b,   9,    12b,  18,   24b,  36,   48,   54 Mbps */
+	 0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c},
+	0x00,
+	{0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+const wlc_rateset_t cck_ofdm_rates = {
+	12,
+	{			/*    1b,   2b,   5.5b, 6,    9,    11b,  12,   18,   24,   36,   48,   54 Mbps */
+	 0x82, 0x84, 0x8b, 0x0c, 0x12, 0x96, 0x18, 0x24, 0x30, 0x48, 0x60,
+	 0x6c},
+	0x00,
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+const wlc_rateset_t gphy_legacy_rates = {
+	4,
+	{			/*    1b,   2b,   5.5b,  11b Mbps */
+	 0x82, 0x84, 0x8b, 0x96},
+	0x00,
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+const wlc_rateset_t ofdm_rates = {
+	8,
+	{			/*    6b,   9,    12b,  18,   24b,  36,   48,   54 Mbps */
+	 0x8c, 0x12, 0x98, 0x24, 0xb0, 0x48, 0x60, 0x6c},
+	0x00,
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+const wlc_rateset_t cck_rates = {
+	4,
+	{			/*    1b,   2b,   5.5,  11 Mbps */
+	 0x82, 0x84, 0x0b, 0x16},
+	0x00,
+	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	 0x00, 0x00, 0x00, 0x00}
+};
+
+static bool wlc_rateset_valid(wlc_rateset_t * rs, bool check_brate);
+
+/* check if rateset is valid.
+ * if check_brate is true, rateset without a basic rate is considered NOT valid.
+ */
+static bool wlc_rateset_valid(wlc_rateset_t * rs, bool check_brate)
+{
+	uint idx;
+
+	if (!rs->count)
+		return FALSE;
+
+	if (!check_brate)
+		return TRUE;
+
+	/* error if no basic rates */
+	for (idx = 0; idx < rs->count; idx++) {
+		if (rs->rates[idx] & WLC_RATE_FLAG)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+void wlc_rateset_mcs_upd(wlc_rateset_t * rs, uint8 txstreams)
+{
+	int i;
+	for (i = txstreams; i < MAX_STREAMS_SUPPORTED; i++)
+		rs->mcs[i] = 0;
+}
+
+/* filter based on hardware rateset, and sort filtered rateset with basic bit(s) preserved,
+ * and check if resulting rateset is valid.
+*/
+bool
+wlc_rate_hwrs_filter_sort_validate(wlc_rateset_t * rs,
+				   const wlc_rateset_t * hw_rs,
+				   bool check_brate, uint8 txstreams)
+{
+	uint8 rateset[WLC_MAXRATE + 1];
+	uint8 r;
+	uint count;
+	uint i;
+
+	bzero(rateset, sizeof(rateset));
+	count = rs->count;
+
+	for (i = 0; i < count; i++) {
+		/* mask off "basic rate" bit, WLC_RATE_FLAG */
+		r = (int)rs->rates[i] & RATE_MASK;
+		if ((r > WLC_MAXRATE) || (rate_info[r] == 0)) {
+			continue;
+		}
+		rateset[r] = rs->rates[i];	/* preserve basic bit! */
+	}
+
+	/* fill out the rates in order, looking at only supported rates */
+	count = 0;
+	for (i = 0; i < hw_rs->count; i++) {
+		r = hw_rs->rates[i] & RATE_MASK;
+		ASSERT(r <= WLC_MAXRATE);
+		if (rateset[r])
+			rs->rates[count++] = rateset[r];
+	}
+
+	rs->count = count;
+
+	/* only set the mcs rate bit if the equivalent hw mcs bit is set */
+	for (i = 0; i < MCSSET_LEN; i++)
+		rs->mcs[i] = (rs->mcs[i] & hw_rs->mcs[i]);
+
+	if (wlc_rateset_valid(rs, check_brate))
+		return TRUE;
+	else
+		return FALSE;
+}
+
+/* caluclate the rate of a rx'd frame and return it as a ratespec */
+ratespec_t BCMFASTPATH wlc_compute_rspec(d11rxhdr_t * rxh, uint8 * plcp)
+{
+	int phy_type;
+	ratespec_t rspec = PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT;
+
+	phy_type =
+	    ((rxh->RxChan & RXS_CHAN_PHYTYPE_MASK) >> RXS_CHAN_PHYTYPE_SHIFT);
+
+	if ((phy_type == PHY_TYPE_N) || (phy_type == PHY_TYPE_SSN) ||
+	    (phy_type == PHY_TYPE_LCN) || (phy_type == PHY_TYPE_HT)) {
+		switch (rxh->PhyRxStatus_0 & PRXS0_FT_MASK) {
+		case PRXS0_CCK:
+			rspec =
+			    CCK_PHY2MAC_RATE(((cck_phy_hdr_t *) plcp)->signal);
+			break;
+		case PRXS0_OFDM:
+			rspec =
+			    OFDM_PHY2MAC_RATE(((ofdm_phy_hdr_t *) plcp)->
+					      rlpt[0]);
+			break;
+		case PRXS0_PREN:
+			rspec = (plcp[0] & MIMO_PLCP_MCS_MASK) | RSPEC_MIMORATE;
+			if (plcp[0] & MIMO_PLCP_40MHZ) {
+				/* indicate rspec is for 40 MHz mode */
+				rspec &= ~RSPEC_BW_MASK;
+				rspec |= (PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT);
+			}
+			break;
+		case PRXS0_STDN:
+			/* fallthru */
+		default:
+			/* not supported */
+			ASSERT(0);
+			break;
+		}
+		if (PLCP3_ISSGI(plcp[3]))
+			rspec |= RSPEC_SHORT_GI;
+	} else
+	    if ((phy_type == PHY_TYPE_A) || (rxh->PhyRxStatus_0 & PRXS0_OFDM))
+		rspec = OFDM_PHY2MAC_RATE(((ofdm_phy_hdr_t *) plcp)->rlpt[0]);
+	else
+		rspec = CCK_PHY2MAC_RATE(((cck_phy_hdr_t *) plcp)->signal);
+
+	return rspec;
+}
+
+/* copy rateset src to dst as-is (no masking or sorting) */
+void wlc_rateset_copy(const wlc_rateset_t * src, wlc_rateset_t * dst)
+{
+	bcopy(src, dst, sizeof(wlc_rateset_t));
+}
+
+/*
+ * Copy and selectively filter one rateset to another.
+ * 'basic_only' means only copy basic rates.
+ * 'rates' indicates cck (11b) and ofdm rates combinations.
+ *    - 0: cck and ofdm
+ *    - 1: cck only
+ *    - 2: ofdm only
+ * 'xmask' is the copy mask (typically 0x7f or 0xff).
+ */
+void
+wlc_rateset_filter(wlc_rateset_t * src, wlc_rateset_t * dst, bool basic_only,
+		   uint8 rates, uint xmask, bool mcsallow)
+{
+	uint i;
+	uint r;
+	uint count;
+
+	count = 0;
+	for (i = 0; i < src->count; i++) {
+		r = src->rates[i];
+		if (basic_only && !(r & WLC_RATE_FLAG))
+			continue;
+		if ((rates == WLC_RATES_CCK) && IS_OFDM((r & RATE_MASK)))
+			continue;
+		if ((rates == WLC_RATES_OFDM) && IS_CCK((r & RATE_MASK)))
+			continue;
+		dst->rates[count++] = r & xmask;
+	}
+	dst->count = count;
+	dst->htphy_membership = src->htphy_membership;
+
+	if (mcsallow && rates != WLC_RATES_CCK)
+		bcopy(&src->mcs[0], &dst->mcs[0], MCSSET_LEN);
+	else
+		wlc_rateset_mcs_clear(dst);
+}
+
+/* select rateset for a given phy_type and bandtype and filter it, sort it
+ * and fill rs_tgt with result
+ */
+void
+wlc_rateset_default(wlc_rateset_t * rs_tgt, const wlc_rateset_t * rs_hw,
+		    uint phy_type, int bandtype, bool cck_only, uint rate_mask,
+		    bool mcsallow, uint8 bw, uint8 txstreams)
+{
+	const wlc_rateset_t *rs_dflt;
+	wlc_rateset_t rs_sel;
+	if ((PHYTYPE_IS(phy_type, PHY_TYPE_HT)) ||
+	    (PHYTYPE_IS(phy_type, PHY_TYPE_N)) ||
+	    (PHYTYPE_IS(phy_type, PHY_TYPE_LCN)) ||
+	    (PHYTYPE_IS(phy_type, PHY_TYPE_SSN))) {
+		if (BAND_5G(bandtype)) {
+			rs_dflt = (bw == WLC_20_MHZ ?
+				   &ofdm_mimo_rates : &ofdm_40bw_mimo_rates);
+		} else {
+			rs_dflt = (bw == WLC_20_MHZ ?
+				   &cck_ofdm_mimo_rates :
+				   &cck_ofdm_40bw_mimo_rates);
+		}
+	} else if (PHYTYPE_IS(phy_type, PHY_TYPE_LP)) {
+		rs_dflt = (BAND_5G(bandtype)) ? &ofdm_rates : &cck_ofdm_rates;
+	} else if (PHYTYPE_IS(phy_type, PHY_TYPE_A)) {
+		rs_dflt = &ofdm_rates;
+	} else if (PHYTYPE_IS(phy_type, PHY_TYPE_G)) {
+		rs_dflt = &cck_ofdm_rates;
+	} else {
+		ASSERT(0);	/* should not happen */
+		rs_dflt = &cck_rates;	/* force cck */
+	}
+
+	/* if hw rateset is not supplied, assign selected rateset to it */
+	if (!rs_hw)
+		rs_hw = rs_dflt;
+
+	wlc_rateset_copy(rs_dflt, &rs_sel);
+	wlc_rateset_mcs_upd(&rs_sel, txstreams);
+	wlc_rateset_filter(&rs_sel, rs_tgt, FALSE,
+			   cck_only ? WLC_RATES_CCK : WLC_RATES_CCK_OFDM,
+			   rate_mask, mcsallow);
+	wlc_rate_hwrs_filter_sort_validate(rs_tgt, rs_hw, FALSE,
+					   mcsallow ? txstreams : 1);
+}
+
+int16 BCMFASTPATH wlc_rate_legacy_phyctl(uint rate)
+{
+	uint i;
+	for (i = 0; i < LEGACY_PHYCFG_TABLE_SIZE; i++)
+		if (rate == legacy_phycfg_table[i].rate_ofdm)
+			return legacy_phycfg_table[i].tx_phy_ctl3;
+
+	return -1;
+}
+
+void wlc_rateset_mcs_clear(wlc_rateset_t * rateset)
+{
+	uint i;
+	for (i = 0; i < MCSSET_LEN; i++)
+		rateset->mcs[i] = 0;
+}
+
+void wlc_rateset_mcs_build(wlc_rateset_t * rateset, uint8 txstreams)
+{
+	bcopy(&cck_ofdm_mimo_rates.mcs[0], &rateset->mcs[0], MCSSET_LEN);
+	wlc_rateset_mcs_upd(rateset, txstreams);
+}
+
+/* Based on bandwidth passed, allow/disallow MCS 32 in the rateset */
+void wlc_rateset_bw_mcs_filter(wlc_rateset_t * rateset, uint8 bw)
+{
+	if (bw == WLC_40_MHZ)
+		setbit(rateset->mcs, 32);
+	else
+		clrbit(rateset->mcs, 32);
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_rate.h b/drivers/staging/brcm80211/sys/wlc_rate.h
new file mode 100644
index 0000000..20db2a7
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_rate.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLC_RATE_H_
+#define _WLC_RATE_H_
+
+extern const uint8 rate_info[];
+extern const struct wlc_rateset cck_ofdm_mimo_rates;
+extern const struct wlc_rateset ofdm_mimo_rates;
+extern const struct wlc_rateset cck_ofdm_rates;
+extern const struct wlc_rateset ofdm_rates;
+extern const struct wlc_rateset cck_rates;
+extern const struct wlc_rateset gphy_legacy_rates;
+extern const struct wlc_rateset wlc_lrs_rates;
+extern const struct wlc_rateset rate_limit_1_2;
+
+typedef struct mcs_info {
+	uint32 phy_rate_20;	/* phy rate in kbps [20Mhz] */
+	uint32 phy_rate_40;	/* phy rate in kbps [40Mhz] */
+	uint32 phy_rate_20_sgi;	/* phy rate in kbps [20Mhz] with SGI */
+	uint32 phy_rate_40_sgi;	/* phy rate in kbps [40Mhz] with SGI */
+	uint8 tx_phy_ctl3;	/* phy ctl byte 3, code rate, modulation type, # of streams */
+	uint8 leg_ofdm;		/* matching legacy ofdm rate in 500bkps */
+} mcs_info_t;
+
+#define WLC_MAXMCS	32	/* max valid mcs index */
+#define MCS_TABLE_SIZE	33	/* Number of mcs entries in the table */
+extern const mcs_info_t mcs_table[];
+
+#define MCS_INVALID	0xFF
+#define MCS_CR_MASK	0x07	/* Code Rate bit mask */
+#define MCS_MOD_MASK	0x38	/* Modulation bit shift */
+#define MCS_MOD_SHIFT	3	/* MOdulation bit shift */
+#define MCS_TXS_MASK	0xc0	/* num tx streams - 1 bit mask */
+#define MCS_TXS_SHIFT	6	/* num tx streams - 1 bit shift */
+#define MCS_CR(_mcs)	(mcs_table[_mcs].tx_phy_ctl3 & MCS_CR_MASK)
+#define MCS_MOD(_mcs)	((mcs_table[_mcs].tx_phy_ctl3 & MCS_MOD_MASK) >> MCS_MOD_SHIFT)
+#define MCS_TXS(_mcs)	((mcs_table[_mcs].tx_phy_ctl3 & MCS_TXS_MASK) >> MCS_TXS_SHIFT)
+#define MCS_RATE(_mcs, _is40, _sgi)	(_sgi ? \
+	(_is40 ? mcs_table[_mcs].phy_rate_40_sgi : mcs_table[_mcs].phy_rate_20_sgi) : \
+	(_is40 ? mcs_table[_mcs].phy_rate_40 : mcs_table[_mcs].phy_rate_20))
+#define VALID_MCS(_mcs)	((_mcs < MCS_TABLE_SIZE))
+
+#define	WLC_RATE_FLAG	0x80	/* Rate flag: basic or ofdm */
+
+/* Macros to use the rate_info table */
+#define	RATE_MASK	0x7f	/* Rate value mask w/o basic rate flag */
+#define	RATE_MASK_FULL	0xff	/* Rate value mask with basic rate flag */
+
+#define WLC_RATE_500K_TO_BPS(rate)	((rate) * 500000)	/* convert 500kbps to bps */
+
+/* rate spec : holds rate and mode specific information required to generate a tx frame. */
+/* Legacy CCK and OFDM information is held in the same manner as was done in the past    */
+/* (in the lower byte) the upper 3 bytes primarily hold MIMO specific information        */
+typedef uint32 ratespec_t;
+
+/* rate spec bit fields */
+#define RSPEC_RATE_MASK		0x0000007F	/* Either 500Kbps units or MIMO MCS idx */
+#define RSPEC_MIMORATE		0x08000000	/* mimo MCS is stored in RSPEC_RATE_MASK */
+#define RSPEC_BW_MASK		0x00000700	/* mimo bw mask */
+#define RSPEC_BW_SHIFT		8	/* mimo bw shift */
+#define RSPEC_STF_MASK		0x00003800	/* mimo Space/Time/Frequency mode mask */
+#define RSPEC_STF_SHIFT		11	/* mimo Space/Time/Frequency mode shift */
+#define RSPEC_CT_MASK		0x0000C000	/* mimo coding type mask */
+#define RSPEC_CT_SHIFT		14	/* mimo coding type shift */
+#define RSPEC_STC_MASK		0x00300000	/* mimo num STC streams per PLCP defn. */
+#define RSPEC_STC_SHIFT		20	/* mimo num STC streams per PLCP defn. */
+#define RSPEC_LDPC_CODING	0x00400000	/* mimo bit indicates adv coding in use */
+#define RSPEC_SHORT_GI		0x00800000	/* mimo bit indicates short GI in use */
+#define RSPEC_OVERRIDE		0x80000000	/* bit indicates override both rate & mode */
+#define RSPEC_OVERRIDE_MCS_ONLY 0x40000000	/* bit indicates override rate only */
+
+#define WLC_HTPHY		127	/* HT PHY Membership */
+
+#define RSPEC_ACTIVE(rspec)	(rspec & (RSPEC_RATE_MASK | RSPEC_MIMORATE))
+#define RSPEC2RATE(rspec)      	((rspec & RSPEC_MIMORATE) ? \
+	MCS_RATE((rspec & RSPEC_RATE_MASK), RSPEC_IS40MHZ(rspec), RSPEC_ISSGI(rspec)) : \
+	(rspec & RSPEC_RATE_MASK))
+/* return rate in unit of 500Kbps -- for internal use in wlc_rate_sel.c */
+#define RSPEC2RATE500K(rspec)	((rspec & RSPEC_MIMORATE) ? \
+		MCS_RATE((rspec & RSPEC_RATE_MASK), state->is40bw, RSPEC_ISSGI(rspec))/500 : \
+		(rspec & RSPEC_RATE_MASK))
+#define CRSPEC2RATE500K(rspec)	((rspec & RSPEC_MIMORATE) ? \
+		MCS_RATE((rspec & RSPEC_RATE_MASK), RSPEC_IS40MHZ(rspec), RSPEC_ISSGI(rspec))/500 :\
+		(rspec & RSPEC_RATE_MASK))
+
+#define RSPEC2KBPS(rspec)	(IS_MCS(rspec) ? RSPEC2RATE(rspec) : RSPEC2RATE(rspec)*500)
+#define RSPEC_PHYTXBYTE2(rspec)	((rspec & 0xff00) >> 8)
+#define RSPEC_GET_BW(rspec)	((rspec & RSPEC_BW_MASK) >> RSPEC_BW_SHIFT)
+#define RSPEC_IS40MHZ(rspec)	((((rspec & RSPEC_BW_MASK) >> RSPEC_BW_SHIFT) == \
+				PHY_TXC1_BW_40MHZ) || (((rspec & RSPEC_BW_MASK) >> \
+				RSPEC_BW_SHIFT) == PHY_TXC1_BW_40MHZ_DUP))
+#define RSPEC_ISSGI(rspec)	((rspec & RSPEC_SHORT_GI) == RSPEC_SHORT_GI)
+#define RSPEC_MIMOPLCP3(rspec)	((rspec & 0xf00000) >> 16)
+#define PLCP3_ISSGI(plcp)	(plcp & (RSPEC_SHORT_GI >> 16))
+#define RSPEC_STC(rspec)	((rspec & RSPEC_STC_MASK) >> RSPEC_STC_SHIFT)
+#define RSPEC_STF(rspec)	((rspec & RSPEC_STF_MASK) >> RSPEC_STF_SHIFT)
+#define PLCP3_ISSTBC(plcp)	((plcp & (RSPEC_STC_MASK) >> 16) == 0x10)
+#define PLCP3_STC_MASK          0x30
+#define PLCP3_STC_SHIFT         4
+
+/* Rate info table; takes a legacy rate or ratespec_t */
+#define	IS_MCS(r)     	(r & RSPEC_MIMORATE)
+#define	IS_OFDM(r)     	(!IS_MCS(r) && (rate_info[(r) & RSPEC_RATE_MASK] & WLC_RATE_FLAG))
+#define	IS_CCK(r)	(!IS_MCS(r) && (((r) & RATE_MASK) == WLC_RATE_1M || \
+			 ((r) & RATE_MASK) == WLC_RATE_2M || \
+			 ((r) & RATE_MASK) == WLC_RATE_5M5 || ((r) & RATE_MASK) == WLC_RATE_11M))
+#define IS_SINGLE_STREAM(mcs)	(((mcs) <= HIGHEST_SINGLE_STREAM_MCS) || ((mcs) == 32))
+#define CCK_RSPEC(cck)		((cck) & RSPEC_RATE_MASK)
+#define OFDM_RSPEC(ofdm)	(((ofdm) & RSPEC_RATE_MASK) |\
+	(PHY_TXC1_MODE_CDD << RSPEC_STF_SHIFT))
+#define LEGACY_RSPEC(rate)	(IS_CCK(rate) ? CCK_RSPEC(rate) : OFDM_RSPEC(rate))
+
+#define MCS_RSPEC(mcs)		(((mcs) & RSPEC_RATE_MASK) | RSPEC_MIMORATE | \
+	(IS_SINGLE_STREAM(mcs) ? (PHY_TXC1_MODE_CDD << RSPEC_STF_SHIFT) : \
+	(PHY_TXC1_MODE_SDM << RSPEC_STF_SHIFT)))
+
+/* Convert encoded rate value in plcp header to numerical rates in 500 KHz increments */
+extern const uint8 ofdm_rate_lookup[];
+#define OFDM_PHY2MAC_RATE(rlpt)		(ofdm_rate_lookup[rlpt & 0x7])
+#define CCK_PHY2MAC_RATE(signal)	(signal/5)
+
+/* Rates specified in wlc_rateset_filter() */
+#define WLC_RATES_CCK_OFDM	0
+#define WLC_RATES_CCK		1
+#define WLC_RATES_OFDM		2
+
+/* use the stuct form instead of typedef to fix dependency problems */
+struct wlc_rateset;
+
+/* sanitize, and sort a rateset with the basic bit(s) preserved, validate rateset */
+extern bool wlc_rate_hwrs_filter_sort_validate(struct wlc_rateset *rs,
+					       const struct wlc_rateset *hw_rs,
+					       bool check_brate,
+					       uint8 txstreams);
+/* copy rateset src to dst as-is (no masking or sorting) */
+extern void wlc_rateset_copy(const struct wlc_rateset *src,
+			     struct wlc_rateset *dst);
+
+/* would be nice to have these documented ... */
+extern ratespec_t wlc_compute_rspec(d11rxhdr_t * rxh, uint8 * plcp);
+
+extern void wlc_rateset_filter(struct wlc_rateset *src, struct wlc_rateset *dst,
+			       bool basic_only, uint8 rates, uint xmask,
+			       bool mcsallow);
+extern void wlc_rateset_default(struct wlc_rateset *rs_tgt,
+				const struct wlc_rateset *rs_hw, uint phy_type,
+				int bandtype, bool cck_only, uint rate_mask,
+				bool mcsallow, uint8 bw, uint8 txstreams);
+extern int16 wlc_rate_legacy_phyctl(uint rate);
+
+extern void wlc_rateset_mcs_upd(struct wlc_rateset *rs, uint8 txstreams);
+extern void wlc_rateset_mcs_clear(struct wlc_rateset *rateset);
+extern void wlc_rateset_mcs_build(struct wlc_rateset *rateset, uint8 txstreams);
+extern void wlc_rateset_bw_mcs_filter(struct wlc_rateset *rateset, uint8 bw);
+
+#endif				/* _WLC_RATE_H_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_rpc.h b/drivers/staging/brcm80211/sys/wlc_rpc.h
new file mode 100644
index 0000000..dd4547d
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_rpc.h
@@ -0,0 +1,527 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _WLC_RPC_H_
+#define _WLC_RPC_H_
+
+#include <wlc_types.h>
+
+/* RPC IDs, reordering is OK. This needs to be in sync with RPC_ID_TABLE below */
+typedef enum {
+	WLRPC_NULL_ID = 0,
+	WLRPC_WLC_REG_READ_ID,
+	WLRPC_WLC_REG_WRITE_ID,
+	WLRPC_WLC_MHF_SET_ID,
+	WLRPC_WLC_MHF_GET_ID,
+	WLRPC_WLC_BMAC_UP_PREP_ID,
+	WLRPC_WLC_BMAC_UP_FINISH_ID,
+	WLRPC_WLC_BMAC_DOWN_PREP_ID,
+	WLRPC_WLC_BMAC_DOWN_FINISH_ID,
+	WLRPC_WLC_BMAC_WRITE_HW_BCNTEMPLATES_ID,
+	WLRPC_WLC_BMAC_RESET_ID,
+	WLRPC_WLC_DNGL_REBOOT_ID,
+	WLRPC_WLC_BMAC_RPC_TXQ_WM_SET_ID,
+	WLRPC_WLC_BMAC_RPC_TXQ_WM_GET_ID,
+	WLRPC_WLC_BMAC_RPC_AGG_SET_ID,
+	WLRPC_WLC_BMAC_RPC_MSGLEVEL_SET_ID,
+	WLRPC_WLC_BMAC_RPC_AGG_LIMIT_SET_ID,
+	WLRPC_WLC_BMAC_RPC_AGG_LIMIT_GET_ID,
+	WLRPC_WLC_BMAC_INIT_ID,
+	WLRPC_WLC_BMAC_SET_CWMIN_ID,
+	WLRPC_WLC_BMAC_MUTE_ID,
+	WLRPC_WLC_PHY_DOIOVAR_ID,
+	WLRPC_WLC_PHY_HOLD_UPD_ID,
+	WLRPC_WLC_PHY_MUTE_UPD_ID,
+	WLRPC_WLC_PHY_CLEAR_TSSI_ID,
+	WLRPC_WLC_PHY_ANT_RXDIV_GET_ID,
+	WLRPC_WLC_PHY_ANT_RXDIV_SET_ID,
+	WLRPC_WLC_PHY_PREAMBLE_SET_ID,
+	WLRPC_WLC_PHY_FREQTRACK_END_ID,
+	WLRPC_WLC_PHY_FREQTRACK_START_ID,
+	WLRPC_WLC_PHY_IOCTL_ID,
+	WLRPC_WLC_PHY_NOISE_SAMPLE_REQUEST_ID,
+	WLRPC_WLC_PHY_CAL_PERICAL_ID,
+	WLRPC_WLC_PHY_TXPOWER_GET_ID,
+	WLRPC_WLC_PHY_TXPOWER_SET_ID,
+	WLRPC_WLC_PHY_TXPOWER_SROMLIMIT_ID,
+	WLRPC_WLC_PHY_RADAR_DETECT_ENABLE_ID,
+	WLRPC_WLC_PHY_RADAR_DETECT_RUN_ID,
+	WLRPC_WLC_PHY_TEST_ISON_ID,
+	WLRPC_WLC_BMAC_COPYFROM_OBJMEM_ID,
+	WLRPC_WLC_BMAC_COPYTO_OBJMEM_ID,
+	WLRPC_WLC_ENABLE_MAC_ID,
+	WLRPC_WLC_MCTRL_ID,
+	WLRPC_WLC_CORERESET_ID,
+	WLRPC_WLC_BMAC_READ_SHM_ID,
+	WLRPC_WLC_BMAC_READ_TSF_ID,
+	WLRPC_WLC_BMAC_SET_ADDRMATCH_ID,
+	WLRPC_WLC_BMAC_SET_CWMAX_ID,
+	WLRPC_WLC_BMAC_SET_RCMTA_ID,
+	WLRPC_WLC_BMAC_SET_SHM_ID,
+	WLRPC_WLC_SUSPEND_MAC_AND_WAIT_ID,
+	WLRPC_WLC_BMAC_WRITE_SHM_ID,
+	WLRPC_WLC_BMAC_WRITE_TEMPLATE_RAM_ID,
+	WLRPC_WLC_TX_FIFO_SUSPEND_ID,
+	WLRPC_WLC_TX_FIFO_RESUME_ID,
+	WLRPC_WLC_TX_FIFO_SUSPENDED_ID,
+	WLRPC_WLC_HW_ETHERADDR_ID,
+	WLRPC_WLC_SET_HW_ETHERADDR_ID,
+	WLRPC_WLC_BMAC_CHANSPEC_SET_ID,
+	WLRPC_WLC_BMAC_TXANT_SET_ID,
+	WLRPC_WLC_BMAC_ANTSEL_TYPE_SET_ID,
+	WLRPC_WLC_BMAC_TXFIFO_ID,
+	WLRPC_WLC_RADIO_READ_HWDISABLED_ID,
+	WLRPC_WLC_RM_CCA_MEASURE_ID,
+	WLRPC_WLC_SET_SHORTSLOT_ID,
+	WLRPC_WLC_WAIT_FOR_WAKE_ID,
+	WLRPC_WLC_PHY_TXPOWER_GET_CURRENT_ID,
+	WLRPC_WLC_PHY_TXPOWER_HW_CTRL_GET_ID,
+	WLRPC_WLC_PHY_TXPOWER_HW_CTRL_SET_ID,
+	WLRPC_WLC_PHY_BSSINIT_ID,
+	WLRPC_WLC_BAND_STF_SS_SET_ID,
+	WLRPC_WLC_PHY_BAND_FIRST_CHANSPEC_ID,
+	WLRPC_WLC_PHY_TXPOWER_LIMIT_SET_ID,
+	WLRPC_WLC_PHY_BAND_CHANNELS_ID,
+	WLRPC_WLC_BMAC_REVINFO_GET_ID,
+	WLRPC_WLC_BMAC_STATE_GET_ID,
+	WLRPC_WLC_BMAC_XMTFIFO_SZ_GET_ID,
+	WLRPC_WLC_BMAC_XMTFIFO_SZ_SET_ID,
+	WLRPC_WLC_BMAC_VALIDATE_CHIP_ACCESS_ID,
+	WLRPC_WLC_RM_CCA_COMPLETE_ID,
+	WLRPC_WLC_RECV_ID,
+	WLRPC_WLC_DOTXSTATUS_ID,
+	WLRPC_WLC_HIGH_DPC_ID,
+	WLRPC_WLC_FATAL_ERROR_ID,
+	WLRPC_WLC_PHY_SET_CHANNEL_14_WIDE_FILTER_ID,
+	WLRPC_WLC_PHY_NOISE_AVG_ID,
+	WLRPC_WLC_PHYCHAIN_INIT_ID,
+	WLRPC_WLC_PHYCHAIN_SET_ID,
+	WLRPC_WLC_PHYCHAIN_GET_ID,
+	WLRPC_WLC_PHY_TKIP_RIFS_WAR_ID,
+	WLRPC_WLC_BMAC_COPYFROM_VARS_ID,
+	WLRPC_WLC_BMAC_RETRYLIMIT_UPD_ID,
+	WLRPC_WLC_BMAC_BTC_MODE_SET_ID,
+	WLRPC_WLC_BMAC_BTC_MODE_GET_ID,
+	WLRPC_WLC_BMAC_BTC_WIRE_SET_ID,
+	WLRPC_WLC_BMAC_BTC_WIRE_GET_ID,
+	WLRPC_WLC_BMAC_SET_NORESET_ID,
+	WLRPC_WLC_AMPDU_TXSTATUS_COMPLETE_ID,
+	WLRPC_WLC_BMAC_FIFOERRORS_ID,
+	WLRPC_WLC_PHY_TXPOWER_GET_TARGET_MIN_ID,
+	WLRPC_WLC_PHY_TXPOWER_GET_TARGET_MAX_ID,
+	WLRPC_WLC_NOISE_CB_ID,
+	WLRPC_WLC_BMAC_LED_HW_DEINIT_ID,
+	WLRPC_WLC_BMAC_LED_HW_MASK_INIT_ID,
+	WLRPC_WLC_PLLREQ_ID,
+	WLRPC_WLC_BMAC_TACLEAR_ID,
+	WLRPC_WLC_BMAC_SET_CLK_ID,
+	WLRPC_WLC_PHY_OFDM_RATESET_WAR_ID,
+	WLRPC_WLC_PHY_BF_PREEMPT_ENABLE_ID,
+	WLRPC_WLC_BMAC_DOIOVARS_ID,
+	WLRPC_WLC_BMAC_DUMP_ID,
+	WLRPC_WLC_CISWRITE_ID,
+	WLRPC_WLC_CISDUMP_ID,
+	WLRPC_WLC_UPDATE_PHY_MODE_ID,
+	WLRPC_WLC_RESET_BMAC_DONE_ID,
+	WLRPC_WLC_BMAC_LED_BLINK_EVENT_ID,
+	WLRPC_WLC_BMAC_LED_SET_ID,
+	WLRPC_WLC_BMAC_LED_BLINK_ID,
+	WLRPC_WLC_BMAC_LED_ID,
+	WLRPC_WLC_BMAC_RATE_SHM_OFFSET_ID,
+	WLRPC_SI_ISCORE_UP_ID,
+	WLRPC_WLC_BMAC_PS_SWITCH_ID,
+	WLRPC_WLC_PHY_STF_SSMODE_GET_ID,
+	WLRPC_WLC_BMAC_DEBUG_ID,
+	WLRPC_WLC_EXTLOG_MSG_ID,
+	WLRPC_WLC_EXTLOG_CFG_ID,
+	WLRPC_BCM_ASSERT_LOG_ID,
+	WLRPC_BCM_ASSERT_TYPE_ID,
+	WLRPC_WLC_BMAC_SET_PHYCAL_CACHE_FLAG_ID,
+	WLRPC_WLC_BMAC_GET_PHYCAL_CACHE_FLAG_ID,
+	WLRPC_WLC_PHY_CAL_CACHE_INIT_ID,
+	WLRPC_WLC_PHY_CAL_CACHE_DEINIT_ID,
+	WLRPC_WLC_BMAC_HW_UP_ID,
+	WLRPC_WLC_BMAC_SET_TXPWR_PERCENT_ID,
+	WLRPC_WLC_PHYCHAIN_ACTIVE_GET_ID,
+	WLRPC_WLC_BMAC_BLINK_SYNC_ID,
+	WLRPC_WLC_BMAC_UCODE_DBGSEL_SET_ID,
+	WLRPC_WLC_BMAC_UCODE_DBGSEL_GET_ID,
+	WLRPC_WLC_PHY_RADAR_DETECT_MODE_SET_ID,
+	WLRPC_WLC_PHY_ACIM_NOISEM_RESET_NPHY_ID,
+	WLRPC_WLC_PHY_INTERFER_SET_NPHY_ID,
+	WLRPC_WLC_BMAC_IFSCTL_EDCRS_SET_ID,
+	WLRPC_WLC_PKTENGTX,
+	WLRPC_WLC_BMAC_SET_DEAF,
+	WLRPC_WLC_BMAC_CLEAR_DEAF,
+	WLRPC_WLC_BMAC_BTC_FLAGS_SET_ID,
+	WLRPC_WLC_BMAC_BTC_FLAGS_GET_ID,
+	WLRPC_WLC_BMAC_SET_RCMTA_TYPE_ID,
+	WLRPC_WLC_BMAC_BTC_FLAGS_UPD_ID,
+	WLRPC_WLC_BMAC_BTC_STUCKWAR_ID,
+	WLRPC_WLC_BMAC_CCA_STATS_READ_ID,
+	WLRPC_WLC_BMAC_ANTSEL_SET_ID,
+	WLRPC_WLC_BMAC_SET_UCODE_LOADED,
+	WLRPC_WLC_PHY_LDPC_SET_ID,
+
+	WLRPC_LAST
+} wlc_rpc_id_t;
+
+#if defined(BCMDBG) | 0
+struct name_entry {
+	int id;
+	char *name;
+};
+
+#define NAME_ENTRY(x) {x, #x}
+
+#define RPC_ID_TABLE { \
+	NAME_ENTRY(WLRPC_WLC_REG_READ_ID),	\
+	NAME_ENTRY(WLRPC_WLC_REG_WRITE_ID),	\
+	NAME_ENTRY(WLRPC_WLC_MHF_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_MHF_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_UP_PREP_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_UP_FINISH_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_DOWN_PREP_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_DOWN_FINISH_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_WRITE_HW_BCNTEMPLATES_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_RESET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_DNGL_REBOOT_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_RPC_TXQ_WM_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_RPC_TXQ_WM_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_RPC_AGG_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_RPC_MSGLEVEL_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_RPC_AGG_LIMIT_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_RPC_AGG_LIMIT_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_INIT_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_CWMIN_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_MUTE_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_DOIOVAR_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_HOLD_UPD_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_MUTE_UPD_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_CLEAR_TSSI_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_ANT_RXDIV_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_ANT_RXDIV_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_PREAMBLE_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_FREQTRACK_END_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_FREQTRACK_START_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_IOCTL_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_NOISE_SAMPLE_REQUEST_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_CAL_PERICAL_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_SROMLIMIT_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_RADAR_DETECT_ENABLE_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_RADAR_DETECT_RUN_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TEST_ISON_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_COPYFROM_OBJMEM_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_COPYTO_OBJMEM_ID),	\
+	NAME_ENTRY(WLRPC_WLC_ENABLE_MAC_ID),	\
+	NAME_ENTRY(WLRPC_WLC_MCTRL_ID),	\
+	NAME_ENTRY(WLRPC_WLC_CORERESET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_READ_SHM_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_READ_TSF_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_ADDRMATCH_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_CWMAX_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_RCMTA_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_SHM_ID),	\
+	NAME_ENTRY(WLRPC_WLC_SUSPEND_MAC_AND_WAIT_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_WRITE_SHM_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_WRITE_TEMPLATE_RAM_ID),	\
+	NAME_ENTRY(WLRPC_WLC_TX_FIFO_SUSPEND_ID),	\
+	NAME_ENTRY(WLRPC_WLC_TX_FIFO_RESUME_ID),	\
+	NAME_ENTRY(WLRPC_WLC_TX_FIFO_SUSPENDED_ID),	\
+	NAME_ENTRY(WLRPC_WLC_HW_ETHERADDR_ID),	\
+	NAME_ENTRY(WLRPC_WLC_SET_HW_ETHERADDR_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_CHANSPEC_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_TXANT_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_ANTSEL_TYPE_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_TXFIFO_ID),	\
+	NAME_ENTRY(WLRPC_WLC_RADIO_READ_HWDISABLED_ID),	\
+	NAME_ENTRY(WLRPC_WLC_RM_CCA_MEASURE_ID),	\
+	NAME_ENTRY(WLRPC_WLC_SET_SHORTSLOT_ID),	\
+	NAME_ENTRY(WLRPC_WLC_WAIT_FOR_WAKE_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_GET_CURRENT_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_HW_CTRL_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_HW_CTRL_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_BSSINIT_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BAND_STF_SS_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_BAND_FIRST_CHANSPEC_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_LIMIT_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_BAND_CHANNELS_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_REVINFO_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_STATE_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_XMTFIFO_SZ_GET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_XMTFIFO_SZ_SET_ID),	\
+	NAME_ENTRY(WLRPC_WLC_BMAC_VALIDATE_CHIP_ACCESS_ID),	\
+	NAME_ENTRY(WLRPC_WLC_RM_CCA_COMPLETE_ID),	\
+	NAME_ENTRY(WLRPC_WLC_RECV_ID),	\
+	NAME_ENTRY(WLRPC_WLC_DOTXSTATUS_ID),	\
+	NAME_ENTRY(WLRPC_WLC_HIGH_DPC_ID),	\
+	NAME_ENTRY(WLRPC_WLC_FATAL_ERROR_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_SET_CHANNEL_14_WIDE_FILTER_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_NOISE_AVG_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHYCHAIN_INIT_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHYCHAIN_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHYCHAIN_GET_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_TKIP_RIFS_WAR_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_COPYFROM_VARS_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_RETRYLIMIT_UPD_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_BTC_MODE_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_BTC_MODE_GET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_BTC_WIRE_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_BTC_WIRE_GET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_NORESET_ID), \
+	NAME_ENTRY(WLRPC_WLC_AMPDU_TXSTATUS_COMPLETE_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_FIFOERRORS_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_GET_TARGET_MIN_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_TXPOWER_GET_TARGET_MAX_ID), \
+	NAME_ENTRY(WLRPC_WLC_NOISE_CB_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_LED_HW_DEINIT_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_LED_HW_MASK_INIT_ID), \
+	NAME_ENTRY(WLRPC_WLC_PLLREQ_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_TACLEAR_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_CLK_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_OFDM_RATESET_WAR_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_BF_PREEMPT_ENABLE_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_DOIOVARS_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_DUMP_ID), \
+	NAME_ENTRY(WLRPC_WLC_CISWRITE_ID), \
+	NAME_ENTRY(WLRPC_WLC_CISDUMP_ID), \
+	NAME_ENTRY(WLRPC_WLC_UPDATE_PHY_MODE_ID), \
+	NAME_ENTRY(WLRPC_WLC_RESET_BMAC_DONE_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_LED_BLINK_EVENT_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_LED_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_LED_BLINK_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_LED_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_RATE_SHM_OFFSET_ID), \
+	NAME_ENTRY(WLRPC_SI_ISCORE_UP_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_PS_SWITCH_ID),	\
+	NAME_ENTRY(WLRPC_WLC_PHY_STF_SSMODE_GET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_DEBUG_ID), \
+	NAME_ENTRY(WLRPC_WLC_EXTLOG_MSG_ID), \
+	NAME_ENTRY(WLRPC_WLC_EXTLOG_CFG_ID), \
+	NAME_ENTRY(WLRPC_BCM_ASSERT_LOG_ID), \
+	NAME_ENTRY(WLRPC_BCM_ASSERT_TYPE_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_PHYCAL_CACHE_FLAG_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_GET_PHYCAL_CACHE_FLAG_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_CAL_CACHE_INIT_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_CAL_CACHE_DEINIT_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_HW_UP_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_TXPWR_PERCENT_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHYCHAIN_ACTIVE_GET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_BLINK_SYNC_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_UCODE_DBGSEL_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_UCODE_DBGSEL_GET_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_RADAR_DETECT_MODE_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_ACIM_NOISEM_RESET_NPHY_ID), \
+	NAME_ENTRY(WLRPC_WLC_PHY_INTERFER_SET_NPHY_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_IFSCTL_EDCRS_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_PKTENGTX), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_DEAF), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_CLEAR_DEAF), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_BTC_FLAGS_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_BTC_FLAGS_GET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_RCMTA_TYPE_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_CCA_STATS_READ_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_ANTSEL_SET_ID), \
+	NAME_ENTRY(WLRPC_WLC_BMAC_SET_UCODE_LOADED), \
+	NAME_ENTRY(WLRPC_WLC_PHY_LDPC_SET_ID),	\
+	{0, NULL} \
+	}
+
+static __inline char *_wlc_rpc_id_lookup(const struct name_entry *tbl, int _id)
+{
+	const struct name_entry *elt = tbl;
+	static char __unknown[64];
+	for (; elt->name != NULL; elt++) {
+		if (_id == elt->id)
+			break;
+	}
+	if (_id == elt->id)
+		strncpy(__unknown, elt->name, sizeof(__unknown));
+	else
+		snprintf(__unknown, sizeof(__unknown), "ID:%d", _id);
+	return __unknown;
+}
+
+#define WLC_RPC_ID_LOOKUP(tbl, _id) (_wlc_rpc_id_lookup(tbl, _id))
+
+#endif				/* BCMDBG */
+
+/* refer to txpwr_limits_t for each elements, mcs32 is the at the end for 1 byte */
+#define TXPOWER_XDR_SZ	(ROUNDUP(WLC_NUM_RATES_CCK, 4) + ROUNDUP(WLC_NUM_RATES_OFDM, 4) * 4 + \
+	ROUNDUP(WLC_NUM_RATES_MCS_1_STREAM, 4) * 6 + ROUNDUP(WLC_NUM_RATES_MCS_2_STREAM, 4) * 2 + \
+	ROUNDUP(1, 4))
+
+#define wlc_rpc_txpwr_limits(b, txpwr, op, err)	\
+	do {											\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->cck, WLC_NUM_RATES_CCK);		\
+		ASSERT(!(err));									\
+												\
+		/* 20 MHz Legacy OFDM rates with SISO transmission */				\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm, WLC_NUM_RATES_OFDM);	\
+		ASSERT(!(err));									\
+												\
+		/* 20 MHz Legacy OFDM rates with CDD transmission */				\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_cdd, WLC_NUM_RATES_OFDM);   \
+		ASSERT(!(err));									\
+												\
+		/* 40 MHz Legacy OFDM rates with SISO transmission */				\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_40_siso, WLC_NUM_RATES_OFDM); \
+		ASSERT(!(err));									\
+												\
+		/* 40 MHz Legacy OFDM rates with CDD transmission */				\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->ofdm_40_cdd, WLC_NUM_RATES_OFDM); \
+		ASSERT(!(err));									\
+												\
+		/* 20MHz MCS rates SISO/CDD/STBC/SDM */							 \
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_siso, WLC_NUM_RATES_MCS_1_STREAM); \
+		ASSERT(!(err));									\
+												\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
+		ASSERT(!(err));									\
+												\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
+		ASSERT(!(err));									\
+												\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_20_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
+		ASSERT(!(err));									\
+												\
+		/* 40MHz MCS rates SISO/CDD/STBC/SDM */							 \
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_siso, WLC_NUM_RATES_MCS_1_STREAM); \
+		ASSERT(!(err));									\
+												\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_cdd, WLC_NUM_RATES_MCS_1_STREAM); \
+		ASSERT(!(err));									\
+												\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_stbc, WLC_NUM_RATES_MCS_1_STREAM); \
+		ASSERT(!(err));									\
+												\
+		(err) = bcm_xdr_##op##_uint8_vec((b), (txpwr)->mcs_40_mimo, WLC_NUM_RATES_MCS_2_STREAM); \
+		ASSERT(!(err));									\
+	} while (0)
+
+typedef struct wlc_rpc_ctx {
+	rpc_info_t *rpc;
+	wlc_info_t *wlc;
+	wlc_hw_info_t *wlc_hw;
+} wlc_rpc_ctx_t;
+
+static INLINE rpc_buf_t *wlc_rpc_buf_alloc(rpc_info_t * rpc, bcm_xdr_buf_t * b,
+					   uint len, wlc_rpc_id_t rpc_id)
+{
+	rpc_buf_t *rpc_buf;
+
+	rpc_buf = bcm_rpc_buf_alloc(rpc, len + sizeof(uint32));
+
+	if (!rpc_buf)
+		return NULL;
+
+	bcm_xdr_buf_init(b, bcm_rpc_buf_data(bcm_rpc_tp_get(rpc), rpc_buf),
+			 len + sizeof(uint32));
+
+	bcm_xdr_pack_uint32(b, rpc_id);
+
+	return rpc_buf;
+}
+
+#if defined(BCMDBG)
+static __inline wlc_rpc_id_t
+wlc_rpc_id_get(struct rpc_info *rpc, rpc_buf_t * buf)
+{
+	wlc_rpc_id_t rpc_id;
+	bcm_xdr_buf_t b;
+
+	bcm_xdr_buf_init(&b, bcm_rpc_buf_data(bcm_rpc_tp_get(rpc), buf),
+			 sizeof(uint32));
+
+	bcm_xdr_unpack_uint32(&b, (uint32 *) ((uintptr) & rpc_id));
+	return rpc_id;
+}
+#endif
+
+static __inline int _wlc_rpc_call(struct rpc_info *rpc, rpc_buf_t * send)
+{
+	int _err = 0;
+#if defined(BCMDBG)
+	wlc_rpc_id_t rpc_id = wlc_rpc_id_get(rpc, send);
+	/* const struct name_entry rpc_name_tbl[] = RPC_ID_TABLE; */
+	static struct name_entry rpc_name_tbl[] = RPC_ID_TABLE;
+	WL_TRACE(("%s: Called id %s\n", __func__,
+		  WLC_RPC_ID_LOOKUP(rpc_name_tbl, rpc_id)));
+#endif
+	_err = bcm_rpc_call(rpc, send);
+	if (_err) {
+#if defined(BCMDBG)
+		WL_ERROR(("%s: Call id %s FAILED\n", __func__,
+			  WLC_RPC_ID_LOOKUP(rpc_name_tbl, rpc_id)));
+#endif
+		_err = 0;
+	}
+	return _err;
+}
+
+#define wlc_rpc_call(rpc, send) (_wlc_rpc_call(rpc, send))
+
+#include <sbhnddma.h>
+#include <sbhndpio.h>
+#include <d11.h>
+
+#ifdef WLC_LOW
+extern void wlc_rpc_bmac_dispatch(wlc_rpc_ctx_t * rpc_ctx, struct rpc_buf *buf);
+extern void wlc_rpc_bmac_dump_txfifohist(wlc_hw_info_t * wlc_hw,
+					 bool dump_clear);
+#else
+extern void wlc_rpc_high_dispatch(wlc_rpc_ctx_t * ctx, struct rpc_buf *buf);
+#endif
+
+/* Packed structure for ease of transport across RPC bus along uint32 boundary */
+typedef struct wlc_rpc_txstatus {
+	uint32 PAD_framelen;
+	uint32 status_frameid;
+	uint32 sequence_lasttxtime;
+	uint32 ackphyrxsh_phyerr;
+} wlc_rpc_txstatus_t;
+
+static INLINE
+    void txstatus2rpc_txstatus(tx_status_t * txstatus,
+			       wlc_rpc_txstatus_t * rpc_txstatus)
+{
+	rpc_txstatus->PAD_framelen = txstatus->framelen;
+	rpc_txstatus->status_frameid =
+	    (txstatus->status << 16) | txstatus->frameid;
+	rpc_txstatus->sequence_lasttxtime =
+	    (txstatus->sequence << 16) | txstatus->lasttxtime;
+	rpc_txstatus->ackphyrxsh_phyerr =
+	    (txstatus->ackphyrxsh << 16) | txstatus->phyerr;
+}
+
+static INLINE
+    void rpc_txstatus2txstatus(wlc_rpc_txstatus_t * rpc_txstatus,
+			       tx_status_t * txstatus)
+{
+	txstatus->framelen = rpc_txstatus->PAD_framelen & 0xffff;
+	txstatus->status = (rpc_txstatus->status_frameid >> 16) & 0xffff;
+	txstatus->frameid = rpc_txstatus->status_frameid & 0xffff;
+	txstatus->sequence = (rpc_txstatus->sequence_lasttxtime >> 16) & 0xffff;
+	txstatus->lasttxtime = rpc_txstatus->sequence_lasttxtime & 0xffff;
+	txstatus->ackphyrxsh = (rpc_txstatus->ackphyrxsh_phyerr >> 16) & 0xffff;
+	txstatus->phyerr = rpc_txstatus->ackphyrxsh_phyerr & 0xffff;
+}
+
+extern void wlc_bmac_dngl_reboot(rpc_info_t * rpc);
+
+#endif				/* WLC_RPC_H */
diff --git a/drivers/staging/brcm80211/sys/wlc_rpctx.h b/drivers/staging/brcm80211/sys/wlc_rpctx.h
new file mode 100644
index 0000000..5abd35c
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_rpctx.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_rpctx_h_
+#define _wlc_rpctx_h_
+
+/* forward declaration */
+struct wlc_info;
+
+/* This controls how many packets are given to the dongle. This is required as
+ * NTXD needs to be power of 2 but we may not have enough memory to absorb that
+ * large number of frames
+ */
+#ifndef NRPCTXBUFPOST
+#define NRPCTXBUFPOST NTXD
+#endif
+
+#if defined(WLC_HIGH_ONLY)
+
+struct wlc_rpc_phy {
+	struct rpc_info *rpc;
+};
+
+#define RPCTX_ENAB(pub)		(TRUE)
+extern rpctx_info_t *wlc_rpctx_attach(wlc_pub_t * pub, struct wlc_info *wlc);
+extern int wlc_rpctx_fifoinit(rpctx_info_t * rpctx, uint fifo, uint ntxd);
+extern void wlc_rpctx_detach(rpctx_info_t * rpctx);
+extern int wlc_rpctx_dump(rpctx_info_t * rpctx, struct bcmstrbuf *b);
+extern void *wlc_rpctx_getnexttxp(rpctx_info_t * rpctx, uint fifo);
+extern void wlc_rpctx_txreclaim(rpctx_info_t * rpctx);
+extern uint wlc_rpctx_txavail(rpctx_info_t * rpctx, uint fifo);
+extern int wlc_rpctx_pkteng(rpctx_info_t * rpctx, uint fifo, void *p);
+extern int wlc_rpctx_tx(rpctx_info_t * rpctx, uint fifo, void *p, bool commit,
+			uint16 frameid, uint8 txpktpend);
+extern void wlc_rpctx_txpktpendinc(rpctx_info_t * rpctx, uint fifo, uint8 val);
+extern void wlc_rpctx_txpktpenddec(rpctx_info_t * rpctx, uint fifo, uint8 val);
+extern void wlc_rpctx_txpktpendclr(rpctx_info_t * rpctx, uint fifo);
+extern int wlc_rpctx_txpktpend(rpctx_info_t * rpctx, uint fifo, bool all);
+
+#else
+#define	RPCTX_ENAB(pub)			(FALSE)
+#define	wlc_rpctx_attach(pub, wlc)	(NULL)
+#define	wlc_rpctx_fifoinit(rpctx, fifo, ntxd) (0)
+#define	wlc_rpctx_detach(rpctx)		ASSERT(0)
+#define	wlc_rpctx_txavail(rpctx, f)	(FALSE)
+#define	wlc_rpctx_dump(rpctx, b)		(0)
+#define	wlc_rpctx_getnexttxp(rpctx, f)		(NULL)
+#define	wlc_rpctx_txreclaim(rpctx)		ASSERT(0)
+#define	wlc_rpctx_pkteng(rpctx, fifo, p)	do { } while (0)
+#define	wlc_rpctx_tx(rpctx, f, p, c, fid, t)	(0)
+#define	wlc_rpctx_txpktpendinc(rpctx, f, val)	do { } while (0)
+#define	wlc_rpctx_txpktpenddec(rpctx, f, val)	do { } while (0)
+#define	wlc_rpctx_txpktpendclr(rpctx, f)	do { } while (0)
+#define	wlc_rpctx_txpktpend(rpctx, f, all)	(0)
+
+#endif				/* WLC_HIGH */
+
+#endif				/* _wlc_rpctx_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_scb.h b/drivers/staging/brcm80211/sys/wlc_scb.h
new file mode 100644
index 0000000..7c21b1c
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_scb.h
@@ -0,0 +1,211 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_scb_h_
+#define _wlc_scb_h_
+
+#include <proto/802.1d.h>
+
+extern bool wlc_aggregatable(wlc_info_t * wlc, uint8 tid);
+
+#define AMPDU_TX_BA_MAX_WSIZE	64	/* max Tx ba window size (in pdu) */
+/* structure to store per-tid state for the ampdu initiator */
+typedef struct scb_ampdu_tid_ini {
+	uint32 magic;
+	uint8 tx_in_transit;	/* number of pending mpdus in transit in driver */
+	uint8 tid;		/* initiator tid for easy lookup */
+	uint8 txretry[AMPDU_TX_BA_MAX_WSIZE];	/* tx retry count; indexed by seq modulo */
+	struct scb *scb;	/* backptr for easy lookup */
+} scb_ampdu_tid_ini_t;
+
+#define AMPDU_MAX_SCB_TID	NUMPRIO
+
+typedef struct scb_ampdu {
+	struct scb *scb;	/* back pointer for easy reference */
+	uint8 mpdu_density;	/* mpdu density */
+	uint8 max_pdu;		/* max pdus allowed in ampdu */
+	uint8 release;		/* # of mpdus released at a time */
+	uint16 min_len;		/* min mpdu len to support the density */
+	uint32 max_rxlen;	/* max ampdu rcv length; 8k, 16k, 32k, 64k */
+	struct pktq txq;	/* sdu transmit queue pending aggregation */
+
+	/* This could easily be a ini[] pointer and we keep this info in wl itself instead
+	 * of having mac80211 hold it for us.  Also could be made dynamic per tid instead of
+	 * static.
+	 */
+	scb_ampdu_tid_ini_t ini[AMPDU_MAX_SCB_TID];	/* initiator info - per tid (NUMPRIO) */
+} scb_ampdu_t;
+
+#define SCB_MAGIC 	0xbeefcafe
+#define INI_MAGIC 	0xabcd1234
+
+/* station control block - one per remote MAC address */
+struct scb {
+	uint32 magic;
+	uint32 flags;		/* various bit flags as defined below */
+	uint32 flags2;		/* various bit flags2 as defined below */
+	uint8 state;		/* current state bitfield of auth/assoc process */
+	struct ether_addr ea;	/* station address */
+	void *fragbuf[NUMPRIO];	/* defragmentation buffer per prio */
+	uint fragresid[NUMPRIO];	/* #bytes unused in frag buffer per prio */
+
+	uint16 seqctl[NUMPRIO];	/* seqctl of last received frame (for dups) */
+	uint16 seqctl_nonqos;	/* seqctl of last received frame (for dups) for
+				 * non-QoS data and management
+				 */
+	uint16 seqnum[NUMPRIO];	/* WME: driver maintained sw seqnum per priority */
+
+	scb_ampdu_t scb_ampdu;	/* AMPDU state including per tid info */
+};
+
+/* SCB flags */
+#define SCB_NONERP		0x0001	/* No ERP */
+#define SCB_LONGSLOT		0x0002	/* Long Slot */
+#define SCB_SHORTPREAMBLE	0x0004	/* Short Preamble ok */
+#define SCB_8021XHDR		0x0008	/* 802.1x Header */
+#define SCB_WPA_SUP		0x0010	/* 0 - authenticator, 1 - supplicant */
+#define SCB_DEAUTH		0x0020	/* 0 - ok to deauth, 1 - no (just did) */
+#define SCB_WMECAP		0x0040	/* WME Cap; may ONLY be set if WME_ENAB(wlc) */
+#define SCB_BRCM		0x0100	/* BRCM AP or STA */
+#define SCB_WDS_LINKUP		0x0200	/* WDS link up */
+#define SCB_RESERVED1		0x0400
+#define SCB_RESERVED2		0x0800
+#define SCB_MYAP		0x1000	/* We are associated to this AP */
+#define SCB_PENDING_PROBE	0x2000	/* Probe is pending to this SCB */
+#define SCB_AMSDUCAP		0x4000	/* A-MSDU capable */
+#define SCB_BACAP		0x8000	/* pre-n blockack capable */
+#define SCB_HTCAP		0x10000	/* HT (MIMO) capable device */
+#define SCB_RECV_PM		0x20000	/* state of PM bit in last data frame recv'd */
+#define SCB_AMPDUCAP		0x40000	/* A-MPDU capable */
+#define SCB_IS40		0x80000	/* 40MHz capable */
+#define SCB_NONGF		0x100000	/* Not Green Field capable */
+#define SCB_APSDCAP		0x200000	/* APSD capable */
+#define SCB_PENDING_FREE	0x400000	/* marked for deletion - clip recursion */
+#define SCB_PENDING_PSPOLL	0x800000	/* PS-Poll is pending to this SCB */
+#define SCB_RIFSCAP		0x1000000	/* RIFS capable */
+#define SCB_HT40INTOLERANT	0x2000000	/* 40 Intolerant */
+#define SCB_WMEPS		0x4000000	/* PS + WME w/o APSD capable */
+#define SCB_SENT_APSD_TRIG	0x8000000	/* APSD Trigger Null Frame was recently sent */
+#define SCB_COEX_MGMT		0x10000000	/* Coexistence Management supported */
+#define SCB_IBSS_PEER		0x20000000	/* Station is an IBSS peer */
+#define SCB_STBCCAP		0x40000000	/* STBC Capable */
+
+/* scb flags2 */
+#define SCB2_SGI20_CAP		0x00000001	/* 20MHz SGI Capable */
+#define SCB2_SGI40_CAP		0x00000002	/* 40MHz SGI Capable */
+#define SCB2_RX_LARGE_AGG	0x00000004	/* device can rx large aggs */
+#define SCB2_INTERNAL		0x00000008	/* This scb is an internal scb */
+#define SCB2_IN_ASSOC		0x00000010	/* Incoming assocation in progress */
+#define SCB2_RESERVED1		0x00000040
+#define SCB2_LDPCCAP		0x00000080	/* LDPC Cap */
+
+/* scb association state bitfield */
+#define UNAUTHENTICATED		0	/* unknown */
+#define AUTHENTICATED		1	/* 802.11 authenticated (open or shared key) */
+#define ASSOCIATED		2	/* 802.11 associated */
+#define PENDING_AUTH		4	/* Waiting for 802.11 authentication response */
+#define PENDING_ASSOC		8	/* Waiting for 802.11 association response */
+#define AUTHORIZED		0x10	/* 802.1X authorized */
+#define TAKEN4IBSS		0x80	/* Taken */
+
+/* scb association state helpers */
+#define SCB_ASSOCIATED(a)	((a)->state & ASSOCIATED)
+#define SCB_AUTHENTICATED(a)	((a)->state & AUTHENTICATED)
+#define SCB_AUTHORIZED(a)	((a)->state & AUTHORIZED)
+
+/* flag access */
+#define SCB_ISMYAP(a)           ((a)->flags & SCB_MYAP)
+#define SCB_ISPERMANENT(a)      ((a)->permanent)
+#define	SCB_INTERNAL(a) 	((a)->flags2 & SCB2_INTERNAL)
+/* scb association state helpers w/ respect to ssid (in case of multi ssids)
+ * The bit set in the bit field is relative to the current state (i.e. if
+ * the current state is "associated", a 1 at the position "i" means the
+ * sta is associated to ssid "i"
+ */
+#define SCB_ASSOCIATED_BSSCFG(a, i)	\
+	(((a)->state & ASSOCIATED) && isset(&(scb->auth_bsscfg), i))
+
+#define SCB_AUTHENTICATED_BSSCFG(a, i)	\
+	(((a)->state & AUTHENTICATED) && isset(&(scb->auth_bsscfg), i))
+
+#define SCB_AUTHORIZED_BSSCFG(a, i)	\
+	(((a)->state & AUTHORIZED) && isset(&(scb->auth_bsscfg), i))
+
+#define SCB_LONG_TIMEOUT	3600	/* # seconds of idle time after which we proactively
+					 * free an authenticated SCB
+					 */
+#define SCB_SHORT_TIMEOUT	  60	/* # seconds of idle time after which we will reclaim an
+					 * authenticated SCB if we would otherwise fail
+					 * an SCB allocation.
+					 */
+#define SCB_TIMEOUT		  60	/* # seconds: interval to probe idle STAs */
+#define SCB_ACTIVITY_TIME	   5	/* # seconds: skip probe if activity during this time */
+#define SCB_GRACE_ATTEMPTS	   3	/* # attempts to probe sta beyond scb_activity_time */
+
+/* scb_info macros */
+#define SCB_PS(a)		NULL
+#define SCB_WDS(a)		NULL
+#define SCB_INTERFACE(a)        ((a)->bsscfg->wlcif->wlif)
+#define SCB_WLCIFP(a)           (((a)->bsscfg->wlcif))
+#define WLC_BCMC_PSMODE(wlc, bsscfg) (TRUE)
+
+#define SCB_WME(a)		((a)->flags & SCB_WMECAP)	/* Also implies WME_ENAB(wlc) */
+
+#define SCB_AMPDU(a)		TRUE
+#define SCB_AMSDU(a)		FALSE
+
+#define SCB_HT_CAP(a)		((a)->flags & SCB_HTCAP)
+#define SCB_ISGF_CAP(a)		(((a)->flags & (SCB_HTCAP | SCB_NONGF)) == SCB_HTCAP)
+#define SCB_NONGF_CAP(a)	(((a)->flags & (SCB_HTCAP | SCB_NONGF)) == \
+					(SCB_HTCAP | SCB_NONGF))
+#define SCB_COEX_CAP(a)		((a)->flags & SCB_COEX_MGMT)
+#define SCB_STBC_CAP(a)		((a)->flags & SCB_STBCCAP)
+#define SCB_LDPC_CAP(a)		(SCB_HT_CAP(a) && ((a)->flags2 & SCB2_LDPCCAP))
+
+#define SCB_IS_IBSS_PEER(a)	((a)->flags & SCB_IBSS_PEER)
+#define SCB_SET_IBSS_PEER(a)	((a)->flags |= SCB_IBSS_PEER)
+#define SCB_UNSET_IBSS_PEER(a)	((a)->flags &= ~SCB_IBSS_PEER)
+
+#define SCB_11E(a)		FALSE
+
+#define SCB_QOS(a)		((a)->flags & (SCB_WMECAP | SCB_HTCAP))
+
+#define SCB_BSSCFG(a)           ((a)->bsscfg)
+
+#define SCB_SEQNUM(scb, prio)	(scb)->seqnum[(prio)]
+
+#define SCB_ISMULTI(a)	ETHER_ISMULTI((a)->ea.octet)
+#define SCB_ISVALID(a, _pkttag_dbgid)	((a) && (a)->_dbgid == (_pkttag_dbgid))
+
+/* API for accessing SCB pointer in WLPKTTAG */
+#ifdef BCMDBG
+#define WLPKTTAGSCBSET(p, scb) { WLPKTTAG(p)->_scb = scb; WLPKTTAG(p)->_scb_dbgid = scb->_dbgid; }
+#define WLPKTTAGSCBCLR(p) { WLPKTTAG(p)->_scb = NULL; WLPKTTAG(p)->_scb_dbgid = 0; }
+#else
+#define WLPKTTAGSCBSET(p, scb) (WLPKTTAG(p)->_scb = scb)
+#define WLPKTTAGSCBCLR(p) (WLPKTTAG(p)->_scb = NULL)
+#endif
+
+#define WLCNTSCBINCR(a)		/* No stats support */
+#define WLCNTSCBDECR(a)		/* No stats support */
+#define WLCNTSCBADD(a,delta)	/* No stats support */
+#define WLCNTSCBSET(a,value)	/* No stats support */
+#define WLCNTSCBVAL(a)		0	/* No stats support */
+#define WLCNTSCB_COND_SET(c, a, v)	/* No stats support */
+#define WLCNTSCB_COND_ADD(c, a, d)	/* No stats support */
+#define WLCNTSCB_COND_INCR(c, a)	/* No stats support */
+
+#endif				/* _wlc_scb_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_stf.c b/drivers/staging/brcm80211/sys/wlc_stf.c
new file mode 100644
index 0000000..ea3a07c
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_stf.c
@@ -0,0 +1,590 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <wlc_cfg.h>
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <proto/802.11.h>
+#include <wlioctl.h>
+#include <bcmwpa.h>
+#include <bcmwifi.h>
+#include <d11.h>
+#include <wlc_rate.h>
+#include <wlc_pub.h>
+#include <wlc_key.h>
+#include <wlc_channel.h>
+#include <wlc_bsscfg.h>
+#include <wlc_mac80211.h>
+#include <wlc_scb.h>
+#include <wl_export.h>
+#include <wlc_bmac.h>
+#include <wlc_stf.h>
+
+#define WLC_STF_SS_STBC_RX(wlc) (WLCISNPHY(wlc->band) && \
+	NREV_GT(wlc->band->phyrev, 3) && NREV_LE(wlc->band->phyrev, 6))
+
+static int8 wlc_stf_stbc_rx_get(wlc_info_t * wlc);
+static bool wlc_stf_stbc_tx_set(wlc_info_t * wlc, int32 int_val);
+static int wlc_stf_txcore_set(wlc_info_t * wlc, uint8 Nsts, uint8 val);
+static int wlc_stf_spatial_policy_set(wlc_info_t * wlc, int val);
+static void wlc_stf_stbc_rx_ht_update(wlc_info_t * wlc, int val);
+
+static void _wlc_stf_phy_txant_upd(wlc_info_t * wlc);
+static uint16 _wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec);
+
+#define NSTS_1	1
+#define NSTS_2	2
+#define NSTS_3	3
+#define NSTS_4	4
+const uint8 txcore_default[5] = {
+	(0),			/* bitmap of the core enabled */
+	(0x01),			/* For Nsts = 1, enable core 1 */
+	(0x03),			/* For Nsts = 2, enable core 1 & 2 */
+	(0x07),			/* For Nsts = 3, enable core 1, 2 & 3 */
+	(0x0f)			/* For Nsts = 4, enable all cores */
+};
+
+static void wlc_stf_stbc_rx_ht_update(wlc_info_t * wlc, int val)
+{
+	ASSERT((val == HT_CAP_RX_STBC_NO)
+	       || (val == HT_CAP_RX_STBC_ONE_STREAM));
+
+	/* MIMOPHYs rev3-6 cannot receive STBC with only one rx core active */
+	if (WLC_STF_SS_STBC_RX(wlc)) {
+		if ((wlc->stf->rxstreams == 1) && (val != HT_CAP_RX_STBC_NO))
+			return;
+	}
+
+	wlc->ht_cap.cap &= ~HT_CAP_RX_STBC_MASK;
+	wlc->ht_cap.cap |= (val << HT_CAP_RX_STBC_SHIFT);
+
+	if (wlc->pub->up) {
+		wlc_update_beacon(wlc);
+		wlc_update_probe_resp(wlc, TRUE);
+	}
+}
+
+/* every WLC_TEMPSENSE_PERIOD seconds temperature check to decide whether to turn on/off txchain */
+void wlc_tempsense_upd(wlc_info_t * wlc)
+{
+	wlc_phy_t *pi = wlc->band->pi;
+	uint active_chains, txchain;
+
+	/* Check if the chip is too hot. Disable one Tx chain, if it is */
+	/* high 4 bits are for Rx chain, low 4 bits are  for Tx chain */
+	active_chains = wlc_phy_stf_chain_active_get(pi);
+	txchain = active_chains & 0xf;
+
+	if (wlc->stf->txchain == wlc->stf->hw_txchain) {
+		if (txchain && (txchain < wlc->stf->hw_txchain)) {
+			/* turn off 1 tx chain */
+			wlc_stf_txchain_set(wlc, txchain, TRUE);
+		}
+	} else if (wlc->stf->txchain < wlc->stf->hw_txchain) {
+		if (txchain == wlc->stf->hw_txchain) {
+			/* turn back on txchain */
+			wlc_stf_txchain_set(wlc, txchain, TRUE);
+		}
+	}
+}
+
+void
+wlc_stf_ss_algo_channel_get(wlc_info_t * wlc, uint16 * ss_algo_channel,
+			    chanspec_t chanspec)
+{
+	tx_power_t power;
+	uint8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
+
+	/* Clear previous settings */
+	*ss_algo_channel = 0;
+
+	if (!wlc->pub->up) {
+		*ss_algo_channel = (uint16) - 1;
+		return;
+	}
+
+	wlc_phy_txpower_get_current(wlc->band->pi, &power,
+				    CHSPEC_CHANNEL(chanspec));
+
+	siso_mcs_id = (CHSPEC_IS40(chanspec)) ?
+	    WL_TX_POWER_MCS40_SISO_FIRST : WL_TX_POWER_MCS20_SISO_FIRST;
+	cdd_mcs_id = (CHSPEC_IS40(chanspec)) ?
+	    WL_TX_POWER_MCS40_CDD_FIRST : WL_TX_POWER_MCS20_CDD_FIRST;
+	stbc_mcs_id = (CHSPEC_IS40(chanspec)) ?
+	    WL_TX_POWER_MCS40_STBC_FIRST : WL_TX_POWER_MCS20_STBC_FIRST;
+
+	/* criteria to choose stf mode */
+
+	/* the "+3dbm (12 0.25db units)" is to account for the fact that with CDD, tx occurs
+	 * on both chains
+	 */
+	if (power.target[siso_mcs_id] > (power.target[cdd_mcs_id] + 12))
+		setbit(ss_algo_channel, PHY_TXC1_MODE_SISO);
+	else
+		setbit(ss_algo_channel, PHY_TXC1_MODE_CDD);
+
+	/* STBC is ORed into to algo channel as STBC requires per-packet SCB capability check
+	 * so cannot be default mode of operation. One of SISO, CDD have to be set
+	 */
+	if (power.target[siso_mcs_id] <= (power.target[stbc_mcs_id] + 12))
+		setbit(ss_algo_channel, PHY_TXC1_MODE_STBC);
+}
+
+static int8 wlc_stf_stbc_rx_get(wlc_info_t * wlc)
+{
+	return (wlc->ht_cap.cap & HT_CAP_RX_STBC_MASK) >> HT_CAP_RX_STBC_SHIFT;
+}
+
+static bool wlc_stf_stbc_tx_set(wlc_info_t * wlc, int32 int_val)
+{
+	if ((int_val != AUTO) && (int_val != OFF) && (int_val != ON)) {
+		return FALSE;
+	}
+
+	if ((int_val == ON) && (wlc->stf->txstreams == 1))
+		return FALSE;
+
+	if ((int_val == OFF) || (wlc->stf->txstreams == 1)
+	    || !WLC_STBC_CAP_PHY(wlc))
+		wlc->ht_cap.cap &= ~HT_CAP_TX_STBC;
+	else
+		wlc->ht_cap.cap |= HT_CAP_TX_STBC;
+
+	wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = (int8) int_val;
+	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = (int8) int_val;
+
+	return TRUE;
+}
+
+bool wlc_stf_stbc_rx_set(wlc_info_t * wlc, int32 int_val)
+{
+	if ((int_val != HT_CAP_RX_STBC_NO)
+	    && (int_val != HT_CAP_RX_STBC_ONE_STREAM)) {
+		return FALSE;
+	}
+
+	if (WLC_STF_SS_STBC_RX(wlc)) {
+		if ((int_val != HT_CAP_RX_STBC_NO)
+		    && (wlc->stf->rxstreams == 1))
+			return FALSE;
+	}
+
+	wlc_stf_stbc_rx_ht_update(wlc, int_val);
+	return TRUE;
+}
+
+static int wlc_stf_txcore_set(wlc_info_t * wlc, uint8 Nsts, uint8 core_mask)
+{
+	WL_TRACE(("wl%d: %s: Nsts %d core_mask %x\n",
+		  wlc->pub->unit, __func__, Nsts, core_mask));
+
+	ASSERT((Nsts > 0) && (Nsts <= MAX_STREAMS_SUPPORTED));
+
+	if (WLC_BITSCNT(core_mask) > wlc->stf->txstreams) {
+		core_mask = 0;
+	}
+
+	if ((WLC_BITSCNT(core_mask) == wlc->stf->txstreams) &&
+	    ((core_mask & ~wlc->stf->txchain)
+	     || !(core_mask & wlc->stf->txchain))) {
+		core_mask = wlc->stf->txchain;
+	}
+
+	ASSERT(!core_mask || Nsts <= WLC_BITSCNT(core_mask));
+
+	wlc->stf->txcore[Nsts] = core_mask;
+	/* Nsts = 1..4, txcore index = 1..4 */
+	if (Nsts == 1) {
+		/* Needs to update beacon and ucode generated response
+		 * frames when 1 stream core map changed
+		 */
+		wlc->stf->phytxant = core_mask << PHY_TXC_ANT_SHIFT;
+		wlc_bmac_txant_set(wlc->hw, wlc->stf->phytxant);
+		if (wlc->clk) {
+			wlc_suspend_mac_and_wait(wlc);
+			wlc_beacon_phytxctl_txant_upd(wlc, wlc->bcn_rspec);
+			wlc_enable_mac(wlc);
+		}
+	}
+
+	return BCME_OK;
+}
+
+static int wlc_stf_spatial_policy_set(wlc_info_t * wlc, int val)
+{
+	int i;
+	uint8 core_mask = 0;
+
+	WL_TRACE(("wl%d: %s: val %x\n", wlc->pub->unit, __func__, val));
+
+	wlc->stf->spatial_policy = (int8) val;
+	for (i = 1; i <= MAX_STREAMS_SUPPORTED; i++) {
+		core_mask = (val == MAX_SPATIAL_EXPANSION) ?
+		    wlc->stf->txchain : txcore_default[i];
+		wlc_stf_txcore_set(wlc, (uint8) i, core_mask);
+	}
+	return BCME_OK;
+}
+
+int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force)
+{
+	uint8 txchain = (uint8) int_val;
+	uint8 txstreams;
+	uint i;
+
+	if (wlc->stf->txchain == txchain)
+		return BCME_OK;
+
+	if ((txchain & ~wlc->stf->hw_txchain)
+	    || !(txchain & wlc->stf->hw_txchain))
+		return BCME_RANGE;
+
+	/* if nrate override is configured to be non-SISO STF mode, reject reducing txchain to 1 */
+	txstreams = (uint8) WLC_BITSCNT(txchain);
+	if (txstreams > MAX_STREAMS_SUPPORTED)
+		return BCME_RANGE;
+
+	if (txstreams == 1) {
+		for (i = 0; i < NBANDS(wlc); i++)
+			if ((RSPEC_STF(wlc->bandstate[i]->rspec_override) !=
+			     PHY_TXC1_MODE_SISO)
+			    || (RSPEC_STF(wlc->bandstate[i]->mrspec_override) !=
+				PHY_TXC1_MODE_SISO)) {
+				if (!force)
+					return BCME_ERROR;
+
+				/* over-write the override rspec */
+				if (RSPEC_STF(wlc->bandstate[i]->rspec_override)
+				    != PHY_TXC1_MODE_SISO) {
+					wlc->bandstate[i]->rspec_override = 0;
+					WL_ERROR(("%s(): temp sense override non-SISO" " rspec_override.\n", __func__));
+				}
+				if (RSPEC_STF
+				    (wlc->bandstate[i]->mrspec_override) !=
+				    PHY_TXC1_MODE_SISO) {
+					wlc->bandstate[i]->mrspec_override = 0;
+					WL_ERROR(("%s(): temp sense override non-SISO" " mrspec_override.\n", __func__));
+				}
+			}
+	}
+
+	wlc->stf->txchain = txchain;
+	wlc->stf->txstreams = txstreams;
+	wlc_stf_stbc_tx_set(wlc, wlc->band->band_stf_stbc_tx);
+	wlc_stf_ss_update(wlc, wlc->bandstate[BAND_2G_INDEX]);
+	wlc_stf_ss_update(wlc, wlc->bandstate[BAND_5G_INDEX]);
+	wlc->stf->txant =
+	    (wlc->stf->txstreams == 1) ? ANT_TX_FORCE_0 : ANT_TX_DEF;
+	_wlc_stf_phy_txant_upd(wlc);
+
+	wlc_phy_stf_chain_set(wlc->band->pi, wlc->stf->txchain,
+			      wlc->stf->rxchain);
+
+	for (i = 1; i <= MAX_STREAMS_SUPPORTED; i++)
+		wlc_stf_txcore_set(wlc, (uint8) i, txcore_default[i]);
+
+	return BCME_OK;
+}
+
+int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val)
+{
+	uint8 rxchain_cnt;
+	uint8 rxchain = (uint8) int_val;
+	uint8 mimops_mode;
+	uint8 old_rxchain, old_rxchain_cnt;
+
+	if (wlc->stf->rxchain == rxchain)
+		return BCME_OK;
+
+	if ((rxchain & ~wlc->stf->hw_rxchain)
+	    || !(rxchain & wlc->stf->hw_rxchain))
+		return BCME_RANGE;
+
+	rxchain_cnt = (uint8) WLC_BITSCNT(rxchain);
+	if (WLC_STF_SS_STBC_RX(wlc)) {
+		if ((rxchain_cnt == 1)
+		    && (wlc_stf_stbc_rx_get(wlc) != HT_CAP_RX_STBC_NO))
+			return BCME_RANGE;
+	}
+
+	if (APSTA_ENAB(wlc->pub) && (wlc->pub->associated))
+		return BCME_ASSOCIATED;
+
+	old_rxchain = wlc->stf->rxchain;
+	old_rxchain_cnt = wlc->stf->rxstreams;
+
+	wlc->stf->rxchain = rxchain;
+	wlc->stf->rxstreams = rxchain_cnt;
+
+	if (rxchain_cnt != old_rxchain_cnt) {
+		mimops_mode =
+		    (rxchain_cnt == 1) ? HT_CAP_MIMO_PS_ON : HT_CAP_MIMO_PS_OFF;
+		wlc->mimops_PM = mimops_mode;
+		if (AP_ENAB(wlc->pub)) {
+			wlc_phy_stf_chain_set(wlc->band->pi, wlc->stf->txchain,
+					      wlc->stf->rxchain);
+			wlc_ht_mimops_cap_update(wlc, mimops_mode);
+			if (wlc->pub->associated)
+				wlc_mimops_action_ht_send(wlc, wlc->cfg,
+							  mimops_mode);
+			return BCME_OK;
+		}
+		if (wlc->pub->associated) {
+			if (mimops_mode == HT_CAP_MIMO_PS_OFF) {
+				/* if mimops is off, turn on the Rx chain first */
+				wlc_phy_stf_chain_set(wlc->band->pi,
+						      wlc->stf->txchain,
+						      wlc->stf->rxchain);
+				wlc_ht_mimops_cap_update(wlc, mimops_mode);
+			}
+		} else {
+			wlc_phy_stf_chain_set(wlc->band->pi, wlc->stf->txchain,
+					      wlc->stf->rxchain);
+			wlc_ht_mimops_cap_update(wlc, mimops_mode);
+		}
+	} else if (old_rxchain != rxchain)
+		wlc_phy_stf_chain_set(wlc->band->pi, wlc->stf->txchain,
+				      wlc->stf->rxchain);
+
+	return BCME_OK;
+}
+
+/* update wlc->stf->ss_opmode which represents the operational stf_ss mode we're using */
+int wlc_stf_ss_update(wlc_info_t * wlc, wlcband_t * band)
+{
+	int ret_code = 0;
+	uint8 prev_stf_ss;
+	uint8 upd_stf_ss;
+
+	prev_stf_ss = wlc->stf->ss_opmode;
+
+	/* NOTE: opmode can only be SISO or CDD as STBC is decided on a per-packet basis */
+	if (WLC_STBC_CAP_PHY(wlc) &&
+	    wlc->stf->ss_algosel_auto
+	    && (wlc->stf->ss_algo_channel != (uint16) - 1)) {
+		ASSERT(isset(&wlc->stf->ss_algo_channel, PHY_TXC1_MODE_CDD)
+		       || isset(&wlc->stf->ss_algo_channel,
+				PHY_TXC1_MODE_SISO));
+		upd_stf_ss = (wlc->stf->no_cddstbc || (wlc->stf->txstreams == 1)
+			      || isset(&wlc->stf->ss_algo_channel,
+				       PHY_TXC1_MODE_SISO)) ? PHY_TXC1_MODE_SISO
+		    : PHY_TXC1_MODE_CDD;
+	} else {
+		if (wlc->band != band)
+			return ret_code;
+		upd_stf_ss = (wlc->stf->no_cddstbc
+			      || (wlc->stf->txstreams ==
+				  1)) ? PHY_TXC1_MODE_SISO : band->
+		    band_stf_ss_mode;
+	}
+	if (prev_stf_ss != upd_stf_ss) {
+		wlc->stf->ss_opmode = upd_stf_ss;
+		wlc_bmac_band_stf_ss_set(wlc->hw, upd_stf_ss);
+	}
+
+	return ret_code;
+}
+
+int BCMATTACHFN(wlc_stf_attach) (wlc_info_t * wlc) {
+	wlc->bandstate[BAND_2G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_SISO;
+	wlc->bandstate[BAND_5G_INDEX]->band_stf_ss_mode = PHY_TXC1_MODE_CDD;
+
+	if (WLCISNPHY(wlc->band) &&
+	    (wlc_phy_txpower_hw_ctrl_get(wlc->band->pi) != PHY_TPC_HW_ON))
+		wlc->bandstate[BAND_2G_INDEX]->band_stf_ss_mode =
+		    PHY_TXC1_MODE_CDD;
+	wlc_stf_ss_update(wlc, wlc->bandstate[BAND_2G_INDEX]);
+	wlc_stf_ss_update(wlc, wlc->bandstate[BAND_5G_INDEX]);
+
+	wlc_stf_stbc_rx_ht_update(wlc, HT_CAP_RX_STBC_NO);
+	wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = OFF;
+	wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = OFF;
+
+	if (WLC_STBC_CAP_PHY(wlc)) {
+		wlc->stf->ss_algosel_auto = TRUE;
+		wlc->stf->ss_algo_channel = (uint16) - 1;	/* Init the default value */
+	}
+	return 0;
+}
+
+void BCMATTACHFN(wlc_stf_detach) (wlc_info_t * wlc) {
+}
+
+int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val)
+{
+	int bcmerror = BCME_OK;
+
+	/* when there is only 1 tx_streams, don't allow to change the txant */
+	if (WLCISNPHY(wlc->band) && (wlc->stf->txstreams == 1))
+		return ((val == wlc->stf->txant) ? bcmerror : BCME_RANGE);
+
+	switch (val) {
+	case -1:
+		val = ANT_TX_DEF;
+		break;
+	case 0:
+		val = ANT_TX_FORCE_0;
+		break;
+	case 1:
+		val = ANT_TX_FORCE_1;
+		break;
+	case 3:
+		val = ANT_TX_LAST_RX;
+		break;
+	default:
+		bcmerror = BCME_RANGE;
+		break;
+	}
+
+	if (bcmerror == BCME_OK)
+		wlc->stf->txant = (int8) val;
+
+	return bcmerror;
+
+}
+
+/*
+ * Centralized txant update function. call it whenever wlc->stf->txant and/or wlc->stf->txchain
+ *  change
+ *
+ * Antennas are controlled by ucode indirectly, which drives PHY or GPIO to
+ *   achieve various tx/rx antenna selection schemes
+ *
+ * legacy phy, bit 6 and bit 7 means antenna 0 and 1 respectively, bit6+bit7 means auto(last rx)
+ * for NREV<3, bit 6 and bit 7 means antenna 0 and 1 respectively, bit6+bit7 means last rx and
+ *    do tx-antenna selection for SISO transmissions
+ * for NREV=3, bit 6 and bit _8_ means antenna 0 and 1 respectively, bit6+bit7 means last rx and
+ *    do tx-antenna selection for SISO transmissions
+ * for NREV>=7, bit 6 and bit 7 mean antenna 0 and 1 respectively, nit6+bit7 means both cores active
+*/
+static void _wlc_stf_phy_txant_upd(wlc_info_t * wlc)
+{
+	int8 txant;
+
+	txant = (int8) wlc->stf->txant;
+	ASSERT(txant == ANT_TX_FORCE_0 || txant == ANT_TX_FORCE_1
+	       || txant == ANT_TX_LAST_RX);
+
+	if (WLC_PHY_11N_CAP(wlc->band)) {
+		if (txant == ANT_TX_FORCE_0) {
+			wlc->stf->phytxant = PHY_TXC_ANT_0;
+		} else if (txant == ANT_TX_FORCE_1) {
+			wlc->stf->phytxant = PHY_TXC_ANT_1;
+
+			if (WLCISNPHY(wlc->band) &&
+			    NREV_GE(wlc->band->phyrev, 3)
+			    && NREV_LT(wlc->band->phyrev, 7)) {
+				wlc->stf->phytxant = PHY_TXC_ANT_2;
+			}
+		} else {
+			if (WLCISLCNPHY(wlc->band) || WLCISSSLPNPHY(wlc->band))
+				wlc->stf->phytxant = PHY_TXC_LCNPHY_ANT_LAST;
+			else {
+				/* keep this assert to catch out of sync wlc->stf->txcore */
+				ASSERT(wlc->stf->txchain > 0);
+				wlc->stf->phytxant =
+				    wlc->stf->txchain << PHY_TXC_ANT_SHIFT;
+			}
+		}
+	} else {
+		if (txant == ANT_TX_FORCE_0)
+			wlc->stf->phytxant = PHY_TXC_OLD_ANT_0;
+		else if (txant == ANT_TX_FORCE_1)
+			wlc->stf->phytxant = PHY_TXC_OLD_ANT_1;
+		else
+			wlc->stf->phytxant = PHY_TXC_OLD_ANT_LAST;
+	}
+
+	wlc_bmac_txant_set(wlc->hw, wlc->stf->phytxant);
+}
+
+void wlc_stf_phy_txant_upd(wlc_info_t * wlc)
+{
+	_wlc_stf_phy_txant_upd(wlc);
+}
+
+void BCMATTACHFN(wlc_stf_phy_chain_calc) (wlc_info_t * wlc) {
+	/* get available rx/tx chains */
+	wlc->stf->hw_txchain = (uint8) getintvar(wlc->pub->vars, "txchain");
+	wlc->stf->hw_rxchain = (uint8) getintvar(wlc->pub->vars, "rxchain");
+
+	/* these parameter are intended to be used for all PHY types */
+	if (wlc->stf->hw_txchain == 0 || wlc->stf->hw_txchain == 0xf) {
+		if (WLCISNPHY(wlc->band)) {
+			wlc->stf->hw_txchain = TXCHAIN_DEF_NPHY;
+		} else {
+			wlc->stf->hw_txchain = TXCHAIN_DEF;
+		}
+	}
+
+	wlc->stf->txchain = wlc->stf->hw_txchain;
+	wlc->stf->txstreams = (uint8) WLC_BITSCNT(wlc->stf->hw_txchain);
+
+	if (wlc->stf->hw_rxchain == 0 || wlc->stf->hw_rxchain == 0xf) {
+		if (WLCISNPHY(wlc->band)) {
+			wlc->stf->hw_rxchain = RXCHAIN_DEF_NPHY;
+		} else {
+			wlc->stf->hw_rxchain = RXCHAIN_DEF;
+		}
+	}
+
+	wlc->stf->rxchain = wlc->stf->hw_rxchain;
+	wlc->stf->rxstreams = (uint8) WLC_BITSCNT(wlc->stf->hw_rxchain);
+
+	/* initialize the txcore table */
+	bcopy(txcore_default, wlc->stf->txcore, sizeof(wlc->stf->txcore));
+
+	/* default spatial_policy */
+	wlc->stf->spatial_policy = MIN_SPATIAL_EXPANSION;
+	wlc_stf_spatial_policy_set(wlc, MIN_SPATIAL_EXPANSION);
+}
+
+static uint16 _wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec)
+{
+	uint16 phytxant = wlc->stf->phytxant;
+
+	if (RSPEC_STF(rspec) != PHY_TXC1_MODE_SISO) {
+		ASSERT(wlc->stf->txstreams > 1);
+		phytxant = wlc->stf->txchain << PHY_TXC_ANT_SHIFT;
+	} else if (wlc->stf->txant == ANT_TX_DEF)
+		phytxant = wlc->stf->txchain << PHY_TXC_ANT_SHIFT;
+	phytxant &= PHY_TXC_ANT_MASK;
+	return phytxant;
+}
+
+uint16 wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec)
+{
+	return _wlc_stf_phytxchain_sel(wlc, rspec);
+}
+
+uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t * wlc, ratespec_t rspec)
+{
+	uint16 phytxant = wlc->stf->phytxant;
+	uint16 mask = PHY_TXC_ANT_MASK;
+
+	/* for non-siso rates or default setting, use the available chains */
+	if (WLCISNPHY(wlc->band)) {
+		ASSERT(wlc->stf->txchain != 0);
+		phytxant = _wlc_stf_phytxchain_sel(wlc, rspec);
+		mask = PHY_TXC_HTANT_MASK;
+	}
+	phytxant |= phytxant & mask;
+	return phytxant;
+}
diff --git a/drivers/staging/brcm80211/sys/wlc_stf.h b/drivers/staging/brcm80211/sys/wlc_stf.h
new file mode 100644
index 0000000..b789ea1
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_stf.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_stf_h_
+#define _wlc_stf_h_
+
+#define MIN_SPATIAL_EXPANSION	0
+#define MAX_SPATIAL_EXPANSION	1
+
+extern int wlc_stf_attach(wlc_info_t * wlc);
+extern void wlc_stf_detach(wlc_info_t * wlc);
+
+extern void wlc_tempsense_upd(wlc_info_t * wlc);
+extern void wlc_stf_ss_algo_channel_get(wlc_info_t * wlc,
+					uint16 * ss_algo_channel,
+					chanspec_t chanspec);
+extern int wlc_stf_ss_update(wlc_info_t * wlc, struct wlcband *band);
+extern void wlc_stf_phy_txant_upd(wlc_info_t * wlc);
+extern int wlc_stf_txchain_set(wlc_info_t * wlc, int32 int_val, bool force);
+extern int wlc_stf_rxchain_set(wlc_info_t * wlc, int32 int_val);
+extern bool wlc_stf_stbc_rx_set(wlc_info_t * wlc, int32 int_val);
+
+extern int wlc_stf_ant_txant_validate(wlc_info_t * wlc, int8 val);
+extern void wlc_stf_phy_txant_upd(wlc_info_t * wlc);
+extern void wlc_stf_phy_chain_calc(wlc_info_t * wlc);
+extern uint16 wlc_stf_phytxchain_sel(wlc_info_t * wlc, ratespec_t rspec);
+extern uint16 wlc_stf_d11hdrs_phyctl_txant(wlc_info_t * wlc, ratespec_t rspec);
+extern uint16 wlc_stf_spatial_expansion_get(wlc_info_t * wlc, ratespec_t rspec);
+#endif				/* _wlc_stf_h_ */
diff --git a/drivers/staging/brcm80211/sys/wlc_types.h b/drivers/staging/brcm80211/sys/wlc_types.h
new file mode 100644
index 0000000..33047eb
--- /dev/null
+++ b/drivers/staging/brcm80211/sys/wlc_types.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _wlc_types_h_
+#define _wlc_types_h_
+
+/* forward declarations */
+
+typedef struct wlc_info wlc_info_t;
+typedef struct wlc_hw_info wlc_hw_info_t;
+typedef struct wlc_if wlc_if_t;
+typedef struct wl_if wl_if_t;
+typedef struct led_info led_info_t;
+typedef struct bmac_led bmac_led_t;
+typedef struct bmac_led_info bmac_led_info_t;
+typedef struct scb_module scb_module_t;
+typedef struct ba_info ba_info_t;
+typedef struct ampdu_info ampdu_info_t;
+typedef struct ratesel_info ratesel_info_t;
+typedef struct wlc_ap_info wlc_ap_info_t;
+typedef struct wlc_auth_info wlc_auth_info_t;
+typedef struct supplicant supplicant_t;
+typedef struct authenticator authenticator_t;
+typedef struct antsel_info antsel_info_t;
+#if !defined(WLC_LOW)
+typedef struct rpctx_info rpctx_info_t;
+#endif
+#ifdef WLC_LOW
+typedef struct bmac_pmq bmac_pmq_t;
+#endif
+
+struct d11init;
+
+#ifndef _hnddma_pub_
+#define _hnddma_pub_
+typedef const struct hnddma_pub hnddma_t;
+#endif				/* _hnddma_pub_ */
+
+#endif				/* _wlc_types_h_ */
diff --git a/drivers/staging/brcm80211/util/aiutils.c b/drivers/staging/brcm80211/util/aiutils.c
new file mode 100644
index 0000000..8883af0
--- /dev/null
+++ b/drivers/staging/brcm80211/util/aiutils.c
@@ -0,0 +1,795 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <pcicfg.h>
+#include <bcmdevs.h>
+
+#define BCM47162_DMP() ((CHIPID(sih->chip) == BCM47162_CHIP_ID) && \
+		(CHIPREV(sih->chiprev) == 0) && \
+		(sii->coreid[sii->curidx] == MIPS74K_CORE_ID))
+
+/* EROM parsing */
+
+static uint32
+get_erom_ent(si_t * sih, uint32 ** eromptr, uint32 mask, uint32 match)
+{
+	uint32 ent;
+	uint inv = 0, nom = 0;
+
+	while (TRUE) {
+		ent = R_REG(si_osh(sih), *eromptr);
+		(*eromptr)++;
+
+		if (mask == 0)
+			break;
+
+		if ((ent & ER_VALID) == 0) {
+			inv++;
+			continue;
+		}
+
+		if (ent == (ER_END | ER_VALID))
+			break;
+
+		if ((ent & mask) == match)
+			break;
+
+		nom++;
+	}
+
+	SI_VMSG(("%s: Returning ent 0x%08x\n", __func__, ent));
+	if (inv + nom) {
+		SI_VMSG(("  after %d invalid and %d non-matching entries\n",
+			 inv, nom));
+	}
+	return ent;
+}
+
+static uint32
+get_asd(si_t * sih, uint32 ** eromptr, uint sp, uint ad, uint st,
+	uint32 * addrl, uint32 * addrh, uint32 * sizel, uint32 * sizeh)
+{
+	uint32 asd, sz, szd;
+
+	asd = get_erom_ent(sih, eromptr, ER_VALID, ER_VALID);
+	if (((asd & ER_TAG1) != ER_ADD) ||
+	    (((asd & AD_SP_MASK) >> AD_SP_SHIFT) != sp) ||
+	    ((asd & AD_ST_MASK) != st)) {
+		/* This is not what we want, "push" it back */
+		(*eromptr)--;
+		return 0;
+	}
+	*addrl = asd & AD_ADDR_MASK;
+	if (asd & AD_AG32)
+		*addrh = get_erom_ent(sih, eromptr, 0, 0);
+	else
+		*addrh = 0;
+	*sizeh = 0;
+	sz = asd & AD_SZ_MASK;
+	if (sz == AD_SZ_SZD) {
+		szd = get_erom_ent(sih, eromptr, 0, 0);
+		*sizel = szd & SD_SZ_MASK;
+		if (szd & SD_SG32)
+			*sizeh = get_erom_ent(sih, eromptr, 0, 0);
+	} else
+		*sizel = AD_SZ_BASE << (sz >> AD_SZ_SHIFT);
+
+	SI_VMSG(("  SP %d, ad %d: st = %d, 0x%08x_0x%08x @ 0x%08x_0x%08x\n",
+		 sp, ad, st, *sizeh, *sizel, *addrh, *addrl));
+
+	return asd;
+}
+
+static void ai_hwfixup(si_info_t * sii)
+{
+}
+
+/* parse the enumeration rom to identify all cores */
+void BCMATTACHFN(ai_scan) (si_t * sih, void *regs, uint devid) {
+	si_info_t *sii = SI_INFO(sih);
+	chipcregs_t *cc = (chipcregs_t *) regs;
+	uint32 erombase, *eromptr, *eromlim;
+
+	erombase = R_REG(sii->osh, &cc->eromptr);
+
+	switch (BUSTYPE(sih->bustype)) {
+	case SI_BUS:
+		eromptr = (uint32 *) REG_MAP(erombase, SI_CORE_SIZE);
+		break;
+
+	case PCI_BUS:
+		/* Set wrappers address */
+		sii->curwrap = (void *)((uintptr) regs + SI_CORE_SIZE);
+
+		/* Now point the window at the erom */
+		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, erombase);
+		eromptr = regs;
+		break;
+
+#ifdef BCMSDIO
+	case SPI_BUS:
+	case SDIO_BUS:
+#endif				/* BCMSDIO */
+		eromptr = (uint32 *) (uintptr) erombase;
+		break;
+
+	default:
+		SI_ERROR(("Don't know how to do AXI enumertion on bus %d\n",
+			  sih->bustype));
+		ASSERT(0);
+		return;
+	}
+	eromlim = eromptr + (ER_REMAPCONTROL / sizeof(uint32));
+
+	SI_VMSG(("ai_scan: regs = 0x%p, erombase = 0x%08x, eromptr = 0x%p, eromlim = 0x%p\n", regs, erombase, eromptr, eromlim));
+	while (eromptr < eromlim) {
+		uint32 cia, cib, cid, mfg, crev, nmw, nsw, nmp, nsp;
+		uint32 mpd, asd, addrl, addrh, sizel, sizeh;
+		uint32 *base;
+		uint i, j, idx;
+		bool br;
+
+		br = FALSE;
+
+		/* Grok a component */
+		cia = get_erom_ent(sih, &eromptr, ER_TAG, ER_CI);
+		if (cia == (ER_END | ER_VALID)) {
+			SI_VMSG(("Found END of erom after %d cores\n",
+				 sii->numcores));
+			ai_hwfixup(sii);
+			return;
+		}
+		base = eromptr - 1;
+		cib = get_erom_ent(sih, &eromptr, 0, 0);
+
+		if ((cib & ER_TAG) != ER_CI) {
+			SI_ERROR(("CIA not followed by CIB\n"));
+			goto error;
+		}
+
+		cid = (cia & CIA_CID_MASK) >> CIA_CID_SHIFT;
+		mfg = (cia & CIA_MFG_MASK) >> CIA_MFG_SHIFT;
+		crev = (cib & CIB_REV_MASK) >> CIB_REV_SHIFT;
+		nmw = (cib & CIB_NMW_MASK) >> CIB_NMW_SHIFT;
+		nsw = (cib & CIB_NSW_MASK) >> CIB_NSW_SHIFT;
+		nmp = (cib & CIB_NMP_MASK) >> CIB_NMP_SHIFT;
+		nsp = (cib & CIB_NSP_MASK) >> CIB_NSP_SHIFT;
+
+		SI_VMSG(("Found component 0x%04x/0x%04x rev %d at erom addr 0x%p, with nmw = %d, " "nsw = %d, nmp = %d & nsp = %d\n", mfg, cid, crev, base, nmw, nsw, nmp, nsp));
+
+		if (((mfg == MFGID_ARM) && (cid == DEF_AI_COMP)) || (nsp == 0))
+			continue;
+		if ((nmw + nsw == 0)) {
+			/* A component which is not a core */
+			if (cid == OOB_ROUTER_CORE_ID) {
+				asd = get_asd(sih, &eromptr, 0, 0, AD_ST_SLAVE,
+					      &addrl, &addrh, &sizel, &sizeh);
+				if (asd != 0) {
+					sii->oob_router = addrl;
+				}
+			}
+			continue;
+		}
+
+		idx = sii->numcores;
+/*		sii->eromptr[idx] = base; */
+		sii->cia[idx] = cia;
+		sii->cib[idx] = cib;
+		sii->coreid[idx] = cid;
+
+		for (i = 0; i < nmp; i++) {
+			mpd = get_erom_ent(sih, &eromptr, ER_VALID, ER_VALID);
+			if ((mpd & ER_TAG) != ER_MP) {
+				SI_ERROR(("Not enough MP entries for component 0x%x\n", cid));
+				goto error;
+			}
+			SI_VMSG(("  Master port %d, mp: %d id: %d\n", i,
+				 (mpd & MPD_MP_MASK) >> MPD_MP_SHIFT,
+				 (mpd & MPD_MUI_MASK) >> MPD_MUI_SHIFT));
+		}
+
+		/* First Slave Address Descriptor should be port 0:
+		 * the main register space for the core
+		 */
+		asd =
+		    get_asd(sih, &eromptr, 0, 0, AD_ST_SLAVE, &addrl, &addrh,
+			    &sizel, &sizeh);
+		if (asd == 0) {
+			/* Try again to see if it is a bridge */
+			asd =
+			    get_asd(sih, &eromptr, 0, 0, AD_ST_BRIDGE, &addrl,
+				    &addrh, &sizel, &sizeh);
+			if (asd != 0)
+				br = TRUE;
+			else if ((addrh != 0) || (sizeh != 0)
+				 || (sizel != SI_CORE_SIZE)) {
+				SI_ERROR(("First Slave ASD for core 0x%04x malformed " "(0x%08x)\n", cid, asd));
+				goto error;
+			}
+		}
+		sii->coresba[idx] = addrl;
+		sii->coresba_size[idx] = sizel;
+		/* Get any more ASDs in port 0 */
+		j = 1;
+		do {
+			asd =
+			    get_asd(sih, &eromptr, 0, j, AD_ST_SLAVE, &addrl,
+				    &addrh, &sizel, &sizeh);
+			if ((asd != 0) && (j == 1) && (sizel == SI_CORE_SIZE)) {
+				sii->coresba2[idx] = addrl;
+				sii->coresba2_size[idx] = sizel;
+			}
+			j++;
+		} while (asd != 0);
+
+		/* Go through the ASDs for other slave ports */
+		for (i = 1; i < nsp; i++) {
+			j = 0;
+			do {
+				asd =
+				    get_asd(sih, &eromptr, i, j++, AD_ST_SLAVE,
+					    &addrl, &addrh, &sizel, &sizeh);
+			} while (asd != 0);
+			if (j == 0) {
+				SI_ERROR((" SP %d has no address descriptors\n",
+					  i));
+				goto error;
+			}
+		}
+
+		/* Now get master wrappers */
+		for (i = 0; i < nmw; i++) {
+			asd =
+			    get_asd(sih, &eromptr, i, 0, AD_ST_MWRAP, &addrl,
+				    &addrh, &sizel, &sizeh);
+			if (asd == 0) {
+				SI_ERROR(("Missing descriptor for MW %d\n", i));
+				goto error;
+			}
+			if ((sizeh != 0) || (sizel != SI_CORE_SIZE)) {
+				SI_ERROR(("Master wrapper %d is not 4KB\n", i));
+				goto error;
+			}
+			if (i == 0)
+				sii->wrapba[idx] = addrl;
+		}
+
+		/* And finally slave wrappers */
+		for (i = 0; i < nsw; i++) {
+			uint fwp = (nsp == 1) ? 0 : 1;
+			asd =
+			    get_asd(sih, &eromptr, fwp + i, 0, AD_ST_SWRAP,
+				    &addrl, &addrh, &sizel, &sizeh);
+			if (asd == 0) {
+				SI_ERROR(("Missing descriptor for SW %d\n", i));
+				goto error;
+			}
+			if ((sizeh != 0) || (sizel != SI_CORE_SIZE)) {
+				SI_ERROR(("Slave wrapper %d is not 4KB\n", i));
+				goto error;
+			}
+			if ((nmw == 0) && (i == 0))
+				sii->wrapba[idx] = addrl;
+		}
+
+		/* Don't record bridges */
+		if (br)
+			continue;
+
+		/* Done with core */
+		sii->numcores++;
+	}
+
+	SI_ERROR(("Reached end of erom without finding END"));
+
+ error:
+	sii->numcores = 0;
+	return;
+}
+
+/* This function changes the logical "focus" to the indicated core.
+ * Return the current core's virtual address.
+ */
+void *ai_setcoreidx(si_t * sih, uint coreidx)
+{
+	si_info_t *sii = SI_INFO(sih);
+	uint32 addr = sii->coresba[coreidx];
+	uint32 wrap = sii->wrapba[coreidx];
+	void *regs;
+
+	if (coreidx >= sii->numcores)
+		return (NULL);
+
+	/*
+	 * If the user has provided an interrupt mask enabled function,
+	 * then assert interrupts are disabled before switching the core.
+	 */
+	ASSERT((sii->intrsenabled_fn == NULL)
+	       || !(*(sii)->intrsenabled_fn) ((sii)->intr_arg));
+
+	switch (BUSTYPE(sih->bustype)) {
+	case SI_BUS:
+		/* map new one */
+		if (!sii->regs[coreidx]) {
+			sii->regs[coreidx] = REG_MAP(addr, SI_CORE_SIZE);
+			ASSERT(GOODREGS(sii->regs[coreidx]));
+		}
+		sii->curmap = regs = sii->regs[coreidx];
+		if (!sii->wrappers[coreidx]) {
+			sii->wrappers[coreidx] = REG_MAP(wrap, SI_CORE_SIZE);
+			ASSERT(GOODREGS(sii->wrappers[coreidx]));
+		}
+		sii->curwrap = sii->wrappers[coreidx];
+		break;
+
+	case PCI_BUS:
+		/* point bar0 window */
+		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, addr);
+		regs = sii->curmap;
+		/* point bar0 2nd 4KB window */
+		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN2, 4, wrap);
+		break;
+
+#ifdef BCMSDIO
+	case SPI_BUS:
+	case SDIO_BUS:
+#endif				/* BCMSDIO */
+		sii->curmap = regs = (void *)((uintptr) addr);
+		sii->curwrap = (void *)((uintptr) wrap);
+		break;
+
+	default:
+		ASSERT(0);
+		regs = NULL;
+		break;
+	}
+
+	sii->curmap = regs;
+	sii->curidx = coreidx;
+
+	return regs;
+}
+
+/* Return the number of address spaces in current core */
+int ai_numaddrspaces(si_t * sih)
+{
+	return 2;
+}
+
+/* Return the address of the nth address space in the current core */
+uint32 ai_addrspace(si_t * sih, uint asidx)
+{
+	si_info_t *sii;
+	uint cidx;
+
+	sii = SI_INFO(sih);
+	cidx = sii->curidx;
+
+	if (asidx == 0)
+		return sii->coresba[cidx];
+	else if (asidx == 1)
+		return sii->coresba2[cidx];
+	else {
+		SI_ERROR(("%s: Need to parse the erom again to find addr space %d\n", __func__, asidx));
+		return 0;
+	}
+}
+
+/* Return the size of the nth address space in the current core */
+uint32 ai_addrspacesize(si_t * sih, uint asidx)
+{
+	si_info_t *sii;
+	uint cidx;
+
+	sii = SI_INFO(sih);
+	cidx = sii->curidx;
+
+	if (asidx == 0)
+		return sii->coresba_size[cidx];
+	else if (asidx == 1)
+		return sii->coresba2_size[cidx];
+	else {
+		SI_ERROR(("%s: Need to parse the erom again to find addr space %d\n", __func__, asidx));
+		return 0;
+	}
+}
+
+uint ai_flag(si_t * sih)
+{
+	si_info_t *sii;
+	aidmp_t *ai;
+
+	sii = SI_INFO(sih);
+	if (BCM47162_DMP()) {
+		SI_ERROR(("%s: Attempting to read MIPS DMP registers on 47162a0", __func__));
+		return sii->curidx;
+	}
+	ai = sii->curwrap;
+
+	return (R_REG(sii->osh, &ai->oobselouta30) & 0x1f);
+}
+
+void ai_setint(si_t * sih, int siflag)
+{
+}
+
+void ai_write_wrap_reg(si_t * sih, uint32 offset, uint32 val)
+{
+	si_info_t *sii = SI_INFO(sih);
+	uint32 *w = (uint32 *) sii->curwrap;
+	W_REG(sii->osh, w + (offset / 4), val);
+	return;
+}
+
+uint ai_corevendor(si_t * sih)
+{
+	si_info_t *sii;
+	uint32 cia;
+
+	sii = SI_INFO(sih);
+	cia = sii->cia[sii->curidx];
+	return ((cia & CIA_MFG_MASK) >> CIA_MFG_SHIFT);
+}
+
+uint ai_corerev(si_t * sih)
+{
+	si_info_t *sii;
+	uint32 cib;
+
+	sii = SI_INFO(sih);
+	cib = sii->cib[sii->curidx];
+	return ((cib & CIB_REV_MASK) >> CIB_REV_SHIFT);
+}
+
+bool ai_iscoreup(si_t * sih)
+{
+	si_info_t *sii;
+	aidmp_t *ai;
+
+	sii = SI_INFO(sih);
+	ai = sii->curwrap;
+
+	return (((R_REG(sii->osh, &ai->ioctrl) & (SICF_FGC | SICF_CLOCK_EN)) ==
+		 SICF_CLOCK_EN)
+		&& ((R_REG(sii->osh, &ai->resetctrl) & AIRC_RESET) == 0));
+}
+
+/*
+ * Switch to 'coreidx', issue a single arbitrary 32bit register mask&set operation,
+ * switch back to the original core, and return the new value.
+ *
+ * When using the silicon backplane, no fiddling with interrupts or core switches is needed.
+ *
+ * Also, when using pci/pcie, we can optimize away the core switching for pci registers
+ * and (on newer pci cores) chipcommon registers.
+ */
+uint ai_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
+{
+	uint origidx = 0;
+	uint32 *r = NULL;
+	uint w;
+	uint intr_val = 0;
+	bool fast = FALSE;
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	ASSERT(GOODIDX(coreidx));
+	ASSERT(regoff < SI_CORE_SIZE);
+	ASSERT((val & ~mask) == 0);
+
+	if (coreidx >= SI_MAXCORES)
+		return 0;
+
+	if (BUSTYPE(sih->bustype) == SI_BUS) {
+		/* If internal bus, we can always get at everything */
+		fast = TRUE;
+		/* map if does not exist */
+		if (!sii->regs[coreidx]) {
+			sii->regs[coreidx] = REG_MAP(sii->coresba[coreidx],
+						     SI_CORE_SIZE);
+			ASSERT(GOODREGS(sii->regs[coreidx]));
+		}
+		r = (uint32 *) ((uchar *) sii->regs[coreidx] + regoff);
+	} else if (BUSTYPE(sih->bustype) == PCI_BUS) {
+		/* If pci/pcie, we can get at pci/pcie regs and on newer cores to chipc */
+
+		if ((sii->coreid[coreidx] == CC_CORE_ID) && SI_FAST(sii)) {
+			/* Chipc registers are mapped at 12KB */
+
+			fast = TRUE;
+			r = (uint32 *) ((char *)sii->curmap +
+					PCI_16KB0_CCREGS_OFFSET + regoff);
+		} else if (sii->pub.buscoreidx == coreidx) {
+			/* pci registers are at either in the last 2KB of an 8KB window
+			 * or, in pcie and pci rev 13 at 8KB
+			 */
+			fast = TRUE;
+			if (SI_FAST(sii))
+				r = (uint32 *) ((char *)sii->curmap +
+						PCI_16KB0_PCIREGS_OFFSET +
+						regoff);
+			else
+				r = (uint32 *) ((char *)sii->curmap +
+						((regoff >= SBCONFIGOFF) ?
+						 PCI_BAR0_PCISBR_OFFSET :
+						 PCI_BAR0_PCIREGS_OFFSET) +
+						regoff);
+		}
+	}
+
+	if (!fast) {
+		INTR_OFF(sii, intr_val);
+
+		/* save current core index */
+		origidx = si_coreidx(&sii->pub);
+
+		/* switch core */
+		r = (uint32 *) ((uchar *) ai_setcoreidx(&sii->pub, coreidx) +
+				regoff);
+	}
+	ASSERT(r != NULL);
+
+	/* mask and set */
+	if (mask || val) {
+		w = (R_REG(sii->osh, r) & ~mask) | val;
+		W_REG(sii->osh, r, w);
+	}
+
+	/* readback */
+	w = R_REG(sii->osh, r);
+
+	if (!fast) {
+		/* restore core index */
+		if (origidx != coreidx)
+			ai_setcoreidx(&sii->pub, origidx);
+
+		INTR_RESTORE(sii, intr_val);
+	}
+
+	return (w);
+}
+
+void ai_core_disable(si_t * sih, uint32 bits)
+{
+	si_info_t *sii;
+	volatile uint32 dummy;
+	aidmp_t *ai;
+
+	sii = SI_INFO(sih);
+
+	ASSERT(GOODREGS(sii->curwrap));
+	ai = sii->curwrap;
+
+	/* if core is already in reset, just return */
+	if (R_REG(sii->osh, &ai->resetctrl) & AIRC_RESET)
+		return;
+
+	W_REG(sii->osh, &ai->ioctrl, bits);
+	dummy = R_REG(sii->osh, &ai->ioctrl);
+	OSL_DELAY(10);
+
+	W_REG(sii->osh, &ai->resetctrl, AIRC_RESET);
+	OSL_DELAY(1);
+}
+
+/* reset and re-enable a core
+ * inputs:
+ * bits - core specific bits that are set during and after reset sequence
+ * resetbits - core specific bits that are set only during reset sequence
+ */
+void ai_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
+{
+	si_info_t *sii;
+	aidmp_t *ai;
+	volatile uint32 dummy;
+
+	sii = SI_INFO(sih);
+	ASSERT(GOODREGS(sii->curwrap));
+	ai = sii->curwrap;
+
+	/*
+	 * Must do the disable sequence first to work for arbitrary current core state.
+	 */
+	ai_core_disable(sih, (bits | resetbits));
+
+	/*
+	 * Now do the initialization sequence.
+	 */
+	W_REG(sii->osh, &ai->ioctrl, (bits | SICF_FGC | SICF_CLOCK_EN));
+	dummy = R_REG(sii->osh, &ai->ioctrl);
+	W_REG(sii->osh, &ai->resetctrl, 0);
+	OSL_DELAY(1);
+
+	W_REG(sii->osh, &ai->ioctrl, (bits | SICF_CLOCK_EN));
+	dummy = R_REG(sii->osh, &ai->ioctrl);
+	OSL_DELAY(1);
+}
+
+void ai_core_cflags_wo(si_t * sih, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+	aidmp_t *ai;
+	uint32 w;
+
+	sii = SI_INFO(sih);
+
+	if (BCM47162_DMP()) {
+		SI_ERROR(("%s: Accessing MIPS DMP register (ioctrl) on 47162a0",
+			  __func__));
+		return;
+	}
+
+	ASSERT(GOODREGS(sii->curwrap));
+	ai = sii->curwrap;
+
+	ASSERT((val & ~mask) == 0);
+
+	if (mask || val) {
+		w = ((R_REG(sii->osh, &ai->ioctrl) & ~mask) | val);
+		W_REG(sii->osh, &ai->ioctrl, w);
+	}
+}
+
+uint32 ai_core_cflags(si_t * sih, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+	aidmp_t *ai;
+	uint32 w;
+
+	sii = SI_INFO(sih);
+	if (BCM47162_DMP()) {
+		SI_ERROR(("%s: Accessing MIPS DMP register (ioctrl) on 47162a0",
+			  __func__));
+		return 0;
+	}
+
+	ASSERT(GOODREGS(sii->curwrap));
+	ai = sii->curwrap;
+
+	ASSERT((val & ~mask) == 0);
+
+	if (mask || val) {
+		w = ((R_REG(sii->osh, &ai->ioctrl) & ~mask) | val);
+		W_REG(sii->osh, &ai->ioctrl, w);
+	}
+
+	return R_REG(sii->osh, &ai->ioctrl);
+}
+
+uint32 ai_core_sflags(si_t * sih, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+	aidmp_t *ai;
+	uint32 w;
+
+	sii = SI_INFO(sih);
+	if (BCM47162_DMP()) {
+		SI_ERROR(("%s: Accessing MIPS DMP register (iostatus) on 47162a0", __func__));
+		return 0;
+	}
+
+	ASSERT(GOODREGS(sii->curwrap));
+	ai = sii->curwrap;
+
+	ASSERT((val & ~mask) == 0);
+	ASSERT((mask & ~SISF_CORE_BITS) == 0);
+
+	if (mask || val) {
+		w = ((R_REG(sii->osh, &ai->iostatus) & ~mask) | val);
+		W_REG(sii->osh, &ai->iostatus, w);
+	}
+
+	return R_REG(sii->osh, &ai->iostatus);
+}
+
+#ifdef BCMDBG
+void ai_view(si_t * sih, bool verbose)
+{
+	si_info_t *sii;
+	osl_t *osh;
+	aidmp_t *ai;
+	uint32 config;
+
+	sii = SI_INFO(sih);
+	ai = sii->curwrap;
+	osh = sii->osh;
+	if (BCM47162_DMP()) {
+		SI_ERROR(("Cannot access mips74k DMP in 47162a0\n"));
+		return;
+	}
+
+	config = R_REG(osh, &ai->config);
+	SI_ERROR(("\nCore ID: 0x%x, config 0x%x\n", si_coreid(&sii->pub),
+		  config));
+
+	if (config & AICFG_RST)
+		SI_ERROR(("resetctrl 0x%x, resetstatus 0x%x, resetreadid 0x%x, resetwriteid 0x%x\n", R_REG(osh, &ai->resetctrl), R_REG(osh, &ai->resetstatus), R_REG(osh, &ai->resetreadid), R_REG(osh, &ai->resetwriteid)));
+
+	if (config & AICFG_IOC)
+		SI_ERROR(("ioctrl 0x%x, width %d\n", R_REG(osh, &ai->ioctrl),
+			  R_REG(osh, &ai->ioctrlwidth)));
+
+	if (config & AICFG_IOS)
+		SI_ERROR(("iostatus 0x%x, width %d\n",
+			  R_REG(osh, &ai->iostatus), R_REG(osh,
+							   &ai->
+							   iostatuswidth)));
+
+	if (config & AICFG_ERRL) {
+		SI_ERROR(("errlogctrl 0x%x, errlogdone 0x%x, errlogstatus 0x%x, intstatus 0x%x\n", R_REG(osh, &ai->errlogctrl), R_REG(osh, &ai->errlogdone), R_REG(osh, &ai->errlogstatus), R_REG(osh, &ai->intstatus)));
+		SI_ERROR(("errlogid 0x%x, errloguser 0x%x, errlogflags 0x%x, errlogaddr " "0x%x/0x%x\n", R_REG(osh, &ai->errlogid), R_REG(osh, &ai->errloguser), R_REG(osh, &ai->errlogflags), R_REG(osh, &ai->errlogaddrhi), R_REG(osh, &ai->errlogaddrlo)));
+	}
+
+	if (verbose && (config & AICFG_OOB)) {
+		SI_ERROR(("oobselina30 0x%x, oobselina74 0x%x\n",
+			  R_REG(osh, &ai->oobselina30), R_REG(osh,
+							      &ai->
+							      oobselina74)));
+		SI_ERROR(("oobselinb30 0x%x, oobselinb74 0x%x\n",
+			  R_REG(osh, &ai->oobselinb30), R_REG(osh,
+							      &ai->
+							      oobselinb74)));
+		SI_ERROR(("oobselinc30 0x%x, oobselinc74 0x%x\n",
+			  R_REG(osh, &ai->oobselinc30), R_REG(osh,
+							      &ai->
+							      oobselinc74)));
+		SI_ERROR(("oobselind30 0x%x, oobselind74 0x%x\n",
+			  R_REG(osh, &ai->oobselind30), R_REG(osh,
+							      &ai->
+							      oobselind74)));
+		SI_ERROR(("oobselouta30 0x%x, oobselouta74 0x%x\n",
+			  R_REG(osh, &ai->oobselouta30), R_REG(osh,
+							       &ai->
+							       oobselouta74)));
+		SI_ERROR(("oobseloutb30 0x%x, oobseloutb74 0x%x\n",
+			  R_REG(osh, &ai->oobseloutb30), R_REG(osh,
+							       &ai->
+							       oobseloutb74)));
+		SI_ERROR(("oobseloutc30 0x%x, oobseloutc74 0x%x\n",
+			  R_REG(osh, &ai->oobseloutc30), R_REG(osh,
+							       &ai->
+							       oobseloutc74)));
+		SI_ERROR(("oobseloutd30 0x%x, oobseloutd74 0x%x\n",
+			  R_REG(osh, &ai->oobseloutd30), R_REG(osh,
+							       &ai->
+							       oobseloutd74)));
+		SI_ERROR(("oobsynca 0x%x, oobseloutaen 0x%x\n",
+			  R_REG(osh, &ai->oobsynca), R_REG(osh,
+							   &ai->oobseloutaen)));
+		SI_ERROR(("oobsyncb 0x%x, oobseloutben 0x%x\n",
+			  R_REG(osh, &ai->oobsyncb), R_REG(osh,
+							   &ai->oobseloutben)));
+		SI_ERROR(("oobsyncc 0x%x, oobseloutcen 0x%x\n",
+			  R_REG(osh, &ai->oobsyncc), R_REG(osh,
+							   &ai->oobseloutcen)));
+		SI_ERROR(("oobsyncd 0x%x, oobseloutden 0x%x\n",
+			  R_REG(osh, &ai->oobsyncd), R_REG(osh,
+							   &ai->oobseloutden)));
+		SI_ERROR(("oobaextwidth 0x%x, oobainwidth 0x%x, oobaoutwidth 0x%x\n", R_REG(osh, &ai->oobaextwidth), R_REG(osh, &ai->oobainwidth), R_REG(osh, &ai->oobaoutwidth)));
+		SI_ERROR(("oobbextwidth 0x%x, oobbinwidth 0x%x, oobboutwidth 0x%x\n", R_REG(osh, &ai->oobbextwidth), R_REG(osh, &ai->oobbinwidth), R_REG(osh, &ai->oobboutwidth)));
+		SI_ERROR(("oobcextwidth 0x%x, oobcinwidth 0x%x, oobcoutwidth 0x%x\n", R_REG(osh, &ai->oobcextwidth), R_REG(osh, &ai->oobcinwidth), R_REG(osh, &ai->oobcoutwidth)));
+		SI_ERROR(("oobdextwidth 0x%x, oobdinwidth 0x%x, oobdoutwidth 0x%x\n", R_REG(osh, &ai->oobdextwidth), R_REG(osh, &ai->oobdinwidth), R_REG(osh, &ai->oobdoutwidth)));
+	}
+}
+#endif				/* BCMDBG */
diff --git a/drivers/staging/brcm80211/util/bcmotp.c b/drivers/staging/brcm80211/util/bcmotp.c
new file mode 100644
index 0000000..c85cc6a
--- /dev/null
+++ b/drivers/staging/brcm80211/util/bcmotp.c
@@ -0,0 +1,954 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmdevs.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <bcmotp.h>
+#include "siutils_priv.h"
+
+/*
+ * There are two different OTP controllers so far:
+ * 	1. new IPX OTP controller:	chipc 21, >=23
+ * 	2. older HND OTP controller:	chipc 12, 17, 22
+ *
+ * Define BCMHNDOTP to include support for the HND OTP controller.
+ * Define BCMIPXOTP to include support for the IPX OTP controller.
+ *
+ * NOTE 1: More than one may be defined
+ * NOTE 2: If none are defined, the default is to include them all.
+ */
+
+#if !defined(BCMHNDOTP) && !defined(BCMIPXOTP)
+#define BCMHNDOTP	1
+#define BCMIPXOTP	1
+#endif
+
+#define OTPTYPE_HND(ccrev)	((ccrev) < 21 || (ccrev) == 22)
+#define OTPTYPE_IPX(ccrev)	((ccrev) == 21 || (ccrev) >= 23)
+
+#define OTPP_TRIES	10000000	/* # of tries for OTPP */
+
+#ifdef BCMIPXOTP
+#define MAXNUMRDES		9	/* Maximum OTP redundancy entries */
+#endif
+
+/* OTP common function type */
+typedef int (*otp_status_t) (void *oh);
+typedef int (*otp_size_t) (void *oh);
+typedef void *(*otp_init_t) (si_t * sih);
+typedef uint16(*otp_read_bit_t) (void *oh, chipcregs_t * cc, uint off);
+typedef int (*otp_read_region_t) (si_t * sih, int region, uint16 * data,
+				  uint * wlen);
+typedef int (*otp_nvread_t) (void *oh, char *data, uint * len);
+
+/* OTP function struct */
+typedef struct otp_fn_s {
+	otp_size_t size;
+	otp_read_bit_t read_bit;
+	otp_init_t init;
+	otp_read_region_t read_region;
+	otp_nvread_t nvread;
+	otp_status_t status;
+} otp_fn_t;
+
+typedef struct {
+	uint ccrev;		/* chipc revision */
+	otp_fn_t *fn;		/* OTP functions */
+	si_t *sih;		/* Saved sb handle */
+	osl_t *osh;
+
+#ifdef BCMIPXOTP
+	/* IPX OTP section */
+	uint16 wsize;		/* Size of otp in words */
+	uint16 rows;		/* Geometry */
+	uint16 cols;		/* Geometry */
+	uint32 status;		/* Flag bits (lock/prog/rv).
+				 * (Reflected only when OTP is power cycled)
+				 */
+	uint16 hwbase;		/* hardware subregion offset */
+	uint16 hwlim;		/* hardware subregion boundary */
+	uint16 swbase;		/* software subregion offset */
+	uint16 swlim;		/* software subregion boundary */
+	uint16 fbase;		/* fuse subregion offset */
+	uint16 flim;		/* fuse subregion boundary */
+	int otpgu_base;		/* offset to General Use Region */
+#endif				/* BCMIPXOTP */
+
+#ifdef BCMHNDOTP
+	/* HND OTP section */
+	uint size;		/* Size of otp in bytes */
+	uint hwprot;		/* Hardware protection bits */
+	uint signvalid;		/* Signature valid bits */
+	int boundary;		/* hw/sw boundary */
+#endif				/* BCMHNDOTP */
+} otpinfo_t;
+
+static otpinfo_t otpinfo;
+
+/*
+ * IPX OTP Code
+ *
+ *   Exported functions:
+ *	ipxotp_status()
+ *	ipxotp_size()
+ *	ipxotp_init()
+ *	ipxotp_read_bit()
+ *	ipxotp_read_region()
+ *	ipxotp_nvread()
+ *
+ */
+
+#ifdef BCMIPXOTP
+
+#define HWSW_RGN(rgn)		(((rgn) == OTP_HW_RGN) ? "h/w" : "s/w")
+
+/* OTP layout */
+/* CC revs 21, 24 and 27 OTP General Use Region word offset */
+#define REVA4_OTPGU_BASE	12
+
+/* CC revs 23, 25, 26, 28 and above OTP General Use Region word offset */
+#define REVB8_OTPGU_BASE	20
+
+/* CC rev 36 OTP General Use Region word offset */
+#define REV36_OTPGU_BASE	12
+
+/* Subregion word offsets in General Use region */
+#define OTPGU_HSB_OFF		0
+#define OTPGU_SFB_OFF		1
+#define OTPGU_CI_OFF		2
+#define OTPGU_P_OFF		3
+#define OTPGU_SROM_OFF		4
+
+/* Flag bit offsets in General Use region  */
+#define OTPGU_HWP_OFF		60
+#define OTPGU_SWP_OFF		61
+#define OTPGU_CIP_OFF		62
+#define OTPGU_FUSEP_OFF		63
+#define OTPGU_CIP_MSK		0x4000
+#define OTPGU_P_MSK		0xf000
+#define OTPGU_P_SHIFT		(OTPGU_HWP_OFF % 16)
+
+/* OTP Size */
+#define OTP_SZ_FU_324		((ROUNDUP(324,8))/8)	/* 324 bits */
+#define OTP_SZ_FU_288		(288/8)	/* 288 bits */
+#define OTP_SZ_FU_216		(216/8)	/* 216 bits */
+#define OTP_SZ_FU_72		(72/8)	/* 72 bits */
+#define OTP_SZ_CHECKSUM		(16/8)	/* 16 bits */
+#define OTP4315_SWREG_SZ	178	/* 178 bytes */
+#define OTP_SZ_FU_144		(144/8)	/* 144 bits */
+
+static int ipxotp_status(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	return (int)(oi->status);
+}
+
+/* Return size in bytes */
+static int ipxotp_size(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	return (int)oi->wsize * 2;
+}
+
+static uint16 ipxotp_otpr(void *oh, chipcregs_t * cc, uint wn)
+{
+	otpinfo_t *oi;
+
+	oi = (otpinfo_t *) oh;
+
+	ASSERT(wn < oi->wsize);
+	ASSERT(cc != NULL);
+
+	return R_REG(oi->osh, &cc->sromotp[wn]);
+}
+
+static uint16 ipxotp_read_bit(void *oh, chipcregs_t * cc, uint off)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	uint k, row, col;
+	uint32 otpp, st;
+
+	row = off / oi->cols;
+	col = off % oi->cols;
+
+	otpp = OTPP_START_BUSY |
+	    ((OTPPOC_READ << OTPP_OC_SHIFT) & OTPP_OC_MASK) |
+	    ((row << OTPP_ROW_SHIFT) & OTPP_ROW_MASK) |
+	    ((col << OTPP_COL_SHIFT) & OTPP_COL_MASK);
+	W_REG(oi->osh, &cc->otpprog, otpp);
+
+	for (k = 0;
+	     ((st = R_REG(oi->osh, &cc->otpprog)) & OTPP_START_BUSY)
+	     && (k < OTPP_TRIES); k++) ;
+	if (k >= OTPP_TRIES) {
+		return 0xffff;
+	}
+	if (st & OTPP_READERR) {
+		return 0xffff;
+	}
+	st = (st & OTPP_VALUE_MASK) >> OTPP_VALUE_SHIFT;
+
+	return (int)st;
+}
+
+/* Calculate max HW/SW region byte size by substracting fuse region and checksum size,
+ * osizew is oi->wsize (OTP size - GU size) in words
+ */
+static int ipxotp_max_rgnsz(si_t * sih, int osizew)
+{
+	int ret = 0;
+
+	switch (CHIPID(sih->chip)) {
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+		ret = osizew * 2 - OTP_SZ_FU_72 - OTP_SZ_CHECKSUM;
+		break;
+	case BCM4313_CHIP_ID:
+		ret = osizew * 2 - OTP_SZ_FU_72 - OTP_SZ_CHECKSUM;
+		break;
+	default:
+		ASSERT(0);	/* Don't konw about this chip */
+	}
+
+	return ret;
+}
+
+static void BCMNMIATTACHFN(_ipxotp_init) (otpinfo_t * oi, chipcregs_t * cc) {
+	uint k;
+	uint32 otpp, st;
+
+	/* record word offset of General Use Region for various chipcommon revs */
+	if (oi->sih->ccrev == 21 || oi->sih->ccrev == 24
+	    || oi->sih->ccrev == 27) {
+		oi->otpgu_base = REVA4_OTPGU_BASE;
+	} else if (oi->sih->ccrev == 36) {
+		/* OTP size greater than equal to 2KB (128 words), otpgu_base is similar to rev23 */
+		if (oi->wsize >= 128)
+			oi->otpgu_base = REVB8_OTPGU_BASE;
+		else
+			oi->otpgu_base = REV36_OTPGU_BASE;
+	} else if (oi->sih->ccrev == 23 || oi->sih->ccrev >= 25) {
+		oi->otpgu_base = REVB8_OTPGU_BASE;
+	}
+
+	/* First issue an init command so the status is up to date */
+	otpp =
+	    OTPP_START_BUSY | ((OTPPOC_INIT << OTPP_OC_SHIFT) & OTPP_OC_MASK);
+
+	W_REG(oi->osh, &cc->otpprog, otpp);
+	for (k = 0;
+	     ((st = R_REG(oi->osh, &cc->otpprog)) & OTPP_START_BUSY)
+	     && (k < OTPP_TRIES); k++) ;
+	if (k >= OTPP_TRIES) {
+		return;
+	}
+
+	/* Read OTP lock bits and subregion programmed indication bits */
+	oi->status = R_REG(oi->osh, &cc->otpstatus);
+
+	if ((CHIPID(oi->sih->chip) == BCM43224_CHIP_ID)
+	    || (CHIPID(oi->sih->chip) == BCM43225_CHIP_ID)) {
+		uint32 p_bits;
+		p_bits =
+		    (ipxotp_otpr(oi, cc, oi->otpgu_base + OTPGU_P_OFF) &
+		     OTPGU_P_MSK)
+		    >> OTPGU_P_SHIFT;
+		oi->status |= (p_bits << OTPS_GUP_SHIFT);
+	}
+
+	/*
+	 * h/w region base and fuse region limit are fixed to the top and
+	 * the bottom of the general use region. Everything else can be flexible.
+	 */
+	oi->hwbase = oi->otpgu_base + OTPGU_SROM_OFF;
+	oi->hwlim = oi->wsize;
+	if (oi->status & OTPS_GUP_HW) {
+		oi->hwlim =
+		    ipxotp_otpr(oi, cc, oi->otpgu_base + OTPGU_HSB_OFF) / 16;
+		oi->swbase = oi->hwlim;
+	} else
+		oi->swbase = oi->hwbase;
+
+	/* subtract fuse and checksum from beginning */
+	oi->swlim = ipxotp_max_rgnsz(oi->sih, oi->wsize) / 2;
+
+	if (oi->status & OTPS_GUP_SW) {
+		oi->swlim =
+		    ipxotp_otpr(oi, cc, oi->otpgu_base + OTPGU_SFB_OFF) / 16;
+		oi->fbase = oi->swlim;
+	} else
+		oi->fbase = oi->swbase;
+
+	oi->flim = oi->wsize;
+}
+
+static void *BCMNMIATTACHFN(ipxotp_init) (si_t * sih) {
+	uint idx;
+	chipcregs_t *cc;
+	otpinfo_t *oi;
+
+	/* Make sure we're running IPX OTP */
+	ASSERT(OTPTYPE_IPX(sih->ccrev));
+	if (!OTPTYPE_IPX(sih->ccrev))
+		return NULL;
+
+	/* Make sure OTP is not disabled */
+	if (si_is_otp_disabled(sih)) {
+		return NULL;
+	}
+
+	/* Make sure OTP is powered up */
+	if (!si_is_otp_powered(sih)) {
+		return NULL;
+	}
+
+	oi = &otpinfo;
+
+	/* Check for otp size */
+	switch ((sih->cccaps & CC_CAP_OTPSIZE) >> CC_CAP_OTPSIZE_SHIFT) {
+	case 0:
+		/* Nothing there */
+		return NULL;
+	case 1:		/* 32x64 */
+		oi->rows = 32;
+		oi->cols = 64;
+		oi->wsize = 128;
+		break;
+	case 2:		/* 64x64 */
+		oi->rows = 64;
+		oi->cols = 64;
+		oi->wsize = 256;
+		break;
+	case 5:		/* 96x64 */
+		oi->rows = 96;
+		oi->cols = 64;
+		oi->wsize = 384;
+		break;
+	case 7:		/* 16x64 *//* 1024 bits */
+		oi->rows = 16;
+		oi->cols = 64;
+		oi->wsize = 64;
+		break;
+	default:
+		/* Don't know the geometry */
+		return NULL;
+	}
+
+	/* Retrieve OTP region info */
+	idx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	_ipxotp_init(oi, cc);
+
+	si_setcoreidx(sih, idx);
+
+	return (void *)oi;
+}
+
+static int ipxotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	uint idx;
+	chipcregs_t *cc;
+	uint base, i, sz;
+
+	/* Validate region selection */
+	switch (region) {
+	case OTP_HW_RGN:
+		sz = (uint) oi->hwlim - oi->hwbase;
+		if (!(oi->status & OTPS_GUP_HW)) {
+			*wlen = sz;
+			return BCME_NOTFOUND;
+		}
+		if (*wlen < sz) {
+			*wlen = sz;
+			return BCME_BUFTOOSHORT;
+		}
+		base = oi->hwbase;
+		break;
+	case OTP_SW_RGN:
+		sz = ((uint) oi->swlim - oi->swbase);
+		if (!(oi->status & OTPS_GUP_SW)) {
+			*wlen = sz;
+			return BCME_NOTFOUND;
+		}
+		if (*wlen < sz) {
+			*wlen = sz;
+			return BCME_BUFTOOSHORT;
+		}
+		base = oi->swbase;
+		break;
+	case OTP_CI_RGN:
+		sz = OTPGU_CI_SZ;
+		if (!(oi->status & OTPS_GUP_CI)) {
+			*wlen = sz;
+			return BCME_NOTFOUND;
+		}
+		if (*wlen < sz) {
+			*wlen = sz;
+			return BCME_BUFTOOSHORT;
+		}
+		base = oi->otpgu_base + OTPGU_CI_OFF;
+		break;
+	case OTP_FUSE_RGN:
+		sz = (uint) oi->flim - oi->fbase;
+		if (!(oi->status & OTPS_GUP_FUSE)) {
+			*wlen = sz;
+			return BCME_NOTFOUND;
+		}
+		if (*wlen < sz) {
+			*wlen = sz;
+			return BCME_BUFTOOSHORT;
+		}
+		base = oi->fbase;
+		break;
+	case OTP_ALL_RGN:
+		sz = ((uint) oi->flim - oi->hwbase);
+		if (!(oi->status & (OTPS_GUP_HW | OTPS_GUP_SW))) {
+			*wlen = sz;
+			return BCME_NOTFOUND;
+		}
+		if (*wlen < sz) {
+			*wlen = sz;
+			return BCME_BUFTOOSHORT;
+		}
+		base = oi->hwbase;
+		break;
+	default:
+		return BCME_BADARG;
+	}
+
+	idx = si_coreidx(oi->sih);
+	cc = si_setcoreidx(oi->sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	/* Read the data */
+	for (i = 0; i < sz; i++)
+		data[i] = ipxotp_otpr(oh, cc, base + i);
+
+	si_setcoreidx(oi->sih, idx);
+	*wlen = sz;
+	return 0;
+}
+
+static int ipxotp_nvread(void *oh, char *data, uint * len)
+{
+	return BCME_UNSUPPORTED;
+}
+
+static otp_fn_t ipxotp_fn = {
+	(otp_size_t) ipxotp_size,
+	(otp_read_bit_t) ipxotp_read_bit,
+
+	(otp_init_t) ipxotp_init,
+	(otp_read_region_t) ipxotp_read_region,
+	(otp_nvread_t) ipxotp_nvread,
+
+	(otp_status_t) ipxotp_status
+};
+
+#endif				/* BCMIPXOTP */
+
+/*
+ * HND OTP Code
+ *
+ *   Exported functions:
+ *	hndotp_status()
+ *	hndotp_size()
+ *	hndotp_init()
+ *	hndotp_read_bit()
+ *	hndotp_read_region()
+ *	hndotp_nvread()
+ *
+ */
+
+#ifdef BCMHNDOTP
+
+/* Fields in otpstatus */
+#define	OTPS_PROGFAIL		0x80000000
+#define	OTPS_PROTECT		0x00000007
+#define	OTPS_HW_PROTECT		0x00000001
+#define	OTPS_SW_PROTECT		0x00000002
+#define	OTPS_CID_PROTECT	0x00000004
+#define	OTPS_RCEV_MSK		0x00003f00
+#define	OTPS_RCEV_SHIFT		8
+
+/* Fields in the otpcontrol register */
+#define	OTPC_RECWAIT		0xff000000
+#define	OTPC_PROGWAIT		0x00ffff00
+#define	OTPC_PRW_SHIFT		8
+#define	OTPC_MAXFAIL		0x00000038
+#define	OTPC_VSEL		0x00000006
+#define	OTPC_SELVL		0x00000001
+
+/* OTP regions (Word offsets from otp size) */
+#define	OTP_SWLIM_OFF	(-4)
+#define	OTP_CIDBASE_OFF	0
+#define	OTP_CIDLIM_OFF	4
+
+/* Predefined OTP words (Word offset from otp size) */
+#define	OTP_BOUNDARY_OFF (-4)
+#define	OTP_HWSIGN_OFF	(-3)
+#define	OTP_SWSIGN_OFF	(-2)
+#define	OTP_CIDSIGN_OFF	(-1)
+#define	OTP_CID_OFF	0
+#define	OTP_PKG_OFF	1
+#define	OTP_FID_OFF	2
+#define	OTP_RSV_OFF	3
+#define	OTP_LIM_OFF	4
+#define	OTP_RD_OFF	4	/* Redundancy row starts here */
+#define	OTP_RC0_OFF	28	/* Redundancy control word 1 */
+#define	OTP_RC1_OFF	32	/* Redundancy control word 2 */
+#define	OTP_RC_LIM_OFF	36	/* Redundancy control word end */
+
+#define	OTP_HW_REGION	OTPS_HW_PROTECT
+#define	OTP_SW_REGION	OTPS_SW_PROTECT
+#define	OTP_CID_REGION	OTPS_CID_PROTECT
+
+#if OTP_HW_REGION != OTP_HW_RGN
+#error "incompatible OTP_HW_RGN"
+#endif
+#if OTP_SW_REGION != OTP_SW_RGN
+#error "incompatible OTP_SW_RGN"
+#endif
+#if OTP_CID_REGION != OTP_CI_RGN
+#error "incompatible OTP_CI_RGN"
+#endif
+
+/* Redundancy entry definitions */
+#define	OTP_RCE_ROW_SZ		6
+#define	OTP_RCE_SIGN_MASK	0x7fff
+#define	OTP_RCE_ROW_MASK	0x3f
+#define	OTP_RCE_BITS		21
+#define	OTP_RCE_SIGN_SZ		15
+#define	OTP_RCE_BIT0		1
+
+#define	OTP_WPR		4
+#define	OTP_SIGNATURE	0x578a
+#define	OTP_MAGIC	0x4e56
+
+static int hndotp_status(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	return ((int)(oi->hwprot | oi->signvalid));
+}
+
+static int hndotp_size(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	return ((int)(oi->size));
+}
+
+static uint16 hndotp_otpr(void *oh, chipcregs_t * cc, uint wn)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	osl_t *osh;
+	volatile uint16 *ptr;
+
+	ASSERT(wn < ((oi->size / 2) + OTP_RC_LIM_OFF));
+	ASSERT(cc != NULL);
+
+	osh = si_osh(oi->sih);
+
+	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
+	return (R_REG(osh, &ptr[wn]));
+}
+
+static uint16 hndotp_otproff(void *oh, chipcregs_t * cc, int woff)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	osl_t *osh;
+	volatile uint16 *ptr;
+
+	ASSERT(woff >= (-((int)oi->size / 2)));
+	ASSERT(woff < OTP_LIM_OFF);
+	ASSERT(cc != NULL);
+
+	osh = si_osh(oi->sih);
+
+	ptr = (volatile uint16 *)((volatile char *)cc + CC_SROM_OTP);
+
+	return (R_REG(osh, &ptr[(oi->size / 2) + woff]));
+}
+
+static uint16 hndotp_read_bit(void *oh, chipcregs_t * cc, uint idx)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	uint k, row, col;
+	uint32 otpp, st;
+	osl_t *osh;
+
+	osh = si_osh(oi->sih);
+	row = idx / 65;
+	col = idx % 65;
+
+	otpp = OTPP_START_BUSY | OTPP_READ |
+	    ((row << OTPP_ROW_SHIFT) & OTPP_ROW_MASK) | (col & OTPP_COL_MASK);
+
+	W_REG(osh, &cc->otpprog, otpp);
+	st = R_REG(osh, &cc->otpprog);
+	for (k = 0;
+	     ((st & OTPP_START_BUSY) == OTPP_START_BUSY) && (k < OTPP_TRIES);
+	     k++)
+		st = R_REG(osh, &cc->otpprog);
+
+	if (k >= OTPP_TRIES) {
+		return 0xffff;
+	}
+	if (st & OTPP_READERR) {
+		return 0xffff;
+	}
+	st = (st & OTPP_VALUE_MASK) >> OTPP_VALUE_SHIFT;
+	return (uint16) st;
+}
+
+static void *BCMNMIATTACHFN(hndotp_init) (si_t * sih) {
+	uint idx;
+	chipcregs_t *cc;
+	otpinfo_t *oi;
+	uint32 cap = 0, clkdiv, otpdiv = 0;
+	void *ret = NULL;
+	osl_t *osh;
+
+	oi = &otpinfo;
+
+	idx = si_coreidx(sih);
+	osh = si_osh(oi->sih);
+
+	/* Check for otp */
+	if ((cc = si_setcoreidx(sih, SI_CC_IDX)) != NULL) {
+		cap = R_REG(osh, &cc->capabilities);
+		if ((cap & CC_CAP_OTPSIZE) == 0) {
+			/* Nothing there */
+			goto out;
+		}
+
+		/* As of right now, support only 4320a2, 4311a1 and 4312 */
+		ASSERT((oi->ccrev == 12) || (oi->ccrev == 17)
+		       || (oi->ccrev == 22));
+		if (!
+		    ((oi->ccrev == 12) || (oi->ccrev == 17)
+		     || (oi->ccrev == 22)))
+			return NULL;
+
+		/* Read the OTP byte size. chipcommon rev >= 18 has RCE so the size is
+		 * 8 row (64 bytes) smaller
+		 */
+		oi->size =
+		    1 << (((cap & CC_CAP_OTPSIZE) >> CC_CAP_OTPSIZE_SHIFT)
+			  + CC_CAP_OTPSIZE_BASE);
+		if (oi->ccrev >= 18)
+			oi->size -= ((OTP_RC0_OFF - OTP_BOUNDARY_OFF) * 2);
+
+		oi->hwprot = (int)(R_REG(osh, &cc->otpstatus) & OTPS_PROTECT);
+		oi->boundary = -1;
+
+		/* Check the region signature */
+		if (hndotp_otproff(oi, cc, OTP_HWSIGN_OFF) == OTP_SIGNATURE) {
+			oi->signvalid |= OTP_HW_REGION;
+			oi->boundary = hndotp_otproff(oi, cc, OTP_BOUNDARY_OFF);
+		}
+
+		if (hndotp_otproff(oi, cc, OTP_SWSIGN_OFF) == OTP_SIGNATURE)
+			oi->signvalid |= OTP_SW_REGION;
+
+		if (hndotp_otproff(oi, cc, OTP_CIDSIGN_OFF) == OTP_SIGNATURE)
+			oi->signvalid |= OTP_CID_REGION;
+
+		/* Set OTP clkdiv for stability */
+		if (oi->ccrev == 22)
+			otpdiv = 12;
+
+		if (otpdiv) {
+			clkdiv = R_REG(osh, &cc->clkdiv);
+			clkdiv =
+			    (clkdiv & ~CLKD_OTP) | (otpdiv << CLKD_OTP_SHIFT);
+			W_REG(osh, &cc->clkdiv, clkdiv);
+		}
+		OSL_DELAY(10);
+
+		ret = (void *)oi;
+	}
+
+ out:				/* All done */
+	si_setcoreidx(sih, idx);
+
+	return ret;
+}
+
+static int hndotp_read_region(void *oh, int region, uint16 * data, uint * wlen)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	uint32 idx, st;
+	chipcregs_t *cc;
+	int i;
+
+	/* Only support HW region (no active chips use HND OTP SW region) */
+	ASSERT(region == OTP_HW_REGION);
+
+	/* Region empty? */
+	st = oi->hwprot | oi->signvalid;
+	if ((st & region) == 0)
+		return BCME_NOTFOUND;
+
+	*wlen =
+	    ((int)*wlen < oi->boundary / 2) ? *wlen : (uint) oi->boundary / 2;
+
+	idx = si_coreidx(oi->sih);
+	cc = si_setcoreidx(oi->sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	for (i = 0; i < (int)*wlen; i++)
+		data[i] = hndotp_otpr(oh, cc, i);
+
+	si_setcoreidx(oi->sih, idx);
+
+	return 0;
+}
+
+static int hndotp_nvread(void *oh, char *data, uint * len)
+{
+	int rc = 0;
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	uint32 base, bound, lim = 0, st;
+	int i, chunk, gchunks, tsz = 0;
+	uint32 idx;
+	chipcregs_t *cc;
+	uint offset;
+	uint16 *rawotp = NULL;
+
+	/* save the orig core */
+	idx = si_coreidx(oi->sih);
+	cc = si_setcoreidx(oi->sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	st = hndotp_status(oh);
+	if (!(st & (OTP_HW_REGION | OTP_SW_REGION))) {
+		rc = -1;
+		goto out;
+	}
+
+	/* Read the whole otp so we can easily manipulate it */
+	lim = hndotp_size(oh);
+	if ((rawotp = MALLOC(si_osh(oi->sih), lim)) == NULL) {
+		rc = -2;
+		goto out;
+	}
+	for (i = 0; i < (int)(lim / 2); i++)
+		rawotp[i] = hndotp_otpr(oh, cc, i);
+
+	if ((st & OTP_HW_REGION) == 0) {
+		/* This could be a programming failure in the first
+		 * chunk followed by one or more good chunks
+		 */
+		for (i = 0; i < (int)(lim / 2); i++)
+			if (rawotp[i] == OTP_MAGIC)
+				break;
+
+		if (i < (int)(lim / 2)) {
+			base = i;
+			bound = (i * 2) + rawotp[i + 1];
+		} else {
+			rc = -3;
+			goto out;
+		}
+	} else {
+		bound = rawotp[(lim / 2) + OTP_BOUNDARY_OFF];
+
+		/* There are two cases: 1) The whole otp is used as nvram
+		 * and 2) There is a hardware header followed by nvram.
+		 */
+		if (rawotp[0] == OTP_MAGIC) {
+			base = 0;
+		} else
+			base = bound;
+	}
+
+	/* Find and copy the data */
+
+	chunk = 0;
+	gchunks = 0;
+	i = base / 2;
+	offset = 0;
+	while ((i < (int)(lim / 2)) && (rawotp[i] == OTP_MAGIC)) {
+		int dsz, rsz = rawotp[i + 1];
+
+		if (((i * 2) + rsz) >= (int)lim) {
+			/* Bad length, try to find another chunk anyway */
+			rsz = 6;
+		}
+		if (hndcrc16((uint8 *) & rawotp[i], rsz,
+			     CRC16_INIT_VALUE) == CRC16_GOOD_VALUE) {
+			/* Good crc, copy the vars */
+			gchunks++;
+			dsz = rsz - 6;
+			tsz += dsz;
+			if (offset + dsz >= *len) {
+				goto out;
+			}
+			bcopy((char *)&rawotp[i + 2], &data[offset], dsz);
+			offset += dsz;
+			/* Remove extra null characters at the end */
+			while (offset > 1 &&
+			       data[offset - 1] == 0 && data[offset - 2] == 0)
+				offset--;
+			i += rsz / 2;
+		} else {
+			/* bad length or crc didn't check, try to find the next set */
+			if (rawotp[i + (rsz / 2)] == OTP_MAGIC) {
+				/* Assume length is good */
+				i += rsz / 2;
+			} else {
+				while (++i < (int)(lim / 2))
+					if (rawotp[i] == OTP_MAGIC)
+						break;
+			}
+		}
+		chunk++;
+	}
+
+	*len = offset;
+
+ out:
+	if (rawotp)
+		MFREE(si_osh(oi->sih), rawotp, lim);
+	si_setcoreidx(oi->sih, idx);
+
+	return rc;
+}
+
+static otp_fn_t hndotp_fn = {
+	(otp_size_t) hndotp_size,
+	(otp_read_bit_t) hndotp_read_bit,
+
+	(otp_init_t) hndotp_init,
+	(otp_read_region_t) hndotp_read_region,
+	(otp_nvread_t) hndotp_nvread,
+
+	(otp_status_t) hndotp_status
+};
+
+#endif				/* BCMHNDOTP */
+
+/*
+ * Common Code: Compiled for IPX / HND / AUTO
+ *	otp_status()
+ *	otp_size()
+ *	otp_read_bit()
+ *	otp_init()
+ * 	otp_read_region()
+ * 	otp_nvread()
+ */
+
+int otp_status(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+
+	return oi->fn->status(oh);
+}
+
+int otp_size(void *oh)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+
+	return oi->fn->size(oh);
+}
+
+uint16 otp_read_bit(void *oh, uint offset)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+	uint idx = si_coreidx(oi->sih);
+	chipcregs_t *cc = si_setcoreidx(oi->sih, SI_CC_IDX);
+	uint16 readBit = (uint16) oi->fn->read_bit(oh, cc, offset);
+	si_setcoreidx(oi->sih, idx);
+	return readBit;
+}
+
+void *BCMNMIATTACHFN(otp_init) (si_t * sih) {
+	otpinfo_t *oi;
+	void *ret = NULL;
+
+	oi = &otpinfo;
+	bzero(oi, sizeof(otpinfo_t));
+
+	oi->ccrev = sih->ccrev;
+
+#ifdef BCMIPXOTP
+	if (OTPTYPE_IPX(oi->ccrev))
+		oi->fn = &ipxotp_fn;
+#endif
+
+#ifdef BCMHNDOTP
+	if (OTPTYPE_HND(oi->ccrev))
+		oi->fn = &hndotp_fn;
+#endif
+
+	if (oi->fn == NULL) {
+		return NULL;
+	}
+
+	oi->sih = sih;
+	oi->osh = si_osh(oi->sih);
+
+	ret = (oi->fn->init) (sih);
+
+	return ret;
+}
+
+int
+BCMNMIATTACHFN(otp_read_region) (si_t * sih, int region, uint16 * data,
+				 uint * wlen) {
+	bool wasup = FALSE;
+	void *oh;
+	int err = 0;
+
+	if (!(wasup = si_is_otp_powered(sih)))
+		si_otp_power(sih, TRUE);
+
+	if (!si_is_otp_powered(sih) || si_is_otp_disabled(sih)) {
+		err = BCME_NOTREADY;
+		goto out;
+	}
+
+	oh = otp_init(sih);
+	if (oh == NULL) {
+		err = BCME_ERROR;
+		goto out;
+	}
+
+	err = (((otpinfo_t *) oh)->fn->read_region) (oh, region, data, wlen);
+
+ out:
+	if (!wasup)
+		si_otp_power(sih, FALSE);
+
+	return err;
+}
+
+int otp_nvread(void *oh, char *data, uint * len)
+{
+	otpinfo_t *oi = (otpinfo_t *) oh;
+
+	return oi->fn->nvread(oh, data, len);
+}
diff --git a/drivers/staging/brcm80211/util/bcmsrom.c b/drivers/staging/brcm80211/util/bcmsrom.c
new file mode 100644
index 0000000..d5527f7
--- /dev/null
+++ b/drivers/staging/brcm80211/util/bcmsrom.c
@@ -0,0 +1,2081 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <stdarg.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <bcmdevs.h>
+#include <bcmendian.h>
+#include <pcicfg.h>
+#include <siutils.h>
+#include <bcmsrom.h>
+#include <bcmsrom_tbl.h>
+#ifdef BCMSDIO
+#include <bcmsdh.h>
+#include <sdio.h>
+#endif
+
+#include <bcmnvram.h>
+#include <bcmotp.h>
+
+#if defined(BCMSDIO)
+#include <sbsdio.h>
+#include <sbhnddma.h>
+#include <sbsdpcmdev.h>
+#endif
+
+#include <proto/ethernet.h>	/* for sprom content groking */
+
+#define	BS_ERROR(args)
+
+#define SROM_OFFSET(sih) ((sih->ccrev > 31) ? \
+	(((sih->cccaps & CC_CAP_SROM) == 0) ? NULL : \
+	 ((uint8 *)curmap + PCI_16KB0_CCREGS_OFFSET + CC_SROM_OTP)) : \
+	((uint8 *)curmap + PCI_BAR0_SPROM_OFFSET))
+
+#if defined(BCMDBG)
+#define WRITE_ENABLE_DELAY	500	/* 500 ms after write enable/disable toggle */
+#define WRITE_WORD_DELAY	20	/* 20 ms between each word write */
+#endif
+
+typedef struct varbuf {
+	char *base;		/* pointer to buffer base */
+	char *buf;		/* pointer to current position */
+	unsigned int size;	/* current (residual) size in bytes */
+} varbuf_t;
+extern char *_vars;
+extern uint _varsz;
+
+#define SROM_CIS_SINGLE	1
+
+static int initvars_srom_si(si_t * sih, osl_t * osh, void *curmap, char **vars,
+			    uint * count);
+static void _initvars_srom_pci(uint8 sromrev, uint16 * srom, uint off,
+			       varbuf_t * b);
+static int initvars_srom_pci(si_t * sih, void *curmap, char **vars,
+			     uint * count);
+static int initvars_flash_si(si_t * sih, char **vars, uint * count);
+#ifdef BCMSDIO
+static int initvars_cis_sdio(osl_t * osh, char **vars, uint * count);
+static int sprom_cmd_sdio(osl_t * osh, uint8 cmd);
+static int sprom_read_sdio(osl_t * osh, uint16 addr, uint16 * data);
+#endif				/* BCMSDIO */
+static int sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
+			  uint16 * buf, uint nwords, bool check_crc);
+#if defined(BCMNVRAMR)
+static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz);
+#endif
+static uint16 srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd,
+			  uint wordoff, uint16 data);
+
+static int initvars_table(osl_t * osh, char *start, char *end, char **vars,
+			  uint * count);
+static int initvars_flash(si_t * sih, osl_t * osh, char **vp, uint len);
+
+/* Initialization of varbuf structure */
+static void BCMATTACHFN(varbuf_init) (varbuf_t * b, char *buf, uint size) {
+	b->size = size;
+	b->base = b->buf = buf;
+}
+
+/* append a null terminated var=value string */
+static int BCMATTACHFN(varbuf_append) (varbuf_t * b, const char *fmt, ...) {
+	va_list ap;
+	int r;
+	size_t len;
+	char *s;
+
+	if (b->size < 2)
+		return 0;
+
+	va_start(ap, fmt);
+	r = vsnprintf(b->buf, b->size, fmt, ap);
+	va_end(ap);
+
+	/* C99 snprintf behavior returns r >= size on overflow,
+	 * others return -1 on overflow.
+	 * All return -1 on format error.
+	 * We need to leave room for 2 null terminations, one for the current var
+	 * string, and one for final null of the var table. So check that the
+	 * strlen written, r, leaves room for 2 chars.
+	 */
+	if ((r == -1) || (r > (int)(b->size - 2))) {
+		b->size = 0;
+		return 0;
+	}
+
+	/* Remove any earlier occurrence of the same variable */
+	if ((s = strchr(b->buf, '=')) != NULL) {
+		len = (size_t) (s - b->buf);
+		for (s = b->base; s < b->buf;) {
+			if ((bcmp(s, b->buf, len) == 0) && s[len] == '=') {
+				len = strlen(s) + 1;
+				memmove(s, (s + len),
+					((b->buf + r + 1) - (s + len)));
+				b->buf -= len;
+				b->size += (unsigned int)len;
+				break;
+			}
+
+			while (*s++) ;
+		}
+	}
+
+	/* skip over this string's null termination */
+	r++;
+	b->size -= r;
+	b->buf += r;
+
+	return r;
+}
+
+/*
+ * Initialize local vars from the right source for this platform.
+ * Return 0 on success, nonzero on error.
+ */
+int
+BCMATTACHFN(srom_var_init) (si_t * sih, uint bustype, void *curmap, osl_t * osh,
+			    char **vars, uint * count) {
+	uint len;
+
+	len = 0;
+
+	ASSERT(bustype == BUSTYPE(bustype));
+	if (vars == NULL || count == NULL)
+		return (0);
+
+	*vars = NULL;
+	*count = 0;
+
+	switch (BUSTYPE(bustype)) {
+	case SI_BUS:
+	case JTAG_BUS:
+		return initvars_srom_si(sih, osh, curmap, vars, count);
+
+	case PCI_BUS:
+		ASSERT(curmap != NULL);
+		if (curmap == NULL)
+			return (-1);
+
+		return initvars_srom_pci(sih, curmap, vars, count);
+
+#ifdef BCMSDIO
+	case SDIO_BUS:
+		return initvars_cis_sdio(osh, vars, count);
+#endif				/* BCMSDIO */
+
+	default:
+		ASSERT(0);
+	}
+	return (-1);
+}
+
+/* support only 16-bit word read from srom */
+int
+srom_read(si_t * sih, uint bustype, void *curmap, osl_t * osh,
+	  uint byteoff, uint nbytes, uint16 * buf, bool check_crc)
+{
+	uint off, nw;
+#ifdef BCMSDIO
+	uint i;
+#endif				/* BCMSDIO */
+
+	ASSERT(bustype == BUSTYPE(bustype));
+
+	/* check input - 16-bit access only */
+	if (byteoff & 1 || nbytes & 1 || (byteoff + nbytes) > SROM_MAX)
+		return 1;
+
+	off = byteoff / 2;
+	nw = nbytes / 2;
+
+	if (BUSTYPE(bustype) == PCI_BUS) {
+		if (!curmap)
+			return 1;
+
+		if (si_is_sprom_available(sih)) {
+			uint16 *srom;
+
+			srom = (uint16 *) SROM_OFFSET(sih);
+			if (srom == NULL)
+				return 1;
+
+			if (sprom_read_pci
+			    (osh, sih, srom, off, buf, nw, check_crc))
+				return 1;
+		}
+#if defined(BCMNVRAMR)
+		else {
+			if (otp_read_pci(osh, sih, buf, SROM_MAX))
+				return 1;
+		}
+#endif
+#ifdef BCMSDIO
+	} else if (BUSTYPE(bustype) == SDIO_BUS) {
+		off = byteoff / 2;
+		nw = nbytes / 2;
+		for (i = 0; i < nw; i++) {
+			if (sprom_read_sdio
+			    (osh, (uint16) (off + i), (uint16 *) (buf + i)))
+				return 1;
+		}
+#endif				/* BCMSDIO */
+	} else if (BUSTYPE(bustype) == SI_BUS) {
+		return 1;
+	} else {
+		return 1;
+	}
+
+	return 0;
+}
+
+static const char BCMATTACHDATA(vstr_manf)[] = "manf=%s";
+static const char BCMATTACHDATA(vstr_productname)[] = "productname=%s";
+static const char BCMATTACHDATA(vstr_manfid)[] = "manfid=0x%x";
+static const char BCMATTACHDATA(vstr_prodid)[] = "prodid=0x%x";
+#ifdef BCMSDIO
+static const char BCMATTACHDATA(vstr_sdmaxspeed)[] = "sdmaxspeed=%d";
+static const char BCMATTACHDATA(vstr_sdmaxblk)[][13] =
+{
+"sdmaxblk0=%d", "sdmaxblk1=%d", "sdmaxblk2=%d"};
+#endif
+static const char BCMATTACHDATA(vstr_regwindowsz)[] = "regwindowsz=%d";
+static const char BCMATTACHDATA(vstr_sromrev)[] = "sromrev=%d";
+static const char BCMATTACHDATA(vstr_chiprev)[] = "chiprev=%d";
+static const char BCMATTACHDATA(vstr_subvendid)[] = "subvendid=0x%x";
+static const char BCMATTACHDATA(vstr_subdevid)[] = "subdevid=0x%x";
+static const char BCMATTACHDATA(vstr_boardrev)[] = "boardrev=0x%x";
+static const char BCMATTACHDATA(vstr_aa2g)[] = "aa2g=0x%x";
+static const char BCMATTACHDATA(vstr_aa5g)[] = "aa5g=0x%x";
+static const char BCMATTACHDATA(vstr_ag)[] = "ag%d=0x%x";
+static const char BCMATTACHDATA(vstr_cc)[] = "cc=%d";
+static const char BCMATTACHDATA(vstr_opo)[] = "opo=%d";
+static const char BCMATTACHDATA(vstr_pa0b)[][9] =
+{
+"pa0b0=%d", "pa0b1=%d", "pa0b2=%d"};
+
+static const char BCMATTACHDATA(vstr_pa0itssit)[] = "pa0itssit=%d";
+static const char BCMATTACHDATA(vstr_pa0maxpwr)[] = "pa0maxpwr=%d";
+static const char BCMATTACHDATA(vstr_pa1b)[][9] =
+{
+"pa1b0=%d", "pa1b1=%d", "pa1b2=%d"};
+
+static const char BCMATTACHDATA(vstr_pa1lob)[][11] =
+{
+"pa1lob0=%d", "pa1lob1=%d", "pa1lob2=%d"};
+
+static const char BCMATTACHDATA(vstr_pa1hib)[][11] =
+{
+"pa1hib0=%d", "pa1hib1=%d", "pa1hib2=%d"};
+
+static const char BCMATTACHDATA(vstr_pa1itssit)[] = "pa1itssit=%d";
+static const char BCMATTACHDATA(vstr_pa1maxpwr)[] = "pa1maxpwr=%d";
+static const char BCMATTACHDATA(vstr_pa1lomaxpwr)[] = "pa1lomaxpwr=%d";
+static const char BCMATTACHDATA(vstr_pa1himaxpwr)[] = "pa1himaxpwr=%d";
+static const char BCMATTACHDATA(vstr_oem)[] =
+    "oem=%02x%02x%02x%02x%02x%02x%02x%02x";
+static const char BCMATTACHDATA(vstr_boardflags)[] = "boardflags=0x%x";
+static const char BCMATTACHDATA(vstr_boardflags2)[] = "boardflags2=0x%x";
+static const char BCMATTACHDATA(vstr_ledbh)[] = "ledbh%d=0x%x";
+static const char BCMATTACHDATA(vstr_noccode)[] = "ccode=0x0";
+static const char BCMATTACHDATA(vstr_ccode)[] = "ccode=%c%c";
+static const char BCMATTACHDATA(vstr_cctl)[] = "cctl=0x%x";
+static const char BCMATTACHDATA(vstr_cckpo)[] = "cckpo=0x%x";
+static const char BCMATTACHDATA(vstr_ofdmpo)[] = "ofdmpo=0x%x";
+static const char BCMATTACHDATA(vstr_rdlid)[] = "rdlid=0x%x";
+static const char BCMATTACHDATA(vstr_rdlrndis)[] = "rdlrndis=%d";
+static const char BCMATTACHDATA(vstr_rdlrwu)[] = "rdlrwu=%d";
+static const char BCMATTACHDATA(vstr_usbfs)[] = "usbfs=%d";
+static const char BCMATTACHDATA(vstr_wpsgpio)[] = "wpsgpio=%d";
+static const char BCMATTACHDATA(vstr_wpsled)[] = "wpsled=%d";
+static const char BCMATTACHDATA(vstr_rdlsn)[] = "rdlsn=%d";
+static const char BCMATTACHDATA(vstr_rssismf2g)[] = "rssismf2g=%d";
+static const char BCMATTACHDATA(vstr_rssismc2g)[] = "rssismc2g=%d";
+static const char BCMATTACHDATA(vstr_rssisav2g)[] = "rssisav2g=%d";
+static const char BCMATTACHDATA(vstr_bxa2g)[] = "bxa2g=%d";
+static const char BCMATTACHDATA(vstr_rssismf5g)[] = "rssismf5g=%d";
+static const char BCMATTACHDATA(vstr_rssismc5g)[] = "rssismc5g=%d";
+static const char BCMATTACHDATA(vstr_rssisav5g)[] = "rssisav5g=%d";
+static const char BCMATTACHDATA(vstr_bxa5g)[] = "bxa5g=%d";
+static const char BCMATTACHDATA(vstr_tri2g)[] = "tri2g=%d";
+static const char BCMATTACHDATA(vstr_tri5gl)[] = "tri5gl=%d";
+static const char BCMATTACHDATA(vstr_tri5g)[] = "tri5g=%d";
+static const char BCMATTACHDATA(vstr_tri5gh)[] = "tri5gh=%d";
+static const char BCMATTACHDATA(vstr_rxpo2g)[] = "rxpo2g=%d";
+static const char BCMATTACHDATA(vstr_rxpo5g)[] = "rxpo5g=%d";
+static const char BCMATTACHDATA(vstr_boardtype)[] = "boardtype=0x%x";
+static const char BCMATTACHDATA(vstr_leddc)[] = "leddc=0x%04x";
+static const char BCMATTACHDATA(vstr_vendid)[] = "vendid=0x%x";
+static const char BCMATTACHDATA(vstr_devid)[] = "devid=0x%x";
+static const char BCMATTACHDATA(vstr_xtalfreq)[] = "xtalfreq=%d";
+static const char BCMATTACHDATA(vstr_txchain)[] = "txchain=0x%x";
+static const char BCMATTACHDATA(vstr_rxchain)[] = "rxchain=0x%x";
+static const char BCMATTACHDATA(vstr_antswitch)[] = "antswitch=0x%x";
+static const char BCMATTACHDATA(vstr_regrev)[] = "regrev=0x%x";
+static const char BCMATTACHDATA(vstr_antswctl2g)[] = "antswctl2g=0x%x";
+static const char BCMATTACHDATA(vstr_triso2g)[] = "triso2g=0x%x";
+static const char BCMATTACHDATA(vstr_pdetrange2g)[] = "pdetrange2g=0x%x";
+static const char BCMATTACHDATA(vstr_extpagain2g)[] = "extpagain2g=0x%x";
+static const char BCMATTACHDATA(vstr_tssipos2g)[] = "tssipos2g=0x%x";
+static const char BCMATTACHDATA(vstr_antswctl5g)[] = "antswctl5g=0x%x";
+static const char BCMATTACHDATA(vstr_triso5g)[] = "triso5g=0x%x";
+static const char BCMATTACHDATA(vstr_pdetrange5g)[] = "pdetrange5g=0x%x";
+static const char BCMATTACHDATA(vstr_extpagain5g)[] = "extpagain5g=0x%x";
+static const char BCMATTACHDATA(vstr_tssipos5g)[] = "tssipos5g=0x%x";
+static const char BCMATTACHDATA(vstr_maxp2ga0)[] = "maxp2ga0=0x%x";
+static const char BCMATTACHDATA(vstr_itt2ga0)[] = "itt2ga0=0x%x";
+static const char BCMATTACHDATA(vstr_pa)[] = "pa%dgw%da%d=0x%x";
+static const char BCMATTACHDATA(vstr_pahl)[] = "pa%dg%cw%da%d=0x%x";
+static const char BCMATTACHDATA(vstr_maxp5ga0)[] = "maxp5ga0=0x%x";
+static const char BCMATTACHDATA(vstr_itt5ga0)[] = "itt5ga0=0x%x";
+static const char BCMATTACHDATA(vstr_maxp5gha0)[] = "maxp5gha0=0x%x";
+static const char BCMATTACHDATA(vstr_maxp5gla0)[] = "maxp5gla0=0x%x";
+static const char BCMATTACHDATA(vstr_maxp2ga1)[] = "maxp2ga1=0x%x";
+static const char BCMATTACHDATA(vstr_itt2ga1)[] = "itt2ga1=0x%x";
+static const char BCMATTACHDATA(vstr_maxp5ga1)[] = "maxp5ga1=0x%x";
+static const char BCMATTACHDATA(vstr_itt5ga1)[] = "itt5ga1=0x%x";
+static const char BCMATTACHDATA(vstr_maxp5gha1)[] = "maxp5gha1=0x%x";
+static const char BCMATTACHDATA(vstr_maxp5gla1)[] = "maxp5gla1=0x%x";
+static const char BCMATTACHDATA(vstr_cck2gpo)[] = "cck2gpo=0x%x";
+static const char BCMATTACHDATA(vstr_ofdm2gpo)[] = "ofdm2gpo=0x%x";
+static const char BCMATTACHDATA(vstr_ofdm5gpo)[] = "ofdm5gpo=0x%x";
+static const char BCMATTACHDATA(vstr_ofdm5glpo)[] = "ofdm5glpo=0x%x";
+static const char BCMATTACHDATA(vstr_ofdm5ghpo)[] = "ofdm5ghpo=0x%x";
+static const char BCMATTACHDATA(vstr_cddpo)[] = "cddpo=0x%x";
+static const char BCMATTACHDATA(vstr_stbcpo)[] = "stbcpo=0x%x";
+static const char BCMATTACHDATA(vstr_bw40po)[] = "bw40po=0x%x";
+static const char BCMATTACHDATA(vstr_bwduppo)[] = "bwduppo=0x%x";
+static const char BCMATTACHDATA(vstr_mcspo)[] = "mcs%dgpo%d=0x%x";
+static const char BCMATTACHDATA(vstr_mcspohl)[] = "mcs%dg%cpo%d=0x%x";
+static const char BCMATTACHDATA(vstr_custom)[] = "customvar%d=0x%x";
+static const char BCMATTACHDATA(vstr_cckdigfilttype)[] = "cckdigfilttype=%d";
+static const char BCMATTACHDATA(vstr_boardnum)[] = "boardnum=%d";
+static const char BCMATTACHDATA(vstr_macaddr)[] = "macaddr=%s";
+static const char BCMATTACHDATA(vstr_usbepnum)[] = "usbepnum=0x%x";
+static const char BCMATTACHDATA(vstr_end)[] = "END\0";
+
+uint8 patch_pair = 0;
+
+/* For dongle HW, accept partial calibration parameters */
+#define BCMDONGLECASE(n)
+
+int
+BCMATTACHFN(srom_parsecis) (osl_t * osh, uint8 * pcis[], uint ciscnt,
+			    char **vars, uint * count)
+{
+	char eabuf[32];
+	char *base;
+	varbuf_t b;
+	uint8 *cis, tup, tlen, sromrev = 1;
+	int i, j;
+	bool ag_init = FALSE;
+	uint32 w32;
+	uint funcid;
+	uint cisnum;
+	int32 boardnum;
+	int err;
+	bool standard_cis;
+
+	ASSERT(vars != NULL);
+	ASSERT(count != NULL);
+
+	boardnum = -1;
+
+	base = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	ASSERT(base != NULL);
+	if (!base)
+		return -2;
+
+	varbuf_init(&b, base, MAXSZ_NVRAM_VARS);
+	bzero(base, MAXSZ_NVRAM_VARS);
+	eabuf[0] = '\0';
+	for (cisnum = 0; cisnum < ciscnt; cisnum++) {
+		cis = *pcis++;
+		i = 0;
+		funcid = 0;
+		standard_cis = TRUE;
+		do {
+			if (standard_cis) {
+				tup = cis[i++];
+				if (tup == CISTPL_NULL || tup == CISTPL_END)
+					tlen = 0;
+				else
+					tlen = cis[i++];
+			} else {
+				if (cis[i] == CISTPL_NULL
+				    || cis[i] == CISTPL_END) {
+					tlen = 0;
+					tup = cis[i];
+				} else {
+					tlen = cis[i];
+					tup = CISTPL_BRCM_HNBU;
+				}
+				++i;
+			}
+			if ((i + tlen) >= CIS_SIZE)
+				break;
+
+			switch (tup) {
+			case CISTPL_VERS_1:
+				/* assume the strings are good if the version field checks out */
+				if (((cis[i + 1] << 8) + cis[i]) >= 0x0008) {
+					varbuf_append(&b, vstr_manf,
+						      &cis[i + 2]);
+					varbuf_append(&b, vstr_productname,
+						      &cis[i + 3 +
+							   strlen((char *)
+								  &cis[i +
+								       2])]);
+					break;
+				}
+
+			case CISTPL_MANFID:
+				varbuf_append(&b, vstr_manfid,
+					      (cis[i + 1] << 8) + cis[i]);
+				varbuf_append(&b, vstr_prodid,
+					      (cis[i + 3] << 8) + cis[i + 2]);
+				break;
+
+			case CISTPL_FUNCID:
+				funcid = cis[i];
+				break;
+
+			case CISTPL_FUNCE:
+				switch (funcid) {
+				case CISTPL_FID_SDIO:
+#ifdef BCMSDIO
+					if (cis[i] == 0) {
+						uint8 spd = cis[i + 3];
+						static int base[] = {
+							-1, 10, 12, 13, 15, 20,
+							    25, 30,
+							35, 40, 45, 50, 55, 60,
+							    70, 80
+						};
+						static int mult[] = {
+							10, 100, 1000, 10000,
+							-1, -1, -1, -1
+						};
+						ASSERT((mult[spd & 0x7] != -1)
+						       &&
+						       (base
+							[(spd >> 3) & 0x0f]));
+						varbuf_append(&b,
+							      vstr_sdmaxblk[0],
+							      (cis[i + 2] << 8)
+							      + cis[i + 1]);
+						varbuf_append(&b,
+							      vstr_sdmaxspeed,
+							      (mult[spd & 0x7] *
+							       base[(spd >> 3) &
+								    0x0f]));
+					} else if (cis[i] == 1) {
+						varbuf_append(&b,
+							      vstr_sdmaxblk
+							      [cisnum],
+							      (cis[i + 13] << 8)
+							      | cis[i + 12]);
+					}
+#endif				/* BCMSDIO */
+					funcid = 0;
+					break;
+				default:
+					/* set macaddr if HNBU_MACADDR not seen yet */
+					if (eabuf[0] == '\0'
+					    && cis[i] == LAN_NID
+					    && !(ETHER_ISNULLADDR(&cis[i + 2]))
+					    && !(ETHER_ISMULTI(&cis[i + 2]))) {
+						ASSERT(cis[i + 1] ==
+						       ETHER_ADDR_LEN);
+						bcm_ether_ntoa((struct
+								ether_addr *)
+							       &cis[i + 2],
+							       eabuf);
+
+						/* set boardnum if HNBU_BOARDNUM not seen yet */
+						if (boardnum == -1)
+							boardnum =
+							    (cis[i + 6] << 8) +
+							    cis[i + 7];
+					}
+					break;
+				}
+				break;
+
+			case CISTPL_CFTABLE:
+				varbuf_append(&b, vstr_regwindowsz,
+					      (cis[i + 7] << 8) | cis[i + 6]);
+				break;
+
+			case CISTPL_BRCM_HNBU:
+				switch (cis[i]) {
+				case HNBU_SROMREV:
+					sromrev = cis[i + 1];
+					varbuf_append(&b, vstr_sromrev,
+						      sromrev);
+					break;
+
+				case HNBU_XTALFREQ:
+					varbuf_append(&b, vstr_xtalfreq,
+						      (cis[i + 4] << 24) |
+						      (cis[i + 3] << 16) |
+						      (cis[i + 2] << 8) |
+						      cis[i + 1]);
+					break;
+
+				case HNBU_CHIPID:
+					varbuf_append(&b, vstr_vendid,
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_devid,
+						      (cis[i + 4] << 8) +
+						      cis[i + 3]);
+					if (tlen >= 7) {
+						varbuf_append(&b, vstr_chiprev,
+							      (cis[i + 6] << 8)
+							      + cis[i + 5]);
+					}
+					if (tlen >= 9) {
+						varbuf_append(&b,
+							      vstr_subvendid,
+							      (cis[i + 8] << 8)
+							      + cis[i + 7]);
+					}
+					if (tlen >= 11) {
+						varbuf_append(&b, vstr_subdevid,
+							      (cis[i + 10] << 8)
+							      + cis[i + 9]);
+						/* subdevid doubles for boardtype */
+						varbuf_append(&b,
+							      vstr_boardtype,
+							      (cis[i + 10] << 8)
+							      + cis[i + 9]);
+					}
+					break;
+
+				case HNBU_BOARDNUM:
+					boardnum =
+					    (cis[i + 2] << 8) + cis[i + 1];
+					break;
+
+				case HNBU_PATCH:
+					{
+						char vstr_paddr[16];
+						char vstr_pdata[16];
+
+						/* retrieve the patch pairs
+						 * from tlen/6; where 6 is
+						 * sizeof(patch addr(2)) +
+						 * sizeof(patch data(4)).
+						 */
+						patch_pair = tlen / 6;
+
+						for (j = 0; j < patch_pair; j++) {
+							snprintf(vstr_paddr,
+								 sizeof
+								 (vstr_paddr),
+								 "pa%d=0x%%x",
+								 j);
+							snprintf(vstr_pdata,
+								 sizeof
+								 (vstr_pdata),
+								 "pd%d=0x%%x",
+								 j);
+
+							varbuf_append(&b,
+								      vstr_paddr,
+								      (cis
+								       [i +
+									(j *
+									 6) +
+									2] << 8)
+								      | cis[i +
+									    (j *
+									     6)
+									    +
+									    1]);
+
+							varbuf_append(&b,
+								      vstr_pdata,
+								      (cis
+								       [i +
+									(j *
+									 6) +
+									6] <<
+								       24) |
+								      (cis
+								       [i +
+									(j *
+									 6) +
+									5] <<
+								       16) |
+								      (cis
+								       [i +
+									(j *
+									 6) +
+									4] << 8)
+								      | cis[i +
+									    (j *
+									     6)
+									    +
+									    3]);
+						}
+					}
+					break;
+
+				case HNBU_BOARDREV:
+					if (tlen == 2)
+						varbuf_append(&b, vstr_boardrev,
+							      cis[i + 1]);
+					else
+						varbuf_append(&b, vstr_boardrev,
+							      (cis[i + 2] << 8)
+							      + cis[i + 1]);
+					break;
+
+				case HNBU_BOARDFLAGS:
+					w32 = (cis[i + 2] << 8) + cis[i + 1];
+					if (tlen >= 5)
+						w32 |=
+						    ((cis[i + 4] << 24) +
+						     (cis[i + 3] << 16));
+					varbuf_append(&b, vstr_boardflags, w32);
+
+					if (tlen >= 7) {
+						w32 =
+						    (cis[i + 6] << 8) + cis[i +
+									    5];
+						if (tlen >= 9)
+							w32 |=
+							    ((cis[i + 8] << 24)
+							     +
+							     (cis[i + 7] <<
+							      16));
+						varbuf_append(&b,
+							      vstr_boardflags2,
+							      w32);
+					}
+					break;
+
+				case HNBU_USBFS:
+					varbuf_append(&b, vstr_usbfs,
+						      cis[i + 1]);
+					break;
+
+				case HNBU_BOARDTYPE:
+					varbuf_append(&b, vstr_boardtype,
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					break;
+
+				case HNBU_HNBUCIS:
+					/*
+					 * what follows is a nonstandard HNBU CIS
+					 * that lacks CISTPL_BRCM_HNBU tags
+					 *
+					 * skip 0xff (end of standard CIS)
+					 * after this tuple
+					 */
+					tlen++;
+					standard_cis = FALSE;
+					break;
+
+				case HNBU_USBEPNUM:
+					varbuf_append(&b, vstr_usbepnum,
+						      (cis[i + 2] << 8) | cis[i
+									      +
+									      1]);
+					break;
+
+				case HNBU_AA:
+					varbuf_append(&b, vstr_aa2g,
+						      cis[i + 1]);
+					if (tlen >= 3)
+						varbuf_append(&b, vstr_aa5g,
+							      cis[i + 2]);
+					break;
+
+				case HNBU_AG:
+					varbuf_append(&b, vstr_ag, 0,
+						      cis[i + 1]);
+					if (tlen >= 3)
+						varbuf_append(&b, vstr_ag, 1,
+							      cis[i + 2]);
+					if (tlen >= 4)
+						varbuf_append(&b, vstr_ag, 2,
+							      cis[i + 3]);
+					if (tlen >= 5)
+						varbuf_append(&b, vstr_ag, 3,
+							      cis[i + 4]);
+					ag_init = TRUE;
+					break;
+
+				case HNBU_ANT5G:
+					varbuf_append(&b, vstr_aa5g,
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_ag, 1,
+						      cis[i + 2]);
+					break;
+
+				case HNBU_CC:
+					ASSERT(sromrev == 1);
+					varbuf_append(&b, vstr_cc, cis[i + 1]);
+					break;
+
+				case HNBU_PAPARMS:
+					switch (tlen) {
+					case 2:
+						ASSERT(sromrev == 1);
+						varbuf_append(&b,
+							      vstr_pa0maxpwr,
+							      cis[i + 1]);
+						break;
+					case 10:
+						ASSERT(sromrev >= 2);
+						varbuf_append(&b, vstr_opo,
+							      cis[i + 9]);
+						/* FALLTHROUGH */
+					case 9:
+						varbuf_append(&b,
+							      vstr_pa0maxpwr,
+							      cis[i + 8]);
+						/* FALLTHROUGH */
+						BCMDONGLECASE(8)
+						    varbuf_append(&b,
+								  vstr_pa0itssit,
+								  cis[i + 7]);
+						/* FALLTHROUGH */
+						BCMDONGLECASE(7)
+						    for (j = 0; j < 3; j++) {
+							varbuf_append(&b,
+								      vstr_pa0b
+								      [j],
+								      (cis
+								       [i +
+									(j *
+									 2) +
+									2] << 8)
+								      + cis[i +
+									    (j *
+									     2)
+									    +
+									    1]);
+						}
+						break;
+					default:
+						ASSERT((tlen == 2)
+						       || (tlen == 9)
+						       || (tlen == 10));
+						break;
+					}
+					break;
+
+				case HNBU_PAPARMS5G:
+					ASSERT((sromrev == 2)
+					       || (sromrev == 3));
+					switch (tlen) {
+					case 23:
+						varbuf_append(&b,
+							      vstr_pa1himaxpwr,
+							      cis[i + 22]);
+						varbuf_append(&b,
+							      vstr_pa1lomaxpwr,
+							      cis[i + 21]);
+						varbuf_append(&b,
+							      vstr_pa1maxpwr,
+							      cis[i + 20]);
+						/* FALLTHROUGH */
+					case 20:
+						varbuf_append(&b,
+							      vstr_pa1itssit,
+							      cis[i + 19]);
+						/* FALLTHROUGH */
+					case 19:
+						for (j = 0; j < 3; j++) {
+							varbuf_append(&b,
+								      vstr_pa1b
+								      [j],
+								      (cis
+								       [i +
+									(j *
+									 2) +
+									2] << 8)
+								      + cis[i +
+									    (j *
+									     2)
+									    +
+									    1]);
+						}
+						for (j = 3; j < 6; j++) {
+							varbuf_append(&b,
+								      vstr_pa1lob
+								      [j - 3],
+								      (cis
+								       [i +
+									(j *
+									 2) +
+									2] << 8)
+								      + cis[i +
+									    (j *
+									     2)
+									    +
+									    1]);
+						}
+						for (j = 6; j < 9; j++) {
+							varbuf_append(&b,
+								      vstr_pa1hib
+								      [j - 6],
+								      (cis
+								       [i +
+									(j *
+									 2) +
+									2] << 8)
+								      + cis[i +
+									    (j *
+									     2)
+									    +
+									    1]);
+						}
+						break;
+					default:
+						ASSERT((tlen == 19) ||
+						       (tlen == 20)
+						       || (tlen == 23));
+						break;
+					}
+					break;
+
+				case HNBU_OEM:
+					ASSERT(sromrev == 1);
+					varbuf_append(&b, vstr_oem,
+						      cis[i + 1], cis[i + 2],
+						      cis[i + 3], cis[i + 4],
+						      cis[i + 5], cis[i + 6],
+						      cis[i + 7], cis[i + 8]);
+					break;
+
+				case HNBU_LEDS:
+					for (j = 1; j <= 4; j++) {
+						if (cis[i + j] != 0xff) {
+							varbuf_append(&b,
+								      vstr_ledbh,
+								      j - 1,
+								      cis[i +
+									  j]);
+						}
+					}
+					break;
+
+				case HNBU_CCODE:
+					ASSERT(sromrev > 1);
+					if ((cis[i + 1] == 0)
+					    || (cis[i + 2] == 0))
+						varbuf_append(&b, vstr_noccode);
+					else
+						varbuf_append(&b, vstr_ccode,
+							      cis[i + 1],
+							      cis[i + 2]);
+					varbuf_append(&b, vstr_cctl,
+						      cis[i + 3]);
+					break;
+
+				case HNBU_CCKPO:
+					ASSERT(sromrev > 2);
+					varbuf_append(&b, vstr_cckpo,
+						      (cis[i + 2] << 8) | cis[i
+									      +
+									      1]);
+					break;
+
+				case HNBU_OFDMPO:
+					ASSERT(sromrev > 2);
+					varbuf_append(&b, vstr_ofdmpo,
+						      (cis[i + 4] << 24) |
+						      (cis[i + 3] << 16) |
+						      (cis[i + 2] << 8) |
+						      cis[i + 1]);
+					break;
+
+				case HNBU_WPS:
+					varbuf_append(&b, vstr_wpsgpio,
+						      cis[i + 1]);
+					if (tlen >= 3)
+						varbuf_append(&b, vstr_wpsled,
+							      cis[i + 2]);
+					break;
+
+				case HNBU_RSSISMBXA2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, vstr_rssismf2g,
+						      cis[i + 1] & 0xf);
+					varbuf_append(&b, vstr_rssismc2g,
+						      (cis[i + 1] >> 4) & 0xf);
+					varbuf_append(&b, vstr_rssisav2g,
+						      cis[i + 2] & 0x7);
+					varbuf_append(&b, vstr_bxa2g,
+						      (cis[i + 2] >> 3) & 0x3);
+					break;
+
+				case HNBU_RSSISMBXA5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, vstr_rssismf5g,
+						      cis[i + 1] & 0xf);
+					varbuf_append(&b, vstr_rssismc5g,
+						      (cis[i + 1] >> 4) & 0xf);
+					varbuf_append(&b, vstr_rssisav5g,
+						      cis[i + 2] & 0x7);
+					varbuf_append(&b, vstr_bxa5g,
+						      (cis[i + 2] >> 3) & 0x3);
+					break;
+
+				case HNBU_TRI2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, vstr_tri2g,
+						      cis[i + 1]);
+					break;
+
+				case HNBU_TRI5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, vstr_tri5gl,
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_tri5g,
+						      cis[i + 2]);
+					varbuf_append(&b, vstr_tri5gh,
+						      cis[i + 3]);
+					break;
+
+				case HNBU_RXPO2G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, vstr_rxpo2g,
+						      cis[i + 1]);
+					break;
+
+				case HNBU_RXPO5G:
+					ASSERT(sromrev == 3);
+					varbuf_append(&b, vstr_rxpo5g,
+						      cis[i + 1]);
+					break;
+
+				case HNBU_MACADDR:
+					if (!(ETHER_ISNULLADDR(&cis[i + 1])) &&
+					    !(ETHER_ISMULTI(&cis[i + 1]))) {
+						bcm_ether_ntoa((struct
+								ether_addr *)
+							       &cis[i + 1],
+							       eabuf);
+
+						/* set boardnum if HNBU_BOARDNUM not seen yet */
+						if (boardnum == -1)
+							boardnum =
+							    (cis[i + 5] << 8) +
+							    cis[i + 6];
+					}
+					break;
+
+				case HNBU_LEDDC:
+					/* CIS leddc only has 16bits, convert it to 32bits */
+					w32 = ((cis[i + 2] << 24) |	/* oncount */
+					       (cis[i + 1] << 8));	/* offcount */
+					varbuf_append(&b, vstr_leddc, w32);
+					break;
+
+				case HNBU_CHAINSWITCH:
+					varbuf_append(&b, vstr_txchain,
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_rxchain,
+						      cis[i + 2]);
+					varbuf_append(&b, vstr_antswitch,
+						      (cis[i + 4] << 8) +
+						      cis[i + 3]);
+					break;
+
+				case HNBU_REGREV:
+					varbuf_append(&b, vstr_regrev,
+						      cis[i + 1]);
+					break;
+
+				case HNBU_FEM:{
+						uint16 fem =
+						    (cis[i + 2] << 8) + cis[i +
+									    1];
+						varbuf_append(&b,
+							      vstr_antswctl2g,
+							      (fem &
+							       SROM8_FEM_ANTSWLUT_MASK)
+							      >>
+							      SROM8_FEM_ANTSWLUT_SHIFT);
+						varbuf_append(&b, vstr_triso2g,
+							      (fem &
+							       SROM8_FEM_TR_ISO_MASK)
+							      >>
+							      SROM8_FEM_TR_ISO_SHIFT);
+						varbuf_append(&b,
+							      vstr_pdetrange2g,
+							      (fem &
+							       SROM8_FEM_PDET_RANGE_MASK)
+							      >>
+							      SROM8_FEM_PDET_RANGE_SHIFT);
+						varbuf_append(&b,
+							      vstr_extpagain2g,
+							      (fem &
+							       SROM8_FEM_EXTPA_GAIN_MASK)
+							      >>
+							      SROM8_FEM_EXTPA_GAIN_SHIFT);
+						varbuf_append(&b,
+							      vstr_tssipos2g,
+							      (fem &
+							       SROM8_FEM_TSSIPOS_MASK)
+							      >>
+							      SROM8_FEM_TSSIPOS_SHIFT);
+						if (tlen < 5)
+							break;
+
+						fem =
+						    (cis[i + 4] << 8) + cis[i +
+									    3];
+						varbuf_append(&b,
+							      vstr_antswctl5g,
+							      (fem &
+							       SROM8_FEM_ANTSWLUT_MASK)
+							      >>
+							      SROM8_FEM_ANTSWLUT_SHIFT);
+						varbuf_append(&b, vstr_triso5g,
+							      (fem &
+							       SROM8_FEM_TR_ISO_MASK)
+							      >>
+							      SROM8_FEM_TR_ISO_SHIFT);
+						varbuf_append(&b,
+							      vstr_pdetrange5g,
+							      (fem &
+							       SROM8_FEM_PDET_RANGE_MASK)
+							      >>
+							      SROM8_FEM_PDET_RANGE_SHIFT);
+						varbuf_append(&b,
+							      vstr_extpagain5g,
+							      (fem &
+							       SROM8_FEM_EXTPA_GAIN_MASK)
+							      >>
+							      SROM8_FEM_EXTPA_GAIN_SHIFT);
+						varbuf_append(&b,
+							      vstr_tssipos5g,
+							      (fem &
+							       SROM8_FEM_TSSIPOS_MASK)
+							      >>
+							      SROM8_FEM_TSSIPOS_SHIFT);
+						break;
+					}
+
+				case HNBU_PAPARMS_C0:
+					varbuf_append(&b, vstr_maxp2ga0,
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_itt2ga0,
+						      cis[i + 2]);
+					varbuf_append(&b, vstr_pa, 2, 0, 0,
+						      (cis[i + 4] << 8) +
+						      cis[i + 3]);
+					varbuf_append(&b, vstr_pa, 2, 1, 0,
+						      (cis[i + 6] << 8) +
+						      cis[i + 5]);
+					varbuf_append(&b, vstr_pa, 2, 2, 0,
+						      (cis[i + 8] << 8) +
+						      cis[i + 7]);
+					if (tlen < 31)
+						break;
+
+					varbuf_append(&b, vstr_maxp5ga0,
+						      cis[i + 9]);
+					varbuf_append(&b, vstr_itt5ga0,
+						      cis[i + 10]);
+					varbuf_append(&b, vstr_maxp5gha0,
+						      cis[i + 11]);
+					varbuf_append(&b, vstr_maxp5gla0,
+						      cis[i + 12]);
+					varbuf_append(&b, vstr_pa, 5, 0, 0,
+						      (cis[i + 14] << 8) +
+						      cis[i + 13]);
+					varbuf_append(&b, vstr_pa, 5, 1, 0,
+						      (cis[i + 16] << 8) +
+						      cis[i + 15]);
+					varbuf_append(&b, vstr_pa, 5, 2, 0,
+						      (cis[i + 18] << 8) +
+						      cis[i + 17]);
+					varbuf_append(&b, vstr_pahl, 5, 'l', 0,
+						      0,
+						      (cis[i + 20] << 8) +
+						      cis[i + 19]);
+					varbuf_append(&b, vstr_pahl, 5, 'l', 1,
+						      0,
+						      (cis[i + 22] << 8) +
+						      cis[i + 21]);
+					varbuf_append(&b, vstr_pahl, 5, 'l', 2,
+						      0,
+						      (cis[i + 24] << 8) +
+						      cis[i + 23]);
+					varbuf_append(&b, vstr_pahl, 5, 'h', 0,
+						      0,
+						      (cis[i + 26] << 8) +
+						      cis[i + 25]);
+					varbuf_append(&b, vstr_pahl, 5, 'h', 1,
+						      0,
+						      (cis[i + 28] << 8) +
+						      cis[i + 27]);
+					varbuf_append(&b, vstr_pahl, 5, 'h', 2,
+						      0,
+						      (cis[i + 30] << 8) +
+						      cis[i + 29]);
+					break;
+
+				case HNBU_PAPARMS_C1:
+					varbuf_append(&b, vstr_maxp2ga1,
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_itt2ga1,
+						      cis[i + 2]);
+					varbuf_append(&b, vstr_pa, 2, 0, 1,
+						      (cis[i + 4] << 8) +
+						      cis[i + 3]);
+					varbuf_append(&b, vstr_pa, 2, 1, 1,
+						      (cis[i + 6] << 8) +
+						      cis[i + 5]);
+					varbuf_append(&b, vstr_pa, 2, 2, 1,
+						      (cis[i + 8] << 8) +
+						      cis[i + 7]);
+					if (tlen < 31)
+						break;
+
+					varbuf_append(&b, vstr_maxp5ga1,
+						      cis[i + 9]);
+					varbuf_append(&b, vstr_itt5ga1,
+						      cis[i + 10]);
+					varbuf_append(&b, vstr_maxp5gha1,
+						      cis[i + 11]);
+					varbuf_append(&b, vstr_maxp5gla1,
+						      cis[i + 12]);
+					varbuf_append(&b, vstr_pa, 5, 0, 1,
+						      (cis[i + 14] << 8) +
+						      cis[i + 13]);
+					varbuf_append(&b, vstr_pa, 5, 1, 1,
+						      (cis[i + 16] << 8) +
+						      cis[i + 15]);
+					varbuf_append(&b, vstr_pa, 5, 2, 1,
+						      (cis[i + 18] << 8) +
+						      cis[i + 17]);
+					varbuf_append(&b, vstr_pahl, 5, 'l', 0,
+						      1,
+						      (cis[i + 20] << 8) +
+						      cis[i + 19]);
+					varbuf_append(&b, vstr_pahl, 5, 'l', 1,
+						      1,
+						      (cis[i + 22] << 8) +
+						      cis[i + 21]);
+					varbuf_append(&b, vstr_pahl, 5, 'l', 2,
+						      1,
+						      (cis[i + 24] << 8) +
+						      cis[i + 23]);
+					varbuf_append(&b, vstr_pahl, 5, 'h', 0,
+						      1,
+						      (cis[i + 26] << 8) +
+						      cis[i + 25]);
+					varbuf_append(&b, vstr_pahl, 5, 'h', 1,
+						      1,
+						      (cis[i + 28] << 8) +
+						      cis[i + 27]);
+					varbuf_append(&b, vstr_pahl, 5, 'h', 2,
+						      1,
+						      (cis[i + 30] << 8) +
+						      cis[i + 29]);
+					break;
+
+				case HNBU_PO_CCKOFDM:
+					varbuf_append(&b, vstr_cck2gpo,
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_ofdm2gpo,
+						      (cis[i + 6] << 24) +
+						      (cis[i + 5] << 16) +
+						      (cis[i + 4] << 8) +
+						      cis[i + 3]);
+					if (tlen < 19)
+						break;
+
+					varbuf_append(&b, vstr_ofdm5gpo,
+						      (cis[i + 10] << 24) +
+						      (cis[i + 9] << 16) +
+						      (cis[i + 8] << 8) +
+						      cis[i + 7]);
+					varbuf_append(&b, vstr_ofdm5glpo,
+						      (cis[i + 14] << 24) +
+						      (cis[i + 13] << 16) +
+						      (cis[i + 12] << 8) +
+						      cis[i + 11]);
+					varbuf_append(&b, vstr_ofdm5ghpo,
+						      (cis[i + 18] << 24) +
+						      (cis[i + 17] << 16) +
+						      (cis[i + 16] << 8) +
+						      cis[i + 15]);
+					break;
+
+				case HNBU_PO_MCS2G:
+					for (j = 0; j <= (tlen / 2); j++) {
+						varbuf_append(&b, vstr_mcspo, 2,
+							      j,
+							      (cis
+							       [i + 2 +
+								2 * j] << 8) +
+							      cis[i + 1 +
+								  2 * j]);
+					}
+					break;
+
+				case HNBU_PO_MCS5GM:
+					for (j = 0; j <= (tlen / 2); j++) {
+						varbuf_append(&b, vstr_mcspo, 5,
+							      j,
+							      (cis
+							       [i + 2 +
+								2 * j] << 8) +
+							      cis[i + 1 +
+								  2 * j]);
+					}
+					break;
+
+				case HNBU_PO_MCS5GLH:
+					for (j = 0; j <= (tlen / 4); j++) {
+						varbuf_append(&b, vstr_mcspohl,
+							      5, 'l', j,
+							      (cis
+							       [i + 2 +
+								2 * j] << 8) +
+							      cis[i + 1 +
+								  2 * j]);
+					}
+
+					for (j = 0; j <= (tlen / 4); j++) {
+						varbuf_append(&b, vstr_mcspohl,
+							      5, 'h', j,
+							      (cis
+							       [i +
+								((tlen / 2) +
+								 2) +
+								2 * j] << 8) +
+							      cis[i +
+								  ((tlen / 2) +
+								   1) + 2 * j]);
+					}
+
+					break;
+
+				case HNBU_PO_CDD:
+					varbuf_append(&b, vstr_cddpo,
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					break;
+
+				case HNBU_PO_STBC:
+					varbuf_append(&b, vstr_stbcpo,
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					break;
+
+				case HNBU_PO_40M:
+					varbuf_append(&b, vstr_bw40po,
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					break;
+
+				case HNBU_PO_40MDUP:
+					varbuf_append(&b, vstr_bwduppo,
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					break;
+
+				case HNBU_OFDMPO5G:
+					varbuf_append(&b, vstr_ofdm5gpo,
+						      (cis[i + 4] << 24) +
+						      (cis[i + 3] << 16) +
+						      (cis[i + 2] << 8) +
+						      cis[i + 1]);
+					varbuf_append(&b, vstr_ofdm5glpo,
+						      (cis[i + 8] << 24) +
+						      (cis[i + 7] << 16) +
+						      (cis[i + 6] << 8) +
+						      cis[i + 5]);
+					varbuf_append(&b, vstr_ofdm5ghpo,
+						      (cis[i + 12] << 24) +
+						      (cis[i + 11] << 16) +
+						      (cis[i + 10] << 8) +
+						      cis[i + 9]);
+					break;
+
+				case HNBU_CUSTOM1:
+					varbuf_append(&b, vstr_custom, 1,
+						      ((cis[i + 4] << 24) +
+						       (cis[i + 3] << 16) +
+						       (cis[i + 2] << 8) +
+						       cis[i + 1]));
+					break;
+
+#if defined(BCMSDIO)
+				case HNBU_SROM3SWRGN:
+					if (tlen >= 73) {
+						uint16 srom[35];
+						uint8 srev = cis[i + 1 + 70];
+						ASSERT(srev == 3);
+						/* make tuple value 16-bit aligned and parse it */
+						bcopy(&cis[i + 1], srom,
+						      sizeof(srom));
+						_initvars_srom_pci(srev, srom,
+								   SROM3_SWRGN_OFF,
+								   &b);
+						/* 2.4G antenna gain is included in SROM */
+						ag_init = TRUE;
+						/* Ethernet MAC address is included in SROM */
+						eabuf[0] = 0;
+						boardnum = -1;
+					}
+					/* create extra variables */
+					if (tlen >= 75)
+						varbuf_append(&b, vstr_vendid,
+							      (cis[i + 1 + 73]
+							       << 8) + cis[i +
+									   1 +
+									   72]);
+					if (tlen >= 77)
+						varbuf_append(&b, vstr_devid,
+							      (cis[i + 1 + 75]
+							       << 8) + cis[i +
+									   1 +
+									   74]);
+					if (tlen >= 79)
+						varbuf_append(&b, vstr_xtalfreq,
+							      (cis[i + 1 + 77]
+							       << 8) + cis[i +
+									   1 +
+									   76]);
+					break;
+#endif				/* defined(BCMSDIO) */
+
+				case HNBU_CCKFILTTYPE:
+					varbuf_append(&b, vstr_cckdigfilttype,
+						      (cis[i + 1]));
+					break;
+				}
+
+				break;
+			}
+			i += tlen;
+		} while (tup != CISTPL_END);
+	}
+
+	if (boardnum != -1) {
+		varbuf_append(&b, vstr_boardnum, boardnum);
+	}
+
+	if (eabuf[0]) {
+		varbuf_append(&b, vstr_macaddr, eabuf);
+	}
+
+	/* if there is no antenna gain field, set default */
+	if (getvar(NULL, "ag0") == NULL && ag_init == FALSE) {
+		varbuf_append(&b, vstr_ag, 0, 0xff);
+	}
+
+	/* final nullbyte terminator */
+	ASSERT(b.size >= 1);
+	*b.buf++ = '\0';
+
+	ASSERT(b.buf - base <= MAXSZ_NVRAM_VARS);
+	err = initvars_table(osh, base, b.buf, vars, count);
+
+	MFREE(osh, base, MAXSZ_NVRAM_VARS);
+	return err;
+}
+
+/* In chips with chipcommon rev 32 and later, the srom is in chipcommon,
+ * not in the bus cores.
+ */
+static uint16
+srom_cc_cmd(si_t * sih, osl_t * osh, void *ccregs, uint32 cmd, uint wordoff,
+	    uint16 data)
+{
+	chipcregs_t *cc = (chipcregs_t *) ccregs;
+	uint wait_cnt = 1000;
+
+	if ((cmd == SRC_OP_READ) || (cmd == SRC_OP_WRITE)) {
+		W_REG(osh, &cc->sromaddress, wordoff * 2);
+		if (cmd == SRC_OP_WRITE)
+			W_REG(osh, &cc->sromdata, data);
+	}
+
+	W_REG(osh, &cc->sromcontrol, SRC_START | cmd);
+
+	while (wait_cnt--) {
+		if ((R_REG(osh, &cc->sromcontrol) & SRC_BUSY) == 0)
+			break;
+	}
+
+	if (!wait_cnt) {
+		BS_ERROR(("%s: Command 0x%x timed out\n", __func__, cmd));
+		return 0xffff;
+	}
+	if (cmd == SRC_OP_READ)
+		return (uint16) R_REG(osh, &cc->sromdata);
+	else
+		return 0xffff;
+}
+
+/*
+ * Read in and validate sprom.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+sprom_read_pci(osl_t * osh, si_t * sih, uint16 * sprom, uint wordoff,
+	       uint16 * buf, uint nwords, bool check_crc)
+{
+	int err = 0;
+	uint i;
+	void *ccregs = NULL;
+
+	/* read the sprom */
+	for (i = 0; i < nwords; i++) {
+
+		if (sih->ccrev > 31 && ISSIM_ENAB(sih)) {
+			/* use indirect since direct is too slow on QT */
+			if ((sih->cccaps & CC_CAP_SROM) == 0)
+				return 1;
+
+			ccregs = (void *)((uint8 *) sprom - CC_SROM_OTP);
+			buf[i] =
+			    srom_cc_cmd(sih, osh, ccregs, SRC_OP_READ,
+					wordoff + i, 0);
+
+		} else {
+			if (ISSIM_ENAB(sih))
+				buf[i] = R_REG(osh, &sprom[wordoff + i]);
+
+			buf[i] = R_REG(osh, &sprom[wordoff + i]);
+		}
+
+	}
+
+	/* bypass crc checking for simulation to allow srom hack */
+	if (ISSIM_ENAB(sih))
+		return err;
+
+	if (check_crc) {
+
+		if (buf[0] == 0xffff) {
+			/* The hardware thinks that an srom that starts with 0xffff
+			 * is blank, regardless of the rest of the content, so declare
+			 * it bad.
+			 */
+			BS_ERROR(("%s: buf[0] = 0x%x, returning bad-crc\n",
+				  __func__, buf[0]));
+			return 1;
+		}
+
+		/* fixup the endianness so crc8 will pass */
+		htol16_buf(buf, nwords * 2);
+		if (hndcrc8((uint8 *) buf, nwords * 2, CRC8_INIT_VALUE) !=
+		    CRC8_GOOD_VALUE) {
+			/* DBG only pci always read srom4 first, then srom8/9 */
+			/* BS_ERROR(("%s: bad crc\n", __func__)); */
+			err = 1;
+		}
+		/* now correct the endianness of the byte array */
+		ltoh16_buf(buf, nwords * 2);
+	}
+	return err;
+}
+
+#if defined(BCMNVRAMR)
+static int otp_read_pci(osl_t * osh, si_t * sih, uint16 * buf, uint bufsz)
+{
+	uint8 *otp;
+	uint sz = OTP_SZ_MAX / 2;	/* size in words */
+	int err = 0;
+
+	ASSERT(bufsz <= OTP_SZ_MAX);
+
+	if ((otp = MALLOC(osh, OTP_SZ_MAX)) == NULL) {
+		return BCME_ERROR;
+	}
+
+	bzero(otp, OTP_SZ_MAX);
+
+	err = otp_read_region(sih, OTP_HW_RGN, (uint16 *) otp, &sz);
+
+	bcopy(otp, buf, bufsz);
+
+	if (otp)
+		MFREE(osh, otp, OTP_SZ_MAX);
+
+	/* Check CRC */
+	if (buf[0] == 0xffff) {
+		/* The hardware thinks that an srom that starts with 0xffff
+		 * is blank, regardless of the rest of the content, so declare
+		 * it bad.
+		 */
+		BS_ERROR(("%s: buf[0] = 0x%x, returning bad-crc\n", __func__,
+			  buf[0]));
+		return 1;
+	}
+
+	/* fixup the endianness so crc8 will pass */
+	htol16_buf(buf, bufsz);
+	if (hndcrc8((uint8 *) buf, SROM4_WORDS * 2, CRC8_INIT_VALUE) !=
+	    CRC8_GOOD_VALUE) {
+		BS_ERROR(("%s: bad crc\n", __func__));
+		err = 1;
+	}
+	/* now correct the endianness of the byte array */
+	ltoh16_buf(buf, bufsz);
+
+	return err;
+}
+#endif				/* defined(BCMNVRAMR) */
+/*
+* Create variable table from memory.
+* Return 0 on success, nonzero on error.
+*/
+static int
+BCMATTACHFN(initvars_table) (osl_t * osh, char *start, char *end, char **vars,
+			     uint * count) {
+	int c = (int)(end - start);
+
+	/* do it only when there is more than just the null string */
+	if (c > 1) {
+		char *vp = MALLOC(osh, c);
+		ASSERT(vp != NULL);
+		if (!vp)
+			return BCME_NOMEM;
+		bcopy(start, vp, c);
+		*vars = vp;
+		*count = c;
+	} else {
+		*vars = NULL;
+		*count = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Find variables with <devpath> from flash. 'base' points to the beginning
+ * of the table upon enter and to the end of the table upon exit when success.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+BCMATTACHFN(initvars_flash) (si_t * sih, osl_t * osh, char **base, uint len) {
+	char *vp = *base;
+	char *flash;
+	int err;
+	char *s;
+	uint l, dl, copy_len;
+	char devpath[SI_DEVPATH_BUFSZ];
+
+	/* allocate memory and read in flash */
+	if (!(flash = MALLOC(osh, NVRAM_SPACE)))
+		return BCME_NOMEM;
+	if ((err = nvram_getall(flash, NVRAM_SPACE)))
+		goto exit;
+
+	si_devpath(sih, devpath, sizeof(devpath));
+
+	/* grab vars with the <devpath> prefix in name */
+	dl = strlen(devpath);
+	for (s = flash; s && *s; s += l + 1) {
+		l = strlen(s);
+
+		/* skip non-matching variable */
+		if (strncmp(s, devpath, dl))
+			continue;
+
+		/* is there enough room to copy? */
+		copy_len = l - dl + 1;
+		if (len < copy_len) {
+			err = BCME_BUFTOOSHORT;
+			goto exit;
+		}
+
+		/* no prefix, just the name=value */
+		strncpy(vp, &s[dl], copy_len);
+		vp += copy_len;
+		len -= copy_len;
+	}
+
+	/* add null string as terminator */
+	if (len < 1) {
+		err = BCME_BUFTOOSHORT;
+		goto exit;
+	}
+	*vp++ = '\0';
+
+	*base = vp;
+
+ exit:	MFREE(osh, flash, NVRAM_SPACE);
+	return err;
+}
+
+/*
+ * Initialize nonvolatile variable table from flash.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+BCMATTACHFN(initvars_flash_si) (si_t * sih, char **vars, uint * count) {
+	osl_t *osh = si_osh(sih);
+	char *vp, *base;
+	int err;
+
+	ASSERT(vars != NULL);
+	ASSERT(count != NULL);
+
+	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	ASSERT(vp != NULL);
+	if (!vp)
+		return BCME_NOMEM;
+
+	if ((err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS)) == 0)
+		err = initvars_table(osh, base, vp, vars, count);
+
+	MFREE(osh, base, MAXSZ_NVRAM_VARS);
+
+	return err;
+}
+
+/* Parse SROM and create name=value pairs. 'srom' points to
+ * the SROM word array. 'off' specifies the offset of the
+ * first word 'srom' points to, which should be either 0 or
+ * SROM3_SWRG_OFF (full SROM or software region).
+ */
+
+static uint mask_shift(uint16 mask)
+{
+	uint i;
+	for (i = 0; i < (sizeof(mask) << 3); i++) {
+		if (mask & (1 << i))
+			return i;
+	}
+	ASSERT(mask);
+	return 0;
+}
+
+static uint mask_width(uint16 mask)
+{
+	int i;
+	for (i = (sizeof(mask) << 3) - 1; i >= 0; i--) {
+		if (mask & (1 << i))
+			return (uint) (i - mask_shift(mask) + 1);
+	}
+	ASSERT(mask);
+	return 0;
+}
+
+#if defined(BCMDBG)
+static bool mask_valid(uint16 mask)
+{
+	uint shift = mask_shift(mask);
+	uint width = mask_width(mask);
+	return mask == ((~0 << shift) & ~(~0 << (shift + width)));
+}
+#endif				/* BCMDBG */
+
+static void
+BCMATTACHFN(_initvars_srom_pci) (uint8 sromrev, uint16 * srom, uint off,
+				 varbuf_t * b) {
+	uint16 w;
+	uint32 val;
+	const sromvar_t *srv;
+	uint width;
+	uint flags;
+	uint32 sr = (1 << sromrev);
+
+	varbuf_append(b, "sromrev=%d", sromrev);
+
+	for (srv = pci_sromvars; srv->name != NULL; srv++) {
+		const char *name;
+
+		if ((srv->revmask & sr) == 0)
+			continue;
+
+		if (srv->off < off)
+			continue;
+
+		flags = srv->flags;
+		name = srv->name;
+
+		/* This entry is for mfgc only. Don't generate param for it, */
+		if (flags & SRFL_NOVAR)
+			continue;
+
+		if (flags & SRFL_ETHADDR) {
+			char eabuf[ETHER_ADDR_STR_LEN];
+			struct ether_addr ea;
+
+			ea.octet[0] = (srom[srv->off - off] >> 8) & 0xff;
+			ea.octet[1] = srom[srv->off - off] & 0xff;
+			ea.octet[2] = (srom[srv->off + 1 - off] >> 8) & 0xff;
+			ea.octet[3] = srom[srv->off + 1 - off] & 0xff;
+			ea.octet[4] = (srom[srv->off + 2 - off] >> 8) & 0xff;
+			ea.octet[5] = srom[srv->off + 2 - off] & 0xff;
+			bcm_ether_ntoa(&ea, eabuf);
+
+			varbuf_append(b, "%s=%s", name, eabuf);
+		} else {
+			ASSERT(mask_valid(srv->mask));
+			ASSERT(mask_width(srv->mask));
+
+			w = srom[srv->off - off];
+			val = (w & srv->mask) >> mask_shift(srv->mask);
+			width = mask_width(srv->mask);
+
+			while (srv->flags & SRFL_MORE) {
+				srv++;
+				ASSERT(srv->name != NULL);
+
+				if (srv->off == 0 || srv->off < off)
+					continue;
+
+				ASSERT(mask_valid(srv->mask));
+				ASSERT(mask_width(srv->mask));
+
+				w = srom[srv->off - off];
+				val +=
+				    ((w & srv->mask) >> mask_shift(srv->
+								   mask)) <<
+				    width;
+				width += mask_width(srv->mask);
+			}
+
+			if ((flags & SRFL_NOFFS)
+			    && ((int)val == (1 << width) - 1))
+				continue;
+
+			if (flags & SRFL_CCODE) {
+				if (val == 0)
+					varbuf_append(b, "ccode=");
+				else
+					varbuf_append(b, "ccode=%c%c",
+						      (val >> 8), (val & 0xff));
+			}
+			/* LED Powersave duty cycle has to be scaled:
+			 *(oncount >> 24) (offcount >> 8)
+			 */
+			else if (flags & SRFL_LEDDC) {
+				uint32 w32 = (((val >> 8) & 0xff) << 24) |	/* oncount */
+				    (((val & 0xff)) << 8);	/* offcount */
+				varbuf_append(b, "leddc=%d", w32);
+			} else if (flags & SRFL_PRHEX)
+				varbuf_append(b, "%s=0x%x", name, val);
+			else if ((flags & SRFL_PRSIGN)
+				 && (val & (1 << (width - 1))))
+				varbuf_append(b, "%s=%d", name,
+					      (int)(val | (~0 << width)));
+			else
+				varbuf_append(b, "%s=%u", name, val);
+		}
+	}
+
+	if (sromrev >= 4) {
+		/* Do per-path variables */
+		uint p, pb, psz;
+
+		if (sromrev >= 8) {
+			pb = SROM8_PATH0;
+			psz = SROM8_PATH1 - SROM8_PATH0;
+		} else {
+			pb = SROM4_PATH0;
+			psz = SROM4_PATH1 - SROM4_PATH0;
+		}
+
+		for (p = 0; p < MAX_PATH_SROM; p++) {
+			for (srv = perpath_pci_sromvars; srv->name != NULL;
+			     srv++) {
+				if ((srv->revmask & sr) == 0)
+					continue;
+
+				if (pb + srv->off < off)
+					continue;
+
+				/* This entry is for mfgc only. Don't generate param for it, */
+				if (srv->flags & SRFL_NOVAR)
+					continue;
+
+				w = srom[pb + srv->off - off];
+
+				ASSERT(mask_valid(srv->mask));
+				val = (w & srv->mask) >> mask_shift(srv->mask);
+				width = mask_width(srv->mask);
+
+				/* Cheating: no per-path var is more than 1 word */
+
+				if ((srv->flags & SRFL_NOFFS)
+				    && ((int)val == (1 << width) - 1))
+					continue;
+
+				if (srv->flags & SRFL_PRHEX)
+					varbuf_append(b, "%s%d=0x%x", srv->name,
+						      p, val);
+				else
+					varbuf_append(b, "%s%d=%d", srv->name,
+						      p, val);
+			}
+			pb += psz;
+		}
+	}
+}
+
+/*
+ * Initialize nonvolatile variable table from sprom.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+BCMATTACHFN(initvars_srom_pci) (si_t * sih, void *curmap, char **vars,
+				uint * count) {
+	uint16 *srom, *sromwindow;
+	uint8 sromrev = 0;
+	uint32 sr;
+	varbuf_t b;
+	char *vp, *base = NULL;
+	osl_t *osh = si_osh(sih);
+	bool flash = FALSE;
+	int err = 0;
+
+	/*
+	 * Apply CRC over SROM content regardless SROM is present or not,
+	 * and use variable <devpath>sromrev's existance in flash to decide
+	 * if we should return an error when CRC fails or read SROM variables
+	 * from flash.
+	 */
+	srom = MALLOC(osh, SROM_MAX);
+	ASSERT(srom != NULL);
+	if (!srom)
+		return -2;
+
+	sromwindow = (uint16 *) SROM_OFFSET(sih);
+	if (si_is_sprom_available(sih)) {
+		err =
+		    sprom_read_pci(osh, sih, sromwindow, 0, srom, SROM_WORDS,
+				   TRUE);
+
+		if ((srom[SROM4_SIGN] == SROM4_SIGNATURE) ||
+		    (((sih->buscoretype == PCIE_CORE_ID)
+		      && (sih->buscorerev >= 6))
+		     || ((sih->buscoretype == PCI_CORE_ID)
+			 && (sih->buscorerev >= 0xe)))) {
+			/* sromrev >= 4, read more */
+			err =
+			    sprom_read_pci(osh, sih, sromwindow, 0, srom,
+					   SROM4_WORDS, TRUE);
+			sromrev = srom[SROM4_CRCREV] & 0xff;
+			if (err)
+				BS_ERROR(("%s: srom %d, bad crc\n", __func__,
+					  sromrev));
+
+		} else if (err == 0) {
+			/* srom is good and is rev < 4 */
+			/* top word of sprom contains version and crc8 */
+			sromrev = srom[SROM_CRCREV] & 0xff;
+			/* bcm4401 sroms misprogrammed */
+			if (sromrev == 0x10)
+				sromrev = 1;
+		}
+	}
+#if defined(BCMNVRAMR)
+	/* Use OTP if SPROM not available */
+	else if ((err = otp_read_pci(osh, sih, srom, SROM_MAX)) == 0) {
+		/* OTP only contain SROM rev8/rev9 for now */
+		sromrev = srom[SROM4_CRCREV] & 0xff;
+	}
+#endif
+	else {
+		err = 1;
+		BS_ERROR(("Neither SPROM nor OTP has valid image\n"));
+	}
+
+	/* We want internal/wltest driver to come up with default sromvars so we can
+	 * program a blank SPROM/OTP.
+	 */
+	if (err) {
+		char *value;
+		uint32 val;
+		val = 0;
+
+		if ((value = si_getdevpathvar(sih, "sromrev"))) {
+			sromrev = (uint8) bcm_strtoul(value, NULL, 0);
+			flash = TRUE;
+			goto varscont;
+		}
+
+		BS_ERROR(("%s, SROM CRC Error\n", __func__));
+
+		if ((value = si_getnvramflvar(sih, "sromrev"))) {
+			err = 0;
+			goto errout;
+		}
+
+		{
+			err = -1;
+			goto errout;
+		}
+	}
+
+ varscont:
+	/* Bitmask for the sromrev */
+	sr = 1 << sromrev;
+
+	/* srom version check: Current valid versions: 1, 2, 3, 4, 5, 8, 9 */
+	if ((sr & 0x33e) == 0) {
+		err = -2;
+		goto errout;
+	}
+
+	ASSERT(vars != NULL);
+	ASSERT(count != NULL);
+
+	base = vp = MALLOC(osh, MAXSZ_NVRAM_VARS);
+	ASSERT(vp != NULL);
+	if (!vp) {
+		err = -2;
+		goto errout;
+	}
+
+	/* read variables from flash */
+	if (flash) {
+		if ((err = initvars_flash(sih, osh, &vp, MAXSZ_NVRAM_VARS)))
+			goto errout;
+		goto varsdone;
+	}
+
+	varbuf_init(&b, base, MAXSZ_NVRAM_VARS);
+
+	/* parse SROM into name=value pairs. */
+	_initvars_srom_pci(sromrev, srom, 0, &b);
+
+	/* final nullbyte terminator */
+	ASSERT(b.size >= 1);
+	vp = b.buf;
+	*vp++ = '\0';
+
+	ASSERT((vp - base) <= MAXSZ_NVRAM_VARS);
+
+ varsdone:
+	err = initvars_table(osh, base, vp, vars, count);
+
+ errout:
+	if (base)
+		MFREE(osh, base, MAXSZ_NVRAM_VARS);
+
+	MFREE(osh, srom, SROM_MAX);
+	return err;
+}
+
+#ifdef BCMSDIO
+/*
+ * Read the SDIO cis and call parsecis to initialize the vars.
+ * Return 0 on success, nonzero on error.
+ */
+static int
+BCMATTACHFN(initvars_cis_sdio) (osl_t * osh, char **vars, uint * count) {
+	uint8 *cis[SBSDIO_NUM_FUNCTION + 1];
+	uint fn, numfn;
+	int rc = 0;
+
+	numfn = bcmsdh_query_iofnum(NULL);
+	ASSERT(numfn <= SDIOD_MAX_IOFUNCS);
+
+	for (fn = 0; fn <= numfn; fn++) {
+		if ((cis[fn] = MALLOC(osh, SBSDIO_CIS_SIZE_LIMIT)) == NULL) {
+			rc = -1;
+			break;
+		}
+
+		bzero(cis[fn], SBSDIO_CIS_SIZE_LIMIT);
+
+		if (bcmsdh_cis_read(NULL, fn, cis[fn], SBSDIO_CIS_SIZE_LIMIT) !=
+		    0) {
+			MFREE(osh, cis[fn], SBSDIO_CIS_SIZE_LIMIT);
+			rc = -2;
+			break;
+		}
+	}
+
+	if (!rc)
+		rc = srom_parsecis(osh, cis, fn, vars, count);
+
+	while (fn-- > 0)
+		MFREE(osh, cis[fn], SBSDIO_CIS_SIZE_LIMIT);
+
+	return (rc);
+}
+
+/* set SDIO sprom command register */
+static int BCMATTACHFN(sprom_cmd_sdio) (osl_t * osh, uint8 cmd) {
+	uint8 status = 0;
+	uint wait_cnt = 1000;
+
+	/* write sprom command register */
+	bcmsdh_cfg_write(NULL, SDIO_FUNC_1, SBSDIO_SPROM_CS, cmd, NULL);
+
+	/* wait status */
+	while (wait_cnt--) {
+		status =
+		    bcmsdh_cfg_read(NULL, SDIO_FUNC_1, SBSDIO_SPROM_CS, NULL);
+		if (status & SBSDIO_SPROM_DONE)
+			return 0;
+	}
+
+	return 1;
+}
+
+/* read a word from the SDIO srom */
+static int sprom_read_sdio(osl_t * osh, uint16 addr, uint16 * data)
+{
+	uint8 addr_l, addr_h, data_l, data_h;
+
+	addr_l = (uint8) ((addr * 2) & 0xff);
+	addr_h = (uint8) (((addr * 2) >> 8) & 0xff);
+
+	/* set address */
+	bcmsdh_cfg_write(NULL, SDIO_FUNC_1, SBSDIO_SPROM_ADDR_HIGH, addr_h,
+			 NULL);
+	bcmsdh_cfg_write(NULL, SDIO_FUNC_1, SBSDIO_SPROM_ADDR_LOW, addr_l,
+			 NULL);
+
+	/* do read */
+	if (sprom_cmd_sdio(osh, SBSDIO_SPROM_READ))
+		return 1;
+
+	/* read data */
+	data_h =
+	    bcmsdh_cfg_read(NULL, SDIO_FUNC_1, SBSDIO_SPROM_DATA_HIGH, NULL);
+	data_l =
+	    bcmsdh_cfg_read(NULL, SDIO_FUNC_1, SBSDIO_SPROM_DATA_LOW, NULL);
+
+	*data = (data_h << 8) | data_l;
+	return 0;
+}
+#endif				/* BCMSDIO */
+
+static int
+BCMATTACHFN(initvars_srom_si) (si_t * sih, osl_t * osh, void *curmap,
+			       char **vars, uint * varsz) {
+	/* Search flash nvram section for srom variables */
+	return initvars_flash_si(sih, vars, varsz);
+}
diff --git a/drivers/staging/brcm80211/util/bcmutils.c b/drivers/staging/brcm80211/util/bcmutils.c
new file mode 100644
index 0000000..364f837
--- /dev/null
+++ b/drivers/staging/brcm80211/util/bcmutils.c
@@ -0,0 +1,1760 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <stdarg.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmnvram.h>
+#include <bcmendian.h>
+#include <bcmdevs.h>
+#include <proto/ethernet.h>
+#include <proto/802.1d.h>
+#include <proto/802.11.h>
+
+#ifdef WLC_LOW
+/* nvram vars cache */
+static char *nvram_vars = NULL;
+static int vars_len = -1;
+#endif				/* WLC_LOW */
+
+/* copy a pkt buffer chain into a buffer */
+uint pktcopy(osl_t * osh, void *p, uint offset, int len, uchar * buf)
+{
+	uint n, ret = 0;
+
+	if (len < 0)
+		len = 4096;	/* "infinite" */
+
+	/* skip 'offset' bytes */
+	for (; p && offset; p = PKTNEXT(p)) {
+		if (offset < (uint) PKTLEN(p))
+			break;
+		offset -= PKTLEN(p);
+	}
+
+	if (!p)
+		return 0;
+
+	/* copy the data */
+	for (; p && len; p = PKTNEXT(p)) {
+		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
+		bcopy(PKTDATA(p) + offset, buf, n);
+		buf += n;
+		len -= n;
+		ret += n;
+		offset = 0;
+	}
+
+	return ret;
+}
+
+/* copy a buffer into a pkt buffer chain */
+uint pktfrombuf(osl_t * osh, void *p, uint offset, int len, uchar * buf)
+{
+	uint n, ret = 0;
+
+	/* skip 'offset' bytes */
+	for (; p && offset; p = PKTNEXT(p)) {
+		if (offset < (uint) PKTLEN(p))
+			break;
+		offset -= PKTLEN(p);
+	}
+
+	if (!p)
+		return 0;
+
+	/* copy the data */
+	for (; p && len; p = PKTNEXT(p)) {
+		n = MIN((uint) PKTLEN(p) - offset, (uint) len);
+		bcopy(buf, PKTDATA(p) + offset, n);
+		buf += n;
+		len -= n;
+		ret += n;
+		offset = 0;
+	}
+
+	return ret;
+}
+
+/* return total length of buffer chain */
+uint BCMFASTPATH pkttotlen(osl_t * osh, void *p)
+{
+	uint total;
+
+	total = 0;
+	for (; p; p = PKTNEXT(p))
+		total += PKTLEN(p);
+	return (total);
+}
+
+/* return the last buffer of chained pkt */
+void *pktlast(osl_t * osh, void *p)
+{
+	for (; PKTNEXT(p); p = PKTNEXT(p)) ;
+
+	return (p);
+}
+
+/* count segments of a chained packet */
+uint BCMFASTPATH pktsegcnt(osl_t * osh, void *p)
+{
+	uint cnt;
+
+	for (cnt = 0; p; p = PKTNEXT(p))
+		cnt++;
+
+	return cnt;
+}
+
+/*
+ * osl multiple-precedence packet queue
+ * hi_prec is always >= the number of the highest non-empty precedence
+ */
+void *BCMFASTPATH pktq_penq(struct pktq *pq, int prec, void *p)
+{
+	struct pktq_prec *q;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+	ASSERT(PKTLINK(p) == NULL);	/* queueing chains not allowed */
+
+	ASSERT(!pktq_full(pq));
+	ASSERT(!pktq_pfull(pq, prec));
+
+	q = &pq->q[prec];
+
+	if (q->head)
+		PKTSETLINK(q->tail, p);
+	else
+		q->head = p;
+
+	q->tail = p;
+	q->len++;
+
+	pq->len++;
+
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (uint8) prec;
+
+	return p;
+}
+
+void *BCMFASTPATH pktq_penq_head(struct pktq *pq, int prec, void *p)
+{
+	struct pktq_prec *q;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+	ASSERT(PKTLINK(p) == NULL);	/* queueing chains not allowed */
+
+	ASSERT(!pktq_full(pq));
+	ASSERT(!pktq_pfull(pq, prec));
+
+	q = &pq->q[prec];
+
+	if (q->head == NULL)
+		q->tail = p;
+
+	PKTSETLINK(p, q->head);
+	q->head = p;
+	q->len++;
+
+	pq->len++;
+
+	if (pq->hi_prec < prec)
+		pq->hi_prec = (uint8) prec;
+
+	return p;
+}
+
+void *BCMFASTPATH pktq_pdeq(struct pktq *pq, int prec)
+{
+	struct pktq_prec *q;
+	void *p;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
+
+	q->len--;
+
+	pq->len--;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void *BCMFASTPATH pktq_pdeq_tail(struct pktq *pq, int prec)
+{
+	struct pktq_prec *q;
+	void *p, *prev;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	for (prev = NULL; p != q->tail; p = PKTLINK(p))
+		prev = p;
+
+	if (prev)
+		PKTSETLINK(prev, NULL);
+	else
+		q->head = NULL;
+
+	q->tail = prev;
+	q->len--;
+
+	pq->len--;
+
+	return p;
+}
+
+void
+pktq_pflush(osl_t * osh, struct pktq *pq, int prec, bool dir, ifpkt_cb_t fn,
+	    int arg)
+{
+	struct pktq_prec *q;
+	void *p, *prev = NULL;
+
+	q = &pq->q[prec];
+	p = q->head;
+	while (p) {
+		if (fn == NULL || (*fn) (p, arg)) {
+			bool head = (p == q->head);
+			if (head)
+				q->head = PKTLINK(p);
+			else
+				PKTSETLINK(prev, PKTLINK(p));
+			PKTSETLINK(p, NULL);
+			PKTFREE(osh, p, dir);
+			q->len--;
+			pq->len--;
+			p = (head ? q->head : PKTLINK(prev));
+		} else {
+			prev = p;
+			p = PKTLINK(p);
+		}
+	}
+
+	if (q->head == NULL) {
+		ASSERT(q->len == 0);
+		q->tail = NULL;
+	}
+}
+
+bool BCMFASTPATH pktq_pdel(struct pktq *pq, void *pktbuf, int prec)
+{
+	struct pktq_prec *q;
+	void *p;
+
+	ASSERT(prec >= 0 && prec < pq->num_prec);
+
+	if (!pktbuf)
+		return FALSE;
+
+	q = &pq->q[prec];
+
+	if (q->head == pktbuf) {
+		if ((q->head = PKTLINK(pktbuf)) == NULL)
+			q->tail = NULL;
+	} else {
+		for (p = q->head; p && PKTLINK(p) != pktbuf; p = PKTLINK(p)) ;
+		if (p == NULL)
+			return FALSE;
+
+		PKTSETLINK(p, PKTLINK(pktbuf));
+		if (q->tail == pktbuf)
+			q->tail = p;
+	}
+
+	q->len--;
+	pq->len--;
+	PKTSETLINK(pktbuf, NULL);
+	return TRUE;
+}
+
+void pktq_init(struct pktq *pq, int num_prec, int max_len)
+{
+	int prec;
+
+	ASSERT(num_prec > 0 && num_prec <= PKTQ_MAX_PREC);
+
+	/* pq is variable size; only zero out what's requested */
+	bzero(pq,
+	      OFFSETOF(struct pktq, q) + (sizeof(struct pktq_prec) * num_prec));
+
+	pq->num_prec = (uint16) num_prec;
+
+	pq->max = (uint16) max_len;
+
+	for (prec = 0; prec < num_prec; prec++)
+		pq->q[prec].max = pq->max;
+}
+
+void *BCMFASTPATH pktq_deq(struct pktq *pq, int *prec_out)
+{
+	struct pktq_prec *q;
+	void *p;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
+
+	q->len--;
+
+	pq->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void *BCMFASTPATH pktq_deq_tail(struct pktq *pq, int *prec_out)
+{
+	struct pktq_prec *q;
+	void *p, *prev;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		if (pq->q[prec].head)
+			break;
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	for (prev = NULL; p != q->tail; p = PKTLINK(p))
+		prev = p;
+
+	if (prev)
+		PKTSETLINK(prev, NULL);
+	else
+		q->head = NULL;
+
+	q->tail = prev;
+	q->len--;
+
+	pq->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+void *pktq_peek(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return (pq->q[prec].head);
+}
+
+void *pktq_peek_tail(struct pktq *pq, int *prec_out)
+{
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	for (prec = 0; prec < pq->hi_prec; prec++)
+		if (pq->q[prec].head)
+			break;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	return (pq->q[prec].tail);
+}
+
+void pktq_flush(osl_t * osh, struct pktq *pq, bool dir, ifpkt_cb_t fn, int arg)
+{
+	int prec;
+	for (prec = 0; prec < pq->num_prec; prec++)
+		pktq_pflush(osh, pq, prec, dir, fn, arg);
+	if (fn == NULL)
+		ASSERT(pq->len == 0);
+}
+
+/* Return sum of lengths of a specific set of precedences */
+int pktq_mlen(struct pktq *pq, uint prec_bmp)
+{
+	int prec, len;
+
+	len = 0;
+
+	for (prec = 0; prec <= pq->hi_prec; prec++)
+		if (prec_bmp & (1 << prec))
+			len += pq->q[prec].len;
+
+	return len;
+}
+
+/* Priority dequeue from a specific set of precedences */
+void *BCMFASTPATH pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out)
+{
+	struct pktq_prec *q;
+	void *p;
+	int prec;
+
+	if (pq->len == 0)
+		return NULL;
+
+	while ((prec = pq->hi_prec) > 0 && pq->q[prec].head == NULL)
+		pq->hi_prec--;
+
+	while ((prec_bmp & (1 << prec)) == 0 || pq->q[prec].head == NULL)
+		if (prec-- == 0)
+			return NULL;
+
+	q = &pq->q[prec];
+
+	if ((p = q->head) == NULL)
+		return NULL;
+
+	if ((q->head = PKTLINK(p)) == NULL)
+		q->tail = NULL;
+
+	q->len--;
+
+	if (prec_out)
+		*prec_out = prec;
+
+	pq->len--;
+
+	PKTSETLINK(p, NULL);
+
+	return p;
+}
+
+const unsigned char bcm_ctype[] = {
+
+	_BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C,	/* 0-7 */
+	_BCM_C, _BCM_C | _BCM_S, _BCM_C | _BCM_S, _BCM_C | _BCM_S,
+	    _BCM_C | _BCM_S, _BCM_C | _BCM_S, _BCM_C,
+	_BCM_C,			/* 8-15 */
+	_BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C,	/* 16-23 */
+	_BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C, _BCM_C,	/* 24-31 */
+	_BCM_S | _BCM_SP, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 32-39 */
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 40-47 */
+	_BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D, _BCM_D,	/* 48-55 */
+	_BCM_D, _BCM_D, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 56-63 */
+	_BCM_P, _BCM_U | _BCM_X, _BCM_U | _BCM_X, _BCM_U | _BCM_X,
+	    _BCM_U | _BCM_X, _BCM_U | _BCM_X,
+	_BCM_U | _BCM_X, _BCM_U,	/* 64-71 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 72-79 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 80-87 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 88-95 */
+	_BCM_P, _BCM_L | _BCM_X, _BCM_L | _BCM_X, _BCM_L | _BCM_X,
+	    _BCM_L | _BCM_X, _BCM_L | _BCM_X,
+	_BCM_L | _BCM_X, _BCM_L,	/* 96-103 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 104-111 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 112-119 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_C,	/* 120-127 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 128-143 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 144-159 */
+	_BCM_S | _BCM_SP, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
+	    _BCM_P, _BCM_P, _BCM_P,
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 160-175 */
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,
+	    _BCM_P, _BCM_P,
+	_BCM_P, _BCM_P, _BCM_P, _BCM_P, _BCM_P,	/* 176-191 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,
+	    _BCM_U, _BCM_U,
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U,	/* 192-207 */
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_P, _BCM_U,
+	    _BCM_U, _BCM_U,
+	_BCM_U, _BCM_U, _BCM_U, _BCM_U, _BCM_L,	/* 208-223 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,
+	    _BCM_L, _BCM_L,
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L,	/* 224-239 */
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_P, _BCM_L,
+	    _BCM_L, _BCM_L,
+	_BCM_L, _BCM_L, _BCM_L, _BCM_L, _BCM_L	/* 240-255 */
+};
+
+ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base) {
+	ulong result, last_result = 0, value;
+	bool minus;
+
+	minus = FALSE;
+
+	while (bcm_isspace(*cp))
+		cp++;
+
+	if (cp[0] == '+')
+		cp++;
+	else if (cp[0] == '-') {
+		minus = TRUE;
+		cp++;
+	}
+
+	if (base == 0) {
+		if (cp[0] == '0') {
+			if ((cp[1] == 'x') || (cp[1] == 'X')) {
+				base = 16;
+				cp = &cp[2];
+			} else {
+				base = 8;
+				cp = &cp[1];
+			}
+		} else
+			base = 10;
+	} else if (base == 16 && (cp[0] == '0')
+		   && ((cp[1] == 'x') || (cp[1] == 'X'))) {
+		cp = &cp[2];
+	}
+
+	result = 0;
+
+	while (bcm_isxdigit(*cp) &&
+	       (value =
+		bcm_isdigit(*cp) ? *cp - '0' : bcm_toupper(*cp) - 'A' + 10) <
+	       base) {
+		result = result * base + value;
+		/* Detected overflow */
+		if (result < last_result && !minus)
+			return (ulong) - 1;
+		last_result = result;
+		cp++;
+	}
+
+	if (minus)
+		result = (ulong) (-(long)result);
+
+	if (endp)
+		*endp = (char *)cp;
+
+	return (result);
+}
+
+int BCMROMFN(bcm_atoi) (char *s) {
+	return (int)bcm_strtoul(s, NULL, 10);
+}
+
+/* return pointer to location of substring 'needle' in 'haystack' */
+char *BCMROMFN(bcmstrstr) (char *haystack, char *needle) {
+	int len, nlen;
+	int i;
+
+	if ((haystack == NULL) || (needle == NULL))
+		return (haystack);
+
+	nlen = strlen(needle);
+	len = strlen(haystack) - nlen + 1;
+
+	for (i = 0; i < len; i++)
+		if (memcmp(needle, &haystack[i], nlen) == 0)
+			return (&haystack[i]);
+	return (NULL);
+}
+
+char *BCMROMFN(bcmstrcat) (char *dest, const char *src) {
+	char *p;
+
+	p = dest + strlen(dest);
+
+	while ((*p++ = *src++) != '\0') ;
+
+	return (dest);
+}
+
+char *BCMROMFN(bcmstrncat) (char *dest, const char *src, uint size) {
+	char *endp;
+	char *p;
+
+	p = dest + strlen(dest);
+	endp = p + size;
+
+	while (p != endp && (*p++ = *src++) != '\0') ;
+
+	return (dest);
+}
+
+/****************************************************************************
+* Function:   bcmstrtok
+*
+* Purpose:
+*  Tokenizes a string. This function is conceptually similiar to ANSI C strtok(),
+*  but allows strToken() to be used by different strings or callers at the same
+*  time. Each call modifies '*string' by substituting a NULL character for the
+*  first delimiter that is encountered, and updates 'string' to point to the char
+*  after the delimiter. Leading delimiters are skipped.
+*
+* Parameters:
+*  string      (mod) Ptr to string ptr, updated by token.
+*  delimiters  (in)  Set of delimiter characters.
+*  tokdelim    (out) Character that delimits the returned token. (May
+*                    be set to NULL if token delimiter is not required).
+*
+* Returns:  Pointer to the next token found. NULL when no more tokens are found.
+*****************************************************************************
+*/
+char *bcmstrtok(char **string, const char *delimiters, char *tokdelim)
+{
+	unsigned char *str;
+	unsigned long map[8];
+	int count;
+	char *nextoken;
+
+	if (tokdelim != NULL) {
+		/* Prime the token delimiter */
+		*tokdelim = '\0';
+	}
+
+	/* Clear control map */
+	for (count = 0; count < 8; count++) {
+		map[count] = 0;
+	}
+
+	/* Set bits in delimiter table */
+	do {
+		map[*delimiters >> 5] |= (1 << (*delimiters & 31));
+	}
+	while (*delimiters++);
+
+	str = (unsigned char *)*string;
+
+	/* Find beginning of token (skip over leading delimiters). Note that
+	 * there is no token iff this loop sets str to point to the terminal
+	 * null (*str == '\0')
+	 */
+	while (((map[*str >> 5] & (1 << (*str & 31))) && *str) || (*str == ' ')) {
+		str++;
+	}
+
+	nextoken = (char *)str;
+
+	/* Find the end of the token. If it is not the end of the string,
+	 * put a null there.
+	 */
+	for (; *str; str++) {
+		if (map[*str >> 5] & (1 << (*str & 31))) {
+			if (tokdelim != NULL) {
+				*tokdelim = *str;
+			}
+
+			*str++ = '\0';
+			break;
+		}
+	}
+
+	*string = (char *)str;
+
+	/* Determine if a token has been found. */
+	if (nextoken == (char *)str) {
+		return NULL;
+	} else {
+		return nextoken;
+	}
+}
+
+#define xToLower(C) \
+	((C >= 'A' && C <= 'Z') ? (char)((int)C - (int)'A' + (int)'a') : C)
+
+/****************************************************************************
+* Function:   bcmstricmp
+*
+* Purpose:    Compare to strings case insensitively.
+*
+* Parameters: s1 (in) First string to compare.
+*             s2 (in) Second string to compare.
+*
+* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
+*             t1 > t2, when ignoring case sensitivity.
+*****************************************************************************
+*/
+int bcmstricmp(const char *s1, const char *s2)
+{
+	char dc, sc;
+
+	while (*s2 && *s1) {
+		dc = xToLower(*s1);
+		sc = xToLower(*s2);
+		if (dc < sc)
+			return -1;
+		if (dc > sc)
+			return 1;
+		s1++;
+		s2++;
+	}
+
+	if (*s1 && !*s2)
+		return 1;
+	if (!*s1 && *s2)
+		return -1;
+	return 0;
+}
+
+/****************************************************************************
+* Function:   bcmstrnicmp
+*
+* Purpose:    Compare to strings case insensitively, upto a max of 'cnt'
+*             characters.
+*
+* Parameters: s1  (in) First string to compare.
+*             s2  (in) Second string to compare.
+*             cnt (in) Max characters to compare.
+*
+* Returns:    Return 0 if the two strings are equal, -1 if t1 < t2 and 1 if
+*             t1 > t2, when ignoring case sensitivity.
+*****************************************************************************
+*/
+int bcmstrnicmp(const char *s1, const char *s2, int cnt)
+{
+	char dc, sc;
+
+	while (*s2 && *s1 && cnt) {
+		dc = xToLower(*s1);
+		sc = xToLower(*s2);
+		if (dc < sc)
+			return -1;
+		if (dc > sc)
+			return 1;
+		s1++;
+		s2++;
+		cnt--;
+	}
+
+	if (!cnt)
+		return 0;
+	if (*s1 && !*s2)
+		return 1;
+	if (!*s1 && *s2)
+		return -1;
+	return 0;
+}
+
+/* parse a xx:xx:xx:xx:xx:xx format ethernet address */
+int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr * ea) {
+	int i = 0;
+
+	for (;;) {
+		ea->octet[i++] = (char)bcm_strtoul(p, &p, 16);
+		if (!*p++ || i == 6)
+			break;
+	}
+
+	return (i == 6);
+}
+
+char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf)
+{
+	static const char template[] = "%02x:%02x:%02x:%02x:%02x:%02x";
+	snprintf(buf, 18, template,
+		 ea->octet[0] & 0xff, ea->octet[1] & 0xff, ea->octet[2] & 0xff,
+		 ea->octet[3] & 0xff, ea->octet[4] & 0xff, ea->octet[5] & 0xff);
+	return (buf);
+}
+
+void bcm_mdelay(uint ms)
+{
+	uint i;
+
+	for (i = 0; i < ms; i++) {
+		OSL_DELAY(1000);
+	}
+}
+
+/*
+ * Search the name=value vars for a specific one and return its value.
+ * Returns NULL if not found.
+ */
+char *getvar(char *vars, const char *name)
+{
+	char *s;
+	int len;
+
+	if (!name)
+		return NULL;
+
+	len = strlen(name);
+	if (len == 0)
+		return NULL;
+
+	/* first look in vars[] */
+	for (s = vars; s && *s;) {
+		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
+			return (&s[len + 1]);
+
+		while (*s++) ;
+	}
+
+	/* then query nvram */
+	return (nvram_get(name));
+}
+
+/*
+ * Search the vars for a specific one and return its value as
+ * an integer. Returns 0 if not found.
+ */
+int getintvar(char *vars, const char *name)
+{
+	char *val;
+
+	if ((val = getvar(vars, name)) == NULL)
+		return (0);
+
+	return (bcm_strtoul(val, NULL, 0));
+}
+
+int getintvararray(char *vars, const char *name, uint8 index)
+{
+	char *buf, *endp;
+	int i = 0;
+	int val = 0;
+
+	if ((buf = getvar(vars, name)) == NULL) {
+		return (0);
+	}
+
+	/* table values are always separated by "," or " " */
+	while (*buf != '\0') {
+		val = bcm_strtoul(buf, &endp, 0);
+		if (i == index) {
+			return val;
+		}
+		buf = endp;
+		/* delimiter is ',' */
+		if (*buf == ',')
+			buf++;
+		i++;
+	}
+	return 0;
+}
+
+/* Search for token in comma separated token-string */
+static int findmatch(char *string, char *name)
+{
+	uint len;
+	char *c;
+
+	len = strlen(name);
+	while ((c = strchr(string, ',')) != NULL) {
+		if (len == (uint) (c - string) && !strncmp(string, name, len))
+			return 1;
+		string = c + 1;
+	}
+
+	return (!strcmp(string, name));
+}
+
+/* Return gpio pin number assigned to the named pin
+ *
+ * Variable should be in format:
+ *
+ *	gpio<N>=pin_name,pin_name
+ *
+ * This format allows multiple features to share the gpio with mutual
+ * understanding.
+ *
+ * 'def_pin' is returned if a specific gpio is not defined for the requested functionality
+ * and if def_pin is not used by others.
+ */
+uint getgpiopin(char *vars, char *pin_name, uint def_pin)
+{
+	char name[] = "gpioXXXX";
+	char *val;
+	uint pin;
+
+	/* Go thru all possibilities till a match in pin name */
+	for (pin = 0; pin < GPIO_NUMPINS; pin++) {
+		snprintf(name, sizeof(name), "gpio%d", pin);
+		val = getvar(vars, name);
+		if (val && findmatch(val, pin_name))
+			return pin;
+	}
+
+	if (def_pin != GPIO_PIN_NOTDEFINED) {
+		/* make sure the default pin is not used by someone else */
+		snprintf(name, sizeof(name), "gpio%d", def_pin);
+		if (getvar(vars, name)) {
+			def_pin = GPIO_PIN_NOTDEFINED;
+		}
+	}
+	return def_pin;
+}
+
+#if defined(BCMDBG)
+/* pretty hex print a pkt buffer chain */
+void prpkt(const char *msg, osl_t * osh, void *p0)
+{
+	void *p;
+
+	if (msg && (msg[0] != '\0'))
+		printf("%s:\n", msg);
+
+	for (p = p0; p; p = PKTNEXT(p))
+		prhex(NULL, PKTDATA(p), PKTLEN(p));
+}
+#endif				/* defined(BCMDBG) */
+
+static char bcm_undeferrstr[32];
+static const char *bcmerrorstrtable[] = BCMERRSTRINGTABLE;
+
+/* Convert the error codes into related error strings  */
+const char *bcmerrorstr(int bcmerror)
+{
+	/* check if someone added a bcmerror code but forgot to add errorstring */
+	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(bcmerrorstrtable) - 1));
+
+	if (bcmerror > 0 || bcmerror < BCME_LAST) {
+		snprintf(bcm_undeferrstr, sizeof(bcm_undeferrstr),
+			 "Undefined error %d", bcmerror);
+		return bcm_undeferrstr;
+	}
+
+	ASSERT(strlen(bcmerrorstrtable[-bcmerror]) < BCME_STRLEN);
+
+	return bcmerrorstrtable[-bcmerror];
+}
+
+#ifdef WLC_LOW
+static void BCMINITFN(bcm_nvram_refresh) (char *flash) {
+	int i;
+	int ret = 0;
+
+	ASSERT(flash != NULL);
+
+	/* default "empty" vars cache */
+	bzero(flash, 2);
+
+	if ((ret = nvram_getall(flash, NVRAM_SPACE)))
+		return;
+
+	/* determine nvram length */
+	for (i = 0; i < NVRAM_SPACE; i++) {
+		if (flash[i] == '\0' && flash[i + 1] == '\0')
+			break;
+	}
+
+	if (i > 1)
+		vars_len = i + 2;
+	else
+		vars_len = 0;
+}
+
+char *bcm_nvram_vars(uint * length)
+{
+#ifndef BCMNVRAMR
+	/* cache may be stale if nvram is read/write */
+	if (nvram_vars) {
+		ASSERT(!bcmreclaimed);
+		bcm_nvram_refresh(nvram_vars);
+	}
+#endif
+	if (length)
+		*length = vars_len;
+	return nvram_vars;
+}
+
+/* copy nvram vars into locally-allocated multi-string array */
+int BCMINITFN(bcm_nvram_cache) (void *sih) {
+	int ret = 0;
+	void *osh;
+	char *flash = NULL;
+
+	if (vars_len >= 0) {
+#ifndef BCMNVRAMR
+		bcm_nvram_refresh(nvram_vars);
+#endif
+		return 0;
+	}
+
+	osh = si_osh((si_t *) sih);
+
+	/* allocate memory and read in flash */
+	if (!(flash = MALLOC(osh, NVRAM_SPACE))) {
+		ret = BCME_NOMEM;
+		goto exit;
+	}
+
+	bcm_nvram_refresh(flash);
+#ifdef BCMNVRAMR
+	if (vars_len > 3) {
+		/* copy into a properly-sized buffer */
+		if (!(nvram_vars = MALLOC(osh, vars_len))) {
+			ret = BCME_NOMEM;
+		} else
+			bcopy(flash, nvram_vars, vars_len);
+	}
+	MFREE(osh, flash, NVRAM_SPACE);
+#else
+	/* cache must be full size of nvram if read/write */
+	nvram_vars = flash;
+#endif				/* BCMNVRAMR */
+
+ exit:
+	return ret;
+}
+#endif				/* WLC_LOW */
+
+/* iovar table lookup */
+const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table, const char *name)
+{
+	const bcm_iovar_t *vi;
+	const char *lookup_name;
+
+	/* skip any ':' delimited option prefixes */
+	lookup_name = strrchr(name, ':');
+	if (lookup_name != NULL)
+		lookup_name++;
+	else
+		lookup_name = name;
+
+	ASSERT(table != NULL);
+
+	for (vi = table; vi->name; vi++) {
+		if (!strcmp(vi->name, lookup_name))
+			return vi;
+	}
+	/* ran to end of table */
+
+	return NULL;		/* var name not found */
+}
+
+int bcm_iovar_lencheck(const bcm_iovar_t * vi, void *arg, int len, bool set)
+{
+	int bcmerror = 0;
+
+	/* length check on io buf */
+	switch (vi->type) {
+	case IOVT_BOOL:
+	case IOVT_INT8:
+	case IOVT_INT16:
+	case IOVT_INT32:
+	case IOVT_UINT8:
+	case IOVT_UINT16:
+	case IOVT_UINT32:
+		/* all integers are int32 sized args at the ioctl interface */
+		if (len < (int)sizeof(int)) {
+			bcmerror = BCME_BUFTOOSHORT;
+		}
+		break;
+
+	case IOVT_BUFFER:
+		/* buffer must meet minimum length requirement */
+		if (len < vi->minlen) {
+			bcmerror = BCME_BUFTOOSHORT;
+		}
+		break;
+
+	case IOVT_VOID:
+		if (!set) {
+			/* Cannot return nil... */
+			bcmerror = BCME_UNSUPPORTED;
+		} else if (len) {
+			/* Set is an action w/o parameters */
+			bcmerror = BCME_BUFTOOLONG;
+		}
+		break;
+
+	default:
+		/* unknown type for length check in iovar info */
+		ASSERT(0);
+		bcmerror = BCME_UNSUPPORTED;
+	}
+
+	return bcmerror;
+}
+
+/*******************************************************************************
+ * crc8
+ *
+ * Computes a crc8 over the input data using the polynomial:
+ *
+ *       x^8 + x^7 +x^6 + x^4 + x^2 + 1
+ *
+ * The caller provides the initial value (either CRC8_INIT_VALUE
+ * or the previous returned value) to allow for processing of
+ * discontiguous blocks of data.  When generating the CRC the
+ * caller is responsible for complementing the final return value
+ * and inserting it into the byte stream.  When checking, a final
+ * return value of CRC8_GOOD_VALUE indicates a valid CRC.
+ *
+ * Reference: Dallas Semiconductor Application Note 27
+ *   Williams, Ross N., "A Painless Guide to CRC Error Detection Algorithms",
+ *     ver 3, Aug 1993, ross@guest.adelaide.edu.au, Rocksoft Pty Ltd.,
+ *     ftp://ftp.rocksoft.com/clients/rocksoft/papers/crc_v3.txt
+ *
+ * ****************************************************************************
+ */
+
+static const uint8 crc8_table[256] = {
+	0x00, 0xF7, 0xB9, 0x4E, 0x25, 0xD2, 0x9C, 0x6B,
+	0x4A, 0xBD, 0xF3, 0x04, 0x6F, 0x98, 0xD6, 0x21,
+	0x94, 0x63, 0x2D, 0xDA, 0xB1, 0x46, 0x08, 0xFF,
+	0xDE, 0x29, 0x67, 0x90, 0xFB, 0x0C, 0x42, 0xB5,
+	0x7F, 0x88, 0xC6, 0x31, 0x5A, 0xAD, 0xE3, 0x14,
+	0x35, 0xC2, 0x8C, 0x7B, 0x10, 0xE7, 0xA9, 0x5E,
+	0xEB, 0x1C, 0x52, 0xA5, 0xCE, 0x39, 0x77, 0x80,
+	0xA1, 0x56, 0x18, 0xEF, 0x84, 0x73, 0x3D, 0xCA,
+	0xFE, 0x09, 0x47, 0xB0, 0xDB, 0x2C, 0x62, 0x95,
+	0xB4, 0x43, 0x0D, 0xFA, 0x91, 0x66, 0x28, 0xDF,
+	0x6A, 0x9D, 0xD3, 0x24, 0x4F, 0xB8, 0xF6, 0x01,
+	0x20, 0xD7, 0x99, 0x6E, 0x05, 0xF2, 0xBC, 0x4B,
+	0x81, 0x76, 0x38, 0xCF, 0xA4, 0x53, 0x1D, 0xEA,
+	0xCB, 0x3C, 0x72, 0x85, 0xEE, 0x19, 0x57, 0xA0,
+	0x15, 0xE2, 0xAC, 0x5B, 0x30, 0xC7, 0x89, 0x7E,
+	0x5F, 0xA8, 0xE6, 0x11, 0x7A, 0x8D, 0xC3, 0x34,
+	0xAB, 0x5C, 0x12, 0xE5, 0x8E, 0x79, 0x37, 0xC0,
+	0xE1, 0x16, 0x58, 0xAF, 0xC4, 0x33, 0x7D, 0x8A,
+	0x3F, 0xC8, 0x86, 0x71, 0x1A, 0xED, 0xA3, 0x54,
+	0x75, 0x82, 0xCC, 0x3B, 0x50, 0xA7, 0xE9, 0x1E,
+	0xD4, 0x23, 0x6D, 0x9A, 0xF1, 0x06, 0x48, 0xBF,
+	0x9E, 0x69, 0x27, 0xD0, 0xBB, 0x4C, 0x02, 0xF5,
+	0x40, 0xB7, 0xF9, 0x0E, 0x65, 0x92, 0xDC, 0x2B,
+	0x0A, 0xFD, 0xB3, 0x44, 0x2F, 0xD8, 0x96, 0x61,
+	0x55, 0xA2, 0xEC, 0x1B, 0x70, 0x87, 0xC9, 0x3E,
+	0x1F, 0xE8, 0xA6, 0x51, 0x3A, 0xCD, 0x83, 0x74,
+	0xC1, 0x36, 0x78, 0x8F, 0xE4, 0x13, 0x5D, 0xAA,
+	0x8B, 0x7C, 0x32, 0xC5, 0xAE, 0x59, 0x17, 0xE0,
+	0x2A, 0xDD, 0x93, 0x64, 0x0F, 0xF8, 0xB6, 0x41,
+	0x60, 0x97, 0xD9, 0x2E, 0x45, 0xB2, 0xFC, 0x0B,
+	0xBE, 0x49, 0x07, 0xF0, 0x9B, 0x6C, 0x22, 0xD5,
+	0xF4, 0x03, 0x4D, 0xBA, 0xD1, 0x26, 0x68, 0x9F
+};
+
+#define CRC_INNER_LOOP(n, c, x) \
+	(c) = ((c) >> 8) ^ crc##n##_table[((c) ^ (x)) & 0xff]
+
+uint8 BCMROMFN(hndcrc8) (uint8 * pdata,	/* pointer to array of data to process */
+			 uint nbytes,	/* number of input data bytes to process */
+			 uint8 crc	/* either CRC8_INIT_VALUE or previous return value */
+    ) {
+	/* hard code the crc loop instead of using CRC_INNER_LOOP macro
+	 * to avoid the undefined and unnecessary (uint8 >> 8) operation.
+	 */
+	while (nbytes-- > 0)
+		crc = crc8_table[(crc ^ *pdata++) & 0xff];
+
+	return crc;
+}
+
+/*******************************************************************************
+ * crc16
+ *
+ * Computes a crc16 over the input data using the polynomial:
+ *
+ *       x^16 + x^12 +x^5 + 1
+ *
+ * The caller provides the initial value (either CRC16_INIT_VALUE
+ * or the previous returned value) to allow for processing of
+ * discontiguous blocks of data.  When generating the CRC the
+ * caller is responsible for complementing the final return value
+ * and inserting it into the byte stream.  When checking, a final
+ * return value of CRC16_GOOD_VALUE indicates a valid CRC.
+ *
+ * Reference: Dallas Semiconductor Application Note 27
+ *   Williams, Ross N., "A Painless Guide to CRC Error Detection Algorithms",
+ *     ver 3, Aug 1993, ross@guest.adelaide.edu.au, Rocksoft Pty Ltd.,
+ *     ftp://ftp.rocksoft.com/clients/rocksoft/papers/crc_v3.txt
+ *
+ * ****************************************************************************
+ */
+
+static const uint16 crc16_table[256] = {
+	0x0000, 0x1189, 0x2312, 0x329B, 0x4624, 0x57AD, 0x6536, 0x74BF,
+	0x8C48, 0x9DC1, 0xAF5A, 0xBED3, 0xCA6C, 0xDBE5, 0xE97E, 0xF8F7,
+	0x1081, 0x0108, 0x3393, 0x221A, 0x56A5, 0x472C, 0x75B7, 0x643E,
+	0x9CC9, 0x8D40, 0xBFDB, 0xAE52, 0xDAED, 0xCB64, 0xF9FF, 0xE876,
+	0x2102, 0x308B, 0x0210, 0x1399, 0x6726, 0x76AF, 0x4434, 0x55BD,
+	0xAD4A, 0xBCC3, 0x8E58, 0x9FD1, 0xEB6E, 0xFAE7, 0xC87C, 0xD9F5,
+	0x3183, 0x200A, 0x1291, 0x0318, 0x77A7, 0x662E, 0x54B5, 0x453C,
+	0xBDCB, 0xAC42, 0x9ED9, 0x8F50, 0xFBEF, 0xEA66, 0xD8FD, 0xC974,
+	0x4204, 0x538D, 0x6116, 0x709F, 0x0420, 0x15A9, 0x2732, 0x36BB,
+	0xCE4C, 0xDFC5, 0xED5E, 0xFCD7, 0x8868, 0x99E1, 0xAB7A, 0xBAF3,
+	0x5285, 0x430C, 0x7197, 0x601E, 0x14A1, 0x0528, 0x37B3, 0x263A,
+	0xDECD, 0xCF44, 0xFDDF, 0xEC56, 0x98E9, 0x8960, 0xBBFB, 0xAA72,
+	0x6306, 0x728F, 0x4014, 0x519D, 0x2522, 0x34AB, 0x0630, 0x17B9,
+	0xEF4E, 0xFEC7, 0xCC5C, 0xDDD5, 0xA96A, 0xB8E3, 0x8A78, 0x9BF1,
+	0x7387, 0x620E, 0x5095, 0x411C, 0x35A3, 0x242A, 0x16B1, 0x0738,
+	0xFFCF, 0xEE46, 0xDCDD, 0xCD54, 0xB9EB, 0xA862, 0x9AF9, 0x8B70,
+	0x8408, 0x9581, 0xA71A, 0xB693, 0xC22C, 0xD3A5, 0xE13E, 0xF0B7,
+	0x0840, 0x19C9, 0x2B52, 0x3ADB, 0x4E64, 0x5FED, 0x6D76, 0x7CFF,
+	0x9489, 0x8500, 0xB79B, 0xA612, 0xD2AD, 0xC324, 0xF1BF, 0xE036,
+	0x18C1, 0x0948, 0x3BD3, 0x2A5A, 0x5EE5, 0x4F6C, 0x7DF7, 0x6C7E,
+	0xA50A, 0xB483, 0x8618, 0x9791, 0xE32E, 0xF2A7, 0xC03C, 0xD1B5,
+	0x2942, 0x38CB, 0x0A50, 0x1BD9, 0x6F66, 0x7EEF, 0x4C74, 0x5DFD,
+	0xB58B, 0xA402, 0x9699, 0x8710, 0xF3AF, 0xE226, 0xD0BD, 0xC134,
+	0x39C3, 0x284A, 0x1AD1, 0x0B58, 0x7FE7, 0x6E6E, 0x5CF5, 0x4D7C,
+	0xC60C, 0xD785, 0xE51E, 0xF497, 0x8028, 0x91A1, 0xA33A, 0xB2B3,
+	0x4A44, 0x5BCD, 0x6956, 0x78DF, 0x0C60, 0x1DE9, 0x2F72, 0x3EFB,
+	0xD68D, 0xC704, 0xF59F, 0xE416, 0x90A9, 0x8120, 0xB3BB, 0xA232,
+	0x5AC5, 0x4B4C, 0x79D7, 0x685E, 0x1CE1, 0x0D68, 0x3FF3, 0x2E7A,
+	0xE70E, 0xF687, 0xC41C, 0xD595, 0xA12A, 0xB0A3, 0x8238, 0x93B1,
+	0x6B46, 0x7ACF, 0x4854, 0x59DD, 0x2D62, 0x3CEB, 0x0E70, 0x1FF9,
+	0xF78F, 0xE606, 0xD49D, 0xC514, 0xB1AB, 0xA022, 0x92B9, 0x8330,
+	0x7BC7, 0x6A4E, 0x58D5, 0x495C, 0x3DE3, 0x2C6A, 0x1EF1, 0x0F78
+};
+
+uint16 BCMROMFN(hndcrc16) (uint8 * pdata,	/* pointer to array of data to process */
+			   uint nbytes,	/* number of input data bytes to process */
+			   uint16 crc	/* either CRC16_INIT_VALUE or previous return value */
+    ) {
+	while (nbytes-- > 0)
+		CRC_INNER_LOOP(16, crc, *pdata++);
+	return crc;
+}
+
+/*
+ * Advance from the current 1-byte tag/1-byte length/variable-length value
+ * triple, to the next, returning a pointer to the next.
+ * If the current or next TLV is invalid (does not fit in given buffer length),
+ * NULL is returned.
+ * *buflen is not modified if the TLV elt parameter is invalid, or is decremented
+ * by the TLV parameter's length if it is valid.
+ */
+bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t * elt, int *buflen) {
+	int len;
+
+	/* validate current elt */
+	if (!bcm_valid_tlv(elt, *buflen))
+		return NULL;
+
+	/* advance to next elt */
+	len = elt->len;
+	elt = (bcm_tlv_t *) (elt->data + len);
+	*buflen -= (2 + len);
+
+	/* validate next elt */
+	if (!bcm_valid_tlv(elt, *buflen))
+		return NULL;
+
+	return elt;
+}
+
+/*
+ * Traverse a string of 1-byte tag/1-byte length/variable-length value
+ * triples, returning a pointer to the substring whose first element
+ * matches tag
+ */
+bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen, uint key) {
+	bcm_tlv_t *elt;
+	int totlen;
+
+	elt = (bcm_tlv_t *) buf;
+	totlen = buflen;
+
+	/* find tagged parameter */
+	while (totlen >= 2) {
+		int len = elt->len;
+
+		/* validate remaining totlen */
+		if ((elt->id == key) && (totlen >= (len + 2)))
+			return (elt);
+
+		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
+		totlen -= (len + 2);
+	}
+
+	return NULL;
+}
+
+/*
+ * Traverse a string of 1-byte tag/1-byte length/variable-length value
+ * triples, returning a pointer to the substring whose first element
+ * matches tag.  Stop parsing when we see an element whose ID is greater
+ * than the target key.
+ */
+bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf, int buflen, uint key) {
+	bcm_tlv_t *elt;
+	int totlen;
+
+	elt = (bcm_tlv_t *) buf;
+	totlen = buflen;
+
+	/* find tagged parameter */
+	while (totlen >= 2) {
+		uint id = elt->id;
+		int len = elt->len;
+
+		/* Punt if we start seeing IDs > than target key */
+		if (id > key)
+			return (NULL);
+
+		/* validate remaining totlen */
+		if ((id == key) && (totlen >= (len + 2)))
+			return (elt);
+
+		elt = (bcm_tlv_t *) ((uint8 *) elt + (len + 2));
+		totlen -= (len + 2);
+	}
+	return NULL;
+}
+
+#if defined(BCMDBG)
+int
+bcm_format_flags(const bcm_bit_desc_t * bd, uint32 flags, char *buf, int len)
+{
+	int i;
+	char *p = buf;
+	char hexstr[16];
+	int slen = 0, nlen = 0;
+	uint32 bit;
+	const char *name;
+
+	if (len < 2 || !buf)
+		return 0;
+
+	buf[0] = '\0';
+
+	for (i = 0; flags != 0; i++) {
+		bit = bd[i].bit;
+		name = bd[i].name;
+		if (bit == 0 && flags != 0) {
+			/* print any unnamed bits */
+			snprintf(hexstr, 16, "0x%X", flags);
+			name = hexstr;
+			flags = 0;	/* exit loop */
+		} else if ((flags & bit) == 0)
+			continue;
+		flags &= ~bit;
+		nlen = strlen(name);
+		slen += nlen;
+		/* count btwn flag space */
+		if (flags != 0)
+			slen += 1;
+		/* need NULL char as well */
+		if (len <= slen)
+			break;
+		/* copy NULL char but don't count it */
+		strncpy(p, name, nlen + 1);
+		p += nlen;
+		/* copy btwn flag space and NULL char */
+		if (flags != 0)
+			p += snprintf(p, 2, " ");
+		len -= slen;
+	}
+
+	/* indicate the str was too short */
+	if (flags != 0) {
+		if (len < 2)
+			p -= 2 - len;	/* overwrite last char */
+		p += snprintf(p, 2, ">");
+	}
+
+	return (int)(p - buf);
+}
+
+/* print bytes formatted as hex to a string. return the resulting string length */
+int bcm_format_hex(char *str, const void *bytes, int len)
+{
+	int i;
+	char *p = str;
+	const uint8 *src = (const uint8 *)bytes;
+
+	for (i = 0; i < len; i++) {
+		p += snprintf(p, 3, "%02X", *src);
+		src++;
+	}
+	return (int)(p - str);
+}
+#endif				/* defined(BCMDBG) */
+
+/* pretty hex print a contiguous buffer */
+void prhex(const char *msg, uchar * buf, uint nbytes)
+{
+	char line[128], *p;
+	int len = sizeof(line);
+	int nchar;
+	uint i;
+
+	if (msg && (msg[0] != '\0'))
+		printf("%s:\n", msg);
+
+	p = line;
+	for (i = 0; i < nbytes; i++) {
+		if (i % 16 == 0) {
+			nchar = snprintf(p, len, "  %04d: ", i);	/* line prefix */
+			p += nchar;
+			len -= nchar;
+		}
+		if (len > 0) {
+			nchar = snprintf(p, len, "%02x ", buf[i]);
+			p += nchar;
+			len -= nchar;
+		}
+
+		if (i % 16 == 15) {
+			printf("%s\n", line);	/* flush line */
+			p = line;
+			len = sizeof(line);
+		}
+	}
+
+	/* flush last partial line */
+	if (p != line)
+		printf("%s\n", line);
+}
+
+static const char *crypto_algo_names[] = {
+	"NONE",
+	"WEP1",
+	"TKIP",
+	"WEP128",
+	"AES_CCM",
+	"NALG" "UNDEF",
+	"UNDEF",
+	"UNDEF",
+	"UNDEF"
+};
+
+const char *bcm_crypto_algo_name(uint algo)
+{
+	return (algo <
+		ARRAYSIZE(crypto_algo_names)) ? crypto_algo_names[algo] : "ERR";
+}
+
+#ifdef BCMDBG
+void deadbeef(void *p, uint len)
+{
+	static uint8 meat[] = { 0xde, 0xad, 0xbe, 0xef };
+
+	while (len-- > 0) {
+		*(uint8 *) p = meat[((uintptr) p) & 3];
+		p = (uint8 *) p + 1;
+	}
+}
+#endif				/* BCMDBG */
+
+char *bcm_chipname(uint chipid, char *buf, uint len)
+{
+	const char *fmt;
+
+	fmt = ((chipid > 0xa000) || (chipid < 0x4000)) ? "%d" : "%x";
+	snprintf(buf, len, fmt, chipid);
+	return buf;
+}
+
+/* Produce a human-readable string for boardrev */
+char *bcm_brev_str(uint32 brev, char *buf)
+{
+	if (brev < 0x100)
+		snprintf(buf, 8, "%d.%d", (brev & 0xf0) >> 4, brev & 0xf);
+	else
+		snprintf(buf, 8, "%c%03x",
+			 ((brev & 0xf000) == 0x1000) ? 'P' : 'A', brev & 0xfff);
+
+	return (buf);
+}
+
+#define BUFSIZE_TODUMP_ATONCE 512	/* Buffer size */
+
+/* dump large strings to console */
+void printbig(char *buf)
+{
+	uint len, max_len;
+	char c;
+
+	len = strlen(buf);
+
+	max_len = BUFSIZE_TODUMP_ATONCE;
+
+	while (len > max_len) {
+		c = buf[max_len];
+		buf[max_len] = '\0';
+		printf("%s", buf);
+		buf[max_len] = c;
+
+		buf += max_len;
+		len -= max_len;
+	}
+	/* print the remaining string */
+	printf("%s\n", buf);
+	return;
+}
+
+/* routine to dump fields in a fileddesc structure */
+uint
+bcmdumpfields(bcmutl_rdreg_rtn read_rtn, void *arg0, uint arg1,
+	      struct fielddesc * fielddesc_array, char *buf, uint32 bufsize)
+{
+	uint filled_len;
+	int len;
+	struct fielddesc *cur_ptr;
+
+	filled_len = 0;
+	cur_ptr = fielddesc_array;
+
+	while (bufsize > 1) {
+		if (cur_ptr->nameandfmt == NULL)
+			break;
+		len = snprintf(buf, bufsize, cur_ptr->nameandfmt,
+			       read_rtn(arg0, arg1, cur_ptr->offset));
+		/* check for snprintf overflow or error */
+		if (len < 0 || (uint32) len >= bufsize)
+			len = bufsize - 1;
+		buf += len;
+		bufsize -= len;
+		filled_len += len;
+		cur_ptr++;
+	}
+	return filled_len;
+}
+
+uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf, uint buflen)
+{
+	uint len;
+
+	len = strlen(name) + 1;
+
+	if ((len + datalen) > buflen)
+		return 0;
+
+	strncpy(buf, name, buflen);
+
+	/* append data onto the end of the name string */
+	memcpy(&buf[len], data, datalen);
+	len += datalen;
+
+	return len;
+}
+
+/* Quarter dBm units to mW
+ * Table starts at QDBM_OFFSET, so the first entry is mW for qdBm=153
+ * Table is offset so the last entry is largest mW value that fits in
+ * a uint16.
+ */
+
+#define QDBM_OFFSET 153		/* Offset for first entry */
+#define QDBM_TABLE_LEN 40	/* Table size */
+
+/* Smallest mW value that will round up to the first table entry, QDBM_OFFSET.
+ * Value is ( mW(QDBM_OFFSET - 1) + mW(QDBM_OFFSET) ) / 2
+ */
+#define QDBM_TABLE_LOW_BOUND 6493	/* Low bound */
+
+/* Largest mW value that will round down to the last table entry,
+ * QDBM_OFFSET + QDBM_TABLE_LEN-1.
+ * Value is ( mW(QDBM_OFFSET + QDBM_TABLE_LEN - 1) + mW(QDBM_OFFSET + QDBM_TABLE_LEN) ) / 2.
+ */
+#define QDBM_TABLE_HIGH_BOUND 64938	/* High bound */
+
+static const uint16 nqdBm_to_mW_map[QDBM_TABLE_LEN] = {
+/* qdBm: 	+0 	+1 	+2 	+3 	+4 	+5 	+6 	+7 */
+/* 153: */ 6683, 7079, 7499, 7943, 8414, 8913, 9441, 10000,
+/* 161: */ 10593, 11220, 11885, 12589, 13335, 14125, 14962, 15849,
+/* 169: */ 16788, 17783, 18836, 19953, 21135, 22387, 23714, 25119,
+/* 177: */ 26607, 28184, 29854, 31623, 33497, 35481, 37584, 39811,
+/* 185: */ 42170, 44668, 47315, 50119, 53088, 56234, 59566, 63096
+};
+
+uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm) {
+	uint factor = 1;
+	int idx = qdbm - QDBM_OFFSET;
+
+	if (idx >= QDBM_TABLE_LEN) {
+		/* clamp to max uint16 mW value */
+		return 0xFFFF;
+	}
+
+	/* scale the qdBm index up to the range of the table 0-40
+	 * where an offset of 40 qdBm equals a factor of 10 mW.
+	 */
+	while (idx < 0) {
+		idx += 40;
+		factor *= 10;
+	}
+
+	/* return the mW value scaled down to the correct factor of 10,
+	 * adding in factor/2 to get proper rounding.
+	 */
+	return ((nqdBm_to_mW_map[idx] + factor / 2) / factor);
+}
+
+uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw) {
+	uint8 qdbm;
+	int offset;
+	uint mw_uint = mw;
+	uint boundary;
+
+	/* handle boundary case */
+	if (mw_uint <= 1)
+		return 0;
+
+	offset = QDBM_OFFSET;
+
+	/* move mw into the range of the table */
+	while (mw_uint < QDBM_TABLE_LOW_BOUND) {
+		mw_uint *= 10;
+		offset -= 40;
+	}
+
+	for (qdbm = 0; qdbm < QDBM_TABLE_LEN - 1; qdbm++) {
+		boundary = nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm + 1] -
+						    nqdBm_to_mW_map[qdbm]) / 2;
+		if (mw_uint < boundary)
+			break;
+	}
+
+	qdbm += (uint8) offset;
+
+	return (qdbm);
+}
+
+uint BCMROMFN(bcm_bitcount) (uint8 * bitmap, uint length) {
+	uint bitcount = 0, i;
+	uint8 tmp;
+	for (i = 0; i < length; i++) {
+		tmp = bitmap[i];
+		while (tmp) {
+			bitcount++;
+			tmp &= (tmp - 1);
+		}
+	}
+	return bitcount;
+}
+
+/* Initialization of bcmstrbuf structure */
+void bcm_binit(struct bcmstrbuf *b, char *buf, uint size)
+{
+	b->origsize = b->size = size;
+	b->origbuf = b->buf = buf;
+}
+
+/* Buffer sprintf wrapper to guard against buffer overflow */
+int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...)
+{
+	va_list ap;
+	int r;
+
+	va_start(ap, fmt);
+	r = vsnprintf(b->buf, b->size, fmt, ap);
+
+	/* Non Ansi C99 compliant returns -1,
+	 * Ansi compliant return r >= b->size,
+	 * bcmstdlib returns 0, handle all
+	 */
+	if ((r == -1) || (r >= (int)b->size) || (r == 0)) {
+		b->size = 0;
+	} else {
+		b->size -= r;
+		b->buf += r;
+	}
+
+	va_end(ap);
+
+	return r;
+}
+
+void bcm_inc_bytes(uchar * num, int num_bytes, uint8 amount)
+{
+	int i;
+
+	for (i = 0; i < num_bytes; i++) {
+		num[i] += amount;
+		if (num[i] >= amount)
+			break;
+		amount = 1;
+	}
+}
+
+int bcm_cmp_bytes(uchar * arg1, uchar * arg2, uint8 nbytes)
+{
+	int i;
+
+	for (i = nbytes - 1; i >= 0; i--) {
+		if (arg1[i] != arg2[i])
+			return (arg1[i] - arg2[i]);
+	}
+	return 0;
+}
+
+void bcm_print_bytes(char *name, const uchar * data, int len)
+{
+	int i;
+	int per_line = 0;
+
+	printf("%s: %d\n", name ? name : "", len);
+	for (i = 0; i < len; i++) {
+		printf("%02x ", *data++);
+		per_line++;
+		if (per_line == 16) {
+			per_line = 0;
+			printf("\n");
+		}
+	}
+	printf("\n");
+}
+
+#if defined(BCMDBG)
+#define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)
+int bcm_format_ssid(char *buf, const uchar ssid[], uint ssid_len)
+{
+	uint i, c;
+	char *p = buf;
+	char *endp = buf + SSID_FMT_BUF_LEN;
+
+	if (ssid_len > DOT11_MAX_SSID_LEN)
+		ssid_len = DOT11_MAX_SSID_LEN;
+
+	for (i = 0; i < ssid_len; i++) {
+		c = (uint) ssid[i];
+		if (c == '\\') {
+			*p++ = '\\';
+			*p++ = '\\';
+		} else if (bcm_isprint((uchar) c)) {
+			*p++ = (char)c;
+		} else {
+			p += snprintf(p, (endp - p), "\\x%02X", c);
+		}
+	}
+	*p = '\0';
+	ASSERT(p < endp);
+
+	return (int)(p - buf);
+}
+#endif				/* defined(BCMDBG) */
diff --git a/drivers/staging/brcm80211/util/bcmwifi.c b/drivers/staging/brcm80211/util/bcmwifi.c
new file mode 100644
index 0000000..ae5ff88
--- /dev/null
+++ b/drivers/staging/brcm80211/util/bcmwifi.c
@@ -0,0 +1,318 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+
+#include <osl.h>
+#include <bcmutils.h>
+#define strtoul(nptr, endptr, base) bcm_strtoul((nptr), (endptr), (base))
+#define tolower(c) (bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
+#include <bcmwifi.h>
+
+/* Chanspec ASCII representation:
+ * <channel><band><bandwidth><ctl-sideband>
+ *   digit   [AB]     [N]        [UL]
+ *
+ * <channel>: channel number of the 10MHz or 20MHz channel,
+ *	or control sideband channel of 40MHz channel.
+ * <band>: A for 5GHz, B for 2.4GHz
+ * <bandwidth>: N for 10MHz, nothing for 20MHz or 40MHz
+ *	(ctl-sideband spec implies 40MHz)
+ * <ctl-sideband>: U for upper, L for lower
+ *
+ * <band> may be omitted on input, and will be assumed to be
+ * 2.4GHz if channel number <= 14.
+ *
+ * Examples:
+ *	8  ->  2.4GHz channel 8, 20MHz
+ *	8b ->  2.4GHz channel 8, 20MHz
+ *	8l ->  2.4GHz channel 8, 40MHz, lower ctl sideband
+ *	8a ->  5GHz channel 8 (low 5 GHz band), 20MHz
+ *	36 ->  5GHz channel 36, 20MHz
+ *	36l -> 5GHz channel 36, 40MHz, lower ctl sideband
+ *	40u -> 5GHz channel 40, 40MHz, upper ctl sideband
+ *	180n -> channel 180, 10MHz
+ */
+
+/* given a chanspec and a string buffer, format the chanspec as a
+ * string, and return the original pointer a.
+ * Min buffer length must be CHANSPEC_STR_LEN.
+ * On error return NULL
+ */
+char *wf_chspec_ntoa(chanspec_t chspec, char *buf)
+{
+	const char *band, *bw, *sb;
+	uint channel;
+
+	band = "";
+	bw = "";
+	sb = "";
+	channel = CHSPEC_CHANNEL(chspec);
+	/* check for non-default band spec */
+	if ((CHSPEC_IS2G(chspec) && channel > CH_MAX_2G_CHANNEL) ||
+	    (CHSPEC_IS5G(chspec) && channel <= CH_MAX_2G_CHANNEL))
+		band = (CHSPEC_IS2G(chspec)) ? "b" : "a";
+	if (CHSPEC_IS40(chspec)) {
+		if (CHSPEC_SB_UPPER(chspec)) {
+			sb = "u";
+			channel += CH_10MHZ_APART;
+		} else {
+			sb = "l";
+			channel -= CH_10MHZ_APART;
+		}
+	} else if (CHSPEC_IS10(chspec)) {
+		bw = "n";
+	}
+
+	/* Outputs a max of 6 chars including '\0'  */
+	snprintf(buf, 6, "%d%s%s%s", channel, band, bw, sb);
+	return (buf);
+}
+
+/* given a chanspec string, convert to a chanspec.
+ * On error return 0
+ */
+chanspec_t wf_chspec_aton(char *a)
+{
+	char *endp = NULL;
+	uint channel, band, bw, ctl_sb;
+	char c;
+
+	channel = strtoul(a, &endp, 10);
+
+	/* check for no digits parsed */
+	if (endp == a)
+		return 0;
+
+	if (channel > MAXCHANNEL)
+		return 0;
+
+	band =
+	    ((channel <=
+	      CH_MAX_2G_CHANNEL) ? WL_CHANSPEC_BAND_2G : WL_CHANSPEC_BAND_5G);
+	bw = WL_CHANSPEC_BW_20;
+	ctl_sb = WL_CHANSPEC_CTL_SB_NONE;
+
+	a = endp;
+
+	c = tolower(a[0]);
+	if (c == '\0')
+		goto done;
+
+	/* parse the optional ['A' | 'B'] band spec */
+	if (c == 'a' || c == 'b') {
+		band = (c == 'a') ? WL_CHANSPEC_BAND_5G : WL_CHANSPEC_BAND_2G;
+		a++;
+		c = tolower(a[0]);
+		if (c == '\0')
+			goto done;
+	}
+
+	/* parse bandwidth 'N' (10MHz) or 40MHz ctl sideband ['L' | 'U'] */
+	if (c == 'n') {
+		bw = WL_CHANSPEC_BW_10;
+	} else if (c == 'l') {
+		bw = WL_CHANSPEC_BW_40;
+		ctl_sb = WL_CHANSPEC_CTL_SB_LOWER;
+		/* adjust channel to center of 40MHz band */
+		if (channel <= (MAXCHANNEL - CH_20MHZ_APART))
+			channel += CH_10MHZ_APART;
+		else
+			return 0;
+	} else if (c == 'u') {
+		bw = WL_CHANSPEC_BW_40;
+		ctl_sb = WL_CHANSPEC_CTL_SB_UPPER;
+		/* adjust channel to center of 40MHz band */
+		if (channel > CH_20MHZ_APART)
+			channel -= CH_10MHZ_APART;
+		else
+			return 0;
+	} else {
+		return 0;
+	}
+
+ done:
+	return (channel | band | bw | ctl_sb);
+}
+
+/*
+ * Verify the chanspec is using a legal set of parameters, i.e. that the
+ * chanspec specified a band, bw, ctl_sb and channel and that the
+ * combination could be legal given any set of circumstances.
+ * RETURNS: TRUE is the chanspec is malformed, false if it looks good.
+ */
+bool wf_chspec_malformed(chanspec_t chanspec)
+{
+	/* must be 2G or 5G band */
+	if (!CHSPEC_IS5G(chanspec) && !CHSPEC_IS2G(chanspec))
+		return TRUE;
+	/* must be 20 or 40 bandwidth */
+	if (!CHSPEC_IS40(chanspec) && !CHSPEC_IS20(chanspec))
+		return TRUE;
+
+	/* 20MHZ b/w must have no ctl sb, 40 must have a ctl sb */
+	if (CHSPEC_IS20(chanspec)) {
+		if (!CHSPEC_SB_NONE(chanspec))
+			return TRUE;
+	} else {
+		if (!CHSPEC_SB_UPPER(chanspec) && !CHSPEC_SB_LOWER(chanspec))
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+/*
+ * This function returns the channel number that control traffic is being sent on, for legacy
+ * channels this is just the channel number, for 40MHZ channels it is the upper or lowre 20MHZ
+ * sideband depending on the chanspec selected
+ */
+uint8 wf_chspec_ctlchan(chanspec_t chspec)
+{
+	uint8 ctl_chan;
+
+	/* Is there a sideband ? */
+	if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_NONE) {
+		return CHSPEC_CHANNEL(chspec);
+	} else {
+		/* we only support 40MHZ with sidebands */
+		ASSERT(CHSPEC_BW(chspec) == WL_CHANSPEC_BW_40);
+		/* chanspec channel holds the centre frequency, use that and the
+		 * side band information to reconstruct the control channel number
+		 */
+		if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_UPPER) {
+			/* control chan is the upper 20 MHZ SB of the 40MHZ channel */
+			ctl_chan = UPPER_20_SB(CHSPEC_CHANNEL(chspec));
+		} else {
+			ASSERT(CHSPEC_CTL_SB(chspec) ==
+			       WL_CHANSPEC_CTL_SB_LOWER);
+			/* control chan is the lower 20 MHZ SB of the 40MHZ channel */
+			ctl_chan = LOWER_20_SB(CHSPEC_CHANNEL(chspec));
+		}
+	}
+
+	return ctl_chan;
+}
+
+chanspec_t wf_chspec_ctlchspec(chanspec_t chspec)
+{
+	chanspec_t ctl_chspec = 0;
+	uint8 channel;
+
+	ASSERT(!wf_chspec_malformed(chspec));
+
+	/* Is there a sideband ? */
+	if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_NONE) {
+		return chspec;
+	} else {
+		if (CHSPEC_CTL_SB(chspec) == WL_CHANSPEC_CTL_SB_UPPER) {
+			channel = UPPER_20_SB(CHSPEC_CHANNEL(chspec));
+		} else {
+			channel = LOWER_20_SB(CHSPEC_CHANNEL(chspec));
+		}
+		ctl_chspec =
+		    channel | WL_CHANSPEC_BW_20 | WL_CHANSPEC_CTL_SB_NONE;
+		ctl_chspec |= CHSPEC_BAND(chspec);
+	}
+	return ctl_chspec;
+}
+
+/*
+ * Return the channel number for a given frequency and base frequency.
+ * The returned channel number is relative to the given base frequency.
+ * If the given base frequency is zero, a base frequency of 5 GHz is assumed for
+ * frequencies from 5 - 6 GHz, and 2.407 GHz is assumed for 2.4 - 2.5 GHz.
+ *
+ * Frequency is specified in MHz.
+ * The base frequency is specified as (start_factor * 500 kHz).
+ * Constants WF_CHAN_FACTOR_2_4_G, WF_CHAN_FACTOR_5_G are defined for
+ * 2.4 GHz and 5 GHz bands.
+ *
+ * The returned channel will be in the range [1, 14] in the 2.4 GHz band
+ * and [0, 200] otherwise.
+ * -1 is returned if the start_factor is WF_CHAN_FACTOR_2_4_G and the
+ * frequency is not a 2.4 GHz channel, or if the frequency is not and even
+ * multiple of 5 MHz from the base frequency to the base plus 1 GHz.
+ *
+ * Reference 802.11 REVma, section 17.3.8.3, and 802.11B section 18.4.6.2
+ */
+int wf_mhz2channel(uint freq, uint start_factor)
+{
+	int ch = -1;
+	uint base;
+	int offset;
+
+	/* take the default channel start frequency */
+	if (start_factor == 0) {
+		if (freq >= 2400 && freq <= 2500)
+			start_factor = WF_CHAN_FACTOR_2_4_G;
+		else if (freq >= 5000 && freq <= 6000)
+			start_factor = WF_CHAN_FACTOR_5_G;
+	}
+
+	if (freq == 2484 && start_factor == WF_CHAN_FACTOR_2_4_G)
+		return 14;
+
+	base = start_factor / 2;
+
+	/* check that the frequency is in 1GHz range of the base */
+	if ((freq < base) || (freq > base + 1000))
+		return -1;
+
+	offset = freq - base;
+	ch = offset / 5;
+
+	/* check that frequency is a 5MHz multiple from the base */
+	if (offset != (ch * 5))
+		return -1;
+
+	/* restricted channel range check for 2.4G */
+	if (start_factor == WF_CHAN_FACTOR_2_4_G && (ch < 1 || ch > 13))
+		return -1;
+
+	return ch;
+}
+
+/*
+ * Return the center frequency in MHz of the given channel and base frequency.
+ * The channel number is interpreted relative to the given base frequency.
+ *
+ * The valid channel range is [1, 14] in the 2.4 GHz band and [0, 200] otherwise.
+ * The base frequency is specified as (start_factor * 500 kHz).
+ * Constants WF_CHAN_FACTOR_2_4_G, WF_CHAN_FACTOR_4_G, and WF_CHAN_FACTOR_5_G
+ * are defined for 2.4 GHz, 4 GHz, and 5 GHz bands.
+ * The channel range of [1, 14] is only checked for a start_factor of
+ * WF_CHAN_FACTOR_2_4_G (4814 = 2407 * 2).
+ * Odd start_factors produce channels on .5 MHz boundaries, in which case
+ * the answer is rounded down to an integral MHz.
+ * -1 is returned for an out of range channel.
+ *
+ * Reference 802.11 REVma, section 17.3.8.3, and 802.11B section 18.4.6.2
+ */
+int wf_channel2mhz(uint ch, uint start_factor)
+{
+	int freq;
+
+	if ((start_factor == WF_CHAN_FACTOR_2_4_G && (ch < 1 || ch > 14)) ||
+	    (ch > 200))
+		freq = -1;
+	else if ((start_factor == WF_CHAN_FACTOR_2_4_G) && (ch == 14))
+		freq = 2484;
+	else
+		freq = ch * 5 + start_factor / 2;
+
+	return freq;
+}
diff --git a/drivers/staging/brcm80211/util/bcmwpa.c b/drivers/staging/brcm80211/util/bcmwpa.c
new file mode 100644
index 0000000..d1b7c8d
--- /dev/null
+++ b/drivers/staging/brcm80211/util/bcmwpa.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <bcmutils.h>
+#include <bcmwpa.h>
+
+/* Is this body of this tlvs entry a WFA entry? If
+ * not update the tlvs buffer pointer/length.
+ */
+bool bcm_is_wfa_ie(uint8 * ie, uint8 ** tlvs, uint * tlvs_len, uint8 type)
+{
+	/* If the contents match the WFA_OUI and type */
+	if ((ie[TLV_LEN_OFF] > (WFA_OUI_LEN + 1)) &&
+	    !bcmp(&ie[TLV_BODY_OFF], WFA_OUI, WFA_OUI_LEN) &&
+	    type == ie[TLV_BODY_OFF + WFA_OUI_LEN]) {
+		return TRUE;
+	}
+
+	/* point to the next ie */
+	ie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;
+	/* calculate the length of the rest of the buffer */
+	*tlvs_len -= (int)(ie - *tlvs);
+	/* update the pointer to the start of the buffer */
+	*tlvs = ie;
+
+	return FALSE;
+}
+
+wpa_ie_fixed_t *BCMROMFN(bcm_find_wpaie) (uint8 * parse, uint len) {
+	bcm_tlv_t *ie;
+
+	while ((ie = bcm_parse_tlvs(parse, len, DOT11_MNG_VS_ID))) {
+		if (bcm_is_wpa_ie((uint8 *) ie, &parse, &len)) {
+			return (wpa_ie_fixed_t *) ie;
+		}
+	}
+	return NULL;
+}
diff --git a/drivers/staging/brcm80211/util/hnddma.c b/drivers/staging/brcm80211/util/hnddma.c
new file mode 100644
index 0000000..5b59ad8
--- /dev/null
+++ b/drivers/staging/brcm80211/util/hnddma.c
@@ -0,0 +1,2689 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <bcmdevs.h>
+#include <osl.h>
+#include <bcmendian.h>
+#include <hndsoc.h>
+#include <bcmutils.h>
+#include <siutils.h>
+
+#include <sbhnddma.h>
+#include <hnddma.h>
+
+/* debug/trace */
+#ifdef BCMDBG
+#define	DMA_ERROR(args) if (!(*di->msg_level & 1)); else printf args
+#define	DMA_TRACE(args) if (!(*di->msg_level & 2)); else printf args
+#else
+#define	DMA_ERROR(args)
+#define	DMA_TRACE(args)
+#endif				/* BCMDBG */
+
+#define	DMA_NONE(args)
+
+#define d32txregs	dregs.d32_u.txregs_32
+#define d32rxregs	dregs.d32_u.rxregs_32
+#define txd32		dregs.d32_u.txd_32
+#define rxd32		dregs.d32_u.rxd_32
+
+#define d64txregs	dregs.d64_u.txregs_64
+#define d64rxregs	dregs.d64_u.rxregs_64
+#define txd64		dregs.d64_u.txd_64
+#define rxd64		dregs.d64_u.rxd_64
+
+/* default dma message level (if input msg_level pointer is null in dma_attach()) */
+static uint dma_msg_level = 0;
+
+#define	MAXNAMEL	8	/* 8 char names */
+
+#define	DI_INFO(dmah)	((dma_info_t *)dmah)
+
+/* dma engine software state */
+typedef struct dma_info {
+	struct hnddma_pub hnddma;	/* exported structure, don't use hnddma_t,
+					 * which could be const
+					 */
+	uint *msg_level;	/* message level pointer */
+	char name[MAXNAMEL];	/* callers name for diag msgs */
+
+	void *osh;		/* os handle */
+	si_t *sih;		/* sb handle */
+
+	bool dma64;		/* this dma engine is operating in 64-bit mode */
+	bool addrext;		/* this dma engine supports DmaExtendedAddrChanges */
+
+	union {
+		struct {
+			dma32regs_t *txregs_32;	/* 32-bit dma tx engine registers */
+			dma32regs_t *rxregs_32;	/* 32-bit dma rx engine registers */
+			dma32dd_t *txd_32;	/* pointer to dma32 tx descriptor ring */
+			dma32dd_t *rxd_32;	/* pointer to dma32 rx descriptor ring */
+		} d32_u;
+		struct {
+			dma64regs_t *txregs_64;	/* 64-bit dma tx engine registers */
+			dma64regs_t *rxregs_64;	/* 64-bit dma rx engine registers */
+			dma64dd_t *txd_64;	/* pointer to dma64 tx descriptor ring */
+			dma64dd_t *rxd_64;	/* pointer to dma64 rx descriptor ring */
+		} d64_u;
+	} dregs;
+
+	uint16 dmadesc_align;	/* alignment requirement for dma descriptors */
+
+	uint16 ntxd;		/* # tx descriptors tunable */
+	uint16 txin;		/* index of next descriptor to reclaim */
+	uint16 txout;		/* index of next descriptor to post */
+	void **txp;		/* pointer to parallel array of pointers to packets */
+	osldma_t *tx_dmah;	/* DMA TX descriptor ring handle */
+	hnddma_seg_map_t *txp_dmah;	/* DMA MAP meta-data handle */
+	dmaaddr_t txdpa;	/* Aligned physical address of descriptor ring */
+	dmaaddr_t txdpaorig;	/* Original physical address of descriptor ring */
+	uint16 txdalign;	/* #bytes added to alloc'd mem to align txd */
+	uint32 txdalloc;	/* #bytes allocated for the ring */
+	uint32 xmtptrbase;	/* When using unaligned descriptors, the ptr register
+				 * is not just an index, it needs all 13 bits to be
+				 * an offset from the addr register.
+				 */
+
+	uint16 nrxd;		/* # rx descriptors tunable */
+	uint16 rxin;		/* index of next descriptor to reclaim */
+	uint16 rxout;		/* index of next descriptor to post */
+	void **rxp;		/* pointer to parallel array of pointers to packets */
+	osldma_t *rx_dmah;	/* DMA RX descriptor ring handle */
+	hnddma_seg_map_t *rxp_dmah;	/* DMA MAP meta-data handle */
+	dmaaddr_t rxdpa;	/* Aligned physical address of descriptor ring */
+	dmaaddr_t rxdpaorig;	/* Original physical address of descriptor ring */
+	uint16 rxdalign;	/* #bytes added to alloc'd mem to align rxd */
+	uint32 rxdalloc;	/* #bytes allocated for the ring */
+	uint32 rcvptrbase;	/* Base for ptr reg when using unaligned descriptors */
+
+	/* tunables */
+	uint16 rxbufsize;	/* rx buffer size in bytes,
+				 * not including the extra headroom
+				 */
+	uint rxextrahdrroom;	/* extra rx headroom, reverseved to assist upper stack
+				 *  e.g. some rx pkt buffers will be bridged to tx side
+				 *  without byte copying. The extra headroom needs to be
+				 *  large enough to fit txheader needs.
+				 *  Some dongle driver may not need it.
+				 */
+	uint nrxpost;		/* # rx buffers to keep posted */
+	uint rxoffset;		/* rxcontrol offset */
+	uint ddoffsetlow;	/* add to get dma address of descriptor ring, low 32 bits */
+	uint ddoffsethigh;	/*   high 32 bits */
+	uint dataoffsetlow;	/* add to get dma address of data buffer, low 32 bits */
+	uint dataoffsethigh;	/*   high 32 bits */
+	bool aligndesc_4k;	/* descriptor base need to be aligned or not */
+} dma_info_t;
+
+/*
+ * If BCMDMA32 is defined, hnddma will support both 32-bit and 64-bit DMA engines.
+ * Otherwise it will support only 64-bit.
+ *
+ * DMA32_ENAB indicates whether hnddma is compiled with support for 32-bit DMA engines.
+ * DMA64_ENAB indicates whether hnddma is compiled with support for 64-bit DMA engines.
+ *
+ * DMA64_MODE indicates whether the current DMA engine is running as 64-bit.
+ */
+#ifdef BCMDMA32
+#define	DMA32_ENAB(di)		1
+#define	DMA64_ENAB(di)		1
+#define	DMA64_MODE(di)		((di)->dma64)
+#else				/* !BCMDMA32 */
+#define	DMA32_ENAB(di)		0
+#define	DMA64_ENAB(di)		1
+#define	DMA64_MODE(di)		1
+#endif				/* !BCMDMA32 */
+
+/* DMA Scatter-gather list is supported. Note this is limited to TX direction only */
+#ifdef BCMDMASGLISTOSL
+#define DMASGLIST_ENAB TRUE
+#else
+#define DMASGLIST_ENAB FALSE
+#endif				/* BCMDMASGLISTOSL */
+
+/* descriptor bumping macros */
+#define	XXD(x, n)	((x) & ((n) - 1))	/* faster than %, but n must be power of 2 */
+#define	TXD(x)		XXD((x), di->ntxd)
+#define	RXD(x)		XXD((x), di->nrxd)
+#define	NEXTTXD(i)	TXD((i) + 1)
+#define	PREVTXD(i)	TXD((i) - 1)
+#define	NEXTRXD(i)	RXD((i) + 1)
+#define	PREVRXD(i)	RXD((i) - 1)
+
+#define	NTXDACTIVE(h, t)	TXD((t) - (h))
+#define	NRXDACTIVE(h, t)	RXD((t) - (h))
+
+/* macros to convert between byte offsets and indexes */
+#define	B2I(bytes, type)	((bytes) / sizeof(type))
+#define	I2B(index, type)	((index) * sizeof(type))
+
+#define	PCI32ADDR_HIGH		0xc0000000	/* address[31:30] */
+#define	PCI32ADDR_HIGH_SHIFT	30	/* address[31:30] */
+
+#define	PCI64ADDR_HIGH		0x80000000	/* address[63] */
+#define	PCI64ADDR_HIGH_SHIFT	31	/* address[63] */
+
+/* Common prototypes */
+static bool _dma_isaddrext(dma_info_t * di);
+static bool _dma_descriptor_align(dma_info_t * di);
+static bool _dma_alloc(dma_info_t * di, uint direction);
+static void _dma_detach(dma_info_t * di);
+static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa);
+static void _dma_rxinit(dma_info_t * di);
+static void *_dma_rx(dma_info_t * di);
+static bool _dma_rxfill(dma_info_t * di);
+static void _dma_rxreclaim(dma_info_t * di);
+static void _dma_rxenable(dma_info_t * di);
+static void *_dma_getnextrxp(dma_info_t * di, bool forceall);
+static void _dma_rx_param_get(dma_info_t * di, uint16 * rxoffset,
+			      uint16 * rxbufsize);
+
+static void _dma_txblock(dma_info_t * di);
+static void _dma_txunblock(dma_info_t * di);
+static uint _dma_txactive(dma_info_t * di);
+static uint _dma_rxactive(dma_info_t * di);
+static uint _dma_txpending(dma_info_t * di);
+static uint _dma_txcommitted(dma_info_t * di);
+
+static void *_dma_peeknexttxp(dma_info_t * di);
+static void *_dma_peeknextrxp(dma_info_t * di);
+static uintptr _dma_getvar(dma_info_t * di, const char *name);
+static void _dma_counterreset(dma_info_t * di);
+static void _dma_fifoloopbackenable(dma_info_t * di);
+static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags);
+static uint8 dma_align_sizetobits(uint size);
+static void *dma_ringalloc(osl_t * osh, uint32 boundary, uint size,
+			   uint16 * alignbits, uint * alloced,
+			   dmaaddr_t * descpa, osldma_t ** dmah);
+
+/* Prototypes for 32-bit routines */
+static bool dma32_alloc(dma_info_t * di, uint direction);
+static bool dma32_txreset(dma_info_t * di);
+static bool dma32_rxreset(dma_info_t * di);
+static bool dma32_txsuspendedidle(dma_info_t * di);
+static int dma32_txfast(dma_info_t * di, void *p0, bool commit);
+static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range);
+static void *dma32_getnextrxp(dma_info_t * di, bool forceall);
+static void dma32_txrotate(dma_info_t * di);
+static bool dma32_rxidle(dma_info_t * di);
+static void dma32_txinit(dma_info_t * di);
+static bool dma32_txenabled(dma_info_t * di);
+static void dma32_txsuspend(dma_info_t * di);
+static void dma32_txresume(dma_info_t * di);
+static bool dma32_txsuspended(dma_info_t * di);
+static void dma32_txreclaim(dma_info_t * di, txd_range_t range);
+static bool dma32_txstopped(dma_info_t * di);
+static bool dma32_rxstopped(dma_info_t * di);
+static bool dma32_rxenabled(dma_info_t * di);
+
+static bool _dma32_addrext(osl_t * osh, dma32regs_t * dma32regs);
+
+/* Prototypes for 64-bit routines */
+static bool dma64_alloc(dma_info_t * di, uint direction);
+static bool dma64_txreset(dma_info_t * di);
+static bool dma64_rxreset(dma_info_t * di);
+static bool dma64_txsuspendedidle(dma_info_t * di);
+static int dma64_txfast(dma_info_t * di, void *p0, bool commit);
+static int dma64_txunframed(dma_info_t * di, void *p0, uint len, bool commit);
+static void *dma64_getpos(dma_info_t * di, bool direction);
+static void *dma64_getnexttxp(dma_info_t * di, txd_range_t range);
+static void *dma64_getnextrxp(dma_info_t * di, bool forceall);
+static void dma64_txrotate(dma_info_t * di);
+
+static bool dma64_rxidle(dma_info_t * di);
+static void dma64_txinit(dma_info_t * di);
+static bool dma64_txenabled(dma_info_t * di);
+static void dma64_txsuspend(dma_info_t * di);
+static void dma64_txresume(dma_info_t * di);
+static bool dma64_txsuspended(dma_info_t * di);
+static void dma64_txreclaim(dma_info_t * di, txd_range_t range);
+static bool dma64_txstopped(dma_info_t * di);
+static bool dma64_rxstopped(dma_info_t * di);
+static bool dma64_rxenabled(dma_info_t * di);
+static bool _dma64_addrext(osl_t * osh, dma64regs_t * dma64regs);
+
+STATIC INLINE uint32 parity32(uint32 data);
+
+const di_fcn_t dma64proc = {
+	(di_detach_t) _dma_detach,
+	(di_txinit_t) dma64_txinit,
+	(di_txreset_t) dma64_txreset,
+	(di_txenabled_t) dma64_txenabled,
+	(di_txsuspend_t) dma64_txsuspend,
+	(di_txresume_t) dma64_txresume,
+	(di_txsuspended_t) dma64_txsuspended,
+	(di_txsuspendedidle_t) dma64_txsuspendedidle,
+	(di_txfast_t) dma64_txfast,
+	(di_txunframed_t) dma64_txunframed,
+	(di_getpos_t) dma64_getpos,
+	(di_txstopped_t) dma64_txstopped,
+	(di_txreclaim_t) dma64_txreclaim,
+	(di_getnexttxp_t) dma64_getnexttxp,
+	(di_peeknexttxp_t) _dma_peeknexttxp,
+	(di_txblock_t) _dma_txblock,
+	(di_txunblock_t) _dma_txunblock,
+	(di_txactive_t) _dma_txactive,
+	(di_txrotate_t) dma64_txrotate,
+
+	(di_rxinit_t) _dma_rxinit,
+	(di_rxreset_t) dma64_rxreset,
+	(di_rxidle_t) dma64_rxidle,
+	(di_rxstopped_t) dma64_rxstopped,
+	(di_rxenable_t) _dma_rxenable,
+	(di_rxenabled_t) dma64_rxenabled,
+	(di_rx_t) _dma_rx,
+	(di_rxfill_t) _dma_rxfill,
+	(di_rxreclaim_t) _dma_rxreclaim,
+	(di_getnextrxp_t) _dma_getnextrxp,
+	(di_peeknextrxp_t) _dma_peeknextrxp,
+	(di_rxparam_get_t) _dma_rx_param_get,
+
+	(di_fifoloopbackenable_t) _dma_fifoloopbackenable,
+	(di_getvar_t) _dma_getvar,
+	(di_counterreset_t) _dma_counterreset,
+	(di_ctrlflags_t) _dma_ctrlflags,
+	NULL,
+	NULL,
+	NULL,
+	(di_rxactive_t) _dma_rxactive,
+	(di_txpending_t) _dma_txpending,
+	(di_txcommitted_t) _dma_txcommitted,
+	39
+};
+
+static const di_fcn_t dma32proc = {
+	(di_detach_t) _dma_detach,
+	(di_txinit_t) dma32_txinit,
+	(di_txreset_t) dma32_txreset,
+	(di_txenabled_t) dma32_txenabled,
+	(di_txsuspend_t) dma32_txsuspend,
+	(di_txresume_t) dma32_txresume,
+	(di_txsuspended_t) dma32_txsuspended,
+	(di_txsuspendedidle_t) dma32_txsuspendedidle,
+	(di_txfast_t) dma32_txfast,
+	NULL,
+	NULL,
+	(di_txstopped_t) dma32_txstopped,
+	(di_txreclaim_t) dma32_txreclaim,
+	(di_getnexttxp_t) dma32_getnexttxp,
+	(di_peeknexttxp_t) _dma_peeknexttxp,
+	(di_txblock_t) _dma_txblock,
+	(di_txunblock_t) _dma_txunblock,
+	(di_txactive_t) _dma_txactive,
+	(di_txrotate_t) dma32_txrotate,
+
+	(di_rxinit_t) _dma_rxinit,
+	(di_rxreset_t) dma32_rxreset,
+	(di_rxidle_t) dma32_rxidle,
+	(di_rxstopped_t) dma32_rxstopped,
+	(di_rxenable_t) _dma_rxenable,
+	(di_rxenabled_t) dma32_rxenabled,
+	(di_rx_t) _dma_rx,
+	(di_rxfill_t) _dma_rxfill,
+	(di_rxreclaim_t) _dma_rxreclaim,
+	(di_getnextrxp_t) _dma_getnextrxp,
+	(di_peeknextrxp_t) _dma_peeknextrxp,
+	(di_rxparam_get_t) _dma_rx_param_get,
+
+	(di_fifoloopbackenable_t) _dma_fifoloopbackenable,
+	(di_getvar_t) _dma_getvar,
+	(di_counterreset_t) _dma_counterreset,
+	(di_ctrlflags_t) _dma_ctrlflags,
+	NULL,
+	NULL,
+	NULL,
+	(di_rxactive_t) _dma_rxactive,
+	(di_txpending_t) _dma_txpending,
+	(di_txcommitted_t) _dma_txcommitted,
+	39
+};
+
+hnddma_t *dma_attach(osl_t * osh, char *name, si_t * sih, void *dmaregstx,
+		     void *dmaregsrx, uint ntxd, uint nrxd, uint rxbufsize,
+		     int rxextheadroom, uint nrxpost, uint rxoffset,
+		     uint * msg_level)
+{
+	dma_info_t *di;
+	uint size;
+
+	/* allocate private info structure */
+	if ((di = MALLOC(osh, sizeof(dma_info_t))) == NULL) {
+#ifdef BCMDBG
+		printf("dma_attach: out of memory, malloced %d bytes\n",
+		       MALLOCED(osh));
+#endif
+		return (NULL);
+	}
+
+	bzero((char *)di, sizeof(dma_info_t));
+
+	di->msg_level = msg_level ? msg_level : &dma_msg_level;
+
+	/* old chips w/o sb is no longer supported */
+	ASSERT(sih != NULL);
+
+	if (DMA64_ENAB(di))
+		di->dma64 =
+		    ((si_core_sflags(sih, 0, 0) & SISF_DMA64) == SISF_DMA64);
+	else
+		di->dma64 = 0;
+
+	/* check arguments */
+	ASSERT(ISPOWEROF2(ntxd));
+	ASSERT(ISPOWEROF2(nrxd));
+
+	if (nrxd == 0)
+		ASSERT(dmaregsrx == NULL);
+	if (ntxd == 0)
+		ASSERT(dmaregstx == NULL);
+
+	/* init dma reg pointer */
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		ASSERT(ntxd <= D64MAXDD);
+		ASSERT(nrxd <= D64MAXDD);
+		di->d64txregs = (dma64regs_t *) dmaregstx;
+		di->d64rxregs = (dma64regs_t *) dmaregsrx;
+		di->hnddma.di_fn = (const di_fcn_t *)&dma64proc;
+	} else if (DMA32_ENAB(di)) {
+		ASSERT(ntxd <= D32MAXDD);
+		ASSERT(nrxd <= D32MAXDD);
+		di->d32txregs = (dma32regs_t *) dmaregstx;
+		di->d32rxregs = (dma32regs_t *) dmaregsrx;
+		di->hnddma.di_fn = (const di_fcn_t *)&dma32proc;
+	} else {
+		DMA_ERROR(("dma_attach: driver doesn't support 32-bit DMA\n"));
+		ASSERT(0);
+		goto fail;
+	}
+
+	/* Default flags (which can be changed by the driver calling dma_ctrlflags
+	 * before enable): For backwards compatibility both Rx Overflow Continue
+	 * and Parity are DISABLED.
+	 * supports it.
+	 */
+	di->hnddma.di_fn->ctrlflags(&di->hnddma, DMA_CTRL_ROC | DMA_CTRL_PEN,
+				    0);
+
+	DMA_TRACE(("%s: dma_attach: %s osh %p flags 0x%x ntxd %d nrxd %d rxbufsize %d " "rxextheadroom %d nrxpost %d rxoffset %d dmaregstx %p dmaregsrx %p\n", name, (DMA64_MODE(di) ? "DMA64" : "DMA32"), osh, di->hnddma.dmactrlflags, ntxd, nrxd, rxbufsize, rxextheadroom, nrxpost, rxoffset, dmaregstx, dmaregsrx));
+
+	/* make a private copy of our callers name */
+	strncpy(di->name, name, MAXNAMEL);
+	di->name[MAXNAMEL - 1] = '\0';
+
+	di->osh = osh;
+	di->sih = sih;
+
+	/* save tunables */
+	di->ntxd = (uint16) ntxd;
+	di->nrxd = (uint16) nrxd;
+
+	/* the actual dma size doesn't include the extra headroom */
+	di->rxextrahdrroom =
+	    (rxextheadroom == -1) ? BCMEXTRAHDROOM : rxextheadroom;
+	if (rxbufsize > BCMEXTRAHDROOM)
+		di->rxbufsize = (uint16) (rxbufsize - di->rxextrahdrroom);
+	else
+		di->rxbufsize = (uint16) rxbufsize;
+
+	di->nrxpost = (uint16) nrxpost;
+	di->rxoffset = (uint8) rxoffset;
+
+	/*
+	 * figure out the DMA physical address offset for dd and data
+	 *     PCI/PCIE: they map silicon backplace address to zero based memory, need offset
+	 *     Other bus: use zero
+	 *     SI_BUS BIGENDIAN kludge: use sdram swapped region for data buffer, not descriptor
+	 */
+	di->ddoffsetlow = 0;
+	di->dataoffsetlow = 0;
+	/* for pci bus, add offset */
+	if (sih->bustype == PCI_BUS) {
+		if ((sih->buscoretype == PCIE_CORE_ID) && DMA64_MODE(di)) {
+			/* pcie with DMA64 */
+			di->ddoffsetlow = 0;
+			di->ddoffsethigh = SI_PCIE_DMA_H32;
+		} else {
+			/* pci(DMA32/DMA64) or pcie with DMA32 */
+			di->ddoffsetlow = SI_PCI_DMA;
+			di->ddoffsethigh = 0;
+		}
+		di->dataoffsetlow = di->ddoffsetlow;
+		di->dataoffsethigh = di->ddoffsethigh;
+	}
+#if defined(__mips__) && defined(IL_BIGENDIAN)
+	di->dataoffsetlow = di->dataoffsetlow + SI_SDRAM_SWAPPED;
+#endif				/* defined(__mips__) && defined(IL_BIGENDIAN) */
+	/* WAR64450 : DMACtl.Addr ext fields are not supported in SDIOD core. */
+	if ((si_coreid(sih) == SDIOD_CORE_ID)
+	    && ((si_corerev(sih) > 0) && (si_corerev(sih) <= 2)))
+		di->addrext = 0;
+	else if ((si_coreid(sih) == I2S_CORE_ID) &&
+		 ((si_corerev(sih) == 0) || (si_corerev(sih) == 1)))
+		di->addrext = 0;
+	else
+		di->addrext = _dma_isaddrext(di);
+
+	/* does the descriptors need to be aligned and if yes, on 4K/8K or not */
+	di->aligndesc_4k = _dma_descriptor_align(di);
+	if (di->aligndesc_4k) {
+		if (DMA64_MODE(di)) {
+			di->dmadesc_align = D64RINGALIGN_BITS;
+			if ((ntxd < D64MAXDD / 2) && (nrxd < D64MAXDD / 2)) {
+				/* for smaller dd table, HW relax the alignment requirement */
+				di->dmadesc_align = D64RINGALIGN_BITS - 1;
+			}
+		} else
+			di->dmadesc_align = D32RINGALIGN_BITS;
+	} else
+		di->dmadesc_align = 4;	/* 16 byte alignment */
+
+	DMA_NONE(("DMA descriptor align_needed %d, align %d\n",
+		  di->aligndesc_4k, di->dmadesc_align));
+
+	/* allocate tx packet pointer vector */
+	if (ntxd) {
+		size = ntxd * sizeof(void *);
+		if ((di->txp = MALLOC(osh, size)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of tx memory, malloced %d bytes\n", di->name, MALLOCED(osh)));
+			goto fail;
+		}
+		bzero((char *)di->txp, size);
+	}
+
+	/* allocate rx packet pointer vector */
+	if (nrxd) {
+		size = nrxd * sizeof(void *);
+		if ((di->rxp = MALLOC(osh, size)) == NULL) {
+			DMA_ERROR(("%s: dma_attach: out of rx memory, malloced %d bytes\n", di->name, MALLOCED(osh)));
+			goto fail;
+		}
+		bzero((char *)di->rxp, size);
+	}
+
+	/* allocate transmit descriptor ring, only need ntxd descriptors but it must be aligned */
+	if (ntxd) {
+		if (!_dma_alloc(di, DMA_TX))
+			goto fail;
+	}
+
+	/* allocate receive descriptor ring, only need nrxd descriptors but it must be aligned */
+	if (nrxd) {
+		if (!_dma_alloc(di, DMA_RX))
+			goto fail;
+	}
+
+	if ((di->ddoffsetlow != 0) && !di->addrext) {
+		if (PHYSADDRLO(di->txdpa) > SI_PCI_DMA_SZ) {
+			DMA_ERROR(("%s: dma_attach: txdpa 0x%x: addrext not supported\n", di->name, (uint32) PHYSADDRLO(di->txdpa)));
+			goto fail;
+		}
+		if (PHYSADDRLO(di->rxdpa) > SI_PCI_DMA_SZ) {
+			DMA_ERROR(("%s: dma_attach: rxdpa 0x%x: addrext not supported\n", di->name, (uint32) PHYSADDRLO(di->rxdpa)));
+			goto fail;
+		}
+	}
+
+	DMA_TRACE(("ddoffsetlow 0x%x ddoffsethigh 0x%x dataoffsetlow 0x%x dataoffsethigh " "0x%x addrext %d\n", di->ddoffsetlow, di->ddoffsethigh, di->dataoffsetlow, di->dataoffsethigh, di->addrext));
+
+	/* allocate DMA mapping vectors */
+	if (DMASGLIST_ENAB) {
+		if (ntxd) {
+			size = ntxd * sizeof(hnddma_seg_map_t);
+			if ((di->txp_dmah =
+			     (hnddma_seg_map_t *) MALLOC(osh, size)) == NULL)
+				goto fail;
+			bzero((char *)di->txp_dmah, size);
+		}
+
+		if (nrxd) {
+			size = nrxd * sizeof(hnddma_seg_map_t);
+			if ((di->rxp_dmah =
+			     (hnddma_seg_map_t *) MALLOC(osh, size)) == NULL)
+				goto fail;
+			bzero((char *)di->rxp_dmah, size);
+		}
+	}
+
+	return ((hnddma_t *) di);
+
+ fail:
+	_dma_detach(di);
+	return (NULL);
+}
+
+/* init the tx or rx descriptor */
+static INLINE void
+dma32_dd_upd(dma_info_t * di, dma32dd_t * ddring, dmaaddr_t pa, uint outidx,
+	     uint32 * flags, uint32 bufcount)
+{
+	/* dma32 uses 32-bit control to fit both flags and bufcounter */
+	*flags = *flags | (bufcount & CTRL_BC_MASK);
+
+	if ((di->dataoffsetlow == 0) || !(PHYSADDRLO(pa) & PCI32ADDR_HIGH)) {
+		W_SM(&ddring[outidx].addr,
+		     BUS_SWAP32(PHYSADDRLO(pa) + di->dataoffsetlow));
+		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
+	} else {
+		/* address extension */
+		uint32 ae;
+		ASSERT(di->addrext);
+		ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+		PHYSADDRLO(pa) &= ~PCI32ADDR_HIGH;
+
+		*flags |= (ae << CTRL_AE_SHIFT);
+		W_SM(&ddring[outidx].addr,
+		     BUS_SWAP32(PHYSADDRLO(pa) + di->dataoffsetlow));
+		W_SM(&ddring[outidx].ctrl, BUS_SWAP32(*flags));
+	}
+}
+
+/* Check for odd number of 1's */
+STATIC INLINE uint32 parity32(uint32 data)
+{
+	data ^= data >> 16;
+	data ^= data >> 8;
+	data ^= data >> 4;
+	data ^= data >> 2;
+	data ^= data >> 1;
+
+	return (data & 1);
+}
+
+#define DMA64_DD_PARITY(dd)  parity32((dd)->addrlow ^ (dd)->addrhigh ^ (dd)->ctrl1 ^ (dd)->ctrl2)
+
+static INLINE void
+dma64_dd_upd(dma_info_t * di, dma64dd_t * ddring, dmaaddr_t pa, uint outidx,
+	     uint32 * flags, uint32 bufcount)
+{
+	uint32 ctrl2 = bufcount & D64_CTRL2_BC_MASK;
+
+	/* PCI bus with big(>1G) physical address, use address extension */
+#if defined(__mips__) && defined(IL_BIGENDIAN)
+	if ((di->dataoffsetlow == SI_SDRAM_SWAPPED)
+	    || !(PHYSADDRLO(pa) & PCI32ADDR_HIGH)) {
+#else
+	if ((di->dataoffsetlow == 0) || !(PHYSADDRLO(pa) & PCI32ADDR_HIGH)) {
+#endif				/* defined(__mips__) && defined(IL_BIGENDIAN) */
+		ASSERT((PHYSADDRHI(pa) & PCI64ADDR_HIGH) == 0);
+
+		W_SM(&ddring[outidx].addrlow,
+		     BUS_SWAP32(PHYSADDRLO(pa) + di->dataoffsetlow));
+		W_SM(&ddring[outidx].addrhigh,
+		     BUS_SWAP32(PHYSADDRHI(pa) + di->dataoffsethigh));
+		W_SM(&ddring[outidx].ctrl1, BUS_SWAP32(*flags));
+		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
+	} else {
+		/* address extension for 32-bit PCI */
+		uint32 ae;
+		ASSERT(di->addrext);
+
+		ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >> PCI32ADDR_HIGH_SHIFT;
+		PHYSADDRLO(pa) &= ~PCI32ADDR_HIGH;
+		ASSERT(PHYSADDRHI(pa) == 0);
+
+		ctrl2 |= (ae << D64_CTRL2_AE_SHIFT) & D64_CTRL2_AE;
+		W_SM(&ddring[outidx].addrlow,
+		     BUS_SWAP32(PHYSADDRLO(pa) + di->dataoffsetlow));
+		W_SM(&ddring[outidx].addrhigh,
+		     BUS_SWAP32(0 + di->dataoffsethigh));
+		W_SM(&ddring[outidx].ctrl1, BUS_SWAP32(*flags));
+		W_SM(&ddring[outidx].ctrl2, BUS_SWAP32(ctrl2));
+	}
+	if (di->hnddma.dmactrlflags & DMA_CTRL_PEN) {
+		if (DMA64_DD_PARITY(&ddring[outidx])) {
+			W_SM(&ddring[outidx].ctrl2,
+			     BUS_SWAP32(ctrl2 | D64_CTRL2_PARITY));
+		}
+	}
+}
+
+static bool _dma32_addrext(osl_t * osh, dma32regs_t * dma32regs)
+{
+	uint32 w;
+
+	OR_REG(osh, &dma32regs->control, XC_AE);
+	w = R_REG(osh, &dma32regs->control);
+	AND_REG(osh, &dma32regs->control, ~XC_AE);
+	return ((w & XC_AE) == XC_AE);
+}
+
+static bool _dma_alloc(dma_info_t * di, uint direction)
+{
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		return dma64_alloc(di, direction);
+	} else if (DMA32_ENAB(di)) {
+		return dma32_alloc(di, direction);
+	} else
+		ASSERT(0);
+}
+
+/* !! may be called with core in reset */
+static void _dma_detach(dma_info_t * di)
+{
+
+	DMA_TRACE(("%s: dma_detach\n", di->name));
+
+	/* shouldn't be here if descriptors are unreclaimed */
+	ASSERT(di->txin == di->txout);
+	ASSERT(di->rxin == di->rxout);
+
+	/* free dma descriptor rings */
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		if (di->txd64)
+			DMA_FREE_CONSISTENT(di->osh,
+					    ((int8 *) (uintptr) di->txd64 -
+					     di->txdalign), di->txdalloc,
+					    (di->txdpaorig), &di->tx_dmah);
+		if (di->rxd64)
+			DMA_FREE_CONSISTENT(di->osh,
+					    ((int8 *) (uintptr) di->rxd64 -
+					     di->rxdalign), di->rxdalloc,
+					    (di->rxdpaorig), &di->rx_dmah);
+	} else if (DMA32_ENAB(di)) {
+		if (di->txd32)
+			DMA_FREE_CONSISTENT(di->osh,
+					    ((int8 *) (uintptr) di->txd32 -
+					     di->txdalign), di->txdalloc,
+					    (di->txdpaorig), &di->tx_dmah);
+		if (di->rxd32)
+			DMA_FREE_CONSISTENT(di->osh,
+					    ((int8 *) (uintptr) di->rxd32 -
+					     di->rxdalign), di->rxdalloc,
+					    (di->rxdpaorig), &di->rx_dmah);
+	} else
+		ASSERT(0);
+
+	/* free packet pointer vectors */
+	if (di->txp)
+		MFREE(di->osh, (void *)di->txp, (di->ntxd * sizeof(void *)));
+	if (di->rxp)
+		MFREE(di->osh, (void *)di->rxp, (di->nrxd * sizeof(void *)));
+
+	/* free tx packet DMA handles */
+	if (di->txp_dmah)
+		MFREE(di->osh, (void *)di->txp_dmah,
+		      di->ntxd * sizeof(hnddma_seg_map_t));
+
+	/* free rx packet DMA handles */
+	if (di->rxp_dmah)
+		MFREE(di->osh, (void *)di->rxp_dmah,
+		      di->nrxd * sizeof(hnddma_seg_map_t));
+
+	/* free our private info structure */
+	MFREE(di->osh, (void *)di, sizeof(dma_info_t));
+
+}
+
+static bool _dma_descriptor_align(dma_info_t * di)
+{
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		uint32 addrl;
+
+		/* Check to see if the descriptors need to be aligned on 4K/8K or not */
+		if (di->d64txregs != NULL) {
+			W_REG(di->osh, &di->d64txregs->addrlow, 0xff0);
+			addrl = R_REG(di->osh, &di->d64txregs->addrlow);
+			if (addrl != 0)
+				return FALSE;
+		} else if (di->d64rxregs != NULL) {
+			W_REG(di->osh, &di->d64rxregs->addrlow, 0xff0);
+			addrl = R_REG(di->osh, &di->d64rxregs->addrlow);
+			if (addrl != 0)
+				return FALSE;
+		}
+	}
+	return TRUE;
+}
+
+/* return TRUE if this dma engine supports DmaExtendedAddrChanges, otherwise FALSE */
+static bool _dma_isaddrext(dma_info_t * di)
+{
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		/* DMA64 supports full 32- or 64-bit operation. AE is always valid */
+
+		/* not all tx or rx channel are available */
+		if (di->d64txregs != NULL) {
+			if (!_dma64_addrext(di->osh, di->d64txregs)) {
+				DMA_ERROR(("%s: _dma_isaddrext: DMA64 tx doesn't have AE set\n", di->name));
+				ASSERT(0);
+			}
+			return TRUE;
+		} else if (di->d64rxregs != NULL) {
+			if (!_dma64_addrext(di->osh, di->d64rxregs)) {
+				DMA_ERROR(("%s: _dma_isaddrext: DMA64 rx doesn't have AE set\n", di->name));
+				ASSERT(0);
+			}
+			return TRUE;
+		}
+		return FALSE;
+	} else if (DMA32_ENAB(di)) {
+		if (di->d32txregs)
+			return (_dma32_addrext(di->osh, di->d32txregs));
+		else if (di->d32rxregs)
+			return (_dma32_addrext(di->osh, di->d32rxregs));
+	} else
+		ASSERT(0);
+
+	return FALSE;
+}
+
+/* initialize descriptor table base address */
+static void _dma_ddtable_init(dma_info_t * di, uint direction, dmaaddr_t pa)
+{
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		if (!di->aligndesc_4k) {
+			if (direction == DMA_TX)
+				di->xmtptrbase = PHYSADDRLO(pa);
+			else
+				di->rcvptrbase = PHYSADDRLO(pa);
+		}
+
+		if ((di->ddoffsetlow == 0)
+		    || !(PHYSADDRLO(pa) & PCI32ADDR_HIGH)) {
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d64txregs->addrlow,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64txregs->addrhigh,
+				      (PHYSADDRHI(pa) + di->ddoffsethigh));
+			} else {
+				W_REG(di->osh, &di->d64rxregs->addrlow,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64rxregs->addrhigh,
+				      (PHYSADDRHI(pa) + di->ddoffsethigh));
+			}
+		} else {
+			/* DMA64 32bits address extension */
+			uint32 ae;
+			ASSERT(di->addrext);
+			ASSERT(PHYSADDRHI(pa) == 0);
+
+			/* shift the high bit(s) from pa to ae */
+			ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >>
+			    PCI32ADDR_HIGH_SHIFT;
+			PHYSADDRLO(pa) &= ~PCI32ADDR_HIGH;
+
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d64txregs->addrlow,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64txregs->addrhigh,
+				      di->ddoffsethigh);
+				SET_REG(di->osh, &di->d64txregs->control,
+					D64_XC_AE, (ae << D64_XC_AE_SHIFT));
+			} else {
+				W_REG(di->osh, &di->d64rxregs->addrlow,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+				W_REG(di->osh, &di->d64rxregs->addrhigh,
+				      di->ddoffsethigh);
+				SET_REG(di->osh, &di->d64rxregs->control,
+					D64_RC_AE, (ae << D64_RC_AE_SHIFT));
+			}
+		}
+
+	} else if (DMA32_ENAB(di)) {
+		ASSERT(PHYSADDRHI(pa) == 0);
+		if ((di->ddoffsetlow == 0)
+		    || !(PHYSADDRLO(pa) & PCI32ADDR_HIGH)) {
+			if (direction == DMA_TX)
+				W_REG(di->osh, &di->d32txregs->addr,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+			else
+				W_REG(di->osh, &di->d32rxregs->addr,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+		} else {
+			/* dma32 address extension */
+			uint32 ae;
+			ASSERT(di->addrext);
+
+			/* shift the high bit(s) from pa to ae */
+			ae = (PHYSADDRLO(pa) & PCI32ADDR_HIGH) >>
+			    PCI32ADDR_HIGH_SHIFT;
+			PHYSADDRLO(pa) &= ~PCI32ADDR_HIGH;
+
+			if (direction == DMA_TX) {
+				W_REG(di->osh, &di->d32txregs->addr,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+				SET_REG(di->osh, &di->d32txregs->control, XC_AE,
+					ae << XC_AE_SHIFT);
+			} else {
+				W_REG(di->osh, &di->d32rxregs->addr,
+				      (PHYSADDRLO(pa) + di->ddoffsetlow));
+				SET_REG(di->osh, &di->d32rxregs->control, RC_AE,
+					ae << RC_AE_SHIFT);
+			}
+		}
+	} else
+		ASSERT(0);
+}
+
+static void _dma_fifoloopbackenable(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_fifoloopbackenable\n", di->name));
+
+	if (DMA64_ENAB(di) && DMA64_MODE(di))
+		OR_REG(di->osh, &di->d64txregs->control, D64_XC_LE);
+	else if (DMA32_ENAB(di))
+		OR_REG(di->osh, &di->d32txregs->control, XC_LE);
+	else
+		ASSERT(0);
+}
+
+static void _dma_rxinit(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_rxinit\n", di->name));
+
+	if (di->nrxd == 0)
+		return;
+
+	di->rxin = di->rxout = 0;
+
+	/* clear rx descriptor ring */
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		BZERO_SM((void *)(uintptr) di->rxd64,
+			 (di->nrxd * sizeof(dma64dd_t)));
+
+		/* DMA engine with out alignment requirement requires table to be inited
+		 * before enabling the engine
+		 */
+		if (!di->aligndesc_4k)
+			_dma_ddtable_init(di, DMA_RX, di->rxdpa);
+
+		_dma_rxenable(di);
+
+		if (di->aligndesc_4k)
+			_dma_ddtable_init(di, DMA_RX, di->rxdpa);
+	} else if (DMA32_ENAB(di)) {
+		BZERO_SM((void *)(uintptr) di->rxd32,
+			 (di->nrxd * sizeof(dma32dd_t)));
+		_dma_rxenable(di);
+		_dma_ddtable_init(di, DMA_RX, di->rxdpa);
+	} else
+		ASSERT(0);
+}
+
+static void _dma_rxenable(dma_info_t * di)
+{
+	uint dmactrlflags = di->hnddma.dmactrlflags;
+
+	DMA_TRACE(("%s: dma_rxenable\n", di->name));
+
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		uint32 control =
+		    (R_REG(di->osh, &di->d64rxregs->control) & D64_RC_AE) |
+		    D64_RC_RE;
+
+		if ((dmactrlflags & DMA_CTRL_PEN) == 0)
+			control |= D64_RC_PD;
+
+		if (dmactrlflags & DMA_CTRL_ROC)
+			control |= D64_RC_OC;
+
+		W_REG(di->osh, &di->d64rxregs->control,
+		      ((di->rxoffset << D64_RC_RO_SHIFT) | control));
+	} else if (DMA32_ENAB(di)) {
+		uint32 control =
+		    (R_REG(di->osh, &di->d32rxregs->control) & RC_AE) | RC_RE;
+
+		if ((dmactrlflags & DMA_CTRL_PEN) == 0)
+			control |= RC_PD;
+
+		if (dmactrlflags & DMA_CTRL_ROC)
+			control |= RC_OC;
+
+		W_REG(di->osh, &di->d32rxregs->control,
+		      ((di->rxoffset << RC_RO_SHIFT) | control));
+	} else
+		ASSERT(0);
+}
+
+static void
+_dma_rx_param_get(dma_info_t * di, uint16 * rxoffset, uint16 * rxbufsize)
+{
+	/* the normal values fit into 16 bits */
+	*rxoffset = (uint16) di->rxoffset;
+	*rxbufsize = (uint16) di->rxbufsize;
+}
+
+/* !! rx entry routine
+ * returns a pointer to the next frame received, or NULL if there are no more
+ *   if DMA_CTRL_RXMULTI is defined, DMA scattering(multiple buffers) is supported
+ *      with pkts chain
+ *   otherwise, it's treated as giant pkt and will be tossed.
+ *   The DMA scattering starts with normal DMA header, followed by first buffer data.
+ *   After it reaches the max size of buffer, the data continues in next DMA descriptor
+ *   buffer WITHOUT DMA header
+ */
+static void *BCMFASTPATH _dma_rx(dma_info_t * di)
+{
+	void *p, *head, *tail;
+	uint len;
+	uint pkt_len;
+	int resid = 0;
+
+ next_frame:
+	head = _dma_getnextrxp(di, FALSE);
+	if (head == NULL)
+		return (NULL);
+
+	len = ltoh16(*(uint16 *) (PKTDATA(head)));
+	DMA_TRACE(("%s: dma_rx len %d\n", di->name, len));
+
+#if defined(__mips__)
+	if (!len) {
+		while (!(len = *(uint16 *) OSL_UNCACHED(PKTDATA(head))))
+			OSL_DELAY(1);
+
+		*(uint16 *) PKTDATA(head) = htol16((uint16) len);
+	}
+#endif				/* defined(__mips__) */
+
+	/* set actual length */
+	pkt_len = MIN((di->rxoffset + len), di->rxbufsize);
+	PKTSETLEN(head, pkt_len);
+	resid = len - (di->rxbufsize - di->rxoffset);
+
+	/* check for single or multi-buffer rx */
+	if (resid > 0) {
+		tail = head;
+		while ((resid > 0) && (p = _dma_getnextrxp(di, FALSE))) {
+			PKTSETNEXT(tail, p);
+			pkt_len = MIN(resid, (int)di->rxbufsize);
+			PKTSETLEN(p, pkt_len);
+
+			tail = p;
+			resid -= di->rxbufsize;
+		}
+
+#ifdef BCMDBG
+		if (resid > 0) {
+			uint cur;
+			ASSERT(p == NULL);
+			cur = (DMA64_ENAB(di) && DMA64_MODE(di)) ?
+			    B2I(((R_REG(di->osh, &di->d64rxregs->status0) &
+				  D64_RS0_CD_MASK) -
+				 di->rcvptrbase) & D64_RS0_CD_MASK,
+				dma64dd_t) : B2I(R_REG(di->osh,
+						       &di->d32rxregs->
+						       status) & RS_CD_MASK,
+						 dma32dd_t);
+			DMA_ERROR(("_dma_rx, rxin %d rxout %d, hw_curr %d\n",
+				   di->rxin, di->rxout, cur));
+		}
+#endif				/* BCMDBG */
+
+		if ((di->hnddma.dmactrlflags & DMA_CTRL_RXMULTI) == 0) {
+			DMA_ERROR(("%s: dma_rx: bad frame length (%d)\n",
+				   di->name, len));
+			PKTFREE(di->osh, head, FALSE);
+			di->hnddma.rxgiants++;
+			goto next_frame;
+		}
+	}
+
+	return (head);
+}
+
+/* post receive buffers
+ *  return FALSE is refill failed completely and ring is empty
+ *  this will stall the rx dma and user might want to call rxfill again asap
+ *  This unlikely happens on memory-rich NIC, but often on memory-constrained dongle
+ */
+static bool BCMFASTPATH _dma_rxfill(dma_info_t * di)
+{
+	void *p;
+	uint16 rxin, rxout;
+	uint32 flags = 0;
+	uint n;
+	uint i;
+	dmaaddr_t pa;
+	uint extra_offset = 0;
+	bool ring_empty;
+
+	ring_empty = FALSE;
+
+	/*
+	 * Determine how many receive buffers we're lacking
+	 * from the full complement, allocate, initialize,
+	 * and post them, then update the chip rx lastdscr.
+	 */
+
+	rxin = di->rxin;
+	rxout = di->rxout;
+
+	n = di->nrxpost - NRXDACTIVE(rxin, rxout);
+
+	DMA_TRACE(("%s: dma_rxfill: post %d\n", di->name, n));
+
+	if (di->rxbufsize > BCMEXTRAHDROOM)
+		extra_offset = di->rxextrahdrroom;
+
+	for (i = 0; i < n; i++) {
+		/* the di->rxbufsize doesn't include the extra headroom, we need to add it to the
+		   size to be allocated
+		 */
+
+		p = osl_pktget(di->osh, di->rxbufsize + extra_offset);
+
+		if (p == NULL) {
+			DMA_ERROR(("%s: dma_rxfill: out of rxbufs\n",
+				   di->name));
+			if (i == 0) {
+				if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+					if (dma64_rxidle(di)) {
+						DMA_ERROR(("%s: rxfill64: ring is empty !\n", di->name));
+						ring_empty = TRUE;
+					}
+				} else if (DMA32_ENAB(di)) {
+					if (dma32_rxidle(di)) {
+						DMA_ERROR(("%s: rxfill32: ring is empty !\n", di->name));
+						ring_empty = TRUE;
+					}
+				} else
+					ASSERT(0);
+			}
+			di->hnddma.rxnobuf++;
+			break;
+		}
+		/* reserve an extra headroom, if applicable */
+		if (extra_offset)
+			PKTPULL(p, extra_offset);
+
+		/* Do a cached write instead of uncached write since DMA_MAP
+		 * will flush the cache.
+		 */
+		*(uint32 *) (PKTDATA(p)) = 0;
+
+		if (DMASGLIST_ENAB)
+			bzero(&di->rxp_dmah[rxout], sizeof(hnddma_seg_map_t));
+
+		pa = DMA_MAP(di->osh, PKTDATA(p),
+			     di->rxbufsize, DMA_RX, p, &di->rxp_dmah[rxout]);
+
+		ASSERT(ISALIGNED(PHYSADDRLO(pa), 4));
+
+		/* save the free packet pointer */
+		ASSERT(di->rxp[rxout] == NULL);
+		di->rxp[rxout] = p;
+
+		/* reset flags for each descriptor */
+		flags = 0;
+		if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+			if (rxout == (di->nrxd - 1))
+				flags = D64_CTRL1_EOT;
+
+			dma64_dd_upd(di, di->rxd64, pa, rxout, &flags,
+				     di->rxbufsize);
+		} else if (DMA32_ENAB(di)) {
+			if (rxout == (di->nrxd - 1))
+				flags = CTRL_EOT;
+
+			ASSERT(PHYSADDRHI(pa) == 0);
+			dma32_dd_upd(di, di->rxd32, pa, rxout, &flags,
+				     di->rxbufsize);
+		} else
+			ASSERT(0);
+		rxout = NEXTRXD(rxout);
+	}
+
+	di->rxout = rxout;
+
+	/* update the chip lastdscr pointer */
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		W_REG(di->osh, &di->d64rxregs->ptr,
+		      di->rcvptrbase + I2B(rxout, dma64dd_t));
+	} else if (DMA32_ENAB(di)) {
+		W_REG(di->osh, &di->d32rxregs->ptr, I2B(rxout, dma32dd_t));
+	} else
+		ASSERT(0);
+
+	return ring_empty;
+}
+
+/* like getnexttxp but no reclaim */
+static void *_dma_peeknexttxp(dma_info_t * di)
+{
+	uint end, i;
+
+	if (di->ntxd == 0)
+		return (NULL);
+
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		end =
+		    B2I(((R_REG(di->osh, &di->d64txregs->status0) &
+			  D64_XS0_CD_MASK) - di->xmtptrbase) & D64_XS0_CD_MASK,
+			dma64dd_t);
+	} else if (DMA32_ENAB(di)) {
+		end =
+		    B2I(R_REG(di->osh, &di->d32txregs->status) & XS_CD_MASK,
+			dma32dd_t);
+	} else
+		ASSERT(0);
+
+	for (i = di->txin; i != end; i = NEXTTXD(i))
+		if (di->txp[i])
+			return (di->txp[i]);
+
+	return (NULL);
+}
+
+/* like getnextrxp but not take off the ring */
+static void *_dma_peeknextrxp(dma_info_t * di)
+{
+	uint end, i;
+
+	if (di->nrxd == 0)
+		return (NULL);
+
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		end =
+		    B2I(((R_REG(di->osh, &di->d64rxregs->status0) &
+			  D64_RS0_CD_MASK) - di->rcvptrbase) & D64_RS0_CD_MASK,
+			dma64dd_t);
+	} else if (DMA32_ENAB(di)) {
+		end =
+		    B2I(R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK,
+			dma32dd_t);
+	} else
+		ASSERT(0);
+
+	for (i = di->rxin; i != end; i = NEXTRXD(i))
+		if (di->rxp[i])
+			return (di->rxp[i]);
+
+	return (NULL);
+}
+
+static void _dma_rxreclaim(dma_info_t * di)
+{
+	void *p;
+
+	/* "unused local" warning suppression for OSLs that
+	 * define PKTFREE() without using the di->osh arg
+	 */
+	di = di;
+
+	DMA_TRACE(("%s: dma_rxreclaim\n", di->name));
+
+	while ((p = _dma_getnextrxp(di, TRUE)))
+		PKTFREE(di->osh, p, FALSE);
+}
+
+static void *BCMFASTPATH _dma_getnextrxp(dma_info_t * di, bool forceall)
+{
+	if (di->nrxd == 0)
+		return (NULL);
+
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		return dma64_getnextrxp(di, forceall);
+	} else if (DMA32_ENAB(di)) {
+		return dma32_getnextrxp(di, forceall);
+	} else
+		ASSERT(0);
+}
+
+static void _dma_txblock(dma_info_t * di)
+{
+	di->hnddma.txavail = 0;
+}
+
+static void _dma_txunblock(dma_info_t * di)
+{
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+}
+
+static uint _dma_txactive(dma_info_t * di)
+{
+	return NTXDACTIVE(di->txin, di->txout);
+}
+
+static uint _dma_txpending(dma_info_t * di)
+{
+	uint curr;
+
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		curr =
+		    B2I(((R_REG(di->osh, &di->d64txregs->status0) &
+			  D64_XS0_CD_MASK) - di->xmtptrbase) & D64_XS0_CD_MASK,
+			dma64dd_t);
+	} else if (DMA32_ENAB(di)) {
+		curr =
+		    B2I(R_REG(di->osh, &di->d32txregs->status) & XS_CD_MASK,
+			dma32dd_t);
+	} else
+		ASSERT(0);
+
+	return NTXDACTIVE(curr, di->txout);
+}
+
+static uint _dma_txcommitted(dma_info_t * di)
+{
+	uint ptr;
+	uint txin = di->txin;
+
+	if (txin == di->txout)
+		return 0;
+
+	if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+		ptr = B2I(R_REG(di->osh, &di->d64txregs->ptr), dma64dd_t);
+	} else if (DMA32_ENAB(di)) {
+		ptr = B2I(R_REG(di->osh, &di->d32txregs->ptr), dma32dd_t);
+	} else
+		ASSERT(0);
+
+	return NTXDACTIVE(di->txin, ptr);
+}
+
+static uint _dma_rxactive(dma_info_t * di)
+{
+	return NRXDACTIVE(di->rxin, di->rxout);
+}
+
+static void _dma_counterreset(dma_info_t * di)
+{
+	/* reset all software counter */
+	di->hnddma.rxgiants = 0;
+	di->hnddma.rxnobuf = 0;
+	di->hnddma.txnobuf = 0;
+}
+
+static uint _dma_ctrlflags(dma_info_t * di, uint mask, uint flags)
+{
+	uint dmactrlflags = di->hnddma.dmactrlflags;
+
+	if (di == NULL) {
+		DMA_ERROR(("%s: _dma_ctrlflags: NULL dma handle\n", di->name));
+		return (0);
+	}
+
+	ASSERT((flags & ~mask) == 0);
+
+	dmactrlflags &= ~mask;
+	dmactrlflags |= flags;
+
+	/* If trying to enable parity, check if parity is actually supported */
+	if (dmactrlflags & DMA_CTRL_PEN) {
+		uint32 control;
+
+		if (DMA64_ENAB(di) && DMA64_MODE(di)) {
+			control = R_REG(di->osh, &di->d64txregs->control);
+			W_REG(di->osh, &di->d64txregs->control,
+			      control | D64_XC_PD);
+			if (R_REG(di->osh, &di->d64txregs->control) & D64_XC_PD) {
+				/* We *can* disable it so it is supported,
+				 * restore control register
+				 */
+				W_REG(di->osh, &di->d64txregs->control,
+				      control);
+			} else {
+				/* Not supported, don't allow it to be enabled */
+				dmactrlflags &= ~DMA_CTRL_PEN;
+			}
+		} else if (DMA32_ENAB(di)) {
+			control = R_REG(di->osh, &di->d32txregs->control);
+			W_REG(di->osh, &di->d32txregs->control,
+			      control | XC_PD);
+			if (R_REG(di->osh, &di->d32txregs->control) & XC_PD) {
+				W_REG(di->osh, &di->d32txregs->control,
+				      control);
+			} else {
+				/* Not supported, don't allow it to be enabled */
+				dmactrlflags &= ~DMA_CTRL_PEN;
+			}
+		} else
+			ASSERT(0);
+	}
+
+	di->hnddma.dmactrlflags = dmactrlflags;
+
+	return (dmactrlflags);
+}
+
+/* get the address of the var in order to change later */
+static uintptr _dma_getvar(dma_info_t * di, const char *name)
+{
+	if (!strcmp(name, "&txavail"))
+		return ((uintptr) & (di->hnddma.txavail));
+	else {
+		ASSERT(0);
+	}
+	return (0);
+}
+
+void dma_txpioloopback(osl_t * osh, dma32regs_t * regs)
+{
+	OR_REG(osh, &regs->control, XC_LE);
+}
+
+static
+uint8 dma_align_sizetobits(uint size)
+{
+	uint8 bitpos = 0;
+	ASSERT(size);
+	ASSERT(!(size & (size - 1)));
+	while (size >>= 1) {
+		bitpos++;
+	}
+	return (bitpos);
+}
+
+/* This function ensures that the DMA descriptor ring will not get allocated
+ * across Page boundary. If the allocation is done across the page boundary
+ * at the first time, then it is freed and the allocation is done at
+ * descriptor ring size aligned location. This will ensure that the ring will
+ * not cross page boundary
+ */
+static void *dma_ringalloc(osl_t * osh, uint32 boundary, uint size,
+			   uint16 * alignbits, uint * alloced,
+			   dmaaddr_t * descpa, osldma_t ** dmah)
+{
+	void *va;
+	uint32 desc_strtaddr;
+	uint32 alignbytes = 1 << *alignbits;
+
+	if (NULL ==
+	    (va =
+	     DMA_ALLOC_CONSISTENT(osh, size, *alignbits, alloced, descpa,
+				  dmah)))
+		return NULL;
+
+	desc_strtaddr = (uint32) ROUNDUP((uintptr) va, alignbytes);
+	if (((desc_strtaddr + size - 1) & boundary) != (desc_strtaddr
+							& boundary)) {
+		*alignbits = dma_align_sizetobits(size);
+		DMA_FREE_CONSISTENT(osh, va, size, *descpa, dmah);
+		va = DMA_ALLOC_CONSISTENT(osh, size, *alignbits, alloced,
+					  descpa, dmah);
+	}
+	return va;
+}
+
+/* 32-bit DMA functions */
+
+static void dma32_txinit(dma_info_t * di)
+{
+	uint32 control = XC_XE;
+
+	DMA_TRACE(("%s: dma_txinit\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	di->txin = di->txout = 0;
+	di->hnddma.txavail = di->ntxd - 1;
+
+	/* clear tx descriptor ring */
+	BZERO_SM((void *)(uintptr) di->txd32, (di->ntxd * sizeof(dma32dd_t)));
+
+	if ((di->hnddma.dmactrlflags & DMA_CTRL_PEN) == 0)
+		control |= XC_PD;
+	W_REG(di->osh, &di->d32txregs->control, control);
+	_dma_ddtable_init(di, DMA_TX, di->txdpa);
+}
+
+static bool dma32_txenabled(dma_info_t * di)
+{
+	uint32 xc;
+
+	/* If the chip is dead, it is not enabled :-) */
+	xc = R_REG(di->osh, &di->d32txregs->control);
+	return ((xc != 0xffffffff) && (xc & XC_XE));
+}
+
+static void dma32_txsuspend(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	OR_REG(di->osh, &di->d32txregs->control, XC_SE);
+}
+
+static void dma32_txresume(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_txresume\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	AND_REG(di->osh, &di->d32txregs->control, ~XC_SE);
+}
+
+static bool dma32_txsuspended(dma_info_t * di)
+{
+	return (di->ntxd == 0)
+	    || ((R_REG(di->osh, &di->d32txregs->control) & XC_SE) == XC_SE);
+}
+
+static void dma32_txreclaim(dma_info_t * di, txd_range_t range)
+{
+	void *p;
+
+	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name,
+		   (range == HNDDMA_RANGE_ALL) ? "all" :
+		   ((range ==
+		     HNDDMA_RANGE_TRANSMITTED) ? "transmitted" :
+		    "transfered")));
+
+	if (di->txin == di->txout)
+		return;
+
+	while ((p = dma32_getnexttxp(di, range)))
+		PKTFREE(di->osh, p, TRUE);
+}
+
+static bool dma32_txstopped(dma_info_t * di)
+{
+	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) ==
+		XS_XS_STOPPED);
+}
+
+static bool dma32_rxstopped(dma_info_t * di)
+{
+	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_RS_MASK) ==
+		RS_RS_STOPPED);
+}
+
+static bool dma32_alloc(dma_info_t * di, uint direction)
+{
+	uint size;
+	uint ddlen;
+	void *va;
+	uint alloced;
+	uint16 align;
+	uint16 align_bits;
+
+	ddlen = sizeof(dma32dd_t);
+
+	size = (direction == DMA_TX) ? (di->ntxd * ddlen) : (di->nrxd * ddlen);
+
+	alloced = 0;
+	align_bits = di->dmadesc_align;
+	align = (1 << align_bits);
+
+	if (direction == DMA_TX) {
+		if ((va =
+		     dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
+				   &alloced, &di->txdpaorig,
+				   &di->tx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
+			return FALSE;
+		}
+
+		PHYSADDRHISET(di->txdpa, 0);
+		ASSERT(PHYSADDRHI(di->txdpaorig) == 0);
+		di->txd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
+		di->txdalign =
+		    (uint) ((int8 *) (uintptr) di->txd32 - (int8 *) va);
+
+		PHYSADDRLOSET(di->txdpa,
+			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
+		/* Make sure that alignment didn't overflow */
+		ASSERT(PHYSADDRLO(di->txdpa) >= PHYSADDRLO(di->txdpaorig));
+
+		di->txdalloc = alloced;
+		ASSERT(ISALIGNED((uintptr) di->txd32, align));
+	} else {
+		if ((va =
+		     dma_ringalloc(di->osh, D32RINGALIGN, size, &align_bits,
+				   &alloced, &di->rxdpaorig,
+				   &di->rx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
+			return FALSE;
+		}
+
+		PHYSADDRHISET(di->rxdpa, 0);
+		ASSERT(PHYSADDRHI(di->rxdpaorig) == 0);
+		di->rxd32 = (dma32dd_t *) ROUNDUP((uintptr) va, align);
+		di->rxdalign =
+		    (uint) ((int8 *) (uintptr) di->rxd32 - (int8 *) va);
+
+		PHYSADDRLOSET(di->rxdpa,
+			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
+		/* Make sure that alignment didn't overflow */
+		ASSERT(PHYSADDRLO(di->rxdpa) >= PHYSADDRLO(di->rxdpaorig));
+		di->rxdalloc = alloced;
+		ASSERT(ISALIGNED((uintptr) di->rxd32, align));
+	}
+
+	return TRUE;
+}
+
+static bool dma32_txreset(dma_info_t * di)
+{
+	uint32 status;
+
+	if (di->ntxd == 0)
+		return TRUE;
+
+	/* suspend tx DMA first */
+	W_REG(di->osh, &di->d32txregs->control, XC_SE);
+	SPINWAIT(((status =
+		   (R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK))
+		  != XS_XS_DISABLED) && (status != XS_XS_IDLE)
+		 && (status != XS_XS_STOPPED), (10000));
+
+	W_REG(di->osh, &di->d32txregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh,
+				   &di->d32txregs->status) & XS_XS_MASK)) !=
+		  XS_XS_DISABLED), 10000);
+
+	/* wait for the last transaction to complete */
+	OSL_DELAY(300);
+
+	return (status == XS_XS_DISABLED);
+}
+
+static bool dma32_rxidle(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_rxidle\n", di->name));
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	return ((R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK) ==
+		R_REG(di->osh, &di->d32rxregs->ptr));
+}
+
+static bool dma32_rxreset(dma_info_t * di)
+{
+	uint32 status;
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	W_REG(di->osh, &di->d32rxregs->control, 0);
+	SPINWAIT(((status = (R_REG(di->osh,
+				   &di->d32rxregs->status) & RS_RS_MASK)) !=
+		  RS_RS_DISABLED), 10000);
+
+	return (status == RS_RS_DISABLED);
+}
+
+static bool dma32_rxenabled(dma_info_t * di)
+{
+	uint32 rc;
+
+	rc = R_REG(di->osh, &di->d32rxregs->control);
+	return ((rc != 0xffffffff) && (rc & RC_RE));
+}
+
+static bool dma32_txsuspendedidle(dma_info_t * di)
+{
+	if (di->ntxd == 0)
+		return TRUE;
+
+	if (!(R_REG(di->osh, &di->d32txregs->control) & XC_SE))
+		return 0;
+
+	if ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) != XS_XS_IDLE)
+		return 0;
+
+	OSL_DELAY(2);
+	return ((R_REG(di->osh, &di->d32txregs->status) & XS_XS_MASK) ==
+		XS_XS_IDLE);
+}
+
+/* !! tx entry routine
+ * supports full 32bit dma engine buffer addressing so
+ * dma buffers can cross 4 Kbyte page boundaries.
+ *
+ * WARNING: call must check the return value for error.
+ *   the error(toss frames) could be fatal and cause many subsequent hard to debug problems
+ */
+static int dma32_txfast(dma_info_t * di, void *p0, bool commit)
+{
+	void *p, *next;
+	uchar *data;
+	uint len;
+	uint16 txout;
+	uint32 flags = 0;
+	dmaaddr_t pa;
+
+	DMA_TRACE(("%s: dma_txfast\n", di->name));
+
+	txout = di->txout;
+
+	/*
+	 * Walk the chain of packet buffers
+	 * allocating and initializing transmit descriptor entries.
+	 */
+	for (p = p0; p; p = next) {
+		uint nsegs, j;
+		hnddma_seg_map_t *map;
+
+		data = PKTDATA(p);
+		len = PKTLEN(p);
+#ifdef BCM_DMAPAD
+		len += PKTDMAPAD(di->osh, p);
+#endif
+		next = PKTNEXT(p);
+
+		/* return nonzero if out of tx descriptors */
+		if (NEXTTXD(txout) == di->txin)
+			goto outoftxd;
+
+		if (len == 0)
+			continue;
+
+		if (DMASGLIST_ENAB)
+			bzero(&di->txp_dmah[txout], sizeof(hnddma_seg_map_t));
+
+		/* get physical address of buffer start */
+		pa = DMA_MAP(di->osh, data, len, DMA_TX, p,
+			     &di->txp_dmah[txout]);
+
+		if (DMASGLIST_ENAB) {
+			map = &di->txp_dmah[txout];
+
+			/* See if all the segments can be accounted for */
+			if (map->nsegs >
+			    (uint) (di->ntxd - NTXDACTIVE(di->txin, di->txout) -
+				    1))
+				goto outoftxd;
+
+			nsegs = map->nsegs;
+		} else
+			nsegs = 1;
+
+		for (j = 1; j <= nsegs; j++) {
+			flags = 0;
+			if (p == p0 && j == 1)
+				flags |= CTRL_SOF;
+
+			/* With a DMA segment list, Descriptor table is filled
+			 * using the segment list instead of looping over
+			 * buffers in multi-chain DMA. Therefore, EOF for SGLIST is when
+			 * end of segment list is reached.
+			 */
+			if ((!DMASGLIST_ENAB && next == NULL) ||
+			    (DMASGLIST_ENAB && j == nsegs))
+				flags |= (CTRL_IOC | CTRL_EOF);
+			if (txout == (di->ntxd - 1))
+				flags |= CTRL_EOT;
+
+			if (DMASGLIST_ENAB) {
+				len = map->segs[j - 1].length;
+				pa = map->segs[j - 1].addr;
+			}
+			ASSERT(PHYSADDRHI(pa) == 0);
+
+			dma32_dd_upd(di, di->txd32, pa, txout, &flags, len);
+			ASSERT(di->txp[txout] == NULL);
+
+			txout = NEXTTXD(txout);
+		}
+
+		/* See above. No need to loop over individual buffers */
+		if (DMASGLIST_ENAB)
+			break;
+	}
+
+	/* if last txd eof not set, fix it */
+	if (!(flags & CTRL_EOF))
+		W_SM(&di->txd32[PREVTXD(txout)].ctrl,
+		     BUS_SWAP32(flags | CTRL_IOC | CTRL_EOF));
+
+	/* save the packet */
+	di->txp[PREVTXD(txout)] = p0;
+
+	/* bump the tx descriptor index */
+	di->txout = txout;
+
+	/* kick the chip */
+	if (commit)
+		W_REG(di->osh, &di->d32txregs->ptr, I2B(txout, dma32dd_t));
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (0);
+
+ outoftxd:
+	DMA_ERROR(("%s: dma_txfast: out of txds\n", di->name));
+	PKTFREE(di->osh, p0, TRUE);
+	di->hnddma.txavail = 0;
+	di->hnddma.txnobuf++;
+	return (-1);
+}
+
+/*
+ * Reclaim next completed txd (txds if using chained buffers) in the range
+ * specified and return associated packet.
+ * If range is HNDDMA_RANGE_TRANSMITTED, reclaim descriptors that have be
+ * transmitted as noted by the hardware "CurrDescr" pointer.
+ * If range is HNDDMA_RANGE_TRANSFERED, reclaim descriptors that have be
+ * transfered by the DMA as noted by the hardware "ActiveDescr" pointer.
+ * If range is HNDDMA_RANGE_ALL, reclaim all txd(s) posted to the ring and
+ * return associated packet regardless of the value of hardware pointers.
+ */
+static void *dma32_getnexttxp(dma_info_t * di, txd_range_t range)
+{
+	uint16 start, end, i;
+	uint16 active_desc;
+	void *txp;
+
+	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name,
+		   (range == HNDDMA_RANGE_ALL) ? "all" :
+		   ((range ==
+		     HNDDMA_RANGE_TRANSMITTED) ? "transmitted" :
+		    "transfered")));
+
+	if (di->ntxd == 0)
+		return (NULL);
+
+	txp = NULL;
+
+	start = di->txin;
+	if (range == HNDDMA_RANGE_ALL)
+		end = di->txout;
+	else {
+		dma32regs_t *dregs = di->d32txregs;
+
+		end =
+		    (uint16) B2I(R_REG(di->osh, &dregs->status) & XS_CD_MASK,
+				 dma32dd_t);
+
+		if (range == HNDDMA_RANGE_TRANSFERED) {
+			active_desc =
+			    (uint16) ((R_REG(di->osh, &dregs->status) &
+				       XS_AD_MASK) >> XS_AD_SHIFT);
+			active_desc = (uint16) B2I(active_desc, dma32dd_t);
+			if (end != active_desc)
+				end = PREVTXD(active_desc);
+		}
+	}
+
+	if ((start == 0) && (end > di->txout))
+		goto bogus;
+
+	for (i = start; i != end && !txp; i = NEXTTXD(i)) {
+		dmaaddr_t pa;
+		hnddma_seg_map_t *map = NULL;
+		uint size, j, nsegs;
+
+		PHYSADDRLOSET(pa,
+			      (BUS_SWAP32(R_SM(&di->txd32[i].addr)) -
+			       di->dataoffsetlow));
+		PHYSADDRHISET(pa, 0);
+
+		if (DMASGLIST_ENAB) {
+			map = &di->txp_dmah[i];
+			size = map->origsize;
+			nsegs = map->nsegs;
+		} else {
+			size =
+			    (BUS_SWAP32(R_SM(&di->txd32[i].ctrl)) &
+			     CTRL_BC_MASK);
+			nsegs = 1;
+		}
+
+		for (j = nsegs; j > 0; j--) {
+			W_SM(&di->txd32[i].addr, 0xdeadbeef);
+
+			txp = di->txp[i];
+			di->txp[i] = NULL;
+			if (j > 1)
+				i = NEXTTXD(i);
+		}
+
+		DMA_UNMAP(di->osh, pa, size, DMA_TX, txp, map);
+	}
+
+	di->txin = i;
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (txp);
+
+ bogus:
+	DMA_NONE(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n", start, end, di->txout, forceall));
+	return (NULL);
+}
+
+static void *dma32_getnextrxp(dma_info_t * di, bool forceall)
+{
+	uint i, curr;
+	void *rxp;
+	dmaaddr_t pa;
+	/* if forcing, dma engine must be disabled */
+	ASSERT(!forceall || !dma32_rxenabled(di));
+
+	i = di->rxin;
+
+	/* return if no packets posted */
+	if (i == di->rxout)
+		return (NULL);
+
+	curr =
+	    B2I(R_REG(di->osh, &di->d32rxregs->status) & RS_CD_MASK, dma32dd_t);
+
+	/* ignore curr if forceall */
+	if (!forceall && (i == curr))
+		return (NULL);
+
+	/* get the packet pointer that corresponds to the rx descriptor */
+	rxp = di->rxp[i];
+	ASSERT(rxp);
+	di->rxp[i] = NULL;
+
+	PHYSADDRLOSET(pa,
+		      (BUS_SWAP32(R_SM(&di->rxd32[i].addr)) -
+		       di->dataoffsetlow));
+	PHYSADDRHISET(pa, 0);
+
+	/* clear this packet from the descriptor ring */
+	DMA_UNMAP(di->osh, pa, di->rxbufsize, DMA_RX, rxp, &di->rxp_dmah[i]);
+
+	W_SM(&di->rxd32[i].addr, 0xdeadbeef);
+
+	di->rxin = NEXTRXD(i);
+
+	return (rxp);
+}
+
+/*
+ * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
+ */
+static void dma32_txrotate(dma_info_t * di)
+{
+	uint16 ad;
+	uint nactive;
+	uint rot;
+	uint16 old, new;
+	uint32 w;
+	uint16 first, last;
+
+	ASSERT(dma32_txsuspendedidle(di));
+
+	nactive = _dma_txactive(di);
+	ad = (uint16) (B2I
+		       (((R_REG(di->osh, &di->d32txregs->status) & XS_AD_MASK)
+			 >> XS_AD_SHIFT), dma32dd_t));
+	rot = TXD(ad - di->txin);
+
+	ASSERT(rot < di->ntxd);
+
+	/* full-ring case is a lot harder - don't worry about this */
+	if (rot >= (di->ntxd - nactive)) {
+		DMA_ERROR(("%s: dma_txrotate: ring full - punt\n", di->name));
+		return;
+	}
+
+	first = di->txin;
+	last = PREVTXD(di->txout);
+
+	/* move entries starting at last and moving backwards to first */
+	for (old = last; old != PREVTXD(first); old = PREVTXD(old)) {
+		new = TXD(old + rot);
+
+		/*
+		 * Move the tx dma descriptor.
+		 * EOT is set only in the last entry in the ring.
+		 */
+		w = BUS_SWAP32(R_SM(&di->txd32[old].ctrl)) & ~CTRL_EOT;
+		if (new == (di->ntxd - 1))
+			w |= CTRL_EOT;
+		W_SM(&di->txd32[new].ctrl, BUS_SWAP32(w));
+		W_SM(&di->txd32[new].addr, R_SM(&di->txd32[old].addr));
+
+		/* zap the old tx dma descriptor address field */
+		W_SM(&di->txd32[old].addr, BUS_SWAP32(0xdeadbeef));
+
+		/* move the corresponding txp[] entry */
+		ASSERT(di->txp[new] == NULL);
+		di->txp[new] = di->txp[old];
+
+		/* Move the segment map as well */
+		if (DMASGLIST_ENAB) {
+			bcopy(&di->txp_dmah[old], &di->txp_dmah[new],
+			      sizeof(hnddma_seg_map_t));
+			bzero(&di->txp_dmah[old], sizeof(hnddma_seg_map_t));
+		}
+
+		di->txp[old] = NULL;
+	}
+
+	/* update txin and txout */
+	di->txin = ad;
+	di->txout = TXD(di->txout + rot);
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	/* kick the chip */
+	W_REG(di->osh, &di->d32txregs->ptr, I2B(di->txout, dma32dd_t));
+}
+
+/* 64-bit DMA functions */
+
+static void dma64_txinit(dma_info_t * di)
+{
+	uint32 control = D64_XC_XE;
+
+	DMA_TRACE(("%s: dma_txinit\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	di->txin = di->txout = 0;
+	di->hnddma.txavail = di->ntxd - 1;
+
+	/* clear tx descriptor ring */
+	BZERO_SM((void *)(uintptr) di->txd64, (di->ntxd * sizeof(dma64dd_t)));
+
+	/* DMA engine with out alignment requirement requires table to be inited
+	 * before enabling the engine
+	 */
+	if (!di->aligndesc_4k)
+		_dma_ddtable_init(di, DMA_TX, di->txdpa);
+
+	if ((di->hnddma.dmactrlflags & DMA_CTRL_PEN) == 0)
+		control |= D64_XC_PD;
+	OR_REG(di->osh, &di->d64txregs->control, control);
+
+	/* DMA engine with alignment requirement requires table to be inited
+	 * before enabling the engine
+	 */
+	if (di->aligndesc_4k)
+		_dma_ddtable_init(di, DMA_TX, di->txdpa);
+}
+
+static bool dma64_txenabled(dma_info_t * di)
+{
+	uint32 xc;
+
+	/* If the chip is dead, it is not enabled :-) */
+	xc = R_REG(di->osh, &di->d64txregs->control);
+	return ((xc != 0xffffffff) && (xc & D64_XC_XE));
+}
+
+static void dma64_txsuspend(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_txsuspend\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	OR_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
+}
+
+static void dma64_txresume(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_txresume\n", di->name));
+
+	if (di->ntxd == 0)
+		return;
+
+	AND_REG(di->osh, &di->d64txregs->control, ~D64_XC_SE);
+}
+
+static bool dma64_txsuspended(dma_info_t * di)
+{
+	return (di->ntxd == 0) ||
+	    ((R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE) ==
+	     D64_XC_SE);
+}
+
+static void BCMFASTPATH dma64_txreclaim(dma_info_t * di, txd_range_t range)
+{
+	void *p;
+
+	DMA_TRACE(("%s: dma_txreclaim %s\n", di->name,
+		   (range == HNDDMA_RANGE_ALL) ? "all" :
+		   ((range ==
+		     HNDDMA_RANGE_TRANSMITTED) ? "transmitted" :
+		    "transfered")));
+
+	if (di->txin == di->txout)
+		return;
+
+	while ((p = dma64_getnexttxp(di, range))) {
+		/* For unframed data, we don't have any packets to free */
+		if (!(di->hnddma.dmactrlflags & DMA_CTRL_UNFRAMED))
+			PKTFREE(di->osh, p, TRUE);
+	}
+}
+
+static bool dma64_txstopped(dma_info_t * di)
+{
+	return ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) ==
+		D64_XS0_XS_STOPPED);
+}
+
+static bool dma64_rxstopped(dma_info_t * di)
+{
+	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK) ==
+		D64_RS0_RS_STOPPED);
+}
+
+static bool dma64_alloc(dma_info_t * di, uint direction)
+{
+	uint16 size;
+	uint ddlen;
+	void *va;
+	uint alloced = 0;
+	uint16 align;
+	uint16 align_bits;
+
+	ddlen = sizeof(dma64dd_t);
+
+	size = (direction == DMA_TX) ? (di->ntxd * ddlen) : (di->nrxd * ddlen);
+	align_bits = di->dmadesc_align;
+	align = (1 << align_bits);
+
+	if (direction == DMA_TX) {
+		if ((va =
+		     dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
+				   &alloced, &di->txdpaorig,
+				   &di->tx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(ntxd) failed\n", di->name));
+			return FALSE;
+		}
+		align = (1 << align_bits);
+		di->txd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
+		di->txdalign =
+		    (uint) ((int8 *) (uintptr) di->txd64 - (int8 *) va);
+		PHYSADDRLOSET(di->txdpa,
+			      PHYSADDRLO(di->txdpaorig) + di->txdalign);
+		/* Make sure that alignment didn't overflow */
+		ASSERT(PHYSADDRLO(di->txdpa) >= PHYSADDRLO(di->txdpaorig));
+
+		PHYSADDRHISET(di->txdpa, PHYSADDRHI(di->txdpaorig));
+		di->txdalloc = alloced;
+		ASSERT(ISALIGNED((uintptr) di->txd64, align));
+	} else {
+		if ((va =
+		     dma_ringalloc(di->osh, D64RINGALIGN, size, &align_bits,
+				   &alloced, &di->rxdpaorig,
+				   &di->rx_dmah)) == NULL) {
+			DMA_ERROR(("%s: dma64_alloc: DMA_ALLOC_CONSISTENT(nrxd) failed\n", di->name));
+			return FALSE;
+		}
+		align = (1 << align_bits);
+		di->rxd64 = (dma64dd_t *) ROUNDUP((uintptr) va, align);
+		di->rxdalign =
+		    (uint) ((int8 *) (uintptr) di->rxd64 - (int8 *) va);
+		PHYSADDRLOSET(di->rxdpa,
+			      PHYSADDRLO(di->rxdpaorig) + di->rxdalign);
+		/* Make sure that alignment didn't overflow */
+		ASSERT(PHYSADDRLO(di->rxdpa) >= PHYSADDRLO(di->rxdpaorig));
+
+		PHYSADDRHISET(di->rxdpa, PHYSADDRHI(di->rxdpaorig));
+		di->rxdalloc = alloced;
+		ASSERT(ISALIGNED((uintptr) di->rxd64, align));
+	}
+
+	return TRUE;
+}
+
+static bool dma64_txreset(dma_info_t * di)
+{
+	uint32 status;
+
+	if (di->ntxd == 0)
+		return TRUE;
+
+	/* suspend tx DMA first */
+	W_REG(di->osh, &di->d64txregs->control, D64_XC_SE);
+	SPINWAIT(((status =
+		   (R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK))
+		  != D64_XS0_XS_DISABLED) && (status != D64_XS0_XS_IDLE)
+		 && (status != D64_XS0_XS_STOPPED), 10000);
+
+	W_REG(di->osh, &di->d64txregs->control, 0);
+	SPINWAIT(((status =
+		   (R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK))
+		  != D64_XS0_XS_DISABLED), 10000);
+
+	/* wait for the last transaction to complete */
+	OSL_DELAY(300);
+
+	return (status == D64_XS0_XS_DISABLED);
+}
+
+static bool dma64_rxidle(dma_info_t * di)
+{
+	DMA_TRACE(("%s: dma_rxidle\n", di->name));
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	return ((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) ==
+		(R_REG(di->osh, &di->d64rxregs->ptr) & D64_RS0_CD_MASK));
+}
+
+static bool dma64_rxreset(dma_info_t * di)
+{
+	uint32 status;
+
+	if (di->nrxd == 0)
+		return TRUE;
+
+	W_REG(di->osh, &di->d64rxregs->control, 0);
+	SPINWAIT(((status =
+		   (R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_RS_MASK))
+		  != D64_RS0_RS_DISABLED), 10000);
+
+	return (status == D64_RS0_RS_DISABLED);
+}
+
+static bool dma64_rxenabled(dma_info_t * di)
+{
+	uint32 rc;
+
+	rc = R_REG(di->osh, &di->d64rxregs->control);
+	return ((rc != 0xffffffff) && (rc & D64_RC_RE));
+}
+
+static bool dma64_txsuspendedidle(dma_info_t * di)
+{
+
+	if (di->ntxd == 0)
+		return TRUE;
+
+	if (!(R_REG(di->osh, &di->d64txregs->control) & D64_XC_SE))
+		return 0;
+
+	if ((R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_XS_MASK) ==
+	    D64_XS0_XS_IDLE)
+		return 1;
+
+	return 0;
+}
+
+/* Useful when sending unframed data.  This allows us to get a progress report from the DMA.
+ * We return a pointer to the beginning of the DATA buffer of the current descriptor.
+ * If DMA is idle, we return NULL.
+ */
+static void *dma64_getpos(dma_info_t * di, bool direction)
+{
+	void *va;
+	bool idle;
+	uint32 cd_offset;
+
+	if (direction == DMA_TX) {
+		cd_offset =
+		    R_REG(di->osh, &di->d64txregs->status0) & D64_XS0_CD_MASK;
+		idle = !NTXDACTIVE(di->txin, di->txout);
+		va = di->txp[B2I(cd_offset, dma64dd_t)];
+	} else {
+		cd_offset =
+		    R_REG(di->osh, &di->d64rxregs->status0) & D64_XS0_CD_MASK;
+		idle = !NRXDACTIVE(di->rxin, di->rxout);
+		va = di->rxp[B2I(cd_offset, dma64dd_t)];
+	}
+
+	/* If DMA is IDLE, return NULL */
+	if (idle) {
+		DMA_TRACE(("%s: DMA idle, return NULL\n", __func__));
+		va = NULL;
+	}
+
+	return va;
+}
+
+/* TX of unframed data
+ *
+ * Adds a DMA ring descriptor for the data pointed to by "buf".
+ * This is for DMA of a buffer of data and is unlike other hnddma TX functions
+ * that take a pointer to a "packet"
+ * Each call to this is results in a single descriptor being added for "len" bytes of
+ * data starting at "buf", it doesn't handle chained buffers.
+ */
+static int dma64_txunframed(dma_info_t * di, void *buf, uint len, bool commit)
+{
+	uint16 txout;
+	uint32 flags = 0;
+	dmaaddr_t pa;		/* phys addr */
+
+	txout = di->txout;
+
+	/* return nonzero if out of tx descriptors */
+	if (NEXTTXD(txout) == di->txin)
+		goto outoftxd;
+
+	if (len == 0)
+		return 0;
+
+	pa = DMA_MAP(di->osh, buf, len, DMA_TX, NULL, &di->txp_dmah[txout]);
+
+	flags = (D64_CTRL1_SOF | D64_CTRL1_IOC | D64_CTRL1_EOF);
+
+	if (txout == (di->ntxd - 1))
+		flags |= D64_CTRL1_EOT;
+
+	dma64_dd_upd(di, di->txd64, pa, txout, &flags, len);
+	ASSERT(di->txp[txout] == NULL);
+
+	/* save the buffer pointer - used by dma_getpos */
+	di->txp[txout] = buf;
+
+	txout = NEXTTXD(txout);
+	/* bump the tx descriptor index */
+	di->txout = txout;
+
+	/* kick the chip */
+	if (commit) {
+		W_REG(di->osh, &di->d64txregs->ptr,
+		      di->xmtptrbase + I2B(txout, dma64dd_t));
+	}
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (0);
+
+ outoftxd:
+	DMA_ERROR(("%s: %s: out of txds !!!\n", di->name, __func__));
+	di->hnddma.txavail = 0;
+	di->hnddma.txnobuf++;
+	return (-1);
+}
+
+/* !! tx entry routine
+ * WARNING: call must check the return value for error.
+ *   the error(toss frames) could be fatal and cause many subsequent hard to debug problems
+ */
+static int BCMFASTPATH dma64_txfast(dma_info_t * di, void *p0, bool commit)
+{
+	void *p, *next;
+	uchar *data;
+	uint len;
+	uint16 txout;
+	uint32 flags = 0;
+	dmaaddr_t pa;
+
+	DMA_TRACE(("%s: dma_txfast\n", di->name));
+
+	txout = di->txout;
+
+	/*
+	 * Walk the chain of packet buffers
+	 * allocating and initializing transmit descriptor entries.
+	 */
+	for (p = p0; p; p = next) {
+		uint nsegs, j;
+		hnddma_seg_map_t *map;
+
+		data = PKTDATA(p);
+		len = PKTLEN(p);
+#ifdef BCM_DMAPAD
+		len += PKTDMAPAD(di->osh, p);
+#endif				/* BCM_DMAPAD */
+		next = PKTNEXT(p);
+
+		/* return nonzero if out of tx descriptors */
+		if (NEXTTXD(txout) == di->txin)
+			goto outoftxd;
+
+		if (len == 0)
+			continue;
+
+		/* get physical address of buffer start */
+		if (DMASGLIST_ENAB)
+			bzero(&di->txp_dmah[txout], sizeof(hnddma_seg_map_t));
+
+		pa = DMA_MAP(di->osh, data, len, DMA_TX, p,
+			     &di->txp_dmah[txout]);
+
+		if (DMASGLIST_ENAB) {
+			map = &di->txp_dmah[txout];
+
+			/* See if all the segments can be accounted for */
+			if (map->nsegs >
+			    (uint) (di->ntxd - NTXDACTIVE(di->txin, di->txout) -
+				    1))
+				goto outoftxd;
+
+			nsegs = map->nsegs;
+		} else
+			nsegs = 1;
+
+		for (j = 1; j <= nsegs; j++) {
+			flags = 0;
+			if (p == p0 && j == 1)
+				flags |= D64_CTRL1_SOF;
+
+			/* With a DMA segment list, Descriptor table is filled
+			 * using the segment list instead of looping over
+			 * buffers in multi-chain DMA. Therefore, EOF for SGLIST is when
+			 * end of segment list is reached.
+			 */
+			if ((!DMASGLIST_ENAB && next == NULL) ||
+			    (DMASGLIST_ENAB && j == nsegs))
+				flags |= (D64_CTRL1_IOC | D64_CTRL1_EOF);
+			if (txout == (di->ntxd - 1))
+				flags |= D64_CTRL1_EOT;
+
+			if (DMASGLIST_ENAB) {
+				len = map->segs[j - 1].length;
+				pa = map->segs[j - 1].addr;
+			}
+			dma64_dd_upd(di, di->txd64, pa, txout, &flags, len);
+			ASSERT(di->txp[txout] == NULL);
+
+			txout = NEXTTXD(txout);
+		}
+
+		/* See above. No need to loop over individual buffers */
+		if (DMASGLIST_ENAB)
+			break;
+	}
+
+	/* if last txd eof not set, fix it */
+	if (!(flags & D64_CTRL1_EOF))
+		W_SM(&di->txd64[PREVTXD(txout)].ctrl1,
+		     BUS_SWAP32(flags | D64_CTRL1_IOC | D64_CTRL1_EOF));
+
+	/* save the packet */
+	di->txp[PREVTXD(txout)] = p0;
+
+	/* bump the tx descriptor index */
+	di->txout = txout;
+
+	/* kick the chip */
+	if (commit)
+		W_REG(di->osh, &di->d64txregs->ptr,
+		      di->xmtptrbase + I2B(txout, dma64dd_t));
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (0);
+
+ outoftxd:
+	DMA_ERROR(("%s: dma_txfast: out of txds !!!\n", di->name));
+	PKTFREE(di->osh, p0, TRUE);
+	di->hnddma.txavail = 0;
+	di->hnddma.txnobuf++;
+	return (-1);
+}
+
+/*
+ * Reclaim next completed txd (txds if using chained buffers) in the range
+ * specified and return associated packet.
+ * If range is HNDDMA_RANGE_TRANSMITTED, reclaim descriptors that have be
+ * transmitted as noted by the hardware "CurrDescr" pointer.
+ * If range is HNDDMA_RANGE_TRANSFERED, reclaim descriptors that have be
+ * transfered by the DMA as noted by the hardware "ActiveDescr" pointer.
+ * If range is HNDDMA_RANGE_ALL, reclaim all txd(s) posted to the ring and
+ * return associated packet regardless of the value of hardware pointers.
+ */
+static void *BCMFASTPATH dma64_getnexttxp(dma_info_t * di, txd_range_t range)
+{
+	uint16 start, end, i;
+	uint16 active_desc;
+	void *txp;
+
+	DMA_TRACE(("%s: dma_getnexttxp %s\n", di->name,
+		   (range == HNDDMA_RANGE_ALL) ? "all" :
+		   ((range ==
+		     HNDDMA_RANGE_TRANSMITTED) ? "transmitted" :
+		    "transfered")));
+
+	if (di->ntxd == 0)
+		return (NULL);
+
+	txp = NULL;
+
+	start = di->txin;
+	if (range == HNDDMA_RANGE_ALL)
+		end = di->txout;
+	else {
+		dma64regs_t *dregs = di->d64txregs;
+
+		end =
+		    (uint16) (B2I
+			      (((R_REG(di->osh, &dregs->status0) &
+				 D64_XS0_CD_MASK) -
+				di->xmtptrbase) & D64_XS0_CD_MASK, dma64dd_t));
+
+		if (range == HNDDMA_RANGE_TRANSFERED) {
+			active_desc =
+			    (uint16) (R_REG(di->osh, &dregs->status1) &
+				      D64_XS1_AD_MASK);
+			active_desc =
+			    (active_desc - di->xmtptrbase) & D64_XS0_CD_MASK;
+			active_desc = B2I(active_desc, dma64dd_t);
+			if (end != active_desc)
+				end = PREVTXD(active_desc);
+		}
+	}
+
+	if ((start == 0) && (end > di->txout))
+		goto bogus;
+
+	for (i = start; i != end && !txp; i = NEXTTXD(i)) {
+		dmaaddr_t pa;
+		hnddma_seg_map_t *map = NULL;
+		uint size, j, nsegs;
+
+		PHYSADDRLOSET(pa,
+			      (BUS_SWAP32(R_SM(&di->txd64[i].addrlow)) -
+			       di->dataoffsetlow));
+		PHYSADDRHISET(pa,
+			      (BUS_SWAP32(R_SM(&di->txd64[i].addrhigh)) -
+			       di->dataoffsethigh));
+
+		if (DMASGLIST_ENAB) {
+			map = &di->txp_dmah[i];
+			size = map->origsize;
+			nsegs = map->nsegs;
+		} else {
+			size =
+			    (BUS_SWAP32(R_SM(&di->txd64[i].ctrl2)) &
+			     D64_CTRL2_BC_MASK);
+			nsegs = 1;
+		}
+
+		for (j = nsegs; j > 0; j--) {
+			W_SM(&di->txd64[i].addrlow, 0xdeadbeef);
+			W_SM(&di->txd64[i].addrhigh, 0xdeadbeef);
+
+			txp = di->txp[i];
+			di->txp[i] = NULL;
+			if (j > 1)
+				i = NEXTTXD(i);
+		}
+
+		DMA_UNMAP(di->osh, pa, size, DMA_TX, txp, map);
+	}
+
+	di->txin = i;
+
+	/* tx flow control */
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	return (txp);
+
+ bogus:
+	DMA_NONE(("dma_getnexttxp: bogus curr: start %d end %d txout %d force %d\n", start, end, di->txout, forceall));
+	return (NULL);
+}
+
+static void *BCMFASTPATH dma64_getnextrxp(dma_info_t * di, bool forceall)
+{
+	uint i, curr;
+	void *rxp;
+	dmaaddr_t pa;
+
+	/* if forcing, dma engine must be disabled */
+	ASSERT(!forceall || !dma64_rxenabled(di));
+
+	i = di->rxin;
+
+	/* return if no packets posted */
+	if (i == di->rxout)
+		return (NULL);
+
+	curr =
+	    B2I(((R_REG(di->osh, &di->d64rxregs->status0) & D64_RS0_CD_MASK) -
+		 di->rcvptrbase) & D64_RS0_CD_MASK, dma64dd_t);
+
+	/* ignore curr if forceall */
+	if (!forceall && (i == curr))
+		return (NULL);
+
+	/* get the packet pointer that corresponds to the rx descriptor */
+	rxp = di->rxp[i];
+	ASSERT(rxp);
+	di->rxp[i] = NULL;
+
+	PHYSADDRLOSET(pa,
+		      (BUS_SWAP32(R_SM(&di->rxd64[i].addrlow)) -
+		       di->dataoffsetlow));
+	PHYSADDRHISET(pa,
+		      (BUS_SWAP32(R_SM(&di->rxd64[i].addrhigh)) -
+		       di->dataoffsethigh));
+
+	/* clear this packet from the descriptor ring */
+	DMA_UNMAP(di->osh, pa, di->rxbufsize, DMA_RX, rxp, &di->rxp_dmah[i]);
+
+	W_SM(&di->rxd64[i].addrlow, 0xdeadbeef);
+	W_SM(&di->rxd64[i].addrhigh, 0xdeadbeef);
+
+	di->rxin = NEXTRXD(i);
+
+	return (rxp);
+}
+
+static bool _dma64_addrext(osl_t * osh, dma64regs_t * dma64regs)
+{
+	uint32 w;
+	OR_REG(osh, &dma64regs->control, D64_XC_AE);
+	w = R_REG(osh, &dma64regs->control);
+	AND_REG(osh, &dma64regs->control, ~D64_XC_AE);
+	return ((w & D64_XC_AE) == D64_XC_AE);
+}
+
+/*
+ * Rotate all active tx dma ring entries "forward" by (ActiveDescriptor - txin).
+ */
+static void dma64_txrotate(dma_info_t * di)
+{
+	uint16 ad;
+	uint nactive;
+	uint rot;
+	uint16 old, new;
+	uint32 w;
+	uint16 first, last;
+
+	ASSERT(dma64_txsuspendedidle(di));
+
+	nactive = _dma_txactive(di);
+	ad = (uint16) (B2I
+		       ((((R_REG(di->osh, &di->d64txregs->status1) &
+			   D64_XS1_AD_MASK)
+			  - di->xmtptrbase) & D64_XS1_AD_MASK), dma64dd_t));
+	rot = TXD(ad - di->txin);
+
+	ASSERT(rot < di->ntxd);
+
+	/* full-ring case is a lot harder - don't worry about this */
+	if (rot >= (di->ntxd - nactive)) {
+		DMA_ERROR(("%s: dma_txrotate: ring full - punt\n", di->name));
+		return;
+	}
+
+	first = di->txin;
+	last = PREVTXD(di->txout);
+
+	/* move entries starting at last and moving backwards to first */
+	for (old = last; old != PREVTXD(first); old = PREVTXD(old)) {
+		new = TXD(old + rot);
+
+		/*
+		 * Move the tx dma descriptor.
+		 * EOT is set only in the last entry in the ring.
+		 */
+		w = BUS_SWAP32(R_SM(&di->txd64[old].ctrl1)) & ~D64_CTRL1_EOT;
+		if (new == (di->ntxd - 1))
+			w |= D64_CTRL1_EOT;
+		W_SM(&di->txd64[new].ctrl1, BUS_SWAP32(w));
+
+		w = BUS_SWAP32(R_SM(&di->txd64[old].ctrl2));
+		W_SM(&di->txd64[new].ctrl2, BUS_SWAP32(w));
+
+		W_SM(&di->txd64[new].addrlow, R_SM(&di->txd64[old].addrlow));
+		W_SM(&di->txd64[new].addrhigh, R_SM(&di->txd64[old].addrhigh));
+
+		/* zap the old tx dma descriptor address field */
+		W_SM(&di->txd64[old].addrlow, BUS_SWAP32(0xdeadbeef));
+		W_SM(&di->txd64[old].addrhigh, BUS_SWAP32(0xdeadbeef));
+
+		/* move the corresponding txp[] entry */
+		ASSERT(di->txp[new] == NULL);
+		di->txp[new] = di->txp[old];
+
+		/* Move the map */
+		if (DMASGLIST_ENAB) {
+			bcopy(&di->txp_dmah[old], &di->txp_dmah[new],
+			      sizeof(hnddma_seg_map_t));
+			bzero(&di->txp_dmah[old], sizeof(hnddma_seg_map_t));
+		}
+
+		di->txp[old] = NULL;
+	}
+
+	/* update txin and txout */
+	di->txin = ad;
+	di->txout = TXD(di->txout + rot);
+	di->hnddma.txavail = di->ntxd - NTXDACTIVE(di->txin, di->txout) - 1;
+
+	/* kick the chip */
+	W_REG(di->osh, &di->d64txregs->ptr,
+	      di->xmtptrbase + I2B(di->txout, dma64dd_t));
+}
+
+uint dma_addrwidth(si_t * sih, void *dmaregs)
+{
+	dma32regs_t *dma32regs;
+	osl_t *osh;
+
+	osh = si_osh(sih);
+
+	/* Perform 64-bit checks only if we want to advertise 64-bit (> 32bit) capability) */
+	/* DMA engine is 64-bit capable */
+	if ((si_core_sflags(sih, 0, 0) & SISF_DMA64) == SISF_DMA64) {
+		/* backplane are 64-bit capable */
+		if (si_backplane64(sih))
+			/* If bus is System Backplane or PCIE then we can access 64-bits */
+			if ((BUSTYPE(sih->bustype) == SI_BUS) ||
+			    ((BUSTYPE(sih->bustype) == PCI_BUS) &&
+			     (sih->buscoretype == PCIE_CORE_ID)))
+				return (DMADDRWIDTH_64);
+
+		/* DMA64 is always 32-bit capable, AE is always TRUE */
+		ASSERT(_dma64_addrext(osh, (dma64regs_t *) dmaregs));
+
+		return (DMADDRWIDTH_32);
+	}
+
+	/* Start checking for 32-bit / 30-bit addressing */
+	dma32regs = (dma32regs_t *) dmaregs;
+
+	/* For System Backplane, PCIE bus or addrext feature, 32-bits ok */
+	if ((BUSTYPE(sih->bustype) == SI_BUS) ||
+	    ((BUSTYPE(sih->bustype) == PCI_BUS)
+	     && sih->buscoretype == PCIE_CORE_ID)
+	    || (_dma32_addrext(osh, dma32regs)))
+		return (DMADDRWIDTH_32);
+
+	/* Fallthru */
+	return (DMADDRWIDTH_30);
+}
diff --git a/drivers/staging/brcm80211/util/hndpmu.c b/drivers/staging/brcm80211/util/hndpmu.c
new file mode 100644
index 0000000..5fca01e
--- /dev/null
+++ b/drivers/staging/brcm80211/util/hndpmu.c
@@ -0,0 +1,2681 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmdevs.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <hndpmu.h>
+#include "siutils_priv.h"
+
+#define	PMU_ERROR(args)
+
+#ifdef BCMDBG
+#define	PMU_MSG(args)	printf args
+#else
+#define	PMU_MSG(args)
+#endif				/* BCMDBG */
+
+/* To check in verbose debugging messages not intended
+ * to be on except on private builds.
+ */
+#define	PMU_NONE(args)
+
+/* PLL controls/clocks */
+static void si_pmu1_pllinit0(si_t * sih, osl_t * osh, chipcregs_t * cc,
+			     uint32 xtal);
+static uint32 si_pmu1_cpuclk0(si_t * sih, osl_t * osh, chipcregs_t * cc);
+static uint32 si_pmu1_alpclk0(si_t * sih, osl_t * osh, chipcregs_t * cc);
+
+/* PMU resources */
+static bool si_pmu_res_depfltr_bb(si_t * sih);
+static bool si_pmu_res_depfltr_ncb(si_t * sih);
+static bool si_pmu_res_depfltr_paldo(si_t * sih);
+static bool si_pmu_res_depfltr_npaldo(si_t * sih);
+static uint32 si_pmu_res_deps(si_t * sih, osl_t * osh, chipcregs_t * cc,
+			      uint32 rsrcs, bool all);
+static uint si_pmu_res_uptime(si_t * sih, osl_t * osh, chipcregs_t * cc,
+			      uint8 rsrc);
+static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax);
+static void si_pmu_spuravoid_pllupdate(si_t * sih, chipcregs_t * cc,
+				       osl_t * osh, uint8 spuravoid);
+
+static void si_pmu_set_4330_plldivs(si_t * sih);
+
+/* FVCO frequency */
+#define FVCO_880	880000	/* 880MHz */
+#define FVCO_1760	1760000	/* 1760MHz */
+#define FVCO_1440	1440000	/* 1440MHz */
+#define FVCO_960	960000	/* 960MHz */
+
+/* Read/write a chipcontrol reg */
+uint32 si_pmu_chipcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+{
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+		   reg);
+	return si_corereg(sih, SI_CC_IDX,
+			  OFFSETOF(chipcregs_t, chipcontrol_data), mask, val);
+}
+
+/* Read/write a regcontrol reg */
+uint32 si_pmu_regcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+{
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr), ~0,
+		   reg);
+	return si_corereg(sih, SI_CC_IDX,
+			  OFFSETOF(chipcregs_t, regcontrol_data), mask, val);
+}
+
+/* Read/write a pllcontrol reg */
+uint32 si_pmu_pllcontrol(si_t * sih, uint reg, uint32 mask, uint32 val)
+{
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pllcontrol_addr), ~0,
+		   reg);
+	return si_corereg(sih, SI_CC_IDX,
+			  OFFSETOF(chipcregs_t, pllcontrol_data), mask, val);
+}
+
+/* PMU PLL update */
+void si_pmu_pllupd(si_t * sih)
+{
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmucontrol),
+		   PCTL_PLL_PLLCTL_UPD, PCTL_PLL_PLLCTL_UPD);
+}
+
+/* Setup switcher voltage */
+void
+BCMATTACHFN(si_pmu_set_switcher_voltage) (si_t * sih, osl_t * osh,
+					  uint8 bb_voltage, uint8 rf_voltage) {
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	W_REG(osh, &cc->regcontrol_addr, 0x01);
+	W_REG(osh, &cc->regcontrol_data, (uint32) (bb_voltage & 0x1f) << 22);
+
+	W_REG(osh, &cc->regcontrol_addr, 0x00);
+	W_REG(osh, &cc->regcontrol_data, (uint32) (rf_voltage & 0x1f) << 14);
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+void
+BCMATTACHFN(si_pmu_set_ldo_voltage) (si_t * sih, osl_t * osh, uint8 ldo,
+				     uint8 voltage) {
+	uint8 sr_cntl_shift = 0, rc_shift = 0, shift = 0, mask = 0;
+	uint8 addr = 0;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4336_CHIP_ID:
+		switch (ldo) {
+		case SET_LDO_VOLTAGE_CLDO_PWM:
+			addr = 4;
+			rc_shift = 1;
+			mask = 0xf;
+			break;
+		case SET_LDO_VOLTAGE_CLDO_BURST:
+			addr = 4;
+			rc_shift = 5;
+			mask = 0xf;
+			break;
+		case SET_LDO_VOLTAGE_LNLDO1:
+			addr = 4;
+			rc_shift = 17;
+			mask = 0xf;
+			break;
+		default:
+			ASSERT(FALSE);
+			return;
+		}
+		break;
+	case BCM4330_CHIP_ID:
+		switch (ldo) {
+		case SET_LDO_VOLTAGE_CBUCK_PWM:
+			addr = 3;
+			rc_shift = 0;
+			mask = 0x1f;
+			break;
+		default:
+			ASSERT(FALSE);
+			break;
+		}
+		break;
+	default:
+		ASSERT(FALSE);
+		return;
+	}
+
+	shift = sr_cntl_shift + rc_shift;
+
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_addr),
+		   ~0, addr);
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, regcontrol_data),
+		   mask << shift, (voltage & mask) << shift);
+}
+
+/* d11 slow to fast clock transition time in slow clock cycles */
+#define D11SCC_SLOW2FAST_TRANSITION	2
+
+uint16 BCMINITFN(si_pmu_fast_pwrup_delay) (si_t * sih, osl_t * osh) {
+	uint delay = PMU_MAX_TRANSITION_DLY;
+	chipcregs_t *cc;
+	uint origidx;
+#ifdef BCMDBG
+	char chn[8];
+	chn[0] = 0;		/* to suppress compile error */
+#endif
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:
+	case BCM4331_CHIP_ID:
+	case BCM6362_CHIP_ID:
+	case BCM4313_CHIP_ID:
+		delay = ISSIM_ENAB(sih) ? 70 : 3700;
+		break;
+	case BCM4329_CHIP_ID:
+		if (ISSIM_ENAB(sih))
+			delay = 70;
+		else {
+			uint32 ilp = si_ilp_clock(sih);
+			delay =
+			    (si_pmu_res_uptime(sih, osh, cc, RES4329_HT_AVAIL) +
+			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
+							      1) / ilp);
+			delay = (11 * delay) / 10;
+		}
+		break;
+	case BCM4319_CHIP_ID:
+		delay = ISSIM_ENAB(sih) ? 70 : 3700;
+		break;
+	case BCM4336_CHIP_ID:
+		if (ISSIM_ENAB(sih))
+			delay = 70;
+		else {
+			uint32 ilp = si_ilp_clock(sih);
+			delay =
+			    (si_pmu_res_uptime(sih, osh, cc, RES4336_HT_AVAIL) +
+			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
+							      1) / ilp);
+			delay = (11 * delay) / 10;
+		}
+		break;
+	case BCM4330_CHIP_ID:
+		if (ISSIM_ENAB(sih))
+			delay = 70;
+		else {
+			uint32 ilp = si_ilp_clock(sih);
+			delay =
+			    (si_pmu_res_uptime(sih, osh, cc, RES4330_HT_AVAIL) +
+			     D11SCC_SLOW2FAST_TRANSITION) * ((1000000 + ilp -
+							      1) / ilp);
+			delay = (11 * delay) / 10;
+		}
+		break;
+	default:
+		break;
+	}
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+
+	return (uint16) delay;
+}
+
+uint32 BCMATTACHFN(si_pmu_force_ilp) (si_t * sih, osl_t * osh, bool force) {
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 oldpmucontrol;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	oldpmucontrol = R_REG(osh, &cc->pmucontrol);
+	if (force)
+		W_REG(osh, &cc->pmucontrol, oldpmucontrol &
+		      ~(PCTL_HT_REQ_EN | PCTL_ALP_REQ_EN));
+	else
+		W_REG(osh, &cc->pmucontrol, oldpmucontrol |
+		      (PCTL_HT_REQ_EN | PCTL_ALP_REQ_EN));
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+
+	return oldpmucontrol;
+}
+
+/* Setup resource up/down timers */
+typedef struct {
+	uint8 resnum;
+	uint16 updown;
+} pmu_res_updown_t;
+
+/* Change resource dependancies masks */
+typedef struct {
+	uint32 res_mask;	/* resources (chip specific) */
+	int8 action;		/* action */
+	uint32 depend_mask;	/* changes to the dependancies mask */
+	 bool(*filter) (si_t * sih);	/* action is taken when filter is NULL or return TRUE */
+} pmu_res_depend_t;
+
+/* Resource dependancies mask change action */
+#define RES_DEPEND_SET		0	/* Override the dependancies mask */
+#define RES_DEPEND_ADD		1	/* Add to the  dependancies mask */
+#define RES_DEPEND_REMOVE	-1	/* Remove from the dependancies mask */
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4328a0_res_updown)[] =
+{
+	{
+	RES4328_EXT_SWITCHER_PWM, 0x0101}, {
+	RES4328_BB_SWITCHER_PWM, 0x1f01}, {
+	RES4328_BB_SWITCHER_BURST, 0x010f}, {
+	RES4328_BB_EXT_SWITCHER_BURST, 0x0101}, {
+	RES4328_ILP_REQUEST, 0x0202}, {
+	RES4328_RADIO_SWITCHER_PWM, 0x0f01}, {
+	RES4328_RADIO_SWITCHER_BURST, 0x0f01}, {
+	RES4328_ROM_SWITCH, 0x0101}, {
+	RES4328_PA_REF_LDO, 0x0f01}, {
+	RES4328_RADIO_LDO, 0x0f01}, {
+	RES4328_AFE_LDO, 0x0f01}, {
+	RES4328_PLL_LDO, 0x0f01}, {
+	RES4328_BG_FILTBYP, 0x0101}, {
+	RES4328_TX_FILTBYP, 0x0101}, {
+	RES4328_RX_FILTBYP, 0x0101}, {
+	RES4328_XTAL_PU, 0x0101}, {
+	RES4328_XTAL_EN, 0xa001}, {
+	RES4328_BB_PLL_FILTBYP, 0x0101}, {
+	RES4328_RF_PLL_FILTBYP, 0x0101}, {
+	RES4328_BB_PLL_PU, 0x0701}
+};
+
+static const pmu_res_depend_t BCMATTACHDATA(bcm4328a0_res_depend)[] =
+{
+	/* Adjust ILP request resource not to force ext/BB switchers into burst mode */
+	{
+	PMURES_BIT(RES4328_ILP_REQUEST),
+		    RES_DEPEND_SET,
+		    PMURES_BIT(RES4328_EXT_SWITCHER_PWM) |
+		    PMURES_BIT(RES4328_BB_SWITCHER_PWM), NULL}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4325a0_res_updown_qt)[] =
+{
+	{
+	RES4325_HT_AVAIL, 0x0300}, {
+	RES4325_BBPLL_PWRSW_PU, 0x0101}, {
+	RES4325_RFPLL_PWRSW_PU, 0x0101}, {
+	RES4325_ALP_AVAIL, 0x0100}, {
+	RES4325_XTAL_PU, 0x1000}, {
+	RES4325_LNLDO1_PU, 0x0800}, {
+	RES4325_CLDO_CBUCK_PWM, 0x0101}, {
+	RES4325_CBUCK_PWM, 0x0803}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4325a0_res_updown)[] =
+{
+	{
+	RES4325_XTAL_PU, 0x1501}
+};
+
+static const pmu_res_depend_t BCMATTACHDATA(bcm4325a0_res_depend)[] =
+{
+	/* Adjust OTP PU resource dependencies - remove BB BURST */
+	{
+	PMURES_BIT(RES4325_OTP_PU),
+		    RES_DEPEND_REMOVE,
+		    PMURES_BIT(RES4325_BUCK_BOOST_BURST), NULL},
+	    /* Adjust ALP/HT Avail resource dependencies - bring up BB along if it is used. */
+	{
+	PMURES_BIT(RES4325_ALP_AVAIL) | PMURES_BIT(RES4325_HT_AVAIL),
+		    RES_DEPEND_ADD,
+		    PMURES_BIT(RES4325_BUCK_BOOST_BURST) |
+		    PMURES_BIT(RES4325_BUCK_BOOST_PWM), si_pmu_res_depfltr_bb},
+	    /* Adjust HT Avail resource dependencies - bring up RF switches along with HT. */
+	{
+	PMURES_BIT(RES4325_HT_AVAIL),
+		    RES_DEPEND_ADD,
+		    PMURES_BIT(RES4325_RX_PWRSW_PU) |
+		    PMURES_BIT(RES4325_TX_PWRSW_PU) |
+		    PMURES_BIT(RES4325_LOGEN_PWRSW_PU) |
+		    PMURES_BIT(RES4325_AFE_PWRSW_PU), NULL},
+	    /* Adjust ALL resource dependencies - remove CBUCK dependancies if it is not used. */
+	{
+	PMURES_BIT(RES4325_ILP_REQUEST) |
+		    PMURES_BIT(RES4325_ABUCK_BURST) |
+		    PMURES_BIT(RES4325_ABUCK_PWM) |
+		    PMURES_BIT(RES4325_LNLDO1_PU) |
+		    PMURES_BIT(RES4325C1_LNLDO2_PU) |
+		    PMURES_BIT(RES4325_XTAL_PU) |
+		    PMURES_BIT(RES4325_ALP_AVAIL) |
+		    PMURES_BIT(RES4325_RX_PWRSW_PU) |
+		    PMURES_BIT(RES4325_TX_PWRSW_PU) |
+		    PMURES_BIT(RES4325_RFPLL_PWRSW_PU) |
+		    PMURES_BIT(RES4325_LOGEN_PWRSW_PU) |
+		    PMURES_BIT(RES4325_AFE_PWRSW_PU) |
+		    PMURES_BIT(RES4325_BBPLL_PWRSW_PU) |
+		    PMURES_BIT(RES4325_HT_AVAIL), RES_DEPEND_REMOVE,
+		    PMURES_BIT(RES4325B0_CBUCK_LPOM) |
+		    PMURES_BIT(RES4325B0_CBUCK_BURST) |
+		    PMURES_BIT(RES4325B0_CBUCK_PWM), si_pmu_res_depfltr_ncb}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4315a0_res_updown_qt)[] =
+{
+	{
+	RES4315_HT_AVAIL, 0x0101}, {
+	RES4315_XTAL_PU, 0x0100}, {
+	RES4315_LNLDO1_PU, 0x0100}, {
+	RES4315_PALDO_PU, 0x0100}, {
+	RES4315_CLDO_PU, 0x0100}, {
+	RES4315_CBUCK_PWM, 0x0100}, {
+	RES4315_CBUCK_BURST, 0x0100}, {
+	RES4315_CBUCK_LPOM, 0x0100}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4315a0_res_updown)[] =
+{
+	{
+	RES4315_XTAL_PU, 0x2501}
+};
+
+static const pmu_res_depend_t BCMATTACHDATA(bcm4315a0_res_depend)[] =
+{
+	/* Adjust OTP PU resource dependencies - not need PALDO unless write */
+	{
+	PMURES_BIT(RES4315_OTP_PU),
+		    RES_DEPEND_REMOVE,
+		    PMURES_BIT(RES4315_PALDO_PU), si_pmu_res_depfltr_npaldo},
+	    /* Adjust ALP/HT Avail resource dependencies - bring up PALDO along if it is used. */
+	{
+	PMURES_BIT(RES4315_ALP_AVAIL) | PMURES_BIT(RES4315_HT_AVAIL),
+		    RES_DEPEND_ADD,
+		    PMURES_BIT(RES4315_PALDO_PU), si_pmu_res_depfltr_paldo},
+	    /* Adjust HT Avail resource dependencies - bring up RF switches along with HT. */
+	{
+	PMURES_BIT(RES4315_HT_AVAIL),
+		    RES_DEPEND_ADD,
+		    PMURES_BIT(RES4315_RX_PWRSW_PU) |
+		    PMURES_BIT(RES4315_TX_PWRSW_PU) |
+		    PMURES_BIT(RES4315_LOGEN_PWRSW_PU) |
+		    PMURES_BIT(RES4315_AFE_PWRSW_PU), NULL},
+	    /* Adjust ALL resource dependencies - remove CBUCK dependancies if it is not used. */
+	{
+	PMURES_BIT(RES4315_CLDO_PU) | PMURES_BIT(RES4315_ILP_REQUEST) |
+		    PMURES_BIT(RES4315_LNLDO1_PU) |
+		    PMURES_BIT(RES4315_OTP_PU) |
+		    PMURES_BIT(RES4315_LNLDO2_PU) |
+		    PMURES_BIT(RES4315_XTAL_PU) |
+		    PMURES_BIT(RES4315_ALP_AVAIL) |
+		    PMURES_BIT(RES4315_RX_PWRSW_PU) |
+		    PMURES_BIT(RES4315_TX_PWRSW_PU) |
+		    PMURES_BIT(RES4315_RFPLL_PWRSW_PU) |
+		    PMURES_BIT(RES4315_LOGEN_PWRSW_PU) |
+		    PMURES_BIT(RES4315_AFE_PWRSW_PU) |
+		    PMURES_BIT(RES4315_BBPLL_PWRSW_PU) |
+		    PMURES_BIT(RES4315_HT_AVAIL), RES_DEPEND_REMOVE,
+		    PMURES_BIT(RES4315_CBUCK_LPOM) |
+		    PMURES_BIT(RES4315_CBUCK_BURST) |
+		    PMURES_BIT(RES4315_CBUCK_PWM), si_pmu_res_depfltr_ncb}
+};
+
+	/* 4329 specific. needs to come back this issue later */
+static const pmu_res_updown_t BCMINITDATA(bcm4329_res_updown)[] =
+{
+	{
+	RES4329_XTAL_PU, 0x1501}
+};
+
+static const pmu_res_depend_t BCMINITDATA(bcm4329_res_depend)[] =
+{
+	/* Adjust HT Avail resource dependencies */
+	{
+	PMURES_BIT(RES4329_HT_AVAIL),
+		    RES_DEPEND_ADD,
+		    PMURES_BIT(RES4329_CBUCK_LPOM) |
+		    PMURES_BIT(RES4329_CBUCK_BURST) |
+		    PMURES_BIT(RES4329_CBUCK_PWM) |
+		    PMURES_BIT(RES4329_CLDO_PU) |
+		    PMURES_BIT(RES4329_PALDO_PU) |
+		    PMURES_BIT(RES4329_LNLDO1_PU) |
+		    PMURES_BIT(RES4329_XTAL_PU) |
+		    PMURES_BIT(RES4329_ALP_AVAIL) |
+		    PMURES_BIT(RES4329_RX_PWRSW_PU) |
+		    PMURES_BIT(RES4329_TX_PWRSW_PU) |
+		    PMURES_BIT(RES4329_RFPLL_PWRSW_PU) |
+		    PMURES_BIT(RES4329_LOGEN_PWRSW_PU) |
+		    PMURES_BIT(RES4329_AFE_PWRSW_PU) |
+		    PMURES_BIT(RES4329_BBPLL_PWRSW_PU), NULL}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4319a0_res_updown_qt)[] =
+{
+	{
+	RES4319_HT_AVAIL, 0x0101}, {
+	RES4319_XTAL_PU, 0x0100}, {
+	RES4319_LNLDO1_PU, 0x0100}, {
+	RES4319_PALDO_PU, 0x0100}, {
+	RES4319_CLDO_PU, 0x0100}, {
+	RES4319_CBUCK_PWM, 0x0100}, {
+	RES4319_CBUCK_BURST, 0x0100}, {
+	RES4319_CBUCK_LPOM, 0x0100}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4319a0_res_updown)[] =
+{
+	{
+	RES4319_XTAL_PU, 0x3f01}
+};
+
+static const pmu_res_depend_t BCMATTACHDATA(bcm4319a0_res_depend)[] =
+{
+	/* Adjust OTP PU resource dependencies - not need PALDO unless write */
+	{
+	PMURES_BIT(RES4319_OTP_PU),
+		    RES_DEPEND_REMOVE,
+		    PMURES_BIT(RES4319_PALDO_PU), si_pmu_res_depfltr_npaldo},
+	    /* Adjust HT Avail resource dependencies - bring up PALDO along if it is used. */
+	{
+	PMURES_BIT(RES4319_HT_AVAIL),
+		    RES_DEPEND_ADD,
+		    PMURES_BIT(RES4319_PALDO_PU), si_pmu_res_depfltr_paldo},
+	    /* Adjust HT Avail resource dependencies - bring up RF switches along with HT. */
+	{
+	PMURES_BIT(RES4319_HT_AVAIL),
+		    RES_DEPEND_ADD,
+		    PMURES_BIT(RES4319_RX_PWRSW_PU) |
+		    PMURES_BIT(RES4319_TX_PWRSW_PU) |
+		    PMURES_BIT(RES4319_RFPLL_PWRSW_PU) |
+		    PMURES_BIT(RES4319_LOGEN_PWRSW_PU) |
+		    PMURES_BIT(RES4319_AFE_PWRSW_PU), NULL}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4336a0_res_updown_qt)[] =
+{
+	{
+	RES4336_HT_AVAIL, 0x0101}, {
+	RES4336_XTAL_PU, 0x0100}, {
+	RES4336_CLDO_PU, 0x0100}, {
+	RES4336_CBUCK_PWM, 0x0100}, {
+	RES4336_CBUCK_BURST, 0x0100}, {
+	RES4336_CBUCK_LPOM, 0x0100}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4336a0_res_updown)[] =
+{
+	{
+	RES4336_HT_AVAIL, 0x0D01}
+};
+
+static const pmu_res_depend_t BCMATTACHDATA(bcm4336a0_res_depend)[] =
+{
+	/* Just a dummy entry for now */
+	{
+	PMURES_BIT(RES4336_RSVD), RES_DEPEND_ADD, 0, NULL}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4330a0_res_updown_qt)[] =
+{
+	{
+	RES4330_HT_AVAIL, 0x0101}, {
+	RES4330_XTAL_PU, 0x0100}, {
+	RES4330_CLDO_PU, 0x0100}, {
+	RES4330_CBUCK_PWM, 0x0100}, {
+	RES4330_CBUCK_BURST, 0x0100}, {
+	RES4330_CBUCK_LPOM, 0x0100}
+};
+
+static const pmu_res_updown_t BCMATTACHDATA(bcm4330a0_res_updown)[] =
+{
+	{
+	RES4330_HT_AVAIL, 0x0e02}
+};
+
+static const pmu_res_depend_t BCMATTACHDATA(bcm4330a0_res_depend)[] =
+{
+	/* Just a dummy entry for now */
+	{
+	PMURES_BIT(RES4330_HT_AVAIL), RES_DEPEND_ADD, 0, NULL}
+};
+
+/* TRUE if the power topology uses the buck boost to provide 3.3V to VDDIO_RF and WLAN PA */
+static bool BCMATTACHFN(si_pmu_res_depfltr_bb) (si_t * sih) {
+	return (sih->boardflags & BFL_BUCKBOOST) != 0;
+}
+
+/* TRUE if the power topology doesn't use the cbuck. Key on chiprev also if the chip is BCM4325. */
+static bool BCMATTACHFN(si_pmu_res_depfltr_ncb) (si_t * sih) {
+
+	return ((sih->boardflags & BFL_NOCBUCK) != 0);
+}
+
+/* TRUE if the power topology uses the PALDO */
+static bool BCMATTACHFN(si_pmu_res_depfltr_paldo) (si_t * sih) {
+	return (sih->boardflags & BFL_PALDO) != 0;
+}
+
+/* TRUE if the power topology doesn't use the PALDO */
+static bool BCMATTACHFN(si_pmu_res_depfltr_npaldo) (si_t * sih) {
+	return (sih->boardflags & BFL_PALDO) == 0;
+}
+
+#define BCM94325_BBVDDIOSD_BOARDS(sih) (sih->boardtype == BCM94325DEVBU_BOARD || \
+					sih->boardtype == BCM94325BGABU_BOARD)
+
+/* Determine min/max rsrc masks. Value 0 leaves hardware at default. */
+static void si_pmu_res_masks(si_t * sih, uint32 * pmin, uint32 * pmax)
+{
+	uint32 min_mask = 0, max_mask = 0;
+	uint rsrcs;
+	char *val;
+
+	/* # resources */
+	rsrcs = (sih->pmucaps & PCAP_RC_MASK) >> PCAP_RC_SHIFT;
+
+	/* determine min/max rsrc masks */
+	switch (CHIPID(sih->chip)) {
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:
+	case BCM4331_CHIP_ID:
+	case BCM6362_CHIP_ID:
+		/* ??? */
+		break;
+
+	case BCM4329_CHIP_ID:
+		/* 4329 spedific issue. Needs to come back this issue later */
+		/* Down to save the power. */
+		min_mask =
+		    PMURES_BIT(RES4329_CBUCK_LPOM) |
+		    PMURES_BIT(RES4329_CLDO_PU);
+		/* Allow (but don't require) PLL to turn on */
+		max_mask = 0x3ff63e;
+		break;
+	case BCM4319_CHIP_ID:
+		/* We only need a few resources to be kept on all the time */
+		min_mask = PMURES_BIT(RES4319_CBUCK_LPOM) |
+		    PMURES_BIT(RES4319_CLDO_PU);
+
+		/* Allow everything else to be turned on upon requests */
+		max_mask = ~(~0 << rsrcs);
+		break;
+	case BCM4336_CHIP_ID:
+		/* Down to save the power. */
+		min_mask =
+		    PMURES_BIT(RES4336_CBUCK_LPOM) | PMURES_BIT(RES4336_CLDO_PU)
+		    | PMURES_BIT(RES4336_LDO3P3_PU) | PMURES_BIT(RES4336_OTP_PU)
+		    | PMURES_BIT(RES4336_DIS_INT_RESET_PD);
+		/* Allow (but don't require) PLL to turn on */
+		max_mask = 0x1ffffff;
+		break;
+
+	case BCM4330_CHIP_ID:
+		/* Down to save the power. */
+		min_mask =
+		    PMURES_BIT(RES4330_CBUCK_LPOM) | PMURES_BIT(RES4330_CLDO_PU)
+		    | PMURES_BIT(RES4330_DIS_INT_RESET_PD) |
+		    PMURES_BIT(RES4330_LDO3P3_PU) | PMURES_BIT(RES4330_OTP_PU);
+		/* Allow (but don't require) PLL to turn on */
+		max_mask = 0xfffffff;
+		break;
+
+	case BCM4313_CHIP_ID:
+		min_mask = PMURES_BIT(RES4313_BB_PU_RSRC) |
+		    PMURES_BIT(RES4313_XTAL_PU_RSRC) |
+		    PMURES_BIT(RES4313_ALP_AVAIL_RSRC) |
+		    PMURES_BIT(RES4313_BB_PLL_PWRSW_RSRC);
+		max_mask = 0xffff;
+		break;
+	default:
+		break;
+	}
+
+	/* Apply nvram override to min mask */
+	if ((val = getvar(NULL, "rmin")) != NULL) {
+		PMU_MSG(("Applying rmin=%s to min_mask\n", val));
+		min_mask = (uint32) bcm_strtoul(val, NULL, 0);
+	}
+	/* Apply nvram override to max mask */
+	if ((val = getvar(NULL, "rmax")) != NULL) {
+		PMU_MSG(("Applying rmax=%s to max_mask\n", val));
+		max_mask = (uint32) bcm_strtoul(val, NULL, 0);
+	}
+
+	*pmin = min_mask;
+	*pmax = max_mask;
+}
+
+/* initialize PMU resources */
+void BCMATTACHFN(si_pmu_res_init) (si_t * sih, osl_t * osh) {
+	chipcregs_t *cc;
+	uint origidx;
+	const pmu_res_updown_t *pmu_res_updown_table = NULL;
+	uint pmu_res_updown_table_sz = 0;
+	const pmu_res_depend_t *pmu_res_depend_table = NULL;
+	uint pmu_res_depend_table_sz = 0;
+	uint32 min_mask = 0, max_mask = 0;
+	char name[8], *val;
+	uint i, rsrcs;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		/* Optimize resources up/down timers */
+		if (ISSIM_ENAB(sih)) {
+			pmu_res_updown_table = NULL;
+			pmu_res_updown_table_sz = 0;
+		} else {
+			pmu_res_updown_table = bcm4329_res_updown;
+			pmu_res_updown_table_sz = ARRAYSIZE(bcm4329_res_updown);
+		}
+		/* Optimize resources dependencies */
+		pmu_res_depend_table = bcm4329_res_depend;
+		pmu_res_depend_table_sz = ARRAYSIZE(bcm4329_res_depend);
+		break;
+
+	case BCM4319_CHIP_ID:
+		/* Optimize resources up/down timers */
+		if (ISSIM_ENAB(sih)) {
+			pmu_res_updown_table = bcm4319a0_res_updown_qt;
+			pmu_res_updown_table_sz =
+			    ARRAYSIZE(bcm4319a0_res_updown_qt);
+		} else {
+			pmu_res_updown_table = bcm4319a0_res_updown;
+			pmu_res_updown_table_sz =
+			    ARRAYSIZE(bcm4319a0_res_updown);
+		}
+		/* Optimize resources dependancies masks */
+		pmu_res_depend_table = bcm4319a0_res_depend;
+		pmu_res_depend_table_sz = ARRAYSIZE(bcm4319a0_res_depend);
+		break;
+
+	case BCM4336_CHIP_ID:
+		/* Optimize resources up/down timers */
+		if (ISSIM_ENAB(sih)) {
+			pmu_res_updown_table = bcm4336a0_res_updown_qt;
+			pmu_res_updown_table_sz =
+			    ARRAYSIZE(bcm4336a0_res_updown_qt);
+		} else {
+			pmu_res_updown_table = bcm4336a0_res_updown;
+			pmu_res_updown_table_sz =
+			    ARRAYSIZE(bcm4336a0_res_updown);
+		}
+		/* Optimize resources dependancies masks */
+		pmu_res_depend_table = bcm4336a0_res_depend;
+		pmu_res_depend_table_sz = ARRAYSIZE(bcm4336a0_res_depend);
+		break;
+
+	case BCM4330_CHIP_ID:
+		/* Optimize resources up/down timers */
+		if (ISSIM_ENAB(sih)) {
+			pmu_res_updown_table = bcm4330a0_res_updown_qt;
+			pmu_res_updown_table_sz =
+			    ARRAYSIZE(bcm4330a0_res_updown_qt);
+		} else {
+			pmu_res_updown_table = bcm4330a0_res_updown;
+			pmu_res_updown_table_sz =
+			    ARRAYSIZE(bcm4330a0_res_updown);
+		}
+		/* Optimize resources dependancies masks */
+		pmu_res_depend_table = bcm4330a0_res_depend;
+		pmu_res_depend_table_sz = ARRAYSIZE(bcm4330a0_res_depend);
+		break;
+
+	default:
+		break;
+	}
+
+	/* # resources */
+	rsrcs = (sih->pmucaps & PCAP_RC_MASK) >> PCAP_RC_SHIFT;
+
+	/* Program up/down timers */
+	while (pmu_res_updown_table_sz--) {
+		ASSERT(pmu_res_updown_table != NULL);
+		PMU_MSG(("Changing rsrc %d res_updn_timer to 0x%x\n",
+			 pmu_res_updown_table[pmu_res_updown_table_sz].resnum,
+			 pmu_res_updown_table[pmu_res_updown_table_sz].updown));
+		W_REG(osh, &cc->res_table_sel,
+		      pmu_res_updown_table[pmu_res_updown_table_sz].resnum);
+		W_REG(osh, &cc->res_updn_timer,
+		      pmu_res_updown_table[pmu_res_updown_table_sz].updown);
+	}
+	/* Apply nvram overrides to up/down timers */
+	for (i = 0; i < rsrcs; i++) {
+		snprintf(name, sizeof(name), "r%dt", i);
+		if ((val = getvar(NULL, name)) == NULL)
+			continue;
+		PMU_MSG(("Applying %s=%s to rsrc %d res_updn_timer\n", name,
+			 val, i));
+		W_REG(osh, &cc->res_table_sel, (uint32) i);
+		W_REG(osh, &cc->res_updn_timer,
+		      (uint32) bcm_strtoul(val, NULL, 0));
+	}
+
+	/* Program resource dependencies table */
+	while (pmu_res_depend_table_sz--) {
+		ASSERT(pmu_res_depend_table != NULL);
+		if (pmu_res_depend_table[pmu_res_depend_table_sz].filter != NULL
+		    && !(pmu_res_depend_table[pmu_res_depend_table_sz].
+			 filter) (sih))
+			continue;
+		for (i = 0; i < rsrcs; i++) {
+			if ((pmu_res_depend_table[pmu_res_depend_table_sz].
+			     res_mask & PMURES_BIT(i)) == 0)
+				continue;
+			W_REG(osh, &cc->res_table_sel, i);
+			switch (pmu_res_depend_table[pmu_res_depend_table_sz].
+				action) {
+			case RES_DEPEND_SET:
+				PMU_MSG(("Changing rsrc %d res_dep_mask to 0x%x\n", i, pmu_res_depend_table[pmu_res_depend_table_sz].depend_mask));
+				W_REG(osh, &cc->res_dep_mask,
+				      pmu_res_depend_table
+				      [pmu_res_depend_table_sz].depend_mask);
+				break;
+			case RES_DEPEND_ADD:
+				PMU_MSG(("Adding 0x%x to rsrc %d res_dep_mask\n", pmu_res_depend_table[pmu_res_depend_table_sz].depend_mask, i));
+				OR_REG(osh, &cc->res_dep_mask,
+				       pmu_res_depend_table
+				       [pmu_res_depend_table_sz].depend_mask);
+				break;
+			case RES_DEPEND_REMOVE:
+				PMU_MSG(("Removing 0x%x from rsrc %d res_dep_mask\n", pmu_res_depend_table[pmu_res_depend_table_sz].depend_mask, i));
+				AND_REG(osh, &cc->res_dep_mask,
+					~pmu_res_depend_table
+					[pmu_res_depend_table_sz].depend_mask);
+				break;
+			default:
+				ASSERT(0);
+				break;
+			}
+		}
+	}
+	/* Apply nvram overrides to dependancies masks */
+	for (i = 0; i < rsrcs; i++) {
+		snprintf(name, sizeof(name), "r%dd", i);
+		if ((val = getvar(NULL, name)) == NULL)
+			continue;
+		PMU_MSG(("Applying %s=%s to rsrc %d res_dep_mask\n", name, val,
+			 i));
+		W_REG(osh, &cc->res_table_sel, (uint32) i);
+		W_REG(osh, &cc->res_dep_mask,
+		      (uint32) bcm_strtoul(val, NULL, 0));
+	}
+
+	/* Determine min/max rsrc masks */
+	si_pmu_res_masks(sih, &min_mask, &max_mask);
+
+	/* It is required to program max_mask first and then min_mask */
+
+	/* Program max resource mask */
+
+	if (max_mask) {
+		PMU_MSG(("Changing max_res_mask to 0x%x\n", max_mask));
+		W_REG(osh, &cc->max_res_mask, max_mask);
+	}
+
+	/* Program min resource mask */
+
+	if (min_mask) {
+		PMU_MSG(("Changing min_res_mask to 0x%x\n", min_mask));
+		W_REG(osh, &cc->min_res_mask, min_mask);
+	}
+
+	/* Add some delay; allow resources to come up and settle. */
+	OSL_DELAY(2000);
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+/* setup pll and query clock speed */
+typedef struct {
+	uint16 freq;
+	uint8 xf;
+	uint8 wbint;
+	uint32 wbfrac;
+} pmu0_xtaltab0_t;
+
+/* the following table is based on 880Mhz fvco */
+static const pmu0_xtaltab0_t BCMINITDATA(pmu0_xtaltab0)[] =
+{
+	{
+	12000, 1, 73, 349525}, {
+	13000, 2, 67, 725937}, {
+	14400, 3, 61, 116508}, {
+	15360, 4, 57, 305834}, {
+	16200, 5, 54, 336579}, {
+	16800, 6, 52, 399457}, {
+	19200, 7, 45, 873813}, {
+	19800, 8, 44, 466033}, {
+	20000, 9, 44, 0}, {
+	25000, 10, 70, 419430}, {
+	26000, 11, 67, 725937}, {
+	30000, 12, 58, 699050}, {
+	38400, 13, 45, 873813}, {
+	40000, 14, 45, 0}, {
+	0, 0, 0, 0}
+};
+
+#define PMU0_XTAL0_DEFAULT	8
+
+/* setup pll and query clock speed */
+typedef struct {
+	uint16 fref;
+	uint8 xf;
+	uint8 p1div;
+	uint8 p2div;
+	uint8 ndiv_int;
+	uint32 ndiv_frac;
+} pmu1_xtaltab0_t;
+
+static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_880_4329)[] =
+{
+	{
+	12000, 1, 3, 22, 0x9, 0xFFFFEF}, {
+	13000, 2, 1, 6, 0xb, 0x483483}, {
+	14400, 3, 1, 10, 0xa, 0x1C71C7}, {
+	15360, 4, 1, 5, 0xb, 0x755555}, {
+	16200, 5, 1, 10, 0x5, 0x6E9E06}, {
+	16800, 6, 1, 10, 0x5, 0x3Cf3Cf}, {
+	19200, 7, 1, 4, 0xb, 0x755555}, {
+	19800, 8, 1, 11, 0x4, 0xA57EB}, {
+	20000, 9, 1, 11, 0x4, 0x0}, {
+	24000, 10, 3, 11, 0xa, 0x0}, {
+	25000, 11, 5, 16, 0xb, 0x0}, {
+	26000, 12, 1, 1, 0x21, 0xD89D89}, {
+	30000, 13, 3, 8, 0xb, 0x0}, {
+	37400, 14, 3, 1, 0x46, 0x969696}, {
+	38400, 15, 1, 1, 0x16, 0xEAAAAA}, {
+	40000, 16, 1, 2, 0xb, 0}, {
+	0, 0, 0, 0, 0, 0}
+};
+
+/* the following table is based on 880Mhz fvco */
+static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_880)[] =
+{
+	{
+	12000, 1, 3, 22, 0x9, 0xFFFFEF}, {
+	13000, 2, 1, 6, 0xb, 0x483483}, {
+	14400, 3, 1, 10, 0xa, 0x1C71C7}, {
+	15360, 4, 1, 5, 0xb, 0x755555}, {
+	16200, 5, 1, 10, 0x5, 0x6E9E06}, {
+	16800, 6, 1, 10, 0x5, 0x3Cf3Cf}, {
+	19200, 7, 1, 4, 0xb, 0x755555}, {
+	19800, 8, 1, 11, 0x4, 0xA57EB}, {
+	20000, 9, 1, 11, 0x4, 0x0}, {
+	24000, 10, 3, 11, 0xa, 0x0}, {
+	25000, 11, 5, 16, 0xb, 0x0}, {
+	26000, 12, 1, 2, 0x10, 0xEC4EC4}, {
+	30000, 13, 3, 8, 0xb, 0x0}, {
+	33600, 14, 1, 2, 0xd, 0x186186}, {
+	38400, 15, 1, 2, 0xb, 0x755555}, {
+	40000, 16, 1, 2, 0xb, 0}, {
+	0, 0, 0, 0, 0, 0}
+};
+
+#define PMU1_XTALTAB0_880_12000K	0
+#define PMU1_XTALTAB0_880_13000K	1
+#define PMU1_XTALTAB0_880_14400K	2
+#define PMU1_XTALTAB0_880_15360K	3
+#define PMU1_XTALTAB0_880_16200K	4
+#define PMU1_XTALTAB0_880_16800K	5
+#define PMU1_XTALTAB0_880_19200K	6
+#define PMU1_XTALTAB0_880_19800K	7
+#define PMU1_XTALTAB0_880_20000K	8
+#define PMU1_XTALTAB0_880_24000K	9
+#define PMU1_XTALTAB0_880_25000K	10
+#define PMU1_XTALTAB0_880_26000K	11
+#define PMU1_XTALTAB0_880_30000K	12
+#define PMU1_XTALTAB0_880_37400K	13
+#define PMU1_XTALTAB0_880_38400K	14
+#define PMU1_XTALTAB0_880_40000K	15
+
+/* the following table is based on 1760Mhz fvco */
+static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_1760)[] =
+{
+	{
+	12000, 1, 3, 44, 0x9, 0xFFFFEF}, {
+	13000, 2, 1, 12, 0xb, 0x483483}, {
+	14400, 3, 1, 20, 0xa, 0x1C71C7}, {
+	15360, 4, 1, 10, 0xb, 0x755555}, {
+	16200, 5, 1, 20, 0x5, 0x6E9E06}, {
+	16800, 6, 1, 20, 0x5, 0x3Cf3Cf}, {
+	19200, 7, 1, 18, 0x5, 0x17B425}, {
+	19800, 8, 1, 22, 0x4, 0xA57EB}, {
+	20000, 9, 1, 22, 0x4, 0x0}, {
+	24000, 10, 3, 22, 0xa, 0x0}, {
+	25000, 11, 5, 32, 0xb, 0x0}, {
+	26000, 12, 1, 4, 0x10, 0xEC4EC4}, {
+	30000, 13, 3, 16, 0xb, 0x0}, {
+	38400, 14, 1, 10, 0x4, 0x955555}, {
+	40000, 15, 1, 4, 0xb, 0}, {
+	0, 0, 0, 0, 0, 0}
+};
+
+/* table index */
+#define PMU1_XTALTAB0_1760_12000K	0
+#define PMU1_XTALTAB0_1760_13000K	1
+#define PMU1_XTALTAB0_1760_14400K	2
+#define PMU1_XTALTAB0_1760_15360K	3
+#define PMU1_XTALTAB0_1760_16200K	4
+#define PMU1_XTALTAB0_1760_16800K	5
+#define PMU1_XTALTAB0_1760_19200K	6
+#define PMU1_XTALTAB0_1760_19800K	7
+#define PMU1_XTALTAB0_1760_20000K	8
+#define PMU1_XTALTAB0_1760_24000K	9
+#define PMU1_XTALTAB0_1760_25000K	10
+#define PMU1_XTALTAB0_1760_26000K	11
+#define PMU1_XTALTAB0_1760_30000K	12
+#define PMU1_XTALTAB0_1760_38400K	13
+#define PMU1_XTALTAB0_1760_40000K	14
+
+/* the following table is based on 1440Mhz fvco */
+static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_1440)[] =
+{
+	{
+	12000, 1, 1, 1, 0x78, 0x0}, {
+	13000, 2, 1, 1, 0x6E, 0xC4EC4E}, {
+	14400, 3, 1, 1, 0x64, 0x0}, {
+	15360, 4, 1, 1, 0x5D, 0xC00000}, {
+	16200, 5, 1, 1, 0x58, 0xE38E38}, {
+	16800, 6, 1, 1, 0x55, 0xB6DB6D}, {
+	19200, 7, 1, 1, 0x4B, 0}, {
+	19800, 8, 1, 1, 0x48, 0xBA2E8B}, {
+	20000, 9, 1, 1, 0x48, 0x0}, {
+	25000, 10, 1, 1, 0x39, 0x999999}, {
+	26000, 11, 1, 1, 0x37, 0x627627}, {
+	30000, 12, 1, 1, 0x30, 0x0}, {
+	37400, 13, 2, 1, 0x4D, 0x15E76}, {
+	38400, 13, 2, 1, 0x4B, 0x0}, {
+	40000, 14, 2, 1, 0x48, 0x0}, {
+	48000, 15, 2, 1, 0x3c, 0x0}, {
+	0, 0, 0, 0, 0, 0}
+};
+
+/* table index */
+#define PMU1_XTALTAB0_1440_12000K	0
+#define PMU1_XTALTAB0_1440_13000K	1
+#define PMU1_XTALTAB0_1440_14400K	2
+#define PMU1_XTALTAB0_1440_15360K	3
+#define PMU1_XTALTAB0_1440_16200K	4
+#define PMU1_XTALTAB0_1440_16800K	5
+#define PMU1_XTALTAB0_1440_19200K	6
+#define PMU1_XTALTAB0_1440_19800K	7
+#define PMU1_XTALTAB0_1440_20000K	8
+#define PMU1_XTALTAB0_1440_25000K	9
+#define PMU1_XTALTAB0_1440_26000K	10
+#define PMU1_XTALTAB0_1440_30000K	11
+#define PMU1_XTALTAB0_1440_37400K	12
+#define PMU1_XTALTAB0_1440_38400K	13
+#define PMU1_XTALTAB0_1440_40000K	14
+#define PMU1_XTALTAB0_1440_48000K	15
+
+#define XTAL_FREQ_24000MHZ		24000
+#define XTAL_FREQ_30000MHZ		30000
+#define XTAL_FREQ_37400MHZ		37400
+#define XTAL_FREQ_48000MHZ		48000
+
+static const pmu1_xtaltab0_t BCMINITDATA(pmu1_xtaltab0_960)[] =
+{
+	{
+	12000, 1, 1, 1, 0x50, 0x0}, {
+	13000, 2, 1, 1, 0x49, 0xD89D89}, {
+	14400, 3, 1, 1, 0x42, 0xAAAAAA}, {
+	15360, 4, 1, 1, 0x3E, 0x800000}, {
+	16200, 5, 1, 1, 0x39, 0x425ED0}, {
+	16800, 6, 1, 1, 0x39, 0x249249}, {
+	19200, 7, 1, 1, 0x32, 0x0}, {
+	19800, 8, 1, 1, 0x30, 0x7C1F07}, {
+	20000, 9, 1, 1, 0x30, 0x0}, {
+	25000, 10, 1, 1, 0x26, 0x666666}, {
+	26000, 11, 1, 1, 0x24, 0xEC4EC4}, {
+	30000, 12, 1, 1, 0x20, 0x0}, {
+	37400, 13, 2, 1, 0x33, 0x563EF9}, {
+	38400, 14, 2, 1, 0x32, 0x0}, {
+	40000, 15, 2, 1, 0x30, 0x0}, {
+	48000, 16, 2, 1, 0x28, 0x0}, {
+	0, 0, 0, 0, 0, 0}
+};
+
+/* table index */
+#define PMU1_XTALTAB0_960_12000K	0
+#define PMU1_XTALTAB0_960_13000K	1
+#define PMU1_XTALTAB0_960_14400K	2
+#define PMU1_XTALTAB0_960_15360K	3
+#define PMU1_XTALTAB0_960_16200K	4
+#define PMU1_XTALTAB0_960_16800K	5
+#define PMU1_XTALTAB0_960_19200K	6
+#define PMU1_XTALTAB0_960_19800K	7
+#define PMU1_XTALTAB0_960_20000K	8
+#define PMU1_XTALTAB0_960_25000K	9
+#define PMU1_XTALTAB0_960_26000K	10
+#define PMU1_XTALTAB0_960_30000K	11
+#define PMU1_XTALTAB0_960_37400K	12
+#define PMU1_XTALTAB0_960_38400K	13
+#define PMU1_XTALTAB0_960_40000K	14
+#define PMU1_XTALTAB0_960_48000K	15
+
+/* select xtal table for each chip */
+static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaltab0) (si_t * sih) {
+#ifdef BCMDBG
+	char chn[8];
+#endif
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		return pmu1_xtaltab0_880_4329;
+	case BCM4319_CHIP_ID:
+		return pmu1_xtaltab0_1440;
+	case BCM4336_CHIP_ID:
+		return pmu1_xtaltab0_960;
+	case BCM4330_CHIP_ID:
+		if (CST4330_CHIPMODE_SDIOD(sih->chipst))
+			return pmu1_xtaltab0_960;
+		else
+			return pmu1_xtaltab0_1440;
+	default:
+		PMU_MSG(("si_pmu1_xtaltab0: Unknown chipid %s\n",
+			 bcm_chipname(sih->chip, chn, 8)));
+		break;
+	}
+	ASSERT(0);
+	return NULL;
+}
+
+/* select default xtal frequency for each chip */
+static const pmu1_xtaltab0_t *BCMINITFN(si_pmu1_xtaldef0) (si_t * sih) {
+#ifdef BCMDBG
+	char chn[8];
+#endif
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		/* Default to 38400Khz */
+		return &pmu1_xtaltab0_880_4329[PMU1_XTALTAB0_880_38400K];
+	case BCM4319_CHIP_ID:
+		/* Default to 30000Khz */
+		return &pmu1_xtaltab0_1440[PMU1_XTALTAB0_1440_30000K];
+	case BCM4336_CHIP_ID:
+		/* Default to 26000Khz */
+		return &pmu1_xtaltab0_960[PMU1_XTALTAB0_960_26000K];
+	case BCM4330_CHIP_ID:
+		/* Default to 37400Khz */
+		if (CST4330_CHIPMODE_SDIOD(sih->chipst))
+			return &pmu1_xtaltab0_960[PMU1_XTALTAB0_960_37400K];
+		else
+			return &pmu1_xtaltab0_1440[PMU1_XTALTAB0_1440_37400K];
+	default:
+		PMU_MSG(("si_pmu1_xtaldef0: Unknown chipid %s\n",
+			 bcm_chipname(sih->chip, chn, 8)));
+		break;
+	}
+	ASSERT(0);
+	return NULL;
+}
+
+/* select default pll fvco for each chip */
+static uint32 BCMINITFN(si_pmu1_pllfvco0) (si_t * sih) {
+#ifdef BCMDBG
+	char chn[8];
+#endif
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		return FVCO_880;
+	case BCM4319_CHIP_ID:
+		return FVCO_1440;
+	case BCM4336_CHIP_ID:
+		return FVCO_960;
+	case BCM4330_CHIP_ID:
+		if (CST4330_CHIPMODE_SDIOD(sih->chipst))
+			return FVCO_960;
+		else
+			return FVCO_1440;
+	default:
+		PMU_MSG(("si_pmu1_pllfvco0: Unknown chipid %s\n",
+			 bcm_chipname(sih->chip, chn, 8)));
+		break;
+	}
+	ASSERT(0);
+	return 0;
+}
+
+/* query alp/xtal clock frequency */
+static uint32
+BCMINITFN(si_pmu1_alpclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
+	const pmu1_xtaltab0_t *xt;
+	uint32 xf;
+
+	/* Find the frequency in the table */
+	xf = (R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	    PCTL_XTALFREQ_SHIFT;
+	for (xt = si_pmu1_xtaltab0(sih); xt != NULL && xt->fref != 0; xt++)
+		if (xt->xf == xf)
+			break;
+	/* Could not find it so assign a default value */
+	if (xt == NULL || xt->fref == 0)
+		xt = si_pmu1_xtaldef0(sih);
+	ASSERT(xt != NULL && xt->fref != 0);
+
+	return xt->fref * 1000;
+}
+
+/* Set up PLL registers in the PMU as per the crystal speed.
+ * XtalFreq field in pmucontrol register being 0 indicates the PLL
+ * is not programmed and the h/w default is assumed to work, in which
+ * case the xtal frequency is unknown to the s/w so we need to call
+ * si_pmu1_xtaldef0() wherever it is needed to return a default value.
+ */
+static void
+BCMATTACHFN(si_pmu1_pllinit0) (si_t * sih, osl_t * osh, chipcregs_t * cc,
+			       uint32 xtal) {
+	const pmu1_xtaltab0_t *xt;
+	uint32 tmp;
+	uint32 buf_strength = 0;
+	uint8 ndiv_mode = 1;
+
+	/* Use h/w default PLL config */
+	if (xtal == 0) {
+		PMU_MSG(("Unspecified xtal frequency, skip PLL configuration\n"));
+		return;
+	}
+
+	/* Find the frequency in the table */
+	for (xt = si_pmu1_xtaltab0(sih); xt != NULL && xt->fref != 0; xt++)
+		if (xt->fref == xtal)
+			break;
+
+	/* Check current PLL state, bail out if it has been programmed or
+	 * we don't know how to program it.
+	 */
+	if (xt == NULL || xt->fref == 0) {
+		PMU_MSG(("Unsupported xtal frequency %d.%d MHz, skip PLL configuration\n", xtal / 1000, xtal % 1000));
+		return;
+	}
+	/*  for 4319 bootloader already programs the PLL but bootloader does not program the
+	   PLL4 and PLL5. So Skip this check for 4319
+	 */
+	if ((((R_REG(osh, &cc->pmucontrol) & PCTL_XTALFREQ_MASK) >>
+	      PCTL_XTALFREQ_SHIFT) == xt->xf) &&
+	    !((CHIPID(sih->chip) == BCM4319_CHIP_ID)
+	      || (CHIPID(sih->chip) == BCM4330_CHIP_ID))) {
+		PMU_MSG(("PLL already programmed for %d.%d MHz\n",
+			 xt->fref / 1000, xt->fref % 1000));
+		return;
+	}
+
+	PMU_MSG(("XTAL %d.%d MHz (%d)\n", xtal / 1000, xtal % 1000, xt->xf));
+	PMU_MSG(("Programming PLL for %d.%d MHz\n", xt->fref / 1000,
+		 xt->fref % 1000));
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		/* Change the BBPLL drive strength to 8 for all channels */
+		buf_strength = 0x888888;
+		AND_REG(osh, &cc->min_res_mask,
+			~(PMURES_BIT(RES4329_BBPLL_PWRSW_PU) |
+			  PMURES_BIT(RES4329_HT_AVAIL)));
+		AND_REG(osh, &cc->max_res_mask,
+			~(PMURES_BIT(RES4329_BBPLL_PWRSW_PU) |
+			  PMURES_BIT(RES4329_HT_AVAIL)));
+		SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL,
+			 PMU_MAX_TRANSITION_DLY);
+		ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+		if (xt->fref == 38400)
+			tmp = 0x200024C0;
+		else if (xt->fref == 37400)
+			tmp = 0x20004500;
+		else if (xt->fref == 26000)
+			tmp = 0x200024C0;
+		else
+			tmp = 0x200005C0;	/* Chip Dflt Settings */
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+		tmp =
+		    R_REG(osh,
+			  &cc->pllcontrol_data) & PMU1_PLL0_PC5_CLK_DRV_MASK;
+		if ((xt->fref == 38400) || (xt->fref == 37400)
+		    || (xt->fref == 26000))
+			tmp |= 0x15;
+		else
+			tmp |= 0x25;	/* Chip Dflt Settings */
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+		break;
+
+	case BCM4319_CHIP_ID:
+		/* Change the BBPLL drive strength to 2 for all channels */
+		buf_strength = 0x222222;
+
+		/* Make sure the PLL is off */
+		/* WAR65104: Disable the HT_AVAIL resource first and then
+		 * after a delay (more than downtime for HT_AVAIL) remove the
+		 * BBPLL resource; backplane clock moves to ALP from HT.
+		 */
+		AND_REG(osh, &cc->min_res_mask,
+			~(PMURES_BIT(RES4319_HT_AVAIL)));
+		AND_REG(osh, &cc->max_res_mask,
+			~(PMURES_BIT(RES4319_HT_AVAIL)));
+
+		OSL_DELAY(100);
+		AND_REG(osh, &cc->min_res_mask,
+			~(PMURES_BIT(RES4319_BBPLL_PWRSW_PU)));
+		AND_REG(osh, &cc->max_res_mask,
+			~(PMURES_BIT(RES4319_BBPLL_PWRSW_PU)));
+
+		OSL_DELAY(100);
+		SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL,
+			 PMU_MAX_TRANSITION_DLY);
+		ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+		tmp = 0x200005c0;
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+		break;
+
+	case BCM4336_CHIP_ID:
+		AND_REG(osh, &cc->min_res_mask,
+			~(PMURES_BIT(RES4336_HT_AVAIL) |
+			  PMURES_BIT(RES4336_MACPHY_CLKAVAIL)));
+		AND_REG(osh, &cc->max_res_mask,
+			~(PMURES_BIT(RES4336_HT_AVAIL) |
+			  PMURES_BIT(RES4336_MACPHY_CLKAVAIL)));
+		OSL_DELAY(100);
+		SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL,
+			 PMU_MAX_TRANSITION_DLY);
+		ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
+		break;
+
+	case BCM4330_CHIP_ID:
+		AND_REG(osh, &cc->min_res_mask,
+			~(PMURES_BIT(RES4330_HT_AVAIL) |
+			  PMURES_BIT(RES4330_MACPHY_CLKAVAIL)));
+		AND_REG(osh, &cc->max_res_mask,
+			~(PMURES_BIT(RES4330_HT_AVAIL) |
+			  PMURES_BIT(RES4330_MACPHY_CLKAVAIL)));
+		OSL_DELAY(100);
+		SPINWAIT(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL,
+			 PMU_MAX_TRANSITION_DLY);
+		ASSERT(!(R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL));
+		break;
+
+	default:
+		ASSERT(0);
+	}
+
+	PMU_MSG(("Done masking\n"));
+
+	/* Write p1div and p2div to pllcontrol[0] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+	tmp = R_REG(osh, &cc->pllcontrol_data) &
+	    ~(PMU1_PLL0_PC0_P1DIV_MASK | PMU1_PLL0_PC0_P2DIV_MASK);
+	tmp |=
+	    ((xt->
+	      p1div << PMU1_PLL0_PC0_P1DIV_SHIFT) & PMU1_PLL0_PC0_P1DIV_MASK) |
+	    ((xt->
+	      p2div << PMU1_PLL0_PC0_P2DIV_SHIFT) & PMU1_PLL0_PC0_P2DIV_MASK);
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	if ((CHIPID(sih->chip) == BCM4330_CHIP_ID))
+		si_pmu_set_4330_plldivs(sih);
+
+	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID)
+	    && (CHIPREV(sih->chiprev) == 0)) {
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+		tmp = R_REG(osh, &cc->pllcontrol_data);
+		tmp = tmp & (~DOT11MAC_880MHZ_CLK_DIVISOR_MASK);
+		tmp = tmp | DOT11MAC_880MHZ_CLK_DIVISOR_VAL;
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+	}
+	if ((CHIPID(sih->chip) == BCM4319_CHIP_ID) ||
+	    (CHIPID(sih->chip) == BCM4336_CHIP_ID) ||
+	    (CHIPID(sih->chip) == BCM4330_CHIP_ID))
+		ndiv_mode = PMU1_PLL0_PC2_NDIV_MODE_MFB;
+	else
+		ndiv_mode = PMU1_PLL0_PC2_NDIV_MODE_MASH;
+
+	/* Write ndiv_int and ndiv_mode to pllcontrol[2] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+	tmp = R_REG(osh, &cc->pllcontrol_data) &
+	    ~(PMU1_PLL0_PC2_NDIV_INT_MASK | PMU1_PLL0_PC2_NDIV_MODE_MASK);
+	tmp |=
+	    ((xt->
+	      ndiv_int << PMU1_PLL0_PC2_NDIV_INT_SHIFT) &
+	     PMU1_PLL0_PC2_NDIV_INT_MASK) | ((ndiv_mode <<
+					      PMU1_PLL0_PC2_NDIV_MODE_SHIFT) &
+					     PMU1_PLL0_PC2_NDIV_MODE_MASK);
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	/* Write ndiv_frac to pllcontrol[3] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+	tmp = R_REG(osh, &cc->pllcontrol_data) & ~PMU1_PLL0_PC3_NDIV_FRAC_MASK;
+	tmp |= ((xt->ndiv_frac << PMU1_PLL0_PC3_NDIV_FRAC_SHIFT) &
+		PMU1_PLL0_PC3_NDIV_FRAC_MASK);
+	W_REG(osh, &cc->pllcontrol_data, tmp);
+
+	/* Write clock driving strength to pllcontrol[5] */
+	if (buf_strength) {
+		PMU_MSG(("Adjusting PLL buffer drive strength: %x\n",
+			 buf_strength));
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+		tmp =
+		    R_REG(osh,
+			  &cc->pllcontrol_data) & ~PMU1_PLL0_PC5_CLK_DRV_MASK;
+		tmp |= (buf_strength << PMU1_PLL0_PC5_CLK_DRV_SHIFT);
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+	}
+
+	PMU_MSG(("Done pll\n"));
+
+	/* to operate the 4319 usb in 24MHz/48MHz; chipcontrol[2][84:83] needs
+	 * to be updated.
+	 */
+	if ((CHIPID(sih->chip) == BCM4319_CHIP_ID)
+	    && (xt->fref != XTAL_FREQ_30000MHZ)) {
+		W_REG(osh, &cc->chipcontrol_addr, PMU1_PLL0_CHIPCTL2);
+		tmp =
+		    R_REG(osh,
+			  &cc->chipcontrol_data) & ~CCTL_4319USB_XTAL_SEL_MASK;
+		if (xt->fref == XTAL_FREQ_24000MHZ) {
+			tmp |=
+			    (CCTL_4319USB_24MHZ_PLL_SEL <<
+			     CCTL_4319USB_XTAL_SEL_SHIFT);
+		} else if (xt->fref == XTAL_FREQ_48000MHZ) {
+			tmp |=
+			    (CCTL_4319USB_48MHZ_PLL_SEL <<
+			     CCTL_4319USB_XTAL_SEL_SHIFT);
+		}
+		W_REG(osh, &cc->chipcontrol_data, tmp);
+	}
+
+	/* Flush deferred pll control registers writes */
+	if (sih->pmurev >= 2)
+		OR_REG(osh, &cc->pmucontrol, PCTL_PLL_PLLCTL_UPD);
+
+	/* Write XtalFreq. Set the divisor also. */
+	tmp = R_REG(osh, &cc->pmucontrol) &
+	    ~(PCTL_ILP_DIV_MASK | PCTL_XTALFREQ_MASK);
+	tmp |= (((((xt->fref + 127) / 128) - 1) << PCTL_ILP_DIV_SHIFT) &
+		PCTL_ILP_DIV_MASK) |
+	    ((xt->xf << PCTL_XTALFREQ_SHIFT) & PCTL_XTALFREQ_MASK);
+
+	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID)
+	    && CHIPREV(sih->chiprev) == 0) {
+		/* clear the htstretch before clearing HTReqEn */
+		AND_REG(osh, &cc->clkstretch, ~CSTRETCH_HT);
+		tmp &= ~PCTL_HT_REQ_EN;
+	}
+
+	W_REG(osh, &cc->pmucontrol, tmp);
+}
+
+/* query the CPU clock frequency */
+static uint32
+BCMINITFN(si_pmu1_cpuclk0) (si_t * sih, osl_t * osh, chipcregs_t * cc) {
+	uint32 tmp, m1div;
+#ifdef BCMDBG
+	uint32 ndiv_int, ndiv_frac, p2div, p1div, fvco;
+	uint32 fref;
+#endif
+	uint32 FVCO = si_pmu1_pllfvco0(sih);
+
+	/* Read m1div from pllcontrol[1] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	m1div = (tmp & PMU1_PLL0_PC1_M1DIV_MASK) >> PMU1_PLL0_PC1_M1DIV_SHIFT;
+
+#ifdef BCMDBG
+	/* Read p2div/p1div from pllcontrol[0] */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	p2div = (tmp & PMU1_PLL0_PC0_P2DIV_MASK) >> PMU1_PLL0_PC0_P2DIV_SHIFT;
+	p1div = (tmp & PMU1_PLL0_PC0_P1DIV_MASK) >> PMU1_PLL0_PC0_P1DIV_SHIFT;
+
+	/* Calculate fvco based on xtal freq and ndiv and pdiv */
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	ndiv_int =
+	    (tmp & PMU1_PLL0_PC2_NDIV_INT_MASK) >> PMU1_PLL0_PC2_NDIV_INT_SHIFT;
+
+	W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	ndiv_frac =
+	    (tmp & PMU1_PLL0_PC3_NDIV_FRAC_MASK) >>
+	    PMU1_PLL0_PC3_NDIV_FRAC_SHIFT;
+
+	fref = si_pmu1_alpclk0(sih, osh, cc) / 1000;
+
+	fvco = (fref * ndiv_int) << 8;
+	fvco += (fref * (ndiv_frac >> 12)) >> 4;
+	fvco += (fref * (ndiv_frac & 0xfff)) >> 12;
+	fvco >>= 8;
+	fvco *= p2div;
+	fvco /= p1div;
+	fvco /= 1000;
+	fvco *= 1000;
+
+	PMU_MSG(("si_pmu1_cpuclk0: ndiv_int %u ndiv_frac %u p2div %u p1div %u fvco %u\n", ndiv_int, ndiv_frac, p2div, p1div, fvco));
+
+	FVCO = fvco;
+#endif				/* BCMDBG */
+
+	/* Return ARM/SB clock */
+	return FVCO / m1div * 1000;
+}
+
+/* initialize PLL */
+void BCMATTACHFN(si_pmu_pll_init) (si_t * sih, osl_t * osh, uint xtalfreq) {
+	chipcregs_t *cc;
+	uint origidx;
+#ifdef BCMDBG
+	char chn[8];
+#endif
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		if (xtalfreq == 0)
+			xtalfreq = 38400;
+		si_pmu1_pllinit0(sih, osh, cc, xtalfreq);
+		break;
+	case BCM4313_CHIP_ID:
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:
+	case BCM4331_CHIP_ID:
+	case BCM6362_CHIP_ID:
+		/* ??? */
+		break;
+	case BCM4319_CHIP_ID:
+	case BCM4336_CHIP_ID:
+	case BCM4330_CHIP_ID:
+		si_pmu1_pllinit0(sih, osh, cc, xtalfreq);
+		break;
+	default:
+		PMU_MSG(("No PLL init done for chip %s rev %d pmurev %d\n",
+			 bcm_chipname(sih->chip, chn, 8), sih->chiprev,
+			 sih->pmurev));
+		break;
+	}
+
+#ifdef BCMDBG_FORCEHT
+	OR_REG(osh, &cc->clk_ctl_st, CCS_FORCEHT);
+#endif
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+/* query alp/xtal clock frequency */
+uint32 BCMINITFN(si_pmu_alp_clock) (si_t * sih, osl_t * osh) {
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 clock = ALP_CLOCK;
+#ifdef BCMDBG
+	char chn[8];
+#endif
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:
+	case BCM4331_CHIP_ID:
+	case BCM6362_CHIP_ID:
+	case BCM4716_CHIP_ID:
+	case BCM4748_CHIP_ID:
+	case BCM47162_CHIP_ID:
+	case BCM4313_CHIP_ID:
+	case BCM5357_CHIP_ID:
+		/* always 20Mhz */
+		clock = 20000 * 1000;
+		break;
+	case BCM4329_CHIP_ID:
+	case BCM4319_CHIP_ID:
+	case BCM4336_CHIP_ID:
+	case BCM4330_CHIP_ID:
+
+		clock = si_pmu1_alpclk0(sih, osh, cc);
+		break;
+	case BCM5356_CHIP_ID:
+		/* always 25Mhz */
+		clock = 25000 * 1000;
+		break;
+	default:
+		PMU_MSG(("No ALP clock specified "
+			 "for chip %s rev %d pmurev %d, using default %d Hz\n",
+			 bcm_chipname(sih->chip, chn, 8), sih->chiprev,
+			 sih->pmurev, clock));
+		break;
+	}
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+	return clock;
+}
+
+/* Find the output of the "m" pll divider given pll controls that start with
+ * pllreg "pll0" i.e. 12 for main 6 for phy, 0 for misc.
+ */
+static uint32
+BCMINITFN(si_pmu5_clock) (si_t * sih, osl_t * osh, chipcregs_t * cc, uint pll0,
+			  uint m) {
+	uint32 tmp, div, ndiv, p1, p2, fc;
+
+	if ((pll0 & 3) || (pll0 > PMU4716_MAINPLL_PLL0)) {
+		PMU_ERROR(("%s: Bad pll0: %d\n", __func__, pll0));
+		return 0;
+	}
+
+	/* Strictly there is an m5 divider, but I'm not sure we use it */
+	if ((m == 0) || (m > 4)) {
+		PMU_ERROR(("%s: Bad m divider: %d\n", __func__, m));
+		return 0;
+	}
+
+	if (CHIPID(sih->chip) == BCM5357_CHIP_ID) {
+		/* Detect failure in clock setting */
+		if ((R_REG(osh, &cc->chipstatus) & 0x40000) != 0) {
+			return (133 * 1000000);
+		}
+	}
+
+	W_REG(osh, &cc->pllcontrol_addr, pll0 + PMU5_PLL_P1P2_OFF);
+	(void)R_REG(osh, &cc->pllcontrol_addr);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	p1 = (tmp & PMU5_PLL_P1_MASK) >> PMU5_PLL_P1_SHIFT;
+	p2 = (tmp & PMU5_PLL_P2_MASK) >> PMU5_PLL_P2_SHIFT;
+
+	W_REG(osh, &cc->pllcontrol_addr, pll0 + PMU5_PLL_M14_OFF);
+	(void)R_REG(osh, &cc->pllcontrol_addr);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	div = (tmp >> ((m - 1) * PMU5_PLL_MDIV_WIDTH)) & PMU5_PLL_MDIV_MASK;
+
+	W_REG(osh, &cc->pllcontrol_addr, pll0 + PMU5_PLL_NM5_OFF);
+	(void)R_REG(osh, &cc->pllcontrol_addr);
+	tmp = R_REG(osh, &cc->pllcontrol_data);
+	ndiv = (tmp & PMU5_PLL_NDIV_MASK) >> PMU5_PLL_NDIV_SHIFT;
+
+	/* Do calculation in Mhz */
+	fc = si_pmu_alp_clock(sih, osh) / 1000000;
+	fc = (p1 * ndiv * fc) / p2;
+
+	PMU_NONE(("%s: p1=%d, p2=%d, ndiv=%d(0x%x), m%d=%d; fc=%d, clock=%d\n",
+		  __func__, p1, p2, ndiv, ndiv, m, div, fc, fc / div));
+
+	/* Return clock in Hertz */
+	return ((fc / div) * 1000000);
+}
+
+/* query backplane clock frequency */
+/* For designs that feed the same clock to both backplane
+ * and CPU just return the CPU clock speed.
+ */
+uint32 BCMINITFN(si_pmu_si_clock) (si_t * sih, osl_t * osh) {
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 clock = HT_CLOCK;
+#ifdef BCMDBG
+	char chn[8];
+#endif
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM4331_CHIP_ID:
+	case BCM6362_CHIP_ID:
+		/* 96MHz backplane clock */
+		clock = 96000 * 1000;
+		break;
+	case BCM4716_CHIP_ID:
+	case BCM4748_CHIP_ID:
+	case BCM47162_CHIP_ID:
+		clock =
+		    si_pmu5_clock(sih, osh, cc, PMU4716_MAINPLL_PLL0,
+				  PMU5_MAINPLL_SI);
+		break;
+	case BCM4329_CHIP_ID:
+		if (CHIPREV(sih->chiprev) == 0)
+			clock = 38400 * 1000;
+		else
+			clock = si_pmu1_cpuclk0(sih, osh, cc);
+		break;
+	case BCM4319_CHIP_ID:
+	case BCM4336_CHIP_ID:
+	case BCM4330_CHIP_ID:
+		clock = si_pmu1_cpuclk0(sih, osh, cc);
+		break;
+	case BCM4313_CHIP_ID:
+		/* 80MHz backplane clock */
+		clock = 80000 * 1000;
+		break;
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:
+		clock =
+		    (cc->chipstatus & CST43236_BP_CLK) ? (120000 *
+							  1000) : (96000 *
+								   1000);
+		break;
+	case BCM5356_CHIP_ID:
+		clock =
+		    si_pmu5_clock(sih, osh, cc, PMU5356_MAINPLL_PLL0,
+				  PMU5_MAINPLL_SI);
+		break;
+	case BCM5357_CHIP_ID:
+		clock =
+		    si_pmu5_clock(sih, osh, cc, PMU5357_MAINPLL_PLL0,
+				  PMU5_MAINPLL_SI);
+		break;
+	default:
+		PMU_MSG(("No backplane clock specified "
+			 "for chip %s rev %d pmurev %d, using default %d Hz\n",
+			 bcm_chipname(sih->chip, chn, 8), sih->chiprev,
+			 sih->pmurev, clock));
+		break;
+	}
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+	return clock;
+}
+
+/* query CPU clock frequency */
+uint32 BCMINITFN(si_pmu_cpu_clock) (si_t * sih, osl_t * osh) {
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 clock;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	if ((sih->pmurev >= 5) &&
+	    !((CHIPID(sih->chip) == BCM4329_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM4319_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM43236_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM4336_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM4330_CHIP_ID))) {
+		uint pll;
+
+		switch (CHIPID(sih->chip)) {
+		case BCM5356_CHIP_ID:
+			pll = PMU5356_MAINPLL_PLL0;
+			break;
+		case BCM5357_CHIP_ID:
+			pll = PMU5357_MAINPLL_PLL0;
+			break;
+		default:
+			pll = PMU4716_MAINPLL_PLL0;
+			break;
+		}
+
+		/* Remember original core before switch to chipc */
+		origidx = si_coreidx(sih);
+		cc = si_setcoreidx(sih, SI_CC_IDX);
+		ASSERT(cc != NULL);
+
+		clock = si_pmu5_clock(sih, osh, cc, pll, PMU5_MAINPLL_CPU);
+
+		/* Return to original core */
+		si_setcoreidx(sih, origidx);
+	} else
+		clock = si_pmu_si_clock(sih, osh);
+
+	return clock;
+}
+
+/* query memory clock frequency */
+uint32 BCMINITFN(si_pmu_mem_clock) (si_t * sih, osl_t * osh) {
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 clock;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	if ((sih->pmurev >= 5) &&
+	    !((CHIPID(sih->chip) == BCM4329_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM4319_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM4330_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM4336_CHIP_ID) ||
+	      (CHIPID(sih->chip) == BCM43236_CHIP_ID))) {
+		uint pll;
+
+		switch (CHIPID(sih->chip)) {
+		case BCM5356_CHIP_ID:
+			pll = PMU5356_MAINPLL_PLL0;
+			break;
+		case BCM5357_CHIP_ID:
+			pll = PMU5357_MAINPLL_PLL0;
+			break;
+		default:
+			pll = PMU4716_MAINPLL_PLL0;
+			break;
+		}
+
+		/* Remember original core before switch to chipc */
+		origidx = si_coreidx(sih);
+		cc = si_setcoreidx(sih, SI_CC_IDX);
+		ASSERT(cc != NULL);
+
+		clock = si_pmu5_clock(sih, osh, cc, pll, PMU5_MAINPLL_MEM);
+
+		/* Return to original core */
+		si_setcoreidx(sih, origidx);
+	} else {
+		clock = si_pmu_si_clock(sih, osh);
+	}
+
+	return clock;
+}
+
+/* Measure ILP clock frequency */
+#define ILP_CALC_DUR	10	/* ms, make sure 1000 can be divided by it. */
+
+static uint32 ilpcycles_per_sec = 0;
+
+uint32 BCMINITFN(si_pmu_ilp_clock) (si_t * sih, osl_t * osh) {
+	if (ISSIM_ENAB(sih))
+		return ILP_CLOCK;
+
+	if (ilpcycles_per_sec == 0) {
+		uint32 start, end, delta;
+		uint32 origidx = si_coreidx(sih);
+		chipcregs_t *cc = si_setcoreidx(sih, SI_CC_IDX);
+		ASSERT(cc != NULL);
+		start = R_REG(osh, &cc->pmutimer);
+		OSL_DELAY(ILP_CALC_DUR * 1000);
+		end = R_REG(osh, &cc->pmutimer);
+		delta = end - start;
+		ilpcycles_per_sec = delta * (1000 / ILP_CALC_DUR);
+		si_setcoreidx(sih, origidx);
+	}
+
+	return ilpcycles_per_sec;
+}
+
+/* SDIO Pad drive strength to select value mappings */
+typedef struct {
+	uint8 strength;		/* Pad Drive Strength in mA */
+	uint8 sel;		/* Chip-specific select value */
+} sdiod_drive_str_t;
+
+/* SDIO Drive Strength to sel value table for PMU Rev 1 */
+static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab1)[] =
+{
+	{
+	4, 0x2}, {
+	2, 0x3}, {
+	1, 0x0}, {
+0, 0x0}};
+
+/* SDIO Drive Strength to sel value table for PMU Rev 2, 3 */
+static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab2)[] =
+{
+	{
+	12, 0x7}, {
+	10, 0x6}, {
+	8, 0x5}, {
+	6, 0x4}, {
+	4, 0x2}, {
+	2, 0x1}, {
+0, 0x0}};
+
+/* SDIO Drive Strength to sel value table for PMU Rev 8 (1.8V) */
+static const sdiod_drive_str_t BCMINITDATA(sdiod_drive_strength_tab3)[] =
+{
+	{
+	32, 0x7}, {
+	26, 0x6}, {
+	22, 0x5}, {
+	16, 0x4}, {
+	12, 0x3}, {
+	8, 0x2}, {
+	4, 0x1}, {
+0, 0x0}};
+
+#define SDIOD_DRVSTR_KEY(chip, pmu)	(((chip) << 16) | (pmu))
+
+void
+BCMINITFN(si_sdiod_drive_strength_init) (si_t * sih, osl_t * osh,
+					 uint32 drivestrength) {
+	chipcregs_t *cc;
+	uint origidx, intr_val = 0;
+	sdiod_drive_str_t *str_tab = NULL;
+	uint32 str_mask = 0;
+	uint32 str_shift = 0;
+#ifdef BCMDBG
+	char chn[8];
+#endif
+
+	if (!(sih->cccaps & CC_CAP_PMU)) {
+		return;
+	}
+
+	/* Remember original core before switch to chipc */
+	cc = (chipcregs_t *) si_switch_core(sih, CC_CORE_ID, &origidx,
+					    &intr_val);
+
+	switch (SDIOD_DRVSTR_KEY(sih->chip, sih->pmurev)) {
+	case SDIOD_DRVSTR_KEY(BCM4336_CHIP_ID, 8):
+		str_tab = (sdiod_drive_str_t *) & sdiod_drive_strength_tab3;
+		str_mask = 0x00003800;
+		str_shift = 11;
+		break;
+
+	default:
+		PMU_MSG(("No SDIO Drive strength init done for chip %s rev %d pmurev %d\n", bcm_chipname(sih->chip, chn, 8), sih->chiprev, sih->pmurev));
+
+		break;
+	}
+
+	if (str_tab != NULL) {
+		uint32 drivestrength_sel = 0;
+		uint32 cc_data_temp;
+		int i;
+
+		for (i = 0; str_tab[i].strength != 0; i++) {
+			if (drivestrength >= str_tab[i].strength) {
+				drivestrength_sel = str_tab[i].sel;
+				break;
+			}
+		}
+
+		W_REG(osh, &cc->chipcontrol_addr, 1);
+		cc_data_temp = R_REG(osh, &cc->chipcontrol_data);
+		cc_data_temp &= ~str_mask;
+		drivestrength_sel <<= str_shift;
+		cc_data_temp |= drivestrength_sel;
+		W_REG(osh, &cc->chipcontrol_data, cc_data_temp);
+
+		PMU_MSG(("SDIO: %dmA drive strength selected, set to 0x%08x\n",
+			 drivestrength, cc_data_temp));
+	}
+
+	/* Return to original core */
+	si_restore_core(sih, origidx, intr_val);
+}
+
+/* initialize PMU */
+void BCMATTACHFN(si_pmu_init) (si_t * sih, osl_t * osh) {
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	if (sih->pmurev == 1)
+		AND_REG(osh, &cc->pmucontrol, ~PCTL_NOILP_ON_WAIT);
+	else if (sih->pmurev >= 2)
+		OR_REG(osh, &cc->pmucontrol, PCTL_NOILP_ON_WAIT);
+
+	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) && (sih->chiprev == 2)) {
+		/* Fix for 4329b0 bad LPOM state. */
+		W_REG(osh, &cc->regcontrol_addr, 2);
+		OR_REG(osh, &cc->regcontrol_data, 0x100);
+
+		W_REG(osh, &cc->regcontrol_addr, 3);
+		OR_REG(osh, &cc->regcontrol_data, 0x4);
+	}
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+/* Return up time in ILP cycles for the given resource. */
+static uint
+BCMINITFN(si_pmu_res_uptime) (si_t * sih, osl_t * osh, chipcregs_t * cc,
+			      uint8 rsrc) {
+	uint32 deps;
+	uint up, i, dup, dmax;
+	uint32 min_mask = 0, max_mask = 0;
+
+	/* uptime of resource 'rsrc' */
+	W_REG(osh, &cc->res_table_sel, rsrc);
+	up = (R_REG(osh, &cc->res_updn_timer) >> 8) & 0xff;
+
+	/* direct dependancies of resource 'rsrc' */
+	deps = si_pmu_res_deps(sih, osh, cc, PMURES_BIT(rsrc), FALSE);
+	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
+		if (!(deps & PMURES_BIT(i)))
+			continue;
+		deps &= ~si_pmu_res_deps(sih, osh, cc, PMURES_BIT(i), TRUE);
+	}
+	si_pmu_res_masks(sih, &min_mask, &max_mask);
+	deps &= ~min_mask;
+
+	/* max uptime of direct dependancies */
+	dmax = 0;
+	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
+		if (!(deps & PMURES_BIT(i)))
+			continue;
+		dup = si_pmu_res_uptime(sih, osh, cc, (uint8) i);
+		if (dmax < dup)
+			dmax = dup;
+	}
+
+	PMU_MSG(("si_pmu_res_uptime: rsrc %u uptime %u(deps 0x%08x uptime %u)\n", rsrc, up, deps, dmax));
+
+	return up + dmax + PMURES_UP_TRANSITION;
+}
+
+/* Return dependancies (direct or all/indirect) for the given resources */
+static uint32
+si_pmu_res_deps(si_t * sih, osl_t * osh, chipcregs_t * cc, uint32 rsrcs,
+		bool all)
+{
+	uint32 deps = 0;
+	uint32 i;
+
+	for (i = 0; i <= PMURES_MAX_RESNUM; i++) {
+		if (!(rsrcs & PMURES_BIT(i)))
+			continue;
+		W_REG(osh, &cc->res_table_sel, i);
+		deps |= R_REG(osh, &cc->res_dep_mask);
+	}
+
+	return !all ? deps : (deps
+			      ? (deps |
+				 si_pmu_res_deps(sih, osh, cc, deps,
+						 TRUE)) : 0);
+}
+
+/* power up/down OTP through PMU resources */
+void si_pmu_otp_power(si_t * sih, osl_t * osh, bool on)
+{
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 rsrcs = 0;	/* rsrcs to turn on/off OTP power */
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Don't do anything if OTP is disabled */
+	if (si_is_otp_disabled(sih)) {
+		PMU_MSG(("si_pmu_otp_power: OTP is disabled\n"));
+		return;
+	}
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		rsrcs = PMURES_BIT(RES4329_OTP_PU);
+		break;
+	case BCM4319_CHIP_ID:
+		rsrcs = PMURES_BIT(RES4319_OTP_PU);
+		break;
+	case BCM4336_CHIP_ID:
+		rsrcs = PMURES_BIT(RES4336_OTP_PU);
+		break;
+	case BCM4330_CHIP_ID:
+		rsrcs = PMURES_BIT(RES4330_OTP_PU);
+		break;
+	default:
+		break;
+	}
+
+	if (rsrcs != 0) {
+		uint32 otps;
+
+		/* Figure out the dependancies (exclude min_res_mask) */
+		uint32 deps = si_pmu_res_deps(sih, osh, cc, rsrcs, TRUE);
+		uint32 min_mask = 0, max_mask = 0;
+		si_pmu_res_masks(sih, &min_mask, &max_mask);
+		deps &= ~min_mask;
+		/* Turn on/off the power */
+		if (on) {
+			PMU_MSG(("Adding rsrc 0x%x to min_res_mask\n",
+				 rsrcs | deps));
+			OR_REG(osh, &cc->min_res_mask, (rsrcs | deps));
+			SPINWAIT(!(R_REG(osh, &cc->res_state) & rsrcs),
+				 PMU_MAX_TRANSITION_DLY);
+			ASSERT(R_REG(osh, &cc->res_state) & rsrcs);
+		} else {
+			PMU_MSG(("Removing rsrc 0x%x from min_res_mask\n",
+				 rsrcs | deps));
+			AND_REG(osh, &cc->min_res_mask, ~(rsrcs | deps));
+		}
+
+		SPINWAIT((((otps = R_REG(osh, &cc->otpstatus)) & OTPS_READY) !=
+			  (on ? OTPS_READY : 0)), 100);
+		ASSERT((otps & OTPS_READY) == (on ? OTPS_READY : 0));
+		if ((otps & OTPS_READY) != (on ? OTPS_READY : 0))
+			PMU_MSG(("OTP ready bit not %s after wait\n",
+				 (on ? "ON" : "OFF")));
+	}
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+void si_pmu_rcal(si_t * sih, osl_t * osh)
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:{
+			uint8 rcal_code;
+			uint32 val;
+
+			/* Kick RCal */
+			W_REG(osh, &cc->chipcontrol_addr, 1);
+
+			/* Power Down RCAL Block */
+			AND_REG(osh, &cc->chipcontrol_data, ~0x04);
+
+			/* Power Up RCAL block */
+			OR_REG(osh, &cc->chipcontrol_data, 0x04);
+
+			/* Wait for completion */
+			SPINWAIT(0 == (R_REG(osh, &cc->chipstatus) & 0x08),
+				 10 * 1000 * 1000);
+			ASSERT(R_REG(osh, &cc->chipstatus) & 0x08);
+
+			/* Drop the LSB to convert from 5 bit code to 4 bit code */
+			rcal_code =
+			    (uint8) (R_REG(osh, &cc->chipstatus) >> 5) & 0x0f;
+
+			PMU_MSG(("RCal completed, status 0x%x, code 0x%x\n",
+				 R_REG(osh, &cc->chipstatus), rcal_code));
+
+			/* Write RCal code into pmu_vreg_ctrl[32:29] */
+			W_REG(osh, &cc->regcontrol_addr, 0);
+			val =
+			    R_REG(osh,
+				  &cc->
+				  regcontrol_data) & ~((uint32) 0x07 << 29);
+			val |= (uint32) (rcal_code & 0x07) << 29;
+			W_REG(osh, &cc->regcontrol_data, val);
+			W_REG(osh, &cc->regcontrol_addr, 1);
+			val = R_REG(osh, &cc->regcontrol_data) & ~(uint32) 0x01;
+			val |= (uint32) ((rcal_code >> 3) & 0x01);
+			W_REG(osh, &cc->regcontrol_data, val);
+
+			/* Write RCal code into pmu_chip_ctrl[33:30] */
+			W_REG(osh, &cc->chipcontrol_addr, 0);
+			val =
+			    R_REG(osh,
+				  &cc->
+				  chipcontrol_data) & ~((uint32) 0x03 << 30);
+			val |= (uint32) (rcal_code & 0x03) << 30;
+			W_REG(osh, &cc->chipcontrol_data, val);
+			W_REG(osh, &cc->chipcontrol_addr, 1);
+			val =
+			    R_REG(osh, &cc->chipcontrol_data) & ~(uint32) 0x03;
+			val |= (uint32) ((rcal_code >> 2) & 0x03);
+			W_REG(osh, &cc->chipcontrol_data, val);
+
+			/* Set override in pmu_chip_ctrl[29] */
+			W_REG(osh, &cc->chipcontrol_addr, 0);
+			OR_REG(osh, &cc->chipcontrol_data, (0x01 << 29));
+
+			/* Power off RCal block */
+			W_REG(osh, &cc->chipcontrol_addr, 1);
+			AND_REG(osh, &cc->chipcontrol_data, ~0x04);
+
+			break;
+		}
+	default:
+		break;
+	}
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+void si_pmu_spuravoid(si_t * sih, osl_t * osh, uint8 spuravoid)
+{
+	chipcregs_t *cc;
+	uint origidx, intr_val;
+	uint32 tmp = 0;
+
+	/* Remember original core before switch to chipc */
+	cc = (chipcregs_t *) si_switch_core(sih, CC_CORE_ID, &origidx,
+					    &intr_val);
+	ASSERT(cc != NULL);
+
+	/* force the HT off  */
+	if (CHIPID(sih->chip) == BCM4336_CHIP_ID) {
+		tmp = R_REG(osh, &cc->max_res_mask);
+		tmp &= ~RES4336_HT_AVAIL;
+		W_REG(osh, &cc->max_res_mask, tmp);
+		/* wait for the ht to really go away */
+		SPINWAIT(((R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL) == 0),
+			 10000);
+		ASSERT((R_REG(osh, &cc->clk_ctl_st) & CCS_HTAVAIL) == 0);
+	}
+
+	/* update the pll changes */
+	si_pmu_spuravoid_pllupdate(sih, cc, osh, spuravoid);
+
+	/* enable HT back on  */
+	if (CHIPID(sih->chip) == BCM4336_CHIP_ID) {
+		tmp = R_REG(osh, &cc->max_res_mask);
+		tmp |= RES4336_HT_AVAIL;
+		W_REG(osh, &cc->max_res_mask, tmp);
+	}
+
+	/* Return to original core */
+	si_restore_core(sih, origidx, intr_val);
+}
+
+static void
+si_pmu_spuravoid_pllupdate(si_t * sih, chipcregs_t * cc, osl_t * osh,
+			   uint8 spuravoid)
+{
+	uint32 tmp = 0;
+	uint8 phypll_offset = 0;
+	uint8 bcm5357_bcm43236_p1div[] = { 0x1, 0x5, 0x5 };
+	uint8 bcm5357_bcm43236_ndiv[] = { 0x30, 0xf6, 0xfc };
+
+	switch (CHIPID(sih->chip)) {
+	case BCM5357_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:
+
+		/* BCM5357 needs to touch PLL1_PLLCTL[02], so offset PLL0_PLLCTL[02] by 6 */
+		phypll_offset = (CHIPID(sih->chip) == BCM5357_CHIP_ID) ? 6 : 0;
+
+		/* RMW only the P1 divider */
+		W_REG(osh, &cc->pllcontrol_addr,
+		      PMU1_PLL0_PLLCTL0 + phypll_offset);
+		tmp = R_REG(osh, &cc->pllcontrol_data);
+		tmp &= (~(PMU1_PLL0_PC0_P1DIV_MASK));
+		tmp |=
+		    (bcm5357_bcm43236_p1div[spuravoid] <<
+		     PMU1_PLL0_PC0_P1DIV_SHIFT);
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+
+		/* RMW only the int feedback divider */
+		W_REG(osh, &cc->pllcontrol_addr,
+		      PMU1_PLL0_PLLCTL2 + phypll_offset);
+		tmp = R_REG(osh, &cc->pllcontrol_data);
+		tmp &= ~(PMU1_PLL0_PC2_NDIV_INT_MASK);
+		tmp |=
+		    (bcm5357_bcm43236_ndiv[spuravoid]) <<
+		    PMU1_PLL0_PC2_NDIV_INT_SHIFT;
+		W_REG(osh, &cc->pllcontrol_data, tmp);
+
+		tmp = 1 << 10;
+		break;
+
+	case BCM4331_CHIP_ID:
+		if (spuravoid == 2) {
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+			W_REG(osh, &cc->pllcontrol_data, 0x11500014);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x0FC00a08);
+		} else if (spuravoid == 1) {
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+			W_REG(osh, &cc->pllcontrol_data, 0x11500014);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x0F600a08);
+		} else {
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+			W_REG(osh, &cc->pllcontrol_data, 0x11100014);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x03000a08);
+		}
+		tmp = 1 << 10;
+		break;
+
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM6362_CHIP_ID:
+		if (spuravoid == 1) {
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+			W_REG(osh, &cc->pllcontrol_data, 0x11500010);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+			W_REG(osh, &cc->pllcontrol_data, 0x000C0C06);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x0F600a08);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+			W_REG(osh, &cc->pllcontrol_data, 0x00000000);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+			W_REG(osh, &cc->pllcontrol_data, 0x2001E920);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+			W_REG(osh, &cc->pllcontrol_data, 0x88888815);
+		} else {
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+			W_REG(osh, &cc->pllcontrol_data, 0x11100010);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+			W_REG(osh, &cc->pllcontrol_data, 0x000c0c06);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x03000a08);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+			W_REG(osh, &cc->pllcontrol_data, 0x00000000);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+			W_REG(osh, &cc->pllcontrol_data, 0x200005c0);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+			W_REG(osh, &cc->pllcontrol_data, 0x88888815);
+		}
+		tmp = 1 << 10;
+		break;
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+		W_REG(osh, &cc->pllcontrol_data, 0x11100008);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+		W_REG(osh, &cc->pllcontrol_data, 0x0c000c06);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+		W_REG(osh, &cc->pllcontrol_data, 0x03000a08);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+		W_REG(osh, &cc->pllcontrol_data, 0x00000000);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+		W_REG(osh, &cc->pllcontrol_data, 0x200005c0);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+		W_REG(osh, &cc->pllcontrol_data, 0x88888855);
+
+		tmp = 1 << 10;
+		break;
+
+	case BCM4716_CHIP_ID:
+	case BCM4748_CHIP_ID:
+	case BCM47162_CHIP_ID:
+		if (spuravoid == 1) {
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+			W_REG(osh, &cc->pllcontrol_data, 0x11500060);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+			W_REG(osh, &cc->pllcontrol_data, 0x080C0C06);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x0F600000);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+			W_REG(osh, &cc->pllcontrol_data, 0x00000000);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+			W_REG(osh, &cc->pllcontrol_data, 0x2001E924);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+			W_REG(osh, &cc->pllcontrol_data, 0x88888815);
+		} else {
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+			W_REG(osh, &cc->pllcontrol_data, 0x11100060);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+			W_REG(osh, &cc->pllcontrol_data, 0x080c0c06);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x03000000);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+			W_REG(osh, &cc->pllcontrol_data, 0x00000000);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+			W_REG(osh, &cc->pllcontrol_data, 0x200005c0);
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+			W_REG(osh, &cc->pllcontrol_data, 0x88888815);
+		}
+
+		tmp = 3 << 9;
+		break;
+
+	case BCM4319_CHIP_ID:
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+		W_REG(osh, &cc->pllcontrol_data, 0x11100070);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+		W_REG(osh, &cc->pllcontrol_data, 0x1014140a);
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+		W_REG(osh, &cc->pllcontrol_data, 0x88888854);
+
+		if (spuravoid == 1) {	/* spur_avoid ON, enable 41/82/164Mhz clock mode */
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x05201828);
+		} else {	/* enable 40/80/160Mhz clock mode */
+			W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+			W_REG(osh, &cc->pllcontrol_data, 0x05001828);
+		}
+		break;
+	case BCM4336_CHIP_ID:
+		/* Looks like these are only for default xtal freq 26MHz */
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL0);
+		W_REG(osh, &cc->pllcontrol_data, 0x02100020);
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL1);
+		W_REG(osh, &cc->pllcontrol_data, 0x0C0C0C0C);
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL2);
+		W_REG(osh, &cc->pllcontrol_data, 0x01240C0C);
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL4);
+		W_REG(osh, &cc->pllcontrol_data, 0x202C2820);
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL5);
+		W_REG(osh, &cc->pllcontrol_data, 0x88888825);
+
+		W_REG(osh, &cc->pllcontrol_addr, PMU1_PLL0_PLLCTL3);
+		if (spuravoid == 1) {
+			W_REG(osh, &cc->pllcontrol_data, 0x00EC4EC4);
+		} else {
+			W_REG(osh, &cc->pllcontrol_data, 0x00762762);
+		}
+
+		tmp = PCTL_PLL_PLLCTL_UPD;
+		break;
+
+	default:
+		PMU_ERROR(("%s: unknown spuravoidance settings for chip %s, not changing PLL\n", __func__, bcm_chipname(sih->chip, chn, 8)));
+		break;
+	}
+
+	tmp |= R_REG(osh, &cc->pmucontrol);
+	W_REG(osh, &cc->pmucontrol, tmp);
+}
+
+bool si_pmu_is_otp_powered(si_t * sih, osl_t * osh)
+{
+	uint idx;
+	chipcregs_t *cc;
+	bool st;
+
+	/* Remember original core before switch to chipc */
+	idx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		st = (R_REG(osh, &cc->res_state) & PMURES_BIT(RES4329_OTP_PU))
+		    != 0;
+		break;
+	case BCM4319_CHIP_ID:
+		st = (R_REG(osh, &cc->res_state) & PMURES_BIT(RES4319_OTP_PU))
+		    != 0;
+		break;
+	case BCM4336_CHIP_ID:
+		st = (R_REG(osh, &cc->res_state) & PMURES_BIT(RES4336_OTP_PU))
+		    != 0;
+		break;
+	case BCM4330_CHIP_ID:
+		st = (R_REG(osh, &cc->res_state) & PMURES_BIT(RES4330_OTP_PU))
+		    != 0;
+		break;
+
+		/* These chip doesn't use PMU bit to power up/down OTP. OTP always on.
+		 * Use OTP_INIT command to reset/refresh state.
+		 */
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43238_CHIP_ID:
+		st = TRUE;
+		break;
+	default:
+		st = TRUE;
+		break;
+	}
+
+	/* Return to original core */
+	si_setcoreidx(sih, idx);
+	return st;
+}
+
+void
+#if defined(BCMDBG)
+si_pmu_sprom_enable(si_t * sih, osl_t * osh, bool enable)
+#else
+BCMATTACHFN(si_pmu_sprom_enable) (si_t * sih, osl_t * osh, bool enable)
+#endif
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+/* initialize PMU chip controls and other chip level stuff */
+void BCMATTACHFN(si_pmu_chip_init) (si_t * sih, osl_t * osh) {
+	uint origidx;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+#ifdef CHIPC_UART_ALWAYS_ON
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, clk_ctl_st),
+		   CCS_FORCEALP, CCS_FORCEALP);
+#endif				/* CHIPC_UART_ALWAYS_ON */
+
+	/* Gate off SPROM clock and chip select signals */
+	si_pmu_sprom_enable(sih, osh, FALSE);
+
+	/* Remember original core */
+	origidx = si_coreidx(sih);
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+}
+
+/* initialize PMU switch/regulators */
+void BCMATTACHFN(si_pmu_swreg_init) (si_t * sih, osl_t * osh) {
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4336_CHIP_ID:
+		/* Reduce CLDO PWM output voltage to 1.2V */
+		si_pmu_set_ldo_voltage(sih, osh, SET_LDO_VOLTAGE_CLDO_PWM, 0xe);
+		/* Reduce CLDO BURST output voltage to 1.2V */
+		si_pmu_set_ldo_voltage(sih, osh, SET_LDO_VOLTAGE_CLDO_BURST,
+				       0xe);
+		/* Reduce LNLDO1 output voltage to 1.2V */
+		si_pmu_set_ldo_voltage(sih, osh, SET_LDO_VOLTAGE_LNLDO1, 0xe);
+		if (CHIPREV(sih->chiprev) == 0)
+			si_pmu_regcontrol(sih, 2, 0x400000, 0x400000);
+		break;
+
+	case BCM4330_CHIP_ID:
+		/* CBUCK Voltage is 1.8 by default and set that to 1.5 */
+		si_pmu_set_ldo_voltage(sih, osh, SET_LDO_VOLTAGE_CBUCK_PWM, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+void si_pmu_radio_enable(si_t * sih, bool enable)
+{
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4319_CHIP_ID:
+		if (enable)
+			si_write_wrapperreg(sih, AI_OOBSELOUTB74,
+					    (uint32) 0x868584);
+		else
+			si_write_wrapperreg(sih, AI_OOBSELOUTB74,
+					    (uint32) 0x060584);
+		break;
+	}
+}
+
+/* Wait for a particular clock level to be on the backplane */
+uint32
+si_pmu_waitforclk_on_backplane(si_t * sih, osl_t * osh, uint32 clk,
+			       uint32 delay)
+{
+	chipcregs_t *cc;
+	uint origidx;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	if (delay)
+		SPINWAIT(((R_REG(osh, &cc->pmustatus) & clk) != clk), delay);
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+
+	return (R_REG(osh, &cc->pmustatus) & clk);
+}
+
+/*
+ * Measures the ALP clock frequency in KHz.  Returns 0 if not possible.
+ * Possible only if PMU rev >= 10 and there is an external LPO 32768Hz crystal.
+ */
+
+#define EXT_ILP_HZ 32768
+
+uint32 BCMATTACHFN(si_pmu_measure_alpclk) (si_t * sih, osl_t * osh) {
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 alp_khz;
+
+	if (sih->pmurev < 10)
+		return 0;
+
+	ASSERT(sih->cccaps & CC_CAP_PMU);
+
+	/* Remember original core before switch to chipc */
+	origidx = si_coreidx(sih);
+	cc = si_setcoreidx(sih, SI_CC_IDX);
+	ASSERT(cc != NULL);
+
+	if (R_REG(osh, &cc->pmustatus) & PST_EXTLPOAVAIL) {
+		uint32 ilp_ctr, alp_hz;
+
+		/* Enable the reg to measure the freq, in case disabled before */
+		W_REG(osh, &cc->pmu_xtalfreq,
+		      1U << PMU_XTALFREQ_REG_MEASURE_SHIFT);
+
+		/* Delay for well over 4 ILP clocks */
+		OSL_DELAY(1000);
+
+		/* Read the latched number of ALP ticks per 4 ILP ticks */
+		ilp_ctr =
+		    R_REG(osh,
+			  &cc->pmu_xtalfreq) & PMU_XTALFREQ_REG_ILPCTR_MASK;
+
+		/* Turn off the PMU_XTALFREQ_REG_MEASURE_SHIFT bit to save power */
+		W_REG(osh, &cc->pmu_xtalfreq, 0);
+
+		/* Calculate ALP frequency */
+		alp_hz = (ilp_ctr * EXT_ILP_HZ) / 4;
+
+		/* Round to nearest 100KHz, and at the same time convert to KHz */
+		alp_khz = (alp_hz + 50000) / 100000 * 100;
+	} else
+		alp_khz = 0;
+
+	/* Return to original core */
+	si_setcoreidx(sih, origidx);
+
+	return alp_khz;
+}
+
+static void BCMATTACHFN(si_pmu_set_4330_plldivs) (si_t * sih) {
+	uint32 FVCO = si_pmu1_pllfvco0(sih) / 1000;
+	uint32 m1div, m2div, m3div, m4div, m5div, m6div;
+	uint32 pllc1, pllc2;
+
+	m2div = m3div = m4div = m6div = FVCO / 80;
+	m5div = FVCO / 160;
+
+	if (CST4330_CHIPMODE_SDIOD(sih->chipst))
+		m1div = FVCO / 80;
+	else
+		m1div = FVCO / 90;
+	pllc1 =
+	    (m1div << PMU1_PLL0_PC1_M1DIV_SHIFT) | (m2div <<
+						    PMU1_PLL0_PC1_M2DIV_SHIFT) |
+	    (m3div << PMU1_PLL0_PC1_M3DIV_SHIFT) | (m4div <<
+						    PMU1_PLL0_PC1_M4DIV_SHIFT);
+	si_pmu_pllcontrol(sih, PMU1_PLL0_PLLCTL1, ~0, pllc1);
+
+	pllc2 = si_pmu_pllcontrol(sih, PMU1_PLL0_PLLCTL1, 0, 0);
+	pllc2 &= ~(PMU1_PLL0_PC2_M5DIV_MASK | PMU1_PLL0_PC2_M6DIV_MASK);
+	pllc2 |=
+	    ((m5div << PMU1_PLL0_PC2_M5DIV_SHIFT) |
+	     (m6div << PMU1_PLL0_PC2_M6DIV_SHIFT));
+	si_pmu_pllcontrol(sih, PMU1_PLL0_PLLCTL2, ~0, pllc2);
+}
diff --git a/drivers/staging/brcm80211/util/linux_osl.c b/drivers/staging/brcm80211/util/linux_osl.c
new file mode 100644
index 0000000..a1898bb
--- /dev/null
+++ b/drivers/staging/brcm80211/util/linux_osl.c
@@ -0,0 +1,516 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmendian.h>
+#include <linuxver.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <linux/delay.h>
+#ifdef mips
+#include <asm/paccess.h>
+#endif				/* mips */
+#include <pcicfg.h>
+
+#include <linux/fs.h>
+
+#define PCI_CFG_RETRY 		10
+
+#define OS_HANDLE_MAGIC		0x1234abcd	/* Magic # to recognise osh */
+#define BCM_MEM_FILENAME_LEN 	24	/* Mem. filename length */
+
+typedef struct bcm_mem_link {
+	struct bcm_mem_link *prev;
+	struct bcm_mem_link *next;
+	uint size;
+	int line;
+	char file[BCM_MEM_FILENAME_LEN];
+} bcm_mem_link_t;
+
+struct osl_info {
+	osl_pubinfo_t pub;
+	uint magic;
+	void *pdev;
+	uint malloced;
+	uint failed;
+	uint bustype;
+	bcm_mem_link_t *dbgmem_list;
+};
+
+/* Global ASSERT type flag */
+uint32 g_assert_type = 0;
+
+static int16 linuxbcmerrormap[] = { 0,	/* 0 */
+	-EINVAL,		/* BCME_ERROR */
+	-EINVAL,		/* BCME_BADARG */
+	-EINVAL,		/* BCME_BADOPTION */
+	-EINVAL,		/* BCME_NOTUP */
+	-EINVAL,		/* BCME_NOTDOWN */
+	-EINVAL,		/* BCME_NOTAP */
+	-EINVAL,		/* BCME_NOTSTA */
+	-EINVAL,		/* BCME_BADKEYIDX */
+	-EINVAL,		/* BCME_RADIOOFF */
+	-EINVAL,		/* BCME_NOTBANDLOCKED */
+	-EINVAL,		/* BCME_NOCLK */
+	-EINVAL,		/* BCME_BADRATESET */
+	-EINVAL,		/* BCME_BADBAND */
+	-E2BIG,			/* BCME_BUFTOOSHORT */
+	-E2BIG,			/* BCME_BUFTOOLONG */
+	-EBUSY,			/* BCME_BUSY */
+	-EINVAL,		/* BCME_NOTASSOCIATED */
+	-EINVAL,		/* BCME_BADSSIDLEN */
+	-EINVAL,		/* BCME_OUTOFRANGECHAN */
+	-EINVAL,		/* BCME_BADCHAN */
+	-EFAULT,		/* BCME_BADADDR */
+	-ENOMEM,		/* BCME_NORESOURCE */
+	-EOPNOTSUPP,		/* BCME_UNSUPPORTED */
+	-EMSGSIZE,		/* BCME_BADLENGTH */
+	-EINVAL,		/* BCME_NOTREADY */
+	-EPERM,			/* BCME_NOTPERMITTED */
+	-ENOMEM,		/* BCME_NOMEM */
+	-EINVAL,		/* BCME_ASSOCIATED */
+	-ERANGE,		/* BCME_RANGE */
+	-EINVAL,		/* BCME_NOTFOUND */
+	-EINVAL,		/* BCME_WME_NOT_ENABLED */
+	-EINVAL,		/* BCME_TSPEC_NOTFOUND */
+	-EINVAL,		/* BCME_ACM_NOTSUPPORTED */
+	-EINVAL,		/* BCME_NOT_WME_ASSOCIATION */
+	-EIO,			/* BCME_SDIO_ERROR */
+	-ENODEV,		/* BCME_DONGLE_DOWN */
+	-EINVAL,		/* BCME_VERSION */
+	-EIO,			/* BCME_TXFAIL */
+	-EIO,			/* BCME_RXFAIL */
+	-EINVAL,		/* BCME_NODEVICE */
+	-EINVAL,		/* BCME_NMODE_DISABLED */
+	-ENODATA,		/* BCME_NONRESIDENT */
+
+/* When an new error code is added to bcmutils.h, add os
+ * spcecific error translation here as well
+ */
+/* check if BCME_LAST changed since the last time this function was updated */
+#if BCME_LAST != -42
+#error "You need to add a OS error translation in the linuxbcmerrormap \
+	for new error code defined in bcmutils.h"
+#endif
+};
+
+/* translate bcmerrors into linux errors */
+int osl_error(int bcmerror)
+{
+	if (bcmerror > 0)
+		bcmerror = 0;
+	else if (bcmerror < BCME_LAST)
+		bcmerror = BCME_ERROR;
+
+	/* Array bounds covered by ASSERT in osl_attach */
+	return linuxbcmerrormap[-bcmerror];
+}
+
+osl_t *osl_attach(void *pdev, uint bustype, bool pkttag)
+{
+	osl_t *osh;
+
+	osh = kmalloc(sizeof(osl_t), GFP_ATOMIC);
+	ASSERT(osh);
+
+	bzero(osh, sizeof(osl_t));
+
+	/* Check that error map has the right number of entries in it */
+	ASSERT(ABS(BCME_LAST) == (ARRAYSIZE(linuxbcmerrormap) - 1));
+
+	osh->magic = OS_HANDLE_MAGIC;
+	osh->malloced = 0;
+	osh->failed = 0;
+	osh->dbgmem_list = NULL;
+	osh->pdev = pdev;
+	osh->pub.pkttag = pkttag;
+	osh->bustype = bustype;
+
+	switch (bustype) {
+	case PCI_BUS:
+	case SI_BUS:
+		osh->pub.mmbus = TRUE;
+		break;
+	case JTAG_BUS:
+	case SDIO_BUS:
+	case USB_BUS:
+	case SPI_BUS:
+	case RPC_BUS:
+		osh->pub.mmbus = FALSE;
+		break;
+	default:
+		ASSERT(FALSE);
+		break;
+	}
+
+#ifdef BCMDBG
+	if (pkttag) {
+		struct sk_buff *skb;
+		ASSERT(OSL_PKTTAG_SZ <= sizeof(skb->cb));
+	}
+#endif
+	return osh;
+}
+
+void osl_detach(osl_t * osh)
+{
+	if (osh == NULL)
+		return;
+
+	ASSERT(osh->magic == OS_HANDLE_MAGIC);
+	kfree(osh);
+}
+
+/* Return a new packet. zero out pkttag */
+void *BCMFASTPATH osl_pktget(osl_t * osh, uint len)
+{
+	struct sk_buff *skb;
+
+	if ((skb = dev_alloc_skb(len))) {
+		skb_put(skb, len);
+		skb->priority = 0;
+
+		osh->pub.pktalloced++;
+	}
+
+	return ((void *)skb);
+}
+
+/* Free the driver packet. Free the tag if present */
+void BCMFASTPATH osl_pktfree(osl_t * osh, void *p, bool send)
+{
+	struct sk_buff *skb, *nskb;
+	int nest = 0;
+
+	skb = (struct sk_buff *)p;
+	ASSERT(skb);
+
+	if (send && osh->pub.tx_fn)
+		osh->pub.tx_fn(osh->pub.tx_ctx, p, 0);
+
+	/* perversion: we use skb->next to chain multi-skb packets */
+	while (skb) {
+		nskb = skb->next;
+		skb->next = NULL;
+
+		if (skb->destructor)
+			/* cannot kfree_skb() on hard IRQ (net/core/skbuff.c) if
+			 * destructor exists
+			 */
+			dev_kfree_skb_any(skb);
+		else
+			/* can free immediately (even in_irq()) if destructor
+			 * does not exist
+			 */
+			dev_kfree_skb(skb);
+
+		osh->pub.pktalloced--;
+		nest++;
+		skb = nskb;
+	}
+}
+
+uint32 osl_pci_read_config(osl_t * osh, uint offset, uint size)
+{
+	uint val = 0;
+	uint retry = PCI_CFG_RETRY;
+
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+
+	/* only 4byte access supported */
+	ASSERT(size == 4);
+
+	do {
+		pci_read_config_dword(osh->pdev, offset, &val);
+		if (val != 0xffffffff)
+			break;
+	} while (retry--);
+
+#ifdef BCMDBG
+	if (retry < PCI_CFG_RETRY)
+		printk("PCI CONFIG READ access to %d required %d retries\n",
+		       offset, (PCI_CFG_RETRY - retry));
+#endif				/* BCMDBG */
+
+	return (val);
+}
+
+void osl_pci_write_config(osl_t * osh, uint offset, uint size, uint val)
+{
+	uint retry = PCI_CFG_RETRY;
+
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+
+	/* only 4byte access supported */
+	ASSERT(size == 4);
+
+	do {
+		pci_write_config_dword(osh->pdev, offset, val);
+		if (offset != PCI_BAR0_WIN)
+			break;
+		if (osl_pci_read_config(osh, offset, size) == val)
+			break;
+	} while (retry--);
+
+#ifdef BCMDBG
+	if (retry < PCI_CFG_RETRY)
+		printk("PCI CONFIG WRITE access to %d required %d retries\n",
+		       offset, (PCI_CFG_RETRY - retry));
+#endif				/* BCMDBG */
+}
+
+/* return bus # for the pci device pointed by osh->pdev */
+uint osl_pci_bus(osl_t * osh)
+{
+	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
+
+	return ((struct pci_dev *)osh->pdev)->bus->number;
+}
+
+/* return slot # for the pci device pointed by osh->pdev */
+uint osl_pci_slot(osl_t * osh)
+{
+	ASSERT(osh && (osh->magic == OS_HANDLE_MAGIC) && osh->pdev);
+
+	return PCI_SLOT(((struct pci_dev *)osh->pdev)->devfn);
+}
+
+static void
+osl_pcmcia_attr(osl_t * osh, uint offset, char *buf, int size, bool write)
+{
+}
+
+void osl_pcmcia_read_attr(osl_t * osh, uint offset, void *buf, int size)
+{
+	osl_pcmcia_attr(osh, offset, (char *)buf, size, FALSE);
+}
+
+void osl_pcmcia_write_attr(osl_t * osh, uint offset, void *buf, int size)
+{
+	osl_pcmcia_attr(osh, offset, (char *)buf, size, TRUE);
+}
+
+void *osl_malloc(osl_t * osh, uint size)
+{
+	void *addr;
+
+	/* only ASSERT if osh is defined */
+	if (osh)
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+
+	if ((addr = kmalloc(size, GFP_ATOMIC)) == NULL) {
+		if (osh)
+			osh->failed++;
+		return (NULL);
+	}
+	if (osh)
+		osh->malloced += size;
+
+	return (addr);
+}
+
+void osl_mfree(osl_t * osh, void *addr, uint size)
+{
+	if (osh) {
+		ASSERT(osh->magic == OS_HANDLE_MAGIC);
+		osh->malloced -= size;
+	}
+	kfree(addr);
+}
+
+uint osl_malloced(osl_t * osh)
+{
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	return (osh->malloced);
+}
+
+uint osl_malloc_failed(osl_t * osh)
+{
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	return (osh->failed);
+}
+
+uint osl_dma_consistent_align(void)
+{
+	return (PAGE_SIZE);
+}
+
+void *osl_dma_alloc_consistent(osl_t * osh, uint size, uint16 align_bits,
+			       uint * alloced, ulong * pap)
+{
+	uint16 align = (1 << align_bits);
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+
+	if (!ISALIGNED(DMA_CONSISTENT_ALIGN, align))
+		size += align;
+	*alloced = size;
+
+	return (pci_alloc_consistent(osh->pdev, size, (dma_addr_t *) pap));
+}
+
+void osl_dma_free_consistent(osl_t * osh, void *va, uint size, ulong pa)
+{
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+
+	pci_free_consistent(osh->pdev, size, va, (dma_addr_t) pa);
+}
+
+uint BCMFASTPATH osl_dma_map(osl_t * osh, void *va, uint size, int direction)
+{
+	int dir;
+
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	dir = (direction == DMA_TX) ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE;
+	return (pci_map_single(osh->pdev, va, size, dir));
+}
+
+void BCMFASTPATH osl_dma_unmap(osl_t * osh, uint pa, uint size, int direction)
+{
+	int dir;
+
+	ASSERT((osh && (osh->magic == OS_HANDLE_MAGIC)));
+	dir = (direction == DMA_TX) ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE;
+	pci_unmap_single(osh->pdev, (uint32) pa, size, dir);
+}
+
+#if defined(BCMDBG_ASSERT)
+void osl_assert(char *exp, char *file, int line)
+{
+	char tempbuf[256];
+	char *basename;
+
+	basename = strrchr(file, '/');
+	/* skip the '/' */
+	if (basename)
+		basename++;
+
+	if (!basename)
+		basename = file;
+
+#ifdef BCMDBG_ASSERT
+	snprintf(tempbuf, 256,
+		 "assertion \"%s\" failed: file \"%s\", line %d\n", exp,
+		 basename, line);
+
+	/* Print assert message and give it time to be written to /var/log/messages */
+	if (!in_interrupt()) {
+		const int delay = 3;
+		printk("%s", tempbuf);
+		printk("panic in %d seconds\n", delay);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(delay * HZ);
+	}
+
+	switch (g_assert_type) {
+	case 0:
+		panic("%s", tempbuf);
+		break;
+	case 1:
+		printk("%s", tempbuf);
+		BUG();
+		break;
+	case 2:
+		printk("%s", tempbuf);
+		break;
+	default:
+		break;
+	}
+#endif				/* BCMDBG_ASSERT */
+
+}
+#endif				/* defined(BCMDBG_ASSERT) */
+
+void osl_delay(uint usec)
+{
+	uint d;
+
+	while (usec > 0) {
+		d = MIN(usec, 1000);
+		udelay(d);
+		usec -= d;
+	}
+}
+
+/* Clone a packet.
+ * The pkttag contents are NOT cloned.
+ */
+void *osl_pktdup(osl_t * osh, void *skb)
+{
+	void *p;
+
+	if ((p = skb_clone((struct sk_buff *)skb, GFP_ATOMIC)) == NULL)
+		return NULL;
+
+	/* skb_clone copies skb->cb.. we don't want that */
+	if (osh->pub.pkttag)
+		bzero((void *)((struct sk_buff *)p)->cb, OSL_PKTTAG_SZ);
+
+	/* Increment the packet counter */
+	osh->pub.pktalloced++;
+	return (p);
+}
+
+#ifdef BCMSDIO
+uint8 osl_readb(osl_t * osh, volatile uint8 * r)
+{
+	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
+	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
+
+	return (uint8) ((rreg) (ctx, (void *)r, sizeof(uint8)));
+}
+
+uint16 osl_readw(osl_t * osh, volatile uint16 * r)
+{
+	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
+	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
+
+	return (uint16) ((rreg) (ctx, (void *)r, sizeof(uint16)));
+}
+
+uint32 osl_readl(osl_t * osh, volatile uint32 * r)
+{
+	osl_rreg_fn_t rreg = ((osl_pubinfo_t *) osh)->rreg_fn;
+	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
+
+	return (uint32) ((rreg) (ctx, (void *)r, sizeof(uint32)));
+}
+
+void osl_writeb(osl_t * osh, volatile uint8 * r, uint8 v)
+{
+	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
+	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
+
+	((wreg) (ctx, (void *)r, v, sizeof(uint8)));
+}
+
+void osl_writew(osl_t * osh, volatile uint16 * r, uint16 v)
+{
+	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
+	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
+
+	((wreg) (ctx, (void *)r, v, sizeof(uint16)));
+}
+
+void osl_writel(osl_t * osh, volatile uint32 * r, uint32 v)
+{
+	osl_wreg_fn_t wreg = ((osl_pubinfo_t *) osh)->wreg_fn;
+	void *ctx = ((osl_pubinfo_t *) osh)->reg_ctx;
+
+	((wreg) (ctx, (void *)r, v, sizeof(uint32)));
+}
+#endif				/* BCMSDIO */
+/* Linux Kernel: File Operations: end */
diff --git a/drivers/staging/brcm80211/util/nicpci.c b/drivers/staging/brcm80211/util/nicpci.c
new file mode 100644
index 0000000..feaa54f
--- /dev/null
+++ b/drivers/staging/brcm80211/util/nicpci.c
@@ -0,0 +1,880 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <hndsoc.h>
+#include <bcmdevs.h>
+#include <sbchipc.h>
+#include <pci_core.h>
+#include <pcie_core.h>
+#include <nicpci.h>
+#include <pcicfg.h>
+
+typedef struct {
+	union {
+		sbpcieregs_t *pcieregs;
+		sbpciregs_t *pciregs;
+	} regs;			/* Memory mapped register to the core */
+
+	si_t *sih;		/* System interconnect handle */
+	osl_t *osh;		/* OSL handle */
+	uint8 pciecap_lcreg_offset;	/* PCIE capability LCreg offset in the config space */
+	bool pcie_pr42767;
+	uint8 pcie_polarity;
+	uint8 pcie_war_aspm_ovr;	/* Override ASPM/Clkreq settings */
+
+	uint8 pmecap_offset;	/* PM Capability offset in the config space */
+	bool pmecap;		/* Capable of generating PME */
+} pcicore_info_t;
+
+/* debug/trace */
+#define	PCI_ERROR(args)
+#define PCIE_PUB(sih) ((BUSTYPE((sih)->bustype) == PCI_BUS) && ((sih)->buscoretype == PCIE_CORE_ID))
+
+/* routines to access mdio slave device registers */
+static bool pcie_mdiosetblock(pcicore_info_t * pi, uint blk);
+static int pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr,
+		       bool write, uint * val);
+static int pcie_mdiowrite(pcicore_info_t * pi, uint physmedia, uint readdr,
+			  uint val);
+static int pcie_mdioread(pcicore_info_t * pi, uint physmedia, uint readdr,
+			 uint * ret_val);
+
+static void pcie_extendL1timer(pcicore_info_t * pi, bool extend);
+static void pcie_clkreq_upd(pcicore_info_t * pi, uint state);
+
+static void pcie_war_aspm_clkreq(pcicore_info_t * pi);
+static void pcie_war_serdes(pcicore_info_t * pi);
+static void pcie_war_noplldown(pcicore_info_t * pi);
+static void pcie_war_polarity(pcicore_info_t * pi);
+static void pcie_war_pci_setup(pcicore_info_t * pi);
+
+static bool pcicore_pmecap(pcicore_info_t * pi);
+
+#define PCIE_ASPM(sih)	((PCIE_PUB(sih)) && (((sih)->buscorerev >= 3) && ((sih)->buscorerev <= 5)))
+
+#define DWORD_ALIGN(x)  (x & ~(0x03))
+#define BYTE_POS(x) (x & 0x3)
+#define WORD_POS(x) (x & 0x1)
+
+#define BYTE_SHIFT(x)  (8 * BYTE_POS(x))
+#define WORD_SHIFT(x)  (16 * WORD_POS(x))
+
+#define BYTE_VAL(a, x) ((a >> BYTE_SHIFT(x)) & 0xFF)
+#define WORD_VAL(a, x) ((a >> WORD_SHIFT(x)) & 0xFFFF)
+
+#define read_pci_cfg_byte(a) \
+	(BYTE_VAL(OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4), a) & 0xff)
+
+#define read_pci_cfg_word(a) \
+	(WORD_VAL(OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4), a) & 0xffff)
+
+#define write_pci_cfg_byte(a, val) do { \
+	uint32 tmpval; \
+	tmpval = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFF << BYTE_POS(a)) | \
+		val << BYTE_POS(a); \
+	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
+	} while (0)
+
+#define write_pci_cfg_word(a, val) do { \
+	uint32 tmpval; \
+	tmpval = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFFFF << WORD_POS(a)) | \
+		val << WORD_POS(a); \
+	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
+	} while (0)
+
+/* delay needed between the mdio control/ mdiodata register data access */
+#define PR28829_DELAY() OSL_DELAY(10)
+
+/* Initialize the PCI core. It's caller's responsibility to make sure that this is done
+ * only once
+ */
+void *pcicore_init(si_t * sih, osl_t * osh, void *regs)
+{
+	pcicore_info_t *pi;
+
+	ASSERT(sih->bustype == PCI_BUS);
+
+	/* alloc pcicore_info_t */
+	if ((pi = MALLOC(osh, sizeof(pcicore_info_t))) == NULL) {
+		PCI_ERROR(("pci_attach: malloc failed! malloced %d bytes\n",
+			   MALLOCED(osh)));
+		return (NULL);
+	}
+
+	bzero(pi, sizeof(pcicore_info_t));
+
+	pi->sih = sih;
+	pi->osh = osh;
+
+	if (sih->buscoretype == PCIE_CORE_ID) {
+		uint8 cap_ptr;
+		pi->regs.pcieregs = (sbpcieregs_t *) regs;
+		cap_ptr =
+		    pcicore_find_pci_capability(pi->osh, PCI_CAP_PCIECAP_ID,
+						NULL, NULL);
+		ASSERT(cap_ptr);
+		pi->pciecap_lcreg_offset = cap_ptr + PCIE_CAP_LINKCTRL_OFFSET;
+	} else
+		pi->regs.pciregs = (sbpciregs_t *) regs;
+
+	return pi;
+}
+
+void pcicore_deinit(void *pch)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+	if (pi == NULL)
+		return;
+	MFREE(pi->osh, pi, sizeof(pcicore_info_t));
+}
+
+/* return cap_offset if requested capability exists in the PCI config space */
+/* Note that it's caller's responsibility to make sure it's a pci bus */
+uint8
+pcicore_find_pci_capability(osl_t * osh, uint8 req_cap_id, uchar * buf,
+			    uint32 * buflen)
+{
+	uint8 cap_id;
+	uint8 cap_ptr = 0;
+	uint32 bufsize;
+	uint8 byte_val;
+
+	/* check for Header type 0 */
+	byte_val = read_pci_cfg_byte(PCI_CFG_HDR);
+	if ((byte_val & 0x7f) != PCI_HEADER_NORMAL)
+		goto end;
+
+	/* check if the capability pointer field exists */
+	byte_val = read_pci_cfg_byte(PCI_CFG_STAT);
+	if (!(byte_val & PCI_CAPPTR_PRESENT))
+		goto end;
+
+	cap_ptr = read_pci_cfg_byte(PCI_CFG_CAPPTR);
+	/* check if the capability pointer is 0x00 */
+	if (cap_ptr == 0x00)
+		goto end;
+
+	/* loop thr'u the capability list and see if the pcie capabilty exists */
+
+	cap_id = read_pci_cfg_byte(cap_ptr);
+
+	while (cap_id != req_cap_id) {
+		cap_ptr = read_pci_cfg_byte((cap_ptr + 1));
+		if (cap_ptr == 0x00)
+			break;
+		cap_id = read_pci_cfg_byte(cap_ptr);
+	}
+	if (cap_id != req_cap_id) {
+		goto end;
+	}
+	/* found the caller requested capability */
+	if ((buf != NULL) && (buflen != NULL)) {
+		uint8 cap_data;
+
+		bufsize = *buflen;
+		if (!bufsize)
+			goto end;
+		*buflen = 0;
+		/* copy the cpability data excluding cap ID and next ptr */
+		cap_data = cap_ptr + 2;
+		if ((bufsize + cap_data) > SZPCR)
+			bufsize = SZPCR - cap_data;
+		*buflen = bufsize;
+		while (bufsize--) {
+			*buf = read_pci_cfg_byte(cap_data);
+			cap_data++;
+			buf++;
+		}
+	}
+ end:
+	return cap_ptr;
+}
+
+/* ***** Register Access API */
+uint
+pcie_readreg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset)
+{
+	uint retval = 0xFFFFFFFF;
+
+	ASSERT(pcieregs != NULL);
+
+	switch (addrtype) {
+	case PCIE_CONFIGREGS:
+		W_REG(osh, (&pcieregs->configaddr), offset);
+		(void)R_REG(osh, (&pcieregs->configaddr));
+		retval = R_REG(osh, &(pcieregs->configdata));
+		break;
+	case PCIE_PCIEREGS:
+		W_REG(osh, &(pcieregs->pcieindaddr), offset);
+		(void)R_REG(osh, (&pcieregs->pcieindaddr));
+		retval = R_REG(osh, &(pcieregs->pcieinddata));
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+
+	return retval;
+}
+
+uint
+pcie_writereg(osl_t * osh, sbpcieregs_t * pcieregs, uint addrtype, uint offset,
+	      uint val)
+{
+	ASSERT(pcieregs != NULL);
+
+	switch (addrtype) {
+	case PCIE_CONFIGREGS:
+		W_REG(osh, (&pcieregs->configaddr), offset);
+		W_REG(osh, (&pcieregs->configdata), val);
+		break;
+	case PCIE_PCIEREGS:
+		W_REG(osh, (&pcieregs->pcieindaddr), offset);
+		W_REG(osh, (&pcieregs->pcieinddata), val);
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+	return 0;
+}
+
+static bool pcie_mdiosetblock(pcicore_info_t * pi, uint blk)
+{
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+	uint mdiodata, i = 0;
+	uint pcie_serdes_spinwait = 200;
+
+	mdiodata =
+	    MDIODATA_START | MDIODATA_WRITE | (MDIODATA_DEV_ADDR <<
+					       MDIODATA_DEVADDR_SHF) |
+	    (MDIODATA_BLK_ADDR << MDIODATA_REGADDR_SHF) | MDIODATA_TA | (blk <<
+									 4);
+	W_REG(pi->osh, &pcieregs->mdiodata, mdiodata);
+
+	PR28829_DELAY();
+	/* retry till the transaction is complete */
+	while (i < pcie_serdes_spinwait) {
+		if (R_REG(pi->osh, &(pcieregs->mdiocontrol)) &
+		    MDIOCTL_ACCESS_DONE) {
+			break;
+		}
+		OSL_DELAY(1000);
+		i++;
+	}
+
+	if (i >= pcie_serdes_spinwait) {
+		PCI_ERROR(("pcie_mdiosetblock: timed out\n"));
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static int
+pcie_mdioop(pcicore_info_t * pi, uint physmedia, uint regaddr, bool write,
+	    uint * val)
+{
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+	uint mdiodata;
+	uint i = 0;
+	uint pcie_serdes_spinwait = 10;
+
+	/* enable mdio access to SERDES */
+	W_REG(pi->osh, (&pcieregs->mdiocontrol),
+	      MDIOCTL_PREAM_EN | MDIOCTL_DIVISOR_VAL);
+
+	if (pi->sih->buscorerev >= 10) {
+		/* new serdes is slower in rw, using two layers of reg address mapping */
+		if (!pcie_mdiosetblock(pi, physmedia))
+			return 1;
+		mdiodata = (MDIODATA_DEV_ADDR << MDIODATA_DEVADDR_SHF) |
+		    (regaddr << MDIODATA_REGADDR_SHF);
+		pcie_serdes_spinwait *= 20;
+	} else {
+		mdiodata = (physmedia << MDIODATA_DEVADDR_SHF_OLD) |
+		    (regaddr << MDIODATA_REGADDR_SHF_OLD);
+	}
+
+	if (!write)
+		mdiodata |= (MDIODATA_START | MDIODATA_READ | MDIODATA_TA);
+	else
+		mdiodata |=
+		    (MDIODATA_START | MDIODATA_WRITE | MDIODATA_TA | *val);
+
+	W_REG(pi->osh, &pcieregs->mdiodata, mdiodata);
+
+	PR28829_DELAY();
+
+	/* retry till the transaction is complete */
+	while (i < pcie_serdes_spinwait) {
+		if (R_REG(pi->osh, &(pcieregs->mdiocontrol)) &
+		    MDIOCTL_ACCESS_DONE) {
+			if (!write) {
+				PR28829_DELAY();
+				*val =
+				    (R_REG(pi->osh, &(pcieregs->mdiodata)) &
+				     MDIODATA_MASK);
+			}
+			/* Disable mdio access to SERDES */
+			W_REG(pi->osh, (&pcieregs->mdiocontrol), 0);
+			return 0;
+		}
+		OSL_DELAY(1000);
+		i++;
+	}
+
+	PCI_ERROR(("pcie_mdioop: timed out op: %d\n", write));
+	/* Disable mdio access to SERDES */
+	W_REG(pi->osh, (&pcieregs->mdiocontrol), 0);
+	return 1;
+}
+
+/* use the mdio interface to read from mdio slaves */
+static int
+pcie_mdioread(pcicore_info_t * pi, uint physmedia, uint regaddr, uint * regval)
+{
+	return pcie_mdioop(pi, physmedia, regaddr, FALSE, regval);
+}
+
+/* use the mdio interface to write to mdio slaves */
+static int
+pcie_mdiowrite(pcicore_info_t * pi, uint physmedia, uint regaddr, uint val)
+{
+	return pcie_mdioop(pi, physmedia, regaddr, TRUE, &val);
+}
+
+/* ***** Support functions ***** */
+uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	uint32 reg_val;
+	uint8 offset;
+
+	offset = pi->pciecap_lcreg_offset;
+	if (!offset)
+		return 0;
+
+	reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+	/* set operation */
+	if (mask) {
+		if (val)
+			reg_val |= PCIE_CLKREQ_ENAB;
+		else
+			reg_val &= ~PCIE_CLKREQ_ENAB;
+		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), reg_val);
+		reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+	}
+	if (reg_val & PCIE_CLKREQ_ENAB)
+		return 1;
+	else
+		return 0;
+}
+
+static void pcie_extendL1timer(pcicore_info_t * pi, bool extend)
+{
+	uint32 w;
+	si_t *sih = pi->sih;
+	osl_t *osh = pi->osh;
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+
+	if (!PCIE_PUB(sih) || sih->buscorerev < 7)
+		return;
+
+	w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_PMTHRESHREG);
+	if (extend)
+		w |= PCIE_ASPMTIMER_EXTEND;
+	else
+		w &= ~PCIE_ASPMTIMER_EXTEND;
+	pcie_writereg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_PMTHRESHREG, w);
+	w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_PMTHRESHREG);
+}
+
+/* centralized clkreq control policy */
+static void pcie_clkreq_upd(pcicore_info_t * pi, uint state)
+{
+	si_t *sih = pi->sih;
+	ASSERT(PCIE_PUB(sih));
+
+	switch (state) {
+	case SI_DOATTACH:
+		if (PCIE_ASPM(sih))
+			pcie_clkreq((void *)pi, 1, 0);
+		break;
+	case SI_PCIDOWN:
+		if (sih->buscorerev == 6) {	/* turn on serdes PLL down */
+			si_corereg(sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+				   0);
+			si_corereg(sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, chipcontrol_data),
+				   ~0x40, 0);
+		} else if (pi->pcie_pr42767) {
+			pcie_clkreq((void *)pi, 1, 1);
+		}
+		break;
+	case SI_PCIUP:
+		if (sih->buscorerev == 6) {	/* turn off serdes PLL down */
+			si_corereg(sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, chipcontrol_addr), ~0,
+				   0);
+			si_corereg(sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, chipcontrol_data),
+				   ~0x40, 0x40);
+		} else if (PCIE_ASPM(sih)) {	/* disable clkreq */
+			pcie_clkreq((void *)pi, 1, 0);
+		}
+		break;
+	default:
+		ASSERT(0);
+		break;
+	}
+}
+
+/* ***** PCI core WARs ***** */
+/* Done only once at attach time */
+static void pcie_war_polarity(pcicore_info_t * pi)
+{
+	uint32 w;
+
+	if (pi->pcie_polarity != 0)
+		return;
+
+	w = pcie_readreg(pi->osh, pi->regs.pcieregs, PCIE_PCIEREGS,
+			 PCIE_PLP_STATUSREG);
+
+	/* Detect the current polarity at attach and force that polarity and
+	 * disable changing the polarity
+	 */
+	if ((w & PCIE_PLP_POLARITYINV_STAT) == 0)
+		pi->pcie_polarity = (SERDES_RX_CTRL_FORCE);
+	else
+		pi->pcie_polarity =
+		    (SERDES_RX_CTRL_FORCE | SERDES_RX_CTRL_POLARITY);
+}
+
+/* enable ASPM and CLKREQ if srom doesn't have it */
+/* Needs to happen when update to shadow SROM is needed
+ *   : Coming out of 'standby'/'hibernate'
+ *   : If pcie_war_aspm_ovr state changed
+ */
+static void pcie_war_aspm_clkreq(pcicore_info_t * pi)
+{
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+	si_t *sih = pi->sih;
+	uint16 val16, *reg16;
+	uint32 w;
+
+	if (!PCIE_ASPM(sih))
+		return;
+
+	/* bypass this on QT or VSIM */
+	if (!ISSIM_ENAB(sih)) {
+
+		reg16 = &pcieregs->sprom[SRSH_ASPM_OFFSET];
+		val16 = R_REG(pi->osh, reg16);
+
+		val16 &= ~SRSH_ASPM_ENB;
+		if (pi->pcie_war_aspm_ovr == PCIE_ASPM_ENAB)
+			val16 |= SRSH_ASPM_ENB;
+		else if (pi->pcie_war_aspm_ovr == PCIE_ASPM_L1_ENAB)
+			val16 |= SRSH_ASPM_L1_ENB;
+		else if (pi->pcie_war_aspm_ovr == PCIE_ASPM_L0s_ENAB)
+			val16 |= SRSH_ASPM_L0s_ENB;
+
+		W_REG(pi->osh, reg16, val16);
+
+		w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
+					sizeof(uint32));
+		w &= ~PCIE_ASPM_ENAB;
+		w |= pi->pcie_war_aspm_ovr;
+		OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
+				     sizeof(uint32), w);
+	}
+
+	reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET_REV5];
+	val16 = R_REG(pi->osh, reg16);
+
+	if (pi->pcie_war_aspm_ovr != PCIE_ASPM_DISAB) {
+		val16 |= SRSH_CLKREQ_ENB;
+		pi->pcie_pr42767 = TRUE;
+	} else
+		val16 &= ~SRSH_CLKREQ_ENB;
+
+	W_REG(pi->osh, reg16, val16);
+}
+
+/* Apply the polarity determined at the start */
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void pcie_war_serdes(pcicore_info_t * pi)
+{
+	uint32 w = 0;
+
+	if (pi->pcie_polarity != 0)
+		pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CTRL,
+			       pi->pcie_polarity);
+
+	pcie_mdioread(pi, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, &w);
+	if (w & PLL_CTRL_FREQDET_EN) {
+		w &= ~PLL_CTRL_FREQDET_EN;
+		pcie_mdiowrite(pi, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, w);
+	}
+}
+
+/* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t * pi) {
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+	uint16 val16, *reg16;
+
+	reg16 = &pcieregs->sprom[SRSH_PCIE_MISC_CONFIG];
+	val16 = R_REG(pi->osh, reg16);
+
+	if ((val16 & SRSH_L23READY_EXIT_NOPERST) == 0) {
+		val16 |= SRSH_L23READY_EXIT_NOPERST;
+		W_REG(pi->osh, reg16, val16);
+	}
+}
+
+/* quick hack for testing */
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void pcie_war_noplldown(pcicore_info_t * pi)
+{
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+	uint16 *reg16;
+
+	ASSERT(pi->sih->buscorerev == 7);
+
+	/* turn off serdes PLL down */
+	si_corereg(pi->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
+		   CHIPCTRL_4321_PLL_DOWN, CHIPCTRL_4321_PLL_DOWN);
+
+	/*  clear srom shadow backdoor */
+	reg16 = &pcieregs->sprom[SRSH_BD_OFFSET];
+	W_REG(pi->osh, reg16, 0);
+}
+
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void pcie_war_pci_setup(pcicore_info_t * pi)
+{
+	si_t *sih = pi->sih;
+	osl_t *osh = pi->osh;
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+	uint32 w;
+
+	if ((sih->buscorerev == 0) || (sih->buscorerev == 1)) {
+		w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS,
+				 PCIE_TLP_WORKAROUNDSREG);
+		w |= 0x8;
+		pcie_writereg(osh, pcieregs, PCIE_PCIEREGS,
+			      PCIE_TLP_WORKAROUNDSREG, w);
+	}
+
+	if (sih->buscorerev == 1) {
+		w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_LCREG);
+		w |= (0x40);
+		pcie_writereg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_LCREG, w);
+	}
+
+	if (sih->buscorerev == 0) {
+		pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_TIMER1, 0x8128);
+		pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CDR, 0x0100);
+		pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CDRBW, 0x1466);
+	} else if (PCIE_ASPM(sih)) {
+		/* Change the L1 threshold for better performance */
+		w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS,
+				 PCIE_DLLP_PMTHRESHREG);
+		w &= ~(PCIE_L1THRESHOLDTIME_MASK);
+		w |= (PCIE_L1THRESHOLD_WARVAL << PCIE_L1THRESHOLDTIME_SHIFT);
+		pcie_writereg(osh, pcieregs, PCIE_PCIEREGS,
+			      PCIE_DLLP_PMTHRESHREG, w);
+
+		pcie_war_serdes(pi);
+
+		pcie_war_aspm_clkreq(pi);
+	} else if (pi->sih->buscorerev == 7)
+		pcie_war_noplldown(pi);
+
+	/* Note that the fix is actually in the SROM, that's why this is open-ended */
+	if (pi->sih->buscorerev >= 6)
+		pcie_misc_config_fixup(pi);
+}
+
+void pcie_war_ovr_aspm_update(void *pch, uint8 aspm)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+	if (!PCIE_ASPM(pi->sih))
+		return;
+
+	/* Validate */
+	if (aspm > PCIE_ASPM_ENAB)
+		return;
+
+	pi->pcie_war_aspm_ovr = aspm;
+
+	/* Update the current state */
+	pcie_war_aspm_clkreq(pi);
+}
+
+/* ***** Functions called during driver state changes ***** */
+void BCMATTACHFN(pcicore_attach) (void *pch, char *pvars, int state) {
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	si_t *sih = pi->sih;
+
+	/* Determine if this board needs override */
+	if (PCIE_ASPM(sih)) {
+		if ((uint32) getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR) {
+			pi->pcie_war_aspm_ovr = PCIE_ASPM_DISAB;
+		} else {
+			pi->pcie_war_aspm_ovr = PCIE_ASPM_ENAB;
+		}
+	}
+
+	/* These need to happen in this order only */
+	pcie_war_polarity(pi);
+
+	pcie_war_serdes(pi);
+
+	pcie_war_aspm_clkreq(pi);
+
+	pcie_clkreq_upd(pi, state);
+
+}
+
+void pcicore_hwup(void *pch)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+	if (!pi || !PCIE_PUB(pi->sih))
+		return;
+
+	pcie_war_pci_setup(pi);
+}
+
+void pcicore_up(void *pch, int state)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+	if (!pi || !PCIE_PUB(pi->sih))
+		return;
+
+	/* Restore L1 timer for better performance */
+	pcie_extendL1timer(pi, TRUE);
+
+	pcie_clkreq_upd(pi, state);
+}
+
+/* When the device is going to enter D3 state (or the system is going to enter S3/S4 states */
+void pcicore_sleep(void *pch)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	uint32 w;
+
+	if (!pi || !PCIE_ASPM(pi->sih))
+		return;
+
+	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
+				sizeof(uint32));
+	w &= ~PCIE_CAP_LCREG_ASPML1;
+	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset, sizeof(uint32),
+			     w);
+
+	pi->pcie_pr42767 = FALSE;
+}
+
+void pcicore_down(void *pch, int state)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+	if (!pi || !PCIE_PUB(pi->sih))
+		return;
+
+	pcie_clkreq_upd(pi, state);
+
+	/* Reduce L1 timer for better power savings */
+	pcie_extendL1timer(pi, FALSE);
+}
+
+/* ***** Wake-on-wireless-LAN (WOWL) support functions ***** */
+/* Just uses PCI config accesses to find out, when needed before sb_attach is done */
+bool pcicore_pmecap_fast(osl_t * osh)
+{
+	uint8 cap_ptr;
+	uint32 pmecap;
+
+	cap_ptr =
+	    pcicore_find_pci_capability(osh, PCI_CAP_POWERMGMTCAP_ID, NULL,
+					NULL);
+
+	if (!cap_ptr)
+		return FALSE;
+
+	pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(uint32));
+
+	return ((pmecap & PME_CAP_PM_STATES) != 0);
+}
+
+/* return TRUE if PM capability exists in the pci config space
+ * Uses and caches the information using core handle
+ */
+static bool pcicore_pmecap(pcicore_info_t * pi)
+{
+	uint8 cap_ptr;
+	uint32 pmecap;
+
+	if (!pi->pmecap_offset) {
+		cap_ptr =
+		    pcicore_find_pci_capability(pi->osh,
+						PCI_CAP_POWERMGMTCAP_ID, NULL,
+						NULL);
+		if (!cap_ptr)
+			return FALSE;
+
+		pi->pmecap_offset = cap_ptr;
+
+		pmecap =
+		    OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset,
+					sizeof(uint32));
+
+		/* At least one state can generate PME */
+		pi->pmecap = (pmecap & PME_CAP_PM_STATES) != 0;
+	}
+
+	return (pi->pmecap);
+}
+
+/* Enable PME generation */
+void pcicore_pmeen(void *pch)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	uint32 w;
+
+	/* if not pmecapable return */
+	if (!pcicore_pmecap(pi))
+		return;
+
+	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+				sizeof(uint32));
+	w |= (PME_CSR_PME_EN);
+	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+			     sizeof(uint32), w);
+}
+
+/*
+ * Return TRUE if PME status set
+ */
+bool pcicore_pmestat(void *pch)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	uint32 w;
+
+	if (!pcicore_pmecap(pi))
+		return FALSE;
+
+	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+				sizeof(uint32));
+
+	return (w & PME_CSR_PME_STAT) == PME_CSR_PME_STAT;
+}
+
+/* Disable PME generation, clear the PME status bit if set
+ */
+void pcicore_pmeclr(void *pch)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	uint32 w;
+
+	if (!pcicore_pmecap(pi))
+		return;
+
+	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+				sizeof(uint32));
+
+	PCI_ERROR(("pcicore_pci_pmeclr PMECSR : 0x%x\n", w));
+
+	/* PMESTAT is cleared by writing 1 to it */
+	w &= ~(PME_CSR_PME_EN);
+
+	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+			     sizeof(uint32), w);
+}
+
+uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val)
+{
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	uint8 offset;
+
+	offset = pi->pciecap_lcreg_offset;
+	if (!offset)
+		return 0;
+
+	/* set operation */
+	if (mask)
+		OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), val);
+
+	return OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+}
+
+uint32
+pcicore_pciereg(void *pch, uint32 offset, uint32 mask, uint32 val, uint type)
+{
+	uint32 reg_val = 0;
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+	sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+	osl_t *osh = pi->osh;
+
+	if (mask) {
+		PCI_ERROR(("PCIEREG: 0x%x writeval  0x%x\n", offset, val));
+		pcie_writereg(osh, pcieregs, type, offset, val);
+	}
+
+	/* Should not read register 0x154 */
+	if (pi->sih->buscorerev <= 5 && offset == PCIE_DLLP_PCIE11
+	    && type == PCIE_PCIEREGS)
+		return reg_val;
+
+	reg_val = pcie_readreg(osh, pcieregs, type, offset);
+	PCI_ERROR(("PCIEREG: 0x%x readval is 0x%x\n", offset, reg_val));
+
+	return reg_val;
+}
+
+uint32
+pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset, uint32 mask,
+		      uint32 val)
+{
+	uint32 reg_val = 0;
+	pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+	if (mask) {
+		PCI_ERROR(("PCIEMDIOREG: 0x%x writeval  0x%x\n", offset, val));
+		pcie_mdiowrite(pi, mdioslave, offset, val);
+	}
+
+	if (pcie_mdioread(pi, mdioslave, offset, &reg_val))
+		reg_val = 0xFFFFFFFF;
+	PCI_ERROR(("PCIEMDIOREG: dev 0x%x offset 0x%x read 0x%x\n", mdioslave,
+		   offset, reg_val));
+
+	return reg_val;
+}
diff --git a/drivers/staging/brcm80211/util/nvram/nvram_ro.c b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
new file mode 100644
index 0000000..68c69ee
--- /dev/null
+++ b/drivers/staging/brcm80211/util/nvram/nvram_ro.c
@@ -0,0 +1,198 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmendian.h>
+#include <bcmnvram.h>
+#include <sbchipc.h>
+#include <bcmsrom.h>
+#include <bcmotp.h>
+#include <bcmdevs.h>
+#include <hndsoc.h>
+
+#define NVR_MSG(x)
+
+typedef struct _vars {
+	struct _vars *next;
+	int bufsz;		/* allocated size */
+	int size;		/* actual vars size */
+	char *vars;
+} vars_t;
+
+#define	VARS_T_OH	sizeof(vars_t)
+
+static vars_t *vars = NULL;
+
+#define NVRAM_FILE	1
+
+static char *findvar(char *vars, char *lim, const char *name);
+
+#if defined(FLASH)
+/* copy flash to ram */
+static void BCMINITFN(get_flash_nvram) (si_t * sih, struct nvram_header * nvh) {
+	osl_t *osh;
+	uint nvs, bufsz;
+	vars_t *new;
+
+	osh = si_osh(sih);
+
+	nvs = R_REG(osh, &nvh->len) - sizeof(struct nvram_header);
+	bufsz = nvs + VARS_T_OH;
+
+	if ((new = (vars_t *) MALLOC(osh, bufsz)) == NULL) {
+		NVR_MSG(("Out of memory for flash vars\n"));
+		return;
+	}
+	new->vars = (char *)new + VARS_T_OH;
+
+	new->bufsz = bufsz;
+	new->size = nvs;
+	new->next = vars;
+	vars = new;
+
+	bcopy((char *)(&nvh[1]), new->vars, nvs);
+
+	NVR_MSG(("%s: flash nvram @ %p, copied %d bytes to %p\n", __func__,
+		 nvh, nvs, new->vars));
+}
+#endif				/* FLASH */
+
+int BCMATTACHFN(nvram_init) (void *si) {
+
+	/* Make sure we read nvram in flash just once before freeing the memory */
+	if (vars != NULL) {
+		NVR_MSG(("nvram_init: called again without calling nvram_exit()\n"));
+		return 0;
+	}
+	return 0;
+}
+
+int BCMATTACHFN(nvram_append) (void *si, char *varlst, uint varsz) {
+	uint bufsz = VARS_T_OH;
+	vars_t *new;
+
+	if ((new = MALLOC(si_osh((si_t *) si), bufsz)) == NULL)
+		return BCME_NOMEM;
+
+	new->vars = varlst;
+	new->bufsz = bufsz;
+	new->size = varsz;
+	new->next = vars;
+	vars = new;
+
+	return BCME_OK;
+}
+
+void BCMUNINITFN(nvram_exit) (void *si) {
+	vars_t *this, *next;
+	si_t *sih;
+
+	sih = (si_t *) si;
+	this = vars;
+
+	if (this)
+		MFREE(si_osh(sih), this->vars, this->size);
+
+	while (this) {
+		next = this->next;
+		MFREE(si_osh(sih), this, this->bufsz);
+		this = next;
+	}
+	vars = NULL;
+}
+
+static char *findvar(char *vars, char *lim, const char *name)
+{
+	char *s;
+	int len;
+
+	len = strlen(name);
+
+	for (s = vars; (s < lim) && *s;) {
+		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
+			return (&s[len + 1]);
+
+		while (*s++) ;
+	}
+
+	return NULL;
+}
+
+char *nvram_get(const char *name)
+{
+	char *v = NULL;
+	vars_t *cur;
+
+	for (cur = vars; cur; cur = cur->next)
+		if ((v = findvar(cur->vars, cur->vars + cur->size, name)))
+			break;
+
+	return v;
+}
+
+int BCMATTACHFN(nvram_set) (const char *name, const char *value) {
+	return 0;
+}
+
+int BCMATTACHFN(nvram_unset) (const char *name) {
+	return 0;
+}
+
+int BCMATTACHFN(nvram_reset) (void *si) {
+	return 0;
+}
+
+int BCMATTACHFN(nvram_commit) (void) {
+	return 0;
+}
+
+int nvram_getall(char *buf, int count)
+{
+	int len, resid = count;
+	vars_t *this;
+
+	this = vars;
+	while (this) {
+		char *from, *lim, *to;
+		int acc;
+
+		from = this->vars;
+		lim = (char *)((uintptr) this->vars + this->size);
+		to = buf;
+		acc = 0;
+		while ((from < lim) && (*from)) {
+			len = strlen(from) + 1;
+			if (resid < (acc + len))
+				return BCME_BUFTOOSHORT;
+			bcopy(from, to, len);
+			acc += len;
+			from += len;
+			to += len;
+		}
+
+		resid -= acc;
+		buf += acc;
+		this = this->next;
+	}
+	if (resid < 1)
+		return BCME_BUFTOOSHORT;
+	*buf = '\0';
+	return 0;
+}
diff --git a/drivers/staging/brcm80211/util/qmath.c b/drivers/staging/brcm80211/util/qmath.c
new file mode 100644
index 0000000..99a1776
--- /dev/null
+++ b/drivers/staging/brcm80211/util/qmath.c
@@ -0,0 +1,680 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "qmath.h"
+
+/*
+Description: This function saturate input 32 bit number into a 16 bit number.
+If input number is greater than 0x7fff then output is saturated to 0x7fff.
+else if input number is less than 0xffff8000 then output is saturated to 0xffff8000
+else output is same as input.
+*/
+int16 qm_sat32(int32 op)
+{
+	int16 result;
+	if (op > (int32) 0x7fff) {
+		result = 0x7fff;
+	} else if (op < (int32) 0xffff8000) {
+		result = (int16) (0x8000);
+	} else {
+		result = (int16) op;
+	}
+	return result;
+}
+
+/*
+Description: This function multiply two input 16 bit numbers and return the 32 bit result.
+This multiplication is similar to compiler multiplication. This operation is defined if
+16 bit multiplication on the processor platform is cheaper than 32 bit multiplication (as
+the most of qmath functions can be replaced with processor intrinsic instructions).
+*/
+int32 qm_mul321616(int16 op1, int16 op2)
+{
+	return ((int32) (op1) * (int32) (op2));
+}
+
+/*
+Description: This function make 16 bit multiplication and return the result in 16 bits.
+To fit the result into 16 bits the 32 bit multiplication result is right
+shifted by 16 bits.
+*/
+int16 qm_mul16(int16 op1, int16 op2)
+{
+	int32 result;
+	result = ((int32) (op1) * (int32) (op2));
+	return ((int16) (result >> 16));
+}
+
+/*
+Description: This function multiply two 16 bit numbers and return the result in 32 bits.
+This function remove the extra sign bit created by the multiplication by leftshifting the
+32 bit multiplication result by 1 bit before returning the result. So the output is
+twice that of compiler multiplication. (i.e. qm_muls321616(2,3)=12).
+When both input 16 bit numbers are 0x8000, then the result is saturated to 0x7fffffff.
+*/
+int32 qm_muls321616(int16 op1, int16 op2)
+{
+	int32 result;
+	if (op1 == (int16) (0x8000) && op2 == (int16) (0x8000)) {
+		result = 0x7fffffff;
+	} else {
+		result = ((int32) (op1) * (int32) (op2));
+		result = result << 1;
+	}
+	return result;
+}
+
+/*
+Description: This function make 16 bit unsigned multiplication. To fit the output into
+16 bits the 32 bit multiplication result is right shifted by 16 bits.
+*/
+uint16 qm_mulu16(uint16 op1, uint16 op2)
+{
+	return (uint16) (((uint32) op1 * (uint32) op2) >> 16);
+}
+
+/*
+Description: This function make 16 bit multiplication and return the result in 16 bits.
+To fit the multiplication result into 16 bits the multiplication result is right shifted by
+15 bits. Right shifting 15 bits instead of 16 bits is done to remove the extra sign bit formed
+due to the multiplication.
+When both the 16bit inputs are 0x8000 then the output is saturated to 0x7fffffff.
+*/
+int16 qm_muls16(int16 op1, int16 op2)
+{
+	int32 result;
+	if (op1 == (int16) 0x8000 && op2 == (int16) 0x8000) {
+		result = 0x7fffffff;
+	} else {
+		result = ((int32) (op1) * (int32) (op2));
+	}
+	return ((int16) (result >> 15));
+}
+
+/*
+Description: This function add two 32 bit numbers and return the 32bit result.
+If the result overflow 32 bits, the output will be saturated to 32bits.
+*/
+int32 qm_add32(int32 op1, int32 op2)
+{
+	int32 result;
+	result = op1 + op2;
+	if (op1 < 0 && op2 < 0 && result > 0) {
+		result = 0x80000000;
+	} else if (op1 > 0 && op2 > 0 && result < 0) {
+		result = 0x7fffffff;
+	}
+	return result;
+}
+
+/*
+Description: This function add two 16 bit numbers and return the 16bit result.
+If the result overflow 16 bits, the output will be saturated to 16bits.
+*/
+int16 qm_add16(int16 op1, int16 op2)
+{
+	int16 result;
+	int32 temp = (int32) op1 + (int32) op2;
+	if (temp > (int32) 0x7fff) {
+		result = (int16) 0x7fff;
+	} else if (temp < (int32) 0xffff8000) {
+		result = (int16) 0xffff8000;
+	} else {
+		result = (int16) temp;
+	}
+	return result;
+}
+
+/*
+Description: This function make 16 bit subtraction and return the 16bit result.
+If the result overflow 16 bits, the output will be saturated to 16bits.
+*/
+int16 qm_sub16(int16 op1, int16 op2)
+{
+	int16 result;
+	int32 temp = (int32) op1 - (int32) op2;
+	if (temp > (int32) 0x7fff) {
+		result = (int16) 0x7fff;
+	} else if (temp < (int32) 0xffff8000) {
+		result = (int16) 0xffff8000;
+	} else {
+		result = (int16) temp;
+	}
+	return result;
+}
+
+/*
+Description: This function make 32 bit subtraction and return the 32bit result.
+If the result overflow 32 bits, the output will be saturated to 32bits.
+*/
+int32 qm_sub32(int32 op1, int32 op2)
+{
+	int32 result;
+	result = op1 - op2;
+	if (op1 >= 0 && op2 < 0 && result < 0) {
+		result = 0x7fffffff;
+	} else if (op1 < 0 && op2 > 0 && result > 0) {
+		result = 0x80000000;
+	}
+	return result;
+}
+
+/*
+Description: This function multiply input 16 bit numbers and accumulate the result
+into the input 32 bit number and return the 32 bit accumulated result.
+If the accumulation result in overflow, then the output will be saturated.
+*/
+int32 qm_mac321616(int32 acc, int16 op1, int16 op2)
+{
+	int32 result;
+	result = qm_add32(acc, qm_mul321616(op1, op2));
+	return result;
+}
+
+/*
+Description: This function make a 32 bit saturated left shift when the specified shift
+is +ve. This function will make a 32 bit right shift when the specified shift is -ve.
+This function return the result after shifting operation.
+*/
+int32 qm_shl32(int32 op, int shift)
+{
+	int i;
+	int32 result;
+	result = op;
+	if (shift > 31)
+		shift = 31;
+	else if (shift < -31)
+		shift = -31;
+	if (shift >= 0) {
+		for (i = 0; i < shift; i++) {
+			result = qm_add32(result, result);
+		}
+	} else {
+		result = result >> (-shift);
+	}
+	return result;
+}
+
+/*
+Description: This function make a 32 bit right shift when shift is +ve.
+This function make a 32 bit saturated left shift when shift is -ve. This function
+return the result of the shift operation.
+*/
+int32 qm_shr32(int32 op, int shift)
+{
+	return qm_shl32(op, -shift);
+}
+
+/*
+Description: This function make a 16 bit saturated left shift when the specified shift
+is +ve. This function will make a 16 bit right shift when the specified shift is -ve.
+This function return the result after shifting operation.
+*/
+int16 qm_shl16(int16 op, int shift)
+{
+	int i;
+	int16 result;
+	result = op;
+	if (shift > 15)
+		shift = 15;
+	else if (shift < -15)
+		shift = -15;
+	if (shift > 0) {
+		for (i = 0; i < shift; i++) {
+			result = qm_add16(result, result);
+		}
+	} else {
+		result = result >> (-shift);
+	}
+	return result;
+}
+
+/*
+Description: This function make a 16 bit right shift when shift is +ve.
+This function make a 16 bit saturated left shift when shift is -ve. This function
+return the result of the shift operation.
+*/
+int16 qm_shr16(int16 op, int shift)
+{
+	return qm_shl16(op, -shift);
+}
+
+/*
+Description: This function return the number of redundant sign bits in a 16 bit number.
+Example: qm_norm16(0x0080) = 7.
+*/
+int16 qm_norm16(int16 op)
+{
+	uint16 u16extraSignBits;
+	if (op == 0) {
+		return 15;
+	} else {
+		u16extraSignBits = 0;
+		while ((op >> 15) == (op >> 14)) {
+			u16extraSignBits++;
+			op = op << 1;
+		}
+	}
+	return u16extraSignBits;
+}
+
+/*
+Description: This function return the number of redundant sign bits in a 32 bit number.
+Example: qm_norm32(0x00000080) = 23
+*/
+int16 qm_norm32(int32 op)
+{
+	uint16 u16extraSignBits;
+	if (op == 0) {
+		return 31;
+	} else {
+		u16extraSignBits = 0;
+		while ((op >> 31) == (op >> 30)) {
+			u16extraSignBits++;
+			op = op << 1;
+		}
+	}
+	return u16extraSignBits;
+}
+
+/*
+Description: This function divide two 16 bit unsigned numbers.
+The numerator should be less than denominator. So the quotient is always less than 1.
+This function return the quotient in q.15 format.
+*/
+int16 qm_div_s(int16 num, int16 denom)
+{
+	int16 var_out;
+	int16 iteration;
+	int32 L_num;
+	int32 L_denom;
+	L_num = (num) << 15;
+	L_denom = (denom) << 15;
+	for (iteration = 0; iteration < 15; iteration++) {
+		L_num <<= 1;
+		if (L_num >= L_denom) {
+			L_num = qm_sub32(L_num, L_denom);
+			L_num = qm_add32(L_num, 1);
+		}
+	}
+	var_out = (int16) (L_num & 0x7fff);
+	return (var_out);
+}
+
+/*
+Description: This function compute the absolute value of a 16 bit number.
+*/
+int16 qm_abs16(int16 op)
+{
+	if (op < 0) {
+		if (op == (int16) 0xffff8000) {
+			return 0x7fff;
+		} else {
+			return -op;
+		}
+	} else {
+		return op;
+	}
+}
+
+/*
+Description: This function divide two 16 bit numbers.
+The quotient is returned through return value.
+The qformat of the quotient is returned through the pointer (qQuotient) passed
+to this function. The qformat of quotient is adjusted appropriately such that
+the quotient occupies all 16 bits.
+*/
+int16 qm_div16(int16 num, int16 denom, int16 * qQuotient)
+{
+	int16 sign;
+	int16 nNum, nDenom;
+	sign = num ^ denom;
+	num = qm_abs16(num);
+	denom = qm_abs16(denom);
+	nNum = qm_norm16(num);
+	nDenom = qm_norm16(denom);
+	num = qm_shl16(num, nNum - 1);
+	denom = qm_shl16(denom, nDenom);
+	*qQuotient = nNum - 1 - nDenom + 15;
+	if (sign >= 0) {
+		return qm_div_s(num, denom);
+	} else {
+		return -qm_div_s(num, denom);
+	}
+}
+
+/*
+Description: This function compute absolute value of a 32 bit number.
+*/
+int32 qm_abs32(int32 op)
+{
+	if (op < 0) {
+		if (op == (int32) 0x80000000) {
+			return 0x7fffffff;
+		} else {
+			return -op;
+		}
+	} else {
+		return op;
+	}
+}
+
+/*
+Description: This function divide two 32 bit numbers. The division is performed
+by considering only important 16 bits in 32 bit numbers.
+The quotient is returned through return value.
+The qformat of the quotient is returned through the pointer (qquotient) passed
+to this function. The qformat of quotient is adjusted appropriately such that
+the quotient occupies all 16 bits.
+*/
+int16 qm_div163232(int32 num, int32 denom, int16 * qquotient)
+{
+	int32 sign;
+	int16 nNum, nDenom;
+	sign = num ^ denom;
+	num = qm_abs32(num);
+	denom = qm_abs32(denom);
+	nNum = qm_norm32(num);
+	nDenom = qm_norm32(denom);
+	num = qm_shl32(num, nNum - 1);
+	denom = qm_shl32(denom, nDenom);
+	*qquotient = nNum - 1 - nDenom + 15;
+	if (sign >= 0) {
+		return qm_div_s((int16) (num >> 16), (int16) (denom >> 16));
+	} else {
+		return -qm_div_s((int16) (num >> 16), (int16) (denom >> 16));
+	}
+}
+
+/*
+Description: This function multiply a 32 bit number with a 16 bit number.
+The multiplicaton result is right shifted by 16 bits to fit the result
+into 32 bit output.
+*/
+int32 qm_mul323216(int32 op1, int16 op2)
+{
+	int16 hi;
+	uint16 lo;
+	int32 result;
+	hi = op1 >> 16;
+	lo = (int16) (op1 & 0xffff);
+	result = qm_mul321616(hi, op2);
+	result = result + (qm_mulsu321616(op2, lo) >> 16);
+	return result;
+}
+
+/*
+Description: This function multiply signed 16 bit number with unsigned 16 bit number and return
+the result in 32 bits.
+*/
+int32 qm_mulsu321616(int16 op1, uint16 op2)
+{
+	return (int32) (op1) * op2;
+}
+
+/*
+Description: This function multiply 32 bit number with 16 bit number. The multiplication result is
+right shifted by 15 bits to fit the result into 32 bits. Right shifting by only 15 bits instead of
+16 bits is done to remove the extra sign bit formed by multiplication from the return value.
+When the input numbers are 0x80000000, 0x8000 the return value is saturated to 0x7fffffff.
+*/
+int32 qm_muls323216(int32 op1, int16 op2)
+{
+	int16 hi;
+	uint16 lo;
+	int32 result;
+	hi = op1 >> 16;
+	lo = (int16) (op1 & 0xffff);
+	result = qm_muls321616(hi, op2);
+	result = qm_add32(result, (qm_mulsu321616(op2, lo) >> 15));
+	return result;
+}
+
+/*
+Description: This function multiply two 32 bit numbers. The multiplication result is right
+shifted by 32 bits to fit the multiplication result into 32 bits. The right shifted
+multiplication result is returned as output.
+*/
+int32 qm_mul32(int32 a, int32 b)
+{
+	int16 hi1, hi2;
+	uint16 lo1, lo2;
+	int32 result;
+	hi1 = a >> 16;
+	hi2 = b >> 16;
+	lo1 = (uint16) (a & 0xffff);
+	lo2 = (uint16) (b & 0xffff);
+	result = qm_mul321616(hi1, hi2);
+	result = result + (qm_mulsu321616(hi1, lo2) >> 16);
+	result = result + (qm_mulsu321616(hi2, lo1) >> 16);
+	return result;
+}
+
+/*
+Description: This function multiply two 32 bit numbers. The multiplication result is
+right shifted by 31 bits to fit the multiplication result into 32 bits. The right
+shifted multiplication result is returned as output. Right shifting by only 31 bits
+instead of 32 bits is done to remove the extra sign bit formed by multiplication.
+When the input numbers are 0x80000000, 0x80000000 the return value is saturated to
+0x7fffffff.
+*/
+int32 qm_muls32(int32 a, int32 b)
+{
+	int16 hi1, hi2;
+	uint16 lo1, lo2;
+	int32 result;
+	hi1 = a >> 16;
+	hi2 = b >> 16;
+	lo1 = (uint16) (a & 0xffff);
+	lo2 = (uint16) (b & 0xffff);
+	result = qm_muls321616(hi1, hi2);
+	result = qm_add32(result, (qm_mulsu321616(hi1, lo2) >> 15));
+	result = qm_add32(result, (qm_mulsu321616(hi2, lo1) >> 15));
+	result = qm_add32(result, (qm_mulu16(lo1, lo2) >> 15));
+	return result;
+}
+
+/* This table is log2(1+(i/32)) where i=[0:1:31], in q.15 format */
+static const int16 log_table[] = {
+	0,
+	1455,
+	2866,
+	4236,
+	5568,
+	6863,
+	8124,
+	9352,
+	10549,
+	11716,
+	12855,
+	13968,
+	15055,
+	16117,
+	17156,
+	18173,
+	19168,
+	20143,
+	21098,
+	22034,
+	22952,
+	23852,
+	24736,
+	25604,
+	26455,
+	27292,
+	28114,
+	28922,
+	29717,
+	30498,
+	31267,
+	32024
+};
+
+#define LOG_TABLE_SIZE 32	/* log_table size */
+#define LOG2_LOG_TABLE_SIZE 5	/* log2(log_table size) */
+#define Q_LOG_TABLE 15		/* qformat of log_table */
+#define LOG10_2		19728	/* log10(2) in q.16 */
+
+/*
+Description:
+This routine takes the input number N and its q format qN and compute
+the log10(N). This routine first normalizes the input no N.	Then N is in mag*(2^x) format.
+mag is any number in the range 2^30-(2^31 - 1). Then log2(mag * 2^x) = log2(mag) + x is computed.
+From that log10(mag * 2^x) = log2(mag * 2^x) * log10(2) is computed.
+This routine looks the log2 value in the table considering LOG2_LOG_TABLE_SIZE+1 MSBs.
+As the MSB is always 1, only next LOG2_OF_LOG_TABLE_SIZE MSBs are used for table lookup.
+Next 16 MSBs are used for interpolation.
+Inputs:
+N - number to which log10 has to be found.
+qN - q format of N
+log10N - address where log10(N) will be written.
+qLog10N - address where log10N qformat will be written.
+Note/Problem:
+For accurate results input should be in normalized or near normalized form.
+*/
+void qm_log10(int32 N, int16 qN, int16 * log10N, int16 * qLog10N)
+{
+	int16 s16norm, s16tableIndex, s16errorApproximation;
+	uint16 u16offset;
+	int32 s32log;
+
+	/* Logerithm of negative values is undefined.
+	 * assert N is greater than 0.
+	 */
+	/* ASSERT(N > 0); */
+
+	/* normalize the N. */
+	s16norm = qm_norm32(N);
+	N = N << s16norm;
+
+	/* The qformat of N after normalization.
+	 * -30 is added to treat the no as between 1.0 to 2.0
+	 * i.e. after adding the -30 to the qformat the decimal point will be
+	 * just rigtht of the MSB. (i.e. after sign bit and 1st MSB). i.e.
+	 * at the right side of 30th bit.
+	 */
+	qN = qN + s16norm - 30;
+
+	/* take the table index as the LOG2_OF_LOG_TABLE_SIZE bits right of the MSB */
+	s16tableIndex = (int16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE)));
+
+	/* remove the MSB. the MSB is always 1 after normalization. */
+	s16tableIndex =
+	    s16tableIndex & (int16) ((1 << LOG2_LOG_TABLE_SIZE) - 1);
+
+	/* remove the (1+LOG2_OF_LOG_TABLE_SIZE) MSBs in the N. */
+	N = N & ((1 << (32 - (2 + LOG2_LOG_TABLE_SIZE))) - 1);
+
+	/* take the offset as the 16 MSBS after table index.
+	 */
+	u16offset = (uint16) (N >> (32 - (2 + LOG2_LOG_TABLE_SIZE + 16)));
+
+	/* look the log value in the table. */
+	s32log = log_table[s16tableIndex];	/* q.15 format */
+
+	/* interpolate using the offset. */
+	s16errorApproximation = (int16) qm_mulu16(u16offset, (uint16) (log_table[s16tableIndex + 1] - log_table[s16tableIndex]));	/* q.15 */
+
+	s32log = qm_add16((int16) s32log, s16errorApproximation);	/* q.15 format */
+
+	/* adjust for the qformat of the N as
+	 * log2(mag * 2^x) = log2(mag) + x
+	 */
+	s32log = qm_add32(s32log, ((int32) - qN) << 15);	/* q.15 format */
+
+	/* normalize the result. */
+	s16norm = qm_norm32(s32log);
+
+	/* bring all the important bits into lower 16 bits */
+	s32log = qm_shl32(s32log, s16norm - 16);	/* q.15+s16norm-16 format */
+
+	/* compute the log10(N) by multiplying log2(N) with log10(2).
+	 * as log10(mag * 2^x) = log2(mag * 2^x) * log10(2)
+	 * log10N in q.15+s16norm-16+1 (LOG10_2 is in q.16)
+	 */
+	*log10N = qm_muls16((int16) s32log, (int16) LOG10_2);
+
+	/* write the q format of the result. */
+	*qLog10N = 15 + s16norm - 16 + 1;
+
+	return;
+}
+
+/*
+Description:
+This routine compute 1/N.
+This routine reformates the given no N as N * 2^qN where N is in between 0.5 and 1.0
+in q.15 format in 16 bits. So the problem now boils down to finding the inverse of a
+q.15 no in 16 bits which is in the range of 0.5 to 1.0. The output is always between
+2.0 to 1. So the output is 2.0 to 1.0 in q.30 format. Once the final output format is found
+by taking the qN into account. Inverse is found with newton rapson method. Initially
+inverse (x) is guessed as 1/0.75 (with appropriate sign). The new guess is calculated
+using the formula x' = 2*x - N*x*x. After 4 or 5 iterations the inverse is very close to
+inverse of N.
+Inputs:
+N - number to which 1/N has to be found.
+qn - q format of N.
+sqrtN - address where 1/N has to be written.
+qsqrtN - address where q format of 1/N has to be written.
+*/
+#define qx 29
+void qm_1byN(int32 N, int16 qN, int32 * result, int16 * qResult)
+{
+	int16 normN;
+	int32 s32firstTerm, s32secondTerm, x;
+	int i;
+
+	normN = qm_norm32(N);
+
+	/* limit N to least significant 16 bits. 15th bit is the sign bit. */
+	N = qm_shl32(N, normN - 16);
+	qN = qN + normN - 16 - 15;
+	/* -15 is added to treat N as 16 bit q.15 number in the range from 0.5 to 1 */
+
+	/* Take the initial guess as 1/0.75 in qx format with appropriate sign. */
+	if (N >= 0) {
+		x = (int32) ((1 / 0.75) * (1 << qx));
+		/* input no is in the range 0.5 to 1. So 1/0.75 is taken as initial guess. */
+	} else {
+		x = (int32) ((1 / -0.75) * (1 << qx));
+		/* input no is in the range -0.5 to -1. So 1/-0.75 is taken as initial guess. */
+	}
+
+	/* iterate the equation x = 2*x - N*x*x for 4 times. */
+	for (i = 0; i < 4; i++) {
+		s32firstTerm = qm_shl32(x, 1);	/* s32firstTerm = 2*x in q.29 */
+		s32secondTerm =
+		    qm_muls321616((int16) (s32firstTerm >> 16),
+				  (int16) (s32firstTerm >> 16));
+		/* s32secondTerm = x*x in q.(29+1-16)*2+1 */
+		s32secondTerm =
+		    qm_muls321616((int16) (s32secondTerm >> 16), (int16) N);
+		/* s32secondTerm = N*x*x in q.((29+1-16)*2+1)-16+15+1 i.e. in q.29 */
+		x = qm_sub32(s32firstTerm, s32secondTerm);
+		/* can be added directly as both are in q.29 */
+	}
+
+	/* Bring the x to q.30 format. */
+	*result = qm_shl32(x, 1);
+	/* giving the output in q.30 format for q.15 input in 16 bits. */
+
+	/* compute the final q format of the result. */
+	*qResult = -qN + 30;	/* adjusting the q format of actual output */
+
+	return;
+}
+
+#undef qx
diff --git a/drivers/staging/brcm80211/util/siutils.c b/drivers/staging/brcm80211/util/siutils.c
new file mode 100644
index 0000000..af35564
--- /dev/null
+++ b/drivers/staging/brcm80211/util/siutils.c
@@ -0,0 +1,2914 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <bcmdevs.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <pci_core.h>
+#include <pcie_core.h>
+#include <nicpci.h>
+#include <bcmnvram.h>
+#include <bcmsrom.h>
+#include <hndtcam.h>
+#include <pcicfg.h>
+#include <sbsocram.h>
+#ifdef BCMSDIO
+#include <bcmsdh.h>
+#include <sdio.h>
+#include <sbsdio.h>
+#include <sbhnddma.h>
+#include <sbsdpcmdev.h>
+#include <bcmsdpcm.h>
+#endif				/* BCMSDIO */
+#include <hndpmu.h>
+
+/* this file now contains only definitions for sb functions, only necessary
+*for devices using Sonics backplanes (bcm4329)
+*/
+
+/* if an amba SDIO device is supported, please further restrict the inclusion
+ * of this file
+ */
+#ifdef BCMSDIO
+#include "siutils_priv.h"
+#endif
+
+/* local prototypes */
+static si_info_t *si_doattach(si_info_t * sii, uint devid, osl_t * osh,
+			      void *regs, uint bustype, void *sdh, char **vars,
+			      uint * varsz);
+static bool si_buscore_prep(si_info_t * sii, uint bustype, uint devid,
+			    void *sdh);
+static bool si_buscore_setup(si_info_t * sii, chipcregs_t * cc, uint bustype,
+			     uint32 savewin, uint * origidx, void *regs);
+static void si_nvram_process(si_info_t * sii, char *pvars);
+
+/* dev path concatenation util */
+static char *si_devpathvar(si_t * sih, char *var, int len, const char *name);
+static bool _si_clkctl_cc(si_info_t * sii, uint mode);
+static bool si_ispcie(si_info_t * sii);
+static uint BCMINITFN(socram_banksize) (si_info_t * sii, sbsocramregs_t * r,
+					uint8 idx, uint8 mtype);
+
+/* global variable to indicate reservation/release of gpio's */
+static uint32 si_gpioreservation = 0;
+
+/* global flag to prevent shared resources from being initialized multiple times in si_attach() */
+
+/*
+ * Allocate a si handle.
+ * devid - pci device id (used to determine chip#)
+ * osh - opaque OS handle
+ * regs - virtual address of initial core registers
+ * bustype - pci/sb/sdio/etc
+ * vars - pointer to a pointer area for "environment" variables
+ * varsz - pointer to int to return the size of the vars
+ */
+si_t *BCMATTACHFN(si_attach) (uint devid, osl_t * osh, void *regs,
+			      uint bustype, void *sdh, char **vars,
+			      uint * varsz) {
+	si_info_t *sii;
+
+	/* alloc si_info_t */
+	if ((sii = MALLOC(osh, sizeof(si_info_t))) == NULL) {
+		SI_ERROR(("si_attach: malloc failed! malloced %d bytes\n",
+			  MALLOCED(osh)));
+		return (NULL);
+	}
+
+	if (si_doattach(sii, devid, osh, regs, bustype, sdh, vars, varsz) ==
+	    NULL) {
+		MFREE(osh, sii, sizeof(si_info_t));
+		return (NULL);
+	}
+	sii->vars = vars ? *vars : NULL;
+	sii->varsz = varsz ? *varsz : 0;
+
+	return (si_t *) sii;
+}
+
+/* global kernel resource */
+static si_info_t ksii;
+
+static uint32 wd_msticks;	/* watchdog timer ticks normalized to ms */
+
+static bool
+BCMATTACHFN(si_buscore_prep) (si_info_t * sii, uint bustype, uint devid,
+			      void *sdh) {
+
+	/* kludge to enable the clock on the 4306 which lacks a slowclock */
+	if (BUSTYPE(bustype) == PCI_BUS && !si_ispcie(sii))
+		si_clkctl_xtal(&sii->pub, XTAL | PLL, ON);
+
+#if defined(BCMSDIO)
+	if (BUSTYPE(bustype) == SDIO_BUS) {
+		int err;
+		uint8 clkset;
+
+		/* Try forcing SDIO core to do ALPAvail request only */
+		clkset = SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ;
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_CHIPCLKCSR,
+				 clkset, &err);
+		if (!err) {
+			uint8 clkval;
+
+			/* If register supported, wait for ALPAvail and then force ALP */
+			clkval =
+			    bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+					    SBSDIO_FUNC1_CHIPCLKCSR, NULL);
+			if ((clkval & ~SBSDIO_AVBITS) == clkset) {
+				SPINWAIT(((clkval =
+					   bcmsdh_cfg_read(sdh, SDIO_FUNC_1,
+							   SBSDIO_FUNC1_CHIPCLKCSR,
+							   NULL)),
+					  !SBSDIO_ALPAV(clkval)),
+					 PMU_MAX_TRANSITION_DLY);
+				if (!SBSDIO_ALPAV(clkval)) {
+					SI_ERROR(("timeout on ALPAV wait, clkval 0x%02x\n", clkval));
+					return FALSE;
+				}
+				clkset =
+				    SBSDIO_FORCE_HW_CLKREQ_OFF |
+				    SBSDIO_FORCE_ALP;
+				bcmsdh_cfg_write(sdh, SDIO_FUNC_1,
+						 SBSDIO_FUNC1_CHIPCLKCSR,
+						 clkset, &err);
+				OSL_DELAY(65);
+			}
+		}
+
+		/* Also, disable the extra SDIO pull-ups */
+		bcmsdh_cfg_write(sdh, SDIO_FUNC_1, SBSDIO_FUNC1_SDIOPULLUP, 0,
+				 NULL);
+	}
+#endif				/* defined(BCMSDIO) */
+
+	return TRUE;
+}
+
+static bool
+BCMATTACHFN(si_buscore_setup) (si_info_t * sii, chipcregs_t * cc, uint bustype,
+			       uint32 savewin, uint * origidx, void *regs) {
+	bool pci, pcie;
+	uint i;
+	uint pciidx, pcieidx, pcirev, pcierev;
+
+	cc = si_setcoreidx(&sii->pub, SI_CC_IDX);
+	ASSERT((uintptr) cc);
+
+	/* get chipcommon rev */
+	sii->pub.ccrev = (int)si_corerev(&sii->pub);
+
+	/* get chipcommon chipstatus */
+	if (sii->pub.ccrev >= 11)
+		sii->pub.chipst = R_REG(sii->osh, &cc->chipstatus);
+
+	/* get chipcommon capabilites */
+	sii->pub.cccaps = R_REG(sii->osh, &cc->capabilities);
+	/* get chipcommon extended capabilities */
+
+	if (sii->pub.ccrev >= 35)
+		sii->pub.cccaps_ext = R_REG(sii->osh, &cc->capabilities_ext);
+
+	/* get pmu rev and caps */
+	if (sii->pub.cccaps & CC_CAP_PMU) {
+		sii->pub.pmucaps = R_REG(sii->osh, &cc->pmucapabilities);
+		sii->pub.pmurev = sii->pub.pmucaps & PCAP_REV_MASK;
+	}
+
+	/*
+	   SI_MSG(("Chipc: rev %d, caps 0x%x, chipst 0x%x pmurev %d, pmucaps 0x%x\n",
+	   sii->pub.ccrev, sii->pub.cccaps, sii->pub.chipst, sii->pub.pmurev,
+	   sii->pub.pmucaps));
+	 */
+
+	/* figure out bus/orignal core idx */
+	sii->pub.buscoretype = NODEV_CORE_ID;
+	sii->pub.buscorerev = NOREV;
+	sii->pub.buscoreidx = BADIDX;
+
+	pci = pcie = FALSE;
+	pcirev = pcierev = NOREV;
+	pciidx = pcieidx = BADIDX;
+
+	for (i = 0; i < sii->numcores; i++) {
+		uint cid, crev;
+
+		si_setcoreidx(&sii->pub, i);
+		cid = si_coreid(&sii->pub);
+		crev = si_corerev(&sii->pub);
+
+		/* Display cores found */
+		SI_VMSG(("CORE[%d]: id 0x%x rev %d base 0x%x regs 0x%p\n",
+			 i, cid, crev, sii->coresba[i], sii->regs[i]));
+
+		if (BUSTYPE(bustype) == PCI_BUS) {
+			if (cid == PCI_CORE_ID) {
+				pciidx = i;
+				pcirev = crev;
+				pci = TRUE;
+			} else if (cid == PCIE_CORE_ID) {
+				pcieidx = i;
+				pcierev = crev;
+				pcie = TRUE;
+			}
+		}
+#ifdef BCMSDIO
+		else if (((BUSTYPE(bustype) == SDIO_BUS) ||
+			  (BUSTYPE(bustype) == SPI_BUS)) &&
+			 ((cid == PCMCIA_CORE_ID) || (cid == SDIOD_CORE_ID))) {
+			sii->pub.buscorerev = crev;
+			sii->pub.buscoretype = cid;
+			sii->pub.buscoreidx = i;
+		}
+#endif				/* BCMSDIO */
+
+		/* find the core idx before entering this func. */
+		if ((savewin && (savewin == sii->coresba[i])) ||
+		    (regs == sii->regs[i]))
+			*origidx = i;
+	}
+
+	if (pci && pcie) {
+		if (si_ispcie(sii))
+			pci = FALSE;
+		else
+			pcie = FALSE;
+	}
+	if (pci) {
+		sii->pub.buscoretype = PCI_CORE_ID;
+		sii->pub.buscorerev = pcirev;
+		sii->pub.buscoreidx = pciidx;
+	} else if (pcie) {
+		sii->pub.buscoretype = PCIE_CORE_ID;
+		sii->pub.buscorerev = pcierev;
+		sii->pub.buscoreidx = pcieidx;
+	}
+
+	SI_VMSG(("Buscore id/type/rev %d/0x%x/%d\n", sii->pub.buscoreidx,
+		 sii->pub.buscoretype, sii->pub.buscorerev));
+
+	/* fixup necessary chip/core configurations */
+	if (BUSTYPE(sii->pub.bustype) == PCI_BUS) {
+		if (SI_FAST(sii)) {
+			if (!sii->pch &&
+			    ((sii->pch =
+			      (void *)(uintptr) pcicore_init(&sii->pub,
+							     sii->osh,
+							     (void *)
+							     PCIEREGS(sii))) ==
+			     NULL))
+				return FALSE;
+		}
+		if (si_pci_fixcfg(&sii->pub)) {
+			SI_ERROR(("si_doattach: sb_pci_fixcfg failed\n"));
+			return FALSE;
+		}
+	}
+
+	/* return to the original core */
+	si_setcoreidx(&sii->pub, *origidx);
+
+	return TRUE;
+}
+
+static void BCMATTACHFN(si_nvram_process) (si_info_t * sii, char *pvars) {
+	uint w = 0;
+
+	/* get boardtype and boardrev */
+	switch (BUSTYPE(sii->pub.bustype)) {
+	case PCI_BUS:
+		/* do a pci config read to get subsystem id and subvendor id */
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_SVID, sizeof(uint32));
+		/* Let nvram variables override subsystem Vend/ID */
+		if ((sii->pub.boardvendor =
+		     (uint16) si_getdevpathintvar(&sii->pub, "boardvendor"))
+		    == 0)
+			sii->pub.boardvendor = w & 0xffff;
+		else
+			SI_ERROR(("Overriding boardvendor: 0x%x instead of 0x%x\n", sii->pub.boardvendor, w & 0xffff));
+		if ((sii->pub.boardtype =
+		     (uint16) si_getdevpathintvar(&sii->pub, "boardtype"))
+		    == 0)
+			sii->pub.boardtype = (w >> 16) & 0xffff;
+		else
+			SI_ERROR(("Overriding boardtype: 0x%x instead of 0x%x\n", sii->pub.boardtype, (w >> 16) & 0xffff));
+		break;
+
+#ifdef BCMSDIO
+	case SDIO_BUS:
+#endif
+		sii->pub.boardvendor = getintvar(pvars, "manfid");
+		sii->pub.boardtype = getintvar(pvars, "prodid");
+		break;
+
+#ifdef BCMSDIO
+	case SPI_BUS:
+		sii->pub.boardvendor = VENDOR_BROADCOM;
+		sii->pub.boardtype = SPI_BOARD;
+		break;
+#endif
+
+	case SI_BUS:
+	case JTAG_BUS:
+		sii->pub.boardvendor = VENDOR_BROADCOM;
+		if (pvars == NULL
+		    || ((sii->pub.boardtype = getintvar(pvars, "prodid")) == 0))
+			if ((sii->pub.boardtype =
+			     getintvar(NULL, "boardtype")) == 0)
+				sii->pub.boardtype = 0xffff;
+		break;
+	}
+
+	if (sii->pub.boardtype == 0) {
+		SI_ERROR(("si_doattach: unknown board type\n"));
+		ASSERT(sii->pub.boardtype);
+	}
+
+	sii->pub.boardflags = getintvar(pvars, "boardflags");
+}
+
+/* this is will make Sonics calls directly, since Sonics is no longer supported in the Si abstraction */
+/* this has been customized for the bcm 4329 ONLY */
+#ifdef BCMSDIO
+static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
+					    osl_t * osh, void *regs,
+					    uint bustype, void *sdh,
+					    char **vars, uint * varsz) {
+	struct si_pub *sih = &sii->pub;
+	uint32 w, savewin;
+	chipcregs_t *cc;
+	char *pvars = NULL;
+	uint origidx;
+
+	ASSERT(GOODREGS(regs));
+
+	bzero((uchar *) sii, sizeof(si_info_t));
+
+	savewin = 0;
+
+	sih->buscoreidx = BADIDX;
+
+	sii->curmap = regs;
+	sii->sdh = sdh;
+	sii->osh = osh;
+
+	/* find Chipcommon address */
+	cc = (chipcregs_t *) sii->curmap;
+	sih->bustype = bustype;
+
+	if (bustype != BUSTYPE(bustype)) {
+		SI_ERROR(("si_doattach: bus type %d does not match configured bus type %d\n", bustype, BUSTYPE(bustype)));
+		return NULL;
+	}
+
+	/* bus/core/clk setup for register access */
+	if (!si_buscore_prep(sii, bustype, devid, sdh)) {
+		SI_ERROR(("si_doattach: si_core_clk_prep failed %d\n",
+			  bustype));
+		return NULL;
+	}
+
+	/* ChipID recognition.
+	 *   We assume we can read chipid at offset 0 from the regs arg.
+	 *   If we add other chiptypes (or if we need to support old sdio hosts w/o chipcommon),
+	 *   some way of recognizing them needs to be added here.
+	 */
+	w = R_REG(osh, &cc->chipid);
+	sih->socitype = (w & CID_TYPE_MASK) >> CID_TYPE_SHIFT;
+	/* Might as wll fill in chip id rev & pkg */
+	sih->chip = w & CID_ID_MASK;
+	sih->chiprev = (w & CID_REV_MASK) >> CID_REV_SHIFT;
+	sih->chippkg = (w & CID_PKG_MASK) >> CID_PKG_SHIFT;
+
+	if ((CHIPID(sih->chip) == BCM4329_CHIP_ID) && (sih->chiprev == 0) &&
+	    (sih->chippkg != BCM4329_289PIN_PKG_ID)) {
+		sih->chippkg = BCM4329_182PIN_PKG_ID;
+	}
+	sih->issim = IS_SIM(sih->chippkg);
+
+	/* scan for cores */
+	/* SI_MSG(("Found chip type SB (0x%08x)\n", w)); */
+	sb_scan(&sii->pub, regs, devid);
+
+	/* no cores found, bail out */
+	if (sii->numcores == 0) {
+		SI_ERROR(("si_doattach: could not find any cores\n"));
+		return NULL;
+	}
+	/* bus/core/clk setup */
+	origidx = SI_CC_IDX;
+	if (!si_buscore_setup(sii, cc, bustype, savewin, &origidx, regs)) {
+		SI_ERROR(("si_doattach: si_buscore_setup failed\n"));
+		goto exit;
+	}
+
+	/* Init nvram from flash if it exists */
+	nvram_init((void *)&(sii->pub));
+
+	/* Init nvram from sprom/otp if they exist */
+	if (srom_var_init
+	    (&sii->pub, BUSTYPE(bustype), regs, sii->osh, vars, varsz)) {
+		SI_ERROR(("si_doattach: srom_var_init failed: bad srom\n"));
+		goto exit;
+	}
+	pvars = vars ? *vars : NULL;
+	si_nvram_process(sii, pvars);
+
+	/* === NVRAM, clock is ready === */
+
+	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+	W_REG(osh, &cc->gpiopullup, 0);
+	W_REG(osh, &cc->gpiopulldown, 0);
+	sb_setcoreidx(sih, origidx);
+
+	/* PMU specific initializations */
+	if (PMUCTL_ENAB(sih)) {
+		uint32 xtalfreq;
+		si_pmu_init(sih, sii->osh);
+		si_pmu_chip_init(sih, sii->osh);
+		xtalfreq = getintvar(pvars, "xtalfreq");
+		/* If xtalfreq var not available, try to measure it */
+		if (xtalfreq == 0)
+			xtalfreq = si_pmu_measure_alpclk(sih, sii->osh);
+		si_pmu_pll_init(sih, sii->osh, xtalfreq);
+		si_pmu_res_init(sih, sii->osh);
+		si_pmu_swreg_init(sih, sii->osh);
+	}
+
+	/* setup the GPIO based LED powersave register */
+	if ((w = getintvar(pvars, "leddc")) == 0)
+		w = DEFAULT_GPIOTIMERVAL;
+	sb_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+
+#ifdef BCMDBG
+	/* clear any previous epidiag-induced target abort */
+	sb_taclear(sih, FALSE);
+#endif				/* BCMDBG */
+
+	return (sii);
+
+ exit:
+	return NULL;
+}
+
+#else				/* BCMSDIO */
+static si_info_t *BCMATTACHFN(si_doattach) (si_info_t * sii, uint devid,
+					    osl_t * osh, void *regs,
+					    uint bustype, void *sdh,
+					    char **vars, uint * varsz) {
+	struct si_pub *sih = &sii->pub;
+	uint32 w, savewin;
+	chipcregs_t *cc;
+	char *pvars = NULL;
+	uint origidx;
+
+	ASSERT(GOODREGS(regs));
+
+	bzero((uchar *) sii, sizeof(si_info_t));
+
+	savewin = 0;
+
+	sih->buscoreidx = BADIDX;
+
+	sii->curmap = regs;
+	sii->sdh = sdh;
+	sii->osh = osh;
+
+	/* check to see if we are a si core mimic'ing a pci core */
+	if ((bustype == PCI_BUS) &&
+	    (OSL_PCI_READ_CONFIG(sii->osh, PCI_SPROM_CONTROL, sizeof(uint32)) ==
+	     0xffffffff)) {
+		SI_ERROR(("%s: incoming bus is PCI but it's a lie, switching to SI " "devid:0x%x\n", __func__, devid));
+		bustype = SI_BUS;
+	}
+
+	/* find Chipcommon address */
+	if (bustype == PCI_BUS) {
+		savewin =
+		    OSL_PCI_READ_CONFIG(sii->osh, PCI_BAR0_WIN, sizeof(uint32));
+		if (!GOODCOREADDR(savewin, SI_ENUM_BASE))
+			savewin = SI_ENUM_BASE;
+		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_BAR0_WIN, 4, SI_ENUM_BASE);
+		cc = (chipcregs_t *) regs;
+	} else {
+		cc = (chipcregs_t *) REG_MAP(SI_ENUM_BASE, SI_CORE_SIZE);
+	}
+
+	sih->bustype = bustype;
+	if (bustype != BUSTYPE(bustype)) {
+		SI_ERROR(("si_doattach: bus type %d does not match configured bus type %d\n", bustype, BUSTYPE(bustype)));
+		return NULL;
+	}
+
+	/* bus/core/clk setup for register access */
+	if (!si_buscore_prep(sii, bustype, devid, sdh)) {
+		SI_ERROR(("si_doattach: si_core_clk_prep failed %d\n",
+			  bustype));
+		return NULL;
+	}
+
+	/* ChipID recognition.
+	 *   We assume we can read chipid at offset 0 from the regs arg.
+	 *   If we add other chiptypes (or if we need to support old sdio hosts w/o chipcommon),
+	 *   some way of recognizing them needs to be added here.
+	 */
+	w = R_REG(osh, &cc->chipid);
+	sih->socitype = (w & CID_TYPE_MASK) >> CID_TYPE_SHIFT;
+	/* Might as wll fill in chip id rev & pkg */
+	sih->chip = w & CID_ID_MASK;
+	sih->chiprev = (w & CID_REV_MASK) >> CID_REV_SHIFT;
+	sih->chippkg = (w & CID_PKG_MASK) >> CID_PKG_SHIFT;
+
+	sih->issim = IS_SIM(sih->chippkg);
+
+	/* scan for cores */
+	if (CHIPTYPE(sii->pub.socitype) == SOCI_AI) {
+		SI_MSG(("Found chip type AI (0x%08x)\n", w));
+		/* pass chipc address instead of original core base */
+		ai_scan(&sii->pub, (void *)(uintptr) cc, devid);
+	} else {
+		SI_ERROR(("Found chip of unknown type (0x%08x)\n", w));
+		return NULL;
+	}
+	/* no cores found, bail out */
+	if (sii->numcores == 0) {
+		SI_ERROR(("si_doattach: could not find any cores\n"));
+		return NULL;
+	}
+	/* bus/core/clk setup */
+	origidx = SI_CC_IDX;
+	if (!si_buscore_setup(sii, cc, bustype, savewin, &origidx, regs)) {
+		SI_ERROR(("si_doattach: si_buscore_setup failed\n"));
+		goto exit;
+	}
+
+	/* assume current core is CC */
+	if ((sii->pub.ccrev == 0x25)
+	    &&
+	    ((CHIPID(sih->chip) == BCM43236_CHIP_ID
+	      || CHIPID(sih->chip) == BCM43235_CHIP_ID
+	      || CHIPID(sih->chip) == BCM43238_CHIP_ID)
+	     && (CHIPREV(sii->pub.chiprev) <= 2))) {
+
+		if ((cc->chipstatus & CST43236_BP_CLK) != 0) {
+			uint clkdiv;
+			clkdiv = R_REG(osh, &cc->clkdiv);
+			/* otp_clk_div is even number, 120/14 < 9mhz */
+			clkdiv = (clkdiv & ~CLKD_OTP) | (14 << CLKD_OTP_SHIFT);
+			W_REG(osh, &cc->clkdiv, clkdiv);
+			SI_ERROR(("%s: set clkdiv to %x\n", __func__, clkdiv));
+		}
+		OSL_DELAY(10);
+	}
+
+	/* Init nvram from flash if it exists */
+	nvram_init((void *)&(sii->pub));
+
+	/* Init nvram from sprom/otp if they exist */
+	if (srom_var_init
+	    (&sii->pub, BUSTYPE(bustype), regs, sii->osh, vars, varsz)) {
+		SI_ERROR(("si_doattach: srom_var_init failed: bad srom\n"));
+		goto exit;
+	}
+	pvars = vars ? *vars : NULL;
+	si_nvram_process(sii, pvars);
+
+	/* === NVRAM, clock is ready === */
+	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+	W_REG(osh, &cc->gpiopullup, 0);
+	W_REG(osh, &cc->gpiopulldown, 0);
+	si_setcoreidx(sih, origidx);
+
+	/* PMU specific initializations */
+	if (PMUCTL_ENAB(sih)) {
+		uint32 xtalfreq;
+		si_pmu_init(sih, sii->osh);
+		si_pmu_chip_init(sih, sii->osh);
+		xtalfreq = getintvar(pvars, "xtalfreq");
+		/* If xtalfreq var not available, try to measure it */
+		if (xtalfreq == 0)
+			xtalfreq = si_pmu_measure_alpclk(sih, sii->osh);
+		si_pmu_pll_init(sih, sii->osh, xtalfreq);
+		si_pmu_res_init(sih, sii->osh);
+		si_pmu_swreg_init(sih, sii->osh);
+	}
+
+	/* setup the GPIO based LED powersave register */
+	if ((w = getintvar(pvars, "leddc")) == 0)
+		w = DEFAULT_GPIOTIMERVAL;
+	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimerval), ~0, w);
+
+	if (PCIE(sii)) {
+		ASSERT(sii->pch != NULL);
+		pcicore_attach(sii->pch, pvars, SI_DOATTACH);
+	}
+
+	if ((CHIPID(sih->chip) == BCM43224_CHIP_ID) ||
+	    (CHIPID(sih->chip) == BCM43421_CHIP_ID)) {
+		/* enable 12 mA drive strenth for 43224 and set chipControl register bit 15 */
+		if (CHIPREV(sih->chiprev) == 0) {
+			SI_MSG(("Applying 43224A0 WARs\n"));
+			si_corereg(sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, chipcontrol),
+				   CCTRL43224_GPIO_TOGGLE,
+				   CCTRL43224_GPIO_TOGGLE);
+			si_pmu_chipcontrol(sih, 0, CCTRL_43224A0_12MA_LED_DRIVE,
+					   CCTRL_43224A0_12MA_LED_DRIVE);
+		}
+		if (CHIPREV(sih->chiprev) >= 1) {
+			SI_MSG(("Applying 43224B0+ WARs\n"));
+			si_pmu_chipcontrol(sih, 0, CCTRL_43224B0_12MA_LED_DRIVE,
+					   CCTRL_43224B0_12MA_LED_DRIVE);
+		}
+	}
+
+	if (CHIPID(sih->chip) == BCM4313_CHIP_ID) {
+		/* enable 12 mA drive strenth for 4313 and set chipControl register bit 1 */
+		SI_MSG(("Applying 4313 WARs\n"));
+		si_pmu_chipcontrol(sih, 0, CCTRL_4313_12MA_LED_DRIVE,
+				   CCTRL_4313_12MA_LED_DRIVE);
+	}
+
+	if (CHIPID(sih->chip) == BCM4331_CHIP_ID) {
+		/* Enable Ext PA lines depending on chip package option */
+		si_chipcontrl_epa4331(sih, TRUE);
+	}
+
+	return (sii);
+ exit:
+	if (BUSTYPE(sih->bustype) == PCI_BUS) {
+		if (sii->pch)
+			pcicore_deinit(sii->pch);
+		sii->pch = NULL;
+	}
+
+	return NULL;
+}
+#endif				/* BCMSDIO */
+
+/* may be called with core in reset */
+void BCMATTACHFN(si_detach) (si_t * sih) {
+	si_info_t *sii;
+	uint idx;
+
+	struct si_pub *si_local = NULL;
+	bcopy(&sih, &si_local, sizeof(si_t **));
+
+	sii = SI_INFO(sih);
+
+	if (sii == NULL)
+		return;
+
+	if (BUSTYPE(sih->bustype) == SI_BUS)
+		for (idx = 0; idx < SI_MAXCORES; idx++)
+			if (sii->regs[idx]) {
+				REG_UNMAP(sii->regs[idx]);
+				sii->regs[idx] = NULL;
+			}
+
+	nvram_exit((void *)si_local);	/* free up nvram buffers */
+
+	if (BUSTYPE(sih->bustype) == PCI_BUS) {
+		if (sii->pch)
+			pcicore_deinit(sii->pch);
+		sii->pch = NULL;
+	}
+#if !defined(BCMBUSTYPE) || (BCMBUSTYPE == SI_BUS)
+	if (sii != &ksii)
+#endif				/* !BCMBUSTYPE || (BCMBUSTYPE == SI_BUS) */
+		MFREE(sii->osh, sii, sizeof(si_info_t));
+}
+
+void *si_osh(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	return sii->osh;
+}
+
+void si_setosh(si_t * sih, osl_t * osh)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	if (sii->osh != NULL) {
+		SI_ERROR(("osh is already set....\n"));
+		ASSERT(!sii->osh);
+	}
+	sii->osh = osh;
+}
+
+/* register driver interrupt disabling and restoring callback functions */
+void
+si_register_intr_callback(si_t * sih, void *intrsoff_fn, void *intrsrestore_fn,
+			  void *intrsenabled_fn, void *intr_arg)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	sii->intr_arg = intr_arg;
+	sii->intrsoff_fn = (si_intrsoff_t) intrsoff_fn;
+	sii->intrsrestore_fn = (si_intrsrestore_t) intrsrestore_fn;
+	sii->intrsenabled_fn = (si_intrsenabled_t) intrsenabled_fn;
+	/* save current core id.  when this function called, the current core
+	 * must be the core which provides driver functions(il, et, wl, etc.)
+	 */
+	sii->dev_coreid = sii->coreid[sii->curidx];
+}
+
+void si_deregister_intr_callback(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	sii->intrsoff_fn = NULL;
+}
+
+uint si_intflag(si_t * sih)
+{
+	si_info_t *sii = SI_INFO(sih);
+
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return R_REG(sii->osh,
+			     ((uint32 *) (uintptr) (sii->oob_router +
+						    OOB_STATUSA)));
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+uint si_flag(si_t * sih)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_flag(sih);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+void si_setint(si_t * sih, int siflag)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		ai_setint(sih, siflag);
+	else
+		ASSERT(0);
+}
+
+#ifndef BCMSDIO
+uint si_coreid(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	return sii->coreid[sii->curidx];
+}
+#endif
+
+uint si_coreidx(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	return sii->curidx;
+}
+
+/* return the core-type instantiation # of the current core */
+uint si_coreunit(si_t * sih)
+{
+	si_info_t *sii;
+	uint idx;
+	uint coreid;
+	uint coreunit;
+	uint i;
+
+	sii = SI_INFO(sih);
+	coreunit = 0;
+
+	idx = sii->curidx;
+
+	ASSERT(GOODREGS(sii->curmap));
+	coreid = si_coreid(sih);
+
+	/* count the cores of our type */
+	for (i = 0; i < idx; i++)
+		if (sii->coreid[i] == coreid)
+			coreunit++;
+
+	return (coreunit);
+}
+
+uint si_corevendor(si_t * sih)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_corevendor(sih);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+bool si_backplane64(si_t * sih)
+{
+	return ((sih->cccaps & CC_CAP_BKPLN64) != 0);
+}
+
+#ifndef BCMSDIO
+uint si_corerev(si_t * sih)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_corerev(sih);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+#endif
+
+/* return index of coreid or BADIDX if not found */
+uint si_findcoreidx(si_t * sih, uint coreid, uint coreunit)
+{
+	si_info_t *sii;
+	uint found;
+	uint i;
+
+	sii = SI_INFO(sih);
+
+	found = 0;
+
+	for (i = 0; i < sii->numcores; i++)
+		if (sii->coreid[i] == coreid) {
+			if (found == coreunit)
+				return (i);
+			found++;
+		}
+
+	return (BADIDX);
+}
+
+/* return list of found cores */
+uint si_corelist(si_t * sih, uint coreid[])
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	bcopy((uchar *) sii->coreid, (uchar *) coreid,
+	      (sii->numcores * sizeof(uint)));
+	return (sii->numcores);
+}
+
+/* return current register mapping */
+void *si_coreregs(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	ASSERT(GOODREGS(sii->curmap));
+
+	return (sii->curmap);
+}
+
+/*
+ * This function changes logical "focus" to the indicated core;
+ * must be called with interrupts off.
+ * Moreover, callers should keep interrupts off during switching out of and back to d11 core
+ */
+void *si_setcore(si_t * sih, uint coreid, uint coreunit)
+{
+	uint idx;
+
+	idx = si_findcoreidx(sih, coreid, coreunit);
+	if (!GOODIDX(idx))
+		return (NULL);
+
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_setcoreidx(sih, idx);
+	else {
+#ifdef BCMSDIO
+		return sb_setcoreidx(sih, idx);
+#else
+		ASSERT(0);
+		return NULL;
+#endif
+	}
+}
+
+#ifndef BCMSDIO
+void *si_setcoreidx(si_t * sih, uint coreidx)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_setcoreidx(sih, coreidx);
+	else {
+		ASSERT(0);
+		return NULL;
+	}
+}
+#endif
+
+/* Turn off interrupt as required by sb_setcore, before switch core */
+void *si_switch_core(si_t * sih, uint coreid, uint * origidx, uint * intr_val)
+{
+	void *cc;
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (SI_FAST(sii)) {
+		/* Overloading the origidx variable to remember the coreid,
+		 * this works because the core ids cannot be confused with
+		 * core indices.
+		 */
+		*origidx = coreid;
+		if (coreid == CC_CORE_ID)
+			return (void *)CCREGS_FAST(sii);
+		else if (coreid == sih->buscoretype)
+			return (void *)PCIEREGS(sii);
+	}
+	INTR_OFF(sii, *intr_val);
+	*origidx = sii->curidx;
+	cc = si_setcore(sih, coreid, 0);
+	ASSERT(cc != NULL);
+
+	return cc;
+}
+
+/* restore coreidx and restore interrupt */
+void si_restore_core(si_t * sih, uint coreid, uint intr_val)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	if (SI_FAST(sii)
+	    && ((coreid == CC_CORE_ID) || (coreid == sih->buscoretype)))
+		return;
+
+	si_setcoreidx(sih, coreid);
+	INTR_RESTORE(sii, intr_val);
+}
+
+int si_numaddrspaces(si_t * sih)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_numaddrspaces(sih);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+uint32 si_addrspace(si_t * sih, uint asidx)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_addrspace(sih, asidx);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+uint32 si_addrspacesize(si_t * sih, uint asidx)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_addrspacesize(sih, asidx);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+uint32 si_core_cflags(si_t * sih, uint32 mask, uint32 val)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_core_cflags(sih, mask, val);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+void si_core_cflags_wo(si_t * sih, uint32 mask, uint32 val)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		ai_core_cflags_wo(sih, mask, val);
+	else
+		ASSERT(0);
+}
+
+uint32 si_core_sflags(si_t * sih, uint32 mask, uint32 val)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_core_sflags(sih, mask, val);
+	else {
+		ASSERT(0);
+		return 0;
+	}
+}
+
+bool si_iscoreup(si_t * sih)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_iscoreup(sih);
+	else {
+#ifdef BCMSDIO
+		return sb_iscoreup(sih);
+#else
+		ASSERT(0);
+		return FALSE;
+#endif
+	}
+}
+
+void si_write_wrapperreg(si_t * sih, uint32 offset, uint32 val)
+{
+	/* only for 4319, no requirement for SOCI_SB */
+	if (CHIPTYPE(sih->socitype) == SOCI_AI) {
+		ai_write_wrap_reg(sih, offset, val);
+	}
+}
+
+uint si_corereg(si_t * sih, uint coreidx, uint regoff, uint mask, uint val)
+{
+
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		return ai_corereg(sih, coreidx, regoff, mask, val);
+	else {
+#ifdef BCMSDIO
+		return sb_corereg(sih, coreidx, regoff, mask, val);
+#else
+		ASSERT(0);
+		return 0;
+#endif
+	}
+}
+
+void si_core_disable(si_t * sih, uint32 bits)
+{
+
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		ai_core_disable(sih, bits);
+#ifdef BCMSDIO
+	else
+		sb_core_disable(sih, bits);
+#endif
+}
+
+void si_core_reset(si_t * sih, uint32 bits, uint32 resetbits)
+{
+	if (CHIPTYPE(sih->socitype) == SOCI_AI)
+		ai_core_reset(sih, bits, resetbits);
+#ifdef BCMSDIO
+	else
+		sb_core_reset(sih, bits, resetbits);
+#endif
+}
+
+/* Run bist on current core. Caller needs to take care of core-specific bist hazards */
+int si_corebist(si_t * sih)
+{
+	uint32 cflags;
+	int result = 0;
+
+	/* Read core control flags */
+	cflags = si_core_cflags(sih, 0, 0);
+
+	/* Set bist & fgc */
+	si_core_cflags(sih, ~0, (SICF_BIST_EN | SICF_FGC));
+
+	/* Wait for bist done */
+	SPINWAIT(((si_core_sflags(sih, 0, 0) & SISF_BIST_DONE) == 0), 100000);
+
+	if (si_core_sflags(sih, 0, 0) & SISF_BIST_ERROR)
+		result = BCME_ERROR;
+
+	/* Reset core control flags */
+	si_core_cflags(sih, 0xffff, cflags);
+
+	return result;
+}
+
+static uint32 BCMINITFN(factor6) (uint32 x) {
+	switch (x) {
+	case CC_F6_2:
+		return 2;
+	case CC_F6_3:
+		return 3;
+	case CC_F6_4:
+		return 4;
+	case CC_F6_5:
+		return 5;
+	case CC_F6_6:
+		return 6;
+	case CC_F6_7:
+		return 7;
+	default:
+		return 0;
+	}
+}
+
+/* calculate the speed the SI would run at given a set of clockcontrol values */
+uint32 BCMINITFN(si_clock_rate) (uint32 pll_type, uint32 n, uint32 m) {
+	uint32 n1, n2, clock, m1, m2, m3, mc;
+
+	n1 = n & CN_N1_MASK;
+	n2 = (n & CN_N2_MASK) >> CN_N2_SHIFT;
+
+	if (pll_type == PLL_TYPE6) {
+		if (m & CC_T6_MMASK)
+			return CC_T6_M1;
+		else
+			return CC_T6_M0;
+	} else if ((pll_type == PLL_TYPE1) ||
+		   (pll_type == PLL_TYPE3) ||
+		   (pll_type == PLL_TYPE4) || (pll_type == PLL_TYPE7)) {
+		n1 = factor6(n1);
+		n2 += CC_F5_BIAS;
+	} else if (pll_type == PLL_TYPE2) {
+		n1 += CC_T2_BIAS;
+		n2 += CC_T2_BIAS;
+		ASSERT((n1 >= 2) && (n1 <= 7));
+		ASSERT((n2 >= 5) && (n2 <= 23));
+	} else if (pll_type == PLL_TYPE5) {
+		return (100000000);
+	} else
+		ASSERT(0);
+	/* PLL types 3 and 7 use BASE2 (25Mhz) */
+	if ((pll_type == PLL_TYPE3) || (pll_type == PLL_TYPE7)) {
+		clock = CC_CLOCK_BASE2 * n1 * n2;
+	} else
+		clock = CC_CLOCK_BASE1 * n1 * n2;
+
+	if (clock == 0)
+		return 0;
+
+	m1 = m & CC_M1_MASK;
+	m2 = (m & CC_M2_MASK) >> CC_M2_SHIFT;
+	m3 = (m & CC_M3_MASK) >> CC_M3_SHIFT;
+	mc = (m & CC_MC_MASK) >> CC_MC_SHIFT;
+
+	if ((pll_type == PLL_TYPE1) ||
+	    (pll_type == PLL_TYPE3) ||
+	    (pll_type == PLL_TYPE4) || (pll_type == PLL_TYPE7)) {
+		m1 = factor6(m1);
+		if ((pll_type == PLL_TYPE1) || (pll_type == PLL_TYPE3))
+			m2 += CC_F5_BIAS;
+		else
+			m2 = factor6(m2);
+		m3 = factor6(m3);
+
+		switch (mc) {
+		case CC_MC_BYPASS:
+			return (clock);
+		case CC_MC_M1:
+			return (clock / m1);
+		case CC_MC_M1M2:
+			return (clock / (m1 * m2));
+		case CC_MC_M1M2M3:
+			return (clock / (m1 * m2 * m3));
+		case CC_MC_M1M3:
+			return (clock / (m1 * m3));
+		default:
+			return (0);
+		}
+	} else {
+		ASSERT(pll_type == PLL_TYPE2);
+
+		m1 += CC_T2_BIAS;
+		m2 += CC_T2M2_BIAS;
+		m3 += CC_T2_BIAS;
+		ASSERT((m1 >= 2) && (m1 <= 7));
+		ASSERT((m2 >= 3) && (m2 <= 10));
+		ASSERT((m3 >= 2) && (m3 <= 7));
+
+		if ((mc & CC_T2MC_M1BYP) == 0)
+			clock /= m1;
+		if ((mc & CC_T2MC_M2BYP) == 0)
+			clock /= m2;
+		if ((mc & CC_T2MC_M3BYP) == 0)
+			clock /= m3;
+
+		return (clock);
+	}
+}
+
+uint32 BCMINITFN(si_clock) (si_t * sih) {
+	si_info_t *sii;
+	chipcregs_t *cc;
+	uint32 n, m;
+	uint idx;
+	uint32 pll_type, rate;
+	uint intr_val = 0;
+
+	sii = SI_INFO(sih);
+	INTR_OFF(sii, intr_val);
+	if (PMUCTL_ENAB(sih)) {
+		rate = si_pmu_si_clock(sih, sii->osh);
+		goto exit;
+	}
+
+	idx = sii->curidx;
+	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+	ASSERT(cc != NULL);
+
+	n = R_REG(sii->osh, &cc->clockcontrol_n);
+	pll_type = sih->cccaps & CC_CAP_PLL_MASK;
+	if (pll_type == PLL_TYPE6)
+		m = R_REG(sii->osh, &cc->clockcontrol_m3);
+	else if (pll_type == PLL_TYPE3)
+		m = R_REG(sii->osh, &cc->clockcontrol_m2);
+	else
+		m = R_REG(sii->osh, &cc->clockcontrol_sb);
+
+	/* calculate rate */
+	rate = si_clock_rate(pll_type, n, m);
+
+	if (pll_type == PLL_TYPE3)
+		rate = rate / 2;
+
+	/* switch back to previous core */
+	si_setcoreidx(sih, idx);
+ exit:
+	INTR_RESTORE(sii, intr_val);
+
+	return rate;
+}
+
+uint32 BCMINITFN(si_alp_clock) (si_t * sih) {
+	if (PMUCTL_ENAB(sih))
+		return si_pmu_alp_clock(sih, si_osh(sih));
+
+	return ALP_CLOCK;
+}
+
+uint32 BCMINITFN(si_ilp_clock) (si_t * sih) {
+	if (PMUCTL_ENAB(sih))
+		return si_pmu_ilp_clock(sih, si_osh(sih));
+
+	return ILP_CLOCK;
+}
+
+/* set chip watchdog reset timer to fire in 'ticks' */
+void si_watchdog(si_t * sih, uint ticks)
+{
+	uint nb, maxt;
+
+	if (PMUCTL_ENAB(sih)) {
+
+		if ((CHIPID(sih->chip) == BCM4319_CHIP_ID) &&
+		    (CHIPREV(sih->chiprev) == 0) && (ticks != 0)) {
+			si_corereg(sih, SI_CC_IDX,
+				   OFFSETOF(chipcregs_t, clk_ctl_st), ~0, 0x2);
+			si_setcore(sih, USB20D_CORE_ID, 0);
+			si_core_disable(sih, 1);
+			si_setcore(sih, CC_CORE_ID, 0);
+		}
+
+		nb = (sih->ccrev < 26) ? 16 : ((sih->ccrev >= 37) ? 32 : 24);
+		/* The mips compiler uses the sllv instruction,
+		 * so we specially handle the 32-bit case.
+		 */
+		if (nb == 32)
+			maxt = 0xffffffff;
+		else
+			maxt = ((1 << nb) - 1);
+
+		if (ticks == 1)
+			ticks = 2;
+		else if (ticks > maxt)
+			ticks = maxt;
+
+		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, pmuwatchdog),
+			   ~0, ticks);
+	} else {
+		/* make sure we come up in fast clock mode; or if clearing, clear clock */
+		si_clkctl_cc(sih, ticks ? CLK_FAST : CLK_DYNAMIC);
+		maxt = (1 << 28) - 1;
+		if (ticks > maxt)
+			ticks = maxt;
+
+		si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, watchdog), ~0,
+			   ticks);
+	}
+}
+
+/* trigger watchdog reset after ms milliseconds */
+void si_watchdog_ms(si_t * sih, uint32 ms)
+{
+	si_watchdog(sih, wd_msticks * ms);
+}
+
+uint16 BCMATTACHFN(si_d11_devid) (si_t * sih) {
+	si_info_t *sii = SI_INFO(sih);
+	uint16 device;
+
+	/* normal case: nvram variable with devpath->devid->wl0id */
+	if ((device = (uint16) si_getdevpathintvar(sih, "devid")) != 0) ;
+	/* Get devid from OTP/SPROM depending on where the SROM is read */
+	else if ((device = (uint16) getintvar(sii->vars, "devid")) != 0) ;
+	/* no longer support wl0id, but keep the code here for backward compatibility. */
+	else if ((device = (uint16) getintvar(sii->vars, "wl0id")) != 0) ;
+	else
+		/* ignore it */
+		device = 0xffff;
+
+	return device;
+}
+
+/* return the slow clock source - LPO, XTAL, or PCI */
+static uint si_slowclk_src(si_info_t * sii)
+{
+	chipcregs_t *cc;
+
+	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);
+
+	if (sii->pub.ccrev < 6) {
+		if ((BUSTYPE(sii->pub.bustype) == PCI_BUS) &&
+		    (OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32))
+		     & PCI_CFG_GPIO_SCS))
+			return (SCC_SS_PCI);
+		else
+			return (SCC_SS_XTAL);
+	} else if (sii->pub.ccrev < 10) {
+		cc = (chipcregs_t *) si_setcoreidx(&sii->pub, sii->curidx);
+		return (R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_SS_MASK);
+	} else			/* Insta-clock */
+		return (SCC_SS_XTAL);
+}
+
+/* return the ILP (slowclock) min or max frequency */
+static uint si_slowclk_freq(si_info_t * sii, bool max_freq, chipcregs_t * cc)
+{
+	uint32 slowclk;
+	uint div;
+
+	ASSERT(SI_FAST(sii) || si_coreid(&sii->pub) == CC_CORE_ID);
+
+	/* shouldn't be here unless we've established the chip has dynamic clk control */
+	ASSERT(R_REG(sii->osh, &cc->capabilities) & CC_CAP_PWR_CTL);
+
+	slowclk = si_slowclk_src(sii);
+	if (sii->pub.ccrev < 6) {
+		if (slowclk == SCC_SS_PCI)
+			return (max_freq ? (PCIMAXFREQ / 64)
+				: (PCIMINFREQ / 64));
+		else
+			return (max_freq ? (XTALMAXFREQ / 32)
+				: (XTALMINFREQ / 32));
+	} else if (sii->pub.ccrev < 10) {
+		div = 4 *
+		    (((R_REG(sii->osh, &cc->slow_clk_ctl) & SCC_CD_MASK) >>
+		      SCC_CD_SHIFT) + 1);
+		if (slowclk == SCC_SS_LPO)
+			return (max_freq ? LPOMAXFREQ : LPOMINFREQ);
+		else if (slowclk == SCC_SS_XTAL)
+			return (max_freq ? (XTALMAXFREQ / div)
+				: (XTALMINFREQ / div));
+		else if (slowclk == SCC_SS_PCI)
+			return (max_freq ? (PCIMAXFREQ / div)
+				: (PCIMINFREQ / div));
+		else
+			ASSERT(0);
+	} else {
+		/* Chipc rev 10 is InstaClock */
+		div = R_REG(sii->osh, &cc->system_clk_ctl) >> SYCC_CD_SHIFT;
+		div = 4 * (div + 1);
+		return (max_freq ? XTALMAXFREQ : (XTALMINFREQ / div));
+	}
+	return (0);
+}
+
+static void BCMINITFN(si_clkctl_setdelay) (si_info_t * sii, void *chipcregs) {
+	chipcregs_t *cc = (chipcregs_t *) chipcregs;
+	uint slowmaxfreq, pll_delay, slowclk;
+	uint pll_on_delay, fref_sel_delay;
+
+	pll_delay = PLL_DELAY;
+
+	/* If the slow clock is not sourced by the xtal then add the xtal_on_delay
+	 * since the xtal will also be powered down by dynamic clk control logic.
+	 */
+
+	slowclk = si_slowclk_src(sii);
+	if (slowclk != SCC_SS_XTAL)
+		pll_delay += XTAL_ON_DELAY;
+
+	/* Starting with 4318 it is ILP that is used for the delays */
+	slowmaxfreq =
+	    si_slowclk_freq(sii, (sii->pub.ccrev >= 10) ? FALSE : TRUE, cc);
+
+	pll_on_delay = ((slowmaxfreq * pll_delay) + 999999) / 1000000;
+	fref_sel_delay = ((slowmaxfreq * FREF_DELAY) + 999999) / 1000000;
+
+	W_REG(sii->osh, &cc->pll_on_delay, pll_on_delay);
+	W_REG(sii->osh, &cc->fref_sel_delay, fref_sel_delay);
+}
+
+/* initialize power control delay registers */
+void BCMINITFN(si_clkctl_init) (si_t * sih) {
+	si_info_t *sii;
+	uint origidx = 0;
+	chipcregs_t *cc;
+	bool fast;
+
+	if (!CCCTL_ENAB(sih))
+		return;
+
+	sii = SI_INFO(sih);
+	fast = SI_FAST(sii);
+	if (!fast) {
+		origidx = sii->curidx;
+		if ((cc =
+		     (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0)) == NULL)
+			return;
+	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
+		return;
+	ASSERT(cc != NULL);
+
+	/* set all Instaclk chip ILP to 1 MHz */
+	if (sih->ccrev >= 10)
+		SET_REG(sii->osh, &cc->system_clk_ctl, SYCC_CD_MASK,
+			(ILP_DIV_1MHZ << SYCC_CD_SHIFT));
+
+	si_clkctl_setdelay(sii, (void *)(uintptr) cc);
+
+	if (!fast)
+		si_setcoreidx(sih, origidx);
+}
+
+/* return the value suitable for writing to the dot11 core FAST_PWRUP_DELAY register */
+uint16 BCMINITFN(si_clkctl_fast_pwrup_delay) (si_t * sih) {
+	si_info_t *sii;
+	uint origidx = 0;
+	chipcregs_t *cc;
+	uint slowminfreq;
+	uint16 fpdelay;
+	uint intr_val = 0;
+	bool fast;
+
+	sii = SI_INFO(sih);
+	if (PMUCTL_ENAB(sih)) {
+		INTR_OFF(sii, intr_val);
+		fpdelay = si_pmu_fast_pwrup_delay(sih, sii->osh);
+		INTR_RESTORE(sii, intr_val);
+		return fpdelay;
+	}
+
+	if (!CCCTL_ENAB(sih))
+		return 0;
+
+	fast = SI_FAST(sii);
+	fpdelay = 0;
+	if (!fast) {
+		origidx = sii->curidx;
+		INTR_OFF(sii, intr_val);
+		if ((cc =
+		     (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0)) == NULL)
+			goto done;
+	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
+		goto done;
+	ASSERT(cc != NULL);
+
+	slowminfreq = si_slowclk_freq(sii, FALSE, cc);
+	fpdelay = (((R_REG(sii->osh, &cc->pll_on_delay) + 2) * 1000000) +
+		   (slowminfreq - 1)) / slowminfreq;
+
+ done:
+	if (!fast) {
+		si_setcoreidx(sih, origidx);
+		INTR_RESTORE(sii, intr_val);
+	}
+	return fpdelay;
+}
+
+/* turn primary xtal and/or pll off/on */
+int si_clkctl_xtal(si_t * sih, uint what, bool on)
+{
+	si_info_t *sii;
+	uint32 in, out, outen;
+
+	sii = SI_INFO(sih);
+
+	switch (BUSTYPE(sih->bustype)) {
+
+#ifdef BCMSDIO
+	case SDIO_BUS:
+		return (-1);
+#endif				/* BCMSDIO */
+
+	case PCI_BUS:
+		/* pcie core doesn't have any mapping to control the xtal pu */
+		if (PCIE(sii))
+			return -1;
+
+		in = OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_IN, sizeof(uint32));
+		out =
+		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUT, sizeof(uint32));
+		outen =
+		    OSL_PCI_READ_CONFIG(sii->osh, PCI_GPIO_OUTEN,
+					sizeof(uint32));
+
+		/*
+		 * Avoid glitching the clock if GPRS is already using it.
+		 * We can't actually read the state of the PLLPD so we infer it
+		 * by the value of XTAL_PU which *is* readable via gpioin.
+		 */
+		if (on && (in & PCI_CFG_GPIO_XTAL))
+			return (0);
+
+		if (what & XTAL)
+			outen |= PCI_CFG_GPIO_XTAL;
+		if (what & PLL)
+			outen |= PCI_CFG_GPIO_PLL;
+
+		if (on) {
+			/* turn primary xtal on */
+			if (what & XTAL) {
+				out |= PCI_CFG_GPIO_XTAL;
+				if (what & PLL)
+					out |= PCI_CFG_GPIO_PLL;
+				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
+						     sizeof(uint32), out);
+				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUTEN,
+						     sizeof(uint32), outen);
+				OSL_DELAY(XTAL_ON_DELAY);
+			}
+
+			/* turn pll on */
+			if (what & PLL) {
+				out &= ~PCI_CFG_GPIO_PLL;
+				OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
+						     sizeof(uint32), out);
+				OSL_DELAY(2000);
+			}
+		} else {
+			if (what & XTAL)
+				out &= ~PCI_CFG_GPIO_XTAL;
+			if (what & PLL)
+				out |= PCI_CFG_GPIO_PLL;
+			OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUT,
+					     sizeof(uint32), out);
+			OSL_PCI_WRITE_CONFIG(sii->osh, PCI_GPIO_OUTEN,
+					     sizeof(uint32), outen);
+		}
+
+	default:
+		return (-1);
+	}
+
+	return (0);
+}
+
+/*
+ *  clock control policy function throught chipcommon
+ *
+ *    set dynamic clk control mode (forceslow, forcefast, dynamic)
+ *    returns true if we are forcing fast clock
+ *    this is a wrapper over the next internal function
+ *      to allow flexible policy settings for outside caller
+ */
+bool si_clkctl_cc(si_t * sih, uint mode)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (sih->ccrev < 6)
+		return FALSE;
+
+	if (PCI_FORCEHT(sii))
+		return (mode == CLK_FAST);
+
+	return _si_clkctl_cc(sii, mode);
+}
+
+/* clk control mechanism through chipcommon, no policy checking */
+static bool _si_clkctl_cc(si_info_t * sii, uint mode)
+{
+	uint origidx = 0;
+	chipcregs_t *cc;
+	uint32 scc;
+	uint intr_val = 0;
+	bool fast = SI_FAST(sii);
+
+	/* chipcommon cores prior to rev6 don't support dynamic clock control */
+	if (sii->pub.ccrev < 6)
+		return (FALSE);
+
+	/* Chips with ccrev 10 are EOL and they don't have SYCC_HR which we use below */
+	ASSERT(sii->pub.ccrev != 10);
+
+	if (!fast) {
+		INTR_OFF(sii, intr_val);
+		origidx = sii->curidx;
+
+		if ((BUSTYPE(sii->pub.bustype) == SI_BUS) &&
+		    si_setcore(&sii->pub, MIPS33_CORE_ID, 0) &&
+		    (si_corerev(&sii->pub) <= 7) && (sii->pub.ccrev >= 10))
+			goto done;
+
+		cc = (chipcregs_t *) si_setcore(&sii->pub, CC_CORE_ID, 0);
+	} else if ((cc = (chipcregs_t *) CCREGS_FAST(sii)) == NULL)
+		goto done;
+	ASSERT(cc != NULL);
+
+	if (!CCCTL_ENAB(&sii->pub) && (sii->pub.ccrev < 20))
+		goto done;
+
+	switch (mode) {
+	case CLK_FAST:		/* FORCEHT, fast (pll) clock */
+		if (sii->pub.ccrev < 10) {
+			/* don't forget to force xtal back on before we clear SCC_DYN_XTAL.. */
+			si_clkctl_xtal(&sii->pub, XTAL, ON);
+			SET_REG(sii->osh, &cc->slow_clk_ctl,
+				(SCC_XC | SCC_FS | SCC_IP), SCC_IP);
+		} else if (sii->pub.ccrev < 20) {
+			OR_REG(sii->osh, &cc->system_clk_ctl, SYCC_HR);
+		} else {
+			OR_REG(sii->osh, &cc->clk_ctl_st, CCS_FORCEHT);
+		}
+
+		/* wait for the PLL */
+		if (PMUCTL_ENAB(&sii->pub)) {
+			uint32 htavail = CCS_HTAVAIL;
+			SPINWAIT(((R_REG(sii->osh, &cc->clk_ctl_st) & htavail)
+				  == 0), PMU_MAX_TRANSITION_DLY);
+			ASSERT(R_REG(sii->osh, &cc->clk_ctl_st) & htavail);
+		} else {
+			OSL_DELAY(PLL_DELAY);
+		}
+		break;
+
+	case CLK_DYNAMIC:	/* enable dynamic clock control */
+		if (sii->pub.ccrev < 10) {
+			scc = R_REG(sii->osh, &cc->slow_clk_ctl);
+			scc &= ~(SCC_FS | SCC_IP | SCC_XC);
+			if ((scc & SCC_SS_MASK) != SCC_SS_XTAL)
+				scc |= SCC_XC;
+			W_REG(sii->osh, &cc->slow_clk_ctl, scc);
+
+			/* for dynamic control, we have to release our xtal_pu "force on" */
+			if (scc & SCC_XC)
+				si_clkctl_xtal(&sii->pub, XTAL, OFF);
+		} else if (sii->pub.ccrev < 20) {
+			/* Instaclock */
+			AND_REG(sii->osh, &cc->system_clk_ctl, ~SYCC_HR);
+		} else {
+			AND_REG(sii->osh, &cc->clk_ctl_st, ~CCS_FORCEHT);
+		}
+		break;
+
+	default:
+		ASSERT(0);
+	}
+
+ done:
+	if (!fast) {
+		si_setcoreidx(&sii->pub, origidx);
+		INTR_RESTORE(sii, intr_val);
+	}
+	return (mode == CLK_FAST);
+}
+
+/* Build device path. Support SI, PCI, and JTAG for now. */
+int BCMATTACHFN(si_devpath) (si_t * sih, char *path, int size) {
+	int slen;
+
+	ASSERT(path != NULL);
+	ASSERT(size >= SI_DEVPATH_BUFSZ);
+
+	if (!path || size <= 0)
+		return -1;
+
+	switch (BUSTYPE(sih->bustype)) {
+	case SI_BUS:
+	case JTAG_BUS:
+		slen = snprintf(path, (size_t) size, "sb/%u/", si_coreidx(sih));
+		break;
+	case PCI_BUS:
+		ASSERT((SI_INFO(sih))->osh != NULL);
+		slen = snprintf(path, (size_t) size, "pci/%u/%u/",
+				OSL_PCI_BUS((SI_INFO(sih))->osh),
+				OSL_PCI_SLOT((SI_INFO(sih))->osh));
+		break;
+
+#ifdef BCMSDIO
+	case SDIO_BUS:
+		SI_ERROR(("si_devpath: device 0 assumed\n"));
+		slen = snprintf(path, (size_t) size, "sd/%u/", si_coreidx(sih));
+		break;
+#endif
+	default:
+		slen = -1;
+		ASSERT(0);
+		break;
+	}
+
+	if (slen < 0 || slen >= size) {
+		path[0] = '\0';
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Get a variable, but only if it has a devpath prefix */
+char *BCMATTACHFN(si_getdevpathvar) (si_t * sih, const char *name) {
+	char varname[SI_DEVPATH_BUFSZ + 32];
+
+	si_devpathvar(sih, varname, sizeof(varname), name);
+
+	return (getvar(NULL, varname));
+}
+
+/* Get a variable, but only if it has a devpath prefix */
+int BCMATTACHFN(si_getdevpathintvar) (si_t * sih, const char *name) {
+#if defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS)
+	return (getintvar(NULL, name));
+#else
+	char varname[SI_DEVPATH_BUFSZ + 32];
+
+	si_devpathvar(sih, varname, sizeof(varname), name);
+
+	return (getintvar(NULL, varname));
+#endif
+}
+
+char *si_getnvramflvar(si_t * sih, const char *name)
+{
+	return (getvar(NULL, name));
+}
+
+/* Concatenate the dev path with a varname into the given 'var' buffer
+ * and return the 'var' pointer.
+ * Nothing is done to the arguments if len == 0 or var is NULL, var is still returned.
+ * On overflow, the first char will be set to '\0'.
+ */
+static char *BCMATTACHFN(si_devpathvar) (si_t * sih, char *var, int len,
+					 const char *name) {
+	uint path_len;
+
+	if (!var || len <= 0)
+		return var;
+
+	if (si_devpath(sih, var, len) == 0) {
+		path_len = strlen(var);
+
+		if (strlen(name) + 1 > (uint) (len - path_len))
+			var[0] = '\0';
+		else
+			strncpy(var + path_len, name, len - path_len - 1);
+	}
+
+	return var;
+}
+
+uint32 si_pciereg(si_t * sih, uint32 offset, uint32 mask, uint32 val, uint type)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (!PCIE(sii)) {
+		SI_ERROR(("%s: Not a PCIE device\n", __func__));
+		return 0;
+	}
+
+	return pcicore_pciereg(sii->pch, offset, mask, val, type);
+}
+
+uint32
+si_pcieserdesreg(si_t * sih, uint32 mdioslave, uint32 offset, uint32 mask,
+		 uint32 val)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (!PCIE(sii)) {
+		SI_ERROR(("%s: Not a PCIE device\n", __func__));
+		return 0;
+	}
+
+	return pcicore_pcieserdesreg(sii->pch, mdioslave, offset, mask, val);
+
+}
+
+/* return TRUE if PCIE capability exists in the pci config space */
+static bool si_ispcie(si_info_t * sii)
+{
+	uint8 cap_ptr;
+
+	if (BUSTYPE(sii->pub.bustype) != PCI_BUS)
+		return FALSE;
+
+	cap_ptr =
+	    pcicore_find_pci_capability(sii->osh, PCI_CAP_PCIECAP_ID, NULL,
+					NULL);
+	if (!cap_ptr)
+		return FALSE;
+
+	return TRUE;
+}
+
+/* Wake-on-wireless-LAN (WOWL) support functions */
+/* Enable PME generation and disable clkreq */
+void si_pci_pmeen(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	pcicore_pmeen(sii->pch);
+}
+
+/* Return TRUE if PME status is set */
+bool si_pci_pmestat(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	return pcicore_pmestat(sii->pch);
+}
+
+/* Disable PME generation, clear the PME status bit if set */
+void si_pci_pmeclr(si_t * sih)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	pcicore_pmeclr(sii->pch);
+}
+
+#ifdef BCMSDIO
+/* initialize the sdio core */
+void si_sdio_init(si_t * sih)
+{
+	si_info_t *sii = SI_INFO(sih);
+
+	if (((sih->buscoretype == PCMCIA_CORE_ID) && (sih->buscorerev >= 8)) ||
+	    (sih->buscoretype == SDIOD_CORE_ID)) {
+		uint idx;
+		sdpcmd_regs_t *sdpregs;
+
+		/* get the current core index */
+		idx = sii->curidx;
+		ASSERT(idx == si_findcoreidx(sih, D11_CORE_ID, 0));
+
+		/* switch to sdio core */
+		if (!
+		    (sdpregs =
+		     (sdpcmd_regs_t *) si_setcore(sih, PCMCIA_CORE_ID, 0)))
+			sdpregs =
+			    (sdpcmd_regs_t *) si_setcore(sih, SDIOD_CORE_ID, 0);
+		ASSERT(sdpregs);
+
+		SI_MSG(("si_sdio_init: For PCMCIA/SDIO Corerev %d, enable ints from core %d " "through SD core %d (%p)\n", sih->buscorerev, idx, sii->curidx, sdpregs));
+
+		/* enable backplane error and core interrupts */
+		W_REG(sii->osh, &sdpregs->hostintmask, I_SBINT);
+		W_REG(sii->osh, &sdpregs->sbintmask,
+		      (I_SB_SERR | I_SB_RESPERR | (1 << idx)));
+
+		/* switch back to previous core */
+		si_setcoreidx(sih, idx);
+	}
+
+	/* enable interrupts */
+	bcmsdh_intr_enable(sii->sdh);
+
+}
+#endif				/* BCMSDIO */
+
+bool BCMATTACHFN(si_pci_war16165) (si_t * sih) {
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	return (PCI(sii) && (sih->buscorerev <= 10));
+}
+
+/* Disable pcie_war_ovr for some platforms (sigh!)
+ * This is for boards that have BFL2_PCIEWAR_OVR set
+ * but are in systems that still want the benefits of ASPM
+ * Note that this should be done AFTER si_doattach
+ */
+void si_pcie_war_ovr_update(si_t * sih, uint8 aspm)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (!PCIE(sii))
+		return;
+
+	pcie_war_ovr_aspm_update(sii->pch, aspm);
+}
+
+/* back door for other module to override chippkg */
+void si_chippkg_set(si_t * sih, uint val)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	sii->pub.chippkg = val;
+}
+
+void BCMINITFN(si_pci_up) (si_t * sih) {
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	/* if not pci bus, we're done */
+	if (BUSTYPE(sih->bustype) != PCI_BUS)
+		return;
+
+	if (PCI_FORCEHT(sii))
+		_si_clkctl_cc(sii, CLK_FAST);
+
+	if (PCIE(sii))
+		pcicore_up(sii->pch, SI_PCIUP);
+
+}
+
+/* Unconfigure and/or apply various WARs when system is going to sleep mode */
+void BCMUNINITFN(si_pci_sleep) (si_t * sih) {
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	pcicore_sleep(sii->pch);
+}
+
+/* Unconfigure and/or apply various WARs when going down */
+void BCMINITFN(si_pci_down) (si_t * sih) {
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	/* if not pci bus, we're done */
+	if (BUSTYPE(sih->bustype) != PCI_BUS)
+		return;
+
+	/* release FORCEHT since chip is going to "down" state */
+	if (PCI_FORCEHT(sii))
+		_si_clkctl_cc(sii, CLK_DYNAMIC);
+
+	pcicore_down(sii->pch, SI_PCIDOWN);
+}
+
+/*
+ * Configure the pci core for pci client (NIC) action
+ * coremask is the bitvec of cores by index to be enabled.
+ */
+void BCMATTACHFN(si_pci_setup) (si_t * sih, uint coremask) {
+	si_info_t *sii;
+	sbpciregs_t *pciregs = NULL;
+	uint32 siflag = 0, w;
+	uint idx = 0;
+
+	sii = SI_INFO(sih);
+
+	if (BUSTYPE(sii->pub.bustype) != PCI_BUS)
+		return;
+
+	ASSERT(PCI(sii) || PCIE(sii));
+	ASSERT(sii->pub.buscoreidx != BADIDX);
+
+	if (PCI(sii)) {
+		/* get current core index */
+		idx = sii->curidx;
+
+		/* we interrupt on this backplane flag number */
+		siflag = si_flag(sih);
+
+		/* switch over to pci core */
+		pciregs =
+		    (sbpciregs_t *) si_setcoreidx(sih, sii->pub.buscoreidx);
+	}
+
+	/*
+	 * Enable sb->pci interrupts.  Assume
+	 * PCI rev 2.3 support was added in pci core rev 6 and things changed..
+	 */
+	if (PCIE(sii) || (PCI(sii) && ((sii->pub.buscorerev) >= 6))) {
+		/* pci config write to set this core bit in PCIIntMask */
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_INT_MASK, sizeof(uint32));
+		w |= (coremask << PCI_SBIM_SHIFT);
+		OSL_PCI_WRITE_CONFIG(sii->osh, PCI_INT_MASK, sizeof(uint32), w);
+	} else {
+		/* set sbintvec bit for our flag number */
+		si_setint(sih, siflag);
+	}
+
+	if (PCI(sii)) {
+		OR_REG(sii->osh, &pciregs->sbtopci2,
+		       (SBTOPCI_PREF | SBTOPCI_BURST));
+		if (sii->pub.buscorerev >= 11) {
+			OR_REG(sii->osh, &pciregs->sbtopci2,
+			       SBTOPCI_RC_READMULTI);
+			w = R_REG(sii->osh, &pciregs->clkrun);
+			W_REG(sii->osh, &pciregs->clkrun,
+			      (w | PCI_CLKRUN_DSBL));
+			w = R_REG(sii->osh, &pciregs->clkrun);
+		}
+
+		/* switch back to previous core */
+		si_setcoreidx(sih, idx);
+	}
+}
+
+uint8 si_pcieclkreq(si_t * sih, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (!(PCIE(sii)))
+		return 0;
+	return pcie_clkreq(sii->pch, mask, val);
+}
+
+uint32 si_pcielcreg(si_t * sih, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (!PCIE(sii))
+		return 0;
+
+	return pcie_lcreg(sii->pch, mask, val);
+}
+
+/* indirect way to read pcie config regs */
+uint si_pcie_readreg(void *sih, uint addrtype, uint offset)
+{
+	return pcie_readreg(((si_info_t *) sih)->osh,
+			    (sbpcieregs_t *) PCIEREGS(((si_info_t *) sih)),
+			    addrtype, offset);
+}
+
+/*
+ * Fixup SROMless PCI device's configuration.
+ * The current core may be changed upon return.
+ */
+int si_pci_fixcfg(si_t * sih)
+{
+	uint origidx, pciidx;
+	sbpciregs_t *pciregs = NULL;
+	sbpcieregs_t *pcieregs = NULL;
+	void *regs = NULL;
+	uint16 val16, *reg16 = NULL;
+
+	si_info_t *sii = SI_INFO(sih);
+
+	ASSERT(BUSTYPE(sii->pub.bustype) == PCI_BUS);
+
+	/* Fixup PI in SROM shadow area to enable the correct PCI core access */
+	/* save the current index */
+	origidx = si_coreidx(&sii->pub);
+
+	/* check 'pi' is correct and fix it if not */
+	if (sii->pub.buscoretype == PCIE_CORE_ID) {
+		pcieregs =
+		    (sbpcieregs_t *) si_setcore(&sii->pub, PCIE_CORE_ID, 0);
+		regs = pcieregs;
+		ASSERT(pcieregs != NULL);
+		reg16 = &pcieregs->sprom[SRSH_PI_OFFSET];
+	} else if (sii->pub.buscoretype == PCI_CORE_ID) {
+		pciregs = (sbpciregs_t *) si_setcore(&sii->pub, PCI_CORE_ID, 0);
+		regs = pciregs;
+		ASSERT(pciregs != NULL);
+		reg16 = &pciregs->sprom[SRSH_PI_OFFSET];
+	}
+	pciidx = si_coreidx(&sii->pub);
+	val16 = R_REG(sii->osh, reg16);
+	if (((val16 & SRSH_PI_MASK) >> SRSH_PI_SHIFT) != (uint16) pciidx) {
+		val16 =
+		    (uint16) (pciidx << SRSH_PI_SHIFT) | (val16 &
+							  ~SRSH_PI_MASK);
+		W_REG(sii->osh, reg16, val16);
+	}
+
+	/* restore the original index */
+	si_setcoreidx(&sii->pub, origidx);
+
+	pcicore_hwup(sii->pch);
+	return 0;
+}
+
+/* change logical "focus" to the gpio core for optimized access */
+void *si_gpiosetcore(si_t * sih)
+{
+	return (si_setcoreidx(sih, SI_CC_IDX));
+}
+
+/* mask&set gpiocontrol bits */
+uint32 si_gpiocontrol(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+{
+	uint regoff;
+
+	regoff = 0;
+
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
+		mask = priority ? (si_gpioreservation & mask) :
+		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
+		val &= mask;
+	}
+
+	regoff = OFFSETOF(chipcregs_t, gpiocontrol);
+	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* mask&set gpio output enable bits */
+uint32 si_gpioouten(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+{
+	uint regoff;
+
+	regoff = 0;
+
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
+		mask = priority ? (si_gpioreservation & mask) :
+		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
+		val &= mask;
+	}
+
+	regoff = OFFSETOF(chipcregs_t, gpioouten);
+	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* mask&set gpio output bits */
+uint32 si_gpioout(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+{
+	uint regoff;
+
+	regoff = 0;
+
+	/* gpios could be shared on router platforms
+	 * ignore reservation if it's high priority (e.g., test apps)
+	 */
+	if ((priority != GPIO_HI_PRIORITY) &&
+	    (BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
+		mask = priority ? (si_gpioreservation & mask) :
+		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
+		val &= mask;
+	}
+
+	regoff = OFFSETOF(chipcregs_t, gpioout);
+	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* reserve one gpio */
+uint32 si_gpioreserve(si_t * sih, uint32 gpio_bitmask, uint8 priority)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	/* only cores on SI_BUS share GPIO's and only applcation users need to
+	 * reserve/release GPIO
+	 */
+	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
+		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
+		return 0xffffffff;
+	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask)
+		       && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return 0xffffffff;
+	}
+
+	/* already reserved */
+	if (si_gpioreservation & gpio_bitmask)
+		return 0xffffffff;
+	/* set reservation */
+	si_gpioreservation |= gpio_bitmask;
+
+	return si_gpioreservation;
+}
+
+/* release one gpio */
+/*
+ * releasing the gpio doesn't change the current value on the GPIO last write value
+ * persists till some one overwrites it
+ */
+
+uint32 si_gpiorelease(si_t * sih, uint32 gpio_bitmask, uint8 priority)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	/* only cores on SI_BUS share GPIO's and only applcation users need to
+	 * reserve/release GPIO
+	 */
+	if ((BUSTYPE(sih->bustype) != SI_BUS) || (!priority)) {
+		ASSERT((BUSTYPE(sih->bustype) == SI_BUS) && (priority));
+		return 0xffffffff;
+	}
+	/* make sure only one bit is set */
+	if ((!gpio_bitmask) || ((gpio_bitmask) & (gpio_bitmask - 1))) {
+		ASSERT((gpio_bitmask)
+		       && !((gpio_bitmask) & (gpio_bitmask - 1)));
+		return 0xffffffff;
+	}
+
+	/* already released */
+	if (!(si_gpioreservation & gpio_bitmask))
+		return 0xffffffff;
+
+	/* clear reservation */
+	si_gpioreservation &= ~gpio_bitmask;
+
+	return si_gpioreservation;
+}
+
+/* return the current gpioin register value */
+uint32 si_gpioin(si_t * sih)
+{
+	si_info_t *sii;
+	uint regoff;
+
+	sii = SI_INFO(sih);
+	regoff = 0;
+
+	regoff = OFFSETOF(chipcregs_t, gpioin);
+	return (si_corereg(sih, SI_CC_IDX, regoff, 0, 0));
+}
+
+/* mask&set gpio interrupt polarity bits */
+uint32 si_gpiointpolarity(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+{
+	si_info_t *sii;
+	uint regoff;
+
+	sii = SI_INFO(sih);
+	regoff = 0;
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
+		mask = priority ? (si_gpioreservation & mask) :
+		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
+		val &= mask;
+	}
+
+	regoff = OFFSETOF(chipcregs_t, gpiointpolarity);
+	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* mask&set gpio interrupt mask bits */
+uint32 si_gpiointmask(si_t * sih, uint32 mask, uint32 val, uint8 priority)
+{
+	si_info_t *sii;
+	uint regoff;
+
+	sii = SI_INFO(sih);
+	regoff = 0;
+
+	/* gpios could be shared on router platforms */
+	if ((BUSTYPE(sih->bustype) == SI_BUS) && (val || mask)) {
+		mask = priority ? (si_gpioreservation & mask) :
+		    ((si_gpioreservation | mask) & ~(si_gpioreservation));
+		val &= mask;
+	}
+
+	regoff = OFFSETOF(chipcregs_t, gpiointmask);
+	return (si_corereg(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* assign the gpio to an led */
+uint32 si_gpioled(si_t * sih, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+	if (sih->ccrev < 16)
+		return 0xffffffff;
+
+	/* gpio led powersave reg */
+	return (si_corereg
+		(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiotimeroutmask), mask,
+		 val));
+}
+
+/* mask&set gpio timer val */
+uint32 si_gpiotimerval(si_t * sih, uint32 mask, uint32 gpiotimerval)
+{
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	if (sih->ccrev < 16)
+		return 0xffffffff;
+
+	return (si_corereg(sih, SI_CC_IDX,
+			   OFFSETOF(chipcregs_t, gpiotimerval), mask,
+			   gpiotimerval));
+}
+
+uint32 si_gpiopull(si_t * sih, bool updown, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+	uint offs;
+
+	sii = SI_INFO(sih);
+	if (sih->ccrev < 20)
+		return 0xffffffff;
+
+	offs =
+	    (updown ? OFFSETOF(chipcregs_t, gpiopulldown) :
+	     OFFSETOF(chipcregs_t, gpiopullup));
+	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
+}
+
+uint32 si_gpioevent(si_t * sih, uint regtype, uint32 mask, uint32 val)
+{
+	si_info_t *sii;
+	uint offs;
+
+	sii = SI_INFO(sih);
+	if (sih->ccrev < 11)
+		return 0xffffffff;
+
+	if (regtype == GPIO_REGEVT)
+		offs = OFFSETOF(chipcregs_t, gpioevent);
+	else if (regtype == GPIO_REGEVT_INTMSK)
+		offs = OFFSETOF(chipcregs_t, gpioeventintmask);
+	else if (regtype == GPIO_REGEVT_INTPOL)
+		offs = OFFSETOF(chipcregs_t, gpioeventintpolarity);
+	else
+		return 0xffffffff;
+
+	return (si_corereg(sih, SI_CC_IDX, offs, mask, val));
+}
+
+void *BCMATTACHFN(si_gpio_handler_register) (si_t * sih, uint32 event,
+					     bool level, gpio_handler_t cb,
+					     void *arg) {
+	si_info_t *sii;
+	gpioh_item_t *gi;
+
+	ASSERT(event);
+	ASSERT(cb != NULL);
+
+	sii = SI_INFO(sih);
+	if (sih->ccrev < 11)
+		return NULL;
+
+	if ((gi = MALLOC(sii->osh, sizeof(gpioh_item_t))) == NULL)
+		return NULL;
+
+	bzero(gi, sizeof(gpioh_item_t));
+	gi->event = event;
+	gi->handler = cb;
+	gi->arg = arg;
+	gi->level = level;
+
+	gi->next = sii->gpioh_head;
+	sii->gpioh_head = gi;
+
+	return (void *)(gi);
+}
+
+void BCMATTACHFN(si_gpio_handler_unregister) (si_t * sih, void *gpioh) {
+	si_info_t *sii;
+	gpioh_item_t *p, *n;
+
+	sii = SI_INFO(sih);
+	if (sih->ccrev < 11)
+		return;
+
+	ASSERT(sii->gpioh_head != NULL);
+	if ((void *)sii->gpioh_head == gpioh) {
+		sii->gpioh_head = sii->gpioh_head->next;
+		MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
+		return;
+	} else {
+		p = sii->gpioh_head;
+		n = p->next;
+		while (n) {
+			if ((void *)n == gpioh) {
+				p->next = n->next;
+				MFREE(sii->osh, gpioh, sizeof(gpioh_item_t));
+				return;
+			}
+			p = n;
+			n = n->next;
+		}
+	}
+
+	ASSERT(0);		/* Not found in list */
+}
+
+void si_gpio_handler_process(si_t * sih)
+{
+	si_info_t *sii;
+	gpioh_item_t *h;
+	uint32 status;
+	uint32 level = si_gpioin(sih);
+	uint32 edge = si_gpioevent(sih, GPIO_REGEVT, 0, 0);
+
+	sii = SI_INFO(sih);
+	for (h = sii->gpioh_head; h != NULL; h = h->next) {
+		if (h->handler) {
+			status = (h->level ? level : edge);
+
+			if (status & h->event)
+				h->handler(status, h->arg);
+		}
+	}
+
+	si_gpioevent(sih, GPIO_REGEVT, edge, edge);	/* clear edge-trigger status */
+}
+
+uint32 si_gpio_int_enable(si_t * sih, bool enable)
+{
+	si_info_t *sii;
+	uint offs;
+
+	sii = SI_INFO(sih);
+	if (sih->ccrev < 11)
+		return 0xffffffff;
+
+	offs = OFFSETOF(chipcregs_t, intmask);
+	return (si_corereg
+		(sih, SI_CC_IDX, offs, CI_GPIO, (enable ? CI_GPIO : 0)));
+}
+
+/* Return the size of the specified SOCRAM bank */
+static uint
+socram_banksize(si_info_t * sii, sbsocramregs_t * regs, uint8 index,
+		uint8 mem_type)
+{
+	uint banksize, bankinfo;
+	uint bankidx = index | (mem_type << SOCRAM_BANKIDX_MEMTYPE_SHIFT);
+
+	ASSERT(mem_type <= SOCRAM_MEMTYPE_DEVRAM);
+
+	W_REG(sii->osh, &regs->bankidx, bankidx);
+	bankinfo = R_REG(sii->osh, &regs->bankinfo);
+	banksize =
+	    SOCRAM_BANKINFO_SZBASE * ((bankinfo & SOCRAM_BANKINFO_SZMASK) + 1);
+	return banksize;
+}
+
+void si_socdevram(si_t * sih, bool set, uint8 * enable, uint8 * protect)
+{
+	si_info_t *sii;
+	uint origidx;
+	uint intr_val = 0;
+	sbsocramregs_t *regs;
+	bool wasup;
+	uint corerev;
+
+	sii = SI_INFO(sih);
+
+	/* Block ints and save current core */
+	INTR_OFF(sii, intr_val);
+	origidx = si_coreidx(sih);
+
+	if (!set)
+		*enable = *protect = 0;
+
+	/* Switch to SOCRAM core */
+	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
+		goto done;
+
+	/* Get info for determining size */
+	if (!(wasup = si_iscoreup(sih)))
+		si_core_reset(sih, 0, 0);
+
+	corerev = si_corerev(sih);
+	if (corerev >= 10) {
+		uint32 extcinfo;
+		uint8 nb;
+		uint8 i;
+		uint32 bankidx, bankinfo;
+
+		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
+		nb = ((extcinfo & SOCRAM_DEVRAMBANK_MASK) >>
+		      SOCRAM_DEVRAMBANK_SHIFT);
+		for (i = 0; i < nb; i++) {
+			bankidx =
+			    i | (SOCRAM_MEMTYPE_DEVRAM <<
+				 SOCRAM_BANKIDX_MEMTYPE_SHIFT);
+			W_REG(sii->osh, &regs->bankidx, bankidx);
+			bankinfo = R_REG(sii->osh, &regs->bankinfo);
+			if (set) {
+				bankinfo &= ~SOCRAM_BANKINFO_DEVRAMSEL_MASK;
+				bankinfo &= ~SOCRAM_BANKINFO_DEVRAMPRO_MASK;
+				if (*enable) {
+					bankinfo |=
+					    (1 <<
+					     SOCRAM_BANKINFO_DEVRAMSEL_SHIFT);
+					if (*protect)
+						bankinfo |=
+						    (1 <<
+						     SOCRAM_BANKINFO_DEVRAMPRO_SHIFT);
+				}
+				W_REG(sii->osh, &regs->bankinfo, bankinfo);
+			} else if (i == 0) {
+				if (bankinfo & SOCRAM_BANKINFO_DEVRAMSEL_MASK) {
+					*enable = 1;
+					if (bankinfo &
+					    SOCRAM_BANKINFO_DEVRAMPRO_MASK)
+						*protect = 1;
+				}
+			}
+		}
+	}
+
+	/* Return to previous state and core */
+	if (!wasup)
+		si_core_disable(sih, 0);
+	si_setcoreidx(sih, origidx);
+
+ done:
+	INTR_RESTORE(sii, intr_val);
+}
+
+bool si_socdevram_pkg(si_t * sih)
+{
+	if (si_socdevram_size(sih) > 0)
+		return TRUE;
+	else
+		return FALSE;
+}
+
+uint32 si_socdevram_size(si_t * sih)
+{
+	si_info_t *sii;
+	uint origidx;
+	uint intr_val = 0;
+	uint32 memsize = 0;
+	sbsocramregs_t *regs;
+	bool wasup;
+	uint corerev;
+
+	sii = SI_INFO(sih);
+
+	/* Block ints and save current core */
+	INTR_OFF(sii, intr_val);
+	origidx = si_coreidx(sih);
+
+	/* Switch to SOCRAM core */
+	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
+		goto done;
+
+	/* Get info for determining size */
+	if (!(wasup = si_iscoreup(sih)))
+		si_core_reset(sih, 0, 0);
+
+	corerev = si_corerev(sih);
+	if (corerev >= 10) {
+		uint32 extcinfo;
+		uint8 nb;
+		uint8 i;
+
+		extcinfo = R_REG(sii->osh, &regs->extracoreinfo);
+		nb = (((extcinfo & SOCRAM_DEVRAMBANK_MASK) >>
+		       SOCRAM_DEVRAMBANK_SHIFT));
+		for (i = 0; i < nb; i++)
+			memsize +=
+			    socram_banksize(sii, regs, i,
+					    SOCRAM_MEMTYPE_DEVRAM);
+	}
+
+	/* Return to previous state and core */
+	if (!wasup)
+		si_core_disable(sih, 0);
+	si_setcoreidx(sih, origidx);
+
+ done:
+	INTR_RESTORE(sii, intr_val);
+
+	return memsize;
+}
+
+/* Return the RAM size of the SOCRAM core */
+uint32 si_socram_size(si_t * sih)
+{
+	si_info_t *sii;
+	uint origidx;
+	uint intr_val = 0;
+
+	sbsocramregs_t *regs;
+	bool wasup;
+	uint corerev;
+	uint32 coreinfo;
+	uint memsize = 0;
+
+	sii = SI_INFO(sih);
+
+	/* Block ints and save current core */
+	INTR_OFF(sii, intr_val);
+	origidx = si_coreidx(sih);
+
+	/* Switch to SOCRAM core */
+	if (!(regs = si_setcore(sih, SOCRAM_CORE_ID, 0)))
+		goto done;
+
+	/* Get info for determining size */
+	if (!(wasup = si_iscoreup(sih)))
+		si_core_reset(sih, 0, 0);
+	corerev = si_corerev(sih);
+	coreinfo = R_REG(sii->osh, &regs->coreinfo);
+
+	/* Calculate size from coreinfo based on rev */
+	if (corerev == 0)
+		memsize = 1 << (16 + (coreinfo & SRCI_MS0_MASK));
+	else if (corerev < 3) {
+		memsize = 1 << (SR_BSZ_BASE + (coreinfo & SRCI_SRBSZ_MASK));
+		memsize *= (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
+	} else if ((corerev <= 7) || (corerev == 12)) {
+		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
+		uint bsz = (coreinfo & SRCI_SRBSZ_MASK);
+		uint lss = (coreinfo & SRCI_LSS_MASK) >> SRCI_LSS_SHIFT;
+		if (lss != 0)
+			nb--;
+		memsize = nb * (1 << (bsz + SR_BSZ_BASE));
+		if (lss != 0)
+			memsize += (1 << ((lss - 1) + SR_BSZ_BASE));
+	} else {
+		uint8 i;
+		uint nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
+		for (i = 0; i < nb; i++)
+			memsize +=
+			    socram_banksize(sii, regs, i, SOCRAM_MEMTYPE_RAM);
+	}
+
+	/* Return to previous state and core */
+	if (!wasup)
+		si_core_disable(sih, 0);
+	si_setcoreidx(sih, origidx);
+
+ done:
+	INTR_RESTORE(sii, intr_val);
+
+	return memsize;
+}
+
+void si_chipcontrl_epa4331(si_t * sih, bool on)
+{
+	si_info_t *sii;
+	chipcregs_t *cc;
+	uint origidx;
+	uint32 val;
+
+	sii = SI_INFO(sih);
+	origidx = si_coreidx(sih);
+
+	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+
+	val = R_REG(sii->osh, &cc->chipcontrol);
+
+	if (on) {
+		if (sih->chippkg == 9 || sih->chippkg == 0xb) {
+			/* Ext PA Controls for 4331 12x9 Package */
+			W_REG(sii->osh, &cc->chipcontrol, val |
+			      (CCTRL4331_EXTPA_EN |
+			       CCTRL4331_EXTPA_ON_GPIO2_5));
+		} else {
+			/* Ext PA Controls for 4331 12x12 Package */
+			W_REG(sii->osh, &cc->chipcontrol,
+			      val | (CCTRL4331_EXTPA_EN));
+		}
+	} else {
+		val &= ~(CCTRL4331_EXTPA_EN | CCTRL4331_EXTPA_ON_GPIO2_5);
+		W_REG(sii->osh, &cc->chipcontrol, val);
+	}
+
+	si_setcoreidx(sih, origidx);
+}
+
+/* Enable BT-COEX & Ex-PA for 4313 */
+void si_epa_4313war(si_t * sih)
+{
+	si_info_t *sii;
+	chipcregs_t *cc;
+	uint origidx;
+
+	sii = SI_INFO(sih);
+	origidx = si_coreidx(sih);
+
+	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+
+	/* EPA Fix */
+	W_REG(sii->osh, &cc->gpiocontrol,
+	      R_REG(sii->osh, &cc->gpiocontrol) | GPIO_CTRL_EPA_EN_MASK);
+
+	si_setcoreidx(sih, origidx);
+}
+
+/* check if the device is removed */
+bool si_deviceremoved(si_t * sih)
+{
+	uint32 w;
+	si_info_t *sii;
+
+	sii = SI_INFO(sih);
+
+	switch (BUSTYPE(sih->bustype)) {
+	case PCI_BUS:
+		ASSERT(sii->osh != NULL);
+		w = OSL_PCI_READ_CONFIG(sii->osh, PCI_CFG_VID, sizeof(uint32));
+		if ((w & 0xFFFF) != VENDOR_BROADCOM)
+			return TRUE;
+		break;
+	}
+	return FALSE;
+}
+
+bool si_is_sprom_available(si_t * sih)
+{
+	if (sih->ccrev >= 31) {
+		si_info_t *sii;
+		uint origidx;
+		chipcregs_t *cc;
+		uint32 sromctrl;
+
+		if ((sih->cccaps & CC_CAP_SROM) == 0)
+			return FALSE;
+
+		sii = SI_INFO(sih);
+		origidx = sii->curidx;
+		cc = si_setcoreidx(sih, SI_CC_IDX);
+		sromctrl = R_REG(sii->osh, &cc->sromcontrol);
+		si_setcoreidx(sih, origidx);
+		return (sromctrl & SRC_PRESENT);
+	}
+
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		return (sih->chipst & CST4329_SPROM_SEL) != 0;
+	case BCM4319_CHIP_ID:
+		return (sih->chipst & CST4319_SPROM_SEL) != 0;
+	case BCM4336_CHIP_ID:
+		return (sih->chipst & CST4336_SPROM_PRESENT) != 0;
+	case BCM4330_CHIP_ID:
+		return (sih->chipst & CST4330_SPROM_PRESENT) != 0;
+	case BCM4313_CHIP_ID:
+		return (sih->chipst & CST4313_SPROM_PRESENT) != 0;
+	case BCM4331_CHIP_ID:
+		return (sih->chipst & CST4331_SPROM_PRESENT) != 0;
+	default:
+		return TRUE;
+	}
+}
+
+bool si_is_otp_disabled(si_t * sih)
+{
+	switch (CHIPID(sih->chip)) {
+	case BCM4329_CHIP_ID:
+		return (sih->chipst & CST4329_SPROM_OTP_SEL_MASK) ==
+		    CST4329_OTP_PWRDN;
+	case BCM4319_CHIP_ID:
+		return (sih->chipst & CST4319_SPROM_OTP_SEL_MASK) ==
+		    CST4319_OTP_PWRDN;
+	case BCM4336_CHIP_ID:
+		return ((sih->chipst & CST4336_OTP_PRESENT) == 0);
+	case BCM4330_CHIP_ID:
+		return ((sih->chipst & CST4330_OTP_PRESENT) == 0);
+	case BCM4313_CHIP_ID:
+		return (sih->chipst & CST4313_OTP_PRESENT) == 0;
+		/* These chips always have their OTP on */
+	case BCM43224_CHIP_ID:
+	case BCM43225_CHIP_ID:
+	case BCM43421_CHIP_ID:
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:
+	case BCM4331_CHIP_ID:
+	default:
+		return FALSE;
+	}
+}
+
+bool si_is_otp_powered(si_t * sih)
+{
+	if (PMUCTL_ENAB(sih))
+		return si_pmu_is_otp_powered(sih, si_osh(sih));
+	return TRUE;
+}
+
+void si_otp_power(si_t * sih, bool on)
+{
+	if (PMUCTL_ENAB(sih))
+		si_pmu_otp_power(sih, si_osh(sih), on);
+	OSL_DELAY(1000);
+}
+
+bool
+#if defined(BCMDBG)
+si_is_sprom_enabled(si_t * sih)
+#else
+BCMATTACHFN(si_is_sprom_enabled) (si_t * sih)
+#endif
+{
+
+	return TRUE;
+}
+
+void
+#if defined(BCMDBG)
+si_sprom_enable(si_t * sih, bool enable)
+#else
+BCMATTACHFN(si_sprom_enable) (si_t * sih, bool enable)
+#endif
+{
+	if (PMUCTL_ENAB(sih))
+		si_pmu_sprom_enable(sih, si_osh(sih), enable);
+}
+
+/* Return BCME_NOTFOUND if the card doesn't have CIS format nvram */
+int si_cis_source(si_t * sih)
+{
+	/* Many chips have the same mapping of their chipstatus field */
+	static const uint cis_sel[] =
+	    { CIS_DEFAULT, CIS_SROM, CIS_OTP, CIS_SROM };
+	static const uint cis_43236_sel[] =
+	    { CIS_DEFAULT, CIS_SROM, CIS_OTP, CIS_OTP };
+
+	/* PCI chips use SROM format instead of CIS */
+	if (BUSTYPE(sih->bustype) == PCI_BUS)
+		return BCME_NOTFOUND;
+
+	switch (CHIPID(sih->chip)) {
+	case BCM43235_CHIP_ID:
+	case BCM43236_CHIP_ID:
+	case BCM43238_CHIP_ID:{
+			uint8 strap =
+			    (sih->
+			     chipst & CST4322_SPROM_OTP_SEL_MASK) >>
+			    CST4322_SPROM_OTP_SEL_SHIFT;
+			return ((strap >=
+				 sizeof(cis_sel)) ? CIS_DEFAULT :
+				cis_43236_sel[strap]);
+		}
+
+	case BCM4329_CHIP_ID:
+		return ((sih->chipst & CST4329_SPROM_OTP_SEL_MASK) >=
+			sizeof(cis_sel)) ? CIS_DEFAULT : cis_sel[(sih->
+								  chipst &
+								  CST4329_SPROM_OTP_SEL_MASK)];
+	case BCM4319_CHIP_ID:{
+			uint cis_sel4319 =
+			    ((sih->
+			      chipst & CST4319_SPROM_OTP_SEL_MASK) >>
+			     CST4319_SPROM_OTP_SEL_SHIFT);
+			return (cis_sel4319 >=
+				sizeof(cis_sel)) ? CIS_DEFAULT :
+			    cis_sel[cis_sel4319];
+		}
+	case BCM4336_CHIP_ID:{
+			if (sih->chipst & CST4336_SPROM_PRESENT)
+				return CIS_SROM;
+			if (sih->chipst & CST4336_OTP_PRESENT)
+				return CIS_OTP;
+			return CIS_DEFAULT;
+		}
+	case BCM4330_CHIP_ID:{
+			if (sih->chipst & CST4330_SPROM_PRESENT)
+				return CIS_SROM;
+			if (sih->chipst & CST4330_OTP_PRESENT)
+				return CIS_OTP;
+			return CIS_DEFAULT;
+		}
+	default:
+		return CIS_DEFAULT;
+	}
+}
diff --git a/drivers/staging/brcm80211/util/siutils_priv.h b/drivers/staging/brcm80211/util/siutils_priv.h
new file mode 100644
index 0000000..b0c7803
--- /dev/null
+++ b/drivers/staging/brcm80211/util/siutils_priv.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_siutils_priv_h_
+#define	_siutils_priv_h_
+
+/* Silicon Backplane externs */
+extern void sb_scan(si_t * sih, void *regs, uint devid);
+uint sb_coreid(si_t * sih);
+uint sb_corerev(si_t * sih);
+extern uint sb_corereg(si_t * sih, uint coreidx, uint regoff, uint mask,
+		       uint val);
+extern bool sb_iscoreup(si_t * sih);
+void *sb_setcoreidx(si_t * sih, uint coreidx);
+extern uint32 sb_base(uint32 admatch);
+extern void sb_core_reset(si_t * sih, uint32 bits, uint32 resetbits);
+extern void sb_core_disable(si_t * sih, uint32 bits);
+extern bool sb_taclear(si_t * sih, bool details);
+#endif				/* _siutils_priv_h_ */
-- 
1.7.1

