--- a/arch/arm/mach-orion/Kconfig
+++ b/arch/arm/mach-orion/Kconfig
@@ -36,6 +36,12 @@ config MACH_TS209
 	  Say 'Y' here if you want your kernel to support the
 	  QNAP TS-109/TS-209 platform.
 
+config MACH_TS409
+	bool "QNAP TS-409"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  QNAP TS-409 platform.
+
 endmenu
 
 endif
diff --git a/arch/arm/mach-orion/Makefile b/arch/arm/mach-orion/Makefile
index f91d937..07e8886 100644
--- a/arch/arm/mach-orion/Makefile~	2008-04-20 14:19:27.000000000 +0000
+++ b/arch/arm/mach-orion/Makefile	2008-04-20 14:19:43.000000000 +0000
@@ -5,3 +5,4 @@
 obj-$(CONFIG_MACH_LINKSTATION_PRO) += kurobox_pro-setup.o
 obj-$(CONFIG_MACH_DNS323)	+= dns323-setup.o
 obj-$(CONFIG_MACH_TS209)	+= ts209-setup.o
+obj-$(CONFIG_MACH_TS409)	+= ts409-setup.o
--- /dev/null	2007-09-25 12:43:17.000000000 +0000
+++ b/arch/arm/mach-orion/ts409-setup.c	2008-04-20 12:10:02.000000000 +0000
@@ -0,0 +1,399 @@
+/*
+ * QNAP TS-409 Board Setup
+ *
+ * Maintainer: Sylver Bruneau <sylver.bruneau@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/nand.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/serial_reg.h>
+#include <linux/ata_platform.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/orion.h>
+#include <asm/arch/platform.h>
+#include "common.h"
+
+#define QNAP_TS409_NOR_BOOT_BASE 0xff800000
+/*#define QNAP_TS409_NOR_BOOT_BASE 0xf4000000*/
+#define QNAP_TS409_NOR_BOOT_SIZE SZ_8M
+
+/****************************************************************************
+ * 8MiB NOR flash. The struct mtd_partition is not in the same order as the
+ *     partitions on the device because we want to keep compatability with
+ *     existing QNAP firmware.
+ *
+ * Layout as used by QNAP:
+ *  [2] 0x00000000-0x00200000 : "Kernel"
+ *  [3] 0x00200000-0x00600000 : "RootFS1"
+ *  [4] 0x00600000-0x00700000 : "RootFS2"
+ *  [6] 0x00700000-0x00760000 : "NAS Config" (read-only)
+ *  [5] 0x00760000-0x00780000 : "U-Boot Config"
+ *  [1] 0x00780000-0x00800000 : "U-Boot" (read-only)
+ ***************************************************************************/
+static struct mtd_partition qnap_ts409_partitions[] = {
+	{
+		.name       = "U-Boot",
+		.size       = 0x00080000,
+		.offset     = 0x00780000,
+		.mask_flags = MTD_WRITEABLE,
+	}, {
+		.name   = "Kernel",
+		.size   = 0x00200000,
+		.offset = 0,
+	}, {
+		.name   = "RootFS1",
+		.size   = 0x00400000,
+		.offset = 0x00200000,
+	}, {
+		.name   = "RootFS2",
+		.size   = 0x00100000,
+		.offset = 0x00600000,
+	}, {
+		.name   = "U-Boot Config",
+		.size   = 0x00020000,
+		.offset = 0x00760000,
+	}, {
+		.name       = "NAS Config",
+		.size       = 0x00060000,
+		.offset     = 0x00700000,
+		.mask_flags = MTD_WRITEABLE,
+	}
+};
+
+static struct physmap_flash_data qnap_ts409_nor_flash_data = {
+	.width    = 1,
+	.parts    = qnap_ts409_partitions,
+	.nr_parts = ARRAY_SIZE(qnap_ts409_partitions)
+};
+
+static struct resource qnap_ts409_nor_flash_resource = {
+	.flags = IORESOURCE_MEM,
+	.start = QNAP_TS409_NOR_BOOT_BASE,
+	.end   = QNAP_TS409_NOR_BOOT_BASE + QNAP_TS409_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device qnap_ts409_nor_flash = {
+	.name          = "physmap-flash",
+	.id            = 0,
+	.dev           = { .platform_data = &qnap_ts409_nor_flash_data, },
+	.resource      = &qnap_ts409_nor_flash_resource,
+	.num_resources = 1,
+};
+
+/*****************************************************************************
+ * PCI
+ ****************************************************************************/
+#define QNAP_TS409_PCI_SLOT0_OFFS		7
+#define QNAP_TS409_PCI_SLOT0_IRQ_PIN		12
+#define QNAP_TS409_PCI_SLOT1_SLOT2_IRQ_PIN	13
+
+void __init qnap_ts409_pci_preinit(void)
+{
+	int pin;
+
+	/*
+	 * Configure PCI GPIO IRQ pins
+	 */
+	pin = QNAP_TS409_PCI_SLOT0_IRQ_PIN;
+	if (gpio_request(pin, "PCI Int1") == 0) {
+		if (gpio_direction_input(pin) == 0) {
+			set_irq_type(gpio_to_irq(pin), IRQT_LOW);
+		} else {
+			printk(KERN_ERR "qnap_ts409_pci_preinit failed to "
+					"set_irq_type pin %d\n", pin);
+			gpio_free(pin);
+		}
+	} else {
+		printk(KERN_ERR "qnap_ts409_pci_preinit failed to gpio_request "
+				"%d\n", pin);
+	}
+
+	pin = QNAP_TS409_PCI_SLOT1_SLOT2_IRQ_PIN;
+	if (gpio_request(pin, "PCI Int2") == 0) {
+		if (gpio_direction_input(pin) == 0) {
+			set_irq_type(gpio_to_irq(pin), IRQT_LOW);
+		} else {
+			printk(KERN_ERR "qnap_ts409_pci_preinit failed "
+					"to set_irq_type pin %d\n", pin);
+			gpio_free(pin);
+		}
+	} else {
+		printk(KERN_ERR "qnap_ts409_pci_preinit failed to gpio_request "
+				"%d\n", pin);
+	}
+}
+
+static int __init qnap_ts409_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	/*
+	 * PCIE IRQ is connected internally (not GPIO)
+	 */
+	if (dev->bus->number == orion_pcie_local_bus_nr())
+		return IRQ_ORION_PCIE0_INT;
+
+	/*
+	 * PCI IRQs are connected via GPIOs
+	 */
+	switch (slot - QNAP_TS409_PCI_SLOT0_OFFS) {
+	case 0:
+		return gpio_to_irq(QNAP_TS409_PCI_SLOT0_IRQ_PIN);
+	case 1:
+	case 2:
+		return gpio_to_irq(QNAP_TS409_PCI_SLOT1_SLOT2_IRQ_PIN);
+	default:
+		return -1;
+	}
+}
+
+static struct hw_pci qnap_ts409_pci __initdata = {
+	.nr_controllers = 2,
+	.preinit        = qnap_ts409_pci_preinit,
+	.swizzle        = pci_std_swizzle,
+	.setup          = orion_pci_sys_setup,
+	.scan           = orion_pci_sys_scan_bus,
+	.map_irq        = qnap_ts409_pci_map_irq,
+};
+
+static int __init qnap_ts409_pci_init(void)
+{
+	if (machine_is_ts409())
+		pci_common_init(&qnap_ts409_pci);
+
+	return 0;
+}
+
+subsys_initcall(qnap_ts409_pci_init);
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+
+static struct mv643xx_eth_platform_data qnap_ts409_eth_data = {
+	.phy_addr       = 8,
+	.force_phy_addr = 1,
+};
+
+static int __init parse_hex_nibble(char n)
+{
+	if (n >= '0' && n <= '9')
+		return n - '0';
+
+	if (n >= 'A' && n <= 'F')
+		return n - 'A' + 10;
+
+	if (n >= 'a' && n <= 'f')
+		return n - 'a' + 10;
+
+	return -1;
+}
+
+static int __init parse_hex_byte(const char *b)
+{
+	int hi;
+	int lo;
+
+	hi = parse_hex_nibble(b[0]);
+	lo = parse_hex_nibble(b[1]);
+
+	if (hi < 0 || lo < 0)
+		return -1;
+
+	return (hi << 4) | lo;
+}
+
+static int __init check_mac_addr(const char *addr_str)
+{
+	u_int8_t addr[6];
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int byte;
+
+		/*
+		 * Enforce "xx:xx:xx:xx:xx:xx\n" format.
+		 */
+		if (addr_str[(i * 3) + 2] != ((i < 5) ? ':' : '\n'))
+			return -1;
+
+		byte = parse_hex_byte(addr_str + (i * 3));
+		if (byte < 0)
+			return -1;
+		addr[i] = byte;
+	}
+
+	printk(KERN_INFO "ts409: found ethernet mac address ");
+	for (i = 0; i < 6; i++)
+		printk("%.2x%s", addr[i], (i < 5) ? ":" : ".\n");
+
+	memcpy(qnap_ts409_eth_data.mac_addr, addr, 6);
+
+	return 0;
+}
+
+/*
+ * The 'NAS Config' flash partition has an ext2 filesystem which
+ * contains a file that has the ethernet MAC address in plain text
+ * (format "xx:xx:xx:xx:xx:xx\n".)
+ */
+static void __init ts409_find_mac_addr(void)
+{
+	unsigned long addr;
+
+	for (addr = 0x00700000; addr < 0x00760000; addr += 1024) {
+		char *nor_page;
+		int ret = 0;
+
+		nor_page = ioremap(QNAP_TS409_NOR_BOOT_BASE + addr, 1024);
+		if (nor_page != NULL) {
+			ret = check_mac_addr(nor_page);
+			iounmap(nor_page);
+		}
+
+		if (ret == 0)
+			break;
+	}
+}
+
+/*****************************************************************************
+ * RTC S35390A on I2C bus
+ ****************************************************************************/
+
+#define TS409_RTC_GPIO	10
+
+static struct i2c_board_info __initdata qnap_ts409_i2c_rtc = {
+       .driver_name = "rtc-s35390a",
+       .addr        = 0x30,
+       .irq         = 0,
+};
+
+/*****************************************************************************
+ * General Setup
+ ****************************************************************************/
+
+static struct platform_device *qnap_ts409_devices[] __initdata = {
+	&qnap_ts409_nor_flash,
+};
+
+/*
+ * QNAP TS-409 specific power off method via UART1-attached PIC
+ */
+
+#define UART1_REG(x)  (UART1_VIRT_BASE + ((UART_##x) << 2))
+
+static void qnap_ts409_power_off(void)
+{
+	/* 19200 baud divisor */
+	const unsigned divisor = ((ORION_TCLK + (8 * 19200)) / (16 * 19200));
+
+	pr_info("%s: triggering power-off...\n", __func__);
+
+	/* hijack uart1 and reset into sane state (19200,8n1) */
+	orion_write(UART1_REG(LCR), 0x83);
+	orion_write(UART1_REG(DLL), divisor & 0xff);
+	orion_write(UART1_REG(DLM), (divisor >> 8) & 0xff);
+	orion_write(UART1_REG(LCR), 0x03);
+	orion_write(UART1_REG(IER), 0x00);
+	orion_write(UART1_REG(FCR), 0x00);
+	orion_write(UART1_REG(MCR), 0x00);
+
+	/* send the power-off command 'A' to PIC */
+	orion_write(UART1_REG(TX), 'A');
+}
+
+static void __init qnap_ts409_init(void)
+{
+	/*
+	 * Setup basic Orion functions. Need to be called early.
+	 */
+	orion_init();
+
+	/*
+	 * Setup flash mapping
+	 */
+	orion_setup_cpu_win(ORION_DEV_BOOT, QNAP_TS409_NOR_BOOT_BASE,
+			    QNAP_TS409_NOR_BOOT_SIZE, -1);
+
+	/*
+	 * Open a special address decode windows for the PCIE WA.
+	 */
+	orion_write(ORION_REGS_VIRT_BASE | 0x20074, ORION_PCIE_WA_PHYS_BASE);
+	orion_write(ORION_REGS_VIRT_BASE | 0x20070, (0x7941 |
+		(((ORION_PCIE_WA_SIZE >> 16) - 1)) << 16));
+
+	/*
+	 * Setup Multiplexing Pins --
+	 * MPP[0] GPIO ???
+	 * MPP[1] GPIO ???
+	 * MPP[2] ???
+	 * MPP[3] ???
+	 * MPP[4] GPIO ???
+	 * MPP[5] GPIO ???
+	 * MPP[6] GPIO ???
+	 * MPP[7] GPIO ???
+	 * MPP[8] ???
+	 * MPP[9] ???
+	 * MPP[10] GPIO RTC int
+	 * MPP[11] GPIO ???
+	 * MPP[12] GPIO PCI int 1
+	 * MPP[13] GPIO PCI int 2
+	 * MPP[14] GPIO ???
+	 * MPP[15] GPIO ???
+	 * MPP[16] ???
+	 * MPP[17] ???
+	 * MPP[18] ???
+	 * MPP[19] ???
+	 */
+	orion_write(MPP_0_7_CTRL, 0x00002203);
+	orion_write(MPP_8_15_CTRL, 0x00000033);
+	orion_write(MPP_16_19_CTRL, 0x0);
+	orion_gpio_set_valid_pins(0xfffcf3);
+
+	/* register ts409 specific power-off method */
+	pm_power_off = qnap_ts409_power_off;
+
+	platform_add_devices(qnap_ts409_devices,
+				ARRAY_SIZE(qnap_ts409_devices));
+
+	/* Get RTC IRQ and register the chip */
+	if (gpio_request(TS409_RTC_GPIO, "rtc") == 0) {
+		if (gpio_direction_input(TS409_RTC_GPIO) == 0)
+			qnap_ts409_i2c_rtc.irq = gpio_to_irq(TS409_RTC_GPIO);
+		else
+			gpio_free(TS409_RTC_GPIO);
+	}
+	if (qnap_ts409_i2c_rtc.irq == 0)
+		pr_warning("qnap_ts409_init: failed to get RTC IRQ\n");
+	i2c_register_board_info(0, &qnap_ts409_i2c_rtc, 1);
+
+	ts409_find_mac_addr();
+	orion_eth_init(&qnap_ts409_eth_data);
+}
+
+MACHINE_START(TS409, "QNAP TS-409")
+	/* Maintainer:  Sylver Bruneau <sylver.bruneau@gmail.com> */
+	.phys_io	= ORION_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= qnap_ts409_init,
+	.map_io		= orion_map_io,
+	.init_irq	= orion_init_irq,
+	.timer		= &orion_timer,
+	.fixup		= tag_fixup_mem32,
+MACHINE_END
