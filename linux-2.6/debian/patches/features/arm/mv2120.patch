--- a/arch/arm/mach-orion/Kconfig~	2008-04-20 14:09:56.000000000 +0000
+++ b/arch/arm/mach-orion/Kconfig	2008-04-20 14:11:39.000000000 +0000
@@ -50,6 +50,12 @@
 	  Say 'Y' here if you want your kernel to support the
 	  QNAP TS-409 platform.
 
+config MACH_MV2120
+	bool "HP Media Vault mv2120"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  HP Media Vault mv2120 or mv5100.
+
 endmenu
 
 endif
--- a/arch/arm/mach-orion/Makefile~	2008-04-20 14:10:07.000000000 +0000
+++ b/arch/arm/mach-orion/Makefile	2008-04-20 14:12:25.000000000 +0000
@@ -6,3 +6,4 @@
 obj-$(CONFIG_MACH_DNS323)	+= dns323-setup.o
 obj-$(CONFIG_MACH_TS209)	+= ts209-setup.o
 obj-$(CONFIG_MACH_TS409)	+= ts409-setup.o
+obj-$(CONFIG_MACH_MV2120)	+= mv2120-setup.o
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1611,3 +1611,4 @@ kb9263			MACH_KB9263		KB9263			1612
 mt7108			MACH_MT7108		MT7108			1613
 smtr2440		MACH_SMTR2440		SMTR2440		1614
 manao			MACH_MANAO		MANAO			1615
+mv2120			MACH_MV2120		MV2120			1693
--- /dev/null	2007-09-25 12:43:17.000000000 +0000
+++ b/arch/arm/mach-orion/mv2120-setup.c	2008-04-20 14:08:20.000000000 +0000
@@ -0,0 +1,215 @@
+/*
+ *
+ * Copyright (C) 2007 Herbert Valerio Riedel <hvr@gnu.org>
+ * Copyright (C) 2008 Martin Michlmayr <tbm@cyrius.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/leds.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/ata_platform.h>
+#include <asm/mach-types.h>
+#include <asm/gpio.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/pci.h>
+#include <asm/arch/orion.h>
+#include <asm/arch/platform.h>
+#include "common.h"
+
+#define MV2120_GPIO_KEY_RESET		17
+#define MV2120_GPIO_KEY_POWER		18
+#define MV2120_GPIO_POWER_OFF		19
+
+/****************************************************************************
+ * PCI setup
+ */
+
+static int __init mv2120_pci_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	/* PCI-E */
+	if (dev->bus->number == orion_pcie_local_bus_nr())
+		return IRQ_ORION_PCIE0_INT;
+
+	pr_err("%s: requested mapping for unknown bus\n", __func__);
+
+	return -1;
+}
+
+static struct hw_pci mv2120_pci __initdata = {
+	.nr_controllers = 1,
+	.swizzle	= pci_std_swizzle,
+	.setup		= orion_pci_sys_setup,
+	.scan		= orion_pci_sys_scan_bus,
+	.map_irq	= mv2120_pci_map_irq,
+};
+
+static int __init mv2120_pci_init(void)
+{
+	if (machine_is_mv2120())
+		pci_common_init(&mv2120_pci);
+
+	return 0;
+}
+
+subsys_initcall(mv2120_pci_init);
+
+static struct mv643xx_eth_platform_data mv2120_eth_data = {
+	.phy_addr = 8,
+	.force_phy_addr = 1,
+};
+
+static struct mv_sata_platform_data mv2120_sata_data = {
+	.n_ports        = 2,
+};
+
+#define MV2120_NOR_BOOT_BASE 0xf4000000
+#define MV2120_NOR_BOOT_SIZE SZ_512K
+
+static struct mtd_partition mv2120_partitions[] = {
+	{
+		.name	= "firmware",
+		.size	= 0x00080000,
+		.offset	= 0,
+	}
+};
+
+static struct physmap_flash_data mv2120_nor_flash_data = {
+	.width		= 1,
+	.parts		= mv2120_partitions,
+	.nr_parts	= ARRAY_SIZE(mv2120_partitions)
+};
+
+static struct resource mv2120_nor_flash_resource = {
+	.flags		= IORESOURCE_MEM,
+	.start		= MV2120_NOR_BOOT_BASE,
+	.end		= MV2120_NOR_BOOT_BASE + MV2120_NOR_BOOT_SIZE - 1,
+};
+
+static struct platform_device mv2120_nor_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= { .platform_data = &mv2120_nor_flash_data, },
+	.resource	= &mv2120_nor_flash_resource,
+	.num_resources	= 1,
+};
+
+
+static struct gpio_keys_button mv2120_buttons[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= MV2120_GPIO_KEY_RESET,
+		.desc		= "Reset Button",
+		.active_low	= 1,
+	},
+	{
+		.code		= KEY_POWER,
+		.gpio		= MV2120_GPIO_POWER_OFF,
+//MV2120_GPIO_KEY_POWER,
+		.desc		= "Power Button",
+		.active_low	= 1,
+	}
+};
+
+static struct gpio_keys_platform_data mv2120_button_data = {
+	.buttons	= mv2120_buttons,
+	.nbuttons       = ARRAY_SIZE(mv2120_buttons),
+};
+
+static struct platform_device mv2120_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= { .platform_data  = &mv2120_button_data, },
+};
+
+/****************************************************************************
+ * General Setup
+ */
+
+static struct platform_device *mv2120_plat_devices[] __initdata = {
+	&mv2120_nor_flash,
+	&mv2120_button_device,
+};
+
+/*
+ * 
+ */
+
+#define MV2120_RTC_GPIO	3
+
+static struct i2c_board_info __initdata mv2120_i2c_rtc = {
+	I2C_BOARD_INFO("rtc-pcf8563", 0x51),
+	.irq = 0,
+};
+
+static void mv2120_power_off(void)
+{
+	pr_info("%s: triggering power-off...\n", __func__);
+	gpio_set_value(MV2120_GPIO_POWER_OFF, 1);
+}
+
+static void __init mv2120_init(void)
+{
+	/* Setup basic Orion functions. Need to be called early. */
+	orion_init();
+
+	/* setup flash mapping */
+	orion_setup_cpu_win(ORION_DEV_BOOT, MV2120_NOR_BOOT_BASE,
+			    MV2120_NOR_BOOT_SIZE, -1);
+
+	/* * Open a special address decode windows for the PCIE WA. */
+	orion_write(ORION_REGS_VIRT_BASE | 0x20074, ORION_PCIE_WA_PHYS_BASE);
+	orion_write(ORION_REGS_VIRT_BASE | 0x20070,
+		    (0x7941 | (((ORION_PCIE_WA_SIZE >> 16) - 1)) << 16));
+
+	orion_write(MPP_0_7_CTRL, 0x00000003);
+	orion_write(MPP_8_15_CTRL, 0x0);
+	orion_write(MPP_16_19_CTRL, 0x00005555);
+
+	/* register mv2120 specific power-off method */
+	if ((gpio_request(MV2120_GPIO_POWER_OFF, "POWEROFF") != 0)
+	    || (gpio_direction_output(MV2120_GPIO_POWER_OFF, 0) != 0))
+		pr_err("mv2120: failed to setup power-off GPIO\n");
+
+	pm_power_off = mv2120_power_off;
+
+	/* register flash and other platform devices */
+	platform_add_devices(mv2120_plat_devices,
+			     ARRAY_SIZE(mv2120_plat_devices));
+
+	if (gpio_request(MV2120_RTC_GPIO, "rtc") == 0) {
+		if (gpio_direction_input(MV2120_RTC_GPIO) == 0)
+			mv2120_i2c_rtc.irq = gpio_to_irq(MV2120_RTC_GPIO);
+		else
+			gpio_free(MV2120_RTC_GPIO);
+	}
+	i2c_register_board_info(0, &mv2120_i2c_rtc, 1);
+
+	orion_eth_init(&mv2120_eth_data);
+	orion_sata_init(&mv2120_sata_data);
+}
+
+MACHINE_START(MV2120, "HP Media Vault mv2120")
+	.phys_io	= ORION_REGS_PHYS_BASE,
+	.io_pg_offst	= ((ORION_REGS_VIRT_BASE) >> 18) & 0xFFFC,
+	.boot_params	= 0x00000100,
+	.init_machine	= mv2120_init,
+	.map_io		= orion_map_io,
+	.init_irq	= orion_init_irq,
+	.timer		= &orion_timer,
+	.fixup		= tag_fixup_mem32
+MACHINE_END
